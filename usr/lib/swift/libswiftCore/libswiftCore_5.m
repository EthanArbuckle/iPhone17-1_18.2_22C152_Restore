_WORD *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt16(_WORD *result, _WORD *a2, _WORD *a3)
{
  _WORD *v3;
  __int16 v4;

  if (!*a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0xDE1uLL, 0);
  }
  v4 = *v3 / *a3;
  *a2 = *v3 % *a3;
  *result = v4;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance UInt16(unsigned __int16 *a1)
{
  return specialized BinaryInteger.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance UInt16(_WORD *a1@<X8>)
{
  *a1 = *v1 != 0;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt16(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v63 = a4;
  uint64_t v5 = a3;
  uint64_t v69 = a5;
  uint64_t v8 = *(void *)(*(void *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v66 = (char *)&v59 - v11;
  uint64_t v12 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  v61 = (char *)&v59 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  v68 = (char *)&v59 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  v19 = (char *)&v59 - v18;
  MEMORY[0x1F4188790](v17);
  v21 = (char *)&v59 - v20;
  v64 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 64);
  char v22 = v64(a2, v5);
  uint64_t v70 = a1;
  uint64_t v71 = v12;
  v67 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v67(v21, a1, a2);
  if ((v22 & 1) == 0)
  {
    uint64_t v60 = v8;
    v62 = v19;
    v65 = *(void (**)(char *, uint64_t))(v71 + 8);
    v65(v21, a2);
    goto LABEL_6;
  }
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v24 = v66;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v24, a2, v8);
  char v25 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v21, v19, a2);
  uint64_t v59 = v5;
  v26 = v19;
  v27 = *(void (**)(char *, uint64_t))(v71 + 8);
  v27(v26, a2);
  v27(v21, a2);
  if ((v25 & 1) == 0)
  {
    uint64_t v60 = v8;
    v62 = v26;
    v65 = v27;
    uint64_t v5 = v59;
LABEL_6:
    v32 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
    uint64_t v33 = v70;
    uint64_t v34 = v32(a2, v5);
    v35 = v68;
    v67(v68, v33, a2);
    if (v34 <= 15)
    {
      v36 = (uint64_t (*)(uint64_t, uint64_t))v65;
      v65(v35, a2);
      uint64_t v31 = v69;
LABEL_8:
      __int16 v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5);
      uint64_t result = v36(v33, a2);
      char v30 = 0;
      goto LABEL_19;
    }
    unsigned __int16 v72 = -1;
    char v37 = v64(a2, v5);
    uint64_t v38 = v32(a2, v5);
    v41 = v35;
    if (v37)
    {
      if (v38 < 17)
      {
        uint64_t v42 = v60;
        uint64_t v43 = swift_getAssociatedConformanceWitness(v60, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v44 = v66;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v43 + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, v43);
        v45 = v62;
        (*(void (**)(char *, uint64_t, uint64_t))(v42 + 24))(v44, a2, v42);
        LOBYTE(v42) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 40))(v41, v45, a2);
        uint64_t v46 = v71;
        v47 = v45;
        v48 = v41;
        v36 = (uint64_t (*)(uint64_t, uint64_t))v65;
        v65(v47, a2);
        unsigned int v49 = v72;
        v50 = v61;
        (*(void (**)(char *, char *, uint64_t))(v46 + 32))(v61, v48, a2);
        if ((v42 & 1) == 0)
        {
          v36((uint64_t)v50, a2);
          uint64_t v31 = v69;
          uint64_t v33 = v70;
          goto LABEL_8;
        }
        unsigned __int16 v51 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5);
        v36((uint64_t)v50, a2);
        BOOL v52 = v49 >= v51;
LABEL_17:
        uint64_t v31 = v69;
        uint64_t v33 = v70;
        if (v52) {
          goto LABEL_8;
        }
        goto LABEL_18;
      }
    }
    else if (v38 < 17)
    {
      v57 = v62;
      (*(void (**)(char *, char *, uint64_t))(v71 + 32))(v62, v35, a2);
      unsigned __int16 v58 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5);
      v36 = (uint64_t (*)(uint64_t, uint64_t))v65;
      v65(v57, a2);
      BOOL v52 = v72 >= v58;
      goto LABEL_17;
    }
    v53 = *(void (**)(unsigned __int16 *, uint64_t, unint64_t, uint64_t, uint64_t))(v5 + 96);
    unint64_t v54 = lazy protocol witness table accessor for type UInt16 and conformance UInt16(v38, v39, v40);
    v55 = v62;
    v53(&v72, v63, v54, a2, v5);
    char v56 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v55, v41, a2);
    v36 = (uint64_t (*)(uint64_t, uint64_t))v65;
    v65(v55, a2);
    v36((uint64_t)v41, a2);
    uint64_t v31 = v69;
    uint64_t v33 = v70;
    if ((v56 & 1) == 0) {
      goto LABEL_8;
    }
LABEL_18:
    uint64_t result = v36(v33, a2);
    __int16 v29 = 0;
    char v30 = 1;
    goto LABEL_19;
  }
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v27)(v70, a2);
  __int16 v29 = 0;
  char v30 = 1;
  uint64_t v31 = v69;
LABEL_19:
  *(_WORD *)uint64_t v31 = v29;
  *(unsigned char *)(v31 + 2) = v30;
  return result;
}

unsigned __int16 *protocol witness for static Numeric.* infix(_:_:) in conformance UInt16@<X0>(unsigned __int16 *result@<X0>, unsigned __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = *result * *a2;
  if ((v3 & 0xFFFF0000) != 0) {
    __break(1u);
  }
  else {
    *a3 = v3;
  }
  return result;
}

uint64_t static UInt16.* infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  uint64_t result = a1 * a2;
  if ((result & 0xFFFF0000) != 0) {
    __break(1u);
  }
  return result;
}

_WORD *protocol witness for static Numeric.*= infix(_:_:) in conformance UInt16(_WORD *result, unsigned __int16 *a2)
{
  int v2 = (unsigned __int16)*result * *a2;
  if ((v2 & 0xFFFF0000) != 0) {
    __break(1u);
  }
  else {
    *uint64_t result = v2;
  }
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance UInt16()
{
  return _uint64ToString(_:radix:uppercase:)(*v0, 10, 0)._countAndFlagsBits;
}

unsigned __int16 *protocol witness for Strideable.distance(to:) in conformance UInt16@<X0>(unsigned __int16 *result@<X0>, uint64_t *a2@<X8>)
{
  unsigned int v3 = *result;
  unsigned int v4 = *v2;
  uint64_t v5 = v4 - v3;
  BOOL v6 = v3 >= v4;
  uint64_t v7 = v3 - v4;
  if (!v6) {
    uint64_t v7 = -v5;
  }
  *a2 = v7;
  return result;
}

unint64_t *protocol witness for Strideable.advanced(by:) in conformance UInt16@<X0>(unint64_t *result@<X0>, _WORD *a2@<X8>)
{
  unint64_t v3 = *result;
  int v4 = *v2;
  if ((*result & 0x8000000000000000) == 0)
  {
    if (v3 >= 0x10000) {
      goto LABEL_8;
    }
    v4 += (unsigned __int16)v3;
    unint64_t v3 = (unsigned __int16)v4;
    if ((unsigned __int16)v4 == v4)
    {
LABEL_7:
      *a2 = v4;
      return result;
    }
    __break(1u);
  }
  unint64_t v5 = -(uint64_t)v3;
  if (v5 >= 0x10000) {
LABEL_8:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
  v4 -= (unsigned __int16)v5;
  if ((v4 & 0xFFFF0000) == 0) {
    goto LABEL_7;
  }
  __break(1u);
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt16(uint64_t a1, uint64_t a2, char a3, unsigned __int16 *a4, unsigned __int16 *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt16(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

unsigned __int16 *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance UInt16@<X0>(unsigned __int16 *result@<X0>, unsigned __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = *result + *a2;
  if ((v3 & 0x10000) != 0) {
    __break(1u);
  }
  else {
    *a3 = v3;
  }
  return result;
}

_WORD *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance UInt16(_WORD *result, unsigned __int16 *a2)
{
  int v2 = (unsigned __int16)*result + *a2;
  if ((v2 & 0x10000) != 0) {
    __break(1u);
  }
  else {
    *uint64_t result = v2;
  }
  return result;
}

unsigned __int16 *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance UInt16@<X0>(unsigned __int16 *result@<X0>, unsigned __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = *result - *a2;
  if ((v3 & 0xFFFF0000) != 0) {
    __break(1u);
  }
  else {
    *a3 = v3;
  }
  return result;
}

_WORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance UInt16(_WORD *result, unsigned __int16 *a2)
{
  int v2 = (unsigned __int16)*result - *a2;
  if ((v2 & 0xFFFF0000) != 0) {
    __break(1u);
  }
  else {
    *uint64_t result = v2;
  }
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance UInt16(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance UInt16(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a2 >= *a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance UInt16(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a1 >= *a2;
}

BOOL static UInt16.>= infix(_:_:)(unsigned __int16 a1, unsigned __int16 a2)
{
  return a1 >= a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance UInt16(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a2 < *a1;
}

uint64_t UInt16.hashValue.getter(unsigned __int16 a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0, a1, 2);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance UInt16()
{
  return specialized static Hasher._hash(seed:bytes:count:)(0, *v0, 2);
}

uint64_t UInt16._toCustomAnyHashable()@<X0>(__int16 a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt16>);
  *(void *)(a2 + 24) = result;
  *(void *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_WORD *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance UInt16@<X0>(uint64_t a1@<X8>)
{
  __int16 v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt16>);
  *(void *)(a1 + 24) = result;
  *(void *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_WORD *)a1 = v3;
  return result;
}

uint64_t Int16._value.setter(uint64_t result)
{
  _WORD *v1 = result;
  return result;
}

uint64_t (*Int16._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.init(_:)(float a1)
{
  if ((~LODWORD(a1) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to Int16 because it is either infinite or NaN", 79, 2, "Swift/IntegerTypes.swift", 24, 2, 0x123CuLL, 0);
  }
  if (*(short float *)&a1 <= COERCE_SHORT_FLOAT(-2047)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to Int16 because the result would be less than Int16.min", 90, 2, "Swift/IntegerTypes.swift", 24, 2, 0x123FuLL, 0);
  }
  if (*(short float *)&a1 >= COERCE_SHORT_FLOAT(30720)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to Int16 because the result would be greater than Int16.max", 93, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1242uLL, 0);
  }
  return (int)*(short float *)&a1;
}

uint64_t Int16.init(exactly:)(__n128 a1)
{
  BOOL v1 = *(short float *)a1.n128_u16 > COERCE_SHORT_FLOAT(-2047);
  if (*(short float *)a1.n128_u16 >= COERCE_SHORT_FLOAT(30720)) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (truncl(*(short float *)a1.n128_u16) == *(short float *)a1.n128_u16);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    int v5 = 0;
  }
  else {
    int v5 = (unsigned __int16)(int)*(short float *)a1.n128_u16;
  }
  return v5 & 0xFFFEFFFF | ((v4 & 1) << 16);
}

Swift::Int16 __swiftcall Int16.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int16 because it is either infinite or NaN", 77, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1288uLL, 0);
  }
  if (a1 <= -32769.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int16 because the result would be less than Int16.min", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x128BuLL, 0);
  }
  if (a1 >= 32768.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int16 because the result would be greater than Int16.max", 91, 2, "Swift/IntegerTypes.swift", 24, 2, 0x128EuLL, 0);
  }
  return (int)a1;
}

Swift::Int16_optional __swiftcall Int16.init(exactly:)(Swift::Float exactly)
{
  BOOL v1 = exactly > -32769.0;
  if (exactly >= 32768.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (truncf(exactly) == exactly);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    int v5 = 0;
  }
  else {
    int v5 = (unsigned __int16)(int)exactly;
  }
  return (Swift::Int16_optional)(v5 & 0xFFFEFFFF | ((v4 & 1) << 16));
}

Swift::Int16 __swiftcall Int16.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int16 because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0x12D0uLL, 0);
  }
  if (a1 <= -32769.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int16 because the result would be less than Int16.min", 89, 2, "Swift/IntegerTypes.swift", 24, 2, 0x12D3uLL, 0);
  }
  if (a1 >= 32768.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int16 because the result would be greater than Int16.max", 92, 2, "Swift/IntegerTypes.swift", 24, 2, 0x12D6uLL, 0);
  }
  return (int)a1;
}

Swift::Int16_optional __swiftcall Int16.init(exactly:)(Swift::Double exactly)
{
  BOOL v1 = exactly > -32769.0;
  if (exactly >= 32768.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (trunc(exactly) == exactly);
  BOOL v2 = v3 == 0;
  char v4 = ~(_BYTE)v3;
  if (v2) {
    int v5 = 0;
  }
  else {
    int v5 = (unsigned __int16)(int)exactly;
  }
  return (Swift::Int16_optional)(v5 & 0xFFFEFFFF | ((v4 & 1) << 16));
}

BOOL static Int16.== infix(_:_:)(__int16 a1, __int16 a2)
{
  return a1 == a2;
}

BOOL static Int16.< infix(_:_:)(__int16 a1, __int16 a2)
{
  return a1 < a2;
}

__int16 *static Int16.+= infix(_:_:)(__int16 *result, __int16 a2)
{
  int v2 = *result + a2;
  if ((__int16)(*result + a2) == v2) {
    *uint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

__int16 *static Int16.-= infix(_:_:)(__int16 *result, __int16 a2)
{
  int v2 = *result - a2;
  if ((__int16)(*result - a2) == v2) {
    *uint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

__int16 *static Int16.*= infix(_:_:)(__int16 *result, __int16 a2)
{
  int v2 = *result * a2;
  if ((__int16)(*result * a2) == v2) {
    *uint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

_WORD *static Int16./= infix(_:_:)(_WORD *result, __int16 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13C4uLL, 0);
  }
  int v2 = (unsigned __int16)*result;
  if (a2 == -1 && v2 == 0x8000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13CBuLL, 0);
  }
  *uint64_t result = (__int16)v2 / a2;
  return result;
}

Swift::tuple_partialValue_Int16_overflow_Bool __swiftcall Int16.addingReportingOverflow(_:)(Swift::Int16 a1)
{
  Swift::Int16 v2 = v1 + a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int16_overflow_Bool __swiftcall Int16.subtractingReportingOverflow(_:)(Swift::Int16 a1)
{
  Swift::Int16 v2 = v1 - a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int16_overflow_Bool __swiftcall Int16.multipliedReportingOverflow(by:)(Swift::Int16 by)
{
  Swift::Int16 v2 = v1 * by;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int16_overflow_Bool __swiftcall Int16.dividedReportingOverflow(by:)(Swift::Int16 by)
{
  if (by)
  {
    if (by == -1 && (unsigned __int16)v1 == 0x8000) {
      __int16 v1 = 0x8000;
    }
    else {
      v1 /= by;
    }
  }
  Swift::Int16 v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int16_overflow_Bool __swiftcall Int16.remainderReportingOverflow(dividingBy:)(Swift::Int16 dividingBy)
{
  if (dividingBy)
  {
    if (dividingBy == -1 && (unsigned __int16)v1 == 0x8000) {
      __int16 v1 = 0;
    }
    else {
      v1 %= dividingBy;
    }
  }
  Swift::Int16 v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

_WORD *static Int16.%= infix(_:_:)(_WORD *result, __int16 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x14A9uLL, 0);
  }
  int v2 = (unsigned __int16)*result;
  if (a2 == -1 && v2 == 0x8000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x14AEuLL, 0);
  }
  *Swift::tuple_partialValue_Int16_overflow_Bool result = (__int16)v2 % a2;
  return result;
}

_WORD *static Int16.&= infix(_:_:)(_WORD *result, __int16 a2)
{
  *result &= a2;
  return result;
}

_WORD *static Int16.|= infix(_:_:)(_WORD *result, __int16 a2)
{
  *result |= a2;
  return result;
}

_WORD *static Int16.^= infix(_:_:)(_WORD *result, __int16 a2)
{
  *result ^= a2;
  return result;
}

__int16 *static Int16.&>>= infix(_:_:)(__int16 *result, char a2)
{
  *result >>= a2 & 0xF;
  return result;
}

uint64_t static Int16.& infix(_:_:)(unsigned int a1, int a2)
{
  return a2 & a1;
}

_WORD *static Int16.&<<= infix(_:_:)(_WORD *result, char a2)
{
  *Swift::tuple_partialValue_Int16_overflow_Bool result = (unsigned __int16)*result << (a2 & 0xF);
  return result;
}

uint64_t static Int16.bitWidth.getter()
{
  return 16;
}

uint64_t Int16.leadingZeroBitCount.getter(unsigned __int16 a1)
{
  return (unsigned __int16)(__clz(a1) - 16);
}

uint64_t Int16._lowWord.getter(uint64_t result)
{
  return (__int16)result;
}

uint64_t Int16.trailingZeroBitCount.getter(int a1)
{
  return __clz(__rbit32(a1 | 0x10000));
}

uint64_t Int16.nonzeroBitCount.getter(unsigned __int16 a1)
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t Int16.Words._value.setter(uint64_t result)
{
  _WORD *v1 = result;
  return result;
}

uint64_t (*Int16.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.Words.count.getter()
{
  return 1;
}

uint64_t Int16.Words.startIndex.getter()
{
  return 0;
}

uint64_t Int16.Words.endIndex.getter()
{
  return 1;
}

uint64_t Int16.Words.indices.getter()
{
  return 0;
}

Swift::Int __swiftcall Int16.Words.index(after:)(Swift::Int after)
{
  BOOL v1 = __OFADD__(after, 1);
  Swift::Int result = after + 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

Swift::Int __swiftcall Int16.Words.index(before:)(Swift::Int before)
{
  BOOL v1 = __OFSUB__(before, 1);
  Swift::Int result = before - 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

uint64_t Int16.Words.subscript.getter(uint64_t a1, __int16 a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative word index", 19, 2, "Swift/IntegerTypes.swift", 24, 2, 0x15ABuLL, 0);
  }
  if (a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Word index out of range", 23, 2, "Swift/IntegerTypes.swift", 24, 2, 0x15ACuLL, 0);
  }
  return a2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Int16.Words(uint64_t *a1, uint64_t *a2))()
{
  *a1 = Int16.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Collection.subscript.getter in conformance UInt16.Words@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  if ((*result & 0x8000000000000000) != 0 || (uint64_t v3 = result[1], v3 >= 2)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  }
  __int16 v4 = *v2;
  *(void *)a2 = *result;
  *(void *)(a2 + 8) = v3;
  *(_WORD *)(a2 + 16) = v4;
  return result;
}

void protocol witness for Sequence.makeIterator() in conformance Int16.Words(uint64_t a1@<X8>)
{
  *(_WORD *)a1 = *v1;
  *(void *)(a1 + 8) = 0;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance Int16.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Int16.Words(uint64_t a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Int16.Words@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySuqd__Isgyrzo_s4Int8V5WordsVABsAG_pAKRszr__lIetMgyrzo_Tpq5Tm(a1, a2);
}

uint64_t Int16.magnitude.getter(__int16 a1)
{
  if (a1 >= 0) {
    return a1;
  }
  else {
    return -a1;
  }
}

Swift::tuple_high_Int16_low_UInt16 __swiftcall Int16.multipliedFullWidth(by:)(Swift::Int16 by)
{
  Swift::Int16 v2 = (v1 * by) >> 16;
  result.low = v1;
  result.high = v2;
  return result;
}

Swift::tuple_quotient_Int16_remainder_Int16 __swiftcall Int16.dividingFullWidth(_:)(Swift::tuple_high_Int16_low_UInt16 a1)
{
  if (!v1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x162AuLL, 0);
  }
  int v2 = a1.low | ((unsigned __int16)a1.high << 16);
  if (v1 == -1 && v2 == 0x80000000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FD1uLL, 0);
  }
  int v3 = v2 / v1;
  if (v3 != (__int16)v3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Quotient is not representable", 29, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1634uLL, 0);
  }
  result.remainder = v2;
  result.quotient = v3;
  return result;
}

uint64_t static Int32.&<< infix(_:_:)(int a1, char a2)
{
  return (a1 << a2);
}

uint64_t Int16.byteSwapped.getter(unsigned int a1)
{
  return bswap32(a1) >> 16;
}

Swift::Int16 __swiftcall Int16.signum()()
{
  return (v0 > 0) | (v0 >> 15);
}

BOOL static Int16.> infix(_:_:)(__int16 a1, __int16 a2)
{
  return a2 < a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance Int16(_WORD *a1@<X8>)
{
  *a1 = 0x7FFF;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance Int16(_WORD *a1@<X8>)
{
  *a1 = 0x8000;
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance Int16(_WORD *a1, __int16 *a2)
{
  int v3 = *v2 + *a2;
  BOOL v4 = v3 != (__int16)(*v2 + *a2);
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance Int16(_WORD *a1, __int16 *a2)
{
  int v3 = *v2 - *a2;
  BOOL v4 = v3 != (__int16)(*v2 - *a2);
  *a1 = v3;
  return v4;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance Int16(_WORD *a1, __int16 *a2)
{
  int v3 = *v2 * *a2;
  BOOL v4 = v3 != (__int16)(*v2 * *a2);
  *a1 = v3;
  return v4;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance Int16(_WORD *a1, _WORD *a2)
{
  int v3 = (unsigned __int16)*a2;
  int v4 = *v2;
  if (!*a2 || v3 == 0xFFFF && v4 == 0x8000)
  {
    uint64_t v5 = 1;
  }
  else
  {
    uint64_t v5 = 0;
    LOWORD(v4) = (__int16)v4 / (__int16)v3;
  }
  *a1 = v4;
  return v5;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance Int16(_WORD *a1, _WORD *a2)
{
  int v3 = (unsigned __int16)*a2;
  int v4 = *v2;
  if (!*a2) {
    goto LABEL_7;
  }
  if (v3 == 0xFFFF && v4 == 0x8000)
  {
    LOWORD(v4) = 0;
LABEL_7:
    uint64_t v5 = 1;
    goto LABEL_5;
  }
  uint64_t v5 = 0;
  LOWORD(v4) = (__int16)v4 % (__int16)v3;
LABEL_5:
  *a1 = v4;
  return v5;
}

_WORD *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance Int16(_WORD *result, _WORD *a2, __int16 *a3)
{
  int v4 = *v3 * *a3;
  *Swift::tuple_quotient_Int16_remainder_Int16 result = HIWORD(v4);
  *a2 = v4;
  return result;
}

Swift::Int16 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int16(Swift::Int16 *a1, _WORD *a2, _WORD *a3, _WORD *a4)
{
  Swift::Int16 result = Int16.dividingFullWidth(_:)((Swift::tuple_high_Int16_low_UInt16)__PAIR32__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance Int16()
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)*v0);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance Int16()
{
  return (unsigned __int16)(__clz(*v0) - 16);
}

unsigned __int16 *protocol witness for FixedWidthInteger.init(bigEndian:) in conformance Int16@<X0>(unsigned __int16 *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = bswap32(*result) >> 16;
  return result;
}

_WORD *protocol witness for FixedWidthInteger.init(littleEndian:) in conformance Int16@<X0>(_WORD *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = *result;
  return result;
}

void protocol witness for FixedWidthInteger.bigEndian.getter in conformance Int16(_WORD *a1@<X8>)
{
  *a1 = bswap32(*v1) >> 16;
}

void protocol witness for FixedWidthInteger.littleEndian.getter in conformance Int16(_WORD *a1@<X8>)
{
  *a1 = *v1;
}

__int16 *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance Int16@<X0>(__int16 *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *result >> (*a2 & 0xF);
  return result;
}

__int16 *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance Int16(__int16 *result, _WORD *a2)
{
  *result >>= *a2 & 0xF;
  return result;
}

unsigned __int16 *protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance Int16@<X0>(unsigned __int16 *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *result << (*a2 & 0xF);
  return result;
}

_WORD *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance Int16(_WORD *result, _WORD *a2)
{
  *Swift::Int16 result = (unsigned __int16)*result << (*a2 & 0xF);
  return result;
}

_WORD *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance Int16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *a2 * *result;
  return result;
}

_WORD *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance Int16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *a2 + *result;
  return result;
}

_WORD *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance Int16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

_WORD *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Int16@<X0>(_WORD *result@<X0>, unint64_t a2@<X1>, _WORD *a3@<X8>)
{
  if (a2 >> 8 <= 0x10) {
    *a3 = *result;
  }
  else {
    *a3 = 0;
  }
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int16 and conformance Int16(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int16@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt16(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type Int16 and conformance Int16, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt16@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, _WORD *a6@<X8>)
{
  uint64_t v8 = v6;
  uint64_t v13 = a5();
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v38, a1, a4, (uint64_t)a2, v13, a3);
  if ((v38 & 0x10000) != 0)
  {
    uint64_t v38 = static String._createEmpty(withInitialCapacity:)(80);
    unint64_t v39 = v15;
    TypeName = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v17 & 0x8000000000000000) == 0)
    {
      uint64_t v18 = (uint8x16_t *)TypeName;
      int64_t v19 = v17;
      int64_t v20 = validateUTF8(_:)(TypeName, v17);
      uint64_t v23 = (v22 & 1) != 0
          ? repairUTF8(_:firstKnownBrokenRange:)(v18->i8, v19, v20, v21)
          : specialized static String._uncheckedFromUTF8(_:isASCII:)(v18, v19, v20 & 1);
      uint64_t v25 = v24;
      String.append(_:)(*(Swift::String *)&v23);
      swift_bridgeObjectRelease(v25);
      v26._object = (void *)0x80000001816DE7E0;
      v26._countAndFlagsBits = 0xD00000000000001ELL;
      String.append(_:)(v26);
      v27 = (uint64_t *)swift_getTypeName(v8, 0);
      if ((v28 & 0x8000000000000000) == 0)
      {
        __int16 v29 = (uint8x16_t *)v27;
        int64_t v30 = v28;
        int64_t v31 = validateUTF8(_:)(v27, v28);
        if (v33) {
          uint64_t v34 = repairUTF8(_:firstKnownBrokenRange:)(v29->i8, v30, v31, v32);
        }
        else {
          uint64_t v34 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v29, v30, v31 & 1);
        }
        uint64_t v36 = v35;
        String.append(_:)(*(Swift::String *)&v34);
        swift_bridgeObjectRelease(v36);
        v37._countAndFlagsBits = 0xD00000000000002ELL;
        v37._object = (void *)0x80000001816DE800;
        String.append(_:)(v37);
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v38, v39, "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  uint64_t result = (*((uint64_t (**)(uint64_t, Class *))*(a2 - 1) + 1))(a1, a2);
  *a6 = v38;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _WORD *a6@<X8>)
{
  uint64_t v79 = a4;
  uint64_t v80 = a5;
  v75 = *(int ***)(*(void *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v75, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v73 = (char *)&v72 - v11;
  uint64_t v12 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  v76 = (char *)&v72 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  v83 = (char *)&v72 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  int64_t v19 = (char *)&v72 - v18;
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  v81 = (char *)&v72 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  v78 = (char *)&v72 - v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v25 = (char *)&v72 - v24;
  v85 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v26 = v85(a2, a3);
  uint64_t v86 = a1;
  uint64_t v87 = v12;
  v88 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v88(v25, a1, a2);
  v84 = a6;
  uint64_t v82 = a3 + 64;
  if (v26)
  {
    v77 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v27 = v77(a2, a3);
    v89 = *(void (**)(char *, uint64_t))(v12 + 8);
    v89(v25, a2);
    if (v27 <= 16)
    {
      uint64_t v34 = v86;
      char v33 = v77;
      uint64_t v35 = v77(a2, a3);
      goto LABEL_23;
    }
    unsigned __int16 v72 = v19;
    uint64_t v28 = v78;
    v88(v78, v86, a2);
    __int16 v90 = 0x8000;
    __int16 v29 = v85;
    if (v85(a2, a3))
    {
      if (v77(a2, a3) < 16)
      {
        int64_t v30 = v81;
        v88(v81, (uint64_t)v28, a2);
        __int16 v31 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        int64_t v32 = v30;
LABEL_17:
        uint64_t v43 = v89;
        v89(v32, a2);
        if (v90 > v31) {
LABEL_40:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_21;
      }
      uint64_t v42 = v81;
      (*(void (**)(__int16 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v90, v79, v80, a2, a3);
      char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v28, v42, a2);
      v41 = v42;
    }
    else
    {
      char v36 = v29(a2, a3);
      uint64_t v37 = v77(a2, a3);
      uint64_t v38 = v28;
      if ((v36 & 1) == 0)
      {
        if (v37 >= 16)
        {
          v89(v28, a2);
          uint64_t v34 = v86;
          int64_t v19 = v72;
          char v33 = v77;
          uint64_t v35 = v77(a2, a3);
          goto LABEL_23;
        }
        v44 = v81;
        v88(v81, (uint64_t)v28, a2);
        __int16 v31 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        int64_t v32 = v44;
        goto LABEL_17;
      }
      if (v37 <= 16)
      {
        v45 = AssociatedTypeWitness;
        uint64_t v46 = v75;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v75, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v48 = v73;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v45, AssociatedConformanceWitness);
        unsigned int v49 = v81;
        ((void (*)(char *, uint64_t, int **))v46[3])(v48, a2, v46);
        LOBYTE(v45) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v38, v49, a2);
        v50 = v38;
        uint64_t v43 = v89;
        v89(v49, a2);
        unsigned __int16 v51 = v76;
        v88(v76, (uint64_t)v50, a2);
        if (v45)
        {
          v43(v51, a2);
          goto LABEL_40;
        }
        int v52 = v90;
        __int16 v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v43(v51, a2);
        uint64_t v28 = v78;
        if (v52 > v53) {
          goto LABEL_40;
        }
LABEL_21:
        v43(v28, a2);
        int64_t v19 = v72;
        char v33 = v77;
        goto LABEL_22;
      }
      unint64_t v39 = v81;
      (*(void (**)(__int16 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v90, v79, v80, a2, a3);
      char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v28, v39, a2);
      v41 = v39;
    }
    uint64_t v43 = v89;
    v89(v41, a2);
    if (v40) {
      goto LABEL_40;
    }
    goto LABEL_21;
  }
  v89 = *(void (**)(char *, uint64_t))(v12 + 8);
  v89(v25, a2);
  char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
LABEL_22:
  uint64_t v34 = v86;
  uint64_t v35 = v33(a2, a3);
LABEL_23:
  uint64_t v54 = v35;
  v88(v19, v34, a2);
  if (v54 < 17)
  {
    v55 = v33;
    uint64_t v62 = v33(a2, a3);
    v89(v19, a2);
    if (v62 != 16)
    {
      char v56 = v84;
      goto LABEL_37;
    }
    char v63 = v85(a2, a3);
    char v56 = v84;
    if (v63) {
      goto LABEL_37;
    }
  }
  else
  {
    v55 = v33;
    v89(v19, a2);
    char v56 = v84;
  }
  v57 = v83;
  v88(v83, v34, a2);
  __int16 v92 = 0x7FFF;
  char v58 = v85(a2, a3);
  uint64_t v59 = v55(a2, a3);
  if ((v58 & 1) == 0)
  {
    if (v59 > 15)
    {
      __int16 v91 = 0x7FFF;
      uint64_t v60 = *(void (**)(__int16 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      v61 = &v91;
      goto LABEL_35;
    }
LABEL_32:
    v64 = v81;
    v88(v81, (uint64_t)v57, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    v65 = v89;
    v89(v64, a2);
    v65(v57, a2);
    goto LABEL_37;
  }
  if (v59 <= 16) {
    goto LABEL_32;
  }
  uint64_t v60 = *(void (**)(__int16 *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
  v61 = &v92;
LABEL_35:
  v66 = v81;
  v60(v61, v79, v80, a2, a3);
  char v67 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v66, v57, a2);
  v68 = v66;
  uint64_t v69 = v89;
  v89(v68, a2);
  if (v67) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v69(v83, a2);
LABEL_37:
  __int16 v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v89)(v34, a2);
  *char v56 = v70;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance UInt16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _WORD *a4@<X8>)
{
  __int16 v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  *a4 = v7;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int16 and conformance Int16(a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance Int16()
{
  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance Int16()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

uint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance Int16()
{
  return __clz(__rbit32(*v0 | 0x10000));
}

unsigned __int16 *protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int16@<X0>(unsigned __int16 *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = (unsigned __int16)*a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13C4uLL, 0);
  }
  int v4 = *result;
  if (v4 == 0x8000 && v3 == 0xFFFF) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13CBuLL, 0);
  }
  *a3 = (__int16)v4 / (__int16)v3;
  return result;
}

uint64_t static Int16./ infix(_:_:)(unsigned __int16 a1, __int16 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13C4uLL, 0);
  }
  if (a1 == 0x8000 && a2 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13CBuLL, 0);
  }
  return ((__int16)a1 / a2);
}

_WORD *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int16(_WORD *result, _WORD *a2)
{
  int v2 = (unsigned __int16)*a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13C4uLL, 0);
  }
  int v3 = (unsigned __int16)*result;
  if (v2 == 0xFFFF && v3 == 0x8000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x13CBuLL, 0);
  }
  *uint64_t result = (__int16)v3 / (__int16)v2;
  return result;
}

unsigned __int16 *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int16@<X0>(unsigned __int16 *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = (unsigned __int16)*a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x14A9uLL, 0);
  }
  int v4 = *result;
  if (v4 == 0x8000 && v3 == 0xFFFF) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x14AEuLL, 0);
  }
  *a3 = (__int16)v4 % (__int16)v3;
  return result;
}

uint64_t static Int16.% infix(_:_:)(unsigned __int16 a1, __int16 a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x14A9uLL, 0);
  }
  if (a1 == 0x8000 && a2 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x14AEuLL, 0);
  }
  return ((__int16)a1 % a2);
}

_WORD *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int16(_WORD *result, _WORD *a2)
{
  int v2 = (unsigned __int16)*a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x14A9uLL, 0);
  }
  int v3 = (unsigned __int16)*result;
  if (v2 == 0xFFFF && v3 == 0x8000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x14AEuLL, 0);
  }
  *uint64_t result = (__int16)v3 % (__int16)v2;
  return result;
}

_WORD *protocol witness for static BinaryInteger.~ prefix(_:) in conformance Int16@<X0>(_WORD *result@<X0>, _WORD *a2@<X8>)
{
  *a2 = ~*result;
  return result;
}

_WORD *protocol witness for static BinaryInteger.& infix(_:_:) in conformance Int16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *a2 & *result;
  return result;
}

_WORD *protocol witness for static BinaryInteger.&= infix(_:_:) in conformance Int16(_WORD *result, _WORD *a2)
{
  *result &= *a2;
  return result;
}

_WORD *protocol witness for static BinaryInteger.| infix(_:_:) in conformance Int16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *a2 | *result;
  return result;
}

_WORD *protocol witness for static BinaryInteger.|= infix(_:_:) in conformance Int16(_WORD *result, _WORD *a2)
{
  *result |= *a2;
  return result;
}

_WORD *protocol witness for static BinaryInteger.^ infix(_:_:) in conformance Int16@<X0>(_WORD *result@<X0>, _WORD *a2@<X1>, _WORD *a3@<X8>)
{
  *a3 = *a2 ^ *result;
  return result;
}

uint64_t static Int16.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

_WORD *protocol witness for static BinaryInteger.^= infix(_:_:) in conformance Int16(_WORD *result, _WORD *a2)
{
  *result ^= *a2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int16@<X0>(unsigned __int16 *a1@<X0>, uint64_t (*a2)(char *, uint64_t)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  v134 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v134, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v132 = (char *)v125 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v125 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  v129 = (char *)v125 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v135 = (char *)v125 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)v125 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  v130 = (char *)v125 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v136 = (char *)v125 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  v140 = (char *)v125 - v28;
  MEMORY[0x1F4188790](v27);
  int64_t v30 = (char *)v125 - v29;
  int v138 = *a1;
  __int16 v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v142 = a4 + 64;
  char v32 = v31(a3, a4);
  v139 = a5;
  if (v32)
  {
    char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 < 64)
    {
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      if (v37 >= -16) {
        goto LABEL_19;
      }
LABEL_18:
      LOWORD(v59) = 0;
      uint64_t v60 = v139;
      goto LABEL_60;
    }
    v144[0] = -16;
    v141 = v33;
    v47 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
    v47(v144, &type metadata for Int, v48, a3, a4);
    char v33 = v141;
    char v49 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                              + 16))(a2, v30, a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
    if (v49) {
      goto LABEL_18;
    }
  }
  else
  {
    char v39 = v31(a3, a4);
    char v40 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v137 = a2;
    v141 = v40;
    uint64_t v41 = v40(a3, a4);
    if (v39)
    {
      v131 = v31;
      if (v41 <= 64)
      {
        unsigned __int16 v51 = AssociatedTypeWitness;
        int v52 = v134;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v134, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v54 = v132;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v51, AssociatedConformanceWitness);
        ((void (*)(char *, uint64_t, int **))v52[3])(v54, a3, v52);
        v55 = v137;
        LOBYTE(v51) = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v137, v30, a3);
        uint64_t v56 = v12;
        v57 = *(void (**)(char *, uint64_t))(v12 + 8);
        v57(v30, a3);
        uint64_t v128 = v56;
        (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v56 + 16))(v15, v55, a3);
        if (v51)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
        }
        else
        {
          uint64_t v58 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
          uint64_t v12 = v128;
          __int16 v31 = v131;
          char v33 = v141;
          a2 = v137;
          if (v58 >= -16) {
            goto LABEL_19;
          }
        }
        goto LABEL_18;
      }
      v144[0] = -16;
      v44 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
      v44(v144, &type metadata for Int, v45, a3, a4);
      a2 = v137;
      char v46 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                                + 16))(v137, v30, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      __int16 v31 = v131;
      char v33 = v141;
      if (v46) {
        goto LABEL_18;
      }
    }
    else
    {
      if (v41 >= 64)
      {
        char v33 = v141;
        a2 = v137;
        goto LABEL_19;
      }
      a2 = v137;
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, v137, a3);
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      char v33 = v141;
      if (v50 < -16) {
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  char v61 = v31(a3, a4);
  uint64_t v62 = a4 + 128;
  char v63 = (uint64_t (*)(uint64_t, uint64_t))a4;
  v64 = (char *)a2;
  uint64_t v65 = v62;
  v131 = v63;
  uint64_t v66 = ((uint64_t (*)(uint64_t))v33)(a3);
  v125[0] = v22;
  v125[1] = v65;
  if (v61)
  {
    if (v66 > 64) {
      goto LABEL_21;
    }
  }
  else if (v66 > 63)
  {
LABEL_21:
    v144[0] = 16;
    uint64_t v69 = v131;
    __int16 v70 = v31;
    uint64_t v71 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (**)(uint64_t, void)))*((void *)v131 + 12);
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v71(v144, &type metadata for Int, v72, a3, (uint64_t (**)(uint64_t, void))v69);
    __int16 v31 = v70;
    v73 = v64;
    v74 = v69;
    char v75 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v69 + 4) + 8) + 16))(v30, v73, a3);
    v76 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    uint64_t result = v76(v30, a3);
    if ((v75 & 1) == 0) {
      goto LABEL_22;
    }
LABEL_29:
    int v59 = (__int16)v138 >> 15;
    uint64_t v60 = v139;
    goto LABEL_60;
  }
  v73 = v64;
  (*(void (**)(char *, char *, uint64_t))(v12 + 16))(v30, v64, a3);
  v74 = v131;
  uint64_t v89 = (*((uint64_t (**)(uint64_t, void))v131 + 15))(a3, v131);
  v76 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  uint64_t result = v76(v30, a3);
  if (v89 > 16) {
    goto LABEL_29;
  }
LABEL_22:
  v137 = v76;
  v141 = v33;
  v77 = v31;
  uint64_t v79 = v12 + 16;
  v78 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
  uint64_t v80 = v12;
  v81 = v140;
  v78(v140, v73, a3);
  uint64_t v82 = v77;
  LOBYTE(v77) = v77(a3, (uint64_t)v74);
  v83 = v136;
  v126 = v78;
  uint64_t v127 = v79;
  v78(v136, v81, a3);
  uint64_t v128 = v80;
  if ((v77 & 1) == 0)
  {
    v137(v83, a3);
    goto LABEL_44;
  }
  uint64_t v84 = v141(a3, (uint64_t)v74);
  v137(v83, a3);
  if (v84 <= 64) {
    goto LABEL_44;
  }
  v85 = v130;
  v126(v130, v140, a3);
  v144[0] = 0x8000000000000000;
  if (v82(a3, (uint64_t)v74))
  {
    uint64_t v86 = v141(a3, (uint64_t)v74);
    if (v86 < 64)
    {
LABEL_37:
      v126(v30, v85, a3);
      uint64_t v95 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
      v94 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      if (v95 < v144[0]) {
        goto LABEL_66;
      }
      goto LABEL_43;
    }
  }
  else
  {
    char v90 = v82(a3, (uint64_t)v74);
    uint64_t v86 = v141(a3, (uint64_t)v74);
    if ((v90 & 1) == 0)
    {
      if (v86 >= 64)
      {
        v137(v85, a3);
        goto LABEL_44;
      }
      goto LABEL_37;
    }
    if (v86 <= 64)
    {
      v131 = v82;
      v97 = AssociatedTypeWitness;
      v96 = v134;
      uint64_t v98 = swift_getAssociatedConformanceWitness((uint64_t)v134, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v99 = v132;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v98 + 8))(&qword_18162B0B8, 256, v97, v98);
      ((void (*)(char *, uint64_t, int **))v96[3])(v99, a3, v96);
      v100 = v130;
      char v101 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v74 + 4) + 8) + 16))(v130, v30, a3);
      v102 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      v103 = v129;
      v126(v129, v100, a3);
      if (v101)
      {
        v102(v103, a3);
        goto LABEL_66;
      }
      uint64_t v104 = v144[0];
      uint64_t v105 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
      v102(v103, a3);
      BOOL v106 = v105 < v104;
      v85 = v130;
      uint64_t v82 = v131;
      v94 = v102;
      if (v106) {
LABEL_66:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_43;
    }
  }
  __int16 v91 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
  unint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v86, v87, v88);
  ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v91)(v144, &type metadata for Int, v92, a3, v131);
  v85 = v130;
  v74 = v131;
  char v93 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v131 + 4) + 8) + 16))(v130, v30, a3);
  v94 = (void (*)(char *, uint64_t))v137;
  v137(v30, a3);
  if (v93) {
    goto LABEL_66;
  }
LABEL_43:
  v94(v85, a3);
LABEL_44:
  v107 = v140;
  v108 = v141;
  uint64_t v109 = v141(a3, (uint64_t)v74);
  v110 = (char *)v125[0];
  v126((char *)v125[0], v107, a3);
  if (v109 < 65)
  {
    uint64_t v119 = v108(a3, (uint64_t)v74);
    v137(v110, a3);
    v111 = v135;
    if (v119 != 64 || (v82(a3, (uint64_t)v74) & 1) != 0) {
      goto LABEL_57;
    }
  }
  else
  {
    v137(v110, a3);
    v111 = v135;
  }
  v126(v111, v140, a3);
  v144[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v112 = v82(a3, (uint64_t)v74);
  uint64_t v113 = v141(a3, (uint64_t)v74);
  if (v112)
  {
    if (v113 > 64)
    {
      v116 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
      unint64_t v117 = lazy protocol witness table accessor for type Int and conformance Int(v113, v114, v115);
      v118 = v144;
LABEL_55:
      ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v116)(v118, &type metadata for Int, v117, a3, v74);
      char v121 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v74 + 4) + 8) + 16))(v30, v111, a3);
      v122 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      if (v121) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      v122(v111, a3);
      goto LABEL_57;
    }
  }
  else if (v113 > 63)
  {
    uint64_t v143 = 0x7FFFFFFFFFFFFFFFLL;
    v116 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
    unint64_t v117 = lazy protocol witness table accessor for type Int and conformance Int(v113, v114, v115);
    v118 = &v143;
    goto LABEL_55;
  }
  v126(v30, v111, a3);
  (*((void (**)(uint64_t, uint64_t (*)(uint64_t, uint64_t)))v74 + 15))(a3, v74);
  v120 = (void (*)(char *, uint64_t))v137;
  v137(v30, a3);
  v120(v111, a3);
LABEL_57:
  v123 = v140;
  unint64_t v124 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
  uint64_t result = v137(v123, a3);
  if ((v124 & 0x8000000000000000) != 0)
  {
    uint64_t v60 = v139;
    if (v124 <= 0xFFFFFFFFFFFFFFF0) {
      LOWORD(v59) = 0;
    }
    else {
      int v59 = v138 << -(char)v124;
    }
  }
  else
  {
    uint64_t v60 = v139;
    if (v124 >= 0x10) {
      int v59 = (__int16)v138 >> 15;
    }
    else {
      int v59 = (__int16)v138 >> v124;
    }
  }
LABEL_60:
  *uint64_t v60 = v59;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int16(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v120 = a1;
  v110 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v110, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v108 = (char *)&v105 - v8;
  v9 = *(uint64_t (**)(char *, uint64_t))(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v12 = (char *)&v105 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  BOOL v106 = (char *)&v105 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v113 = (char *)&v105 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  char v112 = (char *)&v105 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  v107 = (char *)&v105 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v114 = (char *)&v105 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  v118 = (char *)&v105 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v26 = (char *)&v105 - v25;
  uint64_t v28 = a4 + 64;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v27(a3, a4) & 1) == 0)
  {
    char v32 = v27(a3, a4);
    uint64_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v29 = v119(a3, a4);
    if ((v32 & 1) == 0)
    {
      if (v29 >= 64) {
        goto LABEL_14;
      }
      goto LABEL_9;
    }
    if (v29 <= 64)
    {
      uint64_t v115 = a4 + 64;
      unint64_t v117 = v27;
      char v39 = AssociatedTypeWitness;
      char v40 = v110;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v110, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v42 = v108;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v39, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v40[3])(v42, a3, v40);
      LOBYTE(v39) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
      uint64_t v43 = (void (*)(char *, uint64_t))*((void *)v9 + 1);
      v43(v26, a3);
      v116 = v9;
      (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v12, a2, a3);
      if (v39)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v43)(v12, a3);
        LOWORD(v38) = 0;
        goto LABEL_53;
      }
      uint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v43)(v12, a3);
      v9 = v116;
      uint64_t v27 = v117;
      uint64_t v28 = v115;
      if (v44 < -16) {
        goto LABEL_10;
      }
      goto LABEL_14;
    }
LABEL_6:
    int64_t v122 = -16;
    char v33 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v34 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
    v33(&v122, &type metadata for Int, v34, a3, a4);
    char v35 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
    if (v35) {
      goto LABEL_10;
    }
    goto LABEL_14;
  }
  uint64_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v29 = v119(a3, a4);
  if (v29 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
  if (v37 < -16)
  {
LABEL_10:
    LOWORD(v38) = 0;
    goto LABEL_53;
  }
LABEL_14:
  char v45 = v27(a3, a4);
  uint64_t v111 = a4 + 128;
  uint64_t v46 = v119(a3, a4);
  unint64_t v117 = v27;
  uint64_t v115 = v28;
  if (v45)
  {
    if (v46 > 64) {
      goto LABEL_16;
    }
  }
  else if (v46 >= 64)
  {
LABEL_16:
    int64_t v122 = 16;
    char v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v46, v47, v48);
    v49(&v122, &type metadata for Int, v50, a3, a4);
    char v51 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v26, a2, a3);
    int v52 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
    uint64_t result = v52(v26, a3);
    if ((v51 & 1) == 0) {
      goto LABEL_17;
    }
LABEL_24:
    int v38 = (__int16)*v120 >> 15;
    goto LABEL_53;
  }
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v68 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  int v52 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
  uint64_t result = v52(v26, a3);
  if (v68 > 16) {
    goto LABEL_24;
  }
LABEL_17:
  __int16 v53 = v26;
  v116 = v52;
  uint64_t v54 = (char *)v9 + 16;
  v55 = (void (*)(char *, uint64_t, uint64_t))*((void *)v9 + 2);
  uint64_t v56 = v118;
  v55(v118, a2, a3);
  char v57 = v117(a3, a4);
  uint64_t v58 = v114;
  int v59 = v56;
  uint64_t v105 = v54;
  uint64_t v60 = (void (*)(char *, char *, uint64_t))v55;
  v55(v114, (uint64_t)v59, a3);
  if ((v57 & 1) == 0)
  {
    v116(v58, a3);
    uint64_t v62 = v53;
    goto LABEL_37;
  }
  uint64_t v61 = v119(a3, a4);
  v116(v58, a3);
  uint64_t v62 = v53;
  char v63 = v117;
  if (v61 <= 64) {
    goto LABEL_37;
  }
  v64 = v107;
  v60(v107, v118, a3);
  int64_t v122 = 0x8000000000000000;
  if (v63(a3, a4))
  {
    uint64_t v65 = v119(a3, a4);
    if (v65 >= 64)
    {
LABEL_28:
      __int16 v70 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v71 = lazy protocol witness table accessor for type Int and conformance Int(v65, v66, v67);
      v70(&v122, &type metadata for Int, v71, a3, a4);
      v64 = v107;
      char v72 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v107, v62, a3);
      v73 = (void (*)(char *, uint64_t))v116;
      v116(v62, a3);
      if (v72) {
        goto LABEL_59;
      }
      goto LABEL_36;
    }
LABEL_32:
    v60(v62, v64, a3);
    uint64_t v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v73 = (void (*)(char *, uint64_t))v116;
    v116(v62, a3);
    if (v74 < v122) {
LABEL_59:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_36;
  }
  char v69 = v63(a3, a4);
  uint64_t v65 = v119(a3, a4);
  if ((v69 & 1) == 0)
  {
    if (v65 >= 64)
    {
      v116(v64, a3);
      goto LABEL_37;
    }
    goto LABEL_32;
  }
  if (v65 > 64) {
    goto LABEL_28;
  }
  v76 = AssociatedTypeWitness;
  char v75 = v110;
  uint64_t v77 = swift_getAssociatedConformanceWitness((uint64_t)v110, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  v78 = v108;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v77 + 8))(&qword_18162B0B8, 256, v76, v77);
  ((void (*)(char *, uint64_t, int **))v75[3])(v78, a3, v75);
  uint64_t v79 = v107;
  char v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v107, v62, a3);
  v81 = (void (*)(char *, uint64_t))v116;
  v116(v62, a3);
  uint64_t v82 = v106;
  v60(v106, v79, a3);
  if (v80)
  {
    v81(v82, a3);
    goto LABEL_59;
  }
  int64_t v83 = v122;
  uint64_t v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v81(v82, a3);
  BOOL v85 = v84 < v83;
  v64 = v107;
  v73 = v81;
  if (v85) {
    goto LABEL_59;
  }
LABEL_36:
  v73(v64, a3);
LABEL_37:
  uint64_t v86 = v118;
  uint64_t v87 = v119;
  uint64_t v88 = v119(a3, a4);
  uint64_t v89 = v112;
  v60(v112, v86, a3);
  if (v88 < 65)
  {
    uint64_t v98 = v87(a3, a4);
    v116(v89, a3);
    char v90 = v113;
    if (v98 != 64 || (v117(a3, a4) & 1) != 0) {
      goto LABEL_50;
    }
  }
  else
  {
    v116(v89, a3);
    char v90 = v113;
  }
  v60(v90, v118, a3);
  int64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
  char v91 = v117(a3, a4);
  uint64_t v92 = v119(a3, a4);
  if ((v91 & 1) == 0)
  {
    if (v92 >= 64)
    {
      uint64_t v121 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
      v97 = &v121;
      goto LABEL_48;
    }
LABEL_47:
    v60(v62, v90, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v99 = (void (*)(char *, uint64_t))v116;
    v116(v62, a3);
    v99(v90, a3);
    goto LABEL_50;
  }
  if (v92 <= 64) {
    goto LABEL_47;
  }
  uint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
  v97 = &v122;
LABEL_48:
  v95(v97, &type metadata for Int, v96, a3, a4);
  char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v62, v90, a3);
  char v101 = (void (*)(char *, uint64_t))v116;
  v116(v62, a3);
  if (v100) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v101(v90, a3);
LABEL_50:
  v102 = v118;
  unint64_t v103 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v116(v102, a3);
  int v104 = *v120;
  if ((v103 & 0x8000000000000000) != 0)
  {
    if (v103 > 0xFFFFFFFFFFFFFFF0)
    {
      int v38 = v104 << -(char)v103;
      goto LABEL_53;
    }
    goto LABEL_10;
  }
  if (v103 >= 0x10) {
    int v38 = (__int16)v104 >> 15;
  }
  else {
    int v38 = (__int16)v104 >> v103;
  }
LABEL_53:
  unsigned __int16 *v120 = v38;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int16@<X0>(unsigned __int16 *a1@<X0>, uint64_t (*a2)(char *, uint64_t)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _WORD *a5@<X8>)
{
  v134 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v134, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v132 = (char *)v125 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v125 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  v129 = (char *)v125 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v135 = (char *)v125 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)v125 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  v130 = (char *)v125 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v136 = (char *)v125 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  v140 = (char *)v125 - v28;
  MEMORY[0x1F4188790](v27);
  uint64_t v30 = (char *)v125 - v29;
  int v138 = *a1;
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v142 = a4 + 64;
  char v32 = v31(a3, a4);
  v139 = a5;
  if (v32)
  {
    char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 < 64)
    {
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      if (v37 > -17) {
        goto LABEL_19;
      }
LABEL_18:
      int v59 = (__int16)v138 >> 15;
      uint64_t v60 = v139;
      goto LABEL_60;
    }
    v144[0] = -16;
    v141 = v33;
    uint64_t v47 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
    v47(v144, &type metadata for Int, v48, a3, a4);
    char v33 = v141;
    char v49 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                              + 16))(a2, v30, a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
    if (v49) {
      goto LABEL_18;
    }
  }
  else
  {
    char v39 = v31(a3, a4);
    char v40 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v137 = a2;
    v141 = v40;
    uint64_t v41 = v40(a3, a4);
    if (v39)
    {
      v131 = v31;
      if (v41 <= 64)
      {
        char v51 = AssociatedTypeWitness;
        int v52 = v134;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v134, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v54 = v132;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v51, AssociatedConformanceWitness);
        ((void (*)(char *, uint64_t, int **))v52[3])(v54, a3, v52);
        v55 = v137;
        LOBYTE(v51) = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v137, v30, a3);
        uint64_t v56 = v12;
        char v57 = *(void (**)(char *, uint64_t))(v12 + 8);
        v57(v30, a3);
        uint64_t v128 = v56;
        (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v56 + 16))(v15, v55, a3);
        if (v51)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
        }
        else
        {
          uint64_t v58 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
          uint64_t v12 = v128;
          uint64_t v31 = v131;
          char v33 = v141;
          a2 = v137;
          if (v58 >= -16) {
            goto LABEL_19;
          }
        }
        goto LABEL_18;
      }
      v144[0] = -16;
      uint64_t v44 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
      v44(v144, &type metadata for Int, v45, a3, a4);
      a2 = v137;
      char v46 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                                + 16))(v137, v30, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      uint64_t v31 = v131;
      char v33 = v141;
      if (v46) {
        goto LABEL_18;
      }
    }
    else
    {
      if (v41 >= 64)
      {
        char v33 = v141;
        a2 = v137;
        goto LABEL_19;
      }
      a2 = v137;
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, v137, a3);
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      char v33 = v141;
      if (v50 < -16) {
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  char v61 = v31(a3, a4);
  uint64_t v62 = a4 + 128;
  char v63 = (uint64_t (*)(uint64_t, uint64_t))a4;
  v64 = (char *)a2;
  uint64_t v65 = v62;
  v131 = v63;
  uint64_t v66 = ((uint64_t (*)(uint64_t))v33)(a3);
  v125[0] = v22;
  v125[1] = v65;
  if (v61)
  {
    if (v66 > 64) {
      goto LABEL_21;
    }
  }
  else if (v66 > 63)
  {
LABEL_21:
    v144[0] = 16;
    char v69 = v131;
    __int16 v70 = v31;
    unint64_t v71 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (**)(uint64_t, void)))*((void *)v131 + 12);
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v71(v144, &type metadata for Int, v72, a3, (uint64_t (**)(uint64_t, void))v69);
    uint64_t v31 = v70;
    v73 = v64;
    uint64_t v74 = v69;
    char v75 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v69 + 4) + 8) + 16))(v30, v73, a3);
    v76 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    uint64_t result = v76(v30, a3);
    if ((v75 & 1) == 0) {
      goto LABEL_22;
    }
LABEL_29:
    LOWORD(v59) = 0;
    uint64_t v60 = v139;
    goto LABEL_60;
  }
  v73 = v64;
  (*(void (**)(char *, char *, uint64_t))(v12 + 16))(v30, v64, a3);
  uint64_t v74 = v131;
  uint64_t v89 = (*((uint64_t (**)(uint64_t, void))v131 + 15))(a3, v131);
  v76 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  uint64_t result = v76(v30, a3);
  if (v89 > 16) {
    goto LABEL_29;
  }
LABEL_22:
  v137 = v76;
  v141 = v33;
  uint64_t v77 = v31;
  uint64_t v79 = v12 + 16;
  v78 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
  uint64_t v80 = v12;
  v81 = v140;
  v78(v140, v73, a3);
  uint64_t v82 = v77;
  LOBYTE(v77) = v77(a3, (uint64_t)v74);
  int64_t v83 = v136;
  v126 = v78;
  uint64_t v127 = v79;
  v78(v136, v81, a3);
  uint64_t v128 = v80;
  if ((v77 & 1) == 0)
  {
    v137(v83, a3);
    goto LABEL_44;
  }
  uint64_t v84 = v141(a3, (uint64_t)v74);
  v137(v83, a3);
  if (v84 <= 64) {
    goto LABEL_44;
  }
  BOOL v85 = v130;
  v126(v130, v140, a3);
  v144[0] = 0x8000000000000000;
  if (v82(a3, (uint64_t)v74))
  {
    uint64_t v86 = v141(a3, (uint64_t)v74);
    if (v86 < 64)
    {
LABEL_37:
      v126(v30, v85, a3);
      uint64_t v95 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
      uint64_t v94 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      if (v95 < v144[0]) {
        goto LABEL_66;
      }
      goto LABEL_43;
    }
  }
  else
  {
    char v90 = v82(a3, (uint64_t)v74);
    uint64_t v86 = v141(a3, (uint64_t)v74);
    if ((v90 & 1) == 0)
    {
      if (v86 >= 64)
      {
        v137(v85, a3);
        goto LABEL_44;
      }
      goto LABEL_37;
    }
    if (v86 <= 64)
    {
      v131 = v82;
      v97 = AssociatedTypeWitness;
      unint64_t v96 = v134;
      uint64_t v98 = swift_getAssociatedConformanceWitness((uint64_t)v134, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v99 = v132;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v98 + 8))(&qword_18162B0B8, 256, v97, v98);
      ((void (*)(char *, uint64_t, int **))v96[3])(v99, a3, v96);
      char v100 = v130;
      char v101 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v74 + 4) + 8) + 16))(v130, v30, a3);
      v102 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      unint64_t v103 = v129;
      v126(v129, v100, a3);
      if (v101)
      {
        v102(v103, a3);
        goto LABEL_66;
      }
      uint64_t v104 = v144[0];
      uint64_t v105 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
      v102(v103, a3);
      BOOL v106 = v105 < v104;
      BOOL v85 = v130;
      uint64_t v82 = v131;
      uint64_t v94 = v102;
      if (v106) {
LABEL_66:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_43;
    }
  }
  char v91 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
  unint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v86, v87, v88);
  ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v91)(v144, &type metadata for Int, v92, a3, v131);
  BOOL v85 = v130;
  uint64_t v74 = v131;
  char v93 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v131 + 4) + 8) + 16))(v130, v30, a3);
  uint64_t v94 = (void (*)(char *, uint64_t))v137;
  v137(v30, a3);
  if (v93) {
    goto LABEL_66;
  }
LABEL_43:
  v94(v85, a3);
LABEL_44:
  v107 = v140;
  v108 = v141;
  uint64_t v109 = v141(a3, (uint64_t)v74);
  v110 = (char *)v125[0];
  v126((char *)v125[0], v107, a3);
  if (v109 < 65)
  {
    uint64_t v119 = v108(a3, (uint64_t)v74);
    v137(v110, a3);
    uint64_t v111 = v135;
    if (v119 != 64 || (v82(a3, (uint64_t)v74) & 1) != 0) {
      goto LABEL_57;
    }
  }
  else
  {
    v137(v110, a3);
    uint64_t v111 = v135;
  }
  v126(v111, v140, a3);
  v144[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v112 = v82(a3, (uint64_t)v74);
  uint64_t v113 = v141(a3, (uint64_t)v74);
  if (v112)
  {
    if (v113 > 64)
    {
      v116 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
      unint64_t v117 = lazy protocol witness table accessor for type Int and conformance Int(v113, v114, v115);
      v118 = v144;
LABEL_55:
      ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v116)(v118, &type metadata for Int, v117, a3, v74);
      char v121 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v74 + 4) + 8) + 16))(v30, v111, a3);
      int64_t v122 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      if (v121) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      v122(v111, a3);
      goto LABEL_57;
    }
  }
  else if (v113 > 63)
  {
    uint64_t v143 = 0x7FFFFFFFFFFFFFFFLL;
    v116 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
    unint64_t v117 = lazy protocol witness table accessor for type Int and conformance Int(v113, v114, v115);
    v118 = &v143;
    goto LABEL_55;
  }
  v126(v30, v111, a3);
  (*((void (**)(uint64_t, uint64_t (*)(uint64_t, uint64_t)))v74 + 15))(a3, v74);
  v120 = (void (*)(char *, uint64_t))v137;
  v137(v30, a3);
  v120(v111, a3);
LABEL_57:
  v123 = v140;
  unint64_t v124 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
  uint64_t result = v137(v123, a3);
  if ((v124 & 0x8000000000000000) != 0)
  {
    uint64_t v60 = v139;
    if (v124 <= 0xFFFFFFFFFFFFFFF0) {
      int v59 = (__int16)v138 >> 15;
    }
    else {
      int v59 = (__int16)v138 >> -(char)v124;
    }
  }
  else
  {
    uint64_t v60 = v139;
    if (v124 >= 0x10) {
      LOWORD(v59) = 0;
    }
    else {
      int v59 = v138 << v124;
    }
  }
LABEL_60:
  *uint64_t v60 = v59;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int16(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v121 = a1;
  uint64_t v111 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v111, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v109 = (char *)&v106 - v8;
  v9 = *(char **)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v12 = (char *)&v106 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  v107 = (char *)&v106 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v114 = (char *)&v106 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v113 = (char *)&v106 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  v108 = (char *)&v106 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v115 = (char *)&v106 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v119 = (char *)&v106 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v26 = (char *)&v106 - v25;
  uint64_t v28 = a4 + 64;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v27(a3, a4) & 1) == 0)
  {
    char v34 = v27(a3, a4);
    v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v29 = v120(a3, a4);
    if ((v34 & 1) == 0)
    {
      if (v29 < 64)
      {
        (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
        uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
        if (v38 < -16) {
          goto LABEL_15;
        }
      }
      goto LABEL_16;
    }
    if (v29 <= 64)
    {
      uint64_t v116 = a4 + 64;
      v118 = v27;
      char v39 = AssociatedTypeWitness;
      char v40 = v111;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v42 = v109;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v39, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v40[3])(v42, a3, v40);
      LOBYTE(v39) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
      uint64_t v43 = (void (*)(char *, uint64_t))*((void *)v9 + 1);
      v43(v26, a3);
      unint64_t v117 = v9;
      (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v12, a2, a3);
      if (v39)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v43)(v12, a3);
      }
      else
      {
        uint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v43)(v12, a3);
        v9 = v117;
        uint64_t v27 = v118;
        uint64_t v28 = v116;
        if (v44 >= -16) {
          goto LABEL_16;
        }
      }
LABEL_15:
      int v45 = (__int16)*v121 >> 15;
      goto LABEL_56;
    }
    goto LABEL_7;
  }
  v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v29 = v120(a3, a4);
  if (v29 >= 64)
  {
LABEL_7:
    int64_t v123 = -16;
    uint64_t v35 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v36 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
    v35(&v123, &type metadata for Int, v36, a3, a4);
    char v37 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
    if (v37) {
      goto LABEL_15;
    }
    goto LABEL_16;
  }
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
  if (v32 <= -17) {
    goto LABEL_15;
  }
LABEL_16:
  char v46 = v27(a3, a4);
  uint64_t v112 = a4 + 128;
  uint64_t v47 = v120(a3, a4);
  v118 = v27;
  uint64_t v116 = v28;
  if (v46)
  {
    if (v47 > 64) {
      goto LABEL_18;
    }
  }
  else if (v47 >= 64)
  {
LABEL_18:
    int64_t v123 = 16;
    uint64_t v50 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v51 = lazy protocol witness table accessor for type Int and conformance Int(v47, v48, v49);
    v50(&v123, &type metadata for Int, v51, a3, a4);
    char v52 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v26, a2, a3);
    __int16 v53 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
    uint64_t result = v53(v26, a3);
    if (v52) {
      goto LABEL_22;
    }
    goto LABEL_23;
  }
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  __int16 v53 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
  uint64_t result = v53(v26, a3);
  if (v54 > 16)
  {
LABEL_22:
    LOWORD(v45) = 0;
    goto LABEL_56;
  }
LABEL_23:
  v55 = v26;
  unint64_t v117 = (char *)v53;
  uint64_t v56 = v9 + 16;
  char v57 = (void (*)(char *, uint64_t, uint64_t))*((void *)v9 + 2);
  uint64_t v58 = v119;
  v57(v119, a2, a3);
  char v59 = v118(a3, a4);
  uint64_t v60 = v115;
  char v61 = v58;
  BOOL v106 = v56;
  uint64_t v62 = (void (*)(char *, char *, uint64_t))v57;
  v57(v115, (uint64_t)v61, a3);
  if ((v59 & 1) == 0)
  {
    ((void (*)(char *, uint64_t))v117)(v60, a3);
    v64 = v55;
    goto LABEL_40;
  }
  uint64_t v63 = v120(a3, a4);
  ((void (*)(char *, uint64_t))v117)(v60, a3);
  v64 = v55;
  uint64_t v65 = v118;
  if (v63 <= 64) {
    goto LABEL_40;
  }
  uint64_t v66 = v108;
  v62(v108, v119, a3);
  int64_t v123 = 0x8000000000000000;
  if (v65(a3, a4))
  {
    uint64_t v67 = v120(a3, a4);
    if (v67 >= 64)
    {
LABEL_31:
      unint64_t v71 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v67, v68, v69);
      v71(&v123, &type metadata for Int, v72, a3, a4);
      uint64_t v66 = v108;
      char v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v108, v64, a3);
      uint64_t v74 = v117;
      ((void (*)(char *, uint64_t))v117)(v64, a3);
      if (v73) {
        goto LABEL_61;
      }
      goto LABEL_39;
    }
LABEL_35:
    v62(v64, v66, a3);
    uint64_t v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v74 = v117;
    ((void (*)(char *, uint64_t))v117)(v64, a3);
    if (v75 < v123) {
LABEL_61:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_39;
  }
  char v70 = v65(a3, a4);
  uint64_t v67 = v120(a3, a4);
  if ((v70 & 1) == 0)
  {
    if (v67 >= 64)
    {
      ((void (*)(char *, uint64_t))v117)(v66, a3);
      goto LABEL_40;
    }
    goto LABEL_35;
  }
  if (v67 > 64) {
    goto LABEL_31;
  }
  uint64_t v77 = AssociatedTypeWitness;
  v76 = v111;
  uint64_t v78 = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v79 = v109;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v78 + 8))(&qword_18162B0B8, 256, v77, v78);
  ((void (*)(char *, uint64_t, int **))v76[3])(v79, a3, v76);
  uint64_t v80 = v108;
  char v81 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v108, v64, a3);
  uint64_t v82 = v117;
  ((void (*)(char *, uint64_t))v117)(v64, a3);
  int64_t v83 = v107;
  v62(v107, v80, a3);
  if (v81)
  {
    ((void (*)(char *, uint64_t))v82)(v83, a3);
    goto LABEL_61;
  }
  int64_t v84 = v123;
  uint64_t v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  ((void (*)(char *, uint64_t))v82)(v83, a3);
  BOOL v86 = v85 < v84;
  uint64_t v66 = v108;
  uint64_t v74 = v82;
  if (v86) {
    goto LABEL_61;
  }
LABEL_39:
  ((void (*)(char *, uint64_t))v74)(v66, a3);
LABEL_40:
  uint64_t v87 = v119;
  uint64_t v88 = v120;
  uint64_t v89 = v120(a3, a4);
  char v90 = v113;
  v62(v113, v87, a3);
  if (v89 < 65)
  {
    uint64_t v99 = v88(a3, a4);
    ((void (*)(char *, uint64_t))v117)(v90, a3);
    char v91 = v114;
    if (v99 != 64 || (v118(a3, a4) & 1) != 0) {
      goto LABEL_53;
    }
  }
  else
  {
    ((void (*)(char *, uint64_t))v117)(v90, a3);
    char v91 = v114;
  }
  v62(v91, v119, a3);
  int64_t v123 = 0x7FFFFFFFFFFFFFFFLL;
  char v92 = v118(a3, a4);
  uint64_t v93 = v120(a3, a4);
  if ((v92 & 1) == 0)
  {
    if (v93 >= 64)
    {
      uint64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v96 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v97 = lazy protocol witness table accessor for type Int and conformance Int(v93, v94, v95);
      uint64_t v98 = &v122;
      goto LABEL_51;
    }
LABEL_50:
    v62(v64, v91, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v100 = v117;
    ((void (*)(char *, uint64_t))v117)(v64, a3);
    ((void (*)(char *, uint64_t))v100)(v91, a3);
    goto LABEL_53;
  }
  if (v93 <= 64) {
    goto LABEL_50;
  }
  unint64_t v96 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v97 = lazy protocol witness table accessor for type Int and conformance Int(v93, v94, v95);
  uint64_t v98 = &v123;
LABEL_51:
  v96(v98, &type metadata for Int, v97, a3, a4);
  char v101 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v64, v91, a3);
  v102 = v117;
  ((void (*)(char *, uint64_t))v117)(v64, a3);
  if (v101) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  ((void (*)(char *, uint64_t))v102)(v91, a3);
LABEL_53:
  unint64_t v103 = v119;
  unint64_t v104 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v117)(v103, a3);
  int v105 = *v121;
  if ((v104 & 0x8000000000000000) == 0)
  {
    if (v104 < 0x10)
    {
      int v45 = v105 << v104;
      goto LABEL_56;
    }
    goto LABEL_22;
  }
  if (v104 <= 0xFFFFFFFFFFFFFFF0) {
    int v45 = (__int16)v105 >> 15;
  }
  else {
    int v45 = (__int16)v105 >> -(char)v104;
  }
LABEL_56:
  *char v121 = v45;
  return result;
}

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int16(_WORD *a1, _WORD *a2, __int16 *a3)
{
  uint64_t result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, *v3);
  *a1 = result;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance Int16(__int16 *a1)
{
  return specialized SignedInteger<>.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance Int16(_WORD *a1@<X8>)
{
  *a1 = (*v1 > 0) | (unsigned __int16)(*v1 >> 15);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int16(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt16(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, uint64_t (*a4)(void *, uint64_t, uint64_t)@<X5>, uint64_t a5@<X8>)
{
  uint64_t v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0) {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v7)
  {
    int v10 = a3();
    if ((v10 & 0x1000000) != 0) {
      int v10 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10, a4);
    }
    swift_bridgeObjectRelease(a2);
    unsigned int v11 = (v10 & 0x10000u) >> 16;
    if ((v10 & 0x10000) != 0) {
      __int16 v12 = 0;
    }
    else {
      __int16 v12 = v10;
    }
  }
  else
  {
    swift_bridgeObjectRelease(a2);
    __int16 v12 = 0;
    LOBYTE(v11) = 1;
  }
  *(_WORD *)a5 = v12;
  *(unsigned char *)(a5 + 2) = v11 & 1;
}

__int16 *protocol witness for static SignedNumeric.- prefix(_:) in conformance Int16@<X0>(__int16 *result@<X0>, _WORD *a2@<X8>)
{
  int v2 = *result;
  if (v2 + (__int16)-*result) {
    __break(1u);
  }
  else {
    *a2 = -(__int16)v2;
  }
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance Int16()
{
  int v1 = *v0;
  if (v1 + (__int16)-*v0) {
    __break(1u);
  }
  else {
    __int16 *v0 = -(__int16)v1;
  }
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int16@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v103 = a4;
  uint64_t v110 = a5;
  uint64_t v99 = *(int ***)(*(void *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v99, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v97 = (char *)&v96 - v9;
  uint64_t v10 = *(void *)(a2 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  char v100 = (char *)&v96 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  char v101 = (char *)&v96 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v96 - v16;
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  v108 = (char *)&v96 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  BOOL v106 = (char *)&v96 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (char *)&v96 - v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v26 = (char *)&v96 - v25;
  uint64_t v109 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v27 = v109(a2, a3);
  uint64_t v112 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  v112(v26, a1, a2);
  v107 = v17;
  BOOL v28 = (v27 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 16;
  uint64_t v102 = v10;
  uint64_t v29 = *(void (**)(char *, uint64_t))(v10 + 8);
  v29(v26, a2);
  v112(v24, a1, a2);
  uint64_t v113 = a1;
  uint64_t v111 = v29;
  uint64_t v105 = a3 + 64;
  if (!v28)
  {
    v29(v24, a2);
    uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v32 = (a3 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    goto LABEL_10;
  }
  __int16 v114 = 0x8000;
  uint64_t v30 = v109;
  if ((v109(a2, a3) & 1) == 0)
  {
    char v56 = v30(a2, a3);
    uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    unint64_t v104 = (void (*)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t))((a3 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000);
    uint64_t v57 = v31(a2, a3);
    if (v56)
    {
      if (v57 > 16)
      {
        uint64_t v60 = *(void (**)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
        unint64_t v61 = lazy protocol witness table accessor for type Int16 and conformance Int16(v57, v58, v59);
        uint64_t v62 = v31;
        uint64_t v63 = v106;
        v60(&v114, v103, v61, a2, a3);
        char v64 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v24, v63, a2);
        uint64_t v65 = v63;
        uint64_t v31 = v62;
        char v37 = v111;
        v111(v65, a2);
        v37(v24, a2);
        uint64_t v38 = v110;
        uint64_t v32 = (uint64_t)v104;
        if (v64) {
          goto LABEL_39;
        }
        goto LABEL_10;
      }
      unint64_t v96 = v31;
      uint64_t v88 = AssociatedTypeWitness;
      uint64_t v87 = v99;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v99, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v90 = v97;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v88, AssociatedConformanceWitness);
      char v91 = v106;
      ((void (*)(char *, uint64_t, int **))v87[3])(v90, a2, v87);
      LOBYTE(v87) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v24, v91, a2);
      char v37 = v111;
      v111(v91, a2);
      char v92 = v100;
      (*(void (**)(char *, char *, uint64_t))(v102 + 32))(v100, v24, a2);
      if (v87)
      {
        v37(v92, a2);
        uint64_t v38 = v110;
        goto LABEL_39;
      }
      int v93 = v114;
      __int16 v94 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      char v37 = v111;
      __int16 v95 = v94;
      v111(v92, a2);
      BOOL v79 = v93 <= v95;
      uint64_t v38 = v110;
      uint64_t v31 = v96;
    }
    else
    {
      if (v57 >= 16)
      {
        v111(v24, a2);
        uint64_t v32 = (uint64_t)v104;
        goto LABEL_10;
      }
      __int16 v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      char v37 = v111;
      v111(v24, a2);
      BOOL v79 = v114 <= v78;
      uint64_t v38 = v110;
    }
    uint64_t v32 = (uint64_t)v104;
    if (v79) {
      goto LABEL_10;
    }
LABEL_39:
    uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v37)(v113, a2);
    __int16 v70 = 0;
    char v72 = 1;
    goto LABEL_40;
  }
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v32 = (a3 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
  uint64_t v33 = v31(a2, a3);
  if (v33 >= 16)
  {
    unint64_t v104 = *(void (**)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v73 = lazy protocol witness table accessor for type Int16 and conformance Int16(v33, v34, v35);
    uint64_t v74 = v31;
    uint64_t v75 = v106;
    v104(&v114, v103, v73, a2, a3);
    char v76 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v24, v75, a2);
    uint64_t v77 = v75;
    uint64_t v31 = v74;
    char v37 = v111;
    v111(v77, a2);
    v37(v24, a2);
    uint64_t v38 = v110;
    if (v76) {
      goto LABEL_39;
    }
  }
  else
  {
    __int16 v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    char v37 = v111;
    v111(v24, a2);
    uint64_t v38 = v110;
    if (v114 > v36) {
      goto LABEL_39;
    }
  }
LABEL_10:
  uint64_t v39 = v113;
  uint64_t v40 = v31(a2, a3);
  uint64_t v41 = v31;
  uint64_t v42 = v108;
  uint64_t v43 = v112;
  v112(v108, v39, a2);
  if (v40 >= 17)
  {
    unint64_t v104 = (void (*)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t))v32;
    v111(v42, a2);
    uint64_t v44 = v107;
    v43(v107, v39, a2);
    uint64_t v38 = v110;
    goto LABEL_14;
  }
  uint64_t v45 = v41(a2, a3);
  v111(v42, a2);
  if (v45 != 16)
  {
    uint64_t v44 = v107;
    v112(v107, v113, a2);
    uint64_t v38 = v110;
    goto LABEL_24;
  }
  unint64_t v104 = (void (*)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t))v32;
  char v46 = v109(a2, a3);
  uint64_t v44 = v107;
  v112(v107, v113, a2);
  uint64_t v38 = v110;
  if (v46)
  {
LABEL_24:
    uint64_t v67 = v44;
    goto LABEL_25;
  }
LABEL_14:
  v116[0] = 0x7FFF;
  char v47 = v109(a2, a3);
  uint64_t v48 = v41(a2, a3);
  if (v47)
  {
    if (v48 > 16)
    {
      unint64_t v51 = *(void (**)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v52 = lazy protocol witness table accessor for type Int16 and conformance Int16(v48, v49, v50);
      __int16 v53 = v106;
      v51(v116, v103, v52, a2, a3);
      char v54 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v53, v44, a2);
      char v37 = v111;
      v111(v53, a2);
      v55 = v44;
      goto LABEL_33;
    }
    goto LABEL_22;
  }
  if (v48 <= 15)
  {
LABEL_22:
    uint64_t v66 = v106;
    (*(void (**)(char *, char *, uint64_t))(v102 + 32))(v106, v44, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    uint64_t v67 = v66;
LABEL_25:
    char v37 = v111;
    v111(v67, a2);
    goto LABEL_26;
  }
  __int16 v115 = 0x7FFF;
  uint64_t v80 = v106;
  uint64_t v81 = (*(uint64_t (**)(char *, char *, uint64_t))(v102 + 32))(v106, v44, a2);
  uint64_t v82 = *(void (**)(__int16 *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
  unint64_t v85 = lazy protocol witness table accessor for type Int16 and conformance Int16(v81, v83, v84);
  BOOL v86 = v101;
  v82(&v115, v103, v85, a2, a3);
  char v54 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v86, v80, a2);
  char v37 = v111;
  v111(v86, a2);
  v55 = v80;
LABEL_33:
  v37(v55, a2);
  if (v54) {
    goto LABEL_39;
  }
LABEL_26:
  uint64_t v68 = (uint64_t (*)(uint64_t, uint64_t))v37;
  uint64_t v69 = v113;
  __int16 v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = v68(v69, a2);
  char v72 = 0;
LABEL_40:
  *(_WORD *)uint64_t v38 = v70;
  *(unsigned char *)(v38 + 2) = v72;
  return result;
}

void protocol witness for Numeric.magnitude.getter in conformance Int16(_WORD *a1@<X8>)
{
  int v2 = *v1;
  if (v2 < 0) {
    int v2 = -v2;
  }
  *a1 = v2;
}

__int16 *protocol witness for static Numeric.* infix(_:_:) in conformance Int16@<X0>(__int16 *result@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = *result * *a2;
  if ((__int16)(*result * *a2) == v3) {
    *a3 = v3;
  }
  else {
    __break(1u);
  }
  return result;
}

uint64_t static Int16.* infix(_:_:)(__int16 a1, __int16 a2)
{
  uint64_t result = (a1 * a2);
  if ((__int16)(a1 * a2) != result) {
    __break(1u);
  }
  return result;
}

__int16 *protocol witness for static Numeric.*= infix(_:_:) in conformance Int16(__int16 *result, __int16 *a2)
{
  int v2 = *result * *a2;
  if ((__int16)(*result * *a2) == v2) {
    *uint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Int16()
{
  return _int64ToString(_:radix:uppercase:)(*v0, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
}

unsigned __int16 *protocol witness for Strideable.distance(to:) in conformance Int16@<X0>(unsigned __int16 *result@<X0>, uint64_t *a2@<X8>)
{
  int v3 = *result;
  int v4 = *v2;
  if (((v4 ^ v3) & 0x8000) == 0)
  {
    int v5 = (__int16)v3 - v4;
    if ((__int16)v5 == v5)
    {
      *a2 = (__int16)v5;
      return result;
    }
    __break(1u);
    goto LABEL_15;
  }
  if (v4 >= 0) {
    LOWORD(v6) = *v2;
  }
  else {
    int v6 = -v4;
  }
  if ((v3 & 0x8000u) != 0) {
    int v3 = -(__int16)v3;
  }
  int v7 = (unsigned __int16)v6 + (unsigned __int16)v3;
  if ((v7 & 0x10000) != 0)
  {
LABEL_15:
    __break(1u);
    return result;
  }
  if (v4 < 0) {
    uint64_t v8 = (unsigned __int16)v7;
  }
  else {
    uint64_t v8 = -(uint64_t)(unsigned __int16)v7;
  }
  *a2 = v8;
  return result;
}

void *protocol witness for Strideable.advanced(by:) in conformance Int16@<X0>(void *result@<X0>, _WORD *a2@<X8>)
{
  uint64_t v3 = *v2;
  uint64_t v4 = v3 + *result;
  if (__OFADD__(v3, *result))
  {
    __break(1u);
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  if (v4 <= -32769) {
    goto LABEL_6;
  }
  if (v4 >= 0x8000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  *a2 = v4;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int16(uint64_t a1, uint64_t a2, char a3, unsigned __int16 *a4, unsigned __int16 *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt16(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt16(uint64_t a1, uint64_t a2, char a3, unsigned __int16 *a4, unsigned __int16 *a5, void *a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, void, void, void, void))
{
  return a9(a1, a2, a3 & 1, *a4, *a5, *a6);
}

__int16 *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Int16@<X0>(__int16 *result@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = *result + *a2;
  if ((__int16)(*result + *a2) == v3) {
    *a3 = v3;
  }
  else {
    __break(1u);
  }
  return result;
}

uint64_t static Int16.+ infix(_:_:)(__int16 a1, __int16 a2)
{
  uint64_t result = (a1 + a2);
  if ((__int16)result != result) {
    __break(1u);
  }
  return result;
}

__int16 *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Int16(__int16 *result, __int16 *a2)
{
  int v2 = *result + *a2;
  if ((__int16)(*result + *a2) == v2) {
    *uint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

__int16 *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Int16@<X0>(__int16 *result@<X0>, __int16 *a2@<X1>, _WORD *a3@<X8>)
{
  int v3 = *result - *a2;
  if ((__int16)(*result - *a2) == v3) {
    *a3 = v3;
  }
  else {
    __break(1u);
  }
  return result;
}

uint64_t static Int16.- infix(_:_:)(__int16 a1, __int16 a2)
{
  uint64_t result = (a1 - a2);
  if ((__int16)result != result) {
    __break(1u);
  }
  return result;
}

__int16 *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Int16(__int16 *result, __int16 *a2)
{
  int v2 = *result - *a2;
  if ((__int16)(*result - *a2) == v2) {
    *uint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Int16(__int16 *a1, __int16 *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Int16(__int16 *a1, __int16 *a2)
{
  return *a2 >= *a1;
}

BOOL static Int16.<= infix(_:_:)(__int16 a1, __int16 a2)
{
  return a2 >= a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Int16(__int16 *a1, __int16 *a2)
{
  return *a1 >= *a2;
}

BOOL static Int16.>= infix(_:_:)(__int16 a1, __int16 a2)
{
  return a1 >= a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Int16(__int16 *a1, __int16 *a2)
{
  return *a2 < *a1;
}

void Int16.hash(into:)(int a1, Swift::UInt16 a2)
{
}

Swift::Int __swiftcall Int16._rawHashValue(seed:)(Swift::Int seed)
{
  return specialized static Hasher._hash(seed:bytes:count:)(seed, v1, 2);
}

uint64_t Int16.hashValue.getter(unsigned __int16 a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0, a1, 2);
}

void protocol witness for Hashable.hash(into:) in conformance Int16()
{
  Hasher._combine(_:)(*v0);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Int16(uint64_t a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(a1, *v1, 2);
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance Int16(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a1 == *a2;
}

uint64_t Int16._toCustomAnyHashable()@<X0>(__int16 a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int16>);
  *(void *)(a2 + 24) = result;
  *(void *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_WORD *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Int16@<X0>(uint64_t a1@<X8>)
{
  __int16 v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int16>);
  *(void *)(a1 + 24) = result;
  *(void *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_WORD *)a1 = v3;
  return result;
}

uint64_t UInt32._value.setter(uint64_t result)
{
  _DWORD *v1 = result;
  return result;
}

uint64_t (*UInt32._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.init(_:)(float a1)
{
  if ((~LODWORD(a1) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt32 because it is either infinite or NaN", 80, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1858uLL, 0);
  }
  if (*(short float *)&a1 <= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(-1.0))) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt32 because the result would be less than UInt32.min", 92, 2, "Swift/IntegerTypes.swift", 24, 2, 0x185BuLL, 0);
  }
  return *(short float *)&a1;
}

unint64_t UInt32.init(exactly:)(float a1)
{
  BOOL v1 = truncl(*(short float *)&a1) != *(short float *)&a1;
  int v2 = (~LODWORD(a1) & 0x7C00) == 0 || v1;
  uint64_t v3 = *(short float *)&a1;
  if (v2) {
    uint64_t v3 = 0;
  }
  if (*(short float *)&a1 > COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(-1.0)))
  {
    unsigned __int8 v4 = v2;
  }
  else
  {
    uint64_t v3 = 0;
    unsigned __int8 v4 = 1;
  }
  return v3 | ((unint64_t)v4 << 32);
}

Swift::UInt32 __swiftcall UInt32.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt32 because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0x18A6uLL, 0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt32 because the result would be less than UInt32.min", 90, 2, "Swift/IntegerTypes.swift", 24, 2, 0x18A9uLL, 0);
  }
  if (a1 >= 4295000000.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt32 because the result would be greater than UInt32.max", 93, 2, "Swift/IntegerTypes.swift", 24, 2, 0x18ACuLL, 0);
  }
  return a1;
}

Swift::UInt32_optional __swiftcall UInt32.init(exactly:)(Swift::Float exactly)
{
  BOOL v1 = exactly > -1.0;
  if (exactly >= 4295000000.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (truncf(exactly) == exactly);
  BOOL v2 = v3 == 0;
  uint64_t v4 = (v3 & 1) == 0;
  if (v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = exactly;
  }
  return (Swift::UInt32_optional)(v5 | (v4 << 32));
}

Swift::UInt32 __swiftcall UInt32.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt32 because it is either infinite or NaN", 79, 2, "Swift/IntegerTypes.swift", 24, 2, 0x18EEuLL, 0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt32 because the result would be less than UInt32.min", 91, 2, "Swift/IntegerTypes.swift", 24, 2, 0x18F1uLL, 0);
  }
  if (a1 >= 4294967300.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt32 because the result would be greater than UInt32.max", 94, 2, "Swift/IntegerTypes.swift", 24, 2, 0x18F4uLL, 0);
  }
  return a1;
}

Swift::UInt32_optional __swiftcall UInt32.init(exactly:)(Swift::Double exactly)
{
  BOOL v1 = exactly > -1.0;
  if (exactly >= 4294967300.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (trunc(exactly) == exactly);
  BOOL v2 = v3 == 0;
  uint64_t v4 = (v3 & 1) == 0;
  if (v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = exactly;
  }
  return (Swift::UInt32_optional)(v5 | (v4 << 32));
}

unsigned int *static UInt32.-= infix(_:_:)(unsigned int *result, unsigned int a2)
{
  if (*result < a2) {
    __break(1u);
  }
  else {
    *result -= a2;
  }
  return result;
}

_DWORD *static UInt32.*= infix(_:_:)(_DWORD *result, unsigned int a2)
{
  unint64_t v2 = *result * (unint64_t)a2;
  if ((v2 & 0xFFFFFFFF00000000) != 0) {
    __break(1u);
  }
  else {
    *uint64_t result = v2;
  }
  return result;
}

_DWORD *static UInt32./= infix(_:_:)(_DWORD *result, unsigned int a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x19E2uLL, 0);
  }
  *result /= a2;
  return result;
}

Swift::tuple_partialValue_UInt32_overflow_Bool __swiftcall UInt32.subtractingReportingOverflow(_:)(Swift::UInt32 a1)
{
  Swift::UInt32 v2 = v1 - a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt32_overflow_Bool __swiftcall UInt32.multipliedReportingOverflow(by:)(Swift::UInt32 by)
{
  Swift::UInt32 v2 = v1 * by;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt32_overflow_Bool __swiftcall UInt32.dividedReportingOverflow(by:)(Swift::UInt32 by)
{
  if (by) {
    v1 /= by;
  }
  Swift::UInt32 v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_UInt32_overflow_Bool __swiftcall UInt32.remainderReportingOverflow(dividingBy:)(Swift::UInt32 dividingBy)
{
  if (dividingBy) {
    v1 %= dividingBy;
  }
  Swift::UInt32 v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

_DWORD *static UInt32.%= infix(_:_:)(_DWORD *result, unsigned int a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1AB6uLL, 0);
  }
  *result %= a2;
  return result;
}

uint64_t UInt32._lowWord.getter(uint64_t result)
{
  return result;
}

uint64_t UInt32.Words._value.setter(uint64_t result)
{
  _DWORD *v1 = result;
  return result;
}

uint64_t (*UInt32.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.Words.count.getter()
{
  return 1;
}

uint64_t UInt32.Words.startIndex.getter()
{
  return 0;
}

uint64_t UInt32.Words.endIndex.getter()
{
  return 1;
}

uint64_t UInt32.Words.indices.getter()
{
  return 0;
}

uint64_t UInt32.Words.subscript.getter(uint64_t a1, unsigned int a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative word index", 19, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1BB3uLL, 0);
  }
  if (a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Word index out of range", 23, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1BB4uLL, 0);
  }
  return a2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt32.Words(uint64_t *a1, uint64_t *a2))()
{
  *a1 = UInt32.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance UInt32.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UInt32.Words(uint64_t a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

Swift::tuple_high_UInt32_low_UInt32 __swiftcall UInt32.multipliedFullWidth(by:)(Swift::UInt32 by)
{
  Swift::UInt32 v2 = __ROR8__(v1 * (unint64_t)by, 32);
  result.low = v1;
  result.high = v2;
  return result;
}

Swift::tuple_quotient_UInt32_remainder_UInt32 __swiftcall UInt32.dividingFullWidth(_:)(Swift::tuple_quotient_UInt32_remainder_UInt32 result)
{
  if (!v1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1C19uLL, 0);
  }
  if (result.quotient >= v1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Quotient is not representable", 29, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1C1BuLL, 0);
  }
  Swift::UInt32 v3 = (result.remainder | (__PAIR64__(v2, result.quotient) << 32)) / v1;
  result.quotient = v3;
  return result;
}

Swift::UInt32 __swiftcall UInt32.signum()()
{
  return v0 != 0;
}

uint64_t protocol witness for static FixedWidthInteger.bitWidth.getter in conformance UInt32()
{
  return 32;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance UInt32(_DWORD *a1@<X8>)
{
  *a1 = -1;
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance UInt32(_DWORD *a1, _DWORD *a2)
{
  BOOL v3 = __CFADD__(*v2, *a2);
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance UInt32(_DWORD *a1, _DWORD *a2)
{
  BOOL v3 = *v2 < *a2;
  *a1 = *v2 - *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance UInt32(_DWORD *a1, unsigned int *a2)
{
  unint64_t v3 = *v2 * (unint64_t)*a2;
  *a1 = v3;
  return (v3 & 0xFFFFFFFF00000000) != 0;
}

BOOL protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance UInt32(_DWORD *a1, unsigned int *a2)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *v2;
  if (*a2) {
    v4 /= v3;
  }
  *a1 = v4;
  return v3 == 0;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance UInt32(_DWORD *a1, unsigned int *a2)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *v2;
  if (*a2) {
    v4 %= v3;
  }
  *a1 = v4;
  return v3 == 0;
}

_DWORD *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance UInt32(_DWORD *result, _DWORD *a2, unsigned int *a3)
{
  unint64_t v4 = *v3 * (unint64_t)*a3;
  *Swift::tuple_high_UInt32_low_UInt32 result = HIDWORD(v4);
  *a2 = v4;
  return result;
}

Swift::UInt32 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt32(Swift::UInt32 *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  Swift::UInt32 result = UInt32.dividingFullWidth(_:)((Swift::tuple_high_UInt32_low_UInt32)__PAIR64__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

_DWORD *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance UInt32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *result >> *a2;
  return result;
}

_DWORD *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance UInt32(_DWORD *result, _DWORD *a2)
{
  *result >>= *a2;
  return result;
}

_DWORD *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance UInt32@<X0>(_DWORD *result@<X0>, unint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  if (a2 >> 9 <= 0x10 && (a2 & 1) == 0) {
    *a3 = *result;
  }
  else {
    *a3 = 0;
  }
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt32@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _DWORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt32(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt32 and conformance UInt32, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _DWORD *a6@<X8>)
{
  uint64_t v53 = a4;
  uint64_t v54 = a5;
  uint64_t v57 = *(int ***)(*(void *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v57, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v55 = (char *)&v49 - v11;
  uint64_t v61 = *(void *)(a2 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  unint64_t v52 = (char *)&v49 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v60 = (char *)&v49 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v49 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v49 - v19;
  uint64_t v21 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v22 = v21(a2, a3);
  uint64_t v58 = a1;
  uint64_t v59 = a6;
  if (v22)
  {
    uint64_t v23 = v61;
    (*(void (**)(char *, uint64_t, uint64_t))(v61 + 16))(v20, a1, a2);
    uint64_t v25 = AssociatedTypeWitness;
    uint64_t v24 = v57;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v57, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    char v27 = v55;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v25, AssociatedConformanceWitness);
    ((void (*)(char *, uint64_t, int **))v24[3])(v27, a2, v24);
    LOBYTE(v25) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 32))(v20, v18, a2);
    BOOL v28 = *(void (**)(char *, uint64_t))(v23 + 8);
    v28(v18, a2);
    if ((v25 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
    }
    v28(v20, a2);
    a1 = v58;
  }
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  if (v29(a2, a3) >= 32)
  {
    unint64_t v51 = v18;
    uint64_t v50 = *(void (**)(char *, uint64_t, uint64_t))(v61 + 16);
    v50(v60, a1, a2);
    unsigned int v62 = -1;
    char v30 = v21(a2, a3);
    uint64_t v31 = v29(a2, a3);
    if (v30)
    {
      uint64_t v32 = v51;
      if (v31 < 33)
      {
        __int16 v36 = AssociatedTypeWitness;
        char v37 = v57;
        uint64_t v38 = swift_getAssociatedConformanceWitness((uint64_t)v57, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v39 = v55;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v38 + 8))(&qword_18162B0B8, 256, v36, v38);
        ((void (*)(char *, uint64_t, int **))v37[3])(v39, a2, v37);
        uint64_t v40 = v60;
        LOBYTE(v36) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 40))(v60, v32, a2);
        uint64_t v34 = *(void (**)(char *, uint64_t))(v61 + 8);
        v34(v32, a2);
        unsigned int v41 = v62;
        uint64_t v42 = v52;
        v50(v52, (uint64_t)v40, a2);
        if (v36)
        {
          unsigned int v43 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v34(v42, a2);
          if (v41 < v43) {
LABEL_20:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
        }
        else
        {
          v34(v42, a2);
        }
        goto LABEL_16;
      }
      (*(void (**)(unsigned int *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v62, v53, v54, a2, a3);
      char v33 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v32, v60, a2);
      uint64_t v34 = *(void (**)(char *, uint64_t))(v61 + 8);
      v34(v32, a2);
    }
    else
    {
      uint64_t v35 = v51;
      if (v31 <= 32)
      {
        v50(v51, (uint64_t)v60, a2);
        unsigned int v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        uint64_t v34 = *(void (**)(char *, uint64_t))(v61 + 8);
        v34(v35, a2);
        if (v62 < v44) {
          goto LABEL_20;
        }
LABEL_16:
        v34(v60, a2);
        a1 = v58;
        goto LABEL_17;
      }
      (*(void (**)(unsigned int *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v62, v53, v54, a2, a3);
      char v33 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v35, v60, a2);
      uint64_t v34 = *(void (**)(char *, uint64_t))(v61 + 8);
      v34(v35, a2);
    }
    if (v33) {
      goto LABEL_20;
    }
    goto LABEL_16;
  }
LABEL_17:
  int v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t v46 = a1;
  int v47 = v45;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v61 + 8))(v46, a2);
  *uint64_t v59 = v47;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance UInt32()
{
  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance UInt32()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

_DWORD *protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x19E2uLL, 0);
  }
  *a3 = *result / *a2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt32(_DWORD *result, _DWORD *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x19E2uLL, 0);
  }
  *result /= *a2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1AB6uLL, 0);
  }
  *a3 = *result % *a2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt32(_DWORD *result, _DWORD *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1AB6uLL, 0);
  }
  *result %= *a2;
  return result;
}

uint64_t static UInt32.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance UInt32@<X0>(unsigned int *a1@<X0>, void (*a2)(void, void)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned int *a5@<X8>)
{
  uint64_t v5 = a4;
  v141 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v141, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v139 = (char *)&v133 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v133 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  v136 = (char *)&v133 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v144 = (char *)&v133 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  char v22 = (char *)&v133 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  v137 = (char *)&v133 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v145 = (char *)&v133 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  v149 = (char *)&v133 - v28;
  MEMORY[0x1F4188790](v27);
  v151 = (char *)&v133 - v29;
  unsigned int v143 = *a1;
  char v30 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 64);
  uint64_t v150 = v5 + 64;
  char v31 = v30(a3, v5);
  v147 = a5;
  if (v31)
  {
    uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
    uint64_t v146 = (v5 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v33 = v32(a3, v5);
    if (v33 >= 64)
    {
      v153[0] = -32;
      uint64_t v49 = v151;
      v148 = v32;
      uint64_t v50 = v22;
      unint64_t v51 = v30;
      uint64_t v52 = v12;
      uint64_t v53 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
      unint64_t v54 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v53(v153, &type metadata for Int, v54, a3, v5);
      uint64_t v12 = v52;
      char v30 = v51;
      char v22 = v50;
      uint64_t v32 = v148;
      char v55 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                                            + 16))(a2, v49, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v49, a3);
      if (v55) {
        goto LABEL_28;
      }
    }
    else
    {
      __int16 v36 = v151;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v151, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v36, a3);
      if (v37 < -32) {
        goto LABEL_28;
      }
    }
  }
  else
  {
    char v39 = v30(a3, v5);
    uint64_t v40 = *(uint64_t (**)(void, void))(v5 + 128);
    uint64_t v146 = (v5 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    int v138 = a2;
    v148 = v40;
    uint64_t v41 = v40(a3, v5);
    if (v39)
    {
      uint64_t v142 = v30;
      if (v41 <= 64)
      {
        uint64_t v58 = AssociatedTypeWitness;
        uint64_t v59 = v141;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v61 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v58, AssociatedConformanceWitness);
        unsigned int v62 = v151;
        ((void (*)(char *, uint64_t, int **))v59[3])(v61, a3, v59);
        uint64_t v63 = v138;
        LOBYTE(v58) = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v138, v62, a3);
        char v64 = *(void (**)(char *, uint64_t))(v12 + 8);
        v64(v62, a3);
        uint64_t v133 = v12;
        (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v15, v63, a3);
        if (v58)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v64)(v15, a3);
          goto LABEL_28;
        }
        uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v64)(v15, a3);
        uint64_t v12 = v133;
        char v30 = v142;
        uint64_t v32 = v148;
        a2 = v138;
        if (v65 < -32) {
          goto LABEL_28;
        }
      }
      else
      {
        v153[0] = -32;
        uint64_t v44 = v12;
        int v45 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
        unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
        int v47 = v151;
        v45(v153, &type metadata for Int, v46, a3, v5);
        uint64_t v12 = v44;
        a2 = v138;
        char v48 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                                              + 16))(v138, v47, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v44 + 8))(v47, a3);
        char v30 = v142;
        uint64_t v32 = v148;
        if (v48) {
          goto LABEL_28;
        }
      }
    }
    else if (v41 >= 64)
    {
      uint64_t v32 = v148;
      a2 = v138;
    }
    else
    {
      char v56 = v151;
      a2 = v138;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v151, v138, a3);
      uint64_t v57 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v56, a3);
      uint64_t v32 = v148;
      if (v57 < -32) {
        goto LABEL_28;
      }
    }
  }
  uint64_t v142 = v30;
  char v66 = v30(a3, v5);
  uint64_t v67 = a2;
  uint64_t v68 = v32(a3, v5);
  v134 = v22;
  if (v66)
  {
    if (v68 > 64) {
      goto LABEL_20;
    }
  }
  else if (v68 > 63)
  {
LABEL_20:
    v153[0] = 32;
    unint64_t v71 = v151;
    uint64_t v72 = v12;
    unint64_t v73 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
    unint64_t v74 = lazy protocol witness table accessor for type Int and conformance Int(v68, v69, v70);
    v73(v153, &type metadata for Int, v74, a3, v5);
    uint64_t v12 = v72;
    char v75 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v71, (char *)v67, a3);
    int v138 = *(void (**)(void, void))(v72 + 8);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v71, a3);
    if ((v75 & 1) == 0) {
      goto LABEL_21;
    }
    goto LABEL_28;
  }
  int v93 = v151;
  (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v151, a2, a3);
  uint64_t v94 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
  int v138 = *(void (**)(void, void))(v12 + 8);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v93, a3);
  if (v94 <= 32)
  {
LABEL_21:
    v148 = v32;
    uint64_t v76 = v12;
    uint64_t v77 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
    __int16 v78 = v149;
    v77(v149, (char *)v67, a3);
    BOOL v79 = v142;
    char v80 = v142(a3, v5);
    uint64_t v81 = v145;
    v135 = v77;
    v77(v145, v78, a3);
    uint64_t v133 = v12;
    if ((v80 & 1) == 0)
    {
      v138(v81, a3);
      uint64_t v87 = v79;
      uint64_t v88 = v148;
      goto LABEL_41;
    }
    uint64_t v82 = v5;
    uint64_t v83 = v5;
    uint64_t v84 = v148;
    uint64_t v85 = v148(a3, v82);
    v138(v81, a3);
    BOOL v86 = v84;
    uint64_t v5 = v83;
    uint64_t v87 = v79;
    uint64_t v88 = v86;
    if (v85 <= 64) {
      goto LABEL_41;
    }
    v145 = (char *)(v76 + 8);
    uint64_t v89 = v137;
    v135(v137, v149, a3);
    v153[0] = 0x8000000000000000;
    if (v87(a3, v83))
    {
      uint64_t v90 = v88(a3, v83);
      if (v90 < 64)
      {
LABEL_36:
        uint64_t v105 = v151;
        v135(v151, v89, a3);
        uint64_t v106 = (*(uint64_t (**)(uint64_t, uint64_t))(v83 + 120))(a3, v83);
        unint64_t v104 = (void (*)(char *, uint64_t))v138;
        v138(v105, a3);
        if (v106 < v153[0]) {
LABEL_63:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_40;
      }
    }
    else
    {
      char v97 = v87(a3, v83);
      uint64_t v90 = v88(a3, v83);
      if ((v97 & 1) == 0)
      {
        if (v90 >= 64)
        {
          v138(v89, a3);
          goto LABEL_41;
        }
        goto LABEL_36;
      }
      if (v90 <= 64)
      {
        v108 = AssociatedTypeWitness;
        v107 = v141;
        uint64_t v109 = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v110 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v109 + 8))(&qword_18162B0B8, 256, v108, v109);
        uint64_t v111 = v151;
        ((void (*)(char *, uint64_t, int **))v107[3])(v110, a3, v107);
        LODWORD(v141) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                           + 16))(v89, v111, a3);
        unint64_t v104 = (void (*)(char *, uint64_t))v138;
        v138(v111, a3);
        uint64_t v112 = v136;
        v135(v136, v89, a3);
        if (v141)
        {
          v104(v112, a3);
          goto LABEL_63;
        }
        v141 = (int **)v153[0];
        uint64_t v113 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
        v104(v112, a3);
        BOOL v114 = v113 < (uint64_t)v141;
        uint64_t v88 = v148;
        if (v114) {
          goto LABEL_63;
        }
LABEL_40:
        v104(v89, a3);
LABEL_41:
        __int16 v115 = v149;
        uint64_t v116 = v88(a3, v5);
        unint64_t v117 = v134;
        v135(v134, v115, a3);
        if (v116 < 65)
        {
          uint64_t v127 = v88(a3, v5);
          v118 = (uint64_t (*)(char *, uint64_t))v138;
          v138(v117, a3);
          uint64_t v119 = v144;
          if (v127 != 64 || (v87(a3, v5) & 1) != 0)
          {
LABEL_54:
            v131 = v149;
            unint64_t v132 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
            uint64_t result = v118(v131, a3);
            if ((v132 & 0x8000000000000000) != 0)
            {
              unint64_t v96 = v147;
              if (v132 > 0xFFFFFFFFFFFFFFE0)
              {
                unsigned int v95 = v143 << -(char)v132;
                goto LABEL_57;
              }
            }
            else
            {
              unint64_t v96 = v147;
              if (v132 < 0x20)
              {
                unsigned int v95 = v143 >> v132;
                goto LABEL_57;
              }
            }
            unsigned int v95 = 0;
            goto LABEL_57;
          }
        }
        else
        {
          v118 = (uint64_t (*)(char *, uint64_t))v138;
          v138(v117, a3);
          uint64_t v119 = v144;
        }
        v135(v119, v149, a3);
        v153[0] = 0x7FFFFFFFFFFFFFFFLL;
        char v120 = v87(a3, v5);
        uint64_t v121 = v88(a3, v5);
        if (v120)
        {
          if (v121 > 64)
          {
            unint64_t v124 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
            unint64_t v125 = lazy protocol witness table accessor for type Int and conformance Int(v121, v122, v123);
            v126 = v153;
            goto LABEL_52;
          }
        }
        else if (v121 > 63)
        {
          uint64_t v152 = 0x7FFFFFFFFFFFFFFFLL;
          unint64_t v124 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
          unint64_t v125 = lazy protocol witness table accessor for type Int and conformance Int(v121, v122, v123);
          v126 = &v152;
LABEL_52:
          v129 = v151;
          v124(v126, &type metadata for Int, v125, a3, v5);
          char v130 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v129, v119, a3);
          v118(v129, a3);
          if (v130) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
          }
          goto LABEL_53;
        }
        uint64_t v128 = v151;
        v135(v151, v119, a3);
        (*(void (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
        v118(v128, a3);
LABEL_53:
        v118(v119, a3);
        goto LABEL_54;
      }
    }
    uint64_t v98 = v151;
    uint64_t v99 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v83 + 96);
    unint64_t v100 = lazy protocol witness table accessor for type Int and conformance Int(v90, v91, v92);
    v99(v153, &type metadata for Int, v100, a3, v5);
    char v101 = v98;
    uint64_t v89 = v137;
    uint64_t v88 = v148;
    char v102 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v137, v101, a3);
    uint64_t v103 = v101;
    unint64_t v104 = (void (*)(char *, uint64_t))v138;
    v138(v103, a3);
    if (v102) {
      goto LABEL_63;
    }
    goto LABEL_40;
  }
LABEL_28:
  unsigned int v95 = 0;
  unint64_t v96 = v147;
LABEL_57:
  *unint64_t v96 = v95;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance UInt32(unsigned int *a1, void (*a2)(void, void), uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  v141 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v141, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v139 = (char *)&v132 - v9;
  uint64_t v10 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v132 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  v136 = (char *)&v132 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  unsigned int v143 = (char *)&v132 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v132 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  v137 = (char *)&v132 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  v144 = (char *)&v132 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v148 = (char *)&v132 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v150 = (char *)&v132 - v27;
  uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 64);
  uint64_t v149 = v4 + 64;
  char v29 = v28(a3, v4);
  uint64_t v146 = a1;
  if (v29)
  {
    char v30 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 128);
    uint64_t v145 = (v4 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v31 = v30(a3, v4);
    if (v31 >= 64)
    {
      v152[0] = -32;
      int v47 = v150;
      v147 = v30;
      char v48 = v20;
      uint64_t v49 = v28;
      uint64_t v50 = v10;
      unint64_t v51 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
      unint64_t v52 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
      v51(v152, &type metadata for Int, v52, a3, v4);
      uint64_t v10 = v50;
      uint64_t v28 = v49;
      uint64_t v20 = v48;
      char v30 = v147;
      char v53 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                                            + 16))(a2, v47, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v47, a3);
      if (v53) {
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v34 = v150;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, a2, a3);
      uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v34, a3);
      if (v35 < -32) {
        goto LABEL_28;
      }
    }
  }
  else
  {
    char v37 = v28(a3, v4);
    uint64_t v38 = *(uint64_t (**)(void, void))(v4 + 128);
    uint64_t v145 = (v4 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    int v138 = a2;
    v147 = v38;
    uint64_t v39 = v38(a3, v4);
    if (v37)
    {
      uint64_t v142 = v28;
      if (v39 <= 64)
      {
        char v56 = AssociatedTypeWitness;
        uint64_t v57 = v141;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v59 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v56, AssociatedConformanceWitness);
        uint64_t v60 = v150;
        ((void (*)(char *, uint64_t, int **))v57[3])(v59, a3, v57);
        uint64_t v61 = v138;
        LOBYTE(v56) = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v138, v60, a3);
        unsigned int v62 = *(void (**)(char *, uint64_t))(v10 + 8);
        v62(v60, a3);
        uint64_t v133 = v10;
        (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v13, v61, a3);
        if (v56)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v62)(v13, a3);
          goto LABEL_28;
        }
        uint64_t v63 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v62)(v13, a3);
        uint64_t v10 = v133;
        uint64_t v28 = v142;
        char v30 = v147;
        a2 = v138;
        if (v63 < -32) {
          goto LABEL_28;
        }
      }
      else
      {
        v152[0] = -32;
        uint64_t v42 = v10;
        uint64_t v43 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
        unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        int v45 = v150;
        v43(v152, &type metadata for Int, v44, a3, v4);
        uint64_t v10 = v42;
        a2 = v138;
        char v46 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                                              + 16))(v138, v45, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v42 + 8))(v45, a3);
        uint64_t v28 = v142;
        char v30 = v147;
        if (v46) {
          goto LABEL_28;
        }
      }
    }
    else if (v39 >= 64)
    {
      char v30 = v147;
      a2 = v138;
    }
    else
    {
      unint64_t v54 = v150;
      a2 = v138;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, v138, a3);
      uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v54, a3);
      char v30 = v147;
      if (v55 < -32) {
        goto LABEL_28;
      }
    }
  }
  uint64_t v142 = v28;
  char v64 = v28(a3, v4);
  uint64_t v65 = a2;
  uint64_t v66 = v30(a3, v4);
  v134 = v20;
  if (v64)
  {
    if (v66 > 64) {
      goto LABEL_20;
    }
  }
  else if (v66 >= 64)
  {
LABEL_20:
    v152[0] = 32;
    uint64_t v69 = v150;
    uint64_t v70 = v10;
    unint64_t v71 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v71(v152, &type metadata for Int, v72, a3, v4);
    uint64_t v10 = v70;
    char v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v69, (char *)v65, a3);
    int v138 = *(void (**)(void, void))(v70 + 8);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v69, a3);
    if ((v73 & 1) == 0) {
      goto LABEL_21;
    }
    goto LABEL_28;
  }
  uint64_t v91 = v150;
  (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, a2, a3);
  uint64_t v92 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
  int v138 = *(void (**)(void, void))(v10 + 8);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v91, a3);
  if (v92 <= 32)
  {
LABEL_21:
    v147 = v30;
    uint64_t v74 = v10;
    char v75 = *(void (**)(char *, char *, uint64_t))(v10 + 16);
    uint64_t v76 = v148;
    v75(v148, (char *)v65, a3);
    uint64_t v77 = v142;
    char v78 = v142(a3, v4);
    BOOL v79 = v144;
    v135 = v75;
    v75(v144, v76, a3);
    uint64_t v133 = v10;
    if ((v78 & 1) == 0)
    {
      v138(v79, a3);
      uint64_t v85 = v77;
      BOOL v86 = v147;
      goto LABEL_41;
    }
    uint64_t v80 = v4;
    uint64_t v81 = v4;
    uint64_t v82 = v147;
    uint64_t v83 = v147(a3, v80);
    v138(v79, a3);
    uint64_t v84 = v82;
    uint64_t v4 = v81;
    uint64_t v85 = v77;
    BOOL v86 = v84;
    if (v83 <= 64) {
      goto LABEL_41;
    }
    v144 = (char *)(v74 + 8);
    uint64_t v87 = v137;
    v135(v137, v148, a3);
    v152[0] = 0x8000000000000000;
    if (v85(a3, v81))
    {
      uint64_t v88 = v86(a3, v81);
      if (v88 < 64)
      {
LABEL_36:
        uint64_t v103 = v150;
        v135(v150, v87, a3);
        uint64_t v104 = (*(uint64_t (**)(uint64_t, uint64_t))(v81 + 120))(a3, v81);
        char v102 = (void (*)(char *, uint64_t))v138;
        v138(v103, a3);
        if (v104 < v152[0]) {
LABEL_63:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_40;
      }
    }
    else
    {
      char v95 = v85(a3, v81);
      uint64_t v88 = v86(a3, v81);
      if ((v95 & 1) == 0)
      {
        if (v88 >= 64)
        {
          v138(v87, a3);
          goto LABEL_41;
        }
        goto LABEL_36;
      }
      if (v88 <= 64)
      {
        uint64_t v106 = AssociatedTypeWitness;
        uint64_t v105 = v141;
        uint64_t v107 = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v108 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v107 + 8))(&qword_18162B0B8, 256, v106, v107);
        uint64_t v109 = v150;
        ((void (*)(char *, uint64_t, int **))v105[3])(v108, a3, v105);
        LODWORD(v141) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                           + 16))(v87, v109, a3);
        char v102 = (void (*)(char *, uint64_t))v138;
        v138(v109, a3);
        uint64_t v110 = v136;
        v135(v136, v87, a3);
        if (v141)
        {
          v102(v110, a3);
          goto LABEL_63;
        }
        v141 = (int **)v152[0];
        uint64_t v111 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
        v102(v110, a3);
        BOOL v112 = v111 < (uint64_t)v141;
        BOOL v86 = v147;
        if (v112) {
          goto LABEL_63;
        }
LABEL_40:
        v102(v87, a3);
LABEL_41:
        uint64_t v113 = v148;
        uint64_t v114 = v86(a3, v4);
        __int16 v115 = v134;
        v135(v134, v113, a3);
        if (v114 < 65)
        {
          uint64_t v125 = v86(a3, v4);
          uint64_t v116 = (uint64_t (*)(char *, uint64_t))v138;
          v138(v115, a3);
          unint64_t v117 = v143;
          if (v125 != 64 || (v85(a3, v4) & 1) != 0)
          {
LABEL_54:
            v129 = v148;
            unint64_t v130 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
            uint64_t result = v116(v129, a3);
            uint64_t v94 = v146;
            unsigned int v131 = *v146;
            if ((v130 & 0x8000000000000000) != 0)
            {
              if (v130 >= 0xFFFFFFFFFFFFFFE1)
              {
                unsigned int v93 = v131 << -(char)v130;
                goto LABEL_57;
              }
            }
            else if (v130 < 0x20)
            {
              unsigned int v93 = v131 >> v130;
              goto LABEL_57;
            }
            unsigned int v93 = 0;
            goto LABEL_57;
          }
        }
        else
        {
          uint64_t v116 = (uint64_t (*)(char *, uint64_t))v138;
          v138(v115, a3);
          unint64_t v117 = v143;
        }
        v135(v117, v148, a3);
        v152[0] = 0x7FFFFFFFFFFFFFFFLL;
        char v118 = v85(a3, v4);
        uint64_t v119 = v86(a3, v4);
        if (v118)
        {
          if (v119 > 64)
          {
            uint64_t v122 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
            unint64_t v123 = lazy protocol witness table accessor for type Int and conformance Int(v119, v120, v121);
            unint64_t v124 = v152;
            goto LABEL_52;
          }
        }
        else if (v119 >= 64)
        {
          uint64_t v151 = 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v122 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
          unint64_t v123 = lazy protocol witness table accessor for type Int and conformance Int(v119, v120, v121);
          unint64_t v124 = &v151;
LABEL_52:
          uint64_t v127 = v150;
          v122(v124, &type metadata for Int, v123, a3, v4);
          char v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v127, v117, a3);
          v116(v127, a3);
          if (v128) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
          }
          goto LABEL_53;
        }
        v126 = v150;
        v135(v150, v117, a3);
        (*(void (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
        v116(v126, a3);
LABEL_53:
        v116(v117, a3);
        goto LABEL_54;
      }
    }
    unint64_t v96 = v150;
    char v97 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v81 + 96);
    unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v88, v89, v90);
    v97(v152, &type metadata for Int, v98, a3, v4);
    uint64_t v99 = v96;
    uint64_t v87 = v137;
    BOOL v86 = v147;
    char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v137, v99, a3);
    char v101 = v99;
    char v102 = (void (*)(char *, uint64_t))v138;
    v138(v101, a3);
    if (v100) {
      goto LABEL_63;
    }
    goto LABEL_40;
  }
LABEL_28:
  unsigned int v93 = 0;
  uint64_t v94 = v146;
LABEL_57:
  *uint64_t v94 = v93;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt32@<X0>(unsigned int *a1@<X0>, void (*a2)(void, void)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned int *a5@<X8>)
{
  uint64_t v5 = a4;
  v141 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v141, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v139 = (char *)&v133 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v133 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  v136 = (char *)&v133 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v144 = (char *)&v133 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)&v133 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  v137 = (char *)&v133 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v145 = (char *)&v133 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v149 = (char *)&v133 - v28;
  MEMORY[0x1F4188790](v27);
  uint64_t v151 = (char *)&v133 - v29;
  unsigned int v143 = *a1;
  char v30 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 64);
  uint64_t v150 = v5 + 64;
  char v31 = v30(a3, v5);
  v147 = a5;
  if (v31)
  {
    uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
    uint64_t v146 = (v5 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v33 = v32(a3, v5);
    if (v33 >= 64)
    {
      v153[0] = -32;
      uint64_t v49 = v151;
      v148 = v32;
      uint64_t v50 = v22;
      unint64_t v51 = v30;
      uint64_t v52 = v12;
      char v53 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
      unint64_t v54 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v53(v153, &type metadata for Int, v54, a3, v5);
      uint64_t v12 = v52;
      char v30 = v51;
      uint64_t v22 = v50;
      uint64_t v32 = v148;
      char v55 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                                            + 16))(a2, v49, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v49, a3);
      if (v55) {
        goto LABEL_28;
      }
    }
    else
    {
      __int16 v36 = v151;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v151, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v36, a3);
      if (v37 < -32) {
        goto LABEL_28;
      }
    }
  }
  else
  {
    char v39 = v30(a3, v5);
    uint64_t v40 = *(uint64_t (**)(void, void))(v5 + 128);
    uint64_t v146 = (v5 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    int v138 = a2;
    v148 = v40;
    uint64_t v41 = v40(a3, v5);
    if (v39)
    {
      uint64_t v142 = v30;
      if (v41 <= 64)
      {
        uint64_t v58 = AssociatedTypeWitness;
        uint64_t v59 = v141;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v61 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v58, AssociatedConformanceWitness);
        unsigned int v62 = v151;
        ((void (*)(char *, uint64_t, int **))v59[3])(v61, a3, v59);
        uint64_t v63 = v138;
        LOBYTE(v58) = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v138, v62, a3);
        char v64 = *(void (**)(char *, uint64_t))(v12 + 8);
        v64(v62, a3);
        uint64_t v133 = v12;
        (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v15, v63, a3);
        if (v58)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v64)(v15, a3);
          goto LABEL_28;
        }
        uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v64)(v15, a3);
        uint64_t v12 = v133;
        char v30 = v142;
        uint64_t v32 = v148;
        a2 = v138;
        if (v65 < -32) {
          goto LABEL_28;
        }
      }
      else
      {
        v153[0] = -32;
        uint64_t v44 = v12;
        int v45 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
        unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
        int v47 = v151;
        v45(v153, &type metadata for Int, v46, a3, v5);
        uint64_t v12 = v44;
        a2 = v138;
        char v48 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                                              + 16))(v138, v47, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v44 + 8))(v47, a3);
        char v30 = v142;
        uint64_t v32 = v148;
        if (v48) {
          goto LABEL_28;
        }
      }
    }
    else if (v41 >= 64)
    {
      uint64_t v32 = v148;
      a2 = v138;
    }
    else
    {
      char v56 = v151;
      a2 = v138;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v151, v138, a3);
      uint64_t v57 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v56, a3);
      uint64_t v32 = v148;
      if (v57 < -32) {
        goto LABEL_28;
      }
    }
  }
  uint64_t v142 = v30;
  char v66 = v30(a3, v5);
  uint64_t v67 = a2;
  uint64_t v68 = v32(a3, v5);
  v134 = v22;
  if (v66)
  {
    if (v68 > 64) {
      goto LABEL_20;
    }
  }
  else if (v68 > 63)
  {
LABEL_20:
    v153[0] = 32;
    unint64_t v71 = v151;
    uint64_t v72 = v12;
    char v73 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
    unint64_t v74 = lazy protocol witness table accessor for type Int and conformance Int(v68, v69, v70);
    v73(v153, &type metadata for Int, v74, a3, v5);
    uint64_t v12 = v72;
    char v75 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v71, (char *)v67, a3);
    int v138 = *(void (**)(void, void))(v72 + 8);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v71, a3);
    if ((v75 & 1) == 0) {
      goto LABEL_21;
    }
    goto LABEL_28;
  }
  unsigned int v93 = v151;
  (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v151, a2, a3);
  uint64_t v94 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
  int v138 = *(void (**)(void, void))(v12 + 8);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v93, a3);
  if (v94 <= 32)
  {
LABEL_21:
    v148 = v32;
    uint64_t v76 = v12;
    uint64_t v77 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
    char v78 = v149;
    v77(v149, (char *)v67, a3);
    BOOL v79 = v142;
    char v80 = v142(a3, v5);
    uint64_t v81 = v145;
    v135 = v77;
    v77(v145, v78, a3);
    uint64_t v133 = v12;
    if ((v80 & 1) == 0)
    {
      v138(v81, a3);
      uint64_t v87 = v79;
      uint64_t v88 = v148;
      goto LABEL_41;
    }
    uint64_t v82 = v5;
    uint64_t v83 = v5;
    uint64_t v84 = v148;
    uint64_t v85 = v148(a3, v82);
    v138(v81, a3);
    BOOL v86 = v84;
    uint64_t v5 = v83;
    uint64_t v87 = v79;
    uint64_t v88 = v86;
    if (v85 <= 64) {
      goto LABEL_41;
    }
    uint64_t v145 = (char *)(v76 + 8);
    uint64_t v89 = v137;
    v135(v137, v149, a3);
    v153[0] = 0x8000000000000000;
    if (v87(a3, v83))
    {
      uint64_t v90 = v88(a3, v83);
      if (v90 < 64)
      {
LABEL_36:
        uint64_t v105 = v151;
        v135(v151, v89, a3);
        uint64_t v106 = (*(uint64_t (**)(uint64_t, uint64_t))(v83 + 120))(a3, v83);
        uint64_t v104 = (void (*)(char *, uint64_t))v138;
        v138(v105, a3);
        if (v106 < v153[0]) {
LABEL_63:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_40;
      }
    }
    else
    {
      char v97 = v87(a3, v83);
      uint64_t v90 = v88(a3, v83);
      if ((v97 & 1) == 0)
      {
        if (v90 >= 64)
        {
          v138(v89, a3);
          goto LABEL_41;
        }
        goto LABEL_36;
      }
      if (v90 <= 64)
      {
        v108 = AssociatedTypeWitness;
        uint64_t v107 = v141;
        uint64_t v109 = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v110 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v109 + 8))(&qword_18162B0B8, 256, v108, v109);
        uint64_t v111 = v151;
        ((void (*)(char *, uint64_t, int **))v107[3])(v110, a3, v107);
        LODWORD(v141) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                           + 16))(v89, v111, a3);
        uint64_t v104 = (void (*)(char *, uint64_t))v138;
        v138(v111, a3);
        BOOL v112 = v136;
        v135(v136, v89, a3);
        if (v141)
        {
          v104(v112, a3);
          goto LABEL_63;
        }
        v141 = (int **)v153[0];
        uint64_t v113 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
        v104(v112, a3);
        BOOL v114 = v113 < (uint64_t)v141;
        uint64_t v88 = v148;
        if (v114) {
          goto LABEL_63;
        }
LABEL_40:
        v104(v89, a3);
LABEL_41:
        __int16 v115 = v149;
        uint64_t v116 = v88(a3, v5);
        unint64_t v117 = v134;
        v135(v134, v115, a3);
        if (v116 < 65)
        {
          uint64_t v127 = v88(a3, v5);
          char v118 = (uint64_t (*)(char *, uint64_t))v138;
          v138(v117, a3);
          uint64_t v119 = v144;
          if (v127 != 64 || (v87(a3, v5) & 1) != 0)
          {
LABEL_54:
            unsigned int v131 = v149;
            unint64_t v132 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
            uint64_t result = v118(v131, a3);
            if ((v132 & 0x8000000000000000) != 0)
            {
              unint64_t v96 = v147;
              if (v132 > 0xFFFFFFFFFFFFFFE0)
              {
                unsigned int v95 = v143 >> -(char)v132;
                goto LABEL_57;
              }
            }
            else
            {
              unint64_t v96 = v147;
              if (v132 <= 0x1F)
              {
                unsigned int v95 = v143 << v132;
                goto LABEL_57;
              }
            }
            unsigned int v95 = 0;
            goto LABEL_57;
          }
        }
        else
        {
          char v118 = (uint64_t (*)(char *, uint64_t))v138;
          v138(v117, a3);
          uint64_t v119 = v144;
        }
        v135(v119, v149, a3);
        v153[0] = 0x7FFFFFFFFFFFFFFFLL;
        char v120 = v87(a3, v5);
        uint64_t v121 = v88(a3, v5);
        if (v120)
        {
          if (v121 > 64)
          {
            unint64_t v124 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
            unint64_t v125 = lazy protocol witness table accessor for type Int and conformance Int(v121, v122, v123);
            v126 = v153;
            goto LABEL_52;
          }
        }
        else if (v121 > 63)
        {
          uint64_t v152 = 0x7FFFFFFFFFFFFFFFLL;
          unint64_t v124 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
          unint64_t v125 = lazy protocol witness table accessor for type Int and conformance Int(v121, v122, v123);
          v126 = &v152;
LABEL_52:
          v129 = v151;
          v124(v126, &type metadata for Int, v125, a3, v5);
          char v130 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v129, v119, a3);
          v118(v129, a3);
          if (v130) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
          }
          goto LABEL_53;
        }
        char v128 = v151;
        v135(v151, v119, a3);
        (*(void (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
        v118(v128, a3);
LABEL_53:
        v118(v119, a3);
        goto LABEL_54;
      }
    }
    unint64_t v98 = v151;
    uint64_t v99 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v83 + 96);
    unint64_t v100 = lazy protocol witness table accessor for type Int and conformance Int(v90, v91, v92);
    v99(v153, &type metadata for Int, v100, a3, v5);
    char v101 = v98;
    uint64_t v89 = v137;
    uint64_t v88 = v148;
    char v102 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v137, v101, a3);
    uint64_t v103 = v101;
    uint64_t v104 = (void (*)(char *, uint64_t))v138;
    v138(v103, a3);
    if (v102) {
      goto LABEL_63;
    }
    goto LABEL_40;
  }
LABEL_28:
  unsigned int v95 = 0;
  unint64_t v96 = v147;
LABEL_57:
  *unint64_t v96 = v95;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance UInt32(unsigned int *a1, void (*a2)(void, void), uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  v141 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v141, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v139 = (char *)&v132 - v9;
  uint64_t v10 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v132 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  v136 = (char *)&v132 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  unsigned int v143 = (char *)&v132 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v132 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  v137 = (char *)&v132 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  v144 = (char *)&v132 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v148 = (char *)&v132 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v150 = (char *)&v132 - v27;
  uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 64);
  uint64_t v149 = v4 + 64;
  char v29 = v28(a3, v4);
  uint64_t v146 = a1;
  if (v29)
  {
    char v30 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 128);
    uint64_t v145 = (v4 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v31 = v30(a3, v4);
    if (v31 >= 64)
    {
      v152[0] = -32;
      int v47 = v150;
      v147 = v30;
      char v48 = v20;
      uint64_t v49 = v28;
      uint64_t v50 = v10;
      unint64_t v51 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
      unint64_t v52 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
      v51(v152, &type metadata for Int, v52, a3, v4);
      uint64_t v10 = v50;
      uint64_t v28 = v49;
      uint64_t v20 = v48;
      char v30 = v147;
      char v53 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                                            + 16))(a2, v47, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v47, a3);
      if (v53) {
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v34 = v150;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, a2, a3);
      uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v34, a3);
      if (v35 < -32) {
        goto LABEL_28;
      }
    }
  }
  else
  {
    char v37 = v28(a3, v4);
    uint64_t v38 = *(uint64_t (**)(void, void))(v4 + 128);
    uint64_t v145 = (v4 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    int v138 = a2;
    v147 = v38;
    uint64_t v39 = v38(a3, v4);
    if (v37)
    {
      uint64_t v142 = v28;
      if (v39 <= 64)
      {
        char v56 = AssociatedTypeWitness;
        uint64_t v57 = v141;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v59 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v56, AssociatedConformanceWitness);
        uint64_t v60 = v150;
        ((void (*)(char *, uint64_t, int **))v57[3])(v59, a3, v57);
        uint64_t v61 = v138;
        LOBYTE(v56) = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v138, v60, a3);
        unsigned int v62 = *(void (**)(char *, uint64_t))(v10 + 8);
        v62(v60, a3);
        uint64_t v133 = v10;
        (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v13, v61, a3);
        if (v56)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v62)(v13, a3);
          goto LABEL_28;
        }
        uint64_t v63 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v62)(v13, a3);
        uint64_t v10 = v133;
        uint64_t v28 = v142;
        char v30 = v147;
        a2 = v138;
        if (v63 < -32) {
          goto LABEL_28;
        }
      }
      else
      {
        v152[0] = -32;
        uint64_t v42 = v10;
        uint64_t v43 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
        unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        int v45 = v150;
        v43(v152, &type metadata for Int, v44, a3, v4);
        uint64_t v10 = v42;
        a2 = v138;
        char v46 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                                              + 16))(v138, v45, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v42 + 8))(v45, a3);
        uint64_t v28 = v142;
        char v30 = v147;
        if (v46) {
          goto LABEL_28;
        }
      }
    }
    else if (v39 >= 64)
    {
      char v30 = v147;
      a2 = v138;
    }
    else
    {
      unint64_t v54 = v150;
      a2 = v138;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, v138, a3);
      uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v54, a3);
      char v30 = v147;
      if (v55 < -32) {
        goto LABEL_28;
      }
    }
  }
  uint64_t v142 = v28;
  char v64 = v28(a3, v4);
  uint64_t v65 = a2;
  uint64_t v66 = v30(a3, v4);
  v134 = v20;
  if (v64)
  {
    if (v66 > 64) {
      goto LABEL_20;
    }
  }
  else if (v66 >= 64)
  {
LABEL_20:
    v152[0] = 32;
    uint64_t v69 = v150;
    uint64_t v70 = v10;
    unint64_t v71 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v71(v152, &type metadata for Int, v72, a3, v4);
    uint64_t v10 = v70;
    char v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v69, (char *)v65, a3);
    int v138 = *(void (**)(void, void))(v70 + 8);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v69, a3);
    if ((v73 & 1) == 0) {
      goto LABEL_21;
    }
    goto LABEL_28;
  }
  uint64_t v91 = v150;
  (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, a2, a3);
  uint64_t v92 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
  int v138 = *(void (**)(void, void))(v10 + 8);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v91, a3);
  if (v92 <= 32)
  {
LABEL_21:
    v147 = v30;
    uint64_t v74 = v10;
    char v75 = *(void (**)(char *, char *, uint64_t))(v10 + 16);
    uint64_t v76 = v148;
    v75(v148, (char *)v65, a3);
    uint64_t v77 = v142;
    char v78 = v142(a3, v4);
    BOOL v79 = v144;
    v135 = v75;
    v75(v144, v76, a3);
    uint64_t v133 = v10;
    if ((v78 & 1) == 0)
    {
      v138(v79, a3);
      uint64_t v85 = v77;
      BOOL v86 = v147;
      goto LABEL_41;
    }
    uint64_t v80 = v4;
    uint64_t v81 = v4;
    uint64_t v82 = v147;
    uint64_t v83 = v147(a3, v80);
    v138(v79, a3);
    uint64_t v84 = v82;
    uint64_t v4 = v81;
    uint64_t v85 = v77;
    BOOL v86 = v84;
    if (v83 <= 64) {
      goto LABEL_41;
    }
    v144 = (char *)(v74 + 8);
    uint64_t v87 = v137;
    v135(v137, v148, a3);
    v152[0] = 0x8000000000000000;
    if (v85(a3, v81))
    {
      uint64_t v88 = v86(a3, v81);
      if (v88 < 64)
      {
LABEL_36:
        uint64_t v103 = v150;
        v135(v150, v87, a3);
        uint64_t v104 = (*(uint64_t (**)(uint64_t, uint64_t))(v81 + 120))(a3, v81);
        char v102 = (void (*)(char *, uint64_t))v138;
        v138(v103, a3);
        if (v104 < v152[0]) {
LABEL_63:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_40;
      }
    }
    else
    {
      char v95 = v85(a3, v81);
      uint64_t v88 = v86(a3, v81);
      if ((v95 & 1) == 0)
      {
        if (v88 >= 64)
        {
          v138(v87, a3);
          goto LABEL_41;
        }
        goto LABEL_36;
      }
      if (v88 <= 64)
      {
        uint64_t v106 = AssociatedTypeWitness;
        uint64_t v105 = v141;
        uint64_t v107 = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v108 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v107 + 8))(&qword_18162B0B8, 256, v106, v107);
        uint64_t v109 = v150;
        ((void (*)(char *, uint64_t, int **))v105[3])(v108, a3, v105);
        LODWORD(v141) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                           + 16))(v87, v109, a3);
        char v102 = (void (*)(char *, uint64_t))v138;
        v138(v109, a3);
        uint64_t v110 = v136;
        v135(v136, v87, a3);
        if (v141)
        {
          v102(v110, a3);
          goto LABEL_63;
        }
        v141 = (int **)v152[0];
        uint64_t v111 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
        v102(v110, a3);
        BOOL v112 = v111 < (uint64_t)v141;
        BOOL v86 = v147;
        if (v112) {
          goto LABEL_63;
        }
LABEL_40:
        v102(v87, a3);
LABEL_41:
        uint64_t v113 = v148;
        uint64_t v114 = v86(a3, v4);
        __int16 v115 = v134;
        v135(v134, v113, a3);
        if (v114 < 65)
        {
          uint64_t v125 = v86(a3, v4);
          uint64_t v116 = (uint64_t (*)(char *, uint64_t))v138;
          v138(v115, a3);
          unint64_t v117 = v143;
          if (v125 != 64 || (v85(a3, v4) & 1) != 0)
          {
LABEL_54:
            v129 = v148;
            unint64_t v130 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
            uint64_t result = v116(v129, a3);
            uint64_t v94 = v146;
            unsigned int v131 = *v146;
            if ((v130 & 0x8000000000000000) != 0)
            {
              if (v130 > 0xFFFFFFFFFFFFFFE0)
              {
                unsigned int v93 = v131 >> -(char)v130;
                goto LABEL_57;
              }
            }
            else if (v130 < 0x20)
            {
              unsigned int v93 = v131 << v130;
              goto LABEL_57;
            }
            unsigned int v93 = 0;
            goto LABEL_57;
          }
        }
        else
        {
          uint64_t v116 = (uint64_t (*)(char *, uint64_t))v138;
          v138(v115, a3);
          unint64_t v117 = v143;
        }
        v135(v117, v148, a3);
        v152[0] = 0x7FFFFFFFFFFFFFFFLL;
        char v118 = v85(a3, v4);
        uint64_t v119 = v86(a3, v4);
        if (v118)
        {
          if (v119 > 64)
          {
            uint64_t v122 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
            unint64_t v123 = lazy protocol witness table accessor for type Int and conformance Int(v119, v120, v121);
            unint64_t v124 = v152;
            goto LABEL_52;
          }
        }
        else if (v119 >= 64)
        {
          uint64_t v151 = 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v122 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
          unint64_t v123 = lazy protocol witness table accessor for type Int and conformance Int(v119, v120, v121);
          unint64_t v124 = &v151;
LABEL_52:
          uint64_t v127 = v150;
          v122(v124, &type metadata for Int, v123, a3, v4);
          char v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v127, v117, a3);
          v116(v127, a3);
          if (v128) {
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
          }
          goto LABEL_53;
        }
        v126 = v150;
        v135(v150, v117, a3);
        (*(void (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
        v116(v126, a3);
LABEL_53:
        v116(v117, a3);
        goto LABEL_54;
      }
    }
    unint64_t v96 = v150;
    char v97 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v81 + 96);
    unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v88, v89, v90);
    v97(v152, &type metadata for Int, v98, a3, v4);
    uint64_t v99 = v96;
    uint64_t v87 = v137;
    BOOL v86 = v147;
    char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v137, v99, a3);
    char v101 = v99;
    char v102 = (void (*)(char *, uint64_t))v138;
    v138(v101, a3);
    if (v100) {
      goto LABEL_63;
    }
    goto LABEL_40;
  }
LABEL_28:
  unsigned int v93 = 0;
  uint64_t v94 = v146;
LABEL_57:
  *uint64_t v94 = v93;
  return result;
}

int *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt32(int *result, int *a2, unsigned int *a3)
{
  unsigned int v4 = *a3;
  if (!*a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x19E2uLL, 0);
  }
  unsigned int v5 = *v3;
  *a2 = *v3 % v4;
  *uint64_t result = v5 / v4;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance UInt32(unsigned int *a1)
{
  return specialized BinaryInteger.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance UInt32(_DWORD *a1@<X8>)
{
  *a1 = *v1 != 0;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt32(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v63 = a4;
  uint64_t v5 = a3;
  uint64_t v69 = a5;
  uint64_t v8 = *(void *)(*(void *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v8, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v66 = (char *)&v59 - v11;
  uint64_t v12 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v61 = (char *)&v59 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v68 = (char *)&v59 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v59 - v18;
  MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v59 - v20;
  char v64 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 64);
  char v22 = v64(a2, v5);
  uint64_t v70 = a1;
  uint64_t v71 = v12;
  uint64_t v67 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v67(v21, a1, a2);
  if ((v22 & 1) == 0)
  {
    uint64_t v60 = v8;
    unsigned int v62 = v19;
    uint64_t v65 = *(void (**)(char *, uint64_t))(v71 + 8);
    v65(v21, a2);
    goto LABEL_6;
  }
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v8, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v24 = v66;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v8 + 24))(v24, a2, v8);
  char v25 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v21, v19, a2);
  uint64_t v59 = v5;
  uint64_t v26 = v19;
  uint64_t v27 = *(void (**)(char *, uint64_t))(v71 + 8);
  v27(v26, a2);
  v27(v21, a2);
  if ((v25 & 1) == 0)
  {
    uint64_t v60 = v8;
    unsigned int v62 = v26;
    uint64_t v65 = v27;
    uint64_t v5 = v59;
LABEL_6:
    uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
    uint64_t v33 = v70;
    uint64_t v34 = v32(a2, v5);
    uint64_t v35 = v68;
    v67(v68, v33, a2);
    if (v34 <= 31)
    {
      __int16 v36 = (uint64_t (*)(uint64_t, uint64_t))v65;
      v65(v35, a2);
      uint64_t v31 = v69;
LABEL_8:
      int v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5);
      uint64_t result = v36(v33, a2);
      char v30 = 0;
      goto LABEL_19;
    }
    unsigned int v72 = -1;
    char v37 = v64(a2, v5);
    uint64_t v38 = v32(a2, v5);
    uint64_t v41 = v35;
    if (v37)
    {
      if (v38 < 33)
      {
        uint64_t v42 = v60;
        uint64_t v43 = swift_getAssociatedConformanceWitness(v60, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v44 = v66;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v43 + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, v43);
        int v45 = v62;
        (*(void (**)(char *, uint64_t, uint64_t))(v42 + 24))(v44, a2, v42);
        LOBYTE(v42) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 40))(v41, v45, a2);
        uint64_t v46 = v71;
        int v47 = v45;
        char v48 = v41;
        __int16 v36 = (uint64_t (*)(uint64_t, uint64_t))v65;
        v65(v47, a2);
        unsigned int v49 = v72;
        uint64_t v50 = v61;
        (*(void (**)(char *, char *, uint64_t))(v46 + 32))(v61, v48, a2);
        if ((v42 & 1) == 0)
        {
          v36((uint64_t)v50, a2);
          uint64_t v31 = v69;
          uint64_t v33 = v70;
          goto LABEL_8;
        }
        unsigned int v51 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5);
        v36((uint64_t)v50, a2);
        BOOL v52 = v49 >= v51;
LABEL_17:
        uint64_t v31 = v69;
        uint64_t v33 = v70;
        if (v52) {
          goto LABEL_8;
        }
        goto LABEL_18;
      }
    }
    else if (v38 < 33)
    {
      uint64_t v57 = v62;
      (*(void (**)(char *, char *, uint64_t))(v71 + 32))(v62, v35, a2);
      unsigned int v58 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a2, v5);
      __int16 v36 = (uint64_t (*)(uint64_t, uint64_t))v65;
      v65(v57, a2);
      BOOL v52 = v72 >= v58;
      goto LABEL_17;
    }
    char v53 = *(void (**)(unsigned int *, uint64_t, unint64_t, uint64_t, uint64_t))(v5 + 96);
    unint64_t v54 = lazy protocol witness table accessor for type UInt32 and conformance UInt32(v38, v39, v40);
    uint64_t v55 = v62;
    v53(&v72, v63, v54, a2, v5);
    char v56 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v55, v41, a2);
    __int16 v36 = (uint64_t (*)(uint64_t, uint64_t))v65;
    v65(v55, a2);
    v36((uint64_t)v41, a2);
    uint64_t v31 = v69;
    uint64_t v33 = v70;
    if ((v56 & 1) == 0) {
      goto LABEL_8;
    }
LABEL_18:
    uint64_t result = v36(v33, a2);
    int v29 = 0;
    char v30 = 1;
    goto LABEL_19;
  }
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v27)(v70, a2);
  int v29 = 0;
  char v30 = 1;
  uint64_t v31 = v69;
LABEL_19:
  *(_DWORD *)uint64_t v31 = v29;
  *(unsigned char *)(v31 + 4) = v30;
  return result;
}

unsigned int *protocol witness for static Numeric.* infix(_:_:) in conformance UInt32@<X0>(unsigned int *result@<X0>, unsigned int *a2@<X1>, _DWORD *a3@<X8>)
{
  unint64_t v3 = *result * (unint64_t)*a2;
  if ((v3 & 0xFFFFFFFF00000000) != 0) {
    __break(1u);
  }
  else {
    *a3 = v3;
  }
  return result;
}

unint64_t static UInt32.* infix(_:_:)(unsigned int a1, unsigned int a2)
{
  unint64_t result = a1 * (unint64_t)a2;
  if ((result & 0xFFFFFFFF00000000) != 0) {
    __break(1u);
  }
  return result;
}

_DWORD *protocol witness for static Numeric.*= infix(_:_:) in conformance UInt32(_DWORD *result, unsigned int *a2)
{
  unint64_t v2 = *result * (unint64_t)*a2;
  if ((v2 & 0xFFFFFFFF00000000) != 0) {
    __break(1u);
  }
  else {
    *unint64_t result = v2;
  }
  return result;
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance UInt32()
{
  return _uint64ToString(_:radix:uppercase:)(*v0, 10, 0)._countAndFlagsBits;
}

_DWORD *protocol witness for Strideable.distance(to:) in conformance UInt32@<X0>(_DWORD *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = (*result - *v2);
  if (*result < *v2) {
    uint64_t v3 = -(uint64_t)(*v2 - *result);
  }
  *a2 = v3;
  return result;
}

unint64_t *protocol witness for Strideable.advanced(by:) in conformance UInt32@<X0>(unint64_t *result@<X0>, unsigned int *a2@<X8>)
{
  unint64_t v3 = *result;
  unsigned int v4 = *v2;
  if ((*result & 0x8000000000000000) == 0)
  {
    if (HIDWORD(v3)) {
      goto LABEL_10;
    }
    BOOL v5 = __CFADD__(v4, v3);
    v4 += v3;
    if (!v5) {
      goto LABEL_9;
    }
    __break(1u);
  }
  unint64_t v6 = -(uint64_t)v3;
  if (HIDWORD(v6)) {
LABEL_10:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
  BOOL v5 = v4 >= v6;
  v4 -= v6;
  if (!v5)
  {
    __break(1u);
    return result;
  }
LABEL_9:
  *a2 = v4;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt32(uint64_t a1, uint64_t a2, char a3, unsigned int *a4, unsigned int *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt32(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

_DWORD *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance UInt32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  if (__CFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *a3 = *result + *a2;
  }
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance UInt32(_DWORD *result, _DWORD *a2)
{
  if (__CFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *result += *a2;
  }
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance UInt32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  if (*result < *a2) {
    __break(1u);
  }
  else {
    *a3 = *result - *a2;
  }
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance UInt32(_DWORD *result, _DWORD *a2)
{
  if (*result < *a2) {
    __break(1u);
  }
  else {
    *result -= *a2;
  }
  return result;
}

uint64_t UInt32.hashValue.getter(unsigned int a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0, a1, 4);
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance UInt32()
{
  return specialized static Hasher._hash(seed:bytes:count:)(0, *v0, 4);
}

uint64_t UInt32._toCustomAnyHashable()@<X0>(int a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt32>);
  *(void *)(a2 + 24) = result;
  *(void *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_DWORD *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance UInt32@<X0>(uint64_t a1@<X8>)
{
  int v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt32>);
  *(void *)(a1 + 24) = result;
  *(void *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_DWORD *)a1 = v3;
  return result;
}

uint64_t Int32._value.setter(uint64_t result)
{
  _DWORD *v1 = result;
  return result;
}

uint64_t (*Int32._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.init(_:)(float a1)
{
  if ((~LODWORD(a1) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to Int32 because it is either infinite or NaN", 79, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E43uLL, 0);
  }
  return (int)*(short float *)&a1;
}

uint64_t Int32.init(exactly:)(float a1)
{
  BOOL v1 = truncl(*(short float *)&a1) != *(short float *)&a1;
  int v2 = (~LODWORD(a1) & 0x7C00) == 0 || v1;
  uint64_t v3 = v2;
  if (v2) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = (int)*(short float *)&a1;
  }
  return v4 | (v3 << 32);
}

Swift::Int32 __swiftcall Int32.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int32 because it is either infinite or NaN", 77, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E8EuLL, 0);
  }
  if (a1 <= -2147500000.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int32 because the result would be less than Int32.min", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E91uLL, 0);
  }
  if (a1 >= 2147500000.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int32 because the result would be greater than Int32.max", 91, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1E94uLL, 0);
  }
  return (int)a1;
}

Swift::Int32_optional __swiftcall Int32.init(exactly:)(Swift::Float exactly)
{
  BOOL v1 = exactly > -2147500000.0;
  if (exactly >= 2147500000.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (truncf(exactly) == exactly);
  BOOL v2 = v3 == 0;
  uint64_t v4 = (v3 & 1) == 0;
  if (v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = (int)exactly;
  }
  return (Swift::Int32_optional)(v5 | (v4 << 32));
}

Swift::Int32 __swiftcall Int32.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int32 because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1ED6uLL, 0);
  }
  if (a1 <= -2147483650.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int32 because the result would be less than Int32.min", 89, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1ED9uLL, 0);
  }
  if (a1 >= 2147483650.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int32 because the result would be greater than Int32.max", 92, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1EDCuLL, 0);
  }
  return (int)a1;
}

Swift::Int32_optional __swiftcall Int32.init(exactly:)(Swift::Double exactly)
{
  BOOL v1 = exactly > -2147483650.0;
  if (exactly >= 2147483650.0) {
    BOOL v1 = 0;
  }
  int v3 = v1 & (trunc(exactly) == exactly);
  BOOL v2 = v3 == 0;
  uint64_t v4 = (v3 & 1) == 0;
  if (v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = (int)exactly;
  }
  return (Swift::Int32_optional)(v5 | (v4 << 32));
}

_DWORD *static Int32.-= infix(_:_:)(_DWORD *result, int a2)
{
  if (__OFSUB__(*result, a2)) {
    __break(1u);
  }
  else {
    *result -= a2;
  }
  return result;
}

int *static Int32.*= infix(_:_:)(int *result, int a2)
{
  uint64_t v2 = *result * (uint64_t)a2;
  if (v2 == (int)v2) {
    *uint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

int *static Int32./= infix(_:_:)(int *result, int a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FCAuLL, 0);
  }
  int v2 = *result;
  if (a2 == -1 && v2 == 0x80000000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FD1uLL, 0);
  }
  *uint64_t result = v2 / a2;
  return result;
}

Swift::tuple_partialValue_Int32_overflow_Bool __swiftcall Int32.addingReportingOverflow(_:)(Swift::Int32 a1)
{
  Swift::Int32 v2 = v1 + a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int32_overflow_Bool __swiftcall Int32.subtractingReportingOverflow(_:)(Swift::Int32 a1)
{
  Swift::Int32 v2 = v1 - a1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int32_overflow_Bool __swiftcall Int32.multipliedReportingOverflow(by:)(Swift::Int32 by)
{
  Swift::Int32 v2 = v1 * by;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int32_overflow_Bool __swiftcall Int32.dividedReportingOverflow(by:)(Swift::Int32 by)
{
  if (by)
  {
    if (by == -1 && v1 == 0x80000000) {
      signed int v1 = 0x80000000;
    }
    else {
      v1 /= by;
    }
  }
  Swift::Int32 v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

Swift::tuple_partialValue_Int32_overflow_Bool __swiftcall Int32.remainderReportingOverflow(dividingBy:)(Swift::Int32 dividingBy)
{
  if (dividingBy)
  {
    if (dividingBy == -1 && v1 == 0x80000000) {
      Swift::Int32 v1 = 0;
    }
    else {
      v1 %= dividingBy;
    }
  }
  Swift::Int32 v2 = v1;
  result.overflow = v1;
  result.partialValue = v2;
  return result;
}

int *static Int32.%= infix(_:_:)(int *result, int a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20AFuLL, 0);
  }
  int v2 = *result;
  if (a2 == -1 && v2 == 0x80000000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20B4uLL, 0);
  }
  *Swift::tuple_partialValue_Int32_overflow_Bool result = v2 % a2;
  return result;
}

_DWORD *static Int32.&= infix(_:_:)(_DWORD *result, int a2)
{
  *result &= a2;
  return result;
}

_DWORD *static Int32.|= infix(_:_:)(_DWORD *result, int a2)
{
  *result |= a2;
  return result;
}

_DWORD *static Int32.^= infix(_:_:)(_DWORD *result, int a2)
{
  *result ^= a2;
  return result;
}

int *static Int32.&>>= infix(_:_:)(int *result, char a2)
{
  *result >>= a2;
  return result;
}

_DWORD *static Int32.&<<= infix(_:_:)(_DWORD *result, char a2)
{
  *result <<= a2;
  return result;
}

uint64_t static Int32.bitWidth.getter()
{
  return 32;
}

uint64_t Int32.leadingZeroBitCount.getter(unsigned int a1)
{
  return __clz(a1);
}

uint64_t Int32._lowWord.getter(uint64_t result)
{
  return (int)result;
}

uint64_t Int32.trailingZeroBitCount.getter(unsigned int a1)
{
  return __clz(__rbit32(a1));
}

uint64_t Int32.nonzeroBitCount.getter(__int32 a1, int8x8_t a2)
{
  a2.i32[0] = a1;
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(a2);
  v2.i16[0] = vaddlv_u8(v2);
  return v2.u32[0];
}

uint64_t Int32.Words._value.setter(uint64_t result)
{
  _DWORD *v1 = result;
  return result;
}

uint64_t (*Int32.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.Words.count.getter()
{
  return 1;
}

uint64_t Int32.Words.startIndex.getter()
{
  return 0;
}

uint64_t Int32.Words.endIndex.getter()
{
  return 1;
}

uint64_t Int32.Words.indices.getter()
{
  return 0;
}

Swift::Int __swiftcall Int32.Words.index(after:)(Swift::Int after)
{
  BOOL v1 = __OFADD__(after, 1);
  Swift::Int result = after + 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

Swift::Int __swiftcall Int32.Words.index(before:)(Swift::Int before)
{
  BOOL v1 = __OFSUB__(before, 1);
  Swift::Int result = before - 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

uint64_t Int32.Words.subscript.getter(uint64_t a1, int a2)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative word index", 19, 2, "Swift/IntegerTypes.swift", 24, 2, 0x21B1uLL, 0);
  }
  if (a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Word index out of range", 23, 2, "Swift/IntegerTypes.swift", 24, 2, 0x21B2uLL, 0);
  }
  return a2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Int32.Words(uint64_t *a1, uint64_t *a2))()
{
  *a1 = Int32.Words.subscript.getter(*a2, *v2);
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Collection.subscript.getter in conformance UInt32.Words@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  if ((*result & 0x8000000000000000) != 0 || (uint64_t v3 = result[1], v3 >= 2)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  }
  int v4 = *v2;
  *(void *)a2 = *result;
  *(void *)(a2 + 8) = v3;
  *(_DWORD *)(a2 + 16) = v4;
  return result;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance Int32.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Int32.Words(uint64_t a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t Int32.magnitude.getter(uint64_t result)
{
  if ((int)result >= 0) {
    return result;
  }
  else {
    return -(int)result;
  }
}

Swift::tuple_high_Int32_low_UInt32 __swiftcall Int32.multipliedFullWidth(by:)(Swift::Int32 by)
{
  Swift::Int32 v2 = __ROR8__(v1 * (uint64_t)by, 32);
  result.low = v1;
  result.high = v2;
  return result;
}

Swift::tuple_quotient_Int32_remainder_Int32 __swiftcall Int32.dividingFullWidth(_:)(Swift::tuple_quotient_Int32_remainder_Int32 result)
{
  if (!v1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2230uLL, 0);
  }
  if (v1 == -1 && (result.remainder | (__PAIR64__(v2, result.quotient) << 32)) == 0x8000000000000000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2BEEuLL, 0);
  }
  uint64_t v3 = (uint64_t)(result.remainder | (__PAIR64__(v2, result.quotient) << 32)) / v1;
  if (v3 != (int)v3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Quotient is not representable", 29, 2, "Swift/IntegerTypes.swift", 24, 2, 0x223AuLL, 0);
  }
  result.quotient = v3;
  return result;
}

uint64_t Int32.byteSwapped.getter(unsigned int a1)
{
  return bswap32(a1);
}

Swift::Int32 __swiftcall Int32.signum()()
{
  return (v0 > 0) | (v0 >> 31);
}

BOOL static Int32.> infix(_:_:)(int a1, int a2)
{
  return a2 < a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance Int32(_DWORD *a1@<X8>)
{
  *a1 = 0x7FFFFFFF;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance Int32(_DWORD *a1@<X8>)
{
  *a1 = 0x80000000;
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance Int32(_DWORD *a1, _DWORD *a2)
{
  BOOL v3 = __OFADD__(*v2, *a2);
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance Int32(_DWORD *a1, _DWORD *a2)
{
  BOOL v3 = __OFSUB__(*v2, *a2);
  *a1 = *v2 - *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance Int32(_DWORD *a1, int *a2)
{
  uint64_t v3 = *v2 * (uint64_t)*a2;
  *a1 = v3;
  return v3 != (int)v3;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance Int32(signed int *a1, int *a2)
{
  int v3 = *a2;
  signed int v4 = *v2;
  if (*a2)
  {
    if (v3 == -1 && v4 == 0x80000000)
    {
      uint64_t v6 = 1;
      signed int v4 = 0x80000000;
    }
    else
    {
      uint64_t v6 = 0;
      v4 /= v3;
    }
  }
  else
  {
    uint64_t v6 = 1;
  }
  *a1 = v4;
  return v6;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance Int32(_DWORD *a1, int *a2)
{
  int v3 = *a2;
  int v4 = *v2;
  if (!*a2) {
    goto LABEL_9;
  }
  if (v3 == -1 && v4 == 0x80000000)
  {
    int v4 = 0;
LABEL_9:
    uint64_t v6 = 1;
    goto LABEL_7;
  }
  uint64_t v6 = 0;
  v4 %= v3;
LABEL_7:
  *a1 = v4;
  return v6;
}

_DWORD *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance Int32(_DWORD *result, _DWORD *a2, int *a3)
{
  uint64_t v4 = *v3 * (uint64_t)*a3;
  *Swift::tuple_high_Int32_low_UInt32 result = HIDWORD(v4);
  *a2 = v4;
  return result;
}

Swift::Int32 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int32(Swift::Int32 *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  Swift::Int32 result = Int32.dividingFullWidth(_:)((Swift::tuple_high_Int32_low_UInt32)__PAIR64__(*a4, *a3)).quotient;
  *a1 = result;
  *a2 = v7;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance Int32()
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)*v0);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

uint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance Int32()
{
  return __clz(*v0);
}

unsigned int *protocol witness for FixedWidthInteger.init(bigEndian:) in conformance Int32@<X0>(unsigned int *result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = bswap32(*result);
  return result;
}

void protocol witness for FixedWidthInteger.bigEndian.getter in conformance Int32(_DWORD *a1@<X8>)
{
  *a1 = bswap32(*v1);
}

int *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance Int32@<X0>(int *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  *a3 = *result >> *a2;
  return result;
}

int *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance Int32(int *result, _DWORD *a2)
{
  *result >>= *a2;
  return result;
}

_DWORD *protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *result << *a2;
  return result;
}

_DWORD *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance Int32(_DWORD *result, _DWORD *a2)
{
  *result <<= *a2;
  return result;
}

_DWORD *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *a2 * *result;
  return result;
}

_DWORD *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *a2 + *result;
  return result;
}

_DWORD *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

_DWORD *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Int32@<X0>(_DWORD *result@<X0>, unint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  if (a2 >> 8 <= 0x20) {
    *a3 = *result;
  }
  else {
    *a3 = 0;
  }
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int32 and conformance Int32(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int32@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _DWORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt32(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type Int32 and conformance Int32, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt32@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, _DWORD *a6@<X8>)
{
  uint64_t v8 = v6;
  uint64_t v13 = a5();
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v38, a1, a4, (uint64_t)a2, v13, a3);
  if ((v38 & 0x100000000) != 0)
  {
    uint64_t v38 = static String._createEmpty(withInitialCapacity:)(80);
    unint64_t v39 = v15;
    TypeName = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v17 & 0x8000000000000000) == 0)
    {
      uint64_t v18 = (uint8x16_t *)TypeName;
      int64_t v19 = v17;
      int64_t v20 = validateUTF8(_:)(TypeName, v17);
      uint64_t v23 = (v22 & 1) != 0
          ? repairUTF8(_:firstKnownBrokenRange:)(v18->i8, v19, v20, v21)
          : specialized static String._uncheckedFromUTF8(_:isASCII:)(v18, v19, v20 & 1);
      uint64_t v25 = v24;
      String.append(_:)(*(Swift::String *)&v23);
      swift_bridgeObjectRelease(v25);
      v26._object = (void *)0x80000001816DE7E0;
      v26._countAndFlagsBits = 0xD00000000000001ELL;
      String.append(_:)(v26);
      uint64_t v27 = (uint64_t *)swift_getTypeName(v8, 0);
      if ((v28 & 0x8000000000000000) == 0)
      {
        int v29 = (uint8x16_t *)v27;
        int64_t v30 = v28;
        int64_t v31 = validateUTF8(_:)(v27, v28);
        if (v33) {
          uint64_t v34 = repairUTF8(_:firstKnownBrokenRange:)(v29->i8, v30, v31, v32);
        }
        else {
          uint64_t v34 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v29, v30, v31 & 1);
        }
        uint64_t v36 = v35;
        String.append(_:)(*(Swift::String *)&v34);
        swift_bridgeObjectRelease(v36);
        v37._countAndFlagsBits = 0xD00000000000002ELL;
        v37._object = (void *)0x80000001816DE800;
        String.append(_:)(v37);
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v38, v39, "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  uint64_t result = (*((uint64_t (**)(uint64_t, Class *))*(a2 - 1) + 1))(a1, a2);
  *a6 = v38;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, _DWORD *a6@<X8>)
{
  uint64_t v80 = a4;
  uint64_t v81 = a5;
  uint64_t v76 = *(int ***)(*(void *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v76, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v74 = (char *)&v72 - v11;
  uint64_t v12 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v77 = (char *)&v72 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v84 = (char *)&v72 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  int64_t v19 = (char *)&v72 - v18;
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v82 = (char *)&v72 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  BOOL v79 = (char *)&v72 - v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v25 = (char *)&v72 - v24;
  BOOL v86 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v26 = v86(a2, a3);
  uint64_t v87 = a1;
  uint64_t v88 = v12;
  uint64_t v89 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v89(v25, a1, a2);
  uint64_t v85 = a6;
  uint64_t v83 = a3 + 64;
  if (v26)
  {
    char v78 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v27 = v78(a2, a3);
    uint64_t v90 = *(void (**)(char *, uint64_t))(v12 + 8);
    v90(v25, a2);
    if (v27 <= 32)
    {
      uint64_t v34 = v87;
      char v33 = v78;
      uint64_t v35 = v78(a2, a3);
      goto LABEL_23;
    }
    char v73 = v19;
    uint64_t v28 = v79;
    v89(v79, v87, a2);
    signed int v91 = 0x80000000;
    int v29 = v86;
    if (v86(a2, a3))
    {
      if (v78(a2, a3) < 32)
      {
        int64_t v30 = v82;
        v89(v82, (uint64_t)v28, a2);
        signed int v31 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        int64_t v32 = v30;
LABEL_17:
        uint64_t v43 = v90;
        v90(v32, a2);
        if (v91 > v31) {
LABEL_40:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_21;
      }
      uint64_t v42 = v82;
      (*(void (**)(signed int *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v91, v80, v81, a2, a3);
      char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v28, v42, a2);
      uint64_t v41 = v42;
    }
    else
    {
      char v36 = v29(a2, a3);
      uint64_t v37 = v78(a2, a3);
      uint64_t v38 = v28;
      if ((v36 & 1) == 0)
      {
        if (v37 >= 32)
        {
          v90(v28, a2);
          uint64_t v34 = v87;
          int64_t v19 = v73;
          char v33 = v78;
          uint64_t v35 = v78(a2, a3);
          goto LABEL_23;
        }
        unint64_t v44 = v82;
        v89(v82, (uint64_t)v28, a2);
        signed int v31 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        int64_t v32 = v44;
        goto LABEL_17;
      }
      if (v37 <= 32)
      {
        int v45 = AssociatedTypeWitness;
        uint64_t v46 = v76;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v76, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v48 = v74;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v45, AssociatedConformanceWitness);
        unsigned int v49 = v82;
        ((void (*)(char *, uint64_t, int **))v46[3])(v48, a2, v46);
        LOBYTE(v45) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v38, v49, a2);
        uint64_t v50 = v38;
        uint64_t v43 = v90;
        v90(v49, a2);
        unsigned int v51 = v77;
        v89(v77, (uint64_t)v50, a2);
        if (v45)
        {
          v43(v51, a2);
          goto LABEL_40;
        }
        signed int v52 = v91;
        signed int v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v43(v51, a2);
        uint64_t v28 = v79;
        if (v52 > v53) {
          goto LABEL_40;
        }
LABEL_21:
        v43(v28, a2);
        int64_t v19 = v73;
        char v33 = v78;
        goto LABEL_22;
      }
      unint64_t v39 = v82;
      (*(void (**)(signed int *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v91, v80, v81, a2, a3);
      char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v28, v39, a2);
      uint64_t v41 = v39;
    }
    uint64_t v43 = v90;
    v90(v41, a2);
    if (v40) {
      goto LABEL_40;
    }
    goto LABEL_21;
  }
  uint64_t v90 = *(void (**)(char *, uint64_t))(v12 + 8);
  v90(v25, a2);
  char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
LABEL_22:
  uint64_t v34 = v87;
  uint64_t v35 = v33(a2, a3);
LABEL_23:
  uint64_t v54 = v35;
  v89(v19, v34, a2);
  if (v54 < 33)
  {
    uint64_t v55 = v33;
    uint64_t v62 = v33(a2, a3);
    v90(v19, a2);
    if (v62 != 32)
    {
      char v56 = v85;
      goto LABEL_37;
    }
    char v63 = v86(a2, a3);
    char v56 = v85;
    if (v63) {
      goto LABEL_37;
    }
  }
  else
  {
    uint64_t v55 = v33;
    v90(v19, a2);
    char v56 = v85;
  }
  uint64_t v57 = v84;
  v89(v84, v34, a2);
  int v93 = 0x7FFFFFFF;
  char v58 = v86(a2, a3);
  uint64_t v59 = v55(a2, a3);
  if ((v58 & 1) == 0)
  {
    if (v59 > 31)
    {
      int v92 = 0x7FFFFFFF;
      uint64_t v60 = *(void (**)(int *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      uint64_t v61 = &v92;
      goto LABEL_35;
    }
LABEL_32:
    char v64 = v82;
    v89(v82, (uint64_t)v57, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    uint64_t v65 = v90;
    v90(v64, a2);
    v65(v57, a2);
    goto LABEL_37;
  }
  if (v59 <= 32) {
    goto LABEL_32;
  }
  uint64_t v60 = *(void (**)(int *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
  uint64_t v61 = &v93;
LABEL_35:
  uint64_t v66 = v82;
  v60(v61, v80, v81, a2, a3);
  char v67 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v66, v57, a2);
  uint64_t v68 = v66;
  uint64_t v69 = v90;
  v90(v68, a2);
  if (v67) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v69(v84, a2);
LABEL_37:
  int v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v90)(v34, a2);
  *char v56 = v70;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance UInt32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _DWORD *a4@<X8>)
{
  int v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  *a4 = v7;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int32 and conformance Int32(a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger._lowWord.getter in conformance Int32()
{
  return *v0;
}

uint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance Int32()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0);
}

uint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance Int32()
{
  return __clz(__rbit32(*v0));
}

_DWORD *protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, int *a2@<X1>, int *a3@<X8>)
{
  int v3 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FCAuLL, 0);
  }
  if (*result == 0x80000000 && v3 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FD1uLL, 0);
  }
  *a3 = *result / v3;
  return result;
}

uint64_t static Int32./ infix(_:_:)(int a1, int a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FCAuLL, 0);
  }
  if (a1 == 0x80000000 && a2 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FD1uLL, 0);
  }
  return (a1 / a2);
}

int *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int32(int *result, int *a2)
{
  int v2 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FCAuLL, 0);
  }
  int v3 = *result;
  if (v2 == -1 && v3 == 0x80000000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x1FD1uLL, 0);
  }
  *uint64_t result = v3 / v2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, int *a2@<X1>, int *a3@<X8>)
{
  int v3 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20AFuLL, 0);
  }
  if (*result == 0x80000000 && v3 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20B4uLL, 0);
  }
  *a3 = *result % v3;
  return result;
}

uint64_t static Int32.% infix(_:_:)(int a1, int a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20AFuLL, 0);
  }
  if (a1 == 0x80000000 && a2 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20B4uLL, 0);
  }
  return (a1 % a2);
}

int *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int32(int *result, int *a2)
{
  int v2 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20AFuLL, 0);
  }
  int v3 = *result;
  if (v2 == -1 && v3 == 0x80000000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, 0x20B4uLL, 0);
  }
  *uint64_t result = v3 % v2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.~ prefix(_:) in conformance Int32@<X0>(_DWORD *result@<X0>, int *a2@<X8>)
{
  *a2 = ~*result;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.& infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  *a3 = *a2 & *result;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.&= infix(_:_:) in conformance Int32(_DWORD *result, _DWORD *a2)
{
  *result &= *a2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.| infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  *a3 = *a2 | *result;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.|= infix(_:_:) in conformance Int32(_DWORD *result, _DWORD *a2)
{
  *result |= *a2;
  return result;
}

_DWORD *protocol witness for static BinaryInteger.^ infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, int *a3@<X8>)
{
  *a3 = *a2 ^ *result;
  return result;
}

uint64_t static Int32.^ infix(_:_:)(unsigned int a1, int a2)
{
  return a2 ^ a1;
}

_DWORD *protocol witness for static BinaryInteger.^= infix(_:_:) in conformance Int32(_DWORD *result, _DWORD *a2)
{
  *result ^= *a2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int32@<X0>(int *a1@<X0>, uint64_t (*a2)(char *, uint64_t)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int *a5@<X8>)
{
  v134 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v134, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v132 = (char *)v125 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v125 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  v129 = (char *)v125 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v135 = (char *)v125 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)v125 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  unint64_t v130 = (char *)v125 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v136 = (char *)v125 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  v140 = (char *)v125 - v28;
  MEMORY[0x1F4188790](v27);
  int64_t v30 = (char *)v125 - v29;
  int v138 = *a1;
  signed int v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v142 = a4 + 64;
  char v32 = v31(a3, a4);
  v139 = a5;
  if (v32)
  {
    char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 < 64)
    {
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      if (v37 >= -32) {
        goto LABEL_19;
      }
LABEL_18:
      int v59 = 0;
      uint64_t v60 = v139;
      goto LABEL_60;
    }
    v144[0] = -32;
    v141 = v33;
    int v47 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
    v47(v144, &type metadata for Int, v48, a3, a4);
    char v33 = v141;
    char v49 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                              + 16))(a2, v30, a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
    if (v49) {
      goto LABEL_18;
    }
  }
  else
  {
    char v39 = v31(a3, a4);
    char v40 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v137 = a2;
    v141 = v40;
    uint64_t v41 = v40(a3, a4);
    if (v39)
    {
      unsigned int v131 = v31;
      if (v41 <= 64)
      {
        unsigned int v51 = AssociatedTypeWitness;
        signed int v52 = v134;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v134, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v54 = v132;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v51, AssociatedConformanceWitness);
        ((void (*)(char *, uint64_t, int **))v52[3])(v54, a3, v52);
        uint64_t v55 = v137;
        LOBYTE(v51) = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v137, v30, a3);
        uint64_t v56 = v12;
        uint64_t v57 = *(void (**)(char *, uint64_t))(v12 + 8);
        v57(v30, a3);
        uint64_t v128 = v56;
        (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v56 + 16))(v15, v55, a3);
        if (v51)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
        }
        else
        {
          uint64_t v58 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
          uint64_t v12 = v128;
          signed int v31 = v131;
          char v33 = v141;
          a2 = v137;
          if (v58 >= -32) {
            goto LABEL_19;
          }
        }
        goto LABEL_18;
      }
      v144[0] = -32;
      unint64_t v44 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
      v44(v144, &type metadata for Int, v45, a3, a4);
      a2 = v137;
      char v46 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                                + 16))(v137, v30, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      signed int v31 = v131;
      char v33 = v141;
      if (v46) {
        goto LABEL_18;
      }
    }
    else
    {
      if (v41 >= 64)
      {
        char v33 = v141;
        a2 = v137;
        goto LABEL_19;
      }
      a2 = v137;
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, v137, a3);
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      char v33 = v141;
      if (v50 < -32) {
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  char v61 = v31(a3, a4);
  uint64_t v62 = a4 + 128;
  char v63 = (uint64_t (*)(uint64_t, uint64_t))a4;
  char v64 = (char *)a2;
  uint64_t v65 = v62;
  unsigned int v131 = v63;
  uint64_t v66 = ((uint64_t (*)(uint64_t))v33)(a3);
  v125[0] = v22;
  v125[1] = v65;
  if (v61)
  {
    if (v66 > 64) {
      goto LABEL_21;
    }
  }
  else if (v66 > 63)
  {
LABEL_21:
    v144[0] = 32;
    uint64_t v69 = v131;
    int v70 = v31;
    uint64_t v71 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (**)(uint64_t, void)))*((void *)v131 + 12);
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v71(v144, &type metadata for Int, v72, a3, (uint64_t (**)(uint64_t, void))v69);
    signed int v31 = v70;
    char v73 = v64;
    uint64_t v74 = v69;
    char v75 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v69 + 4) + 8) + 16))(v30, v73, a3);
    uint64_t v76 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    uint64_t result = v76(v30, a3);
    if ((v75 & 1) == 0) {
      goto LABEL_22;
    }
LABEL_29:
    int v59 = v138 >> 31;
    uint64_t v60 = v139;
    goto LABEL_60;
  }
  char v73 = v64;
  (*(void (**)(char *, char *, uint64_t))(v12 + 16))(v30, v64, a3);
  uint64_t v74 = v131;
  uint64_t v89 = (*((uint64_t (**)(uint64_t, void))v131 + 15))(a3, v131);
  uint64_t v76 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  uint64_t result = v76(v30, a3);
  if (v89 > 32) {
    goto LABEL_29;
  }
LABEL_22:
  v137 = v76;
  v141 = v33;
  uint64_t v77 = v31;
  uint64_t v79 = v12 + 16;
  char v78 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
  uint64_t v80 = v12;
  uint64_t v81 = v140;
  v78(v140, v73, a3);
  uint64_t v82 = v77;
  LOBYTE(v77) = v77(a3, (uint64_t)v74);
  uint64_t v83 = v136;
  v126 = v78;
  uint64_t v127 = v79;
  v78(v136, v81, a3);
  uint64_t v128 = v80;
  if ((v77 & 1) == 0)
  {
    v137(v83, a3);
    goto LABEL_44;
  }
  uint64_t v84 = v141(a3, (uint64_t)v74);
  v137(v83, a3);
  if (v84 <= 64) {
    goto LABEL_44;
  }
  uint64_t v85 = v130;
  v126(v130, v140, a3);
  v144[0] = 0x8000000000000000;
  if (v82(a3, (uint64_t)v74))
  {
    uint64_t v86 = v141(a3, (uint64_t)v74);
    if (v86 < 64)
    {
LABEL_37:
      v126(v30, v85, a3);
      uint64_t v95 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
      uint64_t v94 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      if (v95 < v144[0]) {
        goto LABEL_66;
      }
      goto LABEL_43;
    }
  }
  else
  {
    char v90 = v82(a3, (uint64_t)v74);
    uint64_t v86 = v141(a3, (uint64_t)v74);
    if ((v90 & 1) == 0)
    {
      if (v86 >= 64)
      {
        v137(v85, a3);
        goto LABEL_44;
      }
      goto LABEL_37;
    }
    if (v86 <= 64)
    {
      unsigned int v131 = v82;
      char v97 = AssociatedTypeWitness;
      unint64_t v96 = v134;
      uint64_t v98 = swift_getAssociatedConformanceWitness((uint64_t)v134, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v99 = v132;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v98 + 8))(&qword_18162B0B8, 256, v97, v98);
      ((void (*)(char *, uint64_t, int **))v96[3])(v99, a3, v96);
      char v100 = v130;
      char v101 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v74 + 4) + 8) + 16))(v130, v30, a3);
      char v102 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      uint64_t v103 = v129;
      v126(v129, v100, a3);
      if (v101)
      {
        v102(v103, a3);
        goto LABEL_66;
      }
      uint64_t v104 = v144[0];
      uint64_t v105 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
      v102(v103, a3);
      BOOL v106 = v105 < v104;
      uint64_t v85 = v130;
      uint64_t v82 = v131;
      uint64_t v94 = v102;
      if (v106) {
LABEL_66:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_43;
    }
  }
  signed int v91 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
  unint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v86, v87, v88);
  ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v91)(v144, &type metadata for Int, v92, a3, v131);
  uint64_t v85 = v130;
  uint64_t v74 = v131;
  char v93 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v131 + 4) + 8) + 16))(v130, v30, a3);
  uint64_t v94 = (void (*)(char *, uint64_t))v137;
  v137(v30, a3);
  if (v93) {
    goto LABEL_66;
  }
LABEL_43:
  v94(v85, a3);
LABEL_44:
  uint64_t v107 = v140;
  v108 = v141;
  uint64_t v109 = v141(a3, (uint64_t)v74);
  uint64_t v110 = (char *)v125[0];
  v126((char *)v125[0], v107, a3);
  if (v109 < 65)
  {
    uint64_t v119 = v108(a3, (uint64_t)v74);
    v137(v110, a3);
    uint64_t v111 = v135;
    if (v119 != 64 || (v82(a3, (uint64_t)v74) & 1) != 0) {
      goto LABEL_57;
    }
  }
  else
  {
    v137(v110, a3);
    uint64_t v111 = v135;
  }
  v126(v111, v140, a3);
  v144[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v112 = v82(a3, (uint64_t)v74);
  uint64_t v113 = v141(a3, (uint64_t)v74);
  if (v112)
  {
    if (v113 > 64)
    {
      uint64_t v116 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
      unint64_t v117 = lazy protocol witness table accessor for type Int and conformance Int(v113, v114, v115);
      char v118 = v144;
LABEL_55:
      ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v116)(v118, &type metadata for Int, v117, a3, v74);
      char v121 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v74 + 4) + 8) + 16))(v30, v111, a3);
      uint64_t v122 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      if (v121) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      v122(v111, a3);
      goto LABEL_57;
    }
  }
  else if (v113 > 63)
  {
    uint64_t v143 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v116 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
    unint64_t v117 = lazy protocol witness table accessor for type Int and conformance Int(v113, v114, v115);
    char v118 = &v143;
    goto LABEL_55;
  }
  v126(v30, v111, a3);
  (*((void (**)(uint64_t, uint64_t (*)(uint64_t, uint64_t)))v74 + 15))(a3, v74);
  uint64_t v120 = (void (*)(char *, uint64_t))v137;
  v137(v30, a3);
  v120(v111, a3);
LABEL_57:
  unint64_t v123 = v140;
  unint64_t v124 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
  uint64_t result = v137(v123, a3);
  if ((v124 & 0x8000000000000000) != 0)
  {
    uint64_t v60 = v139;
    if (v124 <= 0xFFFFFFFFFFFFFFE0) {
      int v59 = 0;
    }
    else {
      int v59 = v138 << -(char)v124;
    }
  }
  else
  {
    uint64_t v60 = v139;
    if (v124 >= 0x20) {
      int v59 = v138 >> 31;
    }
    else {
      int v59 = v138 >> v124;
    }
  }
LABEL_60:
  *uint64_t v60 = v59;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int32(int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v120 = a1;
  uint64_t v110 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v110, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v108 = (char *)&v105 - v8;
  uint64_t v9 = *(uint64_t (**)(char *, uint64_t))(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v12 = (char *)&v105 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  BOOL v106 = (char *)&v105 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v113 = (char *)&v105 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  char v112 = (char *)&v105 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v107 = (char *)&v105 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v114 = (char *)&v105 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  char v118 = (char *)&v105 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v26 = (char *)&v105 - v25;
  uint64_t v28 = a4 + 64;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v27(a3, a4) & 1) == 0)
  {
    char v32 = v27(a3, a4);
    uint64_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v29 = v119(a3, a4);
    if ((v32 & 1) == 0)
    {
      if (v29 >= 64) {
        goto LABEL_14;
      }
      goto LABEL_9;
    }
    if (v29 <= 64)
    {
      uint64_t v115 = a4 + 64;
      unint64_t v117 = v27;
      char v39 = AssociatedTypeWitness;
      char v40 = v110;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v110, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v42 = v108;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v39, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v40[3])(v42, a3, v40);
      LOBYTE(v39) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
      uint64_t v43 = (void (*)(char *, uint64_t))*((void *)v9 + 1);
      v43(v26, a3);
      uint64_t v116 = v9;
      (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v12, a2, a3);
      if (v39)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v43)(v12, a3);
        int v38 = 0;
        goto LABEL_53;
      }
      uint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v43)(v12, a3);
      uint64_t v9 = v116;
      uint64_t v27 = v117;
      uint64_t v28 = v115;
      if (v44 < -32) {
        goto LABEL_10;
      }
      goto LABEL_14;
    }
LABEL_6:
    int64_t v122 = -32;
    char v33 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v34 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
    v33(&v122, &type metadata for Int, v34, a3, a4);
    char v35 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
    if (v35) {
      goto LABEL_10;
    }
    goto LABEL_14;
  }
  uint64_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v29 = v119(a3, a4);
  if (v29 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
  if (v37 < -32)
  {
LABEL_10:
    int v38 = 0;
    goto LABEL_53;
  }
LABEL_14:
  char v45 = v27(a3, a4);
  uint64_t v111 = a4 + 128;
  uint64_t v46 = v119(a3, a4);
  unint64_t v117 = v27;
  uint64_t v115 = v28;
  if (v45)
  {
    if (v46 > 64) {
      goto LABEL_16;
    }
  }
  else if (v46 >= 64)
  {
LABEL_16:
    int64_t v122 = 32;
    char v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v46, v47, v48);
    v49(&v122, &type metadata for Int, v50, a3, a4);
    char v51 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v26, a2, a3);
    signed int v52 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
    uint64_t result = v52(v26, a3);
    if ((v51 & 1) == 0) {
      goto LABEL_17;
    }
LABEL_24:
    int v38 = *v120 >> 31;
    goto LABEL_53;
  }
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v68 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  signed int v52 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
  uint64_t result = v52(v26, a3);
  if (v68 > 32) {
    goto LABEL_24;
  }
LABEL_17:
  signed int v53 = v26;
  uint64_t v116 = v52;
  uint64_t v54 = (char *)v9 + 16;
  uint64_t v55 = (void (*)(char *, uint64_t, uint64_t))*((void *)v9 + 2);
  uint64_t v56 = v118;
  v55(v118, a2, a3);
  char v57 = v117(a3, a4);
  uint64_t v58 = v114;
  int v59 = v56;
  uint64_t v105 = v54;
  uint64_t v60 = (void (*)(char *, char *, uint64_t))v55;
  v55(v114, (uint64_t)v59, a3);
  if ((v57 & 1) == 0)
  {
    v116(v58, a3);
    uint64_t v62 = v53;
    goto LABEL_37;
  }
  uint64_t v61 = v119(a3, a4);
  v116(v58, a3);
  uint64_t v62 = v53;
  char v63 = v117;
  if (v61 <= 64) {
    goto LABEL_37;
  }
  char v64 = v107;
  v60(v107, v118, a3);
  int64_t v122 = 0x8000000000000000;
  if (v63(a3, a4))
  {
    uint64_t v65 = v119(a3, a4);
    if (v65 >= 64)
    {
LABEL_28:
      int v70 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v71 = lazy protocol witness table accessor for type Int and conformance Int(v65, v66, v67);
      v70(&v122, &type metadata for Int, v71, a3, a4);
      char v64 = v107;
      char v72 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v107, v62, a3);
      char v73 = (void (*)(char *, uint64_t))v116;
      v116(v62, a3);
      if (v72) {
        goto LABEL_59;
      }
      goto LABEL_36;
    }
LABEL_32:
    v60(v62, v64, a3);
    uint64_t v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v73 = (void (*)(char *, uint64_t))v116;
    v116(v62, a3);
    if (v74 < v122) {
LABEL_59:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_36;
  }
  char v69 = v63(a3, a4);
  uint64_t v65 = v119(a3, a4);
  if ((v69 & 1) == 0)
  {
    if (v65 >= 64)
    {
      v116(v64, a3);
      goto LABEL_37;
    }
    goto LABEL_32;
  }
  if (v65 > 64) {
    goto LABEL_28;
  }
  uint64_t v76 = AssociatedTypeWitness;
  char v75 = v110;
  uint64_t v77 = swift_getAssociatedConformanceWitness((uint64_t)v110, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  char v78 = v108;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v77 + 8))(&qword_18162B0B8, 256, v76, v77);
  ((void (*)(char *, uint64_t, int **))v75[3])(v78, a3, v75);
  uint64_t v79 = v107;
  char v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v107, v62, a3);
  uint64_t v81 = (void (*)(char *, uint64_t))v116;
  v116(v62, a3);
  uint64_t v82 = v106;
  v60(v106, v79, a3);
  if (v80)
  {
    v81(v82, a3);
    goto LABEL_59;
  }
  int64_t v83 = v122;
  uint64_t v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v81(v82, a3);
  BOOL v85 = v84 < v83;
  char v64 = v107;
  char v73 = v81;
  if (v85) {
    goto LABEL_59;
  }
LABEL_36:
  v73(v64, a3);
LABEL_37:
  uint64_t v86 = v118;
  uint64_t v87 = v119;
  uint64_t v88 = v119(a3, a4);
  uint64_t v89 = v112;
  v60(v112, v86, a3);
  if (v88 < 65)
  {
    uint64_t v98 = v87(a3, a4);
    v116(v89, a3);
    char v90 = v113;
    if (v98 != 64 || (v117(a3, a4) & 1) != 0) {
      goto LABEL_50;
    }
  }
  else
  {
    v116(v89, a3);
    char v90 = v113;
  }
  v60(v90, v118, a3);
  int64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
  char v91 = v117(a3, a4);
  uint64_t v92 = v119(a3, a4);
  if ((v91 & 1) == 0)
  {
    if (v92 >= 64)
    {
      uint64_t v121 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
      char v97 = &v121;
      goto LABEL_48;
    }
LABEL_47:
    v60(v62, v90, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v99 = (void (*)(char *, uint64_t))v116;
    v116(v62, a3);
    v99(v90, a3);
    goto LABEL_50;
  }
  if (v92 <= 64) {
    goto LABEL_47;
  }
  uint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
  char v97 = &v122;
LABEL_48:
  v95(v97, &type metadata for Int, v96, a3, a4);
  char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v62, v90, a3);
  char v101 = (void (*)(char *, uint64_t))v116;
  v116(v62, a3);
  if (v100) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v101(v90, a3);
LABEL_50:
  char v102 = v118;
  unint64_t v103 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v116(v102, a3);
  int v104 = *v120;
  if ((v103 & 0x8000000000000000) != 0)
  {
    if (v103 > 0xFFFFFFFFFFFFFFE0)
    {
      int v38 = v104 << -(char)v103;
      goto LABEL_53;
    }
    goto LABEL_10;
  }
  if (v103 >= 0x20) {
    int v38 = v104 >> 31;
  }
  else {
    int v38 = v104 >> v103;
  }
LABEL_53:
  int *v120 = v38;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int32@<X0>(int *a1@<X0>, uint64_t (*a2)(char *, uint64_t)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int *a5@<X8>)
{
  v134 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v134, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v132 = (char *)v125 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v125 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  v129 = (char *)v125 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v135 = (char *)v125 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)v125 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  unint64_t v130 = (char *)v125 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v136 = (char *)v125 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  v140 = (char *)v125 - v28;
  MEMORY[0x1F4188790](v27);
  uint64_t v30 = (char *)v125 - v29;
  int v138 = *a1;
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v142 = a4 + 64;
  char v32 = v31(a3, a4);
  v139 = a5;
  if (v32)
  {
    char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 < 64)
    {
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      if (v37 > -33) {
        goto LABEL_19;
      }
LABEL_18:
      int v59 = v138 >> 31;
      uint64_t v60 = v139;
      goto LABEL_60;
    }
    v144[0] = -32;
    v141 = v33;
    uint64_t v47 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
    v47(v144, &type metadata for Int, v48, a3, a4);
    char v33 = v141;
    char v49 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                              + 16))(a2, v30, a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
    if (v49) {
      goto LABEL_18;
    }
  }
  else
  {
    char v39 = v31(a3, a4);
    char v40 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v137 = a2;
    v141 = v40;
    uint64_t v41 = v40(a3, a4);
    if (v39)
    {
      unsigned int v131 = v31;
      if (v41 <= 64)
      {
        char v51 = AssociatedTypeWitness;
        signed int v52 = v134;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v134, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v54 = v132;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v51, AssociatedConformanceWitness);
        ((void (*)(char *, uint64_t, int **))v52[3])(v54, a3, v52);
        uint64_t v55 = v137;
        LOBYTE(v51) = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v137, v30, a3);
        uint64_t v56 = v12;
        char v57 = *(void (**)(char *, uint64_t))(v12 + 8);
        v57(v30, a3);
        uint64_t v128 = v56;
        (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v56 + 16))(v15, v55, a3);
        if (v51)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
        }
        else
        {
          uint64_t v58 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
          uint64_t v12 = v128;
          uint64_t v31 = v131;
          char v33 = v141;
          a2 = v137;
          if (v58 >= -32) {
            goto LABEL_19;
          }
        }
        goto LABEL_18;
      }
      v144[0] = -32;
      uint64_t v44 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
      v44(v144, &type metadata for Int, v45, a3, a4);
      a2 = v137;
      char v46 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                                + 16))(v137, v30, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      uint64_t v31 = v131;
      char v33 = v141;
      if (v46) {
        goto LABEL_18;
      }
    }
    else
    {
      if (v41 >= 64)
      {
        char v33 = v141;
        a2 = v137;
        goto LABEL_19;
      }
      a2 = v137;
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, v137, a3);
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      char v33 = v141;
      if (v50 < -32) {
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  char v61 = v31(a3, a4);
  uint64_t v62 = a4 + 128;
  char v63 = (uint64_t (*)(uint64_t, uint64_t))a4;
  char v64 = (char *)a2;
  uint64_t v65 = v62;
  unsigned int v131 = v63;
  uint64_t v66 = ((uint64_t (*)(uint64_t))v33)(a3);
  v125[0] = v22;
  v125[1] = v65;
  if (v61)
  {
    if (v66 > 64) {
      goto LABEL_21;
    }
  }
  else if (v66 > 63)
  {
LABEL_21:
    v144[0] = 32;
    char v69 = v131;
    int v70 = v31;
    unint64_t v71 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (**)(uint64_t, void)))*((void *)v131 + 12);
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v71(v144, &type metadata for Int, v72, a3, (uint64_t (**)(uint64_t, void))v69);
    uint64_t v31 = v70;
    char v73 = v64;
    uint64_t v74 = v69;
    char v75 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v69 + 4) + 8) + 16))(v30, v73, a3);
    uint64_t v76 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    uint64_t result = v76(v30, a3);
    if ((v75 & 1) == 0) {
      goto LABEL_22;
    }
LABEL_29:
    int v59 = 0;
    uint64_t v60 = v139;
    goto LABEL_60;
  }
  char v73 = v64;
  (*(void (**)(char *, char *, uint64_t))(v12 + 16))(v30, v64, a3);
  uint64_t v74 = v131;
  uint64_t v89 = (*((uint64_t (**)(uint64_t, void))v131 + 15))(a3, v131);
  uint64_t v76 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  uint64_t result = v76(v30, a3);
  if (v89 > 32) {
    goto LABEL_29;
  }
LABEL_22:
  v137 = v76;
  v141 = v33;
  uint64_t v77 = v31;
  uint64_t v79 = v12 + 16;
  char v78 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
  uint64_t v80 = v12;
  uint64_t v81 = v140;
  v78(v140, v73, a3);
  uint64_t v82 = v77;
  LOBYTE(v77) = v77(a3, (uint64_t)v74);
  int64_t v83 = v136;
  v126 = v78;
  uint64_t v127 = v79;
  v78(v136, v81, a3);
  uint64_t v128 = v80;
  if ((v77 & 1) == 0)
  {
    v137(v83, a3);
    goto LABEL_44;
  }
  uint64_t v84 = v141(a3, (uint64_t)v74);
  v137(v83, a3);
  if (v84 <= 64) {
    goto LABEL_44;
  }
  BOOL v85 = v130;
  v126(v130, v140, a3);
  v144[0] = 0x8000000000000000;
  if (v82(a3, (uint64_t)v74))
  {
    uint64_t v86 = v141(a3, (uint64_t)v74);
    if (v86 < 64)
    {
LABEL_37:
      v126(v30, v85, a3);
      uint64_t v95 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
      uint64_t v94 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      if (v95 < v144[0]) {
        goto LABEL_66;
      }
      goto LABEL_43;
    }
  }
  else
  {
    char v90 = v82(a3, (uint64_t)v74);
    uint64_t v86 = v141(a3, (uint64_t)v74);
    if ((v90 & 1) == 0)
    {
      if (v86 >= 64)
      {
        v137(v85, a3);
        goto LABEL_44;
      }
      goto LABEL_37;
    }
    if (v86 <= 64)
    {
      unsigned int v131 = v82;
      char v97 = AssociatedTypeWitness;
      unint64_t v96 = v134;
      uint64_t v98 = swift_getAssociatedConformanceWitness((uint64_t)v134, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v99 = v132;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v98 + 8))(&qword_18162B0B8, 256, v97, v98);
      ((void (*)(char *, uint64_t, int **))v96[3])(v99, a3, v96);
      char v100 = v130;
      char v101 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v74 + 4) + 8) + 16))(v130, v30, a3);
      char v102 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      unint64_t v103 = v129;
      v126(v129, v100, a3);
      if (v101)
      {
        v102(v103, a3);
        goto LABEL_66;
      }
      uint64_t v104 = v144[0];
      uint64_t v105 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
      v102(v103, a3);
      BOOL v106 = v105 < v104;
      BOOL v85 = v130;
      uint64_t v82 = v131;
      uint64_t v94 = v102;
      if (v106) {
LABEL_66:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_43;
    }
  }
  char v91 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
  unint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v86, v87, v88);
  ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v91)(v144, &type metadata for Int, v92, a3, v131);
  BOOL v85 = v130;
  uint64_t v74 = v131;
  char v93 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v131 + 4) + 8) + 16))(v130, v30, a3);
  uint64_t v94 = (void (*)(char *, uint64_t))v137;
  v137(v30, a3);
  if (v93) {
    goto LABEL_66;
  }
LABEL_43:
  v94(v85, a3);
LABEL_44:
  uint64_t v107 = v140;
  v108 = v141;
  uint64_t v109 = v141(a3, (uint64_t)v74);
  uint64_t v110 = (char *)v125[0];
  v126((char *)v125[0], v107, a3);
  if (v109 < 65)
  {
    uint64_t v119 = v108(a3, (uint64_t)v74);
    v137(v110, a3);
    uint64_t v111 = v135;
    if (v119 != 64 || (v82(a3, (uint64_t)v74) & 1) != 0) {
      goto LABEL_57;
    }
  }
  else
  {
    v137(v110, a3);
    uint64_t v111 = v135;
  }
  v126(v111, v140, a3);
  v144[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v112 = v82(a3, (uint64_t)v74);
  uint64_t v113 = v141(a3, (uint64_t)v74);
  if (v112)
  {
    if (v113 > 64)
    {
      uint64_t v116 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
      unint64_t v117 = lazy protocol witness table accessor for type Int and conformance Int(v113, v114, v115);
      char v118 = v144;
LABEL_55:
      ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v116)(v118, &type metadata for Int, v117, a3, v74);
      char v121 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v74 + 4) + 8) + 16))(v30, v111, a3);
      int64_t v122 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      if (v121) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      v122(v111, a3);
      goto LABEL_57;
    }
  }
  else if (v113 > 63)
  {
    uint64_t v143 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v116 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
    unint64_t v117 = lazy protocol witness table accessor for type Int and conformance Int(v113, v114, v115);
    char v118 = &v143;
    goto LABEL_55;
  }
  v126(v30, v111, a3);
  (*((void (**)(uint64_t, uint64_t (*)(uint64_t, uint64_t)))v74 + 15))(a3, v74);
  uint64_t v120 = (void (*)(char *, uint64_t))v137;
  v137(v30, a3);
  v120(v111, a3);
LABEL_57:
  unint64_t v123 = v140;
  unint64_t v124 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
  uint64_t result = v137(v123, a3);
  if ((v124 & 0x8000000000000000) != 0)
  {
    uint64_t v60 = v139;
    if (v124 <= 0xFFFFFFFFFFFFFFE0) {
      int v59 = v138 >> 31;
    }
    else {
      int v59 = v138 >> -(char)v124;
    }
  }
  else
  {
    uint64_t v60 = v139;
    if (v124 >= 0x20) {
      int v59 = 0;
    }
    else {
      int v59 = v138 << v124;
    }
  }
LABEL_60:
  *uint64_t v60 = v59;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int32(int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v121 = a1;
  uint64_t v111 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v111, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v109 = (char *)&v106 - v8;
  uint64_t v9 = *(char **)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v12 = (char *)&v106 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v107 = (char *)&v106 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v114 = (char *)&v106 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v113 = (char *)&v106 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  v108 = (char *)&v106 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v115 = (char *)&v106 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v119 = (char *)&v106 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v26 = (char *)&v106 - v25;
  uint64_t v28 = a4 + 64;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v27(a3, a4) & 1) == 0)
  {
    char v34 = v27(a3, a4);
    uint64_t v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v29 = v120(a3, a4);
    if ((v34 & 1) == 0)
    {
      if (v29 < 64)
      {
        (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
        uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
        if (v38 < -32) {
          goto LABEL_15;
        }
      }
      goto LABEL_16;
    }
    if (v29 <= 64)
    {
      uint64_t v116 = a4 + 64;
      char v118 = v27;
      char v39 = AssociatedTypeWitness;
      char v40 = v111;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v42 = v109;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v39, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v40[3])(v42, a3, v40);
      LOBYTE(v39) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
      uint64_t v43 = (void (*)(char *, uint64_t))*((void *)v9 + 1);
      v43(v26, a3);
      unint64_t v117 = v9;
      (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v12, a2, a3);
      if (v39)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v43)(v12, a3);
      }
      else
      {
        uint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v43)(v12, a3);
        uint64_t v9 = v117;
        uint64_t v27 = v118;
        uint64_t v28 = v116;
        if (v44 >= -32) {
          goto LABEL_16;
        }
      }
LABEL_15:
      int v45 = *v121 >> 31;
      goto LABEL_56;
    }
    goto LABEL_7;
  }
  uint64_t v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v29 = v120(a3, a4);
  if (v29 >= 64)
  {
LABEL_7:
    int64_t v123 = -32;
    uint64_t v35 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v36 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
    v35(&v123, &type metadata for Int, v36, a3, a4);
    char v37 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
    if (v37) {
      goto LABEL_15;
    }
    goto LABEL_16;
  }
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
  if (v32 <= -33) {
    goto LABEL_15;
  }
LABEL_16:
  char v46 = v27(a3, a4);
  uint64_t v112 = a4 + 128;
  uint64_t v47 = v120(a3, a4);
  char v118 = v27;
  uint64_t v116 = v28;
  if (v46)
  {
    if (v47 > 64) {
      goto LABEL_18;
    }
  }
  else if (v47 >= 64)
  {
LABEL_18:
    int64_t v123 = 32;
    uint64_t v50 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v51 = lazy protocol witness table accessor for type Int and conformance Int(v47, v48, v49);
    v50(&v123, &type metadata for Int, v51, a3, a4);
    char v52 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v26, a2, a3);
    signed int v53 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
    uint64_t result = v53(v26, a3);
    if (v52) {
      goto LABEL_22;
    }
    goto LABEL_23;
  }
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  signed int v53 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
  uint64_t result = v53(v26, a3);
  if (v54 > 32)
  {
LABEL_22:
    int v45 = 0;
    goto LABEL_56;
  }
LABEL_23:
  uint64_t v55 = v26;
  unint64_t v117 = (char *)v53;
  uint64_t v56 = v9 + 16;
  char v57 = (void (*)(char *, uint64_t, uint64_t))*((void *)v9 + 2);
  uint64_t v58 = v119;
  v57(v119, a2, a3);
  char v59 = v118(a3, a4);
  uint64_t v60 = v115;
  char v61 = v58;
  BOOL v106 = v56;
  uint64_t v62 = (void (*)(char *, char *, uint64_t))v57;
  v57(v115, (uint64_t)v61, a3);
  if ((v59 & 1) == 0)
  {
    ((void (*)(char *, uint64_t))v117)(v60, a3);
    char v64 = v55;
    goto LABEL_40;
  }
  uint64_t v63 = v120(a3, a4);
  ((void (*)(char *, uint64_t))v117)(v60, a3);
  char v64 = v55;
  uint64_t v65 = v118;
  if (v63 <= 64) {
    goto LABEL_40;
  }
  uint64_t v66 = v108;
  v62(v108, v119, a3);
  int64_t v123 = 0x8000000000000000;
  if (v65(a3, a4))
  {
    uint64_t v67 = v120(a3, a4);
    if (v67 >= 64)
    {
LABEL_31:
      unint64_t v71 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v67, v68, v69);
      v71(&v123, &type metadata for Int, v72, a3, a4);
      uint64_t v66 = v108;
      char v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v108, v64, a3);
      uint64_t v74 = v117;
      ((void (*)(char *, uint64_t))v117)(v64, a3);
      if (v73) {
        goto LABEL_61;
      }
      goto LABEL_39;
    }
LABEL_35:
    v62(v64, v66, a3);
    uint64_t v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v74 = v117;
    ((void (*)(char *, uint64_t))v117)(v64, a3);
    if (v75 < v123) {
LABEL_61:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_39;
  }
  char v70 = v65(a3, a4);
  uint64_t v67 = v120(a3, a4);
  if ((v70 & 1) == 0)
  {
    if (v67 >= 64)
    {
      ((void (*)(char *, uint64_t))v117)(v66, a3);
      goto LABEL_40;
    }
    goto LABEL_35;
  }
  if (v67 > 64) {
    goto LABEL_31;
  }
  uint64_t v77 = AssociatedTypeWitness;
  uint64_t v76 = v111;
  uint64_t v78 = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v79 = v109;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v78 + 8))(&qword_18162B0B8, 256, v77, v78);
  ((void (*)(char *, uint64_t, int **))v76[3])(v79, a3, v76);
  uint64_t v80 = v108;
  char v81 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v108, v64, a3);
  uint64_t v82 = v117;
  ((void (*)(char *, uint64_t))v117)(v64, a3);
  int64_t v83 = v107;
  v62(v107, v80, a3);
  if (v81)
  {
    ((void (*)(char *, uint64_t))v82)(v83, a3);
    goto LABEL_61;
  }
  int64_t v84 = v123;
  uint64_t v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  ((void (*)(char *, uint64_t))v82)(v83, a3);
  BOOL v86 = v85 < v84;
  uint64_t v66 = v108;
  uint64_t v74 = v82;
  if (v86) {
    goto LABEL_61;
  }
LABEL_39:
  ((void (*)(char *, uint64_t))v74)(v66, a3);
LABEL_40:
  uint64_t v87 = v119;
  uint64_t v88 = v120;
  uint64_t v89 = v120(a3, a4);
  char v90 = v113;
  v62(v113, v87, a3);
  if (v89 < 65)
  {
    uint64_t v99 = v88(a3, a4);
    ((void (*)(char *, uint64_t))v117)(v90, a3);
    char v91 = v114;
    if (v99 != 64 || (v118(a3, a4) & 1) != 0) {
      goto LABEL_53;
    }
  }
  else
  {
    ((void (*)(char *, uint64_t))v117)(v90, a3);
    char v91 = v114;
  }
  v62(v91, v119, a3);
  int64_t v123 = 0x7FFFFFFFFFFFFFFFLL;
  char v92 = v118(a3, a4);
  uint64_t v93 = v120(a3, a4);
  if ((v92 & 1) == 0)
  {
    if (v93 >= 64)
    {
      uint64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v96 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v97 = lazy protocol witness table accessor for type Int and conformance Int(v93, v94, v95);
      uint64_t v98 = &v122;
      goto LABEL_51;
    }
LABEL_50:
    v62(v64, v91, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v100 = v117;
    ((void (*)(char *, uint64_t))v117)(v64, a3);
    ((void (*)(char *, uint64_t))v100)(v91, a3);
    goto LABEL_53;
  }
  if (v93 <= 64) {
    goto LABEL_50;
  }
  unint64_t v96 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v97 = lazy protocol witness table accessor for type Int and conformance Int(v93, v94, v95);
  uint64_t v98 = &v123;
LABEL_51:
  v96(v98, &type metadata for Int, v97, a3, a4);
  char v101 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v64, v91, a3);
  char v102 = v117;
  ((void (*)(char *, uint64_t))v117)(v64, a3);
  if (v101) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  ((void (*)(char *, uint64_t))v102)(v91, a3);
LABEL_53:
  unint64_t v103 = v119;
  unint64_t v104 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v117)(v103, a3);
  int v105 = *v121;
  if ((v104 & 0x8000000000000000) == 0)
  {
    if (v104 < 0x20)
    {
      int v45 = v105 << v104;
      goto LABEL_56;
    }
    goto LABEL_22;
  }
  if (v104 <= 0xFFFFFFFFFFFFFFE0) {
    int v45 = v105 >> 31;
  }
  else {
    int v45 = v105 >> -(char)v104;
  }
LABEL_56:
  *char v121 = v45;
  return result;
}

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int32(_DWORD *a1, int *a2, int *a3)
{
  uint64_t result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, *v3);
  *a1 = result;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance Int32(int *a1)
{
  return specialized SignedInteger<>.isMultiple(of:)(*a1, *v1);
}

void protocol witness for BinaryInteger.signum() in conformance Int32(int *a1@<X8>)
{
  *a1 = (*v1 > 0) | (*v1 >> 31);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int32(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt32(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, uint64_t (*a4)(void *, uint64_t, uint64_t)@<X5>, uint64_t a5@<X8>)
{
  uint64_t v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0) {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v7)
  {
    uint64_t v10 = a3();
    if ((v10 & 0x10000000000) != 0) {
      uint64_t v10 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10, a4);
    }
    swift_bridgeObjectRelease(a2);
    unint64_t v11 = (v10 & 0x100000000uLL) >> 32;
    if ((v10 & 0x100000000) != 0) {
      int v12 = 0;
    }
    else {
      int v12 = v10;
    }
  }
  else
  {
    swift_bridgeObjectRelease(a2);
    int v12 = 0;
    LOBYTE(v11) = 1;
  }
  *(_DWORD *)a5 = v12;
  *(unsigned char *)(a5 + 4) = v11 & 1;
}

_DWORD *protocol witness for static SignedNumeric.- prefix(_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X8>)
{
  if (__OFSUB__(0, *result)) {
    __break(1u);
  }
  else {
    *a2 = -*result;
  }
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance Int32()
{
  if (__OFSUB__(0, *v0)) {
    __break(1u);
  }
  else {
    _DWORD *v0 = -*v0;
  }
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int32@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v104 = a4;
  uint64_t v111 = a5;
  char v100 = *(int ***)(*(void *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v100, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v98 = (char *)&v96 - v9;
  uint64_t v10 = *(void *)(a2 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  char v101 = (char *)&v96 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  char v102 = (char *)&v96 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v96 - v16;
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v109 = (char *)&v96 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v107 = (char *)&v96 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v24 = (char *)&v96 - v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v26 = (char *)&v96 - v25;
  uint64_t v110 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v27 = v110(a2, a3);
  uint64_t v113 = *(void (**)(char *, uint64_t, uint64_t))(v10 + 16);
  v113(v26, a1, a2);
  v108 = v17;
  BOOL v28 = (v27 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 32;
  uint64_t v103 = v10;
  uint64_t v29 = *(void (**)(char *, uint64_t))(v10 + 8);
  v29(v26, a2);
  v113(v24, a1, a2);
  uint64_t v114 = a1;
  uint64_t v112 = v29;
  uint64_t v106 = a3 + 64;
  if (!v28)
  {
    v29(v24, a2);
    uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v32 = (a3 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    goto LABEL_10;
  }
  signed int v115 = 0x80000000;
  uint64_t v30 = v110;
  if ((v110(a2, a3) & 1) == 0)
  {
    char v56 = v30(a2, a3);
    uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    int v105 = (void (*)(signed int *, uint64_t, unint64_t, uint64_t, uint64_t))((a3 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000);
    uint64_t v57 = v31(a2, a3);
    if (v56)
    {
      if (v57 > 32)
      {
        uint64_t v60 = *(void (**)(signed int *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
        unint64_t v61 = lazy protocol witness table accessor for type Int32 and conformance Int32(v57, v58, v59);
        uint64_t v62 = v31;
        uint64_t v63 = v107;
        v60(&v115, v104, v61, a2, a3);
        char v64 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v24, v63, a2);
        uint64_t v65 = v63;
        uint64_t v31 = v62;
        char v37 = v112;
        v112(v65, a2);
        v37(v24, a2);
        uint64_t v38 = v111;
        uint64_t v32 = (uint64_t)v105;
        if (v64) {
          goto LABEL_39;
        }
        goto LABEL_10;
      }
      unint64_t v97 = v31;
      uint64_t v88 = AssociatedTypeWitness;
      uint64_t v87 = v100;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v100, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      char v90 = v98;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v88, AssociatedConformanceWitness);
      char v91 = v107;
      ((void (*)(char *, uint64_t, int **))v87[3])(v90, a2, v87);
      LOBYTE(v87) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v24, v91, a2);
      char v37 = v112;
      v112(v91, a2);
      char v92 = v101;
      (*(void (**)(char *, char *, uint64_t))(v103 + 32))(v101, v24, a2);
      if (v87)
      {
        v37(v92, a2);
        uint64_t v38 = v111;
        goto LABEL_39;
      }
      signed int v93 = v115;
      signed int v94 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      char v37 = v112;
      signed int v95 = v94;
      v112(v92, a2);
      BOOL v79 = v93 <= v95;
      uint64_t v38 = v111;
      uint64_t v31 = v97;
    }
    else
    {
      if (v57 >= 32)
      {
        v112(v24, a2);
        uint64_t v32 = (uint64_t)v105;
        goto LABEL_10;
      }
      signed int v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
      char v37 = v112;
      v112(v24, a2);
      BOOL v79 = v115 <= v78;
      uint64_t v38 = v111;
    }
    uint64_t v32 = (uint64_t)v105;
    if (v79) {
      goto LABEL_10;
    }
LABEL_39:
    uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v37)(v114, a2);
    int v70 = 0;
    char v72 = 1;
    goto LABEL_40;
  }
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v32 = (a3 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
  uint64_t v33 = v31(a2, a3);
  if (v33 >= 32)
  {
    int v105 = *(void (**)(signed int *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v73 = lazy protocol witness table accessor for type Int32 and conformance Int32(v33, v34, v35);
    uint64_t v74 = v31;
    uint64_t v75 = v107;
    v105(&v115, v104, v73, a2, a3);
    char v76 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v24, v75, a2);
    uint64_t v77 = v75;
    uint64_t v31 = v74;
    char v37 = v112;
    v112(v77, a2);
    v37(v24, a2);
    uint64_t v38 = v111;
    if (v76) {
      goto LABEL_39;
    }
  }
  else
  {
    signed int v36 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    char v37 = v112;
    v112(v24, a2);
    uint64_t v38 = v111;
    if (v115 > v36) {
      goto LABEL_39;
    }
  }
LABEL_10:
  uint64_t v39 = v114;
  uint64_t v40 = v31(a2, a3);
  uint64_t v41 = v31;
  uint64_t v42 = v109;
  uint64_t v43 = v113;
  v113(v109, v39, a2);
  if (v40 >= 33)
  {
    int v105 = (void (*)(signed int *, uint64_t, unint64_t, uint64_t, uint64_t))v32;
    v112(v42, a2);
    uint64_t v44 = v108;
    v43(v108, v39, a2);
    uint64_t v38 = v111;
    goto LABEL_14;
  }
  uint64_t v45 = v41(a2, a3);
  v112(v42, a2);
  if (v45 != 32)
  {
    uint64_t v44 = v108;
    v113(v108, v114, a2);
    uint64_t v38 = v111;
    goto LABEL_24;
  }
  int v105 = (void (*)(signed int *, uint64_t, unint64_t, uint64_t, uint64_t))v32;
  char v46 = v110(a2, a3);
  uint64_t v44 = v108;
  v113(v108, v114, a2);
  uint64_t v38 = v111;
  if (v46)
  {
LABEL_24:
    uint64_t v67 = v44;
    goto LABEL_25;
  }
LABEL_14:
  v117[0] = 0x7FFFFFFF;
  char v47 = v110(a2, a3);
  uint64_t v48 = v41(a2, a3);
  if (v47)
  {
    if (v48 > 32)
    {
      unint64_t v51 = *(void (**)(int *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
      unint64_t v52 = lazy protocol witness table accessor for type Int32 and conformance Int32(v48, v49, v50);
      signed int v53 = v107;
      v51(v117, v104, v52, a2, a3);
      char v54 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v53, v44, a2);
      char v37 = v112;
      v112(v53, a2);
      uint64_t v55 = v44;
      goto LABEL_33;
    }
    goto LABEL_22;
  }
  if (v48 <= 31)
  {
LABEL_22:
    uint64_t v66 = v107;
    (*(void (**)(char *, char *, uint64_t))(v103 + 32))(v107, v44, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    uint64_t v67 = v66;
LABEL_25:
    char v37 = v112;
    v112(v67, a2);
    goto LABEL_26;
  }
  int v116 = 0x7FFFFFFF;
  uint64_t v80 = v107;
  uint64_t v81 = (*(uint64_t (**)(char *, char *, uint64_t))(v103 + 32))(v107, v44, a2);
  uint64_t v82 = *(void (**)(int *, uint64_t, unint64_t, uint64_t, uint64_t))(a3 + 96);
  unint64_t v85 = lazy protocol witness table accessor for type Int32 and conformance Int32(v81, v83, v84);
  BOOL v86 = v102;
  v82(&v116, v104, v85, a2, a3);
  char v54 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v86, v80, a2);
  char v37 = v112;
  v112(v86, a2);
  uint64_t v55 = v80;
LABEL_33:
  v37(v55, a2);
  if (v54) {
    goto LABEL_39;
  }
LABEL_26:
  uint64_t v68 = (uint64_t (*)(uint64_t, uint64_t))v37;
  uint64_t v69 = v114;
  int v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = v68(v69, a2);
  char v72 = 0;
LABEL_40:
  *(_DWORD *)uint64_t v38 = v70;
  *(unsigned char *)(v38 + 4) = v72;
  return result;
}

void protocol witness for Numeric.magnitude.getter in conformance Int32(int *a1@<X8>)
{
  int v2 = *v1;
  if (*v1 < 0) {
    int v2 = -v2;
  }
  *a1 = v2;
}

int *protocol witness for static Numeric.* infix(_:_:) in conformance Int32@<X0>(int *result@<X0>, int *a2@<X1>, _DWORD *a3@<X8>)
{
  uint64_t v3 = *result * (uint64_t)*a2;
  if (v3 == (int)v3) {
    *a3 = v3;
  }
  else {
    __break(1u);
  }
  return result;
}

uint64_t static Int32.* infix(_:_:)(int a1, int a2)
{
  uint64_t result = a1 * (uint64_t)a2;
  if (result != (int)result) {
    __break(1u);
  }
  return result;
}

int *protocol witness for static Numeric.*= infix(_:_:) in conformance Int32(int *result, int *a2)
{
  uint64_t v2 = *result * (uint64_t)*a2;
  if (v2 == (int)v2) {
    *uint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Int32()
{
  return _int64ToString(_:radix:uppercase:)(*v0, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
}

int *protocol witness for Strideable.distance(to:) in conformance Int32@<X0>(int *result@<X0>, uint64_t *a2@<X8>)
{
  int v3 = *result;
  int v4 = *v2;
  if (((*v2 ^ *result) & 0x80000000) == 0)
  {
    BOOL v5 = __OFSUB__(v3, v4);
    int v6 = v3 - v4;
    if (!v5)
    {
      *a2 = v6;
      return result;
    }
    __break(1u);
    goto LABEL_15;
  }
  if (v4 >= 0) {
    int v7 = *v2;
  }
  else {
    int v7 = -v4;
  }
  if (v3 < 0) {
    int v3 = -v3;
  }
  BOOL v8 = __CFADD__(v7, v3);
  uint64_t v9 = (v7 + v3);
  if (v8)
  {
LABEL_15:
    __break(1u);
    return result;
  }
  if (v4 < 0) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = -v9;
  }
  *a2 = v10;
  return result;
}

void *protocol witness for Strideable.advanced(by:) in conformance Int32@<X0>(void *result@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v3 = *v2;
  uint64_t v4 = v3 + *result;
  if (__OFADD__(v3, *result))
  {
    __break(1u);
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
  }
  if (v4 <= (uint64_t)0xFFFFFFFF7FFFFFFFLL) {
    goto LABEL_6;
  }
  if (v4 >= 0x80000000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  *a2 = v4;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int32(uint64_t a1, uint64_t a2, char a3, unsigned int *a4, unsigned int *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance UInt32(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt32(uint64_t a1, uint64_t a2, char a3, unsigned int *a4, unsigned int *a5, void *a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, void, void, void, void))
{
  return a9(a1, a2, a3 & 1, *a4, *a5, *a6);
}

_DWORD *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  if (__OFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *a3 = *result + *a2;
  }
  return result;
}

uint64_t static Int32.+ infix(_:_:)(int a1, int a2)
{
  BOOL v2 = __OFADD__(a1, a2);
  uint64_t result = (a1 + a2);
  if (v2) {
    __break(1u);
  }
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Int32(_DWORD *result, _DWORD *a2)
{
  if (__OFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *result += *a2;
  }
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Int32@<X0>(_DWORD *result@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X8>)
{
  if (__OFSUB__(*result, *a2)) {
    __break(1u);
  }
  else {
    *a3 = *result - *a2;
  }
  return result;
}

_DWORD *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Int32(_DWORD *result, _DWORD *a2)
{
  if (__OFSUB__(*result, *a2)) {
    __break(1u);
  }
  else {
    *result -= *a2;
  }
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Int32(_DWORD *a1, _DWORD *a2)
{
  return *a1 < *a2;
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance Int32(_DWORD *a1, _DWORD *a2)
{
  return *a2 >= *a1;
}

BOOL static Int32.<= infix(_:_:)(int a1, int a2)
{
  return a2 >= a1;
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance Int32(_DWORD *a1, _DWORD *a2)
{
  return *a1 >= *a2;
}

BOOL static Int32.>= infix(_:_:)(int a1, int a2)
{
  return a1 >= a2;
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance Int32(_DWORD *a1, _DWORD *a2)
{
  return *a2 < *a1;
}

void Int32.hash(into:)(int a1, Swift::UInt32 a2)
{
}

Swift::Int __swiftcall Int32._rawHashValue(seed:)(Swift::Int seed)
{
  return specialized static Hasher._hash(seed:bytes:count:)(seed, v1, 4);
}

uint64_t Int32.hashValue.getter(unsigned int a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(0, a1, 4);
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance Int32(uint64_t a1)
{
  return specialized static Hasher._hash(seed:bytes:count:)(a1, *v1, 4);
}

uint64_t Int32._toCustomAnyHashable()@<X0>(int a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int32>);
  *(void *)(a2 + 24) = result;
  *(void *)(a2 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_DWORD *)a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Int32@<X0>(uint64_t a1@<X8>)
{
  int v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int32>);
  *(void *)(a1 + 24) = result;
  *(void *)(a1 + 32) = &protocol witness table for _IntegerAnyHashableBox<A>;
  *(_DWORD *)a1 = v3;
  return result;
}

uint64_t UInt64._value.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*UInt64._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

unint64_t UInt64.init(_:)(float a1)
{
  if ((~LODWORD(a1) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt64 because it is either infinite or NaN", 80, 2, "Swift/IntegerTypes.swift", 24, 2, 0x245EuLL, 0);
  }
  if (*(short float *)&a1 <= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(-1.0))) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float16 value cannot be converted to UInt64 because the result would be less than UInt64.min", 92, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2461uLL, 0);
  }
  return (unint64_t)*(short float *)&a1;
}

Swift::UInt64 __swiftcall UInt64.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt64 because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0x24ACuLL, 0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt64 because the result would be less than UInt64.min", 90, 2, "Swift/IntegerTypes.swift", 24, 2, 0x24AFuLL, 0);
  }
  if (a1 >= 1.8447e19) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to UInt64 because the result would be greater than UInt64.max", 93, 2, "Swift/IntegerTypes.swift", 24, 2, 0x24B2uLL, 0);
  }
  return (unint64_t)a1;
}

Swift::UInt64 __swiftcall UInt64.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt64 because it is either infinite or NaN", 79, 2, "Swift/IntegerTypes.swift", 24, 2, 0x24F4uLL, 0);
  }
  if (a1 <= -1.0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt64 because the result would be less than UInt64.min", 91, 2, "Swift/IntegerTypes.swift", 24, 2, 0x24F7uLL, 0);
  }
  if (a1 >= 1.84467441e19) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to UInt64 because the result would be greater than UInt64.max", 94, 2, "Swift/IntegerTypes.swift", 24, 2, 0x24FAuLL, 0);
  }
  return (unint64_t)a1;
}

void *static UInt64./= infix(_:_:)(void *result, unint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x25E8uLL, 0);
  }
  *result /= a2;
  return result;
}

Swift::tuple_partialValue_UInt64_overflow_Bool __swiftcall UInt64.addingReportingOverflow(_:)(Swift::UInt64 a1)
{
  BOOL v2 = __CFADD__(v1, a1);
  Swift::UInt64 v3 = v1 + a1;
  Swift::Bool v4 = v2;
  result.partialValue = v3;
  result.overflow = v4;
  return result;
}

Swift::tuple_partialValue_UInt64_overflow_Bool __swiftcall UInt64.subtractingReportingOverflow(_:)(Swift::UInt64 a1)
{
  BOOL v2 = v1 >= a1;
  Swift::UInt64 v3 = v1 - a1;
  Swift::Bool v4 = !v2;
  result.partialValue = v3;
  result.overflow = v4;
  return result;
}

Swift::tuple_partialValue_UInt64_overflow_Bool __swiftcall UInt64.multipliedReportingOverflow(by:)(Swift::UInt64 by)
{
  Swift::UInt64 v2 = v1 * by;
  Swift::Bool v3 = !is_mul_ok(v1, by);
  Swift::UInt64 v4 = v2;
  result.partialValue = v4;
  result.overflow = v3;
  return result;
}

void *static UInt64.%= infix(_:_:)(void *result, unint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x26BCuLL, 0);
  }
  *result %= a2;
  return result;
}

uint64_t UInt64.Words._value.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*UInt64.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.Words.count.getter()
{
  return 1;
}

uint64_t UInt64.Words.startIndex.getter()
{
  return 0;
}

uint64_t UInt64.Words.endIndex.getter()
{
  return 1;
}

uint64_t UInt64.Words.indices.getter()
{
  return 0;
}

uint64_t UInt64.Words.subscript.getter(uint64_t a1, uint64_t a2)
{
  return UInt64.Words.subscript.getter(a1, a2, 0x27B9uLL, 0x27BAuLL);
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UInt64.Words@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance [A](a1, a2, a3, (uint64_t (*)(void, uint64_t, void))specialized RandomAccessCollection.index(_:offsetBy:limitedBy:), a4);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt64.Words(uint64_t *a1, uint64_t *a2))()
{
  uint64_t v4 = *v2;
  UInt64.Words.subscript.getter(*a2, v4);
  *a1 = v4;
  return EnumeratedSequence._base.modify;
}

Swift::tuple_quotient_UInt64_remainder_UInt64 __swiftcall UInt64.dividingFullWidth(_:)(Swift::tuple_high_UInt64_low_UInt64 a1)
{
  Swift::UInt64 v2 = UInt64.dividingFullWidth(_:)(a1.high, a1.low, v1, 0x282DuLL, 0x282FuLL);
  result.remainder = v3;
  result.quotient = v2;
  return result;
}

uint64_t protocol witness for static FixedWidthInteger.bitWidth.getter in conformance UInt64()
{
  return 64;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance UInt64(void *a1@<X8>)
{
  *a1 = -1;
}

Swift::UInt64 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt64(Swift::UInt64 *a1, Swift::UInt64 *a2, Swift::tuple_high_UInt64_low_UInt64 *a3)
{
  Swift::tuple_quotient_UInt64_remainder_UInt64 v6 = UInt64.dividingFullWidth(_:)(*a3);
  Swift::UInt64 result = v6.quotient;
  *a1 = v6.quotient;
  *a2 = v6.remainder;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt64 and conformance UInt64, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

void *protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt64@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x25E8uLL, 0);
  }
  *a3 = *result / *a2;
  return result;
}

unint64_t static UInt64./ infix(_:_:)(unint64_t a1, unint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x25E8uLL, 0);
  }
  return a1 / a2;
}

void *protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt64(void *result, void *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x25E8uLL, 0);
  }
  *result /= *a2;
  return result;
}

void *protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt64@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x26BCuLL, 0);
  }
  *a3 = *result % *a2;
  return result;
}

unint64_t static UInt64.% infix(_:_:)(unint64_t a1, unint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x26BCuLL, 0);
  }
  return a1 % a2;
}

void *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt64(void *result, void *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x26BCuLL, 0);
  }
  *result %= *a2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance UInt64@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t *a5@<X8>)
{
  uint64_t v120 = a5;
  uint64_t v111 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v111, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v109 = (char *)&v106 - v10;
  uint64_t v11 = *(uint64_t (**)(char *, uint64_t))(a3 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v106 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v107 = (char *)&v106 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  signed int v115 = (char *)&v106 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v114 = (char *)&v106 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  v108 = (char *)&v106 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  int v116 = (char *)&v106 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  char v121 = (char *)&v106 - v26;
  MEMORY[0x1F4188790](v25);
  BOOL v28 = (char *)&v106 - v27;
  unint64_t v113 = *a1;
  uint64_t v30 = a4 + 64;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v29(a3, a4) & 1) == 0)
  {
    char v34 = v29(a3, a4);
    uint64_t v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v31 = v122(a3, a4);
    if ((v34 & 1) == 0)
    {
      if (v31 >= 64) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    if (v31 <= 64)
    {
      uint64_t v117 = a4 + 64;
      uint64_t v119 = v29;
      char v64 = AssociatedTypeWitness;
      uint64_t v65 = v111;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v67 = v109;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v64, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v65[3])(v67, a3, v65);
      LOBYTE(v64) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v28, a3);
      uint64_t v68 = (void (*)(char *, uint64_t))*((void *)v11 + 1);
      v68(v28, a3);
      char v118 = v11;
      (*((void (**)(char *, void, uint64_t))v11 + 2))(v14, a2, a3);
      if (v64)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v68)(v14, a3);
        goto LABEL_25;
      }
      uint64_t v69 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v68)(v14, a3);
      uint64_t v11 = v118;
      uint64_t v29 = v119;
      uint64_t v30 = v117;
      if (v69 < -64) {
        goto LABEL_25;
      }
      goto LABEL_10;
    }
LABEL_6:
    v124[0] = -64;
    uint64_t v35 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v36 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
    v35(v124, &type metadata for Int, v36, a3, a4);
    char v37 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v28, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v11 + 1))(v28, a3);
    if (v37) {
      goto LABEL_25;
    }
    goto LABEL_10;
  }
  uint64_t v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v31 = v122(a3, a4);
  if (v31 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  (*((void (**)(char *, void, uint64_t))v11 + 2))(v28, a2, a3);
  uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*((uint64_t (**)(char *, uint64_t))v11 + 1))(v28, a3);
  if (v39 < -64) {
    goto LABEL_25;
  }
LABEL_10:
  char v40 = v29(a3, a4);
  uint64_t v112 = a4 + 128;
  uint64_t v41 = v122(a3, a4);
  uint64_t v119 = v29;
  uint64_t v117 = v30;
  if (v40)
  {
    if (v41 > 64) {
      goto LABEL_12;
    }
    goto LABEL_15;
  }
  if (v41 <= 63)
  {
LABEL_15:
    (*((void (**)(char *, void, uint64_t))v11 + 2))(v28, a2, a3);
    uint64_t v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v47 = (uint64_t (*)(char *, uint64_t))*((void *)v11 + 1);
    uint64_t result = v47(v28, a3);
    if (v48 <= 64) {
      goto LABEL_16;
    }
LABEL_25:
    unint64_t v70 = 0;
    goto LABEL_53;
  }
LABEL_12:
  v124[0] = 64;
  uint64_t v44 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
  v44(v124, &type metadata for Int, v45, a3, a4);
  char v46 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v28, a2, a3);
  char v47 = (uint64_t (*)(char *, uint64_t))*((void *)v11 + 1);
  uint64_t result = v47(v28, a3);
  if (v46) {
    goto LABEL_25;
  }
LABEL_16:
  uint64_t v49 = v28;
  char v118 = v47;
  uint64_t v50 = (char *)v11 + 16;
  unint64_t v51 = (void (*)(char *, uint64_t, uint64_t))*((void *)v11 + 2);
  unint64_t v52 = v121;
  v51(v121, a2, a3);
  char v53 = v119(a3, a4);
  char v54 = v116;
  uint64_t v55 = v52;
  uint64_t v106 = v50;
  char v56 = (void (*)(char *, char *, uint64_t))v51;
  v51(v116, (uint64_t)v55, a3);
  if ((v53 & 1) == 0)
  {
    v118(v54, a3);
    uint64_t v58 = v49;
    goto LABEL_37;
  }
  uint64_t v57 = v122(a3, a4);
  v118(v54, a3);
  uint64_t v58 = v49;
  uint64_t v59 = v119;
  if (v57 <= 64) {
    goto LABEL_37;
  }
  uint64_t v60 = v108;
  v56(v108, v121, a3);
  v124[0] = 0x8000000000000000;
  if (v59(a3, a4))
  {
    uint64_t v61 = v122(a3, a4);
    if (v61 >= 64)
    {
LABEL_28:
      char v72 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v73 = lazy protocol witness table accessor for type Int and conformance Int(v61, v62, v63);
      v72(v124, &type metadata for Int, v73, a3, a4);
      uint64_t v60 = v108;
      char v74 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v108, v58, a3);
      uint64_t v75 = (void (*)(char *, uint64_t))v118;
      v118(v58, a3);
      if (v74) {
        goto LABEL_58;
      }
      goto LABEL_36;
    }
LABEL_32:
    v56(v58, v60, a3);
    uint64_t v76 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v75 = (void (*)(char *, uint64_t))v118;
    v118(v58, a3);
    if (v76 < v124[0]) {
LABEL_58:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_36;
  }
  char v71 = v59(a3, a4);
  uint64_t v61 = v122(a3, a4);
  if ((v71 & 1) == 0)
  {
    if (v61 >= 64)
    {
      v118(v60, a3);
      goto LABEL_37;
    }
    goto LABEL_32;
  }
  if (v61 > 64) {
    goto LABEL_28;
  }
  signed int v78 = AssociatedTypeWitness;
  uint64_t v77 = v111;
  uint64_t v79 = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v80 = v109;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v79 + 8))(&qword_18162B0B8, 256, v78, v79);
  ((void (*)(char *, uint64_t, int **))v77[3])(v80, a3, v77);
  uint64_t v81 = v108;
  char v82 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v108, v58, a3);
  uint64_t v83 = (void (*)(char *, uint64_t))v118;
  v118(v58, a3);
  uint64_t v84 = v107;
  v56(v107, v81, a3);
  if (v82)
  {
    v83(v84, a3);
    goto LABEL_58;
  }
  uint64_t v85 = v124[0];
  uint64_t v86 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v83(v84, a3);
  BOOL v87 = v86 < v85;
  uint64_t v60 = v108;
  uint64_t v75 = v83;
  if (v87) {
    goto LABEL_58;
  }
LABEL_36:
  v75(v60, a3);
LABEL_37:
  uint64_t v88 = v121;
  uint64_t v89 = v122;
  uint64_t v90 = v122(a3, a4);
  char v91 = v114;
  v56(v114, v88, a3);
  if (v90 < 65)
  {
    uint64_t v100 = v89(a3, a4);
    v118(v91, a3);
    char v92 = v115;
    if (v100 != 64 || (v119(a3, a4) & 1) != 0) {
      goto LABEL_50;
    }
  }
  else
  {
    v118(v91, a3);
    char v92 = v115;
  }
  v56(v92, v121, a3);
  v124[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v93 = v119(a3, a4);
  uint64_t v94 = v122(a3, a4);
  if ((v93 & 1) == 0)
  {
    if (v94 > 63)
    {
      uint64_t v123 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v97 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v94, v95, v96);
      uint64_t v99 = &v123;
      goto LABEL_48;
    }
LABEL_46:
    v56(v58, v92, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v101 = (void (*)(char *, uint64_t))v118;
    v118(v58, a3);
    v101(v92, a3);
    goto LABEL_50;
  }
  if (v94 <= 64) {
    goto LABEL_46;
  }
  unint64_t v97 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v94, v95, v96);
  uint64_t v99 = v124;
LABEL_48:
  v97(v99, &type metadata for Int, v98, a3, a4);
  char v102 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v58, v92, a3);
  uint64_t v103 = (void (*)(char *, uint64_t))v118;
  v118(v58, a3);
  if (v102) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v103(v92, a3);
LABEL_50:
  uint64_t v104 = v121;
  unint64_t v105 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v118(v104, a3);
  if ((v105 & 0x8000000000000000) != 0)
  {
    if (v105 > 0xFFFFFFFFFFFFFFC0)
    {
      unint64_t v70 = v113 << -(char)v105;
      goto LABEL_53;
    }
    goto LABEL_25;
  }
  unint64_t v70 = v113 >> v105;
  if (v105 >= 0x40) {
    unint64_t v70 = 0;
  }
LABEL_53:
  unint64_t *v120 = v70;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance UInt64(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v120 = a1;
  uint64_t v110 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v110, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v108 = (char *)&v105 - v8;
  uint64_t v9 = *(uint64_t (**)(char *, uint64_t))(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v12 = (char *)&v105 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v106 = (char *)&v105 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  unint64_t v113 = (char *)&v105 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v112 = (char *)&v105 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v107 = (char *)&v105 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v114 = (char *)&v105 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  char v118 = (char *)&v105 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v26 = (char *)&v105 - v25;
  uint64_t v28 = a4 + 64;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v27(a3, a4) & 1) == 0)
  {
    char v32 = v27(a3, a4);
    uint64_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v29 = v119(a3, a4);
    if ((v32 & 1) == 0)
    {
      if (v29 >= 64) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    if (v29 <= 64)
    {
      uint64_t v115 = a4 + 64;
      uint64_t v117 = v27;
      uint64_t v63 = AssociatedTypeWitness;
      char v64 = v110;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v110, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v66 = v108;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v63, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v64[3])(v66, a3, v64);
      LOBYTE(v63) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
      uint64_t v67 = (void (*)(char *, uint64_t))*((void *)v9 + 1);
      v67(v26, a3);
      int v116 = v9;
      (*((void (**)(char *, void, uint64_t))v9 + 2))(v12, a2, a3);
      if (v63)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v67)(v12, a3);
        unint64_t v47 = 0;
        goto LABEL_54;
      }
      uint64_t v68 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v67)(v12, a3);
      uint64_t v9 = v116;
      uint64_t v27 = v117;
      uint64_t v28 = v115;
      if (v68 < -64) {
        goto LABEL_16;
      }
      goto LABEL_10;
    }
LABEL_6:
    int64_t v122 = -64;
    uint64_t v33 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v34 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
    v33(&v122, &type metadata for Int, v34, a3, a4);
    char v35 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
    if (v35) {
      goto LABEL_16;
    }
    goto LABEL_10;
  }
  uint64_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v29 = v119(a3, a4);
  if (v29 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  (*((void (**)(char *, void, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
  if (v37 < -64) {
    goto LABEL_16;
  }
LABEL_10:
  char v38 = v27(a3, a4);
  uint64_t v111 = a4 + 128;
  uint64_t v39 = v119(a3, a4);
  uint64_t v117 = v27;
  uint64_t v115 = v28;
  if (v38)
  {
    if (v39 > 64) {
      goto LABEL_12;
    }
    goto LABEL_15;
  }
  if (v39 < 64)
  {
LABEL_15:
    (*((void (**)(char *, void, uint64_t))v9 + 2))(v26, a2, a3);
    uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    unint64_t v45 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
    uint64_t result = v45(v26, a3);
    if (v46 <= 64) {
      goto LABEL_17;
    }
LABEL_16:
    unint64_t v47 = 0;
    goto LABEL_54;
  }
LABEL_12:
  int64_t v122 = 64;
  uint64_t v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
  v42(&v122, &type metadata for Int, v43, a3, a4);
  char v44 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v26, a2, a3);
  unint64_t v45 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
  uint64_t result = v45(v26, a3);
  if (v44) {
    goto LABEL_16;
  }
LABEL_17:
  uint64_t v48 = v26;
  int v116 = v45;
  uint64_t v49 = (char *)v9 + 16;
  uint64_t v50 = (void (*)(char *, uint64_t, uint64_t))*((void *)v9 + 2);
  unint64_t v51 = v118;
  v50(v118, a2, a3);
  char v52 = v117(a3, a4);
  char v53 = v114;
  char v54 = v51;
  unint64_t v105 = v49;
  uint64_t v55 = (void (*)(char *, char *, uint64_t))v50;
  v50(v114, (uint64_t)v54, a3);
  if ((v52 & 1) == 0)
  {
    v116(v53, a3);
    uint64_t v57 = v48;
    goto LABEL_38;
  }
  uint64_t v56 = v119(a3, a4);
  v116(v53, a3);
  uint64_t v57 = v48;
  uint64_t v58 = v117;
  if (v56 <= 64) {
    goto LABEL_38;
  }
  uint64_t v59 = v107;
  v55(v107, v118, a3);
  int64_t v122 = 0x8000000000000000;
  if (v58(a3, a4))
  {
    uint64_t v60 = v119(a3, a4);
    if (v60 >= 64)
    {
LABEL_29:
      unint64_t v70 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v71 = lazy protocol witness table accessor for type Int and conformance Int(v60, v61, v62);
      v70(&v122, &type metadata for Int, v71, a3, a4);
      uint64_t v59 = v107;
      char v72 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v107, v57, a3);
      unint64_t v73 = (void (*)(char *, uint64_t))v116;
      v116(v57, a3);
      if (v72) {
        goto LABEL_59;
      }
      goto LABEL_37;
    }
LABEL_33:
    v55(v57, v59, a3);
    uint64_t v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    unint64_t v73 = (void (*)(char *, uint64_t))v116;
    v116(v57, a3);
    if (v74 < v122) {
LABEL_59:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_37;
  }
  char v69 = v58(a3, a4);
  uint64_t v60 = v119(a3, a4);
  if ((v69 & 1) == 0)
  {
    if (v60 >= 64)
    {
      v116(v59, a3);
      goto LABEL_38;
    }
    goto LABEL_33;
  }
  if (v60 > 64) {
    goto LABEL_29;
  }
  uint64_t v76 = AssociatedTypeWitness;
  uint64_t v75 = v110;
  uint64_t v77 = swift_getAssociatedConformanceWitness((uint64_t)v110, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  signed int v78 = v108;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v77 + 8))(&qword_18162B0B8, 256, v76, v77);
  ((void (*)(char *, uint64_t, int **))v75[3])(v78, a3, v75);
  uint64_t v79 = v107;
  char v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v107, v57, a3);
  uint64_t v81 = (void (*)(char *, uint64_t))v116;
  v116(v57, a3);
  char v82 = v106;
  v55(v106, v79, a3);
  if (v80)
  {
    v81(v82, a3);
    goto LABEL_59;
  }
  int64_t v83 = v122;
  uint64_t v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v81(v82, a3);
  BOOL v85 = v84 < v83;
  uint64_t v59 = v107;
  unint64_t v73 = v81;
  if (v85) {
    goto LABEL_59;
  }
LABEL_37:
  v73(v59, a3);
LABEL_38:
  uint64_t v86 = v118;
  BOOL v87 = v119;
  uint64_t v88 = v119(a3, a4);
  uint64_t v89 = v112;
  v55(v112, v86, a3);
  if (v88 < 65)
  {
    uint64_t v98 = v87(a3, a4);
    v116(v89, a3);
    uint64_t v90 = v113;
    if (v98 != 64 || (v117(a3, a4) & 1) != 0) {
      goto LABEL_51;
    }
  }
  else
  {
    v116(v89, a3);
    uint64_t v90 = v113;
  }
  v55(v90, v118, a3);
  int64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
  char v91 = v117(a3, a4);
  uint64_t v92 = v119(a3, a4);
  if ((v91 & 1) == 0)
  {
    if (v92 >= 64)
    {
      uint64_t v121 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
      unint64_t v97 = &v121;
      goto LABEL_49;
    }
LABEL_48:
    v55(v57, v90, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v99 = (void (*)(char *, uint64_t))v116;
    v116(v57, a3);
    v99(v90, a3);
    goto LABEL_51;
  }
  if (v92 <= 64) {
    goto LABEL_48;
  }
  uint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
  unint64_t v97 = &v122;
LABEL_49:
  v95(v97, &type metadata for Int, v96, a3, a4);
  char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v57, v90, a3);
  char v101 = (void (*)(char *, uint64_t))v116;
  v116(v57, a3);
  if (v100) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v101(v90, a3);
LABEL_51:
  char v102 = v118;
  unint64_t v103 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v116(v102, a3);
  unint64_t v104 = *v120;
  if ((v103 & 0x8000000000000000) != 0)
  {
    if (v103 >= 0xFFFFFFFFFFFFFFC1)
    {
      unint64_t v47 = v104 << -(char)v103;
      goto LABEL_54;
    }
    goto LABEL_16;
  }
  unint64_t v47 = v104 >> v103;
  if (v103 >= 0x40) {
    unint64_t v47 = 0;
  }
LABEL_54:
  unint64_t *v120 = v47;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt64@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t *a5@<X8>)
{
  uint64_t v120 = a5;
  uint64_t v111 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v111, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v109 = (char *)&v106 - v10;
  uint64_t v11 = *(uint64_t (**)(char *, uint64_t))(a3 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v106 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v107 = (char *)&v106 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v115 = (char *)&v106 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v114 = (char *)&v106 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  v108 = (char *)&v106 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  int v116 = (char *)&v106 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v121 = (char *)&v106 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v28 = (char *)&v106 - v27;
  unint64_t v113 = *a1;
  uint64_t v30 = a4 + 64;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v29(a3, a4) & 1) == 0)
  {
    char v34 = v29(a3, a4);
    int64_t v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v31 = v122(a3, a4);
    if ((v34 & 1) == 0)
    {
      if (v31 >= 64) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    if (v31 <= 64)
    {
      uint64_t v117 = a4 + 64;
      uint64_t v119 = v29;
      uint64_t v65 = AssociatedTypeWitness;
      uint64_t v66 = v111;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v68 = v109;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v65, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v66[3])(v68, a3, v66);
      LOBYTE(v65) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v28, a3);
      char v69 = (void (*)(char *, uint64_t))*((void *)v11 + 1);
      v69(v28, a3);
      char v118 = v11;
      (*((void (**)(char *, void, uint64_t))v11 + 2))(v14, a2, a3);
      if (v65)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v69)(v14, a3);
        unint64_t v49 = 0;
        goto LABEL_54;
      }
      uint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v69)(v14, a3);
      uint64_t v11 = v118;
      uint64_t v29 = v119;
      uint64_t v30 = v117;
      if (v70 < -64) {
        goto LABEL_16;
      }
      goto LABEL_10;
    }
LABEL_6:
    v124[0] = -64;
    char v35 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v36 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
    v35(v124, &type metadata for Int, v36, a3, a4);
    char v37 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v28, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v11 + 1))(v28, a3);
    if (v37) {
      goto LABEL_16;
    }
    goto LABEL_10;
  }
  int64_t v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v31 = v122(a3, a4);
  if (v31 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  (*((void (**)(char *, void, uint64_t))v11 + 2))(v28, a2, a3);
  uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*((uint64_t (**)(char *, uint64_t))v11 + 1))(v28, a3);
  if (v39 < -64) {
    goto LABEL_16;
  }
LABEL_10:
  char v40 = v29(a3, a4);
  uint64_t v112 = a4 + 128;
  uint64_t v41 = v122(a3, a4);
  uint64_t v119 = v29;
  uint64_t v117 = v30;
  if (v40)
  {
    if (v41 > 64) {
      goto LABEL_12;
    }
    goto LABEL_15;
  }
  if (v41 <= 63)
  {
LABEL_15:
    (*((void (**)(char *, void, uint64_t))v11 + 2))(v28, a2, a3);
    uint64_t v48 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    unint64_t v47 = (uint64_t (*)(char *, uint64_t))*((void *)v11 + 1);
    uint64_t result = v47(v28, a3);
    if (v48 <= 64) {
      goto LABEL_17;
    }
LABEL_16:
    unint64_t v49 = 0;
    goto LABEL_54;
  }
LABEL_12:
  v124[0] = 64;
  char v44 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
  v44(v124, &type metadata for Int, v45, a3, a4);
  char v46 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v28, a2, a3);
  unint64_t v47 = (uint64_t (*)(char *, uint64_t))*((void *)v11 + 1);
  uint64_t result = v47(v28, a3);
  if (v46) {
    goto LABEL_16;
  }
LABEL_17:
  uint64_t v50 = v28;
  char v118 = v47;
  unint64_t v51 = (char *)v11 + 16;
  char v52 = (void (*)(char *, uint64_t, uint64_t))*((void *)v11 + 2);
  char v53 = v121;
  v52(v121, a2, a3);
  char v54 = v119(a3, a4);
  uint64_t v55 = v116;
  uint64_t v56 = v53;
  uint64_t v106 = v51;
  uint64_t v57 = (void (*)(char *, char *, uint64_t))v52;
  v52(v116, (uint64_t)v56, a3);
  if ((v54 & 1) == 0)
  {
    v118(v55, a3);
    uint64_t v59 = v50;
    goto LABEL_38;
  }
  uint64_t v58 = v122(a3, a4);
  v118(v55, a3);
  uint64_t v59 = v50;
  uint64_t v60 = v119;
  if (v58 <= 64) {
    goto LABEL_38;
  }
  uint64_t v61 = v108;
  v57(v108, v121, a3);
  v124[0] = 0x8000000000000000;
  if (v60(a3, a4))
  {
    uint64_t v62 = v122(a3, a4);
    if (v62 >= 64)
    {
LABEL_29:
      char v72 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v73 = lazy protocol witness table accessor for type Int and conformance Int(v62, v63, v64);
      v72(v124, &type metadata for Int, v73, a3, a4);
      uint64_t v61 = v108;
      char v74 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v108, v59, a3);
      uint64_t v75 = (void (*)(char *, uint64_t))v118;
      v118(v59, a3);
      if (v74) {
        goto LABEL_59;
      }
      goto LABEL_37;
    }
LABEL_33:
    v57(v59, v61, a3);
    uint64_t v76 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v75 = (void (*)(char *, uint64_t))v118;
    v118(v59, a3);
    if (v76 < v124[0]) {
LABEL_59:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_37;
  }
  char v71 = v60(a3, a4);
  uint64_t v62 = v122(a3, a4);
  if ((v71 & 1) == 0)
  {
    if (v62 >= 64)
    {
      v118(v61, a3);
      goto LABEL_38;
    }
    goto LABEL_33;
  }
  if (v62 > 64) {
    goto LABEL_29;
  }
  signed int v78 = AssociatedTypeWitness;
  uint64_t v77 = v111;
  uint64_t v79 = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  char v80 = v109;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v79 + 8))(&qword_18162B0B8, 256, v78, v79);
  ((void (*)(char *, uint64_t, int **))v77[3])(v80, a3, v77);
  uint64_t v81 = v108;
  char v82 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v108, v59, a3);
  int64_t v83 = (void (*)(char *, uint64_t))v118;
  v118(v59, a3);
  uint64_t v84 = v107;
  v57(v107, v81, a3);
  if (v82)
  {
    v83(v84, a3);
    goto LABEL_59;
  }
  uint64_t v85 = v124[0];
  uint64_t v86 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v83(v84, a3);
  BOOL v87 = v86 < v85;
  uint64_t v61 = v108;
  uint64_t v75 = v83;
  if (v87) {
    goto LABEL_59;
  }
LABEL_37:
  v75(v61, a3);
LABEL_38:
  uint64_t v88 = v121;
  uint64_t v89 = v122;
  uint64_t v90 = v122(a3, a4);
  char v91 = v114;
  v57(v114, v88, a3);
  if (v90 < 65)
  {
    uint64_t v100 = v89(a3, a4);
    v118(v91, a3);
    uint64_t v92 = v115;
    if (v100 != 64 || (v119(a3, a4) & 1) != 0) {
      goto LABEL_51;
    }
  }
  else
  {
    v118(v91, a3);
    uint64_t v92 = v115;
  }
  v57(v92, v121, a3);
  v124[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v93 = v119(a3, a4);
  uint64_t v94 = v122(a3, a4);
  if ((v93 & 1) == 0)
  {
    if (v94 > 63)
    {
      uint64_t v123 = 0x7FFFFFFFFFFFFFFFLL;
      unint64_t v97 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v94, v95, v96);
      uint64_t v99 = &v123;
      goto LABEL_49;
    }
LABEL_47:
    v57(v59, v92, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v101 = (void (*)(char *, uint64_t))v118;
    v118(v59, a3);
    v101(v92, a3);
    goto LABEL_51;
  }
  if (v94 <= 64) {
    goto LABEL_47;
  }
  unint64_t v97 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v94, v95, v96);
  uint64_t v99 = v124;
LABEL_49:
  v97(v99, &type metadata for Int, v98, a3, a4);
  char v102 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v59, v92, a3);
  unint64_t v103 = (void (*)(char *, uint64_t))v118;
  v118(v59, a3);
  if (v102) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v103(v92, a3);
LABEL_51:
  unint64_t v104 = v121;
  unint64_t v105 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v118(v104, a3);
  if ((v105 & 0x8000000000000000) != 0)
  {
    if (v105 > 0xFFFFFFFFFFFFFFC0)
    {
      unint64_t v49 = v113 >> -(char)v105;
      goto LABEL_54;
    }
    goto LABEL_16;
  }
  unint64_t v49 = v113 << v105;
  if (v105 >= 0x40) {
    unint64_t v49 = 0;
  }
LABEL_54:
  unint64_t *v120 = v49;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance UInt64(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v120 = a1;
  uint64_t v110 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v110, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v108 = (char *)&v105 - v8;
  uint64_t v9 = *(uint64_t (**)(char *, uint64_t))(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v12 = (char *)&v105 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v106 = (char *)&v105 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  unint64_t v113 = (char *)&v105 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v112 = (char *)&v105 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v107 = (char *)&v105 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v114 = (char *)&v105 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  char v118 = (char *)&v105 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v26 = (char *)&v105 - v25;
  uint64_t v28 = a4 + 64;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v27(a3, a4) & 1) == 0)
  {
    char v32 = v27(a3, a4);
    uint64_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v29 = v119(a3, a4);
    if ((v32 & 1) == 0)
    {
      if (v29 >= 64) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    if (v29 <= 64)
    {
      uint64_t v115 = a4 + 64;
      uint64_t v117 = v27;
      uint64_t v63 = AssociatedTypeWitness;
      uint64_t v64 = v110;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v110, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v66 = v108;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v63, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v64[3])(v66, a3, v64);
      LOBYTE(v63) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
      uint64_t v67 = (void (*)(char *, uint64_t))*((void *)v9 + 1);
      v67(v26, a3);
      int v116 = v9;
      (*((void (**)(char *, void, uint64_t))v9 + 2))(v12, a2, a3);
      if (v63)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v67)(v12, a3);
        unint64_t v47 = 0;
        goto LABEL_54;
      }
      uint64_t v68 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v67)(v12, a3);
      uint64_t v9 = v116;
      uint64_t v27 = v117;
      uint64_t v28 = v115;
      if (v68 < -64) {
        goto LABEL_16;
      }
      goto LABEL_10;
    }
LABEL_6:
    int64_t v122 = -64;
    uint64_t v33 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v34 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
    v33(&v122, &type metadata for Int, v34, a3, a4);
    char v35 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
    if (v35) {
      goto LABEL_16;
    }
    goto LABEL_10;
  }
  uint64_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v29 = v119(a3, a4);
  if (v29 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  (*((void (**)(char *, void, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
  if (v37 < -64) {
    goto LABEL_16;
  }
LABEL_10:
  char v38 = v27(a3, a4);
  uint64_t v111 = a4 + 128;
  uint64_t v39 = v119(a3, a4);
  uint64_t v117 = v27;
  uint64_t v115 = v28;
  if (v38)
  {
    if (v39 > 64) {
      goto LABEL_12;
    }
    goto LABEL_15;
  }
  if (v39 < 64)
  {
LABEL_15:
    (*((void (**)(char *, void, uint64_t))v9 + 2))(v26, a2, a3);
    uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    unint64_t v45 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
    uint64_t result = v45(v26, a3);
    if (v46 <= 64) {
      goto LABEL_17;
    }
LABEL_16:
    unint64_t v47 = 0;
    goto LABEL_54;
  }
LABEL_12:
  int64_t v122 = 64;
  uint64_t v42 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
  v42(&v122, &type metadata for Int, v43, a3, a4);
  char v44 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v26, a2, a3);
  unint64_t v45 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
  uint64_t result = v45(v26, a3);
  if (v44) {
    goto LABEL_16;
  }
LABEL_17:
  uint64_t v48 = v26;
  int v116 = v45;
  unint64_t v49 = (char *)v9 + 16;
  uint64_t v50 = (void (*)(char *, uint64_t, uint64_t))*((void *)v9 + 2);
  unint64_t v51 = v118;
  v50(v118, a2, a3);
  char v52 = v117(a3, a4);
  char v53 = v114;
  char v54 = v51;
  unint64_t v105 = v49;
  uint64_t v55 = (void (*)(char *, char *, uint64_t))v50;
  v50(v114, (uint64_t)v54, a3);
  if ((v52 & 1) == 0)
  {
    v116(v53, a3);
    uint64_t v57 = v48;
    goto LABEL_38;
  }
  uint64_t v56 = v119(a3, a4);
  v116(v53, a3);
  uint64_t v57 = v48;
  uint64_t v58 = v117;
  if (v56 <= 64) {
    goto LABEL_38;
  }
  uint64_t v59 = v107;
  v55(v107, v118, a3);
  int64_t v122 = 0x8000000000000000;
  if (v58(a3, a4))
  {
    uint64_t v60 = v119(a3, a4);
    if (v60 >= 64)
    {
LABEL_29:
      uint64_t v70 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v71 = lazy protocol witness table accessor for type Int and conformance Int(v60, v61, v62);
      v70(&v122, &type metadata for Int, v71, a3, a4);
      uint64_t v59 = v107;
      char v72 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v107, v57, a3);
      unint64_t v73 = (void (*)(char *, uint64_t))v116;
      v116(v57, a3);
      if (v72) {
        goto LABEL_59;
      }
      goto LABEL_37;
    }
LABEL_33:
    v55(v57, v59, a3);
    uint64_t v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    unint64_t v73 = (void (*)(char *, uint64_t))v116;
    v116(v57, a3);
    if (v74 < v122) {
LABEL_59:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_37;
  }
  char v69 = v58(a3, a4);
  uint64_t v60 = v119(a3, a4);
  if ((v69 & 1) == 0)
  {
    if (v60 >= 64)
    {
      v116(v59, a3);
      goto LABEL_38;
    }
    goto LABEL_33;
  }
  if (v60 > 64) {
    goto LABEL_29;
  }
  uint64_t v76 = AssociatedTypeWitness;
  uint64_t v75 = v110;
  uint64_t v77 = swift_getAssociatedConformanceWitness((uint64_t)v110, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  signed int v78 = v108;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v77 + 8))(&qword_18162B0B8, 256, v76, v77);
  ((void (*)(char *, uint64_t, int **))v75[3])(v78, a3, v75);
  uint64_t v79 = v107;
  char v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v107, v57, a3);
  uint64_t v81 = (void (*)(char *, uint64_t))v116;
  v116(v57, a3);
  char v82 = v106;
  v55(v106, v79, a3);
  if (v80)
  {
    v81(v82, a3);
    goto LABEL_59;
  }
  int64_t v83 = v122;
  uint64_t v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v81(v82, a3);
  BOOL v85 = v84 < v83;
  uint64_t v59 = v107;
  unint64_t v73 = v81;
  if (v85) {
    goto LABEL_59;
  }
LABEL_37:
  v73(v59, a3);
LABEL_38:
  uint64_t v86 = v118;
  BOOL v87 = v119;
  uint64_t v88 = v119(a3, a4);
  uint64_t v89 = v112;
  v55(v112, v86, a3);
  if (v88 < 65)
  {
    uint64_t v98 = v87(a3, a4);
    v116(v89, a3);
    uint64_t v90 = v113;
    if (v98 != 64 || (v117(a3, a4) & 1) != 0) {
      goto LABEL_51;
    }
  }
  else
  {
    v116(v89, a3);
    uint64_t v90 = v113;
  }
  v55(v90, v118, a3);
  int64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
  char v91 = v117(a3, a4);
  uint64_t v92 = v119(a3, a4);
  if ((v91 & 1) == 0)
  {
    if (v92 >= 64)
    {
      uint64_t v121 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
      unint64_t v97 = &v121;
      goto LABEL_49;
    }
LABEL_48:
    v55(v57, v90, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v99 = (void (*)(char *, uint64_t))v116;
    v116(v57, a3);
    v99(v90, a3);
    goto LABEL_51;
  }
  if (v92 <= 64) {
    goto LABEL_48;
  }
  uint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
  unint64_t v97 = &v122;
LABEL_49:
  v95(v97, &type metadata for Int, v96, a3, a4);
  char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v57, v90, a3);
  char v101 = (void (*)(char *, uint64_t))v116;
  v116(v57, a3);
  if (v100) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v101(v90, a3);
LABEL_51:
  char v102 = v118;
  unint64_t v103 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v116(v102, a3);
  unint64_t v104 = *v120;
  if ((v103 & 0x8000000000000000) != 0)
  {
    if (v103 > 0xFFFFFFFFFFFFFFC0)
    {
      unint64_t v47 = v104 >> -(char)v103;
      goto LABEL_54;
    }
    goto LABEL_16;
  }
  unint64_t v47 = v104 << v103;
  if (v103 >= 0x40) {
    unint64_t v47 = 0;
  }
LABEL_54:
  unint64_t *v120 = v47;
  return result;
}

unint64_t *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt64(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt64(a1, a2, a3, a4, a5, 0x25E8uLL);
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt64(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance UInt64(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt64 and conformance UInt64, a5);
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance UInt64()
{
  return _uint64ToString(_:radix:uppercase:)(*v0, 10, 0)._countAndFlagsBits;
}

uint64_t *protocol witness for Strideable.distance(to:) in conformance UInt64@<X0>(uint64_t *result@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *result;
  uint64_t v4 = *v2;
  uint64_t v5 = *result - *v2;
  if (*result >= (unint64_t)*v2)
  {
    if (*result - *v2 >= 0) {
      goto LABEL_5;
    }
LABEL_6:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Distance is not representable in Int", 36, 2, "Swift/Integers.swift", 20, 2, 0x64AuLL, 0);
  }
  if (v4 - v3 < 0) {
    goto LABEL_6;
  }
  uint64_t v5 = v3 - v4;
LABEL_5:
  *a2 = v5;
  return result;
}

uint64_t UInt64.hashValue.getter(uint64_t a1)
{
  return specialized static Hasher._hash(seed:_:)(0, a1);
}

void protocol witness for Hashable.hash(into:) in conformance UInt64()
{
  Hasher._combine(_:)(*v0);
}

uint64_t UInt64._toCustomAnyHashable()@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>);
  a2[3] = result;
  a2[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance UInt64@<X0>(void *a1@<X8>)
{
  uint64_t v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>);
  a1[3] = result;
  a1[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a1 = v3;
  return result;
}

uint64_t Int64._value.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*Int64._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.init(_:)(float a1)
{
  return Int.init(_:)("Float16 value cannot be converted to Int64 because it is either infinite or NaN", 79, 0x2A60uLL, a1);
}

uint64_t Int.init(_:)(const char *a1, uint64_t a2, unint64_t a3, float a4)
{
  if ((~LODWORD(a4) & 0x7C00) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, a1, a2, 2, "Swift/IntegerTypes.swift", 24, 2, a3, 0);
  }
  return (uint64_t)*(short float *)&a4;
}

Swift::Int64 __swiftcall Int64.init(_:)(Swift::Float a1)
{
  if ((~LODWORD(a1) & 0x7F800000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int64 because it is either infinite or NaN", 77, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2AABuLL, 0);
  }
  if (a1 <= -9.2234e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int64 because the result would be less than Int64.min", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2AAEuLL, 0);
  }
  if (a1 >= 9.2234e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Float value cannot be converted to Int64 because the result would be greater than Int64.max", 91, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2AB1uLL, 0);
  }
  return (uint64_t)a1;
}

Swift::Int64 __swiftcall Int64.init(_:)(Swift::Double a1)
{
  if ((~*(void *)&a1 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int64 because it is either infinite or NaN", 78, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2AF3uLL, 0);
  }
  if (a1 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int64 because the result would be less than Int64.min", 89, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2AF6uLL, 0);
  }
  if (a1 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int64 because the result would be greater than Int64.max", 92, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2AF9uLL, 0);
  }
  return (uint64_t)a1;
}

BOOL static Int64.< infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a1 < a2;
}

uint64_t *static Int64./= infix(_:_:)(uint64_t *a1, uint64_t a2)
{
  return static Int64./= infix(_:_:)(a1, a2, 0x2BE7uLL, 0x2BEEuLL);
}

Swift::tuple_partialValue_Int64_overflow_Bool __swiftcall Int64.addingReportingOverflow(_:)(Swift::Int64 a1)
{
  BOOL v2 = __OFADD__(v1, a1);
  Swift::Int64 v3 = v1 + a1;
  Swift::Bool v4 = v2;
  result.partialValue = v3;
  result.overflow = v4;
  return result;
}

Swift::tuple_partialValue_Int64_overflow_Bool __swiftcall Int64.subtractingReportingOverflow(_:)(Swift::Int64 a1)
{
  BOOL v2 = __OFSUB__(v1, a1);
  Swift::Int64 v3 = v1 - a1;
  Swift::Bool v4 = v2;
  result.partialValue = v3;
  result.overflow = v4;
  return result;
}

Swift::tuple_partialValue_Int64_overflow_Bool __swiftcall Int64.multipliedReportingOverflow(by:)(Swift::Int64 by)
{
  Swift::Int64 v2 = v1 * by;
  Swift::Bool v3 = (unsigned __int128)(v1 * (__int128)by) >> 64 != (v1 * by) >> 63;
  Swift::Int64 v4 = v2;
  result.partialValue = v4;
  result.overflow = v3;
  return result;
}

uint64_t *static Int64.%= infix(_:_:)(uint64_t *a1, uint64_t a2)
{
  return static Int64.%= infix(_:_:)(a1, a2, 0x2CCCuLL, 0x2CD1uLL);
}

uint64_t static Int64.& infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 & a1;
}

uint64_t static Int64.bitWidth.getter()
{
  return 64;
}

uint64_t Int64.Words._value.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*Int64.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.Words.count.getter()
{
  return 1;
}

uint64_t Int64.Words.startIndex.getter()
{
  return 0;
}

uint64_t Int64.Words.endIndex.getter()
{
  return 1;
}

uint64_t Int64.Words.indices.getter()
{
  return 0;
}

uint64_t Int64.Words.subscript.getter(uint64_t a1, uint64_t a2)
{
  return UInt64.Words.subscript.getter(a1, a2, 0x2DCEuLL, 0x2DCFuLL);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Int64.Words(uint64_t *a1, uint64_t *a2))()
{
  uint64_t v4 = *v2;
  Int64.Words.subscript.getter(*a2, v4);
  *a1 = v4;
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.magnitude.getter(uint64_t result)
{
  if (result < 0) {
    return -result;
  }
  return result;
}

Swift::tuple_quotient_Int64_remainder_Int64 __swiftcall Int64.dividingFullWidth(_:)(Swift::tuple_high_Int64_low_UInt64 a1)
{
  Swift::Int64 v2 = Int64.dividingFullWidth(_:)(a1.high, a1.low, v1, 0x2E5BuLL, 0x2E6CuLL);
  result.remainder = v3;
  result.quotient = v2;
  return result;
}

BOOL static Int64.> infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 < a1;
}

void protocol witness for static FixedWidthInteger.max.getter in conformance Int64(void *a1@<X8>)
{
  *a1 = 0x7FFFFFFFFFFFFFFFLL;
}

void protocol witness for static FixedWidthInteger.min.getter in conformance Int64(void *a1@<X8>)
{
  *a1 = 0x8000000000000000;
}

Swift::Int64 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int64(Swift::Int64 *a1, Swift::Int64 *a2, Swift::tuple_high_Int64_low_UInt64 *a3)
{
  Swift::tuple_quotient_Int64_remainder_Int64 v6 = Int64.dividingFullWidth(_:)(*a3);
  Swift::Int64 result = v6.quotient;
  *a1 = v6.quotient;
  *a2 = v6.remainder;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int64 and conformance Int64(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int64@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type Int64 and conformance Int64, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int64 and conformance Int64(a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

void *protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int64@<X0>(void *result@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2BE7uLL, 0);
  }
  if (*result == 0x8000000000000000 && v3 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x2BEEuLL, 0);
  }
  *a3 = *result / v3;
  return result;
}

uint64_t static Int64./ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return static Int./ infix(_:_:)(a1, a2, 0x2BE7uLL, 0x2BEEuLL);
}

uint64_t static Int./ infix(_:_:)(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, a3, 0);
  }
  if (a1 == 0x8000000000000000 && a2 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  }
  return a1 / a2;
}

uint64_t *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int64(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int64(a1, a2, a3, a4, 0x2BE7uLL, 0x2BEEuLL);
}

uint64_t *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int64@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int64(a1, a2, 0x2CCCuLL, 0x2CD1uLL, a3);
}

uint64_t static Int64.% infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return static Int.% infix(_:_:)(a1, a2, 0x2CCCuLL, 0x2CD1uLL);
}

uint64_t static Int.% infix(_:_:)(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, a3, 0);
  }
  if (a1 == 0x8000000000000000 && a2 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  }
  return a1 % a2;
}

uint64_t *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int64(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int64(a1, a2, a3, a4, 0x2CCCuLL, 0x2CD1uLL);
}

uint64_t static Int64.^ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 ^ a1;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int64@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v120 = a5;
  uint64_t v111 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v111, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v109 = (char *)&v106 - v10;
  uint64_t v11 = *(void (**)(char *, uint64_t))(a3 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v106 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v107 = (char *)&v106 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v114 = (char *)&v106 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  unint64_t v113 = (char *)&v106 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  v108 = (char *)&v106 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v115 = (char *)&v106 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v121 = (char *)&v106 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v28 = (char *)&v106 - v27;
  uint64_t v119 = *a1;
  uint64_t v30 = a4 + 64;
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if (v29(a3, a4))
  {
    int64_t v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v31 = v122(a3, a4);
    if (v31 < 64)
    {
LABEL_9:
      (*((void (**)(char *, uint64_t, uint64_t))v11 + 2))(v28, a2, a3);
      uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*((uint64_t (**)(char *, uint64_t))v11 + 1))(v28, a3);
      if (v39 < -64) {
        goto LABEL_10;
      }
LABEL_14:
      char v47 = v29(a3, a4);
      uint64_t v112 = a4 + 128;
      uint64_t v48 = v122(a3, a4);
      char v118 = v29;
      uint64_t v116 = v30;
      if (v47)
      {
        if (v48 > 64) {
          goto LABEL_16;
        }
      }
      else if (v48 > 63)
      {
LABEL_16:
        v124[0] = 64;
        unint64_t v51 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v52 = lazy protocol witness table accessor for type Int and conformance Int(v48, v49, v50);
        v51(v124, &type metadata for Int, v52, a3, a4);
        char v53 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v28, a2, a3);
        char v54 = (uint64_t (*)(char *, uint64_t))*((void *)v11 + 1);
        uint64_t result = v54(v28, a3);
        if (v53) {
          goto LABEL_20;
        }
LABEL_21:
        uint64_t v56 = v28;
        uint64_t v117 = (void (*)(char *, uint64_t))v54;
        uint64_t v57 = (char *)v11 + 16;
        uint64_t v58 = (void (*)(char *, uint64_t, uint64_t))*((void *)v11 + 2);
        uint64_t v59 = v121;
        v58(v121, a2, a3);
        char v60 = v118(a3, a4);
        uint64_t v61 = v115;
        uint64_t v62 = v59;
        uint64_t v106 = v57;
        uint64_t v63 = (void (*)(char *, char *, uint64_t))v58;
        v58(v115, (uint64_t)v62, a3);
        if ((v60 & 1) == 0)
        {
          v117(v61, a3);
          uint64_t v65 = v56;
          goto LABEL_38;
        }
        uint64_t v64 = v122(a3, a4);
        v117(v61, a3);
        uint64_t v65 = v56;
        uint64_t v66 = v118;
        if (v64 <= 64) {
          goto LABEL_38;
        }
        uint64_t v67 = v108;
        v63(v108, v121, a3);
        v124[0] = 0x8000000000000000;
        if (v66(a3, a4))
        {
          uint64_t v68 = v122(a3, a4);
          if (v68 >= 64) {
            goto LABEL_29;
          }
        }
        else
        {
          char v71 = v66(a3, a4);
          uint64_t v68 = v122(a3, a4);
          if (v71)
          {
            if (v68 <= 64)
            {
              signed int v78 = AssociatedTypeWitness;
              uint64_t v77 = v111;
              uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              char v80 = v109;
              (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v78, AssociatedConformanceWitness);
              ((void (*)(char *, uint64_t, int **))v77[3])(v80, a3, v77);
              uint64_t v81 = v108;
              char v82 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v108, v65, a3);
              int64_t v83 = v117;
              v117(v65, a3);
              uint64_t v84 = v107;
              v63(v107, v81, a3);
              if (v82)
              {
                v83(v84, a3);
                goto LABEL_59;
              }
              uint64_t v85 = v124[0];
              uint64_t v86 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              v83(v84, a3);
              BOOL v87 = v86 < v85;
              uint64_t v67 = v108;
              uint64_t v75 = v83;
              if (v87) {
                goto LABEL_59;
              }
LABEL_37:
              v75(v67, a3);
LABEL_38:
              uint64_t v88 = v121;
              uint64_t v89 = v122;
              uint64_t v90 = v122(a3, a4);
              char v91 = v113;
              v63(v113, v88, a3);
              if (v90 < 65)
              {
                uint64_t v100 = v89(a3, a4);
                v117(v91, a3);
                uint64_t v92 = v114;
                if (v100 != 64 || (v118(a3, a4) & 1) != 0) {
                  goto LABEL_51;
                }
              }
              else
              {
                v117(v91, a3);
                uint64_t v92 = v114;
              }
              v63(v92, v121, a3);
              v124[0] = 0x7FFFFFFFFFFFFFFFLL;
              char v93 = v118(a3, a4);
              uint64_t v94 = v122(a3, a4);
              if (v93)
              {
                if (v94 > 64)
                {
                  unint64_t v97 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
                  unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v94, v95, v96);
                  uint64_t v99 = v124;
LABEL_49:
                  v97(v99, &type metadata for Int, v98, a3, a4);
                  char v102 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                            + 16))(v65, v92, a3);
                  unint64_t v103 = v117;
                  v117(v65, a3);
                  if (v102) {
                    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
                  }
                  v103(v92, a3);
                  goto LABEL_51;
                }
              }
              else if (v94 > 63)
              {
                uint64_t v123 = 0x7FFFFFFFFFFFFFFFLL;
                unint64_t v97 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
                unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v94, v95, v96);
                uint64_t v99 = &v123;
                goto LABEL_49;
              }
              v63(v65, v92, a3);
              (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              char v101 = v117;
              v117(v65, a3);
              v101(v92, a3);
LABEL_51:
              unint64_t v104 = v121;
              unint64_t v105 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
              uint64_t result = ((uint64_t (*)(char *, uint64_t))v117)(v104, a3);
              if ((v105 & 0x8000000000000000) != 0)
              {
                if (v105 > 0xFFFFFFFFFFFFFFC0)
                {
                  uint64_t v40 = v119 << -(char)v105;
                  goto LABEL_54;
                }
                goto LABEL_10;
              }
              if (v105 < 0x40)
              {
                uint64_t v40 = v119 >> v105;
                goto LABEL_54;
              }
LABEL_20:
              uint64_t v40 = v119 >> 63;
              goto LABEL_54;
            }
LABEL_29:
            char v72 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
            unint64_t v73 = lazy protocol witness table accessor for type Int and conformance Int(v68, v69, v70);
            v72(v124, &type metadata for Int, v73, a3, a4);
            uint64_t v67 = v108;
            char v74 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v108, v65, a3);
            uint64_t v75 = v117;
            v117(v65, a3);
            if (v74) {
              goto LABEL_59;
            }
            goto LABEL_37;
          }
          if (v68 >= 64)
          {
            v117(v67, a3);
            goto LABEL_38;
          }
        }
        v63(v65, v67, a3);
        uint64_t v76 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        uint64_t v75 = v117;
        v117(v65, a3);
        if (v76 < v124[0]) {
LABEL_59:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_37;
      }
      (*((void (**)(char *, uint64_t, uint64_t))v11 + 2))(v28, a2, a3);
      uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      char v54 = (uint64_t (*)(char *, uint64_t))*((void *)v11 + 1);
      uint64_t result = v54(v28, a3);
      if (v55 > 64) {
        goto LABEL_20;
      }
      goto LABEL_21;
    }
    goto LABEL_6;
  }
  char v34 = v29(a3, a4);
  int64_t v122 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v31 = v122(a3, a4);
  if ((v34 & 1) == 0)
  {
    if (v31 >= 64) {
      goto LABEL_14;
    }
    goto LABEL_9;
  }
  if (v31 > 64)
  {
LABEL_6:
    v124[0] = -64;
    char v35 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v36 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
    v35(v124, &type metadata for Int, v36, a3, a4);
    char v37 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v28, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v11 + 1))(v28, a3);
    if (v37) {
      goto LABEL_10;
    }
    goto LABEL_14;
  }
  uint64_t v116 = a4 + 64;
  char v118 = v29;
  uint64_t v41 = AssociatedTypeWitness;
  uint64_t v42 = v111;
  uint64_t v43 = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  char v44 = v109;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v43 + 8))(&qword_18162B0B8, 256, v41, v43);
  ((void (*)(char *, uint64_t, int **))v42[3])(v44, a3, v42);
  LOBYTE(v41) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v28, a3);
  unint64_t v45 = (void (*)(char *, uint64_t))*((void *)v11 + 1);
  v45(v28, a3);
  uint64_t v117 = v11;
  (*((void (**)(char *, uint64_t, uint64_t))v11 + 2))(v14, a2, a3);
  if (v41)
  {
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v45)(v14, a3);
    uint64_t v40 = 0;
    goto LABEL_54;
  }
  uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v45)(v14, a3);
  uint64_t v11 = v117;
  uint64_t v29 = v118;
  uint64_t v30 = v116;
  if (v46 >= -64) {
    goto LABEL_14;
  }
LABEL_10:
  uint64_t v40 = 0;
LABEL_54:
  uint64_t *v120 = v40;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int64(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v120 = a1;
  uint64_t v110 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v110, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v108 = (char *)&v105 - v8;
  uint64_t v9 = *(uint64_t (**)(char *, uint64_t))(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v12 = (char *)&v105 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v106 = (char *)&v105 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  unint64_t v113 = (char *)&v105 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v112 = (char *)&v105 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v107 = (char *)&v105 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v114 = (char *)&v105 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  char v118 = (char *)&v105 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v26 = (char *)&v105 - v25;
  uint64_t v28 = a4 + 64;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v27(a3, a4) & 1) == 0)
  {
    char v32 = v27(a3, a4);
    uint64_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v29 = v119(a3, a4);
    if ((v32 & 1) == 0)
    {
      if (v29 >= 64) {
        goto LABEL_14;
      }
      goto LABEL_9;
    }
    if (v29 <= 64)
    {
      uint64_t v115 = a4 + 64;
      uint64_t v117 = v27;
      uint64_t v39 = AssociatedTypeWitness;
      uint64_t v40 = v110;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v110, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v42 = v108;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v39, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v40[3])(v42, a3, v40);
      LOBYTE(v39) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
      uint64_t v43 = (void (*)(char *, uint64_t))*((void *)v9 + 1);
      v43(v26, a3);
      uint64_t v116 = v9;
      (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v12, a2, a3);
      if (v39)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v43)(v12, a3);
        uint64_t v38 = 0;
        goto LABEL_53;
      }
      uint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v43)(v12, a3);
      uint64_t v9 = v116;
      uint64_t v27 = v117;
      uint64_t v28 = v115;
      if (v44 < -64) {
        goto LABEL_10;
      }
      goto LABEL_14;
    }
LABEL_6:
    int64_t v122 = -64;
    uint64_t v33 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v34 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
    v33(&v122, &type metadata for Int, v34, a3, a4);
    char v35 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
    if (v35) {
      goto LABEL_10;
    }
    goto LABEL_14;
  }
  uint64_t v119 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v29 = v119(a3, a4);
  if (v29 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
  if (v37 < -64)
  {
LABEL_10:
    uint64_t v38 = 0;
    goto LABEL_53;
  }
LABEL_14:
  char v45 = v27(a3, a4);
  uint64_t v111 = a4 + 128;
  uint64_t v46 = v119(a3, a4);
  uint64_t v117 = v27;
  uint64_t v115 = v28;
  if (v45)
  {
    if (v46 > 64) {
      goto LABEL_16;
    }
  }
  else if (v46 >= 64)
  {
LABEL_16:
    int64_t v122 = 64;
    uint64_t v49 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v50 = lazy protocol witness table accessor for type Int and conformance Int(v46, v47, v48);
    v49(&v122, &type metadata for Int, v50, a3, a4);
    char v51 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v26, a2, a3);
    unint64_t v52 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
    uint64_t result = v52(v26, a3);
    if ((v51 & 1) == 0) {
      goto LABEL_17;
    }
LABEL_24:
    uint64_t v38 = *v120 >> 63;
    goto LABEL_53;
  }
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v68 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  unint64_t v52 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
  uint64_t result = v52(v26, a3);
  if (v68 > 64) {
    goto LABEL_24;
  }
LABEL_17:
  char v53 = v26;
  uint64_t v116 = v52;
  char v54 = (char *)v9 + 16;
  uint64_t v55 = (void (*)(char *, uint64_t, uint64_t))*((void *)v9 + 2);
  uint64_t v56 = v118;
  v55(v118, a2, a3);
  char v57 = v117(a3, a4);
  uint64_t v58 = v114;
  uint64_t v59 = v56;
  unint64_t v105 = v54;
  char v60 = (void (*)(char *, char *, uint64_t))v55;
  v55(v114, (uint64_t)v59, a3);
  if ((v57 & 1) == 0)
  {
    v116(v58, a3);
    uint64_t v62 = v53;
    goto LABEL_37;
  }
  uint64_t v61 = v119(a3, a4);
  v116(v58, a3);
  uint64_t v62 = v53;
  uint64_t v63 = v117;
  if (v61 <= 64) {
    goto LABEL_37;
  }
  uint64_t v64 = v107;
  v60(v107, v118, a3);
  int64_t v122 = 0x8000000000000000;
  if (v63(a3, a4))
  {
    uint64_t v65 = v119(a3, a4);
    if (v65 >= 64)
    {
LABEL_28:
      uint64_t v70 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v71 = lazy protocol witness table accessor for type Int and conformance Int(v65, v66, v67);
      v70(&v122, &type metadata for Int, v71, a3, a4);
      uint64_t v64 = v107;
      char v72 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v107, v62, a3);
      unint64_t v73 = (void (*)(char *, uint64_t))v116;
      v116(v62, a3);
      if (v72) {
        goto LABEL_59;
      }
      goto LABEL_36;
    }
LABEL_32:
    v60(v62, v64, a3);
    uint64_t v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    unint64_t v73 = (void (*)(char *, uint64_t))v116;
    v116(v62, a3);
    if (v74 < v122) {
LABEL_59:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_36;
  }
  char v69 = v63(a3, a4);
  uint64_t v65 = v119(a3, a4);
  if ((v69 & 1) == 0)
  {
    if (v65 >= 64)
    {
      v116(v64, a3);
      goto LABEL_37;
    }
    goto LABEL_32;
  }
  if (v65 > 64) {
    goto LABEL_28;
  }
  uint64_t v76 = AssociatedTypeWitness;
  uint64_t v75 = v110;
  uint64_t v77 = swift_getAssociatedConformanceWitness((uint64_t)v110, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  signed int v78 = v108;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v77 + 8))(&qword_18162B0B8, 256, v76, v77);
  ((void (*)(char *, uint64_t, int **))v75[3])(v78, a3, v75);
  uint64_t v79 = v107;
  char v80 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v107, v62, a3);
  uint64_t v81 = (void (*)(char *, uint64_t))v116;
  v116(v62, a3);
  char v82 = v106;
  v60(v106, v79, a3);
  if (v80)
  {
    v81(v82, a3);
    goto LABEL_59;
  }
  int64_t v83 = v122;
  uint64_t v84 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v81(v82, a3);
  BOOL v85 = v84 < v83;
  uint64_t v64 = v107;
  unint64_t v73 = v81;
  if (v85) {
    goto LABEL_59;
  }
LABEL_36:
  v73(v64, a3);
LABEL_37:
  uint64_t v86 = v118;
  BOOL v87 = v119;
  uint64_t v88 = v119(a3, a4);
  uint64_t v89 = v112;
  v60(v112, v86, a3);
  if (v88 < 65)
  {
    uint64_t v98 = v87(a3, a4);
    v116(v89, a3);
    uint64_t v90 = v113;
    if (v98 != 64 || (v117(a3, a4) & 1) != 0) {
      goto LABEL_50;
    }
  }
  else
  {
    v116(v89, a3);
    uint64_t v90 = v113;
  }
  v60(v90, v118, a3);
  int64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
  char v91 = v117(a3, a4);
  uint64_t v92 = v119(a3, a4);
  if ((v91 & 1) == 0)
  {
    if (v92 >= 64)
    {
      uint64_t v121 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
      unint64_t v97 = &v121;
      goto LABEL_48;
    }
LABEL_47:
    v60(v62, v90, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v99 = (void (*)(char *, uint64_t))v116;
    v116(v62, a3);
    v99(v90, a3);
    goto LABEL_50;
  }
  if (v92 <= 64) {
    goto LABEL_47;
  }
  uint64_t v95 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v96 = lazy protocol witness table accessor for type Int and conformance Int(v92, v93, v94);
  unint64_t v97 = &v122;
LABEL_48:
  v95(v97, &type metadata for Int, v96, a3, a4);
  char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v62, v90, a3);
  char v101 = (void (*)(char *, uint64_t))v116;
  v116(v62, a3);
  if (v100) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v101(v90, a3);
LABEL_50:
  char v102 = v118;
  unint64_t v103 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = v116(v102, a3);
  uint64_t v104 = *v120;
  if ((v103 & 0x8000000000000000) != 0)
  {
    if (v103 > 0xFFFFFFFFFFFFFFC0)
    {
      uint64_t v38 = v104 << -(char)v103;
      goto LABEL_53;
    }
    goto LABEL_10;
  }
  if (v103 >= 0x40) {
    uint64_t v38 = v104 >> 63;
  }
  else {
    uint64_t v38 = v104 >> v103;
  }
LABEL_53:
  uint64_t *v120 = v38;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int64@<X0>(uint64_t *a1@<X0>, uint64_t (*a2)(char *, uint64_t)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  v134 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v134, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v132 = (char *)v125 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)v125 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  v129 = (char *)v125 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v135 = (char *)v125 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)v125 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  unint64_t v130 = (char *)v125 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v136 = (char *)v125 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  v140 = (char *)v125 - v28;
  MEMORY[0x1F4188790](v27);
  uint64_t v30 = (char *)v125 - v29;
  uint64_t v138 = *a1;
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v142 = a4 + 64;
  char v32 = v31(a3, a4);
  v139 = a5;
  if (v32)
  {
    uint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v33(a3, a4);
    if (v34 < 64)
    {
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      if (v37 > -65) {
        goto LABEL_19;
      }
LABEL_18:
      uint64_t v59 = v139;
      uint64_t v60 = v138 >> 63;
      goto LABEL_60;
    }
    v144[0] = -64;
    v141 = v33;
    uint64_t v47 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v48 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
    v47(v144, &type metadata for Int, v48, a3, a4);
    uint64_t v33 = v141;
    char v49 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                              + 16))(a2, v30, a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
    if (v49) {
      goto LABEL_18;
    }
  }
  else
  {
    char v39 = v31(a3, a4);
    uint64_t v40 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    v137 = a2;
    v141 = v40;
    uint64_t v41 = v40(a3, a4);
    if (v39)
    {
      unsigned int v131 = v31;
      if (v41 <= 64)
      {
        char v51 = AssociatedTypeWitness;
        unint64_t v52 = v134;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v134, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v54 = v132;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v51, AssociatedConformanceWitness);
        ((void (*)(char *, uint64_t, int **))v52[3])(v54, a3, v52);
        uint64_t v55 = v137;
        LOBYTE(v51) = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v137, v30, a3);
        uint64_t v56 = v12;
        char v57 = *(void (**)(char *, uint64_t))(v12 + 8);
        v57(v30, a3);
        uint64_t v128 = v56;
        (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v56 + 16))(v15, v55, a3);
        if (v51)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
        }
        else
        {
          uint64_t v58 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v57)(v15, a3);
          uint64_t v12 = v128;
          uint64_t v31 = v131;
          uint64_t v33 = v141;
          a2 = v137;
          if (v58 >= -64) {
            goto LABEL_19;
          }
        }
        goto LABEL_18;
      }
      v144[0] = -64;
      uint64_t v44 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v45 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
      v44(v144, &type metadata for Int, v45, a3, a4);
      a2 = v137;
      char v46 = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                                + 16))(v137, v30, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      uint64_t v31 = v131;
      uint64_t v33 = v141;
      if (v46) {
        goto LABEL_18;
      }
    }
    else
    {
      if (v41 >= 64)
      {
        uint64_t v33 = v141;
        a2 = v137;
        goto LABEL_19;
      }
      a2 = v137;
      (*(void (**)(char *, uint64_t (*)(char *, uint64_t), uint64_t))(v12 + 16))(v30, v137, a3);
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v30, a3);
      uint64_t v33 = v141;
      if (v50 < -64) {
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  char v61 = v31(a3, a4);
  uint64_t v62 = a4 + 128;
  uint64_t v63 = (uint64_t (*)(uint64_t, uint64_t))a4;
  uint64_t v64 = (char *)a2;
  uint64_t v65 = v62;
  unsigned int v131 = v63;
  uint64_t v66 = ((uint64_t (*)(uint64_t))v33)(a3);
  v125[0] = v22;
  v125[1] = v65;
  if (v61)
  {
    if (v66 > 64) {
      goto LABEL_21;
    }
  }
  else if (v66 > 63)
  {
LABEL_21:
    v144[0] = 64;
    char v69 = v131;
    uint64_t v70 = v31;
    unint64_t v71 = (void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (**)(uint64_t, void)))*((void *)v131 + 12);
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v71(v144, &type metadata for Int, v72, a3, (uint64_t (**)(uint64_t, void))v69);
    uint64_t v31 = v70;
    unint64_t v73 = v64;
    uint64_t v74 = v69;
    char v75 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v69 + 4) + 8) + 16))(v30, v73, a3);
    uint64_t v76 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    uint64_t result = v76(v30, a3);
    if ((v75 & 1) == 0) {
      goto LABEL_22;
    }
LABEL_29:
    uint64_t v60 = 0;
    uint64_t v59 = v139;
    goto LABEL_60;
  }
  unint64_t v73 = v64;
  (*(void (**)(char *, char *, uint64_t))(v12 + 16))(v30, v64, a3);
  uint64_t v74 = v131;
  uint64_t v89 = (*((uint64_t (**)(uint64_t, void))v131 + 15))(a3, v131);
  uint64_t v76 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  uint64_t result = v76(v30, a3);
  if (v89 > 64) {
    goto LABEL_29;
  }
LABEL_22:
  v137 = v76;
  v141 = v33;
  uint64_t v77 = v31;
  uint64_t v79 = v12 + 16;
  signed int v78 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
  uint64_t v80 = v12;
  uint64_t v81 = v140;
  v78(v140, v73, a3);
  char v82 = v77;
  LOBYTE(v77) = v77(a3, (uint64_t)v74);
  int64_t v83 = v136;
  v126 = v78;
  uint64_t v127 = v79;
  v78(v136, v81, a3);
  uint64_t v128 = v80;
  if ((v77 & 1) == 0)
  {
    v137(v83, a3);
    goto LABEL_44;
  }
  uint64_t v84 = v141(a3, (uint64_t)v74);
  v137(v83, a3);
  if (v84 <= 64) {
    goto LABEL_44;
  }
  BOOL v85 = v130;
  v126(v130, v140, a3);
  v144[0] = 0x8000000000000000;
  if (v82(a3, (uint64_t)v74))
  {
    uint64_t v86 = v141(a3, (uint64_t)v74);
    if (v86 < 64)
    {
LABEL_37:
      v126(v30, v85, a3);
      uint64_t v95 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
      uint64_t v94 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      if (v95 < v144[0]) {
        goto LABEL_65;
      }
      goto LABEL_43;
    }
  }
  else
  {
    char v90 = v82(a3, (uint64_t)v74);
    uint64_t v86 = v141(a3, (uint64_t)v74);
    if ((v90 & 1) == 0)
    {
      if (v86 >= 64)
      {
        v137(v85, a3);
        goto LABEL_44;
      }
      goto LABEL_37;
    }
    if (v86 <= 64)
    {
      unsigned int v131 = v82;
      unint64_t v97 = AssociatedTypeWitness;
      unint64_t v96 = v134;
      uint64_t v98 = swift_getAssociatedConformanceWitness((uint64_t)v134, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v99 = v132;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v98 + 8))(&qword_18162B0B8, 256, v97, v98);
      ((void (*)(char *, uint64_t, int **))v96[3])(v99, a3, v96);
      char v100 = v130;
      char v101 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v74 + 4) + 8) + 16))(v130, v30, a3);
      char v102 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      unint64_t v103 = v129;
      v126(v129, v100, a3);
      if (v101)
      {
        v102(v103, a3);
        goto LABEL_65;
      }
      uint64_t v104 = v144[0];
      uint64_t v105 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
      v102(v103, a3);
      BOOL v106 = v105 < v104;
      BOOL v85 = v130;
      char v82 = v131;
      uint64_t v94 = v102;
      if (v106) {
LABEL_65:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_43;
    }
  }
  char v91 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
  unint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v86, v87, v88);
  ((void (*)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v91)(v144, &type metadata for Int, v92, a3, v131);
  BOOL v85 = v130;
  uint64_t v74 = v131;
  char v93 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v131 + 4) + 8) + 16))(v130, v30, a3);
  uint64_t v94 = (void (*)(char *, uint64_t))v137;
  v137(v30, a3);
  if (v93) {
    goto LABEL_65;
  }
LABEL_43:
  v94(v85, a3);
LABEL_44:
  uint64_t v107 = v140;
  v108 = v141;
  uint64_t v109 = v141(a3, (uint64_t)v74);
  uint64_t v110 = (char *)v125[0];
  v126((char *)v125[0], v107, a3);
  if (v109 < 65)
  {
    uint64_t v119 = v108(a3, (uint64_t)v74);
    v137(v110, a3);
    uint64_t v111 = v135;
    if (v119 != 64 || (v82(a3, (uint64_t)v74) & 1) != 0) {
      goto LABEL_57;
    }
  }
  else
  {
    v137(v110, a3);
    uint64_t v111 = v135;
  }
  v126(v111, v140, a3);
  v144[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v112 = v82(a3, (uint64_t)v74);
  uint64_t v113 = v141(a3, (uint64_t)v74);
  if (v112)
  {
    if (v113 > 64)
    {
      uint64_t v116 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
      unint64_t v117 = lazy protocol witness table accessor for type Int and conformance Int(v113, v114, v115);
      char v118 = v144;
LABEL_55:
      ((void (*)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))v116)(v118, &type metadata for Int, v117, a3, v74);
      char v121 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*((void *)v74 + 4) + 8) + 16))(v30, v111, a3);
      int64_t v122 = (void (*)(char *, uint64_t))v137;
      v137(v30, a3);
      if (v121) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      v122(v111, a3);
      goto LABEL_57;
    }
  }
  else if (v113 > 63)
  {
    uint64_t v143 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v116 = (uint64_t (*)(uint64_t, void))*((void *)v74 + 12);
    unint64_t v117 = lazy protocol witness table accessor for type Int and conformance Int(v113, v114, v115);
    char v118 = &v143;
    goto LABEL_55;
  }
  v126(v30, v111, a3);
  (*((void (**)(uint64_t, uint64_t (*)(uint64_t, uint64_t)))v74 + 15))(a3, v74);
  uint64_t v120 = (void (*)(char *, uint64_t))v137;
  v137(v30, a3);
  v120(v111, a3);
LABEL_57:
  uint64_t v123 = v140;
  unint64_t v124 = (*((uint64_t (**)(uint64_t, void))v74 + 15))(a3, v74);
  uint64_t result = v137(v123, a3);
  if ((v124 & 0x8000000000000000) != 0)
  {
    uint64_t v59 = v139;
    if (v124 <= 0xFFFFFFFFFFFFFFC0) {
      uint64_t v60 = v138 >> 63;
    }
    else {
      uint64_t v60 = v138 >> -(char)v124;
    }
  }
  else
  {
    uint64_t v59 = v139;
    uint64_t v60 = v138 << v124;
    if (v124 >= 0x40) {
      uint64_t v60 = 0;
    }
  }
LABEL_60:
  *uint64_t v59 = v60;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int64(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v121 = a1;
  uint64_t v111 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v111, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v109 = (char *)&v106 - v8;
  uint64_t v9 = *(char **)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v12 = (char *)&v106 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v107 = (char *)&v106 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v114 = (char *)&v106 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v113 = (char *)&v106 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  v108 = (char *)&v106 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v115 = (char *)&v106 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v119 = (char *)&v106 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v26 = (char *)&v106 - v25;
  uint64_t v28 = a4 + 64;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  if ((v27(a3, a4) & 1) == 0)
  {
    char v34 = v27(a3, a4);
    uint64_t v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v29 = v120(a3, a4);
    if ((v34 & 1) == 0)
    {
      if (v29 < 64)
      {
        (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
        uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
        if (v38 < -64) {
          goto LABEL_15;
        }
      }
      goto LABEL_16;
    }
    if (v29 <= 64)
    {
      uint64_t v116 = a4 + 64;
      char v118 = v27;
      char v39 = AssociatedTypeWitness;
      uint64_t v40 = v111;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v42 = v109;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v39, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v40[3])(v42, a3, v40);
      LOBYTE(v39) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
      uint64_t v43 = (void (*)(char *, uint64_t))*((void *)v9 + 1);
      v43(v26, a3);
      unint64_t v117 = v9;
      (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v12, a2, a3);
      if (v39)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v43)(v12, a3);
      }
      else
      {
        uint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v43)(v12, a3);
        uint64_t v9 = v117;
        uint64_t v27 = v118;
        uint64_t v28 = v116;
        if (v44 >= -64) {
          goto LABEL_16;
        }
      }
LABEL_15:
      uint64_t v45 = *v121 >> 63;
      goto LABEL_55;
    }
    goto LABEL_7;
  }
  uint64_t v120 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v29 = v120(a3, a4);
  if (v29 >= 64)
  {
LABEL_7:
    int64_t v123 = -64;
    uint64_t v35 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v36 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
    v35(&v123, &type metadata for Int, v36, a3, a4);
    char v37 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v26, a3);
    uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
    if (v37) {
      goto LABEL_15;
    }
    goto LABEL_16;
  }
  (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
  uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*((uint64_t (**)(char *, uint64_t))v9 + 1))(v26, a3);
  if (v32 <= -65) {
    goto LABEL_15;
  }
LABEL_16:
  char v46 = v27(a3, a4);
  uint64_t v112 = a4 + 128;
  uint64_t v47 = v120(a3, a4);
  char v118 = v27;
  uint64_t v116 = v28;
  if (v46)
  {
    if (v47 > 64) {
      goto LABEL_18;
    }
LABEL_21:
    (*((void (**)(char *, uint64_t, uint64_t))v9 + 2))(v26, a2, a3);
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v53 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
    uint64_t result = v53(v26, a3);
    if (v54 > 64) {
      goto LABEL_19;
    }
    goto LABEL_22;
  }
  if (v47 < 64) {
    goto LABEL_21;
  }
LABEL_18:
  int64_t v123 = 64;
  uint64_t v50 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v51 = lazy protocol witness table accessor for type Int and conformance Int(v47, v48, v49);
  v50(&v123, &type metadata for Int, v51, a3, a4);
  char v52 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v26, a2, a3);
  char v53 = (uint64_t (*)(char *, uint64_t))*((void *)v9 + 1);
  uint64_t result = v53(v26, a3);
  if (v52)
  {
LABEL_19:
    uint64_t v45 = 0;
    goto LABEL_55;
  }
LABEL_22:
  uint64_t v55 = v26;
  unint64_t v117 = (char *)v53;
  uint64_t v56 = v9 + 16;
  char v57 = (void (*)(char *, uint64_t, uint64_t))*((void *)v9 + 2);
  uint64_t v58 = v119;
  v57(v119, a2, a3);
  char v59 = v118(a3, a4);
  uint64_t v60 = v115;
  char v61 = v58;
  BOOL v106 = v56;
  uint64_t v62 = (void (*)(char *, char *, uint64_t))v57;
  v57(v115, (uint64_t)v61, a3);
  if ((v59 & 1) == 0)
  {
    ((void (*)(char *, uint64_t))v117)(v60, a3);
    uint64_t v64 = v55;
    goto LABEL_39;
  }
  uint64_t v63 = v120(a3, a4);
  ((void (*)(char *, uint64_t))v117)(v60, a3);
  uint64_t v64 = v55;
  uint64_t v65 = v118;
  if (v63 <= 64) {
    goto LABEL_39;
  }
  uint64_t v66 = v108;
  v62(v108, v119, a3);
  int64_t v123 = 0x8000000000000000;
  if (v65(a3, a4))
  {
    uint64_t v67 = v120(a3, a4);
    if (v67 >= 64)
    {
LABEL_30:
      unint64_t v71 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v67, v68, v69);
      v71(&v123, &type metadata for Int, v72, a3, a4);
      uint64_t v66 = v108;
      char v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v108, v64, a3);
      uint64_t v74 = v117;
      ((void (*)(char *, uint64_t))v117)(v64, a3);
      if (v73) {
        goto LABEL_60;
      }
      goto LABEL_38;
    }
LABEL_34:
    v62(v64, v66, a3);
    uint64_t v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v74 = v117;
    ((void (*)(char *, uint64_t))v117)(v64, a3);
    if (v75 < v123) {
LABEL_60:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_38;
  }
  char v70 = v65(a3, a4);
  uint64_t v67 = v120(a3, a4);
  if ((v70 & 1) == 0)
  {
    if (v67 >= 64)
    {
      ((void (*)(char *, uint64_t))v117)(v66, a3);
      goto LABEL_39;
    }
    goto LABEL_34;
  }
  if (v67 > 64) {
    goto LABEL_30;
  }
  uint64_t v77 = AssociatedTypeWitness;
  uint64_t v76 = v111;
  uint64_t v78 = swift_getAssociatedConformanceWitness((uint64_t)v111, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v79 = v109;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v78 + 8))(&qword_18162B0B8, 256, v77, v78);
  ((void (*)(char *, uint64_t, int **))v76[3])(v79, a3, v76);
  uint64_t v80 = v108;
  char v81 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v108, v64, a3);
  char v82 = v117;
  ((void (*)(char *, uint64_t))v117)(v64, a3);
  int64_t v83 = v107;
  v62(v107, v80, a3);
  if (v81)
  {
    ((void (*)(char *, uint64_t))v82)(v83, a3);
    goto LABEL_60;
  }
  int64_t v84 = v123;
  uint64_t v85 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  ((void (*)(char *, uint64_t))v82)(v83, a3);
  BOOL v86 = v85 < v84;
  uint64_t v66 = v108;
  uint64_t v74 = v82;
  if (v86) {
    goto LABEL_60;
  }
LABEL_38:
  ((void (*)(char *, uint64_t))v74)(v66, a3);
LABEL_39:
  uint64_t v87 = v119;
  uint64_t v88 = v120;
  uint64_t v89 = v120(a3, a4);
  char v90 = v113;
  v62(v113, v87, a3);
  if (v89 < 65)
  {
    uint64_t v99 = v88(a3, a4);
    ((void (*)(char *, uint64_t))v117)(v90, a3);
    char v91 = v114;
    if (v99 != 64 || (v118(a3, a4) & 1) != 0) {
      goto LABEL_52;
    }
  }
  else
  {
    ((void (*)(char *, uint64_t))v117)(v90, a3);
    char v91 = v114;
  }
  v62(v91, v119, a3);
  int64_t v123 = 0x7FFFFFFFFFFFFFFFLL;
  char v92 = v118(a3, a4);
  uint64_t v93 = v120(a3, a4);
  if (v92)
  {
    if (v93 > 64)
    {
      unint64_t v96 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v97 = lazy protocol witness table accessor for type Int and conformance Int(v93, v94, v95);
      uint64_t v98 = &v123;
LABEL_50:
      v96(v98, &type metadata for Int, v97, a3, a4);
      char v101 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v64, v91, a3);
      char v102 = v117;
      ((void (*)(char *, uint64_t))v117)(v64, a3);
      if (v101) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      ((void (*)(char *, uint64_t))v102)(v91, a3);
      goto LABEL_52;
    }
  }
  else if (v93 >= 64)
  {
    uint64_t v122 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v96 = *(void (**)(int64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v97 = lazy protocol witness table accessor for type Int and conformance Int(v93, v94, v95);
    uint64_t v98 = &v122;
    goto LABEL_50;
  }
  v62(v64, v91, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  char v100 = v117;
  ((void (*)(char *, uint64_t))v117)(v64, a3);
  ((void (*)(char *, uint64_t))v100)(v91, a3);
LABEL_52:
  unint64_t v103 = v119;
  unint64_t v104 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v117)(v103, a3);
  uint64_t v105 = *v121;
  if ((v104 & 0x8000000000000000) != 0)
  {
    if (v104 <= 0xFFFFFFFFFFFFFFC0) {
      uint64_t v45 = v105 >> 63;
    }
    else {
      uint64_t v45 = v105 >> -(char)v104;
    }
  }
  else
  {
    uint64_t v45 = v105 << v104;
    if (v104 >= 0x40) {
      uint64_t v45 = 0;
    }
  }
LABEL_55:
  *char v121 = v45;
  return result;
}

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int64(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, *v3, 0x2BE7uLL, 0x2BEEuLL);
  *a1 = result;
  return result;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance Int64(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance UInt64(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, uint64_t (*a4)(void *, uint64_t, uint64_t)@<X5>, uint64_t a5@<X8>)
{
  uint64_t v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0) {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v7)
  {
    uint64_t v10 = a3();
    if ((v11 & 0x100) != 0)
    {
      uint64_t v12 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10, a4);
      char v16 = v15;
      swift_bridgeObjectRelease(a2);
      int v14 = v16 & 1;
    }
    else
    {
      uint64_t v12 = v10;
      char v13 = v11;
      swift_bridgeObjectRelease(a2);
      int v14 = v13 & 1;
    }
    if (v14) {
      uint64_t v17 = 0;
    }
    else {
      uint64_t v17 = v12;
    }
  }
  else
  {
    swift_bridgeObjectRelease(a2);
    uint64_t v17 = 0;
    LOBYTE(v14) = 1;
  }
  *(void *)a5 = v17;
  *(unsigned char *)(a5 + 8) = v14;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int64(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type Int64 and conformance Int64, a5);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance Int64()
{
  return _int64ToString(_:radix:uppercase:)(*v0, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
}

uint64_t *protocol witness for Strideable.distance(to:) in conformance Int64@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = *result;
  uint64_t v4 = *v2;
  if (((*v2 ^ *result) & 0x8000000000000000) == 0)
  {
    BOOL v5 = __OFSUB__(v3, v4);
    uint64_t v4 = v3 - v4;
    if (!v5) {
      goto LABEL_15;
    }
    __break(1u);
  }
  if (v4 >= 0) {
    uint64_t v6 = v4;
  }
  else {
    uint64_t v6 = -v4;
  }
  if (v3 < 0) {
    uint64_t v3 = -v3;
  }
  BOOL v7 = __CFADD__(v6, v3);
  uint64_t v8 = v6 + v3;
  if (v7)
  {
    __break(1u);
LABEL_17:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Distance is not representable in Int", 36, 2, "Swift/Integers.swift", 20, 2, 0x64AuLL, 0);
  }
  if (v8 < 0) {
    goto LABEL_17;
  }
  if (v4 < 0) {
    uint64_t v4 = v8;
  }
  else {
    uint64_t v4 = -v8;
  }
LABEL_15:
  *a2 = v4;
  return result;
}

void *protocol witness for Strideable.advanced(by:) in conformance Int64@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (__OFADD__(*v2, *result)) {
    __break(1u);
  }
  else {
    *a2 = *v2 + *result;
  }
  return result;
}

BOOL static Int64.<= infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 >= a1;
}

void Int64.hash(into:)(int a1, Swift::UInt64 a2)
{
}

uint64_t Int64._toCustomAnyHashable()@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>);
  a2[3] = result;
  a2[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Int64@<X0>(void *a1@<X8>)
{
  uint64_t v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>);
  a1[3] = result;
  a1[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a1 = v3;
  return result;
}

uint64_t UInt._value.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*UInt._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

unint64_t UInt64.init(exactly:)(float a1)
{
  if (*(short float *)&a1 <= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(-1.0))) {
    return 0;
  }
  BOOL v1 = truncl(*(short float *)&a1) != *(short float *)&a1;
  if ((~LODWORD(a1) & 0x7C00) == 0 || v1) {
    return 0;
  }
  else {
    return (unint64_t)*(short float *)&a1;
  }
}

Swift::UInt_optional __swiftcall UInt.init(exactly:)(Swift::Float exactly)
{
  BOOL v1 = exactly > -1.0;
  if (exactly >= 1.8447e19) {
    BOOL v1 = 0;
  }
  int v2 = v1 & (truncf(exactly) == exactly);
  if (v2) {
    Swift::UInt v3 = (unint64_t)exactly;
  }
  else {
    Swift::UInt v3 = 0;
  }
  char v4 = v2 ^ 1;
  result.value = v3;
  result.is_nil = v4;
  return result;
}

Swift::UInt_optional __swiftcall UInt.init(exactly:)(Swift::Double exactly)
{
  BOOL v1 = exactly > -1.0;
  if (exactly >= 1.84467441e19) {
    BOOL v1 = 0;
  }
  int v2 = v1 & (trunc(exactly) == exactly);
  if (v2) {
    Swift::UInt v3 = (unint64_t)exactly;
  }
  else {
    Swift::UInt v3 = 0;
  }
  char v4 = v2 ^ 1;
  result.value = v3;
  result.is_nil = v4;
  return result;
}

void *static UInt.+= infix(_:_:)(void *result, uint64_t a2)
{
  if (__CFADD__(*result, a2)) {
    __break(1u);
  }
  else {
    *result += a2;
  }
  return result;
}

unint64_t *static UInt.-= infix(_:_:)(unint64_t *result, unint64_t a2)
{
  if (*result < a2) {
    __break(1u);
  }
  else {
    *result -= a2;
  }
  return result;
}

unint64_t *static UInt.*= infix(_:_:)(unint64_t *result, unint64_t a2)
{
  if (is_mul_ok(*result, a2)) {
    *result *= a2;
  }
  else {
    __break(1u);
  }
  return result;
}

void *static UInt./= infix(_:_:)(void *result, unint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x321DuLL, 0);
  }
  *result /= a2;
  return result;
}

Swift::tuple_partialValue_UInt_overflow_Bool __swiftcall UInt.addingReportingOverflow(_:)(Swift::UInt a1)
{
  BOOL v2 = __CFADD__(v1, a1);
  Swift::UInt v3 = v1 + a1;
  Swift::Bool v4 = v2;
  result.partialValue = v3;
  result.overflow = v4;
  return result;
}

Swift::tuple_partialValue_UInt_overflow_Bool __swiftcall UInt.subtractingReportingOverflow(_:)(Swift::UInt a1)
{
  BOOL v2 = v1 >= a1;
  Swift::UInt v3 = v1 - a1;
  Swift::Bool v4 = !v2;
  result.partialValue = v3;
  result.overflow = v4;
  return result;
}

Swift::tuple_partialValue_UInt_overflow_Bool __swiftcall UInt.multipliedReportingOverflow(by:)(Swift::UInt by)
{
  Swift::UInt v2 = v1 * by;
  Swift::Bool v3 = !is_mul_ok(v1, by);
  Swift::UInt v4 = v2;
  result.partialValue = v4;
  result.overflow = v3;
  return result;
}

Swift::tuple_partialValue_UInt_overflow_Bool __swiftcall UInt.dividedReportingOverflow(by:)(Swift::UInt by)
{
  Swift::UInt v2 = v1;
  if (by) {
    Swift::UInt v2 = v1 / by;
  }
  Swift::Bool v3 = by == 0;
  Swift::UInt v4 = v2;
  result.partialValue = v4;
  result.overflow = v3;
  return result;
}

Swift::tuple_partialValue_UInt_overflow_Bool __swiftcall UInt.remainderReportingOverflow(dividingBy:)(Swift::UInt dividingBy)
{
  Swift::UInt v2 = v1;
  if (dividingBy) {
    Swift::UInt v2 = v1 % dividingBy;
  }
  Swift::Bool v3 = dividingBy == 0;
  Swift::UInt v4 = v2;
  result.partialValue = v4;
  result.overflow = v3;
  return result;
}

void *static UInt.%= infix(_:_:)(void *result, unint64_t a2)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x32F1uLL, 0);
  }
  *result %= a2;
  return result;
}

void *static UInt.&>>= infix(_:_:)(void *result, char a2)
{
  *result >>= a2;
  return result;
}

uint64_t UInt.Words._value.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*UInt.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.Words.count.getter()
{
  return 1;
}

uint64_t UInt.Words.startIndex.getter()
{
  return 0;
}

uint64_t UInt.Words.endIndex.getter()
{
  return 1;
}

uint64_t UInt.Words.indices.getter()
{
  return 0;
}

uint64_t UInt.Words.subscript.getter(uint64_t a1, uint64_t a2)
{
  return UInt64.Words.subscript.getter(a1, a2, 0x33EFuLL, 0x33F0uLL);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UInt.Words(uint64_t *a1, uint64_t *a2))()
{
  uint64_t v4 = *v2;
  UInt.Words.subscript.getter(*a2, v4);
  *a1 = v4;
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.multipliedFullWidth(by:)(unint64_t a1, unint64_t a2)
{
  return (a2 * (unsigned __int128)a1) >> 64;
}

Swift::tuple_quotient_UInt_remainder_UInt __swiftcall UInt.dividingFullWidth(_:)(Swift::tuple_high_UInt_low_UInt a1)
{
  Swift::UInt v2 = UInt64.dividingFullWidth(_:)(a1.high, a1.low, v1, 0x3463uLL, 0x3465uLL);
  result.remainder = v3;
  result.quotient = v2;
  return result;
}

uint64_t UInt64.dividingFullWidth(_:)(unint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5)
{
  if (!a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  }
  if (a1 >= a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Quotient is not representable", 29, 2, "Swift/IntegerTypes.swift", 24, 2, a5, 0);
  }
  return __udivti3();
}

unint64_t UInt.byteSwapped.getter(unint64_t a1)
{
  return bswap64(a1);
}

Swift::UInt __swiftcall UInt.signum()()
{
  return v0 != 0;
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance UInt(void *a1, void *a2)
{
  BOOL v3 = __CFADD__(*v2, *a2);
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance UInt(void *a1, void *a2)
{
  BOOL v3 = *v2 < *a2;
  *a1 = *v2 - *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance UInt(void *a1, unint64_t *a2)
{
  BOOL v3 = !is_mul_ok(*v2, *a2);
  *a1 = *v2 * *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance UInt(void *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *v2;
  if (*a2) {
    v4 /= v3;
  }
  *a1 = v4;
  return v3 == 0;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance UInt(void *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *v2;
  if (*a2) {
    v4 %= v3;
  }
  *a1 = v4;
  return v3 == 0;
}

void *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance UInt64(void *result, void *a2, void *a3)
{
  uint64_t v4 = *v3 * *a3;
  *Swift::tuple_quotient_UInt_remainder_UInt result = ((unint64_t)*v3 * (unsigned __int128)(unint64_t)*a3) >> 64;
  *a2 = v4;
  return result;
}

Swift::UInt protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance UInt(Swift::UInt *a1, Swift::UInt *a2, Swift::tuple_high_UInt_low_UInt *a3)
{
  Swift::tuple_quotient_UInt_remainder_UInt v6 = UInt.dividingFullWidth(_:)(*a3);
  Swift::UInt result = v6.quotient;
  *a1 = v6.quotient;
  *a2 = v6.remainder;
  return result;
}

void *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance UInt@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *result >> *a2;
  return result;
}

void *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance UInt(void *result, void *a2)
{
  *result >>= *a2;
  return result;
}

void *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance UInt@<X0>(void *result@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (a2 >> 9 <= 0x20 && (a2 & 1) == 0) {
    *a3 = *result;
  }
  else {
    *a3 = 0;
  }
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance UInt@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt and conformance UInt(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt and conformance UInt, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v53 = a4;
  uint64_t v54 = a5;
  char v57 = *(int ***)(*(void *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v57, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v55 = (char *)&v49 - v11;
  uint64_t v61 = *(void *)(a2 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  char v52 = (char *)&v49 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v60 = (char *)&v49 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v18 = (char *)&v49 - v17;
  MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v49 - v19;
  uint64_t v21 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v22 = v21(a2, a3);
  uint64_t v58 = a1;
  char v59 = a6;
  if (v22)
  {
    uint64_t v23 = v61;
    (*(void (**)(char *, uint64_t, uint64_t))(v61 + 16))(v20, a1, a2);
    uint64_t v25 = AssociatedTypeWitness;
    uint64_t v24 = v57;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v57, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v27 = v55;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v25, AssociatedConformanceWitness);
    ((void (*)(char *, uint64_t, int **))v24[3])(v27, a2, v24);
    LOBYTE(v25) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 32))(v20, v18, a2);
    uint64_t v28 = *(void (**)(char *, uint64_t))(v23 + 8);
    v28(v18, a2);
    if ((v25 & 1) == 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
    }
    v28(v20, a2);
    a1 = v58;
  }
  uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  if (v29(a2, a3) >= 64)
  {
    unint64_t v51 = v18;
    uint64_t v50 = *(void (**)(char *, uint64_t, uint64_t))(v61 + 16);
    v50(v60, a1, a2);
    unint64_t v62 = -1;
    char v30 = v21(a2, a3);
    uint64_t v31 = v29(a2, a3);
    if (v30)
    {
      uint64_t v32 = v51;
      if (v31 < 65)
      {
        unint64_t v36 = AssociatedTypeWitness;
        char v37 = v57;
        uint64_t v38 = swift_getAssociatedConformanceWitness((uint64_t)v57, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v39 = v55;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v38 + 8))(&qword_18162B0B8, 256, v36, v38);
        ((void (*)(char *, uint64_t, int **))v37[3])(v39, a2, v37);
        uint64_t v40 = v60;
        LOBYTE(v36) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 40))(v60, v32, a2);
        char v34 = *(void (**)(char *, uint64_t))(v61 + 8);
        v34(v32, a2);
        unint64_t v41 = v62;
        uint64_t v42 = v52;
        v50(v52, (uint64_t)v40, a2);
        if (v36)
        {
          unint64_t v43 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v34(v42, a2);
          if (v41 < v43) {
LABEL_20:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
        }
        else
        {
          v34(v42, a2);
        }
        goto LABEL_16;
      }
      (*(void (**)(unint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v62, v53, v54, a2, a3);
      char v33 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v32, v60, a2);
      char v34 = *(void (**)(char *, uint64_t))(v61 + 8);
      v34(v32, a2);
    }
    else
    {
      uint64_t v35 = v51;
      if (v31 <= 64)
      {
        v50(v51, (uint64_t)v60, a2);
        unint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        char v34 = *(void (**)(char *, uint64_t))(v61 + 8);
        v34(v35, a2);
        if (v62 < v44) {
          goto LABEL_20;
        }
LABEL_16:
        v34(v60, a2);
        a1 = v58;
        goto LABEL_17;
      }
      (*(void (**)(unint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(&v62, v53, v54, a2, a3);
      char v33 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v35, v60, a2);
      char v34 = *(void (**)(char *, uint64_t))(v61 + 8);
      v34(v35, a2);
    }
    if (v33) {
      goto LABEL_20;
    }
    goto LABEL_16;
  }
LABEL_17:
  uint64_t v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t v46 = a1;
  uint64_t v47 = v45;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v61 + 8))(v46, a2);
  *char v59 = v47;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance UInt@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type UInt and conformance UInt(a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance UInt()
{
  if (!*v0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  }
  return __clz(*v0) ^ 0x3F;
}

void *protocol witness for static BinaryInteger./ infix(_:_:) in conformance UInt@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x321DuLL, 0);
  }
  *a3 = *result / *a2;
  return result;
}

void *protocol witness for static BinaryInteger./= infix(_:_:) in conformance UInt(void *result, void *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x321DuLL, 0);
  }
  *result /= *a2;
  return result;
}

void *protocol witness for static BinaryInteger.% infix(_:_:) in conformance UInt@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x32F1uLL, 0);
  }
  *a3 = *result % *a2;
  return result;
}

void *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance UInt(void *result, void *a2)
{
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x32F1uLL, 0);
  }
  *result %= *a2;
  return result;
}

uint64_t static UInt.^ infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return a2 ^ a1;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance UInt@<X0>(unint64_t *a1@<X0>, void (*a2)(void, void)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t *a5@<X8>)
{
  uint64_t v5 = a4;
  v141 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v141, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v139 = (char *)&v133 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v133 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  v136 = (char *)&v133 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v144 = (char *)&v133 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  char v22 = (char *)&v133 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  v137 = (char *)&v133 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v145 = (char *)&v133 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v149 = (char *)&v133 - v28;
  MEMORY[0x1F4188790](v27);
  uint64_t v151 = (char *)&v133 - v29;
  unint64_t v143 = *a1;
  char v30 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 64);
  uint64_t v150 = v5 + 64;
  char v31 = v30(a3, v5);
  v147 = a5;
  if (v31)
  {
    uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
    uint64_t v146 = (v5 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v33 = v32(a3, v5);
    if (v33 >= 64)
    {
      v153[0] = -64;
      uint64_t v49 = v151;
      v148 = v32;
      uint64_t v50 = v22;
      unint64_t v51 = v30;
      uint64_t v52 = v12;
      uint64_t v53 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
      unint64_t v54 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v53(v153, &type metadata for Int, v54, a3, v5);
      uint64_t v12 = v52;
      char v30 = v51;
      char v22 = v50;
      uint64_t v32 = v148;
      char v55 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                                            + 16))(a2, v49, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v49, a3);
      if (v55) {
        goto LABEL_28;
      }
    }
    else
    {
      unint64_t v36 = v151;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v151, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v36, a3);
      if (v37 < -64) {
        goto LABEL_28;
      }
    }
  }
  else
  {
    char v39 = v30(a3, v5);
    uint64_t v40 = *(uint64_t (**)(void, void))(v5 + 128);
    uint64_t v146 = (v5 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v138 = a2;
    v148 = v40;
    uint64_t v41 = v40(a3, v5);
    if (v39)
    {
      uint64_t v142 = v30;
      if (v41 <= 64)
      {
        uint64_t v58 = AssociatedTypeWitness;
        char v59 = v141;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v61 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v58, AssociatedConformanceWitness);
        unint64_t v62 = v151;
        ((void (*)(char *, uint64_t, int **))v59[3])(v61, a3, v59);
        uint64_t v63 = v138;
        LOBYTE(v58) = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v138, v62, a3);
        uint64_t v64 = *(void (**)(char *, uint64_t))(v12 + 8);
        v64(v62, a3);
        uint64_t v133 = v12;
        (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v15, v63, a3);
        if (v58)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v64)(v15, a3);
          goto LABEL_28;
        }
        uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v64)(v15, a3);
        uint64_t v12 = v133;
        char v30 = v142;
        uint64_t v32 = v148;
        a2 = v138;
        if (v65 < -64) {
          goto LABEL_28;
        }
      }
      else
      {
        v153[0] = -64;
        uint64_t v44 = v12;
        uint64_t v45 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
        unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
        uint64_t v47 = v151;
        v45(v153, &type metadata for Int, v46, a3, v5);
        uint64_t v12 = v44;
        a2 = v138;
        char v48 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                                              + 16))(v138, v47, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v44 + 8))(v47, a3);
        char v30 = v142;
        uint64_t v32 = v148;
        if (v48) {
          goto LABEL_28;
        }
      }
    }
    else if (v41 >= 64)
    {
      uint64_t v32 = v148;
      a2 = v138;
    }
    else
    {
      uint64_t v56 = v151;
      a2 = v138;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v151, v138, a3);
      uint64_t v57 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v56, a3);
      uint64_t v32 = v148;
      if (v57 < -64) {
        goto LABEL_28;
      }
    }
  }
  uint64_t v142 = v30;
  char v66 = v30(a3, v5);
  uint64_t v67 = a2;
  uint64_t v68 = v32(a3, v5);
  v134 = v22;
  if (v66)
  {
    if (v68 > 64) {
      goto LABEL_20;
    }
  }
  else if (v68 > 63)
  {
LABEL_20:
    v153[0] = 64;
    unint64_t v71 = v151;
    uint64_t v72 = v12;
    char v73 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
    unint64_t v74 = lazy protocol witness table accessor for type Int and conformance Int(v68, v69, v70);
    v73(v153, &type metadata for Int, v74, a3, v5);
    uint64_t v12 = v72;
    char v75 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v71, (char *)v67, a3);
    uint64_t v138 = *(void (**)(void, void))(v72 + 8);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v71, a3);
    if ((v75 & 1) == 0) {
      goto LABEL_21;
    }
LABEL_28:
    unint64_t v95 = 0;
LABEL_57:
    uint64_t v132 = v147;
    goto LABEL_58;
  }
  uint64_t v93 = v151;
  (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v151, a2, a3);
  uint64_t v94 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
  uint64_t v138 = *(void (**)(void, void))(v12 + 8);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v93, a3);
  if (v94 > 64) {
    goto LABEL_28;
  }
LABEL_21:
  v148 = v32;
  uint64_t v76 = v12;
  uint64_t v77 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
  uint64_t v78 = v149;
  v77(v149, (char *)v67, a3);
  uint64_t v79 = v142;
  char v80 = v142(a3, v5);
  char v81 = v145;
  v135 = v77;
  v77(v145, v78, a3);
  uint64_t v133 = v12;
  if ((v80 & 1) == 0)
  {
    v138(v81, a3);
    uint64_t v87 = v79;
    uint64_t v88 = v148;
    goto LABEL_41;
  }
  uint64_t v82 = v5;
  uint64_t v83 = v5;
  int64_t v84 = v148;
  uint64_t v85 = v148(a3, v82);
  v138(v81, a3);
  BOOL v86 = v84;
  uint64_t v5 = v83;
  uint64_t v87 = v79;
  uint64_t v88 = v86;
  if (v85 <= 64) {
    goto LABEL_41;
  }
  uint64_t v145 = (char *)(v76 + 8);
  uint64_t v89 = v137;
  v135(v137, v149, a3);
  v153[0] = 0x8000000000000000;
  if (v87(a3, v83))
  {
    uint64_t v90 = v88(a3, v83);
    if (v90 < 64)
    {
LABEL_36:
      unint64_t v104 = v151;
      v135(v151, v89, a3);
      uint64_t v105 = (*(uint64_t (**)(uint64_t, uint64_t))(v83 + 120))(a3, v83);
      unint64_t v103 = (void (*)(char *, uint64_t))v138;
      v138(v104, a3);
      if (v105 < v153[0]) {
LABEL_63:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_40;
    }
LABEL_32:
    unint64_t v97 = v151;
    uint64_t v98 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v83 + 96);
    unint64_t v99 = lazy protocol witness table accessor for type Int and conformance Int(v90, v91, v92);
    v98(v153, &type metadata for Int, v99, a3, v5);
    char v100 = v97;
    uint64_t v89 = v137;
    uint64_t v88 = v148;
    char v101 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v137, v100, a3);
    char v102 = v100;
    unint64_t v103 = (void (*)(char *, uint64_t))v138;
    v138(v102, a3);
    if (v101) {
      goto LABEL_63;
    }
    goto LABEL_40;
  }
  char v96 = v87(a3, v83);
  uint64_t v90 = v88(a3, v83);
  if ((v96 & 1) == 0)
  {
    if (v90 >= 64)
    {
      v138(v89, a3);
      goto LABEL_41;
    }
    goto LABEL_36;
  }
  if (v90 > 64) {
    goto LABEL_32;
  }
  uint64_t v107 = AssociatedTypeWitness;
  BOOL v106 = v141;
  uint64_t v108 = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v109 = v139;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v108 + 8))(&qword_18162B0B8, 256, v107, v108);
  uint64_t v110 = v151;
  ((void (*)(char *, uint64_t, int **))v106[3])(v109, a3, v106);
  LODWORD(v141) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v89, v110, a3);
  unint64_t v103 = (void (*)(char *, uint64_t))v138;
  v138(v110, a3);
  uint64_t v111 = v136;
  v135(v136, v89, a3);
  if (v141)
  {
    v103(v111, a3);
    goto LABEL_63;
  }
  v141 = (int **)v153[0];
  uint64_t v112 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
  v103(v111, a3);
  BOOL v113 = v112 < (uint64_t)v141;
  uint64_t v88 = v148;
  if (v113) {
    goto LABEL_63;
  }
LABEL_40:
  v103(v89, a3);
LABEL_41:
  uint64_t v114 = v149;
  uint64_t v115 = v88(a3, v5);
  uint64_t v116 = v134;
  v135(v134, v114, a3);
  if (v115 >= 65)
  {
    unint64_t v117 = (void (*)(char *, uint64_t))v138;
    v138(v116, a3);
    char v118 = v144;
    goto LABEL_43;
  }
  uint64_t v126 = v88(a3, v5);
  unint64_t v117 = (void (*)(char *, uint64_t))v138;
  v138(v116, a3);
  char v118 = v144;
  if (v126 == 64 && (v87(a3, v5) & 1) == 0)
  {
LABEL_43:
    v135(v118, v149, a3);
    v153[0] = 0x7FFFFFFFFFFFFFFFLL;
    char v119 = v87(a3, v5);
    uint64_t v120 = v88(a3, v5);
    if (v119)
    {
      if (v120 > 64)
      {
        int64_t v123 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
        unint64_t v124 = lazy protocol witness table accessor for type Int and conformance Int(v120, v121, v122);
        uint64_t v125 = v153;
        goto LABEL_52;
      }
    }
    else if (v120 > 63)
    {
      uint64_t v152 = 0x7FFFFFFFFFFFFFFFLL;
      int64_t v123 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
      unint64_t v124 = lazy protocol witness table accessor for type Int and conformance Int(v120, v121, v122);
      uint64_t v125 = &v152;
LABEL_52:
      uint64_t v128 = v151;
      v123(v125, &type metadata for Int, v124, a3, v5);
      char v129 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v128, v118, a3);
      v117(v128, a3);
      if (v129) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      goto LABEL_53;
    }
    uint64_t v127 = v151;
    v135(v151, v118, a3);
    (*(void (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
    v117(v127, a3);
LABEL_53:
    v117(v118, a3);
  }
  unint64_t v130 = v149;
  unint64_t v131 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v117)(v130, a3);
  if ((v131 & 0x8000000000000000) == 0)
  {
    unint64_t v95 = v143 >> v131;
    if (v131 >= 0x40) {
      unint64_t v95 = 0;
    }
    goto LABEL_57;
  }
  uint64_t v132 = v147;
  if (v131 <= 0xFFFFFFFFFFFFFFC0) {
    unint64_t v95 = 0;
  }
  else {
    unint64_t v95 = v143 << -(char)v131;
  }
LABEL_58:
  unint64_t *v132 = v95;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance UInt(unint64_t *a1, void (*a2)(void, void), uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  v141 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v141, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v139 = (char *)&v132 - v9;
  uint64_t v10 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v132 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  v136 = (char *)&v132 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  unint64_t v143 = (char *)&v132 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v132 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  v137 = (char *)&v132 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  v144 = (char *)&v132 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v148 = (char *)&v132 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v150 = (char *)&v132 - v27;
  uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 64);
  uint64_t v149 = v4 + 64;
  char v29 = v28(a3, v4);
  uint64_t v146 = a1;
  if (v29)
  {
    char v30 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 128);
    uint64_t v145 = (v4 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v31 = v30(a3, v4);
    if (v31 >= 64)
    {
      v152[0] = -64;
      uint64_t v47 = v150;
      v147 = v30;
      char v48 = v20;
      uint64_t v49 = v28;
      uint64_t v50 = v10;
      unint64_t v51 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
      unint64_t v52 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
      v51(v152, &type metadata for Int, v52, a3, v4);
      uint64_t v10 = v50;
      uint64_t v28 = v49;
      uint64_t v20 = v48;
      char v30 = v147;
      char v53 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                                            + 16))(a2, v47, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v47, a3);
      if (v53) {
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v34 = v150;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, a2, a3);
      uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v34, a3);
      if (v35 < -64) {
        goto LABEL_28;
      }
    }
  }
  else
  {
    char v37 = v28(a3, v4);
    uint64_t v38 = *(uint64_t (**)(void, void))(v4 + 128);
    uint64_t v145 = (v4 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v138 = a2;
    v147 = v38;
    uint64_t v39 = v38(a3, v4);
    if (v37)
    {
      uint64_t v142 = v28;
      if (v39 <= 64)
      {
        uint64_t v56 = AssociatedTypeWitness;
        uint64_t v57 = v141;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v59 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v56, AssociatedConformanceWitness);
        uint64_t v60 = v150;
        ((void (*)(char *, uint64_t, int **))v57[3])(v59, a3, v57);
        uint64_t v61 = v138;
        LOBYTE(v56) = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v138, v60, a3);
        unint64_t v62 = *(void (**)(char *, uint64_t))(v10 + 8);
        v62(v60, a3);
        uint64_t v133 = v10;
        (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v13, v61, a3);
        if (v56)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v62)(v13, a3);
          goto LABEL_28;
        }
        uint64_t v63 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v62)(v13, a3);
        uint64_t v10 = v133;
        uint64_t v28 = v142;
        char v30 = v147;
        a2 = v138;
        if (v63 < -64) {
          goto LABEL_28;
        }
      }
      else
      {
        v152[0] = -64;
        uint64_t v42 = v10;
        uint64_t v43 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
        unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        uint64_t v45 = v150;
        v43(v152, &type metadata for Int, v44, a3, v4);
        uint64_t v10 = v42;
        a2 = v138;
        char v46 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                                              + 16))(v138, v45, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v42 + 8))(v45, a3);
        uint64_t v28 = v142;
        char v30 = v147;
        if (v46) {
          goto LABEL_28;
        }
      }
    }
    else if (v39 >= 64)
    {
      char v30 = v147;
      a2 = v138;
    }
    else
    {
      unint64_t v54 = v150;
      a2 = v138;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, v138, a3);
      uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v54, a3);
      char v30 = v147;
      if (v55 < -64) {
        goto LABEL_28;
      }
    }
  }
  uint64_t v142 = v28;
  char v64 = v28(a3, v4);
  uint64_t v65 = a2;
  uint64_t v66 = v30(a3, v4);
  v134 = v20;
  if (v64)
  {
    if (v66 > 64) {
      goto LABEL_20;
    }
  }
  else if (v66 >= 64)
  {
LABEL_20:
    v152[0] = 64;
    uint64_t v69 = v150;
    uint64_t v70 = v10;
    unint64_t v71 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v71(v152, &type metadata for Int, v72, a3, v4);
    uint64_t v10 = v70;
    char v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v69, (char *)v65, a3);
    uint64_t v138 = *(void (**)(void, void))(v70 + 8);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v69, a3);
    if ((v73 & 1) == 0) {
      goto LABEL_21;
    }
LABEL_28:
    unint64_t v93 = 0;
    uint64_t v94 = v146;
    goto LABEL_57;
  }
  uint64_t v91 = v150;
  (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, a2, a3);
  uint64_t v92 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
  uint64_t v138 = *(void (**)(void, void))(v10 + 8);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v91, a3);
  if (v92 > 64) {
    goto LABEL_28;
  }
LABEL_21:
  v147 = v30;
  uint64_t v74 = v10;
  char v75 = *(void (**)(char *, char *, uint64_t))(v10 + 16);
  uint64_t v76 = v148;
  v75(v148, (char *)v65, a3);
  uint64_t v77 = v142;
  char v78 = v142(a3, v4);
  uint64_t v79 = v144;
  v135 = v75;
  v75(v144, v76, a3);
  uint64_t v133 = v10;
  if ((v78 & 1) == 0)
  {
    v138(v79, a3);
    uint64_t v85 = v77;
    BOOL v86 = v147;
    goto LABEL_41;
  }
  uint64_t v80 = v4;
  uint64_t v81 = v4;
  uint64_t v82 = v147;
  uint64_t v83 = v147(a3, v80);
  v138(v79, a3);
  int64_t v84 = v82;
  uint64_t v4 = v81;
  uint64_t v85 = v77;
  BOOL v86 = v84;
  if (v83 <= 64) {
    goto LABEL_41;
  }
  v144 = (char *)(v74 + 8);
  uint64_t v87 = v137;
  v135(v137, v148, a3);
  v152[0] = 0x8000000000000000;
  if (v85(a3, v81))
  {
    uint64_t v88 = v86(a3, v81);
    if (v88 < 64)
    {
LABEL_36:
      unint64_t v103 = v150;
      v135(v150, v87, a3);
      uint64_t v104 = (*(uint64_t (**)(uint64_t, uint64_t))(v81 + 120))(a3, v81);
      char v102 = (void (*)(char *, uint64_t))v138;
      v138(v103, a3);
      if (v104 < v152[0]) {
LABEL_62:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_40;
    }
LABEL_32:
    char v96 = v150;
    unint64_t v97 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v81 + 96);
    unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v88, v89, v90);
    v97(v152, &type metadata for Int, v98, a3, v4);
    unint64_t v99 = v96;
    uint64_t v87 = v137;
    BOOL v86 = v147;
    char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v137, v99, a3);
    char v101 = v99;
    char v102 = (void (*)(char *, uint64_t))v138;
    v138(v101, a3);
    if (v100) {
      goto LABEL_62;
    }
    goto LABEL_40;
  }
  char v95 = v85(a3, v81);
  uint64_t v88 = v86(a3, v81);
  if ((v95 & 1) == 0)
  {
    if (v88 >= 64)
    {
      v138(v87, a3);
      goto LABEL_41;
    }
    goto LABEL_36;
  }
  if (v88 > 64) {
    goto LABEL_32;
  }
  BOOL v106 = AssociatedTypeWitness;
  uint64_t v105 = v141;
  uint64_t v107 = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v108 = v139;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v107 + 8))(&qword_18162B0B8, 256, v106, v107);
  uint64_t v109 = v150;
  ((void (*)(char *, uint64_t, int **))v105[3])(v108, a3, v105);
  LODWORD(v141) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v87, v109, a3);
  char v102 = (void (*)(char *, uint64_t))v138;
  v138(v109, a3);
  uint64_t v110 = v136;
  v135(v136, v87, a3);
  if (v141)
  {
    v102(v110, a3);
    goto LABEL_62;
  }
  v141 = (int **)v152[0];
  uint64_t v111 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
  v102(v110, a3);
  BOOL v112 = v111 < (uint64_t)v141;
  BOOL v86 = v147;
  if (v112) {
    goto LABEL_62;
  }
LABEL_40:
  v102(v87, a3);
LABEL_41:
  BOOL v113 = v148;
  uint64_t v114 = v86(a3, v4);
  uint64_t v115 = v134;
  v135(v134, v113, a3);
  if (v114 >= 65)
  {
    uint64_t v116 = (void (*)(char *, uint64_t))v138;
    v138(v115, a3);
    unint64_t v117 = v143;
    goto LABEL_43;
  }
  uint64_t v125 = v86(a3, v4);
  uint64_t v116 = (void (*)(char *, uint64_t))v138;
  v138(v115, a3);
  unint64_t v117 = v143;
  if (v125 == 64 && (v85(a3, v4) & 1) == 0)
  {
LABEL_43:
    v135(v117, v148, a3);
    v152[0] = 0x7FFFFFFFFFFFFFFFLL;
    char v118 = v85(a3, v4);
    uint64_t v119 = v86(a3, v4);
    if (v118)
    {
      if (v119 > 64)
      {
        uint64_t v122 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
        unint64_t v123 = lazy protocol witness table accessor for type Int and conformance Int(v119, v120, v121);
        unint64_t v124 = v152;
        goto LABEL_52;
      }
    }
    else if (v119 >= 64)
    {
      uint64_t v151 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v122 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
      unint64_t v123 = lazy protocol witness table accessor for type Int and conformance Int(v119, v120, v121);
      unint64_t v124 = &v151;
LABEL_52:
      uint64_t v127 = v150;
      v122(v124, &type metadata for Int, v123, a3, v4);
      char v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v127, v117, a3);
      v116(v127, a3);
      if (v128) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      goto LABEL_53;
    }
    uint64_t v126 = v150;
    v135(v150, v117, a3);
    (*(void (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
    v116(v126, a3);
LABEL_53:
    v116(v117, a3);
  }
  char v129 = v148;
  unint64_t v130 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v116)(v129, a3);
  uint64_t v94 = v146;
  unint64_t v131 = *v146;
  if ((v130 & 0x8000000000000000) != 0)
  {
    if (v130 < 0xFFFFFFFFFFFFFFC1) {
      unint64_t v93 = 0;
    }
    else {
      unint64_t v93 = v131 << -(char)v130;
    }
  }
  else
  {
    unint64_t v93 = v131 >> v130;
    if (v130 >= 0x40) {
      unint64_t v93 = 0;
    }
  }
LABEL_57:
  *uint64_t v94 = v93;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance UInt@<X0>(unint64_t *a1@<X0>, void (*a2)(void, void)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t *a5@<X8>)
{
  uint64_t v5 = a4;
  v141 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v141, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v139 = (char *)&v132 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v132 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  v136 = (char *)&v132 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v144 = (char *)&v132 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)&v132 - v21;
  uint64_t v23 = MEMORY[0x1F4188790](v20);
  v137 = (char *)&v132 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v145 = (char *)&v132 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v150 = (char *)&v132 - v28;
  MEMORY[0x1F4188790](v27);
  uint64_t v152 = (char *)&v132 - v29;
  unint64_t v143 = *a1;
  char v30 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 64);
  uint64_t v151 = v5 + 64;
  char v31 = v30(a3, v5);
  v148 = a5;
  if (v31)
  {
    uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
    uint64_t v147 = (v5 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v33 = v32(a3, v5);
    if (v33 >= 64)
    {
      v154[0] = -64;
      uint64_t v49 = v152;
      uint64_t v149 = v32;
      uint64_t v146 = v22;
      uint64_t v50 = v30;
      uint64_t v51 = v12;
      unint64_t v52 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
      unint64_t v53 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
      v52(v154, &type metadata for Int, v53, a3, v5);
      uint64_t v12 = v51;
      char v30 = v50;
      uint64_t v22 = v146;
      uint64_t v32 = v149;
      char v54 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                                            + 16))(a2, v49, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v49, a3);
      if (v54) {
        goto LABEL_28;
      }
    }
    else
    {
      unint64_t v36 = v152;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v152, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v36, a3);
      if (v37 < -64) {
        goto LABEL_28;
      }
    }
  }
  else
  {
    char v39 = v30(a3, v5);
    uint64_t v40 = *(uint64_t (**)(void, void))(v5 + 128);
    uint64_t v147 = (v5 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v138 = a2;
    uint64_t v149 = v40;
    uint64_t v41 = v40(a3, v5);
    if (v39)
    {
      uint64_t v142 = v30;
      if (v41 <= 64)
      {
        uint64_t v57 = AssociatedTypeWitness;
        uint64_t v58 = v141;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v60 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v57, AssociatedConformanceWitness);
        uint64_t v61 = v152;
        ((void (*)(char *, uint64_t, int **))v58[3])(v60, a3, v58);
        unint64_t v62 = v138;
        LOBYTE(v57) = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v138, v61, a3);
        uint64_t v63 = *(void (**)(char *, uint64_t))(v12 + 8);
        v63(v61, a3);
        uint64_t v133 = v12;
        (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v15, v62, a3);
        if (v57)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v63)(v15, a3);
          unint64_t v64 = 0;
LABEL_59:
          unint64_t v131 = v148;
          goto LABEL_60;
        }
        uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v63)(v15, a3);
        uint64_t v12 = v133;
        char v30 = v142;
        uint64_t v32 = v149;
        a2 = v138;
        if (v65 < -64) {
          goto LABEL_28;
        }
      }
      else
      {
        v154[0] = -64;
        uint64_t v44 = v12;
        uint64_t v45 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
        unint64_t v46 = lazy protocol witness table accessor for type Int and conformance Int(v41, v42, v43);
        uint64_t v47 = v152;
        v45(v154, &type metadata for Int, v46, a3, v5);
        uint64_t v12 = v44;
        a2 = v138;
        char v48 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                                              + 16))(v138, v47, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v44 + 8))(v47, a3);
        char v30 = v142;
        uint64_t v32 = v149;
        if (v48) {
          goto LABEL_28;
        }
      }
    }
    else if (v41 >= 64)
    {
      uint64_t v32 = v149;
      a2 = v138;
    }
    else
    {
      uint64_t v55 = v152;
      a2 = v138;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v152, v138, a3);
      uint64_t v56 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v55, a3);
      uint64_t v32 = v149;
      if (v56 < -64) {
        goto LABEL_28;
      }
    }
  }
  uint64_t v142 = v30;
  char v66 = v30(a3, v5);
  uint64_t v67 = a2;
  uint64_t v68 = v32(a3, v5);
  uint64_t v146 = v22;
  if (v66)
  {
    if (v68 > 64) {
      goto LABEL_20;
    }
  }
  else if (v68 > 63)
  {
LABEL_20:
    v154[0] = 64;
    unint64_t v71 = v152;
    uint64_t v72 = v12;
    char v73 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
    unint64_t v74 = lazy protocol witness table accessor for type Int and conformance Int(v68, v69, v70);
    v73(v154, &type metadata for Int, v74, a3, v5);
    uint64_t v12 = v72;
    a2 = v67;
    char v75 = (*(uint64_t (**)(char *, void (*)(void, void), uint64_t))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                                          + 16))(v71, v67, a3);
    uint64_t v138 = *(void (**)(void, void))(v12 + 8);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v71, a3);
    if ((v75 & 1) == 0) {
      goto LABEL_21;
    }
LABEL_28:
    unint64_t v64 = 0;
    goto LABEL_59;
  }
  uint64_t v92 = v152;
  (*(void (**)(char *, void (*)(void, void), uint64_t))(v12 + 16))(v152, a2, a3);
  uint64_t v93 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
  uint64_t v138 = *(void (**)(void, void))(v12 + 8);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v92, a3);
  if (v93 > 64) {
    goto LABEL_28;
  }
LABEL_21:
  uint64_t v149 = v32;
  uint64_t v76 = v12;
  uint64_t v77 = *(void (**)(char *, char *, uint64_t))(v12 + 16);
  char v78 = v150;
  v77(v150, (char *)a2, a3);
  uint64_t v79 = v142;
  char v80 = v142(a3, v5);
  uint64_t v81 = v145;
  v134 = v77;
  uint64_t v135 = v12 + 16;
  v77(v145, v78, a3);
  uint64_t v133 = v12;
  if ((v80 & 1) == 0)
  {
    v138(v81, a3);
    BOOL v86 = v149;
    uint64_t v87 = v79;
    goto LABEL_43;
  }
  uint64_t v82 = v5;
  uint64_t v83 = v5;
  int64_t v84 = v149;
  uint64_t v85 = v149(a3, v82);
  uint64_t v145 = (char *)(v76 + 8);
  v138(v81, a3);
  BOOL v86 = v84;
  uint64_t v5 = v83;
  uint64_t v87 = v79;
  if (v85 <= 64) {
    goto LABEL_43;
  }
  uint64_t v88 = v137;
  v134(v137, v150, a3);
  v154[0] = 0x8000000000000000;
  if (v79(a3, v83))
  {
    uint64_t v89 = v86(a3, v83);
    if (v89 < 64)
    {
LABEL_36:
      char v102 = v152;
      v134(v152, v88, a3);
      uint64_t v103 = (*(uint64_t (**)(uint64_t, uint64_t))(v83 + 120))(a3, v83);
      char v101 = (void (*)(char *, uint64_t))v138;
      v138(v102, a3);
      if (v103 < v154[0]) {
        goto LABEL_65;
      }
      goto LABEL_42;
    }
  }
  else
  {
    char v94 = v79(a3, v83);
    uint64_t v89 = v86(a3, v83);
    if ((v94 & 1) == 0)
    {
      if (v89 >= 64)
      {
        v138(v88, a3);
        goto LABEL_43;
      }
      goto LABEL_36;
    }
    if (v89 <= 64)
    {
      uint64_t v105 = AssociatedTypeWitness;
      uint64_t v104 = v141;
      uint64_t v106 = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v107 = v139;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v106 + 8))(&qword_18162B0B8, 256, v105, v106);
      uint64_t v108 = v152;
      ((void (*)(char *, uint64_t, int **))v104[3])(v107, a3, v104);
      LOBYTE(v104) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v88, v108, a3);
      char v101 = (void (*)(char *, uint64_t))v138;
      v138(v108, a3);
      uint64_t v109 = v136;
      v134(v136, v88, a3);
      if (v104)
      {
        v101(v109, a3);
        goto LABEL_65;
      }
      uint64_t v110 = v154[0];
      uint64_t v111 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
      v101(v109, a3);
      BOOL v112 = v111 < v110;
      BOOL v86 = v149;
      if (v112) {
LABEL_65:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_42;
    }
  }
  char v95 = v152;
  char v96 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v83 + 96);
  unint64_t v97 = lazy protocol witness table accessor for type Int and conformance Int(v89, v90, v91);
  v96(v154, &type metadata for Int, v97, a3, v5);
  unint64_t v98 = v95;
  uint64_t v88 = v137;
  BOOL v86 = v149;
  char v99 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v137, v98, a3);
  char v100 = v98;
  char v101 = (void (*)(char *, uint64_t))v138;
  v138(v100, a3);
  if (v99) {
    goto LABEL_65;
  }
LABEL_42:
  v101(v88, a3);
LABEL_43:
  BOOL v113 = v150;
  uint64_t v114 = v86(a3, v5);
  uint64_t v115 = v146;
  v134(v146, v113, a3);
  if (v114 >= 65)
  {
    uint64_t v116 = (void (*)(char *, uint64_t))v138;
    v138(v115, a3);
    unint64_t v117 = v144;
    goto LABEL_45;
  }
  uint64_t v125 = v86(a3, v5);
  uint64_t v116 = (void (*)(char *, uint64_t))v138;
  v138(v115, a3);
  unint64_t v117 = v144;
  if (v125 == 64 && (v87(a3, v5) & 1) == 0)
  {
LABEL_45:
    v134(v117, v150, a3);
    v154[0] = 0x7FFFFFFFFFFFFFFFLL;
    char v118 = v87(a3, v5);
    uint64_t v119 = v86(a3, v5);
    if (v118)
    {
      if (v119 > 64)
      {
        uint64_t v122 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
        unint64_t v123 = lazy protocol witness table accessor for type Int and conformance Int(v119, v120, v121);
        unint64_t v124 = v154;
        goto LABEL_54;
      }
    }
    else if (v119 > 63)
    {
      uint64_t v153 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v122 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
      unint64_t v123 = lazy protocol witness table accessor for type Int and conformance Int(v119, v120, v121);
      unint64_t v124 = &v153;
LABEL_54:
      uint64_t v127 = v152;
      v122(v124, &type metadata for Int, v123, a3, v5);
      char v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v127, v117, a3);
      v116(v127, a3);
      if (v128) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      goto LABEL_55;
    }
    uint64_t v126 = v152;
    v134(v152, v117, a3);
    (*(void (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
    v116(v126, a3);
LABEL_55:
    v116(v117, a3);
  }
  char v129 = v150;
  unint64_t v130 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v116)(v129, a3);
  if ((v130 & 0x8000000000000000) == 0)
  {
    unint64_t v64 = v143 << v130;
    if (v130 >= 0x40) {
      unint64_t v64 = 0;
    }
    goto LABEL_59;
  }
  unint64_t v131 = v148;
  if (v130 <= 0xFFFFFFFFFFFFFFC0) {
    unint64_t v64 = 0;
  }
  else {
    unint64_t v64 = v143 >> -(char)v130;
  }
LABEL_60:
  unint64_t *v131 = v64;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance UInt(unint64_t *a1, void (*a2)(void, void), uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  v141 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v141, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v139 = (char *)&v132 - v9;
  uint64_t v10 = *(void *)(a3 - 8);
  uint64_t v11 = MEMORY[0x1F4188790](v8);
  uint64_t v13 = (char *)&v132 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  v136 = (char *)&v132 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  unint64_t v143 = (char *)&v132 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v132 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  v137 = (char *)&v132 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  v144 = (char *)&v132 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v148 = (char *)&v132 - v26;
  MEMORY[0x1F4188790](v25);
  uint64_t v150 = (char *)&v132 - v27;
  uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 64);
  uint64_t v149 = v4 + 64;
  char v29 = v28(a3, v4);
  uint64_t v146 = a1;
  if (v29)
  {
    char v30 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 128);
    uint64_t v145 = (v4 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v31 = v30(a3, v4);
    if (v31 >= 64)
    {
      v152[0] = -64;
      uint64_t v47 = v150;
      uint64_t v147 = v30;
      char v48 = v20;
      uint64_t v49 = v28;
      uint64_t v50 = v10;
      uint64_t v51 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
      unint64_t v52 = lazy protocol witness table accessor for type Int and conformance Int(v31, v32, v33);
      v51(v152, &type metadata for Int, v52, a3, v4);
      uint64_t v10 = v50;
      uint64_t v28 = v49;
      uint64_t v20 = v48;
      char v30 = v147;
      char v53 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                                            + 16))(a2, v47, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v47, a3);
      if (v53) {
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v34 = v150;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, a2, a3);
      uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v34, a3);
      if (v35 < -64) {
        goto LABEL_28;
      }
    }
  }
  else
  {
    char v37 = v28(a3, v4);
    uint64_t v38 = *(uint64_t (**)(void, void))(v4 + 128);
    uint64_t v145 = (v4 + 128) & 0xFFFFFFFFFFFFLL | 0x47B5000000000000;
    uint64_t v138 = a2;
    uint64_t v147 = v38;
    uint64_t v39 = v38(a3, v4);
    if (v37)
    {
      uint64_t v142 = v28;
      if (v39 <= 64)
      {
        uint64_t v56 = AssociatedTypeWitness;
        uint64_t v57 = v141;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        char v59 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v56, AssociatedConformanceWitness);
        uint64_t v60 = v150;
        ((void (*)(char *, uint64_t, int **))v57[3])(v59, a3, v57);
        uint64_t v61 = v138;
        LOBYTE(v56) = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v138, v60, a3);
        unint64_t v62 = *(void (**)(char *, uint64_t))(v10 + 8);
        v62(v60, a3);
        uint64_t v133 = v10;
        (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v13, v61, a3);
        if (v56)
        {
          uint64_t result = ((uint64_t (*)(char *, uint64_t))v62)(v13, a3);
          goto LABEL_28;
        }
        uint64_t v63 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v62)(v13, a3);
        uint64_t v10 = v133;
        uint64_t v28 = v142;
        char v30 = v147;
        a2 = v138;
        if (v63 < -64) {
          goto LABEL_28;
        }
      }
      else
      {
        v152[0] = -64;
        uint64_t v42 = v10;
        uint64_t v43 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
        unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
        uint64_t v45 = v150;
        v43(v152, &type metadata for Int, v44, a3, v4);
        uint64_t v10 = v42;
        a2 = v138;
        char v46 = (*(uint64_t (**)(void (*)(void, void), char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8)
                                                                                              + 16))(v138, v45, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v42 + 8))(v45, a3);
        uint64_t v28 = v142;
        char v30 = v147;
        if (v46) {
          goto LABEL_28;
        }
      }
    }
    else if (v39 >= 64)
    {
      char v30 = v147;
      a2 = v138;
    }
    else
    {
      char v54 = v150;
      a2 = v138;
      (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, v138, a3);
      uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v10 + 8))(v54, a3);
      char v30 = v147;
      if (v55 < -64) {
        goto LABEL_28;
      }
    }
  }
  uint64_t v142 = v28;
  char v64 = v28(a3, v4);
  uint64_t v65 = a2;
  uint64_t v66 = v30(a3, v4);
  v134 = v20;
  if (v64)
  {
    if (v66 > 64) {
      goto LABEL_20;
    }
  }
  else if (v66 >= 64)
  {
LABEL_20:
    v152[0] = 64;
    uint64_t v69 = v150;
    uint64_t v70 = v10;
    unint64_t v71 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
    unint64_t v72 = lazy protocol witness table accessor for type Int and conformance Int(v66, v67, v68);
    v71(v152, &type metadata for Int, v72, a3, v4);
    uint64_t v10 = v70;
    char v73 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v69, (char *)v65, a3);
    uint64_t v138 = *(void (**)(void, void))(v70 + 8);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v69, a3);
    if ((v73 & 1) == 0) {
      goto LABEL_21;
    }
LABEL_28:
    unint64_t v93 = 0;
    char v94 = v146;
    goto LABEL_57;
  }
  uint64_t v91 = v150;
  (*(void (**)(char *, void (*)(void, void), uint64_t))(v10 + 16))(v150, a2, a3);
  uint64_t v92 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
  uint64_t v138 = *(void (**)(void, void))(v10 + 8);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v138)(v91, a3);
  if (v92 > 64) {
    goto LABEL_28;
  }
LABEL_21:
  uint64_t v147 = v30;
  uint64_t v74 = v10;
  char v75 = *(void (**)(char *, char *, uint64_t))(v10 + 16);
  uint64_t v76 = v148;
  v75(v148, (char *)v65, a3);
  uint64_t v77 = v142;
  char v78 = v142(a3, v4);
  uint64_t v79 = v144;
  uint64_t v135 = v75;
  v75(v144, v76, a3);
  uint64_t v133 = v10;
  if ((v78 & 1) == 0)
  {
    v138(v79, a3);
    uint64_t v85 = v77;
    BOOL v86 = v147;
    goto LABEL_41;
  }
  uint64_t v80 = v4;
  uint64_t v81 = v4;
  uint64_t v82 = v147;
  uint64_t v83 = v147(a3, v80);
  v138(v79, a3);
  int64_t v84 = v82;
  uint64_t v4 = v81;
  uint64_t v85 = v77;
  BOOL v86 = v84;
  if (v83 <= 64) {
    goto LABEL_41;
  }
  v144 = (char *)(v74 + 8);
  uint64_t v87 = v137;
  v135(v137, v148, a3);
  v152[0] = 0x8000000000000000;
  if (v85(a3, v81))
  {
    uint64_t v88 = v86(a3, v81);
    if (v88 < 64)
    {
LABEL_36:
      uint64_t v103 = v150;
      v135(v150, v87, a3);
      uint64_t v104 = (*(uint64_t (**)(uint64_t, uint64_t))(v81 + 120))(a3, v81);
      char v102 = (void (*)(char *, uint64_t))v138;
      v138(v103, a3);
      if (v104 < v152[0]) {
LABEL_62:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_40;
    }
LABEL_32:
    char v96 = v150;
    unint64_t v97 = *(void (**)(void *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v81 + 96);
    unint64_t v98 = lazy protocol witness table accessor for type Int and conformance Int(v88, v89, v90);
    v97(v152, &type metadata for Int, v98, a3, v4);
    char v99 = v96;
    uint64_t v87 = v137;
    BOOL v86 = v147;
    char v100 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v137, v99, a3);
    char v101 = v99;
    char v102 = (void (*)(char *, uint64_t))v138;
    v138(v101, a3);
    if (v100) {
      goto LABEL_62;
    }
    goto LABEL_40;
  }
  char v95 = v85(a3, v81);
  uint64_t v88 = v86(a3, v81);
  if ((v95 & 1) == 0)
  {
    if (v88 >= 64)
    {
      v138(v87, a3);
      goto LABEL_41;
    }
    goto LABEL_36;
  }
  if (v88 > 64) {
    goto LABEL_32;
  }
  uint64_t v106 = AssociatedTypeWitness;
  uint64_t v105 = v141;
  uint64_t v107 = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v108 = v139;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v107 + 8))(&qword_18162B0B8, 256, v106, v107);
  uint64_t v109 = v150;
  ((void (*)(char *, uint64_t, int **))v105[3])(v108, a3, v105);
  LODWORD(v141) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v87, v109, a3);
  char v102 = (void (*)(char *, uint64_t))v138;
  v138(v109, a3);
  uint64_t v110 = v136;
  v135(v136, v87, a3);
  if (v141)
  {
    v102(v110, a3);
    goto LABEL_62;
  }
  v141 = (int **)v152[0];
  uint64_t v111 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
  v102(v110, a3);
  BOOL v112 = v111 < (uint64_t)v141;
  BOOL v86 = v147;
  if (v112) {
    goto LABEL_62;
  }
LABEL_40:
  v102(v87, a3);
LABEL_41:
  BOOL v113 = v148;
  uint64_t v114 = v86(a3, v4);
  uint64_t v115 = v134;
  v135(v134, v113, a3);
  if (v114 >= 65)
  {
    uint64_t v116 = (void (*)(char *, uint64_t))v138;
    v138(v115, a3);
    unint64_t v117 = v143;
    goto LABEL_43;
  }
  uint64_t v125 = v86(a3, v4);
  uint64_t v116 = (void (*)(char *, uint64_t))v138;
  v138(v115, a3);
  unint64_t v117 = v143;
  if (v125 == 64 && (v85(a3, v4) & 1) == 0)
  {
LABEL_43:
    v135(v117, v148, a3);
    v152[0] = 0x7FFFFFFFFFFFFFFFLL;
    char v118 = v85(a3, v4);
    uint64_t v119 = v86(a3, v4);
    if (v118)
    {
      if (v119 > 64)
      {
        uint64_t v122 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
        unint64_t v123 = lazy protocol witness table accessor for type Int and conformance Int(v119, v120, v121);
        unint64_t v124 = v152;
        goto LABEL_52;
      }
    }
    else if (v119 >= 64)
    {
      uint64_t v151 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v122 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
      unint64_t v123 = lazy protocol witness table accessor for type Int and conformance Int(v119, v120, v121);
      unint64_t v124 = &v151;
LABEL_52:
      uint64_t v127 = v150;
      v122(v124, &type metadata for Int, v123, a3, v4);
      char v128 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v127, v117, a3);
      v116(v127, a3);
      if (v128) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      goto LABEL_53;
    }
    uint64_t v126 = v150;
    v135(v150, v117, a3);
    (*(void (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
    v116(v126, a3);
LABEL_53:
    v116(v117, a3);
  }
  char v129 = v148;
  unint64_t v130 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(a3, v4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v116)(v129, a3);
  char v94 = v146;
  unint64_t v131 = *v146;
  if ((v130 & 0x8000000000000000) != 0)
  {
    if (v130 <= 0xFFFFFFFFFFFFFFC0) {
      unint64_t v93 = 0;
    }
    else {
      unint64_t v93 = v131 >> -(char)v130;
    }
  }
  else
  {
    unint64_t v93 = v131 << v130;
    if (v130 >= 0x40) {
      unint64_t v93 = 0;
    }
  }
LABEL_57:
  *char v94 = v93;
  return result;
}

unint64_t *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt64(a1, a2, a3, a4, a5, 0x321DuLL);
}

unint64_t *protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance UInt64(unint64_t *result, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  unint64_t v7 = *a3;
  if (!*a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, a6, 0);
  }
  unint64_t v8 = *v6 / v7;
  *a2 = *v6 % v7;
  *uint64_t result = v8;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance UInt(void *a1)
{
  unint64_t v2 = *v1;
  if (*a1) {
    v2 %= *a1;
  }
  return v2 == 0;
}

void protocol witness for BinaryInteger.signum() in conformance UInt(void *a1@<X8>)
{
  *a1 = *v1 != 0;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance UInt64(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt and conformance UInt, a5);
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance UInt64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, uint64_t a6@<X8>)
{
  uint64_t v63 = a5;
  uint64_t v64 = a4;
  uint64_t v6 = a3;
  uint64_t v70 = a6;
  uint64_t v9 = *(void *)(*(void *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v9, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v11 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v67 = (char *)&v58 - v12;
  uint64_t v13 = *(void *)(a2 - 8);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v61 = (char *)&v58 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v69 = (char *)&v58 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v58 - v19;
  MEMORY[0x1F4188790](v18);
  uint64_t v22 = (char *)&v58 - v21;
  uint64_t v65 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 64);
  char v23 = v65(a2, v6);
  uint64_t v71 = a1;
  uint64_t v72 = v13;
  uint64_t v68 = *(void (**)(char *, uint64_t, uint64_t))(v13 + 16);
  v68(v22, a1, a2);
  if ((v23 & 1) == 0)
  {
    uint64_t v60 = v9;
    unint64_t v62 = v20;
    uint64_t v66 = *(void (**)(char *, uint64_t))(v72 + 8);
    v66(v22, a2);
    goto LABEL_6;
  }
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v9, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v25 = v67;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 24))(v25, a2, v9);
  char v26 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 32) + 8) + 16))(v22, v20, a2);
  uint64_t v59 = v6;
  uint64_t v27 = v20;
  uint64_t v28 = *(void (**)(char *, uint64_t))(v72 + 8);
  v28(v27, a2);
  v28(v22, a2);
  if ((v26 & 1) == 0)
  {
    uint64_t v60 = v9;
    unint64_t v62 = v27;
    uint64_t v66 = v28;
    uint64_t v6 = v59;
LABEL_6:
    uint64_t v33 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 128);
    uint64_t v34 = v71;
    uint64_t v35 = v33(a2, v6);
    unint64_t v36 = v69;
    v68(v69, v34, a2);
    if (v35 <= 63)
    {
      char v37 = (uint64_t (*)(uint64_t, uint64_t))v66;
      v66(v36, a2);
      uint64_t v32 = v70;
LABEL_8:
      uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 120))(a2, v6);
      uint64_t result = v37(v34, a2);
      char v31 = 0;
      goto LABEL_19;
    }
    unint64_t v73 = -1;
    char v38 = v65(a2, v6);
    uint64_t v39 = v33(a2, v6);
    uint64_t v40 = v36;
    if (v38)
    {
      if (v39 < 65)
      {
        uint64_t v41 = v60;
        uint64_t v42 = swift_getAssociatedConformanceWitness(v60, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v43 = v67;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v42 + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, v42);
        unint64_t v44 = v62;
        (*(void (**)(char *, uint64_t, uint64_t))(v41 + 24))(v43, a2, v41);
        LOBYTE(v41) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 32) + 8) + 40))(v40, v44, a2);
        uint64_t v45 = v72;
        char v46 = v44;
        uint64_t v47 = v40;
        char v37 = (uint64_t (*)(uint64_t, uint64_t))v66;
        v66(v46, a2);
        unint64_t v48 = v73;
        uint64_t v49 = v61;
        (*(void (**)(char *, char *, uint64_t))(v45 + 32))(v61, v47, a2);
        if ((v41 & 1) == 0)
        {
          v37((uint64_t)v49, a2);
          uint64_t v32 = v70;
          uint64_t v34 = v71;
          goto LABEL_8;
        }
        unint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 120))(a2, v6);
        v37((uint64_t)v49, a2);
        BOOL v51 = v48 >= v50;
LABEL_17:
        uint64_t v32 = v70;
        uint64_t v34 = v71;
        if (v51) {
          goto LABEL_8;
        }
        goto LABEL_18;
      }
    }
    else if (v39 < 65)
    {
      uint64_t v56 = v62;
      (*(void (**)(char *, char *, uint64_t))(v72 + 32))(v62, v36, a2);
      unint64_t v57 = (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 120))(a2, v6);
      char v37 = (uint64_t (*)(uint64_t, uint64_t))v66;
      v66(v56, a2);
      BOOL v51 = v73 >= v57;
      goto LABEL_17;
    }
    unint64_t v52 = *(void (**)(unint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(v6 + 96);
    uint64_t v53 = v63();
    char v54 = v62;
    v52(&v73, v64, v53, a2, v6);
    char v55 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v6 + 32) + 8) + 16))(v54, v40, a2);
    char v37 = (uint64_t (*)(uint64_t, uint64_t))v66;
    v66(v54, a2);
    v37((uint64_t)v40, a2);
    uint64_t v32 = v70;
    uint64_t v34 = v71;
    if ((v55 & 1) == 0) {
      goto LABEL_8;
    }
LABEL_18:
    uint64_t result = v37(v34, a2);
    uint64_t v30 = 0;
    char v31 = 1;
    goto LABEL_19;
  }
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v28)(v71, a2);
  uint64_t v30 = 0;
  char v31 = 1;
  uint64_t v32 = v70;
LABEL_19:
  *(void *)uint64_t v32 = v30;
  *(unsigned char *)(v32 + 8) = v31;
  return result;
}

unint64_t *protocol witness for static Numeric.* infix(_:_:) in conformance UInt64@<X0>(unint64_t *result@<X0>, unint64_t *a2@<X1>, void *a3@<X8>)
{
  if (is_mul_ok(*result, *a2)) {
    *a3 = *result * *a2;
  }
  else {
    __break(1u);
  }
  return result;
}

unint64_t *protocol witness for static Numeric.*= infix(_:_:) in conformance UInt64(unint64_t *result, unint64_t *a2)
{
  if (is_mul_ok(*result, *a2)) {
    *result *= *a2;
  }
  else {
    __break(1u);
  }
  return result;
}

uint64_t *protocol witness for Strideable.advanced(by:) in conformance UInt64@<X0>(uint64_t *result@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v3 = *result;
  unint64_t v4 = *v2;
  if ((*result & 0x8000000000000000) == 0)
  {
    BOOL v5 = __CFADD__(v4, v3);
    v3 += v4;
    if (!v5) {
      goto LABEL_7;
    }
    __break(1u);
  }
  unint64_t v6 = -(uint64_t)v3;
  BOOL v5 = v4 >= v6;
  unint64_t v3 = v4 - v6;
  if (!v5)
  {
    __break(1u);
    return result;
  }
LABEL_7:
  *a2 = v3;
  return result;
}

unint64_t protocol witness for static Strideable._step(after:from:by:) in conformance UInt64(uint64_t *a1, uint64_t a2, char a3, unint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  return specialized static Strideable<>._step(after:from:by:)(a1, a2, a3 & 1, *a4, *a5, *a6);
}

void *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance UInt64@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (__CFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *a3 = *result + *a2;
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance UInt64(void *result, void *a2)
{
  if (__CFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *result += *a2;
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance UInt64@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (*result < *a2) {
    __break(1u);
  }
  else {
    *a3 = *result - *a2;
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance UInt64(void *result, void *a2)
{
  if (*result < *a2) {
    __break(1u);
  }
  else {
    *result -= *a2;
  }
  return result;
}

BOOL static UInt.<= infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a2 >= a1;
}

BOOL static UInt.>= infix(_:_:)(unint64_t a1, unint64_t a2)
{
  return a1 >= a2;
}

uint64_t UInt._toCustomAnyHashable()@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt>);
  a2[3] = result;
  a2[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance UInt@<X0>(void *a1@<X8>)
{
  uint64_t v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt>);
  a1[3] = result;
  a1[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a1 = v3;
  return result;
}

uint64_t Int._value.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*Int._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.init(exactly:)(float a1)
{
  BOOL v1 = truncl(*(short float *)&a1) != *(short float *)&a1;
  if ((~LODWORD(a1) & 0x7C00) == 0 || v1) {
    return 0;
  }
  else {
    return (uint64_t)*(short float *)&a1;
  }
}

Swift::Int_optional __swiftcall Int.init(exactly:)(Swift::Float exactly)
{
  BOOL v1 = exactly > -9.2234e18;
  if (exactly >= 9.2234e18) {
    BOOL v1 = 0;
  }
  int v2 = v1 & (truncf(exactly) == exactly);
  if (v2) {
    Swift::Int v3 = (uint64_t)exactly;
  }
  else {
    Swift::Int v3 = 0;
  }
  char v4 = v2 ^ 1;
  result.value = v3;
  result.is_nil = v4;
  return result;
}

uint64_t *static Int.*= infix(_:_:)(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result * a2;
  if ((unsigned __int128)(*result * (__int128)a2) >> 64 == v2 >> 63) {
    *Swift::Int_optional result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

uint64_t *static Int./= infix(_:_:)(uint64_t *a1, uint64_t a2)
{
  return static Int64./= infix(_:_:)(a1, a2, 0x3829uLL, 0x3830uLL);
}

uint64_t *static Int64./= infix(_:_:)(uint64_t *result, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, a3, 0);
  }
  uint64_t v4 = *result;
  if (a2 == -1 && v4 == 0x8000000000000000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  }
  *Swift::Int_optional result = v4 / a2;
  return result;
}

Swift::tuple_partialValue_Int_overflow_Bool __swiftcall Int.addingReportingOverflow(_:)(Swift::Int a1)
{
  BOOL v2 = __OFADD__(v1, a1);
  Swift::Int v3 = v1 + a1;
  Swift::Bool v4 = v2;
  result.partialValue = v3;
  result.overflow = v4;
  return result;
}

Swift::tuple_partialValue_Int_overflow_Bool __swiftcall Int.subtractingReportingOverflow(_:)(Swift::Int a1)
{
  BOOL v2 = __OFSUB__(v1, a1);
  Swift::Int v3 = v1 - a1;
  Swift::Bool v4 = v2;
  result.partialValue = v3;
  result.overflow = v4;
  return result;
}

Swift::tuple_partialValue_Int_overflow_Bool __swiftcall Int.dividedReportingOverflow(by:)(Swift::Int by)
{
  Swift::Int v2 = v1;
  if (by)
  {
    if (by == -1 && v1 == 0x8000000000000000)
    {
      Swift::Bool v3 = 1;
      Swift::Int v4 = 0x8000000000000000;
    }
    else
    {
      Swift::Bool v3 = 0;
      Swift::Int v4 = v2 / by;
    }
  }
  else
  {
    Swift::Bool v3 = 1;
    Swift::Int v4 = v2;
  }
  result.partialValue = v4;
  result.overflow = v3;
  return result;
}

Swift::tuple_partialValue_Int_overflow_Bool __swiftcall Int.remainderReportingOverflow(dividingBy:)(Swift::Int dividingBy)
{
  Swift::Int v2 = v1;
  if (dividingBy)
  {
    if (dividingBy == -1 && v1 == 0x8000000000000000)
    {
      Swift::Bool v3 = 1;
      Swift::Int v4 = 0;
    }
    else
    {
      Swift::Bool v3 = 0;
      Swift::Int v4 = v2 % dividingBy;
    }
  }
  else
  {
    Swift::Bool v3 = 1;
    Swift::Int v4 = v2;
  }
  result.partialValue = v4;
  result.overflow = v3;
  return result;
}

uint64_t *static Int.%= infix(_:_:)(uint64_t *a1, uint64_t a2)
{
  return static Int64.%= infix(_:_:)(a1, a2, 0x390EuLL, 0x3913uLL);
}

uint64_t *static Int64.%= infix(_:_:)(uint64_t *result, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (!a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, a3, 0);
  }
  uint64_t v4 = *result;
  if (a2 == -1 && v4 == 0x8000000000000000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  }
  *Swift::tuple_partialValue_Int_overflow_Bool result = v4 % a2;
  return result;
}

void *static Int.&= infix(_:_:)(void *result, uint64_t a2)
{
  *result &= a2;
  return result;
}

void *static Int.|= infix(_:_:)(void *result, uint64_t a2)
{
  *result |= a2;
  return result;
}

uint64_t *static Int.&>>= infix(_:_:)(uint64_t *result, char a2)
{
  *result >>= a2;
  return result;
}

void *static Int.&<<= infix(_:_:)(void *result, char a2)
{
  *result <<= a2;
  return result;
}

uint64_t Int.Words._value.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*Int.Words._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.Words.count.getter()
{
  return 1;
}

uint64_t Int.Words.startIndex.getter()
{
  return 0;
}

uint64_t Int.Words.endIndex.getter()
{
  return 1;
}

uint64_t Int.Words.indices.getter()
{
  return 0;
}

Swift::Int __swiftcall Int.Words.index(after:)(Swift::Int after)
{
  BOOL v1 = __OFADD__(after, 1);
  Swift::Int result = after + 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

Swift::Int __swiftcall Int.Words.index(before:)(Swift::Int before)
{
  BOOL v1 = __OFSUB__(before, 1);
  Swift::Int result = before - 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

uint64_t Int.Words.subscript.getter(uint64_t a1, uint64_t a2)
{
  return UInt64.Words.subscript.getter(a1, a2, 0x3A11uLL, 0x3A12uLL);
}

uint64_t UInt64.Words.subscript.getter(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (a1 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative word index", 19, 2, "Swift/IntegerTypes.swift", 24, 2, a3, 0);
  }
  if (a1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Word index out of range", 23, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  }
  return a2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance Int.Words(uint64_t *a1, uint64_t *a2))()
{
  uint64_t v4 = *v2;
  Int.Words.subscript.getter(*a2, v4);
  *a1 = v4;
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Collection.subscript.getter in conformance UInt64.Words@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if ((*result & 0x8000000000000000) != 0 || (uint64_t v3 = result[1], v3 >= 2)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  }
  uint64_t v4 = *v2;
  *a2 = *result;
  a2[1] = v3;
  a2[2] = v4;
  return result;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance Int.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance Int.Words(void *a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Int.Words@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return _sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlFSRyxGq_s5Error_pRi_zRi0_zRi__Ri0__r0_lySuqd__Isgyrzo_s4Int8V5WordsVABsAG_pAKRszr__lIetMgyrzo_Tpq5Tm(a1, a2);
}

uint64_t Int64.multipliedFullWidth(by:)(uint64_t a1, uint64_t a2)
{
  return (unsigned __int128)(a2 * (__int128)a1) >> 64;
}

Swift::tuple_quotient_Int_remainder_Int __swiftcall Int.dividingFullWidth(_:)(Swift::tuple_high_Int_low_UInt a1)
{
  Swift::Int v2 = Int64.dividingFullWidth(_:)(a1.high, a1.low, v1, 0x3A9EuLL, 0x3AAFuLL);
  result.remainder = v3;
  result.quotient = v2;
  return result;
}

uint64_t Int64.dividingFullWidth(_:)(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  if (!a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  }
  uint64_t result = __divti3();
  if (v7 != result >> 63) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Quotient is not representable", 29, 2, "Swift/IntegerTypes.swift", 24, 2, a5, 0);
  }
  return result;
}

unint64_t Int.byteSwapped.getter(unint64_t a1)
{
  return bswap64(a1);
}

BOOL protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance Int(void *a1, void *a2)
{
  BOOL v3 = __OFADD__(*v2, *a2);
  *a1 = *v2 + *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance Int(void *a1, void *a2)
{
  BOOL v3 = __OFSUB__(*v2, *a2);
  *a1 = *v2 - *a2;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance Int(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *v2 * *a2;
  BOOL v4 = (unsigned __int128)(*v2 * (__int128)*a2) >> 64 != v3 >> 63;
  *a1 = v3;
  return v4;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance Int(int64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  int64_t v4 = *v2;
  if (*a2)
  {
    if (v3 == -1 && v4 == 0x8000000000000000)
    {
      uint64_t v6 = 1;
      int64_t v4 = 0x8000000000000000;
    }
    else
    {
      uint64_t v6 = 0;
      v4 /= v3;
    }
  }
  else
  {
    uint64_t v6 = 1;
  }
  *a1 = v4;
  return v6;
}

uint64_t protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance Int(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *v2;
  if (!*a2) {
    goto LABEL_9;
  }
  if (v3 == -1 && v4 == 0x8000000000000000)
  {
    uint64_t v4 = 0;
LABEL_9:
    uint64_t v6 = 1;
    goto LABEL_7;
  }
  uint64_t v6 = 0;
  v4 %= v3;
LABEL_7:
  *a1 = v4;
  return v6;
}

void *protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance Int64(void *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = *v3 * *a3;
  *uint64_t result = (unsigned __int128)(*v3 * (__int128)*a3) >> 64;
  *a2 = v4;
  return result;
}

Swift::Int protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance Int(Swift::Int *a1, Swift::Int *a2, Swift::tuple_high_Int_low_UInt *a3)
{
  Swift::tuple_quotient_Int_remainder_Int v6 = Int.dividingFullWidth(_:)(*a3);
  Swift::Int result = v6.quotient;
  *a1 = v6.quotient;
  *a2 = v6.remainder;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance Int()
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8(*v0);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

unint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance Int()
{
  return __clz(*v0);
}

unint64_t *protocol witness for FixedWidthInteger.init(bigEndian:) in conformance Int@<X0>(unint64_t *result@<X0>, void *a2@<X8>)
{
  *a2 = bswap64(*result);
  return result;
}

void protocol witness for FixedWidthInteger.bigEndian.getter in conformance Int(void *a1@<X8>)
{
  *a1 = bswap64(*v1);
}

uint64_t *protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance Int@<X0>(uint64_t *result@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  *a3 = *result >> *a2;
  return result;
}

uint64_t *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance Int(uint64_t *result, void *a2)
{
  *result >>= *a2;
  return result;
}

void *protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance Int@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *result << *a2;
  return result;
}

void *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance Int(void *result, void *a2)
{
  *result <<= *a2;
  return result;
}

void *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance Int@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *a2 * *result;
  return result;
}

void *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance Int@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *a2 + *result;
  return result;
}

void *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance Int@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

void *protocol witness for _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:) in conformance Int@<X0>(void *result@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (a2 >> 8 <= 0x40) {
    *a3 = *result;
  }
  else {
    *a3 = 0;
  }
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance Int@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int and conformance Int(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type Int and conformance Int, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance UInt64@<X0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, void *a6@<X8>)
{
  unint64_t v8 = v6;
  uint64_t v13 = a5();
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v38, a1, a4, (uint64_t)a2, v13, a3);
  if (v39)
  {
    uint64_t v38 = static String._createEmpty(withInitialCapacity:)(80);
    unint64_t v39 = v15;
    TypeName = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v17 & 0x8000000000000000) == 0)
    {
      uint64_t v18 = (uint8x16_t *)TypeName;
      int64_t v19 = v17;
      int64_t v20 = validateUTF8(_:)(TypeName, v17);
      uint64_t v23 = (v22 & 1) != 0
          ? repairUTF8(_:firstKnownBrokenRange:)(v18->i8, v19, v20, v21)
          : specialized static String._uncheckedFromUTF8(_:isASCII:)(v18, v19, v20 & 1);
      uint64_t v25 = v24;
      String.append(_:)(*(Swift::String *)&v23);
      swift_bridgeObjectRelease(v25);
      v26._object = (void *)0x80000001816DE7E0;
      v26._countAndFlagsBits = 0xD00000000000001ELL;
      String.append(_:)(v26);
      uint64_t v27 = (uint64_t *)swift_getTypeName(v8, 0);
      if ((v28 & 0x8000000000000000) == 0)
      {
        char v29 = (uint8x16_t *)v27;
        int64_t v30 = v28;
        int64_t v31 = validateUTF8(_:)(v27, v28);
        if (v33) {
          uint64_t v34 = repairUTF8(_:firstKnownBrokenRange:)(v29->i8, v30, v31, v32);
        }
        else {
          uint64_t v34 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v29, v30, v31 & 1);
        }
        uint64_t v36 = v35;
        String.append(_:)(*(Swift::String *)&v34);
        swift_bridgeObjectRelease(v36);
        v37._countAndFlagsBits = 0xD00000000000002ELL;
        v37._object = (void *)0x80000001816DE800;
        String.append(_:)(v37);
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v38, v39, "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  uint64_t result = (*((uint64_t (**)(uint64_t, Class *))*(a2 - 1) + 1))(a1, a2);
  *a6 = v38;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance Int64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v80 = a4;
  uint64_t v81 = a5;
  uint64_t v76 = *(int ***)(*(void *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v76, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v74 = (char *)&v72 - v11;
  uint64_t v12 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v77 = (char *)&v72 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  int64_t v84 = (char *)&v72 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  int64_t v19 = (char *)&v72 - v18;
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v82 = (char *)&v72 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v79 = (char *)&v72 - v23;
  MEMORY[0x1F4188790](v22);
  uint64_t v25 = (char *)&v72 - v24;
  BOOL v86 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v26 = v86(a2, a3);
  uint64_t v87 = a1;
  uint64_t v88 = v12;
  uint64_t v89 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  v89(v25, a1, a2);
  uint64_t v85 = a6;
  uint64_t v83 = a3 + 64;
  if (v26)
  {
    char v78 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v27 = v78(a2, a3);
    uint64_t v90 = *(void (**)(char *, uint64_t))(v12 + 8);
    v90(v25, a2);
    if (v27 <= 64)
    {
      uint64_t v34 = v87;
      char v33 = v78;
      uint64_t v35 = v78(a2, a3);
      goto LABEL_23;
    }
    unint64_t v73 = v19;
    uint64_t v28 = v79;
    v89(v79, v87, a2);
    v92[0] = 0x8000000000000000;
    char v29 = v86;
    if (v86(a2, a3))
    {
      if (v78(a2, a3) < 64)
      {
        int64_t v30 = v82;
        v89(v82, (uint64_t)v28, a2);
        uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        int64_t v32 = v30;
LABEL_17:
        uint64_t v43 = v90;
        v90(v32, a2);
        if (v31 < v92[0]) {
LABEL_40:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_21;
      }
      uint64_t v42 = v82;
      (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(v92, v80, v81, a2, a3);
      char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v28, v42, a2);
      uint64_t v41 = v42;
    }
    else
    {
      char v36 = v29(a2, a3);
      uint64_t v37 = v78(a2, a3);
      uint64_t v38 = v28;
      if ((v36 & 1) == 0)
      {
        if (v37 >= 64)
        {
          v90(v28, a2);
          uint64_t v34 = v87;
          int64_t v19 = v73;
          char v33 = v78;
          uint64_t v35 = v78(a2, a3);
          goto LABEL_23;
        }
        unint64_t v44 = v82;
        v89(v82, (uint64_t)v28, a2);
        uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        int64_t v32 = v44;
        goto LABEL_17;
      }
      if (v37 <= 64)
      {
        uint64_t v45 = AssociatedTypeWitness;
        char v46 = v76;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v76, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v48 = v74;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v45, AssociatedConformanceWitness);
        uint64_t v49 = v82;
        ((void (*)(char *, uint64_t, int **))v46[3])(v48, a2, v46);
        LOBYTE(v45) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v38, v49, a2);
        unint64_t v50 = v38;
        uint64_t v43 = v90;
        v90(v49, a2);
        BOOL v51 = v77;
        v89(v77, (uint64_t)v50, a2);
        if (v45)
        {
          v43(v51, a2);
          goto LABEL_40;
        }
        uint64_t v52 = v92[0];
        uint64_t v53 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v43(v51, a2);
        uint64_t v28 = v79;
        if (v53 < v52) {
          goto LABEL_40;
        }
LABEL_21:
        v43(v28, a2);
        int64_t v19 = v73;
        char v33 = v78;
        goto LABEL_22;
      }
      unint64_t v39 = v82;
      (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96))(v92, v80, v81, a2, a3);
      char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v28, v39, a2);
      uint64_t v41 = v39;
    }
    uint64_t v43 = v90;
    v90(v41, a2);
    if (v40) {
      goto LABEL_40;
    }
    goto LABEL_21;
  }
  uint64_t v90 = *(void (**)(char *, uint64_t))(v12 + 8);
  v90(v25, a2);
  char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
LABEL_22:
  uint64_t v34 = v87;
  uint64_t v35 = v33(a2, a3);
LABEL_23:
  uint64_t v54 = v35;
  v89(v19, v34, a2);
  if (v54 < 65)
  {
    char v55 = v33;
    uint64_t v62 = v33(a2, a3);
    v90(v19, a2);
    if (v62 != 64)
    {
      uint64_t v56 = v85;
      goto LABEL_37;
    }
    char v63 = v86(a2, a3);
    uint64_t v56 = v85;
    if (v63) {
      goto LABEL_37;
    }
  }
  else
  {
    char v55 = v33;
    v90(v19, a2);
    uint64_t v56 = v85;
  }
  unint64_t v57 = v84;
  v89(v84, v34, a2);
  v92[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v58 = v86(a2, a3);
  uint64_t v59 = v55(a2, a3);
  if ((v58 & 1) == 0)
  {
    if (v59 > 63)
    {
      uint64_t v91 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v60 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
      uint64_t v61 = &v91;
      goto LABEL_35;
    }
LABEL_32:
    uint64_t v64 = v82;
    v89(v82, (uint64_t)v57, a2);
    (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    uint64_t v65 = v90;
    v90(v64, a2);
    v65(v57, a2);
    goto LABEL_37;
  }
  if (v59 <= 64) {
    goto LABEL_32;
  }
  uint64_t v60 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
  uint64_t v61 = v92;
LABEL_35:
  uint64_t v66 = v82;
  v60(v61, v80, v81, a2, a3);
  char v67 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v66, v57, a2);
  uint64_t v68 = v66;
  uint64_t v69 = v90;
  v90(v68, a2);
  if (v67) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v69(v84, a2);
LABEL_37:
  uint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v90)(v34, a2);
  *uint64_t v56 = v70;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance UInt64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  *a4 = v7;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance Int@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type Int and conformance Int(a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance Int()
{
  if ((uint64_t)*v0 <= 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/Integers.swift", 20, 2, 0x8F1uLL, 0);
  }
  return __clz(*v0) ^ 0x3F;
}

unint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance Int()
{
  return __clz(__rbit64(*v0));
}

void *protocol witness for static BinaryInteger./ infix(_:_:) in conformance Int@<X0>(void *result@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  }
  if (*result == 0x8000000000000000 && v3 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3830uLL, 0);
  }
  *a3 = *result / v3;
  return result;
}

uint64_t *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int64(a1, a2, a3, a4, 0x3829uLL, 0x3830uLL);
}

uint64_t *protocol witness for static BinaryInteger./= infix(_:_:) in conformance Int64(uint64_t *result, uint64_t *a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  uint64_t v6 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, a5, 0);
  }
  uint64_t v7 = *result;
  if (v6 == -1 && v7 == 0x8000000000000000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow", 31, 2, "Swift/IntegerTypes.swift", 24, 2, a6, 0);
  }
  *uint64_t result = v7 / v6;
  return result;
}

uint64_t *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int64(a1, a2, 0x390EuLL, 0x3913uLL, a3);
}

uint64_t *protocol witness for static BinaryInteger.% infix(_:_:) in conformance Int64@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X4>, unint64_t a4@<X5>, uint64_t *a5@<X8>)
{
  uint64_t v5 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, a3, 0);
  }
  if (*result == 0x8000000000000000 && v5 == -1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, a4, 0);
  }
  *a5 = *result % v5;
  return result;
}

uint64_t *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int64(a1, a2, a3, a4, 0x390EuLL, 0x3913uLL);
}

uint64_t *protocol witness for static BinaryInteger.%= infix(_:_:) in conformance Int64(uint64_t *result, uint64_t *a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  uint64_t v6 = *a2;
  if (!*a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, a5, 0);
  }
  uint64_t v7 = *result;
  if (v6 == -1 && v7 == 0x8000000000000000) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division results in an overflow in remainder operation", 54, 2, "Swift/IntegerTypes.swift", 24, 2, a6, 0);
  }
  *uint64_t result = v7 % v6;
  return result;
}

void *protocol witness for static BinaryInteger.~ prefix(_:) in conformance Int@<X0>(void *result@<X0>, void *a2@<X8>)
{
  *a2 = ~*result;
  return result;
}

void *protocol witness for static BinaryInteger.& infix(_:_:) in conformance Int@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *a2 & *result;
  return result;
}

void *protocol witness for static BinaryInteger.&= infix(_:_:) in conformance Int(void *result, void *a2)
{
  *result &= *a2;
  return result;
}

void *protocol witness for static BinaryInteger.| infix(_:_:) in conformance Int@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *a2 | *result;
  return result;
}

void *protocol witness for static BinaryInteger.|= infix(_:_:) in conformance Int(void *result, void *a2)
{
  *result |= *a2;
  return result;
}

void *protocol witness for static BinaryInteger.^ infix(_:_:) in conformance Int@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *a2 ^ *result;
  return result;
}

void *protocol witness for static BinaryInteger.^= infix(_:_:) in conformance Int(void *result, void *a2)
{
  *result ^= *a2;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance Int@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t v105 = a5;
  uint64_t v107 = a7;
  char v99 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v99, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v12 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v97 = (char *)&v89 - v13;
  uint64_t v14 = *(void *)(a3 - 8);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v89 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  unint64_t v93 = (char *)&v89 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  char v101 = (char *)&v89 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  char v102 = (char *)&v89 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  char v95 = (char *)&v89 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v103 = (char *)&v89 - v27;
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  uint64_t v109 = (char *)&v89 - v29;
  MEMORY[0x1F4188790](v28);
  uint64_t v31 = (char *)&v89 - v30;
  uint64_t v104 = *a1;
  int64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v33 = v32(a3, a4);
  uint64_t v108 = v32;
  if (v33)
  {
    uint64_t v34 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    if (v34(a3, a4) >= 64)
    {
      v111[0] = -64;
      (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v111, v105, a6, a3, a4);
      char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v31, a3);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v31, a3);
      if ((v40 & 1) == 0)
      {
LABEL_20:
        char v49 = v32(a3, a4);
LABEL_21:
        char v51 = v49;
        uint64_t v100 = a4 + 128;
        uint64_t v52 = v34(a3, a4);
        uint64_t v94 = a4 + 64;
        if (v51)
        {
          if (v52 > 64) {
            goto LABEL_23;
          }
        }
        else if (v52 > 63)
        {
LABEL_23:
          v111[0] = 64;
          (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v111, v105, a6, a3, a4);
          char v53 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v31, a2, a3);
          char v96 = *(uint64_t (**)(char *, uint64_t))(v14 + 8);
          uint64_t result = v96(v31, a3);
          if ((v53 & 1) == 0)
          {
LABEL_28:
            uint64_t v55 = a6;
            uint64_t v106 = v34;
            uint64_t v57 = v14 + 16;
            uint64_t v56 = *(void (**)(char *, uint64_t, uint64_t))(v14 + 16);
            uint64_t v58 = v14;
            uint64_t v59 = v109;
            v56(v109, a2, a3);
            char v60 = v108(a3, a4);
            uint64_t v61 = v103;
            uint64_t v91 = (void (*)(char *, char *, uint64_t))v56;
            uint64_t v92 = v57;
            v56(v103, (uint64_t)v59, a3);
            uint64_t v90 = v55;
            if ((v60 & 1) == 0)
            {
              v96(v61, a3);
              goto LABEL_45;
            }
            uint64_t v62 = v106(a3, a4);
            v96(v61, a3);
            if (v62 <= 64) {
              goto LABEL_45;
            }
            char v63 = v95;
            v91(v95, v109, a3);
            v111[0] = 0x8000000000000000;
            uint64_t v64 = v108;
            if (v108(a3, a4))
            {
              uint64_t v89 = v58;
              if (v106(a3, a4) < 64)
              {
LABEL_40:
                v91(v31, v63, a3);
                uint64_t v69 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
                uint64_t v68 = (void (*)(char *, uint64_t))v96;
                v96(v31, a3);
                if (v69 < v111[0]) {
LABEL_67:
                }
                  _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
                goto LABEL_44;
              }
            }
            else
            {
              char v65 = v64(a3, a4);
              uint64_t v66 = v106(a3, a4);
              if ((v65 & 1) == 0)
              {
                if (v66 >= 64)
                {
                  v96(v63, a3);
LABEL_45:
                  uint64_t v77 = v109;
                  char v78 = v106;
                  uint64_t v79 = v106(a3, a4);
                  uint64_t v80 = v102;
                  v91(v102, v77, a3);
                  if (v79 < 65)
                  {
                    uint64_t v85 = v78(a3, a4);
                    uint64_t v81 = (void (*)(char *, uint64_t))v96;
                    v96(v80, a3);
                    if (v85 != 64 || (v108(a3, a4) & 1) != 0) {
                      goto LABEL_58;
                    }
                  }
                  else
                  {
                    uint64_t v81 = (void (*)(char *, uint64_t))v96;
                    v96(v80, a3);
                  }
                  uint64_t v82 = v101;
                  v91(v101, v109, a3);
                  v111[0] = 0x7FFFFFFFFFFFFFFFLL;
                  uint64_t v83 = v82;
                  LOBYTE(v82) = v108(a3, a4);
                  uint64_t v84 = v106(a3, a4);
                  if (v82)
                  {
                    if (v84 > 64)
                    {
                      (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v111, v105, v90, a3, a4);
                      goto LABEL_56;
                    }
                  }
                  else if (v84 > 63)
                  {
                    uint64_t v110 = 0x7FFFFFFFFFFFFFFFLL;
                    (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v110, v105, v90, a3, a4);
LABEL_56:
                    char v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                             + 16))(v31, v83, a3);
                    v81(v31, a3);
                    if (v86) {
                      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
                    }
                    goto LABEL_57;
                  }
                  v91(v31, v83, a3);
                  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
                  v81(v31, a3);
LABEL_57:
                  v81(v83, a3);
LABEL_58:
                  uint64_t v87 = v109;
                  unint64_t v88 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
                  uint64_t result = ((uint64_t (*)(char *, uint64_t))v81)(v87, a3);
                  if ((v88 & 0x8000000000000000) == 0)
                  {
                    if (v88 < 0x40)
                    {
                      uint64_t v48 = v104 >> v88;
                      goto LABEL_61;
                    }
                    goto LABEL_27;
                  }
                  if (v88 > 0xFFFFFFFFFFFFFFC0)
                  {
                    uint64_t v48 = v104 << -(char)v88;
                    goto LABEL_61;
                  }
                  goto LABEL_19;
                }
                uint64_t v89 = v58;
                goto LABEL_40;
              }
              uint64_t v89 = v58;
              if (v66 <= 64)
              {
                uint64_t v71 = AssociatedTypeWitness;
                uint64_t v70 = v99;
                uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v99, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
                unint64_t v73 = v97;
                (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v71, AssociatedConformanceWitness);
                ((void (*)(char *, uint64_t, int **))v70[3])(v73, a3, v70);
                LOBYTE(v70) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                                 + 16))(v63, v31, a3);
                uint64_t v68 = (void (*)(char *, uint64_t))v96;
                v96(v31, a3);
                uint64_t v74 = v93;
                v91(v93, v63, a3);
                if (v70)
                {
                  v68(v74, a3);
                  goto LABEL_67;
                }
                uint64_t v75 = v111[0];
                uint64_t v76 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
                v68(v74, a3);
                if (v76 < v75) {
                  goto LABEL_67;
                }
LABEL_44:
                v68(v63, a3);
                goto LABEL_45;
              }
            }
            (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v111, v105, v55, a3, a4);
            char v67 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v63, v31, a3);
            uint64_t v68 = (void (*)(char *, uint64_t))v96;
            v96(v31, a3);
            if (v67) {
              goto LABEL_67;
            }
            goto LABEL_44;
          }
LABEL_27:
          uint64_t v48 = v104 >> 63;
          goto LABEL_61;
        }
        (*(void (**)(char *, uint64_t, uint64_t))(v14 + 16))(v31, a2, a3);
        uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        char v96 = *(uint64_t (**)(char *, uint64_t))(v14 + 8);
        uint64_t result = v96(v31, a3);
        if (v54 <= 64) {
          goto LABEL_28;
        }
        goto LABEL_27;
      }
    }
    else
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v14 + 16))(v31, a2, a3);
      uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v31, a3);
      if (v35 >= -64) {
        goto LABEL_20;
      }
    }
LABEL_19:
    uint64_t v48 = 0;
    goto LABEL_61;
  }
  char v37 = v32(a3, a4);
  uint64_t v106 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v38 = v106(a3, a4);
  if ((v37 & 1) == 0)
  {
    if (v38 >= 64)
    {
      uint64_t v34 = v106;
      char v49 = v108(a3, a4);
      goto LABEL_21;
    }
    (*(void (**)(char *, uint64_t, uint64_t))(v14 + 16))(v31, a2, a3);
    uint64_t v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v31, a3);
    BOOL v42 = v41 < -64;
LABEL_17:
    int64_t v32 = v108;
    uint64_t v34 = v106;
    if (!v42) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  if (v38 > 64)
  {
    v111[0] = -64;
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v111, v105, a6, a3, a4);
    char v39 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v31, a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v31, a3);
    int64_t v32 = v108;
    uint64_t v34 = v106;
    if ((v39 & 1) == 0) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  uint64_t v90 = a6;
  uint64_t v43 = AssociatedTypeWitness;
  unint64_t v44 = v99;
  uint64_t v45 = swift_getAssociatedConformanceWitness((uint64_t)v99, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  char v46 = v97;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v45 + 8))(&qword_18162B0B8, 256, v43, v45);
  ((void (*)(char *, uint64_t, int **))v44[3])(v46, a3, v44);
  LOBYTE(v43) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v31, a3);
  uint64_t v47 = *(void (**)(char *, uint64_t))(v14 + 8);
  v47(v31, a3);
  uint64_t v89 = v14;
  (*(void (**)(char *, uint64_t, uint64_t))(v14 + 16))(v17, a2, a3);
  if ((v43 & 1) == 0)
  {
    uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v47)(v17, a3);
    BOOL v42 = v50 < -64;
    uint64_t v14 = v89;
    a6 = v90;
    goto LABEL_17;
  }
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v47)(v17, a3);
  uint64_t v48 = 0;
LABEL_61:
  uint64_t *v107 = v48;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance Int(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v110 = a6;
  BOOL v113 = a1;
  uint64_t v103 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v103, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v101 = (char *)&v93 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v93 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  unint64_t v98 = (char *)&v93 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v105 = (char *)&v93 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v104 = (char *)&v93 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  char v99 = (char *)&v93 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v106 = (char *)&v93 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v111 = (char *)&v93 - v27;
  MEMORY[0x1F4188790](v26);
  uint64_t v29 = (char *)&v93 - v28;
  uint64_t v31 = a4 + 64;
  uint64_t v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v32 = v30(a3, a4);
  BOOL v112 = v30;
  if (v32)
  {
    char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    if (v33(a3, a4) < 64)
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
      uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      if (v34 >= -64) {
        goto LABEL_19;
      }
LABEL_18:
      uint64_t v45 = 0;
      goto LABEL_58;
    }
    v115[0] = -64;
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v115, a5, v110, a3, a4);
LABEL_9:
    char v38 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v29, a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
    if ((v38 & 1) == 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  uint64_t v109 = a5;
  char v36 = v30(a3, a4);
  char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v37 = v33(a3, a4);
  if (v36)
  {
    if (v37 > 64)
    {
      v115[0] = -64;
      a5 = v109;
      (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v115, v109, v110, a3, a4);
      goto LABEL_9;
    }
    uint64_t v107 = a4 + 64;
    uint64_t v94 = v33;
    char v40 = AssociatedTypeWitness;
    uint64_t v41 = v103;
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v103, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v43 = v101;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v40, AssociatedConformanceWitness);
    ((void (*)(char *, uint64_t, int **))v41[3])(v43, a3, v41);
    LOBYTE(v40) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v29, a3);
    unint64_t v44 = *(void (**)(char *, uint64_t))(v12 + 8);
    v44(v29, a3);
    uint64_t v97 = v12;
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, a3);
    if (v40)
    {
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v44)(v15, a3);
      uint64_t v45 = 0;
      goto LABEL_58;
    }
    uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v44)(v15, a3);
    uint64_t v12 = v97;
    a5 = v109;
    char v33 = v94;
    uint64_t v31 = v107;
    if (v46 < -64) {
      goto LABEL_18;
    }
  }
  else
  {
    if (v37 >= 64)
    {
      a5 = v109;
      goto LABEL_19;
    }
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
    uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
    a5 = v109;
    if (v39 < -64) {
      goto LABEL_18;
    }
  }
LABEL_19:
  char v47 = v112(a3, a4);
  uint64_t v100 = a4 + 128;
  uint64_t v48 = v33(a3, a4);
  uint64_t v107 = v31;
  if (v47)
  {
    if (v48 > 64) {
      goto LABEL_21;
    }
  }
  else if (v48 >= 64)
  {
LABEL_21:
    v115[0] = 64;
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v115, a5, v110, a3, a4);
    char v49 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v29, a2, a3);
    uint64_t v50 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    uint64_t result = v50(v29, a3);
    if ((v49 & 1) == 0) {
      goto LABEL_22;
    }
LABEL_29:
    uint64_t v45 = *v113 >> 63;
    goto LABEL_58;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
  uint64_t v63 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v50 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  uint64_t result = v50(v29, a3);
  if (v63 > 64) {
    goto LABEL_29;
  }
LABEL_22:
  char v95 = v29;
  uint64_t v108 = (void (*)(char *, uint64_t))v50;
  uint64_t v109 = a5;
  uint64_t v52 = v12 + 16;
  char v51 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  uint64_t v53 = v12;
  uint64_t v54 = v111;
  v51(v111, a2, a3);
  char v55 = v112(a3, a4);
  uint64_t v56 = v106;
  uint64_t v57 = v54;
  uint64_t v96 = v52;
  uint64_t v58 = (void (*)(char *, char *, uint64_t))v51;
  v51(v106, (uint64_t)v57, a3);
  uint64_t v97 = v53;
  if ((v55 & 1) == 0)
  {
    v108(v56, a3);
    char v60 = v95;
    goto LABEL_42;
  }
  uint64_t v59 = v33(a3, a4);
  v108(v56, a3);
  char v60 = v95;
  if (v59 <= 64) {
    goto LABEL_42;
  }
  uint64_t v61 = v99;
  v58(v99, v111, a3);
  v115[0] = 0x8000000000000000;
  uint64_t v62 = v112;
  if (v112(a3, a4))
  {
    if (v33(a3, a4) >= 64)
    {
LABEL_33:
      (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v115, v109, v110, a3, a4);
      char v66 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v61, v60, a3);
      char v67 = v108;
      v108(v60, a3);
      if (v66) {
        goto LABEL_64;
      }
      goto LABEL_41;
    }
LABEL_37:
    v58(v60, v61, a3);
    uint64_t v68 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v67 = v108;
    v108(v60, a3);
    if (v68 < v115[0]) {
LABEL_64:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_41;
  }
  char v64 = v62(a3, a4);
  uint64_t v65 = v33(a3, a4);
  if ((v64 & 1) == 0)
  {
    if (v65 >= 64)
    {
      v108(v61, a3);
      goto LABEL_42;
    }
    goto LABEL_37;
  }
  if (v65 > 64) {
    goto LABEL_33;
  }
  uint64_t v94 = v33;
  uint64_t v70 = AssociatedTypeWitness;
  uint64_t v69 = v103;
  uint64_t v71 = swift_getAssociatedConformanceWitness((uint64_t)v103, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v72 = v101;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v71 + 8))(&qword_18162B0B8, 256, v70, v71);
  ((void (*)(char *, uint64_t, int **))v69[3])(v72, a3, v69);
  LOBYTE(v69) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v61, v60, a3);
  char v67 = v108;
  v108(v60, a3);
  unint64_t v73 = v98;
  v58(v98, v61, a3);
  if (v69)
  {
    v67(v73, a3);
    goto LABEL_64;
  }
  uint64_t v74 = v115[0];
  uint64_t v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v67(v73, a3);
  BOOL v76 = v75 < v74;
  char v33 = v94;
  if (v76) {
    goto LABEL_64;
  }
LABEL_41:
  v67(v61, a3);
LABEL_42:
  uint64_t v78 = v110;
  uint64_t v77 = v111;
  uint64_t v79 = v33(a3, a4);
  uint64_t v80 = v104;
  v58(v104, v77, a3);
  if (v79 < 65)
  {
    uint64_t v81 = v33;
    uint64_t v86 = v33(a3, a4);
    v108(v80, a3);
    uint64_t v82 = v105;
    if (v86 != 64) {
      goto LABEL_55;
    }
    uint64_t v83 = v112;
    if (v112(a3, a4)) {
      goto LABEL_55;
    }
  }
  else
  {
    uint64_t v81 = v33;
    v108(v80, a3);
    uint64_t v82 = v105;
    uint64_t v83 = v112;
  }
  v58(v82, v111, a3);
  v115[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v84 = v83(a3, a4);
  uint64_t v85 = v81(a3, a4);
  if ((v84 & 1) == 0)
  {
    if (v85 >= 64)
    {
      uint64_t v114 = 0x7FFFFFFFFFFFFFFFLL;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v114, v109, v78, a3, a4);
      goto LABEL_53;
    }
LABEL_52:
    v58(v60, v82, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v87 = v108;
    v108(v60, a3);
    v87(v82, a3);
    goto LABEL_55;
  }
  if (v85 <= 64) {
    goto LABEL_52;
  }
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v115, v109, v78, a3, a4);
LABEL_53:
  char v88 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v60, v82, a3);
  uint64_t v89 = v108;
  v108(v60, a3);
  if (v88) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v89(v82, a3);
LABEL_55:
  uint64_t v90 = v111;
  unint64_t v91 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v108)(v90, a3);
  uint64_t v92 = *v113;
  if ((v91 & 0x8000000000000000) != 0)
  {
    if (v91 > 0xFFFFFFFFFFFFFFC0)
    {
      uint64_t v45 = v92 << -(char)v91;
      goto LABEL_58;
    }
    goto LABEL_18;
  }
  if (v91 >= 0x40) {
    uint64_t v45 = v92 >> 63;
  }
  else {
    uint64_t v45 = v92 >> v91;
  }
LABEL_58:
  *BOOL v113 = v45;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance Int@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t *a7@<X8>)
{
  uint64_t v105 = a5;
  uint64_t v107 = a7;
  char v99 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v99, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v12 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v97 = (char *)&v89 - v13;
  uint64_t v14 = *(void *)(a3 - 8);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v89 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v93 = (char *)&v89 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  char v101 = (char *)&v89 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  char v102 = (char *)&v89 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  char v95 = (char *)&v89 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v103 = (char *)&v89 - v27;
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  uint64_t v109 = (char *)&v89 - v29;
  MEMORY[0x1F4188790](v28);
  uint64_t v31 = (char *)&v89 - v30;
  uint64_t v104 = *a1;
  char v32 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v33 = v32(a3, a4);
  uint64_t v108 = v32;
  if ((v33 & 1) == 0)
  {
    char v37 = v32(a3, a4);
    uint64_t v106 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v38 = v106(a3, a4);
    if (v37)
    {
      if (v38 > 64)
      {
        v111[0] = -64;
        (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v111, v105, a6, a3, a4);
        char v39 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v31, a3);
        uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v31, a3);
        char v32 = v108;
        uint64_t v34 = v106;
        if ((v39 & 1) == 0) {
          goto LABEL_20;
        }
LABEL_19:
        uint64_t v50 = v104 >> 63;
        goto LABEL_60;
      }
      uint64_t v90 = a6;
      uint64_t v43 = AssociatedTypeWitness;
      unint64_t v44 = v99;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v99, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v46 = v97;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v43, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v44[3])(v46, a3, v44);
      LOBYTE(v43) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v31, a3);
      char v47 = *(void (**)(char *, uint64_t))(v14 + 8);
      v47(v31, a3);
      uint64_t v89 = v14;
      (*(void (**)(char *, uint64_t, uint64_t))(v14 + 16))(v17, a2, a3);
      if (v43)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v47)(v17, a3);
        goto LABEL_19;
      }
      uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = ((uint64_t (*)(char *, uint64_t))v47)(v17, a3);
      BOOL v42 = v49 < -64;
      uint64_t v14 = v89;
      a6 = v90;
    }
    else
    {
      if (v38 >= 64)
      {
        uint64_t v34 = v106;
        char v48 = v108(a3, a4);
        goto LABEL_21;
      }
      (*(void (**)(char *, uint64_t, uint64_t))(v14 + 16))(v31, a2, a3);
      uint64_t v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v31, a3);
      BOOL v42 = v41 < -64;
    }
    char v32 = v108;
    uint64_t v34 = v106;
    if (!v42) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  uint64_t v34 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  if (v34(a3, a4) >= 64)
  {
    v111[0] = -64;
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v111, v105, a6, a3, a4);
    char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v31, a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v31, a3);
    if ((v40 & 1) == 0) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v14 + 16))(v31, a2, a3);
  uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v31, a3);
  if (v35 <= -65) {
    goto LABEL_19;
  }
LABEL_20:
  char v48 = v32(a3, a4);
LABEL_21:
  char v51 = v48;
  uint64_t v100 = a4 + 128;
  uint64_t v52 = v34(a3, a4);
  uint64_t v94 = a4 + 64;
  if (v51)
  {
    if (v52 > 64) {
      goto LABEL_23;
    }
LABEL_26:
    (*(void (**)(char *, uint64_t, uint64_t))(v14 + 16))(v31, a2, a3);
    uint64_t v54 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v96 = *(uint64_t (**)(char *, uint64_t))(v14 + 8);
    uint64_t result = v96(v31, a3);
    if (v54 > 64) {
      goto LABEL_24;
    }
    goto LABEL_27;
  }
  if (v52 < 64) {
    goto LABEL_26;
  }
LABEL_23:
  v111[0] = 64;
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v111, v105, a6, a3, a4);
  char v53 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v31, a2, a3);
  uint64_t v96 = *(uint64_t (**)(char *, uint64_t))(v14 + 8);
  uint64_t result = v96(v31, a3);
  if (v53)
  {
LABEL_24:
    uint64_t v50 = 0;
    goto LABEL_60;
  }
LABEL_27:
  uint64_t v55 = a6;
  uint64_t v106 = v34;
  uint64_t v57 = v14 + 16;
  uint64_t v56 = *(void (**)(char *, uint64_t, uint64_t))(v14 + 16);
  uint64_t v58 = v14;
  uint64_t v59 = v109;
  v56(v109, a2, a3);
  char v60 = v108(a3, a4);
  uint64_t v61 = v103;
  unint64_t v91 = (void (*)(char *, char *, uint64_t))v56;
  uint64_t v92 = v57;
  v56(v103, (uint64_t)v59, a3);
  uint64_t v90 = v55;
  if ((v60 & 1) == 0)
  {
    v96(v61, a3);
    goto LABEL_44;
  }
  uint64_t v62 = v106(a3, a4);
  v96(v61, a3);
  if (v62 <= 64) {
    goto LABEL_44;
  }
  uint64_t v63 = v95;
  v91(v95, v109, a3);
  v111[0] = 0x8000000000000000;
  char v64 = v108;
  if (v108(a3, a4))
  {
    uint64_t v89 = v58;
    if (v106(a3, a4) < 64)
    {
LABEL_39:
      v91(v31, v63, a3);
      uint64_t v69 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t v68 = (void (*)(char *, uint64_t))v96;
      v96(v31, a3);
      if (v69 < v111[0]) {
LABEL_66:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_43;
    }
    goto LABEL_35;
  }
  char v65 = v64(a3, a4);
  uint64_t v66 = v106(a3, a4);
  if (v65)
  {
    uint64_t v89 = v58;
    if (v66 <= 64)
    {
      uint64_t v71 = AssociatedTypeWitness;
      uint64_t v70 = v99;
      uint64_t v72 = swift_getAssociatedConformanceWitness((uint64_t)v99, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v73 = v97;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v72 + 8))(&qword_18162B0B8, 256, v71, v72);
      ((void (*)(char *, uint64_t, int **))v70[3])(v73, a3, v70);
      LOBYTE(v70) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v63, v31, a3);
      uint64_t v68 = (void (*)(char *, uint64_t))v96;
      v96(v31, a3);
      uint64_t v74 = v93;
      v91(v93, v63, a3);
      if (v70)
      {
        v68(v74, a3);
        goto LABEL_66;
      }
      uint64_t v75 = v111[0];
      uint64_t v76 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v68(v74, a3);
      if (v76 < v75) {
        goto LABEL_66;
      }
LABEL_43:
      v68(v63, a3);
      goto LABEL_44;
    }
LABEL_35:
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v111, v105, v55, a3, a4);
    char v67 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v63, v31, a3);
    uint64_t v68 = (void (*)(char *, uint64_t))v96;
    v96(v31, a3);
    if (v67) {
      goto LABEL_66;
    }
    goto LABEL_43;
  }
  if (v66 < 64)
  {
    uint64_t v89 = v58;
    goto LABEL_39;
  }
  v96(v63, a3);
LABEL_44:
  uint64_t v77 = v109;
  uint64_t v78 = v106;
  uint64_t v79 = v106(a3, a4);
  uint64_t v80 = v102;
  v91(v102, v77, a3);
  if (v79 >= 65)
  {
    uint64_t v81 = (void (*)(char *, uint64_t))v96;
    v96(v80, a3);
    goto LABEL_46;
  }
  uint64_t v85 = v78(a3, a4);
  uint64_t v81 = (void (*)(char *, uint64_t))v96;
  v96(v80, a3);
  if (v85 == 64 && (v108(a3, a4) & 1) == 0)
  {
LABEL_46:
    uint64_t v82 = v101;
    v91(v101, v109, a3);
    v111[0] = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v83 = v82;
    LOBYTE(v82) = v108(a3, a4);
    uint64_t v84 = v106(a3, a4);
    if (v82)
    {
      if (v84 > 64)
      {
        (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v111, v105, v90, a3, a4);
        goto LABEL_55;
      }
    }
    else if (v84 >= 64)
    {
      uint64_t v110 = 0x7FFFFFFFFFFFFFFFLL;
      (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v110, v105, v90, a3, a4);
LABEL_55:
      char v86 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v31, v83, a3);
      v81(v31, a3);
      if (v86) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      goto LABEL_56;
    }
    v91(v31, v83, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v81(v31, a3);
LABEL_56:
    v81(v83, a3);
  }
  uint64_t v87 = v109;
  unint64_t v88 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v81)(v87, a3);
  if ((v88 & 0x8000000000000000) != 0)
  {
    if (v88 > 0xFFFFFFFFFFFFFFC0)
    {
      uint64_t v50 = v104 >> -(char)v88;
      goto LABEL_60;
    }
    goto LABEL_19;
  }
  uint64_t v50 = v104 << v88;
  if (v88 >= 0x40) {
    uint64_t v50 = 0;
  }
LABEL_60:
  uint64_t *v107 = v50;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance Int(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v110 = a6;
  BOOL v113 = a1;
  uint64_t v103 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v103, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  char v101 = (char *)&v93 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v93 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  unint64_t v98 = (char *)&v93 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  uint64_t v105 = (char *)&v93 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v104 = (char *)&v93 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  char v99 = (char *)&v93 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v106 = (char *)&v93 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v111 = (char *)&v93 - v27;
  MEMORY[0x1F4188790](v26);
  uint64_t v29 = (char *)&v93 - v28;
  uint64_t v31 = a4 + 64;
  uint64_t v30 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v32 = v30(a3, a4);
  BOOL v112 = v30;
  if (v32)
  {
    char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    if (v33(a3, a4) < 64)
    {
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
      uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
      if (v34 > -65) {
        goto LABEL_19;
      }
LABEL_18:
      uint64_t v46 = *v113 >> 63;
      goto LABEL_58;
    }
    v115[0] = -64;
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v115, a5, v110, a3, a4);
LABEL_9:
    char v38 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v29, a3);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
    if (v38) {
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v109 = a5;
  char v36 = v30(a3, a4);
  char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v37 = v33(a3, a4);
  if (v36)
  {
    if (v37 <= 64)
    {
      uint64_t v107 = a4 + 64;
      uint64_t v94 = v33;
      char v40 = AssociatedTypeWitness;
      uint64_t v41 = v103;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v103, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v43 = v101;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v40, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v41[3])(v43, a3, v41);
      LOBYTE(v40) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      unint64_t v44 = *(void (**)(char *, uint64_t))(v12 + 8);
      v44(v29, a3);
      uint64_t v97 = v12;
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, a3);
      if (v40)
      {
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v44)(v15, a3);
      }
      else
      {
        uint64_t v45 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        uint64_t result = ((uint64_t (*)(char *, uint64_t))v44)(v15, a3);
        uint64_t v12 = v97;
        a5 = v109;
        char v33 = v94;
        uint64_t v31 = v107;
        if (v45 >= -64) {
          goto LABEL_19;
        }
      }
      goto LABEL_18;
    }
    v115[0] = -64;
    a5 = v109;
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v115, v109, v110, a3, a4);
    goto LABEL_9;
  }
  if (v37 >= 64)
  {
    a5 = v109;
    goto LABEL_19;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
  uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t))(v12 + 8))(v29, a3);
  a5 = v109;
  if (v39 < -64) {
    goto LABEL_18;
  }
LABEL_19:
  char v47 = v112(a3, a4);
  uint64_t v100 = a4 + 128;
  uint64_t v48 = v33(a3, a4);
  uint64_t v107 = v31;
  if (v47)
  {
    if (v48 > 64) {
      goto LABEL_21;
    }
LABEL_24:
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v29, a2, a3);
    uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v50 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
    uint64_t result = v50(v29, a3);
    if (v51 > 64) {
      goto LABEL_22;
    }
    goto LABEL_25;
  }
  if (v48 < 64) {
    goto LABEL_24;
  }
LABEL_21:
  v115[0] = 64;
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v115, a5, v110, a3, a4);
  char v49 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v29, a2, a3);
  uint64_t v50 = *(uint64_t (**)(char *, uint64_t))(v12 + 8);
  uint64_t result = v50(v29, a3);
  if (v49)
  {
LABEL_22:
    uint64_t v46 = 0;
    goto LABEL_58;
  }
LABEL_25:
  char v95 = v29;
  uint64_t v108 = (void (*)(char *, uint64_t))v50;
  uint64_t v109 = a5;
  uint64_t v53 = v12 + 16;
  uint64_t v52 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  uint64_t v54 = v12;
  uint64_t v55 = v111;
  v52(v111, a2, a3);
  char v56 = v112(a3, a4);
  uint64_t v57 = v106;
  uint64_t v58 = v55;
  uint64_t v96 = v53;
  uint64_t v59 = (void (*)(char *, char *, uint64_t))v52;
  v52(v106, (uint64_t)v58, a3);
  uint64_t v97 = v54;
  if ((v56 & 1) == 0)
  {
    v108(v57, a3);
    uint64_t v61 = v95;
    goto LABEL_42;
  }
  uint64_t v60 = v33(a3, a4);
  v108(v57, a3);
  uint64_t v61 = v95;
  if (v60 <= 64) {
    goto LABEL_42;
  }
  uint64_t v62 = v99;
  v59(v99, v111, a3);
  v115[0] = 0x8000000000000000;
  uint64_t v63 = v112;
  if (v112(a3, a4))
  {
    if (v33(a3, a4) >= 64)
    {
LABEL_33:
      (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v115, v109, v110, a3, a4);
      char v66 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v62, v61, a3);
      char v67 = v108;
      v108(v61, a3);
      if (v66) {
        goto LABEL_63;
      }
      goto LABEL_41;
    }
LABEL_37:
    v59(v61, v62, a3);
    uint64_t v68 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    char v67 = v108;
    v108(v61, a3);
    if (v68 < v115[0]) {
LABEL_63:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
    goto LABEL_41;
  }
  char v64 = v63(a3, a4);
  uint64_t v65 = v33(a3, a4);
  if ((v64 & 1) == 0)
  {
    if (v65 >= 64)
    {
      v108(v62, a3);
      goto LABEL_42;
    }
    goto LABEL_37;
  }
  if (v65 > 64) {
    goto LABEL_33;
  }
  uint64_t v94 = v33;
  uint64_t v70 = AssociatedTypeWitness;
  uint64_t v69 = v103;
  uint64_t v71 = swift_getAssociatedConformanceWitness((uint64_t)v103, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v72 = v101;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v71 + 8))(&qword_18162B0B8, 256, v70, v71);
  ((void (*)(char *, uint64_t, int **))v69[3])(v72, a3, v69);
  LOBYTE(v69) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v62, v61, a3);
  char v67 = v108;
  v108(v61, a3);
  unint64_t v73 = v98;
  v59(v98, v62, a3);
  if (v69)
  {
    v67(v73, a3);
    goto LABEL_63;
  }
  uint64_t v74 = v115[0];
  uint64_t v75 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v67(v73, a3);
  BOOL v76 = v75 < v74;
  char v33 = v94;
  if (v76) {
    goto LABEL_63;
  }
LABEL_41:
  v67(v62, a3);
LABEL_42:
  uint64_t v78 = v110;
  uint64_t v77 = v111;
  uint64_t v79 = v33(a3, a4);
  uint64_t v80 = v104;
  v59(v104, v77, a3);
  if (v79 < 65)
  {
    uint64_t v81 = v33;
    uint64_t v86 = v33(a3, a4);
    v108(v80, a3);
    uint64_t v82 = v105;
    if (v86 != 64) {
      goto LABEL_55;
    }
    uint64_t v83 = v112;
    if (v112(a3, a4)) {
      goto LABEL_55;
    }
  }
  else
  {
    uint64_t v81 = v33;
    v108(v80, a3);
    uint64_t v82 = v105;
    uint64_t v83 = v112;
  }
  v59(v82, v111, a3);
  v115[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v84 = v83(a3, a4);
  uint64_t v85 = v81(a3, a4);
  if (v84)
  {
    if (v85 > 64)
    {
      (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(v115, v109, v78, a3, a4);
LABEL_53:
      char v88 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v61, v82, a3);
      uint64_t v89 = v108;
      v108(v61, a3);
      if (v88) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      v89(v82, a3);
      goto LABEL_55;
    }
  }
  else if (v85 >= 64)
  {
    uint64_t v114 = 0x7FFFFFFFFFFFFFFFLL;
    (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 96))(&v114, v109, v78, a3, a4);
    goto LABEL_53;
  }
  v59(v61, v82, a3);
  (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v87 = v108;
  v108(v61, a3);
  v87(v82, a3);
LABEL_55:
  uint64_t v90 = v111;
  unint64_t v91 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t result = ((uint64_t (*)(char *, uint64_t))v108)(v90, a3);
  uint64_t v92 = *v113;
  if ((v91 & 0x8000000000000000) != 0)
  {
    if (v91 <= 0xFFFFFFFFFFFFFFC0) {
      uint64_t v46 = v92 >> 63;
    }
    else {
      uint64_t v46 = v92 >> -(char)v91;
    }
  }
  else
  {
    uint64_t v46 = v92 << v91;
    if (v91 >= 0x40) {
      uint64_t v46 = 0;
    }
  }
LABEL_58:
  *BOOL v113 = v46;
  return result;
}

uint64_t protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance Int(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t result = specialized BinaryInteger.quotientAndRemainder(dividingBy:)(a2, *a3, *v3, 0x3829uLL, 0x3830uLL);
  *a1 = result;
  return result;
}

uint64_t protocol witness for BinaryInteger.isMultiple(of:) in conformance Int(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1 == -1) {
    return 1;
  }
  uint64_t v3 = *v1;
  if (v2) {
    return v3 % v2 == 0;
  }
  else {
    return v3 == 0;
  }
}

void protocol witness for BinaryInteger.signum() in conformance Int(unint64_t *a1@<X8>)
{
  *a1 = (*v1 > 0) | (unint64_t)(*v1 >> 63);
}

void *protocol witness for static SignedNumeric.- prefix(_:) in conformance Int@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (__OFSUB__(0, *result)) {
    __break(1u);
  }
  else {
    *a2 = -*result;
  }
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance Int()
{
  if (__OFSUB__(0, *v0)) {
    __break(1u);
  }
  else {
    void *v0 = -*v0;
  }
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance Int64(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type Int and conformance Int, a5);
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance Int64@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, uint64_t a6@<X8>)
{
  uint64_t v90 = a5;
  uint64_t v91 = a4;
  uint64_t v87 = *(int ***)(*(void *)(a3 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v87, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v85 = (char *)&v83 - v11;
  uint64_t v12 = *(void *)(a2 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  char v88 = (char *)&v83 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v89 = (char *)&v83 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v83 - v18;
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v94 = (char *)&v83 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v93 = (char *)&v83 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v26 = (char *)&v83 - v25;
  MEMORY[0x1F4188790](v24);
  uint64_t v28 = (char *)&v83 - v27;
  uint64_t v96 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v29 = v96(a2, a3);
  uint64_t v98 = v12;
  char v99 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
  uint64_t v100 = a1;
  v99(v28, a1, a2);
  uint64_t v97 = v19;
  BOOL v30 = (v29 & 1) != 0 && (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 128))(a2, a3) > 64;
  uint64_t v31 = *(void (**)(char *, uint64_t))(v98 + 8);
  v31(v28, a2);
  v99(v26, v100, a2);
  uint64_t v95 = a6;
  char v101 = v31;
  uint64_t v92 = a3 + 64;
  if (!v30)
  {
    v31(v26, a2);
    char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    goto LABEL_9;
  }
  v103[0] = 0x8000000000000000;
  char v32 = v96;
  if ((v96(a2, a3) & 1) == 0)
  {
    char v52 = v32(a2, a3);
    char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v53 = v33(a2, a3);
    if (v52)
    {
      if (v53 <= 64)
      {
        char v84 = v33;
        uint64_t v70 = AssociatedTypeWitness;
        uint64_t v71 = v87;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v87, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v73 = v85;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v70, AssociatedConformanceWitness);
        uint64_t v74 = v71;
        uint64_t v75 = v71[3];
        BOOL v76 = v93;
        ((void (*)(char *, uint64_t, int **))v75)(v73, a2, v74);
        LOBYTE(v73) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v26, v76, a2);
        uint64_t v77 = v76;
        uint64_t v78 = v101;
        v101(v77, a2);
        uint64_t v79 = v88;
        (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v88, v26, a2);
        if (v73)
        {
          v78(v79, a2);
          uint64_t v62 = 0;
          char v63 = 1;
          uint64_t v61 = v95;
          uint64_t v34 = v100;
          uint64_t v45 = v78;
          goto LABEL_36;
        }
        uint64_t v80 = v103[0];
        uint64_t v81 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
        v78(v79, a2);
        BOOL v82 = v81 < v80;
        uint64_t v34 = v100;
        char v33 = v84;
        if (v82) {
          goto LABEL_30;
        }
LABEL_10:
        uint64_t v35 = v33(a2, a3);
        char v36 = v94;
        uint64_t v37 = v33;
        char v38 = v99;
        v99(v94, v34, a2);
        if (v35 >= 65)
        {
          v101(v36, a2);
          v38(v97, v34, a2);
LABEL_14:
          v103[0] = 0x7FFFFFFFFFFFFFFFLL;
          char v43 = v96(a2, a3);
          uint64_t v44 = v37(a2, a3);
          if (v43)
          {
            uint64_t v45 = v101;
            uint64_t v46 = v93;
            if (v44 > 64)
            {
              char v47 = *(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
              uint64_t v48 = v90();
              v47(v103, v91, v48, a2, a3);
              char v49 = v97;
              char v50 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v46, v97, a2);
              v45(v46, a2);
              uint64_t v51 = v49;
              goto LABEL_32;
            }
          }
          else
          {
            uint64_t v45 = v101;
            uint64_t v46 = v93;
            if (v44 > 63)
            {
              uint64_t v102 = 0x7FFFFFFFFFFFFFFFLL;
              uint64_t v66 = (*(uint64_t (**)(char *, char *, uint64_t))(v98 + 32))(v93, v97, a2);
              char v67 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a3 + 96);
              uint64_t v68 = ((uint64_t (*)(uint64_t))v90)(v66);
              uint64_t v69 = v89;
              v67(&v102, v91, v68, a2, a3);
              char v50 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v69, v46, a2);
              v45(v69, a2);
              uint64_t v51 = v46;
LABEL_32:
              v45(v51, a2);
              uint64_t v61 = v95;
              if (v50)
              {
                uint64_t v62 = 0;
                char v63 = 1;
                goto LABEL_36;
              }
LABEL_26:
              uint64_t v62 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
              char v63 = 0;
LABEL_36:
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v45)(v34, a2);
              goto LABEL_37;
            }
          }
          (*(void (**)(char *, char *, uint64_t))(v98 + 32))(v46, v97, a2);
          (*(void (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
          v45(v46, a2);
LABEL_25:
          uint64_t v61 = v95;
          goto LABEL_26;
        }
        uint64_t v39 = v37(a2, a3);
        v101(v36, a2);
        if (v39 == 64)
        {
          char v40 = v96(a2, a3);
          uint64_t v41 = v38;
          BOOL v42 = v97;
          v41(v97, v34, a2);
          if ((v40 & 1) == 0) {
            goto LABEL_14;
          }
        }
        else
        {
          uint64_t v60 = v38;
          BOOL v42 = v97;
          v60(v97, v34, a2);
        }
        uint64_t v45 = v101;
        v101(v42, a2);
        goto LABEL_25;
      }
LABEL_19:
      char v88 = *(char **)(a3 + 96);
      uint64_t v54 = v90();
      uint64_t v55 = v33;
      char v56 = v93;
      ((void (*)(void *, uint64_t, uint64_t, uint64_t, uint64_t))v88)(v103, v91, v54, a2, a3);
      char v57 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v26, v56, a2);
      uint64_t v58 = v56;
      char v33 = v55;
      uint64_t v59 = v101;
      v101(v58, a2);
      v59(v26, a2);
      uint64_t v34 = v100;
      if (v57) {
        goto LABEL_30;
      }
      goto LABEL_10;
    }
    if (v53 < 64) {
      goto LABEL_29;
    }
    v101(v26, a2);
LABEL_9:
    uint64_t v34 = v100;
    goto LABEL_10;
  }
  char v33 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  if (v33(a2, a3) >= 64) {
    goto LABEL_19;
  }
LABEL_29:
  uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  v101(v26, a2);
  uint64_t v34 = v100;
  if (v64 >= v103[0]) {
    goto LABEL_10;
  }
LABEL_30:
  uint64_t v62 = 0;
  char v63 = 1;
  uint64_t v61 = v95;
  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))v101)(v34, a2);
LABEL_37:
  *(void *)uint64_t v61 = v62;
  *(unsigned char *)(v61 + 8) = v63;
  return result;
}

void protocol witness for Numeric.magnitude.getter in conformance Int(uint64_t *a1@<X8>)
{
  uint64_t v2 = *v1;
  if (*v1 < 0) {
    uint64_t v2 = -v2;
  }
  *a1 = v2;
}

uint64_t *protocol witness for static Numeric.* infix(_:_:) in conformance Int64@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3 = *result * *a2;
  if ((unsigned __int128)(*result * (__int128)*a2) >> 64 == v3 >> 63) {
    *a3 = v3;
  }
  else {
    __break(1u);
  }
  return result;
}

uint64_t *protocol witness for static Numeric.*= infix(_:_:) in conformance Int64(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *result * *a2;
  if ((unsigned __int128)(*result * (__int128)*a2) >> 64 == v2 >> 63) {
    *uint64_t result = v2;
  }
  else {
    __break(1u);
  }
  return result;
}

void *protocol witness for Strideable.distance(to:) in conformance Int@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (__OFSUB__(*result, *v2)) {
    __break(1u);
  }
  else {
    *a2 = *result - *v2;
  }
  return result;
}

unint64_t protocol witness for static Strideable._step(after:from:by:) in conformance Int64(int64_t *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, void *a6)
{
  int64_t v6 = *a4 + *a6;
  unint64_t v7 = 0x8000000000000000;
  if (__OFADD__(*a4, *a6)) {
    int64_t v6 = (v6 >> 63) ^ 0x8000000000000000;
  }
  else {
    unint64_t v7 = 0;
  }
  *a1 = v6;
  return v7;
}

void *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance Int64@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (__OFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *a3 = *result + *a2;
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance Int64(void *result, void *a2)
{
  if (__OFADD__(*result, *a2)) {
    __break(1u);
  }
  else {
    *result += *a2;
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance Int64@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (__OFSUB__(*result, *a2)) {
    __break(1u);
  }
  else {
    *a3 = *result - *a2;
  }
  return result;
}

void *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance Int64(void *result, void *a2)
{
  if (__OFSUB__(*result, *a2)) {
    __break(1u);
  }
  else {
    *result -= *a2;
  }
  return result;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance Int(void *a1, void *a2)
{
  return *a1 < *a2;
}

void Int.hash(into:)(int a1, Swift::UInt a2)
{
}

Class *type metadata accessor for IndexingIterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for IndexingIterator.Flags);
}

Class *type metadata accessor for EnumeratedSequence.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for EnumeratedSequence.Iterator.Flags);
}

Class *type metadata accessor for Optional(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Optional.Flags, &flag for loading of canonical specialized generic type metadata for Optional);
}

uint64_t Int._toCustomAnyHashable()@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int>);
  a2[3] = result;
  a2[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a2 = a1;
  return result;
}

uint64_t protocol witness for _HasCustomAnyHashableRepresentation._toCustomAnyHashable() in conformance Int@<X0>(void *a1@<X8>)
{
  uint64_t v3 = *v1;
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int>);
  a1[3] = result;
  a1[4] = &protocol witness table for _IntegerAnyHashableBox<A>;
  *a1 = v3;
  return result;
}

Swift::Int __swiftcall _unsafePlus(_:_:)(Swift::Int a1, Swift::Int a2)
{
  return a2 + a1;
}

Swift::Int __swiftcall _unsafeMinus(_:_:)(Swift::Int a1, Swift::Int a2)
{
  return a1 - a2;
}

uint64_t _IntegerAnyHashableBox._canonicalBox.getter@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v45 = a2;
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(*(void *)(a1 + 24) + 8);
  uint64_t v5 = *(void *)(*(void *)(v4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, v3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v9 = (char *)&v41 - v8;
  uint64_t v10 = MEMORY[0x1F4188790](v7);
  uint64_t v12 = (char *)&v41 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  char v43 = (char *)&v41 - v14;
  MEMORY[0x1F4188790](v13);
  uint64_t v16 = (char *)&v41 - v15;
  uint64_t v42 = v17;
  uint64_t v18 = *(void (**)(char *, uint64_t, uint64_t))(v17 + 16);
  uint64_t v44 = v2;
  uint64_t v46 = v18;
  uint64_t v47 = v17 + 16;
  v18((char *)&v41 - v15, v2, v3);
  uint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 64);
  if (v19(v3, v4))
  {
    uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 128))(v3, v4);
    if (v20 < 64)
    {
LABEL_10:
      uint64_t v32 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(v3, v4);
      uint64_t v28 = *(void (**)(char *, uint64_t))(v42 + 8);
      v28(v16, v3);
      uint64_t v30 = v44;
      char v29 = v45;
      uint64_t v31 = v46;
      uint64_t v26 = v43;
      if (v32 < 0) {
        goto LABEL_17;
      }
      goto LABEL_15;
    }
    goto LABEL_6;
  }
  uint64_t v41 = v12;
  char v23 = v19(v3, v4);
  uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 128))(v3, v4);
  if (v23)
  {
    if (v20 <= 64)
    {
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
      uint64_t v26 = v43;
      (*(void (**)(char *, uint64_t, uint64_t))(v5 + 24))(v9, v3, v5);
      char v34 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v16, v26, v3);
      uint64_t v35 = v42;
      uint64_t v28 = *(void (**)(char *, uint64_t))(v42 + 8);
      v28(v26, v3);
      char v36 = v41;
      (*(void (**)(char *, char *, uint64_t))(v35 + 32))(v41, v16, v3);
      uint64_t v30 = v44;
      char v29 = v45;
      if (v34)
      {
        v28(v36, v3);
        v46(v26, v30, v3);
LABEL_18:
        uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(v3, v4);
        v28(v26, v3);
        uint64_t v39 = &demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>;
        goto LABEL_19;
      }
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(v3, v4);
      v28(v36, v3);
      uint64_t v31 = v46;
      if (v37 < 0)
      {
LABEL_17:
        v31(v26, v30, v3);
        goto LABEL_18;
      }
LABEL_15:
      v31(v26, v30, v3);
      goto LABEL_16;
    }
LABEL_6:
    uint64_t v48 = 0;
    uint64_t v24 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v4 + 96);
    unint64_t v25 = lazy protocol witness table accessor for type Int and conformance Int(v20, v21, v22);
    uint64_t v26 = v43;
    v24(&v48, &type metadata for Int, v25, v3, v4);
    char v27 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v4 + 32) + 8) + 16))(v16, v26, v3);
    uint64_t v28 = *(void (**)(char *, uint64_t))(v42 + 8);
    v28(v26, v3);
    v28(v16, v3);
    uint64_t v30 = v44;
    char v29 = v45;
    uint64_t v31 = v46;
    if (v27) {
      goto LABEL_17;
    }
    goto LABEL_15;
  }
  if (v20 < 64) {
    goto LABEL_10;
  }
  uint64_t v28 = *(void (**)(char *, uint64_t))(v42 + 8);
  v28(v16, v3);
  char v29 = v45;
  uint64_t v26 = v43;
  v46(v43, v44, v3);
LABEL_16:
  uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 120))(v3, v4);
  v28(v26, v3);
  uint64_t v39 = &demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>;
LABEL_19:
  uint64_t result = __swift_instantiateConcreteTypeFromMangledName(v39);
  v29[3] = result;
  v29[4] = (uint64_t)&protocol witness table for _IntegerAnyHashableBox<A>;
  *char v29 = v38;
  return result;
}

uint64_t _IntegerAnyHashableBox._isEqual(to:)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(ValueMetadata **)(a2 + 16);
  uint64_t v5 = *(void *)(*(void *)(a2 + 24) + 8);
  uint64_t v81 = *(int ***)(*(void *)(v5 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v81, (uint64_t)v4, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v7 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v80 = (char *)&v80 - v8;
  Description = (void (**)(char *, void, ValueMetadata *))v4[-1].Description;
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)&v80 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v80 - v13;
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v80 - v16;
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v20 = (char *)&v80 - v19;
  uint64_t v21 = MEMORY[0x1F4188790](v18);
  BOOL v82 = (char *)&v80 - v22;
  MEMORY[0x1F4188790](v21);
  uint64_t v24 = (char *)&v80 - v23;
  if (v4 == &type metadata for UInt64)
  {
    outlined init with copy of MirrorPath(a1, (uint64_t)v85);
    uint64_t v32 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
    char v33 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<UInt64>);
    if (!swift_dynamicCast((char *)&v84, v85, v32, v33, 6uLL)) {
      return 2;
    }
    uint64_t v35 = Description;
    unint64_t v34 = v84;
    Description[2](v24, v2, &type metadata for UInt64);
    char v36 = *(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 64);
    if (v36(&type metadata for UInt64, v5))
    {
      char v37 = v36(&type metadata for UInt64, v5);
      uint64_t v38 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 128))(&type metadata for UInt64, v5);
      if (v37)
      {
        if (v38 <= 64)
        {
          uint64_t v41 = v81;
          uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v81, (uint64_t)&type metadata for UInt64, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          char v43 = v80;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, AssociatedConformanceWitness);
          uint64_t v44 = v82;
          ((void (*)(char *, ValueMetadata *, int **))v41[3])(v43, &type metadata for UInt64, v41);
          char v45 = (*(uint64_t (**)(char *, char *, ValueMetadata *))(*(void *)(*(void *)(v5 + 32) + 8)
                                                                           + 32))(v24, v44, &type metadata for UInt64);
          uint64_t v46 = (void (*)(char *, ValueMetadata *))v35[1];
          v46(v44, &type metadata for UInt64);
          ((void (**)(char *, char *, ValueMetadata *))v35)[4](v20, v24, &type metadata for UInt64);
          if ((v45 & 1) == 0)
          {
            v46(v20, &type metadata for UInt64);
            return 0;
          }
          uint64_t v47 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 120))(&type metadata for UInt64, v5);
          v46(v20, &type metadata for UInt64);
LABEL_19:
          BOOL v55 = v47 == v34;
LABEL_23:
          char v57 = v55;
          return v57 & 1;
        }
LABEL_28:
        v85[0] = v34;
        uint64_t v58 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, ValueMetadata *, uint64_t))(v5 + 96);
        unint64_t v59 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v38, v39, v40);
        uint64_t v60 = v82;
        v58(v85, &type metadata for UInt64, v59, &type metadata for UInt64, v5);
        char v61 = (*(uint64_t (**)(char *, char *, ValueMetadata *))(*(void *)(*(void *)(v5 + 16) + 8) + 8))(v24, v60, &type metadata for UInt64);
        uint64_t v62 = (void (*)(char *, ValueMetadata *))v35[1];
        v62(v60, &type metadata for UInt64);
        v62(v24, &type metadata for UInt64);
        return v61 & 1;
      }
      if (v38 >= 64) {
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v38 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 128))(&type metadata for UInt64, v5);
      if (v38 >= 64) {
        goto LABEL_28;
      }
    }
    uint64_t v47 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 120))(&type metadata for UInt64, v5);
    ((void (*)(char *, ValueMetadata *))v35[1])(v24, &type metadata for UInt64);
    goto LABEL_19;
  }
  if (v4 != &type metadata for Int64) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "self isn't canonical", 20, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3CF6uLL, 0);
  }
  outlined init with copy of MirrorPath(a1, (uint64_t)v85);
  unint64_t v25 = (Class *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _AnyHashableBox);
  uint64_t v26 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _IntegerAnyHashableBox<Int64>);
  if (!swift_dynamicCast((char *)&v84, v85, v25, v26, 6uLL)) {
    return 2;
  }
  unint64_t v27 = v84;
  Description[2](v17, v2, &type metadata for Int64);
  uint64_t v28 = *(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 64);
  if (v28(&type metadata for Int64, v5))
  {
    uint64_t v29 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 128))(&type metadata for Int64, v5);
    if (v29 < 64) {
      goto LABEL_22;
    }
LABEL_16:
    v85[0] = v27;
    char v50 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, ValueMetadata *, uint64_t))(v5 + 96);
    unint64_t v51 = lazy protocol witness table accessor for type Int64 and conformance Int64(v29, v30, v31);
    char v52 = v82;
    v50(v85, &type metadata for Int64, v51, &type metadata for Int64, v5);
    char v53 = (*(uint64_t (**)(char *, char *, ValueMetadata *))(*(void *)(*(void *)(v5 + 16) + 8) + 8))(v17, v52, &type metadata for Int64);
    uint64_t v54 = (void (*)(char *, ValueMetadata *))Description[1];
    v54(v52, &type metadata for Int64);
    v54(v17, &type metadata for Int64);
    return v53 & 1;
  }
  char v49 = v28(&type metadata for Int64, v5);
  uint64_t v29 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 128))(&type metadata for Int64, v5);
  if ((v49 & 1) == 0)
  {
    if (v29 < 64)
    {
LABEL_22:
      uint64_t v56 = (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 120))(&type metadata for Int64, v5);
      ((void (*)(char *, ValueMetadata *))Description[1])(v17, &type metadata for Int64);
      BOOL v55 = v56 == v27;
      goto LABEL_23;
    }
    uint64_t v71 = Description;
    uint64_t v72 = ((uint64_t (*)(char *, char *, ValueMetadata *))Description[4])(v11, v17, &type metadata for Int64);
    if ((v27 & 0x8000000000000000) == 0)
    {
      v85[0] = v27;
      uint64_t v75 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, ValueMetadata *, uint64_t))(v5 + 96);
      unint64_t v76 = lazy protocol witness table accessor for type Int64 and conformance Int64(v72, v73, v74);
      uint64_t v77 = v82;
      v75(v85, &type metadata for Int64, v76, &type metadata for Int64, v5);
      char v78 = (*(uint64_t (**)(char *, char *, ValueMetadata *))(*(void *)(*(void *)(v5 + 16) + 8) + 8))(v11, v77, &type metadata for Int64);
      uint64_t v79 = (void (*)(char *, ValueMetadata *))v71[1];
      v79(v77, &type metadata for Int64);
      v79(v11, &type metadata for Int64);
      return v78 & 1;
    }
    ((void (*)(char *, ValueMetadata *))v71[1])(v11, &type metadata for Int64);
    return 0;
  }
  if (v29 > 64) {
    goto LABEL_16;
  }
  char v63 = v81;
  uint64_t v64 = swift_getAssociatedConformanceWitness((uint64_t)v81, (uint64_t)&type metadata for Int64, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v65 = v80;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v64 + 8))(&qword_18162B0B8, 256, AssociatedTypeWitness, v64);
  uint64_t v66 = v82;
  ((void (*)(char *, ValueMetadata *, int **))v63[3])(v65, &type metadata for Int64, v63);
  char v67 = (*(uint64_t (**)(char *, char *, ValueMetadata *))(*(void *)(*(void *)(v5 + 32) + 8) + 32))(v17, v66, &type metadata for Int64);
  uint64_t v68 = Description;
  uint64_t v69 = (void (*)(char *, ValueMetadata *))Description[1];
  v69(v66, &type metadata for Int64);
  ((void (**)(char *, char *, ValueMetadata *))v68)[4](v14, v17, &type metadata for Int64);
  BOOL v70 = (v67 & 1) != 0
     && (*(uint64_t (**)(ValueMetadata *, uint64_t))(v5 + 120))(&type metadata for Int64, v5) == v27;
  v69(v14, &type metadata for Int64);
  return v70;
}

uint64_t _IntegerAnyHashableBox._hashValue.getter(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(*(void *)(a1 + 24) + 8) + 16) + 16))(*(void *)(a1 + 16));
}

uint64_t _IntegerAnyHashableBox._hash(into:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(*(void *)(*(void *)(a2 + 24) + 8) + 16) + 24))(a1, *(void *)(a2 + 16));
}

Swift::Int __swiftcall _IntegerAnyHashableBox._rawHashValue(_seed:)(Swift::Int _seed)
{
  return (*(uint64_t (**)(Swift::Int, void))(*(void *)(*(void *)(*(void *)(v1 + 24) + 8) + 16)
                                                       + 32))(_seed, *(void *)(v1 + 16));
}

uint64_t _IntegerAnyHashableBox._unbox<A>()@<X0>(uint64_t a1@<X0>, const char *a2@<X1>, char *a3@<X8>)
{
  int64_t v6 = *(Class **)(a1 + 16);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (unint64_t *)((char *)&v12 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0));
  (*(void (**)(unint64_t *, uint64_t, Class *))(v9 + 16))(v8, v3, v6);
  int v10 = swift_dynamicCast(a3, v8, v6, a2, 6uLL);
  return (*(uint64_t (**)(char *, void, uint64_t, const char *))(*((void *)a2 - 1) + 56))(a3, v10 ^ 1u, 1, a2);
}

uint64_t _ConcreteHashableBox._downCastConditional<A>(into:)(char *a1, uint64_t a2, const char *a3, uint64_t a4)
{
  uint64_t v5 = v4;
  uint64_t v9 = type metadata accessor for Optional(0, (uint64_t)a3, (uint64_t)a3, a4);
  uint64_t v10 = (uint64_t)*(v9 - 1);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v26 - v12;
  uint64_t v14 = *(Class **)(a2 + 16);
  uint64_t v15 = MEMORY[0x1F4188790](v11);
  uint64_t v17 = (unint64_t *)((char *)&v26 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v18 = *((void *)a3 - 1);
  MEMORY[0x1F4188790](v15);
  uint64_t v20 = (char *)&v26 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(unint64_t *, uint64_t, Class *))(v21 + 16))(v17, v5, v14);
  uint64_t v22 = swift_dynamicCast(v13, v17, v14, a3, 6uLL);
  uint64_t v23 = *(void (**)(char *, uint64_t, uint64_t, const char *))(v18 + 56);
  if (v22)
  {
    v23(v13, 0, 1, a3);
    uint64_t v24 = *(void (**)(char *, char *, const char *))(v18 + 32);
    v24(v20, v13, a3);
    v24(a1, v20, a3);
  }
  else
  {
    v23(v13, 1, 1, a3);
    (*(void (**)(char *, Class *))(v10 + 8))(v13, v9);
  }
  return v22;
}

uint64_t protocol witness for _AnyHashableBox._unbox<A>() in conformance _IntegerAnyHashableBox<A>@<X0>(const char *a1@<X0>, uint64_t a2@<X2>, char *a3@<X8>)
{
  return _IntegerAnyHashableBox._unbox<A>()(a2, a1, a3);
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _UInt128(uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomStringConvertible.description.getter in conformance _UInt128(a1, a2, (uint64_t (*)(uint64_t, void, void, void))specialized BinaryInteger._description(radix:uppercase:));
}

uint64_t < infix<A, B>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v26 = a8;
  uint64_t v27 = a2;
  uint64_t v29 = a7;
  uint64_t v30 = a4;
  uint64_t v28 = a3;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a5, a6, 0, 0);
  uint64_t v31 = *(TupleTypeMetadata2 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v14 = (char *)&v26 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v26 - v15;
  uint64_t v17 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16);
  v17((char *)&v26 - v15, a1, a5);
  uint64_t v18 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v19 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a6 - 8) + 16);
  v19(v18, v27, a6);
  v17(v14, v28, a5);
  uint64_t v20 = v29;
  uint64_t v21 = &v14[*((int *)TupleTypeMetadata2 + 12)];
  v19(v21, v30, a6);
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v20 + 8) + 8))(v16, v14, a5)) {
    char v22 = (*(uint64_t (**)(char *, char *, uint64_t))(v26 + 16))(v18, v21, a6);
  }
  else {
    char v22 = (*(uint64_t (**)(char *, char *, uint64_t))(v20 + 16))(v16, v14, a5);
  }
  char v23 = v22;
  uint64_t v24 = *(void (**)(char *, uint64_t *))(v31 + 8);
  v24(v14, TupleTypeMetadata2);
  v24(v16, TupleTypeMetadata2);
  return v23 & 1;
}

BOOL protocol witness for static Comparable.< infix(_:_:) in conformance _UInt128(void *a1, void *a2)
{
  unint64_t v2 = a1[1];
  unint64_t v3 = a2[1];
  BOOL v4 = v2 == v3;
  BOOL v5 = v2 < v3;
  if (v4) {
    return *a1 < *a2;
  }
  else {
    return v5;
  }
}

BOOL protocol witness for static Comparable.<= infix(_:_:) in conformance _UInt128(void *a1, void *a2)
{
  unint64_t v2 = a1[1];
  unint64_t v3 = a2[1];
  BOOL v4 = v3 == v2;
  BOOL v5 = v3 >= v2;
  if (v4) {
    return *a2 >= *a1;
  }
  else {
    return v5;
  }
}

BOOL protocol witness for static Comparable.>= infix(_:_:) in conformance _UInt128(void *a1, void *a2)
{
  unint64_t v2 = a1[1];
  unint64_t v3 = a2[1];
  BOOL v4 = v2 == v3;
  BOOL v5 = v2 >= v3;
  if (v4) {
    return *a1 >= *a2;
  }
  else {
    return v5;
  }
}

BOOL protocol witness for static Comparable.> infix(_:_:) in conformance _UInt128(void *a1, void *a2)
{
  unint64_t v2 = a1[1];
  unint64_t v3 = a2[1];
  BOOL v4 = v3 == v2;
  BOOL v5 = v3 < v2;
  if (v4) {
    return *a2 < *a1;
  }
  else {
    return v5;
  }
}

void *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance _UInt128@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  BOOL v5 = __CFADD__(*result, *a2);
  BOOL v6 = __CFADD__(v3, v4);
  uint64_t v7 = v3 + v4;
  if (v6 || (v5 ? (BOOL v8 = v7 == -1) : (BOOL v8 = 0), v8)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x6BuLL, 0);
  }
  *a3 = *result + *a2;
  a3[1] = v7 + v5;
  return result;
}

void *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance _UInt128(void *a1, uint64_t *a2)
{
  return specialized static _UInt128.+= infix(_:_:)(a1, *a2, a2[1]);
}

unint64_t *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance _UInt128@<X0>(unint64_t *result@<X0>, unint64_t *a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t v4 = *result;
  unint64_t v3 = result[1];
  unint64_t v6 = *a2;
  unint64_t v5 = a2[1];
  BOOL v7 = v3 >= v5;
  unint64_t v8 = v3 - v5;
  int v9 = !v7;
  BOOL v7 = v4 >= v6;
  unint64_t v10 = v4 - v6;
  if (v7)
  {
    if (v9) {
      goto LABEL_8;
    }
  }
  else
  {
    if (!v8) {
      LOBYTE(v9) = 1;
    }
    if (v9) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x5FuLL, 0);
    --v8;
  }
  *a3 = v10;
  a3[1] = v8;
  return result;
}

unint64_t *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance _UInt128(unint64_t *a1, unint64_t *a2)
{
  return specialized static _UInt128.-= infix(_:_:)(a1, *a2, a2[1]);
}

uint64_t _UInt128.init<A>(exactly:)(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v6, a2, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  v241 = *(int ***)(swift_getAssociatedConformanceWitness(v6, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric)+ 16);
  v240 = swift_getAssociatedTypeWitness(0, v241, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v240);
  v239 = (char *)&v226 - v8;
  int v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v255 = (void *)*(v9 - 1);
  uint64_t v10 = MEMORY[0x1F4188790](v9);
  v230 = (char *)&v226 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  v248 = (char *)&v226 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  v250 = (char *)&v226 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  v254 = (char *)&v226 - v17;
  MEMORY[0x1F4188790](v16);
  v259 = (char *)&v226 - v18;
  uint64_t v256 = v6;
  v247 = *(int ***)(v6 + 16);
  v246 = swift_getAssociatedTypeWitness(0, v247, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v19 = MEMORY[0x1F4188790](v246);
  v245 = (char *)&v226 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  char v23 = (char *)&v226 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v24 = MEMORY[0x1F4188790](v21);
  v236 = (char *)&v226 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  v229 = (char *)&v226 - v27;
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  v234 = (char *)&v226 - v29;
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  uint64_t v32 = (char *)&v226 - v31;
  uint64_t v33 = MEMORY[0x1F4188790](v30);
  v237 = (char *)&v226 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  v231 = (char *)&v226 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  v244 = (char *)&v226 - v38;
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  v249 = (char *)&v226 - v40;
  uint64_t v41 = MEMORY[0x1F4188790](v39);
  v235 = (char *)&v226 - v42;
  uint64_t v43 = MEMORY[0x1F4188790](v41);
  char v45 = (char *)&v226 - v44;
  uint64_t v46 = MEMORY[0x1F4188790](v43);
  v257 = (char *)&v226 - v47;
  MEMORY[0x1F4188790](v46);
  char v49 = (char *)&v226 - v48;
  uint64_t v261 = v50;
  unint64_t v51 = *(void (**)(char *, char *, uint64_t))(v50 + 16);
  v258 = a1;
  uint64_t v242 = v50 + 16;
  v253 = v51;
  v51((char *)&v226 - v48, a1, a2);
  char v52 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 64);
  char v53 = v52(a2, a3);
  v238 = v32;
  uint64_t v252 = a3 + 64;
  v243 = v52;
  if (v53)
  {
    uint64_t v54 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
    uint64_t v55 = v54(a2, a3);
    if (v55 < 64) {
      goto LABEL_11;
    }
    goto LABEL_6;
  }
  char v58 = v52(a2, a3);
  uint64_t v54 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 128);
  uint64_t v55 = v54(a2, a3);
  if ((v58 & 1) == 0)
  {
    if (v55 >= 64)
    {
      v226 = v23;
      char v63 = *(void (**)(char *, uint64_t))(v261 + 8);
      v63(v49, a2);
      goto LABEL_16;
    }
LABEL_11:
    uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
    char v63 = *(void (**)(char *, uint64_t))(v261 + 8);
    v63(v49, a2);
    if ((v65 & 0x8000000000000000) == 0) {
      goto LABEL_12;
    }
    goto LABEL_7;
  }
  if (v55 > 64)
  {
LABEL_6:
    unint64_t v262 = 0;
    unint64_t v59 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a3 + 96);
    unint64_t v60 = lazy protocol witness table accessor for type Int and conformance Int(v55, v56, v57);
    char v61 = v257;
    v59(&v262, &type metadata for Int, v60, a2, a3);
    char v62 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v49, v61, a2);
    char v63 = *(void (**)(char *, uint64_t))(v261 + 8);
    v63(v61, a2);
    v63(v49, a2);
    if ((v62 & 1) == 0)
    {
LABEL_12:
      v226 = v23;
      goto LABEL_16;
    }
    goto LABEL_7;
  }
  v226 = v23;
  uint64_t v66 = v246;
  char v67 = v247;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v247, a2, (uint64_t)v246, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v69 = v245;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v66, AssociatedConformanceWitness);
  BOOL v70 = v257;
  ((void (*)(char *, uint64_t, int **))v67[3])(v69, a2, v67);
  LODWORD(v260) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a3 + 32) + 8) + 16))(v49, v70, a2);
  uint64_t v71 = v261;
  uint64_t v72 = v70;
  uint64_t v73 = *(void (**)(char *, uint64_t))(v261 + 8);
  v73(v72, a2);
  (*(void (**)(char *, char *, uint64_t))(v71 + 32))(v45, v49, a2);
  if (v260)
  {
    v73(v45, a2);
    v73(v258, a2);
    return 0;
  }
  uint64_t v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 120))(a2, a3);
  v73(v45, a2);
  char v63 = v73;
  if (v74 < 0)
  {
LABEL_7:
    v63(v258, a2);
    return 0;
  }
LABEL_16:
  v232 = v54;
  v251 = v63;
  uint64_t v75 = v256;
  unint64_t v76 = v259;
  (*(void (**)(uint64_t, uint64_t))(v256 + 56))(a2, v256);
  uint64_t v260 = a3;
  uint64_t v77 = swift_getAssociatedConformanceWitness(a3, a2, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  char v78 = *(uint64_t (**)(uint64_t *, uint64_t))(v77 + 64);
  uint64_t v233 = v77;
  v227 = v78;
  char v79 = ((uint64_t (*)(uint64_t *))v78)(v9);
  uint64_t v81 = v254;
  uint64_t v80 = v255;
  v228 = (void (*)(char *, char *, uint64_t *))v255[2];
  v228(v254, v76, v9);
  if (v79)
  {
    BOOL v82 = v241;
    uint64_t v83 = v240;
    uint64_t v84 = swift_getAssociatedConformanceWitness((uint64_t)v241, (uint64_t)v9, (uint64_t)v240, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v85 = (uint64_t)v9;
    uint64_t v86 = v239;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v84 + 8))(&qword_18162B0B8, 256, v83, v84);
    uint64_t v87 = v250;
    char v88 = v86;
    int v9 = (uint64_t *)v85;
    ((void (*)(char *, uint64_t, int **))v82[3])(v88, v85, v82);
    uint64_t v89 = swift_getAssociatedConformanceWitness(v75, a2, v85, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    uint64_t v90 = v254;
    LOBYTE(v83) = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v89 + 16))(v254, v87, v9, v89);
    uint64_t v91 = (void (*)(char *, uint64_t *))v80[1];
    v91(v87, v9);
    v91(v90, v9);
    if (v83)
    {
      uint64_t v92 = ((uint64_t (*)(char *, uint64_t *))v91)(v259, v9);
      uint64_t v95 = v261;
      goto LABEL_35;
    }
    v254 = (char *)v91;
  }
  else
  {
    v254 = (char *)v80[1];
    ((void (*)(char *, uint64_t *))v254)(v81, v9);
  }
  uint64_t v96 = v233;
  uint64_t v97 = *(uint64_t (**)(uint64_t *, uint64_t))(v233 + 128);
  uint64_t v98 = v259;
  uint64_t v99 = v97(v9, v233);
  uint64_t v100 = v248;
  v228(v248, v98, v9);
  if (v99 <= 63)
  {
    char v101 = v254;
    ((void (*)(char *, uint64_t *))v254)(v100, v9);
    uint64_t v102 = v260;
    goto LABEL_50;
  }
  unint64_t v262 = -1;
  char v103 = v227(v9, v96);
  uint64_t v104 = v97(v9, v96);
  uint64_t v95 = v261;
  if ((v103 & 1) == 0)
  {
    if (v104 < 65)
    {
      uint64_t v132 = v250;
      ((void (*)(char *, char *, uint64_t *))v255[4])(v250, v100, v9);
      unint64_t v133 = (*(uint64_t (**)(uint64_t *, uint64_t))(v96 + 120))(v9, v96);
      v134 = v132;
      char v101 = v254;
      ((void (*)(char *, uint64_t *))v254)(v134, v9);
      uint64_t v102 = v260;
      if (v262 >= v133) {
        goto LABEL_50;
      }
      goto LABEL_34;
    }
    uint64_t v114 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v96 + 96);
    unint64_t v115 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v104, v105, v106);
    uint64_t v116 = v250;
    v114(&v262, &type metadata for UInt64, v115, v9, v96);
    uint64_t v117 = swift_getAssociatedConformanceWitness(v256, a2, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v112 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v117 + 16))(v116, v100, v9, v117);
    BOOL v113 = v116;
    goto LABEL_28;
  }
  uint64_t v107 = v256;
  if (v104 >= 65)
  {
    uint64_t v108 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v96 + 96);
    unint64_t v109 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v104, v105, v106);
    uint64_t v110 = v250;
    v108(&v262, &type metadata for UInt64, v109, v9, v233);
    uint64_t v111 = swift_getAssociatedConformanceWitness(v107, a2, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v112 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v111 + 16))(v110, v100, v9, v111);
    BOOL v113 = v110;
    uint64_t v96 = v233;
LABEL_28:
    char v101 = v254;
    ((void (*)(char *, uint64_t *))v254)(v113, v9);
    ((void (*)(char *, uint64_t *))v101)(v100, v9);
    uint64_t v102 = v260;
    if ((v112 & 1) == 0) {
      goto LABEL_50;
    }
LABEL_34:
    uint64_t v92 = ((uint64_t (*)(char *, uint64_t *))v101)(v259, v9);
LABEL_35:
    uint64_t v135 = v243;
    unint64_t v262 = -1;
    v136 = *(void (**)(unint64_t *, ValueMetadata *))(v260 + 88);
    unint64_t v137 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v92, v93, v94);
    uint64_t v138 = v257;
    v250 = (char *)v137;
    v136(&v262, &type metadata for UInt64);
    v139 = v235;
    v140 = v258;
    (*(void (**)(char *, char *, uint64_t, uint64_t))(v260 + 192))(v258, v138, a2, v260);
    v141 = v138;
    uint64_t v142 = v251;
    uint64_t v143 = ((uint64_t (*)(char *, uint64_t))v251)(v141, a2);
    unint64_t v262 = 64;
    v144 = *(void (**)(void (*)(void, void, void), unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v260 + 240);
    unint64_t v147 = lazy protocol witness table accessor for type Int and conformance Int(v143, v145, v146);
    v144((void (*)(void, void, void))v140, &v262, &type metadata for Int, v147, a2, v260);
    v148 = v142;
    uint64_t v149 = v260;
    v259 = (char *)(v95 + 8);
    v142(v140, a2);
    uint64_t v151 = *(char **)(v95 + 32);
    uint64_t v150 = v95 + 32;
    uint64_t v152 = v244;
    v258 = v151;
    ((void (*)(char *, char *, uint64_t))v151)(v244, v139, a2);
    char v153 = v135(a2, v149);
    v154 = v238;
    if (v153)
    {
      v155 = v231;
      v253(v231, v152, a2);
      v156 = v246;
      v157 = v247;
      uint64_t v158 = swift_getAssociatedConformanceWitness((uint64_t)v247, a2, (uint64_t)v246, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      v159 = v245;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v158 + 8))(&qword_18162B0B8, 256, v156, v158);
      v160 = v257;
      ((void (*)(char *, uint64_t, int **))v157[3])(v159, a2, v157);
      LOBYTE(v156) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v149 + 32) + 8)
                                                                        + 32))(v155, v160, a2);
      v161 = v160;
      v148 = v251;
      v251(v161, a2);
      if ((v156 & 1) == 0) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
      }
      v148(v155, a2);
      uint64_t v135 = v243;
      uint64_t v152 = v244;
    }
    uint64_t v261 = v150;
    uint64_t v162 = v232(a2, v149);
    uint64_t v256 = v149 + 128;
    if (v162 < 64)
    {
LABEL_55:
      v188 = *(void **)(v149 + 120);
      uint64_t v260 = v149 + 120;
      v255 = v188;
      uint64_t v189 = ((uint64_t (*)(uint64_t, uint64_t))v188)(a2, v149);
      v148(v152, a2);
      ((void (*)(char *, char *, uint64_t))v258)(v154, v249, a2);
      char v190 = v135(a2, v149);
      v191 = v234;
      v253(v234, v154, a2);
      if (v190)
      {
        v192 = v246;
        v193 = v247;
        uint64_t v194 = swift_getAssociatedConformanceWitness((uint64_t)v247, a2, (uint64_t)v246, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v195 = v135;
        v196 = v191;
        v197 = v245;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v194 + 8))(&qword_18162B0B8, 256, v192, v194);
        v198 = v193[3];
        v199 = v257;
        v200 = v193;
        v148 = v251;
        ((void (*)(char *, uint64_t, int **))v198)(v197, a2, v200);
        LOBYTE(v192) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v149 + 32) + 8)
                                                                          + 16))(v196, v199, a2);
        v148(v199, a2);
        v201 = v196;
        uint64_t v135 = v195;
        v148(v201, a2);
        if (v192)
        {
LABEL_57:
          v148(v154, a2);
          return 0;
        }
      }
      else
      {
        v148(v191, a2);
      }
      v254 = (char *)v189;
      v202 = v232;
      uint64_t v203 = v232(a2, v149);
      v204 = v236;
      v253(v236, v154, a2);
      if (v203 <= 63)
      {
        v148(v204, a2);
        uint64_t v64 = (uint64_t)v254;
        goto LABEL_61;
      }
      unint64_t v262 = -1;
      char v206 = v135(a2, v149);
      uint64_t v207 = v202(a2, v149);
      if (v206)
      {
        uint64_t v64 = (uint64_t)v254;
        if (v207 < 65)
        {
          v208 = v246;
          v209 = v247;
          uint64_t v210 = swift_getAssociatedConformanceWitness((uint64_t)v247, a2, (uint64_t)v246, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          v211 = v245;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v210 + 8))(&qword_18162B0B8, 256, v208, v210);
          v212 = v209[3];
          v213 = v257;
          v214 = v209;
          v148 = v251;
          ((void (*)(char *, uint64_t, int **))v212)(v211, a2, v214);
          v215 = v236;
          LOBYTE(v208) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v149 + 32) + 8)
                                                                            + 40))(v236, v213, a2);
          v148(v213, a2);
          uint64_t v216 = v149;
          v217 = v226;
          unint64_t v218 = v262;
          ((void (*)(char *, char *, uint64_t))v258)(v226, v215, a2);
          if ((v208 & 1) == 0)
          {
            v148(v217, a2);
            uint64_t v149 = v216;
            v154 = v238;
            goto LABEL_61;
          }
          unint64_t v219 = ((uint64_t (*)(uint64_t, uint64_t))v255)(a2, v216);
          v148(v217, a2);
          BOOL v220 = v218 >= v219;
          uint64_t v149 = v216;
          goto LABEL_71;
        }
      }
      else
      {
        uint64_t v64 = (uint64_t)v254;
        if (v207 < 65)
        {
          v224 = v257;
          ((void (*)(char *, char *, uint64_t))v258)(v257, v236, a2);
          unint64_t v225 = ((uint64_t (*)(uint64_t, uint64_t))v255)(a2, v149);
          v148(v224, a2);
          BOOL v220 = v262 >= v225;
LABEL_71:
          v154 = v238;
          if (!v220) {
            goto LABEL_57;
          }
          goto LABEL_61;
        }
      }
      v221 = v257;
      (*(void (**)(unint64_t *, ValueMetadata *, char *, uint64_t, uint64_t))(v149 + 96))(&v262, &type metadata for UInt64, v250, a2, v149);
      v222 = v236;
      char v223 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v149 + 32) + 8) + 16))(v221, v236, a2);
      v148(v221, a2);
      v148(v222, a2);
      v154 = v238;
      if (v223) {
        goto LABEL_57;
      }
LABEL_61:
      ((void (*)(uint64_t, uint64_t))v255)(a2, v149);
      v148(v154, a2);
      return v64;
    }
    v253(v237, v152, a2);
    unint64_t v262 = -1;
    char v163 = v135(a2, v149);
    uint64_t v164 = v232(a2, v149);
    if (v163)
    {
      if (v164 < 65)
      {
        v165 = v246;
        v166 = v247;
        uint64_t v167 = swift_getAssociatedConformanceWitness((uint64_t)v247, a2, (uint64_t)v246, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        v168 = v245;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v167 + 8))(&qword_18162B0B8, 256, v165, v167);
        v169 = v257;
        ((void (*)(char *, uint64_t, int **))v166[3])(v168, a2, v166);
        v170 = v237;
        LODWORD(v255) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v149 + 32) + 8)
                                                                           + 40))(v237, v169, a2);
        v171 = v251;
        v251(v169, a2);
        uint64_t v172 = v149;
        unint64_t v173 = v262;
        v174 = v229;
        v253(v229, v170, a2);
        if (v255)
        {
          unint64_t v175 = (*(uint64_t (**)(uint64_t, uint64_t))(v172 + 120))(a2, v172);
          v171(v174, a2);
          BOOL v220 = v173 >= v175;
          uint64_t v149 = v172;
          v148 = v171;
          uint64_t v152 = v244;
          v176 = v237;
          if (!v220) {
            goto LABEL_48;
          }
        }
        else
        {
          v171(v174, a2);
          uint64_t v149 = v172;
          v148 = v171;
          uint64_t v152 = v244;
          v176 = v237;
        }
        goto LABEL_54;
      }
    }
    else if (v164 <= 64)
    {
      v180 = v257;
      v176 = v237;
      v253(v257, v237, a2);
      unint64_t v181 = (*(uint64_t (**)(uint64_t, uint64_t))(v149 + 120))(a2, v149);
      v182 = v180;
      v148 = v251;
      v251(v182, a2);
      if (v262 < v181) {
        goto LABEL_48;
      }
LABEL_54:
      v148(v176, a2);
      goto LABEL_55;
    }
    v177 = v257;
    (*(void (**)(unint64_t *, ValueMetadata *, char *, uint64_t, uint64_t))(v149 + 96))(&v262, &type metadata for UInt64, v250, a2, v149);
    v176 = v237;
    char v178 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v149 + 32) + 8) + 16))(v177, v237, a2);
    v179 = v177;
    v148 = v251;
    v251(v179, a2);
    if (v178) {
LABEL_48:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
    goto LABEL_54;
  }
  char v118 = v241;
  uint64_t v119 = v240;
  uint64_t v120 = swift_getAssociatedConformanceWitness((uint64_t)v241, (uint64_t)v9, (uint64_t)v240, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v121 = v239;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v120 + 8))(&qword_18162B0B8, 256, v119, v120);
  uint64_t v122 = v250;
  ((void (*)(char *, uint64_t *, int **))v118[3])(v121, v9, v118);
  uint64_t v123 = swift_getAssociatedConformanceWitness(v107, a2, (uint64_t)v9, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  LOBYTE(v119) = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v123 + 40))(v100, v122, v9, v123);
  unint64_t v124 = v255;
  uint64_t v125 = v122;
  uint64_t v126 = v100;
  uint64_t v127 = v254;
  ((void (*)(char *, uint64_t *))v254)(v125, v9);
  v250 = (char *)v262;
  char v128 = v230;
  ((void (*)(char *, char *, uint64_t *))v124[4])(v230, v126, v9);
  if ((v119 & 1) == 0)
  {
    ((void (*)(char *, uint64_t *))v127)(v128, v9);
    uint64_t v102 = v260;
    uint64_t v96 = v233;
    char v101 = v127;
    goto LABEL_50;
  }
  uint64_t v129 = v233;
  unint64_t v130 = (*(uint64_t (**)(uint64_t *, uint64_t))(v233 + 120))(v9, v233);
  unint64_t v131 = v128;
  uint64_t v96 = v129;
  ((void (*)(char *, uint64_t *))v127)(v131, v9);
  uint64_t v102 = v260;
  char v101 = v127;
  if ((unint64_t)v250 < v130) {
    goto LABEL_34;
  }
LABEL_50:
  v183 = v259;
  uint64_t v64 = (*(uint64_t (**)(uint64_t *, uint64_t))(v96 + 120))(v9, v96);
  ((void (*)(char *, uint64_t *))v101)(v183, v9);
  v184 = v257;
  (*(void (**)(uint64_t))(*(void *)(v256 + 8) + 16))(a2);
  v185 = v258;
  LOBYTE(v183) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v102 + 32) + 8) + 16))(v258, v184, a2);
  v186 = v185;
  v187 = v251;
  v251(v186, a2);
  v187(v184, a2);
  if (v183) {
    return -v64;
  }
  return v64;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance _UInt128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance _UInt128((uint64_t (*)(void))_UInt128.init<A>(exactly:), a1);
}

uint64_t protocol witness for static Numeric.* infix(_:_:) in conformance _UInt128@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static Numeric.* infix(_:_:) in conformance _UInt128(a1, a2, (uint64_t (*)(void, void, void, void))specialized static _UInt128.* infix(_:_:), a3);
}

unint64_t *protocol witness for static Numeric.*= infix(_:_:) in conformance _UInt128(unint64_t *a1, unint64_t *a2)
{
  return specialized static _UInt128.*= infix(_:_:)(a1, *a2, a2[1]);
}

void *protocol witness for ExpressibleByIntegerLiteral.init(integerLiteral:) in conformance _UInt128@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if ((*result & 0x8000000000000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000028, 0x80000001816DFAC0, "Swift/LegacyInt128.swift", 24, 2, 0x85uLL, 0);
  }
  *a2 = *result;
  a2[1] = 0;
  return result;
}

unint64_t specialized _wideMaskedShiftRight<A>(_:_:)(unint64_t *a1, unint64_t a2, unint64_t a3, char a4)
{
  if ((a4 & 0x7Fu) >= 0x40uLL)
  {
    *a1 = a2 >> a4;
    return 0;
  }
  else if ((a4 & 0x7F) != 0)
  {
    *a1 = (a3 >> a4) | (a2 << -a4);
    return a2 >> a4;
  }
  else
  {
    *a1 = a3;
    return a2;
  }
}

uint64_t specialized _wideMaskedShiftRight<A>(_:_:)(uint64_t *a1, uint64_t a2, unint64_t a3, char a4)
{
  if ((a4 & 0x7Fu) >= 0x40uLL)
  {
    *a1 = a2 >> a4;
    return a2 >> 63;
  }
  else if ((a4 & 0x7F) != 0)
  {
    *a1 = (a3 >> a4) | (a2 << -a4);
    return a2 >> a4;
  }
  else
  {
    *a1 = a3;
    return a2;
  }
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _UInt128.Words(uint64_t *a1, unint64_t *a2))()
{
  *a1 = _UInt128.Words.subscript.getter(*a2, *v2, v2[1], 0xC7uLL);
  return EnumeratedSequence._base.modify;
}

Swift::UInt64 specialized _wideDivide22<A>(_:by:)(Swift::UInt64 *a1, Swift::UInt64 *a2, Swift::tuple_high_UInt64_low_UInt64 a3, Swift::UInt64 a4, unint64_t a5, unint64_t a6)
{
  if (!(a5 | a6)) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000010, 0x80000001816DC400, "Swift/LegacyInt128.swift", 24, 2, 0x4CFuLL, 0);
  }
  high = (void *)a3.high;
  BOOL v9 = a6 < a4;
  if (a5 != a3.low) {
    BOOL v9 = a5 < a3.low;
  }
  if (v9)
  {
    if (a3.low)
    {
      if (a5)
      {
        unint64_t v10 = __clz(a5);
        if (v10)
        {
          a5 = (a6 >> -(char)v10) | (a5 << v10);
          a6 <<= v10;
          if (((0x80 - (_BYTE)v10) & 0x7F) != 0) {
            Swift::UInt64 v11 = (a4 >> (0x80 - v10)) | (a3.low << v10);
          }
          else {
            Swift::UInt64 v11 = a4;
          }
          Swift::UInt64 v12 = a4 >> (-(char)v10 & 0x3F);
          unint64_t v13 = a4 << v10;
          if (((0x80 - (_BYTE)v10) & 0x7Fu) <= 0x3FuLL) {
            a4 = v11;
          }
          else {
            a4 = a3.low >> (0x80 - v10);
          }
          a3.low = v12 | (a3.low << v10);
        }
        else
        {
          unint64_t v13 = a4;
        }
        a3.high = a4;
        Swift::UInt64 v20 = specialized _wideDivide32<A>(_:by:)(&v25, &v24, a3, v13, a5, a6);
        Swift::UInt64 v15 = 0;
        unint64_t v22 = v24;
        Swift::UInt64 v21 = v25;
        *a1 = v20;
        if (v10)
        {
          unint64_t v22 = (v22 >> v10) | (v21 << -(char)v10);
          v21 >>= v10;
        }
        void *high = v22;
        *a2 = v21;
        return v15;
      }
      if (a6)
      {
        Swift::UInt64 v15 = a3.low / a6;
        if (a3.low % a6)
        {
          v16.low = a4;
          v16.high = a3.low % a6;
          Swift::tuple_quotient_UInt64_remainder_UInt64 v19 = UInt64.dividingFullWidth(_:)(v16);
          Swift::UInt64 remainder = v19.remainder;
          Swift::UInt64 quotient = v19.quotient;
        }
        else
        {
          Swift::UInt64 quotient = a4 / a6;
          Swift::UInt64 remainder = a4 % a6;
        }
        *a1 = quotient;
        void *high = remainder;
        goto LABEL_30;
      }
    }
    else if (a6)
    {
      Swift::UInt64 v15 = 0;
      *(void *)a3.high = a4 % a6;
      *a1 = a4 / a6;
LABEL_30:
      *a2 = 0;
      return v15;
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x25E8uLL, 0);
  }
  BOOL v14 = a3.low < a5;
  Swift::UInt64 v15 = 0;
  if (a5 == a3.low) {
    BOOL v14 = a4 < a6;
  }
  if (v14)
  {
    *a1 = 0;
    *a2 = a3.low;
    *(void *)a3.high = a4;
  }
  else
  {
    *a1 = 1;
    *a2 = 0;
    *(void *)a3.high = 0;
  }
  return v15;
}

Swift::tuple_high__UInt128_low__UInt128 __swiftcall _UInt128.multipliedFullWidth(by:)(Swift::_UInt128 by)
{
  Swift::UInt64 v3 = v1 * by.low;
  unint64_t v4 = (__PAIR128__(v2, v1) * by.low) >> 64;
  BOOL v5 = __CFADD__((v1 * (unsigned __int128)by.low) >> 64, v2 * by.low);
  unint64_t v6 = (v2 * (unsigned __int128)by.high) >> 64;
  uint64_t v7 = (v1 * (unsigned __int128)by.high) >> 64;
  uint64_t v8 = (v2 * (unsigned __int128)by.low) >> 64;
  unsigned long long v11 = __PAIR128__(v2 * by.high, v4) + v1 * by.high;
  BOOL v9 = __CFADD__(__CFADD__(v4, v1 * by.high), v2 * by.high) | __CFADD__(v5, *((void *)&v11 + 1));
  BOOL v10 = v5 + *((void *)&v11 + 1);
  uint64_t v12 = v9;
  BOOL v9 = __CFADD__(v8, v7);
  unint64_t v13 = v8 + v7;
  if (v9) {
    ++v6;
  }
  Swift::UInt64 v15 = (__PAIR128__(v6, v13) + __PAIR128__(v12, v10)) >> 64;
  Swift::UInt64 v14 = v13 + v10;
  Swift::UInt64 v16 = v3;
  Swift::UInt64 v17 = v11;
  result.low.high = v17;
  result.low.low = v16;
  result.high.high = v15;
  result.high.low = v14;
  return result;
}

Swift::UInt64 specialized _wideDivide42<A>(_:by:)(Swift::UInt64 *a1, Swift::UInt64 *a2, Swift::tuple_high_UInt64_low_UInt64 a3, Swift::UInt64 a4, Swift::UInt64 a5, Swift::UInt64 a6, Swift::UInt64 a7, unint64_t a8)
{
  unint64_t v8 = a8;
  if (!(a7 | a8)) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000010, 0x80000001816DC400 | 0x8000000000000000, "Swift/LegacyInt128.swift", 24, 2, 0x4F7uLL, 0);
  }
  Swift::UInt64 v9 = a7;
  BOOL v10 = a8 >= a4;
  if (a7 != a3.low) {
    BOOL v10 = a7 >= a3.low;
  }
  if (!v10) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD00000000000001FLL, 0x80000001816DC3C0 | 0x8000000000000000, "Swift/LegacyInt128.swift", 24, 2, 0x4FAuLL, 0);
  }
  unint64_t v11 = a6;
  Swift::UInt64 v12 = a5;
  high = (void *)a3.high;
  if (a3.low | a4)
  {
    if (a7)
    {
      unint64_t v17 = __clz(a7);
      if (v17)
      {
        char v18 = 0x80 - v17;
        unint64_t v8 = a8 << v17;
        Swift::UInt64 v9 = (a8 >> -(char)v17) | (a7 << v17);
        a3.high = (a4 >> -(char)v17) | (a3.low << v17);
        unint64_t v19 = (128 - v17) & 0x7F;
        Swift::UInt64 v20 = a5 << v17;
        if (v19 > 0x3F)
        {
          Swift::UInt64 v25 = a5 >> v18;
        }
        else
        {
          Swift::UInt64 v21 = (a6 >> v18) | v20;
          Swift::UInt64 v22 = a5 >> v18;
          BOOL v23 = v19 == 0;
          if (v19) {
            Swift::UInt64 v24 = v22;
          }
          else {
            Swift::UInt64 v24 = a5;
          }
          if (v23) {
            Swift::UInt64 v25 = a6;
          }
          else {
            Swift::UInt64 v25 = v21;
          }
          a3.high |= v24;
        }
        a3.low = v25 | (a4 << v17);
        Swift::UInt64 v12 = (a6 >> (-(char)v17 & 0x3F)) | v20;
        unint64_t v11 = a6 << v17;
        if (a3.high) {
          goto LABEL_32;
        }
      }
      else
      {
        a3.high = a5 | a3.low;
        a3.low = a6 | a4;
        if (a3.high) {
          goto LABEL_32;
        }
      }
      BOOL v36 = v12 < v8;
      if (a3.low != v9) {
        BOOL v36 = a3.low < v9;
      }
      if (v36)
      {
        v47.high = a3.low;
        v47.low = v12;
        Swift::UInt64 v37 = specialized _wideDivide32<A>(_:by:)(&v45, &v44, v47, v11, v9, v8);
        Swift::UInt64 quotient = 0;
        Swift::UInt64 v39 = v44;
        Swift::UInt64 v38 = v45;
        *a1 = v37;
        Swift::UInt64 v40 = (v39 >> v17) | (v38 << -(char)v17);
        BOOL v41 = v17 == 0;
        Swift::UInt64 v42 = v38 >> v17;
LABEL_33:
        if (!v41)
        {
          Swift::UInt64 v39 = v40;
          Swift::UInt64 v38 = v42;
        }
        void *high = v39;
        *a2 = v38;
        return quotient;
      }
LABEL_32:
      Swift::UInt64 quotient = specialized _wideDivide32<A>(_:by:)(&v45, &v44, a3, v12, v9, v8);
      v48.low = v44;
      v48.high = v45;
      Swift::UInt64 v43 = specialized _wideDivide32<A>(_:by:)(&v45, &v44, v48, v11, v9, v8);
      Swift::UInt64 v39 = v44;
      Swift::UInt64 v38 = v45;
      *a1 = v43;
      Swift::UInt64 v40 = (v39 >> v17) | (v38 << -(char)v17);
      Swift::UInt64 v42 = v38 >> v17;
      BOOL v41 = v17 == 0;
      goto LABEL_33;
    }
    if (!a8) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero in remainder operation", 39, 2, "Swift/IntegerTypes.swift", 24, 2, 0x26BCuLL, 0);
    }
    if (a3.low % a8)
    {
      v26.low = a4;
      v26.high = a3.low % a8;
      Swift::UInt64 remainder = UInt64.dividingFullWidth(_:)(v26).remainder;
      if (remainder) {
        goto LABEL_22;
      }
    }
    else
    {
      Swift::UInt64 remainder = a4 % a8;
      if (a4 % a8)
      {
LABEL_22:
        Swift::UInt64 v28 = v12;
        Swift::tuple_quotient_UInt64_remainder_UInt64 v29 = UInt64.dividingFullWidth(_:)(*(Swift::tuple_high_UInt64_low_UInt64 *)&remainder);
        Swift::UInt64 quotient = v29.quotient;
        Swift::UInt64 v31 = v29.remainder;
        if (v29.remainder)
        {
LABEL_23:
          unint64_t v32 = v11;
          Swift::tuple_quotient_UInt64_remainder_UInt64 v35 = UInt64.dividingFullWidth(_:)(*(Swift::tuple_high_UInt64_low_UInt64 *)&v31);
          Swift::UInt64 v34 = v35.remainder;
          Swift::UInt64 v33 = v35.quotient;
LABEL_39:
          *a1 = v33;
          void *high = v34;
          *a2 = 0;
          return quotient;
        }
LABEL_38:
        Swift::UInt64 v33 = v11 / a8;
        Swift::UInt64 v34 = v11 % a8;
        goto LABEL_39;
      }
    }
    Swift::UInt64 quotient = v12 / a8;
    Swift::UInt64 v31 = v12 % a8;
    if (v12 % a8) {
      goto LABEL_23;
    }
    goto LABEL_38;
  }
  a3.low = a5;

  return specialized _wideDivide22<A>(_:by:)(a1, a2, a3, a6, a7, a8);
}

uint64_t specialized _wideMaskedShiftLeft<A>(_:_:)(uint64_t *a1, unint64_t a2, unint64_t a3, char a4)
{
  unint64_t v4 = (a2 << a4) | (a3 >> -a4);
  if ((a4 & 0x7F) != 0) {
    uint64_t v5 = a3 << a4;
  }
  else {
    uint64_t v5 = a3;
  }
  if ((a4 & 0x7F) == 0) {
    unint64_t v4 = a2;
  }
  if ((a4 & 0x7Fu) <= 0x3FuLL)
  {
    uint64_t v6 = v4;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = a3 << a4;
  }
  *a1 = v5;
  return v6;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance _UInt128(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  uint64_t v4 = v2[1];
  BOOL v5 = __CFADD__(*v2, *a2);
  BOOL v6 = __CFADD__(v4, v3);
  uint64_t v7 = v4 + v3;
  if (v6)
  {
    uint64_t v8 = 1;
    if (!v5)
    {
LABEL_12:
      uint64_t v9 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v8 = v7 == -1 && v5;
    if (!v5) {
      goto LABEL_12;
    }
  }
  uint64_t v9 = 1;
LABEL_13:
  *a1 = *v2 + *a2;
  a1[1] = v9 + v7;
  return v8;
}

unint64_t protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance _UInt128(unint64_t *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  unint64_t v5 = *v2;
  unint64_t v6 = v2[1];
  BOOL v7 = v6 >= v4;
  unint64_t v8 = v6 - v4;
  int v9 = !v7;
  BOOL v7 = v5 >= v3;
  unint64_t v10 = v5 - v3;
  LODWORD(v3) = v5 < v3;
  if (v7)
  {
    if (v9)
    {
      unint64_t v3 = 1;
      unint64_t v11 = v8;
      goto LABEL_13;
    }
    unint64_t v11 = v8;
  }
  else
  {
    unint64_t v11 = v8 - 1;
    if (v9)
    {
      unint64_t v3 = 1;
      goto LABEL_13;
    }
  }
  if (v8) {
    unint64_t v3 = 0;
  }
  else {
    unint64_t v3 = v3;
  }
LABEL_13:
  *a1 = v10;
  a1[1] = v11;
  return v3;
}

uint64_t protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance _UInt128(unint64_t *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  unint64_t v5 = *v2;
  unint64_t v6 = v2[1];
  BOOL v7 = !is_mul_ok(v6, *a2);
  unint64_t v8 = v6 * *a2;
  BOOL v9 = !is_mul_ok(*v2, v4);
  unint64_t v10 = v8 + *v2 * v4;
  BOOL v11 = __CFADD__(v8, *v2 * v4);
  unint64_t v12 = v5 * v3;
  uint64_t v13 = (v5 * (unsigned __int128)v3) >> 64;
  unint64_t v14 = v10 + v13;
  BOOL v15 = __CFADD__(v10, v13);
  if (v4) {
    BOOL v16 = v6 == 0;
  }
  else {
    BOOL v16 = 1;
  }
  uint64_t v17 = 1;
  if (v16)
  {
    unsigned int v18 = v9 || v11 || v15;
    if (v7) {
      uint64_t v17 = 1;
    }
    else {
      uint64_t v17 = v18;
    }
  }
  *a1 = v12;
  a1[1] = v14;
  return v17;
}

BOOL protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance _UInt128(Swift::UInt64 *a1, unint64_t *a2)
{
  unint64_t v4 = a2[1];
  Swift::UInt64 v6 = *v2;
  v5.low = v2[1];
  unint64_t v7 = v4 | *a2;
  BOOL v8 = v7 == 0;
  if (v7)
  {
    v5.high = (Swift::UInt64)&v10;
    v5.low = specialized _wideDivide22<A>(_:by:)(&v12, &v11, v5, v6, v4, *a2);
    Swift::UInt64 v6 = v12;
  }
  *a1 = v6;
  a1[1] = v5.low;
  return v8;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance _UInt128(Swift::UInt64 *a1, unint64_t *a2)
{
  unint64_t v4 = a2[1];
  Swift::UInt64 v6 = *v2;
  v5.low = v2[1];
  unint64_t v7 = v4 | *a2;
  BOOL v8 = v7 == 0;
  if (v7)
  {
    v5.high = (Swift::UInt64)&v10;
    specialized _wideDivide22<A>(_:by:)(&v12, &v11, v5, v6, v4, *a2);
    Swift::UInt64 v6 = v10;
    v5.low = v11;
  }
  *a1 = v6;
  a1[1] = v5.low;
  return v8;
}

uint64_t protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance _UInt128(uint64_t *a1, void *a2, void *a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance _UInt128(a1, a2, a3, a4, a5, (uint64_t (*)(void, void, void, void))_UInt128.multipliedFullWidth(by:));
}

Swift::UInt64 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance _UInt128(void *a1, void *a2, Swift::UInt64 *a3, Swift::UInt64 *a4)
{
  Swift::UInt64 v7 = *a3;
  Swift::UInt64 v8 = a3[1];
  Swift::UInt64 v10 = *a4;
  Swift::UInt64 v9 = a4[1];
  v17.high = (Swift::UInt64)&v14;
  v17.low = v8;
  Swift::UInt64 result = specialized _wideDivide42<A>(_:by:)(&v16, &v15, v17, v7, v9, v10, v4[1], *v4);
  Swift::UInt64 v12 = v15;
  uint64_t v13 = v14;
  *a1 = v16;
  a1[1] = result;
  *a2 = v13;
  a2[1] = v12;
  return result;
}

uint64_t protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance _UInt128@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  return protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance _UInt128(a1, a2, (uint64_t (*)(uint64_t, void, void, void))specialized _wideMaskedShiftRight<A>(_:_:), a3);
}

uint64_t *protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance _UInt128(uint64_t *a1, void *a2)
{
  return specialized static _UInt128.&>>= infix(_:_:)(a1, *a2);
}

uint64_t protocol witness for static FixedWidthInteger.&<< infix(_:_:) in conformance _Int128@<X0>(unint64_t *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = specialized _wideMaskedShiftLeft<A>(_:_:)(a3, a1[1], *a1, *a2);
  a3[1] = result;
  return result;
}

uint64_t *protocol witness for static FixedWidthInteger.&<<= infix(_:_:) in conformance _UInt128(uint64_t *a1, void *a2)
{
  return specialized static _Int128.&<<= infix(_:_:)(a1, *a2);
}

_OWORD *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance _UInt128@<X0>(_OWORD *result@<X0>, _OWORD *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = (*a2 * *result) >> 64;
  *a3 = *(void *)a2 * *(void *)result;
  a3[1] = v3;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance _UInt128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type _UInt128 and conformance _UInt128(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

double protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128@<D0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type _UInt128 and conformance _UInt128, a5);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128(a1, a2, a3, _UInt128.init<A>(exactly:), 0x85uLL, a4);
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance _UInt128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance _UInt128(a1, a2, (uint64_t (*)(void))specialized static FixedWidthInteger._truncatingInit<A>(_:), a3);
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance _UInt128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type _UInt128 and conformance _UInt128(a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance _UInt128()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*v0, v0[1]);
}

uint64_t protocol witness for static BinaryInteger./ infix(_:_:) in conformance _UInt128@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static Numeric.* infix(_:_:) in conformance _UInt128(a1, a2, (uint64_t (*)(void, void, void, void))specialized static _UInt128./ infix(_:_:), a3);
}

Swift::UInt64 protocol witness for static BinaryInteger./= infix(_:_:) in conformance _UInt128(Swift::UInt64 *a1, unint64_t *a2)
{
  return specialized static _UInt128./= infix(_:_:)(a1, *a2, a2[1]);
}

uint64_t protocol witness for static BinaryInteger.% infix(_:_:) in conformance _UInt128@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static Numeric.* infix(_:_:) in conformance _UInt128(a1, a2, specialized static _UInt128.% infix(_:_:), a3);
}

Swift::UInt64 protocol witness for static BinaryInteger.%= infix(_:_:) in conformance _UInt128(Swift::UInt64 *a1, unint64_t *a2)
{
  return specialized static _UInt128.%= infix(_:_:)(a1, *a2, a2[1]);
}

unint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance _UInt128@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  v140 = a5;
  unint64_t v131 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v131, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v129 = (char *)&v123 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v123 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v127 = (char *)&v123 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  unint64_t v133 = (char *)&v123 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  Swift::UInt64 v21 = (char *)&v123 - v20;
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  char v128 = (char *)&v123 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  v136 = (char *)&v123 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  v139 = (char *)&v123 - v27;
  MEMORY[0x1F4188790](v26);
  Swift::tuple_quotient_UInt64_remainder_UInt64 v29 = (char *)&v123 - v28;
  unint64_t v30 = *a1;
  unint64_t v134 = a1[1];
  unint64_t v135 = v30;
  uint64_t v32 = a4 + 64;
  Swift::UInt64 v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v33 = v31(a3, a4);
  uint64_t v138 = v21;
  if ((v33 & 1) == 0)
  {
    char v37 = v31(a3, a4);
    v141 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v141(a3, a4);
    if ((v37 & 1) == 0)
    {
      if (v34 >= 64) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    if (v34 <= 64)
    {
      uint64_t v137 = a4 + 64;
      unint64_t v124 = v31;
      uint64_t v69 = AssociatedTypeWitness;
      BOOL v70 = v131;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v131, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v72 = v129;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v69, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v70[3])(v72, a3, v70);
      LOBYTE(v69) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      uint64_t v73 = *(void (**)(char *, uint64_t))(v11 + 8);
      v73(v29, a3);
      uint64_t v132 = v11;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if (v69)
      {
        v73(v14, a3);
        goto LABEL_25;
      }
      uint64_t v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v73(v14, a3);
      uint64_t v11 = v132;
      Swift::UInt64 v31 = v124;
      uint64_t v32 = v137;
      if (v74 < -128) {
        goto LABEL_25;
      }
      goto LABEL_10;
    }
LABEL_6:
    v143[0] = -128;
    Swift::UInt64 v38 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v39 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
    v38(v143, &type metadata for Int, v39, a3, a4);
    char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v29, a3);
    (*(void (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v40) {
      goto LABEL_25;
    }
    goto LABEL_10;
  }
  v141 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v34 = v141(a3, a4);
  if (v34 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  uint64_t v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v29, a3);
  if (v41 < -128) {
    goto LABEL_25;
  }
LABEL_10:
  char v42 = v31(a3, a4);
  uint64_t v132 = a4 + 128;
  uint64_t v43 = v141(a3, a4);
  uint64_t v137 = v32;
  if (v42)
  {
    if (v43 > 64) {
      goto LABEL_12;
    }
  }
  else if (v43 > 63)
  {
LABEL_12:
    v143[0] = 128;
    uint64_t v46 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v47 = lazy protocol witness table accessor for type Int and conformance Int(v43, v44, v45);
    v46(v143, &type metadata for Int, v47, a3, a4);
    char v48 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v29, a2, a3);
    char v49 = *(void (**)(char *, uint64_t))(v11 + 8);
    v49(v29, a3);
    if (v48) {
      goto LABEL_25;
    }
    goto LABEL_16;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  char v49 = *(void (**)(char *, uint64_t))(v11 + 8);
  v49(v29, a3);
  if (v50 > 128) {
    goto LABEL_25;
  }
LABEL_16:
  uint64_t v123 = v29;
  uint64_t v125 = v49;
  uint64_t v51 = v11 + 16;
  char v52 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v53 = v11;
  uint64_t v54 = v139;
  v52(v139, a2, a3);
  unint64_t v124 = v31;
  char v55 = v31(a3, a4);
  uint64_t v56 = v136;
  uint64_t v57 = v54;
  char v58 = v52;
  uint64_t v126 = v51;
  v52(v136, (uint64_t)v57, a3);
  if (v55)
  {
    uint64_t v59 = v141(a3, a4);
    v136 = (char *)(v53 + 8);
    v125(v56, a3);
    char v61 = v138;
    unint64_t v60 = v139;
    if (v59 <= 64) {
      goto LABEL_41;
    }
    char v62 = v128;
    char v63 = v58;
    v58(v128, (uint64_t)v139, a3);
    v143[0] = 0x8000000000000000;
    uint64_t v64 = v124;
    if (v124(a3, a4))
    {
      uint64_t v65 = v141(a3, a4);
      if (v65 < 64)
      {
        uint64_t v68 = v123;
        v58(v123, (uint64_t)v62, a3);
        goto LABEL_35;
      }
      uint64_t v86 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v87 = lazy protocol witness table accessor for type Int and conformance Int(v65, v66, v67);
      char v88 = v123;
      v86(v143, &type metadata for Int, v87, a3, a4);
      unint64_t v60 = v139;
      char v89 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v62, v88, a3);
      uint64_t v85 = v125;
      v125(v88, a3);
      char v58 = v63;
      if (v89) {
        goto LABEL_63;
      }
LABEL_39:
      v85(v62, a3);
      goto LABEL_40;
    }
    char v77 = v64(a3, a4);
    uint64_t v78 = v141(a3, a4);
    if (v77)
    {
      if (v78 <= 64)
      {
        uint64_t v93 = AssociatedTypeWitness;
        uint64_t v92 = v131;
        uint64_t v94 = swift_getAssociatedConformanceWitness((uint64_t)v131, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v95 = v129;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v94 + 8))(&qword_18162B0B8, 256, v93, v94);
        uint64_t v96 = v123;
        ((void (*)(char *, uint64_t, int **))v92[3])(v95, a3, v92);
        uint64_t v97 = v128;
        char v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v128, v96, a3);
        uint64_t v85 = v125;
        v125(v96, a3);
        uint64_t v99 = v127;
        v58(v127, (uint64_t)v97, a3);
        if (v98)
        {
          v85(v99, a3);
          goto LABEL_63;
        }
        uint64_t v100 = v143[0];
        uint64_t v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v85(v99, a3);
        BOOL v102 = v101 < v100;
        unint64_t v60 = v139;
        char v62 = v128;
        if (v102) {
          goto LABEL_63;
        }
      }
      else
      {
        uint64_t v81 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v82 = lazy protocol witness table accessor for type Int and conformance Int(v78, v79, v80);
        uint64_t v83 = v123;
        v81(v143, &type metadata for Int, v82, a3, a4);
        unint64_t v60 = v139;
        char v62 = v128;
        char v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v128, v83, a3);
        uint64_t v85 = v125;
        v125(v83, a3);
        if (v84) {
          goto LABEL_63;
        }
      }
      goto LABEL_39;
    }
    if (v78 < 64)
    {
      uint64_t v68 = v123;
      char v62 = v128;
      v58(v123, (uint64_t)v128, a3);
LABEL_35:
      uint64_t v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t v91 = v68;
      uint64_t v85 = v125;
      v125(v91, a3);
      if (v90 < v143[0]) {
LABEL_63:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_39;
    }
    v125(v128, a3);
  }
  else
  {
    v125(v56, a3);
    unint64_t v60 = v139;
  }
LABEL_40:
  char v61 = v138;
LABEL_41:
  char v103 = v141;
  uint64_t v104 = v141(a3, a4);
  v58(v61, (uint64_t)v60, a3);
  if (v104 >= 65)
  {
    uint64_t v105 = v125;
    v125(v61, a3);
    goto LABEL_43;
  }
  uint64_t v115 = v103(a3, a4);
  uint64_t v105 = v125;
  v125(v61, a3);
  if (v115 == 64 && (v124(a3, a4) & 1) == 0)
  {
LABEL_43:
    uint64_t v106 = v133;
    uint64_t v107 = (void (*)(char *, char *, uint64_t))v58;
    v58(v133, (uint64_t)v60, a3);
    v143[0] = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v108 = v106;
    LOBYTE(v106) = v124(a3, a4);
    uint64_t v109 = v141(a3, a4);
    if (v106)
    {
      if (v109 > 64)
      {
        char v112 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v113 = lazy protocol witness table accessor for type Int and conformance Int(v109, v110, v111);
        uint64_t v114 = v143;
        goto LABEL_52;
      }
    }
    else if (v109 > 63)
    {
      uint64_t v142 = 0x7FFFFFFFFFFFFFFFLL;
      char v112 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v113 = lazy protocol witness table accessor for type Int and conformance Int(v109, v110, v111);
      uint64_t v114 = &v142;
LABEL_52:
      uint64_t v117 = v123;
      v112(v114, &type metadata for Int, v113, a3, a4);
      char v118 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v117, v108, a3);
      v105(v117, a3);
      if (v118) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      goto LABEL_53;
    }
    uint64_t v116 = v123;
    v107(v123, v108, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v105(v116, a3);
LABEL_53:
    v105(v108, a3);
  }
  unint64_t v119 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v105(v60, a3);
  if ((v119 & 0x8000000000000000) != 0)
  {
    if (v119 > 0xFFFFFFFFFFFFFF80)
    {
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      unint64_t result = specialized _wideMaskedShiftLeft<A>(_:_:)(v143, v134, v135, v122);
      goto LABEL_57;
    }
  }
  else if (v119 < 0x80)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    unint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)((unint64_t *)v143, v134, v135, v120);
LABEL_57:
    uint64_t v76 = v143[0];
    goto LABEL_58;
  }
LABEL_25:
  unint64_t result = 0;
  uint64_t v76 = 0;
LABEL_58:
  uint64_t v121 = v140;
  uint64_t *v140 = v76;
  v121[1] = result;
  return result;
}

unint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance _UInt128(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v114 = a1;
  uint64_t v7 = *(void *)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v105 = (char *)&v101 - v9;
  uint64_t v117 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v12 = (char *)&v101 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v104 = (char *)&v101 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v110 = (char *)&v101 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v108 = (char *)&v101 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  Swift::UInt64 v21 = (char *)&v101 - v20;
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v109 = (char *)&v101 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  char v112 = (char *)&v101 - v25;
  MEMORY[0x1F4188790](v24);
  uint64_t v27 = (char *)&v101 - v26;
  uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v115 = a4 + 64;
  uint64_t v116 = v28;
  if ((v28(a3, a4) & 1) == 0)
  {
    char v32 = v116(a3, a4);
    unint64_t v113 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v29 = v113(a3, a4);
    if ((v32 & 1) == 0)
    {
      if (v29 >= 64) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    if (v29 <= 64)
    {
      BOOL v102 = v21;
      uint64_t v57 = AssociatedTypeWitness;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v7, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v59 = v105;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v57, AssociatedConformanceWitness);
      unint64_t v60 = *(void (**)(char *, uint64_t, uint64_t))(v7 + 24);
      uint64_t v101 = v7;
      v60(v59, a3, v7);
      LOBYTE(v59) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v27, a3);
      uint64_t v61 = v117;
      char v62 = *(void (**)(char *, uint64_t))(v117 + 8);
      v62(v27, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v61 + 16))(v12, a2, a3);
      if (v59)
      {
        v62(v12, a3);
        goto LABEL_25;
      }
      uint64_t v63 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v12, a3);
      uint64_t v7 = v101;
      Swift::UInt64 v21 = v102;
      if (v63 < -128) {
        goto LABEL_25;
      }
      goto LABEL_10;
    }
LABEL_6:
    v119[0] = -128;
    char v33 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v34 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
    v33(v119, &type metadata for Int, v34, a3, a4);
    char v35 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v27, a3);
    (*(void (**)(char *, uint64_t))(v117 + 8))(v27, a3);
    if (v35) {
      goto LABEL_25;
    }
    goto LABEL_10;
  }
  unint64_t v113 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v29 = v113(a3, a4);
  if (v29 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  uint64_t v36 = v117;
  (*(void (**)(char *, uint64_t, uint64_t))(v117 + 16))(v27, a2, a3);
  uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  (*(void (**)(char *, uint64_t))(v36 + 8))(v27, a3);
  if (v37 < -128) {
    goto LABEL_25;
  }
LABEL_10:
  char v38 = v116(a3, a4);
  uint64_t v107 = a4 + 128;
  uint64_t v39 = v113(a3, a4);
  BOOL v102 = v21;
  if (v38)
  {
    if (v39 > 64) {
      goto LABEL_12;
    }
  }
  else if (v39 >= 64)
  {
LABEL_12:
    v119[0] = 128;
    char v42 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
    v42(v119, &type metadata for Int, v43, a3, a4);
    char v44 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v27, a2, a3);
    uint64_t v45 = v117;
    uint64_t v111 = *(void (**)(char *, uint64_t))(v117 + 8);
    v111(v27, a3);
    if (v44) {
      goto LABEL_25;
    }
    goto LABEL_16;
  }
  uint64_t v45 = v117;
  (*(void (**)(char *, uint64_t, uint64_t))(v117 + 16))(v27, a2, a3);
  uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v111 = *(void (**)(char *, uint64_t))(v45 + 8);
  v111(v27, a3);
  if (v46 > 128) {
    goto LABEL_25;
  }
LABEL_16:
  uint64_t v101 = v7;
  unint64_t v47 = *(void (**)(char *, uint64_t, uint64_t))(v45 + 16);
  char v48 = v112;
  v47(v112, a2, a3);
  char v49 = v116(a3, a4);
  uint64_t v50 = v109;
  char v103 = (void (*)(char *, char *, uint64_t))v47;
  v47(v109, (uint64_t)v48, a3);
  if ((v49 & 1) == 0)
  {
    v111(v50, a3);
    goto LABEL_37;
  }
  uint64_t v51 = v113(a3, a4);
  v111(v50, a3);
  if (v51 <= 64) {
    goto LABEL_37;
  }
  char v52 = v102;
  v103(v102, v112, a3);
  v119[0] = 0x8000000000000000;
  uint64_t v53 = v116;
  if (v116(a3, a4))
  {
    uint64_t v54 = v113(a3, a4);
    if (v54 < 64)
    {
LABEL_32:
      v103(v27, v52, a3);
      uint64_t v71 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      BOOL v70 = v111;
      v111(v27, a3);
      if (v71 < v119[0]) {
LABEL_57:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_36;
    }
LABEL_28:
    uint64_t v67 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v68 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
    v67(v119, &type metadata for Int, v68, a3, a4);
    char v69 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v52, v27, a3);
    BOOL v70 = v111;
    v111(v27, a3);
    if (v69) {
      goto LABEL_57;
    }
    goto LABEL_36;
  }
  char v66 = v53(a3, a4);
  uint64_t v54 = v113(a3, a4);
  if ((v66 & 1) == 0)
  {
    if (v54 >= 64)
    {
      v111(v52, a3);
      goto LABEL_37;
    }
    goto LABEL_32;
  }
  if (v54 > 64) {
    goto LABEL_28;
  }
  uint64_t v72 = v101;
  uint64_t v73 = AssociatedTypeWitness;
  uint64_t v74 = swift_getAssociatedConformanceWitness(v101, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v75 = v105;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v74 + 8))(&qword_18162B0B8, 256, v73, v74);
  (*(void (**)(char *, uint64_t, uint64_t))(v72 + 24))(v75, a3, v72);
  LOBYTE(v72) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v52, v27, a3);
  BOOL v70 = v111;
  v111(v27, a3);
  uint64_t v76 = v104;
  v103(v104, v52, a3);
  if (v72)
  {
    v70(v76, a3);
    goto LABEL_57;
  }
  uint64_t v77 = v119[0];
  uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v76, a3);
  BOOL v79 = v78 < v77;
  char v52 = v102;
  if (v79) {
    goto LABEL_57;
  }
LABEL_36:
  v70(v52, a3);
LABEL_37:
  uint64_t v80 = v112;
  uint64_t v81 = v113;
  uint64_t v82 = v113(a3, a4);
  uint64_t v83 = v108;
  v103(v108, v80, a3);
  if (v82 < 65)
  {
    uint64_t v91 = v81(a3, a4);
    v111(v83, a3);
    if (v91 != 64 || (v116(a3, a4) & 1) != 0) {
      goto LABEL_50;
    }
  }
  else
  {
    v111(v83, a3);
  }
  v103(v110, v112, a3);
  v119[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v84 = v116(a3, a4);
  uint64_t v85 = v113(a3, a4);
  if ((v84 & 1) == 0)
  {
    if (v85 >= 64)
    {
      uint64_t v118 = 0x7FFFFFFFFFFFFFFFLL;
      char v88 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v89 = lazy protocol witness table accessor for type Int and conformance Int(v85, v86, v87);
      uint64_t v90 = &v118;
      goto LABEL_48;
    }
LABEL_47:
    v103(v27, v110, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v92 = v111;
    v111(v27, a3);
    v92(v110, a3);
    goto LABEL_50;
  }
  if (v85 <= 64) {
    goto LABEL_47;
  }
  char v88 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v89 = lazy protocol witness table accessor for type Int and conformance Int(v85, v86, v87);
  uint64_t v90 = v119;
LABEL_48:
  v88(v90, &type metadata for Int, v89, a3, a4);
  char v93 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v27, v110, a3);
  v111(v27, a3);
  if (v93) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v111(v110, a3);
LABEL_50:
  uint64_t v94 = v112;
  unint64_t v95 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v111(v94, a3);
  unint64_t v96 = *v114;
  unint64_t v97 = v114[1];
  if ((v95 & 0x8000000000000000) != 0)
  {
    if (v95 > 0xFFFFFFFFFFFFFF80)
    {
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      unint64_t result = specialized _wideMaskedShiftLeft<A>(_:_:)(v119, v97, v96, v100);
      goto LABEL_53;
    }
  }
  else if (v95 < 0x80)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    unint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)((unint64_t *)v119, v97, v96, v98);
LABEL_53:
    uint64_t v65 = v119[0];
    goto LABEL_54;
  }
LABEL_25:
  unint64_t result = 0;
  uint64_t v65 = 0;
LABEL_54:
  uint64_t v99 = v114;
  *uint64_t v114 = v65;
  v99[1] = result;
  return result;
}

unint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance _UInt128@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  v140 = a5;
  unint64_t v131 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v131, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v129 = (char *)&v123 - v10;
  uint64_t v11 = *(void *)(a3 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v9);
  uint64_t v14 = (char *)&v123 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v127 = (char *)&v123 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  unint64_t v133 = (char *)&v123 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  Swift::UInt64 v21 = (char *)&v123 - v20;
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  char v128 = (char *)&v123 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  v136 = (char *)&v123 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  v139 = (char *)&v123 - v27;
  MEMORY[0x1F4188790](v26);
  uint64_t v29 = (char *)&v123 - v28;
  unint64_t v30 = *a1;
  unint64_t v134 = a1[1];
  unint64_t v135 = v30;
  uint64_t v32 = a4 + 64;
  uint64_t v31 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v33 = v31(a3, a4);
  uint64_t v138 = v21;
  if ((v33 & 1) == 0)
  {
    char v37 = v31(a3, a4);
    v141 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v34 = v141(a3, a4);
    if ((v37 & 1) == 0)
    {
      if (v34 >= 64) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    if (v34 <= 64)
    {
      uint64_t v137 = a4 + 64;
      unint64_t v124 = v31;
      char v69 = AssociatedTypeWitness;
      BOOL v70 = v131;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v131, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v72 = v129;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v69, AssociatedConformanceWitness);
      ((void (*)(char *, uint64_t, int **))v70[3])(v72, a3, v70);
      LOBYTE(v69) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v29, a3);
      uint64_t v73 = *(void (**)(char *, uint64_t))(v11 + 8);
      v73(v29, a3);
      uint64_t v132 = v11;
      (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v14, a2, a3);
      if (v69)
      {
        v73(v14, a3);
        goto LABEL_25;
      }
      uint64_t v74 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v73(v14, a3);
      uint64_t v11 = v132;
      uint64_t v31 = v124;
      uint64_t v32 = v137;
      if (v74 < -128) {
        goto LABEL_25;
      }
      goto LABEL_10;
    }
LABEL_6:
    v143[0] = -128;
    char v38 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v39 = lazy protocol witness table accessor for type Int and conformance Int(v34, v35, v36);
    v38(v143, &type metadata for Int, v39, a3, a4);
    char v40 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v29, a3);
    (*(void (**)(char *, uint64_t))(v11 + 8))(v29, a3);
    if (v40) {
      goto LABEL_25;
    }
    goto LABEL_10;
  }
  v141 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v34 = v141(a3, a4);
  if (v34 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  uint64_t v41 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v29, a3);
  if (v41 < -128) {
    goto LABEL_25;
  }
LABEL_10:
  char v42 = v31(a3, a4);
  uint64_t v132 = a4 + 128;
  uint64_t v43 = v141(a3, a4);
  uint64_t v137 = v32;
  if (v42)
  {
    if (v43 > 64) {
      goto LABEL_12;
    }
  }
  else if (v43 > 63)
  {
LABEL_12:
    v143[0] = 128;
    uint64_t v46 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v47 = lazy protocol witness table accessor for type Int and conformance Int(v43, v44, v45);
    v46(v143, &type metadata for Int, v47, a3, a4);
    char v48 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v29, a2, a3);
    char v49 = *(void (**)(char *, uint64_t))(v11 + 8);
    v49(v29, a3);
    if (v48) {
      goto LABEL_25;
    }
    goto LABEL_16;
  }
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v29, a2, a3);
  uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  char v49 = *(void (**)(char *, uint64_t))(v11 + 8);
  v49(v29, a3);
  if (v50 > 128) {
    goto LABEL_25;
  }
LABEL_16:
  uint64_t v123 = v29;
  uint64_t v125 = v49;
  uint64_t v51 = v11 + 16;
  char v52 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  uint64_t v53 = v11;
  uint64_t v54 = v139;
  v52(v139, a2, a3);
  unint64_t v124 = v31;
  char v55 = v31(a3, a4);
  uint64_t v56 = v136;
  uint64_t v57 = v54;
  char v58 = v52;
  uint64_t v126 = v51;
  v52(v136, (uint64_t)v57, a3);
  if (v55)
  {
    uint64_t v59 = v141(a3, a4);
    v136 = (char *)(v53 + 8);
    v125(v56, a3);
    uint64_t v61 = v138;
    unint64_t v60 = v139;
    if (v59 <= 64) {
      goto LABEL_41;
    }
    char v62 = v128;
    uint64_t v63 = v58;
    v58(v128, (uint64_t)v139, a3);
    v143[0] = 0x8000000000000000;
    uint64_t v64 = v124;
    if (v124(a3, a4))
    {
      uint64_t v65 = v141(a3, a4);
      if (v65 < 64)
      {
        unint64_t v68 = v123;
        v58(v123, (uint64_t)v62, a3);
        goto LABEL_35;
      }
      uint64_t v86 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v87 = lazy protocol witness table accessor for type Int and conformance Int(v65, v66, v67);
      char v88 = v123;
      v86(v143, &type metadata for Int, v87, a3, a4);
      unint64_t v60 = v139;
      char v89 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v62, v88, a3);
      uint64_t v85 = v125;
      v125(v88, a3);
      char v58 = v63;
      if (v89) {
        goto LABEL_63;
      }
LABEL_39:
      v85(v62, a3);
      goto LABEL_40;
    }
    char v77 = v64(a3, a4);
    uint64_t v78 = v141(a3, a4);
    if (v77)
    {
      if (v78 <= 64)
      {
        char v93 = AssociatedTypeWitness;
        uint64_t v92 = v131;
        uint64_t v94 = swift_getAssociatedConformanceWitness((uint64_t)v131, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v95 = v129;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v94 + 8))(&qword_18162B0B8, 256, v93, v94);
        unint64_t v96 = v123;
        ((void (*)(char *, uint64_t, int **))v92[3])(v95, a3, v92);
        unint64_t v97 = v128;
        char v98 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v128, v96, a3);
        uint64_t v85 = v125;
        v125(v96, a3);
        uint64_t v99 = v127;
        v58(v127, (uint64_t)v97, a3);
        if (v98)
        {
          v85(v99, a3);
          goto LABEL_63;
        }
        uint64_t v100 = v143[0];
        uint64_t v101 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
        v85(v99, a3);
        BOOL v102 = v101 < v100;
        unint64_t v60 = v139;
        char v62 = v128;
        if (v102) {
          goto LABEL_63;
        }
      }
      else
      {
        uint64_t v81 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v82 = lazy protocol witness table accessor for type Int and conformance Int(v78, v79, v80);
        uint64_t v83 = v123;
        v81(v143, &type metadata for Int, v82, a3, a4);
        unint64_t v60 = v139;
        char v62 = v128;
        char v84 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v128, v83, a3);
        uint64_t v85 = v125;
        v125(v83, a3);
        if (v84) {
          goto LABEL_63;
        }
      }
      goto LABEL_39;
    }
    if (v78 < 64)
    {
      unint64_t v68 = v123;
      char v62 = v128;
      v58(v123, (uint64_t)v128, a3);
LABEL_35:
      uint64_t v90 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t v91 = v68;
      uint64_t v85 = v125;
      v125(v91, a3);
      if (v90 < v143[0]) {
LABEL_63:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_39;
    }
    v125(v128, a3);
  }
  else
  {
    v125(v56, a3);
    unint64_t v60 = v139;
  }
LABEL_40:
  uint64_t v61 = v138;
LABEL_41:
  char v103 = v141;
  uint64_t v104 = v141(a3, a4);
  v58(v61, (uint64_t)v60, a3);
  if (v104 >= 65)
  {
    uint64_t v105 = v125;
    v125(v61, a3);
    goto LABEL_43;
  }
  uint64_t v115 = v103(a3, a4);
  uint64_t v105 = v125;
  v125(v61, a3);
  if (v115 == 64 && (v124(a3, a4) & 1) == 0)
  {
LABEL_43:
    uint64_t v106 = v133;
    uint64_t v107 = (void (*)(char *, char *, uint64_t))v58;
    v58(v133, (uint64_t)v60, a3);
    v143[0] = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v108 = v106;
    LOBYTE(v106) = v124(a3, a4);
    uint64_t v109 = v141(a3, a4);
    if (v106)
    {
      if (v109 > 64)
      {
        char v112 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v113 = lazy protocol witness table accessor for type Int and conformance Int(v109, v110, v111);
        uint64_t v114 = v143;
        goto LABEL_52;
      }
    }
    else if (v109 > 63)
    {
      uint64_t v142 = 0x7FFFFFFFFFFFFFFFLL;
      char v112 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v113 = lazy protocol witness table accessor for type Int and conformance Int(v109, v110, v111);
      uint64_t v114 = &v142;
LABEL_52:
      uint64_t v117 = v123;
      v112(v114, &type metadata for Int, v113, a3, a4);
      char v118 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v117, v108, a3);
      v105(v117, a3);
      if (v118) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
      }
      goto LABEL_53;
    }
    uint64_t v116 = v123;
    v107(v123, v108, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    v105(v116, a3);
LABEL_53:
    v105(v108, a3);
  }
  unint64_t v119 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v105(v60, a3);
  if ((v119 & 0x8000000000000000) != 0)
  {
    if (v119 > 0xFFFFFFFFFFFFFF80)
    {
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      unint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)((unint64_t *)v143, v134, v135, v122);
      goto LABEL_57;
    }
  }
  else if (v119 < 0x80)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    unint64_t result = specialized _wideMaskedShiftLeft<A>(_:_:)(v143, v134, v135, v120);
LABEL_57:
    uint64_t v76 = v143[0];
    goto LABEL_58;
  }
LABEL_25:
  unint64_t result = 0;
  uint64_t v76 = 0;
LABEL_58:
  uint64_t v121 = v140;
  uint64_t *v140 = v76;
  v121[1] = result;
  return result;
}

unint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance _UInt128(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v114 = a1;
  uint64_t v7 = *(void *)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v105 = (char *)&v101 - v9;
  uint64_t v117 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v12 = (char *)&v101 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v104 = (char *)&v101 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v110 = (char *)&v101 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v108 = (char *)&v101 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  Swift::UInt64 v21 = (char *)&v101 - v20;
  uint64_t v22 = MEMORY[0x1F4188790](v19);
  uint64_t v109 = (char *)&v101 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  char v112 = (char *)&v101 - v25;
  MEMORY[0x1F4188790](v24);
  uint64_t v27 = (char *)&v101 - v26;
  uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  uint64_t v115 = a4 + 64;
  uint64_t v116 = v28;
  if ((v28(a3, a4) & 1) == 0)
  {
    char v32 = v116(a3, a4);
    unint64_t v113 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v29 = v113(a3, a4);
    if ((v32 & 1) == 0)
    {
      if (v29 >= 64) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    if (v29 <= 64)
    {
      BOOL v102 = v21;
      uint64_t v57 = AssociatedTypeWitness;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v7, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v59 = v105;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v57, AssociatedConformanceWitness);
      unint64_t v60 = *(void (**)(char *, uint64_t, uint64_t))(v7 + 24);
      uint64_t v101 = v7;
      v60(v59, a3, v7);
      LOBYTE(v59) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v27, a3);
      uint64_t v61 = v117;
      char v62 = *(void (**)(char *, uint64_t))(v117 + 8);
      v62(v27, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v61 + 16))(v12, a2, a3);
      if (v59)
      {
        v62(v12, a3);
        goto LABEL_25;
      }
      uint64_t v63 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v62(v12, a3);
      uint64_t v7 = v101;
      Swift::UInt64 v21 = v102;
      if (v63 < -128) {
        goto LABEL_25;
      }
      goto LABEL_10;
    }
LABEL_6:
    v119[0] = -128;
    char v33 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v34 = lazy protocol witness table accessor for type Int and conformance Int(v29, v30, v31);
    v33(v119, &type metadata for Int, v34, a3, a4);
    char v35 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v27, a3);
    (*(void (**)(char *, uint64_t))(v117 + 8))(v27, a3);
    if (v35) {
      goto LABEL_25;
    }
    goto LABEL_10;
  }
  unint64_t v113 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
  uint64_t v29 = v113(a3, a4);
  if (v29 >= 64) {
    goto LABEL_6;
  }
LABEL_9:
  uint64_t v36 = v117;
  (*(void (**)(char *, uint64_t, uint64_t))(v117 + 16))(v27, a2, a3);
  uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  (*(void (**)(char *, uint64_t))(v36 + 8))(v27, a3);
  if (v37 < -128) {
    goto LABEL_25;
  }
LABEL_10:
  char v38 = v116(a3, a4);
  uint64_t v107 = a4 + 128;
  uint64_t v39 = v113(a3, a4);
  BOOL v102 = v21;
  if (v38)
  {
    if (v39 > 64) {
      goto LABEL_12;
    }
  }
  else if (v39 >= 64)
  {
LABEL_12:
    v119[0] = 128;
    char v42 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v43 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
    v42(v119, &type metadata for Int, v43, a3, a4);
    char v44 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v27, a2, a3);
    uint64_t v45 = v117;
    uint64_t v111 = *(void (**)(char *, uint64_t))(v117 + 8);
    v111(v27, a3);
    if (v44) {
      goto LABEL_25;
    }
    goto LABEL_16;
  }
  uint64_t v45 = v117;
  (*(void (**)(char *, uint64_t, uint64_t))(v117 + 16))(v27, a2, a3);
  uint64_t v46 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  uint64_t v111 = *(void (**)(char *, uint64_t))(v45 + 8);
  v111(v27, a3);
  if (v46 > 128) {
    goto LABEL_25;
  }
LABEL_16:
  uint64_t v101 = v7;
  unint64_t v47 = *(void (**)(char *, uint64_t, uint64_t))(v45 + 16);
  char v48 = v112;
  v47(v112, a2, a3);
  char v49 = v116(a3, a4);
  uint64_t v50 = v109;
  char v103 = (void (*)(char *, char *, uint64_t))v47;
  v47(v109, (uint64_t)v48, a3);
  if ((v49 & 1) == 0)
  {
    v111(v50, a3);
    goto LABEL_37;
  }
  uint64_t v51 = v113(a3, a4);
  v111(v50, a3);
  if (v51 <= 64) {
    goto LABEL_37;
  }
  char v52 = v102;
  v103(v102, v112, a3);
  v119[0] = 0x8000000000000000;
  uint64_t v53 = v116;
  if (v116(a3, a4))
  {
    uint64_t v54 = v113(a3, a4);
    if (v54 < 64)
    {
LABEL_32:
      v103(v27, v52, a3);
      uint64_t v71 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      BOOL v70 = v111;
      v111(v27, a3);
      if (v71 < v119[0]) {
LABEL_57:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
      goto LABEL_36;
    }
LABEL_28:
    uint64_t v67 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v68 = lazy protocol witness table accessor for type Int and conformance Int(v54, v55, v56);
    v67(v119, &type metadata for Int, v68, a3, a4);
    char v69 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v52, v27, a3);
    BOOL v70 = v111;
    v111(v27, a3);
    if (v69) {
      goto LABEL_57;
    }
    goto LABEL_36;
  }
  char v66 = v53(a3, a4);
  uint64_t v54 = v113(a3, a4);
  if ((v66 & 1) == 0)
  {
    if (v54 >= 64)
    {
      v111(v52, a3);
      goto LABEL_37;
    }
    goto LABEL_32;
  }
  if (v54 > 64) {
    goto LABEL_28;
  }
  uint64_t v72 = v101;
  uint64_t v73 = AssociatedTypeWitness;
  uint64_t v74 = swift_getAssociatedConformanceWitness(v101, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v75 = v105;
  (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v74 + 8))(&qword_18162B0B8, 256, v73, v74);
  (*(void (**)(char *, uint64_t, uint64_t))(v72 + 24))(v75, a3, v72);
  LOBYTE(v72) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v52, v27, a3);
  BOOL v70 = v111;
  v111(v27, a3);
  uint64_t v76 = v104;
  v103(v104, v52, a3);
  if (v72)
  {
    v70(v76, a3);
    goto LABEL_57;
  }
  uint64_t v77 = v119[0];
  uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v70(v76, a3);
  BOOL v79 = v78 < v77;
  char v52 = v102;
  if (v79) {
    goto LABEL_57;
  }
LABEL_36:
  v70(v52, a3);
LABEL_37:
  uint64_t v80 = v112;
  uint64_t v81 = v113;
  uint64_t v82 = v113(a3, a4);
  uint64_t v83 = v108;
  v103(v108, v80, a3);
  if (v82 < 65)
  {
    uint64_t v91 = v81(a3, a4);
    v111(v83, a3);
    if (v91 != 64 || (v116(a3, a4) & 1) != 0) {
      goto LABEL_50;
    }
  }
  else
  {
    v111(v83, a3);
  }
  v103(v110, v112, a3);
  v119[0] = 0x7FFFFFFFFFFFFFFFLL;
  char v84 = v116(a3, a4);
  uint64_t v85 = v113(a3, a4);
  if ((v84 & 1) == 0)
  {
    if (v85 >= 64)
    {
      uint64_t v118 = 0x7FFFFFFFFFFFFFFFLL;
      char v88 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
      unint64_t v89 = lazy protocol witness table accessor for type Int and conformance Int(v85, v86, v87);
      uint64_t v90 = &v118;
      goto LABEL_48;
    }
LABEL_47:
    v103(v27, v110, a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
    uint64_t v92 = v111;
    v111(v27, a3);
    v92(v110, a3);
    goto LABEL_50;
  }
  if (v85 <= 64) {
    goto LABEL_47;
  }
  char v88 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
  unint64_t v89 = lazy protocol witness table accessor for type Int and conformance Int(v85, v86, v87);
  uint64_t v90 = v119;
LABEL_48:
  v88(v90, &type metadata for Int, v89, a3, a4);
  char v93 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v27, v110, a3);
  v111(v27, a3);
  if (v93) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  v111(v110, a3);
LABEL_50:
  uint64_t v94 = v112;
  unint64_t v95 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
  v111(v94, a3);
  unint64_t v96 = *v114;
  unint64_t v97 = v114[1];
  if ((v95 & 0x8000000000000000) != 0)
  {
    if (v95 > 0xFFFFFFFFFFFFFF80)
    {
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      unint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)((unint64_t *)v119, v97, v96, v100);
      goto LABEL_53;
    }
  }
  else if (v95 < 0x80)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    unint64_t result = specialized _wideMaskedShiftLeft<A>(_:_:)(v119, v97, v96, v98);
LABEL_53:
    uint64_t v65 = v119[0];
    goto LABEL_54;
  }
LABEL_25:
  unint64_t result = 0;
  uint64_t v65 = 0;
LABEL_54:
  uint64_t v99 = v114;
  *uint64_t v114 = v65;
  v99[1] = result;
  return result;
}

Swift::UInt64 protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance _UInt128(void *a1, void *a2, unint64_t *a3)
{
  unint64_t v7 = *a3;
  unint64_t v6 = a3[1];
  v14.low = v3[1];
  v14.high = (Swift::UInt64)&v11;
  Swift::UInt64 result = specialized _wideDivide22<A>(_:by:)(&v13, &v12, v14, *v3, v6, v7);
  Swift::UInt64 v9 = v12;
  uint64_t v10 = v11;
  *a1 = v13;
  a1[1] = result;
  *a2 = v10;
  a2[1] = v9;
  return result;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance _UInt128(unint64_t *a1)
{
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  Swift::UInt64 v5 = *v1;
  Swift::UInt64 v4 = v1[1];
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  if (v3 == v7 && v2 == v6)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    BOOL v13 = v5 == v16;
    BOOL v15 = v4 == v17;
  }
  else
  {
    uint64_t v9 = specialized static _UInt128.% infix(_:_:)(v5, v4, v2, v3);
    uint64_t v11 = v10;
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    BOOL v13 = v9 == v12;
    BOOL v15 = v11 == v14;
  }
  return v15 && v13;
}

void protocol witness for BinaryInteger.signum() in conformance _UInt128(void *a1@<X8>)
{
  *a1 = *v1 != 0;
  a1[1] = 0;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance _UInt128(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void protocol witness for Strideable.distance(to:) in conformance _UInt128(unint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v5 = *a1;
  unint64_t v4 = a1[1];
  unint64_t v7 = *v2;
  unint64_t v6 = v2[1];
  BOOL v8 = *a1 < *v2;
  if (v4 != v6) {
    BOOL v8 = v4 < v6;
  }
  if (v8)
  {
    unint64_t v9 = v7 - v5;
    unint64_t v10 = v6 - v4;
    BOOL v11 = v6 < v4;
    if (v7 >= v5)
    {
      if (v11) {
        goto LABEL_13;
      }
      goto LABEL_15;
    }
    if (!v10) {
      LOBYTE(v11) = 1;
    }
    if (!v11)
    {
      --v10;
LABEL_15:
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      BOOL v13 = v15 < v9;
      if (v14 != v10) {
        BOOL v13 = v14 < v10;
      }
      if (v13) {
LABEL_28:
      }
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Distance is not representable in Int", 36, 2, "Swift/Integers.swift", 20, 2, 0x64AuLL, 0);
      BOOL v16 = __OFSUB__(0, v9);
      unint64_t v12 = -(uint64_t)v9;
      if (!v16) {
        goto LABEL_27;
      }
      __break(1u);
      goto LABEL_21;
    }
LABEL_13:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x5FuLL, 0);
  }
  unint64_t v12 = v5 - v7;
  unint64_t v10 = v4 - v6;
  BOOL v13 = v4 < v6;
  if (v5 < v7)
  {
    if (!v10) {
      LOBYTE(v13) = 1;
    }
    if (!v13)
    {
      --v10;
      goto LABEL_24;
    }
    goto LABEL_13;
  }
LABEL_21:
  if (v13) {
    goto LABEL_13;
  }
LABEL_24:
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  BOOL v19 = v18 < v12;
  if (v17 != v10) {
    BOOL v19 = v17 < v10;
  }
  if (v19) {
    goto LABEL_28;
  }
LABEL_27:
  *a2 = v12;
}

uint64_t *protocol witness for Strideable.advanced(by:) in conformance _UInt128@<X0>(uint64_t *result@<X0>, unint64_t *a2@<X8>)
{
  uint64_t v3 = *result;
  unint64_t v5 = *v2;
  unint64_t v4 = v2[1];
  if (*result < 0)
  {
    unint64_t v9 = -v3;
    BOOL v6 = v5 >= v9;
    unint64_t v7 = v5 - v9;
    uint64_t v10 = !v6;
    uint64_t v8 = v10 << 63 >> 63;
    if (!v4 && (v10 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x5FuLL, 0);
    }
  }
  else
  {
    BOOL v6 = __CFADD__(v5, v3);
    unint64_t v7 = v5 + v3;
    uint64_t v8 = v6;
    if (v4 == -1 && (v8 & 1) != 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x6BuLL, 0);
    }
  }
  *a2 = v7;
  a2[1] = v8 + v4;
  return result;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance _UInt128(uint64_t a1, uint64_t a2, char a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance _UInt128(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, void, void, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _Int128(uint64_t a1, uint64_t a2)
{
  return protocol witness for CustomStringConvertible.description.getter in conformance _UInt128(a1, a2, (uint64_t (*)(uint64_t, void, void, void))specialized BinaryInteger._description(radix:uppercase:));
}

uint64_t protocol witness for CustomStringConvertible.description.getter in conformance _UInt128(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, void, void, void))
{
  return a3(10, 0, *v3, v3[1]);
}

void *protocol witness for static AdditiveArithmetic.+ infix(_:_:) in conformance _Int128@<X0>(void *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  BOOL v5 = __CFADD__(*result, *a2);
  BOOL v6 = __OFADD__(v3, v4);
  uint64_t v7 = v3 + v4;
  if (v6 || (v5 ? (BOOL v8 = v7 == 0x7FFFFFFFFFFFFFFFLL) : (BOOL v8 = 0), v8)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x25EuLL, 0);
  }
  *a3 = *result + *a2;
  a3[1] = v7 + v5;
  return result;
}

void *protocol witness for static AdditiveArithmetic.+= infix(_:_:) in conformance _Int128(void *a1, uint64_t *a2)
{
  return specialized static _Int128.+= infix(_:_:)(a1, *a2, a2[1]);
}

unint64_t *protocol witness for static AdditiveArithmetic.- infix(_:_:) in conformance _Int128@<X0>(unint64_t *result@<X0>, unint64_t *a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t v4 = *result;
  unint64_t v3 = result[1];
  unint64_t v6 = *a2;
  unint64_t v5 = a2[1];
  BOOL v7 = __OFSUB__(v3, v5);
  unint64_t v8 = v3 - v5;
  int v9 = v7;
  BOOL v10 = v4 >= v6;
  unint64_t v11 = v4 - v6;
  if (v10)
  {
    if (v9) {
      goto LABEL_8;
    }
  }
  else
  {
    if (v8 == 0x8000000000000000) {
      LOBYTE(v9) = 1;
    }
    if (v9) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x252uLL, 0);
    --v8;
  }
  *a3 = v11;
  a3[1] = v8;
  return result;
}

unint64_t *protocol witness for static AdditiveArithmetic.-= infix(_:_:) in conformance _Int128(unint64_t *a1, uint64_t a2)
{
  return specialized static _Int128.-= infix(_:_:)(a1, *(void *)a2, *(void *)(a2 + 8));
}

uint64_t _Int128.init<A>(exactly:)(uint64_t (*a1)(char *, uint64_t), uint64_t a2, uint64_t a3)
{
  uint64_t v254 = a3;
  unint64_t v5 = *(int ***)(a3 + 24);
  v231 = (int **)v5[2];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v231, a2, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v6 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v229 = (char *)&v220 - v7;
  uint64_t v253 = *(void *)(a2 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  v221 = (char *)&v220 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  char v223 = (char *)&v220 - v11;
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  v232 = (char *)&v220 - v13;
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  v235 = (char *)&v220 - v15;
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  v236 = (char *)&v220 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v222 = (char *)&v220 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  v237 = (char *)&v220 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  v241 = (char *)&v220 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  v227 = (char *)&v220 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  v228 = (char *)&v220 - v27;
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  v245 = (char *)&v220 - v29;
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  v244 = (void (*)(char *, char *, uint64_t))((char *)&v220 - v31);
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  v251 = (char *)&v220 - v33;
  MEMORY[0x1F4188790](v32);
  v238 = (char *)&v220 - v34;
  char v35 = swift_getAssociatedTypeWitness(255, v5, a2, (uint64_t)&protocol requirements base descriptor for Numeric, associated type descriptor for Numeric.Magnitude);
  v249 = *(int ***)(swift_getAssociatedConformanceWitness((uint64_t)v5, a2, (uint64_t)v35, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Numeric)+ 16);
  uint64_t v36 = swift_getAssociatedTypeWitness(0, v249, (uint64_t)v35, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  MEMORY[0x1F4188790](v36);
  char v38 = (char *)&v220 - v37;
  uint64_t v39 = swift_checkMetadataState(0, (uint64_t)v35);
  uint64_t v40 = *(v39 - 1);
  uint64_t v41 = MEMORY[0x1F4188790](v39);
  v226 = (char *)&v220 - ((v42 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v43 = MEMORY[0x1F4188790](v41);
  v243 = (char *)&v220 - v44;
  uint64_t v45 = MEMORY[0x1F4188790](v43);
  unint64_t v47 = (char *)&v220 - v46;
  uint64_t v48 = MEMORY[0x1F4188790](v45);
  uint64_t v50 = (char *)&v220 - v49;
  MEMORY[0x1F4188790](v48);
  char v52 = (char *)&v220 - v51;
  uint64_t v53 = v5[7];
  v247 = a1;
  v248 = v5;
  ((void (*)(uint64_t, int **))v53)(a2, v5);
  uint64_t v250 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v254, a2, (uint64_t)v39, (uint64_t)&protocol requirements base descriptor for BinaryInteger, associated conformance descriptor for BinaryInteger.Numeric.Magnitude: BinaryInteger);
  uint64_t v55 = *(uint64_t (**)(uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v246 = AssociatedConformanceWitness;
  uint64_t v233 = v55;
  LOBYTE(a1) = ((uint64_t (*)(uint64_t *))v55)(v39);
  uint64_t v56 = *(void (**)(char *, char *, uint64_t *))(v40 + 16);
  uint64_t v252 = v52;
  uint64_t v242 = v56;
  v56(v50, v52, v39);
  v234 = v47;
  unint64_t v225 = v36;
  v224 = v38;
  if (a1)
  {
    uint64_t v57 = v249;
    uint64_t v58 = swift_getAssociatedConformanceWitness((uint64_t)v249, (uint64_t)v39, (uint64_t)v36, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v58 + 8))(&qword_18162B0B8, 256, v36, v58);
    ((void (*)(char *, uint64_t *, int **))v57[3])(v38, v39, v57);
    uint64_t v59 = swift_getAssociatedConformanceWitness((uint64_t)v248, v250, (uint64_t)v39, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v60 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v59 + 16))(v50, v47, v39, v59);
    uint64_t v61 = *(void (**)(char *, uint64_t *))(v40 + 8);
    v61(v47, v39);
    v61(v50, v39);
    if (v60)
    {
      uint64_t v62 = ((uint64_t (*)(char *, uint64_t *))v61)(v252, v39);
      uint64_t v65 = v253;
      uint64_t v66 = v250;
      goto LABEL_18;
    }
    v239 = v61;
    uint64_t v240 = v40;
  }
  else
  {
    v239 = *(void (**)(char *, uint64_t *))(v40 + 8);
    uint64_t v240 = v40;
    v239(v50, v39);
  }
  uint64_t v67 = v246;
  unint64_t v68 = *(uint64_t (**)(uint64_t *, uint64_t))(v246 + 128);
  char v69 = v252;
  uint64_t v70 = v68(v39, v246);
  uint64_t v71 = v243;
  v242(v243, v69, v39);
  uint64_t v72 = v249;
  if (v70 <= 63)
  {
    uint64_t v73 = v239;
    v239(v71, v39);
    uint64_t v65 = v253;
    uint64_t v74 = v248;
    uint64_t v66 = v250;
    goto LABEL_33;
  }
  unint64_t v256 = -1;
  char v75 = v233(v39, v67);
  uint64_t v76 = v68(v39, v67);
  uint64_t v66 = v250;
  if ((v75 & 1) == 0)
  {
    uint64_t v65 = v253;
    BOOL v79 = v234;
    if (v76 < 65)
    {
      (*(void (**)(char *, char *, uint64_t *))(v240 + 32))(v234, v71, v39);
      unint64_t v93 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v39, v67);
      uint64_t v94 = v79;
      uint64_t v73 = v239;
      v239(v94, v39);
      uint64_t v74 = v248;
      if (v256 >= v93) {
        goto LABEL_33;
      }
      goto LABEL_17;
    }
    goto LABEL_14;
  }
  uint64_t v65 = v253;
  BOOL v79 = v234;
  if (v76 >= 65)
  {
LABEL_14:
    char v88 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t *, uint64_t))(v67 + 96);
    unint64_t v89 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v76, v77, v78);
    v88(&v256, &type metadata for UInt64, v89, v39, v67);
    uint64_t v74 = v248;
    uint64_t v90 = swift_getAssociatedConformanceWitness((uint64_t)v248, v66, (uint64_t)v39, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
    char v91 = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v90 + 16))(v79, v71, v39, v90);
    uint64_t v92 = v79;
    uint64_t v73 = v239;
    v239(v92, v39);
    v73(v71, v39);
    if ((v91 & 1) == 0) {
      goto LABEL_33;
    }
LABEL_17:
    uint64_t v62 = ((uint64_t (*)(char *, uint64_t *))v73)(v252, v39);
LABEL_18:
    unint64_t v256 = -1;
    uint64_t v95 = v254;
    unint64_t v96 = *(void (**)(unint64_t *, ValueMetadata *))(v254 + 88);
    unint64_t v97 = lazy protocol witness table accessor for type UInt64 and conformance UInt64(v62, v63, v64);
    char v98 = v251;
    uint64_t v242 = (void (*)(char *, char *, uint64_t *))v97;
    v96(&v256, &type metadata for UInt64);
    uint64_t v99 = v238;
    char v100 = (char *)v247;
    (*(void (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t, uint64_t))(v95 + 192))(v247, v98, v66, v95);
    uint64_t v101 = *(uint64_t (**)(char *, uint64_t))(v65 + 8);
    uint64_t v102 = v101(v98, v66);
    unint64_t v256 = 64;
    char v103 = *(void (**)(void (*)(void, void), unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v95 + 240);
    unint64_t v106 = lazy protocol witness table accessor for type Int and conformance Int(v102, v104, v105);
    v103((void (*)(void, void))v100, &v256, &type metadata for Int, v106, v66, v95);
    v101(v100, v66);
    uint64_t v107 = *(char **)(v65 + 32);
    uint64_t v108 = v245;
    uint64_t v246 = v65 + 32;
    v243 = v107;
    ((void (*)(char *, char *, uint64_t))v107)(v245, v99, v66);
    v249 = *(int ***)(v95 + 64);
    uint64_t v250 = v95 + 64;
    if (((uint64_t (*)(uint64_t, uint64_t))v249)(v66, v95))
    {
      uint64_t v109 = v228;
      (*(void (**)(char *, char *, uint64_t))(v65 + 16))(v228, v108, v66);
      uint64_t v110 = v231;
      uint64_t v111 = AssociatedTypeWitness;
      uint64_t v112 = swift_getAssociatedConformanceWitness((uint64_t)v231, v66, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      unint64_t v113 = v229;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v112 + 8))(&qword_18162B0B8, 256, v111, v112);
      uint64_t v114 = v251;
      ((void (*)(char *, uint64_t, int **))v110[3])(v113, v66, v110);
      LOBYTE(v111) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v95 + 32) + 8) + 32))(v109, v114, v66);
      v101(v114, v66);
      if ((v111 & 1) == 0) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
      }
      v101(v109, v66);
      uint64_t v95 = v254;
      uint64_t v108 = v245;
    }
    uint64_t v115 = *(uint64_t (**)(uint64_t, uint64_t))(v95 + 128);
    uint64_t v252 = (char *)(v95 + 128);
    uint64_t v116 = v115(v66, v95);
    v248 = (int **)v115;
    if (v116 < 64)
    {
LABEL_38:
      uint64_t v142 = *(void (**)(char *, char *, uint64_t *))(v95 + 120);
      v245 = (char *)(v95 + 120);
      uint64_t v242 = v142;
      uint64_t v240 = ((uint64_t (*)(uint64_t, uint64_t))v142)(v66, v95);
      v101(v108, v66);
      uint64_t v143 = v241;
      ((void (*)(char *, void, uint64_t))v243)(v241, v244, v66);
      char v144 = ((uint64_t (*)(uint64_t, uint64_t))v249)(v66, v95);
      uint64_t v145 = v253 + 16;
      uint64_t v146 = *(void (**)(char *, char *, uint64_t))(v253 + 16);
      unint64_t v147 = v237;
      v146(v237, v143, v66);
      uint64_t v148 = v95;
      uint64_t v253 = v145;
      v244 = v146;
      if (v144)
      {
        uint64_t v149 = ((uint64_t (*)(uint64_t, uint64_t))v248)(v66, v95);
        v101(v147, v66);
        uint64_t v150 = v236;
        v146(v236, v143, v66);
        BOOL v157 = v149 < 65;
        uint64_t v151 = v143;
        if (!v157)
        {
          unint64_t v256 = 0x8000000000000000;
          uint64_t v152 = v249;
          if (((uint64_t (*)(uint64_t, uint64_t))v249)(v66, v148))
          {
            uint64_t v153 = ((uint64_t (*)(uint64_t, uint64_t))v248)(v66, v148);
            if (v153 < 64)
            {
              uint64_t v156 = ((uint64_t (*)(uint64_t, uint64_t))v242)(v66, v148);
              v101(v150, v66);
              BOOL v157 = v156 < (uint64_t)v256;
              uint64_t v151 = v241;
LABEL_74:
              uint64_t v158 = v235;
              if (!v157)
              {
LABEL_45:
                v247 = v101;
                v159 = v248;
                uint64_t v160 = ((uint64_t (*)(uint64_t, uint64_t))v248)(v66, v148);
                v161 = v244;
                v244(v158, v151, v66);
                if (v160 >= 65)
                {
                  uint64_t v162 = v148;
                  v247(v158, v66);
                  char v163 = v232;
                  v161(v232, v151, v66);
                  uint64_t v164 = v249;
                  goto LABEL_47;
                }
                uint64_t v179 = ((uint64_t (*)(uint64_t, uint64_t))v159)(v66, v148);
                v247(v158, v66);
                if (v179 == 64)
                {
                  uint64_t v162 = v148;
                  uint64_t v164 = v249;
                  char v180 = ((uint64_t (*)(uint64_t, uint64_t))v249)(v66, v148);
                  char v163 = v232;
                  v161(v232, v151, v66);
                  if ((v180 & 1) == 0)
                  {
LABEL_47:
                    unint64_t v256 = 0x7FFFFFFFFFFFFFFFLL;
                    char v165 = ((uint64_t (*)(uint64_t, uint64_t))v164)(v66, v162);
                    uint64_t v166 = ((uint64_t (*)(uint64_t, uint64_t))v248)(v66, v162);
                    if (v165)
                    {
                      if (v166 > 64)
                      {
                        v169 = v151;
                        uint64_t v170 = v254;
                        v171 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v254 + 96);
                        unint64_t v172 = lazy protocol witness table accessor for type Int64 and conformance Int64(v166, v167, v168);
                        unint64_t v173 = v163;
                        v174 = v251;
                        v171(&v256, &type metadata for Int64, v172, v66, v170);
                        uint64_t v175 = v170;
                        uint64_t v151 = v169;
                        v176 = (void (*)(char *, uint64_t))v247;
                        char v177 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v175 + 32)
                                                                                              + 8)
                                                                                  + 16))(v174, v173, v66);
                        v176(v174, v66);
                        char v178 = v173;
LABEL_58:
                        v176(v178, v66);
                        if (v177)
                        {
                          v176(v151, v66);
                          return 0;
                        }
                        ((void (*)(uint64_t, uint64_t))v242)(v66, v175);
LABEL_61:
                        v176(v151, v66);
                        return v240;
                      }
                    }
                    else if (v166 > 63)
                    {
                      uint64_t v255 = 0x7FFFFFFFFFFFFFFFLL;
                      v184 = v163;
                      v185 = v251;
                      uint64_t v186 = ((uint64_t (*)(char *, char *, uint64_t))v243)(v251, v184, v66);
                      v187 = v151;
                      uint64_t v188 = v254;
                      uint64_t v189 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v254 + 96);
                      unint64_t v192 = lazy protocol witness table accessor for type Int64 and conformance Int64(v186, v190, v191);
                      v193 = v223;
                      v189(&v255, &type metadata for Int64, v192, v66, v188);
                      uint64_t v175 = v188;
                      uint64_t v151 = v187;
                      v176 = (void (*)(char *, uint64_t))v247;
                      char v177 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v175 + 32)
                                                                                            + 8)
                                                                                + 16))(v193, v185, v66);
                      v176(v193, v66);
                      char v178 = v185;
                      goto LABEL_58;
                    }
                    unint64_t v181 = v251;
                    ((void (*)(char *, char *, uint64_t))v243)(v251, v163, v66);
                    uint64_t v182 = v254;
                    v183 = (void (*)(uint64_t, uint64_t))v242;
                    ((void (*)(uint64_t, uint64_t))v242)(v66, v254);
                    v176 = (void (*)(char *, uint64_t))v247;
                    v247(v181, v66);
                    v183(v66, v182);
                    goto LABEL_61;
                  }
                }
                else
                {
                  uint64_t v162 = v148;
                  char v163 = v232;
                  v161(v232, v151, v66);
                }
                v176 = (void (*)(char *, uint64_t))v247;
                v247(v163, v66);
                ((void (*)(uint64_t, uint64_t))v242)(v66, v162);
                goto LABEL_61;
              }
LABEL_76:
              v101(v151, v66);
              return 0;
            }
            char v206 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v254 + 96);
            unint64_t v207 = lazy protocol witness table accessor for type Int64 and conformance Int64(v153, v154, v155);
            v208 = v251;
            v206(&v256, &type metadata for Int64, v207, v66, v254);
            uint64_t v148 = v254;
            char v205 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v254 + 32) + 8) + 16))(v150, v208, v66);
            v101(v208, v66);
            v101(v150, v66);
            uint64_t v151 = v241;
          }
          else
          {
            char v194 = ((uint64_t (*)(uint64_t, uint64_t))v152)(v66, v148);
            uint64_t v195 = v148;
            char v196 = v194;
            uint64_t v197 = ((uint64_t (*)(uint64_t, uint64_t))v248)(v66, v195);
            if ((v196 & 1) == 0)
            {
              uint64_t v151 = v241;
              if (v197 >= 64)
              {
                v101(v150, v66);
                uint64_t v148 = v254;
                uint64_t v158 = v235;
                goto LABEL_45;
              }
              uint64_t v148 = v254;
              uint64_t v209 = ((uint64_t (*)(uint64_t, uint64_t))v242)(v66, v254);
              v101(v150, v66);
              BOOL v157 = v209 < (uint64_t)v256;
              goto LABEL_74;
            }
            uint64_t v151 = v241;
            if (v197 <= 64)
            {
              uint64_t v210 = v231;
              v211 = AssociatedTypeWitness;
              uint64_t v212 = swift_getAssociatedConformanceWitness((uint64_t)v231, v66, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
              v213 = v229;
              (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v212 + 8))(&qword_18162B0B8, 256, v211, v212);
              v214 = v210;
              v215 = v210[3];
              uint64_t v216 = v251;
              ((void (*)(char *, uint64_t, int **))v215)(v213, v66, v214);
              LOBYTE(v211) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v254 + 32)
                                                                                            + 8)
                                                                                + 16))(v150, v216, v66);
              v101(v216, v66);
              v217 = v221;
              ((void (*)(char *, char *, uint64_t))v243)(v221, v150, v66);
              if (v211)
              {
                v101(v217, v66);
                goto LABEL_76;
              }
              int64_t v218 = v256;
              uint64_t v219 = ((uint64_t (*)(uint64_t, uint64_t))v242)(v66, v254);
              v101(v217, v66);
              BOOL v157 = v219 < v218;
              uint64_t v148 = v254;
              goto LABEL_74;
            }
            v200 = v150;
            uint64_t v201 = v254;
            v202 = *(void (**)(unint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v254 + 96);
            unint64_t v203 = lazy protocol witness table accessor for type Int64 and conformance Int64(v197, v198, v199);
            v204 = v251;
            v202(&v256, &type metadata for Int64, v203, v66, v201);
            uint64_t v148 = v201;
            uint64_t v151 = v241;
            char v205 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v201 + 32) + 8) + 16))(v200, v204, v66);
            v101(v204, v66);
            v101(v200, v66);
          }
          uint64_t v158 = v235;
          if ((v205 & 1) == 0) {
            goto LABEL_45;
          }
          goto LABEL_76;
        }
      }
      else
      {
        v101(v147, v66);
        uint64_t v150 = v236;
        v146(v236, v143, v66);
        uint64_t v151 = v143;
      }
      v101(v150, v66);
      uint64_t v158 = v235;
      goto LABEL_45;
    }
    uint64_t v117 = *(void (**)(char *, char *, uint64_t))(v253 + 16);
    uint64_t v118 = v227;
    v117(v227, v108, v66);
    unint64_t v256 = -1;
    char v119 = ((uint64_t (*)(uint64_t, uint64_t))v249)(v66, v95);
    uint64_t v120 = v115(v66, v95);
    if (v119)
    {
      if (v120 < 65)
      {
        uint64_t v121 = v231;
        char v122 = AssociatedTypeWitness;
        uint64_t v123 = swift_getAssociatedConformanceWitness((uint64_t)v231, v66, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        unint64_t v124 = v229;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v123 + 8))(&qword_18162B0B8, 256, v122, v123);
        uint64_t v125 = v251;
        ((void (*)(char *, uint64_t, int **))v121[3])(v124, v66, v121);
        uint64_t v126 = v254;
        LOBYTE(v122) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v254 + 32) + 8)
                                                                          + 40))(v118, v125, v66);
        v101(v125, v66);
        unint64_t v127 = v256;
        char v128 = v222;
        v117(v222, v118, v66);
        if ((v122 & 1) == 0)
        {
          v101(v128, v66);
          uint64_t v108 = v245;
LABEL_37:
          v101(v118, v66);
          uint64_t v95 = v254;
          goto LABEL_38;
        }
        unint64_t v129 = (*(uint64_t (**)(uint64_t, uint64_t))(v126 + 120))(v66, v126);
        v101(v128, v66);
        BOOL v130 = v127 >= v129;
LABEL_30:
        uint64_t v108 = v245;
        if (!v130) {
          goto LABEL_31;
        }
        goto LABEL_37;
      }
    }
    else if (v120 < 65)
    {
      unint64_t v134 = v251;
      v117(v251, v118, v66);
      unint64_t v135 = (*(uint64_t (**)(uint64_t))(v254 + 120))(v66);
      v101(v134, v66);
      BOOL v130 = v256 >= v135;
      goto LABEL_30;
    }
    uint64_t v131 = v254;
    uint64_t v132 = v251;
    (*(void (**)(unint64_t *, ValueMetadata *, void (*)(char *, char *, uint64_t *), uint64_t, uint64_t))(v254 + 96))(&v256, &type metadata for UInt64, v242, v66, v254);
    char v133 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v131 + 32) + 8) + 16))(v132, v118, v66);
    v101(v132, v66);
    uint64_t v108 = v245;
    if (v133) {
LABEL_31:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
    goto LABEL_37;
  }
  uint64_t v80 = (uint64_t)v225;
  uint64_t v81 = swift_getAssociatedConformanceWitness((uint64_t)v72, (uint64_t)v39, (uint64_t)v225, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
  uint64_t v82 = v224;
  (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v81 + 8))(&qword_18162B0B8, 256, v80, v81);
  ((void (*)(char *, uint64_t *, int **))v72[3])(v82, v39, v72);
  uint64_t v74 = v248;
  uint64_t v83 = swift_getAssociatedConformanceWitness((uint64_t)v248, v66, (uint64_t)v39, (uint64_t)&protocol requirements base descriptor for Numeric, associated conformance descriptor for Numeric.Numeric.Magnitude: Comparable);
  LODWORD(v249) = (*(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v83 + 40))(v71, v79, v39, v83);
  uint64_t v84 = v240;
  uint64_t v85 = v79;
  uint64_t v73 = v239;
  v239(v85, v39);
  uint64_t v242 = (void (*)(char *, char *, uint64_t *))v256;
  uint64_t v86 = v226;
  (*(void (**)(char *, char *, uint64_t *))(v84 + 32))(v226, v71, v39);
  if ((v249 & 1) == 0)
  {
    v73(v86, v39);
    uint64_t v67 = v246;
    goto LABEL_33;
  }
  uint64_t v67 = v246;
  unint64_t v87 = (*(uint64_t (**)(uint64_t *, uint64_t))(v246 + 120))(v39, v246);
  v73(v86, v39);
  if ((unint64_t)v242 < v87) {
    goto LABEL_17;
  }
LABEL_33:
  v136 = v252;
  uint64_t v137 = (*(uint64_t (**)(uint64_t *, uint64_t))(v67 + 120))(v39, v67);
  v73(v136, v39);
  uint64_t v138 = v251;
  (*((void (**)(uint64_t))v74[1] + 2))(v66);
  v139 = v247;
  LOBYTE(v136) = (*(uint64_t (**)(uint64_t (*)(char *, uint64_t), char *, uint64_t))(*(void *)(*(void *)(v254 + 32) + 8) + 16))(v247, v138, v66);
  v140 = *(void (**)(uint64_t (*)(char *, uint64_t), uint64_t))(v65 + 8);
  v140(v139, v66);
  v140((uint64_t (*)(char *, uint64_t))v138, v66);
  if (v136) {
    return -v137;
  }
  else {
    return v137;
  }
}

Swift::tuple_partialValue__Int128_overflow_Bool __swiftcall _Int128.multipliedReportingOverflow(by:)(Swift::_Int128 by)
{
  if (v2)
  {
    if (!by.high)
    {
      int64_t v4 = (unsigned __int128)-(__int128)__PAIR128__(v3, v1) >> 64;
      by.high = 0;
      if (v2 >= 0)
      {
        LODWORD(v4) = 0;
      }
      else
      {
        unint64_t v1 = -(uint64_t)v1;
        int64_t v2 = v4;
        LODWORD(v4) = by.low != 0;
      }
      goto LABEL_19;
    }
    if (((v2 ^ by.high) & 0x8000000000000000) == 0)
    {
      if (v2 < 0)
      {
LABEL_17:
        int64_t v4 = ((unint64_t)v2 ^ by.high) >> 63;
        BOOL v5 = v1 == 0;
        unint64_t v1 = -(uint64_t)v1;
        int64_t v2 = -(v2 + !v5);
        if ((by.high & 0x8000000000000000) == 0) {
          goto LABEL_19;
        }
        goto LABEL_18;
      }
      goto LABEL_9;
    }
    if (v2 < 0) {
      goto LABEL_17;
    }
    LODWORD(v4) = 1;
    if ((by.high & 0x8000000000000000) == 0) {
      goto LABEL_19;
    }
  }
  else
  {
    if ((by.high & 0x8000000000000000) == 0 || !v1)
    {
LABEL_9:
      LODWORD(v4) = 0;
      if ((by.high & 0x8000000000000000) == 0) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }
    int64_t v2 = 0;
    LODWORD(v4) = 1;
  }
LABEL_18:
  BOOL v5 = by.low == 0;
  by.low = -by.low;
  by.high = -(by.high + !v5);
LABEL_19:
  BOOL v6 = !is_mul_ok(v2, by.low);
  BOOL v7 = !is_mul_ok(v1, by.high);
  BOOL v8 = __CFADD__(v2 * by.low, v1 * by.high);
  Swift::UInt64 v9 = v1 * by.low;
  uint64_t v10 = (*(_OWORD *)&by * __PAIR128__(v2, v1)) >> 64;
  BOOL v11 = __CFADD__(v2 * by.low + v1 * by.high, (v1 * (unsigned __int128)by.low) >> 64);
  if (by.high) {
    BOOL v12 = v2 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12 || v6 || v7 || v8)
  {
    if (v4)
    {
      uint64_t v13 = -v10;
      BOOL v11 = 1;
      BOOL v5 = v9 == 0;
      uint64_t v14 = -(uint64_t)v9;
      if (v5) {
        goto LABEL_40;
      }
      goto LABEL_39;
    }
  }
  else
  {
    if (v4)
    {
      uint64_t v13 = -v10;
      BOOL v5 = v9 == 0;
      uint64_t v14 = -(uint64_t)v9;
      if (v5)
      {
LABEL_40:
        BOOL v5 = v14 != 0;
        uint64_t v15 = v14 - 1;
        uint64_t v16 = !v5;
        unsigned long long v17 = __PAIR128__(v13, v15) + __PAIR128__(v16 << 63 >> 63, 1);
        uint64_t v10 = (__PAIR128__(v13, v15) + __PAIR128__(v16 << 63 >> 63, 1)) >> 64;
        Swift::UInt64 v9 = v17;
        if (v11) {
          goto LABEL_44;
        }
LABEL_46:
        char v18 = v4 ^ (v10 < 0);
        goto LABEL_47;
      }
LABEL_39:
      --v13;
      goto LABEL_40;
    }
    if (!v11) {
      goto LABEL_46;
    }
  }
LABEL_44:
  char v18 = 1;
LABEL_47:
  Swift::UInt64 v19 = v9;
  Swift::Int64 v20 = v10;
  result.partialValue.high = v20;
  result.partialValue.low = v19;
  result.overflow = v18;
  return result;
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance _Int128@<X0>(uint64_t a1@<X8>)
{
  return protocol witness for Numeric.init<A>(exactly:) in conformance _UInt128((uint64_t (*)(void))_Int128.init<A>(exactly:), a1);
}

uint64_t protocol witness for Numeric.init<A>(exactly:) in conformance _UInt128@<X0>(uint64_t (*a1)(void)@<X5>, uint64_t a2@<X8>)
{
  uint64_t result = a1();
  *(void *)a2 = result;
  *(void *)(a2 + 8) = v4;
  *(unsigned char *)(a2 + 16) = v5 & 1;
  return result;
}

void protocol witness for Numeric.magnitude.getter in conformance _Int128(void *a1@<X8>)
{
  uint64_t v3 = *v2;
  uint64_t v4 = v2[1];
  uint64_t v5 = (unsigned __int128)-(__int128)__PAIR128__(v1, *v2) >> 64;
  if (v4 < 0)
  {
    uint64_t v3 = -*v2;
    uint64_t v4 = v5;
  }
  *a1 = v3;
  a1[1] = v4;
}

uint64_t protocol witness for static Numeric.* infix(_:_:) in conformance _Int128@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for static Numeric.* infix(_:_:) in conformance _UInt128(a1, a2, (uint64_t (*)(void, void, void, void))specialized static _Int128.* infix(_:_:), a3);
}

uint64_t protocol witness for static Numeric.* infix(_:_:) in conformance _UInt128@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t (*a3)(void, void, void, void)@<X4>, uint64_t *a4@<X8>)
{
  uint64_t result = a3(*a1, a1[1], *a2, a2[1]);
  *a4 = result;
  a4[1] = v6;
  return result;
}

uint64_t protocol witness for static Numeric.*= infix(_:_:) in conformance _Int128(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Numeric.*= infix(_:_:) in conformance _Int128(a1, a2, a3, a4, (uint64_t (*)(void, void, uint64_t, uint64_t))_Int128.multipliedReportingOverflow(by:), "Overflow in *=", 0x2A0uLL);
}

uint64_t *protocol witness for ExpressibleByIntegerLiteral.init(integerLiteral:) in conformance _Int128@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2 = *result >> 63;
  *a2 = *result;
  a2[1] = v2;
  return result;
}

uint64_t _UInt128.Words.subscript.getter(unint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a1 >= 2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Word index out of range", 23, 2, "Swift/LegacyInt128.swift", 24, 2, a4, 0);
  }
  if (a1) {
    return a3;
  }
  else {
    return a2;
  }
}

uint64_t (*protocol witness for Collection.subscript.read in conformance _Int128.Words(uint64_t *a1, unint64_t *a2))()
{
  *a1 = _UInt128.Words.subscript.getter(*a2, *v2, v2[1], 0x2BEuLL);
  return EnumeratedSequence._base.modify;
}

__n128 protocol witness for Collection.subscript.getter in conformance _UInt128.Words@<Q0>(unint64_t *a1@<X0>, __n128 *a2@<X8>)
{
  if ((*a1 & 0x8000000000000000) != 0 || (uint64_t v3 = a1[1], v3 >= 3)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  }
  a2->n128_u64[0] = *a1;
  a2->n128_u64[1] = v3;
  __n128 result = *v2;
  a2[1] = *v2;
  return result;
}

void *protocol witness for Sequence._copyToContiguousArray() in conformance _Int128.Words()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0, v0[1]);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance _Int128.Words(void *a1, void *a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3, v3[1]);
}

Swift::tuple_partialValue__Int128_overflow_Bool __swiftcall _Int128.multipliedReportingOverflow(by:)(Swift::UInt64 by)
{
  BOOL v5 = by != 0;
  uint64_t v6 = -(uint64_t)v1;
  unint64_t v7 = (unsigned __int128)-(__int128)__PAIR128__(v3, v1) >> 64;
  if (v2 >= 0)
  {
    uint64_t v6 = v1;
    unint64_t v7 = v2;
    BOOL v5 = 0;
  }
  uint64_t v8 = (v7 * (unsigned __int128)by) >> 64;
  Swift::UInt64 v9 = v7 * by;
  Swift::UInt64 v10 = v6 * by;
  uint64_t v11 = ((unint64_t)v6 * (unsigned __int128)by) >> 64;
  Swift::Int64 v12 = v9 + v11;
  BOOL v13 = __CFADD__(v9, v11);
  if (v8)
  {
    if (v5)
    {
      Swift::Int64 v14 = -v12;
      BOOL v13 = 1;
      uint64_t v15 = -(uint64_t)v10;
      if (!v10)
      {
LABEL_13:
        BOOL v16 = v15 != 0;
        uint64_t v17 = v15 - 1;
        uint64_t v18 = !v16;
        Swift::Int64 v12 = (__PAIR128__(v14, v17) + __PAIR128__(v18 << 63 >> 63, 1)) >> 64;
        Swift::UInt64 v10 = v17 + 1;
        if (v13) {
          goto LABEL_17;
        }
LABEL_19:
        char v19 = v5 ^ (v12 < 0);
        goto LABEL_20;
      }
LABEL_12:
      --v14;
      goto LABEL_13;
    }
  }
  else
  {
    if (v5)
    {
      Swift::Int64 v14 = -v12;
      uint64_t v15 = -(uint64_t)v10;
      if (!v10) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
    if (!v13) {
      goto LABEL_19;
    }
  }
LABEL_17:
  char v19 = 1;
LABEL_20:
  result.partialValue.high = v12;
  result.partialValue.low = v10;
  result.overflow = v19;
  return result;
}

Swift::tuple_quotient__Int128_remainder__Int128 __swiftcall _Int128.quotientAndRemainder(dividingBy:)(Swift::_Int128 dividingBy)
{
  Swift::UInt64 low = v1.low;
  Swift::UInt64 v4 = (unsigned __int128)-(__int128)__PAIR128__(v2, v1.high) >> 64;
  int v5 = (v1.low & 0x8000000000000000) != 0;
  if ((v1.low & 0x8000000000000000) == 0) {
    Swift::UInt64 high = v1.high;
  }
  else {
    Swift::UInt64 high = -v1.high;
  }
  if ((v1.low & 0x8000000000000000) != 0) {
    v1.Swift::UInt64 low = v4;
  }
  Swift::Int64 v7 = (unsigned __int128)-(__int128)__PAIR128__(v4, dividingBy.low) >> 64;
  int v8 = dividingBy.high < 0;
  if (dividingBy.high >= 0) {
    Swift::UInt64 v9 = dividingBy.low;
  }
  else {
    Swift::UInt64 v9 = -dividingBy.low;
  }
  if (dividingBy.high >= 0) {
    Swift::Int64 v10 = dividingBy.high;
  }
  else {
    Swift::Int64 v10 = v7;
  }
  v1.Swift::UInt64 high = (Swift::UInt64)&v15;
  Swift::Int64 v11 = specialized _wideDivide22<A>(_:by:)((Swift::UInt64 *)&v17, (Swift::UInt64 *)&v16, v1, high, v10, v9);
  Swift::Int64 v13 = v16;
  Swift::UInt64 v12 = v17;
  Swift::UInt64 v14 = v15;
  if (v8 == v5)
  {
    if (v11 < 0) {
      goto LABEL_31;
    }
    if ((low & 0x8000000000000000) == 0) {
      goto LABEL_19;
    }
  }
  else
  {
    if (v11 == 0x8000000000000000 && !v17)
    {
      Swift::Int64 v11 = 0x8000000000000000;
      if ((low & 0x8000000000000000) != 0) {
        goto LABEL_26;
      }
LABEL_19:
      if ((v16 & 0x8000000000000000) == 0) {
        goto LABEL_32;
      }
LABEL_31:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
    }
    if (v11 < 0) {
      goto LABEL_31;
    }
    Swift::UInt64 v12 = -v17;
    if (v17) {
      Swift::Int64 v11 = ~v11;
    }
    else {
      Swift::Int64 v11 = -v11;
    }
    if ((low & 0x8000000000000000) == 0) {
      goto LABEL_19;
    }
  }
LABEL_26:
  if (v16 < 0) {
    goto LABEL_31;
  }
  Swift::UInt64 v14 = -(uint64_t)v15;
  if (v15) {
    Swift::Int64 v13 = ~v16;
  }
  else {
    Swift::Int64 v13 = -v16;
  }
LABEL_32:
  result.remainder.Swift::UInt64 high = v13;
  result.remainder.Swift::UInt64 low = v14;
  result.quotient.Swift::UInt64 high = v11;
  result.quotient.Swift::UInt64 low = v12;
  return result;
}

Swift::tuple_partialValue__Int128_overflow_Bool __swiftcall _Int128.remainderReportingOverflow(dividingBy:)(Swift::_Int128 dividingBy)
{
  Swift::UInt64 low = v1.low;
  if (dividingBy.high == -1)
  {
    if (dividingBy.low == -1 && v1.low == 0x8000000000000000 && !v1.high)
    {
      Swift::UInt64 low = 0;
      char v4 = 1;
      goto LABEL_38;
    }
  }
  else if (!dividingBy.high && !dividingBy.low)
  {
    char v4 = 1;
    goto LABEL_38;
  }
  Swift::UInt64 v5 = (unsigned __int128)-(__int128)__PAIR128__(v2, v1.high) >> 64;
  int v6 = (v1.low & 0x8000000000000000) != 0;
  if ((v1.low & 0x8000000000000000) == 0) {
    Swift::UInt64 high = v1.high;
  }
  else {
    Swift::UInt64 high = -v1.high;
  }
  if ((v1.low & 0x8000000000000000) != 0) {
    v1.Swift::UInt64 low = v5;
  }
  Swift::Int64 v8 = (unsigned __int128)-(__int128)__PAIR128__(v5, dividingBy.low) >> 64;
  int v9 = dividingBy.high < 0;
  if (dividingBy.high >= 0) {
    Swift::UInt64 v10 = dividingBy.low;
  }
  else {
    Swift::UInt64 v10 = -dividingBy.low;
  }
  if (dividingBy.high >= 0) {
    Swift::Int64 v11 = dividingBy.high;
  }
  else {
    Swift::Int64 v11 = v8;
  }
  v1.Swift::UInt64 high = (Swift::UInt64)&v18;
  Swift::UInt64 v12 = specialized _wideDivide22<A>(_:by:)(&v20, (Swift::UInt64 *)&v19, v1, high, v11, v10);
  v1.Swift::UInt64 high = v18;
  if (v9 == v6)
  {
    if ((v12 & 0x8000000000000000) != 0) {
      goto LABEL_39;
    }
  }
  else
  {
    BOOL v14 = v12 != 0x8000000000000000 || v20 != 0;
    if ((v12 & 0x8000000000000000) != 0 && v14) {
      goto LABEL_39;
    }
  }
  if ((low & 0x8000000000000000) == 0)
  {
    if ((v19 & 0x8000000000000000) == 0)
    {
      char v4 = 0;
      Swift::UInt64 low = v19;
      goto LABEL_38;
    }
LABEL_39:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
  }
  if (v19 < 0) {
    goto LABEL_39;
  }
  char v4 = 0;
  v1.Swift::UInt64 high = -(uint64_t)v18;
  if (v18) {
    Swift::UInt64 low = ~v19;
  }
  else {
    Swift::UInt64 low = -v19;
  }
LABEL_38:
  Swift::UInt64 v15 = v1.high;
  Swift::Int64 v16 = low;
  Swift::Bool v17 = v4;
  result.partialValue.Swift::UInt64 high = v16;
  result.partialValue.Swift::UInt64 low = v15;
  result.overfSwift::UInt64 low = v17;
  return result;
}

Swift::tuple_high__Int128_low__UInt128 __swiftcall _Int128.multipliedFullWidth(by:)(Swift::_Int128 by)
{
  unint64_t v4 = v1;
  if (v2)
  {
    unint64_t v5 = v2;
    if (by.high)
    {
      BOOL v6 = ((v2 ^ by.high) & 0x8000000000000000) == 0;
      if ((v2 & 0x8000000000000000) == 0) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }
    if ((v2 & 0x8000000000000000) != 0)
    {
      BOOL v6 = 0;
LABEL_11:
      unint64_t v4 = -(uint64_t)v1;
      unint64_t v5 = (unsigned __int128)-(__int128)__PAIR128__(v2, v1) >> 64;
LABEL_12:
      Swift::Int64 v8 = (unsigned __int128)-(__int128)__PAIR128__(v3, by.low) >> 64;
      if (by.high >= 0)
      {
        Swift::Int64 high = by.high;
      }
      else
      {
        by.Swift::UInt64 low = -by.low;
        Swift::Int64 high = v8;
      }
      goto LABEL_15;
    }
    Swift::Int64 high = 0;
    BOOL v6 = 1;
  }
  else
  {
    if (by.high)
    {
      unint64_t v5 = 0;
      BOOL v6 = by.high >= 0;
      goto LABEL_12;
    }
    Swift::Int64 high = 0;
    unint64_t v5 = 0;
    BOOL v6 = 1;
  }
LABEL_15:
  Swift::UInt64 v9 = (__PAIR128__(high, by.low) * __PAIR128__(v5, v4)) >> 64;
  BOOL v10 = __CFADD__((__PAIR128__(v5, v4) * by.low) >> 64, v4 * high);
  BOOL v11 = __CFADD__((v4 * (unsigned __int128)by.low) >> 64, v5 * by.low);
  Swift::UInt64 v12 = v4 * by.low;
  uint64_t v13 = (v5 * (unsigned __int128)by.low) >> 64;
  Swift::Int64 v14 = v5 * high;
  unint64_t v15 = (v5 * (unsigned __int128)(unint64_t)high) >> 64;
  unint64_t v16 = v13 + ((v4 * (unsigned __int128)(unint64_t)high) >> 64);
  if (__CFADD__(v11, v14) | __CFADD__(v10, v11 + v14)) {
    uint64_t v17 = 1;
  }
  else {
    uint64_t v17 = 0;
  }
  Swift::Int64 v19 = (__PAIR128__(v17, v16) + __PAIR128__(v15, v10 + (unint64_t)v11 + v14)) >> 64;
  Swift::UInt64 v18 = v16 + v10 + v11 + v14;
  if (!v6)
  {
    Swift::UInt64 v20 = -(uint64_t)v9;
    if (v12) {
      Swift::UInt64 v20 = ~v9;
    }
    uint64_t v21 = -(uint64_t)v12 - 1;
    Swift::UInt64 v9 = (__PAIR128__(v20, v12) - 1) >> 64;
    Swift::UInt64 v12 = -(uint64_t)v12;
    BOOL v22 = v21 == -1;
    if (v9 == -1)
    {
      uint64_t v23 = v21 == -1;
    }
    else
    {
      if (v21 != -1)
      {
        BOOL v22 = 0;
        BOOL v25 = 0;
        Swift::Int64 v24 = -v19;
        uint64_t v26 = -(uint64_t)v18;
        if (!v18) {
          goto LABEL_30;
        }
        goto LABEL_29;
      }
      BOOL v22 = 0;
      uint64_t v23 = 1;
    }
    v9 += v23;
    Swift::Int64 v24 = -v19;
    BOOL v25 = v22;
    uint64_t v26 = -(uint64_t)v18;
    if (!v18)
    {
LABEL_30:
      Swift::Int64 v19 = (__PAIR128__(v24, v26 - 1) + __PAIR128__((uint64_t)((unint64_t)(v26 == 0) << 63) >> 63, v25)) >> 64;
      Swift::UInt64 v18 = v26 - 1 + v25;
      goto LABEL_34;
    }
LABEL_29:
    --v24;
    BOOL v25 = v22;
    goto LABEL_30;
  }
LABEL_34:
  result.low.Swift::Int64 high = v9;
  result.low.Swift::UInt64 low = v12;
  result.high.Swift::Int64 high = v19;
  result.high.Swift::UInt64 low = v18;
  return result;
}

Swift::tuple_quotient__Int128_remainder__Int128 __swiftcall _Int128.dividingFullWidth(_:)(Swift::tuple_high__Int128_low__UInt128 a1)
{
  uint64_t high = a1.low.high;
  Swift::UInt64 low = a1.low.low;
  Swift::Int64 v6 = a1.high.high;
  Swift::UInt64 v7 = a1.high.low;
  if (a1.high.high < 0)
  {
    Swift::Int64 v8 = -a1.high.high;
    if (a1.high.low)
    {
      Swift::Int64 v8 = ~a1.high.high;
      uint64_t v9 = 0;
    }
    else
    {
      uint64_t v9 = 1;
    }
    uint64_t v3 = v9 << 63 >> 63;
    if (a1.low.low) {
      Swift::UInt64 v10 = ~a1.low.high;
    }
    else {
      Swift::UInt64 v10 = -a1.low.high;
    }
    Swift::UInt64 v13 = -a1.low.low - 1;
    uint64_t v11 = (__PAIR128__(v10, a1.low.low) - 1) >> 64;
    BOOL v12 = __CFADD__(v13, 1);
    Swift::UInt64 low = -a1.low.low;
    LODWORD(v13) = v13 == -1;
    uint64_t high = ((uint64_t)((unint64_t)(a1.low.low == 0) << 63) >> 63) + v12 + v10;
    if (v11 == -1) {
      Swift::UInt64 v13 = v13;
    }
    else {
      Swift::UInt64 v13 = 0;
    }
    a1.low.uint64_t high = (__PAIR128__(v8, -a1.high.low - 1) + __PAIR128__(v3, v13)) >> 64;
    Swift::UInt64 v7 = -a1.high.low - 1 + v13;
  }
  else
  {
    a1.low.uint64_t high = a1.high.high;
  }
  int v14 = a1.high.high < 0;
  unint64_t v15 = -(uint64_t)v1;
  Swift::UInt64 v16 = (unsigned __int128)-(__int128)__PAIR128__(v3, v1) >> 64;
  int v17 = v2 < 0;
  if (v2 < 0)
  {
    Swift::UInt64 v18 = v16;
  }
  else
  {
    unint64_t v15 = v1;
    Swift::UInt64 v18 = v2;
  }
  a1.low.Swift::UInt64 low = (Swift::UInt64)&v23;
  Swift::Int64 v19 = specialized _wideDivide42<A>(_:by:)((Swift::UInt64 *)&v25, (Swift::UInt64 *)&v24, (Swift::tuple_high_UInt64_low_UInt64)a1.low, v7, high, low, v18, v15);
  Swift::Int64 v21 = v24;
  Swift::UInt64 v20 = v25;
  Swift::UInt64 v22 = v23;
  if (v14 == v17)
  {
    if (v19 < 0) {
      goto LABEL_35;
    }
    if ((v6 & 0x8000000000000000) == 0) {
      goto LABEL_23;
    }
  }
  else
  {
    if (v19 == 0x8000000000000000 && !v25)
    {
      Swift::Int64 v19 = 0x8000000000000000;
      if (v6 < 0) {
        goto LABEL_30;
      }
LABEL_23:
      if ((v24 & 0x8000000000000000) == 0) {
        goto LABEL_36;
      }
LABEL_35:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
    }
    if (v19 < 0) {
      goto LABEL_35;
    }
    Swift::UInt64 v20 = -v25;
    if (v25) {
      Swift::Int64 v19 = ~v19;
    }
    else {
      Swift::Int64 v19 = -v19;
    }
    if ((v6 & 0x8000000000000000) == 0) {
      goto LABEL_23;
    }
  }
LABEL_30:
  if (v24 < 0) {
    goto LABEL_35;
  }
  Swift::UInt64 v22 = -(uint64_t)v23;
  if (v23) {
    Swift::Int64 v21 = ~v24;
  }
  else {
    Swift::Int64 v21 = -v24;
  }
LABEL_36:
  result.remainder.uint64_t high = v21;
  result.remainder.Swift::UInt64 low = v22;
  result.quotient.uint64_t high = v19;
  result.quotient.Swift::UInt64 low = v20;
  return result;
}

double protocol witness for static FixedWidthInteger.max.getter in conformance _Int128@<D0>(_OWORD *a1@<X8>)
{
  double result = NAN;
  *a1 = xmmword_18162B000;
  return result;
}

double protocol witness for static FixedWidthInteger.min.getter in conformance _Int128@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  *a1 = xmmword_18162B010;
  return result;
}

uint64_t protocol witness for FixedWidthInteger.addingReportingOverflow(_:) in conformance _Int128(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  uint64_t v4 = v2[1];
  BOOL v5 = __CFADD__(*v2, *a2);
  BOOL v6 = __OFADD__(v4, v3);
  uint64_t v7 = v4 + v3;
  if (v6)
  {
    uint64_t v8 = 1;
    if (v5)
    {
LABEL_12:
      uint64_t v9 = 1;
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v8 = v7 == 0x7FFFFFFFFFFFFFFFLL && v5;
    if (v5) {
      goto LABEL_12;
    }
  }
  uint64_t v9 = 0;
LABEL_13:
  *a1 = *v2 + *a2;
  a1[1] = v9 + v7;
  return v8;
}

unint64_t protocol witness for FixedWidthInteger.subtractingReportingOverflow(_:) in conformance _Int128(unint64_t *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  unint64_t v5 = *v2;
  unint64_t v6 = v2[1];
  BOOL v7 = __OFSUB__(v6, v4);
  unint64_t v8 = v6 - v4;
  int v9 = v7;
  BOOL v10 = v5 >= v3;
  unint64_t v11 = v5 - v3;
  LODWORD(v3) = v5 < v3;
  if (v10)
  {
    if (v9)
    {
      unint64_t v3 = 1;
      unint64_t v12 = v8;
      goto LABEL_13;
    }
    unint64_t v12 = v8;
  }
  else
  {
    unint64_t v12 = v8 - 1;
    if (v9)
    {
      unint64_t v3 = 1;
      goto LABEL_13;
    }
  }
  if (v8 == 0x8000000000000000) {
    unint64_t v3 = v3;
  }
  else {
    unint64_t v3 = 0;
  }
LABEL_13:
  *a1 = v11;
  a1[1] = v12;
  return v3;
}

BOOL protocol witness for FixedWidthInteger.multipliedReportingOverflow(by:) in conformance _Int128(Swift::UInt64 *a1, Swift::_Int128 *a2)
{
  Swift::tuple_partialValue__Int128_overflow_Bool v4 = _Int128.multipliedReportingOverflow(by:)(*a2);
  *a1 = v4.partialValue.low;
  a1[1] = v4.partialValue.high;
  return v4.overflow;
}

uint64_t protocol witness for FixedWidthInteger.dividedReportingOverflow(by:) in conformance _Int128(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v6 = *v2;
  unint64_t v7 = v2[1];
  if (v5 == -1)
  {
    if (v4 == -1 && v7 == 0x8000000000000000 && v6 == 0)
    {
      uint64_t v6 = 0;
      uint64_t result = 1;
      unint64_t v7 = 0x8000000000000000;
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  if (v5) {
    BOOL v8 = 0;
  }
  else {
    BOOL v8 = v4 == 0;
  }
  if (!v8)
  {
LABEL_15:
    unsigned long long v12 = (unsigned __int128)_Int128.quotientAndRemainder(dividingBy:)(*(Swift::_Int128 *)&v4);
    uint64_t v6 = v12;
    unint64_t v7 = *((void *)&v12 + 1);
    uint64_t result = 0;
    goto LABEL_16;
  }
  uint64_t result = 1;
LABEL_16:
  *a1 = v6;
  a1[1] = v7;
  return result;
}

BOOL protocol witness for FixedWidthInteger.remainderReportingOverflow(dividingBy:) in conformance _Int128(Swift::UInt64 *a1, Swift::_Int128 *a2)
{
  Swift::tuple_partialValue__Int128_overflow_Bool v4 = _Int128.remainderReportingOverflow(dividingBy:)(*a2);
  *a1 = v4.partialValue.low;
  a1[1] = v4.partialValue.high;
  return v4.overflow;
}

uint64_t protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance _Int128(uint64_t *a1, void *a2, void *a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance _UInt128(a1, a2, a3, a4, a5, (uint64_t (*)(void, void, void, void))_Int128.multipliedFullWidth(by:));
}

uint64_t protocol witness for FixedWidthInteger.multipliedFullWidth(by:) in conformance _UInt128(uint64_t *a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(void, void, void, void))
{
  uint64_t result = a6(*a3, a3[1], *v6, v6[1]);
  *a1 = result;
  a1[1] = v10;
  *a2 = v11;
  a2[1] = v12;
  return result;
}

Swift::UInt64 protocol witness for FixedWidthInteger.dividingFullWidth(_:) in conformance _Int128(Swift::UInt64 *a1, Swift::UInt64 *a2, uint64_t a3, Swift::UInt64 *a4)
{
  v7.high.Swift::UInt64 low = *(void *)a3;
  v7.high.uint64_t high = *(void *)(a3 + 8);
  v7.low.Swift::UInt64 low = *a4;
  v7.low.uint64_t high = a4[1];
  Swift::tuple_quotient__Int128_remainder__Int128 v8 = _Int128.dividingFullWidth(_:)(v7);
  *a1 = v8.quotient.low;
  a1[1] = v8.quotient.high;
  *a2 = v8.remainder.low;
  a2[1] = v8.remainder.high;
  return v8.quotient.low;
}

uint64_t protocol witness for FixedWidthInteger.nonzeroBitCount.getter in conformance _Int128()
{
  return vaddvq_s64((int64x2_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(*v0)))));
}

unint64_t protocol witness for FixedWidthInteger.leadingZeroBitCount.getter in conformance _Int128()
{
  unint64_t v1 = v0[1];
  if (v1) {
    return __clz(v1);
  }
  else {
    return __clz(*v0) + 64;
  }
}

int8x16_t protocol witness for FixedWidthInteger.init(bigEndian:) in conformance _Int128@<Q0>(int8x16_t *a1@<X0>, int8x16_t *a2@<X8>)
{
  int8x16_t v2 = vrev64q_s8(*a1);
  int8x16_t result = vextq_s8(v2, v2, 8uLL);
  *a2 = result;
  return result;
}

__n128 protocol witness for FixedWidthInteger.init(littleEndian:) in conformance _Int128@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

int8x16_t protocol witness for FixedWidthInteger.bigEndian.getter in conformance _Int128@<Q0>(int8x16_t *a1@<X8>)
{
  int8x16_t v2 = vrev64q_s8(*v1);
  int8x16_t result = vextq_s8(v2, v2, 8uLL);
  *a1 = result;
  return result;
}

__n128 protocol witness for FixedWidthInteger.littleEndian.getter in conformance _Int128@<Q0>(__n128 *a1@<X8>)
{
  __n128 result = *v1;
  *a1 = *v1;
  return result;
}

uint64_t protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance _Int128@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  return protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance _UInt128(a1, a2, (uint64_t (*)(uint64_t, void, void, void))specialized _wideMaskedShiftRight<A>(_:_:), a3);
}

uint64_t protocol witness for static FixedWidthInteger.&>> infix(_:_:) in conformance _UInt128@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t (*a3)(uint64_t, void, void, void)@<X4>, uint64_t a4@<X8>)
{
  uint64_t result = a3(a4, a1[1], *a1, *a2);
  *(void *)(a4 + 8) = result;
  return result;
}

uint64_t protocol witness for static FixedWidthInteger.&>>= infix(_:_:) in conformance _Int128(uint64_t *a1, void *a2)
{
  uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(a1, a1[1], *a1, *a2);
  a1[1] = result;
  return result;
}

uint64_t *protocol witness for static FixedWidthInteger.&* infix(_:_:) in conformance _Int128@<X0>(uint64_t *result@<X0>, unint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v4 = *result;
  uint64_t v5 = result[1];
  unint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (!v7)
  {
    if ((v5 & 0x8000000000000000) == 0 || !v6)
    {
LABEL_9:
      LODWORD(v8) = 0;
      BOOL v9 = 0;
      if ((v5 & 0x8000000000000000) == 0) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }
    uint64_t v7 = 0;
    LODWORD(v8) = 1;
LABEL_18:
    BOOL v11 = v4 == 0;
    uint64_t v4 = -v4;
    uint64_t v5 = -(v5 + !v11);
    BOOL v9 = v8;
    goto LABEL_19;
  }
  if (v5)
  {
    if (((v7 ^ v5) & 0x8000000000000000) == 0)
    {
      if (v7 < 0)
      {
LABEL_17:
        BOOL v8 = (v7 ^ (unint64_t)v5) >> 63;
        BOOL v11 = v6 == 0;
        unint64_t v6 = -(uint64_t)v6;
        uint64_t v7 = -(v7 + !v11);
        BOOL v9 = v8;
        if ((v5 & 0x8000000000000000) == 0) {
          goto LABEL_19;
        }
        goto LABEL_18;
      }
      goto LABEL_9;
    }
    if (v7 < 0) {
      goto LABEL_17;
    }
    LODWORD(v8) = 1;
    BOOL v9 = 1;
    if ((v5 & 0x8000000000000000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  uint64_t v10 = (unsigned __int128)-(__int128)__PAIR128__(v3, v6) >> 64;
  uint64_t v5 = 0;
  if (v7 >= 0)
  {
    BOOL v9 = 0;
  }
  else
  {
    unint64_t v6 = -(uint64_t)v6;
    uint64_t v7 = v10;
    BOOL v9 = v4 != 0;
  }
LABEL_19:
  uint64_t v12 = v6 * v5 + v7 * v4;
  uint64_t v13 = v6 * v4;
  uint64_t v14 = v12 + ((v6 * (unsigned __int128)(unint64_t)v4) >> 64);
  unint64_t v15 = -v14;
  if (v13) {
    unint64_t v15 = ~v14;
  }
  uint64_t v16 = (__PAIR128__(v15, -v13 - 1) + __PAIR128__((uint64_t)((unint64_t)(v13 == 0) << 63) >> 63, 1)) >> 64;
  uint64_t v17 = -v13;
  if (v9) {
    uint64_t v14 = v16;
  }
  else {
    uint64_t v17 = v13;
  }
  *a3 = v17;
  a3[1] = v14;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(exactly:) in conformance _Int128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type _Int128 and conformance _Int128(a1, a2, a3);
  return FixedWidthInteger.init<A>(exactly:)(a1, a4, a2, v10, a3, a5);
}

double protocol witness for BinaryInteger.init<A>(_:) in conformance _Int128@<D0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128(a1, a2, a3, a4, (uint64_t (*)(void))lazy protocol witness table accessor for type _Int128 and conformance _Int128, a5);
}

double protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128@<D0>(uint64_t a1@<X0>, Class *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(void)@<X5>, _OWORD *a6@<X8>)
{
  BOOL v8 = v6;
  uint64_t v13 = a5();
  static FixedWidthInteger._convert<A>(from:)((uint64_t)&v38, a1, a4, (uint64_t)a2, v13, a3);
  if (v39)
  {
    *(void *)&long long v38 = static String._createEmpty(withInitialCapacity:)(80);
    *((void *)&v38 + 1) = v15;
    TypeName = (uint64_t *)swift_getTypeName(a2, 0);
    if ((v17 & 0x8000000000000000) == 0)
    {
      Swift::UInt64 v18 = (uint8x16_t *)TypeName;
      int64_t v19 = v17;
      int64_t v20 = validateUTF8(_:)(TypeName, v17);
      uint64_t v23 = (v22 & 1) != 0
          ? repairUTF8(_:firstKnownBrokenRange:)(v18->i8, v19, v20, v21)
          : specialized static String._uncheckedFromUTF8(_:isASCII:)(v18, v19, v20 & 1);
      uint64_t v25 = v24;
      String.append(_:)(*(Swift::String *)&v23);
      swift_bridgeObjectRelease(v25);
      v26._object = (void *)0x80000001816DE7E0;
      v26._countAndFlagsBits = 0xD00000000000001ELL;
      String.append(_:)(v26);
      uint64_t v27 = (uint64_t *)swift_getTypeName(v8, 0);
      if ((v28 & 0x8000000000000000) == 0)
      {
        uint64_t v29 = (uint8x16_t *)v27;
        int64_t v30 = v28;
        int64_t v31 = validateUTF8(_:)(v27, v28);
        if (v33) {
          uint64_t v34 = repairUTF8(_:firstKnownBrokenRange:)(v29->i8, v30, v31, v32);
        }
        else {
          uint64_t v34 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v29, v30, v31 & 1);
        }
        uint64_t v36 = v35;
        String.append(_:)(*(Swift::String *)&v34);
        swift_bridgeObjectRelease(v36);
        v37._countAndFlagsBits = 0xD00000000000002ELL;
        v37._object = (void *)0x80000001816DE800;
        String.append(_:)(v37);
        _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v38, *((unint64_t *)&v38 + 1), "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
      }
    }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  (*((void (**)(uint64_t, Class *))*(a2 - 1) + 1))(a1, a2);
  double result = *(double *)&v38;
  *a6 = v38;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance _Int128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128(a1, a2, a3, (uint64_t (*)(char *, uint64_t, uint64_t))_Int128.init<A>(exactly:), 0x27CuLL, a4);
}

uint64_t protocol witness for BinaryInteger.init<A>(_:) in conformance _UInt128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t (*a4)(char *, uint64_t, uint64_t)@<X5>, unint64_t a5@<X6>, uint64_t *a6@<X8>)
{
  uint64_t v9 = specialized _UInt128.init<A>(_:)(a1, a2, a3, a4, a5);
  uint64_t v11 = v10;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  *a6 = v9;
  a6[1] = v11;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance _Int128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance _UInt128(a1, a2, (uint64_t (*)(void))specialized static FixedWidthInteger._truncatingInit<A>(_:), a3);
}

uint64_t protocol witness for BinaryInteger.init<A>(truncatingIfNeeded:) in conformance _UInt128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t (*a3)(void)@<X5>, uint64_t *a4@<X8>)
{
  uint64_t v7 = a3();
  uint64_t v9 = v8;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a2 - 8) + 8))(a1, a2);
  *a4 = v7;
  a4[1] = v9;
  return result;
}

uint64_t protocol witness for BinaryInteger.init<A>(clamping:) in conformance _Int128@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v10 = lazy protocol witness table accessor for type _Int128 and conformance _Int128(a1, a2, a3);
  return FixedWidthInteger.init<A>(clamping:)(a1, a4, a2, v10, a3, a5);
}

unint64_t protocol witness for BinaryInteger._binaryLogarithm() in conformance _Int128()
{
  return specialized FixedWidthInteger._binaryLogarithm()(*(void *)v0, *(void *)(v0 + 8));
}

unint64_t protocol witness for BinaryInteger.trailingZeroBitCount.getter in conformance _Int128()
{
  if (*v0) {
    return __clz(__rbit64(*v0));
  }
  else {
    return __clz(__rbit64(v0[1])) + 64;
  }
}

double protocol witness for static BinaryInteger./ infix(_:_:) in conformance _Int128@<D0>(long long *a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  Swift::UInt64 v4 = *(void *)a2;
  v7.uint64_t high = *(void *)(a2 + 8);
  long long v6 = *a1;
  v7.Swift::UInt64 low = v4;
  specialized static _Int128./= infix(_:_:)(&v6, v7);
  double result = *(double *)&v6;
  *a3 = v6;
  return result;
}

uint64_t protocol witness for static BinaryInteger./= infix(_:_:) in conformance _Int128(void *a1, Swift::_Int128 *a2)
{
  return specialized static _Int128./= infix(_:_:)(a1, *a2);
}

Swift::UInt64 protocol witness for static BinaryInteger.% infix(_:_:) in conformance _Int128@<X0>(Swift::_Int128 *a1@<X1>, Swift::UInt64 *a2@<X8>)
{
  Swift::tuple_partialValue__Int128_overflow_Bool v4 = _Int128.remainderReportingOverflow(dividingBy:)(*a1);
  if (v4.overflow) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in %=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x3DCuLL, 0);
  }
  *a2 = v4.partialValue.low;
  a2[1] = v4.partialValue.high;
  return v4.partialValue.low;
}

uint64_t protocol witness for static BinaryInteger.%= infix(_:_:) in conformance _Int128(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for static Numeric.*= infix(_:_:) in conformance _Int128(a1, a2, a3, a4, (uint64_t (*)(void, void, uint64_t, uint64_t))_Int128.remainderReportingOverflow(dividingBy:), "Overflow in %=", 0x3DCuLL);
}

uint64_t protocol witness for static Numeric.*= infix(_:_:) in conformance _Int128(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, void, uint64_t, uint64_t), const char *a6, unint64_t a7)
{
  uint64_t result = a5(*a2, a2[1], *a1, a1[1]);
  if (v12) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, a6, 14, 2, "Swift/LegacyInt128.swift", 24, 2, a7, 0);
  }
  *a1 = result;
  a1[1] = v11;
  return result;
}

void *protocol witness for static BinaryInteger.~ prefix(_:) in conformance _UInt128@<X0>(void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = result[1];
  if (*result) {
    uint64_t v3 = ~v2;
  }
  else {
    uint64_t v3 = -v2;
  }
  BOOL v4 = *result == 0;
  *a2 = -*result - 1;
  a2[1] = v3 - v4;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.& infix(_:_:) in conformance _Int128@<Q0>(int8x16_t *a1@<X0>, int8x16_t *a2@<X1>, int8x16_t *a3@<X8>)
{
  int8x16_t result = vandq_s8(*a2, *a1);
  *a3 = result;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.&= infix(_:_:) in conformance _Int128(int8x16_t *a1, int8x16_t *a2)
{
  int8x16_t result = vandq_s8(*a1, *a2);
  *a1 = result;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.| infix(_:_:) in conformance _Int128@<Q0>(int8x16_t *a1@<X0>, int8x16_t *a2@<X1>, int8x16_t *a3@<X8>)
{
  int8x16_t result = vorrq_s8(*a2, *a1);
  *a3 = result;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.|= infix(_:_:) in conformance _Int128(int8x16_t *a1, int8x16_t *a2)
{
  int8x16_t result = vorrq_s8(*a1, *a2);
  *a1 = result;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.^ infix(_:_:) in conformance _Int128@<Q0>(int8x16_t *a1@<X0>, int8x16_t *a2@<X1>, int8x16_t *a3@<X8>)
{
  int8x16_t result = veorq_s8(*a2, *a1);
  *a3 = result;
  return result;
}

int8x16_t protocol witness for static BinaryInteger.^= infix(_:_:) in conformance _Int128(int8x16_t *a1, int8x16_t *a2)
{
  int8x16_t result = veorq_s8(*a1, *a2);
  *a1 = result;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>> infix<A>(_:_:) in conformance _Int128@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v5 = a4;
  v141 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v141, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v139 = (char *)&v133 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v133 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  uint64_t v137 = (char *)&v133 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  char v144 = (char *)&v133 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v142 = (char *)&v133 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v138 = (char *)&v133 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v143 = (char *)&v133 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v148 = (char *)&v133 - v27;
  MEMORY[0x1F4188790](v26);
  uint64_t v152 = (char *)&v133 - v28;
  unint64_t v29 = *a1;
  unint64_t v153 = a1[1];
  int64_t v30 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 64);
  char v31 = v30(a3, v5);
  uint64_t v149 = v5 + 64;
  uint64_t v151 = v30;
  if (v31)
  {
    int64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
    uint64_t v33 = v32(a3, v5);
    uint64_t v150 = v32;
    if (v33 < 64)
    {
      uint64_t v36 = v152;
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v152, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
      (*(void (**)(char *, uint64_t))(v12 + 8))(v36, a3);
      if (v37 >= -128) {
        goto LABEL_19;
      }
LABEL_18:
      unint64_t v42 = -128;
      goto LABEL_61;
    }
    unint64_t v42 = -128;
    v155[0] = -128;
    uint64_t v146 = v12;
    unint64_t v47 = v29;
    uint64_t v48 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
    unint64_t v49 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
    uint64_t v50 = v152;
    v48(v155, &type metadata for Int, v49, a3, v5);
    int64_t v30 = v151;
    unint64_t v29 = v47;
    uint64_t v12 = v146;
    char v51 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(a2, v50, a3);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v50, a3);
    if (v51) {
      goto LABEL_61;
    }
LABEL_19:
    unint64_t v147 = a5;
    char v61 = v30(a3, v5);
    uint64_t v136 = v5 + 128;
    uint64_t v62 = v150(a3, v5);
    uint64_t v146 = v12;
    if (v61)
    {
      if (v62 > 64) {
        goto LABEL_21;
      }
    }
    else if (v62 > 63)
    {
LABEL_21:
      unint64_t v42 = 128;
      v155[0] = 128;
      unint64_t v65 = v29;
      uint64_t v66 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
      unint64_t v67 = lazy protocol witness table accessor for type Int and conformance Int(v62, v63, v64);
      unint64_t v68 = v152;
      v66(v155, &type metadata for Int, v67, a3, v5);
      int64_t v30 = v151;
      unint64_t v29 = v65;
      uint64_t v12 = v146;
      a5 = v147;
      char v69 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v68, a2, a3);
      unint64_t v134 = *(void (**)(char *, uint64_t))(v12 + 8);
      v134(v68, a3);
      if (v69) {
        goto LABEL_61;
      }
      goto LABEL_26;
    }
    uint64_t v70 = v152;
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v152, a2, a3);
    uint64_t v71 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
    unint64_t v134 = *(void (**)(char *, uint64_t))(v12 + 8);
    v134(v70, a3);
    a5 = v147;
    if (v71 > 128)
    {
      unint64_t v42 = 128;
      goto LABEL_61;
    }
LABEL_26:
    uint64_t v72 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
    uint64_t v73 = v30;
    uint64_t v74 = v148;
    v72(v148, a2, a3);
    char v75 = v73(a3, v5);
    uint64_t v76 = v143;
    unint64_t v135 = (void (*)(char *, char *, uint64_t))v72;
    v72(v143, (uint64_t)v74, a3);
    unint64_t v145 = v29;
    if ((v75 & 1) == 0)
    {
      uint64_t v78 = v134;
      v134(v76, a3);
      a5 = v147;
      goto LABEL_45;
    }
    uint64_t v77 = v150(a3, v5);
    uint64_t v78 = v134;
    uint64_t v143 = (char *)(v12 + 8);
    v134(v76, a3);
    a5 = v147;
    if (v77 <= 64) {
      goto LABEL_45;
    }
    BOOL v79 = v138;
    v135(v138, v148, a3);
    v155[0] = 0x8000000000000000;
    uint64_t v80 = v151;
    if (v151(a3, v5))
    {
      uint64_t v81 = v150(a3, v5);
      if (v81 < 64)
      {
        uint64_t v84 = v79;
        uint64_t v85 = v152;
        v135(v152, v79, a3);
        uint64_t v86 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
        unint64_t v87 = v85;
        uint64_t v88 = a3;
        uint64_t v78 = v134;
        goto LABEL_38;
      }
    }
    else
    {
      char v89 = v80(a3, v5);
      uint64_t v81 = v150(a3, v5);
      uint64_t v84 = v79;
      if ((v89 & 1) == 0)
      {
        uint64_t v78 = v134;
        if (v81 < 64)
        {
          unint64_t v97 = v152;
          v135(v152, v84, a3);
          uint64_t v86 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
          unint64_t v87 = v97;
          uint64_t v88 = a3;
LABEL_38:
          v78(v87, v88);
          if (v86 < v155[0]) {
            goto LABEL_70;
          }
        }
LABEL_44:
        v78(v84, a3);
LABEL_45:
        uint64_t v109 = v148;
        uint64_t v110 = v150;
        uint64_t v111 = v150(a3, v5);
        uint64_t v112 = v5;
        unint64_t v113 = v142;
        v135(v142, v109, a3);
        if (v111 >= 65)
        {
          uint64_t v114 = v112;
          v78(v113, a3);
          goto LABEL_49;
        }
        uint64_t v115 = v110(a3, v112);
        v78(v113, a3);
        if (v115 == 64)
        {
          uint64_t v114 = v112;
          if ((v151(a3, v112) & 1) == 0)
          {
LABEL_49:
            v135(v144, v148, a3);
            v155[0] = 0x7FFFFFFFFFFFFFFFLL;
            char v116 = v151(a3, v114);
            uint64_t v117 = v150(a3, v114);
            if (v116)
            {
              if (v117 > 64)
              {
                uint64_t v120 = a5;
                uint64_t v121 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v114 + 96);
                unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v117, v118, v119);
                uint64_t v123 = v155;
LABEL_56:
                uint64_t v125 = v152;
                v121(v123, &type metadata for Int, v122, a3, v114);
                char v126 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v114 + 32) + 8)
                                                                          + 16))(v125, v144, a3);
                v78(v125, a3);
                if (v126) {
                  _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
                }
                a5 = v120;
                goto LABEL_58;
              }
            }
            else if (v117 > 63)
            {
              uint64_t v120 = a5;
              uint64_t v154 = 0x7FFFFFFFFFFFFFFFLL;
              uint64_t v121 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v114 + 96);
              unint64_t v122 = lazy protocol witness table accessor for type Int and conformance Int(v117, v118, v119);
              uint64_t v123 = &v154;
              goto LABEL_56;
            }
            unint64_t v124 = v152;
            v135(v152, v144, a3);
            (*(void (**)(uint64_t, uint64_t))(v114 + 120))(a3, v114);
            v78(v124, a3);
LABEL_58:
            v78(v144, a3);
          }
        }
        else
        {
          uint64_t v114 = v112;
        }
        unint64_t v127 = v148;
        unint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(v114 + 120))(a3, v114);
        v78(v127, a3);
        goto LABEL_60;
      }
      if (v81 <= 64)
      {
        uint64_t v99 = AssociatedTypeWitness;
        char v98 = v141;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v101 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v99, AssociatedConformanceWitness);
        uint64_t v102 = v5;
        char v103 = v152;
        ((void (*)(char *, uint64_t, int **))v98[3])(v101, a3, v98);
        char v104 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v102 + 32) + 8) + 16))(v84, v103, a3);
        uint64_t v78 = v134;
        v134(v103, a3);
        uint64_t v105 = v137;
        v135(v137, v84, a3);
        if (v104)
        {
          v78(v105, a3);
          goto LABEL_70;
        }
        uint64_t v106 = v155[0];
        uint64_t v107 = (*(uint64_t (**)(uint64_t, uint64_t))(v102 + 120))(a3, v102);
        v78(v105, a3);
        BOOL v108 = v107 < v106;
        uint64_t v5 = v102;
        if (v108) {
LABEL_70:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_44;
      }
    }
    uint64_t v90 = v5;
    char v91 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
    unint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v81, v82, v83);
    unint64_t v93 = a5;
    uint64_t v94 = v152;
    v91(v155, &type metadata for Int, v92, a3, v90);
    uint64_t v5 = v90;
    uint64_t v84 = v138;
    char v95 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v90 + 32) + 8) + 16))(v138, v94, a3);
    unint64_t v96 = v94;
    a5 = v93;
    uint64_t v78 = v134;
    v134(v96, a3);
    if (v95) {
      goto LABEL_70;
    }
    goto LABEL_44;
  }
  unint64_t v145 = v29;
  char v38 = v30(a3, v5);
  uint64_t v150 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
  uint64_t v39 = ((uint64_t (*)(uint64_t))v150)(a3);
  if ((v38 & 1) == 0)
  {
    if (v39 >= 64)
    {
      int64_t v30 = v151;
      unint64_t v29 = v145;
      goto LABEL_19;
    }
    char v52 = v152;
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v152, a2, a3);
    uint64_t v53 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v52, a3);
    int64_t v30 = v151;
    unint64_t v29 = v145;
    if (v53 >= -128) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  unint64_t v147 = a5;
  if (v39 <= 64)
  {
    uint64_t v54 = AssociatedTypeWitness;
    uint64_t v55 = v141;
    uint64_t v56 = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v57 = v139;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v56 + 8))(&qword_18162B0B8, 256, v54, v56);
    uint64_t v58 = v152;
    ((void (*)(char *, uint64_t, int **))v55[3])(v57, a3, v55);
    LOBYTE(v54) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(a2, v58, a3);
    uint64_t v59 = *(void (**)(char *, uint64_t))(v12 + 8);
    v59(v58, a3);
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, a3);
    if (v54)
    {
      v59(v15, a3);
      unint64_t v42 = -128;
      a5 = v147;
LABEL_60:
      unint64_t v29 = v145;
      goto LABEL_61;
    }
    uint64_t v60 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
    v59(v15, a3);
    int64_t v30 = v151;
    a5 = v147;
    unint64_t v29 = v145;
    if (v60 < -128) {
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  unint64_t v42 = -128;
  v155[0] = -128;
  uint64_t v43 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
  unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
  uint64_t v45 = v152;
  v43(v155, &type metadata for Int, v44, a3, v5);
  char v46 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(a2, v45, a3);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v45, a3);
  a5 = v147;
  int64_t v30 = v151;
  unint64_t v29 = v145;
  if ((v46 & 1) == 0) {
    goto LABEL_19;
  }
LABEL_61:
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(v155, v153, v29, v128);
  if ((v42 & 0x8000000000000000) != 0)
  {
    if (v42 <= 0xFFFFFFFFFFFFFF80)
    {
      uint64_t result = 0;
      uint64_t v131 = 0;
      goto LABEL_65;
    }
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    uint64_t result = specialized _wideMaskedShiftLeft<A>(_:_:)(v155, v153, v29, v132);
  }
  else if (v42 < 0x80)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(v155, v153, v29, v130);
  }
  uint64_t v131 = v155[0];
LABEL_65:
  *a5 = v131;
  a5[1] = result;
  return result;
}

uint64_t protocol witness for static BinaryInteger.>>= infix<A>(_:_:) in conformance _Int128(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v158 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v158, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v156 = (char *)&v149 - v9;
  uint64_t v167 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v12 = (char *)&v149 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  unint64_t v153 = (char *)&v149 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v160 = (char *)&v149 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v162 = (char *)&v149 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v155 = (char *)&v149 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v161 = (uint64_t)&v149 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v25 = (char *)&v149 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v166 = (char *)&v149 - v26;
  uint64_t v28 = a4 + 64;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v29 = v27(a3, a4);
  uint64_t v164 = v27;
  if (v29)
  {
    char v165 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v30 = v165(a3, a4);
    if (v30 < 64)
    {
      uint64_t v34 = v166;
      uint64_t v33 = v167;
      (*(void (**)(char *, uint64_t, uint64_t))(v167 + 16))(v166, a2, a3);
LABEL_12:
      uint64_t v52 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      (*(void (**)(char *, uint64_t))(v33 + 8))(v34, a3);
      if (v52 < -128)
      {
LABEL_13:
        unint64_t v40 = -128;
        goto LABEL_59;
      }
      goto LABEL_18;
    }
    unint64_t v40 = -128;
    v169[0] = -128;
    uint64_t v45 = v166;
    uint64_t v163 = a4 + 64;
    char v46 = v25;
    unint64_t v47 = a1;
    uint64_t v48 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v49 = lazy protocol witness table accessor for type Int and conformance Int(v30, v31, v32);
    v48(v169, &type metadata for Int, v49, a3, a4);
    a1 = v47;
    uint64_t v25 = v46;
    uint64_t v50 = v167;
    uint64_t v28 = v163;
    char v51 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v45, a3);
    (*(void (**)(char *, uint64_t))(v50 + 8))(v45, a3);
    if ((v51 & 1) == 0) {
      goto LABEL_18;
    }
  }
  else
  {
    char v35 = v27(a3, a4);
    uint64_t v36 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v159 = a2;
    char v165 = v36;
    uint64_t v37 = v36(a3, a4);
    if ((v35 & 1) == 0)
    {
      if (v37 >= 64)
      {
        a2 = v159;
        goto LABEL_18;
      }
      uint64_t v34 = v166;
      uint64_t v33 = v167;
      a2 = v159;
      (*(void (**)(char *, uint64_t, uint64_t))(v167 + 16))(v166, v159, a3);
      goto LABEL_12;
    }
    uint64_t v154 = a1;
    if (v37 <= 64)
    {
      uint64_t v53 = AssociatedTypeWitness;
      uint64_t v54 = v158;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v158, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v56 = v156;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v53, AssociatedConformanceWitness);
      uint64_t v57 = v166;
      ((void (*)(char *, uint64_t, int **))v54[3])(v56, a3, v54);
      uint64_t v58 = v159;
      LOBYTE(v53) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v159, v57, a3);
      uint64_t v59 = v167;
      uint64_t v60 = v57;
      char v61 = *(void (**)(char *, uint64_t))(v167 + 8);
      v61(v60, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v59 + 16))(v12, v58, a3);
      if (v53)
      {
        v61(v12, a3);
        unint64_t v40 = -128;
        a1 = v154;
        goto LABEL_59;
      }
      uint64_t v62 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v61(v12, a3);
      a1 = v154;
      a2 = v159;
      if (v62 < -128) {
        goto LABEL_13;
      }
LABEL_18:
      char v63 = v164(a3, a4);
      uint64_t v159 = a4 + 128;
      uint64_t v64 = v165(a3, a4);
      uint64_t v163 = v28;
      if (v63)
      {
        if (v64 > 64) {
          goto LABEL_20;
        }
      }
      else if (v64 >= 64)
      {
LABEL_20:
        unint64_t v40 = 128;
        v169[0] = 128;
        unint64_t v67 = v166;
        unint64_t v68 = v25;
        char v69 = a1;
        uint64_t v70 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v71 = lazy protocol witness table accessor for type Int and conformance Int(v64, v65, v66);
        v70(v169, &type metadata for Int, v71, a3, a4);
        a1 = v69;
        uint64_t v25 = v68;
        uint64_t v72 = v167;
        char v73 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v67, a2, a3);
        uint64_t v74 = *(void (**)(char *, uint64_t))(v72 + 8);
        v74(v67, a3);
        if (v73) {
          goto LABEL_59;
        }
        goto LABEL_25;
      }
      uint64_t v76 = v166;
      uint64_t v75 = v167;
      (*(void (**)(char *, uint64_t, uint64_t))(v167 + 16))(v166, a2, a3);
      uint64_t v77 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      uint64_t v74 = *(void (**)(char *, uint64_t))(v75 + 8);
      v74(v76, a3);
      if (v77 > 128)
      {
        unint64_t v40 = 128;
        goto LABEL_59;
      }
LABEL_25:
      uint64_t v154 = a1;
      uint64_t v78 = v25;
      BOOL v79 = *(void (**)(char *, uint64_t, uint64_t))(v167 + 16);
      v79(v78, a2, a3);
      char v80 = v164(a3, a4);
      uint64_t v81 = v161;
      uint64_t v82 = v78;
      uint64_t v152 = (void (*)(char *, char *, uint64_t))v79;
      v79((char *)v161, (uint64_t)v78, a3);
      uint64_t v150 = v74;
      uint64_t v151 = v78;
      if ((v80 & 1) == 0)
      {
        v74((char *)v81, a3);
        uint64_t v85 = v162;
        uint64_t v83 = v165;
        a1 = v154;
        uint64_t v86 = v82;
        goto LABEL_46;
      }
      uint64_t v83 = v165;
      uint64_t v84 = v165(a3, a4);
      v74((char *)v81, a3);
      uint64_t v85 = v162;
      a1 = v154;
      uint64_t v86 = v82;
      if (v84 <= 64) {
        goto LABEL_46;
      }
      unint64_t v87 = v155;
      v152(v155, v86, a3);
      v169[0] = 0x8000000000000000;
      uint64_t v88 = v164;
      if (v164(a3, a4))
      {
        uint64_t v89 = v165(a3, a4);
        unint64_t v92 = v87;
        if (v89 < 64)
        {
          unint64_t v93 = v166;
          v152(v166, v92, a3);
          uint64_t v94 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          char v95 = v93;
          unint64_t v96 = v150;
          v150(v95, a3);
          BOOL v97 = v94 < v169[0];
          char v98 = v92;
          uint64_t v85 = v162;
          goto LABEL_40;
        }
        uint64_t v109 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v110 = lazy protocol witness table accessor for type Int and conformance Int(v89, v90, v91);
        uint64_t v111 = v166;
        v109(v169, &type metadata for Int, v110, a3, a4);
        uint64_t v86 = v151;
        a1 = v154;
        char v107 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v92, v111, a3);
        uint64_t v112 = v111;
        unint64_t v96 = v150;
        v150(v112, a3);
        char v98 = v92;
        uint64_t v85 = v162;
      }
      else
      {
        char v99 = v88(a3, a4);
        uint64_t v100 = v165(a3, a4);
        if ((v99 & 1) == 0)
        {
          uint64_t v85 = v162;
          if (v100 >= 64)
          {
            v150(v155, a3);
            uint64_t v86 = v151;
            uint64_t v83 = v165;
            goto LABEL_46;
          }
          unint64_t v113 = v166;
          uint64_t v114 = v155;
          v152(v166, v155, a3);
          uint64_t v115 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          unint64_t v96 = v150;
          v150(v113, a3);
          char v98 = v114;
          BOOL v97 = v115 < v169[0];
          uint64_t v86 = v151;
LABEL_40:
          uint64_t v83 = v165;
          if (!v97) {
            goto LABEL_45;
          }
LABEL_68:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        }
        uint64_t v85 = v162;
        if (v100 <= 64)
        {
          char v116 = AssociatedTypeWitness;
          uint64_t v117 = v158;
          uint64_t v118 = swift_getAssociatedConformanceWitness((uint64_t)v158, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v119 = v156;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v118 + 8))(&qword_18162B0B8, 256, v116, v118);
          uint64_t v120 = v166;
          ((void (*)(char *, uint64_t, int **))v117[3])(v119, a3, v117);
          uint64_t v121 = v155;
          LODWORD(v161) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                             + 16))(v155, v120, a3);
          unint64_t v122 = v120;
          unint64_t v96 = v150;
          v150(v122, a3);
          uint64_t v123 = v153;
          v152(v153, v121, a3);
          uint64_t v83 = v165;
          if (v161)
          {
            v96(v123, a3);
            goto LABEL_68;
          }
          uint64_t v161 = v169[0];
          uint64_t v124 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v96(v123, a3);
          BOOL v97 = v124 < v161;
          uint64_t v86 = v151;
          char v98 = v155;
          if (v97) {
            goto LABEL_68;
          }
          goto LABEL_45;
        }
        char v103 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v104 = lazy protocol witness table accessor for type Int and conformance Int(v100, v101, v102);
        uint64_t v105 = v166;
        v103(v169, &type metadata for Int, v104, a3, a4);
        a1 = v154;
        uint64_t v106 = v155;
        char v107 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v155, v105, a3);
        BOOL v108 = v105;
        unint64_t v96 = v150;
        v150(v108, a3);
        char v98 = v106;
        uint64_t v86 = v151;
      }
      uint64_t v83 = v165;
      if (v107) {
        goto LABEL_68;
      }
LABEL_45:
      v96(v98, a3);
LABEL_46:
      uint64_t v125 = v83(a3, a4);
      v152(v85, v86, a3);
      if (v125 < 65)
      {
        uint64_t v129 = v83(a3, a4);
        char v130 = v85;
        unint64_t v127 = v150;
        v150(v130, a3);
        char v128 = v160;
        if (v129 != 64 || (v164(a3, a4) & 1) != 0) {
          goto LABEL_58;
        }
      }
      else
      {
        char v126 = v85;
        unint64_t v127 = v150;
        v150(v126, a3);
        char v128 = v160;
      }
      v152(v128, v151, a3);
      v169[0] = 0x7FFFFFFFFFFFFFFFLL;
      char v131 = v164(a3, a4);
      uint64_t v132 = v165(a3, a4);
      if (v131)
      {
        if (v132 > 64)
        {
          unint64_t v135 = v166;
          uint64_t v136 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v137 = lazy protocol witness table accessor for type Int and conformance Int(v132, v133, v134);
          uint64_t v138 = v169;
          goto LABEL_56;
        }
      }
      else if (v132 >= 64)
      {
        uint64_t v168 = 0x7FFFFFFFFFFFFFFFLL;
        unint64_t v135 = v166;
        uint64_t v136 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v137 = lazy protocol witness table accessor for type Int and conformance Int(v132, v133, v134);
        uint64_t v138 = &v168;
LABEL_56:
        v136(v138, &type metadata for Int, v137, a3, a4);
        char v140 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v135, v128, a3);
        v127(v135, a3);
        if (v140) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
        }
        goto LABEL_57;
      }
      v139 = v166;
      v152(v166, v128, a3);
      (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v127(v139, a3);
LABEL_57:
      v127(v128, a3);
LABEL_58:
      v141 = v151;
      unint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v127(v141, a3);
      goto LABEL_59;
    }
    unint64_t v40 = -128;
    v169[0] = -128;
    uint64_t v41 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v42 = lazy protocol witness table accessor for type Int and conformance Int(v37, v38, v39);
    uint64_t v43 = v166;
    v41(v169, &type metadata for Int, v42, a3, a4);
    a2 = v159;
    char v44 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v159, v43, a3);
    (*(void (**)(char *, uint64_t))(v167 + 8))(v43, a3);
    a1 = v154;
    if ((v44 & 1) == 0) {
      goto LABEL_18;
    }
  }
LABEL_59:
  unint64_t v142 = *a1;
  unint64_t v143 = a1[1];
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(v169, v143, v142, v144);
  if ((v40 & 0x8000000000000000) != 0)
  {
    if (v40 <= 0xFFFFFFFFFFFFFF80)
    {
      uint64_t result = 0;
      uint64_t v147 = 0;
      goto LABEL_63;
    }
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    uint64_t result = specialized _wideMaskedShiftLeft<A>(_:_:)(v169, v143, v142, v148);
  }
  else if (v40 < 0x80)
  {
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(v169, v143, v142, v146);
  }
  uint64_t v147 = v169[0];
LABEL_63:
  *a1 = v147;
  a1[1] = result;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<< infix<A>(_:_:) in conformance _Int128@<X0>(unint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v5 = a4;
  v141 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v141, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v10 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  v139 = (char *)&v133 - v11;
  uint64_t v12 = *(void *)(a3 - 8);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  uint64_t v15 = (char *)&v133 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = MEMORY[0x1F4188790](v13);
  unint64_t v137 = (char *)&v133 - v17;
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  char v144 = (char *)&v133 - v19;
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  unint64_t v142 = (char *)&v133 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  uint64_t v138 = (char *)&v133 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  unint64_t v143 = (char *)&v133 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  char v148 = (char *)&v133 - v27;
  MEMORY[0x1F4188790](v26);
  uint64_t v152 = (char *)&v133 - v28;
  unint64_t v29 = *a1;
  unint64_t v153 = a1[1];
  uint64_t v30 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 64);
  char v31 = v30(a3, v5);
  uint64_t v149 = v5 + 64;
  uint64_t v151 = v30;
  if (v31)
  {
    uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
    uint64_t v33 = v32(a3, v5);
    uint64_t v150 = v32;
    if (v33 < 64)
    {
      uint64_t v36 = v152;
      (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v152, a2, a3);
      uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
      (*(void (**)(char *, uint64_t))(v12 + 8))(v36, a3);
      if (v37 >= -128) {
        goto LABEL_17;
      }
LABEL_31:
      unint64_t v42 = -128;
      goto LABEL_62;
    }
    unint64_t v42 = -128;
    v155[0] = -128;
    uint64_t v146 = v12;
    unint64_t v47 = v29;
    uint64_t v48 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
    unint64_t v49 = lazy protocol witness table accessor for type Int and conformance Int(v33, v34, v35);
    uint64_t v50 = v152;
    v48(v155, &type metadata for Int, v49, a3, v5);
    uint64_t v30 = v151;
    unint64_t v29 = v47;
    uint64_t v12 = v146;
    char v51 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(a2, v50, a3);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v50, a3);
    if (v51) {
      goto LABEL_62;
    }
LABEL_17:
    uint64_t v147 = a5;
    char v60 = v30(a3, v5);
    uint64_t v136 = v5 + 128;
    uint64_t v61 = v150(a3, v5);
    uint64_t v146 = v12;
    if (v60)
    {
      if (v61 > 64) {
        goto LABEL_19;
      }
    }
    else if (v61 > 63)
    {
LABEL_19:
      unint64_t v42 = 128;
      v155[0] = 128;
      unint64_t v64 = v29;
      uint64_t v65 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
      unint64_t v66 = lazy protocol witness table accessor for type Int and conformance Int(v61, v62, v63);
      unint64_t v67 = v152;
      v65(v155, &type metadata for Int, v66, a3, v5);
      uint64_t v30 = v151;
      unint64_t v29 = v64;
      uint64_t v12 = v146;
      a5 = v147;
      char v68 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(v67, a2, a3);
      uint64_t v134 = *(void (**)(char *, uint64_t))(v12 + 8);
      v134(v67, a3);
      if (v68) {
        goto LABEL_62;
      }
      goto LABEL_24;
    }
    char v69 = v152;
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v152, a2, a3);
    uint64_t v70 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
    uint64_t v134 = *(void (**)(char *, uint64_t))(v12 + 8);
    v134(v69, a3);
    a5 = v147;
    if (v70 > 128)
    {
      unint64_t v42 = 128;
      goto LABEL_62;
    }
LABEL_24:
    unint64_t v71 = *(void (**)(char *, uint64_t, uint64_t))(v12 + 16);
    uint64_t v72 = v30;
    char v73 = v148;
    v71(v148, a2, a3);
    char v74 = v72(a3, v5);
    uint64_t v75 = v143;
    unint64_t v135 = (void (*)(char *, char *, uint64_t))v71;
    v71(v143, (uint64_t)v73, a3);
    unint64_t v145 = v29;
    if ((v74 & 1) == 0)
    {
      uint64_t v77 = v134;
      v134(v75, a3);
      a5 = v147;
      goto LABEL_45;
    }
    uint64_t v76 = v150(a3, v5);
    uint64_t v77 = v134;
    unint64_t v143 = (char *)(v12 + 8);
    v134(v75, a3);
    a5 = v147;
    if (v76 <= 64) {
      goto LABEL_45;
    }
    uint64_t v78 = v138;
    v135(v138, v148, a3);
    v155[0] = 0x8000000000000000;
    BOOL v79 = v151;
    if (v151(a3, v5))
    {
      uint64_t v80 = v150(a3, v5);
      if (v80 < 64)
      {
        uint64_t v83 = v78;
        uint64_t v84 = v152;
        v135(v152, v78, a3);
        uint64_t v85 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
        uint64_t v86 = v84;
        uint64_t v87 = a3;
        uint64_t v77 = v134;
        goto LABEL_38;
      }
    }
    else
    {
      char v89 = v79(a3, v5);
      uint64_t v80 = v150(a3, v5);
      uint64_t v83 = v78;
      if ((v89 & 1) == 0)
      {
        uint64_t v77 = v134;
        if (v80 < 64)
        {
          BOOL v97 = v152;
          v135(v152, v83, a3);
          uint64_t v85 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
          uint64_t v86 = v97;
          uint64_t v87 = a3;
LABEL_38:
          v77(v86, v87);
          if (v85 < v155[0]) {
            goto LABEL_72;
          }
        }
LABEL_44:
        v77(v83, a3);
LABEL_45:
        uint64_t v109 = v148;
        unint64_t v110 = v150;
        uint64_t v111 = v150(a3, v5);
        uint64_t v112 = v5;
        unint64_t v113 = v142;
        v135(v142, v109, a3);
        if (v111 < 65)
        {
          uint64_t v123 = v110(a3, v112);
          v77(v113, a3);
          if (v123 != 64)
          {
            uint64_t v114 = v112;
LABEL_60:
            unint64_t v127 = v148;
            unint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t))(v114 + 120))(a3, v114);
            v77(v127, a3);
            goto LABEL_61;
          }
          uint64_t v114 = v112;
          if (v151(a3, v112)) {
            goto LABEL_60;
          }
        }
        else
        {
          uint64_t v114 = v112;
          v77(v113, a3);
        }
        v135(v144, v148, a3);
        v155[0] = 0x7FFFFFFFFFFFFFFFLL;
        char v115 = v151(a3, v114);
        uint64_t v116 = v150(a3, v114);
        if (v115)
        {
          if (v116 > 64)
          {
            uint64_t v119 = a5;
            uint64_t v120 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v114 + 96);
            unint64_t v121 = lazy protocol witness table accessor for type Int and conformance Int(v116, v117, v118);
            unint64_t v122 = v155;
LABEL_57:
            uint64_t v125 = v152;
            v120(v122, &type metadata for Int, v121, a3, v114);
            char v126 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v114 + 32) + 8) + 16))(v125, v144, a3);
            v77(v125, a3);
            if (v126) {
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
            }
            a5 = v119;
            goto LABEL_59;
          }
        }
        else if (v116 > 63)
        {
          uint64_t v119 = a5;
          uint64_t v154 = 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v120 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v114 + 96);
          unint64_t v121 = lazy protocol witness table accessor for type Int and conformance Int(v116, v117, v118);
          unint64_t v122 = &v154;
          goto LABEL_57;
        }
        uint64_t v124 = v152;
        v135(v152, v144, a3);
        (*(void (**)(uint64_t, uint64_t))(v114 + 120))(a3, v114);
        v77(v124, a3);
LABEL_59:
        v77(v144, a3);
        goto LABEL_60;
      }
      if (v80 <= 64)
      {
        char v99 = AssociatedTypeWitness;
        char v98 = v141;
        uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
        uint64_t v101 = v139;
        (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v99, AssociatedConformanceWitness);
        uint64_t v102 = v5;
        char v103 = v152;
        ((void (*)(char *, uint64_t, int **))v98[3])(v101, a3, v98);
        char v104 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v102 + 32) + 8) + 16))(v83, v103, a3);
        uint64_t v77 = v134;
        v134(v103, a3);
        uint64_t v105 = v137;
        v135(v137, v83, a3);
        if (v104)
        {
          v77(v105, a3);
          goto LABEL_72;
        }
        uint64_t v106 = v155[0];
        uint64_t v107 = (*(uint64_t (**)(uint64_t, uint64_t))(v102 + 120))(a3, v102);
        v77(v105, a3);
        BOOL v108 = v107 < v106;
        uint64_t v5 = v102;
        if (v108) {
LABEL_72:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        goto LABEL_44;
      }
    }
    uint64_t v90 = v5;
    uint64_t v91 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
    unint64_t v92 = lazy protocol witness table accessor for type Int and conformance Int(v80, v81, v82);
    unint64_t v93 = a5;
    uint64_t v94 = v152;
    v91(v155, &type metadata for Int, v92, a3, v90);
    uint64_t v5 = v90;
    uint64_t v83 = v138;
    char v95 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(v90 + 32) + 8) + 16))(v138, v94, a3);
    unint64_t v96 = v94;
    a5 = v93;
    uint64_t v77 = v134;
    v134(v96, a3);
    if (v95) {
      goto LABEL_72;
    }
    goto LABEL_44;
  }
  unint64_t v145 = v29;
  char v38 = v30(a3, v5);
  uint64_t v150 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 128);
  uint64_t v39 = ((uint64_t (*)(uint64_t))v150)(a3);
  if ((v38 & 1) == 0)
  {
    if (v39 >= 64)
    {
      uint64_t v30 = v151;
      unint64_t v29 = v145;
      goto LABEL_17;
    }
    uint64_t v52 = v152;
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v152, a2, a3);
    uint64_t v53 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
    (*(void (**)(char *, uint64_t))(v12 + 8))(v52, a3);
    uint64_t v30 = v151;
    unint64_t v29 = v145;
    if (v53 >= -128) {
      goto LABEL_17;
    }
    goto LABEL_31;
  }
  uint64_t v147 = a5;
  if (v39 <= 64)
  {
    uint64_t v54 = AssociatedTypeWitness;
    uint64_t v55 = v141;
    uint64_t v56 = swift_getAssociatedConformanceWitness((uint64_t)v141, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
    uint64_t v57 = v139;
    (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v56 + 8))(&qword_18162B0B8, 256, v54, v56);
    uint64_t v58 = v152;
    ((void (*)(char *, uint64_t, int **))v55[3])(v57, a3, v55);
    LOBYTE(v54) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(a2, v58, a3);
    uint64_t v59 = *(void (**)(char *, uint64_t))(v12 + 8);
    v59(v58, a3);
    (*(void (**)(char *, uint64_t, uint64_t))(v12 + 16))(v15, a2, a3);
    if (v54)
    {
      v59(v15, a3);
      unint64_t v42 = -128;
      a5 = v147;
LABEL_61:
      unint64_t v29 = v145;
      goto LABEL_62;
    }
    uint64_t v88 = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 120))(a3, v5);
    v59(v15, a3);
    uint64_t v30 = v151;
    a5 = v147;
    unint64_t v29 = v145;
    if (v88 < -128) {
      goto LABEL_31;
    }
    goto LABEL_17;
  }
  unint64_t v42 = -128;
  v155[0] = -128;
  uint64_t v43 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v5 + 96);
  unint64_t v44 = lazy protocol witness table accessor for type Int and conformance Int(v39, v40, v41);
  uint64_t v45 = v152;
  v43(v155, &type metadata for Int, v44, a3, v5);
  char v46 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(v5 + 32) + 8) + 16))(a2, v45, a3);
  (*(void (**)(char *, uint64_t))(v12 + 8))(v45, a3);
  a5 = v147;
  uint64_t v30 = v151;
  unint64_t v29 = v145;
  if ((v46 & 1) == 0) {
    goto LABEL_17;
  }
LABEL_62:
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(v155, v153, v29, v128);
  if ((v42 & 0x8000000000000000) != 0)
  {
    if (v42 > 0xFFFFFFFFFFFFFF80)
    {
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(v155, v153, v29, v132);
    }
  }
  else
  {
    if (v42 >= 0x80)
    {
      uint64_t result = 0;
      uint64_t v131 = 0;
      goto LABEL_66;
    }
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    uint64_t result = specialized _wideMaskedShiftLeft<A>(_:_:)(v155, v153, v29, v130);
  }
  uint64_t v131 = v155[0];
LABEL_66:
  *a5 = v131;
  a5[1] = result;
  return result;
}

uint64_t protocol witness for static BinaryInteger.<<= infix<A>(_:_:) in conformance _Int128(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v158 = *(int ***)(*(void *)(a4 + 24) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v158, a3, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated type descriptor for ExpressibleByIntegerLiteral.IntegerLiteralType);
  uint64_t v8 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v156 = (char *)&v149 - v9;
  uint64_t v167 = *(void *)(a3 - 8);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  uint64_t v12 = (char *)&v149 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v13 = MEMORY[0x1F4188790](v10);
  unint64_t v153 = (char *)&v149 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v160 = (char *)&v149 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v162 = (char *)&v149 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v155 = (char *)&v149 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v161 = (uint64_t)&v149 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  uint64_t v25 = (char *)&v149 - v24;
  MEMORY[0x1F4188790](v23);
  uint64_t v166 = (char *)&v149 - v26;
  uint64_t v28 = a4 + 64;
  uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 64);
  char v29 = v27(a3, a4);
  uint64_t v164 = v27;
  if (v29)
  {
    char v165 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v30 = v165(a3, a4);
    if (v30 < 64)
    {
      uint64_t v34 = v166;
      uint64_t v33 = v167;
      (*(void (**)(char *, uint64_t, uint64_t))(v167 + 16))(v166, a2, a3);
LABEL_12:
      uint64_t v52 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      (*(void (**)(char *, uint64_t))(v33 + 8))(v34, a3);
      if (v52 < -128)
      {
LABEL_13:
        unint64_t v40 = -128;
        goto LABEL_61;
      }
      goto LABEL_17;
    }
    unint64_t v40 = -128;
    v169[0] = -128;
    uint64_t v45 = v166;
    uint64_t v163 = a4 + 64;
    char v46 = v25;
    unint64_t v47 = a1;
    uint64_t v48 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v49 = lazy protocol witness table accessor for type Int and conformance Int(v30, v31, v32);
    v48(v169, &type metadata for Int, v49, a3, a4);
    a1 = v47;
    uint64_t v25 = v46;
    uint64_t v50 = v167;
    uint64_t v28 = v163;
    char v51 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(a2, v45, a3);
    (*(void (**)(char *, uint64_t))(v50 + 8))(v45, a3);
    if ((v51 & 1) == 0) {
      goto LABEL_17;
    }
  }
  else
  {
    char v35 = v27(a3, a4);
    uint64_t v36 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 128);
    uint64_t v159 = a2;
    char v165 = v36;
    uint64_t v37 = v36(a3, a4);
    if ((v35 & 1) == 0)
    {
      if (v37 >= 64)
      {
        a2 = v159;
        goto LABEL_17;
      }
      uint64_t v34 = v166;
      uint64_t v33 = v167;
      a2 = v159;
      (*(void (**)(char *, uint64_t, uint64_t))(v167 + 16))(v166, v159, a3);
      goto LABEL_12;
    }
    uint64_t v154 = a1;
    if (v37 <= 64)
    {
      uint64_t v53 = AssociatedTypeWitness;
      uint64_t v54 = v158;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v158, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
      uint64_t v56 = v156;
      (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 8))(&qword_18162B0B8, 256, v53, AssociatedConformanceWitness);
      uint64_t v57 = v166;
      ((void (*)(char *, uint64_t, int **))v54[3])(v56, a3, v54);
      uint64_t v58 = v159;
      LOBYTE(v53) = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v159, v57, a3);
      uint64_t v59 = v167;
      char v60 = v57;
      uint64_t v61 = *(void (**)(char *, uint64_t))(v167 + 8);
      v61(v60, a3);
      (*(void (**)(char *, uint64_t, uint64_t))(v59 + 16))(v12, v58, a3);
      if (v53)
      {
        v61(v12, a3);
        unint64_t v40 = -128;
        a1 = v154;
        goto LABEL_61;
      }
      uint64_t v98 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v61(v12, a3);
      a1 = v154;
      a2 = v159;
      if (v98 < -128) {
        goto LABEL_13;
      }
LABEL_17:
      char v62 = v164(a3, a4);
      uint64_t v159 = a4 + 128;
      uint64_t v63 = v165(a3, a4);
      uint64_t v163 = v28;
      if (v62)
      {
        if (v63 > 64) {
          goto LABEL_19;
        }
      }
      else if (v63 >= 64)
      {
LABEL_19:
        unint64_t v40 = 128;
        v169[0] = 128;
        unint64_t v66 = v166;
        unint64_t v67 = v25;
        char v68 = a1;
        char v69 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v70 = lazy protocol witness table accessor for type Int and conformance Int(v63, v64, v65);
        v69(v169, &type metadata for Int, v70, a3, a4);
        a1 = v68;
        uint64_t v25 = v67;
        uint64_t v71 = v167;
        char v72 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v66, a2, a3);
        char v73 = *(void (**)(char *, uint64_t))(v71 + 8);
        v73(v66, a3);
        if (v72) {
          goto LABEL_61;
        }
        goto LABEL_24;
      }
      uint64_t v75 = v166;
      uint64_t v74 = v167;
      (*(void (**)(char *, uint64_t, uint64_t))(v167 + 16))(v166, a2, a3);
      uint64_t v76 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      char v73 = *(void (**)(char *, uint64_t))(v74 + 8);
      v73(v75, a3);
      if (v76 > 128)
      {
        unint64_t v40 = 128;
        goto LABEL_61;
      }
LABEL_24:
      uint64_t v154 = a1;
      uint64_t v77 = v25;
      uint64_t v78 = *(void (**)(char *, uint64_t, uint64_t))(v167 + 16);
      v78(v77, a2, a3);
      char v79 = v164(a3, a4);
      uint64_t v80 = v161;
      uint64_t v81 = v77;
      uint64_t v152 = (void (*)(char *, char *, uint64_t))v78;
      v78((char *)v161, (uint64_t)v77, a3);
      uint64_t v150 = v73;
      uint64_t v151 = v77;
      if ((v79 & 1) == 0)
      {
        v73((char *)v80, a3);
        uint64_t v84 = v162;
        uint64_t v82 = v165;
        a1 = v154;
        uint64_t v85 = v81;
        goto LABEL_47;
      }
      uint64_t v82 = v165;
      uint64_t v83 = v165(a3, a4);
      v73((char *)v80, a3);
      uint64_t v84 = v162;
      a1 = v154;
      uint64_t v85 = v81;
      if (v83 <= 64) {
        goto LABEL_47;
      }
      uint64_t v86 = v155;
      v152(v155, v85, a3);
      v169[0] = 0x8000000000000000;
      uint64_t v87 = v164;
      if (v164(a3, a4))
      {
        uint64_t v88 = v165(a3, a4);
        uint64_t v91 = v86;
        if (v88 < 64)
        {
          unint64_t v92 = v166;
          v152(v166, v91, a3);
          uint64_t v93 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          uint64_t v94 = v92;
          char v95 = v150;
          v150(v94, a3);
          BOOL v96 = v93 < v169[0];
          BOOL v97 = v91;
          uint64_t v84 = v162;
          goto LABEL_41;
        }
        uint64_t v109 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v110 = lazy protocol witness table accessor for type Int and conformance Int(v88, v89, v90);
        uint64_t v111 = v166;
        v109(v169, &type metadata for Int, v110, a3, a4);
        uint64_t v85 = v151;
        a1 = v154;
        char v107 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v91, v111, a3);
        uint64_t v112 = v111;
        char v95 = v150;
        v150(v112, a3);
        BOOL v97 = v91;
        uint64_t v84 = v162;
      }
      else
      {
        char v99 = v87(a3, a4);
        uint64_t v100 = v165(a3, a4);
        if ((v99 & 1) == 0)
        {
          uint64_t v84 = v162;
          if (v100 >= 64)
          {
            v150(v155, a3);
            uint64_t v85 = v151;
            uint64_t v82 = v165;
            goto LABEL_47;
          }
          unint64_t v113 = v166;
          uint64_t v114 = v155;
          v152(v166, v155, a3);
          uint64_t v115 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          char v95 = v150;
          v150(v113, a3);
          BOOL v97 = v114;
          BOOL v96 = v115 < v169[0];
          uint64_t v85 = v151;
LABEL_41:
          uint64_t v82 = v165;
          if (!v96) {
            goto LABEL_46;
          }
LABEL_71:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent a signed value", 43, 2, "Swift/Integers.swift", 20, 2, 0xE61uLL, 0);
        }
        uint64_t v84 = v162;
        if (v100 <= 64)
        {
          uint64_t v116 = AssociatedTypeWitness;
          uint64_t v117 = v158;
          uint64_t v118 = swift_getAssociatedConformanceWitness((uint64_t)v158, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for ExpressibleByIntegerLiteral, associated conformance descriptor for ExpressibleByIntegerLiteral.ExpressibleByIntegerLiteral.IntegerLiteralType: _ExpressibleByBuiltinIntegerLiteral);
          uint64_t v119 = v156;
          (*(void (**)(uint64_t *, uint64_t, const char *, uint64_t))(v118 + 8))(&qword_18162B0B8, 256, v116, v118);
          uint64_t v120 = v166;
          ((void (*)(char *, uint64_t, int **))v117[3])(v119, a3, v117);
          unint64_t v121 = v155;
          LODWORD(v161) = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8)
                                                                             + 16))(v155, v120, a3);
          unint64_t v122 = v120;
          char v95 = v150;
          v150(v122, a3);
          uint64_t v123 = v153;
          v152(v153, v121, a3);
          uint64_t v82 = v165;
          if (v161)
          {
            v95(v123, a3);
            goto LABEL_71;
          }
          uint64_t v161 = v169[0];
          uint64_t v124 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
          v95(v123, a3);
          BOOL v96 = v124 < v161;
          uint64_t v85 = v151;
          BOOL v97 = v155;
          if (v96) {
            goto LABEL_71;
          }
          goto LABEL_46;
        }
        char v103 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v104 = lazy protocol witness table accessor for type Int and conformance Int(v100, v101, v102);
        uint64_t v105 = v166;
        v103(v169, &type metadata for Int, v104, a3, a4);
        a1 = v154;
        uint64_t v106 = v155;
        char v107 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v155, v105, a3);
        BOOL v108 = v105;
        char v95 = v150;
        v150(v108, a3);
        BOOL v97 = v106;
        uint64_t v85 = v151;
      }
      uint64_t v82 = v165;
      if (v107) {
        goto LABEL_71;
      }
LABEL_46:
      v95(v97, a3);
LABEL_47:
      uint64_t v125 = v82(a3, a4);
      v152(v84, v85, a3);
      if (v125 < 65)
      {
        uint64_t v137 = v82(a3, a4);
        uint64_t v138 = v84;
        unint64_t v127 = v150;
        v150(v138, a3);
        char v128 = v160;
        if (v137 != 64 || (v164(a3, a4) & 1) != 0) {
          goto LABEL_60;
        }
      }
      else
      {
        char v126 = v84;
        unint64_t v127 = v150;
        v150(v126, a3);
        char v128 = v160;
      }
      v152(v128, v151, a3);
      v169[0] = 0x7FFFFFFFFFFFFFFFLL;
      char v129 = v164(a3, a4);
      uint64_t v130 = v165(a3, a4);
      if (v129)
      {
        if (v130 > 64)
        {
          uint64_t v133 = v166;
          uint64_t v134 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
          unint64_t v135 = lazy protocol witness table accessor for type Int and conformance Int(v130, v131, v132);
          uint64_t v136 = v169;
          goto LABEL_58;
        }
      }
      else if (v130 >= 64)
      {
        uint64_t v168 = 0x7FFFFFFFFFFFFFFFLL;
        uint64_t v133 = v166;
        uint64_t v134 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
        unint64_t v135 = lazy protocol witness table accessor for type Int and conformance Int(v130, v131, v132);
        uint64_t v136 = &v168;
LABEL_58:
        v134(v136, &type metadata for Int, v135, a3, a4);
        char v140 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v133, v128, a3);
        v127(v133, a3);
        if (v140) {
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xE67uLL, 0);
        }
        goto LABEL_59;
      }
      v139 = v166;
      v152(v166, v128, a3);
      (*(void (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v127(v139, a3);
LABEL_59:
      v127(v128, a3);
LABEL_60:
      v141 = v151;
      unint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 120))(a3, a4);
      v127(v141, a3);
      goto LABEL_61;
    }
    unint64_t v40 = -128;
    v169[0] = -128;
    uint64_t v41 = *(void (**)(uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(a4 + 96);
    unint64_t v42 = lazy protocol witness table accessor for type Int and conformance Int(v37, v38, v39);
    uint64_t v43 = v166;
    v41(v169, &type metadata for Int, v42, a3, a4);
    a2 = v159;
    char v44 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)(*(void *)(a4 + 32) + 8) + 16))(v159, v43, a3);
    (*(void (**)(char *, uint64_t))(v167 + 8))(v43, a3);
    a1 = v154;
    if ((v44 & 1) == 0) {
      goto LABEL_17;
    }
  }
LABEL_61:
  unint64_t v142 = *a1;
  unint64_t v143 = a1[1];
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(v169, v143, v142, v144);
  if ((v40 & 0x8000000000000000) != 0)
  {
    if (v40 > 0xFFFFFFFFFFFFFF80)
    {
      specialized static FixedWidthInteger._truncatingInit<A>(_:)();
      uint64_t result = specialized _wideMaskedShiftRight<A>(_:_:)(v169, v143, v142, v148);
    }
  }
  else
  {
    if (v40 >= 0x80)
    {
      uint64_t result = 0;
      uint64_t v147 = 0;
      goto LABEL_65;
    }
    specialized static FixedWidthInteger._truncatingInit<A>(_:)();
    uint64_t result = specialized _wideMaskedShiftLeft<A>(_:_:)(v169, v143, v142, v146);
  }
  uint64_t v147 = v169[0];
LABEL_65:
  *a1 = v147;
  a1[1] = result;
  return result;
}

Swift::UInt64 protocol witness for BinaryInteger.quotientAndRemainder(dividingBy:) in conformance _Int128(Swift::UInt64 *a1, Swift::UInt64 *a2, Swift::_Int128 *a3)
{
  Swift::tuple_quotient__Int128_remainder__Int128 v6 = _Int128.quotientAndRemainder(dividingBy:)(*a3);
  *a1 = v6.quotient.low;
  a1[1] = v6.quotient.high;
  *a2 = v6.remainder.low;
  a2[1] = v6.remainder.high;
  return v6.quotient.low;
}

BOOL protocol witness for BinaryInteger.isMultiple(of:) in conformance _Int128(uint64_t *a1)
{
  return specialized SignedInteger<>.isMultiple(of:)(*a1, a1[1], *v1, v1[1]);
}

BOOL protocol witness for BinaryInteger.signum() in conformance _Int128@<W0>(BOOL *a1@<X8>)
{
  BOOL result = specialized BinaryInteger.signum()(*(void *)v1, *(void *)(v1 + 8));
  *a1 = result;
  a1[1] = v4;
  return result;
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance _Int128(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void protocol witness for LosslessStringConvertible.init(_:) in conformance _UInt128(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t (*a3)(void)@<X4>, uint64_t (*a4)(void *, uint64_t, uint64_t)@<X5>, uint64_t a5@<X8>)
{
  uint64_t v7 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0) {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v7)
  {
    uint64_t v10 = a3();
    if ((v12 & 0x100) != 0)
    {
      uint64_t v13 = specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10, a4);
      uint64_t v14 = v17;
      char v19 = v18;
      swift_bridgeObjectRelease(a2);
      int v16 = v19 & 1;
    }
    else
    {
      uint64_t v13 = v10;
      uint64_t v14 = v11;
      char v15 = v12;
      swift_bridgeObjectRelease(a2);
      int v16 = v15 & 1;
    }
    if (v16) {
      uint64_t v20 = 0;
    }
    else {
      uint64_t v20 = v13;
    }
    if (v16) {
      uint64_t v21 = 0;
    }
    else {
      uint64_t v21 = v14;
    }
  }
  else
  {
    swift_bridgeObjectRelease(a2);
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    LOBYTE(v16) = 1;
  }
  *(void *)a5 = v20;
  *(void *)(a5 + 8) = v21;
  *(unsigned char *)(a5 + 16) = v16;
}

void protocol witness for Strideable.distance(to:) in conformance _Int128(unint64_t *a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  unint64_t v6 = *v2;
  uint64_t v7 = v2[1];
  if (v7)
  {
    if (v5)
    {
      if (v5 < 0 != v7 < 0)
      {
        if (v7 < 0)
        {
          BOOL v11 = v6 == 0;
          unint64_t v6 = -(uint64_t)v6;
          if (v11) {
            uint64_t v7 = -v7;
          }
          else {
            uint64_t v7 = ~v7;
          }
          char v8 = 1;
          if ((v5 & 0x8000000000000000) == 0) {
            goto LABEL_38;
          }
        }
        else
        {
          char v8 = 0;
          if ((v5 & 0x8000000000000000) == 0)
          {
            uint64_t v9 = v7 + v5;
            unint64_t v10 = v6 + v4;
            if (!__CFADD__(v6, v4)) {
              goto LABEL_45;
            }
            goto LABEL_44;
          }
        }
LABEL_10:
        BOOL v11 = v4 == 0;
        unint64_t v4 = -(uint64_t)v4;
        uint64_t v5 = -(v5 + !v11);
LABEL_38:
        unint64_t v10 = v6 + v4;
        BOOL v21 = __CFADD__(v6, v4);
        BOOL v11 = __CFADD__(v7, v5);
        uint64_t v9 = v7 + v5;
        if (v11) {
          goto LABEL_54;
        }
        if (!v21)
        {
LABEL_45:
          uint64_t v22 = 0;
LABEL_46:
          unint64_t v23 = v22 + v9;
          specialized static FixedWidthInteger._truncatingInit<A>(_:)();
          BOOL v26 = v25 < v10;
          if (v24 != v23) {
            BOOL v26 = v24 < v23;
          }
          if (!v26)
          {
            if (v8) {
              goto LABEL_51;
            }
            BOOL v27 = __OFSUB__(0, v10);
            unint64_t v10 = -(uint64_t)v10;
            if (!v27) {
              goto LABEL_51;
            }
            __break(1u);
          }
LABEL_53:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Distance is not representable in Int", 36, 2, "Swift/Integers.swift", 20, 2, 0x64AuLL, 0);
        }
        if (v9 == -1) {
LABEL_54:
        }
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x6BuLL, 0);
LABEL_44:
        uint64_t v22 = 1;
        goto LABEL_46;
      }
    }
    else if (v7 < 0)
    {
      BOOL v11 = v6 == 0;
      unint64_t v6 = -(uint64_t)v6;
      uint64_t v5 = 0;
      if (v11) {
        uint64_t v7 = -v7;
      }
      else {
        uint64_t v7 = ~v7;
      }
      char v8 = 1;
      goto LABEL_38;
    }
  }
  else if (v5 < 0)
  {
    uint64_t v7 = 0;
    char v8 = 0;
    goto LABEL_10;
  }
  unint64_t v10 = v4 - v6;
  BOOL v12 = v4 < v6;
  uint64_t v13 = v5 - v7;
  BOOL v14 = __OFSUB__(v5, v7);
  if (v12)
  {
    if (v13 == 0x8000000000000000) {
      LOBYTE(v14) = 1;
    }
    if (v14) {
LABEL_19:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x252uLL, 0);
    --v13;
  }
  else if (v14)
  {
    goto LABEL_19;
  }
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  BOOL v17 = v10 < v16;
  if (v13 != v15) {
    BOOL v17 = v13 < v15;
  }
  if (v17) {
    goto LABEL_53;
  }
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  BOOL v20 = v19 < v10;
  if (v18 != v13) {
    BOOL v20 = v18 < v13;
  }
  if (v20) {
    goto LABEL_53;
  }
LABEL_51:
  *a2 = v10;
}

void protocol witness for Strideable.advanced(by:) in conformance _Int128(void *a1@<X8>)
{
  uint64_t v4 = *v1;
  uint64_t v3 = v1[1];
  specialized static FixedWidthInteger._truncatingInit<A>(_:)();
  BOOL v7 = __CFADD__(v4, v5);
  uint64_t v8 = v3 + v6;
  if (__OFADD__(v3, v6) || (v7 ? (BOOL v9 = v8 == 0x7FFFFFFFFFFFFFFFLL) : (BOOL v9 = 0), v9)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x25EuLL, 0);
  }
  *a1 = v4 + v5;
  a1[1] = v8 + v7;
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance _Int128(uint64_t a1, uint64_t a2, char a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return protocol witness for static Strideable._step(after:from:by:) in conformance _UInt128(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t (*)(uint64_t, uint64_t, void, void, void, void, void, void))specialized static Strideable<>._step(after:from:by:));
}

uint64_t protocol witness for static Strideable._step(after:from:by:) in conformance _UInt128(uint64_t a1, uint64_t a2, char a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, void, void, void, void, void, void))
{
  return a9(a1, a2, a3 & 1, *a4, a4[1], *a5, a5[1], *a6);
}

Swift::UInt64 specialized _wideDivide32<A>(_:by:)(void *a1, unint64_t *a2, Swift::tuple_high_UInt64_low_UInt64 a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  Swift::UInt64 low = a3.low;
  Swift::UInt64 high = a3.high;
  if (a3.high == a5) {
    Swift::UInt64 result = -1;
  }
  else {
    Swift::UInt64 result = UInt64.dividingFullWidth(_:)(a3).quotient;
  }
  unint64_t v14 = result * a6;
  Swift::UInt64 v15 = (__PAIR128__(a5, a6) * result) >> 64;
  if (__CFADD__((result * (unsigned __int128)a6) >> 64, result * a5)) {
    Swift::UInt64 v16 = ((result * (unsigned __int128)a5) >> 64) + 1;
  }
  else {
    Swift::UInt64 v16 = (result * (unsigned __int128)a5) >> 64;
  }
  BOOL v17 = high >= v16;
  if (high != v16) {
    goto LABEL_14;
  }
LABEL_11:
  BOOL v17 = low >= v15;
  if (low != v15)
  {
    while (1)
    {
LABEL_14:
      if (v17) {
        goto LABEL_26;
      }
LABEL_15:
      BOOL v18 = __CFADD__(a4, a6);
      Swift::UInt64 v19 = low + a5;
      if (__CFADD__(low, a5)) {
        break;
      }
      if (v19 == -1)
      {
        if (!v18)
        {
          Swift::UInt64 low = -1;
          goto LABEL_10;
        }
        Swift::UInt64 low = 0;
LABEL_24:
        ++high;
        --result;
        a4 += a6;
        BOOL v17 = high >= v16;
        if (high == v16) {
          goto LABEL_11;
        }
      }
      else
      {
        Swift::UInt64 low = v19 + v18;
LABEL_10:
        a4 += a6;
        --result;
        BOOL v17 = high >= v16;
        if (high == v16) {
          goto LABEL_11;
        }
      }
    }
    Swift::UInt64 low = v19 + v18;
    goto LABEL_24;
  }
  if (a4 < v14) {
    goto LABEL_15;
  }
  Swift::UInt64 low = v15;
LABEL_26:
  BOOL v17 = a4 >= v14;
  unint64_t v20 = a4 - v14;
  uint64_t v21 = !v17;
  *a1 = low - v15 - v21;
  *a2 = v20;
  return result;
}

uint64_t < infix<A, B, C>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  char v35 = (char *)a4;
  uint64_t v36 = a5;
  uint64_t v34 = a3;
  uint64_t v37 = a10;
  uint64_t v38 = a6;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, a7, a8, a9, 0, 0);
  uint64_t v39 = *(TupleTypeMetadata3 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](TupleTypeMetadata3);
  BOOL v18 = (char *)&v30 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  unint64_t v20 = (char *)&v30 - v19;
  uint64_t v21 = *(void *)(a7 - 8);
  uint64_t v32 = *(void (**)(char *, uint64_t, uint64_t))(v21 + 16);
  uint64_t v33 = v21 + 16;
  v32((char *)&v30 - v19, a1, a7);
  uint64_t v22 = *(void (**)(void))(*(void *)(a8 - 8) + 16);
  uint64_t v31 = &v20[*((int *)TupleTypeMetadata3 + 12)];
  v22();
  unint64_t v23 = *(void (**)(void))(*(void *)(a9 - 8) + 16);
  uint64_t v30 = &v20[*((int *)TupleTypeMetadata3 + 16)];
  v23();
  v32(v18, (uint64_t)v35, a7);
  char v35 = &v18[*((int *)TupleTypeMetadata3 + 12)];
  uint64_t v36 = a8;
  v22();
  uint64_t v24 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 16)];
  ((void (*)(uint64_t, uint64_t, uint64_t))v23)(v24, v38, a9);
  uint64_t v25 = v37;
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v37 + 8) + 8))(v20, v18, a7)) {
    char v26 = < infix<A, B>(_:_:)((uint64_t)v31, (uint64_t)v30, (uint64_t)v35, v24, v36, a9, a11, a12);
  }
  else {
    char v26 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v25 + 16))(v20, v18, a7, v25);
  }
  char v27 = v26;
  uint64_t v28 = *(void (**)(char *, uint64_t *))(v39 + 8);
  v28(v18, TupleTypeMetadata3);
  v28(v20, TupleTypeMetadata3);
  return v27 & 1;
}

uint64_t > infix<A, B>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v26 = a8;
  uint64_t v27 = a2;
  uint64_t v29 = a7;
  uint64_t v30 = a4;
  uint64_t v28 = a3;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a5, a6, 0, 0);
  uint64_t v31 = *(TupleTypeMetadata2 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  unint64_t v14 = (char *)&v26 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v26 - v15;
  uint64_t v17 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16);
  v17((char *)&v26 - v15, a1, a5);
  BOOL v18 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v19 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a6 - 8) + 16);
  v19(v18, v27, a6);
  v17(v14, v28, a5);
  uint64_t v20 = v29;
  uint64_t v21 = &v14[*((int *)TupleTypeMetadata2 + 12)];
  v19(v21, v30, a6);
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v20 + 8) + 8))(v16, v14, a5)) {
    char v22 = (*(uint64_t (**)(char *, char *, uint64_t))(v26 + 40))(v18, v21, a6);
  }
  else {
    char v22 = (*(uint64_t (**)(char *, char *, uint64_t))(v20 + 40))(v16, v14, a5);
  }
  char v23 = v22;
  uint64_t v24 = *(void (**)(char *, uint64_t *))(v31 + 8);
  v24(v14, TupleTypeMetadata2);
  v24(v16, TupleTypeMetadata2);
  return v23 & 1;
}

uint64_t >= infix<A, B>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v26 = a8;
  uint64_t v27 = a2;
  uint64_t v29 = a7;
  uint64_t v30 = a4;
  uint64_t v28 = a3;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a5, a6, 0, 0);
  uint64_t v31 = *(TupleTypeMetadata2 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  unint64_t v14 = (char *)&v26 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v26 - v15;
  uint64_t v17 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16);
  v17((char *)&v26 - v15, a1, a5);
  BOOL v18 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v19 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a6 - 8) + 16);
  v19(v18, v27, a6);
  v17(v14, v28, a5);
  uint64_t v20 = v29;
  uint64_t v21 = &v14[*((int *)TupleTypeMetadata2 + 12)];
  v19(v21, v30, a6);
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v20 + 8) + 8))(v16, v14, a5)) {
    char v22 = (*(uint64_t (**)(char *, char *, uint64_t))(v26 + 32))(v18, v21, a6);
  }
  else {
    char v22 = (*(uint64_t (**)(char *, char *, uint64_t))(v20 + 32))(v16, v14, a5);
  }
  char v23 = v22;
  uint64_t v24 = *(void (**)(char *, uint64_t *))(v31 + 8);
  v24(v14, TupleTypeMetadata2);
  v24(v16, TupleTypeMetadata2);
  return v23 & 1;
}

uint64_t *protocol witness for static SignedNumeric.- prefix(_:) in conformance _Int128@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  BOOL v4 = __OFSUB__(0, v2);
  uint64_t v5 = -v2;
  int v6 = v4;
  BOOL v7 = v3 == 0;
  uint64_t v8 = -v3;
  if (v7)
  {
    if (v6) {
      goto LABEL_8;
    }
  }
  else
  {
    if (v5 == 0x8000000000000000) {
      LOBYTE(v6) = 1;
    }
    if (v6) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x252uLL, 0);
    --v5;
  }
  *a2 = v8;
  a2[1] = v5;
  return result;
}

void protocol witness for SignedNumeric.negate() in conformance _Int128()
{
  uint64_t v2 = *v0;
  uint64_t v1 = v0[1];
  BOOL v3 = __OFSUB__(0, v1);
  uint64_t v4 = -v1;
  int v5 = v3;
  BOOL v6 = v2 == 0;
  uint64_t v7 = -v2;
  if (v6)
  {
    if (v5) {
      goto LABEL_8;
    }
  }
  else
  {
    if (v4 == 0x8000000000000000) {
      LOBYTE(v5) = 1;
    }
    if (v5) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x252uLL, 0);
    --v4;
  }
  uint64_t *v0 = v7;
  v0[1] = v4;
}

_OWORD *protocol witness for static SignedInteger._maskingAdd(_:_:) in conformance _Int128@<X0>(_OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  *a3 = *result + *a2;
  return result;
}

_OWORD *protocol witness for static SignedInteger._maskingSubtract(_:_:) in conformance _Int128@<X0>(_OWORD *result@<X0>, _OWORD *a2@<X1>, _OWORD *a3@<X8>)
{
  *a3 = *result - *a2;
  return result;
}

uint64_t UnsafeMutableBufferPointer.count.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

char *UnsafeMutableBufferPointer._copyContents(initializing:)(char *__dst, uint64_t a2, char *__src, uint64_t a4, unint64_t *a5)
{
  BOOL v6 = __src;
  if (a4 && a2)
  {
    if (a4 >= a2) {
      uint64_t v7 = a2;
    }
    else {
      uint64_t v7 = a4;
    }
    UnsafeMutablePointer.initialize(from:count:)(__src, v7, __dst, a5);
    v6 += *(void *)(*(a5 - 1) + 72) * v7;
  }
  return v6;
}

uint64_t protocol witness for Sequence.makeIterator() in conformance UnsafeMutableBufferPointer<A>@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Sequence.makeIterator() in conformance UnsafeMutableBufferPointer<A>(a1, (uint64_t (*)(void, void, void))UnsafeMutableBufferPointer.makeIterator(), a2);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance UnsafeMutableBufferPointer<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a1, a3);

  return Collection.underestimatedCount.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeMutableBufferPointer<A>(unint64_t *a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeMutableBufferPointer<A>(a1, a2, protocol conformance descriptor for UnsafeMutableBufferPointer<A>);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableBufferPointer<A>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, void, void, void))UnsafeMutableBufferPointer._copyContents(initializing:));
}

Swift::Int __swiftcall UnsafeMutableBufferPointer.index(after:)(Swift::Int after)
{
  return UnsafeMutableBufferPointer.index(after:)(after, v1, v2, v3, 0xC9uLL);
}

Swift::Void __swiftcall UnsafeMutableBufferPointer.formIndex(after:)(Swift::Int *after)
{
  UnsafeMutableBufferPointer.formIndex(after:)(after, v1, v2, v3, 0xD7uLL);
}

Swift::Int __swiftcall UnsafeMutableBufferPointer.index(before:)(Swift::Int before)
{
  return UnsafeMutableBufferPointer.index(before:)(before, v1, v2, v3, 0xE5uLL);
}

Swift::Void __swiftcall UnsafeMutableBufferPointer.formIndex(before:)(Swift::Int *before)
{
  UnsafeMutableBufferPointer.formIndex(before:)(before, v1, v2, v3, 0xF3uLL);
}

Swift::Int_optional __swiftcall UnsafeMutableBufferPointer.index(_:offsetBy:limitedBy:)(Swift::Int _, Swift::Int offsetBy, Swift::Int limitedBy)
{
  Swift::Int v3 = specialized UnsafeBufferPointer.index(_:offsetBy:limitedBy:)(_, offsetBy, limitedBy, 0x10FuLL, 0x117uLL);
  Swift::Bool v5 = v4 & 1;
  result.value = v3;
  result.is_nil = v5;
  return result;
}

Swift::Void __swiftcall UnsafeMutableBufferPointer.swapAt(_:_:)(Swift::Int a1, Swift::Int a2)
{
  Swift::Int v3 = v2;
  uint64_t v4 = *(v2 - 1);
  uint64_t v5 = MEMORY[0x1F4188790](a1);
  unint64_t v10 = (char *)&v15 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v5 != v6)
  {
    if (v5 < 0 || v6 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x17AuLL, 0);
    }
    if (v8 <= v5 || v8 <= v6) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x17BuLL, 0);
    }
    if (!v7) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x17CuLL, 0);
    }
    BOOL v11 = *(void (**)(char *, char *, unint64_t *))(v4 + 32);
    uint64_t v12 = *(void *)(v4 + 72);
    uint64_t v13 = (char *)(v7 + v12 * v5);
    unint64_t v14 = (char *)(v7 + v12 * v6);
    v11(v10, v13, v3);
    UnsafeMutablePointer.moveInitialize(from:count:)(v14, 1, v13, v3);
    v11(v14, v10, v3);
  }
}

uint64_t UnsafeMutableBufferPointer.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  return UnsafeBufferPointer.subscript.getter(a1, a2, a3, a4, 0x206uLL, 0x207uLL, a5);
}

uint64_t UnsafeBufferPointer.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t a5@<X4>, unint64_t a6@<X5>, uint64_t a7@<X8>)
{
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  }
  if (a3 <= a1) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a6, 0);
  }
  uint64_t v7 = *(void *)(a4 - 8);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 16);
  uint64_t v9 = a2 + *(void *)(v7 + 72) * a1;

  return v8(a7, v9, a4);
}

uint64_t key path getter for UnsafeMutableBufferPointer.subscript(_:) : <A>UnsafeMutableBufferPointer<A>A@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4 = *a2;
  if (*a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x206uLL, 0);
  }
  if (v4 >= a1[1]) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x207uLL, 0);
  }
  uint64_t v5 = *(void *)(*(uint64_t *)((char *)a2 + a3 - 8) - 8);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 16);
  uint64_t v7 = *a1 + *(void *)(v5 + 72) * v4;

  return v6(a4, v7);
}

uint64_t key path setter for UnsafeMutableBufferPointer.subscript(_:) : <A>UnsafeMutableBufferPointer<A>A(uint64_t a1, void *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = *a3;
  if (*a3 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20DuLL, 0);
  }
  if (v4 >= a2[1]) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20EuLL, 0);
  }
  uint64_t v6 = *(void *)(*(uint64_t *)((char *)a3 + a4 - 8) - 8);
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 24);
  uint64_t v8 = *a2 + *(void *)(v6 + 72) * v4;

  return v7(v8, a1);
}

uint64_t UnsafeMutableBufferPointer.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *(void *)(a5 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v12 = (char *)&v15 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v12, a1, v13);
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20DuLL, 0);
  }
  if (a4 <= a2) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20EuLL, 0);
  }
  (*(void (**)(uint64_t, uint64_t))(v10 + 8))(a1, a5);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v10 + 40))(a3 + *(void *)(v10 + 72) * a2, v12, a5);
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a5 - 8) + 40))(a3 + *(void *)(*(void *)(a5 - 8) + 72) * a2, a1, a5);
}

uint64_t key path getter for UnsafeMutableBufferPointer.subscript(_unchecked:) : <A>UnsafeMutableBufferPointer<A>A(void *a1, void *a2)
{
  return UnsafeBufferPointer.subscript.getter(*a2, *a1);
}

uint64_t key path setter for UnsafeMutableBufferPointer.subscript(_unchecked:) : <A>UnsafeMutableBufferPointer<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a4 + a3 - 8);
  uint64_t v6 = UnsafeMutableBufferPointer.subscript.modify();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 24))(v7, a1, v5);
  return ((uint64_t (*)(uint64_t *, void))v6)(&v9, 0);
}

uint64_t (*UnsafeMutableBufferPointer.subscript.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(a1, a2, a3, a4, a5, a6, 0x234uLL, 0x235uLL);
}

uint64_t UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(a1, a2, a3, a4, a5, a6, a7, 0x23BuLL, 0x23CuLL);
}

uint64_t key path getter for UnsafeMutableBufferPointer.subscript(_:) : <A>UnsafeMutableBufferPointer<A>A@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t *a4@<X8>)
{
  uint64_t result = UnsafeMutableBufferPointer.subscript.getter(*a2, a2[1], *a1, a1[1], a3);
  *a4 = result;
  a4[1] = v6;
  a4[2] = v7;
  a4[3] = v8;
  return result;
}

char *key path setter for UnsafeMutableBufferPointer.subscript(_:) : <A>UnsafeMutableBufferPointer<A>A(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  return UnsafeMutableBufferPointer.subscript.setter(*a1, a1[1], a1[2], a1[3], *a3, a3[1], *a2, a2[1], *(unint64_t **)((char *)a3 + a4 - 8));
}

char *UnsafeMutableBufferPointer.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t *a9)
{
  if (a5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x26CuLL, 0);
  }
  if (a8 < a6) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x26DuLL, 0);
  }
  uint64_t v10 = (char *)(a6 - a5);
  if (__OFSUB__(a6, a5))
  {
    __break(1u);
LABEL_14:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x26EuLL, 0);
  }
  uint64_t v15 = (unint64_t *)type metadata accessor for UnsafeMutableBufferPointer(255, (uint64_t)a9, a3, a4);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for UnsafeMutableBufferPointer<A>, v15, v16);
  uint64_t v19 = (unint64_t *)type metadata accessor for Slice(0, (uint64_t)v15, WitnessTable, v18);
  uint64_t v21 = swift_getWitnessTable(protocol conformance descriptor for Slice<A>, v19, v20);
  uint64_t result = (char *)Collection.count.getter((uint64_t)v19, v21);
  if (v10 != result) {
    goto LABEL_14;
  }
  if (a1 == a2) {
    return result;
  }
  if (!a7)
  {
    unint64_t v23 = 626;
    goto LABEL_18;
  }
  if (!a3)
  {
    unint64_t v23 = 627;
LABEL_18:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v23, 0);
  }
  if (__OFSUB__(a2, a1)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x129uLL, 0);
  }
  return UnsafeMutablePointer.assign(from:count:)((char *)(a3 + *(void *)(*(a9 - 1) + 72) * a1), a2 - a1, (char *)(a7 + *(void *)(*(a9 - 1) + 72) * a5), a9);
}

void (*UnsafeMutableBufferPointer.subscript.modify(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6))(uint64_t **a1)
{
  uint64_t v12 = malloc(0x48uLL);
  *a1 = v12;
  v12[7] = a5;
  v12[8] = a6;
  v12[5] = a3;
  v12[6] = a4;
  v12[4] = a2;
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x265uLL, 0);
  }
  if (a5 < a3) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x266uLL, 0);
  }
  *uint64_t v12 = a2;
  v12[1] = a3;
  v12[2] = a4;
  v12[3] = a5;
  return UnsafeMutableBufferPointer.subscript.modify;
}

void UnsafeMutableBufferPointer.subscript.modify(uint64_t **a1)
{
  uint64_t v1 = *a1;
  UnsafeMutableBufferPointer.subscript.setter(**a1, v1[1], v1[2], (*a1)[3], (*a1)[4], (*a1)[5], (*a1)[6], (*a1)[7], (unint64_t *)(*a1)[8]);

  free(v1);
}

uint64_t UnsafeMutableBufferPointer._withUnsafeMutableBufferPointerIfSupported<A>(_:)@<X0>(uint64_t (*a1)(uint64_t)@<X0>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t result = a1(v3);
  if (!v4) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a2 - 8) + 56))(a3, 0, 1, a2);
  }
  return result;
}

BOOL UnsafeMutableBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)@<W0>(void (*a1)(uint64_t *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v6 = v4;
  uint64_t v11 = *v4;
  uint64_t v10 = v4[1];
  a1(v4);
  if (v5)
  {
    uint64_t v14 = v4[1];
    uint64_t v15 = *(void *)(a2 + 16);
    uint64_t v31 = *v6;
    uint64_t v32 = v11;
    uint64_t v16 = type metadata accessor for UnsafeMutablePointer(255, v15, v12, v13);
    uint64_t v19 = (unint64_t *)type metadata accessor for Optional(0, (uint64_t)v16, v17, v18);
    uint64_t v30 = &protocol witness table for UnsafeMutablePointer<A>;
    uint64_t v20 = &v30;
  }
  else
  {
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a3 - 8) + 56))(a4, 0, 1, a3);
    uint64_t v14 = v4[1];
    uint64_t v21 = *(void *)(a2 + 16);
    uint64_t v31 = *v6;
    uint64_t v32 = v11;
    uint64_t v24 = type metadata accessor for UnsafeMutablePointer(255, v21, v22, v23);
    uint64_t v19 = (unint64_t *)type metadata accessor for Optional(0, (uint64_t)v24, v25, v26);
    uint64_t v29 = &protocol witness table for UnsafeMutablePointer<A>;
    uint64_t v20 = &v29;
  }
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for <A> A?, v19, (uint64_t)v20);
  BOOL result = specialized == infix<A, B>(_:_:)((uint64_t)&v32, v10, (uint64_t)&v31, v14, (uint64_t)v19, WitnessTable);
  if (!result) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer.withContiguousMutableStorageIfAvailable: replacing the buffer is not allowed", 103, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x289uLL, 0);
  }
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UnsafeMutableBufferPointer<A>(void *a1, uint64_t *a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x28uLL);
  *a1 = v7;
  v7[4] = UnsafeMutableBufferPointer.subscript.read(v7, *a2, *v3, v3[1], *(void *)(a3 + 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

uint64_t (*UnsafeMutableBufferPointer.subscript.read(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))()
{
  uint64_t v7 = *(void *)(a5 - 8);
  uint64_t v8 = v7;
  *a1 = a5;
  a1[1] = v7;
  a1[2] = malloc(*(void *)(v7 + 64));
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x206uLL, 0);
  }
  if (a4 <= a2) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x207uLL, 0);
  }
  (*(void (**)(void))(v8 + 16))();
  return _ArrayBuffer.subscript.read;
}

uint64_t protocol witness for Collection.subscript.getter in conformance UnsafeMutableBufferPointer<A>@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance UnsafeMutableBufferPointer<A>(a1, (uint64_t (*)(void, void, void, void))UnsafeMutableBufferPointer.subscript.getter, a2);
}

void *protocol witness for Collection.index(_:offsetBy:) in conformance UnsafeMutableBufferPointer<A>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, 0x101uLL, a3);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance UnsafeMutableBufferPointer<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UnsafeBufferPointer<A>(a1, a2, a3, 0x10FuLL, 0x117uLL, a4);
}

uint64_t protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UnsafeBufferPointer<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, unint64_t a4@<X5>, unint64_t a5@<X6>, uint64_t a6@<X8>)
{
  uint64_t result = specialized UnsafeBufferPointer.index(_:offsetBy:limitedBy:)(*a1, a2, *a3, a4, a5);
  *(void *)a6 = result;
  *(unsigned char *)(a6 + 8) = v8 & 1;
  return result;
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance UnsafeMutableBufferPointer<A>(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for Collection.distance(from:to:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, a4, 0x129uLL);
}

void *protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, a4, 0x234uLL, 0x235uLL);
}

{
  return protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, a4, 0x23BuLL, 0x23CuLL);
}

void *protocol witness for Collection.index(after:) in conformance UnsafeMutableBufferPointer<A>@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  return protocol witness for Collection.index(after:) in conformance UnsafeMutableBufferPointer<A>(a1, 0xC9uLL, a2);
}

void *protocol witness for Collection.formIndex(after:) in conformance UnsafeMutableBufferPointer<A>(void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, 0xD7uLL);
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance UnsafeMutableBufferPointer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](a1);
  char v8 = (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = *v9;
  uint64_t v12 = *v3;
  uint64_t v11 = v3[1];
  (*(void (**)(char *, uint64_t, uint64_t))(v6 + 16))(v8, a1, v5);
  if (v10 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20DuLL, 0);
  }
  if (v10 >= v11) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20EuLL, 0);
  }
  (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, v5);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v6 + 40))(v12 + *(void *)(v6 + 72) * v10, v8, v5);
}

uint64_t (*protocol witness for MutableCollection.subscript.modify in conformance UnsafeMutableBufferPointer<A>(uint64_t a1, void *a2))()
{
  if ((*a2 & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20DuLL, 0);
  }
  if (*a2 >= *(void *)(v2 + 8)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20EuLL, 0);
  }
  return EnumeratedSequence._base.modify;
}

char *protocol witness for MutableCollection.subscript.setter in conformance UnsafeMutableBufferPointer<A>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return UnsafeMutableBufferPointer.subscript.setter(*a1, a1[1], a1[2], a1[3], *a2, a2[1], *v3, v3[1], *(unint64_t **)(a3 + 16));
}

void (*protocol witness for MutableCollection.subscript.modify in conformance UnsafeMutableBufferPointer<A>(void *a1, uint64_t *a2, uint64_t a3))(uint64_t **a1)
{
  uint64_t v7 = malloc(0x48uLL);
  *a1 = v7;
  uint64_t v8 = *a2;
  uint64_t v9 = a2[1];
  v7[4] = *a2;
  v7[5] = v9;
  uint64_t v10 = *v3;
  uint64_t v11 = v3[1];
  v7[6] = *v3;
  v7[7] = v11;
  v7[8] = *(void *)(a3 + 16);
  if (v8 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x265uLL, 0);
  }
  if (v11 < v9) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x266uLL, 0);
  }
  *uint64_t v7 = v8;
  v7[1] = v9;
  v7[2] = v10;
  v7[3] = v11;
  return UnsafeMutableBufferPointer.subscript.modify;
}

void *protocol witness for MutableCollection.partition(by:) in conformance UnsafeMutableBufferPointer<A>@<X0>(uint64_t (*a1)(char *)@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a3, (uint64_t)a3);
  return MutableCollection<>.partition(by:)(a1, a2, (uint64_t)a3, WitnessTable, a4, a5);
}

void protocol witness for MutableCollection.swapAt(_:_:) in conformance UnsafeMutableBufferPointer<A>(Swift::Int *a1, Swift::Int *a2)
{
}

uint64_t protocol witness for MutableCollection._withUnsafeMutableBufferPointerIfSupported<A>(_:) in conformance UnsafeMutableBufferPointer<A>@<X0>(uint64_t (*a1)(uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return UnsafeMutableBufferPointer._withUnsafeMutableBufferPointerIfSupported<A>(_:)(a1, a2, a3);
}

BOOL protocol witness for MutableCollection.withContiguousMutableStorageIfAvailable<A>(_:) in conformance UnsafeMutableBufferPointer<A>@<W0>(void (*a1)(uint64_t *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return UnsafeMutableBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)(a1, a3, a2, a4);
}

void *protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeMutableBufferPointer<A>@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  return protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeMutableBufferPointer<A>(a1, 0xE5uLL, a2);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeMutableBufferPointer<A>(void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, 0xF3uLL);
}

uint64_t UnsafeMutableBufferPointer.withMemoryRebound<A, B>(to:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return UnsafeMutableBufferPointer.withMemoryRebound<A, B>(to:_:)(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t)partial apply for thunk for @callee_guaranteed (@unowned UnsafeMutableBufferPointer<A1>) -> (@out B1, @error @owned Error), (uint64_t (*)(uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_sSrsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_Sryqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSryxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyqd__sAD_pqd_1_Isgyrzr_AEqd_1_sAD_psAD_pRsd_0_Ri_zRi_d__Ri_d_1_r_1_lIetMgyrzo_Tp5);
}

unint64_t UnsafeMutableBufferPointer.debugDescription.getter(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = specialized static String._createEmpty(withInitialCapacity:)(22);
  uint64_t v8 = v6;
  unint64_t v9 = v7;
  v275._uint64_t countAndFlagsBits = v6;
  v275._unint64_t object = (void *)v7;
  unint64_t v10 = HIBYTE(v7) & 0xF;
  unint64_t v11 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v7 & 0x2000000000000000) != 0) {
    uint64_t v12 = HIBYTE(v7) & 0xF;
  }
  else {
    uint64_t v12 = v6 & 0xFFFFFFFFFFFFLL;
  }
  if (!v12 && (v6 & ~v7 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v7);
    v275._uint64_t countAndFlagsBits = 0x203A747261747328;
    v275._unint64_t object = (void *)0xE800000000000000;
    if (a1) {
      goto LABEL_80;
    }
    goto LABEL_58;
  }
  if ((v7 & 0x2000000000000000) == 0 || v10 > 7)
  {
    swift_bridgeObjectRetain_n(0xE800000000000000, 6);
    if ((v9 & 0x1000000000000000) == 0)
    {
      Swift::Int v20 = v12 + 8;
      if (!__OFADD__(v12, 8)) {
        goto LABEL_13;
      }
      goto LABEL_310;
    }
    goto LABEL_308;
  }
  uint64_t v13 = 8 * HIBYTE(v7);
  uint64_t v14 = (40 << (v13 & 0x38)) | ((-255 << (v13 & 0x38)) - 1) & v6;
  char v15 = (v13 + 8) & 0x38;
  uint64_t v16 = (-255 << v15) - 1;
  uint64_t v17 = 115 << v15;
  if (v10 >= 7)
  {
    unint64_t v19 = v17 | v16 & v7;
    char v18 = 8;
    goto LABEL_32;
  }
  uint64_t v14 = v17 | v16 & v14;
  if (v10 == 6)
  {
    char v18 = 0;
    unint64_t v19 = v7;
LABEL_32:
    uint64_t v28 = (116 << v18) | ((-255 << v18) - 1) & v19;
    char v29 = v10 + 3;
LABEL_33:
    uint64_t v30 = (97 << (8 * (v29 & 7u))) | ((-255 << (8 * (v29 & 7u))) - 1) & v28;
    char v31 = v10 + 4;
LABEL_34:
    uint64_t v32 = (114 << (8 * (v31 & 7u))) | ((-255 << (8 * (v31 & 7u))) - 1) & v30;
    char v33 = v10 + 5;
LABEL_35:
    uint64_t v34 = (116 << (8 * (v33 & 7u))) | ((-255 << (8 * (v33 & 7u))) - 1) & v32;
    char v35 = v10 + 6;
LABEL_36:
    uint64_t v36 = (58 << (8 * (v35 & 7u))) | ((-255 << (8 * (v35 & 7u))) - 1) & v34;
    char v37 = v10 + 7;
    goto LABEL_37;
  }
  uint64_t v14 = (116 << ((v13 + 16) & 0x38)) | ((-255 << ((v13 + 16) & 0x38)) - 1) & v14;
  if (v10 >= 5)
  {
    char v29 = 8;
    uint64_t v28 = v7;
    goto LABEL_33;
  }
  uint64_t v14 = (97 << ((v13 + 24) & 0x38)) | ((-255 << ((v13 + 24) & 0x38)) - 1) & v14;
  if (v10 == 4)
  {
    char v31 = 8;
    uint64_t v30 = v7;
    goto LABEL_34;
  }
  uint64_t v14 = (114 << ((v13 + 32) & 0x38)) | ((-255 << ((v13 + 32) & 0x38)) - 1) & v14;
  if (v10 >= 3)
  {
    char v33 = 8;
    uint64_t v32 = v7;
    goto LABEL_35;
  }
  uint64_t v14 = (116 << ((v13 + 40) & 0x38)) | ((-255 << ((v13 + 40) & 0x38)) - 1) & v14;
  if (v10 == 2)
  {
    char v35 = 8;
    uint64_t v34 = v7;
    goto LABEL_36;
  }
  uint64_t v14 = (58 << ((v13 + 48) & 0x38)) | ((-255 << ((v13 + 48) & 0x38)) - 1) & v14;
  if (!v10)
  {
    uint64_t v14 = (32 << ((v13 + 56) & 0x38)) | ((-255 << ((v13 + 56) & 0x38)) - 1) & v14;
    uint64_t v38 = v7;
    goto LABEL_38;
  }
  char v37 = 8;
  uint64_t v36 = v7;
LABEL_37:
  uint64_t v38 = (32 << (8 * (v37 & 7u))) | ((-255 << (8 * (v37 & 7u))) - 1) & v36;
LABEL_38:
  swift_bridgeObjectRelease(v7);
  swift_bridgeObjectRelease(0xE800000000000000);
  unint64_t v41 = 0xA000000000000000;
  if (!(v14 & 0x8080808080808080 | v38 & 0x80808080808080)) {
    unint64_t v41 = 0xE000000000000000;
  }
  v275._uint64_t countAndFlagsBits = v14;
  v275._unint64_t object = (void *)((v41 & 0xFF00000000000000 | (v10 << 56) | v38 & 0xFFFFFFFFFFFFFFLL) + 0x800000000000000);
  if (a1) {
    goto LABEL_80;
  }
LABEL_58:
  a3 = 0xE300000000000000;
  a1 = 7104878;
  while (1)
  {
    uint64_t countAndFlagsBits = v275._countAndFlagsBits;
    unint64_t object = (unint64_t)v275._object;
    unint64_t v75 = ((unint64_t)v275._object >> 56) & 0xF;
    if (((uint64_t)v275._object & 0x2000000000000000) != 0) {
      unint64_t v76 = ((unint64_t)v275._object >> 56) & 0xF;
    }
    else {
      unint64_t v76 = v275._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v273 = a2;
    if (!v76 && (v275._countAndFlagsBits & ~(uint64_t)v275._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v275._object);
      v275._uint64_t countAndFlagsBits = a1;
      v275._unint64_t object = (void *)a3;
      goto LABEL_170;
    }
    uint64_t v8 = a3 & 0x2000000000000000;
    unint64_t v11 = HIBYTE(a3) & 0xF;
    if (((uint64_t)v275._object & 0x2000000000000000) != 0 && v8)
    {
      unint64_t v77 = v75 + v11;
      if (v75 + v11 <= 0xF)
      {
        if (v11)
        {
          char v94 = 0;
          unint64_t v95 = 0;
          unint64_t v96 = (unint64_t)v275._object;
          do
          {
            unint64_t v97 = v75 + v95;
            unint64_t v98 = v95 + 1;
            if (v95 >= 8) {
              unint64_t v99 = a3;
            }
            else {
              unint64_t v99 = a1;
            }
            unint64_t v100 = v99 >> (v94 & 0x38);
            char v101 = (8 * v75 + v94) & 0x38;
            uint64_t v102 = (-255 << v101) - 1;
            unint64_t v103 = (unint64_t)v100 << v101;
            unint64_t v104 = v103 | v102 & v96;
            unint64_t v105 = v103 | v102 & countAndFlagsBits;
            if (v97 < 8) {
              uint64_t countAndFlagsBits = v105;
            }
            else {
              unint64_t v96 = v104;
            }
            v94 += 8;
            unint64_t v95 = v98;
          }
          while (v11 != v98);
        }
        else
        {
          unint64_t v96 = (unint64_t)v275._object;
        }
        swift_bridgeObjectRelease((uint64_t)v275._object);
        swift_bridgeObjectRelease(a3);
        unint64_t v132 = 0xA000000000000000;
        if (!(countAndFlagsBits & 0x8080808080808080 | v96 & 0x80808080808080)) {
          unint64_t v132 = 0xE000000000000000;
        }
        v275._uint64_t countAndFlagsBits = countAndFlagsBits;
        v275._unint64_t object = (void *)(v132 & 0xFF00000000000000 | (v77 << 56) | v96 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_170;
      }
      uint64_t v8 = 1;
    }
    int64_t v53 = a1 & 0xFFFFFFFFFFFFLL;
    uint64_t v78 = v8 ? HIBYTE(a3) & 0xF : a1 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(a3, 2);
    if ((a3 & 0x1000000000000000) != 0) {
      break;
    }
    swift_bridgeObjectRetain_n(a3, 4);
    a2 = v78;
    if ((object & 0x1000000000000000) != 0) {
      goto LABEL_293;
    }
LABEL_95:
    BOOL v79 = __OFADD__(v76, a2);
    Swift::Int v80 = v76 + a2;
    if (v79) {
      goto LABEL_295;
    }
LABEL_96:
    uint64_t v272 = v78;
    if ((countAndFlagsBits & ~object & 0x2000000000000000) == 0
      || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v80 >= 16)
      {
        uint64_t v81 = v275._countAndFlagsBits;
        unint64_t v9 = (unint64_t)v275._object;
        goto LABEL_105;
      }
      Swift::Int v20 = (Swift::Int)v275._object;
      if (((uint64_t)v275._object & 0x2000000000000000) != 0)
      {
        int v93 = 0;
        unint64_t v9 = (unint64_t)v275._object;
      }
      else
      {
        unint64_t v9 = (unint64_t)v275._object;
LABEL_128:
        int v93 = 1;
      }
LABEL_147:
      swift_bridgeObjectRelease_n(a3, 5);
      unint64_t v11 = v275._countAndFlagsBits;
      if (v93)
      {
LABEL_311:
        if ((v20 & 0x1000000000000000) != 0)
        {
          unint64_t v11 = _StringGuts._foreignConvertedToSmall()(v11, v9);
          Swift::Int v20 = v266;
        }
        else
        {
          if ((v11 & 0x1000000000000000) != 0)
          {
            uint64_t v254 = (unsigned __int8 *)((v20 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v255 = v11 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            uint64_t v254 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v11, v9);
            uint64_t v255 = v269;
          }
          swift_bridgeObjectRetain(v9);
          closure #1 in _StringGuts._convertedToSmall()(v254, v255, &v274);
          swift_bridgeObjectRelease(v9);
          Swift::Int v20 = *((void *)&v274 + 1);
          unint64_t v11 = v274;
        }
      }
      v110._rawBits = (v272 << 16) | 1;
      v111._rawBits = 1;
      v112._rawBits = _StringGuts.validateScalarRange(_:)(v111, v110, a1, a3);
      if (v112._rawBits < 0x10000) {
        v112._rawBits |= 3;
      }
      unint64_t v114 = specialized String.init(_:)(v112, v113, a1, a3);
      unint64_t v116 = v115;
      swift_bridgeObjectRelease(a3);
      if ((v116 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v116);
      }
      else if ((v116 & 0x1000000000000000) != 0)
      {
        unint64_t v114 = _StringGuts._foreignConvertedToSmall()(v114, v116);
        unint64_t v268 = v267;
        swift_bridgeObjectRelease(v116);
        unint64_t v116 = v268;
      }
      else
      {
        if ((v114 & 0x1000000000000000) != 0)
        {
          unint64_t v256 = (unsigned __int8 *)((v116 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v257 = v114 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          unint64_t v256 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v114, v116);
        }
        closure #1 in _StringGuts._convertedToSmall()(v256, v257, &v274);
        swift_bridgeObjectRelease(v116);
        unint64_t v116 = *((void *)&v274 + 1);
        unint64_t v114 = v274;
      }
      uint64_t v117 = HIBYTE(v20) & 0xF;
      uint64_t v118 = HIBYTE(v116) & 0xF;
      uint64_t v119 = v118 + v117;
      if ((unint64_t)(v118 + v117) > 0xF) {
        goto LABEL_333;
      }
      if (v118)
      {
        char v120 = 0;
        unint64_t v121 = 0;
        do
        {
          unint64_t v122 = v117 + v121;
          unint64_t v123 = v121 + 1;
          if (v121 >= 8) {
            unint64_t v124 = v116;
          }
          else {
            unint64_t v124 = v114;
          }
          unint64_t v125 = v124 >> (v120 & 0x38);
          char v126 = (8 * v117 + v120) & 0x38;
          uint64_t v127 = (-255 << v126) - 1;
          unint64_t v128 = (unint64_t)v125 << v126;
          Swift::Int v129 = v128 | v127 & v20;
          unint64_t v130 = v128 | v127 & v11;
          if (v122 < 8) {
            unint64_t v11 = v130;
          }
          else {
            Swift::Int v20 = v129;
          }
          v120 += 8;
          unint64_t v121 = v123;
        }
        while (v118 != v123);
      }
      swift_bridgeObjectRelease(v9);
      swift_bridgeObjectRelease(a3);
      unint64_t v131 = 0xA000000000000000;
      if (!(v11 & 0x8080808080808080 | v20 & 0x80808080808080)) {
        unint64_t v131 = 0xE000000000000000;
      }
      v275._uint64_t countAndFlagsBits = v11;
      v275._unint64_t object = (void *)(v131 & 0xFF00000000000000 | (v119 << 56) | v20 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_170;
    }
    uint64_t v81 = v275._countAndFlagsBits;
    unint64_t v9 = (unint64_t)v275._object;
    int64_t v82 = _StringGuts.nativeUnusedCapacity.getter(v275._countAndFlagsBits, (uint64_t)v275._object);
    if (v83) {
      goto LABEL_334;
    }
    if (v80 <= 15)
    {
      if ((v9 & 0x2000000000000000) != 0)
      {
        int v93 = 0;
        Swift::Int v20 = v9;
        goto LABEL_147;
      }
      Swift::Int v20 = v9;
      if (v82 < a2) {
        goto LABEL_128;
      }
    }
LABEL_105:
    int64_t v84 = _StringGuts.nativeUnusedCapacity.getter(v81, v9);
    unint64_t v55 = (v85 & 1) == 0 && v84 >= a2;
    if ((v81 & ~v9 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v55) {
        goto LABEL_123;
      }
LABEL_116:
      uint64_t v87 = _StringGuts.nativeCapacity.getter(v81, v9);
      if (v88) {
        uint64_t v89 = 0;
      }
      else {
        uint64_t v89 = v87;
      }
      if (v89 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_320;
      }
      uint64_t v90 = 2 * v89;
      if (v90 > v80) {
        Swift::Int v80 = v90;
      }
      goto LABEL_122;
    }
    if ((v55 & 1) == 0) {
      goto LABEL_116;
    }
LABEL_122:
    _StringGuts.grow(_:)(v80);
LABEL_123:
    swift_bridgeObjectRelease_n(a3, 4);
    if ((a3 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(a3);
      _StringGuts._foreignAppendInPlace(_:)(a1, a3, 0, v272);
    }
    else
    {
      if (v8)
      {
        swift_bridgeObjectRelease_n(a3, 2);
        *(void *)&long long v274 = a1;
        *((void *)&v274 + 1) = a3 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v91 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(a3) & 0xF, (uint64_t)&v274, HIBYTE(a3) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v91, v92, (a3 & 0x4000000000000000) != 0);
        swift_bridgeObjectRelease(a3);
        goto LABEL_170;
      }
      if ((a1 & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRelease(a3);
        id v106 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v107 = a1 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        id v106 = _StringObject.sharedUTF8.getter(a1, a3);
        uint64_t v107 = v264;
        swift_bridgeObjectRelease(a3);
        if (v107 < v53) {
          goto LABEL_332;
        }
      }
      BOOL v108 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, a1 & 0xFFFFFFFFFFFFLL, (uint64_t)v106, v107);
      _StringGuts.appendInPlace(_:isASCII:)(v108, v109, a1 < 0);
    }
    swift_bridgeObjectRelease_n(a3, 2);
LABEL_170:
    Swift::String v133 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", count: ", 9uLL, 1);
    a1 = v133._countAndFlagsBits;
    a3 = (unint64_t)v133._object;
    uint64_t v134 = v275._countAndFlagsBits;
    unint64_t v9 = (unint64_t)v275._object;
    unint64_t v135 = ((unint64_t)v275._object >> 56) & 0xF;
    unint64_t v136 = v275._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v275._object & 0x2000000000000000) != 0) {
      unint64_t v136 = ((unint64_t)v275._object >> 56) & 0xF;
    }
    if (!v136 && (v275._countAndFlagsBits & ~(uint64_t)v275._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v275._object);
      Swift::String v275 = v133;
      goto LABEL_204;
    }
    a2 = (uint64_t)v133._object & 0x2000000000000000;
    uint64_t v8 = ((unint64_t)v133._object >> 56) & 0xF;
    if (((uint64_t)v275._object & 0x2000000000000000) != 0 && a2)
    {
      unint64_t v137 = v135 + v8;
      if (v135 + v8 <= 0xF)
      {
        uint64_t v161 = v273;
        if (v8)
        {
          char v195 = 0;
          unint64_t v196 = 0;
          unint64_t v197 = (unint64_t)v275._object;
          do
          {
            unint64_t v198 = v135 + v196;
            unint64_t v199 = v196 + 1;
            if (v196 >= 8) {
              unint64_t v200 = (unint64_t)v133._object;
            }
            else {
              unint64_t v200 = v133._countAndFlagsBits;
            }
            unint64_t v201 = v200 >> (v195 & 0x38);
            char v202 = (8 * v135 + v195) & 0x38;
            uint64_t v203 = (-255 << v202) - 1;
            unint64_t v204 = (unint64_t)v201 << v202;
            unint64_t v205 = v204 | v203 & v197;
            unint64_t v206 = v204 | v203 & v134;
            if (v198 < 8) {
              uint64_t v134 = v206;
            }
            else {
              unint64_t v197 = v205;
            }
            v195 += 8;
            unint64_t v196 = v199;
          }
          while (v8 != v199);
        }
        else
        {
          unint64_t v197 = (unint64_t)v275._object;
        }
        swift_bridgeObjectRelease((uint64_t)v275._object);
        swift_bridgeObjectRelease((uint64_t)v133._object);
        unint64_t v227 = 0xA000000000000000;
        if (!(v134 & 0x8080808080808080 | v197 & 0x80808080808080)) {
          unint64_t v227 = 0xE000000000000000;
        }
        v275._uint64_t countAndFlagsBits = v134;
        v275._unint64_t object = (void *)(v227 & 0xFF00000000000000 | (v137 << 56) | v197 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_205;
      }
      a2 = 1;
    }
    unint64_t v11 = v133._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (a2) {
      int64_t v53 = ((unint64_t)v133._object >> 56) & 0xF;
    }
    else {
      int64_t v53 = v133._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n((uint64_t)v133._object, 2);
    if (((uint64_t)v133._object & 0x1000000000000000) != 0) {
      goto LABEL_296;
    }
    swift_bridgeObjectRetain_n((uint64_t)v133._object, 4);
    Swift::Int v138 = v53;
    if ((v9 & 0x1000000000000000) != 0) {
      goto LABEL_299;
    }
LABEL_183:
    if ((v9 & 0x2000000000000000) != 0)
    {
      uint64_t v140 = HIBYTE(v9) & 0xF;
      uint64_t v139 = v140 + v138;
      if (__OFADD__(v140, v138)) {
        goto LABEL_301;
      }
    }
    else
    {
      uint64_t v139 = (v134 & 0xFFFFFFFFFFFFLL) + v138;
      if (__OFADD__(v134 & 0xFFFFFFFFFFFFLL, v138)) {
        goto LABEL_301;
      }
    }
LABEL_188:
    if ((v134 & ~v9 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v141 = _StringGuts.nativeUnusedCapacity.getter(v134, v9);
      if (v142) {
        goto LABEL_334;
      }
      if (v139 <= 15 && ((v9 & 0x2000000000000000) != 0 || v141 < v138))
      {
LABEL_198:
        swift_bridgeObjectRelease_n(a3, 5);
        unint64_t v145 = v275._countAndFlagsBits;
        swift_bridgeObjectRetain(v9);
        unint64_t v146 = _StringGuts._convertedToSmall()(v145, v9);
        unint64_t v148 = v147;
        swift_bridgeObjectRelease(v9);
        v149._rawBits = (v53 << 16) | 1;
        v150._rawBits = 1;
        v151._rawBits = _StringGuts.validateScalarRange(_:)(v150, v149, a1, a3);
        if (v151._rawBits < 0x10000) {
          v151._rawBits |= 3;
        }
        unint64_t v153 = specialized String.init(_:)(v151, v152, a1, a3);
        unint64_t v155 = v154;
        swift_bridgeObjectRelease(a3);
        unint64_t v156 = _StringGuts._convertedToSmall()(v153, v155);
        unint64_t v158 = v157;
        swift_bridgeObjectRelease(v155);
        unint64_t v159 = specialized _SmallString.init(_:appending:)(v146, v148, v156, v158);
        uint64_t v161 = v273;
        if (v162) {
          goto LABEL_333;
        }
        uint64_t v163 = v159;
        uint64_t v164 = v160;
        swift_bridgeObjectRelease(v9);
        swift_bridgeObjectRelease(a3);
        v275._uint64_t countAndFlagsBits = v163;
        v275._unint64_t object = v164;
        goto LABEL_205;
      }
    }
    else if (v139 <= 15)
    {
      goto LABEL_198;
    }
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v139, v138);
    swift_bridgeObjectRelease_n(a3, 4);
    if ((a3 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(a3);
      _StringGuts._foreignAppendInPlace(_:)(a1, a3, 0, v53);
      swift_bridgeObjectRelease_n(a3, 2);
      goto LABEL_204;
    }
    if (a2)
    {
      swift_bridgeObjectRelease_n(a3, 2);
      *(void *)&long long v274 = a1;
      *((void *)&v274 + 1) = a3 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v143 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v8, (uint64_t)&v274, v8);
      _StringGuts.appendInPlace(_:isASCII:)(v143, v144, (a3 & 0x4000000000000000) != 0);
      swift_bridgeObjectRelease(a3);
LABEL_204:
      uint64_t v161 = v273;
      goto LABEL_205;
    }
    if ((a1 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(a3);
      id v219 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v220 = v11;
    }
    else
    {
      id v219 = _StringObject.sharedUTF8.getter(a1, a3);
      uint64_t v220 = v262;
      swift_bridgeObjectRelease(a3);
      if (v220 < (uint64_t)v11) {
        goto LABEL_332;
      }
    }
    uint64_t v161 = v273;
    v221 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v11, (uint64_t)v219, v220);
    _StringGuts.appendInPlace(_:isASCII:)(v221, v222, a1 < 0);
    swift_bridgeObjectRelease_n(a3, 2);
LABEL_205:
    unint64_t v165 = _int64ToString(_:radix:uppercase:)(v161, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
    a3 = v165;
    uint64_t v139 = v166;
    unint64_t v9 = v275._countAndFlagsBits;
    uint64_t v8 = (uint64_t)v275._object;
    unint64_t v167 = ((unint64_t)v275._object >> 56) & 0xF;
    if (((uint64_t)v275._object & 0x2000000000000000) != 0) {
      int64_t v53 = ((unint64_t)v275._object >> 56) & 0xF;
    }
    else {
      int64_t v53 = v275._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v53 && (v275._countAndFlagsBits & ~(uint64_t)v275._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v275._object);
      v275._uint64_t countAndFlagsBits = a3;
      v275._unint64_t object = (void *)v139;
      goto LABEL_273;
    }
    a2 = v166 & 0x2000000000000000;
    a1 = HIBYTE(v166) & 0xF;
    if (((uint64_t)v275._object & 0x2000000000000000) != 0 && a2)
    {
      unint64_t v168 = v167 + a1;
      if (v167 + a1 <= 0xF)
      {
        if (a1)
        {
          char v207 = 0;
          unint64_t v208 = 0;
          unint64_t v209 = (unint64_t)v275._object;
          do
          {
            unint64_t v210 = v167 + v208;
            unint64_t v211 = v208 + 1;
            if (v208 >= 8) {
              unint64_t v212 = v166;
            }
            else {
              unint64_t v212 = v165;
            }
            unint64_t v213 = v212 >> (v207 & 0x38);
            char v214 = (8 * v167 + v207) & 0x38;
            uint64_t v215 = (-255 << v214) - 1;
            unint64_t v216 = (unint64_t)v213 << v214;
            unint64_t v217 = v216 | v215 & v209;
            unint64_t v218 = v216 | v215 & v9;
            if (v210 < 8) {
              unint64_t v9 = v218;
            }
            else {
              unint64_t v209 = v217;
            }
            v207 += 8;
            unint64_t v208 = v211;
          }
          while (a1 != v211);
        }
        else
        {
          unint64_t v209 = (unint64_t)v275._object;
        }
        swift_bridgeObjectRelease((uint64_t)v275._object);
        swift_bridgeObjectRelease(v139);
        unint64_t v228 = 0xA000000000000000;
        if (!(v9 & 0x8080808080808080 | v209 & 0x80808080808080)) {
          unint64_t v228 = 0xE000000000000000;
        }
        v275._uint64_t countAndFlagsBits = v9;
        v275._unint64_t object = (void *)(v228 & 0xFF00000000000000 | (v168 << 56) | v209 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_273;
      }
      a2 = 1;
    }
    uint64_t v134 = v165 & 0xFFFFFFFFFFFFLL;
    if (a2) {
      unint64_t v11 = HIBYTE(v166) & 0xF;
    }
    else {
      unint64_t v11 = v165 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v166, 2);
    if ((v139 & 0x1000000000000000) != 0) {
      goto LABEL_302;
    }
    swift_bridgeObjectRetain_n(v139, 4);
    Swift::Int v169 = v11;
    if ((v8 & 0x1000000000000000) != 0) {
      goto LABEL_305;
    }
LABEL_219:
    BOOL v79 = __OFADD__(v53, v169);
    int64_t v170 = v53 + v169;
    if (!v79) {
      goto LABEL_220;
    }
LABEL_307:
    __break(1u);
LABEL_308:
    Swift::Int v253 = String.UTF8View._foreignCount()();
    Swift::Int v20 = v253 + 8;
    if (__OFADD__(v253, 8))
    {
LABEL_310:
      __break(1u);
      goto LABEL_311;
    }
LABEL_13:
    unint64_t v21 = v8 & ~v9;
    if ((v21 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v22 = _StringGuts.nativeUnusedCapacity.getter(v8, v9);
      if (v23) {
        goto LABEL_334;
      }
      if (v20 > 15) {
        goto LABEL_21;
      }
      if ((v9 & 0x2000000000000000) != 0) {
        goto LABEL_62;
      }
      if (v22 > 7)
      {
LABEL_21:
        int64_t v24 = _StringGuts.nativeUnusedCapacity.getter(v8, v9);
        BOOL v27 = (v25 & 1) == 0 && v24 > 7;
        if ((v21 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v27) {
            goto LABEL_50;
          }
        }
        else if (v27)
        {
          goto LABEL_49;
        }
        uint64_t v42 = _StringGuts.nativeCapacity.getter(v8, v9);
        if (v43) {
          uint64_t v44 = 0;
        }
        else {
          uint64_t v44 = v42;
        }
        if (v44 + 0x4000000000000000 >= 0)
        {
          uint64_t v45 = 2 * v44;
          if (v45 > v20) {
            Swift::Int v20 = v45;
          }
LABEL_49:
          _StringGuts.grow(_:)(v20);
LABEL_50:
          swift_bridgeObjectRelease_n(0xE800000000000000, 6);
          long long v274 = xmmword_18162B020;
          char v46 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 8, (uint64_t)&v274, 8);
          _StringGuts.appendInPlace(_:isASCII:)(v46, v47, 1);
          swift_bridgeObjectRelease(0xE800000000000000);
          if (!a1) {
            goto LABEL_58;
          }
          goto LABEL_80;
        }
        __break(1u);
LABEL_325:
        uint64_t v8 = _StringGuts._foreignConvertedToSmall()(v8, v9);
        unint64_t v11 = v260;
        goto LABEL_63;
      }
    }
    else
    {
      if (v20 > 15) {
        goto LABEL_21;
      }
      if ((v9 & 0x2000000000000000) != 0)
      {
LABEL_62:
        swift_bridgeObjectRelease_n(0xE800000000000000, 5);
        unint64_t v11 = v9;
        goto LABEL_63;
      }
    }
    swift_bridgeObjectRelease_n(0xE800000000000000, 5);
    if ((v9 & 0x1000000000000000) != 0) {
      goto LABEL_325;
    }
    if ((v8 & 0x1000000000000000) != 0)
    {
      uint64_t v48 = (unsigned __int8 *)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      uint64_t v48 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v8, v9);
      unint64_t v11 = v261;
    }
    swift_bridgeObjectRetain(v9);
    closure #1 in _StringGuts._convertedToSmall()(v48, v11, &v274);
    swift_bridgeObjectRelease(v9);
    unint64_t v11 = *((void *)&v274 + 1);
    uint64_t v8 = v274;
LABEL_63:
    v49._rawBits = 1;
    v50._rawBits = 524289;
    v51._rawBits = _StringGuts.validateScalarRange(_:)(v49, v50, 0x203A747261747328uLL, 0xE800000000000000);
    if (v51._rawBits < 0x10000) {
      v51._rawBits |= 3;
    }
    int64_t v53 = specialized String.init(_:)(v51, v52, 0x203A747261747328uLL, 0xE800000000000000);
    unint64_t v55 = v54;
    swift_bridgeObjectRelease(0xE800000000000000);
    if ((v55 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v55);
      goto LABEL_67;
    }
LABEL_320:
    if ((v55 & 0x1000000000000000) != 0)
    {
      int64_t v53 = _StringGuts._foreignConvertedToSmall()(v53, v55);
      unint64_t v271 = v270;
      swift_bridgeObjectRelease(v55);
      unint64_t v55 = v271;
    }
    else
    {
      if ((v53 & 0x1000000000000000) != 0)
      {
        v258 = (unsigned __int8 *)((v55 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v259 = v53 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        v258 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v53, v55);
      }
      closure #1 in _StringGuts._convertedToSmall()(v258, v259, &v274);
      swift_bridgeObjectRelease(v55);
      unint64_t v55 = *((void *)&v274 + 1);
      int64_t v53 = v274;
    }
LABEL_67:
    uint64_t v56 = HIBYTE(v11) & 0xF;
    uint64_t v57 = HIBYTE(v55) & 0xF;
    uint64_t v58 = v57 + v56;
    if ((unint64_t)(v57 + v56) > 0xF) {
      goto LABEL_333;
    }
    if (v57)
    {
      char v59 = 0;
      unint64_t v60 = 0;
      do
      {
        unint64_t v61 = v56 + v60;
        unint64_t v62 = v60 + 1;
        if (v60 >= 8) {
          unint64_t v63 = v55;
        }
        else {
          unint64_t v63 = v53;
        }
        unint64_t v64 = v63 >> (v59 & 0x38);
        char v65 = (8 * v56 + v59) & 0x38;
        uint64_t v66 = (-255 << v65) - 1;
        unint64_t v67 = (unint64_t)v64 << v65;
        unint64_t v68 = v67 | v66 & v11;
        unint64_t v69 = v67 | v66 & v8;
        if (v61 < 8) {
          uint64_t v8 = v69;
        }
        else {
          unint64_t v11 = v68;
        }
        v59 += 8;
        unint64_t v60 = v62;
      }
      while (v57 != v62);
    }
    swift_bridgeObjectRelease(v9);
    swift_bridgeObjectRelease(0xE800000000000000);
    unint64_t v70 = 0xA000000000000000;
    if (!(v8 & 0x8080808080808080 | v11 & 0x80808080808080)) {
      unint64_t v70 = 0xE000000000000000;
    }
    v275._uint64_t countAndFlagsBits = v8;
    v275._unint64_t object = (void *)(v70 & 0xFF00000000000000 | (v58 << 56) | v11 & 0xFFFFFFFFFFFFFFLL);
    if (!a1) {
      goto LABEL_58;
    }
LABEL_80:
    *(void *)&long long v274 = a1;
    uint64_t v71 = type metadata accessor for UnsafeMutablePointer(0, a3, v39, v40);
    a1 = String.init<A>(describing:)((uint64_t)&v274, v71);
    a3 = v72;
  }
  swift_bridgeObjectRetain_n(a3, 5);
  v238._rawBits = 1;
  v239._rawBits = (v78 << 16) | 1;
  v240._rawBits = _StringGuts.validateScalarRange(_:)(v238, v239, a1, a3);
  if (v240._rawBits < 0x10000) {
    v240._rawBits |= 3;
  }
  a2 = specialized Collection.count.getter(v240, v241, a1, a3);
  swift_bridgeObjectRelease(a3);
  if ((object & 0x1000000000000000) == 0) {
    goto LABEL_95;
  }
LABEL_293:
  Swift::Int v242 = String.UTF8View._foreignCount()();
  Swift::Int v80 = v242 + a2;
  if (!__OFADD__(v242, a2)) {
    goto LABEL_96;
  }
LABEL_295:
  __break(1u);
LABEL_296:
  swift_bridgeObjectRetain_n(a3, 5);
  v243._rawBits = 1;
  v244._rawBits = (v53 << 16) | 1;
  v245._rawBits = _StringGuts.validateScalarRange(_:)(v243, v244, a1, a3);
  if (v245._rawBits < 0x10000) {
    v245._rawBits |= 3;
  }
  Swift::Int v138 = specialized Collection.count.getter(v245, v246, a1, a3);
  swift_bridgeObjectRelease(a3);
  uint64_t v134 = v275._countAndFlagsBits;
  unint64_t v9 = (unint64_t)v275._object;
  if (((uint64_t)v275._object & 0x1000000000000000) == 0) {
    goto LABEL_183;
  }
LABEL_299:
  Swift::Int v247 = String.UTF8View._foreignCount()();
  uint64_t v139 = v247 + v138;
  if (!__OFADD__(v247, v138)) {
    goto LABEL_188;
  }
LABEL_301:
  __break(1u);
LABEL_302:
  swift_bridgeObjectRetain_n(v139, 5);
  v248._rawBits = 1;
  v249._rawBits = (v11 << 16) | 1;
  v250._rawBits = _StringGuts.validateScalarRange(_:)(v248, v249, a3, v139);
  if (v250._rawBits < 0x10000) {
    v250._rawBits |= 3;
  }
  Swift::Int v169 = specialized Collection.count.getter(v250, v251, a3, v139);
  swift_bridgeObjectRelease(v139);
  if ((v8 & 0x1000000000000000) == 0) {
    goto LABEL_219;
  }
LABEL_305:
  Swift::Int v252 = String.UTF8View._foreignCount()();
  int64_t v170 = v252 + v169;
  if (__OFADD__(v252, v169)) {
    goto LABEL_307;
  }
LABEL_220:
  if ((v9 & ~v8 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v8 & 0xFFFFFFFFFFFFFFFLL))
  {
    unint64_t v171 = (unint64_t)v275._object;
    int64_t v172 = _StringGuts.nativeUnusedCapacity.getter(v275._countAndFlagsBits, (uint64_t)v275._object);
    if (v173)
    {
LABEL_334:
      unint64_t v265 = 258;
      goto LABEL_335;
    }
    if (v170 <= 15 && ((v171 & 0x2000000000000000) != 0 || v172 < v169))
    {
LABEL_232:
      swift_bridgeObjectRelease_n(v139, 5);
      unint64_t v176 = v275._countAndFlagsBits;
      swift_bridgeObjectRetain(v171);
      unint64_t v177 = _StringGuts._convertedToSmall()(v176, v171);
      unint64_t v179 = v178;
      swift_bridgeObjectRelease(v171);
      v180._rawBits = (v11 << 16) | 1;
      v181._rawBits = 1;
      v182._rawBits = _StringGuts.validateScalarRange(_:)(v181, v180, a3, v139);
      if (v182._rawBits < 0x10000) {
        v182._rawBits |= 3;
      }
      unint64_t v184 = specialized String.init(_:)(v182, v183, a3, v139);
      unint64_t v186 = v185;
      swift_bridgeObjectRelease(v139);
      unint64_t v187 = _StringGuts._convertedToSmall()(v184, v186);
      unint64_t v189 = v188;
      swift_bridgeObjectRelease(v186);
      unint64_t v190 = specialized _SmallString.init(_:appending:)(v177, v179, v187, v189);
      if ((v192 & 1) == 0)
      {
        uint64_t v193 = v190;
        char v194 = v191;
        swift_bridgeObjectRelease(v171);
        swift_bridgeObjectRelease(v139);
        v275._uint64_t countAndFlagsBits = v193;
        v275._unint64_t object = v194;
        goto LABEL_273;
      }
LABEL_333:
      unint64_t v265 = 266;
LABEL_335:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v265, 0);
    }
  }
  else if (v170 <= 15)
  {
    unint64_t v171 = (unint64_t)v275._object;
    goto LABEL_232;
  }
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v170, v169);
  swift_bridgeObjectRelease_n(v139, 4);
  if ((v139 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v139);
    _StringGuts._foreignAppendInPlace(_:)(a3, v139, 0, v11);
  }
  else
  {
    if (a2)
    {
      swift_bridgeObjectRelease_n(v139, 2);
      *(void *)&long long v274 = a3;
      *((void *)&v274 + 1) = v139 & 0xFFFFFFFFFFFFFFLL;
      v174 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, a1, (uint64_t)&v274, a1);
      _StringGuts.appendInPlace(_:isASCII:)(v174, v175, (v139 & 0x4000000000000000) != 0);
      swift_bridgeObjectRelease(v139);
      goto LABEL_273;
    }
    if ((a3 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v139);
      id v223 = (id)((v139 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v224 = v134;
    }
    else
    {
      id v223 = _StringObject.sharedUTF8.getter(a3, v139);
      uint64_t v224 = v263;
      swift_bridgeObjectRelease(v139);
      if (v224 < v134) {
LABEL_332:
      }
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
    }
    unint64_t v225 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v134, (uint64_t)v223, v224);
    _StringGuts.appendInPlace(_:isASCII:)(v225, v226, (a3 & 0x8000000000000000) != 0);
  }
  swift_bridgeObjectRelease_n(v139, 2);
LABEL_273:
  v229 = v275._object;
  unint64_t v230 = ((unint64_t)v275._object >> 56) & 0xF;
  if (((uint64_t)v275._object & 0x2000000000000000) == 0) {
    unint64_t v230 = v275._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (v230 || (v275._countAndFlagsBits & ~(uint64_t)v275._object & 0x2000000000000000) != 0)
  {
    if (((uint64_t)v275._object & 0x2000000000000000) == 0
      || (unint64_t v231 = specialized _SmallString.init(_:appending:)(v275._countAndFlagsBits, (unint64_t)v275._object, 0x29uLL, 0xE100000000000000), (v233 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000);
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      unint64_t v234 = v275._countAndFlagsBits;
      v235 = v275._object;
    }
    else
    {
      unint64_t v234 = v231;
      v235 = v232;
      swift_bridgeObjectRelease((uint64_t)v229);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease((uint64_t)v275._object);
    v235 = (void *)0xE100000000000000;
    unint64_t v234 = 41;
  }
  unint64_t v236 = specialized static String.+ infix(_:_:)(0xD00000000000001ALL, 0x800000018162B0E0 | 0x8000000000000000, v234, (unint64_t)v235);
  swift_bridgeObjectRelease(0x800000018162B0E0 | 0x8000000000000000);
  swift_bridgeObjectRelease((uint64_t)v235);
  return v236;
}

unint64_t _sSryxGs28CustomDebugStringConvertiblesRi_zrlsABP16debugDescriptionSSvgTW(uint64_t a1)
{
  return UnsafeMutableBufferPointer.debugDescription.getter(*v1, v1[1], *(void *)(a1 + 16));
}

uint64_t UnsafeBufferPointer.count.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t UnsafeBufferPointer.init(_empty:)()
{
  return 0;
}

uint64_t UnsafeBufferPointer.Iterator._position.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*UnsafeBufferPointer.Iterator._position.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeBufferPointer.Iterator._end.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t UnsafeBufferPointer.Iterator._end.setter(uint64_t result)
{
  *(void *)(v1 + 8) = result;
  return result;
}

uint64_t (*UnsafeBufferPointer.Iterator._end.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeBufferPointer.withContiguousStorageIfAvailable<A>(_:)@<X0>(uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X5>, uint64_t a5@<X8>)
{
  return UnsafeMutableBufferPointer.withContiguousStorageIfAvailable<A>(_:)(a1, a2, a3, a4, a5);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance UnsafeBufferPointer<A>@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Sequence.makeIterator() in conformance UnsafeMutableBufferPointer<A>(a1, (uint64_t (*)(void, void, void))UnsafeBufferPointer.makeIterator(), a2);
}

uint64_t protocol witness for Sequence.makeIterator() in conformance UnsafeMutableBufferPointer<A>@<X0>(uint64_t a1@<X0>, uint64_t (*a2)(void, void, void)@<X2>, uint64_t *a3@<X8>)
{
  uint64_t result = a2(*v3, v3[1], *(void *)(a1 + 16));
  *a3 = result;
  a3[1] = v6;
  return result;
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance UnsafeBufferPointer<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for UnsafeBufferPointer<A>, a1, a3);

  return Collection.underestimatedCount.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeBufferPointer<A>(unint64_t *a1, uint64_t a2)
{
  return protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeMutableBufferPointer<A>(a1, a2, protocol conformance descriptor for UnsafeBufferPointer<A>);
}

uint64_t protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeMutableBufferPointer<A>(unint64_t *a1, uint64_t a2, int *a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(a3, a1, (uint64_t)a3);
  return Collection._copyToContiguousArray()((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeBufferPointer<A>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, void, void, void))UnsafeBufferPointer._copyContents(initializing:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableBufferPointer<A>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, void, void, void))
{
  *a1 = a6(a2, a3, *v6, v6[1], *(void *)(a4 + 16));
  a1[1] = v8;
  return v9;
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UnsafeBufferPointer<A>@<X0>(uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return UnsafeBufferPointer.withContiguousStorageIfAvailable<A>(_:)(a1, *v3, v3[1], a2, a3);
}

Swift::Int __swiftcall UnsafeBufferPointer.index(after:)(Swift::Int after)
{
  return UnsafeMutableBufferPointer.index(after:)(after, v1, v2, v3, 0x5E7uLL);
}

uint64_t UnsafeMutableBufferPointer.index(after:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  BOOL v5 = __OFADD__(a1, 1);
  uint64_t result = a1 + 1;
  if (v5) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  }
  return result;
}

Swift::Void __swiftcall UnsafeBufferPointer.formIndex(after:)(Swift::Int *after)
{
  UnsafeMutableBufferPointer.formIndex(after:)(after, v1, v2, v3, 0x5F5uLL);
}

void *UnsafeMutableBufferPointer.formIndex(after:)(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (__OFADD__(*result, 1)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  }
  ++*result;
  return result;
}

Swift::Int __swiftcall UnsafeBufferPointer.index(before:)(Swift::Int before)
{
  return UnsafeMutableBufferPointer.index(before:)(before, v1, v2, v3, 0x603uLL);
}

uint64_t UnsafeMutableBufferPointer.index(before:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  BOOL v5 = __OFSUB__(a1, 1);
  uint64_t result = a1 - 1;
  if (v5) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  }
  return result;
}

Swift::Void __swiftcall UnsafeBufferPointer.formIndex(before:)(Swift::Int *before)
{
  UnsafeMutableBufferPointer.formIndex(before:)(before, v1, v2, v3, 0x611uLL);
}

void *UnsafeMutableBufferPointer.formIndex(before:)(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (__OFSUB__(*result, 1)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  }
  --*result;
  return result;
}

Swift::Int __swiftcall UnsafeBufferPointer.index(_:offsetBy:)(Swift::Int _, Swift::Int offsetBy)
{
  return UnsafeMutableBufferPointer.index(_:offsetBy:)(_, offsetBy, v2, v3, v4, 0x61FuLL);
}

uint64_t UnsafeMutableBufferPointer.index(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  BOOL v6 = __OFADD__(a1, a2);
  uint64_t result = a1 + a2;
  if (v6) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a6, 0);
  }
  return result;
}

Swift::Int_optional __swiftcall UnsafeBufferPointer.index(_:offsetBy:limitedBy:)(Swift::Int _, Swift::Int offsetBy, Swift::Int limitedBy)
{
  Swift::Int v3 = specialized UnsafeBufferPointer.index(_:offsetBy:limitedBy:)(_, offsetBy, limitedBy, 0x62DuLL, 0x635uLL);
  Swift::Bool v5 = v4 & 1;
  result.value = v3;
  result.is_nil = v5;
  return result;
}

Swift::Int __swiftcall UnsafeBufferPointer.distance(from:to:)(Swift::Int from, Swift::Int to)
{
  return UnsafeMutableBufferPointer.distance(from:to:)(from, to, v2, v3, v4, 0x647uLL);
}

uint64_t UnsafeMutableBufferPointer.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  BOOL v6 = __OFSUB__(a2, a1);
  uint64_t result = a2 - a1;
  if (v6) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a6, 0);
  }
  return result;
}

uint64_t UnsafeMutableBufferPointer.subscript.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a3 - 8) + 16))(a4, a2 + *(void *)(*(void *)(a3 - 8) + 72) * a1, a3);
}

uint64_t UnsafeBufferPointer._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(a1, a2, a3, a4, a5, a6, 0x714uLL, 0x715uLL);
}

uint64_t UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unint64_t a8)
{
  if (result < a2) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a7, 0);
  }
  if (result >= a3) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a8, 0);
  }
  return result;
}

uint64_t UnsafeBufferPointer._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(a1, a2, a3, a4, a5, a6, a7, 0x71BuLL, 0x71CuLL);
}

uint64_t UnsafeMutableBufferPointer._failEarlyRangeCheck(_:bounds:)(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, unint64_t a9)
{
  if (result < a3) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a8, 0);
  }
  if (a4 < a2) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a9, 0);
  }
  return result;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UnsafeBufferPointer<A>(void *a1, uint64_t *a2, uint64_t a3))()
{
  unint64_t v7 = malloc(0x28uLL);
  *a1 = v7;
  v7[4] = UnsafeBufferPointer.subscript.read(v7, *a2, *v3, v3[1], *(void *)(a3 + 16));
  return protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>;
}

void protocol witness for Collection.subscript.read in conformance _ArrayBuffer<A>(void *a1)
{
  uint64_t v1 = (void *)*a1;
  (*(void (**)(void))(*a1 + 32))(*a1);

  free(v1);
}

uint64_t (*UnsafeBufferPointer.subscript.read(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))()
{
  uint64_t v7 = *(void *)(a5 - 8);
  uint64_t v8 = v7;
  *a1 = a5;
  a1[1] = v7;
  a1[2] = malloc(*(void *)(v7 + 64));
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F5uLL, 0);
  }
  if (a4 <= a2) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
  }
  (*(void (**)(void))(v8 + 16))();
  return _ArrayBuffer.subscript.read;
}

void _ArrayBuffer.subscript.read(void *a1)
{
  uint64_t v1 = (void *)a1[2];
  (*(void (**)(void *, void))(a1[1] + 8))(v1, *a1);

  free(v1);
}

uint64_t protocol witness for Collection.subscript.getter in conformance UnsafeBufferPointer<A>@<X0>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance UnsafeMutableBufferPointer<A>(a1, (uint64_t (*)(void, void, void, void))UnsafeBufferPointer.subscript.getter, a2);
}

uint64_t protocol witness for Collection.subscript.getter in conformance UnsafeMutableBufferPointer<A>@<X0>(void *a1@<X0>, uint64_t (*a2)(void, void, void, void)@<X3>, uint64_t *a3@<X8>)
{
  uint64_t result = a2(*a1, a1[1], *v3, v3[1]);
  *a3 = result;
  a3[1] = v6;
  a3[2] = v7;
  a3[3] = v8;
  return result;
}

uint64_t protocol witness for Collection.indices.getter in conformance UnsafeBufferPointer<A>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = UnsafeBufferPointer.indices.getter(a1, *(void *)(v2 + 8));
  *a2 = 0;
  a2[1] = v5;
  return result;
}

BOOL protocol witness for Collection.isEmpty.getter in conformance UnsafeBufferPointer<A>()
{
  return UnsafeBufferPointer.isEmpty.getter(*v0, v0[1]);
}

void *protocol witness for Collection.index(_:offsetBy:) in conformance UnsafeBufferPointer<A>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return protocol witness for Collection.index(_:offsetBy:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, 0x61FuLL, a3);
}

uint64_t protocol witness for Collection.index(_:offsetBy:limitedBy:) in conformance UnsafeBufferPointer<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for RandomAccessCollection.index(_:offsetBy:limitedBy:) in conformance UnsafeBufferPointer<A>(a1, a2, a3, 0x62DuLL, 0x635uLL, a4);
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance UnsafeBufferPointer<A>(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for Collection.distance(from:to:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, a4, 0x647uLL);
}

void *protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeBufferPointer<A>(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  return protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, a4, 0x714uLL, 0x715uLL);
}

{
  return protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, a4, 0x71BuLL, 0x71CuLL);
}

void *protocol witness for Collection._failEarlyRangeCheck(_:bounds:) in conformance UnsafeMutableBufferPointer<A>(void *result, void *a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  if (*result < *a2) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  }
  if (*result >= a2[1]) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a6, 0);
  }
  return result;
}

{
  if (*result < *a2) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  }
  if (a2[1] < result[1]) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a6, 0);
  }
  return result;
}

void *protocol witness for Collection.index(after:) in conformance UnsafeBufferPointer<A>@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  return protocol witness for Collection.index(after:) in conformance UnsafeMutableBufferPointer<A>(a1, 0x5E7uLL, a2);
}

void *protocol witness for Collection.index(after:) in conformance UnsafeMutableBufferPointer<A>@<X0>(void *result@<X0>, unint64_t a2@<X3>, void *a3@<X8>)
{
  if (__OFADD__(*result, 1)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a2, 0);
  }
  *a3 = *result + 1;
  return result;
}

void *protocol witness for Collection.formIndex(after:) in conformance UnsafeBufferPointer<A>(void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Collection.formIndex(after:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, 0x5F5uLL);
}

void *protocol witness for Collection.formIndex(after:) in conformance UnsafeMutableBufferPointer<A>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (__OFADD__(*result, 1)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a4, 0);
  }
  ++*result;
  return result;
}

void *protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeBufferPointer<A>@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  return protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeMutableBufferPointer<A>(a1, 0x603uLL, a2);
}

void *protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeMutableBufferPointer<A>@<X0>(void *result@<X0>, unint64_t a2@<X3>, void *a3@<X8>)
{
  if (__OFSUB__(*result, 1)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a2, 0);
  }
  *a3 = *result - 1;
  return result;
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeBufferPointer<A>(void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeMutableBufferPointer<A>(a1, a2, a3, 0x611uLL);
}

void *protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeMutableBufferPointer<A>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (__OFSUB__(*result, 1)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a4, 0);
  }
  --*result;
  return result;
}

void *protocol witness for Collection.index(_:offsetBy:) in conformance UnsafeMutableBufferPointer<A>@<X0>(void *result@<X0>, uint64_t a2@<X1>, unint64_t a3@<X4>, void *a4@<X8>)
{
  if (__OFADD__(*result, a2)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a3, 0);
  }
  *a4 = *result + a2;
  return result;
}

uint64_t protocol witness for Collection.distance(from:to:) in conformance UnsafeMutableBufferPointer<A>(void *a1, void *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  BOOL v5 = __OFSUB__(*a2, *a1);
  uint64_t result = *a2 - *a1;
  if (v5) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  }
  return result;
}

Swift::Void __swiftcall UnsafeBufferPointer.deallocate()()
{
  if (v0) {
    swift_slowDealloc(v0);
  }
}

uint64_t UnsafeBufferPointer.withMemoryRebound<A, B>(to:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return UnsafeMutableBufferPointer.withMemoryRebound<A, B>(to:_:)(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t)partial apply for thunk for @callee_guaranteed (@unowned UnsafeBufferPointer<A1>) -> (@out B1, @error @owned Error), (uint64_t (*)(uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_sSRsRi_zrlE17withMemoryRebound2to_qd_1_qd__m_qd_1_SRyqd__Gqd_0_YKXEtqd_0_YKs5ErrorRd_0_Ri_d__Ri_d_1_r1_lFSRyxGq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyqd__sAD_pqd_1_Isgyrzr_AEqd_1_sAD_psAD_pRsd_0_Ri_zRi_d__Ri_d_1_r_1_lIetMgyrzo_Tp5);
}

uint64_t UnsafeMutableBufferPointer.withMemoryRebound<A, B>(to:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t (*a10)(uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  v11[2] = a6;
  v11[3] = a7;
  v11[4] = a8;
  v11[5] = a2;
  v11[6] = a3;
  return a10(a9, v11, a4, a5, a6, a7, a8);
}

unint64_t UnsafeBufferPointer.debugDescription.getter(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = specialized static String._createEmpty(withInitialCapacity:)(22);
  uint64_t v8 = v6;
  unint64_t v9 = v7;
  v275._uint64_t countAndFlagsBits = v6;
  v275._unint64_t object = (void *)v7;
  unint64_t v10 = HIBYTE(v7) & 0xF;
  unint64_t v11 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v7 & 0x2000000000000000) != 0) {
    uint64_t v12 = HIBYTE(v7) & 0xF;
  }
  else {
    uint64_t v12 = v6 & 0xFFFFFFFFFFFFLL;
  }
  if (!v12 && (v6 & ~v7 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v7);
    v275._uint64_t countAndFlagsBits = 0x203A747261747328;
    v275._unint64_t object = (void *)0xE800000000000000;
    if (a1) {
      goto LABEL_80;
    }
    goto LABEL_58;
  }
  if ((v7 & 0x2000000000000000) == 0 || v10 > 7)
  {
    swift_bridgeObjectRetain_n(0xE800000000000000, 6);
    if ((v9 & 0x1000000000000000) == 0)
    {
      Swift::Int v20 = v12 + 8;
      if (!__OFADD__(v12, 8)) {
        goto LABEL_13;
      }
      goto LABEL_310;
    }
    goto LABEL_308;
  }
  uint64_t v13 = 8 * HIBYTE(v7);
  uint64_t v14 = (40 << (v13 & 0x38)) | ((-255 << (v13 & 0x38)) - 1) & v6;
  char v15 = (v13 + 8) & 0x38;
  uint64_t v16 = (-255 << v15) - 1;
  uint64_t v17 = 115 << v15;
  if (v10 >= 7)
  {
    unint64_t v19 = v17 | v16 & v7;
    char v18 = 8;
    goto LABEL_32;
  }
  uint64_t v14 = v17 | v16 & v14;
  if (v10 == 6)
  {
    char v18 = 0;
    unint64_t v19 = v7;
LABEL_32:
    uint64_t v28 = (116 << v18) | ((-255 << v18) - 1) & v19;
    char v29 = v10 + 3;
LABEL_33:
    uint64_t v30 = (97 << (8 * (v29 & 7u))) | ((-255 << (8 * (v29 & 7u))) - 1) & v28;
    char v31 = v10 + 4;
LABEL_34:
    uint64_t v32 = (114 << (8 * (v31 & 7u))) | ((-255 << (8 * (v31 & 7u))) - 1) & v30;
    char v33 = v10 + 5;
LABEL_35:
    uint64_t v34 = (116 << (8 * (v33 & 7u))) | ((-255 << (8 * (v33 & 7u))) - 1) & v32;
    char v35 = v10 + 6;
LABEL_36:
    uint64_t v36 = (58 << (8 * (v35 & 7u))) | ((-255 << (8 * (v35 & 7u))) - 1) & v34;
    char v37 = v10 + 7;
    goto LABEL_37;
  }
  uint64_t v14 = (116 << ((v13 + 16) & 0x38)) | ((-255 << ((v13 + 16) & 0x38)) - 1) & v14;
  if (v10 >= 5)
  {
    char v29 = 8;
    uint64_t v28 = v7;
    goto LABEL_33;
  }
  uint64_t v14 = (97 << ((v13 + 24) & 0x38)) | ((-255 << ((v13 + 24) & 0x38)) - 1) & v14;
  if (v10 == 4)
  {
    char v31 = 8;
    uint64_t v30 = v7;
    goto LABEL_34;
  }
  uint64_t v14 = (114 << ((v13 + 32) & 0x38)) | ((-255 << ((v13 + 32) & 0x38)) - 1) & v14;
  if (v10 >= 3)
  {
    char v33 = 8;
    uint64_t v32 = v7;
    goto LABEL_35;
  }
  uint64_t v14 = (116 << ((v13 + 40) & 0x38)) | ((-255 << ((v13 + 40) & 0x38)) - 1) & v14;
  if (v10 == 2)
  {
    char v35 = 8;
    uint64_t v34 = v7;
    goto LABEL_36;
  }
  uint64_t v14 = (58 << ((v13 + 48) & 0x38)) | ((-255 << ((v13 + 48) & 0x38)) - 1) & v14;
  if (!v10)
  {
    uint64_t v14 = (32 << ((v13 + 56) & 0x38)) | ((-255 << ((v13 + 56) & 0x38)) - 1) & v14;
    uint64_t v38 = v7;
    goto LABEL_38;
  }
  char v37 = 8;
  uint64_t v36 = v7;
LABEL_37:
  uint64_t v38 = (32 << (8 * (v37 & 7u))) | ((-255 << (8 * (v37 & 7u))) - 1) & v36;
LABEL_38:
  swift_bridgeObjectRelease(v7);
  swift_bridgeObjectRelease(0xE800000000000000);
  unint64_t v41 = 0xA000000000000000;
  if (!(v14 & 0x8080808080808080 | v38 & 0x80808080808080)) {
    unint64_t v41 = 0xE000000000000000;
  }
  v275._uint64_t countAndFlagsBits = v14;
  v275._unint64_t object = (void *)((v41 & 0xFF00000000000000 | (v10 << 56) | v38 & 0xFFFFFFFFFFFFFFLL) + 0x800000000000000);
  if (a1) {
    goto LABEL_80;
  }
LABEL_58:
  a3 = 0xE300000000000000;
  a1 = 7104878;
  while (1)
  {
    uint64_t countAndFlagsBits = v275._countAndFlagsBits;
    unint64_t object = (unint64_t)v275._object;
    unint64_t v75 = ((unint64_t)v275._object >> 56) & 0xF;
    if (((uint64_t)v275._object & 0x2000000000000000) != 0) {
      unint64_t v76 = ((unint64_t)v275._object >> 56) & 0xF;
    }
    else {
      unint64_t v76 = v275._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v273 = a2;
    if (!v76 && (v275._countAndFlagsBits & ~(uint64_t)v275._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v275._object);
      v275._uint64_t countAndFlagsBits = a1;
      v275._unint64_t object = (void *)a3;
      goto LABEL_170;
    }
    uint64_t v8 = a3 & 0x2000000000000000;
    unint64_t v11 = HIBYTE(a3) & 0xF;
    if (((uint64_t)v275._object & 0x2000000000000000) != 0 && v8)
    {
      unint64_t v77 = v75 + v11;
      if (v75 + v11 <= 0xF)
      {
        if (v11)
        {
          char v94 = 0;
          unint64_t v95 = 0;
          unint64_t v96 = (unint64_t)v275._object;
          do
          {
            unint64_t v97 = v75 + v95;
            unint64_t v98 = v95 + 1;
            if (v95 >= 8) {
              unint64_t v99 = a3;
            }
            else {
              unint64_t v99 = a1;
            }
            unint64_t v100 = v99 >> (v94 & 0x38);
            char v101 = (8 * v75 + v94) & 0x38;
            uint64_t v102 = (-255 << v101) - 1;
            unint64_t v103 = (unint64_t)v100 << v101;
            unint64_t v104 = v103 | v102 & v96;
            unint64_t v105 = v103 | v102 & countAndFlagsBits;
            if (v97 < 8) {
              uint64_t countAndFlagsBits = v105;
            }
            else {
              unint64_t v96 = v104;
            }
            v94 += 8;
            unint64_t v95 = v98;
          }
          while (v11 != v98);
        }
        else
        {
          unint64_t v96 = (unint64_t)v275._object;
        }
        swift_bridgeObjectRelease((uint64_t)v275._object);
        swift_bridgeObjectRelease(a3);
        unint64_t v132 = 0xA000000000000000;
        if (!(countAndFlagsBits & 0x8080808080808080 | v96 & 0x80808080808080)) {
          unint64_t v132 = 0xE000000000000000;
        }
        v275._uint64_t countAndFlagsBits = countAndFlagsBits;
        v275._unint64_t object = (void *)(v132 & 0xFF00000000000000 | (v77 << 56) | v96 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_170;
      }
      uint64_t v8 = 1;
    }
    int64_t v53 = a1 & 0xFFFFFFFFFFFFLL;
    uint64_t v78 = v8 ? HIBYTE(a3) & 0xF : a1 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(a3, 2);
    if ((a3 & 0x1000000000000000) != 0) {
      break;
    }
    swift_bridgeObjectRetain_n(a3, 4);
    a2 = v78;
    if ((object & 0x1000000000000000) != 0) {
      goto LABEL_293;
    }
LABEL_95:
    BOOL v79 = __OFADD__(v76, a2);
    Swift::Int v80 = v76 + a2;
    if (v79) {
      goto LABEL_295;
    }
LABEL_96:
    uint64_t v272 = v78;
    if ((countAndFlagsBits & ~object & 0x2000000000000000) == 0
      || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v80 >= 16)
      {
        uint64_t v81 = v275._countAndFlagsBits;
        unint64_t v9 = (unint64_t)v275._object;
        goto LABEL_105;
      }
      Swift::Int v20 = (Swift::Int)v275._object;
      if (((uint64_t)v275._object & 0x2000000000000000) != 0)
      {
        int v93 = 0;
        unint64_t v9 = (unint64_t)v275._object;
      }
      else
      {
        unint64_t v9 = (unint64_t)v275._object;
LABEL_128:
        int v93 = 1;
      }
LABEL_147:
      swift_bridgeObjectRelease_n(a3, 5);
      unint64_t v11 = v275._countAndFlagsBits;
      if (v93)
      {
LABEL_311:
        if ((v20 & 0x1000000000000000) != 0)
        {
          unint64_t v11 = _StringGuts._foreignConvertedToSmall()(v11, v9);
          Swift::Int v20 = v266;
        }
        else
        {
          if ((v11 & 0x1000000000000000) != 0)
          {
            uint64_t v254 = (unsigned __int8 *)((v20 & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v255 = v11 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            uint64_t v254 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v11, v9);
            uint64_t v255 = v269;
          }
          swift_bridgeObjectRetain(v9);
          closure #1 in _StringGuts._convertedToSmall()(v254, v255, &v274);
          swift_bridgeObjectRelease(v9);
          Swift::Int v20 = *((void *)&v274 + 1);
          unint64_t v11 = v274;
        }
      }
      v110._rawBits = (v272 << 16) | 1;
      v111._rawBits = 1;
      v112._rawBits = _StringGuts.validateScalarRange(_:)(v111, v110, a1, a3);
      if (v112._rawBits < 0x10000) {
        v112._rawBits |= 3;
      }
      unint64_t v114 = specialized String.init(_:)(v112, v113, a1, a3);
      unint64_t v116 = v115;
      swift_bridgeObjectRelease(a3);
      if ((v116 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v116);
      }
      else if ((v116 & 0x1000000000000000) != 0)
      {
        unint64_t v114 = _StringGuts._foreignConvertedToSmall()(v114, v116);
        unint64_t v268 = v267;
        swift_bridgeObjectRelease(v116);
        unint64_t v116 = v268;
      }
      else
      {
        if ((v114 & 0x1000000000000000) != 0)
        {
          unint64_t v256 = (unsigned __int8 *)((v116 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v257 = v114 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          unint64_t v256 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v114, v116);
        }
        closure #1 in _StringGuts._convertedToSmall()(v256, v257, &v274);
        swift_bridgeObjectRelease(v116);
        unint64_t v116 = *((void *)&v274 + 1);
        unint64_t v114 = v274;
      }
      uint64_t v117 = HIBYTE(v20) & 0xF;
      uint64_t v118 = HIBYTE(v116) & 0xF;
      uint64_t v119 = v118 + v117;
      if ((unint64_t)(v118 + v117) > 0xF) {
        goto LABEL_333;
      }
      if (v118)
      {
        char v120 = 0;
        unint64_t v121 = 0;
        do
        {
          unint64_t v122 = v117 + v121;
          unint64_t v123 = v121 + 1;
          if (v121 >= 8) {
            unint64_t v124 = v116;
          }
          else {
            unint64_t v124 = v114;
          }
          unint64_t v125 = v124 >> (v120 & 0x38);
          char v126 = (8 * v117 + v120) & 0x38;
          uint64_t v127 = (-255 << v126) - 1;
          unint64_t v128 = (unint64_t)v125 << v126;
          Swift::Int v129 = v128 | v127 & v20;
          unint64_t v130 = v128 | v127 & v11;
          if (v122 < 8) {
            unint64_t v11 = v130;
          }
          else {
            Swift::Int v20 = v129;
          }
          v120 += 8;
          unint64_t v121 = v123;
        }
        while (v118 != v123);
      }
      swift_bridgeObjectRelease(v9);
      swift_bridgeObjectRelease(a3);
      unint64_t v131 = 0xA000000000000000;
      if (!(v11 & 0x8080808080808080 | v20 & 0x80808080808080)) {
        unint64_t v131 = 0xE000000000000000;
      }
      v275._uint64_t countAndFlagsBits = v11;
      v275._unint64_t object = (void *)(v131 & 0xFF00000000000000 | (v119 << 56) | v20 & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_170;
    }
    uint64_t v81 = v275._countAndFlagsBits;
    unint64_t v9 = (unint64_t)v275._object;
    int64_t v82 = _StringGuts.nativeUnusedCapacity.getter(v275._countAndFlagsBits, (uint64_t)v275._object);
    if (v83) {
      goto LABEL_334;
    }
    if (v80 <= 15)
    {
      if ((v9 & 0x2000000000000000) != 0)
      {
        int v93 = 0;
        Swift::Int v20 = v9;
        goto LABEL_147;
      }
      Swift::Int v20 = v9;
      if (v82 < a2) {
        goto LABEL_128;
      }
    }
LABEL_105:
    int64_t v84 = _StringGuts.nativeUnusedCapacity.getter(v81, v9);
    unint64_t v55 = (v85 & 1) == 0 && v84 >= a2;
    if ((v81 & ~v9 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v55) {
        goto LABEL_123;
      }
LABEL_116:
      uint64_t v87 = _StringGuts.nativeCapacity.getter(v81, v9);
      if (v88) {
        uint64_t v89 = 0;
      }
      else {
        uint64_t v89 = v87;
      }
      if (v89 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_320;
      }
      uint64_t v90 = 2 * v89;
      if (v90 > v80) {
        Swift::Int v80 = v90;
      }
      goto LABEL_122;
    }
    if ((v55 & 1) == 0) {
      goto LABEL_116;
    }
LABEL_122:
    _StringGuts.grow(_:)(v80);
LABEL_123:
    swift_bridgeObjectRelease_n(a3, 4);
    if ((a3 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(a3);
      _StringGuts._foreignAppendInPlace(_:)(a1, a3, 0, v272);
    }
    else
    {
      if (v8)
      {
        swift_bridgeObjectRelease_n(a3, 2);
        *(void *)&long long v274 = a1;
        *((void *)&v274 + 1) = a3 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v91 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(a3) & 0xF, (uint64_t)&v274, HIBYTE(a3) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v91, v92, (a3 & 0x4000000000000000) != 0);
        swift_bridgeObjectRelease(a3);
        goto LABEL_170;
      }
      if ((a1 & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRelease(a3);
        id v106 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v107 = a1 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        id v106 = _StringObject.sharedUTF8.getter(a1, a3);
        uint64_t v107 = v264;
        swift_bridgeObjectRelease(a3);
        if (v107 < v53) {
          goto LABEL_332;
        }
      }
      BOOL v108 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, a1 & 0xFFFFFFFFFFFFLL, (uint64_t)v106, v107);
      _StringGuts.appendInPlace(_:isASCII:)(v108, v109, a1 < 0);
    }
    swift_bridgeObjectRelease_n(a3, 2);
LABEL_170:
    Swift::String v133 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", count: ", 9uLL, 1);
    a1 = v133._countAndFlagsBits;
    a3 = (unint64_t)v133._object;
    uint64_t v134 = v275._countAndFlagsBits;
    unint64_t v9 = (unint64_t)v275._object;
    unint64_t v135 = ((unint64_t)v275._object >> 56) & 0xF;
    unint64_t v136 = v275._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v275._object & 0x2000000000000000) != 0) {
      unint64_t v136 = ((unint64_t)v275._object >> 56) & 0xF;
    }
    if (!v136 && (v275._countAndFlagsBits & ~(uint64_t)v275._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v275._object);
      Swift::String v275 = v133;
      goto LABEL_204;
    }
    a2 = (uint64_t)v133._object & 0x2000000000000000;
    uint64_t v8 = ((unint64_t)v133._object >> 56) & 0xF;
    if (((uint64_t)v275._object & 0x2000000000000000) != 0 && a2)
    {
      unint64_t v137 = v135 + v8;
      if (v135 + v8 <= 0xF)
      {
        uint64_t v161 = v273;
        if (v8)
        {
          char v195 = 0;
          unint64_t v196 = 0;
          unint64_t v197 = (unint64_t)v275._object;
          do
          {
            unint64_t v198 = v135 + v196;
            unint64_t v199 = v196 + 1;
            if (v196 >= 8) {
              unint64_t v200 = (unint64_t)v133._object;
            }
            else {
              unint64_t v200 = v133._countAndFlagsBits;
            }
            unint64_t v201 = v200 >> (v195 & 0x38);
            char v202 = (8 * v135 + v195) & 0x38;
            uint64_t v203 = (-255 << v202) - 1;
            unint64_t v204 = (unint64_t)v201 << v202;
            unint64_t v205 = v204 | v203 & v197;
            unint64_t v206 = v204 | v203 & v134;
            if (v198 < 8) {
              uint64_t v134 = v206;
            }
            else {
              unint64_t v197 = v205;
            }
            v195 += 8;
            unint64_t v196 = v199;
          }
          while (v8 != v199);
        }
        else
        {
          unint64_t v197 = (unint64_t)v275._object;
        }
        swift_bridgeObjectRelease((uint64_t)v275._object);
        swift_bridgeObjectRelease((uint64_t)v133._object);
        unint64_t v227 = 0xA000000000000000;
        if (!(v134 & 0x8080808080808080 | v197 & 0x80808080808080)) {
          unint64_t v227 = 0xE000000000000000;
        }
        v275._uint64_t countAndFlagsBits = v134;
        v275._unint64_t object = (void *)(v227 & 0xFF00000000000000 | (v137 << 56) | v197 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_205;
      }
      a2 = 1;
    }
    unint64_t v11 = v133._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (a2) {
      int64_t v53 = ((unint64_t)v133._object >> 56) & 0xF;
    }
    else {
      int64_t v53 = v133._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n((uint64_t)v133._object, 2);
    if (((uint64_t)v133._object & 0x1000000000000000) != 0) {
      goto LABEL_296;
    }
    swift_bridgeObjectRetain_n((uint64_t)v133._object, 4);
    Swift::Int v138 = v53;
    if ((v9 & 0x1000000000000000) != 0) {
      goto LABEL_299;
    }
LABEL_183:
    if ((v9 & 0x2000000000000000) != 0)
    {
      uint64_t v140 = HIBYTE(v9) & 0xF;
      uint64_t v139 = v140 + v138;
      if (__OFADD__(v140, v138)) {
        goto LABEL_301;
      }
    }
    else
    {
      uint64_t v139 = (v134 & 0xFFFFFFFFFFFFLL) + v138;
      if (__OFADD__(v134 & 0xFFFFFFFFFFFFLL, v138)) {
        goto LABEL_301;
      }
    }
LABEL_188:
    if ((v134 & ~v9 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v141 = _StringGuts.nativeUnusedCapacity.getter(v134, v9);
      if (v142) {
        goto LABEL_334;
      }
      if (v139 <= 15 && ((v9 & 0x2000000000000000) != 0 || v141 < v138))
      {
LABEL_198:
        swift_bridgeObjectRelease_n(a3, 5);
        unint64_t v145 = v275._countAndFlagsBits;
        swift_bridgeObjectRetain(v9);
        unint64_t v146 = _StringGuts._convertedToSmall()(v145, v9);
        unint64_t v148 = v147;
        swift_bridgeObjectRelease(v9);
        v149._rawBits = (v53 << 16) | 1;
        v150._rawBits = 1;
        v151._rawBits = _StringGuts.validateScalarRange(_:)(v150, v149, a1, a3);
        if (v151._rawBits < 0x10000) {
          v151._rawBits |= 3;
        }
        unint64_t v153 = specialized String.init(_:)(v151, v152, a1, a3);
        unint64_t v155 = v154;
        swift_bridgeObjectRelease(a3);
        unint64_t v156 = _StringGuts._convertedToSmall()(v153, v155);
        unint64_t v158 = v157;
        swift_bridgeObjectRelease(v155);
        unint64_t v159 = specialized _SmallString.init(_:appending:)(v146, v148, v156, v158);
        uint64_t v161 = v273;
        if (v162) {
          goto LABEL_333;
        }
        uint64_t v163 = v159;
        uint64_t v164 = v160;
        swift_bridgeObjectRelease(v9);
        swift_bridgeObjectRelease(a3);
        v275._uint64_t countAndFlagsBits = v163;
        v275._unint64_t object = v164;
        goto LABEL_205;
      }
    }
    else if (v139 <= 15)
    {
      goto LABEL_198;
    }
    _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v139, v138);
    swift_bridgeObjectRelease_n(a3, 4);
    if ((a3 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(a3);
      _StringGuts._foreignAppendInPlace(_:)(a1, a3, 0, v53);
      swift_bridgeObjectRelease_n(a3, 2);
      goto LABEL_204;
    }
    if (a2)
    {
      swift_bridgeObjectRelease_n(a3, 2);
      *(void *)&long long v274 = a1;
      *((void *)&v274 + 1) = a3 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v143 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v8, (uint64_t)&v274, v8);
      _StringGuts.appendInPlace(_:isASCII:)(v143, v144, (a3 & 0x4000000000000000) != 0);
      swift_bridgeObjectRelease(a3);
LABEL_204:
      uint64_t v161 = v273;
      goto LABEL_205;
    }
    if ((a1 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(a3);
      id v219 = (id)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v220 = v11;
    }
    else
    {
      id v219 = _StringObject.sharedUTF8.getter(a1, a3);
      uint64_t v220 = v262;
      swift_bridgeObjectRelease(a3);
      if (v220 < (uint64_t)v11) {
        goto LABEL_332;
      }
    }
    uint64_t v161 = v273;
    v221 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v11, (uint64_t)v219, v220);
    _StringGuts.appendInPlace(_:isASCII:)(v221, v222, a1 < 0);
    swift_bridgeObjectRelease_n(a3, 2);
LABEL_205:
    unint64_t v165 = _int64ToString(_:radix:uppercase:)(v161, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
    a3 = v165;
    uint64_t v139 = v166;
    unint64_t v9 = v275._countAndFlagsBits;
    uint64_t v8 = (uint64_t)v275._object;
    unint64_t v167 = ((unint64_t)v275._object >> 56) & 0xF;
    if (((uint64_t)v275._object & 0x2000000000000000) != 0) {
      int64_t v53 = ((unint64_t)v275._object >> 56) & 0xF;
    }
    else {
      int64_t v53 = v275._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v53 && (v275._countAndFlagsBits & ~(uint64_t)v275._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v275._object);
      v275._uint64_t countAndFlagsBits = a3;
      v275._unint64_t object = (void *)v139;
      goto LABEL_273;
    }
    a2 = v166 & 0x2000000000000000;
    a1 = HIBYTE(v166) & 0xF;
    if (((uint64_t)v275._object & 0x2000000000000000) != 0 && a2)
    {
      unint64_t v168 = v167 + a1;
      if (v167 + a1 <= 0xF)
      {
        if (a1)
        {
          char v207 = 0;
          unint64_t v208 = 0;
          unint64_t v209 = (unint64_t)v275._object;
          do
          {
            unint64_t v210 = v167 + v208;
            unint64_t v211 = v208 + 1;
            if (v208 >= 8) {
              unint64_t v212 = v166;
            }
            else {
              unint64_t v212 = v165;
            }
            unint64_t v213 = v212 >> (v207 & 0x38);
            char v214 = (8 * v167 + v207) & 0x38;
            uint64_t v215 = (-255 << v214) - 1;
            unint64_t v216 = (unint64_t)v213 << v214;
            unint64_t v217 = v216 | v215 & v209;
            unint64_t v218 = v216 | v215 & v9;
            if (v210 < 8) {
              unint64_t v9 = v218;
            }
            else {
              unint64_t v209 = v217;
            }
            v207 += 8;
            unint64_t v208 = v211;
          }
          while (a1 != v211);
        }
        else
        {
          unint64_t v209 = (unint64_t)v275._object;
        }
        swift_bridgeObjectRelease((uint64_t)v275._object);
        swift_bridgeObjectRelease(v139);
        unint64_t v228 = 0xA000000000000000;
        if (!(v9 & 0x8080808080808080 | v209 & 0x80808080808080)) {
          unint64_t v228 = 0xE000000000000000;
        }
        v275._uint64_t countAndFlagsBits = v9;
        v275._unint64_t object = (void *)(v228 & 0xFF00000000000000 | (v168 << 56) | v209 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_273;
      }
      a2 = 1;
    }
    uint64_t v134 = v165 & 0xFFFFFFFFFFFFLL;
    if (a2) {
      unint64_t v11 = HIBYTE(v166) & 0xF;
    }
    else {
      unint64_t v11 = v165 & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n(v166, 2);
    if ((v139 & 0x1000000000000000) != 0) {
      goto LABEL_302;
    }
    swift_bridgeObjectRetain_n(v139, 4);
    Swift::Int v169 = v11;
    if ((v8 & 0x1000000000000000) != 0) {
      goto LABEL_305;
    }
LABEL_219:
    BOOL v79 = __OFADD__(v53, v169);
    int64_t v170 = v53 + v169;
    if (!v79) {
      goto LABEL_220;
    }
LABEL_307:
    __break(1u);
LABEL_308:
    Swift::Int v253 = String.UTF8View._foreignCount()();
    Swift::Int v20 = v253 + 8;
    if (__OFADD__(v253, 8))
    {
LABEL_310:
      __break(1u);
      goto LABEL_311;
    }
LABEL_13:
    unint64_t v21 = v8 & ~v9;
    if ((v21 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v22 = _StringGuts.nativeUnusedCapacity.getter(v8, v9);
      if (v23) {
        goto LABEL_334;
      }
      if (v20 > 15) {
        goto LABEL_21;
      }
      if ((v9 & 0x2000000000000000) != 0) {
        goto LABEL_62;
      }
      if (v22 > 7)
      {
LABEL_21:
        int64_t v24 = _StringGuts.nativeUnusedCapacity.getter(v8, v9);
        BOOL v27 = (v25 & 1) == 0 && v24 > 7;
        if ((v21 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v9 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v27) {
            goto LABEL_50;
          }
        }
        else if (v27)
        {
          goto LABEL_49;
        }
        uint64_t v42 = _StringGuts.nativeCapacity.getter(v8, v9);
        if (v43) {
          uint64_t v44 = 0;
        }
        else {
          uint64_t v44 = v42;
        }
        if (v44 + 0x4000000000000000 >= 0)
        {
          uint64_t v45 = 2 * v44;
          if (v45 > v20) {
            Swift::Int v20 = v45;
          }
LABEL_49:
          _StringGuts.grow(_:)(v20);
LABEL_50:
          swift_bridgeObjectRelease_n(0xE800000000000000, 6);
          long long v274 = xmmword_18162B020;
          char v46 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 8, (uint64_t)&v274, 8);
          _StringGuts.appendInPlace(_:isASCII:)(v46, v47, 1);
          swift_bridgeObjectRelease(0xE800000000000000);
          if (!a1) {
            goto LABEL_58;
          }
          goto LABEL_80;
        }
        __break(1u);
LABEL_325:
        uint64_t v8 = _StringGuts._foreignConvertedToSmall()(v8, v9);
        unint64_t v11 = v260;
        goto LABEL_63;
      }
    }
    else
    {
      if (v20 > 15) {
        goto LABEL_21;
      }
      if ((v9 & 0x2000000000000000) != 0)
      {
LABEL_62:
        swift_bridgeObjectRelease_n(0xE800000000000000, 5);
        unint64_t v11 = v9;
        goto LABEL_63;
      }
    }
    swift_bridgeObjectRelease_n(0xE800000000000000, 5);
    if ((v9 & 0x1000000000000000) != 0) {
      goto LABEL_325;
    }
    if ((v8 & 0x1000000000000000) != 0)
    {
      uint64_t v48 = (unsigned __int8 *)((v9 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      uint64_t v48 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v8, v9);
      unint64_t v11 = v261;
    }
    swift_bridgeObjectRetain(v9);
    closure #1 in _StringGuts._convertedToSmall()(v48, v11, &v274);
    swift_bridgeObjectRelease(v9);
    unint64_t v11 = *((void *)&v274 + 1);
    uint64_t v8 = v274;
LABEL_63:
    v49._rawBits = 1;
    v50._rawBits = 524289;
    v51._rawBits = _StringGuts.validateScalarRange(_:)(v49, v50, 0x203A747261747328uLL, 0xE800000000000000);
    if (v51._rawBits < 0x10000) {
      v51._rawBits |= 3;
    }
    int64_t v53 = specialized String.init(_:)(v51, v52, 0x203A747261747328uLL, 0xE800000000000000);
    unint64_t v55 = v54;
    swift_bridgeObjectRelease(0xE800000000000000);
    if ((v55 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v55);
      goto LABEL_67;
    }
LABEL_320:
    if ((v55 & 0x1000000000000000) != 0)
    {
      int64_t v53 = _StringGuts._foreignConvertedToSmall()(v53, v55);
      unint64_t v271 = v270;
      swift_bridgeObjectRelease(v55);
      unint64_t v55 = v271;
    }
    else
    {
      if ((v53 & 0x1000000000000000) != 0)
      {
        v258 = (unsigned __int8 *)((v55 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v259 = v53 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        v258 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v53, v55);
      }
      closure #1 in _StringGuts._convertedToSmall()(v258, v259, &v274);
      swift_bridgeObjectRelease(v55);
      unint64_t v55 = *((void *)&v274 + 1);
      int64_t v53 = v274;
    }
LABEL_67:
    uint64_t v56 = HIBYTE(v11) & 0xF;
    uint64_t v57 = HIBYTE(v55) & 0xF;
    uint64_t v58 = v57 + v56;
    if ((unint64_t)(v57 + v56) > 0xF) {
      goto LABEL_333;
    }
    if (v57)
    {
      char v59 = 0;
      unint64_t v60 = 0;
      do
      {
        unint64_t v61 = v56 + v60;
        unint64_t v62 = v60 + 1;
        if (v60 >= 8) {
          unint64_t v63 = v55;
        }
        else {
          unint64_t v63 = v53;
        }
        unint64_t v64 = v63 >> (v59 & 0x38);
        char v65 = (8 * v56 + v59) & 0x38;
        uint64_t v66 = (-255 << v65) - 1;
        unint64_t v67 = (unint64_t)v64 << v65;
        unint64_t v68 = v67 | v66 & v11;
        unint64_t v69 = v67 | v66 & v8;
        if (v61 < 8) {
          uint64_t v8 = v69;
        }
        else {
          unint64_t v11 = v68;
        }
        v59 += 8;
        unint64_t v60 = v62;
      }
      while (v57 != v62);
    }
    swift_bridgeObjectRelease(v9);
    swift_bridgeObjectRelease(0xE800000000000000);
    unint64_t v70 = 0xA000000000000000;
    if (!(v8 & 0x8080808080808080 | v11 & 0x80808080808080)) {
      unint64_t v70 = 0xE000000000000000;
    }
    v275._uint64_t countAndFlagsBits = v8;
    v275._unint64_t object = (void *)(v70 & 0xFF00000000000000 | (v58 << 56) | v11 & 0xFFFFFFFFFFFFFFLL);
    if (!a1) {
      goto LABEL_58;
    }
LABEL_80:
    *(void *)&long long v274 = a1;
    uint64_t v71 = type metadata accessor for UnsafePointer(0, a3, v39, v40);
    a1 = String.init<A>(describing:)((uint64_t)&v274, v71);
    a3 = v72;
  }
  swift_bridgeObjectRetain_n(a3, 5);
  v238._rawBits = 1;
  v239._rawBits = (v78 << 16) | 1;
  v240._rawBits = _StringGuts.validateScalarRange(_:)(v238, v239, a1, a3);
  if (v240._rawBits < 0x10000) {
    v240._rawBits |= 3;
  }
  a2 = specialized Collection.count.getter(v240, v241, a1, a3);
  swift_bridgeObjectRelease(a3);
  if ((object & 0x1000000000000000) == 0) {
    goto LABEL_95;
  }
LABEL_293:
  Swift::Int v242 = String.UTF8View._foreignCount()();
  Swift::Int v80 = v242 + a2;
  if (!__OFADD__(v242, a2)) {
    goto LABEL_96;
  }
LABEL_295:
  __break(1u);
LABEL_296:
  swift_bridgeObjectRetain_n(a3, 5);
  v243._rawBits = 1;
  v244._rawBits = (v53 << 16) | 1;
  v245._rawBits = _StringGuts.validateScalarRange(_:)(v243, v244, a1, a3);
  if (v245._rawBits < 0x10000) {
    v245._rawBits |= 3;
  }
  Swift::Int v138 = specialized Collection.count.getter(v245, v246, a1, a3);
  swift_bridgeObjectRelease(a3);
  uint64_t v134 = v275._countAndFlagsBits;
  unint64_t v9 = (unint64_t)v275._object;
  if (((uint64_t)v275._object & 0x1000000000000000) == 0) {
    goto LABEL_183;
  }
LABEL_299:
  Swift::Int v247 = String.UTF8View._foreignCount()();
  uint64_t v139 = v247 + v138;
  if (!__OFADD__(v247, v138)) {
    goto LABEL_188;
  }
LABEL_301:
  __break(1u);
LABEL_302:
  swift_bridgeObjectRetain_n(v139, 5);
  v248._rawBits = 1;
  v249._rawBits = (v11 << 16) | 1;
  v250._rawBits = _StringGuts.validateScalarRange(_:)(v248, v249, a3, v139);
  if (v250._rawBits < 0x10000) {
    v250._rawBits |= 3;
  }
  Swift::Int v169 = specialized Collection.count.getter(v250, v251, a3, v139);
  swift_bridgeObjectRelease(v139);
  if ((v8 & 0x1000000000000000) == 0) {
    goto LABEL_219;
  }
LABEL_305:
  Swift::Int v252 = String.UTF8View._foreignCount()();
  int64_t v170 = v252 + v169;
  if (__OFADD__(v252, v169)) {
    goto LABEL_307;
  }
LABEL_220:
  if ((v9 & ~v8 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v8 & 0xFFFFFFFFFFFFFFFLL))
  {
    unint64_t v171 = (unint64_t)v275._object;
    int64_t v172 = _StringGuts.nativeUnusedCapacity.getter(v275._countAndFlagsBits, (uint64_t)v275._object);
    if (v173)
    {
LABEL_334:
      unint64_t v265 = 258;
      goto LABEL_335;
    }
    if (v170 <= 15 && ((v171 & 0x2000000000000000) != 0 || v172 < v169))
    {
LABEL_232:
      swift_bridgeObjectRelease_n(v139, 5);
      unint64_t v176 = v275._countAndFlagsBits;
      swift_bridgeObjectRetain(v171);
      unint64_t v177 = _StringGuts._convertedToSmall()(v176, v171);
      unint64_t v179 = v178;
      swift_bridgeObjectRelease(v171);
      v180._rawBits = (v11 << 16) | 1;
      v181._rawBits = 1;
      v182._rawBits = _StringGuts.validateScalarRange(_:)(v181, v180, a3, v139);
      if (v182._rawBits < 0x10000) {
        v182._rawBits |= 3;
      }
      unint64_t v184 = specialized String.init(_:)(v182, v183, a3, v139);
      unint64_t v186 = v185;
      swift_bridgeObjectRelease(v139);
      unint64_t v187 = _StringGuts._convertedToSmall()(v184, v186);
      unint64_t v189 = v188;
      swift_bridgeObjectRelease(v186);
      unint64_t v190 = specialized _SmallString.init(_:appending:)(v177, v179, v187, v189);
      if ((v192 & 1) == 0)
      {
        uint64_t v193 = v190;
        char v194 = v191;
        swift_bridgeObjectRelease(v171);
        swift_bridgeObjectRelease(v139);
        v275._uint64_t countAndFlagsBits = v193;
        v275._unint64_t object = v194;
        goto LABEL_273;
      }
LABEL_333:
      unint64_t v265 = 266;
LABEL_335:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v265, 0);
    }
  }
  else if (v170 <= 15)
  {
    unint64_t v171 = (unint64_t)v275._object;
    goto LABEL_232;
  }
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v170, v169);
  swift_bridgeObjectRelease_n(v139, 4);
  if ((v139 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v139);
    _StringGuts._foreignAppendInPlace(_:)(a3, v139, 0, v11);
  }
  else
  {
    if (a2)
    {
      swift_bridgeObjectRelease_n(v139, 2);
      *(void *)&long long v274 = a3;
      *((void *)&v274 + 1) = v139 & 0xFFFFFFFFFFFFFFLL;
      v174 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, a1, (uint64_t)&v274, a1);
      _StringGuts.appendInPlace(_:isASCII:)(v174, v175, (v139 & 0x4000000000000000) != 0);
      swift_bridgeObjectRelease(v139);
      goto LABEL_273;
    }
    if ((a3 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v139);
      id v223 = (id)((v139 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v224 = v134;
    }
    else
    {
      id v223 = _StringObject.sharedUTF8.getter(a3, v139);
      uint64_t v224 = v263;
      swift_bridgeObjectRelease(v139);
      if (v224 < v134) {
LABEL_332:
      }
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
    }
    unint64_t v225 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v134, (uint64_t)v223, v224);
    _StringGuts.appendInPlace(_:isASCII:)(v225, v226, (a3 & 0x8000000000000000) != 0);
  }
  swift_bridgeObjectRelease_n(v139, 2);
LABEL_273:
  v229 = v275._object;
  unint64_t v230 = ((unint64_t)v275._object >> 56) & 0xF;
  if (((uint64_t)v275._object & 0x2000000000000000) == 0) {
    unint64_t v230 = v275._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (v230 || (v275._countAndFlagsBits & ~(uint64_t)v275._object & 0x2000000000000000) != 0)
  {
    if (((uint64_t)v275._object & 0x2000000000000000) == 0
      || (unint64_t v231 = specialized _SmallString.init(_:appending:)(v275._countAndFlagsBits, (unint64_t)v275._object, 0x29uLL, 0xE100000000000000), (v233 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000);
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      unint64_t v234 = v275._countAndFlagsBits;
      v235 = v275._object;
    }
    else
    {
      unint64_t v234 = v231;
      v235 = v232;
      swift_bridgeObjectRelease((uint64_t)v229);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease((uint64_t)v275._object);
    v235 = (void *)0xE100000000000000;
    unint64_t v234 = 41;
  }
  unint64_t v236 = specialized static String.+ infix(_:_:)(0xD000000000000013, 0x800000018162B100 | 0x8000000000000000, v234, (unint64_t)v235);
  swift_bridgeObjectRelease(0x800000018162B100 | 0x8000000000000000);
  swift_bridgeObjectRelease((uint64_t)v235);
  return v236;
}

unint64_t _sSRyxGs28CustomDebugStringConvertiblesRi_zrlsABP16debugDescriptionSSvgTW(uint64_t a1)
{
  return UnsafeBufferPointer.debugDescription.getter(*v1, v1[1], *(void *)(a1 + 16));
}

uint64_t UnsafeMutableRawBufferPointer._end.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

char *UnsafeMutableRawBufferPointer._copyContents(initializing:)(void *a1, int64_t a2, char *__src, unint64_t a4)
{
  uint64_t v4 = __src;
  if (__src && a4 && (unint64_t)__src < a4 && a2)
  {
    if ((uint64_t)(a4 - (void)__src) >= a2) {
      size_t v5 = a2;
    }
    else {
      size_t v5 = a4 - (void)__src;
    }
    if ((v5 & 0x8000000000000000) != 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawPointer.copyMemory with negative count", 54, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x60DuLL, 0);
    }
    memmove(a1, __src, v5);
    v4 += v5;
  }
  return v4;
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeMutableRawBufferPointer()
{
  return specialized _copyCollectionToContiguousArray<A>(_:)(*v0, v0[1], (void (*)(__objc2_class **, uint64_t, uint64_t, uint64_t))UnsafeMutableRawBufferPointer._copyContents(initializing:));
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableRawBufferPointer(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableRawBufferPointer(a1, a2, a3, a4, a5, (uint64_t (*)(uint64_t, uint64_t, void, void))UnsafeMutableRawBufferPointer._copyContents(initializing:));
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UnsafeMutableRawBufferPointer@<X0>(uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return UnsafeMutableRawBufferPointer.withContiguousStorageIfAvailable<A>(_:)(a1, *v3, v3[1], a2, a3);
}

uint64_t UnsafeMutableRawBufferPointer.withContiguousStorageIfAvailable<A>(_:)@<X0>(uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  if (a2)
  {
    uint64_t v9 = a3 - a2;
    if (a3 - a2 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
    }
    uint64_t v10 = a2;
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v9 = 0;
  }
  uint64_t result = a1(v10, v9);
  if (!v5) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a4 - 8) + 56))(a5, 0, 1, a4);
  }
  return result;
}

uint64_t UnsafeMutableRawBufferPointer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return UnsafeMutableRawBufferPointer.subscript.getter(a1, a2, a3, 0xBBuLL, 0xBCuLL);
}

uint64_t key path getter for UnsafeMutableRawBufferPointer.subscript(_:) : UnsafeMutableRawBufferPointer@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t result = UnsafeMutableRawBufferPointer.subscript.getter(*a2, *a1, a1[1]);
  *a3 = result;
  return result;
}

uint64_t key path setter for UnsafeMutableRawBufferPointer.subscript(_:) : UnsafeMutableRawBufferPointer(unsigned __int8 *a1, uint64_t *a2, uint64_t *a3)
{
  return UnsafeMutableRawBufferPointer.subscript.setter(*a1, *a3, *a2, a2[1]);
}

uint64_t (*UnsafeMutableRawBufferPointer.subscript.modify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t a1)
{
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  *(void *)a1 = a2;
  *(unsigned char *)(a1 + 24) = UnsafeMutableRawBufferPointer.subscript.getter(a2, a3, a4);
  return UnsafeMutableRawBufferPointer.subscript.modify;
}

uint64_t UnsafeMutableRawBufferPointer.subscript.modify(uint64_t a1)
{
  return UnsafeMutableRawBufferPointer.subscript.setter(*(unsigned __int8 *)(a1 + 24), *(void *)a1, *(void *)(a1 + 8), *(void *)(a1 + 16));
}

uint64_t UnsafeMutableRawBufferPointer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnsafeMutableRawBufferPointer.subscript.getter(a1, a2, a3, a4, 0xCFuLL, 0xD0uLL);
}

uint64_t *key path getter for UnsafeMutableRawBufferPointer.subscript(_:) : UnsafeMutableRawBufferPointer@<X0>(uint64_t *result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if ((*a2 & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xCFuLL, 0);
  }
  uint64_t v3 = *result;
  uint64_t v4 = result[1];
  uint64_t v5 = a2[1];
  if (!*result)
  {
    if (v5 < 1) {
      goto LABEL_4;
    }
LABEL_6:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xD0uLL, 0);
  }
  if (v4 - v3 < v5) {
    goto LABEL_6;
  }
LABEL_4:
  *a3 = *a2;
  a3[1] = v5;
  a3[2] = v3;
  a3[3] = v4;
  return result;
}

void *key path setter for UnsafeMutableRawBufferPointer.subscript(_:) : UnsafeMutableRawBufferPointer(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  return UnsafeMutableRawBufferPointer.subscript.setter(*a1, a1[1], a1[2], a1[3], *a3, a3[1], *a2, a2[1]);
}

void *UnsafeMutableRawBufferPointer.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xD5uLL, 0);
  }
  if (a7)
  {
    if (a8 - a7 >= a6) {
      goto LABEL_4;
    }
LABEL_14:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xD6uLL, 0);
  }
  if (a6 >= 1) {
    goto LABEL_14;
  }
LABEL_4:
  uint64_t v14 = (void *)(a6 - a5);
  if (__OFSUB__(a6, a5))
  {
    __break(1u);
LABEL_17:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xD7uLL, 0);
  }
  uint64_t result = (void *)specialized RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, a4);
  if (v14 != result) {
    goto LABEL_17;
  }
  if (a1 == a2) {
    return result;
  }
  if (!a7)
  {
    unint64_t v17 = 218;
    goto LABEL_21;
  }
  if (!a3)
  {
    unint64_t v17 = 219;
LABEL_21:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, v17, 0);
  }
  size_t v16 = specialized RandomAccessCollection<>.distance(from:to:)(a1, a2, a3, a4);
  if ((v16 & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawPointer.copyMemory with negative count", 54, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x60DuLL, 0);
  }

  return memmove((void *)(a7 + a5), (const void *)(a3 + a1), v16);
}

void (*UnsafeMutableRawBufferPointer.subscript.modify(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5))(uint64_t **a1)
{
  uint64_t v10 = malloc(0x40uLL);
  *a1 = v10;
  v10[6] = a4;
  v10[7] = a5;
  v10[4] = a2;
  v10[5] = a3;
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xCFuLL, 0);
  }
  if (!a4)
  {
    if (a3 < 1) {
      goto LABEL_4;
    }
LABEL_6:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xD0uLL, 0);
  }
  if (a5 - a4 < a3) {
    goto LABEL_6;
  }
LABEL_4:
  *uint64_t v10 = a2;
  v10[1] = a3;
  v10[2] = a4;
  v10[3] = a5;
  return UnsafeMutableRawBufferPointer.subscript.modify;
}

void UnsafeMutableRawBufferPointer.subscript.modify(uint64_t **a1)
{
  uint64_t v1 = *a1;
  UnsafeMutableRawBufferPointer.subscript.setter(**a1, v1[1], v1[2], v1[3], (*a1)[4], (*a1)[5], (*a1)[6], (*a1)[7]);

  free(v1);
}

Swift::Void __swiftcall UnsafeMutableRawBufferPointer.swapAt(_:_:)(Swift::Int a1, Swift::Int a2)
{
  if (a1 != a2)
  {
    if ((a2 | a1) < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xF0uLL, 0);
    }
    if (!v2 || v3 - v2 <= a1 || v3 - v2 <= a2) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xF1uLL, 0);
    }
    char v4 = *(unsigned char *)(v2 + a1);
    *(unsigned char *)(v2 + a1) = *(unsigned char *)(v2 + a2);
    *(unsigned char *)(v2 + a2) = v4;
  }
}

uint64_t protocol witness for MutableCollection.subscript.setter in conformance UnsafeMutableRawBufferPointer(unsigned __int8 *a1, uint64_t *a2)
{
  return UnsafeMutableRawBufferPointer.subscript.setter(*a1, *a2, *v2, v2[1]);
}

uint64_t (*protocol witness for MutableCollection.subscript.modify in conformance UnsafeMutableRawBufferPointer(uint64_t a1, uint64_t *a2))(uint64_t a1)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *v2;
  uint64_t v6 = v2[1];
  *(void *)a1 = v4;
  *(void *)(a1 + 8) = v5;
  *(void *)(a1 + 16) = v6;
  *(unsigned char *)(a1 + 24) = UnsafeMutableRawBufferPointer.subscript.getter(v4, v5, v6);
  return UnsafeMutableRawBufferPointer.subscript.modify;
}

void *protocol witness for MutableCollection.subscript.setter in conformance UnsafeMutableRawBufferPointer(uint64_t *a1, uint64_t *a2)
{
  return UnsafeMutableRawBufferPointer.subscript.setter(*a1, a1[1], a1[2], a1[3], *a2, a2[1], *v2, v2[1]);
}

void (*protocol witness for MutableCollection.subscript.modify in conformance UnsafeMutableRawBufferPointer(void *a1, uint64_t *a2))(uint64_t **a1)
{
  uint64_t v5 = malloc(0x40uLL);
  *a1 = v5;
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  v5[4] = *a2;
  v5[5] = v7;
  uint64_t v8 = *v2;
  uint64_t v9 = v2[1];
  v5[6] = *v2;
  v5[7] = v9;
  if (v6 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xCFuLL, 0);
  }
  if (!v8)
  {
    if (v7 < 1) {
      goto LABEL_4;
    }
LABEL_6:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0xD0uLL, 0);
  }
  if (v9 - v8 < v7) {
    goto LABEL_6;
  }
LABEL_4:
  *uint64_t v5 = v6;
  v5[1] = v7;
  v5[2] = v8;
  v5[3] = v9;
  return UnsafeMutableRawBufferPointer.subscript.modify;
}

uint64_t protocol witness for MutableCollection.partition(by:) in conformance UnsafeMutableRawBufferPointer@<X0>(uint64_t (*a1)(char *)@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v6 = *v2;
  uint64_t v7 = v2[1];
  uint64_t result = (uint64_t)_sSw17withMemoryRebound2to_q0_xm_q0_SryxGq_YKXEtq_YKs5ErrorR_Ri_zRi_0_r1_lFACq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lys5UInt8VsAD_pq0_Isgyrzr_Swq0_sAD_pAFRszsAD_pRs_Ri_0_r1_lIetMgyrzo_Tpq5SiSg_Tgq5055_sSw39withContiguousMutableStorageIfAvailableyxSgxSrys5F25VGzKXEKlFAbEKXEfU_Si_TGq5SryAFGxsAD_pRi_zRi0_zlySiIsglrzo_Tf1cn_n(*v2, v7, (void *(*)(uint64_t *__return_ptr, uint64_t *))partial apply for specialized closure #1 in MutableCollection<>.partition(by:));
  if (!v3)
  {
    if (v9) {
      uint64_t result = specialized MutableCollection<>._partitionImpl(by:)(a1);
    }
    else {
      uint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(0, result, v6, v7);
    }
    *a2 = result;
  }
  return result;
}

void protocol witness for MutableCollection.swapAt(_:_:) in conformance UnsafeMutableRawBufferPointer(Swift::Int *a1, Swift::Int *a2)
{
}

uint64_t protocol witness for MutableCollection.withContiguousMutableStorageIfAvailable<A>(_:) in conformance UnsafeMutableRawBufferPointer@<X0>(uint64_t (*a1)(uint64_t *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)(a1, *v3, v3[1], a2, a3);
}

uint64_t UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)@<X0>(uint64_t (*a1)(uint64_t *)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  if (a2)
  {
    uint64_t v6 = a3 - a2;
    if (a3 - a2 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
    }
    uint64_t v7 = a2;
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v6 = 0;
  }
  return closure #1 in UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)(v7, v6, a1, a4, &v9, a5);
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UnsafeMutableRawBufferPointer(unsigned char *a1, uint64_t *a2))()
{
  *a1 = UnsafeMutableRawBufferPointer.subscript.getter(*a2, *v2, v2[1]);
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Collection.subscript.getter in conformance UnsafeMutableRawBufferPointer@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance UnsafeMutableRawBufferPointer(a1, 0xCFuLL, 0xD0uLL, a2);
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:limitedBy:) in conformance UnsafeRawBufferPointer@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = *a1;
  uint64_t v8 = *v4;
  uint64_t v9 = v4[1];
  uint64_t v10 = specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a3, *v4, v9);
  if (a2 < 1)
  {
    if (v10 <= 0 && v10 > a2) {
      goto LABEL_4;
    }
LABEL_10:
    uint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(v7, a2, v8, v9);
    char v12 = 0;
    goto LABEL_11;
  }
  if (v10 < 0 || v10 >= (unint64_t)a2) {
    goto LABEL_10;
  }
LABEL_4:
  uint64_t result = 0;
  char v12 = 1;
LABEL_11:
  *(void *)a4 = result;
  *(unsigned char *)(a4 + 8) = v12;
  return result;
}

void *UnsafeMutableRawBufferPointer.storeBytes<A>(of:toByteOffset:as:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.storeBytes with negative offset", 61, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x1CCuLL, 0);
  }
  uint64_t v6 = *(void *)(*(void *)(a6 - 8) + 64);
  BOOL v7 = __OFADD__(a2, v6);
  uint64_t v8 = a2 + v6;
  if (v7)
  {
    __break(1u);
LABEL_10:
    if (v8 < 1) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x1D0uLL, 0);
    }
LABEL_12:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.storeBytes out of bounds", 54, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x1CDuLL, 0);
  }
  if (!a4) {
    goto LABEL_10;
  }
  if (a5 - a4 < v8) {
    goto LABEL_12;
  }

  return UnsafeMutableRawPointer._legacy_se0349_storeBytes_internal<A>(of:toByteOffset:as:)(a1, a2, a6, a4, a6);
}

void *closure #1 in UnsafeMutableRawBufferPointer.copyBytes<A>(from:)(const void *a1, size_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8)
{
  int64_t v22 = a6;
  uint64_t v14 = *(void *)(a7 - 8);
  MEMORY[0x1F4188790](a1);
  size_t v16 = (char *)&v21 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *, uint64_t, uint64_t))(v14 + 16))(v16, v17, v18);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t))(a8 + 112))(a7, a8);
  if (a4)
  {
    if (a5 - a4 >= v19) {
      goto LABEL_3;
    }
LABEL_8:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.copyBytes source has too many elements", 68, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x205uLL, 0);
  }
  if (v19 >= 1) {
    goto LABEL_8;
  }
LABEL_3:
  uint64_t result = (void *)(*(uint64_t (**)(char *, uint64_t))(v14 + 8))(v16, a7);
  if (a1)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawPointer.copyMemory with negative count", 54, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x60DuLL, 0);
    }
    return memmove(v22, a1, a2);
  }
  return result;
}

void *specialized closure #1 in UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)(uint64_t a1, uint64_t a2, void *(*a3)(uint64_t *__return_ptr, uint64_t *))
{
  uint64_t v13 = a1;
  uint64_t v14 = a2;
  uint64_t result = a3(&v15, &v13);
  if (!v3)
  {
    if (a1)
    {
      if (v13) {
        BOOL v9 = a1 == v13;
      }
      else {
        BOOL v9 = 0;
      }
      if (!v9 || v14 != a2) {
        goto LABEL_32;
      }
    }
    else
    {
      if (v13) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v14 == a2;
      }
      if (!v12) {
        goto LABEL_32;
      }
    }
    return (void *)v15;
  }
  if (!a1)
  {
    if (v13) {
      BOOL v11 = 0;
    }
    else {
      BOOL v11 = v14 == a2;
    }
    if (v11) {
      return result;
    }
LABEL_32:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable: replacing the buffer is not allowed", 106, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x401uLL, 0);
  }
  if (v13) {
    BOOL v7 = a1 == v13;
  }
  else {
    BOOL v7 = 0;
  }
  if (!v7 || v14 != a2) {
    goto LABEL_32;
  }
  return result;
}

uint64_t closure #1 in UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t (*a3)(uint64_t *)@<X2>, uint64_t a4@<X4>, void *a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v20 = a2;
  uint64_t v19 = a1;
  uint64_t result = a3(&v19);
  if (v6)
  {
    if (a1)
    {
      if (v19) {
        BOOL v13 = a1 == v19;
      }
      else {
        BOOL v13 = 0;
      }
      if (!v13 || v20 != a2) {
        goto LABEL_33;
      }
      goto LABEL_27;
    }
    if (v19) {
      BOOL v17 = 0;
    }
    else {
      BOOL v17 = v20 == a2;
    }
    if (v17)
    {
LABEL_27:
      *a5 = v6;
      return result;
    }
LABEL_33:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.withContiguousMutableStorageIfAvailable: replacing the buffer is not allowed", 106, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x401uLL, 0);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a4 - 8) + 56))(a6, 0, 1, a4);
  if (a1)
  {
    if (v19) {
      BOOL v15 = a1 == v19;
    }
    else {
      BOOL v15 = 0;
    }
    if (!v15 || v20 != a2) {
      goto LABEL_33;
    }
  }
  else
  {
    if (v19) {
      BOOL v18 = 0;
    }
    else {
      BOOL v18 = v20 == a2;
    }
    if (!v18) {
      goto LABEL_33;
    }
  }
  return result;
}

unint64_t UnsafeMutableRawBufferPointer.debugDescription.getter(int64_t a1, unint64_t object)
{
  uint64_t v5 = specialized static String._createEmpty(withInitialCapacity:)(22);
  unint64_t v7 = v5;
  uint64_t countAndFlagsBits = v6;
  v236._uint64_t countAndFlagsBits = v5;
  v236._unint64_t object = (void *)v6;
  unint64_t v9 = HIBYTE(v6) & 0xF;
  uint64_t v10 = v5 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0x2000000000000000) != 0) {
    uint64_t v11 = HIBYTE(v6) & 0xF;
  }
  else {
    uint64_t v11 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (!v11 && (v5 & ~v6 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v6);
    v236._uint64_t countAndFlagsBits = 0x203A747261747328;
    v236._unint64_t object = (void *)0xE800000000000000;
    unint64_t v233 = object;
    if (a1) {
      goto LABEL_80;
    }
    goto LABEL_58;
  }
  if ((v6 & 0x2000000000000000) == 0 || v9 > 7)
  {
    swift_bridgeObjectRetain_n(0xE800000000000000, 6);
    if ((countAndFlagsBits & 0x1000000000000000) == 0)
    {
      Swift::Int v19 = v11 + 8;
      if (!__OFADD__(v11, 8)) {
        goto LABEL_13;
      }
      goto LABEL_281;
    }
    goto LABEL_279;
  }
  uint64_t v12 = 8 * HIBYTE(v6);
  uint64_t v13 = (40 << (v12 & 0x38)) | ((-255 << (v12 & 0x38)) - 1) & v5;
  char v14 = (v12 + 8) & 0x38;
  uint64_t v15 = (-255 << v14) - 1;
  uint64_t v16 = 115 << v14;
  if (v9 >= 7)
  {
    unint64_t v18 = v16 | v15 & v6;
    char v17 = 8;
    goto LABEL_32;
  }
  uint64_t v13 = v16 | v15 & v13;
  if (v9 == 6)
  {
    char v17 = 0;
    unint64_t v18 = v6;
LABEL_32:
    uint64_t v27 = (116 << v17) | ((-255 << v17) - 1) & v18;
    char v28 = v9 + 3;
LABEL_33:
    uint64_t v29 = (97 << (8 * (v28 & 7u))) | ((-255 << (8 * (v28 & 7u))) - 1) & v27;
    char v30 = v9 + 4;
LABEL_34:
    uint64_t v31 = (114 << (8 * (v30 & 7u))) | ((-255 << (8 * (v30 & 7u))) - 1) & v29;
    char v32 = v9 + 5;
LABEL_35:
    uint64_t v33 = (116 << (8 * (v32 & 7u))) | ((-255 << (8 * (v32 & 7u))) - 1) & v31;
    char v34 = v9 + 6;
LABEL_36:
    uint64_t v35 = (58 << (8 * (v34 & 7u))) | ((-255 << (8 * (v34 & 7u))) - 1) & v33;
    char v36 = v9 + 7;
    goto LABEL_37;
  }
  uint64_t v13 = (116 << ((v12 + 16) & 0x38)) | ((-255 << ((v12 + 16) & 0x38)) - 1) & v13;
  if (v9 >= 5)
  {
    char v28 = 8;
    uint64_t v27 = v6;
    goto LABEL_33;
  }
  uint64_t v13 = (97 << ((v12 + 24) & 0x38)) | ((-255 << ((v12 + 24) & 0x38)) - 1) & v13;
  if (v9 == 4)
  {
    char v30 = 8;
    uint64_t v29 = v6;
    goto LABEL_34;
  }
  uint64_t v13 = (114 << ((v12 + 32) & 0x38)) | ((-255 << ((v12 + 32) & 0x38)) - 1) & v13;
  if (v9 >= 3)
  {
    char v32 = 8;
    uint64_t v31 = v6;
    goto LABEL_35;
  }
  uint64_t v13 = (116 << ((v12 + 40) & 0x38)) | ((-255 << ((v12 + 40) & 0x38)) - 1) & v13;
  if (v9 == 2)
  {
    char v34 = 8;
    uint64_t v33 = v6;
    goto LABEL_36;
  }
  uint64_t v13 = (58 << ((v12 + 48) & 0x38)) | ((-255 << ((v12 + 48) & 0x38)) - 1) & v13;
  if (!v9)
  {
    uint64_t v13 = (32 << ((v12 + 56) & 0x38)) | ((-255 << ((v12 + 56) & 0x38)) - 1) & v13;
    uint64_t v37 = v6;
    goto LABEL_38;
  }
  char v36 = 8;
  uint64_t v35 = v6;
LABEL_37:
  uint64_t v37 = (32 << (8 * (v36 & 7u))) | ((-255 << (8 * (v36 & 7u))) - 1) & v35;
LABEL_38:
  swift_bridgeObjectRelease(v6);
  swift_bridgeObjectRelease(0xE800000000000000);
  unint64_t v38 = 0xA000000000000000;
  if (!(v13 & 0x8080808080808080 | v37 & 0x80808080808080)) {
    unint64_t v38 = 0xE000000000000000;
  }
  v236._uint64_t countAndFlagsBits = v13;
  v236._unint64_t object = (void *)((v38 & 0xFF00000000000000 | (v9 << 56) | v37 & 0xFFFFFFFFFFFFFFLL) + 0x800000000000000);
  unint64_t v233 = object;
  if (a1) {
    goto LABEL_80;
  }
LABEL_58:
  unint64_t v7 = 0xE300000000000000;
  uint64_t v10 = 7104878;
  while (1)
  {
    uint64_t countAndFlagsBits = v236._countAndFlagsBits;
    unint64_t object = (unint64_t)v236._object;
    unint64_t v68 = ((unint64_t)v236._object >> 56) & 0xF;
    if (((uint64_t)v236._object & 0x2000000000000000) != 0) {
      unint64_t v69 = ((unint64_t)v236._object >> 56) & 0xF;
    }
    else {
      unint64_t v69 = v236._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    int64_t v234 = a1;
    if (!v69 && (v236._countAndFlagsBits & ~(uint64_t)v236._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v236._object);
      v236._uint64_t countAndFlagsBits = v10;
      v236._unint64_t object = (void *)v7;
      goto LABEL_170;
    }
    uint64_t v70 = v7 & 0x2000000000000000;
    unint64_t v2 = HIBYTE(v7) & 0xF;
    if (((uint64_t)v236._object & 0x2000000000000000) != 0 && v70)
    {
      unint64_t v71 = v68 + v2;
      if (v68 + v2 <= 0xF)
      {
        if (v2)
        {
          char v88 = 0;
          unint64_t v89 = 0;
          unint64_t v90 = (unint64_t)v236._object;
          do
          {
            unint64_t v91 = v68 + v89;
            unint64_t v92 = v89 + 1;
            if (v89 >= 8) {
              unint64_t v93 = v7;
            }
            else {
              unint64_t v93 = v10;
            }
            unint64_t v94 = v93 >> (v88 & 0x38);
            char v95 = (8 * v68 + v88) & 0x38;
            uint64_t v96 = (-255 << v95) - 1;
            unint64_t v97 = (unint64_t)v94 << v95;
            unint64_t v98 = v97 | v96 & v90;
            unint64_t v99 = v97 | v96 & countAndFlagsBits;
            if (v91 < 8) {
              uint64_t countAndFlagsBits = v99;
            }
            else {
              unint64_t v90 = v98;
            }
            v88 += 8;
            unint64_t v89 = v92;
          }
          while (v2 != v92);
        }
        else
        {
          unint64_t v90 = (unint64_t)v236._object;
        }
        swift_bridgeObjectRelease((uint64_t)v236._object);
        swift_bridgeObjectRelease(v7);
        unint64_t v126 = 0xA000000000000000;
        if (!(countAndFlagsBits & 0x8080808080808080 | v90 & 0x80808080808080)) {
          unint64_t v126 = 0xE000000000000000;
        }
        v236._uint64_t countAndFlagsBits = countAndFlagsBits;
        v236._unint64_t object = (void *)(v126 & 0xFF00000000000000 | (v71 << 56) | v90 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_170;
      }
      uint64_t v70 = 1;
    }
    a1 = v10 & 0xFFFFFFFFFFFFLL;
    uint64_t v72 = v70 ? HIBYTE(v7) & 0xF : v10 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(v7, 2);
    uint64_t v232 = v72;
    if ((v7 & 0x1000000000000000) != 0) {
      break;
    }
    swift_bridgeObjectRetain_n(v7, 4);
    if ((object & 0x1000000000000000) != 0) {
      goto LABEL_270;
    }
LABEL_95:
    BOOL v73 = __OFADD__(v69, v72);
    Swift::Int v74 = v69 + v72;
    if (v73) {
      goto LABEL_272;
    }
LABEL_96:
    if ((countAndFlagsBits & ~object & 0x2000000000000000) == 0
      || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v74 >= 16)
      {
        uint64_t v75 = v236._countAndFlagsBits;
        uint64_t countAndFlagsBits = (uint64_t)v236._object;
        goto LABEL_105;
      }
      unint64_t object = (unint64_t)v236._object;
      if (((uint64_t)v236._object & 0x2000000000000000) != 0)
      {
        int v87 = 0;
        uint64_t countAndFlagsBits = (uint64_t)v236._object;
      }
      else
      {
        uint64_t countAndFlagsBits = (uint64_t)v236._object;
LABEL_128:
        int v87 = 1;
      }
LABEL_147:
      unint64_t v9 = v232;
      swift_bridgeObjectRelease_n(v7, 5);
      unint64_t v2 = v236._countAndFlagsBits;
      if (v87)
      {
LABEL_282:
        if ((object & 0x1000000000000000) != 0)
        {
          unint64_t v2 = _StringGuts._foreignConvertedToSmall()(v2, countAndFlagsBits);
          unint64_t object = v226;
        }
        else
        {
          if ((v2 & 0x1000000000000000) != 0)
          {
            uint64_t v215 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v216 = v2 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            uint64_t v215 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v2, countAndFlagsBits);
            uint64_t v216 = v229;
          }
          swift_bridgeObjectRetain(countAndFlagsBits);
          closure #1 in _StringGuts._convertedToSmall()(v215, v216, &v235);
          swift_bridgeObjectRelease(countAndFlagsBits);
          unint64_t object = *((void *)&v235 + 1);
          unint64_t v2 = v235;
        }
      }
      v104._rawBits = (v9 << 16) | 1;
      v105._rawBits = 1;
      v106._rawBits = _StringGuts.validateScalarRange(_:)(v105, v104, v10, v7);
      if (v106._rawBits < 0x10000) {
        v106._rawBits |= 3;
      }
      unint64_t v108 = specialized String.init(_:)(v106, v107, v10, v7);
      unint64_t v110 = v109;
      swift_bridgeObjectRelease(v7);
      if ((v110 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v110);
      }
      else if ((v110 & 0x1000000000000000) != 0)
      {
        unint64_t v108 = _StringGuts._foreignConvertedToSmall()(v108, v110);
        unint64_t v228 = v227;
        swift_bridgeObjectRelease(v110);
        unint64_t v110 = v228;
      }
      else
      {
        if ((v108 & 0x1000000000000000) != 0)
        {
          unint64_t v217 = (unsigned __int8 *)((v110 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v218 = v108 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          unint64_t v217 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v108, v110);
        }
        closure #1 in _StringGuts._convertedToSmall()(v217, v218, &v235);
        swift_bridgeObjectRelease(v110);
        unint64_t v110 = *((void *)&v235 + 1);
        unint64_t v108 = v235;
      }
      uint64_t v111 = HIBYTE(object) & 0xF;
      uint64_t v112 = HIBYTE(v110) & 0xF;
      uint64_t v113 = v112 + v111;
      if ((unint64_t)(v112 + v111) > 0xF) {
        goto LABEL_302;
      }
      if (v112)
      {
        char v114 = 0;
        unint64_t v115 = 0;
        do
        {
          unint64_t v116 = v111 + v115;
          unint64_t v117 = v115 + 1;
          if (v115 >= 8) {
            unint64_t v118 = v110;
          }
          else {
            unint64_t v118 = v108;
          }
          unint64_t v119 = v118 >> (v114 & 0x38);
          char v120 = (8 * v111 + v114) & 0x38;
          uint64_t v121 = (-255 << v120) - 1;
          unint64_t v122 = (unint64_t)v119 << v120;
          unint64_t v123 = v122 | v121 & object;
          unint64_t v124 = v122 | v121 & v2;
          if (v116 < 8) {
            unint64_t v2 = v124;
          }
          else {
            unint64_t object = v123;
          }
          v114 += 8;
          unint64_t v115 = v117;
        }
        while (v112 != v117);
      }
      swift_bridgeObjectRelease(countAndFlagsBits);
      swift_bridgeObjectRelease(v7);
      unint64_t v125 = 0xA000000000000000;
      if (!(v2 & 0x8080808080808080 | object & 0x80808080808080)) {
        unint64_t v125 = 0xE000000000000000;
      }
      v236._uint64_t countAndFlagsBits = v2;
      v236._unint64_t object = (void *)(v125 & 0xFF00000000000000 | (v113 << 56) | object & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_170;
    }
    uint64_t v75 = v236._countAndFlagsBits;
    uint64_t countAndFlagsBits = (uint64_t)v236._object;
    int64_t v76 = _StringGuts.nativeUnusedCapacity.getter(v236._countAndFlagsBits, (uint64_t)v236._object);
    if (v77) {
      goto LABEL_303;
    }
    if (v74 <= 15)
    {
      if ((countAndFlagsBits & 0x2000000000000000) != 0)
      {
        int v87 = 0;
        unint64_t object = countAndFlagsBits;
        goto LABEL_147;
      }
      unint64_t object = countAndFlagsBits;
      if (v76 < v72) {
        goto LABEL_128;
      }
    }
LABEL_105:
    int64_t v78 = _StringGuts.nativeUnusedCapacity.getter(v75, countAndFlagsBits);
    unint64_t v51 = (v79 & 1) == 0 && v78 >= v72;
    if ((v75 & ~countAndFlagsBits & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v51) {
        goto LABEL_123;
      }
LABEL_116:
      uint64_t v81 = _StringGuts.nativeCapacity.getter(v75, countAndFlagsBits);
      if (v82) {
        uint64_t v83 = 0;
      }
      else {
        uint64_t v83 = v81;
      }
      if (v83 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_291;
      }
      uint64_t v84 = 2 * v83;
      if (v84 > v74) {
        Swift::Int v74 = v84;
      }
      goto LABEL_122;
    }
    if ((v51 & 1) == 0) {
      goto LABEL_116;
    }
LABEL_122:
    _StringGuts.grow(_:)(v74);
LABEL_123:
    swift_bridgeObjectRelease_n(v7, 4);
    if ((v7 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v7);
      _StringGuts._foreignAppendInPlace(_:)(v10, v7, 0, v232);
    }
    else
    {
      if (v70)
      {
        swift_bridgeObjectRelease_n(v7, 2);
        *(void *)&long long v235 = v10;
        *((void *)&v235 + 1) = v7 & 0xFFFFFFFFFFFFFFLL;
        char v85 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(v7) & 0xF, (uint64_t)&v235, HIBYTE(v7) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v85, v86, (v7 & 0x4000000000000000) != 0);
        swift_bridgeObjectRelease(v7);
        goto LABEL_170;
      }
      if ((v10 & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v7);
        id v100 = (id)((v7 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v101 = v10 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        id v100 = _StringObject.sharedUTF8.getter(v10, v7);
        uint64_t v101 = v224;
        swift_bridgeObjectRelease(v7);
        if (v101 < a1) {
          goto LABEL_301;
        }
      }
      uint64_t v102 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v10 & 0xFFFFFFFFFFFFLL, (uint64_t)v100, v101);
      _StringGuts.appendInPlace(_:isASCII:)(v102, v103, v10 < 0);
    }
    swift_bridgeObjectRelease_n(v7, 2);
LABEL_170:
    Swift::String v127 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", count: ", 9uLL, 1);
    uint64_t v10 = v127._countAndFlagsBits;
    unint64_t v7 = (unint64_t)v127._object;
    uint64_t countAndFlagsBits = v236._countAndFlagsBits;
    unint64_t v2 = (unint64_t)v236._object;
    unint64_t v128 = ((unint64_t)v236._object >> 56) & 0xF;
    if (((uint64_t)v236._object & 0x2000000000000000) != 0) {
      Swift::Int v74 = ((unint64_t)v236._object >> 56) & 0xF;
    }
    else {
      Swift::Int v74 = v236._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v74 && (v236._countAndFlagsBits & ~(uint64_t)v236._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v236._object);
      Swift::String v236 = v127;
LABEL_203:
      int64_t v152 = v234;
      goto LABEL_204;
    }
    a1 = (uint64_t)v127._object & 0x2000000000000000;
    uint64_t v72 = ((unint64_t)v127._object >> 56) & 0xF;
    if (((uint64_t)v236._object & 0x2000000000000000) != 0 && a1)
    {
      unint64_t v129 = v128 + v72;
      if (v128 + v72 <= 0xF)
      {
        int64_t v152 = v234;
        if (v72)
        {
          char v185 = 0;
          unint64_t v186 = 0;
          unint64_t v187 = (unint64_t)v236._object;
          do
          {
            unint64_t v188 = v128 + v186;
            unint64_t v189 = v186 + 1;
            if (v186 >= 8) {
              unint64_t v190 = (unint64_t)v127._object;
            }
            else {
              unint64_t v190 = v127._countAndFlagsBits;
            }
            unint64_t v191 = v190 >> (v185 & 0x38);
            char v192 = (8 * v128 + v185) & 0x38;
            uint64_t v193 = (-255 << v192) - 1;
            unint64_t v194 = (unint64_t)v191 << v192;
            unint64_t v195 = v194 | v193 & v187;
            unint64_t v196 = v194 | v193 & countAndFlagsBits;
            if (v188 < 8) {
              uint64_t countAndFlagsBits = v196;
            }
            else {
              unint64_t v187 = v195;
            }
            v185 += 8;
            unint64_t v186 = v189;
          }
          while (v72 != v189);
        }
        else
        {
          unint64_t v187 = (unint64_t)v236._object;
        }
        swift_bridgeObjectRelease((uint64_t)v236._object);
        swift_bridgeObjectRelease((uint64_t)v127._object);
        unint64_t v202 = 0xA000000000000000;
        if (!(countAndFlagsBits & 0x8080808080808080 | v187 & 0x80808080808080)) {
          unint64_t v202 = 0xE000000000000000;
        }
        v236._uint64_t countAndFlagsBits = countAndFlagsBits;
        v236._unint64_t object = (void *)(v202 & 0xFF00000000000000 | (v129 << 56) | v187 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_204;
      }
      a1 = 1;
    }
    uint64_t v232 = v127._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (a1) {
      unint64_t object = ((unint64_t)v127._object >> 56) & 0xF;
    }
    else {
      unint64_t object = v127._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n((uint64_t)v127._object, 2);
    if (((uint64_t)v127._object & 0x1000000000000000) != 0) {
      goto LABEL_273;
    }
    swift_bridgeObjectRetain_n((uint64_t)v127._object, 4);
    unint64_t v9 = object;
    if ((v2 & 0x1000000000000000) != 0) {
      goto LABEL_276;
    }
LABEL_184:
    int64_t v130 = v74 + v9;
    if (!__OFADD__(v74, v9)) {
      goto LABEL_185;
    }
LABEL_278:
    __break(1u);
LABEL_279:
    Swift::Int v214 = String.UTF8View._foreignCount()();
    Swift::Int v19 = v214 + 8;
    if (__OFADD__(v214, 8))
    {
LABEL_281:
      __break(1u);
      goto LABEL_282;
    }
LABEL_13:
    unint64_t v20 = v7 & ~countAndFlagsBits;
    if ((v20 & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v21 = _StringGuts.nativeUnusedCapacity.getter(v7, countAndFlagsBits);
      if (v22) {
        goto LABEL_303;
      }
      if (v19 > 15) {
        goto LABEL_21;
      }
      if ((countAndFlagsBits & 0x2000000000000000) != 0) {
        goto LABEL_62;
      }
      if (v21 > 7)
      {
LABEL_21:
        int64_t v23 = _StringGuts.nativeUnusedCapacity.getter(v7, countAndFlagsBits);
        BOOL v26 = (v24 & 1) == 0 && v23 > 7;
        if ((v20 & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v26) {
            goto LABEL_50;
          }
        }
        else if (v26)
        {
          goto LABEL_49;
        }
        uint64_t v39 = _StringGuts.nativeCapacity.getter(v7, countAndFlagsBits);
        if (v40) {
          uint64_t v41 = 0;
        }
        else {
          uint64_t v41 = v39;
        }
        if (v41 + 0x4000000000000000 >= 0)
        {
          uint64_t v42 = 2 * v41;
          if (v42 > v19) {
            Swift::Int v19 = v42;
          }
LABEL_49:
          _StringGuts.grow(_:)(v19);
LABEL_50:
          swift_bridgeObjectRelease_n(0xE800000000000000, 6);
          long long v235 = xmmword_18162B020;
          char v43 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 8, (uint64_t)&v235, 8);
          _StringGuts.appendInPlace(_:isASCII:)(v43, v44, 1);
          swift_bridgeObjectRelease(0xE800000000000000);
          unint64_t v233 = object;
          if (!a1) {
            goto LABEL_58;
          }
          goto LABEL_80;
        }
        __break(1u);
LABEL_296:
        unint64_t v7 = _StringGuts._foreignConvertedToSmall()(v7, countAndFlagsBits);
        uint64_t v10 = v221;
        goto LABEL_63;
      }
    }
    else
    {
      if (v19 > 15) {
        goto LABEL_21;
      }
      if ((countAndFlagsBits & 0x2000000000000000) != 0)
      {
LABEL_62:
        swift_bridgeObjectRelease_n(0xE800000000000000, 5);
        uint64_t v10 = countAndFlagsBits;
        goto LABEL_63;
      }
    }
    swift_bridgeObjectRelease_n(0xE800000000000000, 5);
    if ((countAndFlagsBits & 0x1000000000000000) != 0) {
      goto LABEL_296;
    }
    if ((v7 & 0x1000000000000000) != 0)
    {
      uint64_t v45 = (unsigned __int8 *)((countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      uint64_t v45 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v7, countAndFlagsBits);
      uint64_t v10 = v222;
    }
    swift_bridgeObjectRetain(countAndFlagsBits);
    closure #1 in _StringGuts._convertedToSmall()(v45, v10, &v235);
    swift_bridgeObjectRelease(countAndFlagsBits);
    uint64_t v10 = *((void *)&v235 + 1);
    unint64_t v7 = v235;
LABEL_63:
    v46._rawBits = 1;
    v47._rawBits = 524289;
    v48._rawBits = _StringGuts.validateScalarRange(_:)(v46, v47, 0x203A747261747328uLL, 0xE800000000000000);
    if (v48._rawBits < 0x10000) {
      v48._rawBits |= 3;
    }
    unint64_t v2 = specialized String.init(_:)(v48, v49, 0x203A747261747328uLL, 0xE800000000000000);
    unint64_t v51 = v50;
    swift_bridgeObjectRelease(0xE800000000000000);
    if ((v51 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v51);
      goto LABEL_67;
    }
LABEL_291:
    if ((v51 & 0x1000000000000000) != 0)
    {
      unint64_t v2 = _StringGuts._foreignConvertedToSmall()(v2, v51);
      unint64_t v231 = v230;
      swift_bridgeObjectRelease(v51);
      unint64_t v51 = v231;
    }
    else
    {
      if ((v2 & 0x1000000000000000) != 0)
      {
        id v219 = (unsigned __int8 *)((v51 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v220 = v2 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        id v219 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v2, v51);
      }
      closure #1 in _StringGuts._convertedToSmall()(v219, v220, &v235);
      swift_bridgeObjectRelease(v51);
      unint64_t v51 = *((void *)&v235 + 1);
      unint64_t v2 = v235;
    }
LABEL_67:
    uint64_t v52 = HIBYTE(v10) & 0xF;
    uint64_t v53 = HIBYTE(v51) & 0xF;
    uint64_t v54 = v53 + v52;
    if ((unint64_t)(v53 + v52) > 0xF) {
      goto LABEL_302;
    }
    if (v53)
    {
      char v55 = 0;
      unint64_t v56 = 0;
      do
      {
        unint64_t v57 = v52 + v56;
        unint64_t v58 = v56 + 1;
        if (v56 >= 8) {
          unint64_t v59 = v51;
        }
        else {
          unint64_t v59 = v2;
        }
        unint64_t v60 = v59 >> (v55 & 0x38);
        char v61 = (8 * v52 + v55) & 0x38;
        uint64_t v62 = (-255 << v61) - 1;
        unint64_t v63 = (unint64_t)v60 << v61;
        unint64_t v64 = v63 | v62 & v10;
        unint64_t v65 = v63 | v62 & v7;
        if (v57 < 8) {
          unint64_t v7 = v65;
        }
        else {
          uint64_t v10 = v64;
        }
        v55 += 8;
        unint64_t v56 = v58;
      }
      while (v53 != v58);
    }
    swift_bridgeObjectRelease(countAndFlagsBits);
    swift_bridgeObjectRelease(0xE800000000000000);
    unint64_t v66 = 0xA000000000000000;
    if (!(v7 & 0x8080808080808080 | v10 & 0x80808080808080)) {
      unint64_t v66 = 0xE000000000000000;
    }
    v236._uint64_t countAndFlagsBits = v7;
    v236._unint64_t object = (void *)(v66 & 0xFF00000000000000 | (v54 << 56) | v10 & 0xFFFFFFFFFFFFFFLL);
    unint64_t v233 = object;
    if (!a1) {
      goto LABEL_58;
    }
LABEL_80:
    uint64_t v10 = specialized String.init<A>(describing:)(a1);
    unint64_t v7 = v67;
  }
  swift_bridgeObjectRetain_n(v7, 5);
  v204._rawBits = 1;
  v205._rawBits = (v72 << 16) | 1;
  v206._rawBits = _StringGuts.validateScalarRange(_:)(v204, v205, v10, v7);
  if (v206._rawBits < 0x10000) {
    v206._rawBits |= 3;
  }
  uint64_t v72 = specialized Collection.count.getter(v206, v207, v10, v7);
  swift_bridgeObjectRelease(v7);
  if ((object & 0x1000000000000000) == 0) {
    goto LABEL_95;
  }
LABEL_270:
  Swift::Int v208 = String.UTF8View._foreignCount()();
  Swift::Int v74 = v208 + v72;
  if (!__OFADD__(v208, v72)) {
    goto LABEL_96;
  }
LABEL_272:
  __break(1u);
LABEL_273:
  swift_bridgeObjectRetain_n(v7, 5);
  v209._rawBits = 1;
  v210._rawBits = (object << 16) | 1;
  v211._rawBits = _StringGuts.validateScalarRange(_:)(v209, v210, v10, v7);
  if (v211._rawBits < 0x10000) {
    v211._rawBits |= 3;
  }
  unint64_t v9 = specialized Collection.count.getter(v211, v212, v10, v7);
  swift_bridgeObjectRelease(v7);
  if ((v2 & 0x1000000000000000) == 0) {
    goto LABEL_184;
  }
LABEL_276:
  Swift::Int v213 = String.UTF8View._foreignCount()();
  int64_t v130 = v213 + v9;
  if (__OFADD__(v213, v9)) {
    goto LABEL_278;
  }
LABEL_185:
  if ((countAndFlagsBits & ~v2 & 0x2000000000000000) != 0
    && swift_isUniquelyReferenced_nonNull_native(v2 & 0xFFFFFFFFFFFFFFFLL))
  {
    unint64_t v131 = (unint64_t)v236._object;
    int64_t v132 = _StringGuts.nativeUnusedCapacity.getter(v236._countAndFlagsBits, (uint64_t)v236._object);
    if (v133)
    {
LABEL_303:
      unint64_t v225 = 258;
      goto LABEL_304;
    }
    if (v130 <= 15 && ((v131 & 0x2000000000000000) != 0 || v132 < (uint64_t)v9))
    {
LABEL_197:
      swift_bridgeObjectRelease_n(v7, 5);
      unint64_t v136 = v236._countAndFlagsBits;
      swift_bridgeObjectRetain(v131);
      unint64_t v137 = _StringGuts._convertedToSmall()(v136, v131);
      unint64_t v139 = v138;
      swift_bridgeObjectRelease(v131);
      v140._rawBits = (object << 16) | 1;
      v141._rawBits = 1;
      v142._rawBits = _StringGuts.validateScalarRange(_:)(v141, v140, v10, v7);
      if (v142._rawBits < 0x10000) {
        v142._rawBits |= 3;
      }
      unint64_t v144 = specialized String.init(_:)(v142, v143, v10, v7);
      unint64_t v146 = v145;
      swift_bridgeObjectRelease(v7);
      unint64_t v147 = _StringGuts._convertedToSmall()(v144, v146);
      unint64_t v149 = v148;
      swift_bridgeObjectRelease(v146);
      unint64_t v150 = specialized _SmallString.init(_:appending:)(v137, v139, v147, v149);
      int64_t v152 = v234;
      if ((v153 & 1) == 0)
      {
        uint64_t v154 = v150;
        unint64_t v155 = v151;
        swift_bridgeObjectRelease(v131);
        swift_bridgeObjectRelease(v7);
        v236._uint64_t countAndFlagsBits = v154;
        v236._unint64_t object = v155;
        goto LABEL_204;
      }
LABEL_302:
      unint64_t v225 = 266;
LABEL_304:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v225, 0);
    }
  }
  else if (v130 <= 15)
  {
    unint64_t v131 = (unint64_t)v236._object;
    goto LABEL_197;
  }
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v130, v9);
  swift_bridgeObjectRelease_n(v7, 4);
  if ((v7 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v7);
    _StringGuts._foreignAppendInPlace(_:)(v10, v7, 0, object);
    swift_bridgeObjectRelease_n(v7, 2);
    goto LABEL_203;
  }
  if (a1)
  {
    swift_bridgeObjectRelease_n(v7, 2);
    *(void *)&long long v235 = v10;
    *((void *)&v235 + 1) = v7 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v134 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v72, (uint64_t)&v235, v72);
    _StringGuts.appendInPlace(_:isASCII:)(v134, v135, (v7 & 0x4000000000000000) != 0);
    swift_bridgeObjectRelease(v7);
    goto LABEL_203;
  }
  if ((v10 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v7);
    id v197 = (id)((v7 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v198 = v232;
    uint64_t v199 = v232;
    int64_t v152 = v234;
  }
  else
  {
    id v197 = _StringObject.sharedUTF8.getter(v10, v7);
    uint64_t v199 = v223;
    swift_bridgeObjectRelease(v7);
    if (v199 < v232) {
LABEL_301:
    }
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
    int64_t v152 = v234;
    uint64_t v198 = v232;
  }
  unint64_t v200 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v198, (uint64_t)v197, v199);
  _StringGuts.appendInPlace(_:isASCII:)(v200, v201, v10 < 0);
  swift_bridgeObjectRelease_n(v7, 2);
LABEL_204:
  if (v152) {
    uint64_t v156 = v233 - v152;
  }
  else {
    uint64_t v156 = 0;
  }
  unint64_t v158 = _int64ToString(_:radix:uppercase:)(v156, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
  unint64_t v159 = v157;
  uint64_t v160 = v236._countAndFlagsBits;
  unint64_t v161 = ((unint64_t)v236._object >> 56) & 0xF;
  unint64_t v162 = v236._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (((uint64_t)v236._object & 0x2000000000000000) != 0) {
    unint64_t v162 = ((unint64_t)v236._object >> 56) & 0xF;
  }
  if (v162 || (v236._countAndFlagsBits & ~(uint64_t)v236._object & 0x2000000000000000) != 0)
  {
    if (((uint64_t)v236._object & 0x2000000000000000) == 0)
    {
      if ((v157 & 0x2000000000000000) != 0)
      {
        uint64_t v163 = HIBYTE(v157) & 0xF;
        goto LABEL_216;
      }
LABEL_215:
      uint64_t v163 = v158 & 0xFFFFFFFFFFFFLL;
      goto LABEL_216;
    }
    if ((v157 & 0x2000000000000000) == 0) {
      goto LABEL_215;
    }
    uint64_t v163 = HIBYTE(v157) & 0xF;
    unint64_t v172 = v161 + v163;
    if (v161 + v163 > 0xF)
    {
LABEL_216:
      _StringGuts.append(_:)(v158, v157, 0, v163);
      swift_bridgeObjectRelease(v159);
      unint64_t v158 = v236._countAndFlagsBits;
      unint64_t v159 = (unint64_t)v236._object;
    }
    else
    {
      if (v163)
      {
        char v173 = 0;
        unint64_t v174 = 0;
        unint64_t v175 = (unint64_t)v236._object;
        do
        {
          unint64_t v176 = v161 + v174;
          unint64_t v177 = v174 + 1;
          if (v174 >= 8) {
            unint64_t v178 = v157;
          }
          else {
            unint64_t v178 = v158;
          }
          unint64_t v179 = v178 >> (v173 & 0x38);
          char v180 = (8 * v161 + v173) & 0x38;
          uint64_t v181 = (-255 << v180) - 1;
          unint64_t v182 = (unint64_t)v179 << v180;
          unint64_t v183 = v182 | v181 & v175;
          unint64_t v184 = v182 | v181 & v160;
          if (v176 < 8) {
            uint64_t v160 = v184;
          }
          else {
            unint64_t v175 = v183;
          }
          v173 += 8;
          unint64_t v174 = v177;
        }
        while (v163 != v177);
      }
      else
      {
        unint64_t v175 = (unint64_t)v236._object;
      }
      swift_bridgeObjectRelease((uint64_t)v236._object);
      swift_bridgeObjectRelease(v159);
      unint64_t v203 = 0xA000000000000000;
      if (!(v160 & 0x8080808080808080 | v175 & 0x80808080808080)) {
        unint64_t v203 = 0xE000000000000000;
      }
      unint64_t v159 = v203 & 0xFF00000000000000 | (v172 << 56) | v175 & 0xFFFFFFFFFFFFFFLL;
      v236._uint64_t countAndFlagsBits = v160;
      v236._unint64_t object = (void *)v159;
      unint64_t v158 = v160;
    }
  }
  else
  {
    swift_bridgeObjectRelease((uint64_t)v236._object);
    v236._uint64_t countAndFlagsBits = v158;
    v236._unint64_t object = (void *)v159;
  }
  uint64_t v164 = HIBYTE(v159) & 0xF;
  if ((v159 & 0x2000000000000000) == 0) {
    uint64_t v164 = v158 & 0xFFFFFFFFFFFFLL;
  }
  if (v164 || (v158 & ~v159 & 0x2000000000000000) != 0)
  {
    if ((v159 & 0x2000000000000000) == 0
      || (unint64_t v165 = specialized _SmallString.init(_:appending:)(v158, v159, 0x29uLL, 0xE100000000000000), (v167 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000);
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      unint64_t v168 = v236._countAndFlagsBits;
      Swift::Int v169 = v236._object;
    }
    else
    {
      unint64_t v168 = v165;
      Swift::Int v169 = v166;
      swift_bridgeObjectRelease(v159);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v159);
    Swift::Int v169 = (void *)0xE100000000000000;
    unint64_t v168 = 41;
  }
  unint64_t v170 = specialized static String.+ infix(_:_:)(0xD00000000000001DLL, 0x800000018162B120 | 0x8000000000000000, v168, (unint64_t)v169);
  swift_bridgeObjectRelease(0x800000018162B120 | 0x8000000000000000);
  swift_bridgeObjectRelease((uint64_t)v169);
  return v170;
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance UnsafeMutableRawBufferPointer()
{
  return UnsafeMutableRawBufferPointer.debugDescription.getter(*(void *)v0, *(void *)(v0 + 8));
}

uint64_t (*UnsafeMutableRawBufferPointer.subscript.modify(void *a1))()
{
  *a1 = 0;
  a1[1] = 0;
  return EnumeratedSequence._base.modify;
}

{
  *a1 = 0;
  a1[1] = 0;
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeRawBufferPointer._end.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t UnsafeRawBufferPointer.Iterator._position.setter(uint64_t result)
{
  void *v1 = result;
  return result;
}

uint64_t (*UnsafeRawBufferPointer.Iterator._position.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UnsafeRawBufferPointer.Iterator._end.getter(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t UnsafeRawBufferPointer.Iterator._end.setter(uint64_t result)
{
  *(void *)(v1 + 8) = result;
  return result;
}

uint64_t (*UnsafeRawBufferPointer.Iterator._end.modify())()
{
  return EnumeratedSequence._base.modify;
}

Swift::UInt8_optional __swiftcall UnsafeRawBufferPointer.Iterator.next()()
{
  unint64_t v2 = *v0;
  uint64_t v1 = v0[1];
  if (!*v0)
  {
    if (v1) {
LABEL_13:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x4BAuLL, 0);
LABEL_10:
    __int16 v5 = 0;
    __int16 v4 = 1;
    return (Swift::UInt8_optional)(v5 | (v4 << 8));
  }
  if (v1) {
    BOOL v3 = v2 == v1;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3) {
    goto LABEL_10;
  }
  if (!v1) {
    goto LABEL_13;
  }
  if (v2 >= v1) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x4BAuLL, 0);
  }
  __int16 v4 = 0;
  __int16 v5 = *v2;
  uint64_t *v0 = v2 + 1;
  return (Swift::UInt8_optional)(v5 | (v4 << 8));
}

Swift::UInt8_optional protocol witness for IteratorProtocol.next() in conformance UnsafeRawBufferPointer.Iterator@<W0>(Swift::UInt8 *a1@<X8>)
{
  Swift::UInt8_optional result = UnsafeRawBufferPointer.Iterator.next()();
  *a1 = result.value;
  a1[1] = result.is_nil;
  return result;
}

__objc2_class **protocol witness for Sequence._copyToContiguousArray() in conformance UnsafeRawBufferPointer.Iterator()
{
  return specialized _copySequenceToContiguousArray<A>(_:)(*v0, v0[1]);
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeRawBufferPointer.Iterator(char **a1, uint64_t a2, uint64_t a3)
{
  return specialized Sequence._copySequenceContents(initializing:)(a1, a2, a3, *v3, v3[1]);
}

uint64_t protocol witness for Sequence.underestimatedCount.getter in conformance UnsafeRawBufferPointer()
{
  if (*v0) {
    return v0[1] - *v0;
  }
  else {
    return 0;
  }
}

uint64_t protocol witness for Sequence._copyContents(initializing:) in conformance UnsafeMutableRawBufferPointer(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, void, void))
{
  *a1 = a6(a2, a3, *v6, v6[1]);
  a1[1] = v8;
  return v9;
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UnsafeRawBufferPointer@<X0>(uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return UnsafeRawBufferPointer.withContiguousStorageIfAvailable<A>(_:)(a1, *v3, v3[1], a2, a3);
}

uint64_t UnsafeRawBufferPointer.withContiguousStorageIfAvailable<A>(_:)@<X0>(uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  if (a2)
  {
    uint64_t v9 = a3 - a2;
    if (a3 - a2 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    uint64_t v10 = a2;
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v9 = 0;
  }
  uint64_t result = a1(v10, v9);
  if (!v5) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(a4 - 8) + 56))(a5, 0, 1, a4);
  }
  return result;
}

uint64_t UnsafeRawBufferPointer.startIndex.getter()
{
  return 0;
}

uint64_t UnsafeRawBufferPointer.endIndex.getter(uint64_t a1, uint64_t a2)
{
  if (a1) {
    return a2 - a1;
  }
  else {
    return 0;
  }
}

uint64_t UnsafeRawBufferPointer.indices.getter()
{
  return 0;
}

uint64_t UnsafeRawBufferPointer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return UnsafeMutableRawBufferPointer.subscript.getter(a1, a2, a3, 0x505uLL, 0x506uLL);
}

uint64_t UnsafeMutableRawBufferPointer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, a4, 0);
  }
  if (!a2 || a3 - a2 <= a1) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, a5, 0);
  }
  return *(unsigned __int8 *)(a2 + a1);
}

uint64_t UnsafeRawBufferPointer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return UnsafeMutableRawBufferPointer.subscript.getter(a1, a2, a3, a4, 0x513uLL, 0x514uLL);
}

uint64_t UnsafeMutableRawBufferPointer.subscript.getter(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  if (result < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, a5, 0);
  }
  if (a3)
  {
    if (a4 - a3 >= a2) {
      return result;
    }
LABEL_6:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, a6, 0);
  }
  if (a2 >= 1) {
    goto LABEL_6;
  }
  return result;
}

void protocol witness for Collection.endIndex.getter in conformance UnsafeRawBufferPointer(void *a1@<X8>)
{
  uint64_t v2 = *v1;
  if (*v1) {
    uint64_t v2 = v1[1] - v2;
  }
  *a1 = v2;
}

uint64_t (*protocol witness for Collection.subscript.read in conformance UnsafeRawBufferPointer(unsigned char *a1, uint64_t *a2))()
{
  *a1 = UnsafeRawBufferPointer.subscript.getter(*a2, *v2, v2[1]);
  return EnumeratedSequence._base.modify;
}

void *protocol witness for Collection.subscript.getter in conformance UnsafeRawBufferPointer@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  return protocol witness for Collection.subscript.getter in conformance UnsafeMutableRawBufferPointer(a1, 0x513uLL, 0x514uLL, a2);
}

void *protocol witness for Collection.subscript.getter in conformance UnsafeMutableRawBufferPointer@<X0>(void *result@<X0>, unint64_t a2@<X3>, unint64_t a3@<X4>, void *a4@<X8>)
{
  if ((*result & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, a2, 0);
  }
  uint64_t v5 = result[1];
  uint64_t v6 = *v4;
  uint64_t v7 = v4[1];
  if (!*v4)
  {
    if (v5 < 1) {
      goto LABEL_4;
    }
LABEL_6:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, a3, 0);
  }
  if (v7 - v6 < v5) {
    goto LABEL_6;
  }
LABEL_4:
  *a4 = *result;
  a4[1] = v5;
  a4[2] = v6;
  a4[3] = v7;
  return result;
}

uint64_t protocol witness for Collection.indices.getter in conformance UnsafeRawBufferPointer@<X0>(void *a1@<X8>)
{
  uint64_t result = UnsafeRawBufferPointer.indices.getter();
  *a1 = 0;
  a1[1] = v3;
  return result;
}

BOOL protocol witness for Collection.isEmpty.getter in conformance UnsafeRawBufferPointer()
{
  return !*v0 || v0[1] == *v0;
}

uint64_t protocol witness for Collection.index(after:) in conformance UnsafeRawBufferPointer@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = specialized RandomAccessCollection<>.index(after:)(*a1, *v2, v2[1]);
  *a2 = result;
  return result;
}

uint64_t *protocol witness for Collection.formIndex(after:) in conformance UnsafeMutableRawBufferPointer(uint64_t *result)
{
  if (!*v1 || (uint64_t v2 = *result, *result < 0) || v2 >= v1[1] - *v1) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
  }
  *uint64_t result = v2 + 1;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(before:) in conformance UnsafeRawBufferPointer@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = specialized RandomAccessCollection<>.index(before:)(*a1, *v2, v2[1]);
  *a2 = result;
  return result;
}

uint64_t *protocol witness for BidirectionalCollection.formIndex(before:) in conformance UnsafeMutableRawBufferPointer(uint64_t *result)
{
  uint64_t v2 = *result - 1;
  if (__OFSUB__(*result, 1))
  {
    __break(1u);
  }
  else
  {
    if (!*v1 || v2 < 0 || v2 >= v1[1] - *v1) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
    }
    *uint64_t result = v2;
  }
  return result;
}

uint64_t protocol witness for BidirectionalCollection.index(_:offsetBy:) in conformance UnsafeRawBufferPointer@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = specialized RandomAccessCollection<>.index(_:offsetBy:)(*a1, a2, *v3, v3[1]);
  *a3 = result;
  return result;
}

uint64_t protocol witness for BidirectionalCollection.distance(from:to:) in conformance UnsafeRawBufferPointer(uint64_t *a1, uint64_t *a2)
{
  return specialized RandomAccessCollection<>.distance(from:to:)(*a1, *a2, *v2, v2[1]);
}

Swift::Void __swiftcall UnsafeRawBufferPointer.deallocate()()
{
  if (v0) {
    swift_slowDealloc(v0);
  }
}

uint64_t UnsafeRawBufferPointer.init(rebasing:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    uint64_t result = a3 + a1;
  }
  else {
    uint64_t result = 0;
  }
  uint64_t v5 = a2 - a1;
  if (v5 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  }
  if (v5)
  {
    if (!result) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer has a nil start and nonzero count", 56, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x486uLL, 0);
    }
  }
  return result;
}

unint64_t UnsafeRawBufferPointer.debugDescription.getter(uint64_t a1, unint64_t object)
{
  uint64_t v5 = specialized static String._createEmpty(withInitialCapacity:)(22);
  unint64_t v7 = v5;
  uint64_t countAndFlagsBits = v6;
  v236._uint64_t countAndFlagsBits = v5;
  v236._unint64_t object = (void *)v6;
  unint64_t v9 = HIBYTE(v6) & 0xF;
  uint64_t v10 = v5 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0x2000000000000000) != 0) {
    uint64_t v11 = HIBYTE(v6) & 0xF;
  }
  else {
    uint64_t v11 = v5 & 0xFFFFFFFFFFFFLL;
  }
  if (!v11 && (v5 & ~v6 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v6);
    v236._uint64_t countAndFlagsBits = 0x203A747261747328;
    v236._unint64_t object = (void *)0xE800000000000000;
    unint64_t v233 = object;
    if (a1) {
      goto LABEL_80;
    }
    goto LABEL_58;
  }
  if ((v6 & 0x2000000000000000) == 0 || v9 > 7)
  {
    swift_bridgeObjectRetain_n(0xE800000000000000, 6);
    if ((countAndFlagsBits & 0x1000000000000000) == 0)
    {
      Swift::Int v19 = v11 + 8;
      if (!__OFADD__(v11, 8)) {
        goto LABEL_13;
      }
      goto LABEL_281;
    }
    goto LABEL_279;
  }
  uint64_t v12 = 8 * HIBYTE(v6);
  uint64_t v13 = (40 << (v12 & 0x38)) | ((-255 << (v12 & 0x38)) - 1) & v5;
  char v14 = (v12 + 8) & 0x38;
  uint64_t v15 = (-255 << v14) - 1;
  uint64_t v16 = 115 << v14;
  if (v9 >= 7)
  {
    unint64_t v18 = v16 | v15 & v6;
    char v17 = 8;
    goto LABEL_32;
  }
  uint64_t v13 = v16 | v15 & v13;
  if (v9 == 6)
  {
    char v17 = 0;
    unint64_t v18 = v6;
LABEL_32:
    uint64_t v27 = (116 << v17) | ((-255 << v17) - 1) & v18;
    char v28 = v9 + 3;
LABEL_33:
    uint64_t v29 = (97 << (8 * (v28 & 7u))) | ((-255 << (8 * (v28 & 7u))) - 1) & v27;
    char v30 = v9 + 4;
LABEL_34:
    uint64_t v31 = (114 << (8 * (v30 & 7u))) | ((-255 << (8 * (v30 & 7u))) - 1) & v29;
    char v32 = v9 + 5;
LABEL_35:
    uint64_t v33 = (116 << (8 * (v32 & 7u))) | ((-255 << (8 * (v32 & 7u))) - 1) & v31;
    char v34 = v9 + 6;
LABEL_36:
    uint64_t v35 = (58 << (8 * (v34 & 7u))) | ((-255 << (8 * (v34 & 7u))) - 1) & v33;
    char v36 = v9 + 7;
    goto LABEL_37;
  }
  uint64_t v13 = (116 << ((v12 + 16) & 0x38)) | ((-255 << ((v12 + 16) & 0x38)) - 1) & v13;
  if (v9 >= 5)
  {
    char v28 = 8;
    uint64_t v27 = v6;
    goto LABEL_33;
  }
  uint64_t v13 = (97 << ((v12 + 24) & 0x38)) | ((-255 << ((v12 + 24) & 0x38)) - 1) & v13;
  if (v9 == 4)
  {
    char v30 = 8;
    uint64_t v29 = v6;
    goto LABEL_34;
  }
  uint64_t v13 = (114 << ((v12 + 32) & 0x38)) | ((-255 << ((v12 + 32) & 0x38)) - 1) & v13;
  if (v9 >= 3)
  {
    char v32 = 8;
    uint64_t v31 = v6;
    goto LABEL_35;
  }
  uint64_t v13 = (116 << ((v12 + 40) & 0x38)) | ((-255 << ((v12 + 40) & 0x38)) - 1) & v13;
  if (v9 == 2)
  {
    char v34 = 8;
    uint64_t v33 = v6;
    goto LABEL_36;
  }
  uint64_t v13 = (58 << ((v12 + 48) & 0x38)) | ((-255 << ((v12 + 48) & 0x38)) - 1) & v13;
  if (!v9)
  {
    uint64_t v13 = (32 << ((v12 + 56) & 0x38)) | ((-255 << ((v12 + 56) & 0x38)) - 1) & v13;
    uint64_t v37 = v6;
    goto LABEL_38;
  }
  char v36 = 8;
  uint64_t v35 = v6;
LABEL_37:
  uint64_t v37 = (32 << (8 * (v36 & 7u))) | ((-255 << (8 * (v36 & 7u))) - 1) & v35;
LABEL_38:
  swift_bridgeObjectRelease(v6);
  swift_bridgeObjectRelease(0xE800000000000000);
  unint64_t v38 = 0xA000000000000000;
  if (!(v13 & 0x8080808080808080 | v37 & 0x80808080808080)) {
    unint64_t v38 = 0xE000000000000000;
  }
  v236._uint64_t countAndFlagsBits = v13;
  v236._unint64_t object = (void *)((v38 & 0xFF00000000000000 | (v9 << 56) | v37 & 0xFFFFFFFFFFFFFFLL) + 0x800000000000000);
  unint64_t v233 = object;
  if (a1) {
    goto LABEL_80;
  }
LABEL_58:
  unint64_t v7 = 0xE300000000000000;
  uint64_t v10 = 7104878;
  while (1)
  {
    uint64_t countAndFlagsBits = v236._countAndFlagsBits;
    unint64_t object = (unint64_t)v236._object;
    unint64_t v68 = ((unint64_t)v236._object >> 56) & 0xF;
    if (((uint64_t)v236._object & 0x2000000000000000) != 0) {
      unint64_t v69 = ((unint64_t)v236._object >> 56) & 0xF;
    }
    else {
      unint64_t v69 = v236._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v234 = a1;
    if (!v69 && (v236._countAndFlagsBits & ~(uint64_t)v236._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v236._object);
      v236._uint64_t countAndFlagsBits = v10;
      v236._unint64_t object = (void *)v7;
      goto LABEL_170;
    }
    uint64_t v70 = v7 & 0x2000000000000000;
    unint64_t v2 = HIBYTE(v7) & 0xF;
    if (((uint64_t)v236._object & 0x2000000000000000) != 0 && v70)
    {
      unint64_t v71 = v68 + v2;
      if (v68 + v2 <= 0xF)
      {
        if (v2)
        {
          char v88 = 0;
          unint64_t v89 = 0;
          unint64_t v90 = (unint64_t)v236._object;
          do
          {
            unint64_t v91 = v68 + v89;
            unint64_t v92 = v89 + 1;
            if (v89 >= 8) {
              unint64_t v93 = v7;
            }
            else {
              unint64_t v93 = v10;
            }
            unint64_t v94 = v93 >> (v88 & 0x38);
            char v95 = (8 * v68 + v88) & 0x38;
            uint64_t v96 = (-255 << v95) - 1;
            unint64_t v97 = (unint64_t)v94 << v95;
            unint64_t v98 = v97 | v96 & v90;
            unint64_t v99 = v97 | v96 & countAndFlagsBits;
            if (v91 < 8) {
              uint64_t countAndFlagsBits = v99;
            }
            else {
              unint64_t v90 = v98;
            }
            v88 += 8;
            unint64_t v89 = v92;
          }
          while (v2 != v92);
        }
        else
        {
          unint64_t v90 = (unint64_t)v236._object;
        }
        swift_bridgeObjectRelease((uint64_t)v236._object);
        swift_bridgeObjectRelease(v7);
        unint64_t v126 = 0xA000000000000000;
        if (!(countAndFlagsBits & 0x8080808080808080 | v90 & 0x80808080808080)) {
          unint64_t v126 = 0xE000000000000000;
        }
        v236._uint64_t countAndFlagsBits = countAndFlagsBits;
        v236._unint64_t object = (void *)(v126 & 0xFF00000000000000 | (v71 << 56) | v90 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_170;
      }
      uint64_t v70 = 1;
    }
    a1 = v10 & 0xFFFFFFFFFFFFLL;
    uint64_t v72 = v70 ? HIBYTE(v7) & 0xF : v10 & 0xFFFFFFFFFFFFLL;
    swift_bridgeObjectRetain_n(v7, 2);
    uint64_t v232 = v72;
    if ((v7 & 0x1000000000000000) != 0) {
      break;
    }
    swift_bridgeObjectRetain_n(v7, 4);
    if ((object & 0x1000000000000000) != 0) {
      goto LABEL_270;
    }
LABEL_95:
    BOOL v73 = __OFADD__(v69, v72);
    Swift::Int v74 = v69 + v72;
    if (v73) {
      goto LABEL_272;
    }
LABEL_96:
    if ((countAndFlagsBits & ~object & 0x2000000000000000) == 0
      || !swift_isUniquelyReferenced_nonNull_native(object & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v74 >= 16)
      {
        uint64_t v75 = v236._countAndFlagsBits;
        uint64_t countAndFlagsBits = (uint64_t)v236._object;
        goto LABEL_105;
      }
      unint64_t object = (unint64_t)v236._object;
      if (((uint64_t)v236._object & 0x2000000000000000) != 0)
      {
        int v87 = 0;
        uint64_t countAndFlagsBits = (uint64_t)v236._object;
      }
      else
      {
        uint64_t countAndFlagsBits = (uint64_t)v236._object;
LABEL_128:
        int v87 = 1;
      }
LABEL_147:
      unint64_t v9 = v232;
      swift_bridgeObjectRelease_n(v7, 5);
      unint64_t v2 = v236._countAndFlagsBits;
      if (v87)
      {
LABEL_282:
        if ((object & 0x1000000000000000) != 0)
        {
          unint64_t v2 = _StringGuts._foreignConvertedToSmall()(v2, countAndFlagsBits);
          unint64_t object = v226;
        }
        else
        {
          if ((v2 & 0x1000000000000000) != 0)
          {
            uint64_t v215 = (unsigned __int8 *)((object & 0xFFFFFFFFFFFFFFFLL) + 32);
            uint64_t v216 = v2 & 0xFFFFFFFFFFFFLL;
          }
          else
          {
            uint64_t v215 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v2, countAndFlagsBits);
            uint64_t v216 = v229;
          }
          swift_bridgeObjectRetain(countAndFlagsBits);
          closure #1 in _StringGuts._convertedToSmall()(v215, v216, &v235);
          swift_bridgeObjectRelease(countAndFlagsBits);
          unint64_t object = *((void *)&v235 + 1);
          unint64_t v2 = v235;
        }
      }
      v104._rawBits = (v9 << 16) | 1;
      v105._rawBits = 1;
      v106._rawBits = _StringGuts.validateScalarRange(_:)(v105, v104, v10, v7);
      if (v106._rawBits < 0x10000) {
        v106._rawBits |= 3;
      }
      unint64_t v108 = specialized String.init(_:)(v106, v107, v10, v7);
      unint64_t v110 = v109;
      swift_bridgeObjectRelease(v7);
      if ((v110 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v110);
      }
      else if ((v110 & 0x1000000000000000) != 0)
      {
        unint64_t v108 = _StringGuts._foreignConvertedToSmall()(v108, v110);
        unint64_t v228 = v227;
        swift_bridgeObjectRelease(v110);
        unint64_t v110 = v228;
      }
      else
      {
        if ((v108 & 0x1000000000000000) != 0)
        {
          unint64_t v217 = (unsigned __int8 *)((v110 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v218 = v108 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          unint64_t v217 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v108, v110);
        }
        closure #1 in _StringGuts._convertedToSmall()(v217, v218, &v235);
        swift_bridgeObjectRelease(v110);
        unint64_t v110 = *((void *)&v235 + 1);
        unint64_t v108 = v235;
      }
      uint64_t v111 = HIBYTE(object) & 0xF;
      uint64_t v112 = HIBYTE(v110) & 0xF;
      uint64_t v113 = v112 + v111;
      if ((unint64_t)(v112 + v111) > 0xF) {
        goto LABEL_302;
      }
      if (v112)
      {
        char v114 = 0;
        unint64_t v115 = 0;
        do
        {
          unint64_t v116 = v111 + v115;
          unint64_t v117 = v115 + 1;
          if (v115 >= 8) {
            unint64_t v118 = v110;
          }
          else {
            unint64_t v118 = v108;
          }
          unint64_t v119 = v118 >> (v114 & 0x38);
          char v120 = (8 * v111 + v114) & 0x38;
          uint64_t v121 = (-255 << v120) - 1;
          unint64_t v122 = (unint64_t)v119 << v120;
          unint64_t v123 = v122 | v121 & object;
          unint64_t v124 = v122 | v121 & v2;
          if (v116 < 8) {
            unint64_t v2 = v124;
          }
          else {
            unint64_t object = v123;
          }
          v114 += 8;
          unint64_t v115 = v117;
        }
        while (v112 != v117);
      }
      swift_bridgeObjectRelease(countAndFlagsBits);
      swift_bridgeObjectRelease(v7);
      unint64_t v125 = 0xA000000000000000;
      if (!(v2 & 0x8080808080808080 | object & 0x80808080808080)) {
        unint64_t v125 = 0xE000000000000000;
      }
      v236._uint64_t countAndFlagsBits = v2;
      v236._unint64_t object = (void *)(v125 & 0xFF00000000000000 | (v113 << 56) | object & 0xFFFFFFFFFFFFFFLL);
      goto LABEL_170;
    }
    uint64_t v75 = v236._countAndFlagsBits;
    uint64_t countAndFlagsBits = (uint64_t)v236._object;
    int64_t v76 = _StringGuts.nativeUnusedCapacity.getter(v236._countAndFlagsBits, (uint64_t)v236._object);
    if (v77) {
      goto LABEL_303;
    }
    if (v74 <= 15)
    {
      if ((countAndFlagsBits & 0x2000000000000000) != 0)
      {
        int v87 = 0;
        unint64_t object = countAndFlagsBits;
        goto LABEL_147;
      }
      unint64_t object = countAndFlagsBits;
      if (v76 < v72) {
        goto LABEL_128;
      }
    }
LABEL_105:
    int64_t v78 = _StringGuts.nativeUnusedCapacity.getter(v75, countAndFlagsBits);
    unint64_t v51 = (v79 & 1) == 0 && v78 >= v72;
    if ((v75 & ~countAndFlagsBits & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
    {
      if (v51) {
        goto LABEL_123;
      }
LABEL_116:
      uint64_t v81 = _StringGuts.nativeCapacity.getter(v75, countAndFlagsBits);
      if (v82) {
        uint64_t v83 = 0;
      }
      else {
        uint64_t v83 = v81;
      }
      if (v83 + 0x4000000000000000 < 0)
      {
        __break(1u);
        goto LABEL_291;
      }
      uint64_t v84 = 2 * v83;
      if (v84 > v74) {
        Swift::Int v74 = v84;
      }
      goto LABEL_122;
    }
    if ((v51 & 1) == 0) {
      goto LABEL_116;
    }
LABEL_122:
    _StringGuts.grow(_:)(v74);
LABEL_123:
    swift_bridgeObjectRelease_n(v7, 4);
    if ((v7 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v7);
      _StringGuts._foreignAppendInPlace(_:)(v10, v7, 0, v232);
    }
    else
    {
      if (v70)
      {
        swift_bridgeObjectRelease_n(v7, 2);
        *(void *)&long long v235 = v10;
        *((void *)&v235 + 1) = v7 & 0xFFFFFFFFFFFFFFLL;
        char v85 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, HIBYTE(v7) & 0xF, (uint64_t)&v235, HIBYTE(v7) & 0xF);
        _StringGuts.appendInPlace(_:isASCII:)(v85, v86, (v7 & 0x4000000000000000) != 0);
        swift_bridgeObjectRelease(v7);
        goto LABEL_170;
      }
      if ((v10 & 0x1000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v7);
        id v100 = (id)((v7 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v101 = v10 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        id v100 = _StringObject.sharedUTF8.getter(v10, v7);
        uint64_t v101 = v224;
        swift_bridgeObjectRelease(v7);
        if (v101 < a1) {
          goto LABEL_301;
        }
      }
      uint64_t v102 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v10 & 0xFFFFFFFFFFFFLL, (uint64_t)v100, v101);
      _StringGuts.appendInPlace(_:isASCII:)(v102, v103, v10 < 0);
    }
    swift_bridgeObjectRelease_n(v7, 2);
LABEL_170:
    Swift::String v127 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(", count: ", 9uLL, 1);
    uint64_t v10 = v127._countAndFlagsBits;
    unint64_t v7 = (unint64_t)v127._object;
    uint64_t countAndFlagsBits = v236._countAndFlagsBits;
    unint64_t v2 = (unint64_t)v236._object;
    unint64_t v128 = ((unint64_t)v236._object >> 56) & 0xF;
    if (((uint64_t)v236._object & 0x2000000000000000) != 0) {
      Swift::Int v74 = ((unint64_t)v236._object >> 56) & 0xF;
    }
    else {
      Swift::Int v74 = v236._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    if (!v74 && (v236._countAndFlagsBits & ~(uint64_t)v236._object & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease((uint64_t)v236._object);
      Swift::String v236 = v127;
LABEL_203:
      uint64_t v152 = v234;
      goto LABEL_204;
    }
    a1 = (uint64_t)v127._object & 0x2000000000000000;
    uint64_t v72 = ((unint64_t)v127._object >> 56) & 0xF;
    if (((uint64_t)v236._object & 0x2000000000000000) != 0 && a1)
    {
      unint64_t v129 = v128 + v72;
      if (v128 + v72 <= 0xF)
      {
        uint64_t v152 = v234;
        if (v72)
        {
          char v185 = 0;
          unint64_t v186 = 0;
          unint64_t v187 = (unint64_t)v236._object;
          do
          {
            unint64_t v188 = v128 + v186;
            unint64_t v189 = v186 + 1;
            if (v186 >= 8) {
              unint64_t v190 = (unint64_t)v127._object;
            }
            else {
              unint64_t v190 = v127._countAndFlagsBits;
            }
            unint64_t v191 = v190 >> (v185 & 0x38);
            char v192 = (8 * v128 + v185) & 0x38;
            uint64_t v193 = (-255 << v192) - 1;
            unint64_t v194 = (unint64_t)v191 << v192;
            unint64_t v195 = v194 | v193 & v187;
            unint64_t v196 = v194 | v193 & countAndFlagsBits;
            if (v188 < 8) {
              uint64_t countAndFlagsBits = v196;
            }
            else {
              unint64_t v187 = v195;
            }
            v185 += 8;
            unint64_t v186 = v189;
          }
          while (v72 != v189);
        }
        else
        {
          unint64_t v187 = (unint64_t)v236._object;
        }
        swift_bridgeObjectRelease((uint64_t)v236._object);
        swift_bridgeObjectRelease((uint64_t)v127._object);
        unint64_t v202 = 0xA000000000000000;
        if (!(countAndFlagsBits & 0x8080808080808080 | v187 & 0x80808080808080)) {
          unint64_t v202 = 0xE000000000000000;
        }
        v236._uint64_t countAndFlagsBits = countAndFlagsBits;
        v236._unint64_t object = (void *)(v202 & 0xFF00000000000000 | (v129 << 56) | v187 & 0xFFFFFFFFFFFFFFLL);
        goto LABEL_204;
      }
      a1 = 1;
    }
    uint64_t v232 = v127._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (a1) {
      unint64_t object = ((unint64_t)v127._object >> 56) & 0xF;
    }
    else {
      unint64_t object = v127._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    }
    swift_bridgeObjectRetain_n((uint64_t)v127._object, 2);
    if (((uint64_t)v127._object & 0x1000000000000000) != 0) {
      goto LABEL_273;
    }
    swift_bridgeObjectRetain_n((uint64_t)v127._object, 4);
    unint64_t v9 = object;
    if ((v2 & 0x1000000000000000) != 0) {
      goto LABEL_276;
    }
LABEL_184:
    int64_t v130 = v74 + v9;
    if (!__OFADD__(v74, v9)) {
      goto LABEL_185;
    }
LABEL_278:
    __break(1u);
LABEL_279:
    Swift::Int v214 = String.UTF8View._foreignCount()();
    Swift::Int v19 = v214 + 8;
    if (__OFADD__(v214, 8))
    {
LABEL_281:
      __break(1u);
      goto LABEL_282;
    }
LABEL_13:
    unint64_t v20 = v7 & ~countAndFlagsBits;
    if ((v20 & 0x2000000000000000) != 0
      && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v21 = _StringGuts.nativeUnusedCapacity.getter(v7, countAndFlagsBits);
      if (v22) {
        goto LABEL_303;
      }
      if (v19 > 15) {
        goto LABEL_21;
      }
      if ((countAndFlagsBits & 0x2000000000000000) != 0) {
        goto LABEL_62;
      }
      if (v21 > 7)
      {
LABEL_21:
        int64_t v23 = _StringGuts.nativeUnusedCapacity.getter(v7, countAndFlagsBits);
        BOOL v26 = (v24 & 1) == 0 && v23 > 7;
        if ((v20 & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v26) {
            goto LABEL_50;
          }
        }
        else if (v26)
        {
          goto LABEL_49;
        }
        uint64_t v39 = _StringGuts.nativeCapacity.getter(v7, countAndFlagsBits);
        if (v40) {
          uint64_t v41 = 0;
        }
        else {
          uint64_t v41 = v39;
        }
        if (v41 + 0x4000000000000000 >= 0)
        {
          uint64_t v42 = 2 * v41;
          if (v42 > v19) {
            Swift::Int v19 = v42;
          }
LABEL_49:
          _StringGuts.grow(_:)(v19);
LABEL_50:
          swift_bridgeObjectRelease_n(0xE800000000000000, 6);
          long long v235 = xmmword_18162B020;
          char v43 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 8, (uint64_t)&v235, 8);
          _StringGuts.appendInPlace(_:isASCII:)(v43, v44, 1);
          swift_bridgeObjectRelease(0xE800000000000000);
          unint64_t v233 = object;
          if (!a1) {
            goto LABEL_58;
          }
          goto LABEL_80;
        }
        __break(1u);
LABEL_296:
        unint64_t v7 = _StringGuts._foreignConvertedToSmall()(v7, countAndFlagsBits);
        uint64_t v10 = v221;
        goto LABEL_63;
      }
    }
    else
    {
      if (v19 > 15) {
        goto LABEL_21;
      }
      if ((countAndFlagsBits & 0x2000000000000000) != 0)
      {
LABEL_62:
        swift_bridgeObjectRelease_n(0xE800000000000000, 5);
        uint64_t v10 = countAndFlagsBits;
        goto LABEL_63;
      }
    }
    swift_bridgeObjectRelease_n(0xE800000000000000, 5);
    if ((countAndFlagsBits & 0x1000000000000000) != 0) {
      goto LABEL_296;
    }
    if ((v7 & 0x1000000000000000) != 0)
    {
      uint64_t v45 = (unsigned __int8 *)((countAndFlagsBits & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      uint64_t v45 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v7, countAndFlagsBits);
      uint64_t v10 = v222;
    }
    swift_bridgeObjectRetain(countAndFlagsBits);
    closure #1 in _StringGuts._convertedToSmall()(v45, v10, &v235);
    swift_bridgeObjectRelease(countAndFlagsBits);
    uint64_t v10 = *((void *)&v235 + 1);
    unint64_t v7 = v235;
LABEL_63:
    v46._rawBits = 1;
    v47._rawBits = 524289;
    v48._rawBits = _StringGuts.validateScalarRange(_:)(v46, v47, 0x203A747261747328uLL, 0xE800000000000000);
    if (v48._rawBits < 0x10000) {
      v48._rawBits |= 3;
    }
    unint64_t v2 = specialized String.init(_:)(v48, v49, 0x203A747261747328uLL, 0xE800000000000000);
    unint64_t v51 = v50;
    swift_bridgeObjectRelease(0xE800000000000000);
    if ((v51 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v51);
      goto LABEL_67;
    }
LABEL_291:
    if ((v51 & 0x1000000000000000) != 0)
    {
      unint64_t v2 = _StringGuts._foreignConvertedToSmall()(v2, v51);
      unint64_t v231 = v230;
      swift_bridgeObjectRelease(v51);
      unint64_t v51 = v231;
    }
    else
    {
      if ((v2 & 0x1000000000000000) != 0)
      {
        id v219 = (unsigned __int8 *)((v51 & 0xFFFFFFFFFFFFFFFLL) + 32);
        uint64_t v220 = v2 & 0xFFFFFFFFFFFFLL;
      }
      else
      {
        id v219 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v2, v51);
      }
      closure #1 in _StringGuts._convertedToSmall()(v219, v220, &v235);
      swift_bridgeObjectRelease(v51);
      unint64_t v51 = *((void *)&v235 + 1);
      unint64_t v2 = v235;
    }
LABEL_67:
    uint64_t v52 = HIBYTE(v10) & 0xF;
    uint64_t v53 = HIBYTE(v51) & 0xF;
    uint64_t v54 = v53 + v52;
    if ((unint64_t)(v53 + v52) > 0xF) {
      goto LABEL_302;
    }
    if (v53)
    {
      char v55 = 0;
      unint64_t v56 = 0;
      do
      {
        unint64_t v57 = v52 + v56;
        unint64_t v58 = v56 + 1;
        if (v56 >= 8) {
          unint64_t v59 = v51;
        }
        else {
          unint64_t v59 = v2;
        }
        unint64_t v60 = v59 >> (v55 & 0x38);
        char v61 = (8 * v52 + v55) & 0x38;
        uint64_t v62 = (-255 << v61) - 1;
        unint64_t v63 = (unint64_t)v60 << v61;
        unint64_t v64 = v63 | v62 & v10;
        unint64_t v65 = v63 | v62 & v7;
        if (v57 < 8) {
          unint64_t v7 = v65;
        }
        else {
          uint64_t v10 = v64;
        }
        v55 += 8;
        unint64_t v56 = v58;
      }
      while (v53 != v58);
    }
    swift_bridgeObjectRelease(countAndFlagsBits);
    swift_bridgeObjectRelease(0xE800000000000000);
    unint64_t v66 = 0xA000000000000000;
    if (!(v7 & 0x8080808080808080 | v10 & 0x80808080808080)) {
      unint64_t v66 = 0xE000000000000000;
    }
    v236._uint64_t countAndFlagsBits = v7;
    v236._unint64_t object = (void *)(v66 & 0xFF00000000000000 | (v54 << 56) | v10 & 0xFFFFFFFFFFFFFFLL);
    unint64_t v233 = object;
    if (!a1) {
      goto LABEL_58;
    }
LABEL_80:
    uint64_t v10 = specialized String.init<A>(describing:)((void *)a1);
    unint64_t v7 = v67;
  }
  swift_bridgeObjectRetain_n(v7, 5);
  v204._rawBits = 1;
  v205._rawBits = (v72 << 16) | 1;
  v206._rawBits = _StringGuts.validateScalarRange(_:)(v204, v205, v10, v7);
  if (v206._rawBits < 0x10000) {
    v206._rawBits |= 3;
  }
  uint64_t v72 = specialized Collection.count.getter(v206, v207, v10, v7);
  swift_bridgeObjectRelease(v7);
  if ((object & 0x1000000000000000) == 0) {
    goto LABEL_95;
  }
LABEL_270:
  Swift::Int v208 = String.UTF8View._foreignCount()();
  Swift::Int v74 = v208 + v72;
  if (!__OFADD__(v208, v72)) {
    goto LABEL_96;
  }
LABEL_272:
  __break(1u);
LABEL_273:
  swift_bridgeObjectRetain_n(v7, 5);
  v209._rawBits = 1;
  v210._rawBits = (object << 16) | 1;
  v211._rawBits = _StringGuts.validateScalarRange(_:)(v209, v210, v10, v7);
  if (v211._rawBits < 0x10000) {
    v211._rawBits |= 3;
  }
  unint64_t v9 = specialized Collection.count.getter(v211, v212, v10, v7);
  swift_bridgeObjectRelease(v7);
  if ((v2 & 0x1000000000000000) == 0) {
    goto LABEL_184;
  }
LABEL_276:
  Swift::Int v213 = String.UTF8View._foreignCount()();
  int64_t v130 = v213 + v9;
  if (__OFADD__(v213, v9)) {
    goto LABEL_278;
  }
LABEL_185:
  if ((countAndFlagsBits & ~v2 & 0x2000000000000000) != 0
    && swift_isUniquelyReferenced_nonNull_native(v2 & 0xFFFFFFFFFFFFFFFLL))
  {
    unint64_t v131 = (unint64_t)v236._object;
    int64_t v132 = _StringGuts.nativeUnusedCapacity.getter(v236._countAndFlagsBits, (uint64_t)v236._object);
    if (v133)
    {
LABEL_303:
      unint64_t v225 = 258;
      goto LABEL_304;
    }
    if (v130 <= 15 && ((v131 & 0x2000000000000000) != 0 || v132 < (uint64_t)v9))
    {
LABEL_197:
      swift_bridgeObjectRelease_n(v7, 5);
      unint64_t v136 = v236._countAndFlagsBits;
      swift_bridgeObjectRetain(v131);
      unint64_t v137 = _StringGuts._convertedToSmall()(v136, v131);
      unint64_t v139 = v138;
      swift_bridgeObjectRelease(v131);
      v140._rawBits = (object << 16) | 1;
      v141._rawBits = 1;
      v142._rawBits = _StringGuts.validateScalarRange(_:)(v141, v140, v10, v7);
      if (v142._rawBits < 0x10000) {
        v142._rawBits |= 3;
      }
      unint64_t v144 = specialized String.init(_:)(v142, v143, v10, v7);
      unint64_t v146 = v145;
      swift_bridgeObjectRelease(v7);
      unint64_t v147 = _StringGuts._convertedToSmall()(v144, v146);
      unint64_t v149 = v148;
      swift_bridgeObjectRelease(v146);
      unint64_t v150 = specialized _SmallString.init(_:appending:)(v137, v139, v147, v149);
      uint64_t v152 = v234;
      if ((v153 & 1) == 0)
      {
        uint64_t v154 = v150;
        unint64_t v155 = v151;
        swift_bridgeObjectRelease(v131);
        swift_bridgeObjectRelease(v7);
        v236._uint64_t countAndFlagsBits = v154;
        v236._unint64_t object = v155;
        goto LABEL_204;
      }
LABEL_302:
      unint64_t v225 = 266;
LABEL_304:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v225, 0);
    }
  }
  else if (v130 <= 15)
  {
    unint64_t v131 = (unint64_t)v236._object;
    goto LABEL_197;
  }
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v130, v9);
  swift_bridgeObjectRelease_n(v7, 4);
  if ((v7 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v7);
    _StringGuts._foreignAppendInPlace(_:)(v10, v7, 0, object);
    swift_bridgeObjectRelease_n(v7, 2);
    goto LABEL_203;
  }
  if (a1)
  {
    swift_bridgeObjectRelease_n(v7, 2);
    *(void *)&long long v235 = v10;
    *((void *)&v235 + 1) = v7 & 0xFFFFFFFFFFFFFFLL;
    uint64_t v134 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v72, (uint64_t)&v235, v72);
    _StringGuts.appendInPlace(_:isASCII:)(v134, v135, (v7 & 0x4000000000000000) != 0);
    swift_bridgeObjectRelease(v7);
    goto LABEL_203;
  }
  if ((v10 & 0x1000000000000000) != 0)
  {
    swift_bridgeObjectRelease(v7);
    id v197 = (id)((v7 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v198 = v232;
    uint64_t v199 = v232;
    uint64_t v152 = v234;
  }
  else
  {
    id v197 = _StringObject.sharedUTF8.getter(v10, v7);
    uint64_t v199 = v223;
    swift_bridgeObjectRelease(v7);
    if (v199 < v232) {
LABEL_301:
    }
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
    uint64_t v152 = v234;
    uint64_t v198 = v232;
  }
  unint64_t v200 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, v198, (uint64_t)v197, v199);
  _StringGuts.appendInPlace(_:isASCII:)(v200, v201, v10 < 0);
  swift_bridgeObjectRelease_n(v7, 2);
LABEL_204:
  if (v152) {
    uint64_t v156 = v233 - v152;
  }
  else {
    uint64_t v156 = 0;
  }
  unint64_t v158 = _int64ToString(_:radix:uppercase:)(v156, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
  unint64_t v159 = v157;
  uint64_t v160 = v236._countAndFlagsBits;
  unint64_t v161 = ((unint64_t)v236._object >> 56) & 0xF;
  unint64_t v162 = v236._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  if (((uint64_t)v236._object & 0x2000000000000000) != 0) {
    unint64_t v162 = ((unint64_t)v236._object >> 56) & 0xF;
  }
  if (v162 || (v236._countAndFlagsBits & ~(uint64_t)v236._object & 0x2000000000000000) != 0)
  {
    if (((uint64_t)v236._object & 0x2000000000000000) == 0)
    {
      if ((v157 & 0x2000000000000000) != 0)
      {
        uint64_t v163 = HIBYTE(v157) & 0xF;
        goto LABEL_216;
      }
LABEL_215:
      uint64_t v163 = v158 & 0xFFFFFFFFFFFFLL;
      goto LABEL_216;
    }
    if ((v157 & 0x2000000000000000) == 0) {
      goto LABEL_215;
    }
    uint64_t v163 = HIBYTE(v157) & 0xF;
    unint64_t v172 = v161 + v163;
    if (v161 + v163 > 0xF)
    {
LABEL_216:
      _StringGuts.append(_:)(v158, v157, 0, v163);
      swift_bridgeObjectRelease(v159);
      unint64_t v158 = v236._countAndFlagsBits;
      unint64_t v159 = (unint64_t)v236._object;
    }
    else
    {
      if (v163)
      {
        char v173 = 0;
        unint64_t v174 = 0;
        unint64_t v175 = (unint64_t)v236._object;
        do
        {
          unint64_t v176 = v161 + v174;
          unint64_t v177 = v174 + 1;
          if (v174 >= 8) {
            unint64_t v178 = v157;
          }
          else {
            unint64_t v178 = v158;
          }
          unint64_t v179 = v178 >> (v173 & 0x38);
          char v180 = (8 * v161 + v173) & 0x38;
          uint64_t v181 = (-255 << v180) - 1;
          unint64_t v182 = (unint64_t)v179 << v180;
          unint64_t v183 = v182 | v181 & v175;
          unint64_t v184 = v182 | v181 & v160;
          if (v176 < 8) {
            uint64_t v160 = v184;
          }
          else {
            unint64_t v175 = v183;
          }
          v173 += 8;
          unint64_t v174 = v177;
        }
        while (v163 != v177);
      }
      else
      {
        unint64_t v175 = (unint64_t)v236._object;
      }
      swift_bridgeObjectRelease((uint64_t)v236._object);
      swift_bridgeObjectRelease(v159);
      unint64_t v203 = 0xA000000000000000;
      if (!(v160 & 0x8080808080808080 | v175 & 0x80808080808080)) {
        unint64_t v203 = 0xE000000000000000;
      }
      unint64_t v159 = v203 & 0xFF00000000000000 | (v172 << 56) | v175 & 0xFFFFFFFFFFFFFFLL;
      v236._uint64_t countAndFlagsBits = v160;
      v236._unint64_t object = (void *)v159;
      unint64_t v158 = v160;
    }
  }
  else
  {
    swift_bridgeObjectRelease((uint64_t)v236._object);
    v236._uint64_t countAndFlagsBits = v158;
    v236._unint64_t object = (void *)v159;
  }
  uint64_t v164 = HIBYTE(v159) & 0xF;
  if ((v159 & 0x2000000000000000) == 0) {
    uint64_t v164 = v158 & 0xFFFFFFFFFFFFLL;
  }
  if (v164 || (v158 & ~v159 & 0x2000000000000000) != 0)
  {
    if ((v159 & 0x2000000000000000) == 0
      || (unint64_t v165 = specialized _SmallString.init(_:appending:)(v158, v159, 0x29uLL, 0xE100000000000000), (v167 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000);
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      unint64_t v168 = v236._countAndFlagsBits;
      Swift::Int v169 = v236._object;
    }
    else
    {
      unint64_t v168 = v165;
      Swift::Int v169 = v166;
      swift_bridgeObjectRelease(v159);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v159);
    Swift::Int v169 = (void *)0xE100000000000000;
    unint64_t v168 = 41;
  }
  unint64_t v170 = specialized static String.+ infix(_:_:)(0xD000000000000016, 0x800000018162B140 | 0x8000000000000000, v168, (unint64_t)v169);
  swift_bridgeObjectRelease(0x800000018162B140 | 0x8000000000000000);
  swift_bridgeObjectRelease((uint64_t)v169);
  return v170;
}

unint64_t protocol witness for CustomDebugStringConvertible.debugDescription.getter in conformance UnsafeRawBufferPointer()
{
  return UnsafeRawBufferPointer.debugDescription.getter(*(void *)v0, *(void *)(v0 + 8));
}

uint64_t UnsafeRawBufferPointer.subscript.getter()
{
  return 0;
}

uint64_t withUnsafeMutableBytes<A, B>(of:_:)(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5)
{
  return withUnsafeMutableBytes<A, B>(of:_:)(a1, a2, a3, a4, a5, "UnsafeMutableRawBufferPointer with negative count", 49, 0x68uLL);
}

uint64_t withUnsafeBytes<A, B>(of:_:)(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5)
{
  return withUnsafeMutableBytes<A, B>(of:_:)(a1, a2, a3, a4, a5, "UnsafeRawBufferPointer with negative count", 42, 0x485uLL);
}

uint64_t withUnsafeMutableBytes<A, B>(of:_:)(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7, unint64_t a8)
{
  uint64_t v8 = *(void *)(*(void *)(a4 - 8) + 64);
  if (v8 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, a6, a7, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, a8, 0);
  }
  return a2(a1, a1 + v8);
}

uint64_t withUnsafeBytes<A, B>(of:_:)(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(a4 - 8) + 64);
  if (v4 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
  }
  return a2(a1, a1 + v4);
}

uint64_t == infix(_:_:)()
{
  return 1;
}

uint64_t != infix(_:_:)()
{
  return 0;
}

uint64_t < infix(_:_:)()
{
  return 0;
}

uint64_t <= infix(_:_:)()
{
  return 1;
}

uint64_t > infix(_:_:)()
{
  return 0;
}

uint64_t >= infix(_:_:)()
{
  return 1;
}

uint64_t != infix<A, B>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v25 = a8;
  uint64_t v26 = a2;
  uint64_t v28 = a4;
  uint64_t v29 = a7;
  uint64_t v27 = a3;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a5, a6, 0, 0);
  uint64_t v12 = *(TupleTypeMetadata2 - 1);
  uint64_t v13 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v15 = (char *)&v24 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v13);
  char v17 = (char *)&v24 - v16;
  unint64_t v18 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16);
  v18((char *)&v24 - v16, a1, a5);
  Swift::Int v19 = *(void (**)(void))(*(void *)(a6 - 8) + 16);
  char v24 = &v17[*((int *)TupleTypeMetadata2 + 12)];
  v19();
  v18(v15, v27, a5);
  unint64_t v20 = &v15[*((int *)TupleTypeMetadata2 + 12)];
  ((void (*)(char *, uint64_t, uint64_t))v19)(v20, v28, a6);
  if ((*(uint64_t (**)(char *, char *, uint64_t))(v29 + 8))(v17, v15, a5)) {
    char v21 = (*(uint64_t (**)(char *, char *, uint64_t))(v25 + 8))(v24, v20, a6) ^ 1;
  }
  else {
    char v21 = 1;
  }
  char v22 = *(void (**)(char *, uint64_t *))(v12 + 8);
  v22(v15, TupleTypeMetadata2);
  v22(v17, TupleTypeMetadata2);
  return v21 & 1;
}

uint64_t <= infix<A, B>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v26 = a8;
  uint64_t v27 = a2;
  uint64_t v29 = a7;
  uint64_t v30 = a4;
  uint64_t v28 = a3;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a5, a6, 0, 0);
  uint64_t v31 = *(TupleTypeMetadata2 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v14 = (char *)&v26 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v26 - v15;
  char v17 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a5 - 8) + 16);
  v17((char *)&v26 - v15, a1, a5);
  unint64_t v18 = &v16[*((int *)TupleTypeMetadata2 + 12)];
  Swift::Int v19 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(a6 - 8) + 16);
  v19(v18, v27, a6);
  v17(v14, v28, a5);
  uint64_t v20 = v29;
  char v21 = &v14[*((int *)TupleTypeMetadata2 + 12)];
  v19(v21, v30, a6);
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v20 + 8) + 8))(v16, v14, a5)) {
    char v22 = (*(uint64_t (**)(char *, char *, uint64_t))(v26 + 24))(v18, v21, a6);
  }
  else {
    char v22 = (*(uint64_t (**)(char *, char *, uint64_t))(v20 + 24))(v16, v14, a5);
  }
  char v23 = v22;
  char v24 = *(void (**)(char *, uint64_t *))(v31 + 8);
  v24(v14, TupleTypeMetadata2);
  v24(v16, TupleTypeMetadata2);
  return v23 & 1;
}

uint64_t == infix<A, B, C>(_:_:)(uint64_t a1, uint64_t a2, void (*a3)(void), uint64_t *a4, char *a5, char *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unint64_t v63 = a4;
  unint64_t v64 = a5;
  uint64_t v61 = a2;
  uint64_t v62 = a3;
  uint64_t v65 = a10;
  unint64_t v66 = a6;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a8, a9, 0, 0);
  uint64_t v56 = *(TupleTypeMetadata2 - 1);
  unint64_t v57 = TupleTypeMetadata2;
  uint64_t v16 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  char v55 = (char *)v52 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  uint64_t v54 = (char *)v52 - v18;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, a7, a8, a9, 0, 0);
  uint64_t v58 = *(TupleTypeMetadata3 - 1);
  uint64_t v20 = MEMORY[0x1F4188790](TupleTypeMetadata3);
  char v22 = (char *)v52 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v20);
  char v24 = (char *)v52 - v23;
  unint64_t v60 = *(char **)(*(void *)(a7 - 8) + 16);
  ((void (*)(char *, uint64_t, uint64_t))v60)((char *)v52 - v23, a1, a7);
  uint64_t v25 = &v24[*((int *)TupleTypeMetadata3 + 12)];
  uint64_t v59 = a8;
  uint64_t v26 = *(void *)(a8 - 8);
  uint64_t v27 = *(void (**)(void))(v26 + 16);
  uint64_t v28 = v26 + 16;
  uint64_t v53 = v25;
  v27();
  uint64_t v29 = *(void (**)(void))(*(void *)(a9 - 8) + 16);
  v52[1] = &v24[*((int *)TupleTypeMetadata3 + 16)];
  v29();
  ((void (*)(char *, uint64_t *, uint64_t))v60)(v22, v63, a7);
  uint64_t v30 = v28;
  uint64_t v31 = v59;
  unint64_t v60 = &v22[*((int *)TupleTypeMetadata3 + 12)];
  uint64_t v61 = v30;
  char v32 = v27;
  v27();
  uint64_t v62 = v29;
  unint64_t v63 = TupleTypeMetadata3;
  uint64_t v33 = &v22[*((int *)TupleTypeMetadata3 + 16)];
  ((void (*)(char *, char *, uint64_t))v29)(v33, v66, a9);
  char v34 = *(uint64_t (**)(char *, char *, uint64_t))(v65 + 8);
  unint64_t v64 = v24;
  unint64_t v66 = v22;
  if (v34(v24, v22, a7))
  {
    uint64_t v65 = a11;
    uint64_t v35 = v54;
    ((void (*)(char *, char *, uint64_t))v32)(v54, v53, v31);
    uint64_t v53 = v33;
    char v36 = v57;
    v52[0] = &v35[*((int *)v57 + 12)];
    uint64_t v37 = v62;
    v62();
    unint64_t v38 = v55;
    ((void (*)(char *, char *, uint64_t))v32)(v55, v60, v31);
    uint64_t v39 = &v38[*((int *)v36 + 12)];
    ((void (*)(char *, char *, uint64_t))v37)(v39, v53, a9);
    char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(v65 + 8))(v35, v38, v31);
    uint64_t v41 = v56;
    uint64_t v42 = v38;
    char v43 = v35;
    size_t v44 = v63;
    if (v40) {
      char v45 = (*(uint64_t (**)(void, char *, uint64_t))(a12 + 8))(v52[0], v39, a9);
    }
    else {
      char v45 = 0;
    }
    Swift::String::Index v48 = *(void (**)(char *, uint64_t *))(v41 + 8);
    v48(v42, v36);
    v48(v43, v36);
    uint64_t v46 = v58;
    Swift::String::Index v47 = v66;
  }
  else
  {
    char v45 = 0;
    uint64_t v46 = v58;
    Swift::String::Index v47 = v66;
    size_t v44 = v63;
  }
  Swift::String::Index v49 = v64;
  unint64_t v50 = *(void (**)(char *, uint64_t *))(v46 + 8);
  v50(v47, v44);
  v50(v49, v44);
  return v45 & 1;
}

uint64_t != infix<A, B, C>(_:_:)(uint64_t a1, uint64_t a2, void (*a3)(void), uint64_t *a4, char *a5, char *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unint64_t v63 = a4;
  unint64_t v64 = a5;
  uint64_t v61 = a2;
  uint64_t v62 = a3;
  uint64_t v65 = a10;
  unint64_t v66 = a6;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, a8, a9, 0, 0);
  uint64_t v56 = *(TupleTypeMetadata2 - 1);
  unint64_t v57 = TupleTypeMetadata2;
  uint64_t v16 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  char v55 = (char *)v52 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  uint64_t v54 = (char *)v52 - v18;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, a7, a8, a9, 0, 0);
  uint64_t v58 = *(TupleTypeMetadata3 - 1);
  uint64_t v20 = MEMORY[0x1F4188790](TupleTypeMetadata3);
  char v22 = (char *)v52 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v20);
  char v24 = (char *)v52 - v23;
  unint64_t v60 = *(char **)(*(void *)(a7 - 8) + 16);
  ((void (*)(char *, uint64_t, uint64_t))v60)((char *)v52 - v23, a1, a7);
  uint64_t v25 = &v24[*((int *)TupleTypeMetadata3 + 12)];
  uint64_t v59 = a8;
  uint64_t v26 = *(void *)(a8 - 8);
  uint64_t v27 = *(void (**)(void))(v26 + 16);
  uint64_t v28 = v26 + 16;
  uint64_t v53 = v25;
  v27();
  uint64_t v29 = *(void (**)(void))(*(void *)(a9 - 8) + 16);
  v52[1] = &v24[*((int *)TupleTypeMetadata3 + 16)];
  v29();
  ((void (*)(char *, uint64_t *, uint64_t))v60)(v22, v63, a7);
  uint64_t v30 = v28;
  uint64_t v31 = v59;
  unint64_t v60 = &v22[*((int *)TupleTypeMetadata3 + 12)];
  uint64_t v61 = v30;
  char v32 = v27;
  v27();
  uint64_t v62 = v29;
  unint64_t v63 = TupleTypeMetadata3;
  uint64_t v33 = &v22[*((int *)TupleTypeMetadata3 + 16)];
  ((void (*)(char *, char *, uint64_t))v29)(v33, v66, a9);
  char v34 = *(uint64_t (**)(char *, char *, uint64_t))(v65 + 8);
  unint64_t v64 = v24;
  unint64_t v66 = v22;
  if (v34(v24, v22, a7))
  {
    uint64_t v65 = a11;
    uint64_t v35 = v54;
    ((void (*)(char *, char *, uint64_t))v32)(v54, v53, v31);
    uint64_t v53 = v33;
    char v36 = v57;
    v52[0] = &v35[*((int *)v57 + 12)];
    uint64_t v37 = v62;
    v62();
    unint64_t v38 = v55;
    ((void (*)(char *, char *, uint64_t))v32)(v55, v60, v31);
    uint64_t v39 = &v38[*((int *)v36 + 12)];
    ((void (*)(char *, char *, uint64_t))v37)(v39, v53, a9);
    char v40 = (*(uint64_t (**)(char *, char *, uint64_t))(v65 + 8))(v35, v38, v31);
    uint64_t v41 = v56;
    uint64_t v42 = v38;
    char v43 = v35;
    size_t v44 = v63;
    if (v40) {
      char v45 = (*(uint64_t (**)(void, char *, uint64_t))(a12 + 8))(v52[0], v39, a9) ^ 1;
    }
    else {
      char v45 = 1;
    }
    Swift::String::Index v48 = *(void (**)(char *, uint64_t *))(v41 + 8);
    v48(v42, v36);
    v48(v43, v36);
    uint64_t v46 = v58;
    Swift::String::Index v47 = v66;
  }
  else
  {
    char v45 = 1;
    uint64_t v46 = v58;
    Swift::String::Index v47 = v66;
    size_t v44 = v63;
  }
  Swift::String::Index v49 = v64;
  unint64_t v50 = *(void (**)(char *, uint64_t *))(v46 + 8);
  v50(v47, v44);
  v50(v49, v44);
  return v45 & 1;
}

uint64_t <= infix<A, B, C>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v35 = (char *)a4;
  uint64_t v36 = a5;
  uint64_t v34 = a3;
  uint64_t v37 = a10;
  uint64_t v38 = a6;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, a7, a8, a9, 0, 0);
  uint64_t v39 = *(TupleTypeMetadata3 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](TupleTypeMetadata3);
  uint64_t v18 = (char *)&v30 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v30 - v19;
  uint64_t v21 = *(void *)(a7 - 8);
  char v32 = *(void (**)(char *, uint64_t, uint64_t))(v21 + 16);
  uint64_t v33 = v21 + 16;
  v32((char *)&v30 - v19, a1, a7);
  char v22 = *(void (**)(void))(*(void *)(a8 - 8) + 16);
  uint64_t v31 = &v20[*((int *)TupleTypeMetadata3 + 12)];
  v22();
  uint64_t v23 = *(void (**)(void))(*(void *)(a9 - 8) + 16);
  uint64_t v30 = &v20[*((int *)TupleTypeMetadata3 + 16)];
  v23();
  v32(v18, (uint64_t)v35, a7);
  uint64_t v35 = &v18[*((int *)TupleTypeMetadata3 + 12)];
  uint64_t v36 = a8;
  v22();
  uint64_t v24 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 16)];
  ((void (*)(uint64_t, uint64_t, uint64_t))v23)(v24, v38, a9);
  uint64_t v25 = v37;
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v37 + 8) + 8))(v20, v18, a7)) {
    char v26 = <= infix<A, B>(_:_:)((uint64_t)v31, (uint64_t)v30, (uint64_t)v35, v24, v36, a9, a11, a12);
  }
  else {
    char v26 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v25 + 24))(v20, v18, a7, v25);
  }
  char v27 = v26;
  uint64_t v28 = *(void (**)(char *, uint64_t *))(v39 + 8);
  v28(v18, TupleTypeMetadata3);
  v28(v20, TupleTypeMetadata3);
  return v27 & 1;
}

uint64_t > infix<A, B, C>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v35 = (char *)a4;
  uint64_t v36 = a5;
  uint64_t v34 = a3;
  uint64_t v37 = a10;
  uint64_t v38 = a6;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, a7, a8, a9, 0, 0);
  uint64_t v39 = *(TupleTypeMetadata3 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](TupleTypeMetadata3);
  uint64_t v18 = (char *)&v30 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v30 - v19;
  uint64_t v21 = *(void *)(a7 - 8);
  char v32 = *(void (**)(char *, uint64_t, uint64_t))(v21 + 16);
  uint64_t v33 = v21 + 16;
  v32((char *)&v30 - v19, a1, a7);
  char v22 = *(void (**)(void))(*(void *)(a8 - 8) + 16);
  uint64_t v31 = &v20[*((int *)TupleTypeMetadata3 + 12)];
  v22();
  uint64_t v23 = *(void (**)(void))(*(void *)(a9 - 8) + 16);
  uint64_t v30 = &v20[*((int *)TupleTypeMetadata3 + 16)];
  v23();
  v32(v18, (uint64_t)v35, a7);
  uint64_t v35 = &v18[*((int *)TupleTypeMetadata3 + 12)];
  uint64_t v36 = a8;
  v22();
  uint64_t v24 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 16)];
  ((void (*)(uint64_t, uint64_t, uint64_t))v23)(v24, v38, a9);
  uint64_t v25 = v37;
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v37 + 8) + 8))(v20, v18, a7)) {
    char v26 = > infix<A, B>(_:_:)((uint64_t)v31, (uint64_t)v30, (uint64_t)v35, v24, v36, a9, a11, a12);
  }
  else {
    char v26 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v25 + 40))(v20, v18, a7, v25);
  }
  char v27 = v26;
  uint64_t v28 = *(void (**)(char *, uint64_t *))(v39 + 8);
  v28(v18, TupleTypeMetadata3);
  v28(v20, TupleTypeMetadata3);
  return v27 & 1;
}

uint64_t >= infix<A, B, C>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v35 = (char *)a4;
  uint64_t v36 = a5;
  uint64_t v34 = a3;
  uint64_t v37 = a10;
  uint64_t v38 = a6;
  TupleTypeMetadata3 = swift_getTupleTypeMetadata3(0, a7, a8, a9, 0, 0);
  uint64_t v39 = *(TupleTypeMetadata3 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](TupleTypeMetadata3);
  uint64_t v18 = (char *)&v30 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v16);
  uint64_t v20 = (char *)&v30 - v19;
  uint64_t v21 = *(void *)(a7 - 8);
  char v32 = *(void (**)(char *, uint64_t, uint64_t))(v21 + 16);
  uint64_t v33 = v21 + 16;
  v32((char *)&v30 - v19, a1, a7);
  char v22 = *(void (**)(void))(*(void *)(a8 - 8) + 16);
  uint64_t v31 = &v20[*((int *)TupleTypeMetadata3 + 12)];
  v22();
  uint64_t v23 = *(void (**)(void))(*(void *)(a9 - 8) + 16);
  uint64_t v30 = &v20[*((int *)TupleTypeMetadata3 + 16)];
  v23();
  v32(v18, (uint64_t)v35, a7);
  uint64_t v35 = &v18[*((int *)TupleTypeMetadata3 + 12)];
  uint64_t v36 = a8;
  v22();
  uint64_t v24 = (uint64_t)&v18[*((int *)TupleTypeMetadata3 + 16)];
  ((void (*)(uint64_t, uint64_t, uint64_t))v23)(v24, v38, a9);
  uint64_t v25 = v37;
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v37 + 8) + 8))(v20, v18, a7)) {
    char v26 = >= infix<A, B>(_:_:)((uint64_t)v31, (uint64_t)v30, (uint64_t)v35, v24, v36, a9, a11, a12);
  }
  else {
    char v26 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v25 + 32))(v20, v18, a7, v25);
  }
  char v27 = v26;
  uint64_t v28 = *(void (**)(char *, uint64_t *))(v39 + 8);
  v28(v18, TupleTypeMetadata3);
  v28(v20, TupleTypeMetadata3);
  return v27 & 1;
}

uint64_t == infix<A, B, C, D>(_:_:)(uint64_t a1, uint64_t a2, void (*a3)(void), uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v46 = a6;
  uint64_t v47 = a7;
  uint64_t v44 = a4;
  char v45 = a5;
  uint64_t v42 = (char *)a2;
  char v43 = a3;
  uint64_t v48 = a13;
  uint64_t v49 = a8;
  v51[0] = a9;
  v51[1] = a10;
  v51[2] = a11;
  v51[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 4, (uint64_t)v51, 0, 0);
  uint64_t v50 = *((void *)TupleTypeMetadata - 1);
  uint64_t v18 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v20 = (char *)&v36 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v18);
  char v22 = (char *)&v36 - v21;
  uint64_t v23 = *(void *)(a9 - 8);
  char v40 = *(void (**)(char *, uint64_t, uint64_t))(v23 + 16);
  uint64_t v41 = v23 + 16;
  v40((char *)&v36 - v21, a1, a9);
  uint64_t v24 = (uint64_t)&v22[TupleTypeMetadata[12]];
  uint64_t v25 = *(void *)(a10 - 8);
  uint64_t v38 = *(void (**)(void))(v25 + 16);
  uint64_t v39 = v25 + 16;
  uint64_t v36 = v24;
  v38();
  char v26 = *(void (**)(void))(*(void *)(a11 - 8) + 16);
  uint64_t v42 = &v22[TupleTypeMetadata[16]];
  v26();
  char v27 = (void (*)(void))&v22[TupleTypeMetadata[20]];
  uint64_t v37 = a12;
  uint64_t v28 = *(void (**)(void))(*(void *)(a12 - 8) + 16);
  char v43 = v27;
  v28();
  v40(v20, (uint64_t)v45, a9);
  char v45 = (uint64_t *)&v20[TupleTypeMetadata[12]];
  uint64_t v46 = a10;
  v38();
  uint64_t v29 = &v20[TupleTypeMetadata[16]];
  uint64_t v30 = v47;
  uint64_t v47 = a11;
  ((void (*)(char *, uint64_t, uint64_t))v26)(v29, v30, a11);
  uint64_t v31 = v37;
  char v32 = &v20[TupleTypeMetadata[20]];
  ((void (*)(char *, uint64_t, uint64_t))v28)(v32, v49, v37);
  if ((*(uint64_t (**)(char *, char *, uint64_t))(v48 + 8))(v22, v20, a9)) {
    char v33 = == infix<A, B, C>(_:_:)(v36, (uint64_t)v42, v43, v45, v29, v32, v46, v47, v31, a14, a15, a16);
  }
  else {
    char v33 = 0;
  }
  uint64_t v34 = *(void (**)(char *, int *))(v50 + 8);
  v34(v20, TupleTypeMetadata);
  v34(v22, TupleTypeMetadata);
  return v33 & 1;
}

uint64_t != infix<A, B, C, D>(_:_:)(uint64_t a1, uint64_t a2, void (*a3)(void), uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v46 = a6;
  uint64_t v47 = a7;
  uint64_t v44 = a4;
  char v45 = a5;
  uint64_t v42 = (char *)a2;
  char v43 = a3;
  uint64_t v48 = a13;
  uint64_t v49 = a8;
  v51[0] = a9;
  v51[1] = a10;
  v51[2] = a11;
  v51[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 4, (uint64_t)v51, 0, 0);
  uint64_t v50 = *((void *)TupleTypeMetadata - 1);
  uint64_t v18 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v20 = (char *)&v36 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v18);
  char v22 = (char *)&v36 - v21;
  uint64_t v23 = *(void *)(a9 - 8);
  char v40 = *(void (**)(char *, uint64_t, uint64_t))(v23 + 16);
  uint64_t v41 = v23 + 16;
  v40((char *)&v36 - v21, a1, a9);
  uint64_t v24 = (uint64_t)&v22[TupleTypeMetadata[12]];
  uint64_t v25 = *(void *)(a10 - 8);
  uint64_t v38 = *(void (**)(void))(v25 + 16);
  uint64_t v39 = v25 + 16;
  uint64_t v36 = v24;
  v38();
  char v26 = *(void (**)(void))(*(void *)(a11 - 8) + 16);
  uint64_t v42 = &v22[TupleTypeMetadata[16]];
  v26();
  char v27 = (void (*)(void))&v22[TupleTypeMetadata[20]];
  uint64_t v37 = a12;
  uint64_t v28 = *(void (**)(void))(*(void *)(a12 - 8) + 16);
  char v43 = v27;
  v28();
  v40(v20, (uint64_t)v45, a9);
  char v45 = (uint64_t *)&v20[TupleTypeMetadata[12]];
  uint64_t v46 = a10;
  v38();
  uint64_t v29 = &v20[TupleTypeMetadata[16]];
  uint64_t v30 = v47;
  uint64_t v47 = a11;
  ((void (*)(char *, uint64_t, uint64_t))v26)(v29, v30, a11);
  uint64_t v31 = v37;
  char v32 = &v20[TupleTypeMetadata[20]];
  ((void (*)(char *, uint64_t, uint64_t))v28)(v32, v49, v37);
  if ((*(uint64_t (**)(char *, char *, uint64_t))(v48 + 8))(v22, v20, a9)) {
    char v33 = != infix<A, B, C>(_:_:)(v36, (uint64_t)v42, v43, v45, v29, v32, v46, v47, v31, a14, a15, a16);
  }
  else {
    char v33 = 1;
  }
  uint64_t v34 = *(void (**)(char *, int *))(v50 + 8);
  v34(v20, TupleTypeMetadata);
  v34(v22, TupleTypeMetadata);
  return v33 & 1;
}

uint64_t < infix<A, B, C, D>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v48 = a6;
  uint64_t v49 = a7;
  uint64_t v46 = a4;
  uint64_t v47 = (char *)a5;
  uint64_t v44 = (char *)a2;
  uint64_t v45 = a3;
  uint64_t v50 = a13;
  uint64_t v51 = a8;
  v53[0] = a9;
  v53[1] = a10;
  v53[2] = a11;
  v53[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 4, (uint64_t)v53, 0, 0);
  uint64_t v52 = *((void *)TupleTypeMetadata - 1);
  uint64_t v18 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v20 = (char *)&v38 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v18);
  char v22 = (char *)&v38 - v21;
  uint64_t v23 = *(void *)(a9 - 8);
  uint64_t v42 = *(void (**)(char *, uint64_t, uint64_t))(v23 + 16);
  uint64_t v43 = v23 + 16;
  v42((char *)&v38 - v21, a1, a9);
  uint64_t v24 = (uint64_t)&v22[TupleTypeMetadata[12]];
  uint64_t v25 = *(void *)(a10 - 8);
  char v40 = *(void (**)(void))(v25 + 16);
  uint64_t v41 = v25 + 16;
  uint64_t v38 = v24;
  v40();
  char v26 = *(void (**)(void))(*(void *)(a11 - 8) + 16);
  uint64_t v44 = &v22[TupleTypeMetadata[16]];
  v26();
  uint64_t v27 = (uint64_t)&v22[TupleTypeMetadata[20]];
  uint64_t v39 = a12;
  uint64_t v28 = *(void (**)(void))(*(void *)(a12 - 8) + 16);
  uint64_t v45 = v27;
  v28();
  v42(v20, (uint64_t)v47, a9);
  uint64_t v47 = &v20[TupleTypeMetadata[12]];
  uint64_t v48 = a10;
  v40();
  uint64_t v29 = (uint64_t)&v20[TupleTypeMetadata[16]];
  uint64_t v30 = v49;
  uint64_t v49 = a11;
  ((void (*)(uint64_t, uint64_t, uint64_t))v26)(v29, v30, a11);
  uint64_t v31 = v39;
  uint64_t v32 = (uint64_t)&v20[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v28)(v32, v51, v39);
  uint64_t v33 = v50;
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v50 + 8) + 8))(v22, v20, a9)) {
    char v34 = < infix<A, B, C>(_:_:)(v38, (uint64_t)v44, v45, (uint64_t)v47, v29, v32, v48, v49, v31, a14, a15, a16);
  }
  else {
    char v34 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v33 + 16))(v22, v20, a9, v33);
  }
  char v35 = v34;
  uint64_t v36 = *(void (**)(char *, int *))(v52 + 8);
  v36(v20, TupleTypeMetadata);
  v36(v22, TupleTypeMetadata);
  return v35 & 1;
}

uint64_t <= infix<A, B, C, D>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v48 = a6;
  uint64_t v49 = a7;
  uint64_t v46 = a4;
  uint64_t v47 = (char *)a5;
  uint64_t v44 = (char *)a2;
  uint64_t v45 = a3;
  uint64_t v50 = a13;
  uint64_t v51 = a8;
  v53[0] = a9;
  v53[1] = a10;
  v53[2] = a11;
  v53[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 4, (uint64_t)v53, 0, 0);
  uint64_t v52 = *((void *)TupleTypeMetadata - 1);
  uint64_t v18 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v20 = (char *)&v38 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v18);
  char v22 = (char *)&v38 - v21;
  uint64_t v23 = *(void *)(a9 - 8);
  uint64_t v42 = *(void (**)(char *, uint64_t, uint64_t))(v23 + 16);
  uint64_t v43 = v23 + 16;
  v42((char *)&v38 - v21, a1, a9);
  uint64_t v24 = (uint64_t)&v22[TupleTypeMetadata[12]];
  uint64_t v25 = *(void *)(a10 - 8);
  char v40 = *(void (**)(void))(v25 + 16);
  uint64_t v41 = v25 + 16;
  uint64_t v38 = v24;
  v40();
  char v26 = *(void (**)(void))(*(void *)(a11 - 8) + 16);
  uint64_t v44 = &v22[TupleTypeMetadata[16]];
  v26();
  uint64_t v27 = (uint64_t)&v22[TupleTypeMetadata[20]];
  uint64_t v39 = a12;
  uint64_t v28 = *(void (**)(void))(*(void *)(a12 - 8) + 16);
  uint64_t v45 = v27;
  v28();
  v42(v20, (uint64_t)v47, a9);
  uint64_t v47 = &v20[TupleTypeMetadata[12]];
  uint64_t v48 = a10;
  v40();
  uint64_t v29 = (uint64_t)&v20[TupleTypeMetadata[16]];
  uint64_t v30 = v49;
  uint64_t v49 = a11;
  ((void (*)(uint64_t, uint64_t, uint64_t))v26)(v29, v30, a11);
  uint64_t v31 = v39;
  uint64_t v32 = (uint64_t)&v20[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v28)(v32, v51, v39);
  uint64_t v33 = v50;
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v50 + 8) + 8))(v22, v20, a9)) {
    char v34 = <= infix<A, B, C>(_:_:)(v38, (uint64_t)v44, v45, (uint64_t)v47, v29, v32, v48, v49, v31, a14, a15, a16);
  }
  else {
    char v34 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v33 + 24))(v22, v20, a9, v33);
  }
  char v35 = v34;
  uint64_t v36 = *(void (**)(char *, int *))(v52 + 8);
  v36(v20, TupleTypeMetadata);
  v36(v22, TupleTypeMetadata);
  return v35 & 1;
}

uint64_t > infix<A, B, C, D>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v48 = a6;
  uint64_t v49 = a7;
  uint64_t v46 = a4;
  uint64_t v47 = (char *)a5;
  uint64_t v44 = (char *)a2;
  uint64_t v45 = a3;
  uint64_t v50 = a13;
  uint64_t v51 = a8;
  v53[0] = a9;
  v53[1] = a10;
  v53[2] = a11;
  v53[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 4, (uint64_t)v53, 0, 0);
  uint64_t v52 = *((void *)TupleTypeMetadata - 1);
  uint64_t v18 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v20 = (char *)&v38 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v18);
  char v22 = (char *)&v38 - v21;
  uint64_t v23 = *(void *)(a9 - 8);
  uint64_t v42 = *(void (**)(char *, uint64_t, uint64_t))(v23 + 16);
  uint64_t v43 = v23 + 16;
  v42((char *)&v38 - v21, a1, a9);
  uint64_t v24 = (uint64_t)&v22[TupleTypeMetadata[12]];
  uint64_t v25 = *(void *)(a10 - 8);
  char v40 = *(void (**)(void))(v25 + 16);
  uint64_t v41 = v25 + 16;
  uint64_t v38 = v24;
  v40();
  char v26 = *(void (**)(void))(*(void *)(a11 - 8) + 16);
  uint64_t v44 = &v22[TupleTypeMetadata[16]];
  v26();
  uint64_t v27 = (uint64_t)&v22[TupleTypeMetadata[20]];
  uint64_t v39 = a12;
  uint64_t v28 = *(void (**)(void))(*(void *)(a12 - 8) + 16);
  uint64_t v45 = v27;
  v28();
  v42(v20, (uint64_t)v47, a9);
  uint64_t v47 = &v20[TupleTypeMetadata[12]];
  uint64_t v48 = a10;
  v40();
  uint64_t v29 = (uint64_t)&v20[TupleTypeMetadata[16]];
  uint64_t v30 = v49;
  uint64_t v49 = a11;
  ((void (*)(uint64_t, uint64_t, uint64_t))v26)(v29, v30, a11);
  uint64_t v31 = v39;
  uint64_t v32 = (uint64_t)&v20[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v28)(v32, v51, v39);
  uint64_t v33 = v50;
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v50 + 8) + 8))(v22, v20, a9)) {
    char v34 = > infix<A, B, C>(_:_:)(v38, (uint64_t)v44, v45, (uint64_t)v47, v29, v32, v48, v49, v31, a14, a15, a16);
  }
  else {
    char v34 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v33 + 40))(v22, v20, a9, v33);
  }
  char v35 = v34;
  uint64_t v36 = *(void (**)(char *, int *))(v52 + 8);
  v36(v20, TupleTypeMetadata);
  v36(v22, TupleTypeMetadata);
  return v35 & 1;
}

uint64_t >= infix<A, B, C, D>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v48 = a6;
  uint64_t v49 = a7;
  uint64_t v46 = a4;
  uint64_t v47 = (char *)a5;
  uint64_t v44 = (char *)a2;
  uint64_t v45 = a3;
  uint64_t v50 = a13;
  uint64_t v51 = a8;
  v53[0] = a9;
  v53[1] = a10;
  v53[2] = a11;
  v53[3] = a12;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 4, (uint64_t)v53, 0, 0);
  uint64_t v52 = *((void *)TupleTypeMetadata - 1);
  uint64_t v18 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v20 = (char *)&v38 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v18);
  char v22 = (char *)&v38 - v21;
  uint64_t v23 = *(void *)(a9 - 8);
  uint64_t v42 = *(void (**)(char *, uint64_t, uint64_t))(v23 + 16);
  uint64_t v43 = v23 + 16;
  v42((char *)&v38 - v21, a1, a9);
  uint64_t v24 = (uint64_t)&v22[TupleTypeMetadata[12]];
  uint64_t v25 = *(void *)(a10 - 8);
  char v40 = *(void (**)(void))(v25 + 16);
  uint64_t v41 = v25 + 16;
  uint64_t v38 = v24;
  v40();
  char v26 = *(void (**)(void))(*(void *)(a11 - 8) + 16);
  uint64_t v44 = &v22[TupleTypeMetadata[16]];
  v26();
  uint64_t v27 = (uint64_t)&v22[TupleTypeMetadata[20]];
  uint64_t v39 = a12;
  uint64_t v28 = *(void (**)(void))(*(void *)(a12 - 8) + 16);
  uint64_t v45 = v27;
  v28();
  v42(v20, (uint64_t)v47, a9);
  uint64_t v47 = &v20[TupleTypeMetadata[12]];
  uint64_t v48 = a10;
  v40();
  uint64_t v29 = (uint64_t)&v20[TupleTypeMetadata[16]];
  uint64_t v30 = v49;
  uint64_t v49 = a11;
  ((void (*)(uint64_t, uint64_t, uint64_t))v26)(v29, v30, a11);
  uint64_t v31 = v39;
  uint64_t v32 = (uint64_t)&v20[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v28)(v32, v51, v39);
  uint64_t v33 = v50;
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v50 + 8) + 8))(v22, v20, a9)) {
    char v34 = >= infix<A, B, C>(_:_:)(v38, (uint64_t)v44, v45, (uint64_t)v47, v29, v32, v48, v49, v31, a14, a15, a16);
  }
  else {
    char v34 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v33 + 32))(v22, v20, a9, v33);
  }
  char v35 = v34;
  uint64_t v36 = *(void (**)(char *, int *))(v52 + 8);
  v36(v20, TupleTypeMetadata);
  v36(v22, TupleTypeMetadata);
  return v35 & 1;
}

uint64_t == infix<A, B, C, D, E>(_:_:)(uint64_t a1, uint64_t a2, void (*a3)(void), uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  char v55 = a6;
  uint64_t v56 = a7;
  uint64_t v53 = a4;
  uint64_t v54 = (char *)a5;
  uint64_t v51 = a3;
  uint64_t v52 = a2;
  uint64_t v50 = a1;
  uint64_t v60 = a16;
  uint64_t v58 = a8;
  uint64_t v59 = a10;
  uint64_t v57 = a9;
  v62[0] = a11;
  v62[1] = a12;
  v62[2] = a13;
  v62[3] = a14;
  v62[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 5, (uint64_t)v62, 0, 0);
  uint64_t v61 = *((void *)TupleTypeMetadata - 1);
  uint64_t v21 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v23 = (char *)&v42 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v21);
  uint64_t v25 = (char *)&v42 - v24;
  uint64_t v26 = *(void *)(a11 - 8);
  uint64_t v48 = *(void (**)(char *, uint64_t, uint64_t))(v26 + 16);
  uint64_t v49 = v26 + 16;
  v48((char *)&v42 - v24, v50, a11);
  uint64_t v27 = (uint64_t)&v25[TupleTypeMetadata[12]];
  uint64_t v28 = *(void *)(a12 - 8);
  uint64_t v47 = *(void (**)(void))(v28 + 16);
  uint64_t v50 = v28 + 16;
  uint64_t v43 = v27;
  v47();
  uint64_t v29 = (uint64_t)&v25[TupleTypeMetadata[16]];
  uint64_t v30 = *(void *)(a13 - 8);
  uint64_t v46 = *(void (**)(void))(v30 + 16);
  uint64_t v52 = v30 + 16;
  uint64_t v42 = v29;
  v46();
  uint64_t v31 = (void (*)(void))&v25[TupleTypeMetadata[20]];
  uint64_t v45 = a14;
  uint64_t v32 = *(void (**)(void))(*(void *)(a14 - 8) + 16);
  uint64_t v51 = v31;
  v32();
  uint64_t v33 = (uint64_t)&v25[TupleTypeMetadata[24]];
  uint64_t v44 = a15;
  char v34 = *(void (**)(void))(*(void *)(a15 - 8) + 16);
  uint64_t v53 = v33;
  v34();
  v48(v23, (uint64_t)v55, a11);
  char v55 = (uint64_t *)&v23[TupleTypeMetadata[12]];
  uint64_t v56 = a12;
  v47();
  uint64_t v54 = &v23[TupleTypeMetadata[16]];
  uint64_t v58 = a13;
  v46();
  uint64_t v35 = v45;
  uint64_t v36 = (uint64_t)&v23[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v32)(v36, v57, v45);
  uint64_t v37 = v44;
  uint64_t v38 = (uint64_t)&v23[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v34)(v38, v59, v44);
  if ((*(uint64_t (**)(char *, char *, uint64_t))(v60 + 8))(v25, v23, a11)) {
    char v39 = == infix<A, B, C, D>(_:_:)(v43, v42, v51, v53, v55, (uint64_t)v54, v36, v38, v56, v58, v35, v37, a17, a18, a19, a20);
  }
  else {
    char v39 = 0;
  }
  char v40 = *(void (**)(char *, int *))(v61 + 8);
  v40(v23, TupleTypeMetadata);
  v40(v25, TupleTypeMetadata);
  return v39 & 1;
}

uint64_t != infix<A, B, C, D, E>(_:_:)(uint64_t a1, uint64_t a2, void (*a3)(void), uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  char v55 = a6;
  uint64_t v56 = a7;
  uint64_t v53 = a4;
  uint64_t v54 = (char *)a5;
  uint64_t v51 = a3;
  uint64_t v52 = a2;
  uint64_t v50 = a1;
  uint64_t v60 = a16;
  uint64_t v58 = a8;
  uint64_t v59 = a10;
  uint64_t v57 = a9;
  v62[0] = a11;
  v62[1] = a12;
  v62[2] = a13;
  v62[3] = a14;
  v62[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 5, (uint64_t)v62, 0, 0);
  uint64_t v61 = *((void *)TupleTypeMetadata - 1);
  uint64_t v21 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v23 = (char *)&v42 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v21);
  uint64_t v25 = (char *)&v42 - v24;
  uint64_t v26 = *(void *)(a11 - 8);
  uint64_t v48 = *(void (**)(char *, uint64_t, uint64_t))(v26 + 16);
  uint64_t v49 = v26 + 16;
  v48((char *)&v42 - v24, v50, a11);
  uint64_t v27 = (uint64_t)&v25[TupleTypeMetadata[12]];
  uint64_t v28 = *(void *)(a12 - 8);
  uint64_t v47 = *(void (**)(void))(v28 + 16);
  uint64_t v50 = v28 + 16;
  uint64_t v43 = v27;
  v47();
  uint64_t v29 = (uint64_t)&v25[TupleTypeMetadata[16]];
  uint64_t v30 = *(void *)(a13 - 8);
  uint64_t v46 = *(void (**)(void))(v30 + 16);
  uint64_t v52 = v30 + 16;
  uint64_t v42 = v29;
  v46();
  uint64_t v31 = (void (*)(void))&v25[TupleTypeMetadata[20]];
  uint64_t v45 = a14;
  uint64_t v32 = *(void (**)(void))(*(void *)(a14 - 8) + 16);
  uint64_t v51 = v31;
  v32();
  uint64_t v33 = (uint64_t)&v25[TupleTypeMetadata[24]];
  uint64_t v44 = a15;
  char v34 = *(void (**)(void))(*(void *)(a15 - 8) + 16);
  uint64_t v53 = v33;
  v34();
  v48(v23, (uint64_t)v55, a11);
  char v55 = (uint64_t *)&v23[TupleTypeMetadata[12]];
  uint64_t v56 = a12;
  v47();
  uint64_t v54 = &v23[TupleTypeMetadata[16]];
  uint64_t v58 = a13;
  v46();
  uint64_t v35 = v45;
  uint64_t v36 = (uint64_t)&v23[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v32)(v36, v57, v45);
  uint64_t v37 = v44;
  uint64_t v38 = (uint64_t)&v23[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v34)(v38, v59, v44);
  if ((*(uint64_t (**)(char *, char *, uint64_t))(v60 + 8))(v25, v23, a11)) {
    char v39 = != infix<A, B, C, D>(_:_:)(v43, v42, v51, v53, v55, (uint64_t)v54, v36, v38, v56, v58, v35, v37, a17, a18, a19, a20);
  }
  else {
    char v39 = 1;
  }
  char v40 = *(void (**)(char *, int *))(v61 + 8);
  v40(v23, TupleTypeMetadata);
  v40(v25, TupleTypeMetadata);
  return v39 & 1;
}

uint64_t < infix<A, B, C, D, E>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  uint64_t v52 = (char *)a6;
  uint64_t v53 = a7;
  uint64_t v50 = (char *)a4;
  uint64_t v51 = (char *)a5;
  uint64_t v48 = a3;
  uint64_t v49 = a2;
  uint64_t v47 = a1;
  uint64_t v57 = a16;
  uint64_t v55 = a8;
  uint64_t v56 = a10;
  uint64_t v54 = a9;
  v61[0] = a11;
  v61[1] = a12;
  v61[2] = a13;
  v61[3] = a14;
  v61[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 5, (uint64_t)v61, 0, 0);
  uint64_t v58 = *((void *)TupleTypeMetadata - 1);
  uint64_t v21 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v23 = (char *)&v41 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v21);
  uint64_t v25 = (char *)&v41 - v24;
  uint64_t v26 = *(void *)(a11 - 8);
  uint64_t v45 = *(void (**)(char *, uint64_t, uint64_t))(v26 + 16);
  uint64_t v46 = v26 + 16;
  v45((char *)&v41 - v24, v47, a11);
  uint64_t v27 = (uint64_t)&v25[TupleTypeMetadata[12]];
  uint64_t v28 = *(void *)(a12 - 8);
  uint64_t v44 = *(void (**)(void))(v28 + 16);
  uint64_t v47 = v28 + 16;
  uint64_t v42 = v27;
  v44();
  uint64_t v29 = (uint64_t)&v25[TupleTypeMetadata[16]];
  uint64_t v59 = a13;
  uint64_t v30 = *(void *)(a13 - 8);
  uint64_t v43 = *(void (**)(void))(v30 + 16);
  uint64_t v49 = v30 + 16;
  uint64_t v41 = v29;
  v43();
  uint64_t v31 = (uint64_t)&v25[TupleTypeMetadata[20]];
  uint64_t v60 = a14;
  uint64_t v32 = *(void (**)(void))(*(void *)(a14 - 8) + 16);
  uint64_t v48 = v31;
  v32();
  uint64_t v33 = *(void (**)(void))(*(void *)(a15 - 8) + 16);
  uint64_t v50 = &v25[TupleTypeMetadata[24]];
  v33();
  v45(v23, (uint64_t)v52, a11);
  uint64_t v52 = &v23[TupleTypeMetadata[12]];
  uint64_t v53 = a12;
  v44();
  uint64_t v51 = &v23[TupleTypeMetadata[16]];
  v43();
  uint64_t v34 = (uint64_t)&v23[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v32)(v34, v54, v60);
  uint64_t v35 = (uint64_t)&v23[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v33)(v35, v56, a15);
  uint64_t v36 = v57;
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v57 + 8) + 8))(v25, v23, a11)) {
    char v37 = < infix<A, B, C, D>(_:_:)(v42, v41, v48, (uint64_t)v50, (uint64_t)v52, (uint64_t)v51, v34, v35, v53, v59, v60, a15, a17, a18, a19, a20);
  }
  else {
    char v37 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v36 + 16))(v25, v23, a11, v36);
  }
  char v38 = v37;
  char v39 = *(void (**)(char *, int *))(v58 + 8);
  v39(v23, TupleTypeMetadata);
  v39(v25, TupleTypeMetadata);
  return v38 & 1;
}

uint64_t <= infix<A, B, C, D, E>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  uint64_t v52 = (char *)a6;
  uint64_t v53 = a7;
  uint64_t v50 = (char *)a4;
  uint64_t v51 = (char *)a5;
  uint64_t v48 = a3;
  uint64_t v49 = a2;
  uint64_t v47 = a1;
  uint64_t v57 = a16;
  uint64_t v55 = a8;
  uint64_t v56 = a10;
  uint64_t v54 = a9;
  v61[0] = a11;
  v61[1] = a12;
  v61[2] = a13;
  v61[3] = a14;
  v61[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 5, (uint64_t)v61, 0, 0);
  uint64_t v58 = *((void *)TupleTypeMetadata - 1);
  uint64_t v21 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v23 = (char *)&v41 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v21);
  uint64_t v25 = (char *)&v41 - v24;
  uint64_t v26 = *(void *)(a11 - 8);
  uint64_t v45 = *(void (**)(char *, uint64_t, uint64_t))(v26 + 16);
  uint64_t v46 = v26 + 16;
  v45((char *)&v41 - v24, v47, a11);
  uint64_t v27 = (uint64_t)&v25[TupleTypeMetadata[12]];
  uint64_t v28 = *(void *)(a12 - 8);
  uint64_t v44 = *(void (**)(void))(v28 + 16);
  uint64_t v47 = v28 + 16;
  uint64_t v42 = v27;
  v44();
  uint64_t v29 = (uint64_t)&v25[TupleTypeMetadata[16]];
  uint64_t v59 = a13;
  uint64_t v30 = *(void *)(a13 - 8);
  uint64_t v43 = *(void (**)(void))(v30 + 16);
  uint64_t v49 = v30 + 16;
  uint64_t v41 = v29;
  v43();
  uint64_t v31 = (uint64_t)&v25[TupleTypeMetadata[20]];
  uint64_t v60 = a14;
  uint64_t v32 = *(void (**)(void))(*(void *)(a14 - 8) + 16);
  uint64_t v48 = v31;
  v32();
  uint64_t v33 = *(void (**)(void))(*(void *)(a15 - 8) + 16);
  uint64_t v50 = &v25[TupleTypeMetadata[24]];
  v33();
  v45(v23, (uint64_t)v52, a11);
  uint64_t v52 = &v23[TupleTypeMetadata[12]];
  uint64_t v53 = a12;
  v44();
  uint64_t v51 = &v23[TupleTypeMetadata[16]];
  v43();
  uint64_t v34 = (uint64_t)&v23[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v32)(v34, v54, v60);
  uint64_t v35 = (uint64_t)&v23[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v33)(v35, v56, a15);
  uint64_t v36 = v57;
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v57 + 8) + 8))(v25, v23, a11)) {
    char v37 = <= infix<A, B, C, D>(_:_:)(v42, v41, v48, (uint64_t)v50, (uint64_t)v52, (uint64_t)v51, v34, v35, v53, v59, v60, a15, a17, a18, a19, a20);
  }
  else {
    char v37 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v36 + 24))(v25, v23, a11, v36);
  }
  char v38 = v37;
  char v39 = *(void (**)(char *, int *))(v58 + 8);
  v39(v23, TupleTypeMetadata);
  v39(v25, TupleTypeMetadata);
  return v38 & 1;
}

uint64_t > infix<A, B, C, D, E>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  uint64_t v52 = (char *)a6;
  uint64_t v53 = a7;
  uint64_t v50 = (char *)a4;
  uint64_t v51 = (char *)a5;
  uint64_t v48 = a3;
  uint64_t v49 = a2;
  uint64_t v47 = a1;
  uint64_t v57 = a16;
  uint64_t v55 = a8;
  uint64_t v56 = a10;
  uint64_t v54 = a9;
  v61[0] = a11;
  v61[1] = a12;
  v61[2] = a13;
  v61[3] = a14;
  v61[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 5, (uint64_t)v61, 0, 0);
  uint64_t v58 = *((void *)TupleTypeMetadata - 1);
  uint64_t v21 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v23 = (char *)&v41 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v21);
  uint64_t v25 = (char *)&v41 - v24;
  uint64_t v26 = *(void *)(a11 - 8);
  uint64_t v45 = *(void (**)(char *, uint64_t, uint64_t))(v26 + 16);
  uint64_t v46 = v26 + 16;
  v45((char *)&v41 - v24, v47, a11);
  uint64_t v27 = (uint64_t)&v25[TupleTypeMetadata[12]];
  uint64_t v28 = *(void *)(a12 - 8);
  uint64_t v44 = *(void (**)(void))(v28 + 16);
  uint64_t v47 = v28 + 16;
  uint64_t v42 = v27;
  v44();
  uint64_t v29 = (uint64_t)&v25[TupleTypeMetadata[16]];
  uint64_t v59 = a13;
  uint64_t v30 = *(void *)(a13 - 8);
  uint64_t v43 = *(void (**)(void))(v30 + 16);
  uint64_t v49 = v30 + 16;
  uint64_t v41 = v29;
  v43();
  uint64_t v31 = (uint64_t)&v25[TupleTypeMetadata[20]];
  uint64_t v60 = a14;
  uint64_t v32 = *(void (**)(void))(*(void *)(a14 - 8) + 16);
  uint64_t v48 = v31;
  v32();
  uint64_t v33 = *(void (**)(void))(*(void *)(a15 - 8) + 16);
  uint64_t v50 = &v25[TupleTypeMetadata[24]];
  v33();
  v45(v23, (uint64_t)v52, a11);
  uint64_t v52 = &v23[TupleTypeMetadata[12]];
  uint64_t v53 = a12;
  v44();
  uint64_t v51 = &v23[TupleTypeMetadata[16]];
  v43();
  uint64_t v34 = (uint64_t)&v23[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v32)(v34, v54, v60);
  uint64_t v35 = (uint64_t)&v23[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v33)(v35, v56, a15);
  uint64_t v36 = v57;
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v57 + 8) + 8))(v25, v23, a11)) {
    char v37 = > infix<A, B, C, D>(_:_:)(v42, v41, v48, (uint64_t)v50, (uint64_t)v52, (uint64_t)v51, v34, v35, v53, v59, v60, a15, a17, a18, a19, a20);
  }
  else {
    char v37 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v36 + 40))(v25, v23, a11, v36);
  }
  char v38 = v37;
  char v39 = *(void (**)(char *, int *))(v58 + 8);
  v39(v23, TupleTypeMetadata);
  v39(v25, TupleTypeMetadata);
  return v38 & 1;
}

uint64_t >= infix<A, B, C, D, E>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  uint64_t v52 = (char *)a6;
  uint64_t v53 = a7;
  uint64_t v50 = (char *)a4;
  uint64_t v51 = (char *)a5;
  uint64_t v48 = a3;
  uint64_t v49 = a2;
  uint64_t v47 = a1;
  uint64_t v57 = a16;
  uint64_t v55 = a8;
  uint64_t v56 = a10;
  uint64_t v54 = a9;
  v61[0] = a11;
  v61[1] = a12;
  v61[2] = a13;
  v61[3] = a14;
  v61[4] = a15;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 5, (uint64_t)v61, 0, 0);
  uint64_t v58 = *((void *)TupleTypeMetadata - 1);
  uint64_t v21 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v23 = (char *)&v41 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v21);
  uint64_t v25 = (char *)&v41 - v24;
  uint64_t v26 = *(void *)(a11 - 8);
  uint64_t v45 = *(void (**)(char *, uint64_t, uint64_t))(v26 + 16);
  uint64_t v46 = v26 + 16;
  v45((char *)&v41 - v24, v47, a11);
  uint64_t v27 = (uint64_t)&v25[TupleTypeMetadata[12]];
  uint64_t v28 = *(void *)(a12 - 8);
  uint64_t v44 = *(void (**)(void))(v28 + 16);
  uint64_t v47 = v28 + 16;
  uint64_t v42 = v27;
  v44();
  uint64_t v29 = (uint64_t)&v25[TupleTypeMetadata[16]];
  uint64_t v59 = a13;
  uint64_t v30 = *(void *)(a13 - 8);
  uint64_t v43 = *(void (**)(void))(v30 + 16);
  uint64_t v49 = v30 + 16;
  uint64_t v41 = v29;
  v43();
  uint64_t v31 = (uint64_t)&v25[TupleTypeMetadata[20]];
  uint64_t v60 = a14;
  uint64_t v32 = *(void (**)(void))(*(void *)(a14 - 8) + 16);
  uint64_t v48 = v31;
  v32();
  uint64_t v33 = *(void (**)(void))(*(void *)(a15 - 8) + 16);
  uint64_t v50 = &v25[TupleTypeMetadata[24]];
  v33();
  v45(v23, (uint64_t)v52, a11);
  uint64_t v52 = &v23[TupleTypeMetadata[12]];
  uint64_t v53 = a12;
  v44();
  uint64_t v51 = &v23[TupleTypeMetadata[16]];
  v43();
  uint64_t v34 = (uint64_t)&v23[TupleTypeMetadata[20]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v32)(v34, v54, v60);
  uint64_t v35 = (uint64_t)&v23[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v33)(v35, v56, a15);
  uint64_t v36 = v57;
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v57 + 8) + 8))(v25, v23, a11)) {
    char v37 = >= infix<A, B, C, D>(_:_:)(v42, v41, v48, (uint64_t)v50, (uint64_t)v52, (uint64_t)v51, v34, v35, v53, v59, v60, a15, a17, a18, a19, a20);
  }
  else {
    char v37 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v36 + 32))(v25, v23, a11, v36);
  }
  char v38 = v37;
  char v39 = *(void (**)(char *, int *))(v58 + 8);
  v39(v23, TupleTypeMetadata);
  v39(v25, TupleTypeMetadata);
  return v38 & 1;
}

uint64_t == infix<A, B, C, D, E, F>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  uint64_t v64 = a8;
  uint64_t v62 = a7;
  uint64_t v59 = (char *)a5;
  uint64_t v60 = a6;
  uint64_t v57 = a3;
  uint64_t v58 = a4;
  uint64_t v56 = a2;
  uint64_t v66 = a12;
  uint64_t v67 = a19;
  uint64_t v65 = a11;
  uint64_t v63 = a10;
  uint64_t v61 = (char *)a9;
  uint64_t v71 = a18;
  v72[0] = a13;
  v72[1] = a14;
  v72[2] = a15;
  v72[3] = a16;
  v72[4] = a17;
  v72[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 6, (uint64_t)v72, 0, 0);
  uint64_t v68 = *((void *)TupleTypeMetadata - 1);
  uint64_t v26 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v28 = (char *)&v47 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v26);
  uint64_t v30 = (char *)&v47 - v29;
  uint64_t v31 = *(void *)(a13 - 8);
  uint64_t v54 = *(void (**)(char *, uint64_t, uint64_t))(v31 + 16);
  uint64_t v55 = (char *)(v31 + 16);
  v54((char *)&v47 - v29, a1, a13);
  uint64_t v32 = (uint64_t)&v30[TupleTypeMetadata[12]];
  uint64_t v33 = *(void *)(a14 - 8);
  uint64_t v52 = *(void (**)(void))(v33 + 16);
  uint64_t v53 = v33 + 16;
  uint64_t v49 = v32;
  v52();
  uint64_t v34 = (uint64_t)&v30[TupleTypeMetadata[16]];
  uint64_t v35 = *(void *)(a15 - 8);
  uint64_t v51 = *(void (**)(void))(v35 + 16);
  uint64_t v56 = v35 + 16;
  uint64_t v48 = v34;
  v51();
  uint64_t v36 = (void (*)(void))&v30[TupleTypeMetadata[20]];
  uint64_t v69 = a16;
  uint64_t v37 = *(void *)(a16 - 8);
  uint64_t v50 = *(void (**)(void))(v37 + 16);
  uint64_t v57 = v37 + 16;
  uint64_t v47 = v36;
  v50();
  uint64_t v38 = (uint64_t)&v30[TupleTypeMetadata[24]];
  uint64_t v70 = a17;
  char v39 = *(void (**)(void))(*(void *)(a17 - 8) + 16);
  uint64_t v58 = v38;
  v39();
  char v40 = *(void (**)(void))(*(void *)(v71 - 8) + 16);
  uint64_t v59 = &v30[TupleTypeMetadata[28]];
  v40();
  v54(v28, v62, a13);
  uint64_t v60 = (uint64_t *)&v28[TupleTypeMetadata[12]];
  uint64_t v62 = a14;
  v52();
  uint64_t v55 = &v28[TupleTypeMetadata[16]];
  uint64_t v64 = a15;
  v51();
  uint64_t v61 = &v28[TupleTypeMetadata[20]];
  v50();
  uint64_t v41 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v39)(v41, v65, v70);
  uint64_t v42 = v71;
  uint64_t v43 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v40)(v43, v66, v71);
  if ((*(uint64_t (**)(char *, char *, uint64_t))(v67 + 8))(v30, v28, a13)) {
    char v44 = == infix<A, B, C, D, E>(_:_:)(v49, v48, v47, v58, (uint64_t)v59, v60, (uint64_t)v55, (uint64_t)v61, v41, v43, v62, v64, v69, v70, v42, a20, a21, a22, a23,
  }
            a24);
  else {
    char v44 = 0;
  }
  uint64_t v45 = *(void (**)(char *, int *))(v68 + 8);
  v45(v28, TupleTypeMetadata);
  v45(v30, TupleTypeMetadata);
  return v44 & 1;
}

uint64_t != infix<A, B, C, D, E, F>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  uint64_t v64 = a8;
  uint64_t v62 = a7;
  uint64_t v59 = (char *)a5;
  uint64_t v60 = a6;
  uint64_t v57 = a3;
  uint64_t v58 = a4;
  uint64_t v56 = a2;
  uint64_t v66 = a12;
  uint64_t v67 = a19;
  uint64_t v65 = a11;
  uint64_t v63 = a10;
  uint64_t v61 = (char *)a9;
  uint64_t v71 = a18;
  v72[0] = a13;
  v72[1] = a14;
  v72[2] = a15;
  v72[3] = a16;
  v72[4] = a17;
  v72[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 6, (uint64_t)v72, 0, 0);
  uint64_t v68 = *((void *)TupleTypeMetadata - 1);
  uint64_t v26 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v28 = (char *)&v47 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v26);
  uint64_t v30 = (char *)&v47 - v29;
  uint64_t v31 = *(void *)(a13 - 8);
  uint64_t v54 = *(void (**)(char *, uint64_t, uint64_t))(v31 + 16);
  uint64_t v55 = (char *)(v31 + 16);
  v54((char *)&v47 - v29, a1, a13);
  uint64_t v32 = (uint64_t)&v30[TupleTypeMetadata[12]];
  uint64_t v33 = *(void *)(a14 - 8);
  uint64_t v52 = *(void (**)(void))(v33 + 16);
  uint64_t v53 = v33 + 16;
  uint64_t v49 = v32;
  v52();
  uint64_t v34 = (uint64_t)&v30[TupleTypeMetadata[16]];
  uint64_t v35 = *(void *)(a15 - 8);
  uint64_t v51 = *(void (**)(void))(v35 + 16);
  uint64_t v56 = v35 + 16;
  uint64_t v48 = v34;
  v51();
  uint64_t v36 = (void (*)(void))&v30[TupleTypeMetadata[20]];
  uint64_t v69 = a16;
  uint64_t v37 = *(void *)(a16 - 8);
  uint64_t v50 = *(void (**)(void))(v37 + 16);
  uint64_t v57 = v37 + 16;
  uint64_t v47 = v36;
  v50();
  uint64_t v38 = (uint64_t)&v30[TupleTypeMetadata[24]];
  uint64_t v70 = a17;
  char v39 = *(void (**)(void))(*(void *)(a17 - 8) + 16);
  uint64_t v58 = v38;
  v39();
  char v40 = *(void (**)(void))(*(void *)(v71 - 8) + 16);
  uint64_t v59 = &v30[TupleTypeMetadata[28]];
  v40();
  v54(v28, v62, a13);
  uint64_t v60 = (uint64_t *)&v28[TupleTypeMetadata[12]];
  uint64_t v62 = a14;
  v52();
  uint64_t v55 = &v28[TupleTypeMetadata[16]];
  uint64_t v64 = a15;
  v51();
  uint64_t v61 = &v28[TupleTypeMetadata[20]];
  v50();
  uint64_t v41 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v39)(v41, v65, v70);
  uint64_t v42 = v71;
  uint64_t v43 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v40)(v43, v66, v71);
  if ((*(uint64_t (**)(char *, char *, uint64_t))(v67 + 8))(v30, v28, a13)) {
    char v44 = != infix<A, B, C, D, E>(_:_:)(v49, v48, v47, v58, (uint64_t)v59, v60, (uint64_t)v55, (uint64_t)v61, v41, v43, v62, v64, v69, v70, v42, a20, a21, a22, a23,
  }
            a24);
  else {
    char v44 = 1;
  }
  uint64_t v45 = *(void (**)(char *, int *))(v68 + 8);
  v45(v28, TupleTypeMetadata);
  v45(v30, TupleTypeMetadata);
  return v44 & 1;
}

uint64_t < infix<A, B, C, D, E, F>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  uint64_t v66 = a8;
  uint64_t v64 = a7;
  uint64_t v61 = (char *)a5;
  uint64_t v62 = (char *)a6;
  uint64_t v59 = a3;
  uint64_t v60 = a4;
  uint64_t v58 = a2;
  uint64_t v68 = a12;
  uint64_t v69 = a19;
  uint64_t v67 = a11;
  uint64_t v65 = a10;
  uint64_t v63 = (char *)a9;
  uint64_t v73 = a18;
  v74[0] = a13;
  v74[1] = a14;
  v74[2] = a15;
  v74[3] = a16;
  v74[4] = a17;
  v74[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 6, (uint64_t)v74, 0, 0);
  uint64_t v70 = *((void *)TupleTypeMetadata - 1);
  uint64_t v26 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v28 = (char *)&v49 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v26);
  uint64_t v30 = (char *)&v49 - v29;
  uint64_t v31 = *(void *)(a13 - 8);
  uint64_t v56 = *(void (**)(char *, uint64_t, uint64_t))(v31 + 16);
  uint64_t v57 = (char *)(v31 + 16);
  v56((char *)&v49 - v29, a1, a13);
  uint64_t v32 = (uint64_t)&v30[TupleTypeMetadata[12]];
  uint64_t v33 = *(void *)(a14 - 8);
  uint64_t v54 = *(void (**)(void))(v33 + 16);
  uint64_t v55 = v33 + 16;
  uint64_t v51 = v32;
  v54();
  uint64_t v34 = (uint64_t)&v30[TupleTypeMetadata[16]];
  uint64_t v35 = *(void *)(a15 - 8);
  uint64_t v53 = *(void (**)(void))(v35 + 16);
  uint64_t v58 = v35 + 16;
  uint64_t v50 = v34;
  v53();
  uint64_t v36 = (uint64_t)&v30[TupleTypeMetadata[20]];
  uint64_t v71 = a16;
  uint64_t v37 = *(void *)(a16 - 8);
  uint64_t v52 = *(void (**)(void))(v37 + 16);
  uint64_t v59 = v37 + 16;
  uint64_t v49 = v36;
  v52();
  uint64_t v38 = (uint64_t)&v30[TupleTypeMetadata[24]];
  uint64_t v72 = a17;
  char v39 = *(void (**)(void))(*(void *)(a17 - 8) + 16);
  uint64_t v60 = v38;
  v39();
  char v40 = *(void (**)(void))(*(void *)(v73 - 8) + 16);
  uint64_t v61 = &v30[TupleTypeMetadata[28]];
  v40();
  v56(v28, v64, a13);
  uint64_t v62 = &v28[TupleTypeMetadata[12]];
  uint64_t v64 = a14;
  v54();
  uint64_t v57 = &v28[TupleTypeMetadata[16]];
  uint64_t v66 = a15;
  v53();
  uint64_t v63 = &v28[TupleTypeMetadata[20]];
  v52();
  uint64_t v41 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v39)(v41, v67, v72);
  uint64_t v42 = v73;
  uint64_t v43 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v40)(v43, v68, v73);
  uint64_t v44 = v69;
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v69 + 8) + 8))(v30, v28, a13)) {
    char v45 = < infix<A, B, C, D, E>(_:_:)(v51, v50, v49, v60, (uint64_t)v61, (uint64_t)v62, (uint64_t)v57, (uint64_t)v63, v41, v43, v64, v66, v71, v72, v42, a20, a21, a22, a23,
  }
            a24);
  else {
    char v45 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v44 + 16))(v30, v28, a13, v44);
  }
  char v46 = v45;
  uint64_t v47 = *(void (**)(char *, int *))(v70 + 8);
  v47(v28, TupleTypeMetadata);
  v47(v30, TupleTypeMetadata);
  return v46 & 1;
}

uint64_t <= infix<A, B, C, D, E, F>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  uint64_t v66 = a8;
  uint64_t v64 = a7;
  uint64_t v61 = (char *)a5;
  uint64_t v62 = (char *)a6;
  uint64_t v59 = a3;
  uint64_t v60 = a4;
  uint64_t v58 = a2;
  uint64_t v68 = a12;
  uint64_t v69 = a19;
  uint64_t v67 = a11;
  uint64_t v65 = a10;
  uint64_t v63 = (char *)a9;
  uint64_t v73 = a18;
  v74[0] = a13;
  v74[1] = a14;
  v74[2] = a15;
  v74[3] = a16;
  v74[4] = a17;
  v74[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 6, (uint64_t)v74, 0, 0);
  uint64_t v70 = *((void *)TupleTypeMetadata - 1);
  uint64_t v26 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v28 = (char *)&v49 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v26);
  uint64_t v30 = (char *)&v49 - v29;
  uint64_t v31 = *(void *)(a13 - 8);
  uint64_t v56 = *(void (**)(char *, uint64_t, uint64_t))(v31 + 16);
  uint64_t v57 = (char *)(v31 + 16);
  v56((char *)&v49 - v29, a1, a13);
  uint64_t v32 = (uint64_t)&v30[TupleTypeMetadata[12]];
  uint64_t v33 = *(void *)(a14 - 8);
  uint64_t v54 = *(void (**)(void))(v33 + 16);
  uint64_t v55 = v33 + 16;
  uint64_t v51 = v32;
  v54();
  uint64_t v34 = (uint64_t)&v30[TupleTypeMetadata[16]];
  uint64_t v35 = *(void *)(a15 - 8);
  uint64_t v53 = *(void (**)(void))(v35 + 16);
  uint64_t v58 = v35 + 16;
  uint64_t v50 = v34;
  v53();
  uint64_t v36 = (uint64_t)&v30[TupleTypeMetadata[20]];
  uint64_t v71 = a16;
  uint64_t v37 = *(void *)(a16 - 8);
  uint64_t v52 = *(void (**)(void))(v37 + 16);
  uint64_t v59 = v37 + 16;
  uint64_t v49 = v36;
  v52();
  uint64_t v38 = (uint64_t)&v30[TupleTypeMetadata[24]];
  uint64_t v72 = a17;
  char v39 = *(void (**)(void))(*(void *)(a17 - 8) + 16);
  uint64_t v60 = v38;
  v39();
  char v40 = *(void (**)(void))(*(void *)(v73 - 8) + 16);
  uint64_t v61 = &v30[TupleTypeMetadata[28]];
  v40();
  v56(v28, v64, a13);
  uint64_t v62 = &v28[TupleTypeMetadata[12]];
  uint64_t v64 = a14;
  v54();
  uint64_t v57 = &v28[TupleTypeMetadata[16]];
  uint64_t v66 = a15;
  v53();
  uint64_t v63 = &v28[TupleTypeMetadata[20]];
  v52();
  uint64_t v41 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v39)(v41, v67, v72);
  uint64_t v42 = v73;
  uint64_t v43 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v40)(v43, v68, v73);
  uint64_t v44 = v69;
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v69 + 8) + 8))(v30, v28, a13)) {
    char v45 = <= infix<A, B, C, D, E>(_:_:)(v51, v50, v49, v60, (uint64_t)v61, (uint64_t)v62, (uint64_t)v57, (uint64_t)v63, v41, v43, v64, v66, v71, v72, v42, a20, a21, a22, a23,
  }
            a24);
  else {
    char v45 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v44 + 24))(v30, v28, a13, v44);
  }
  char v46 = v45;
  uint64_t v47 = *(void (**)(char *, int *))(v70 + 8);
  v47(v28, TupleTypeMetadata);
  v47(v30, TupleTypeMetadata);
  return v46 & 1;
}

uint64_t > infix<A, B, C, D, E, F>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  uint64_t v66 = a8;
  uint64_t v64 = a7;
  uint64_t v61 = (char *)a5;
  uint64_t v62 = (char *)a6;
  uint64_t v59 = a3;
  uint64_t v60 = a4;
  uint64_t v58 = a2;
  uint64_t v68 = a12;
  uint64_t v69 = a19;
  uint64_t v67 = a11;
  uint64_t v65 = a10;
  uint64_t v63 = (char *)a9;
  uint64_t v73 = a18;
  v74[0] = a13;
  v74[1] = a14;
  v74[2] = a15;
  v74[3] = a16;
  v74[4] = a17;
  v74[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 6, (uint64_t)v74, 0, 0);
  uint64_t v70 = *((void *)TupleTypeMetadata - 1);
  uint64_t v26 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v28 = (char *)&v49 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v26);
  uint64_t v30 = (char *)&v49 - v29;
  uint64_t v31 = *(void *)(a13 - 8);
  uint64_t v56 = *(void (**)(char *, uint64_t, uint64_t))(v31 + 16);
  uint64_t v57 = (char *)(v31 + 16);
  v56((char *)&v49 - v29, a1, a13);
  uint64_t v32 = (uint64_t)&v30[TupleTypeMetadata[12]];
  uint64_t v33 = *(void *)(a14 - 8);
  uint64_t v54 = *(void (**)(void))(v33 + 16);
  uint64_t v55 = v33 + 16;
  uint64_t v51 = v32;
  v54();
  uint64_t v34 = (uint64_t)&v30[TupleTypeMetadata[16]];
  uint64_t v35 = *(void *)(a15 - 8);
  uint64_t v53 = *(void (**)(void))(v35 + 16);
  uint64_t v58 = v35 + 16;
  uint64_t v50 = v34;
  v53();
  uint64_t v36 = (uint64_t)&v30[TupleTypeMetadata[20]];
  uint64_t v71 = a16;
  uint64_t v37 = *(void *)(a16 - 8);
  uint64_t v52 = *(void (**)(void))(v37 + 16);
  uint64_t v59 = v37 + 16;
  uint64_t v49 = v36;
  v52();
  uint64_t v38 = (uint64_t)&v30[TupleTypeMetadata[24]];
  uint64_t v72 = a17;
  char v39 = *(void (**)(void))(*(void *)(a17 - 8) + 16);
  uint64_t v60 = v38;
  v39();
  char v40 = *(void (**)(void))(*(void *)(v73 - 8) + 16);
  uint64_t v61 = &v30[TupleTypeMetadata[28]];
  v40();
  v56(v28, v64, a13);
  uint64_t v62 = &v28[TupleTypeMetadata[12]];
  uint64_t v64 = a14;
  v54();
  uint64_t v57 = &v28[TupleTypeMetadata[16]];
  uint64_t v66 = a15;
  v53();
  uint64_t v63 = &v28[TupleTypeMetadata[20]];
  v52();
  uint64_t v41 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v39)(v41, v67, v72);
  uint64_t v42 = v73;
  uint64_t v43 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v40)(v43, v68, v73);
  uint64_t v44 = v69;
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v69 + 8) + 8))(v30, v28, a13)) {
    char v45 = > infix<A, B, C, D, E>(_:_:)(v51, v50, v49, v60, (uint64_t)v61, (uint64_t)v62, (uint64_t)v57, (uint64_t)v63, v41, v43, v64, v66, v71, v72, v42, a20, a21, a22, a23,
  }
            a24);
  else {
    char v45 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v44 + 40))(v30, v28, a13, v44);
  }
  char v46 = v45;
  uint64_t v47 = *(void (**)(char *, int *))(v70 + 8);
  v47(v28, TupleTypeMetadata);
  v47(v30, TupleTypeMetadata);
  return v46 & 1;
}

uint64_t >= infix<A, B, C, D, E, F>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  uint64_t v66 = a8;
  uint64_t v64 = a7;
  uint64_t v61 = (char *)a5;
  uint64_t v62 = (char *)a6;
  uint64_t v59 = a3;
  uint64_t v60 = a4;
  uint64_t v58 = a2;
  uint64_t v68 = a12;
  uint64_t v69 = a19;
  uint64_t v67 = a11;
  uint64_t v65 = a10;
  uint64_t v63 = (char *)a9;
  uint64_t v73 = a18;
  v74[0] = a13;
  v74[1] = a14;
  v74[2] = a15;
  v74[3] = a16;
  v74[4] = a17;
  v74[5] = a18;
  TupleTypeMetadata = (int *)swift_getTupleTypeMetadata(0, 6, (uint64_t)v74, 0, 0);
  uint64_t v70 = *((void *)TupleTypeMetadata - 1);
  uint64_t v26 = MEMORY[0x1F4188790](TupleTypeMetadata);
  uint64_t v28 = (char *)&v49 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v26);
  uint64_t v30 = (char *)&v49 - v29;
  uint64_t v31 = *(void *)(a13 - 8);
  uint64_t v56 = *(void (**)(char *, uint64_t, uint64_t))(v31 + 16);
  uint64_t v57 = (char *)(v31 + 16);
  v56((char *)&v49 - v29, a1, a13);
  uint64_t v32 = (uint64_t)&v30[TupleTypeMetadata[12]];
  uint64_t v33 = *(void *)(a14 - 8);
  uint64_t v54 = *(void (**)(void))(v33 + 16);
  uint64_t v55 = v33 + 16;
  uint64_t v51 = v32;
  v54();
  uint64_t v34 = (uint64_t)&v30[TupleTypeMetadata[16]];
  uint64_t v35 = *(void *)(a15 - 8);
  uint64_t v53 = *(void (**)(void))(v35 + 16);
  uint64_t v58 = v35 + 16;
  uint64_t v50 = v34;
  v53();
  uint64_t v36 = (uint64_t)&v30[TupleTypeMetadata[20]];
  uint64_t v71 = a16;
  uint64_t v37 = *(void *)(a16 - 8);
  uint64_t v52 = *(void (**)(void))(v37 + 16);
  uint64_t v59 = v37 + 16;
  uint64_t v49 = v36;
  v52();
  uint64_t v38 = (uint64_t)&v30[TupleTypeMetadata[24]];
  uint64_t v72 = a17;
  char v39 = *(void (**)(void))(*(void *)(a17 - 8) + 16);
  uint64_t v60 = v38;
  v39();
  char v40 = *(void (**)(void))(*(void *)(v73 - 8) + 16);
  uint64_t v61 = &v30[TupleTypeMetadata[28]];
  v40();
  v56(v28, v64, a13);
  uint64_t v62 = &v28[TupleTypeMetadata[12]];
  uint64_t v64 = a14;
  v54();
  uint64_t v57 = &v28[TupleTypeMetadata[16]];
  uint64_t v66 = a15;
  v53();
  uint64_t v63 = &v28[TupleTypeMetadata[20]];
  v52();
  uint64_t v41 = (uint64_t)&v28[TupleTypeMetadata[24]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v39)(v41, v67, v72);
  uint64_t v42 = v73;
  uint64_t v43 = (uint64_t)&v28[TupleTypeMetadata[28]];
  ((void (*)(uint64_t, uint64_t, uint64_t))v40)(v43, v68, v73);
  uint64_t v44 = v69;
  if ((*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v69 + 8) + 8))(v30, v28, a13)) {
    char v45 = >= infix<A, B, C, D, E>(_:_:)(v51, v50, v49, v60, (uint64_t)v61, (uint64_t)v62, (uint64_t)v57, (uint64_t)v63, v41, v43, v64, v66, v71, v72, v42, a20, a21, a22, a23,
  }
            a24);
  else {
    char v45 = (*(uint64_t (**)(char *, char *, uint64_t, uint64_t))(v44 + 32))(v30, v28, a13, v44);
  }
  char v46 = v45;
  uint64_t v47 = *(void (**)(char *, int *))(v70 + 8);
  v47(v28, TupleTypeMetadata);
  v47(v30, TupleTypeMetadata);
  return v46 & 1;
}

uint64_t SIMD2._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage, a2);
}

uint64_t SIMD2._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
}

uint64_t (*SIMD2._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD2.scalarCount.getter()
{
  return 2;
}

uint64_t key path getter for SIMD2.subscript(_:) : <A>SIMD2<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  if ((unint64_t)*a2 >= 2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x28uLL, 0);
  }
  uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  uint64_t v4 = *(int ***)((char *)a2 + a3 - 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  unint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD2.subscript(_:) : <A>SIMD2<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + a3 - 16);
  uint64_t v5 = *(int ***)(a4 + a3 - 8);
  MEMORY[0x1F4188790](a1);
  unint64_t v7 = (char *)&v17 - v6;
  unint64_t v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x2CuLL, 0);
  }
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v14 = *(uint64_t (**)(char *, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v15 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD2.subscript.modify(void *a1, unint64_t a2, uint64_t a3))()
{
  unint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *unint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x28uLL, 0);
  }
  uint64_t v10 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD2.init(_:_:)(const void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  size_t v8 = *(void *)(*(void *)(a3 - 8) + 64);
  MEMORY[0x1F4188790](a1);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v10, v9, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), a1, v8);
  uint64_t v13 = *(uint64_t (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  v13((char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), a2, v8);
  return v13((char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), 1, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t SIMD2.x.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD2Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage, 0);
}

uint64_t key path getter for SIMD2.x : <A>SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, associated type descriptor for SIMDScalar.SIMD2Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage, 0);
}

uint64_t key path setter for SIMD2.x : <A>SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, a4, associated type descriptor for SIMDScalar.SIMD2Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage, 0);
}

uint64_t SIMD2.x.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD2Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage, 0);
}

void (*SIMD2.x.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  size_t v8 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  size_t v11 = *(void (**)(void, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v5[5] = v12;
  v11(0, v12, AssociatedConformanceWitness);
  return SIMD2.x.modify;
}

void SIMD2.x.modify(uint64_t a1, uint64_t a2)
{
}

uint64_t SIMD2.y.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD2Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage, 1);
}

uint64_t key path getter for SIMD2.y : <A>SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, associated type descriptor for SIMDScalar.SIMD2Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage, 1);
}

uint64_t key path setter for SIMD2.y : <A>SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, a4, associated type descriptor for SIMDScalar.SIMD2Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage, 1);
}

uint64_t SIMD2.y.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD2Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage, 1);
}

void (*SIMD2.y.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  size_t v8 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  size_t v11 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v5[5] = v12;
  v11(1, v12, AssociatedConformanceWitness);
  return SIMD2.y.modify;
}

void SIMD2.y.modify(uint64_t a1, uint64_t a2)
{
}

Swift::Int SIMD2.hashValue.getter(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, protocol conformance descriptor for SIMD2<A>, a3);
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD2<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>(a1, a2, associated type descriptor for SIMDScalar.SIMD2Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD2<A>(unint64_t a1, uint64_t a2)
{
  if (a1 >= 2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x28uLL, 0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  size_t v7 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD2<A>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x2CuLL, 0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  size_t v11 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD2<A>(void *a1, unint64_t a2, uint64_t a3))()
{
  size_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *size_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x28uLL, 0);
  }
  uint64_t v10 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD2<A>(void *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD2<A>, a2, a3);
  return SIMD.encode(to:)(a1, (uint64_t)a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD2<A>@<X0>(uint64_t *a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD2<A>, a2, a3);
  return SIMD.init(from:)(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD2<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD2<A>, a2, a3);

  return SIMD.hash(into:)(a1, (uint64_t)a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD2<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(a1, a2, a3, protocol conformance descriptor for SIMD2<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD2<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD2<A>, a1, a3);

  return SIMD.description.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD2<A>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD2<A>, a2, a3);

  return SIMD.init(arrayLiteral:)(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v5 = a1;
  uint64_t v43 = *(void *)(a3 + 16);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v50 = (char *)&v39 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  uint64_t v49 = (char *)&v39 - v9;
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v8);
  uint64_t v14 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v39 - v16;
  uint64_t v18 = 0;
  uint64_t v20 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v11 += 16;
  uint64_t v19 = v20;
  char v46 = (void (**)(char *, uint64_t))(v11 - 8);
  uint64_t v47 = v21;
  char v22 = 1;
  uint64_t v44 = v23;
  uint64_t v41 = v11;
  uint64_t v42 = v15;
  uint64_t v48 = v14;
  char v40 = v20;
  v20((char *)&v39 - v16, v5, v3);
  while (1)
  {
    v19(v14, a2, v3);
    if (v22)
    {
      uint64_t v25 = *(int ***)(v3 + 24);
      char v45 = v25;
      uint64_t v26 = v43;
      AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v25, v43, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v25, v26, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
      uint64_t v29 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
      uint64_t v30 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
      v29(v18, v30, AssociatedConformanceWitness);
      uint64_t v31 = *v46;
      (*v46)(v17, v47);
      uint64_t v32 = AssociatedConformanceWitness;
      uint64_t v19 = v40;
      v29(v18, v30, v32);
      uint64_t v3 = v47;
      uint64_t v14 = v48;
      v31(v48, v47);
      uint64_t v5 = v42;
      uint64_t v33 = v45;
      uint64_t v34 = swift_getAssociatedTypeWitness(255, v45, v26, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
      uint64_t v35 = (uint64_t)v33;
      a2 = v44;
      uint64_t v36 = swift_getAssociatedConformanceWitness(v35, v26, (uint64_t)v34, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      uint64_t v37 = swift_getAssociatedConformanceWitness(v36, (uint64_t)v34, v26, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      char v22 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v37 + 8) + 8))(v49, v50, v26);
    }
    else
    {
      uint64_t v24 = *v46;
      (*v46)(v14, v3);
      v24(v17, v3);
      char v22 = 0;
    }
    if (++v18 == 2) {
      break;
    }
    v19(v17, v5, v3);
  }
  return v22 & 1;
}

uint64_t SIMD2<>.init<A>(truncatingIfNeeded:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v40 = a4;
  uint64_t v41 = a6;
  uint64_t v45 = a1;
  uint64_t v37 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v32 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v42 = v15;
  MEMORY[0x1F4188790](v12);
  uint64_t v38 = (char *)&v32 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v44 = AssociatedTypeWitness;
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v39 = a7;
  uint64_t v19 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t v35 = a3;
  uint64_t v20 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v36 = *(void (**)(void, uint64_t *, uint64_t))(v20 + 56);
  uint64_t v21 = v36;
  char v22 = swift_checkMetadataState(0, (uint64_t)v19);
  uint64_t v33 = v14;
  v21(0, v22, v20);
  uint64_t v23 = *(void *)(v41 + 8);
  uint64_t v40 = *(void *)(*(void *)(v40 + 8) + 96);
  uint64_t v41 = v23;
  uint64_t v24 = v38;
  ((void (*)(char *, uint64_t))v40)(v14, a3);
  uint64_t v34 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, void, const char *))v34)(v24, 0, v44);
  uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v19);
  uint64_t v26 = v33;
  uint64_t v27 = v45;
  v36(1, v25, v20);
  uint64_t v28 = v35;
  ((void (*)(char *, uint64_t, uint64_t))v40)(v26, v35, v41);
  v34(v24, 1, v44, AssociatedConformanceWitness);
  uint64_t v30 = type metadata accessor for SIMD2(0, v28, (uint64_t)v39, v29);
  return (*((uint64_t (**)(uint64_t, Class *))*(v30 - 1) + 1))(v27, v30);
}

uint64_t SIMD2<>.init<A>(clamping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v40 = a4;
  uint64_t v41 = a6;
  uint64_t v45 = a1;
  uint64_t v37 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v32 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v42 = v15;
  MEMORY[0x1F4188790](v12);
  uint64_t v38 = (char *)&v32 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v44 = AssociatedTypeWitness;
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v39 = a7;
  uint64_t v19 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t v35 = a3;
  uint64_t v20 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v36 = *(void (**)(void, uint64_t *, uint64_t))(v20 + 56);
  uint64_t v21 = v36;
  char v22 = swift_checkMetadataState(0, (uint64_t)v19);
  uint64_t v33 = v14;
  v21(0, v22, v20);
  uint64_t v23 = *(void *)(v41 + 8);
  uint64_t v40 = *(void *)(*(void *)(v40 + 8) + 104);
  uint64_t v41 = v23;
  uint64_t v24 = v38;
  ((void (*)(char *, uint64_t))v40)(v14, a3);
  uint64_t v34 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, void, const char *))v34)(v24, 0, v44);
  uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v19);
  uint64_t v26 = v33;
  uint64_t v27 = v45;
  v36(1, v25, v20);
  uint64_t v28 = v35;
  ((void (*)(char *, uint64_t, uint64_t))v40)(v26, v35, v41);
  v34(v24, 1, v44, AssociatedConformanceWitness);
  uint64_t v30 = type metadata accessor for SIMD2(0, v28, (uint64_t)v39, v29);
  return (*((uint64_t (**)(uint64_t, Class *))*(v30 - 1) + 1))(v27, v30);
}

uint64_t SIMD2<>.init<A>(_:rounding:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, int **a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v52 = a7;
  uint64_t v47 = a5;
  uint64_t v48 = a1;
  uint64_t v50 = a3;
  uint64_t v54 = a2;
  uint64_t v43 = a9;
  uint64_t v13 = MEMORY[0x1F4188790](a1);
  uint64_t v44 = (char *)v38 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v45 = (char *)v38 - v16;
  MEMORY[0x1F4188790](v15);
  uint64_t v51 = (char *)v38 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v19, v18, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v21 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v53 = AssociatedTypeWitness;
  v21(AssociatedTypeWitness, AssociatedConformanceWitness);
  char v46 = a8;
  char v22 = swift_getAssociatedTypeWitness(255, a8, a4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t v23 = (uint64_t)a8;
  uint64_t v24 = (uint64_t)v22;
  uint64_t v40 = v22;
  uint64_t v25 = swift_getAssociatedConformanceWitness(v23, a4, (uint64_t)v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v26 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v25 + 56);
  uint64_t v41 = v25;
  uint64_t v42 = v26;
  uint64_t v27 = swift_checkMetadataState(0, v24);
  v26(0, v27, v25);
  uint64_t v28 = v52;
  uint64_t v29 = *(void *)(v52 + 16);
  uint64_t v30 = *(void (**)(uint64_t, uint64_t, uint64_t))(v29 + 304);
  v38[1] = v29 + 304;
  uint64_t v39 = v30;
  uint64_t v31 = v45;
  v30(v54, a4, v29);
  uint64_t v47 = *(void *)(*(void *)(v47 + 8) + 80);
  uint64_t v32 = v51;
  ((void (*)(char *, uint64_t, uint64_t))v47)(v31, a4, v28);
  v38[0] = *(void *)(AssociatedConformanceWitness + 64);
  ((void (*)(char *, void, const char *))v38[0])(v32, 0, v53);
  uint64_t v33 = swift_checkMetadataState(0, (uint64_t)v40);
  v42(1, v33, v41);
  v39(v54, a4, v29);
  uint64_t v34 = v51;
  ((void (*)(char *, uint64_t, uint64_t))v47)(v31, a4, v52);
  ((void (*)(char *, uint64_t, const char *, uint64_t))v38[0])(v34, 1, v53, AssociatedConformanceWitness);
  uint64_t v36 = type metadata accessor for SIMD2(0, a4, (uint64_t)v46, v35);
  return (*((uint64_t (**)(uint64_t, Class *))*(v36 - 1) + 1))(v48, v36);
}

uint64_t SIMD2.debugDescription.getter(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(Class **)(a1 + 16);
  size_t v3 = *((void *)*(v2 - 1) + 8);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v5 = MEMORY[0x1F4188790](v4);
  v339 = (unint64_t *)((char *)&v333 - v6);
  uint64_t v7 = MEMORY[0x1F4188790](v5);
  v341 = (unint64_t *)((char *)&v333 - v8);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  v343 = (unint64_t *)((char *)&v333 - v10);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v333 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  v336 = (unint64_t *)((char *)&v333 - v15);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  v338 = (unint64_t *)((char *)&v333 - v17);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  v340 = (unint64_t *)((char *)&v333 - v19);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  v342 = (unint64_t *)((char *)&v333 - v21);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  v344 = (unint64_t *)((char *)&v333 - v23);
  MEMORY[0x1F4188790](v22);
  v346 = (char *)&v333 - v24;
  uint64_t v25 = specialized static String._createEmpty(withInitialCapacity:)(17);
  uint64_t v27 = v25;
  unint64_t v28 = v26;
  unint64_t v353 = v25;
  unint64_t v354 = v26;
  unint64_t v29 = HIBYTE(v26) & 0xF;
  if ((v26 & 0x2000000000000000) != 0) {
    uint64_t v30 = HIBYTE(v26) & 0xF;
  }
  else {
    uint64_t v30 = v25 & 0xFFFFFFFFFFFFLL;
  }
  v345 = v13;
  v337 = (unint64_t *)((char *)&v333 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (!v30 && (v25 & ~v26 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v26);
    unint64_t v353 = 0x3C32444D4953;
    unint64_t v354 = 0xE600000000000000;
    goto LABEL_40;
  }
  if ((v26 & 0x2000000000000000) == 0 || v29 > 9)
  {
    swift_bridgeObjectRetain_n(0xE600000000000000, 6);
    if ((v28 & 0x1000000000000000) != 0)
    {
      Swift::Int v331 = String.UTF8View._foreignCount()();
      int64_t v38 = v331 + 6;
      if (!__OFADD__(v331, 6))
      {
LABEL_13:
        if ((v27 & ~v28 & 0x2000000000000000) != 0
          && swift_isUniquelyReferenced_nonNull_native(v28 & 0xFFFFFFFFFFFFFFFLL))
        {
          int64_t v39 = _StringGuts.nativeUnusedCapacity.getter(v27, v28);
          if (v40)
          {
            unint64_t v332 = 258;
            goto LABEL_261;
          }
          BOOL v42 = (v28 & 0x2000000000000000) == 0 && v39 > 5;
          if (v38 <= 15 && !v42)
          {
LABEL_24:
            v335 = v2;
            uint64_t v43 = v1;
            swift_bridgeObjectRelease_n(0xE600000000000000, 5);
            swift_bridgeObjectRetain(v28);
            unint64_t v44 = _StringGuts._convertedToSmall()(v27, v28);
            unint64_t v46 = v45;
            swift_bridgeObjectRelease(v28);
            v47._rawBits = 1;
            v48._rawBits = 393217;
            v49._rawBits = _StringGuts.validateScalarRange(_:)(v47, v48, 0x3C32444D4953uLL, 0xE600000000000000);
            if (v49._rawBits < 0x10000) {
              v49._rawBits |= 3;
            }
            unint64_t v51 = specialized String.init(_:)(v49, v50, 0x3C32444D4953uLL, 0xE600000000000000);
            unint64_t v53 = v52;
            swift_bridgeObjectRelease(0xE600000000000000);
            unint64_t v54 = _StringGuts._convertedToSmall()(v51, v53);
            unint64_t v56 = v55;
            swift_bridgeObjectRelease(v53);
            unint64_t v57 = specialized _SmallString.init(_:appending:)(v44, v46, v54, v56);
            if ((v59 & 1) == 0)
            {
              unint64_t v60 = v57;
              unint64_t v61 = v58;
              swift_bridgeObjectRelease(v28);
              swift_bridgeObjectRelease(0xE600000000000000);
              unint64_t v353 = v60;
              unint64_t v354 = v61;
              uint64_t v35 = v346;
              uint64_t v1 = v43;
              uint64_t v2 = v335;
              goto LABEL_41;
            }
            unint64_t v332 = 266;
LABEL_261:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v332, 0);
          }
        }
        else if (v38 <= 15)
        {
          goto LABEL_24;
        }
        _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v38, 6);
        swift_bridgeObjectRelease_n(0xE600000000000000, 6);
        Swift::String v347 = (Swift::String)xmmword_18162B030;
        uint64_t v62 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 6, (uint64_t)&v347, 6);
        _StringGuts.appendInPlace(_:isASCII:)(v62, v63, 1);
        swift_bridgeObjectRelease(0xE600000000000000);
LABEL_40:
        uint64_t v35 = v346;
        goto LABEL_41;
      }
    }
    else
    {
      BOOL v37 = __OFADD__(v30, 6);
      int64_t v38 = v30 + 6;
      if (!v37) {
        goto LABEL_13;
      }
    }
    __break(1u);
    goto LABEL_257;
  }
  uint64_t v31 = 8 * HIBYTE(v26);
  uint64_t v32 = (-255 << (v31 & 0x38)) - 1;
  uint64_t v33 = 83 << (v31 & 0x38);
  char v34 = v29 + 1;
  if (v29 >= 8)
  {
    unint64_t v36 = v33 | v32 & v26;
    uint64_t v35 = v346;
    goto LABEL_31;
  }
  uint64_t v27 = v33 | v32 & v25;
  uint64_t v35 = v346;
  if (v29 == 7)
  {
    char v34 = 8;
    unint64_t v36 = v26;
LABEL_31:
    uint64_t v64 = (73 << (8 * (v34 & 7u))) | ((-255 << (8 * (v34 & 7u))) - 1) & v36;
    char v65 = v29 + 2;
LABEL_32:
    uint64_t v66 = (77 << (8 * (v65 & 7u))) | ((-255 << (8 * (v65 & 7u))) - 1) & v64;
    char v67 = v29 + 3;
LABEL_33:
    uint64_t v68 = (68 << (8 * (v67 & 7u))) | ((-255 << (8 * (v67 & 7u))) - 1) & v66;
    char v69 = v29 + 4;
LABEL_34:
    size_t v70 = v3;
    uint64_t v71 = (50 << (8 * (v69 & 7u))) | ((-255 << (8 * (v69 & 7u))) - 1) & v68;
    char v72 = v29 + 5;
    goto LABEL_35;
  }
  uint64_t v27 = (73 << (8 * (v34 & 7u))) | ((-255 << (8 * (v34 & 7u))) - 1) & v27;
  if (v29 >= 6)
  {
    char v65 = 8;
    uint64_t v64 = v26;
    goto LABEL_32;
  }
  uint64_t v27 = (77 << ((v31 + 16) & 0x38)) | ((-255 << ((v31 + 16) & 0x38)) - 1) & v27;
  if (v29 == 5)
  {
    char v67 = 8;
    uint64_t v66 = v26;
    goto LABEL_33;
  }
  uint64_t v27 = (68 << ((v31 + 24) & 0x38)) | ((-255 << ((v31 + 24) & 0x38)) - 1) & v27;
  if (v29 >= 4)
  {
    char v69 = 8;
    uint64_t v68 = v26;
    goto LABEL_34;
  }
  uint64_t v27 = (50 << ((v31 + 32) & 0x38)) | ((-255 << ((v31 + 32) & 0x38)) - 1) & v27;
  size_t v70 = v3;
  if (v29 != 3)
  {
    uint64_t v27 = (60 << ((v31 + 40) & 0x38)) | ((-255 << ((v31 + 40) & 0x38)) - 1) & v27;
    uint64_t v73 = v26;
    goto LABEL_36;
  }
  char v72 = 8;
  uint64_t v71 = v26;
LABEL_35:
  uint64_t v73 = (60 << (8 * (v72 & 7u))) | ((-255 << (8 * (v72 & 7u))) - 1) & v71;
LABEL_36:
  swift_bridgeObjectRelease(v26);
  swift_bridgeObjectRelease(0xE600000000000000);
  unint64_t v74 = 0xA000000000000000;
  if (!(v27 & 0x8080808080808080 | v73 & 0x80808080808080)) {
    unint64_t v74 = 0xE000000000000000;
  }
  unint64_t v353 = v27;
  unint64_t v354 = (v74 & 0xFF00000000000000 | (v29 << 56) | v73 & 0xFFFFFFFFFFFFFFLL) + 0x600000000000000;
  size_t v3 = v70;
LABEL_41:
  TypeName = (uint8x16_t *)swift_getTypeName(v2, 0);
  if (v76 < 0) {
    goto LABEL_253;
  }
  size_t v77 = v76;
  if (!v76)
  {
    uint64_t countAndFlagsBits = 0;
    unint64_t object = 0xE000000000000000;
    goto LABEL_157;
  }
  int64_t v78 = (uint64_t *)TypeName;
  char v79 = TypeName;
  if ((v76 & 0xFFFFFFFFFFFFFFF0) != 0)
  {
    if (((TypeName->i64[1] | TypeName->i64[0]) & 0x8080808080808080) != 0) {
      goto LABEL_63;
    }
    char v79 = TypeName + 1;
    while (v79 < (uint8x16_t *)&TypeName->i8[v76 & 0xFFFFFFFFFFFFFFF0])
    {
      uint64_t v80 = v79->i64[0];
      uint64_t v81 = v79->i64[1];
      ++v79;
      if (((v81 | v80) & 0x8080808080808080) != 0) {
        goto LABEL_63;
      }
    }
  }
  if (v79 < (uint8x16_t *)&TypeName->i8[v76 & 0xFFFFFFFFFFFFFFF8])
  {
    if ((v79->i64[0] & 0x8080808080808080) != 0) {
      goto LABEL_63;
    }
    char v79 = (uint8x16_t *)((char *)v79 + 8);
  }
  if (v79 < (uint8x16_t *)&TypeName->i8[v76 & 0xFFFFFFFFFFFFFFFCLL])
  {
    if ((v79->i32[0] & 0x80808080) != 0) {
      goto LABEL_63;
    }
    char v79 = (uint8x16_t *)((char *)v79 + 4);
  }
  if (v79 >= (uint8x16_t *)&TypeName->i8[v76 & 0xFFFFFFFFFFFFFFFELL])
  {
LABEL_59:
    if (v79 >= (uint8x16_t *)&TypeName->i8[v76] || (v79->i8[0] & 0x80000000) == 0)
    {
      if (v76 > 15)
      {
        char v84 = 1;
LABEL_104:
        unint64_t object = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(TypeName->i8, v76, v76, v84 & 1);
        uint64_t countAndFlagsBits = *(void *)(object + 24);
        goto LABEL_157;
      }
LABEL_114:
      unint64_t v122 = v76 - 8;
      unint64_t v123 = 8;
      if (v76 < 8) {
        unint64_t v123 = v76;
      }
      if ((v123 & 0x8000000000000000) == 0)
      {
        if (v123 >= 8)
        {
          if (v123 >= 0x10)
          {
            unint64_t v124 = v123 & 0xFFFFFFFFFFFFFFF0;
            uint16x8_t v149 = vmovl_high_u8(*TypeName);
            int8x16_t v150 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v149.i8);
            uint16x8_t v151 = vmovl_u8(*(uint8x8_t *)TypeName->i8);
            int8x16_t v152 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v151.i8);
            int8x16_t v153 = (int8x16_t)vmovl_high_u16(v149);
            int8x8_t v154 = (int8x8_t)vextq_s8(v153, v153, 8uLL).u64[0];
            int8x16_t v155 = (int8x16_t)vmovl_high_u16(v151);
            int8x8_t v156 = (int8x8_t)vextq_s8(v155, v155, 8uLL).u64[0];
            *(int8x8_t *)v155.i8 = vorr_s8(*(int8x8_t *)v155.i8, *(int8x8_t *)v153.i8);
            v157.i64[0] = v155.u32[0];
            v157.i64[1] = v155.u32[1];
            int8x16_t v158 = (int8x16_t)vshlq_u64(v157, (uint64x2_t)xmmword_18162AD00);
            *(int8x8_t *)v153.i8 = vorr_s8(*(int8x8_t *)v152.i8, *(int8x8_t *)v150.i8);
            v157.i64[0] = v153.u32[0];
            v157.i64[1] = v153.u32[1];
            int8x16_t v159 = vorrq_s8((int8x16_t)vshlq_u64(v157, (uint64x2_t)xmmword_18162ACF0), v158);
            *(int8x8_t *)v153.i8 = vorr_s8(v156, v154);
            v157.i64[0] = v153.u32[0];
            v157.i64[1] = v153.u32[1];
            int8x16_t v160 = (int8x16_t)vshlq_u64(v157, (uint64x2_t)xmmword_18162ACE0);
            *(int8x8_t *)v150.i8 = vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v152, v152, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v150, v150, 8uLL));
            v157.i64[0] = v150.u32[0];
            v157.i64[1] = v150.u32[1];
            int8x16_t v161 = vorrq_s8(v159, vorrq_s8((int8x16_t)vshlq_u64(v157, (uint64x2_t)xmmword_18162ACD0), v160));
            uint64_t countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v161.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v161, v161, 8uLL));
            if (v123 == (v123 & 0xFFFFFFFFFFFFFFF0)) {
              goto LABEL_135;
            }
            unint64_t v125 = 8 * v124;
            if ((v123 & 8) == 0) {
              goto LABEL_133;
            }
          }
          else
          {
            uint64_t countAndFlagsBits = 0;
            unint64_t v125 = 0;
            unint64_t v124 = 0;
          }
          unint64_t v126 = v124;
          int64x2_t v127 = vdupq_n_s64(v125);
          unint64_t v124 = v123 & 0xFFFFFFFFFFFFFFF8;
          unint64_t v125 = 8 * (v123 & 0xFFFFFFFFFFFFFFF8);
          int8x16_t v128 = 0uLL;
          int8x16_t v129 = (int8x16_t)(unint64_t)countAndFlagsBits;
          int64x2_t v130 = vaddq_s64(v127, (int64x2_t)xmmword_18162ACE0);
          int64x2_t v131 = vaddq_s64(v127, (int64x2_t)xmmword_18162AD00);
          int64x2_t v132 = vaddq_s64(v127, (int64x2_t)xmmword_18162ACD0);
          int64x2_t v133 = vaddq_s64(v127, (int64x2_t)xmmword_18162ACF0);
          uint64_t v134 = (uint8x8_t *)&TypeName->i8[v126];
          int8x16_t v135 = (int8x16_t)vdupq_n_s64(0x38uLL);
          unint64_t v136 = v126 - (v123 & 0xFFFFFFFFFFFFFFF8);
          int64x2_t v137 = vdupq_n_s64(0x40uLL);
          int8x16_t v138 = 0uLL;
          int8x16_t v139 = 0uLL;
          do
          {
            uint8x8_t v140 = *v134++;
            uint16x8_t v141 = vmovl_u8(v140);
            uint32x4_t v142 = vmovl_high_u16(v141);
            v143.i64[0] = v142.u32[2];
            v143.i64[1] = v142.u32[3];
            uint64x2_t v144 = v143;
            v143.i64[0] = v142.u32[0];
            v143.i64[1] = v142.u32[1];
            uint64x2_t v145 = v143;
            uint32x4_t v146 = vmovl_u16(*(uint16x4_t *)v141.i8);
            v143.i64[0] = v146.u32[2];
            v143.i64[1] = v146.u32[3];
            uint64x2_t v147 = v143;
            v143.i64[0] = v146.u32[0];
            v143.i64[1] = v146.u32[1];
            int8x16_t v139 = vorrq_s8((int8x16_t)vshlq_u64(v144, (uint64x2_t)vandq_s8((int8x16_t)v130, v135)), v139);
            int8x16_t v138 = vorrq_s8((int8x16_t)vshlq_u64(v145, (uint64x2_t)vandq_s8((int8x16_t)v131, v135)), v138);
            int8x16_t v128 = vorrq_s8((int8x16_t)vshlq_u64(v147, (uint64x2_t)vandq_s8((int8x16_t)v132, v135)), v128);
            int8x16_t v129 = vorrq_s8((int8x16_t)vshlq_u64(v143, (uint64x2_t)vandq_s8((int8x16_t)v133, v135)), v129);
            int64x2_t v131 = vaddq_s64(v131, v137);
            int64x2_t v132 = vaddq_s64(v132, v137);
            int64x2_t v133 = vaddq_s64(v133, v137);
            int64x2_t v130 = vaddq_s64(v130, v137);
            v136 += 8;
          }
          while (v136);
          int8x16_t v148 = vorrq_s8(vorrq_s8(v129, v138), vorrq_s8(v128, v139));
          uint64_t countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v148.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v148, v148, 8uLL));
          if (v123 == v124)
          {
LABEL_135:
            if (v76 < 9)
            {
              int8x8_t v166 = 0;
LABEL_154:
              unint64_t v230 = 0xA000000000000000;
              if (((*(void *)&v166 | countAndFlagsBits) & 0x8080808080808080) == 0) {
                unint64_t v230 = 0xE000000000000000;
              }
              unint64_t object = v230 | (v76 << 56) | *(void *)&v166;
              goto LABEL_157;
            }
            if (v122 < 8)
            {
              unint64_t v165 = 0;
              int8x8_t v166 = 0;
              unint64_t v167 = 0;
LABEL_152:
              uint64_t v227 = v76 - v165 - 8;
              unint64_t v228 = &TypeName->u8[v165 + 8];
              do
              {
                unsigned int v229 = *v228++;
                *(void *)&v166 |= (unint64_t)v229 << (v167 & 0x38);
                v167 += 8;
                --v227;
              }
              while (v227);
              goto LABEL_154;
            }
            if (v122 >= 0x10)
            {
              unint64_t v191 = (uint8x16_t *)&TypeName->u64[1];
              unint64_t v165 = v122 & 0xFFFFFFFFFFFFFFF0;
              int64x2_t v192 = (int64x2_t)xmmword_18162AD80;
              int64x2_t v193 = (int64x2_t)xmmword_18162AD90;
              int64x2_t v194 = (int64x2_t)xmmword_18162ADA0;
              int64x2_t v195 = (int64x2_t)xmmword_18162ADB0;
              int64x2_t v196 = (int64x2_t)xmmword_18162ACE0;
              int64x2_t v197 = (int64x2_t)xmmword_18162AD00;
              int8x16_t v198 = (int8x16_t)vdupq_n_s64(0x38uLL);
              int64x2_t v199 = vdupq_n_s64(0x80uLL);
              int64x2_t v200 = (int64x2_t)xmmword_18162ACD0;
              unint64_t v167 = 8 * (v122 & 0xFFFFFFFFFFFFFFF0);
              int8x16_t v201 = 0uLL;
              int8x16_t v202 = 0uLL;
              int64x2_t v203 = (int64x2_t)xmmword_18162ACF0;
              unint64_t v204 = v122 & 0xFFFFFFFFFFFFFFF0;
              int8x16_t v205 = 0uLL;
              int8x16_t v206 = 0uLL;
              int8x16_t v207 = 0uLL;
              int8x16_t v208 = 0uLL;
              int8x16_t v209 = 0uLL;
              int8x16_t v210 = 0uLL;
              do
              {
                uint8x16_t v211 = *v191++;
                uint16x8_t v212 = vmovl_u8(*(uint8x8_t *)v211.i8);
                uint32x4_t v213 = vmovl_high_u16(v212);
                v214.i64[0] = v213.u32[2];
                v214.i64[1] = v213.u32[3];
                uint64x2_t v215 = v214;
                uint16x8_t v216 = vmovl_high_u8(v211);
                uint32x4_t v217 = vmovl_u16(*(uint16x4_t *)v216.i8);
                v214.i64[0] = v217.u32[2];
                v214.i64[1] = v217.u32[3];
                uint64x2_t v218 = v214;
                v214.i64[0] = v217.u32[0];
                v214.i64[1] = v217.u32[1];
                uint64x2_t v219 = v214;
                v214.i64[0] = v213.u32[0];
                v214.i64[1] = v213.u32[1];
                uint64x2_t v220 = v214;
                uint32x4_t v221 = vmovl_u16(*(uint16x4_t *)v212.i8);
                v214.i64[0] = v221.u32[2];
                v214.i64[1] = v221.u32[3];
                uint64x2_t v222 = v214;
                uint32x4_t v223 = vmovl_high_u16(v216);
                v214.i64[0] = v223.u32[0];
                v214.i64[1] = v223.u32[1];
                uint64x2_t v224 = v214;
                v214.i64[0] = v221.u32[0];
                v214.i64[1] = v221.u32[1];
                uint64x2_t v225 = v214;
                v214.i64[0] = v223.u32[2];
                v214.i64[1] = v223.u32[3];
                int8x16_t v206 = vorrq_s8((int8x16_t)vshlq_u64(v215, (uint64x2_t)vandq_s8((int8x16_t)v196, v198)), v206);
                int8x16_t v208 = vorrq_s8((int8x16_t)vshlq_u64(v218, (uint64x2_t)vandq_s8((int8x16_t)v194, v198)), v208);
                int8x16_t v207 = vorrq_s8((int8x16_t)vshlq_u64(v219, (uint64x2_t)vandq_s8((int8x16_t)v195, v198)), v207);
                int8x16_t v205 = vorrq_s8((int8x16_t)vshlq_u64(v220, (uint64x2_t)vandq_s8((int8x16_t)v197, v198)), v205);
                int8x16_t v202 = vorrq_s8((int8x16_t)vshlq_u64(v222, (uint64x2_t)vandq_s8((int8x16_t)v200, v198)), v202);
                int8x16_t v209 = vorrq_s8((int8x16_t)vshlq_u64(v224, (uint64x2_t)vandq_s8((int8x16_t)v193, v198)), v209);
                int8x16_t v201 = vorrq_s8((int8x16_t)vshlq_u64(v225, (uint64x2_t)vandq_s8((int8x16_t)v203, v198)), v201);
                int8x16_t v210 = vorrq_s8((int8x16_t)vshlq_u64(v214, (uint64x2_t)vandq_s8((int8x16_t)v192, v198)), v210);
                int64x2_t v197 = vaddq_s64(v197, v199);
                int64x2_t v200 = vaddq_s64(v200, v199);
                int64x2_t v203 = vaddq_s64(v203, v199);
                int64x2_t v196 = vaddq_s64(v196, v199);
                int64x2_t v195 = vaddq_s64(v195, v199);
                int64x2_t v194 = vaddq_s64(v194, v199);
                int64x2_t v193 = vaddq_s64(v193, v199);
                int64x2_t v192 = vaddq_s64(v192, v199);
                v204 -= 16;
              }
              while (v204);
              int8x16_t v226 = vorrq_s8(vorrq_s8(vorrq_s8(v201, v207), vorrq_s8(v205, v209)), vorrq_s8(vorrq_s8(v202, v208), vorrq_s8(v206, v210)));
              int8x8_t v166 = vorr_s8(*(int8x8_t *)v226.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v226, v226, 8uLL));
              if (v122 == v165) {
                goto LABEL_154;
              }
              if ((v122 & 8) == 0) {
                goto LABEL_152;
              }
            }
            else
            {
              int8x8_t v166 = 0;
              unint64_t v167 = 0;
              unint64_t v165 = 0;
            }
            unint64_t v168 = v165;
            unint64_t v165 = v122 & 0xFFFFFFFFFFFFFFF8;
            int64x2_t v169 = vdupq_n_s64(v167);
            unint64_t v167 = 8 * (v122 & 0xFFFFFFFFFFFFFFF8);
            int8x16_t v170 = (int8x16_t)(unint64_t)v166;
            int8x16_t v171 = 0uLL;
            int64x2_t v172 = vaddq_s64(v169, (int64x2_t)xmmword_18162ACE0);
            int64x2_t v173 = vaddq_s64(v169, (int64x2_t)xmmword_18162AD00);
            int64x2_t v174 = vaddq_s64(v169, (int64x2_t)xmmword_18162ACD0);
            int64x2_t v175 = vaddq_s64(v169, (int64x2_t)xmmword_18162ACF0);
            unint64_t v176 = (uint8x8_t *)((char *)&TypeName->u64[1] + v168);
            int8x16_t v177 = (int8x16_t)vdupq_n_s64(0x38uLL);
            unint64_t v178 = v168 - (v122 & 0xFFFFFFFFFFFFFFF8);
            int64x2_t v179 = vdupq_n_s64(0x40uLL);
            int8x16_t v180 = 0uLL;
            int8x16_t v181 = 0uLL;
            do
            {
              uint8x8_t v182 = *v176++;
              uint16x8_t v183 = vmovl_u8(v182);
              uint32x4_t v184 = vmovl_high_u16(v183);
              v185.i64[0] = v184.u32[2];
              v185.i64[1] = v184.u32[3];
              uint64x2_t v186 = v185;
              v185.i64[0] = v184.u32[0];
              v185.i64[1] = v184.u32[1];
              uint64x2_t v187 = v185;
              uint32x4_t v188 = vmovl_u16(*(uint16x4_t *)v183.i8);
              v185.i64[0] = v188.u32[2];
              v185.i64[1] = v188.u32[3];
              uint64x2_t v189 = v185;
              v185.i64[0] = v188.u32[0];
              v185.i64[1] = v188.u32[1];
              int8x16_t v181 = vorrq_s8((int8x16_t)vshlq_u64(v186, (uint64x2_t)vandq_s8((int8x16_t)v172, v177)), v181);
              int8x16_t v180 = vorrq_s8((int8x16_t)vshlq_u64(v187, (uint64x2_t)vandq_s8((int8x16_t)v173, v177)), v180);
              int8x16_t v171 = vorrq_s8((int8x16_t)vshlq_u64(v189, (uint64x2_t)vandq_s8((int8x16_t)v174, v177)), v171);
              int8x16_t v170 = vorrq_s8((int8x16_t)vshlq_u64(v185, (uint64x2_t)vandq_s8((int8x16_t)v175, v177)), v170);
              int64x2_t v173 = vaddq_s64(v173, v179);
              int64x2_t v174 = vaddq_s64(v174, v179);
              int64x2_t v175 = vaddq_s64(v175, v179);
              int64x2_t v172 = vaddq_s64(v172, v179);
              v178 += 8;
            }
            while (v178);
            int8x16_t v190 = vorrq_s8(vorrq_s8(v170, v180), vorrq_s8(v171, v181));
            int8x8_t v166 = vorr_s8(*(int8x8_t *)v190.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v190, v190, 8uLL));
            if (v122 == v165) {
              goto LABEL_154;
            }
            goto LABEL_152;
          }
        }
        else
        {
          unint64_t v124 = 0;
          uint64_t countAndFlagsBits = 0;
          unint64_t v125 = 0;
        }
LABEL_133:
        unint64_t v162 = &TypeName->u8[v124];
        unint64_t v163 = v123 - v124;
        do
        {
          unsigned int v164 = *v162++;
          countAndFlagsBits |= (unint64_t)v164 << (v125 & 0x38);
          v125 += 8;
          --v163;
        }
        while (v163);
        goto LABEL_135;
      }
LABEL_258:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    goto LABEL_63;
  }
  if ((v79->i16[0] & 0x8080) == 0)
  {
    char v79 = (uint8x16_t *)((char *)v79 + 2);
    goto LABEL_59;
  }
LABEL_63:
  uint64_t v85 = 0;
  size_t v86 = (uint8x16_t *)((char *)TypeName + v76);
  char v84 = 1;
  int v87 = TypeName;
  char v88 = TypeName;
  while (1)
  {
    int v91 = v88->i8[0];
    char v88 = (uint8x16_t *)((char *)v88 + 1);
    unsigned __int8 v90 = v91;
    if (v91 < 0) {
      break;
    }
    uint64_t v89 = 1;
LABEL_65:
    v85 += v89;
    int v87 = v88;
    if (v88 == v86)
    {
      if (v76 > 15) {
        goto LABEL_104;
      }
      goto LABEL_114;
    }
  }
  if ((v90 + 62) > 0x32u) {
    goto LABEL_105;
  }
  if (v90 <= 0xDFu)
  {
    if (v88 == v86 || (v88->i8[0] & 0xC0) != 0x80) {
      goto LABEL_105;
    }
    char v84 = 0;
    char v88 = (uint8x16_t *)&v87->i16[1];
    uint64_t v89 = 2;
    goto LABEL_65;
  }
  if (v90 == 224)
  {
    if (v88 == v86 || (v87->i8[1] & 0xE0) != 0xA0) {
      goto LABEL_105;
    }
    goto LABEL_85;
  }
  if (v90 <= 0xECu) {
    goto LABEL_82;
  }
  if (v90 == 237)
  {
    if (v88 == v86) {
      goto LABEL_105;
    }
    unsigned int v92 = v87->u8[1];
    if (v92 > 0x9F) {
      goto LABEL_105;
    }
    goto LABEL_84;
  }
  if (v90 <= 0xEFu)
  {
LABEL_82:
    if (v88 == v86) {
      goto LABEL_105;
    }
    LOBYTE(v92) = v87->i8[1];
LABEL_84:
    if ((v92 & 0xC0) != 0x80) {
      goto LABEL_105;
    }
LABEL_85:
    if (&v87->i16[1] == (__int16 *)v86 || (v87->i8[2] & 0xC0) != 0x80) {
      goto LABEL_105;
    }
    char v84 = 0;
    char v88 = (uint8x16_t *)((char *)v87->i32 + 3);
    uint64_t v89 = 3;
    goto LABEL_65;
  }
  if (v90 == 240)
  {
    if (v88 == v86 || (v87->i8[1] + 64) < 0xD0u) {
      goto LABEL_105;
    }
    goto LABEL_98;
  }
  if ((v90 + 15) <= 2u)
  {
    if (v88 == v86) {
      goto LABEL_105;
    }
    LOBYTE(v93) = v87->i8[1];
LABEL_97:
    if ((v93 & 0xC0) != 0x80) {
      goto LABEL_105;
    }
LABEL_98:
    if (&v87->i16[1] == (__int16 *)v86
      || (v87->i8[2] & 0xC0) != 0x80
      || (uint8x16_t *)((char *)v87->i32 + 3) == v86
      || (v87->i8[3] & 0xC0) != 0x80)
    {
      goto LABEL_105;
    }
    char v84 = 0;
    char v88 = (uint8x16_t *)((char *)v87->i64 + 4);
    uint64_t v89 = 4;
    goto LABEL_65;
  }
  if (v88 != v86)
  {
    unsigned int v93 = v87->u8[1];
    if (v93 <= 0x8F) {
      goto LABEL_97;
    }
  }
LABEL_105:
  v335 = v2;
  unint64_t v94 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v94);
  uint64_t v95 = specialized Collection.subscript.getter(v85, (uint64_t)v78, v77);
  uint64_t v100 = findInvalidRange #1 (_:) in validateUTF8(_:)(v95, v96, v97, v98);
  v347._uint64_t countAndFlagsBits = 0;
  v347._unint64_t object = (void *)0xE000000000000000;
  if (__OFADD__(v77, 15))
  {
LABEL_257:
    __break(1u);
    goto LABEL_258;
  }
  uint64_t v101 = v99;
  uint64_t v333 = v1;
  size_t v334 = v3;
  _StringGuts.reserveCapacity(_:)(v77 + 15);
  while (1)
  {
    uint64_t v102 = specialized Collection.subscript.getter(v100, (uint64_t)v78, v77);
    unint64_t v106 = v347._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v347._object & 0x2000000000000000) != 0) {
      unint64_t v106 = ((unint64_t)v347._object >> 56) & 0xF;
    }
    BOOL v37 = __OFADD__(v106, v77);
    unint64_t v107 = v106 + v77;
    if (v37)
    {
      __break(1u);
LABEL_252:
      __break(1u);
LABEL_253:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    uint64_t v108 = v102;
    if (__OFADD__(v107, 3)) {
      goto LABEL_252;
    }
    uint64_t v109 = v103;
    uint64_t v110 = v104;
    uint64_t v111 = v105;
    _StringGuts.reserveCapacity(_:)(v107 + 3);
    uint64_t v112 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v108, v109, v110, v111);
    _StringGuts.appendInPlace(_:isASCII:)(v112, v113, 0);
    v355[0] = 3;
    *(void *)&long long v350 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v350, v355, &v347);
    uint64_t v114 = specialized Collection.subscript.getter(v101, (uint64_t)v78, v77);
    int64_t v78 = (uint64_t *)specialized UnsafeBufferPointer.init(rebasing:)(v114, v115, v116, v117);
    size_t v77 = v118;
    uint64_t v119 = validateUTF8(_:)(v78, v118);
    if ((v121 & 1) == 0) {
      break;
    }
    uint64_t v100 = v119;
    uint64_t v101 = v120;
    if (!v77) {
      goto LABEL_120;
    }
  }
  _StringGuts.appendInPlace(_:isASCII:)((char *)v78, v77, 0);
LABEL_120:
  unint64_t object = (unint64_t)v347._object;
  uint64_t countAndFlagsBits = v347._countAndFlagsBits;
  uint64_t v2 = v335;
  size_t v3 = v334;
  uint64_t v35 = v346;
  uint64_t v1 = v333;
LABEL_157:
  unint64_t v231 = v353;
  unint64_t v232 = HIBYTE(v354) & 0xF;
  unint64_t v233 = v353 & 0xFFFFFFFFFFFFLL;
  if ((v354 & 0x2000000000000000) != 0) {
    unint64_t v233 = HIBYTE(v354) & 0xF;
  }
  if (v233 || (v353 & ~v354 & 0x2000000000000000) != 0)
  {
    if ((v354 & 0x2000000000000000) == 0)
    {
      if ((object & 0x2000000000000000) != 0)
      {
        uint64_t v234 = HIBYTE(object) & 0xF;
        goto LABEL_167;
      }
LABEL_165:
      uint64_t v234 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      goto LABEL_167;
    }
    if ((object & 0x2000000000000000) == 0) {
      goto LABEL_165;
    }
    uint64_t v234 = HIBYTE(object) & 0xF;
    unint64_t v235 = v232 + v234;
    if (v232 + v234 <= 0xF)
    {
      size_t v307 = v3;
      if (v234)
      {
        char v308 = 0;
        unint64_t v309 = 0;
        unint64_t v310 = v354;
        do
        {
          unint64_t v311 = v232 + v309;
          unint64_t v312 = v309 + 1;
          if (v309 >= 8) {
            unint64_t v313 = object;
          }
          else {
            unint64_t v313 = countAndFlagsBits;
          }
          unint64_t v314 = v313 >> (v308 & 0x38);
          char v315 = (8 * v232 + v308) & 0x38;
          uint64_t v316 = (-255 << v315) - 1;
          unint64_t v317 = (unint64_t)v314 << v315;
          unint64_t v318 = v317 | v316 & v310;
          unint64_t v319 = v317 | v316 & v231;
          if (v311 < 8) {
            unint64_t v231 = v319;
          }
          else {
            unint64_t v310 = v318;
          }
          v308 += 8;
          unint64_t v309 = v312;
        }
        while (v234 != v312);
      }
      else
      {
        unint64_t v310 = v354;
      }
      swift_bridgeObjectRelease(v354);
      swift_bridgeObjectRelease(object);
      unint64_t v324 = 0xA000000000000000;
      if (!(v231 & 0x8080808080808080 | v310 & 0x80808080808080)) {
        unint64_t v324 = 0xE000000000000000;
      }
      unint64_t object = v324 & 0xFF00000000000000 | (v235 << 56) | v310 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v353 = v231;
      unint64_t v354 = object;
      uint64_t countAndFlagsBits = v231;
      size_t v3 = v307;
    }
    else
    {
LABEL_167:
      swift_bridgeObjectRetain(object);
      _StringGuts.append(_:)(countAndFlagsBits, object, 0, v234);
      swift_bridgeObjectRelease_n(object, 2);
      uint64_t countAndFlagsBits = v353;
      unint64_t object = v354;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v354);
    unint64_t v353 = countAndFlagsBits;
    unint64_t v354 = object;
  }
  uint64_t v236 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000) == 0) {
    uint64_t v236 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (v236 || (countAndFlagsBits & ~object & 0x2000000000000000) != 0)
  {
    if ((object & 0x2000000000000000) == 0
      || (unint64_t v237 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, 0x283EuLL, 0xE200000000000000),
          (v239 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000);
      _StringGuts.append(_:)(10302, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      unint64_t v240 = v237;
      unint64_t v241 = v238;
      swift_bridgeObjectRelease(object);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v353 = v240;
      unint64_t v354 = v241;
    }
  }
  else
  {
    swift_bridgeObjectRelease(object);
    unint64_t v353 = 10302;
    unint64_t v354 = 0xE200000000000000;
  }
  Swift::Int v242 = *(int ***)(v1 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v242, (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v242, (uint64_t)v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  Swift::String::Index v245 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  Swift::String::Index v246 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v245(0, v246, AssociatedConformanceWitness);
  v348 = (uint64_t *)v2;
  Swift::Int v247 = __swift_allocate_boxed_opaque_existential_0Tm(&v347);
  memcpy(v247, v35, v3);
  Swift::String::Index v248 = v348;
  Swift::String::Index v249 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v347, (uint64_t)v348);
  DynamicType = (void *)swift_getDynamicType(v249, v248, 1);
  LODWORD(v248) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v347._countAndFlagsBits);
  if (v248)
  {
    Swift::String::Index v251 = v344;
    memcpy(v344, v35, v3);
    Swift::Int v252 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v347, v251, v2, v252, 7uLL);
    goto LABEL_178;
  }
  unint64_t v260 = v342;
  memcpy(v342, v35, v3);
  if (swift_dynamicCast((char *)&v347, v260, v2, (const char *)&type metadata for String, 6uLL))
  {
    unint64_t v261 = v347._object;
    String.append(_:)(v347);
    swift_bridgeObjectRelease((uint64_t)v261);
    goto LABEL_187;
  }
  v291 = v340;
  memcpy(v340, v35, v3);
  v292 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v350, v291, v2, v292, 6uLL))
  {
    outlined init with take of MirrorPath(&v350, (uint64_t)&v347);
    uint64_t v293 = (uint64_t)v348;
    uint64_t v294 = v349;
    __swift_project_boxed_opaque_existential_0Tm(&v347, (uint64_t)v348);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v294 + 8))(&v353, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v293, v294);
LABEL_184:
    __swift_destroy_boxed_opaque_existential_1Tm(&v347._countAndFlagsBits);
    goto LABEL_187;
  }
  uint64_t v352 = 0;
  long long v350 = 0u;
  long long v351 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v350, &demangling cache variable for type metadata for TextOutputStreamable?);
  v299 = v338;
  memcpy(v338, v35, v3);
  v300 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v350, v299, v2, v300, 6uLL))
  {
    outlined init with take of MirrorPath(&v350, (uint64_t)&v347);
    uint64_t v301 = (uint64_t)v348;
    uint64_t v302 = v349;
    __swift_project_boxed_opaque_existential_0Tm(&v347, (uint64_t)v348);
    unint64_t v255 = (*(uint64_t (**)(uint64_t, uint64_t))(v302 + 8))(v301, v302);
LABEL_179:
    unint64_t v257 = v255;
    uint64_t v258 = v256;
    unint64_t v259 = HIBYTE(v354) & 0xF;
    if ((v354 & 0x2000000000000000) == 0) {
      unint64_t v259 = v353 & 0xFFFFFFFFFFFFLL;
    }
    if (v259 || (v353 & ~v354 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v255, v256);
      swift_bridgeObjectRelease(v258);
    }
    else
    {
      swift_bridgeObjectRelease(v354);
      unint64_t v353 = v257;
      unint64_t v354 = v258;
    }
    goto LABEL_184;
  }
  uint64_t v352 = 0;
  long long v350 = 0u;
  long long v351 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v350, &demangling cache variable for type metadata for CustomStringConvertible?);
  v320 = v336;
  memcpy(v336, v35, v3);
  v321 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  if (swift_dynamicCast((char *)&v350, v320, v2, v321, 6uLL))
  {
    outlined init with take of MirrorPath(&v350, (uint64_t)&v347);
LABEL_178:
    uint64_t v253 = (uint64_t)v348;
    uint64_t v254 = v349;
    __swift_project_boxed_opaque_existential_0Tm(&v347, (uint64_t)v348);
    unint64_t v255 = (*(uint64_t (**)(uint64_t, uint64_t))(v254 + 8))(v253, v254);
    goto LABEL_179;
  }
  uint64_t v352 = 0;
  long long v350 = 0u;
  long long v351 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v350, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((void *)&v351 + 1) = v2;
  v325 = __swift_allocate_boxed_opaque_existential_0Tm(&v350);
  memcpy(v325, v35, v3);
  Mirror.init(reflecting:)((uint64_t *)&v350, (uint64_t)&v347);
  v326 = v347._object;
  uint64_t v327 = v349;
  ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v35, &v347, &v353, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
  swift_release(v327);
  swift_release((uint64_t)v326);
LABEL_187:
  uint64_t v262 = v354;
  unint64_t v263 = HIBYTE(v354) & 0xF;
  if ((v354 & 0x2000000000000000) == 0) {
    unint64_t v263 = v353 & 0xFFFFFFFFFFFFLL;
  }
  if (v263 || (v353 & ~v354 & 0x2000000000000000) != 0)
  {
    if ((v354 & 0x2000000000000000) == 0
      || (unint64_t v264 = specialized _SmallString.init(_:appending:)(v353, v354, 0x202CuLL, 0xE200000000000000),
          (v266 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000);
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      unint64_t v267 = v264;
      unint64_t v268 = v265;
      swift_bridgeObjectRelease(v262);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v353 = v267;
      unint64_t v354 = v268;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v354);
    unint64_t v353 = 8236;
    unint64_t v354 = 0xE200000000000000;
  }
  uint64_t v269 = v345;
  v245(1, v246, AssociatedConformanceWitness);
  v348 = (uint64_t *)v2;
  unint64_t v270 = __swift_allocate_boxed_opaque_existential_0Tm(&v347);
  memcpy(v270, v269, v3);
  unint64_t v271 = v348;
  uint64_t v272 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v347, (uint64_t)v348);
  uint64_t v273 = (void *)swift_getDynamicType(v272, v271, 1);
  LODWORD(v271) = swift_isOptionalType(v273);
  __swift_destroy_boxed_opaque_existential_1Tm(&v347._countAndFlagsBits);
  if (v271)
  {
    long long v274 = v344;
    memcpy(v344, v269, v3);
    Swift::String v275 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v347, v274, v2, v275, 7uLL);
    goto LABEL_197;
  }
  v283 = v343;
  memcpy(v343, v269, v3);
  if (swift_dynamicCast((char *)&v347, v283, v2, (const char *)&type metadata for String, 6uLL))
  {
    v284 = v347._object;
    String.append(_:)(v347);
    swift_bridgeObjectRelease((uint64_t)v284);
    goto LABEL_206;
  }
  v295 = v341;
  memcpy(v341, v269, v3);
  v296 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v350, v295, v2, v296, 6uLL))
  {
    outlined init with take of MirrorPath(&v350, (uint64_t)&v347);
    uint64_t v297 = (uint64_t)v348;
    uint64_t v298 = v349;
    __swift_project_boxed_opaque_existential_0Tm(&v347, (uint64_t)v348);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v298 + 8))(&v353, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v297, v298);
LABEL_203:
    __swift_destroy_boxed_opaque_existential_1Tm(&v347._countAndFlagsBits);
    goto LABEL_206;
  }
  uint64_t v352 = 0;
  long long v350 = 0u;
  long long v351 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v350, &demangling cache variable for type metadata for TextOutputStreamable?);
  v303 = v339;
  memcpy(v339, v269, v3);
  v304 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v350, v303, v2, v304, 6uLL))
  {
    outlined init with take of MirrorPath(&v350, (uint64_t)&v347);
    uint64_t v305 = (uint64_t)v348;
    uint64_t v306 = v349;
    __swift_project_boxed_opaque_existential_0Tm(&v347, (uint64_t)v348);
    unint64_t v278 = (*(uint64_t (**)(uint64_t, uint64_t))(v306 + 8))(v305, v306);
LABEL_198:
    unint64_t v280 = v278;
    uint64_t v281 = v279;
    unint64_t v282 = HIBYTE(v354) & 0xF;
    if ((v354 & 0x2000000000000000) == 0) {
      unint64_t v282 = v353 & 0xFFFFFFFFFFFFLL;
    }
    if (v282 || (v353 & ~v354 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v278, v279);
      swift_bridgeObjectRelease(v281);
    }
    else
    {
      swift_bridgeObjectRelease(v354);
      unint64_t v353 = v280;
      unint64_t v354 = v281;
    }
    goto LABEL_203;
  }
  uint64_t v352 = 0;
  long long v350 = 0u;
  long long v351 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v350, &demangling cache variable for type metadata for CustomStringConvertible?);
  v322 = v337;
  memcpy(v337, v269, v3);
  v323 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  if (swift_dynamicCast((char *)&v350, v322, v2, v323, 6uLL))
  {
    outlined init with take of MirrorPath(&v350, (uint64_t)&v347);
LABEL_197:
    uint64_t v276 = (uint64_t)v348;
    uint64_t v277 = v349;
    __swift_project_boxed_opaque_existential_0Tm(&v347, (uint64_t)v348);
    unint64_t v278 = (*(uint64_t (**)(uint64_t, uint64_t))(v277 + 8))(v276, v277);
    goto LABEL_198;
  }
  uint64_t v352 = 0;
  long long v350 = 0u;
  long long v351 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v350, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((void *)&v351 + 1) = v2;
  v328 = __swift_allocate_boxed_opaque_existential_0Tm(&v350);
  memcpy(v328, v269, v3);
  Mirror.init(reflecting:)((uint64_t *)&v350, (uint64_t)&v347);
  v329 = v347._object;
  uint64_t v330 = v349;
  ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v269, &v347, &v353, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
  swift_release(v330);
  swift_release((uint64_t)v329);
LABEL_206:
  uint64_t v285 = v354;
  unint64_t v286 = HIBYTE(v354) & 0xF;
  if ((v354 & 0x2000000000000000) == 0) {
    unint64_t v286 = v353 & 0xFFFFFFFFFFFFLL;
  }
  if (v286 || (v353 & ~v354 & 0x2000000000000000) != 0)
  {
    if ((v354 & 0x2000000000000000) == 0
      || (unint64_t v287 = specialized _SmallString.init(_:appending:)(v353, v354, 0x29uLL, 0xE100000000000000), (v288 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000);
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      return v353;
    }
    else
    {
      unint64_t v289 = v287;
      swift_bridgeObjectRelease(v285);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v354);
    return 41;
  }
  return v289;
}

uint64_t SIMD2<>.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v40 = a4;
  uint64_t v41 = a6;
  uint64_t v45 = a1;
  uint64_t v37 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v32 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v42 = v15;
  MEMORY[0x1F4188790](v12);
  int64_t v38 = (char *)&v32 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  unint64_t v44 = AssociatedTypeWitness;
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  int64_t v39 = a7;
  uint64_t v19 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t v35 = a3;
  uint64_t v20 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  unint64_t v36 = *(void (**)(void, uint64_t *, uint64_t))(v20 + 56);
  uint64_t v21 = v36;
  uint64_t v22 = swift_checkMetadataState(0, (uint64_t)v19);
  uint64_t v33 = v14;
  v21(0, v22, v20);
  uint64_t v23 = *(void *)(v41 + 8);
  uint64_t v40 = *(void *)(*(void *)(v40 + 16) + 72);
  uint64_t v41 = v23;
  uint64_t v24 = v38;
  ((void (*)(char *, uint64_t))v40)(v14, a3);
  char v34 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, void, const char *))v34)(v24, 0, v44);
  uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v19);
  unint64_t v26 = v33;
  uint64_t v27 = v45;
  v36(1, v25, v20);
  uint64_t v28 = v35;
  ((void (*)(char *, uint64_t, uint64_t))v40)(v26, v35, v41);
  v34(v24, 1, v44, AssociatedConformanceWitness);
  uint64_t v30 = type metadata accessor for SIMD2(0, v28, (uint64_t)v39, v29);
  return (*((uint64_t (**)(uint64_t, Class *))*(v30 - 1) + 1))(v27, v30);
}

{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  int **v17;
  const char *AssociatedTypeWitness;
  const char *v19;
  uint64_t v20;
  void (*v21)(void, uint64_t *, uint64_t);
  uint64_t *v22;
  char *v23;
  void (*v24)(char *, uint64_t, const char *, uint64_t);
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  Class *v29;
  uint64_t v31;
  void (*v32)(char *, uint64_t, uint64_t);
  void (*v33)(void, uint64_t *, uint64_t);
  uint64_t v34;
  char *v35;
  int **v36;
  uint64_t v37;
  uint64_t AssociatedConformanceWitness;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;

  uint64_t v40 = a4;
  uint64_t v41 = a6;
  uint64_t v42 = a1;
  char v34 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v35 = (char *)&v31 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v37 = v14;
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v31 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  int64_t v39 = AssociatedTypeWitness;
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v36 = a7;
  uint64_t v19 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t v31 = a3;
  uint64_t v20 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  uint64_t v33 = *(void (**)(void, uint64_t *, uint64_t))(v20 + 56);
  uint64_t v21 = v33;
  uint64_t v22 = swift_checkMetadataState(0, (uint64_t)v19);
  uint64_t v23 = v35;
  v21(0, v22, v20);
  uint64_t v32 = *(void (**)(char *, uint64_t, uint64_t))(v40 + 80);
  v32(v23, a3, v41);
  uint64_t v24 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, void, const char *))v24)(v16, 0, v39);
  uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v19);
  unint64_t v26 = v42;
  v33(1, v25, v20);
  uint64_t v27 = v31;
  v32(v23, v31, v41);
  v24(v16, 1, v39, AssociatedConformanceWitness);
  uint64_t v29 = type metadata accessor for SIMD2(0, v27, (uint64_t)v36, v28);
  return (*((uint64_t (**)(uint64_t, Class *))*(v29 - 1) + 1))(v26, v29);
}

uint64_t SIMD4._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage, a2);
}

uint64_t SIMD4._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t (*SIMD4._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD4.scalarCount.getter()
{
  return 4;
}

uint64_t key path getter for SIMD4.subscript(_:) : <A>SIMD4<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  if ((unint64_t)*a2 >= 4) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0xC5uLL, 0);
  }
  uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  uint64_t v4 = *(int ***)((char *)a2 + a3 - 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD4.subscript(_:) : <A>SIMD4<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + a3 - 16);
  uint64_t v5 = *(int ***)(a4 + a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v17 - v6;
  unint64_t v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 4) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0xC9uLL, 0);
  }
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v14 = *(uint64_t (**)(char *, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v15 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD4.subscript.modify(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 4) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0xC5uLL, 0);
  }
  uint64_t v10 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD4.init(_:_:_:_:)(const void *a1, const void *a2, const void *a3, const void *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v18 = a4;
  size_t v11 = *(void *)(*(void *)(a5 - 8) + 64);
  MEMORY[0x1F4188790](a1);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v12, a5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), a1, v11);
  uint64_t v15 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  v15((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), a2, v11);
  v15((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), 1, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), a3, v11);
  v15((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), 2, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), v18, v11);
  return ((uint64_t (*)(char *, uint64_t, const char *, uint64_t))v15)((char *)&v17 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), 3, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t SIMD4.x.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 0);
}

uint64_t key path getter for SIMD4.x : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 0);
}

uint64_t key path setter for SIMD4.x : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, a4, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 0);
}

uint64_t SIMD4.x.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 0);
}

void (*SIMD4.x.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  uint64_t v8 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  size_t v11 = *(void (**)(void, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v5[5] = v12;
  v11(0, v12, AssociatedConformanceWitness);
  return SIMD2.x.modify;
}

uint64_t SIMD4.y.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 1);
}

uint64_t key path getter for SIMD4.y : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 1);
}

uint64_t key path setter for SIMD4.y : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, a4, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 1);
}

uint64_t SIMD4.y.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 1);
}

void (*SIMD4.y.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  uint64_t v8 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  size_t v11 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v5[5] = v12;
  v11(1, v12, AssociatedConformanceWitness);
  return SIMD2.y.modify;
}

uint64_t SIMD4.z.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 2);
}

uint64_t key path getter for SIMD4.z : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 2);
}

uint64_t key path setter for SIMD4.z : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, a4, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 2);
}

uint64_t SIMD4.z.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 2);
}

void (*SIMD4.z.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  uint64_t v8 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  size_t v11 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v5[5] = v12;
  v11(2, v12, AssociatedConformanceWitness);
  return SIMD4.z.modify;
}

void SIMD4.z.modify(uint64_t a1, uint64_t a2)
{
}

uint64_t SIMD4.w.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 3);
}

uint64_t key path getter for SIMD4.w : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 3);
}

uint64_t key path setter for SIMD4.w : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD2.x : <A>SIMD2<A>(a1, a2, a3, a4, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 3);
}

uint64_t SIMD4.w.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 3);
}

void (*SIMD4.w.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  uint64_t v8 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  size_t v11 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v5[5] = v12;
  v11(3, v12, AssociatedConformanceWitness);
  return SIMD4.w.modify;
}

void SIMD4.w.modify(uint64_t a1, uint64_t a2)
{
}

uint64_t SIMD4.init(lowHalf:highHalf:)(uint64_t a1, uint64_t a2, uint64_t a3, int **a4)
{
  void (*v15)(Class *__return_ptr, uint64_t, Class *);
  uint64_t vars8;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  size_t v11 = type metadata accessor for SIMD4(0, a3, (uint64_t)a4, v10);
  specialized SIMD4.lowHalf.setter(a1, (uint64_t)v11, 0, 1);
  uint64_t v13 = type metadata accessor for SIMD2(0, a3, (uint64_t)a4, v12);
  uint64_t v15 = (void (*)(Class *__return_ptr, uint64_t, Class *))*((void *)*(v13 - 1) + 1);
  v15(v13 - 1, a1, v13);
  specialized SIMD4.lowHalf.setter(a2, (uint64_t)v11, 2, 3);

  return ((uint64_t (*)(uint64_t, Class *))v15)(a2, v13);
}

uint64_t SIMD4.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD4.lowHalf.setter(a1, a2, 0, 1);
}

uint64_t SIMD4.highHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD4.lowHalf.setter(a1, a2, 2, 3);
}

uint64_t SIMD4.lowHalf.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  specialized SIMD4.lowHalf.setter(a1, a2, a3, a4);
  size_t v7 = type metadata accessor for SIMD2(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  uint64_t v8 = (uint64_t (*)(uint64_t, Class *))*((void *)*(v7 - 1) + 1);

  return v8(a1, v7);
}

uint64_t SIMD4.lowHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return SIMD4.lowHalf.getter(a1, 0, 1, a2);
}

uint64_t key path getter for SIMD4.lowHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD4, (uint64_t (*)(uint64_t))SIMD4.lowHalf.getter);
}

uint64_t key path setter for SIMD4.lowHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, a4, 0, 1);
}

void (*SIMD4.lowHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  size_t v7 = type metadata accessor for SIMD2(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD4.lowHalf.getter(a2, (uint64_t)v10);
  return SIMD4.lowHalf.modify;
}

void SIMD4.lowHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD4.highHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return SIMD4.lowHalf.getter(a1, 2, 3, a2);
}

uint64_t key path getter for SIMD4.highHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD4, (uint64_t (*)(uint64_t))SIMD4.highHalf.getter);
}

uint64_t key path getter for SIMD4.lowHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void, void, void), uint64_t (*a5)(uint64_t))
{
  uint64_t v6 = a4(0, *(void *)(a3 + a2 - 16), *(void *)(a3 + a2 - 8));
  return a5(v6);
}

uint64_t key path setter for SIMD4.highHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, a4, 2, 3);
}

uint64_t key path setter for SIMD4.lowHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  size_t v9 = type metadata accessor for SIMD4(0, *(void *)(a4 + a3 - 16), *(void *)(a4 + a3 - 8), a4);
  return specialized SIMD4.lowHalf.setter(a1, (uint64_t)v9, a5, a6);
}

void (*SIMD4.highHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  size_t v7 = type metadata accessor for SIMD2(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD4.highHalf.getter(a2, (uint64_t)v10);
  return SIMD4.highHalf.modify;
}

void SIMD4.highHalf.modify(uint64_t **a1, char a2)
{
}

void SIMD4.lowHalf.modify(uint64_t **a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *a1;
  size_t v7 = (void *)(*a1)[4];
  uint64_t v8 = (void *)(*a1)[5];
  uint64_t v9 = (*a1)[2];
  uint64_t v10 = (*a1)[3];
  uint64_t v11 = **a1;
  if (a2)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v10 + 16))((*a1)[4], v8, v9);
    specialized SIMD4.lowHalf.setter((uint64_t)v7, v11, a3, a4);
    uint64_t v12 = *(void (**)(void *, uint64_t))(v10 + 8);
    v12(v7, v9);
    v12(v8, v9);
  }
  else
  {
    specialized SIMD4.lowHalf.setter((*a1)[5], v11, a3, a4);
    (*(void (**)(void *, uint64_t))(v10 + 8))(v8, v9);
  }
  free(v8);
  free(v7);

  free(v6);
}

uint64_t SIMD4.evenHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return SIMD4.lowHalf.getter(a1, 0, 2, a2);
}

uint64_t key path getter for SIMD4.evenHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD4, (uint64_t (*)(uint64_t))SIMD4.evenHalf.getter);
}

uint64_t key path setter for SIMD4.evenHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, a4, 0, 2);
}

uint64_t SIMD4.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD4.lowHalf.setter(a1, a2, 0, 2);
}

void (*SIMD4.evenHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  size_t v7 = type metadata accessor for SIMD2(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD4.evenHalf.getter(a2, (uint64_t)v10);
  return SIMD4.evenHalf.modify;
}

void SIMD4.evenHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD4.oddHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return SIMD4.lowHalf.getter(a1, 1, 3, a2);
}

uint64_t SIMD4.lowHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v21 = a2;
  uint64_t v22 = a3;
  uint64_t v20 = a4;
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = MEMORY[0x1F4188790](a1);
  size_t v7 = (char *)&v18 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = *(int ***)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v8, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v11 = swift_getAssociatedTypeWitness(255, v8, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v12 = swift_getAssociatedConformanceWitness((uint64_t)v8, v4, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v19 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v12 + 56);
  uint64_t v13 = v19;
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)v11);
  v13(v21, v14, v12);
  uint64_t v15 = *(uint64_t (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  v15(v7, 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v16 = swift_checkMetadataState(0, (uint64_t)v11);
  v19(v22, v16, v12);
  return v15(v7, 1, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t key path getter for SIMD4.oddHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD4, (uint64_t (*)(uint64_t))SIMD4.oddHalf.getter);
}

uint64_t key path setter for SIMD4.oddHalf : <A>SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, a4, 1, 3);
}

uint64_t SIMD4.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD4.lowHalf.setter(a1, a2, 1, 3);
}

void (*SIMD4.oddHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  size_t v7 = type metadata accessor for SIMD2(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD4.oddHalf.getter(a2, (uint64_t)v10);
  return SIMD4.oddHalf.modify;
}

void SIMD4.oddHalf.modify(uint64_t **a1, char a2)
{
}

Swift::Int SIMD4.hashValue.getter(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, protocol conformance descriptor for SIMD4<A>, a3);
}

uint64_t protocol witness for SIMDStorage.scalarCount.getter in conformance SIMD4<A>()
{
  return 4;
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD4<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD4<A>(unint64_t a1, uint64_t a2)
{
  if (a1 >= 4) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0xC5uLL, 0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  size_t v9 = *(uint64_t (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  size_t v7 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD4<A>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 4) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0xC9uLL, 0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  size_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD4<A>(void *a1, unint64_t a2, uint64_t a3))()
{
  size_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *size_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 4) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0xC5uLL, 0);
  }
  uint64_t v10 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD4<A>(void *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD4<A>, a2, a3);
  return SIMD.encode(to:)(a1, (uint64_t)a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD4<A>@<X0>(uint64_t *a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD4<A>, a2, a3);
  return SIMD.init(from:)(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD4<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD4<A>, a2, a3);

  return SIMD.hash(into:)(a1, (uint64_t)a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD4<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(a1, a2, a3, protocol conformance descriptor for SIMD4<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD4<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD4<A>, a1, a3);

  return SIMD.description.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD4<A>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD4<A>, a2, a3);

  return SIMD.init(arrayLiteral:)(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD4<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v5 = a1;
  uint64_t v43 = *(void *)(a3 + 16);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  Swift::String::Index v50 = (char *)&v39 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  Swift::String::Index v49 = (char *)&v39 - v9;
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v8);
  uint64_t v14 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v39 - v16;
  uint64_t v18 = 0;
  uint64_t v20 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v11 += 16;
  uint64_t v19 = v20;
  unint64_t v46 = (void (**)(char *, uint64_t))(v11 - 8);
  uint64_t v47 = v21;
  char v22 = 1;
  uint64_t v44 = v23;
  uint64_t v41 = v11;
  uint64_t v42 = v15;
  Swift::String::Index v48 = v14;
  uint64_t v40 = v20;
  v20((char *)&v39 - v16, v5, v3);
  while (1)
  {
    v19(v14, a2, v3);
    if (v22)
    {
      uint64_t v25 = *(int ***)(v3 + 24);
      uint64_t v45 = v25;
      uint64_t v26 = v43;
      AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v25, v43, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v25, v26, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
      uint64_t v29 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
      uint64_t v30 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
      v29(v18, v30, AssociatedConformanceWitness);
      uint64_t v31 = *v46;
      (*v46)(v17, v47);
      uint64_t v32 = AssociatedConformanceWitness;
      uint64_t v19 = v40;
      v29(v18, v30, v32);
      uint64_t v3 = v47;
      uint64_t v14 = v48;
      v31(v48, v47);
      uint64_t v5 = v42;
      uint64_t v33 = v45;
      char v34 = swift_getAssociatedTypeWitness(255, v45, v26, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
      uint64_t v35 = (uint64_t)v33;
      a2 = v44;
      uint64_t v36 = swift_getAssociatedConformanceWitness(v35, v26, (uint64_t)v34, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      uint64_t v37 = swift_getAssociatedConformanceWitness(v36, (uint64_t)v34, v26, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      char v22 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v37 + 8) + 8))(v49, v50, v26);
    }
    else
    {
      uint64_t v24 = *v46;
      (*v46)(v14, v3);
      v24(v17, v3);
      char v22 = 0;
    }
    if (++v18 == 4) {
      break;
    }
    v19(v17, v5, v3);
  }
  return v22 & 1;
}

uint64_t SIMD4<>.init<A>(truncatingIfNeeded:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  unint64_t v60 = a7;
  uint64_t v53 = a6;
  uint64_t v64 = a4;
  uint64_t v65 = a1;
  uint64_t v57 = a8;
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = (char *)&v48 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v48 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v16, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  size_t v63 = AssociatedTypeWitness;
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v18 = v60;
  uint64_t v19 = swift_getAssociatedTypeWitness(255, v60, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v20 = (uint64_t)v18;
  uint64_t v21 = (uint64_t)v19;
  unint64_t v61 = v19;
  uint64_t v22 = swift_getAssociatedConformanceWitness(v20, a3, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v23 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  uint64_t v55 = v22;
  unint64_t v56 = v23;
  uint64_t v59 = v22 + 56;
  uint64_t v24 = swift_checkMetadataState(0, v21);
  v23(0, v24, v22);
  uint64_t v25 = *(void *)(v64 + 8);
  uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v25 + 96);
  uint64_t v64 = v25 + 96;
  uint64_t v53 = *(void *)(v53 + 8);
  unint64_t v54 = v26;
  uint64_t v27 = v15;
  uint64_t v28 = v13;
  uint64_t v58 = a3;
  uint64_t v51 = v25;
  uint64_t v52 = a2;
  ((void (*)(char *, uint64_t))v26)(v13, a3);
  uint64_t v29 = v63;
  Swift::String::Index v49 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v50 = AssociatedConformanceWitness + 64;
  ((void (*)(char *, void, const char *))v49)(v27, 0, v63);
  uint64_t v30 = swift_checkMetadataState(0, (uint64_t)v61);
  uint64_t v31 = v55;
  uint64_t v32 = v56;
  v56(1, v30, v55);
  uint64_t v33 = a3;
  uint64_t v34 = v53;
  uint64_t v35 = v54;
  ((void (*)(char *, uint64_t, uint64_t))v54)(v28, v33, v53);
  uint64_t v36 = v49;
  v49(v27, 1, v29, AssociatedConformanceWitness);
  uint64_t v37 = swift_checkMetadataState(0, (uint64_t)v61);
  v32(2, v37, v31);
  uint64_t v38 = v34;
  uint64_t v40 = v51;
  uint64_t v39 = v52;
  v35(v28, v58, v38, v52, v51);
  uint64_t v41 = AssociatedConformanceWitness;
  v36(v27, 2, v63, AssociatedConformanceWitness);
  uint64_t v42 = swift_checkMetadataState(0, (uint64_t)v61);
  uint64_t v43 = v65;
  v56(3, v42, v55);
  uint64_t v44 = v58;
  v54(v28, v58, v53, v39, v40);
  v36(v27, 3, v63, v41);
  unint64_t v46 = type metadata accessor for SIMD4(0, v44, (uint64_t)v60, v45);
  return (*((uint64_t (**)(uint64_t, Class *))*(v46 - 1) + 1))(v43, v46);
}

uint64_t SIMD4<>.init<A>(clamping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  unint64_t v60 = a7;
  uint64_t v53 = a6;
  uint64_t v64 = a4;
  uint64_t v65 = a1;
  uint64_t v57 = a8;
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = (char *)&v48 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v48 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v16, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  size_t v63 = AssociatedTypeWitness;
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v18 = v60;
  uint64_t v19 = swift_getAssociatedTypeWitness(255, v60, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v20 = (uint64_t)v18;
  uint64_t v21 = (uint64_t)v19;
  unint64_t v61 = v19;
  uint64_t v22 = swift_getAssociatedConformanceWitness(v20, a3, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v23 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  uint64_t v55 = v22;
  unint64_t v56 = v23;
  uint64_t v59 = v22 + 56;
  uint64_t v24 = swift_checkMetadataState(0, v21);
  v23(0, v24, v22);
  uint64_t v25 = *(void *)(v64 + 8);
  uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v25 + 104);
  uint64_t v64 = v25 + 104;
  uint64_t v53 = *(void *)(v53 + 8);
  unint64_t v54 = v26;
  uint64_t v27 = v15;
  uint64_t v28 = v13;
  uint64_t v58 = a3;
  uint64_t v51 = v25;
  uint64_t v52 = a2;
  ((void (*)(char *, uint64_t))v26)(v13, a3);
  uint64_t v29 = v63;
  Swift::String::Index v49 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v50 = AssociatedConformanceWitness + 64;
  ((void (*)(char *, void, const char *))v49)(v27, 0, v63);
  uint64_t v30 = swift_checkMetadataState(0, (uint64_t)v61);
  uint64_t v31 = v55;
  uint64_t v32 = v56;
  v56(1, v30, v55);
  uint64_t v33 = a3;
  uint64_t v34 = v53;
  uint64_t v35 = v54;
  ((void (*)(char *, uint64_t, uint64_t))v54)(v28, v33, v53);
  uint64_t v36 = v49;
  v49(v27, 1, v29, AssociatedConformanceWitness);
  uint64_t v37 = swift_checkMetadataState(0, (uint64_t)v61);
  v32(2, v37, v31);
  uint64_t v38 = v34;
  uint64_t v40 = v51;
  uint64_t v39 = v52;
  v35(v28, v58, v38, v52, v51);
  uint64_t v41 = AssociatedConformanceWitness;
  v36(v27, 2, v63, AssociatedConformanceWitness);
  uint64_t v42 = swift_checkMetadataState(0, (uint64_t)v61);
  uint64_t v43 = v65;
  v56(3, v42, v55);
  uint64_t v44 = v58;
  v54(v28, v58, v53, v39, v40);
  v36(v27, 3, v63, v41);
  unint64_t v46 = type metadata accessor for SIMD4(0, v44, (uint64_t)v60, v45);
  return (*((uint64_t (**)(uint64_t, Class *))*(v46 - 1) + 1))(v43, v46);
}

uint64_t SIMD4<>.init<A>(_:rounding:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, int **a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v34 = a8;
  uint64_t v42 = a5;
  uint64_t v43 = a7;
  uint64_t v40 = a2;
  uint64_t v46 = a1;
  uint64_t v44 = a9;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v33 - v14;
  MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v33 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v19, v18, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v41 = a3;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v22 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v39 = AssociatedTypeWitness;
  v22(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v23 = v34;
  uint64_t v24 = swift_getAssociatedTypeWitness(255, v34, a4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v45 = a4;
  uint64_t v38 = v24;
  uint64_t v25 = swift_getAssociatedConformanceWitness((uint64_t)v23, a4, (uint64_t)v24, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v26 = 0;
  uint64_t v36 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v25 + 56);
  uint64_t v37 = v25;
  uint64_t v35 = AssociatedConformanceWitness + 64;
  uint64_t v27 = v43;
  uint64_t v28 = v45;
  do
  {
    uint64_t v29 = swift_checkMetadataState(0, (uint64_t)v38);
    v36(v26, v29, v37);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v27 + 16) + 304))(v40, v28);
    (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v42 + 8) + 80))(v15, v28, v27);
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v17, v26++, v39, AssociatedConformanceWitness);
  }
  while (v26 != 4);
  uint64_t v31 = type metadata accessor for SIMD4(0, v45, (uint64_t)v34, v30);
  return (*((uint64_t (**)(uint64_t, Class *))*(v31 - 1) + 1))(v46, v31);
}

uint64_t SIMD4.debugDescription.getter(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(Class **)(a1 + 16);
  size_t v3 = *((void *)*(v2 - 1) + 8);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v5 = MEMORY[0x1F4188790](v4);
  unint64_t v270 = (unint64_t *)((char *)&v263 - v6);
  uint64_t v7 = MEMORY[0x1F4188790](v5);
  long long v274 = (unint64_t *)((char *)&v263 - v8);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  unint64_t v278 = (unint64_t *)((char *)&v263 - v10);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  unint64_t v279 = (char *)&v263 - v12;
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  unint64_t v265 = (unint64_t *)((char *)&v263 - v14);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v269 = (unint64_t *)((char *)&v263 - v16);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v273 = (unint64_t *)((char *)&v263 - v18);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v277 = (unint64_t *)((char *)&v263 - v20);
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  unint64_t v280 = (char *)&v263 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  unint64_t v264 = (unint64_t *)((char *)&v263 - v24);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  unint64_t v268 = (unint64_t *)((char *)&v263 - v26);
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v29 = (unint64_t *)((char *)&v263 - v28);
  uint64_t v30 = MEMORY[0x1F4188790](v27);
  uint64_t v276 = (unint64_t *)((char *)&v263 - v31);
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  uint64_t v34 = (char *)&v263 - v33;
  uint64_t v35 = MEMORY[0x1F4188790](v32);
  unint64_t v263 = (unint64_t *)((char *)&v263 - v36);
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  unint64_t v267 = (unint64_t *)((char *)&v263 - v38);
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  uint64_t v272 = (unint64_t *)((char *)&v263 - v40);
  uint64_t v41 = MEMORY[0x1F4188790](v39);
  Swift::String v275 = (unint64_t *)((char *)&v263 - v42);
  uint64_t v43 = MEMORY[0x1F4188790](v41);
  uint64_t v281 = (unint64_t *)((char *)&v263 - v44);
  MEMORY[0x1F4188790](v43);
  uint64_t v46 = (char *)&v263 - v45;
  unint64_t v47 = specialized static String._createEmpty(withInitialCapacity:)(25);
  uint64_t v49 = v48;
  unint64_t v289 = v47;
  unint64_t v290 = v48;
  uint64_t v50 = HIBYTE(v48) & 0xF;
  if ((v48 & 0x2000000000000000) == 0) {
    uint64_t v50 = v47 & 0xFFFFFFFFFFFFLL;
  }
  char v266 = (unint64_t *)((char *)&v263 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v50 || (v47 & ~v48 & 0x2000000000000000) != 0)
  {
    if ((v48 & 0x2000000000000000) == 0
      || (unint64_t v51 = specialized _SmallString.init(_:appending:)(v47, v48, 0x3C34444D4953uLL, 0xE600000000000000),
          (v53 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE600000000000000);
      _StringGuts.append(_:)(0x3C34444D4953, 0xE600000000000000, 0, 6);
      swift_bridgeObjectRelease_n(0xE600000000000000, 2);
    }
    else
    {
      unint64_t v54 = v51;
      unint64_t v55 = v52;
      swift_bridgeObjectRelease(v49);
      swift_bridgeObjectRelease(0xE600000000000000);
      unint64_t v289 = v54;
      unint64_t v290 = v55;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v48);
    unint64_t v289 = 0x3C34444D4953;
    unint64_t v290 = 0xE600000000000000;
  }
  TypeName = (uint64_t *)swift_getTypeName(v2, 0);
  if (v57 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  uint64_t v58 = (uint8x16_t *)TypeName;
  uint64_t v59 = v57;
  if (!_allASCII(_:)(TypeName, v57))
  {
    uint64_t v63 = 0;
    uint64_t v64 = &v58->u8[v59];
    if (!v58) {
      uint64_t v64 = 0;
    }
    char v60 = 1;
    for (i = v58; ; i = (uint8x16_t *)((char *)i + 3))
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            if (!i || i == (uint8x16_t *)v64) {
              goto LABEL_12;
            }
            unsigned int v67 = i->u8[0];
            i = (uint8x16_t *)((char *)i + 1);
            unsigned int v66 = v67;
            if ((v66 & 0x80) != 0) {
              break;
            }
            ++v63;
          }
          if ((v66 + 62) >= 0x33u) {
            goto LABEL_64;
          }
          if (v66 > 0xDF) {
            break;
          }
          if (!i || i == (uint8x16_t *)v64 || (i->i8[0] & 0xC0) != 0x80) {
            goto LABEL_64;
          }
          char v60 = 0;
          i = (uint8x16_t *)((char *)i + 1);
          v63 += 2;
        }
        if (v66 != 224) {
          break;
        }
        if (!i) {
          goto LABEL_64;
        }
        if (i == (uint8x16_t *)v64) {
          goto LABEL_64;
        }
        uint64_t v68 = &i->u8[1];
        if ((i->i8[0] & 0xE0) != 0xA0) {
          goto LABEL_64;
        }
LABEL_42:
        if (v68 == v64 || (*v68 & 0xC0) != 0x80) {
          goto LABEL_64;
        }
        char v60 = 0;
        i = (uint8x16_t *)((char *)i + 2);
        v63 += 3;
      }
      if (v66 <= 0xEC) {
        break;
      }
      if (v66 == 237)
      {
        if (!i) {
          goto LABEL_64;
        }
        if (i == (uint8x16_t *)v64) {
          goto LABEL_64;
        }
        uint64_t v68 = &i->u8[1];
        unsigned int v69 = i->u8[0];
        if (v69 > 0x9F) {
          goto LABEL_64;
        }
        goto LABEL_41;
      }
      if (v66 <= 0xEF) {
        break;
      }
      if (v66 == 240)
      {
        if (!i) {
          goto LABEL_64;
        }
        if (i == (uint8x16_t *)v64) {
          goto LABEL_64;
        }
        size_t v70 = &i->u8[1];
        if ((i->i8[0] + 64) < 0xD0u) {
          goto LABEL_64;
        }
      }
      else
      {
        if ((v66 + 15) > 2u)
        {
          if (!i || i == (uint8x16_t *)v64 || (size_t v70 = &i->u8[1], v71 = i->u8[0], v71 > 0x8F))
          {
LABEL_64:
            char v72 = v46;
            uint64_t v73 = v2;
            unint64_t v74 = (char *)v29;
            uint64_t v75 = v34;
            uint64_t v76 = v1;
            size_t v77 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
            unint64_t v282 = (Class *)v3;
            swift_willThrow();
            int64_t v78 = v77;
            uint64_t v1 = v76;
            uint64_t v34 = v75;
            uint64_t v29 = (unint64_t *)v74;
            uint64_t v2 = v73;
            uint64_t v46 = v72;
            swift_errorRelease(v78);
            uint64_t v79 = specialized Collection.subscript.getter(v63, (uint64_t)v58, v59);
            int64_t v83 = findInvalidRange #1 (_:) in validateUTF8(_:)(v79, v80, v81, v82);
            size_t v3 = (size_t)v282;
            unint64_t v61 = repairUTF8(_:firstKnownBrokenRange:)(v58->i8, v59, v83, v84);
            goto LABEL_65;
          }
        }
        else
        {
          if (!i || i == (uint8x16_t *)v64) {
            goto LABEL_64;
          }
          size_t v70 = &i->u8[1];
          LOBYTE(v71) = i->i8[0];
        }
        if ((v71 & 0xC0) != 0x80) {
          goto LABEL_64;
        }
      }
      if (v70 == v64 || (i->i8[1] & 0xC0) != 0x80 || &i->i16[1] == (__int16 *)v64 || (i->i8[2] & 0xC0) != 0x80) {
        goto LABEL_64;
      }
      char v60 = 0;
      v63 += 4;
    }
    if (!i || i == (uint8x16_t *)v64) {
      goto LABEL_64;
    }
    uint64_t v68 = &i->u8[1];
    LOBYTE(v69) = i->i8[0];
LABEL_41:
    if ((v69 & 0xC0) != 0x80) {
      goto LABEL_64;
    }
    goto LABEL_42;
  }
  char v60 = 1;
LABEL_12:
  unint64_t v61 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v58, v59, v60 & 1);
LABEL_65:
  unint64_t v85 = v61;
  unint64_t v86 = v62;
  uint64_t v87 = v290;
  unint64_t v88 = HIBYTE(v290) & 0xF;
  if ((v290 & 0x2000000000000000) == 0) {
    unint64_t v88 = v289 & 0xFFFFFFFFFFFFLL;
  }
  if (v88 || (v289 & ~v290 & 0x2000000000000000) != 0)
  {
    if ((v290 & 0x2000000000000000) == 0)
    {
      if ((v62 & 0x2000000000000000) != 0)
      {
        uint64_t v89 = HIBYTE(v62) & 0xF;
LABEL_74:
        swift_bridgeObjectRetain(v86);
        _StringGuts.append(_:)(v85, v86, 0, v89);
        swift_bridgeObjectRelease_n(v86, 2);
        unint64_t v85 = v289;
        unint64_t v86 = v290;
        goto LABEL_75;
      }
LABEL_73:
      uint64_t v89 = v61 & 0xFFFFFFFFFFFFLL;
      goto LABEL_74;
    }
    if ((v62 & 0x2000000000000000) == 0) {
      goto LABEL_73;
    }
    unint64_t v282 = v2;
    unint64_t v122 = (char *)v29;
    unint64_t v123 = v34;
    uint64_t v124 = v1;
    unint64_t v125 = specialized _SmallString.init(_:appending:)(v289, v290, v61, v62);
    if (v127)
    {
      uint64_t v89 = HIBYTE(v86) & 0xF;
      uint64_t v34 = v123;
      uint64_t v29 = (unint64_t *)v122;
      uint64_t v2 = v282;
      goto LABEL_74;
    }
    unint64_t v128 = v125;
    unint64_t v129 = v126;
    swift_bridgeObjectRelease(v87);
    swift_bridgeObjectRelease(v86);
    unint64_t v289 = v128;
    unint64_t v290 = v129;
    unint64_t v86 = v129;
    unint64_t v85 = v128;
    uint64_t v1 = v124;
    uint64_t v34 = v123;
    uint64_t v29 = (unint64_t *)v122;
    uint64_t v2 = v282;
  }
  else
  {
    swift_bridgeObjectRelease(v290);
    unint64_t v289 = v85;
    unint64_t v290 = v86;
  }
LABEL_75:
  uint64_t v90 = HIBYTE(v86) & 0xF;
  if ((v86 & 0x2000000000000000) == 0) {
    uint64_t v90 = v85 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v271 = v29;
  if (v90 || (v85 & ~v86 & 0x2000000000000000) != 0)
  {
    if ((v86 & 0x2000000000000000) == 0
      || (unint64_t v91 = specialized _SmallString.init(_:appending:)(v85, v86, 0x283EuLL, 0xE200000000000000), (v93 & 1) != 0))
    {
      uint64_t v96 = v34;
      swift_bridgeObjectRetain(0xE200000000000000);
      _StringGuts.append(_:)(10302, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      unint64_t v94 = v91;
      unint64_t v95 = v92;
      uint64_t v96 = v34;
      swift_bridgeObjectRelease(v86);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v289 = v94;
      unint64_t v290 = v95;
    }
  }
  else
  {
    uint64_t v96 = v34;
    swift_bridgeObjectRelease(v86);
    unint64_t v289 = 10302;
    unint64_t v290 = 0xE200000000000000;
  }
  uint64_t v97 = *(int ***)(v1 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v97, (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v97, (uint64_t)v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v100 = *(Class **)(AssociatedConformanceWitness + 56);
  uint64_t v101 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  unint64_t v282 = v100;
  ((void (*)(void))v100)(0);
  v284 = (uint64_t *)v2;
  uint64_t v102 = __swift_allocate_boxed_opaque_existential_0Tm(&v283);
  memcpy(v102, v46, v3);
  uint64_t v103 = v284;
  uint64_t v104 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
  DynamicType = (void *)swift_getDynamicType(v104, v103, 1);
  LODWORD(v103) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v283._countAndFlagsBits);
  if (v103)
  {
    unint64_t v106 = v281;
    memcpy(v281, v46, v3);
    unint64_t v107 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v283, v106, v2, v107, 7uLL);
    uint64_t v108 = (uint64_t)v284;
    uint64_t v109 = v285;
    __swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
    unint64_t v111 = (*(uint64_t (**)(uint64_t, uint64_t))(v109 + 8))(v108, v109);
    uint64_t v112 = v110;
    unint64_t v113 = HIBYTE(v290) & 0xF;
    if ((v290 & 0x2000000000000000) == 0) {
      unint64_t v113 = v289 & 0xFFFFFFFFFFFFLL;
    }
    if (v113 || (v289 & ~v290 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v111, v110);
      swift_bridgeObjectRelease(v112);
    }
    else
    {
      swift_bridgeObjectRelease(v290);
      unint64_t v289 = v111;
      unint64_t v290 = v112;
    }
    uint64_t v114 = v101;
    __swift_destroy_boxed_opaque_existential_1Tm(&v283._countAndFlagsBits);
    uint64_t v115 = v96;
  }
  else
  {
    uint64_t v116 = v275;
    memcpy(v275, v46, v3);
    if (swift_dynamicCast((char *)&v283, v116, v2, (const char *)&type metadata for String, 6uLL))
    {
      unint64_t object = v283._object;
      String.append(_:)(v283);
      swift_bridgeObjectRelease((uint64_t)object);
      uint64_t v114 = v101;
      uint64_t v115 = v96;
    }
    else
    {
      uint64_t v118 = v272;
      memcpy(v272, v46, v3);
      uint64_t v119 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
      uint64_t v114 = v101;
      if (swift_dynamicCast((char *)&v286, v118, v2, v119, 6uLL))
      {
        outlined init with take of MirrorPath(&v286, (uint64_t)&v283);
        uint64_t v120 = (uint64_t)v284;
        uint64_t v121 = v285;
        __swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
        (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v121 + 8))(&v289, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v120, v121);
        __swift_destroy_boxed_opaque_existential_1Tm(&v283._countAndFlagsBits);
        uint64_t v115 = v96;
      }
      else
      {
        uint64_t v288 = 0;
        long long v286 = 0u;
        long long v287 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v286, &demangling cache variable for type metadata for TextOutputStreamable?);
        int64x2_t v130 = v267;
        memcpy(v267, v46, v3);
        int64x2_t v131 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
        if (swift_dynamicCast((char *)&v286, v130, v2, v131, 6uLL))
        {
          outlined init with take of MirrorPath(&v286, (uint64_t)&v283);
          uint64_t v132 = (uint64_t)v284;
          uint64_t v133 = v285;
          __swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
          unint64_t v135 = (*(uint64_t (**)(uint64_t, uint64_t))(v133 + 8))(v132, v133);
          uint64_t v136 = v134;
          unint64_t v137 = HIBYTE(v290) & 0xF;
          if ((v290 & 0x2000000000000000) == 0) {
            unint64_t v137 = v289 & 0xFFFFFFFFFFFFLL;
          }
          if (v137 || (v289 & ~v290 & 0x2000000000000000) != 0)
          {
            _StringGuts.append(_:)(v135, v134);
            swift_bridgeObjectRelease(v136);
          }
          else
          {
            swift_bridgeObjectRelease(v290);
            unint64_t v289 = v135;
            unint64_t v290 = v136;
          }
          uint64_t v115 = v96;
          __swift_destroy_boxed_opaque_existential_1Tm(&v283._countAndFlagsBits);
        }
        else
        {
          uint64_t v288 = 0;
          long long v286 = 0u;
          long long v287 = 0u;
          outlined destroy of _HasContiguousBytes?((uint64_t)&v286, &demangling cache variable for type metadata for CustomStringConvertible?);
          int8x16_t v138 = v263;
          memcpy(v263, v46, v3);
          int8x16_t v139 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
          uint64_t v115 = v96;
          if (swift_dynamicCast((char *)&v286, v138, v2, v139, 6uLL))
          {
            outlined init with take of MirrorPath(&v286, (uint64_t)&v283);
            uint64_t v140 = (uint64_t)v284;
            uint64_t v141 = v285;
            __swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
            unint64_t v143 = (*(uint64_t (**)(uint64_t, uint64_t))(v141 + 8))(v140, v141);
            uint64_t v144 = v142;
            unint64_t v145 = HIBYTE(v290) & 0xF;
            if ((v290 & 0x2000000000000000) == 0) {
              unint64_t v145 = v289 & 0xFFFFFFFFFFFFLL;
            }
            if (v145 || (v289 & ~v290 & 0x2000000000000000) != 0)
            {
              _StringGuts.append(_:)(v143, v142);
              swift_bridgeObjectRelease(v144);
            }
            else
            {
              swift_bridgeObjectRelease(v290);
              unint64_t v289 = v143;
              unint64_t v290 = v144;
            }
            __swift_destroy_boxed_opaque_existential_1Tm(&v283._countAndFlagsBits);
          }
          else
          {
            uint64_t v288 = 0;
            long long v286 = 0u;
            long long v287 = 0u;
            outlined destroy of _HasContiguousBytes?((uint64_t)&v286, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
            *((void *)&v287 + 1) = v2;
            uint32x4_t v146 = __swift_allocate_boxed_opaque_existential_0Tm(&v286);
            memcpy(v146, v46, v3);
            Mirror.init(reflecting:)((uint64_t *)&v286, (uint64_t)&v283);
            uint64x2_t v147 = v283._object;
            uint64_t v148 = v285;
            ((void (*)(char *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v46, &v283, &v289, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
            swift_release(v148);
            swift_release((uint64_t)v147);
          }
        }
      }
    }
  }
  uint64_t v149 = v290;
  unint64_t v150 = HIBYTE(v290) & 0xF;
  if ((v290 & 0x2000000000000000) == 0) {
    unint64_t v150 = v289 & 0xFFFFFFFFFFFFLL;
  }
  if (v150 || (v289 & ~v290 & 0x2000000000000000) != 0)
  {
    if ((v290 & 0x2000000000000000) == 0
      || (unint64_t v151 = specialized _SmallString.init(_:appending:)(v289, v290, 0x202CuLL, 0xE200000000000000),
          (v153 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000);
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      unint64_t v154 = v151;
      unint64_t v155 = v152;
      swift_bridgeObjectRelease(v149);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v289 = v154;
      unint64_t v290 = v155;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v290);
    unint64_t v289 = 8236;
    unint64_t v290 = 0xE200000000000000;
  }
  ((void (*)(uint64_t, uint64_t *, uint64_t))v282)(1, v114, AssociatedConformanceWitness);
  v284 = (uint64_t *)v2;
  int8x8_t v156 = __swift_allocate_boxed_opaque_existential_0Tm(&v283);
  memcpy(v156, v115, v3);
  uint64x2_t v157 = v284;
  int8x16_t v158 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
  int8x16_t v159 = (void *)swift_getDynamicType(v158, v157, 1);
  LODWORD(v157) = swift_isOptionalType(v159);
  __swift_destroy_boxed_opaque_existential_1Tm(&v283._countAndFlagsBits);
  if (!v157)
  {
    int8x16_t v170 = v276;
    memcpy(v276, v115, v3);
    if (swift_dynamicCast((char *)&v283, v170, v2, (const char *)&type metadata for String, 6uLL))
    {
      int8x16_t v171 = v283._object;
      String.append(_:)(v283);
      swift_bridgeObjectRelease((uint64_t)v171);
    }
    else
    {
      int64x2_t v172 = v271;
      memcpy(v271, v115, v3);
      int64x2_t v173 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
      if (swift_dynamicCast((char *)&v286, v172, v2, v173, 6uLL))
      {
        outlined init with take of MirrorPath(&v286, (uint64_t)&v283);
        uint64_t v174 = (uint64_t)v284;
        uint64_t v175 = v285;
        __swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
        (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v175 + 8))(&v289, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v174, v175);
        __swift_destroy_boxed_opaque_existential_1Tm(&v283._countAndFlagsBits);
      }
      else
      {
        uint64_t v288 = 0;
        long long v286 = 0u;
        long long v287 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v286, &demangling cache variable for type metadata for TextOutputStreamable?);
        unint64_t v235 = v268;
        memcpy(v268, v115, v3);
        uint64_t v236 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
        if (swift_dynamicCast((char *)&v286, v235, v2, v236, 6uLL))
        {
          outlined init with take of MirrorPath(&v286, (uint64_t)&v283);
          uint64_t v237 = (uint64_t)v284;
          uint64_t v238 = v285;
          __swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
          unint64_t v164 = (*(uint64_t (**)(uint64_t, uint64_t))(v238 + 8))(v237, v238);
          goto LABEL_127;
        }
        uint64_t v288 = 0;
        long long v286 = 0u;
        long long v287 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v286, &demangling cache variable for type metadata for CustomStringConvertible?);
        Swift::Int v247 = v264;
        memcpy(v264, v115, v3);
        Swift::String::Index v248 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
        if (swift_dynamicCast((char *)&v286, v247, v2, v248, 6uLL))
        {
          outlined init with take of MirrorPath(&v286, (uint64_t)&v283);
          goto LABEL_126;
        }
        uint64_t v288 = 0;
        long long v286 = 0u;
        long long v287 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v286, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
        *((void *)&v287 + 1) = v2;
        uint64_t v253 = __swift_allocate_boxed_opaque_existential_0Tm(&v286);
        memcpy(v253, v115, v3);
        Mirror.init(reflecting:)((uint64_t *)&v286, (uint64_t)&v283);
        uint64_t v254 = v283._object;
        uint64_t v255 = v285;
        ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v115, &v283, &v289, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
        swift_release(v255);
        swift_release((uint64_t)v254);
      }
    }
    int64x2_t v169 = v279;
    goto LABEL_138;
  }
  int8x16_t v160 = v281;
  memcpy(v281, v115, v3);
  int8x16_t v161 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  swift_dynamicCast((char *)&v283, v160, v2, v161, 7uLL);
LABEL_126:
  uint64_t v162 = (uint64_t)v284;
  uint64_t v163 = v285;
  __swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
  unint64_t v164 = (*(uint64_t (**)(uint64_t, uint64_t))(v163 + 8))(v162, v163);
LABEL_127:
  unint64_t v166 = v164;
  uint64_t v167 = v165;
  unint64_t v168 = HIBYTE(v290) & 0xF;
  if ((v290 & 0x2000000000000000) == 0) {
    unint64_t v168 = v289 & 0xFFFFFFFFFFFFLL;
  }
  if (v168 || (v289 & ~v290 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(v164, v165);
    swift_bridgeObjectRelease(v167);
  }
  else
  {
    swift_bridgeObjectRelease(v290);
    unint64_t v289 = v166;
    unint64_t v290 = v167;
  }
  int64x2_t v169 = v279;
  __swift_destroy_boxed_opaque_existential_1Tm(&v283._countAndFlagsBits);
LABEL_138:
  uint64_t v176 = v290;
  unint64_t v177 = HIBYTE(v290) & 0xF;
  if ((v290 & 0x2000000000000000) == 0) {
    unint64_t v177 = v289 & 0xFFFFFFFFFFFFLL;
  }
  if (v177 || (v289 & ~v290 & 0x2000000000000000) != 0)
  {
    if ((v290 & 0x2000000000000000) == 0
      || (unint64_t v178 = specialized _SmallString.init(_:appending:)(v289, v290, 0x202CuLL, 0xE200000000000000),
          (v180 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000);
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      unint64_t v181 = v178;
      unint64_t v182 = v179;
      swift_bridgeObjectRelease(v176);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v289 = v181;
      unint64_t v290 = v182;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v290);
    unint64_t v289 = 8236;
    unint64_t v290 = 0xE200000000000000;
  }
  uint16x8_t v183 = v280;
  ((void (*)(uint64_t, uint64_t *, uint64_t))v282)(2, v114, AssociatedConformanceWitness);
  v284 = (uint64_t *)v2;
  uint32x4_t v184 = __swift_allocate_boxed_opaque_existential_0Tm(&v283);
  memcpy(v184, v183, v3);
  uint64x2_t v185 = v284;
  uint64x2_t v186 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
  uint64x2_t v187 = (void *)swift_getDynamicType(v186, v185, 1);
  LODWORD(v185) = swift_isOptionalType(v187);
  __swift_destroy_boxed_opaque_existential_1Tm(&v283._countAndFlagsBits);
  if (v185)
  {
    uint32x4_t v188 = v281;
    memcpy(v281, v183, v3);
    uint64x2_t v189 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v283, v188, v2, v189, 7uLL);
LABEL_148:
    uint64_t v190 = (uint64_t)v284;
    uint64_t v191 = v285;
    __swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
    unint64_t v192 = (*(uint64_t (**)(uint64_t, uint64_t))(v191 + 8))(v190, v191);
LABEL_149:
    unint64_t v194 = v192;
    uint64_t v195 = v193;
    unint64_t v196 = HIBYTE(v290) & 0xF;
    if ((v290 & 0x2000000000000000) == 0) {
      unint64_t v196 = v289 & 0xFFFFFFFFFFFFLL;
    }
    if (v196 || (v289 & ~v290 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v192, v193);
      swift_bridgeObjectRelease(v195);
    }
    else
    {
      swift_bridgeObjectRelease(v290);
      unint64_t v289 = v194;
      unint64_t v290 = v195;
    }
    goto LABEL_154;
  }
  int64x2_t v197 = v277;
  memcpy(v277, v183, v3);
  if (swift_dynamicCast((char *)&v283, v197, v2, (const char *)&type metadata for String, 6uLL))
  {
    int8x16_t v198 = v283._object;
    String.append(_:)(v283);
    swift_bridgeObjectRelease((uint64_t)v198);
  }
  else
  {
    uint64_t v227 = v273;
    memcpy(v273, v183, v3);
    unint64_t v228 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v286, v227, v2, v228, 6uLL))
    {
      outlined init with take of MirrorPath(&v286, (uint64_t)&v283);
      uint64_t v229 = (uint64_t)v284;
      uint64_t v230 = v285;
      __swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v230 + 8))(&v289, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v229, v230);
LABEL_154:
      __swift_destroy_boxed_opaque_existential_1Tm(&v283._countAndFlagsBits);
      goto LABEL_157;
    }
    uint64_t v288 = 0;
    long long v286 = 0u;
    long long v287 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v286, &demangling cache variable for type metadata for TextOutputStreamable?);
    char v239 = v269;
    memcpy(v269, v183, v3);
    unint64_t v240 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v286, v239, v2, v240, 6uLL))
    {
      outlined init with take of MirrorPath(&v286, (uint64_t)&v283);
      uint64_t v241 = (uint64_t)v284;
      uint64_t v242 = v285;
      __swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
      unint64_t v192 = (*(uint64_t (**)(uint64_t, uint64_t))(v242 + 8))(v241, v242);
      goto LABEL_149;
    }
    uint64_t v288 = 0;
    long long v286 = 0u;
    long long v287 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v286, &demangling cache variable for type metadata for CustomStringConvertible?);
    Swift::String::Index v249 = v265;
    memcpy(v265, v183, v3);
    Swift::String::Index v250 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v286, v249, v2, v250, 6uLL))
    {
      outlined init with take of MirrorPath(&v286, (uint64_t)&v283);
      goto LABEL_148;
    }
    uint64_t v288 = 0;
    long long v286 = 0u;
    long long v287 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v286, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v287 + 1) = v2;
    unint64_t v256 = __swift_allocate_boxed_opaque_existential_0Tm(&v286);
    memcpy(v256, v183, v3);
    Mirror.init(reflecting:)((uint64_t *)&v286, (uint64_t)&v283);
    unint64_t v257 = v283._object;
    uint64_t v258 = v183;
    uint64_t v259 = v285;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v258, &v283, &v289, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v259);
    swift_release((uint64_t)v257);
  }
LABEL_157:
  uint64_t v199 = v290;
  unint64_t v200 = HIBYTE(v290) & 0xF;
  if ((v290 & 0x2000000000000000) == 0) {
    unint64_t v200 = v289 & 0xFFFFFFFFFFFFLL;
  }
  if (v200 || (v289 & ~v290 & 0x2000000000000000) != 0)
  {
    if ((v290 & 0x2000000000000000) == 0
      || (unint64_t v201 = specialized _SmallString.init(_:appending:)(v289, v290, 0x202CuLL, 0xE200000000000000),
          (v203 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000);
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      unint64_t v204 = v201;
      unint64_t v205 = v202;
      swift_bridgeObjectRelease(v199);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v289 = v204;
      unint64_t v290 = v205;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v290);
    unint64_t v289 = 8236;
    unint64_t v290 = 0xE200000000000000;
  }
  ((void (*)(uint64_t, uint64_t *, uint64_t))v282)(3, v114, AssociatedConformanceWitness);
  v284 = (uint64_t *)v2;
  int8x16_t v206 = __swift_allocate_boxed_opaque_existential_0Tm(&v283);
  memcpy(v206, v169, v3);
  int8x16_t v207 = v284;
  int8x16_t v208 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
  int8x16_t v209 = (void *)swift_getDynamicType(v208, v207, 1);
  LODWORD(v207) = swift_isOptionalType(v209);
  __swift_destroy_boxed_opaque_existential_1Tm(&v283._countAndFlagsBits);
  if (v207)
  {
    int8x16_t v210 = v281;
    memcpy(v281, v169, v3);
    uint8x16_t v211 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v283, v210, v2, v211, 7uLL);
LABEL_167:
    uint64_t v212 = (uint64_t)v284;
    uint64_t v213 = v285;
    __swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
    unint64_t v214 = (*(uint64_t (**)(uint64_t, uint64_t))(v213 + 8))(v212, v213);
LABEL_168:
    unint64_t v216 = v214;
    uint64_t v217 = v215;
    unint64_t v218 = HIBYTE(v290) & 0xF;
    if ((v290 & 0x2000000000000000) == 0) {
      unint64_t v218 = v289 & 0xFFFFFFFFFFFFLL;
    }
    if (v218 || (v289 & ~v290 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v214, v215);
      swift_bridgeObjectRelease(v217);
    }
    else
    {
      swift_bridgeObjectRelease(v290);
      unint64_t v289 = v216;
      unint64_t v290 = v217;
    }
    goto LABEL_173;
  }
  uint64x2_t v219 = v278;
  memcpy(v278, v169, v3);
  if (swift_dynamicCast((char *)&v283, v219, v2, (const char *)&type metadata for String, 6uLL))
  {
    uint64x2_t v220 = v283._object;
    String.append(_:)(v283);
    swift_bridgeObjectRelease((uint64_t)v220);
  }
  else
  {
    unint64_t v231 = v274;
    memcpy(v274, v169, v3);
    unint64_t v232 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v286, v231, v2, v232, 6uLL))
    {
      outlined init with take of MirrorPath(&v286, (uint64_t)&v283);
      uint64_t v233 = (uint64_t)v284;
      uint64_t v234 = v285;
      __swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v234 + 8))(&v289, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v233, v234);
LABEL_173:
      __swift_destroy_boxed_opaque_existential_1Tm(&v283._countAndFlagsBits);
      goto LABEL_176;
    }
    uint64_t v288 = 0;
    long long v286 = 0u;
    long long v287 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v286, &demangling cache variable for type metadata for TextOutputStreamable?);
    Swift::String::Index v243 = v270;
    memcpy(v270, v169, v3);
    Swift::String::Index v244 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v286, v243, v2, v244, 6uLL))
    {
      outlined init with take of MirrorPath(&v286, (uint64_t)&v283);
      uint64_t v245 = (uint64_t)v284;
      uint64_t v246 = v285;
      __swift_project_boxed_opaque_existential_0Tm(&v283, (uint64_t)v284);
      unint64_t v214 = (*(uint64_t (**)(uint64_t, uint64_t))(v246 + 8))(v245, v246);
      goto LABEL_168;
    }
    uint64_t v288 = 0;
    long long v286 = 0u;
    long long v287 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v286, &demangling cache variable for type metadata for CustomStringConvertible?);
    Swift::String::Index v251 = v266;
    memcpy(v266, v169, v3);
    Swift::Int v252 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v286, v251, v2, v252, 6uLL))
    {
      outlined init with take of MirrorPath(&v286, (uint64_t)&v283);
      goto LABEL_167;
    }
    uint64_t v288 = 0;
    long long v286 = 0u;
    long long v287 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v286, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v287 + 1) = v2;
    unint64_t v260 = __swift_allocate_boxed_opaque_existential_0Tm(&v286);
    memcpy(v260, v169, v3);
    Mirror.init(reflecting:)((uint64_t *)&v286, (uint64_t)&v283);
    unint64_t v261 = v283._object;
    uint64_t v262 = v285;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v169, &v283, &v289, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v262);
    swift_release((uint64_t)v261);
  }
LABEL_176:
  uint64_t v221 = v290;
  unint64_t v222 = HIBYTE(v290) & 0xF;
  if ((v290 & 0x2000000000000000) == 0) {
    unint64_t v222 = v289 & 0xFFFFFFFFFFFFLL;
  }
  if (v222 || (v289 & ~v290 & 0x2000000000000000) != 0)
  {
    if ((v290 & 0x2000000000000000) == 0
      || (unint64_t v223 = specialized _SmallString.init(_:appending:)(v289, v290, 0x29uLL, 0xE100000000000000), (v224 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000);
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      return v289;
    }
    else
    {
      unint64_t v225 = v223;
      swift_bridgeObjectRelease(v221);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v290);
    return 41;
  }
  return v225;
}

uint64_t SIMD4<>.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  char v60 = a7;
  uint64_t v53 = a6;
  uint64_t v64 = a4;
  uint64_t v65 = a1;
  uint64_t v57 = a8;
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = (char *)&v48 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  uint64_t v15 = (char *)&v48 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v16, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v63 = AssociatedTypeWitness;
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v18 = v60;
  uint64_t v19 = swift_getAssociatedTypeWitness(255, v60, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v20 = (uint64_t)v18;
  uint64_t v21 = (uint64_t)v19;
  unint64_t v61 = v19;
  uint64_t v22 = swift_getAssociatedConformanceWitness(v20, a3, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v23 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  uint64_t v55 = v22;
  unint64_t v56 = v23;
  uint64_t v59 = v22 + 56;
  uint64_t v24 = swift_checkMetadataState(0, v21);
  v23(0, v24, v22);
  uint64_t v25 = *(void *)(v64 + 16);
  uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v25 + 72);
  uint64_t v64 = v25 + 72;
  uint64_t v53 = *(void *)(v53 + 8);
  unint64_t v54 = v26;
  uint64_t v27 = v15;
  uint64_t v28 = v13;
  uint64_t v58 = a3;
  uint64_t v51 = v25;
  uint64_t v52 = a2;
  ((void (*)(char *, uint64_t))v26)(v13, a3);
  uint64_t v29 = v63;
  uint64_t v49 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v50 = AssociatedConformanceWitness + 64;
  ((void (*)(char *, void, const char *))v49)(v27, 0, v63);
  uint64_t v30 = swift_checkMetadataState(0, (uint64_t)v61);
  uint64_t v31 = v55;
  uint64_t v32 = v56;
  v56(1, v30, v55);
  uint64_t v33 = a3;
  uint64_t v34 = v53;
  uint64_t v35 = v54;
  ((void (*)(char *, uint64_t, uint64_t))v54)(v28, v33, v53);
  uint64_t v36 = v49;
  v49(v27, 1, v29, AssociatedConformanceWitness);
  uint64_t v37 = swift_checkMetadataState(0, (uint64_t)v61);
  v32(2, v37, v31);
  uint64_t v38 = v34;
  uint64_t v40 = v51;
  uint64_t v39 = v52;
  v35(v28, v58, v38, v52, v51);
  uint64_t v41 = AssociatedConformanceWitness;
  v36(v27, 2, v63, AssociatedConformanceWitness);
  uint64_t v42 = swift_checkMetadataState(0, (uint64_t)v61);
  uint64_t v43 = v65;
  v56(3, v42, v55);
  uint64_t v44 = v58;
  v54(v28, v58, v53, v39, v40);
  v36(v27, 3, v63, v41);
  uint64_t v46 = type metadata accessor for SIMD4(0, v44, (uint64_t)v60, v45);
  return (*((uint64_t (**)(uint64_t, Class *))*(v46 - 1) + 1))(v43, v46);
}

{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int **v16;
  const char *AssociatedTypeWitness;
  const char *v18;
  uint64_t v19;
  void (*v20)(void, uint64_t *, uint64_t);
  uint64_t *v21;
  char *v22;
  uint64_t v23;
  void (*v24)(char *, uint64_t, uint64_t, uint64_t, uint64_t);
  char *v25;
  const char *v26;
  uint64_t v27;
  uint64_t *v28;
  void (*v29)(uint64_t, uint64_t *, uint64_t);
  uint64_t v30;
  void (*v31)(char *, uint64_t, uint64_t, uint64_t, uint64_t);
  const char *v32;
  void (*v33)(char *, uint64_t, const char *, uint64_t);
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  Class *v42;
  uint64_t v44;
  char *v45;
  int **v46;
  void (*v47)(char *, uint64_t, const char *, uint64_t);
  uint64_t v48;
  void (*v49)(char *, uint64_t, uint64_t, uint64_t, uint64_t);
  const char *v50;
  void (*v51)(void, uint64_t *, uint64_t);
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t AssociatedConformanceWitness;
  const char *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;

  char v60 = a4;
  unint64_t v61 = a6;
  uint64_t v58 = a1;
  uint64_t v59 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v45 = (char *)&v44 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v44 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v16, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v57 = AssociatedTypeWitness;
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v46 = a7;
  uint64_t v18 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v50 = v18;
  uint64_t v19 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v18, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v51 = *(void (**)(void, uint64_t *, uint64_t))(v19 + 56);
  uint64_t v20 = v51;
  uint64_t v52 = v19 + 56;
  uint64_t v21 = swift_checkMetadataState(0, (uint64_t)v18);
  uint64_t v22 = v45;
  unint64_t v54 = v19;
  v20(0, v21, v19);
  uint64_t v23 = v61;
  uint64_t v24 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(v60 + 80);
  uint64_t v48 = a2;
  uint64_t v49 = v24;
  uint64_t v55 = v60 + 80;
  uint64_t v25 = v15;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t))v24)(v22, a3, v61, a2);
  uint64_t v26 = v57;
  unint64_t v47 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v53 = AssociatedConformanceWitness + 64;
  ((void (*)(char *, void, const char *))v47)(v15, 0, v57);
  uint64_t v27 = (uint64_t)v50;
  uint64_t v28 = swift_checkMetadataState(0, (uint64_t)v50);
  uint64_t v29 = v51;
  v51(1, v28, v19);
  uint64_t v44 = a3;
  uint64_t v30 = v23;
  uint64_t v31 = v49;
  ((void (*)(char *, uint64_t, uint64_t))v49)(v22, a3, v30);
  uint64_t v32 = v26;
  uint64_t v33 = v47;
  v47(v25, 1, v32, AssociatedConformanceWitness);
  uint64_t v34 = swift_checkMetadataState(0, v27);
  v29(2, v34, v54);
  uint64_t v35 = v60;
  uint64_t v36 = v48;
  v31(v22, a3, v61, v48, v60);
  uint64_t v37 = AssociatedConformanceWitness;
  v33(v25, 2, v57, AssociatedConformanceWitness);
  uint64_t v38 = swift_checkMetadataState(0, (uint64_t)v50);
  uint64_t v39 = v58;
  v51(3, v38, v54);
  uint64_t v40 = v44;
  v49(v22, v44, v61, v36, v35);
  v47(v25, 3, v57, v37);
  uint64_t v42 = type metadata accessor for SIMD4(0, v40, (uint64_t)v46, v41);
  return (*((uint64_t (**)(uint64_t, Class *))*(v42 - 1) + 1))(v39, v42);
}

uint64_t SIMD8._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage, a2);
}

uint64_t SIMD8._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
}

uint64_t (*SIMD8._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD8.scalarCount.getter()
{
  return 8;
}

uint64_t key path getter for SIMD8.subscript(_:) : <A>SIMD8<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  if ((unint64_t)*a2 >= 8) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x1B7uLL, 0);
  }
  uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  uint64_t v4 = *(int ***)((char *)a2 + a3 - 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD8.subscript(_:) : <A>SIMD8<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + a3 - 16);
  uint64_t v5 = *(int ***)(a4 + a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v17 - v6;
  unint64_t v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 8) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x1BBuLL, 0);
  }
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v14 = *(uint64_t (**)(char *, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v15 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD8.subscript.modify(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 8) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x1B7uLL, 0);
  }
  uint64_t v10 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD8.init(_:_:_:_:_:_:_:_:)(const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, const void *a7, const void *a8, uint64_t a9, int **a10)
{
  uint64_t v22 = a7;
  uint64_t v23 = a8;
  uint64_t v20 = a5;
  uint64_t v21 = a6;
  uint64_t v19 = a4;
  size_t v13 = *(void *)(*(void *)(a9 - 8) + 64);
  MEMORY[0x1F4188790](a1);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a10, a9, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a10, a9, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), a1, v13);
  uint64_t v16 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), a2, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), 1, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), a3, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), 2, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), v19, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), 3, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), v20, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), 4, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), v21, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), 5, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), v22, v13);
  v16((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), 6, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), v23, v13);
  return ((uint64_t (*)(char *, uint64_t, const char *, uint64_t))v16)((char *)&v18 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0), 7, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t SIMD8.init(lowHalf:highHalf:)(uint64_t a1, uint64_t a2, uint64_t a3, int **a4)
{
  void (*v15)(Class *__return_ptr, uint64_t, Class *);
  uint64_t vars8;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  size_t v11 = type metadata accessor for SIMD8(0, a3, (uint64_t)a4, v10);
  specialized SIMD8.lowHalf.setter(a1, (uint64_t)v11, 0, 1, 2, 3);
  size_t v13 = type metadata accessor for SIMD4(0, a3, (uint64_t)a4, v12);
  uint64_t v15 = (void (*)(Class *__return_ptr, uint64_t, Class *))*((void *)*(v13 - 1) + 1);
  v15(v13 - 1, a1, v13);
  specialized SIMD8.lowHalf.setter(a2, (uint64_t)v11, 4, 5, 6, 7);

  return ((uint64_t (*)(uint64_t, Class *))v15)(a2, v13);
}

uint64_t SIMD8.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD8.oddHalf.setter(a1, a2, 0, 1, 2, 3);
}

uint64_t SIMD8.oddHalf.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  specialized SIMD8.lowHalf.setter(a1, a2, a3, a4, a5, a6);
  size_t v9 = type metadata accessor for SIMD4(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v8);
  uint64_t v10 = (uint64_t (*)(uint64_t, Class *))*((void *)*(v9 - 1) + 1);

  return v10(a1, v9);
}

uint64_t SIMD8.highHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD8.oddHalf.setter(a1, a2, 4, 5, 6, 7);
}

uint64_t SIMD8.lowHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return SIMD8.lowHalf.getter(a1, 0, 1, 2, 3, a2);
}

uint64_t key path getter for SIMD8.lowHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD8, (uint64_t (*)(uint64_t))SIMD8.lowHalf.getter);
}

uint64_t key path setter for SIMD8.lowHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD8.oddHalf : <A>SIMD8<A>(a1, a2, a3, a4, 0, 1, 2, 3);
}

uint64_t key path setter for SIMD8.oddHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v13 = type metadata accessor for SIMD8(0, *(void *)(a4 + a3 - 16), *(void *)(a4 + a3 - 8), a4);
  return specialized SIMD8.lowHalf.setter(a1, (uint64_t)v13, a5, a6, a7, a8);
}

void (*SIMD8.lowHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD4(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD8.lowHalf.getter(a2, (uint64_t)v10);
  return SIMD8.lowHalf.modify;
}

void SIMD8.lowHalf.modify(uint64_t **a1, char a2)
{
}

void SIMD8.oddHalf.modify(uint64_t **a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  size_t v9 = *a1;
  uint64_t v10 = (void *)(*a1)[4];
  size_t v11 = (void *)(*a1)[5];
  uint64_t v12 = (*a1)[2];
  uint64_t v13 = (*a1)[3];
  uint64_t v14 = **a1;
  if (a2)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v13 + 16))((*a1)[4], v11, v12);
    specialized SIMD8.lowHalf.setter((uint64_t)v10, v14, a3, a4, a5, a6);
    uint64_t v15 = *(void (**)(void *, uint64_t))(v13 + 8);
    v15(v10, v12);
    v15(v11, v12);
  }
  else
  {
    specialized SIMD8.lowHalf.setter((*a1)[5], v14, a3, a4, a5, a6);
    (*(void (**)(void *, uint64_t))(v13 + 8))(v11, v12);
  }
  free(v11);
  free(v10);

  free(v9);
}

uint64_t SIMD8.highHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return SIMD8.lowHalf.getter(a1, (void (*)(char *, uint64_t, const char *, uint64_t))4, 5, 6, 7, a2);
}

uint64_t key path getter for SIMD8.highHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD8, (uint64_t (*)(uint64_t))SIMD8.highHalf.getter);
}

uint64_t key path setter for SIMD8.highHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD8.oddHalf : <A>SIMD8<A>(a1, a2, a3, a4, 4, 5, 6, 7);
}

void (*SIMD8.highHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD4(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD8.highHalf.getter(a2, (uint64_t)v10);
  return SIMD8.highHalf.modify;
}

void SIMD8.highHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD8.evenHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return SIMD8.lowHalf.getter(a1, 0, 2, 4, 6, a2);
}

uint64_t key path getter for SIMD8.evenHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD8, (uint64_t (*)(uint64_t))SIMD8.evenHalf.getter);
}

uint64_t key path setter for SIMD8.evenHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD8.oddHalf : <A>SIMD8<A>(a1, a2, a3, a4, 0, 2, 4, 6);
}

uint64_t SIMD8.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD8.oddHalf.setter(a1, a2, 0, 2, 4, 6);
}

void (*SIMD8.evenHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD4(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD8.evenHalf.getter(a2, (uint64_t)v10);
  return SIMD8.evenHalf.modify;
}

void SIMD8.evenHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD8.oddHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return SIMD8.lowHalf.getter(a1, (void (*)(char *, uint64_t, const char *, uint64_t))1, 3, 5, 7, a2);
}

uint64_t SIMD8.lowHalf.getter@<X0>(uint64_t a1@<X0>, void (*a2)(char *, uint64_t, const char *, uint64_t)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v36 = a4;
  uint64_t v37 = a5;
  uint64_t v34 = a6;
  uint64_t v35 = a3;
  uint64_t v38 = a2;
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v28 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  size_t v11 = *(int ***)(v8 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v11, v7, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v11, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v13 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v39 = AssociatedTypeWitness;
  v13(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v14 = swift_getAssociatedTypeWitness(255, v11, v7, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v15 = swift_getAssociatedConformanceWitness((uint64_t)v11, v7, (uint64_t)v14, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v16 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v15 + 56);
  uint64_t v29 = v14;
  uint64_t v30 = v16;
  uint64_t v17 = swift_checkMetadataState(0, (uint64_t)v14);
  v16((uint64_t)v38, v17, v15);
  uint64_t v38 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v18 = AssociatedTypeWitness;
  uint64_t v19 = AssociatedConformanceWitness;
  ((void (*)(char *, void, const char *))v38)(v10, 0, v18);
  uint64_t v20 = swift_checkMetadataState(0, (uint64_t)v14);
  uint64_t v31 = v15;
  uint64_t v32 = v6;
  uint64_t v21 = v30;
  v30(v35, v20, v15);
  v38(v10, 1, v39, v19);
  uint64_t v22 = (uint64_t)v29;
  uint64_t v23 = swift_checkMetadataState(0, (uint64_t)v29);
  v21(v36, v23, v15);
  uint64_t v25 = (uint64_t (*)(char *, uint64_t, const char *, uint64_t))v38;
  uint64_t v24 = v39;
  v38(v10, 2, v39, v19);
  uint64_t v26 = swift_checkMetadataState(0, v22);
  v21(v37, v26, v31);
  return v25(v10, 3, v24, v19);
}

uint64_t key path getter for SIMD8.oddHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD8, (uint64_t (*)(uint64_t))SIMD8.oddHalf.getter);
}

uint64_t key path setter for SIMD8.oddHalf : <A>SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD8.oddHalf : <A>SIMD8<A>(a1, a2, a3, a4, 1, 3, 5, 7);
}

uint64_t SIMD8.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD8.oddHalf.setter(a1, a2, 1, 3, 5, 7);
}

void (*SIMD8.oddHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD4(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD8.oddHalf.getter(a2, (uint64_t)v10);
  return SIMD8.oddHalf.modify;
}

void SIMD8.oddHalf.modify(uint64_t **a1, char a2)
{
}

Swift::Int SIMD8.hashValue.getter(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, protocol conformance descriptor for SIMD8<A>, a3);
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD8<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>(a1, a2, associated type descriptor for SIMDScalar.SIMD8Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD8<A>(unint64_t a1, uint64_t a2)
{
  if (a1 >= 8) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x1B7uLL, 0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  size_t v9 = *(uint64_t (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v7 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD8<A>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 8) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x1BBuLL, 0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  size_t v11 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  size_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD8<A>(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 8) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x1B7uLL, 0);
  }
  uint64_t v10 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD8<A>(void *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD8<A>, a2, a3);
  return SIMD.encode(to:)(a1, (uint64_t)a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD8<A>@<X0>(uint64_t *a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD8<A>, a2, a3);
  return SIMD.init(from:)(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD8<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD8<A>, a2, a3);

  return SIMD.hash(into:)(a1, (uint64_t)a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD8<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(a1, a2, a3, protocol conformance descriptor for SIMD8<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD8<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD8<A>, a1, a3);

  return SIMD.description.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD8<A>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD8<A>, a2, a3);

  return SIMD.init(arrayLiteral:)(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD8<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v5 = a1;
  uint64_t v43 = *(void *)(a3 + 16);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v50 = (char *)&v39 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  uint64_t v49 = (char *)&v39 - v9;
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v8);
  uint64_t v14 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v39 - v16;
  uint64_t v18 = 0;
  uint64_t v20 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v11 += 16;
  uint64_t v19 = v20;
  uint64_t v46 = (void (**)(char *, uint64_t))(v11 - 8);
  uint64_t v47 = v21;
  char v22 = 1;
  uint64_t v44 = v23;
  uint64_t v41 = v11;
  uint64_t v42 = v15;
  uint64_t v48 = v14;
  uint64_t v40 = v20;
  v20((char *)&v39 - v16, v5, v3);
  while (1)
  {
    v19(v14, a2, v3);
    if (v22)
    {
      uint64_t v25 = *(int ***)(v3 + 24);
      uint64_t v45 = v25;
      uint64_t v26 = v43;
      AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v25, v43, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v25, v26, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
      uint64_t v29 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
      uint64_t v30 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
      v29(v18, v30, AssociatedConformanceWitness);
      uint64_t v31 = *v46;
      (*v46)(v17, v47);
      uint64_t v32 = AssociatedConformanceWitness;
      uint64_t v19 = v40;
      v29(v18, v30, v32);
      uint64_t v3 = v47;
      uint64_t v14 = v48;
      v31(v48, v47);
      uint64_t v5 = v42;
      uint64_t v33 = v45;
      uint64_t v34 = swift_getAssociatedTypeWitness(255, v45, v26, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
      uint64_t v35 = (uint64_t)v33;
      a2 = v44;
      uint64_t v36 = swift_getAssociatedConformanceWitness(v35, v26, (uint64_t)v34, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      uint64_t v37 = swift_getAssociatedConformanceWitness(v36, (uint64_t)v34, v26, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      char v22 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v37 + 8) + 8))(v49, v50, v26);
    }
    else
    {
      uint64_t v24 = *v46;
      (*v46)(v14, v3);
      v24(v17, v3);
      char v22 = 0;
    }
    if (++v18 == 8) {
      break;
    }
    v19(v17, v5, v3);
  }
  return v22 & 1;
}

uint64_t SIMD8<>.init<A>(truncatingIfNeeded:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v38 = a1;
  uint64_t v36 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v33 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v32 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v30 = a7;
  uint64_t v31 = v21;
  uint64_t v37 = a3;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v23 = 0;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  do
  {
    uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v31);
    v24(v23, v25, v22);
    (*(void (**)(char *, uint64_t, void))(*(void *)(v34 + 8) + 96))(v14, v37, *(void *)(v35 + 8));
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v16, v23++, v32, AssociatedConformanceWitness);
  }
  while (v23 != 8);
  uint64_t v27 = type metadata accessor for SIMD8(0, v37, (uint64_t)v30, v26);
  return (*((uint64_t (**)(uint64_t, Class *))*(v27 - 1) + 1))(v38, v27);
}

uint64_t SIMD8<>.init<A>(clamping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v38 = a1;
  uint64_t v36 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v33 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v32 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v30 = a7;
  uint64_t v31 = v21;
  uint64_t v37 = a3;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v23 = 0;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  do
  {
    uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v31);
    v24(v23, v25, v22);
    (*(void (**)(char *, uint64_t, void))(*(void *)(v34 + 8) + 104))(v14, v37, *(void *)(v35 + 8));
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v16, v23++, v32, AssociatedConformanceWitness);
  }
  while (v23 != 8);
  uint64_t v27 = type metadata accessor for SIMD8(0, v37, (uint64_t)v30, v26);
  return (*((uint64_t (**)(uint64_t, Class *))*(v27 - 1) + 1))(v38, v27);
}

uint64_t SIMD8<>.init<A>(_:rounding:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, int **a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v34 = a8;
  uint64_t v42 = a5;
  uint64_t v43 = a7;
  uint64_t v40 = a2;
  uint64_t v46 = a1;
  uint64_t v44 = a9;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v33 - v14;
  MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v33 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v19, v18, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v41 = a3;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v22 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v39 = AssociatedTypeWitness;
  v22(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v23 = v34;
  uint64_t v24 = swift_getAssociatedTypeWitness(255, v34, a4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v45 = a4;
  uint64_t v38 = v24;
  uint64_t v25 = swift_getAssociatedConformanceWitness((uint64_t)v23, a4, (uint64_t)v24, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v26 = 0;
  uint64_t v36 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v25 + 56);
  uint64_t v37 = v25;
  uint64_t v35 = AssociatedConformanceWitness + 64;
  uint64_t v27 = v43;
  uint64_t v28 = v45;
  do
  {
    uint64_t v29 = swift_checkMetadataState(0, (uint64_t)v38);
    v36(v26, v29, v37);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v27 + 16) + 304))(v40, v28);
    (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v42 + 8) + 80))(v15, v28, v27);
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v17, v26++, v39, AssociatedConformanceWitness);
  }
  while (v26 != 8);
  uint64_t v31 = type metadata accessor for SIMD8(0, v45, (uint64_t)v34, v30);
  return (*((uint64_t (**)(uint64_t, Class *))*(v31 - 1) + 1))(v46, v31);
}

uint64_t SIMD8.debugDescription.getter(uint64_t a1)
{
  v445 = (uint64_t *)a1;
  uint64_t v1 = *(Class **)(a1 + 16);
  size_t v2 = *((void *)*(v1 - 1) + 8);
  uint64_t v3 = MEMORY[0x1F4188790](a1);
  v412 = (unint64_t *)((char *)&v405 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v4 = MEMORY[0x1F4188790](v3);
  v420 = (unint64_t *)((char *)&v405 - v5);
  uint64_t v6 = MEMORY[0x1F4188790](v4);
  v428 = (unint64_t *)((char *)&v405 - v7);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  v435 = (unint64_t *)((char *)&v405 - v9);
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  v443 = (char *)&v405 - v11;
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v14 = (unint64_t *)((char *)&v405 - v13);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (unint64_t *)((char *)&v405 - v16);
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  v427 = (unint64_t *)((char *)&v405 - v19);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  v434 = (unint64_t *)((char *)&v405 - v21);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  v442 = (char *)&v405 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  v410 = (unint64_t *)((char *)&v405 - v25);
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  v418 = (unint64_t *)((char *)&v405 - v27);
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  v426 = (unint64_t *)((char *)&v405 - v29);
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  v433 = (unint64_t *)((char *)&v405 - v31);
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  v441 = (char *)&v405 - v33;
  uint64_t v34 = MEMORY[0x1F4188790](v32);
  v409 = (unint64_t *)((char *)&v405 - v35);
  uint64_t v36 = MEMORY[0x1F4188790](v34);
  v417 = (unint64_t *)((char *)&v405 - v37);
  uint64_t v38 = MEMORY[0x1F4188790](v36);
  v425 = (unint64_t *)((char *)&v405 - v39);
  uint64_t v40 = MEMORY[0x1F4188790](v38);
  v432 = (unint64_t *)((char *)&v405 - v41);
  uint64_t v42 = MEMORY[0x1F4188790](v40);
  uint64_t v44 = (char *)&v405 - v43;
  uint64_t v45 = MEMORY[0x1F4188790](v42);
  v408 = (unint64_t *)((char *)&v405 - v46);
  uint64_t v47 = MEMORY[0x1F4188790](v45);
  v416 = (unint64_t *)((char *)&v405 - v48);
  uint64_t v49 = MEMORY[0x1F4188790](v47);
  v424 = (unint64_t *)((char *)&v405 - v50);
  uint64_t v51 = MEMORY[0x1F4188790](v49);
  v431 = (unint64_t *)((char *)&v405 - v52);
  uint64_t v53 = MEMORY[0x1F4188790](v51);
  v440 = (char *)&v405 - v54;
  uint64_t v55 = MEMORY[0x1F4188790](v53);
  v407 = (unint64_t *)((char *)&v405 - v56);
  uint64_t v57 = MEMORY[0x1F4188790](v55);
  v415 = (unint64_t *)((char *)&v405 - v58);
  uint64_t v59 = MEMORY[0x1F4188790](v57);
  v423 = (unint64_t *)((char *)&v405 - v60);
  uint64_t v61 = MEMORY[0x1F4188790](v59);
  v430 = (unint64_t *)((char *)&v405 - v62);
  uint64_t v63 = MEMORY[0x1F4188790](v61);
  v439 = (char *)&v405 - v64;
  uint64_t v65 = MEMORY[0x1F4188790](v63);
  v406 = (unint64_t *)((char *)&v405 - v66);
  uint64_t v67 = MEMORY[0x1F4188790](v65);
  v414 = (unint64_t *)((char *)&v405 - v68);
  uint64_t v69 = MEMORY[0x1F4188790](v67);
  v422 = (unint64_t *)((char *)&v405 - v70);
  uint64_t v71 = MEMORY[0x1F4188790](v69);
  v429 = (unint64_t *)((char *)&v405 - v72);
  uint64_t v73 = MEMORY[0x1F4188790](v71);
  v438 = (char *)&v405 - v74;
  uint64_t v75 = MEMORY[0x1F4188790](v73);
  v405 = (unint64_t *)((char *)&v405 - v76);
  uint64_t v77 = MEMORY[0x1F4188790](v75);
  v413 = (unint64_t *)((char *)&v405 - v78);
  uint64_t v79 = MEMORY[0x1F4188790](v77);
  v421 = (unint64_t *)((char *)&v405 - v80);
  uint64_t v81 = MEMORY[0x1F4188790](v79);
  int64_t v83 = (char *)&v405 - v82;
  uint64_t v84 = MEMORY[0x1F4188790](v81);
  v444 = (unint64_t *)((char *)&v405 - v85);
  MEMORY[0x1F4188790](v84);
  uint64_t v87 = (char *)&v405 - v86;
  unint64_t v88 = specialized static String._createEmpty(withInitialCapacity:)(41);
  uint64_t v90 = v89;
  unint64_t v452 = v88;
  unint64_t v453 = v89;
  uint64_t v91 = HIBYTE(v89) & 0xF;
  if ((v89 & 0x2000000000000000) == 0) {
    uint64_t v91 = v88 & 0xFFFFFFFFFFFFLL;
  }
  v411 = v14;
  v419 = v17;
  if (v91 || (v88 & ~v89 & 0x2000000000000000) != 0)
  {
    if ((v89 & 0x2000000000000000) == 0
      || (unint64_t v92 = specialized _SmallString.init(_:appending:)(v88, v89, 0x3C38444D4953uLL, 0xE600000000000000),
          (v94 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE600000000000000);
      _StringGuts.append(_:)(0x3C38444D4953, 0xE600000000000000, 0, 6);
      swift_bridgeObjectRelease_n(0xE600000000000000, 2);
    }
    else
    {
      unint64_t v95 = v92;
      unint64_t v96 = v93;
      swift_bridgeObjectRelease(v90);
      swift_bridgeObjectRelease(0xE600000000000000);
      unint64_t v452 = v95;
      unint64_t v453 = v96;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v89);
    unint64_t v452 = 0x3C38444D4953;
    unint64_t v453 = 0xE600000000000000;
  }
  TypeName = (uint64_t *)swift_getTypeName(v1, 0);
  if (v98 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  uint64_t v99 = (uint8x16_t *)TypeName;
  uint64_t v100 = v98;
  if (!_allASCII(_:)(TypeName, v98) && v100)
  {
    uint64_t v101 = 0;
    uint64_t v102 = (uint8x16_t *)((char *)v99 + v100);
    char v103 = 1;
    uint64_t v104 = v99;
    uint64_t v105 = v99;
    while (1)
    {
      int v107 = v105->i8[0];
      uint64_t v105 = (uint8x16_t *)((char *)v105 + 1);
      unsigned __int8 v106 = v107;
      if ((v107 & 0x80000000) == 0)
      {
        uint64_t v108 = 1;
        goto LABEL_15;
      }
      if ((v106 + 11) <= 0xCCu) {
        goto LABEL_59;
      }
      if (v106 <= 0xDFu)
      {
        if (v105 == v102 || (v105->i8[0] & 0xC0) != 0x80) {
          goto LABEL_59;
        }
        char v103 = 0;
        uint64_t v105 = (uint8x16_t *)&v104->i16[1];
        uint64_t v108 = 2;
      }
      else
      {
        if (v106 == 224)
        {
          if (v105 == v102
            || ((uint64_t v109 = (uint8x16_t *)&v104->i16[1], (v104->i8[1] + 64) >= 0xE0u)
              ? (BOOL v110 = v109 == v102)
              : (BOOL v110 = 1),
                v110))
          {
LABEL_59:
            uint64_t v115 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
            swift_willThrow();
            swift_errorRelease(v115);
            uint64_t v116 = specialized Collection.subscript.getter(v101, (uint64_t)v99, v100);
            int64_t v120 = findInvalidRange #1 (_:) in validateUTF8(_:)(v116, v117, v118, v119);
            unint64_t v113 = repairUTF8(_:firstKnownBrokenRange:)(v99->i8, v100, v120, v121);
            goto LABEL_60;
          }
          goto LABEL_40;
        }
        if (v106 <= 0xECu) {
          goto LABEL_36;
        }
        if (v106 == 237)
        {
          if (v105 == v102) {
            goto LABEL_59;
          }
          unsigned int v111 = v104->u8[1];
          if (v111 > 0x9F) {
            goto LABEL_59;
          }
LABEL_38:
          if ((v111 & 0xC0) != 0x80) {
            goto LABEL_59;
          }
          uint64_t v109 = (uint8x16_t *)&v104->i16[1];
          if (&v104->i16[1] == (__int16 *)v102) {
            goto LABEL_59;
          }
LABEL_40:
          if ((v109->i8[0] & 0xC0) != 0x80) {
            goto LABEL_59;
          }
          char v103 = 0;
          uint64_t v105 = (uint8x16_t *)((char *)v104->i32 + 3);
          uint64_t v108 = 3;
          goto LABEL_15;
        }
        if (v106 <= 0xEFu)
        {
LABEL_36:
          if (v105 == v102) {
            goto LABEL_59;
          }
          LOBYTE(v111) = v104->i8[1];
          goto LABEL_38;
        }
        if (v106 == 240)
        {
          if (v105 == v102 || (v104->i8[1] + 64) < 0xD0u) {
            goto LABEL_59;
          }
        }
        else
        {
          if ((v106 + 15) > 2u)
          {
            if (v105 == v102) {
              goto LABEL_59;
            }
            unsigned int v112 = v104->u8[1];
            if (v112 > 0x8F) {
              goto LABEL_59;
            }
          }
          else
          {
            if (v105 == v102) {
              goto LABEL_59;
            }
            LOBYTE(v112) = v104->i8[1];
          }
          if ((v112 & 0xC0) != 0x80) {
            goto LABEL_59;
          }
        }
        if (&v104->i16[1] == (__int16 *)v102
          || (v104->i8[2] & 0xC0) != 0x80
          || (uint8x16_t *)((char *)v104->i32 + 3) == v102
          || (v104->i8[3] & 0xC0) != 0x80)
        {
          goto LABEL_59;
        }
        char v103 = 0;
        uint64_t v105 = (uint8x16_t *)((char *)v104->i64 + 4);
        uint64_t v108 = 4;
      }
LABEL_15:
      v101 += v108;
      uint64_t v104 = v105;
      if (v105 == v102) {
        goto LABEL_58;
      }
    }
  }
  char v103 = 1;
LABEL_58:
  unint64_t v113 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v99, v100, v103 & 1);
LABEL_60:
  unint64_t v122 = v113;
  unint64_t v123 = v114;
  uint64_t v124 = v453;
  unint64_t v125 = HIBYTE(v453) & 0xF;
  if ((v453 & 0x2000000000000000) == 0) {
    unint64_t v125 = v452 & 0xFFFFFFFFFFFFLL;
  }
  if (v125 || (v452 & ~v453 & 0x2000000000000000) != 0)
  {
    if ((v453 & 0x2000000000000000) != 0)
    {
      if ((v114 & 0x2000000000000000) != 0)
      {
        unint64_t v127 = specialized _SmallString.init(_:appending:)(v452, v453, v113, v114);
        if ((v129 & 1) == 0)
        {
          unint64_t v130 = v127;
          unint64_t v131 = v128;
          swift_bridgeObjectRelease(v124);
          swift_bridgeObjectRelease(v123);
          unint64_t v452 = v130;
          unint64_t v453 = v131;
          unint64_t v123 = v131;
          unint64_t v122 = v130;
          goto LABEL_73;
        }
        goto LABEL_71;
      }
    }
    else if ((v114 & 0x2000000000000000) != 0)
    {
LABEL_71:
      uint64_t v126 = HIBYTE(v123) & 0xF;
      goto LABEL_72;
    }
    uint64_t v126 = v113 & 0xFFFFFFFFFFFFLL;
LABEL_72:
    swift_bridgeObjectRetain(v123);
    _StringGuts.append(_:)(v122, v123, 0, v126);
    swift_bridgeObjectRelease_n(v123, 2);
    unint64_t v122 = v452;
    unint64_t v123 = v453;
    goto LABEL_73;
  }
  swift_bridgeObjectRelease(v453);
  unint64_t v452 = v122;
  unint64_t v453 = v123;
LABEL_73:
  uint64_t v132 = HIBYTE(v123) & 0xF;
  if ((v123 & 0x2000000000000000) == 0) {
    uint64_t v132 = v122 & 0xFFFFFFFFFFFFLL;
  }
  v437 = v44;
  if (v132 || (v122 & ~v123 & 0x2000000000000000) != 0)
  {
    if ((v123 & 0x2000000000000000) == 0
      || (unint64_t v133 = specialized _SmallString.init(_:appending:)(v122, v123, 0x283EuLL, 0xE200000000000000),
          (v135 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000);
      _StringGuts.append(_:)(10302, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      unint64_t v136 = v133;
      unint64_t v137 = v134;
      swift_bridgeObjectRelease(v123);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v452 = v136;
      unint64_t v453 = v137;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v123);
    unint64_t v452 = 10302;
    unint64_t v453 = 0xE200000000000000;
  }
  int8x16_t v138 = (int **)v445[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v138, (uint64_t)v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v138, (uint64_t)v1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v141 = AssociatedConformanceWitness + 56;
  unint64_t v142 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  v445 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v143 = AssociatedConformanceWitness;
  uint64_t v144 = v142;
  uint64_t v436 = v141;
  ((void (*)(void))v142)(0);
  v447 = (uint64_t *)v1;
  unint64_t v145 = __swift_allocate_boxed_opaque_existential_0Tm(&v446);
  memcpy(v145, v87, v2);
  uint32x4_t v146 = v447;
  uint64x2_t v147 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
  DynamicType = (void *)swift_getDynamicType(v147, v146, 1);
  LODWORD(v146) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
  if (v146)
  {
    uint64_t v149 = v444;
    memcpy(v444, v87, v2);
    unint64_t v150 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v446, v149, v1, v150, 7uLL);
    uint64_t v151 = (uint64_t)v447;
    uint64_t v152 = v448;
    __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
    uint64_t v154 = (*(uint64_t (**)(uint64_t, uint64_t))(v152 + 8))(v151, v152);
    unint64_t v155 = v153;
    uint64_t v156 = v453;
    unint64_t v157 = HIBYTE(v453) & 0xF;
    if ((v453 & 0x2000000000000000) == 0) {
      unint64_t v157 = v452 & 0xFFFFFFFFFFFFLL;
    }
    if (v157 || (v452 & ~v453 & 0x2000000000000000) != 0)
    {
      int8x16_t v158 = v144;
      if ((v453 & 0x2000000000000000) == 0)
      {
        if ((v153 & 0x2000000000000000) != 0)
        {
          uint64_t v159 = HIBYTE(v153) & 0xF;
LABEL_124:
          _StringGuts.append(_:)(v154, v155, 0, v159);
          swift_bridgeObjectRelease(v155);
          goto LABEL_125;
        }
LABEL_102:
        uint64_t v159 = v154 & 0xFFFFFFFFFFFFLL;
        goto LABEL_124;
      }
      if ((v153 & 0x2000000000000000) == 0) {
        goto LABEL_102;
      }
      unint64_t v177 = specialized _SmallString.init(_:appending:)(v452, v453, v154, v153);
      if (v179)
      {
        uint64_t v159 = HIBYTE(v155) & 0xF;
        uint64_t v149 = v444;
        int8x16_t v158 = v144;
        goto LABEL_124;
      }
      unint64_t v180 = v177;
      unint64_t v181 = v178;
      swift_bridgeObjectRelease(v155);
      swift_bridgeObjectRelease(v156);
      unint64_t v452 = v180;
      unint64_t v453 = v181;
      uint64_t v149 = v444;
    }
    else
    {
      swift_bridgeObjectRelease(v453);
      unint64_t v452 = v154;
      unint64_t v453 = v155;
    }
    int8x16_t v158 = v144;
LABEL_125:
    uint64_t v194 = v143;
    uint64_t v195 = v438;
    __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
    goto LABEL_131;
  }
  memcpy(v83, v87, v2);
  if (swift_dynamicCast((char *)&v446, (unint64_t *)v83, v1, (const char *)&type metadata for String, 6uLL))
  {
    unint64_t countAndFlagsBits = v446._countAndFlagsBits;
    unint64_t object = (unint64_t)v446._object;
    uint64_t v162 = v453;
    unint64_t v163 = HIBYTE(v453) & 0xF;
    if ((v453 & 0x2000000000000000) == 0) {
      unint64_t v163 = v452 & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v149 = v444;
    int8x16_t v158 = v144;
    if (!v163 && (v452 & ~v453 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v453);
      unint64_t v452 = countAndFlagsBits;
      unint64_t v453 = object;
      goto LABEL_130;
    }
    if ((v453 & 0x2000000000000000) == 0)
    {
      if (((uint64_t)v446._object & 0x2000000000000000) != 0)
      {
        uint64_t v164 = ((unint64_t)v446._object >> 56) & 0xF;
LABEL_129:
        _StringGuts.append(_:)(countAndFlagsBits, object, 0, v164);
        swift_bridgeObjectRelease(object);
        goto LABEL_130;
      }
LABEL_114:
      uint64_t v164 = v446._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
      goto LABEL_129;
    }
    if (((uint64_t)v446._object & 0x2000000000000000) == 0) {
      goto LABEL_114;
    }
    unint64_t v189 = specialized _SmallString.init(_:appending:)(v452, v453, v446._countAndFlagsBits, (unint64_t)v446._object);
    if (v191)
    {
      uint64_t v164 = HIBYTE(object) & 0xF;
      uint64_t v149 = v444;
      int8x16_t v158 = v144;
      goto LABEL_129;
    }
    unint64_t v192 = v189;
    unint64_t v193 = v190;
    swift_bridgeObjectRelease(object);
    swift_bridgeObjectRelease(v162);
    unint64_t v452 = v192;
    unint64_t v453 = v193;
  }
  else
  {
    unint64_t v165 = v421;
    memcpy(v421, v87, v2);
    unint64_t v166 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v449, v165, v1, v166, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      uint64_t v167 = (uint64_t)v447;
      uint64_t v168 = v448;
      __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v168 + 8))(&v452, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v167, v168);
    }
    else
    {
      uint64_t v451 = 0;
      long long v449 = 0u;
      long long v450 = 0u;
      outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for TextOutputStreamable?);
      int64x2_t v169 = v413;
      memcpy(v413, v87, v2);
      int8x16_t v170 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
      if (swift_dynamicCast((char *)&v449, v169, v1, v170, 6uLL))
      {
        outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
        uint64_t v171 = (uint64_t)v447;
        uint64_t v172 = v448;
        __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
        unint64_t v174 = (*(uint64_t (**)(uint64_t, uint64_t))(v172 + 8))(v171, v172);
        uint64_t v175 = v173;
        unint64_t v176 = HIBYTE(v453) & 0xF;
        if ((v453 & 0x2000000000000000) == 0) {
          unint64_t v176 = v452 & 0xFFFFFFFFFFFFLL;
        }
        if (v176 || (v452 & ~v453 & 0x2000000000000000) != 0)
        {
          _StringGuts.append(_:)(v174, v173);
          swift_bridgeObjectRelease(v175);
        }
        else
        {
          swift_bridgeObjectRelease(v453);
          unint64_t v452 = v174;
          unint64_t v453 = v175;
        }
        uint64_t v149 = v444;
        int8x16_t v158 = v144;
        __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
        goto LABEL_130;
      }
      uint64_t v451 = 0;
      long long v449 = 0u;
      long long v450 = 0u;
      outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for CustomStringConvertible?);
      unint64_t v182 = v405;
      memcpy(v405, v87, v2);
      uint16x8_t v183 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
      if (!swift_dynamicCast((char *)&v449, v182, v1, v183, 6uLL))
      {
        uint64_t v451 = 0;
        long long v449 = 0u;
        long long v450 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
        *((void *)&v450 + 1) = v1;
        unint64_t v196 = __swift_allocate_boxed_opaque_existential_0Tm(&v449);
        memcpy(v196, v87, v2);
        Mirror.init(reflecting:)((uint64_t *)&v449, (uint64_t)&v446);
        int64x2_t v197 = v446._object;
        uint64_t v198 = v448;
        ((void (*)(char *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v87, &v446, &v452, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
        swift_release(v198);
        swift_release((uint64_t)v197);
        goto LABEL_100;
      }
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      uint64_t v184 = (uint64_t)v447;
      uint64_t v185 = v448;
      __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
      unint64_t v186 = (*(uint64_t (**)(uint64_t, uint64_t))(v185 + 8))(v184, v185);
      uint64_t v188 = v187;
      specialized String.write<A>(to:)(&v452, v186, v187);
      swift_bridgeObjectRelease(v188);
    }
    __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
  }
LABEL_100:
  uint64_t v149 = v444;
  int8x16_t v158 = v144;
LABEL_130:
  uint64_t v194 = v143;
  uint64_t v195 = v438;
LABEL_131:
  uint64_t v199 = v453;
  unint64_t v200 = HIBYTE(v453) & 0xF;
  if ((v453 & 0x2000000000000000) == 0) {
    unint64_t v200 = v452 & 0xFFFFFFFFFFFFLL;
  }
  if (v200 || (v452 & ~v453 & 0x2000000000000000) != 0)
  {
    if ((v453 & 0x2000000000000000) == 0
      || (unint64_t v201 = specialized _SmallString.init(_:appending:)(v452, v453, 0x202CuLL, 0xE200000000000000),
          (v203 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000);
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      unint64_t v204 = v201;
      unint64_t v205 = v202;
      swift_bridgeObjectRelease(v199);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v452 = v204;
      unint64_t v453 = v205;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v453);
    unint64_t v452 = 8236;
    unint64_t v453 = 0xE200000000000000;
  }
  v158(1, v445, v194);
  v447 = (uint64_t *)v1;
  int8x16_t v206 = __swift_allocate_boxed_opaque_existential_0Tm(&v446);
  memcpy(v206, v195, v2);
  int8x16_t v207 = v447;
  int8x16_t v208 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
  int8x16_t v209 = (void *)swift_getDynamicType(v208, v207, 1);
  LODWORD(v207) = swift_isOptionalType(v209);
  __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
  if (v207)
  {
    memcpy(v149, v195, v2);
    int8x16_t v210 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v446, v149, v1, v210, 7uLL);
    uint64_t v211 = (uint64_t)v447;
    uint64_t v212 = v448;
    __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
    unint64_t v214 = (*(uint64_t (**)(uint64_t, uint64_t))(v212 + 8))(v211, v212);
    unint64_t v215 = v213;
    unint64_t v216 = HIBYTE(v453) & 0xF;
    if ((v453 & 0x2000000000000000) == 0) {
      unint64_t v216 = v452 & 0xFFFFFFFFFFFFLL;
    }
    if (!v216 && (v452 & ~v453 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v453);
      unint64_t v452 = v214;
      unint64_t v453 = v215;
      goto LABEL_146;
    }
    _StringGuts.append(_:)(v214, v213);
    uint64_t v217 = v215;
    goto LABEL_145;
  }
  unint64_t v218 = v429;
  memcpy(v429, v195, v2);
  if (swift_dynamicCast((char *)&v446, v218, v1, (const char *)&type metadata for String, 6uLL))
  {
    uint64x2_t v219 = v446._object;
    String.append(_:)(v446);
    swift_bridgeObjectRelease((uint64_t)v219);
  }
  else
  {
    uint64_t v306 = v422;
    memcpy(v422, v195, v2);
    size_t v307 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v449, v306, v1, v307, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      uint64_t v308 = (uint64_t)v447;
      uint64_t v309 = v448;
      __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v309 + 8))(&v452, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v308, v309);
      goto LABEL_146;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for TextOutputStreamable?);
    size_t v334 = v414;
    memcpy(v414, v195, v2);
    v335 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v449, v334, v1, v335, 6uLL)
      || (uint64_t v451 = 0,
          long long v449 = 0u,
          long long v450 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for CustomStringConvertible?), v360 = v406, memcpy(v406, v195, v2), v361 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v449, v360, v1, v361, 6uLL)))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      uint64_t v362 = (uint64_t)v447;
      uint64_t v363 = v448;
      __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
      unint64_t v364 = (*(uint64_t (**)(uint64_t, uint64_t))(v363 + 8))(v362, v363);
      unint64_t v366 = v365;
      specialized String.write<A>(to:)(&v452, v364, v365);
      uint64_t v217 = v366;
LABEL_145:
      swift_bridgeObjectRelease(v217);
LABEL_146:
      __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
      goto LABEL_149;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v450 + 1) = v1;
    v379 = __swift_allocate_boxed_opaque_existential_0Tm(&v449);
    memcpy(v379, v195, v2);
    Mirror.init(reflecting:)((uint64_t *)&v449, (uint64_t)&v446);
    v380 = v446._object;
    uint64_t v381 = v448;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v195, &v446, &v452, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v381);
    swift_release((uint64_t)v380);
  }
LABEL_149:
  uint64x2_t v220 = v439;
  unint64_t v221 = HIBYTE(v453) & 0xF;
  if ((v453 & 0x2000000000000000) == 0) {
    unint64_t v221 = v452 & 0xFFFFFFFFFFFFLL;
  }
  if (v221 || (v452 & ~v453 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v453);
    unint64_t v452 = 8236;
    unint64_t v453 = 0xE200000000000000;
  }
  v158(2, v445, v194);
  v447 = (uint64_t *)v1;
  unint64_t v222 = __swift_allocate_boxed_opaque_existential_0Tm(&v446);
  memcpy(v222, v220, v2);
  unint64_t v223 = v447;
  char v224 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
  unint64_t v225 = (void *)swift_getDynamicType(v224, v223, 1);
  LODWORD(v223) = swift_isOptionalType(v225);
  __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
  if (v223)
  {
    memcpy(v149, v220, v2);
    int8x16_t v226 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v446, v149, v1, v226, 7uLL);
LABEL_156:
    uint64_t v227 = (uint64_t)v447;
    uint64_t v228 = v448;
    __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
    unint64_t v229 = (*(uint64_t (**)(uint64_t, uint64_t))(v228 + 8))(v227, v228);
LABEL_157:
    uint64_t v231 = v230;
    specialized String.write<A>(to:)(&v452, v229, v230);
    swift_bridgeObjectRelease(v231);
LABEL_158:
    __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
    goto LABEL_161;
  }
  unint64_t v232 = v430;
  memcpy(v430, v220, v2);
  if (swift_dynamicCast((char *)&v446, v232, v1, (const char *)&type metadata for String, 6uLL))
  {
    uint64_t v233 = v446._object;
    String.append(_:)(v446);
    swift_bridgeObjectRelease((uint64_t)v233);
  }
  else
  {
    unint64_t v310 = v423;
    memcpy(v423, v220, v2);
    unint64_t v311 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v449, v310, v1, v311, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      uint64_t v312 = (uint64_t)v447;
      uint64_t v313 = v448;
      __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v313 + 8))(&v452, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v312, v313);
      goto LABEL_158;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for TextOutputStreamable?);
    v336 = v415;
    memcpy(v415, v220, v2);
    v337 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v449, v336, v1, v337, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      uint64_t v338 = (uint64_t)v447;
      uint64_t v339 = v448;
      __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
      unint64_t v229 = (*(uint64_t (**)(uint64_t, uint64_t))(v339 + 8))(v338, v339);
      goto LABEL_157;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for CustomStringConvertible?);
    v367 = v407;
    memcpy(v407, v220, v2);
    v368 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v449, v367, v1, v368, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      goto LABEL_156;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v450 + 1) = v1;
    v382 = __swift_allocate_boxed_opaque_existential_0Tm(&v449);
    memcpy(v382, v220, v2);
    Mirror.init(reflecting:)((uint64_t *)&v449, (uint64_t)&v446);
    v383 = v446._object;
    v384 = v220;
    uint64_t v385 = v448;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v384, &v446, &v452, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v385);
    swift_release((uint64_t)v383);
  }
LABEL_161:
  unint64_t v234 = HIBYTE(v453) & 0xF;
  if ((v453 & 0x2000000000000000) == 0) {
    unint64_t v234 = v452 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v235 = v440;
  if (v234 || (v452 & ~v453 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v453);
    unint64_t v452 = 8236;
    unint64_t v453 = 0xE200000000000000;
  }
  v158(3, v445, v194);
  v447 = (uint64_t *)v1;
  uint64_t v236 = __swift_allocate_boxed_opaque_existential_0Tm(&v446);
  memcpy(v236, v235, v2);
  uint64_t v237 = v447;
  uint64_t v238 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
  char v239 = (void *)swift_getDynamicType(v238, v237, 1);
  LODWORD(v237) = swift_isOptionalType(v239);
  __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
  if (v237)
  {
    memcpy(v149, v235, v2);
    unint64_t v240 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v446, v149, v1, v240, 7uLL);
LABEL_168:
    uint64_t v241 = (uint64_t)v447;
    uint64_t v242 = v448;
    __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
    unint64_t v243 = (*(uint64_t (**)(uint64_t, uint64_t))(v242 + 8))(v241, v242);
LABEL_169:
    uint64_t v245 = v244;
    specialized String.write<A>(to:)(&v452, v243, v244);
    swift_bridgeObjectRelease(v245);
LABEL_170:
    __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
    goto LABEL_173;
  }
  uint64_t v246 = v431;
  memcpy(v431, v235, v2);
  if (swift_dynamicCast((char *)&v446, v246, v1, (const char *)&type metadata for String, 6uLL))
  {
    Swift::Int v247 = v446._object;
    String.append(_:)(v446);
    swift_bridgeObjectRelease((uint64_t)v247);
  }
  else
  {
    unint64_t v314 = v424;
    memcpy(v424, v235, v2);
    char v315 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v449, v314, v1, v315, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      uint64_t v316 = (uint64_t)v447;
      uint64_t v317 = v448;
      __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v317 + 8))(&v452, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v316, v317);
      goto LABEL_170;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for TextOutputStreamable?);
    v340 = v416;
    memcpy(v416, v235, v2);
    v341 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v449, v340, v1, v341, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      uint64_t v342 = (uint64_t)v447;
      uint64_t v343 = v448;
      __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
      unint64_t v243 = (*(uint64_t (**)(uint64_t, uint64_t))(v343 + 8))(v342, v343);
      goto LABEL_169;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for CustomStringConvertible?);
    v369 = v408;
    memcpy(v408, v235, v2);
    v370 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v449, v369, v1, v370, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      goto LABEL_168;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v450 + 1) = v1;
    v386 = __swift_allocate_boxed_opaque_existential_0Tm(&v449);
    memcpy(v386, v235, v2);
    Mirror.init(reflecting:)((uint64_t *)&v449, (uint64_t)&v446);
    v387 = v446._object;
    v388 = v235;
    uint64_t v389 = v448;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v388, &v446, &v452, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v389);
    swift_release((uint64_t)v387);
  }
LABEL_173:
  unint64_t v248 = HIBYTE(v453) & 0xF;
  if ((v453 & 0x2000000000000000) == 0) {
    unint64_t v248 = v452 & 0xFFFFFFFFFFFFLL;
  }
  Swift::String::Index v249 = v437;
  if (v248 || (v452 & ~v453 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v453);
    unint64_t v452 = 8236;
    unint64_t v453 = 0xE200000000000000;
  }
  v158(4, v445, v194);
  v447 = (uint64_t *)v1;
  Swift::String::Index v250 = __swift_allocate_boxed_opaque_existential_0Tm(&v446);
  memcpy(v250, v249, v2);
  Swift::String::Index v251 = v447;
  Swift::Int v252 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
  uint64_t v253 = (void *)swift_getDynamicType(v252, v251, 1);
  LODWORD(v251) = swift_isOptionalType(v253);
  __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
  if (v251)
  {
    memcpy(v149, v249, v2);
    uint64_t v254 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v446, v149, v1, v254, 7uLL);
LABEL_180:
    uint64_t v255 = (uint64_t)v447;
    uint64_t v256 = v448;
    __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
    unint64_t v257 = (*(uint64_t (**)(uint64_t, uint64_t))(v256 + 8))(v255, v256);
LABEL_181:
    uint64_t v259 = v258;
    specialized String.write<A>(to:)(&v452, v257, v258);
    swift_bridgeObjectRelease(v259);
LABEL_182:
    __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
    goto LABEL_185;
  }
  unint64_t v260 = v432;
  memcpy(v432, v249, v2);
  if (swift_dynamicCast((char *)&v446, v260, v1, (const char *)&type metadata for String, 6uLL))
  {
    unint64_t v261 = v446._object;
    String.append(_:)(v446);
    swift_bridgeObjectRelease((uint64_t)v261);
  }
  else
  {
    unint64_t v318 = v425;
    memcpy(v425, v249, v2);
    unint64_t v319 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v449, v318, v1, v319, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      uint64_t v320 = (uint64_t)v447;
      uint64_t v321 = v448;
      __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v321 + 8))(&v452, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v320, v321);
      goto LABEL_182;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for TextOutputStreamable?);
    v344 = v417;
    memcpy(v417, v249, v2);
    v345 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v449, v344, v1, v345, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      uint64_t v346 = (uint64_t)v447;
      uint64_t v347 = v448;
      __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
      unint64_t v257 = (*(uint64_t (**)(uint64_t, uint64_t))(v347 + 8))(v346, v347);
      goto LABEL_181;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for CustomStringConvertible?);
    v371 = v409;
    memcpy(v409, v249, v2);
    v372 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v449, v371, v1, v372, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      goto LABEL_180;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v450 + 1) = v1;
    v390 = __swift_allocate_boxed_opaque_existential_0Tm(&v449);
    memcpy(v390, v249, v2);
    Mirror.init(reflecting:)((uint64_t *)&v449, (uint64_t)&v446);
    v391 = v446._object;
    v392 = v249;
    uint64_t v393 = v448;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v392, &v446, &v452, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v393);
    swift_release((uint64_t)v391);
  }
LABEL_185:
  unint64_t v262 = HIBYTE(v453) & 0xF;
  if ((v453 & 0x2000000000000000) == 0) {
    unint64_t v262 = v452 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v263 = v441;
  if (v262 || (v452 & ~v453 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v453);
    unint64_t v452 = 8236;
    unint64_t v453 = 0xE200000000000000;
  }
  v158(5, v445, v194);
  v447 = (uint64_t *)v1;
  unint64_t v264 = __swift_allocate_boxed_opaque_existential_0Tm(&v446);
  memcpy(v264, v263, v2);
  unint64_t v265 = v447;
  char v266 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
  unint64_t v267 = (void *)swift_getDynamicType(v266, v265, 1);
  LODWORD(v265) = swift_isOptionalType(v267);
  __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
  if (v265)
  {
    memcpy(v149, v263, v2);
    unint64_t v268 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v446, v149, v1, v268, 7uLL);
LABEL_192:
    uint64_t v269 = (uint64_t)v447;
    uint64_t v270 = v448;
    __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
    unint64_t v271 = (*(uint64_t (**)(uint64_t, uint64_t))(v270 + 8))(v269, v270);
LABEL_193:
    uint64_t v273 = v272;
    specialized String.write<A>(to:)(&v452, v271, v272);
    swift_bridgeObjectRelease(v273);
LABEL_194:
    __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
    goto LABEL_197;
  }
  long long v274 = v433;
  memcpy(v433, v263, v2);
  if (swift_dynamicCast((char *)&v446, v274, v1, (const char *)&type metadata for String, 6uLL))
  {
    Swift::String v275 = v446._object;
    String.append(_:)(v446);
    swift_bridgeObjectRelease((uint64_t)v275);
  }
  else
  {
    v322 = v426;
    memcpy(v426, v263, v2);
    v323 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v449, v322, v1, v323, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      uint64_t v324 = (uint64_t)v447;
      uint64_t v325 = v448;
      __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v325 + 8))(&v452, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v324, v325);
      goto LABEL_194;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for TextOutputStreamable?);
    v348 = v418;
    memcpy(v418, v263, v2);
    uint64_t v349 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v449, v348, v1, v349, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      uint64_t v350 = (uint64_t)v447;
      uint64_t v351 = v448;
      __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
      unint64_t v271 = (*(uint64_t (**)(uint64_t, uint64_t))(v351 + 8))(v350, v351);
      goto LABEL_193;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for CustomStringConvertible?);
    v373 = v410;
    memcpy(v410, v263, v2);
    v374 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v449, v373, v1, v374, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      goto LABEL_192;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v450 + 1) = v1;
    v394 = __swift_allocate_boxed_opaque_existential_0Tm(&v449);
    memcpy(v394, v263, v2);
    Mirror.init(reflecting:)((uint64_t *)&v449, (uint64_t)&v446);
    v395 = v446._object;
    v396 = v263;
    uint64_t v397 = v448;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v396, &v446, &v452, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v397);
    swift_release((uint64_t)v395);
  }
LABEL_197:
  unint64_t v276 = HIBYTE(v453) & 0xF;
  if ((v453 & 0x2000000000000000) == 0) {
    unint64_t v276 = v452 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v277 = v442;
  if (v276 || (v452 & ~v453 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v453);
    unint64_t v452 = 8236;
    unint64_t v453 = 0xE200000000000000;
  }
  v158(6, v445, v194);
  v447 = (uint64_t *)v1;
  unint64_t v278 = __swift_allocate_boxed_opaque_existential_0Tm(&v446);
  memcpy(v278, v277, v2);
  unint64_t v279 = v447;
  unint64_t v280 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
  uint64_t v281 = (void *)swift_getDynamicType(v280, v279, 1);
  LODWORD(v279) = swift_isOptionalType(v281);
  __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
  if (v279)
  {
    memcpy(v149, v277, v2);
    unint64_t v282 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v446, v149, v1, v282, 7uLL);
LABEL_204:
    uint64_t v283 = (uint64_t)v447;
    uint64_t v284 = v448;
    __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
    unint64_t v285 = (*(uint64_t (**)(uint64_t, uint64_t))(v284 + 8))(v283, v284);
LABEL_205:
    uint64_t v287 = v286;
    specialized String.write<A>(to:)(&v452, v285, v286);
    swift_bridgeObjectRelease(v287);
LABEL_206:
    __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
    goto LABEL_209;
  }
  uint64_t v288 = v434;
  memcpy(v434, v277, v2);
  if (swift_dynamicCast((char *)&v446, v288, v1, (const char *)&type metadata for String, 6uLL))
  {
    unint64_t v289 = v446._object;
    String.append(_:)(v446);
    swift_bridgeObjectRelease((uint64_t)v289);
  }
  else
  {
    v326 = v427;
    memcpy(v427, v277, v2);
    uint64_t v327 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v449, v326, v1, v327, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      uint64_t v328 = (uint64_t)v447;
      uint64_t v329 = v448;
      __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v329 + 8))(&v452, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v328, v329);
      goto LABEL_206;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for TextOutputStreamable?);
    uint64_t v352 = v419;
    memcpy(v419, v277, v2);
    unint64_t v353 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v449, v352, v1, v353, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      uint64_t v354 = (uint64_t)v447;
      uint64_t v355 = v448;
      __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
      unint64_t v285 = (*(uint64_t (**)(uint64_t, uint64_t))(v355 + 8))(v354, v355);
      goto LABEL_205;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for CustomStringConvertible?);
    v375 = v411;
    memcpy(v411, v277, v2);
    v376 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v449, v375, v1, v376, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      goto LABEL_204;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v450 + 1) = v1;
    v398 = __swift_allocate_boxed_opaque_existential_0Tm(&v449);
    memcpy(v398, v277, v2);
    Mirror.init(reflecting:)((uint64_t *)&v449, (uint64_t)&v446);
    v399 = v446._object;
    v400 = v277;
    uint64_t v401 = v448;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v400, &v446, &v452, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v401);
    swift_release((uint64_t)v399);
  }
LABEL_209:
  unint64_t v290 = HIBYTE(v453) & 0xF;
  if ((v453 & 0x2000000000000000) == 0) {
    unint64_t v290 = v452 & 0xFFFFFFFFFFFFLL;
  }
  v291 = v443;
  if (v290 || (v452 & ~v453 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v453);
    unint64_t v452 = 8236;
    unint64_t v453 = 0xE200000000000000;
  }
  v158(7, v445, v194);
  v447 = (uint64_t *)v1;
  v292 = __swift_allocate_boxed_opaque_existential_0Tm(&v446);
  memcpy(v292, v291, v2);
  uint64_t v293 = v447;
  uint64_t v294 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
  v295 = (void *)swift_getDynamicType(v294, v293, 1);
  LODWORD(v293) = swift_isOptionalType(v295);
  __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
  if (v293)
  {
    memcpy(v149, v291, v2);
    v296 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v446, v149, v1, v296, 7uLL);
LABEL_216:
    uint64_t v297 = (uint64_t)v447;
    uint64_t v298 = v448;
    __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
    unint64_t v299 = (*(uint64_t (**)(uint64_t, uint64_t))(v298 + 8))(v297, v298);
LABEL_217:
    uint64_t v301 = v300;
    specialized String.write<A>(to:)(&v452, v299, v300);
    swift_bridgeObjectRelease(v301);
LABEL_218:
    __swift_destroy_boxed_opaque_existential_1Tm(&v446._countAndFlagsBits);
    goto LABEL_221;
  }
  uint64_t v302 = v435;
  memcpy(v435, v291, v2);
  if (swift_dynamicCast((char *)&v446, v302, v1, (const char *)&type metadata for String, 6uLL))
  {
    v303 = v446._object;
    String.append(_:)(v446);
    swift_bridgeObjectRelease((uint64_t)v303);
  }
  else
  {
    uint64_t v330 = v428;
    memcpy(v428, v291, v2);
    Swift::Int v331 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v449, v330, v1, v331, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      uint64_t v332 = (uint64_t)v447;
      uint64_t v333 = v448;
      __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v333 + 8))(&v452, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v332, v333);
      goto LABEL_218;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for TextOutputStreamable?);
    v356 = v420;
    memcpy(v420, v291, v2);
    v357 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v449, v356, v1, v357, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      uint64_t v358 = (uint64_t)v447;
      uint64_t v359 = v448;
      __swift_project_boxed_opaque_existential_0Tm(&v446, (uint64_t)v447);
      unint64_t v299 = (*(uint64_t (**)(uint64_t, uint64_t))(v359 + 8))(v358, v359);
      goto LABEL_217;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for CustomStringConvertible?);
    v377 = v412;
    memcpy(v412, v291, v2);
    v378 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v449, v377, v1, v378, 6uLL))
    {
      outlined init with take of MirrorPath(&v449, (uint64_t)&v446);
      goto LABEL_216;
    }
    uint64_t v451 = 0;
    long long v449 = 0u;
    long long v450 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v449, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v450 + 1) = v1;
    v402 = __swift_allocate_boxed_opaque_existential_0Tm(&v449);
    memcpy(v402, v291, v2);
    Mirror.init(reflecting:)((uint64_t *)&v449, (uint64_t)&v446);
    v403 = v446._object;
    uint64_t v404 = v448;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v291, &v446, &v452, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v404);
    swift_release((uint64_t)v403);
  }
LABEL_221:
  unint64_t v304 = HIBYTE(v453) & 0xF;
  if ((v453 & 0x2000000000000000) == 0) {
    unint64_t v304 = v452 & 0xFFFFFFFFFFFFLL;
  }
  if (v304 || (v452 & ~v453 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x29uLL, 0xE100000000000000);
    swift_bridgeObjectRelease(0xE100000000000000);
    return v452;
  }
  else
  {
    swift_bridgeObjectRelease(v453);
    return 41;
  }
}

uint64_t SIMD8<>.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v38 = a1;
  uint64_t v36 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v33 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v32 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v30 = a7;
  uint64_t v31 = v21;
  uint64_t v37 = a3;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v23 = 0;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  do
  {
    uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v31);
    v24(v23, v25, v22);
    (*(void (**)(char *, uint64_t, void))(*(void *)(v34 + 16) + 72))(v14, v37, *(void *)(v35 + 8));
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v16, v23++, v32, AssociatedConformanceWitness);
  }
  while (v23 != 8);
  uint64_t v27 = type metadata accessor for SIMD8(0, v37, (uint64_t)v30, v26);
  return (*((uint64_t (**)(uint64_t, Class *))*(v27 - 1) + 1))(v38, v27);
}

{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  int **v17;
  const char *AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  void (*v20)(const char *, uint64_t);
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  Class *v27;
  uint64_t v29;
  uint64_t v30;
  int **v31;
  void (*v32)(uint64_t, uint64_t *, uint64_t);
  uint64_t v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;

  uint64_t v37 = a6;
  uint64_t v38 = a8;
  uint64_t v30 = a4;
  uint64_t v40 = a1;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v36 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v35 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v31 = a7;
  uint64_t v39 = a3;
  uint64_t v34 = v21;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v23 = 0;
  uint64_t v32 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  uint64_t v33 = v22;
  uint64_t v24 = v30;
  do
  {
    uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v34);
    v32(v23, v25, v33);
    (*(void (**)(char *, uint64_t, uint64_t))(v24 + 80))(v14, v39, v37);
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v16, v23++, v35, AssociatedConformanceWitness);
  }
  while (v23 != 8);
  uint64_t v27 = type metadata accessor for SIMD8(0, v39, (uint64_t)v31, v26);
  return (*((uint64_t (**)(uint64_t, Class *))*(v27 - 1) + 1))(v40, v27);
}

uint64_t SIMD16._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage, a2);
}

uint64_t SIMD16._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
}

uint64_t (*SIMD16._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD16.scalarCount.getter()
{
  return 16;
}

uint64_t key path getter for SIMD16.subscript(_:) : <A>SIMD16<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  if ((unint64_t)*a2 >= 0x10) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x27FuLL, 0);
  }
  uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  uint64_t v4 = *(int ***)((char *)a2 + a3 - 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD16.subscript(_:) : <A>SIMD16<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + a3 - 16);
  uint64_t v5 = *(int ***)(a4 + a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v17 - v6;
  unint64_t v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 0x10) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x283uLL, 0);
  }
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v14 = *(uint64_t (**)(char *, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v15 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD16.subscript.modify(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x10) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x27FuLL, 0);
  }
  uint64_t v10 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD16.init(_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:)(const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, const void *a7, const void *a8, const void *a9, const void *a10, const void *a11, const void *a12, const void *a13, const void *a14, const void *a15, const void *a16, uint64_t a17, int **a18)
{
  uint64_t v31 = a8;
  uint64_t v28 = a6;
  uint64_t v29 = a7;
  uint64_t v26 = a4;
  uint64_t v27 = a5;
  uint64_t v37 = a15;
  uint64_t v38 = a16;
  uint64_t v35 = a13;
  uint64_t v36 = a14;
  uint64_t v33 = a11;
  uint64_t v34 = a12;
  size_t v21 = *(void *)(*(void *)(a17 - 8) + 64);
  uint64_t v32 = a10;
  uint64_t v30 = a9;
  MEMORY[0x1F4188790](a1);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a18, a17, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a18, a17, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), a1, v21);
  uint64_t v24 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), a2, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 1, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), a3, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 2, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v26, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 3, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v27, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 4, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v28, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 5, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v29, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 6, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v31, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 7, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v30, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 8, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v32, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 9, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v33, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 10, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v34, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 11, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v35, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 12, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v36, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 13, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v37, v21);
  v24((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 14, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), v38, v21);
  return ((uint64_t (*)(char *, uint64_t, const char *, uint64_t))v24)((char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0), 15, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t SIMD16.init(lowHalf:highHalf:)(uint64_t a1, uint64_t a2, uint64_t a3, int **a4)
{
  void (*v15)(Class *__return_ptr, uint64_t, Class *);
  uint64_t vars8;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  size_t v11 = type metadata accessor for SIMD16(0, a3, (uint64_t)a4, v10);
  specialized SIMD16.lowHalf.setter(a1, (uint64_t)v11);
  uint64_t v13 = type metadata accessor for SIMD8(0, a3, (uint64_t)a4, v12);
  uint64_t v15 = (void (*)(Class *__return_ptr, uint64_t, Class *))*((void *)*(v13 - 1) + 1);
  v15(v13 - 1, a1, v13);
  specialized SIMD16.highHalf.setter(a2, (uint64_t)v11);

  return ((uint64_t (*)(uint64_t, Class *))v15)(a2, v13);
}

uint64_t SIMD16.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD16.lowHalf.setter, (uint64_t (*)(void, void, void))type metadata accessor for SIMD8);
}

uint64_t SIMD64.oddHalf.setter(uint64_t a1, uint64_t a2, void (*a3)(void), uint64_t (*a4)(void, void, void))
{
  a3();
  uint64_t v7 = a4(0, *(void *)(a2 + 16), *(void *)(a2 + 24));
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v7 - 8) + 8);

  return v8(a1, v7);
}

uint64_t SIMD16.highHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD16.highHalf.setter, (uint64_t (*)(void, void, void))type metadata accessor for SIMD8);
}

uint64_t SIMD16.lowHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v42 = a2;
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)v38 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = *(int ***)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  size_t v11 = AssociatedTypeWitness;
  uint64_t v46 = AssociatedTypeWitness;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v12 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v13 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v45 = *(void (**)(void, uint64_t *, uint64_t))(v13 + 56);
  uint64_t v14 = v45;
  uint64_t v15 = swift_checkMetadataState(0, (uint64_t)v12);
  v14(0, v15, v13);
  uint64_t v16 = AssociatedConformanceWitness + 64;
  uint64_t v44 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v17 = v11;
  uint64_t v18 = AssociatedConformanceWitness;
  v44(v6, 0, v17, AssociatedConformanceWitness);
  uint64_t v19 = swift_checkMetadataState(0, (uint64_t)v12);
  uint64_t v43 = v2;
  v45(1, v19, v13);
  uint64_t v20 = AssociatedConformanceWitness;
  size_t v21 = v44;
  v44(v6, 1, v46, v20);
  uint64_t v22 = swift_checkMetadataState(0, (uint64_t)v12);
  uint64_t v23 = v45;
  v45(2, v22, v13);
  uint64_t v39 = v18;
  v21(v6, 2, v46, v18);
  uint64_t v24 = swift_checkMetadataState(0, (uint64_t)v12);
  uint64_t v40 = v13;
  v23(3, v24, v13);
  v38[1] = v13 + 56;
  uint64_t v25 = v46;
  v44(v6, 3, v46, v18);
  uint64_t v41 = v16;
  v38[0] = (uint64_t)v12;
  uint64_t v26 = swift_checkMetadataState(0, (uint64_t)v12);
  v23(4, v26, v13);
  uint64_t v27 = v39;
  uint64_t v28 = v44;
  v44(v6, 4, v25, v39);
  uint64_t v29 = swift_checkMetadataState(0, (uint64_t)v12);
  uint64_t v30 = v40;
  uint64_t v31 = v45;
  v45(5, v29, v40);
  uint64_t v32 = v46;
  v28(v6, 5, v46, v27);
  uint64_t v33 = v38[0];
  uint64_t v34 = swift_checkMetadataState(0, v38[0]);
  v31(6, v34, v30);
  uint64_t v35 = v39;
  v28(v6, 6, v32, v39);
  uint64_t v36 = swift_checkMetadataState(0, v33);
  v31(7, v36, v40);
  return ((uint64_t (*)(char *, uint64_t, const char *, uint64_t))v28)(v6, 7, v32, v35);
}

uint64_t key path getter for SIMD16.lowHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD16, (uint64_t (*)(uint64_t))SIMD16.lowHalf.getter);
}

uint64_t key path setter for SIMD16.lowHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(void, void, void))type metadata accessor for SIMD16, specialized SIMD16.lowHalf.setter);
}

uint64_t key path setter for SIMD64.oddHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void, void, void), uint64_t (*a6)(uint64_t, uint64_t))
{
  uint64_t v8 = a5(0, *(void *)(a4 + a3 - 16), *(void *)(a4 + a3 - 8));
  return a6(a1, v8);
}

void (*SIMD16.lowHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD8(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD16.lowHalf.getter(a2, (uint64_t)v10);
  return SIMD16.lowHalf.modify;
}

void SIMD16.lowHalf.modify(uint64_t **a1, char a2)
{
}

void SIMD64.oddHalf.modify(uint64_t **a1, char a2, void (*a3)(void *, uint64_t))
{
  uint64_t v4 = *a1;
  uint64_t v5 = (void *)(*a1)[4];
  uint64_t v6 = (void *)(*a1)[5];
  uint64_t v7 = (*a1)[2];
  uint64_t v8 = (*a1)[3];
  uint64_t v9 = **a1;
  if (a2)
  {
    (*(void (**)(uint64_t, void *, uint64_t))(v8 + 16))((*a1)[4], v6, v7);
    a3(v5, v9);
    uint64_t v10 = *(void (**)(void *, uint64_t))(v8 + 8);
    v10(v5, v7);
    v10(v6, v7);
  }
  else
  {
    a3((void *)(*a1)[5], v9);
    (*(void (**)(void *, uint64_t))(v8 + 8))(v6, v7);
  }
  free(v6);
  free(v5);

  free(v4);
}

uint64_t SIMD16.highHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = *(int ***)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v18 = AssociatedTypeWitness;
  uint64_t v19 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  size_t v11 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v12 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v13 = 0;
  uint64_t v14 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v12 + 56);
  do
  {
    uint64_t v15 = swift_checkMetadataState(0, (uint64_t)v11);
    v14(v13 + 8, v15, v12);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v6, v13++, v18, AssociatedConformanceWitness);
  }
  while (v13 != 8);
  return result;
}

uint64_t key path getter for SIMD16.highHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD16, (uint64_t (*)(uint64_t))SIMD16.highHalf.getter);
}

uint64_t key path setter for SIMD16.highHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(void, void, void))type metadata accessor for SIMD16, specialized SIMD16.highHalf.setter);
}

void (*SIMD16.highHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD8(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD16.highHalf.getter(a2, (uint64_t)v10);
  return SIMD16.highHalf.modify;
}

void SIMD16.highHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD16.evenHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = *(int ***)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v18 = AssociatedTypeWitness;
  uint64_t v19 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v17 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v11 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)v17, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v11 + 56);
  do
  {
    uint64_t v15 = swift_checkMetadataState(0, (uint64_t)v17);
    v14(v12, v15, v11);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v6, v13, v18, AssociatedConformanceWitness);
    v12 += 2;
    ++v13;
  }
  while (v13 != 8);
  return result;
}

uint64_t key path getter for SIMD16.evenHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD16, (uint64_t (*)(uint64_t))SIMD16.evenHalf.getter);
}

uint64_t key path setter for SIMD16.evenHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(void, void, void))type metadata accessor for SIMD16, specialized SIMD16.evenHalf.setter);
}

uint64_t SIMD16.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD16.evenHalf.setter, (uint64_t (*)(void, void, void))type metadata accessor for SIMD8);
}

void (*SIMD16.evenHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD8(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD16.evenHalf.getter(a2, (uint64_t)v10);
  return SIMD16.evenHalf.modify;
}

void SIMD16.evenHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD16.oddHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = *(int ***)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v18 = AssociatedTypeWitness;
  uint64_t v19 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v17 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v11 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)v17, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v12 = 0;
  uint64_t v13 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v11 + 56);
  uint64_t v14 = 1;
  do
  {
    uint64_t v15 = swift_checkMetadataState(0, (uint64_t)v17);
    v13(v14, v15, v11);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v6, v12, v18, AssociatedConformanceWitness);
    v14 += 2;
    ++v12;
  }
  while (v12 != 8);
  return result;
}

uint64_t key path getter for SIMD16.oddHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD16, (uint64_t (*)(uint64_t))SIMD16.oddHalf.getter);
}

uint64_t key path setter for SIMD16.oddHalf : <A>SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(void, void, void))type metadata accessor for SIMD16, specialized SIMD16.oddHalf.setter);
}

uint64_t SIMD16.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD16.oddHalf.setter, (uint64_t (*)(void, void, void))type metadata accessor for SIMD8);
}

void (*SIMD16.oddHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD8(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD16.oddHalf.getter(a2, (uint64_t)v10);
  return SIMD16.oddHalf.modify;
}

void SIMD16.oddHalf.modify(uint64_t **a1, char a2)
{
}

Swift::Int SIMD16.hashValue.getter(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, protocol conformance descriptor for SIMD16<A>, a3);
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD16<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>(a1, a2, associated type descriptor for SIMDScalar.SIMD16Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD16<A>(unint64_t a1, uint64_t a2)
{
  if (a1 >= 0x10) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x27FuLL, 0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  size_t v9 = *(uint64_t (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v7 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD16<A>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 0x10) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x283uLL, 0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  size_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD16<A>(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x10) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x27FuLL, 0);
  }
  uint64_t v10 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD16<A>(void *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD16<A>, a2, a3);
  return SIMD.encode(to:)(a1, (uint64_t)a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD16<A>@<X0>(uint64_t *a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD16<A>, a2, a3);
  return SIMD.init(from:)(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD16<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD16<A>, a2, a3);

  return SIMD.hash(into:)(a1, (uint64_t)a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD16<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(a1, a2, a3, protocol conformance descriptor for SIMD16<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD16<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD16<A>, a1, a3);

  return SIMD.description.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD16<A>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD16<A>, a2, a3);

  return SIMD.init(arrayLiteral:)(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD16<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v47 = a1;
  uint64_t v40 = *(void *)(a3 + 16);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v39 = (char *)&v36 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = MEMORY[0x1F4188790](v4);
  uint64_t v45 = (char *)&v36 - v7;
  uint64_t v9 = v8;
  uint64_t v10 = MEMORY[0x1F4188790](v6);
  uint64_t v12 = (char *)&v36 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)&v36 - v13;
  uint64_t v15 = 0;
  uint64_t v17 = *(void (**)(void, void, void))(v16 + 16);
  uint64_t v46 = v16 + 16;
  uint64_t v43 = (void (**)(char *, uint64_t))(v16 + 8);
  uint64_t v44 = v18;
  char v19 = 1;
  uint64_t v41 = v20;
  uint64_t v37 = v17;
  uint64_t v38 = (char *)&v36 - v13;
  uint64_t v21 = v40;
  do
  {
    v17(v14, v47, v9);
    v17(v12, a2, v9);
    if (v19)
    {
      uint64_t v23 = *(int ***)(v9 + 24);
      AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v23, v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
      uint64_t v25 = v12;
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v23, v21, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      uint64_t v42 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
      uint64_t v27 = v42;
      uint64_t v28 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
      v27(v15, v28, AssociatedConformanceWitness);
      uint64_t v29 = *v43;
      (*v43)(v14, v44);
      uint64_t v30 = v39;
      v42(v15, v28, AssociatedConformanceWitness);
      uint64_t v9 = v44;
      ((void (*)(char *))v29)(v25);
      uint64_t v17 = v37;
      uint64_t v31 = AssociatedConformanceWitness;
      uint64_t v12 = v25;
      uint64_t v32 = (uint64_t)v28;
      a2 = v41;
      uint64_t v33 = swift_getAssociatedConformanceWitness(v31, v32, v21, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      uint64_t v34 = v30;
      uint64_t v14 = v38;
      char v19 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v33 + 8) + 8))(v45, v34, v21);
    }
    else
    {
      uint64_t v22 = *v43;
      (*v43)(v12, v9);
      v22(v14, v9);
      char v19 = 0;
    }
    ++v15;
  }
  while (v15 != 16);
  return v19 & 1;
}

uint64_t SIMD16<>.init<A>(truncatingIfNeeded:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v38 = a1;
  uint64_t v36 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v33 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v32 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v30 = a7;
  uint64_t v31 = v21;
  uint64_t v37 = a3;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v23 = 0;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  do
  {
    uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v31);
    v24(v23, v25, v22);
    (*(void (**)(char *, uint64_t, void))(*(void *)(v34 + 8) + 96))(v14, v37, *(void *)(v35 + 8));
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v16, v23++, v32, AssociatedConformanceWitness);
  }
  while (v23 != 16);
  uint64_t v27 = type metadata accessor for SIMD16(0, v37, (uint64_t)v30, v26);
  return (*((uint64_t (**)(uint64_t, Class *))*(v27 - 1) + 1))(v38, v27);
}

uint64_t SIMD16<>.init<A>(clamping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v38 = a1;
  uint64_t v36 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v33 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v32 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v30 = a7;
  uint64_t v31 = v21;
  uint64_t v37 = a3;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v23 = 0;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  do
  {
    uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v31);
    v24(v23, v25, v22);
    (*(void (**)(char *, uint64_t, void))(*(void *)(v34 + 8) + 104))(v14, v37, *(void *)(v35 + 8));
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v16, v23++, v32, AssociatedConformanceWitness);
  }
  while (v23 != 16);
  uint64_t v27 = type metadata accessor for SIMD16(0, v37, (uint64_t)v30, v26);
  return (*((uint64_t (**)(uint64_t, Class *))*(v27 - 1) + 1))(v38, v27);
}

uint64_t SIMD16<>.init<A>(_:rounding:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, int **a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v34 = a8;
  uint64_t v42 = a5;
  uint64_t v43 = a7;
  uint64_t v40 = a2;
  uint64_t v46 = a1;
  uint64_t v44 = a9;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v33 - v14;
  MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v33 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v19, v18, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v41 = a3;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v22 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v39 = AssociatedTypeWitness;
  v22(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v23 = v34;
  uint64_t v24 = swift_getAssociatedTypeWitness(255, v34, a4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v45 = a4;
  uint64_t v38 = v24;
  uint64_t v25 = swift_getAssociatedConformanceWitness((uint64_t)v23, a4, (uint64_t)v24, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v26 = 0;
  uint64_t v36 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v25 + 56);
  uint64_t v37 = v25;
  uint64_t v35 = AssociatedConformanceWitness + 64;
  uint64_t v27 = v43;
  uint64_t v28 = v45;
  do
  {
    uint64_t v29 = swift_checkMetadataState(0, (uint64_t)v38);
    v36(v26, v29, v37);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v27 + 16) + 304))(v40, v28);
    (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v42 + 8) + 80))(v15, v28, v27);
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v17, v26++, v39, AssociatedConformanceWitness);
  }
  while (v26 != 16);
  uint64_t v31 = type metadata accessor for SIMD16(0, v45, (uint64_t)v34, v30);
  return (*((uint64_t (**)(uint64_t, Class *))*(v31 - 1) + 1))(v46, v31);
}

unint64_t SIMD16.debugDescription.getter(uint64_t a1)
{
  v545 = (uint64_t *)a1;
  uint64_t v1 = *(Class **)(a1 + 16);
  size_t v2 = *((void *)*(v1 - 1) + 8);
  uint64_t v3 = MEMORY[0x1F4188790](a1);
  uint64_t v4 = MEMORY[0x1F4188790](v3);
  uint64_t v6 = (unint64_t *)((char *)&v495 - v5);
  uint64_t v7 = MEMORY[0x1F4188790](v4);
  v524 = (unint64_t *)((char *)&v495 - v8);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  v533 = (unint64_t *)((char *)&v495 - v10);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  v542 = (char *)&v495 - v12;
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  v505 = (unint64_t *)((char *)&v495 - v14);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  v515 = (unint64_t *)((char *)&v495 - v16);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  v523 = (unint64_t *)((char *)&v495 - v18);
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  v532 = (unint64_t *)((char *)&v495 - v20);
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  v541 = (char *)&v495 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  v504 = (unint64_t *)((char *)&v495 - v24);
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  v514 = (unint64_t *)((char *)&v495 - v26);
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  v522 = (unint64_t *)((char *)&v495 - v28);
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  v531 = (unint64_t *)((char *)&v495 - v30);
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  v540 = (char *)&v495 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  v503 = (unint64_t *)((char *)&v495 - v34);
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  v513 = (unint64_t *)((char *)&v495 - v36);
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  v521 = (unint64_t *)((char *)&v495 - v38);
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  v530 = (unint64_t *)((char *)&v495 - v40);
  uint64_t v41 = MEMORY[0x1F4188790](v39);
  v539 = (char *)&v495 - v42;
  uint64_t v43 = MEMORY[0x1F4188790](v41);
  v502 = (unint64_t *)((char *)&v495 - v44);
  uint64_t v45 = MEMORY[0x1F4188790](v43);
  v512 = (unint64_t *)((char *)&v495 - v46);
  uint64_t v47 = MEMORY[0x1F4188790](v45);
  v520 = (unint64_t *)((char *)&v495 - v48);
  uint64_t v49 = MEMORY[0x1F4188790](v47);
  v529 = (unint64_t *)((char *)&v495 - v50);
  uint64_t v51 = MEMORY[0x1F4188790](v49);
  v538 = (char *)&v495 - v52;
  uint64_t v53 = MEMORY[0x1F4188790](v51);
  v501 = (unint64_t *)((char *)&v495 - v54);
  uint64_t v55 = MEMORY[0x1F4188790](v53);
  v511 = (unint64_t *)((char *)&v495 - v56);
  uint64_t v57 = MEMORY[0x1F4188790](v55);
  v519 = (unint64_t *)((char *)&v495 - v58);
  uint64_t v59 = MEMORY[0x1F4188790](v57);
  v528 = (unint64_t *)((char *)&v495 - v60);
  uint64_t v61 = MEMORY[0x1F4188790](v59);
  v537 = (char *)&v495 - v62;
  uint64_t v63 = MEMORY[0x1F4188790](v61);
  v500 = (unint64_t *)((char *)&v495 - v64);
  uint64_t v65 = MEMORY[0x1F4188790](v63);
  v510 = (unint64_t *)((char *)&v495 - v66);
  uint64_t v67 = MEMORY[0x1F4188790](v65);
  v518 = (unint64_t *)((char *)&v495 - v68);
  uint64_t v69 = MEMORY[0x1F4188790](v67);
  v527 = (unint64_t *)((char *)&v495 - v70);
  uint64_t v71 = MEMORY[0x1F4188790](v69);
  v536 = (char *)&v495 - v72;
  uint64_t v73 = MEMORY[0x1F4188790](v71);
  v499 = (unint64_t *)((char *)&v495 - v74);
  uint64_t v75 = MEMORY[0x1F4188790](v73);
  v509 = (unint64_t *)((char *)&v495 - v76);
  uint64_t v77 = MEMORY[0x1F4188790](v75);
  v517 = (unint64_t *)((char *)&v495 - v78);
  uint64_t v79 = MEMORY[0x1F4188790](v77);
  v526 = (unint64_t *)((char *)&v495 - v80);
  uint64_t v81 = MEMORY[0x1F4188790](v79);
  v535 = (char *)&v495 - v82;
  uint64_t v83 = MEMORY[0x1F4188790](v81);
  v498 = (unint64_t *)((char *)&v495 - v84);
  uint64_t v85 = MEMORY[0x1F4188790](v83);
  v508 = (unint64_t *)((char *)&v495 - v86);
  uint64_t v87 = MEMORY[0x1F4188790](v85);
  v516 = (unint64_t *)((char *)&v495 - v88);
  uint64_t v89 = MEMORY[0x1F4188790](v87);
  v525 = (unint64_t *)((char *)&v495 - v90);
  uint64_t v91 = MEMORY[0x1F4188790](v89);
  v534 = (char *)&v495 - v92;
  uint64_t v93 = MEMORY[0x1F4188790](v91);
  v497 = (unint64_t *)((char *)&v495 - v94);
  uint64_t v95 = MEMORY[0x1F4188790](v93);
  v507 = (unint64_t *)((char *)&v495 - v96);
  uint64_t v97 = MEMORY[0x1F4188790](v95);
  uint64_t v99 = (char *)&v495 - v98;
  uint64_t v100 = MEMORY[0x1F4188790](v97);
  uint64_t v102 = (char *)&v495 - v101;
  uint64_t v103 = MEMORY[0x1F4188790](v100);
  v544 = (unint64_t *)((char *)&v495 - v104);
  MEMORY[0x1F4188790](v103);
  unsigned __int8 v106 = (char *)&v495 - v105;
  unint64_t v107 = specialized static String._createEmpty(withInitialCapacity:)(74);
  uint64_t v109 = v108;
  unint64_t v552 = v107;
  unint64_t v553 = v108;
  uint64_t v110 = HIBYTE(v108) & 0xF;
  if ((v108 & 0x2000000000000000) == 0) {
    uint64_t v110 = v107 & 0xFFFFFFFFFFFFLL;
  }
  if (v110 || (v107 & ~v108 & 0x2000000000000000) != 0)
  {
    if ((v108 & 0x2000000000000000) == 0
      || (unint64_t v111 = specialized _SmallString.init(_:appending:)(v107, v108, 0x3C3631444D4953uLL, 0xE700000000000000),
          (v113 & 1) != 0))
    {
      _StringGuts.append(_:)(0x3C3631444D4953, 0xE700000000000000, 0, 7);
    }
    else
    {
      unint64_t v114 = v111;
      unint64_t v115 = v112;
      swift_bridgeObjectRelease(v109);
      unint64_t v552 = v114;
      unint64_t v553 = v115;
    }
    uint64_t v116 = 0xE700000000000000;
  }
  else
  {
    unint64_t v552 = 0x3C3631444D4953;
    unint64_t v553 = 0xE700000000000000;
    uint64_t v116 = v108;
  }
  swift_bridgeObjectRelease(v116);
  TypeName = (uint64_t *)swift_getTypeName(v1, 0);
  if (v118 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  uint64_t v119 = (uint8x16_t *)TypeName;
  int64_t v120 = v118;
  v506 = v6;
  v496 = (unint64_t *)((char *)&v495 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0));
  int64_t v121 = validateUTF8(_:)(TypeName, v118);
  if (v123) {
    unint64_t v124 = repairUTF8(_:firstKnownBrokenRange:)(v119->i8, v120, v121, v122);
  }
  else {
    unint64_t v124 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v119, v120, v121 & 1);
  }
  unint64_t v126 = v124;
  unint64_t v127 = v125;
  uint64_t v128 = v553;
  unint64_t v129 = HIBYTE(v553) & 0xF;
  if ((v553 & 0x2000000000000000) == 0) {
    unint64_t v129 = v552 & 0xFFFFFFFFFFFFLL;
  }
  if (v129 || (v552 & ~v553 & 0x2000000000000000) != 0)
  {
    if ((v553 & 0x2000000000000000) != 0)
    {
      if ((v125 & 0x2000000000000000) != 0)
      {
        unint64_t v131 = specialized _SmallString.init(_:appending:)(v552, v553, v124, v125);
        if ((v133 & 1) == 0)
        {
          unint64_t v134 = v131;
          unint64_t v135 = v132;
          swift_bridgeObjectRelease(v128);
          unint64_t v552 = v134;
          unint64_t v553 = v135;
          swift_bridgeObjectRelease(v127);
          unint64_t v127 = v135;
          unint64_t v126 = v134;
          goto LABEL_27;
        }
        goto LABEL_25;
      }
    }
    else if ((v125 & 0x2000000000000000) != 0)
    {
LABEL_25:
      uint64_t v130 = HIBYTE(v127) & 0xF;
      goto LABEL_26;
    }
    uint64_t v130 = v124 & 0xFFFFFFFFFFFFLL;
LABEL_26:
    _StringGuts.append(_:)(v126, v127, 0, v130);
    swift_bridgeObjectRelease(v127);
    unint64_t v126 = v552;
    unint64_t v127 = v553;
    goto LABEL_27;
  }
  unint64_t v552 = v124;
  unint64_t v553 = v125;
  swift_bridgeObjectRelease(v128);
LABEL_27:
  uint64_t v136 = HIBYTE(v127) & 0xF;
  if ((v127 & 0x2000000000000000) == 0) {
    uint64_t v136 = v126 & 0xFFFFFFFFFFFFLL;
  }
  if (v136 || (v126 & ~v127 & 0x2000000000000000) != 0)
  {
    if ((v127 & 0x2000000000000000) == 0
      || (unint64_t v137 = specialized _SmallString.init(_:appending:)(v126, v127, 0x283EuLL, 0xE200000000000000),
          (v139 & 1) != 0))
    {
      _StringGuts.append(_:)(10302, 0xE200000000000000, 0, 2);
    }
    else
    {
      unint64_t v140 = v137;
      unint64_t v141 = v138;
      swift_bridgeObjectRelease(v127);
      unint64_t v552 = v140;
      unint64_t v553 = v141;
    }
    uint64_t v142 = 0xE200000000000000;
  }
  else
  {
    unint64_t v552 = 10302;
    unint64_t v553 = 0xE200000000000000;
    uint64_t v142 = v127;
  }
  swift_bridgeObjectRelease(v142);
  uint64_t v143 = (int **)v545[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v143, (uint64_t)v1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v143, (uint64_t)v1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint32x4_t v146 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  v545 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v543 = v146;
  ((void (*)(void))v146)(0);
  v547 = (uint64_t *)v1;
  uint64x2_t v147 = __swift_allocate_boxed_opaque_existential_0Tm(&v546);
  memcpy(v147, v106, v2);
  uint64_t v148 = v547;
  uint64_t v149 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
  DynamicType = (void *)swift_getDynamicType(v149, v148, 1);
  LODWORD(v148) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
  if (!v148)
  {
    memcpy(v102, v106, v2);
    if (swift_dynamicCast((char *)&v546, (unint64_t *)v102, v1, (const char *)&type metadata for String, 6uLL))
    {
      unint64_t countAndFlagsBits = v546._countAndFlagsBits;
      unint64_t object = (unint64_t)v546._object;
      uint64_t v164 = v553;
      unint64_t v165 = HIBYTE(v553) & 0xF;
      if ((v553 & 0x2000000000000000) == 0) {
        unint64_t v165 = v552 & 0xFFFFFFFFFFFFLL;
      }
      int8x16_t v160 = v543;
      if (!v165 && (v552 & ~v553 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRetain((unint64_t)v546._object);
        swift_bridgeObjectRelease(v164);
        unint64_t v552 = countAndFlagsBits;
        unint64_t v553 = object;
        swift_bridgeObjectRelease(object);
        uint64_t v151 = v544;
        goto LABEL_90;
      }
      uint64_t v151 = v544;
      if ((v553 & 0x2000000000000000) == 0)
      {
        if (((uint64_t)v546._object & 0x2000000000000000) != 0)
        {
          uint64_t v166 = ((unint64_t)v546._object >> 56) & 0xF;
LABEL_85:
          _StringGuts.append(_:)(countAndFlagsBits, object, 0, v166);
          swift_bridgeObjectRelease(object);
          goto LABEL_90;
        }
LABEL_68:
        uint64_t v166 = v546._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
        goto LABEL_85;
      }
      if (((uint64_t)v546._object & 0x2000000000000000) == 0) {
        goto LABEL_68;
      }
      unint64_t v191 = specialized _SmallString.init(_:appending:)(v552, v553, v546._countAndFlagsBits, (unint64_t)v546._object);
      if (v193)
      {
        uint64_t v166 = HIBYTE(object) & 0xF;
        int8x16_t v160 = v543;
        uint64_t v151 = v544;
        goto LABEL_85;
      }
      unint64_t v194 = v191;
      unint64_t v195 = v192;
      swift_bridgeObjectRelease(v164);
      unint64_t v552 = v194;
      unint64_t v553 = v195;
      swift_bridgeObjectRelease(object);
    }
    else
    {
      memcpy(v99, v106, v2);
      uint64_t v167 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
      if (!swift_dynamicCast((char *)&v549, (unint64_t *)v99, v1, v167, 6uLL))
      {
        uint64_t v551 = 0;
        long long v549 = 0u;
        long long v550 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for TextOutputStreamable?);
        int8x16_t v170 = v507;
        memcpy(v507, v106, v2);
        uint64_t v171 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
        if (swift_dynamicCast((char *)&v549, v170, v1, v171, 6uLL))
        {
          outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
          uint64_t v172 = (uint64_t)v547;
          uint64_t v173 = v548;
          __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
          unint64_t v174 = (*(uint64_t (**)(uint64_t, uint64_t))(v173 + 8))(v172, v173);
          unint64_t v176 = v174;
          unint64_t v157 = v175;
          uint64_t v177 = v553;
          unint64_t v178 = HIBYTE(v553) & 0xF;
          if ((v553 & 0x2000000000000000) == 0) {
            unint64_t v178 = v552 & 0xFFFFFFFFFFFFLL;
          }
          if (v178 || (v552 & ~v553 & 0x2000000000000000) != 0)
          {
            _StringGuts.append(_:)(v174, v175);
            uint64_t v151 = v544;
          }
          else
          {
            swift_bridgeObjectRetain(v175);
            swift_bridgeObjectRelease(v177);
            unint64_t v552 = v176;
            unint64_t v553 = v157;
            uint64_t v151 = v544;
          }
          goto LABEL_88;
        }
        uint64_t v551 = 0;
        long long v549 = 0u;
        long long v550 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomStringConvertible?);
        uint64_t v184 = v497;
        memcpy(v497, v106, v2);
        uint64_t v185 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
        int v186 = swift_dynamicCast((char *)&v549, v184, v1, v185, 6uLL);
        uint64_t v151 = v544;
        if (v186)
        {
          outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
          uint64_t v187 = (uint64_t)v547;
          uint64_t v188 = v548;
          __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
          unint64_t v189 = (*(uint64_t (**)(uint64_t, uint64_t))(v188 + 8))(v187, v188);
          uint64_t v156 = v189;
          unint64_t v157 = v155;
          uint64_t v158 = v553;
          unint64_t v190 = HIBYTE(v553) & 0xF;
          if ((v553 & 0x2000000000000000) == 0) {
            unint64_t v190 = v552 & 0xFFFFFFFFFFFFLL;
          }
          if (v190 || (v552 & ~v553 & 0x2000000000000000) != 0)
          {
            _StringGuts.append(_:)(v189, v155);
            goto LABEL_88;
          }
LABEL_87:
          swift_bridgeObjectRetain(v155);
          swift_bridgeObjectRelease(v158);
          unint64_t v552 = v156;
          unint64_t v553 = v157;
          goto LABEL_88;
        }
        uint64_t v551 = 0;
        long long v549 = 0u;
        long long v550 = 0u;
        outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
        *((void *)&v550 + 1) = v1;
        unint64_t v196 = __swift_allocate_boxed_opaque_existential_0Tm(&v549);
        memcpy(v196, v106, v2);
        Mirror.init(reflecting:)((uint64_t *)&v549, (uint64_t)&v546);
        int64x2_t v197 = v546._object;
        uint64_t v198 = v548;
        ((void (*)(char *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v106, &v546, &v552, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
        swift_release(v198);
        swift_release((uint64_t)v197);
LABEL_55:
        int8x16_t v160 = v543;
        goto LABEL_90;
      }
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v168 = (uint64_t)v547;
      uint64_t v169 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v169 + 8))(&v552, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v168, v169);
      __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
    }
    uint64_t v151 = v544;
    goto LABEL_55;
  }
  uint64_t v151 = v544;
  memcpy(v544, v106, v2);
  uint64_t v152 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  swift_dynamicCast((char *)&v546, v151, v1, v152, 7uLL);
  uint64_t v153 = (uint64_t)v547;
  uint64_t v154 = v548;
  __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
  uint64_t v156 = (*(uint64_t (**)(uint64_t, uint64_t))(v154 + 8))(v153, v154);
  unint64_t v157 = v155;
  uint64_t v158 = v553;
  unint64_t v159 = HIBYTE(v553) & 0xF;
  if ((v553 & 0x2000000000000000) == 0) {
    unint64_t v159 = v552 & 0xFFFFFFFFFFFFLL;
  }
  if (!v159 && (v552 & ~v553 & 0x2000000000000000) == 0) {
    goto LABEL_87;
  }
  int8x16_t v160 = v543;
  if ((v553 & 0x2000000000000000) != 0)
  {
    if ((v155 & 0x2000000000000000) == 0) {
      goto LABEL_57;
    }
    unint64_t v179 = specialized _SmallString.init(_:appending:)(v552, v553, v156, v155);
    if (v181)
    {
      uint64_t v161 = HIBYTE(v157) & 0xF;
      int8x16_t v160 = v543;
      uint64_t v151 = v544;
      goto LABEL_81;
    }
    unint64_t v182 = v179;
    unint64_t v183 = v180;
    swift_bridgeObjectRelease(v158);
    unint64_t v552 = v182;
    unint64_t v553 = v183;
    uint64_t v151 = v544;
LABEL_88:
    int8x16_t v160 = v543;
    goto LABEL_89;
  }
  if ((v155 & 0x2000000000000000) == 0)
  {
LABEL_57:
    uint64_t v161 = v156 & 0xFFFFFFFFFFFFLL;
    goto LABEL_81;
  }
  uint64_t v161 = HIBYTE(v155) & 0xF;
LABEL_81:
  _StringGuts.append(_:)(v156, v157, 0, v161);
LABEL_89:
  swift_bridgeObjectRelease(v157);
  __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
LABEL_90:
  uint64_t v199 = v553;
  unint64_t v200 = HIBYTE(v553) & 0xF;
  if ((v553 & 0x2000000000000000) == 0) {
    unint64_t v200 = v552 & 0xFFFFFFFFFFFFLL;
  }
  if (v200 || (v552 & ~v553 & 0x2000000000000000) != 0)
  {
    if ((v553 & 0x2000000000000000) == 0
      || (unint64_t v201 = specialized _SmallString.init(_:appending:)(v552, v553, 0x202CuLL, 0xE200000000000000),
          (v203 & 1) != 0))
    {
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
    }
    else
    {
      unint64_t v204 = v201;
      unint64_t v205 = v202;
      swift_bridgeObjectRelease(v199);
      unint64_t v552 = v204;
      unint64_t v553 = v205;
    }
    uint64_t v206 = 0xE200000000000000;
  }
  else
  {
    unint64_t v552 = 8236;
    unint64_t v553 = 0xE200000000000000;
    uint64_t v206 = v199;
  }
  swift_bridgeObjectRelease(v206);
  int8x16_t v207 = v534;
  v160(1, v545, AssociatedConformanceWitness);
  v547 = (uint64_t *)v1;
  int8x16_t v208 = __swift_allocate_boxed_opaque_existential_0Tm(&v546);
  memcpy(v208, v207, v2);
  int8x16_t v209 = v547;
  int8x16_t v210 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
  uint64_t v211 = (void *)swift_getDynamicType(v210, v209, 1);
  LODWORD(v209) = swift_isOptionalType(v211);
  __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
  if (v209)
  {
    memcpy(v151, v207, v2);
    uint64_t v212 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v546, v151, v1, v212, 7uLL);
    uint64_t v213 = (uint64_t)v547;
    uint64_t v214 = v548;
    __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
    uint64_t v216 = (*(uint64_t (**)(uint64_t, uint64_t))(v214 + 8))(v213, v214);
    unint64_t v217 = v215;
    uint64_t v218 = v553;
    unint64_t v219 = HIBYTE(v553) & 0xF;
    if ((v553 & 0x2000000000000000) == 0) {
      unint64_t v219 = v552 & 0xFFFFFFFFFFFFLL;
    }
    if (v219 || (v552 & ~v553 & 0x2000000000000000) != 0)
    {
      if ((v553 & 0x2000000000000000) == 0)
      {
        if ((v215 & 0x2000000000000000) != 0)
        {
          uint64_t v220 = HIBYTE(v215) & 0xF;
LABEL_131:
          _StringGuts.append(_:)(v216, v217, 0, v220);
          goto LABEL_132;
        }
LABEL_117:
        uint64_t v220 = v216 & 0xFFFFFFFFFFFFLL;
        goto LABEL_131;
      }
      if ((v215 & 0x2000000000000000) == 0) {
        goto LABEL_117;
      }
      unint64_t v232 = specialized _SmallString.init(_:appending:)(v552, v553, v216, v215);
      if (v234)
      {
        uint64_t v220 = HIBYTE(v217) & 0xF;
        int8x16_t v160 = v543;
        uint64_t v151 = v544;
        goto LABEL_131;
      }
      unint64_t v235 = v232;
      unint64_t v236 = v233;
      swift_bridgeObjectRelease(v218);
      unint64_t v552 = v235;
      unint64_t v553 = v236;
      int8x16_t v160 = v543;
      uint64_t v151 = v544;
LABEL_132:
      swift_bridgeObjectRelease(v217);
      goto LABEL_133;
    }
    goto LABEL_129;
  }
  unint64_t v221 = v525;
  memcpy(v525, v207, v2);
  if (swift_dynamicCast((char *)&v546, v221, v1, (const char *)&type metadata for String, 6uLL))
  {
    uint64_t v223 = v546._countAndFlagsBits;
    unint64_t v222 = v546._object;
    uint64_t v224 = v553;
    unint64_t v225 = HIBYTE(v553) & 0xF;
    if ((v553 & 0x2000000000000000) == 0) {
      unint64_t v225 = v552 & 0xFFFFFFFFFFFFLL;
    }
    if (v225 || (v552 & ~v553 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v546._countAndFlagsBits, (unint64_t)v546._object);
    }
    else
    {
      swift_bridgeObjectRetain((unint64_t)v546._object);
      swift_bridgeObjectRelease(v224);
      unint64_t v552 = v223;
      unint64_t v553 = (unint64_t)v222;
    }
    swift_bridgeObjectRelease((uint64_t)v222);
  }
  else
  {
    int8x16_t v226 = v516;
    memcpy(v516, v207, v2);
    uint64_t v227 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v549, v226, v1, v227, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v228 = (uint64_t)v547;
      uint64_t v229 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v229 + 8))(&v552, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v228, v229);
LABEL_133:
      __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
      goto LABEL_134;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for TextOutputStreamable?);
    unint64_t v230 = v508;
    memcpy(v508, v207, v2);
    uint64_t v231 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v549, v230, v1, v231, 6uLL)
      || (uint64_t v551 = 0,
          long long v549 = 0u,
          long long v550 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomStringConvertible?), v237 = v498, memcpy(v498, v207, v2), uint64_t v238 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v549, v237, v1, v238, 6uLL)))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v239 = (uint64_t)v547;
      uint64_t v240 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      unint64_t v241 = (*(uint64_t (**)(uint64_t, uint64_t))(v240 + 8))(v239, v240);
      uint64_t v216 = v241;
      unint64_t v217 = v242;
      uint64_t v218 = v553;
      unint64_t v243 = HIBYTE(v553) & 0xF;
      if ((v553 & 0x2000000000000000) == 0) {
        unint64_t v243 = v552 & 0xFFFFFFFFFFFFLL;
      }
      if (v243 || (v552 & ~v553 & 0x2000000000000000) != 0)
      {
        _StringGuts.append(_:)(v241, v242);
        goto LABEL_132;
      }
LABEL_129:
      swift_bridgeObjectRetain(v217);
      swift_bridgeObjectRelease(v218);
      unint64_t v552 = v216;
      unint64_t v553 = v217;
      goto LABEL_132;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v550 + 1) = v1;
    v468 = __swift_allocate_boxed_opaque_existential_0Tm(&v549);
    memcpy(v468, v207, v2);
    Mirror.init(reflecting:)((uint64_t *)&v549, (uint64_t)&v546);
    v469 = v546._object;
    uint64_t v470 = v548;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v207, &v546, &v552, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v470);
    swift_release((uint64_t)v469);
  }
LABEL_134:
  uint64_t v244 = v553;
  unint64_t v245 = HIBYTE(v553) & 0xF;
  if ((v553 & 0x2000000000000000) == 0) {
    unint64_t v245 = v552 & 0xFFFFFFFFFFFFLL;
  }
  if (v245 || (v552 & ~v553 & 0x2000000000000000) != 0)
  {
    if ((v553 & 0x2000000000000000) == 0
      || (unint64_t v246 = specialized _SmallString.init(_:appending:)(v552, v553, 0x202CuLL, 0xE200000000000000),
          (v248 & 1) != 0))
    {
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
    }
    else
    {
      unint64_t v249 = v246;
      unint64_t v250 = v247;
      swift_bridgeObjectRelease(v244);
      unint64_t v552 = v249;
      unint64_t v553 = v250;
    }
    uint64_t v251 = 0xE200000000000000;
  }
  else
  {
    unint64_t v552 = 8236;
    unint64_t v553 = 0xE200000000000000;
    uint64_t v251 = v244;
  }
  swift_bridgeObjectRelease(v251);
  Swift::Int v252 = v535;
  v160(2, v545, AssociatedConformanceWitness);
  v547 = (uint64_t *)v1;
  uint64_t v253 = __swift_allocate_boxed_opaque_existential_0Tm(&v546);
  memcpy(v253, v252, v2);
  uint64_t v254 = v547;
  uint64_t v255 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
  uint64_t v256 = (void *)swift_getDynamicType(v255, v254, 1);
  LODWORD(v254) = swift_isOptionalType(v256);
  __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
  if (v254)
  {
    memcpy(v151, v252, v2);
    unint64_t v257 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v546, v151, v1, v257, 7uLL);
    uint64_t v258 = (uint64_t)v547;
    uint64_t v259 = v548;
    __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
    unint64_t v260 = (*(uint64_t (**)(uint64_t, uint64_t))(v259 + 8))(v258, v259);
    unint64_t v262 = v260;
    unint64_t v263 = v261;
    uint64_t v264 = v553;
    unint64_t v265 = HIBYTE(v553) & 0xF;
    if ((v553 & 0x2000000000000000) == 0) {
      unint64_t v265 = v552 & 0xFFFFFFFFFFFFLL;
    }
    if (v265 || (v552 & ~v553 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v260, v261);
    }
    else
    {
      swift_bridgeObjectRetain(v261);
      swift_bridgeObjectRelease(v264);
      unint64_t v552 = v262;
      unint64_t v553 = v263;
    }
    uint64_t v266 = v263;
    goto LABEL_150;
  }
  unint64_t v267 = v526;
  memcpy(v526, v252, v2);
  if (swift_dynamicCast((char *)&v546, v267, v1, (const char *)&type metadata for String, 6uLL))
  {
    uint64_t v269 = v546._countAndFlagsBits;
    unint64_t v268 = v546._object;
    uint64_t v270 = v553;
    unint64_t v271 = HIBYTE(v553) & 0xF;
    if ((v553 & 0x2000000000000000) == 0) {
      unint64_t v271 = v552 & 0xFFFFFFFFFFFFLL;
    }
    if (v271 || (v552 & ~v553 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v546._countAndFlagsBits, (unint64_t)v546._object);
    }
    else
    {
      swift_bridgeObjectRetain((unint64_t)v546._object);
      swift_bridgeObjectRelease(v270);
      unint64_t v552 = v269;
      unint64_t v553 = (unint64_t)v268;
    }
    swift_bridgeObjectRelease((uint64_t)v268);
  }
  else
  {
    uint64_t v385 = v517;
    memcpy(v517, v252, v2);
    v386 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v549, v385, v1, v386, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v387 = (uint64_t)v547;
      uint64_t v388 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v388 + 8))(&v552, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v387, v388);
      goto LABEL_151;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for TextOutputStreamable?);
    v417 = v509;
    memcpy(v509, v252, v2);
    v418 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v549, v417, v1, v418, 6uLL)
      || (uint64_t v551 = 0,
          long long v549 = 0u,
          long long v550 = 0u,
          outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomStringConvertible?), v447 = v499, memcpy(v499, v252, v2), uint64_t v448 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible), swift_dynamicCast((char *)&v549, v447, v1, v448, 6uLL)))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v449 = (uint64_t)v547;
      uint64_t v450 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      unint64_t v451 = (*(uint64_t (**)(uint64_t, uint64_t))(v450 + 8))(v449, v450);
      unint64_t v453 = v452;
      specialized String.write<A>(to:)(&v552, v451, v452);
      uint64_t v266 = v453;
LABEL_150:
      swift_bridgeObjectRelease(v266);
LABEL_151:
      __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
      goto LABEL_159;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v550 + 1) = v1;
    v471 = __swift_allocate_boxed_opaque_existential_0Tm(&v549);
    memcpy(v471, v252, v2);
    Mirror.init(reflecting:)((uint64_t *)&v549, (uint64_t)&v546);
    v472 = v546._object;
    uint64_t v473 = v548;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v252, &v546, &v552, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v473);
    swift_release((uint64_t)v472);
  }
LABEL_159:
  uint64_t v272 = v553;
  unint64_t v273 = HIBYTE(v553) & 0xF;
  if ((v553 & 0x2000000000000000) == 0) {
    unint64_t v273 = v552 & 0xFFFFFFFFFFFFLL;
  }
  if (v273 || (v552 & ~v553 & 0x2000000000000000) != 0)
  {
    if ((v553 & 0x2000000000000000) == 0
      || (unint64_t v274 = specialized _SmallString.init(_:appending:)(v552, v553, 0x202CuLL, 0xE200000000000000),
          (v276 & 1) != 0))
    {
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
    }
    else
    {
      unint64_t v277 = v274;
      unint64_t v278 = v275;
      swift_bridgeObjectRelease(v272);
      unint64_t v552 = v277;
      unint64_t v553 = v278;
    }
    uint64_t v279 = 0xE200000000000000;
  }
  else
  {
    unint64_t v552 = 8236;
    unint64_t v553 = 0xE200000000000000;
    uint64_t v279 = v272;
  }
  swift_bridgeObjectRelease(v279);
  unint64_t v280 = v536;
  v160(3, v545, AssociatedConformanceWitness);
  v547 = (uint64_t *)v1;
  uint64_t v281 = __swift_allocate_boxed_opaque_existential_0Tm(&v546);
  memcpy(v281, v280, v2);
  unint64_t v282 = v547;
  uint64_t v283 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
  uint64_t v284 = (void *)swift_getDynamicType(v283, v282, 1);
  LODWORD(v282) = swift_isOptionalType(v284);
  __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
  if (v282)
  {
    memcpy(v151, v280, v2);
    unint64_t v285 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v546, v151, v1, v285, 7uLL);
LABEL_170:
    uint64_t v286 = (uint64_t)v547;
    uint64_t v287 = v548;
    __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
    unint64_t v288 = (*(uint64_t (**)(uint64_t, uint64_t))(v287 + 8))(v286, v287);
LABEL_171:
    uint64_t v290 = v289;
    specialized String.write<A>(to:)(&v552, v288, v289);
    swift_bridgeObjectRelease(v290);
LABEL_172:
    __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
    goto LABEL_175;
  }
  v291 = v527;
  memcpy(v527, v280, v2);
  if (swift_dynamicCast((char *)&v546, v291, v1, (const char *)&type metadata for String, 6uLL))
  {
    v292 = v546._object;
    String.append(_:)(v546);
    swift_bridgeObjectRelease((uint64_t)v292);
  }
  else
  {
    uint64_t v389 = v518;
    memcpy(v518, v280, v2);
    v390 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v549, v389, v1, v390, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v391 = (uint64_t)v547;
      uint64_t v392 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v392 + 8))(&v552, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v391, v392);
      goto LABEL_172;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for TextOutputStreamable?);
    v419 = v510;
    memcpy(v510, v280, v2);
    v420 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v549, v419, v1, v420, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v421 = (uint64_t)v547;
      uint64_t v422 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      unint64_t v288 = (*(uint64_t (**)(uint64_t, uint64_t))(v422 + 8))(v421, v422);
      goto LABEL_171;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomStringConvertible?);
    v454 = v500;
    memcpy(v500, v280, v2);
    v455 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v549, v454, v1, v455, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      goto LABEL_170;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v550 + 1) = v1;
    v474 = __swift_allocate_boxed_opaque_existential_0Tm(&v549);
    memcpy(v474, v280, v2);
    Mirror.init(reflecting:)((uint64_t *)&v549, (uint64_t)&v546);
    v475 = v546._object;
    uint64_t v476 = v548;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v280, &v546, &v552, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v476);
    swift_release((uint64_t)v475);
  }
LABEL_175:
  uint64_t v293 = v537;
  uint64_t v294 = v553;
  unint64_t v295 = HIBYTE(v553) & 0xF;
  if ((v553 & 0x2000000000000000) == 0) {
    unint64_t v295 = v552 & 0xFFFFFFFFFFFFLL;
  }
  if (v295 || (v552 & ~v553 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    uint64_t v294 = 0xE200000000000000;
  }
  else
  {
    unint64_t v552 = 8236;
    unint64_t v553 = 0xE200000000000000;
  }
  swift_bridgeObjectRelease(v294);
  v160(4, v545, AssociatedConformanceWitness);
  v547 = (uint64_t *)v1;
  v296 = __swift_allocate_boxed_opaque_existential_0Tm(&v546);
  memcpy(v296, v293, v2);
  uint64_t v297 = v547;
  uint64_t v298 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
  unint64_t v299 = (void *)swift_getDynamicType(v298, v297, 1);
  LODWORD(v297) = swift_isOptionalType(v299);
  __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
  if (v297)
  {
    memcpy(v151, v293, v2);
    unint64_t v300 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v546, v151, v1, v300, 7uLL);
LABEL_182:
    uint64_t v301 = (uint64_t)v547;
    uint64_t v302 = v548;
    __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
    unint64_t v303 = (*(uint64_t (**)(uint64_t, uint64_t))(v302 + 8))(v301, v302);
LABEL_183:
    uint64_t v305 = v304;
    specialized String.write<A>(to:)(&v552, v303, v304);
    swift_bridgeObjectRelease(v305);
LABEL_184:
    __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
    goto LABEL_187;
  }
  uint64_t v306 = v528;
  memcpy(v528, v293, v2);
  if (swift_dynamicCast((char *)&v546, v306, v1, (const char *)&type metadata for String, 6uLL))
  {
    size_t v307 = v546._object;
    String.append(_:)(v546);
    swift_bridgeObjectRelease((uint64_t)v307);
  }
  else
  {
    uint64_t v393 = v519;
    memcpy(v519, v293, v2);
    v394 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v549, v393, v1, v394, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v395 = (uint64_t)v547;
      uint64_t v396 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v396 + 8))(&v552, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v395, v396);
      goto LABEL_184;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for TextOutputStreamable?);
    v423 = v511;
    memcpy(v511, v293, v2);
    v424 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v549, v423, v1, v424, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v425 = (uint64_t)v547;
      uint64_t v426 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      unint64_t v303 = (*(uint64_t (**)(uint64_t, uint64_t))(v426 + 8))(v425, v426);
      goto LABEL_183;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomStringConvertible?);
    v456 = v501;
    memcpy(v501, v293, v2);
    v457 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v549, v456, v1, v457, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      goto LABEL_182;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v550 + 1) = v1;
    v477 = __swift_allocate_boxed_opaque_existential_0Tm(&v549);
    memcpy(v477, v293, v2);
    Mirror.init(reflecting:)((uint64_t *)&v549, (uint64_t)&v546);
    v478 = v546._object;
    uint64_t v479 = v548;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v293, &v546, &v552, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v479);
    swift_release((uint64_t)v478);
  }
LABEL_187:
  uint64_t v308 = v538;
  uint64_t v309 = v553;
  unint64_t v310 = HIBYTE(v553) & 0xF;
  if ((v553 & 0x2000000000000000) == 0) {
    unint64_t v310 = v552 & 0xFFFFFFFFFFFFLL;
  }
  if (v310 || (v552 & ~v553 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    uint64_t v309 = 0xE200000000000000;
  }
  else
  {
    unint64_t v552 = 8236;
    unint64_t v553 = 0xE200000000000000;
  }
  swift_bridgeObjectRelease(v309);
  v160(5, v545, AssociatedConformanceWitness);
  v547 = (uint64_t *)v1;
  unint64_t v311 = __swift_allocate_boxed_opaque_existential_0Tm(&v546);
  memcpy(v311, v308, v2);
  uint64_t v312 = v547;
  uint64_t v313 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
  unint64_t v314 = (void *)swift_getDynamicType(v313, v312, 1);
  LODWORD(v312) = swift_isOptionalType(v314);
  __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
  if (v312)
  {
    memcpy(v151, v308, v2);
    char v315 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v546, v151, v1, v315, 7uLL);
LABEL_194:
    uint64_t v316 = (uint64_t)v547;
    uint64_t v317 = v548;
    __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
    unint64_t v318 = (*(uint64_t (**)(uint64_t, uint64_t))(v317 + 8))(v316, v317);
LABEL_195:
    uint64_t v320 = v319;
    specialized String.write<A>(to:)(&v552, v318, v319);
    swift_bridgeObjectRelease(v320);
LABEL_196:
    __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
    goto LABEL_199;
  }
  uint64_t v321 = v529;
  memcpy(v529, v308, v2);
  if (swift_dynamicCast((char *)&v546, v321, v1, (const char *)&type metadata for String, 6uLL))
  {
    v322 = v546._object;
    String.append(_:)(v546);
    swift_bridgeObjectRelease((uint64_t)v322);
  }
  else
  {
    uint64_t v397 = v520;
    memcpy(v520, v308, v2);
    v398 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v549, v397, v1, v398, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v399 = (uint64_t)v547;
      uint64_t v400 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v400 + 8))(&v552, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v399, v400);
      goto LABEL_196;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for TextOutputStreamable?);
    v427 = v512;
    memcpy(v512, v308, v2);
    v428 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v549, v427, v1, v428, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v429 = (uint64_t)v547;
      uint64_t v430 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      unint64_t v318 = (*(uint64_t (**)(uint64_t, uint64_t))(v430 + 8))(v429, v430);
      goto LABEL_195;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomStringConvertible?);
    v458 = v502;
    memcpy(v502, v308, v2);
    v459 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v549, v458, v1, v459, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      goto LABEL_194;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v550 + 1) = v1;
    v480 = __swift_allocate_boxed_opaque_existential_0Tm(&v549);
    memcpy(v480, v308, v2);
    Mirror.init(reflecting:)((uint64_t *)&v549, (uint64_t)&v546);
    v481 = v546._object;
    uint64_t v482 = v548;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v308, &v546, &v552, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v482);
    swift_release((uint64_t)v481);
  }
LABEL_199:
  v323 = v539;
  uint64_t v324 = v553;
  unint64_t v325 = HIBYTE(v553) & 0xF;
  if ((v553 & 0x2000000000000000) == 0) {
    unint64_t v325 = v552 & 0xFFFFFFFFFFFFLL;
  }
  if (v325 || (v552 & ~v553 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    uint64_t v324 = 0xE200000000000000;
  }
  else
  {
    unint64_t v552 = 8236;
    unint64_t v553 = 0xE200000000000000;
  }
  swift_bridgeObjectRelease(v324);
  v160(6, v545, AssociatedConformanceWitness);
  v547 = (uint64_t *)v1;
  v326 = __swift_allocate_boxed_opaque_existential_0Tm(&v546);
  memcpy(v326, v323, v2);
  uint64_t v327 = v547;
  uint64_t v328 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
  uint64_t v329 = (void *)swift_getDynamicType(v328, v327, 1);
  LODWORD(v327) = swift_isOptionalType(v329);
  __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
  if (v327)
  {
    memcpy(v151, v323, v2);
    uint64_t v330 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v546, v151, v1, v330, 7uLL);
LABEL_206:
    uint64_t v331 = (uint64_t)v547;
    uint64_t v332 = v548;
    __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
    unint64_t v333 = (*(uint64_t (**)(uint64_t, uint64_t))(v332 + 8))(v331, v332);
LABEL_207:
    uint64_t v335 = v334;
    specialized String.write<A>(to:)(&v552, v333, v334);
    swift_bridgeObjectRelease(v335);
LABEL_208:
    __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
    goto LABEL_211;
  }
  v336 = v530;
  memcpy(v530, v323, v2);
  if (swift_dynamicCast((char *)&v546, v336, v1, (const char *)&type metadata for String, 6uLL))
  {
    v337 = v546._object;
    String.append(_:)(v546);
    swift_bridgeObjectRelease((uint64_t)v337);
  }
  else
  {
    uint64_t v401 = v521;
    memcpy(v521, v323, v2);
    v402 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v549, v401, v1, v402, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v403 = (uint64_t)v547;
      uint64_t v404 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v404 + 8))(&v552, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v403, v404);
      goto LABEL_208;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for TextOutputStreamable?);
    v431 = v513;
    memcpy(v513, v323, v2);
    v432 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v549, v431, v1, v432, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v433 = (uint64_t)v547;
      uint64_t v434 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      unint64_t v333 = (*(uint64_t (**)(uint64_t, uint64_t))(v434 + 8))(v433, v434);
      goto LABEL_207;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomStringConvertible?);
    v460 = v503;
    memcpy(v503, v323, v2);
    v461 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v549, v460, v1, v461, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      goto LABEL_206;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v550 + 1) = v1;
    v483 = __swift_allocate_boxed_opaque_existential_0Tm(&v549);
    memcpy(v483, v323, v2);
    Mirror.init(reflecting:)((uint64_t *)&v549, (uint64_t)&v546);
    v484 = v546._object;
    uint64_t v485 = v548;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v323, &v546, &v552, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v485);
    swift_release((uint64_t)v484);
  }
LABEL_211:
  uint64_t v338 = v540;
  uint64_t v339 = v553;
  unint64_t v340 = HIBYTE(v553) & 0xF;
  if ((v553 & 0x2000000000000000) == 0) {
    unint64_t v340 = v552 & 0xFFFFFFFFFFFFLL;
  }
  if (v340 || (v552 & ~v553 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    uint64_t v339 = 0xE200000000000000;
  }
  else
  {
    unint64_t v552 = 8236;
    unint64_t v553 = 0xE200000000000000;
  }
  swift_bridgeObjectRelease(v339);
  v160(7, v545, AssociatedConformanceWitness);
  v547 = (uint64_t *)v1;
  v341 = __swift_allocate_boxed_opaque_existential_0Tm(&v546);
  memcpy(v341, v338, v2);
  uint64_t v342 = v547;
  uint64_t v343 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
  v344 = (void *)swift_getDynamicType(v343, v342, 1);
  LODWORD(v342) = swift_isOptionalType(v344);
  __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
  if (v342)
  {
    memcpy(v151, v338, v2);
    v345 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v546, v151, v1, v345, 7uLL);
LABEL_218:
    uint64_t v346 = (uint64_t)v547;
    uint64_t v347 = v548;
    __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
    unint64_t v348 = (*(uint64_t (**)(uint64_t, uint64_t))(v347 + 8))(v346, v347);
LABEL_219:
    uint64_t v350 = v349;
    specialized String.write<A>(to:)(&v552, v348, v349);
    swift_bridgeObjectRelease(v350);
LABEL_220:
    __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
    goto LABEL_223;
  }
  uint64_t v351 = v531;
  memcpy(v531, v338, v2);
  if (swift_dynamicCast((char *)&v546, v351, v1, (const char *)&type metadata for String, 6uLL))
  {
    uint64_t v352 = v546._object;
    String.append(_:)(v546);
    swift_bridgeObjectRelease((uint64_t)v352);
  }
  else
  {
    v405 = v522;
    memcpy(v522, v338, v2);
    v406 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v549, v405, v1, v406, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v407 = (uint64_t)v547;
      uint64_t v408 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v408 + 8))(&v552, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v407, v408);
      goto LABEL_220;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for TextOutputStreamable?);
    v435 = v514;
    memcpy(v514, v338, v2);
    uint64_t v436 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v549, v435, v1, v436, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v437 = (uint64_t)v547;
      uint64_t v438 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      unint64_t v348 = (*(uint64_t (**)(uint64_t, uint64_t))(v438 + 8))(v437, v438);
      goto LABEL_219;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomStringConvertible?);
    v462 = v504;
    memcpy(v504, v338, v2);
    v463 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v549, v462, v1, v463, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      goto LABEL_218;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v550 + 1) = v1;
    v486 = __swift_allocate_boxed_opaque_existential_0Tm(&v549);
    memcpy(v486, v338, v2);
    Mirror.init(reflecting:)((uint64_t *)&v549, (uint64_t)&v546);
    v487 = v546._object;
    uint64_t v488 = v548;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v338, &v546, &v552, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v488);
    swift_release((uint64_t)v487);
  }
LABEL_223:
  unint64_t v353 = v541;
  uint64_t v354 = v553;
  unint64_t v355 = HIBYTE(v553) & 0xF;
  if ((v553 & 0x2000000000000000) == 0) {
    unint64_t v355 = v552 & 0xFFFFFFFFFFFFLL;
  }
  if (v355 || (v552 & ~v553 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    uint64_t v354 = 0xE200000000000000;
  }
  else
  {
    unint64_t v552 = 8236;
    unint64_t v553 = 0xE200000000000000;
  }
  swift_bridgeObjectRelease(v354);
  v160(8, v545, AssociatedConformanceWitness);
  v547 = (uint64_t *)v1;
  v356 = __swift_allocate_boxed_opaque_existential_0Tm(&v546);
  memcpy(v356, v353, v2);
  v357 = v547;
  uint64_t v358 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
  uint64_t v359 = (void *)swift_getDynamicType(v358, v357, 1);
  LODWORD(v357) = swift_isOptionalType(v359);
  __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
  if (v357)
  {
    memcpy(v151, v353, v2);
    v360 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v546, v151, v1, v360, 7uLL);
LABEL_230:
    uint64_t v361 = (uint64_t)v547;
    uint64_t v362 = v548;
    __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
    unint64_t v363 = (*(uint64_t (**)(uint64_t, uint64_t))(v362 + 8))(v361, v362);
LABEL_231:
    uint64_t v365 = v364;
    specialized String.write<A>(to:)(&v552, v363, v364);
    swift_bridgeObjectRelease(v365);
LABEL_232:
    __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
    goto LABEL_235;
  }
  unint64_t v366 = v532;
  memcpy(v532, v353, v2);
  if (swift_dynamicCast((char *)&v546, v366, v1, (const char *)&type metadata for String, 6uLL))
  {
    v367 = v546._object;
    String.append(_:)(v546);
    swift_bridgeObjectRelease((uint64_t)v367);
  }
  else
  {
    v409 = v523;
    memcpy(v523, v353, v2);
    v410 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v549, v409, v1, v410, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v411 = (uint64_t)v547;
      uint64_t v412 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v412 + 8))(&v552, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v411, v412);
      goto LABEL_232;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for TextOutputStreamable?);
    v439 = v515;
    memcpy(v515, v353, v2);
    v440 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v549, v439, v1, v440, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v441 = (uint64_t)v547;
      uint64_t v442 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      unint64_t v363 = (*(uint64_t (**)(uint64_t, uint64_t))(v442 + 8))(v441, v442);
      goto LABEL_231;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomStringConvertible?);
    v464 = v505;
    memcpy(v505, v353, v2);
    v465 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v549, v464, v1, v465, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      goto LABEL_230;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v550 + 1) = v1;
    v489 = __swift_allocate_boxed_opaque_existential_0Tm(&v549);
    memcpy(v489, v353, v2);
    Mirror.init(reflecting:)((uint64_t *)&v549, (uint64_t)&v546);
    v490 = v546._object;
    uint64_t v491 = v548;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v353, &v546, &v552, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v491);
    swift_release((uint64_t)v490);
  }
LABEL_235:
  v368 = v542;
  uint64_t v369 = v553;
  unint64_t v370 = HIBYTE(v553) & 0xF;
  if ((v553 & 0x2000000000000000) == 0) {
    unint64_t v370 = v552 & 0xFFFFFFFFFFFFLL;
  }
  if (v370 || (v552 & ~v553 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    uint64_t v369 = 0xE200000000000000;
  }
  else
  {
    unint64_t v552 = 8236;
    unint64_t v553 = 0xE200000000000000;
  }
  swift_bridgeObjectRelease(v369);
  v160(9, v545, AssociatedConformanceWitness);
  v547 = (uint64_t *)v1;
  v371 = __swift_allocate_boxed_opaque_existential_0Tm(&v546);
  memcpy(v371, v368, v2);
  v372 = v547;
  v373 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
  v374 = (void *)swift_getDynamicType(v373, v372, 1);
  LODWORD(v372) = swift_isOptionalType(v374);
  __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
  if (v372)
  {
    memcpy(v151, v368, v2);
    v375 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v546, v151, v1, v375, 7uLL);
  }
  else
  {
    uint64_t v381 = v533;
    memcpy(v533, v368, v2);
    if (swift_dynamicCast((char *)&v546, v381, v1, (const char *)&type metadata for String, 6uLL))
    {
      v382 = v546._object;
      String.append(_:)(v546);
      swift_bridgeObjectRelease((uint64_t)v382);
      goto LABEL_247;
    }
    v413 = v524;
    memcpy(v524, v368, v2);
    v414 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v549, v413, v1, v414, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v415 = (uint64_t)v547;
      uint64_t v416 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v416 + 8))(&v552, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v415, v416);
      goto LABEL_244;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for TextOutputStreamable?);
    v443 = v506;
    memcpy(v506, v368, v2);
    v444 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v549, v443, v1, v444, 6uLL))
    {
      outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
      uint64_t v445 = (uint64_t)v547;
      uint64_t v446 = v548;
      __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
      unint64_t v378 = (*(uint64_t (**)(uint64_t, uint64_t))(v446 + 8))(v445, v446);
      goto LABEL_243;
    }
    uint64_t v551 = 0;
    long long v549 = 0u;
    long long v550 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomStringConvertible?);
    v466 = v496;
    memcpy(v496, v368, v2);
    v467 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (!swift_dynamicCast((char *)&v549, v466, v1, v467, 6uLL))
    {
      uint64_t v551 = 0;
      long long v549 = 0u;
      long long v550 = 0u;
      outlined destroy of _HasContiguousBytes?((uint64_t)&v549, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
      *((void *)&v550 + 1) = v1;
      v492 = __swift_allocate_boxed_opaque_existential_0Tm(&v549);
      memcpy(v492, v368, v2);
      Mirror.init(reflecting:)((uint64_t *)&v549, (uint64_t)&v546);
      v493 = v546._object;
      uint64_t v494 = v548;
      ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v368, &v546, &v552, 0, v1, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
      swift_release(v494);
      swift_release((uint64_t)v493);
      goto LABEL_247;
    }
    outlined init with take of MirrorPath(&v549, (uint64_t)&v546);
  }
  uint64_t v376 = (uint64_t)v547;
  uint64_t v377 = v548;
  __swift_project_boxed_opaque_existential_0Tm(&v546, (uint64_t)v547);
  unint64_t v378 = (*(uint64_t (**)(uint64_t, uint64_t))(v377 + 8))(v376, v377);
LABEL_243:
  uint64_t v380 = v379;
  specialized String.write<A>(to:)(&v552, v378, v379);
  swift_bridgeObjectRelease(v380);
LABEL_244:
  __swift_destroy_boxed_opaque_existential_1Tm(&v546._countAndFlagsBits);
LABEL_247:
  specialized String.write<A>(to:)(&v552, 0x202CuLL, 0xE200000000000000);
  swift_bridgeObjectRelease(0xE200000000000000);
  v383 = v545;
  v160(10, v545, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v151, (uint64_t)&v552, v1, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v552, 0x202CuLL, 0xE200000000000000);
  swift_bridgeObjectRelease(0xE200000000000000);
  v160(11, v383, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v151, (uint64_t)&v552, v1, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v552, 0x202CuLL, 0xE200000000000000);
  swift_bridgeObjectRelease(0xE200000000000000);
  v160(12, v383, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v151, (uint64_t)&v552, v1, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v552, 0x202CuLL, 0xE200000000000000);
  swift_bridgeObjectRelease(0xE200000000000000);
  v160(13, v383, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v151, (uint64_t)&v552, v1, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v552, 0x202CuLL, 0xE200000000000000);
  swift_bridgeObjectRelease(0xE200000000000000);
  v160(14, v383, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v151, (uint64_t)&v552, v1, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v552, 0x202CuLL, 0xE200000000000000);
  swift_bridgeObjectRelease(0xE200000000000000);
  v160(15, v383, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v151, (uint64_t)&v552, v1, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v552, 0x29uLL, 0xE100000000000000);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v552;
}

uint64_t SIMD16<>.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v38 = a1;
  uint64_t v36 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v33 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v32 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v30 = a7;
  uint64_t v31 = v21;
  uint64_t v37 = a3;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v23 = 0;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  do
  {
    uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v31);
    v24(v23, v25, v22);
    (*(void (**)(char *, uint64_t, void))(*(void *)(v34 + 16) + 72))(v14, v37, *(void *)(v35 + 8));
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v16, v23++, v32, AssociatedConformanceWitness);
  }
  while (v23 != 16);
  uint64_t v27 = type metadata accessor for SIMD16(0, v37, (uint64_t)v30, v26);
  return (*((uint64_t (**)(uint64_t, Class *))*(v27 - 1) + 1))(v38, v27);
}

{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  int **v17;
  const char *AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  void (*v20)(const char *, uint64_t);
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  Class *v27;
  uint64_t v29;
  uint64_t v30;
  int **v31;
  void (*v32)(uint64_t, uint64_t *, uint64_t);
  uint64_t v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;

  uint64_t v37 = a6;
  uint64_t v38 = a8;
  uint64_t v30 = a4;
  uint64_t v40 = a1;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v36 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v35 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t v31 = a7;
  uint64_t v39 = a3;
  uint64_t v34 = v21;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v23 = 0;
  uint64_t v32 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  uint64_t v33 = v22;
  uint64_t v24 = v30;
  do
  {
    uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v34);
    v32(v23, v25, v33);
    (*(void (**)(char *, uint64_t, uint64_t))(v24 + 80))(v14, v39, v37);
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v16, v23++, v35, AssociatedConformanceWitness);
  }
  while (v23 != 16);
  uint64_t v27 = type metadata accessor for SIMD16(0, v39, (uint64_t)v31, v26);
  return (*((uint64_t (**)(uint64_t, Class *))*(v27 - 1) + 1))(v40, v27);
}

uint64_t SIMD32._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage, a2);
}

uint64_t SIMD32._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
}

uint64_t (*SIMD32._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD32.scalarCount.getter()
{
  return 32;
}

uint64_t key path getter for SIMD32.subscript(_:) : <A>SIMD32<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  if ((unint64_t)*a2 >= 0x20) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x357uLL, 0);
  }
  uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  uint64_t v4 = *(int ***)((char *)a2 + a3 - 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD32.subscript(_:) : <A>SIMD32<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + a3 - 16);
  uint64_t v5 = *(int ***)(a4 + a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v17 - v6;
  unint64_t v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 0x20) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x35BuLL, 0);
  }
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v14 = *(uint64_t (**)(char *, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v15 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD32.subscript.modify(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x20) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x357uLL, 0);
  }
  uint64_t v10 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD32.init(_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:)(const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, const void *a7, const void *a8, const void *a9, const void *a10, const void *a11, const void *a12, const void *a13, const void *a14, const void *a15, const void *a16, const void *a17, const void *a18, const void *a19, const void *a20,const void *a21,const void *a22,const void *a23,const void *a24,const void *a25,const void *a26,const void *a27,const void *a28,const void *a29,const void *a30,const void *a31,const void *a32,uint64_t a33,int **a34)
{
  uint64_t v53 = a8;
  uint64_t v51 = a7;
  uint64_t v49 = a6;
  uint64_t v48 = a5;
  uint64_t v47 = a4;
  uint64_t v75 = a31;
  uint64_t v76 = a32;
  uint64_t v74 = a30;
  uint64_t v71 = a28;
  uint64_t v72 = a29;
  uint64_t v69 = a26;
  uint64_t v70 = a27;
  uint64_t v67 = a24;
  uint64_t v68 = a25;
  uint64_t v65 = a22;
  uint64_t v66 = a23;
  uint64_t v63 = a20;
  uint64_t v64 = a21;
  uint64_t v61 = a18;
  uint64_t v62 = a19;
  uint64_t v59 = a16;
  uint64_t v60 = a17;
  uint64_t v58 = a15;
  size_t v37 = *(void *)(*(void *)(a33 - 8) + 64);
  uint64_t v56 = a13;
  uint64_t v57 = a14;
  uint64_t v55 = a12;
  uint64_t v54 = a11;
  uint64_t v52 = a10;
  uint64_t v50 = a9;
  uint64_t v38 = MEMORY[0x1F4188790](a1);
  uint64_t v73 = (char *)&v46 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v38);
  uint64_t v40 = (char *)&v46 - v39;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a34, a33, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a34, a33, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, a1, v37);
  uint64_t v43 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  v43(v40, 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, a2, v37);
  v43(v40, 1, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, a3, v37);
  v43(v40, 2, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v47, v37);
  v43(v40, 3, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v48, v37);
  v43(v40, 4, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v49, v37);
  v43(v40, 5, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v51, v37);
  v43(v40, 6, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v53, v37);
  v43(v40, 7, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v50, v37);
  v43(v40, 8, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v52, v37);
  v43(v40, 9, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v54, v37);
  v43(v40, 10, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v55, v37);
  v43(v40, 11, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v56, v37);
  v43(v40, 12, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v57, v37);
  v43(v40, 13, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v58, v37);
  v43(v40, 14, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v59, v37);
  v43(v40, 15, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v60, v37);
  v43(v40, 16, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v61, v37);
  v43(v40, 17, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v62, v37);
  v43(v40, 18, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v63, v37);
  v43(v40, 19, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v64, v37);
  v43(v40, 20, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v65, v37);
  v43(v40, 21, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v66, v37);
  v43(v40, 22, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v67, v37);
  v43(v40, 23, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v68, v37);
  v43(v40, 24, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v69, v37);
  v43(v40, 25, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v70, v37);
  v43(v40, 26, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v71, v37);
  v43(v40, 27, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v72, v37);
  v43(v40, 28, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v74, v37);
  v43(v40, 29, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v40, v75, v37);
  v43(v40, 30, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v44 = v73;
  memcpy(v73, v76, v37);
  return ((uint64_t (*)(char *, uint64_t, const char *, uint64_t))v43)(v44, 31, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t SIMD32.init(lowHalf:highHalf:)(uint64_t a1, uint64_t a2, uint64_t a3, int **a4)
{
  void (*v15)(Class *__return_ptr, uint64_t, Class *);
  uint64_t vars8;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  size_t v11 = type metadata accessor for SIMD32(0, a3, (uint64_t)a4, v10);
  specialized SIMD32.lowHalf.setter(a1, (uint64_t)v11);
  uint64_t v13 = type metadata accessor for SIMD16(0, a3, (uint64_t)a4, v12);
  uint64_t v15 = (void (*)(Class *__return_ptr, uint64_t, Class *))*((void *)*(v13 - 1) + 1);
  v15(v13 - 1, a1, v13);
  specialized SIMD32.highHalf.setter(a2, (uint64_t)v11);

  return ((uint64_t (*)(uint64_t, Class *))v15)(a2, v13);
}

uint64_t SIMD32.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD32.lowHalf.setter, (uint64_t (*)(void, void, void))type metadata accessor for SIMD16);
}

uint64_t SIMD32.highHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD32.highHalf.setter, (uint64_t (*)(void, void, void))type metadata accessor for SIMD16);
}

uint64_t SIMD32.lowHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = *(int ***)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v18 = AssociatedTypeWitness;
  uint64_t v19 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  size_t v11 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v12 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v13 = 0;
  uint64_t v14 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v12 + 56);
  do
  {
    uint64_t v15 = swift_checkMetadataState(0, (uint64_t)v11);
    v14(v13, v15, v12);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v6, v13++, v18, AssociatedConformanceWitness);
  }
  while (v13 != 16);
  return result;
}

uint64_t key path getter for SIMD32.lowHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD32, (uint64_t (*)(uint64_t))SIMD32.lowHalf.getter);
}

uint64_t key path setter for SIMD32.lowHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(void, void, void))type metadata accessor for SIMD32, specialized SIMD32.lowHalf.setter);
}

void (*SIMD32.lowHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD16(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD32.lowHalf.getter(a2, (uint64_t)v10);
  return SIMD32.lowHalf.modify;
}

void SIMD32.lowHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD32.highHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = *(int ***)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v18 = AssociatedTypeWitness;
  uint64_t v19 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  size_t v11 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v12 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v13 = 0;
  uint64_t v14 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v12 + 56);
  do
  {
    uint64_t v15 = swift_checkMetadataState(0, (uint64_t)v11);
    v14(v13 + 16, v15, v12);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v6, v13++, v18, AssociatedConformanceWitness);
  }
  while (v13 != 16);
  return result;
}

uint64_t key path getter for SIMD32.highHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD32, (uint64_t (*)(uint64_t))SIMD32.highHalf.getter);
}

uint64_t key path setter for SIMD32.highHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(void, void, void))type metadata accessor for SIMD32, specialized SIMD32.highHalf.setter);
}

void (*SIMD32.highHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD16(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD32.highHalf.getter(a2, (uint64_t)v10);
  return SIMD32.highHalf.modify;
}

void SIMD32.highHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD32.evenHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = *(int ***)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v18 = AssociatedTypeWitness;
  uint64_t v19 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v17 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v11 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)v17, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v11 + 56);
  do
  {
    uint64_t v15 = swift_checkMetadataState(0, (uint64_t)v17);
    v14(v12, v15, v11);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v6, v13, v18, AssociatedConformanceWitness);
    v12 += 2;
    ++v13;
  }
  while (v13 != 16);
  return result;
}

uint64_t key path getter for SIMD32.evenHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD32, (uint64_t (*)(uint64_t))SIMD32.evenHalf.getter);
}

uint64_t key path setter for SIMD32.evenHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(void, void, void))type metadata accessor for SIMD32, specialized SIMD32.evenHalf.setter);
}

uint64_t SIMD32.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD32.evenHalf.setter, (uint64_t (*)(void, void, void))type metadata accessor for SIMD16);
}

void (*SIMD32.evenHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD16(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD32.evenHalf.getter(a2, (uint64_t)v10);
  return SIMD32.evenHalf.modify;
}

void SIMD32.evenHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD32.oddHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = *(int ***)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v18 = AssociatedTypeWitness;
  uint64_t v19 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v17 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v11 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)v17, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v12 = 0;
  uint64_t v13 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v11 + 56);
  uint64_t v14 = 1;
  do
  {
    uint64_t v15 = swift_checkMetadataState(0, (uint64_t)v17);
    v13(v14, v15, v11);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v6, v12, v18, AssociatedConformanceWitness);
    v14 += 2;
    ++v12;
  }
  while (v12 != 16);
  return result;
}

uint64_t key path getter for SIMD32.oddHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD32, (uint64_t (*)(uint64_t))SIMD32.oddHalf.getter);
}

uint64_t key path setter for SIMD32.oddHalf : <A>SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(void, void, void))type metadata accessor for SIMD32, specialized SIMD32.oddHalf.setter);
}

uint64_t SIMD32.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD32.oddHalf.setter, (uint64_t (*)(void, void, void))type metadata accessor for SIMD16);
}

void (*SIMD32.oddHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD16(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD32.oddHalf.getter(a2, (uint64_t)v10);
  return SIMD32.oddHalf.modify;
}

void SIMD32.oddHalf.modify(uint64_t **a1, char a2)
{
}

Swift::Int SIMD32.hashValue.getter(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, protocol conformance descriptor for SIMD32<A>, a3);
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD32<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>(a1, a2, associated type descriptor for SIMDScalar.SIMD32Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD32<A>(unint64_t a1, uint64_t a2)
{
  if (a1 >= 0x20) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x357uLL, 0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  size_t v9 = *(uint64_t (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v7 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD32<A>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 0x20) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x35BuLL, 0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  size_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD32<A>(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x20) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x357uLL, 0);
  }
  uint64_t v10 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD32<A>(void *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD32<A>, a2, a3);
  return SIMD.encode(to:)(a1, (uint64_t)a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD32<A>@<X0>(uint64_t *a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD32<A>, a2, a3);
  return SIMD.init(from:)(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD32<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD32<A>, a2, a3);

  return SIMD.hash(into:)(a1, (uint64_t)a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD32<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(a1, a2, a3, protocol conformance descriptor for SIMD32<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD32<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD32<A>, a1, a3);

  return SIMD.description.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD32<A>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD32<A>, a2, a3);

  return SIMD.init(arrayLiteral:)(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD32<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v5 = a1;
  uint64_t v43 = *(void *)(a3 + 16);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v50 = (char *)&v39 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  uint64_t v49 = (char *)&v39 - v9;
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v8);
  uint64_t v14 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v39 - v16;
  uint64_t v18 = 0;
  uint64_t v20 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v11 += 16;
  uint64_t v19 = v20;
  uint64_t v46 = (void (**)(char *, uint64_t))(v11 - 8);
  uint64_t v47 = v21;
  char v22 = 1;
  uint64_t v44 = v23;
  uint64_t v41 = v11;
  uint64_t v42 = v15;
  uint64_t v48 = v14;
  uint64_t v40 = v20;
  v20((char *)&v39 - v16, v5, v3);
  while (1)
  {
    v19(v14, a2, v3);
    if (v22)
    {
      uint64_t v25 = *(int ***)(v3 + 24);
      uint64_t v45 = v25;
      uint64_t v26 = v43;
      AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v25, v43, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v25, v26, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
      uint64_t v29 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
      uint64_t v30 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
      v29(v18, v30, AssociatedConformanceWitness);
      uint64_t v31 = *v46;
      (*v46)(v17, v47);
      uint64_t v32 = AssociatedConformanceWitness;
      uint64_t v19 = v40;
      v29(v18, v30, v32);
      uint64_t v3 = v47;
      uint64_t v14 = v48;
      v31(v48, v47);
      uint64_t v5 = v42;
      uint64_t v33 = v45;
      uint64_t v34 = swift_getAssociatedTypeWitness(255, v45, v26, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
      uint64_t v35 = (uint64_t)v33;
      a2 = v44;
      uint64_t v36 = swift_getAssociatedConformanceWitness(v35, v26, (uint64_t)v34, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      uint64_t v37 = swift_getAssociatedConformanceWitness(v36, (uint64_t)v34, v26, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      char v22 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v37 + 8) + 8))(v49, v50, v26);
    }
    else
    {
      uint64_t v24 = *v46;
      (*v46)(v14, v3);
      v24(v17, v3);
      char v22 = 0;
    }
    if (++v18 == 32) {
      break;
    }
    v19(v17, v5, v3);
  }
  return v22 & 1;
}

uint64_t SIMD32<>.init<A>(truncatingIfNeeded:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v38 = a1;
  uint64_t v36 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v33 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v32 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v30 = a7;
  uint64_t v31 = v21;
  uint64_t v37 = a3;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v23 = 0;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  do
  {
    uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v31);
    v24(v23, v25, v22);
    (*(void (**)(char *, uint64_t, void))(*(void *)(v34 + 8) + 96))(v14, v37, *(void *)(v35 + 8));
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v16, v23++, v32, AssociatedConformanceWitness);
  }
  while (v23 != 32);
  uint64_t v27 = type metadata accessor for SIMD32(0, v37, (uint64_t)v30, v26);
  return (*((uint64_t (**)(uint64_t, Class *))*(v27 - 1) + 1))(v38, v27);
}

uint64_t SIMD32<>.init<A>(clamping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v38 = a1;
  uint64_t v36 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v33 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v32 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v30 = a7;
  uint64_t v31 = v21;
  uint64_t v37 = a3;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v23 = 0;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  do
  {
    uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v31);
    v24(v23, v25, v22);
    (*(void (**)(char *, uint64_t, void))(*(void *)(v34 + 8) + 104))(v14, v37, *(void *)(v35 + 8));
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v16, v23++, v32, AssociatedConformanceWitness);
  }
  while (v23 != 32);
  uint64_t v27 = type metadata accessor for SIMD32(0, v37, (uint64_t)v30, v26);
  return (*((uint64_t (**)(uint64_t, Class *))*(v27 - 1) + 1))(v38, v27);
}

uint64_t SIMD32<>.init<A>(_:rounding:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, int **a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v34 = a8;
  uint64_t v42 = a5;
  uint64_t v43 = a7;
  uint64_t v40 = a2;
  uint64_t v46 = a1;
  uint64_t v44 = a9;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v33 - v14;
  MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v33 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v19, v18, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v41 = a3;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v22 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v39 = AssociatedTypeWitness;
  v22(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v23 = v34;
  uint64_t v24 = swift_getAssociatedTypeWitness(255, v34, a4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v45 = a4;
  uint64_t v38 = v24;
  uint64_t v25 = swift_getAssociatedConformanceWitness((uint64_t)v23, a4, (uint64_t)v24, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v26 = 0;
  uint64_t v36 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v25 + 56);
  uint64_t v37 = v25;
  uint64_t v35 = AssociatedConformanceWitness + 64;
  uint64_t v27 = v43;
  uint64_t v28 = v45;
  do
  {
    uint64_t v29 = swift_checkMetadataState(0, (uint64_t)v38);
    v36(v26, v29, v37);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v27 + 16) + 304))(v40, v28);
    (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v42 + 8) + 80))(v15, v28, v27);
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v17, v26++, v39, AssociatedConformanceWitness);
  }
  while (v26 != 32);
  uint64_t v31 = type metadata accessor for SIMD32(0, v45, (uint64_t)v34, v30);
  return (*((uint64_t (**)(uint64_t, Class *))*(v31 - 1) + 1))(v46, v31);
}

unint64_t SIMD32.debugDescription.getter(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(Class **)(a1 + 16);
  size_t v3 = *((void *)*(v2 - 1) + 8);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v5 = (char *)&v356 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = MEMORY[0x1F4188790](v4);
  uint64_t v8 = (char *)&v356 - v7;
  uint64_t v9 = MEMORY[0x1F4188790](v6);
  v405 = (char *)&v356 - v10;
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v404 = (char *)&v356 - v12;
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v403 = (char *)&v356 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  v402 = (char *)&v356 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v401 = (char *)&v356 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v400 = (char *)&v356 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v399 = (char *)&v356 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  v398 = (char *)&v356 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  uint64_t v397 = (char *)&v356 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v396 = (char *)&v356 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  uint64_t v395 = (char *)&v356 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  v394 = (char *)&v356 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  uint64_t v393 = (char *)&v356 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  uint64_t v392 = (char *)&v356 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  uint64_t v391 = (char *)&v356 - v38;
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  v390 = (char *)&v356 - v40;
  uint64_t v41 = MEMORY[0x1F4188790](v39);
  unint64_t v363 = (unint64_t *)((char *)&v356 - v42);
  uint64_t v43 = MEMORY[0x1F4188790](v41);
  uint64_t v369 = (unint64_t *)((char *)&v356 - v44);
  uint64_t v45 = MEMORY[0x1F4188790](v43);
  v375 = (unint64_t *)((char *)&v356 - v46);
  uint64_t v47 = MEMORY[0x1F4188790](v45);
  uint64_t v381 = (unint64_t *)((char *)&v356 - v48);
  uint64_t v49 = MEMORY[0x1F4188790](v47);
  uint64_t v51 = (char *)&v356 - v50;
  uint64_t v52 = MEMORY[0x1F4188790](v49);
  uint64_t v362 = (unint64_t *)((char *)&v356 - v53);
  uint64_t v54 = MEMORY[0x1F4188790](v52);
  v368 = (unint64_t *)((char *)&v356 - v55);
  uint64_t v56 = MEMORY[0x1F4188790](v54);
  v374 = (unint64_t *)((char *)&v356 - v57);
  uint64_t v58 = MEMORY[0x1F4188790](v56);
  uint64_t v380 = (unint64_t *)((char *)&v356 - v59);
  uint64_t v60 = MEMORY[0x1F4188790](v58);
  uint64_t v389 = (char *)&v356 - v61;
  uint64_t v62 = MEMORY[0x1F4188790](v60);
  uint64_t v361 = (unint64_t *)((char *)&v356 - v63);
  uint64_t v64 = MEMORY[0x1F4188790](v62);
  v367 = (unint64_t *)((char *)&v356 - v65);
  uint64_t v66 = MEMORY[0x1F4188790](v64);
  v373 = (unint64_t *)((char *)&v356 - v67);
  uint64_t v68 = MEMORY[0x1F4188790](v66);
  unint64_t v379 = (unint64_t *)((char *)&v356 - v69);
  uint64_t v70 = MEMORY[0x1F4188790](v68);
  uint64_t v388 = (char *)&v356 - v71;
  uint64_t v72 = MEMORY[0x1F4188790](v70);
  v360 = (unint64_t *)((char *)&v356 - v73);
  uint64_t v74 = MEMORY[0x1F4188790](v72);
  unint64_t v366 = (unint64_t *)((char *)&v356 - v75);
  uint64_t v76 = MEMORY[0x1F4188790](v74);
  v372 = (unint64_t *)((char *)&v356 - v77);
  uint64_t v78 = MEMORY[0x1F4188790](v76);
  unint64_t v378 = (unint64_t *)((char *)&v356 - v79);
  uint64_t v80 = MEMORY[0x1F4188790](v78);
  uint64_t v387 = (char *)&v356 - v81;
  uint64_t v82 = MEMORY[0x1F4188790](v80);
  uint64_t v359 = (unint64_t *)((char *)&v356 - v83);
  uint64_t v84 = MEMORY[0x1F4188790](v82);
  uint64_t v365 = (unint64_t *)((char *)&v356 - v85);
  uint64_t v86 = MEMORY[0x1F4188790](v84);
  v371 = (unint64_t *)((char *)&v356 - v87);
  uint64_t v88 = MEMORY[0x1F4188790](v86);
  uint64_t v377 = (unint64_t *)((char *)&v356 - v89);
  uint64_t v90 = MEMORY[0x1F4188790](v88);
  v386 = (char *)&v356 - v91;
  uint64_t v92 = MEMORY[0x1F4188790](v90);
  uint64_t v358 = (unint64_t *)((char *)&v356 - v93);
  uint64_t v94 = MEMORY[0x1F4188790](v92);
  unint64_t v364 = (unint64_t *)((char *)&v356 - v95);
  uint64_t v96 = MEMORY[0x1F4188790](v94);
  unint64_t v370 = (unint64_t *)((char *)&v356 - v97);
  uint64_t v98 = MEMORY[0x1F4188790](v96);
  uint64_t v376 = (unint64_t *)((char *)&v356 - v99);
  uint64_t v100 = MEMORY[0x1F4188790](v98);
  v406 = (unint64_t *)((char *)&v356 - v101);
  MEMORY[0x1F4188790](v100);
  uint64_t v385 = (char *)&v356 - v102;
  unint64_t v103 = specialized static String._createEmpty(withInitialCapacity:)(138);
  uint64_t v105 = v104;
  unint64_t v413 = v103;
  unint64_t v414 = v104;
  uint64_t v106 = HIBYTE(v104) & 0xF;
  if ((v104 & 0x2000000000000000) == 0) {
    uint64_t v106 = v103 & 0xFFFFFFFFFFFFLL;
  }
  if (v106 || (v103 & ~v104 & 0x2000000000000000) != 0)
  {
    if ((v104 & 0x2000000000000000) == 0
      || (unint64_t v107 = specialized _SmallString.init(_:appending:)(v103, v104, 0x3C3233444D4953uLL, 0xE700000000000000),
          (v109 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE700000000000000);
      _StringGuts.append(_:)(0x3C3233444D4953, 0xE700000000000000, 0, 7);
      swift_bridgeObjectRelease_n(0xE700000000000000, 2);
    }
    else
    {
      unint64_t v110 = v107;
      unint64_t v111 = v108;
      swift_bridgeObjectRelease(v105);
      swift_bridgeObjectRelease(0xE700000000000000);
      unint64_t v413 = v110;
      unint64_t v414 = v111;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v104);
    unint64_t v413 = 0x3C3233444D4953;
    unint64_t v414 = 0xE700000000000000;
  }
  TypeName = (uint64_t *)swift_getTypeName(v2, 0);
  if (v113 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  unint64_t v114 = (uint8x16_t *)TypeName;
  uint64_t v115 = v113;
  BOOL v116 = _allASCII(_:)(TypeName, v113);
  v382 = v51;
  if (!v116)
  {
    uint64_t v120 = 0;
    int64_t v121 = &v114->u8[v115];
    if (!v114) {
      int64_t v121 = 0;
    }
    char v117 = 1;
    for (i = v114; ; i = (uint8x16_t *)((char *)i + 3))
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            if (!i || i == (uint8x16_t *)v121) {
              goto LABEL_12;
            }
            unsigned int v124 = i->u8[0];
            i = (uint8x16_t *)((char *)i + 1);
            unsigned int v123 = v124;
            if ((v123 & 0x80) != 0) {
              break;
            }
            ++v120;
          }
          if ((v123 + 62) >= 0x33u) {
            goto LABEL_64;
          }
          if (v123 > 0xDF) {
            break;
          }
          if (!i || i == (uint8x16_t *)v121 || (i->i8[0] & 0xC0) != 0x80) {
            goto LABEL_64;
          }
          char v117 = 0;
          i = (uint8x16_t *)((char *)i + 1);
          v120 += 2;
        }
        if (v123 != 224) {
          break;
        }
        if (!i) {
          goto LABEL_64;
        }
        if (i == (uint8x16_t *)v121) {
          goto LABEL_64;
        }
        unint64_t v125 = &i->u8[1];
        if ((i->i8[0] & 0xE0) != 0xA0) {
          goto LABEL_64;
        }
LABEL_42:
        if (v125 == v121 || (*v125 & 0xC0) != 0x80) {
          goto LABEL_64;
        }
        char v117 = 0;
        i = (uint8x16_t *)((char *)i + 2);
        v120 += 3;
      }
      if (v123 <= 0xEC) {
        break;
      }
      if (v123 == 237)
      {
        if (!i) {
          goto LABEL_64;
        }
        if (i == (uint8x16_t *)v121) {
          goto LABEL_64;
        }
        unint64_t v125 = &i->u8[1];
        unsigned int v126 = i->u8[0];
        if (v126 > 0x9F) {
          goto LABEL_64;
        }
        goto LABEL_41;
      }
      if (v123 <= 0xEF) {
        break;
      }
      if (v123 == 240)
      {
        if (!i) {
          goto LABEL_64;
        }
        if (i == (uint8x16_t *)v121) {
          goto LABEL_64;
        }
        unint64_t v127 = &i->u8[1];
        if ((i->i8[0] + 64) < 0xD0u) {
          goto LABEL_64;
        }
      }
      else
      {
        if ((v123 + 15) > 2u)
        {
          if (!i || i == (uint8x16_t *)v121 || (unint64_t v127 = &i->u8[1], v128 = i->u8[0], v128 > 0x8F))
          {
LABEL_64:
            uint64_t v129 = v1;
            uint64_t v130 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
            v357 = v2;
            swift_willThrow();
            unint64_t v131 = v130;
            uint64_t v1 = v129;
            uint64_t v5 = (char *)&v356 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
            swift_errorRelease(v131);
            uint64_t v132 = specialized Collection.subscript.getter(v120, (uint64_t)v114, v115);
            int64_t v136 = findInvalidRange #1 (_:) in validateUTF8(_:)(v132, v133, v134, v135);
            uint64_t v2 = v357;
            unint64_t v118 = repairUTF8(_:firstKnownBrokenRange:)(v114->i8, v115, v136, v137);
            goto LABEL_65;
          }
        }
        else
        {
          if (!i || i == (uint8x16_t *)v121) {
            goto LABEL_64;
          }
          unint64_t v127 = &i->u8[1];
          LOBYTE(v128) = i->i8[0];
        }
        if ((v128 & 0xC0) != 0x80) {
          goto LABEL_64;
        }
      }
      if (v127 == v121 || (i->i8[1] & 0xC0) != 0x80 || &i->i16[1] == (__int16 *)v121 || (i->i8[2] & 0xC0) != 0x80) {
        goto LABEL_64;
      }
      char v117 = 0;
      v120 += 4;
    }
    if (!i || i == (uint8x16_t *)v121) {
      goto LABEL_64;
    }
    unint64_t v125 = &i->u8[1];
    LOBYTE(v126) = i->i8[0];
LABEL_41:
    if ((v126 & 0xC0) != 0x80) {
      goto LABEL_64;
    }
    goto LABEL_42;
  }
  char v117 = 1;
LABEL_12:
  unint64_t v118 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v114, v115, v117 & 1);
LABEL_65:
  unint64_t v138 = v118;
  unint64_t v139 = v119;
  unint64_t v140 = HIBYTE(v414) & 0xF;
  if ((v414 & 0x2000000000000000) == 0) {
    unint64_t v140 = v413 & 0xFFFFFFFFFFFFLL;
  }
  if (v140 || (v413 & ~v414 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(v118, v119);
    swift_bridgeObjectRelease(v139);
    unint64_t v138 = v413;
    unint64_t v139 = v414;
  }
  else
  {
    swift_bridgeObjectRelease(v414);
    unint64_t v413 = v138;
    unint64_t v414 = v139;
  }
  uint64_t v141 = HIBYTE(v139) & 0xF;
  if ((v139 & 0x2000000000000000) == 0) {
    uint64_t v141 = v138 & 0xFFFFFFFFFFFFLL;
  }
  v384 = v5;
  v383 = v8;
  if (v141 || (v138 & ~v139 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x283EuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v139);
    unint64_t v413 = 10302;
    unint64_t v414 = 0xE200000000000000;
  }
  uint64_t v142 = *(int ***)(v1 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v142, (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v142, (uint64_t)v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  unint64_t v145 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint32x4_t v146 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64x2_t v147 = v385;
  v145(0, v146, AssociatedConformanceWitness);
  uint64_t v408 = (uint64_t *)v2;
  uint64_t v148 = __swift_allocate_boxed_opaque_existential_0Tm(&v407);
  memcpy(v148, v147, v3);
  uint64_t v149 = v408;
  unint64_t v150 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
  DynamicType = (void *)swift_getDynamicType(v150, v149, 1);
  LODWORD(v149) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v407._countAndFlagsBits);
  if (v149)
  {
    uint64_t v152 = v406;
    memcpy(v406, v147, v3);
    uint64_t v153 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v407, v152, v2, v153, 7uLL);
LABEL_77:
    uint64_t v154 = (uint64_t)v408;
    uint64_t v155 = v409;
    __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
    unint64_t v156 = (*(uint64_t (**)(uint64_t, uint64_t))(v155 + 8))(v154, v155);
LABEL_78:
    uint64_t v158 = v157;
    specialized String.write<A>(to:)(&v413, v156, v157);
    swift_bridgeObjectRelease(v158);
LABEL_79:
    __swift_destroy_boxed_opaque_existential_1Tm(&v407._countAndFlagsBits);
    goto LABEL_82;
  }
  unint64_t v159 = v376;
  memcpy(v376, v147, v3);
  if (swift_dynamicCast((char *)&v407, v159, v2, (const char *)&type metadata for String, 6uLL))
  {
    unint64_t object = v407._object;
    String.append(_:)(v407);
    swift_bridgeObjectRelease((uint64_t)object);
  }
  else
  {
    unint64_t v274 = v370;
    memcpy(v370, v147, v3);
    unint64_t v275 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v410, v274, v2, v275, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      uint64_t v276 = (uint64_t)v408;
      uint64_t v277 = v409;
      __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v277 + 8))(&v413, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v276, v277);
      goto LABEL_79;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for TextOutputStreamable?);
    uint64_t v298 = v364;
    memcpy(v364, v147, v3);
    unint64_t v299 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v410, v298, v2, v299, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      uint64_t v300 = (uint64_t)v408;
      uint64_t v301 = v409;
      __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
      unint64_t v156 = (*(uint64_t (**)(uint64_t, uint64_t))(v301 + 8))(v300, v301);
      goto LABEL_78;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for CustomStringConvertible?);
    v322 = v358;
    memcpy(v358, v147, v3);
    v323 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v410, v322, v2, v323, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      goto LABEL_77;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v411 + 1) = v2;
    unint64_t v334 = __swift_allocate_boxed_opaque_existential_0Tm(&v410);
    memcpy(v334, v147, v3);
    Mirror.init(reflecting:)((uint64_t *)&v410, (uint64_t)&v407);
    uint64_t v335 = v407._object;
    uint64_t v336 = v409;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v147, &v407, &v413, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v336);
    swift_release((uint64_t)v335);
  }
LABEL_82:
  unint64_t v161 = HIBYTE(v414) & 0xF;
  if ((v414 & 0x2000000000000000) == 0) {
    unint64_t v161 = v413 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v162 = v386;
  if (v161 || (v413 & ~v414 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v414);
    unint64_t v413 = 8236;
    unint64_t v414 = 0xE200000000000000;
  }
  v145(1, v146, AssociatedConformanceWitness);
  uint64_t v408 = (uint64_t *)v2;
  unint64_t v163 = __swift_allocate_boxed_opaque_existential_0Tm(&v407);
  memcpy(v163, v162, v3);
  uint64_t v164 = v408;
  unint64_t v165 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
  uint64_t v166 = (void *)swift_getDynamicType(v165, v164, 1);
  LODWORD(v164) = swift_isOptionalType(v166);
  __swift_destroy_boxed_opaque_existential_1Tm(&v407._countAndFlagsBits);
  if (v164)
  {
    uint64_t v167 = v406;
    memcpy(v406, v162, v3);
    uint64_t v168 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v407, v167, v2, v168, 7uLL);
LABEL_89:
    uint64_t v169 = (uint64_t)v408;
    uint64_t v170 = v409;
    __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
    unint64_t v171 = (*(uint64_t (**)(uint64_t, uint64_t))(v170 + 8))(v169, v170);
LABEL_90:
    uint64_t v173 = v172;
    specialized String.write<A>(to:)(&v413, v171, v172);
    swift_bridgeObjectRelease(v173);
LABEL_91:
    __swift_destroy_boxed_opaque_existential_1Tm(&v407._countAndFlagsBits);
    goto LABEL_94;
  }
  unint64_t v174 = v377;
  memcpy(v377, v162, v3);
  if (swift_dynamicCast((char *)&v407, v174, v2, (const char *)&type metadata for String, 6uLL))
  {
    unint64_t v175 = v407._object;
    String.append(_:)(v407);
    swift_bridgeObjectRelease((uint64_t)v175);
  }
  else
  {
    unint64_t v278 = v371;
    memcpy(v371, v162, v3);
    uint64_t v279 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v410, v278, v2, v279, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      uint64_t v280 = (uint64_t)v408;
      uint64_t v281 = v409;
      __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v281 + 8))(&v413, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v280, v281);
      goto LABEL_91;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for TextOutputStreamable?);
    uint64_t v302 = v365;
    memcpy(v365, v162, v3);
    unint64_t v303 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v410, v302, v2, v303, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      uint64_t v304 = (uint64_t)v408;
      uint64_t v305 = v409;
      __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
      unint64_t v171 = (*(uint64_t (**)(uint64_t, uint64_t))(v305 + 8))(v304, v305);
      goto LABEL_90;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for CustomStringConvertible?);
    uint64_t v324 = v359;
    memcpy(v359, v162, v3);
    unint64_t v325 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v410, v324, v2, v325, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      goto LABEL_89;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v411 + 1) = v2;
    v337 = __swift_allocate_boxed_opaque_existential_0Tm(&v410);
    memcpy(v337, v162, v3);
    Mirror.init(reflecting:)((uint64_t *)&v410, (uint64_t)&v407);
    uint64_t v338 = v407._object;
    uint64_t v339 = v162;
    uint64_t v340 = v409;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v339, &v407, &v413, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v340);
    swift_release((uint64_t)v338);
  }
LABEL_94:
  unint64_t v176 = HIBYTE(v414) & 0xF;
  if ((v414 & 0x2000000000000000) == 0) {
    unint64_t v176 = v413 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v177 = v387;
  if (v176 || (v413 & ~v414 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v414);
    unint64_t v413 = 8236;
    unint64_t v414 = 0xE200000000000000;
  }
  v145(2, v146, AssociatedConformanceWitness);
  uint64_t v408 = (uint64_t *)v2;
  unint64_t v178 = __swift_allocate_boxed_opaque_existential_0Tm(&v407);
  memcpy(v178, v177, v3);
  unint64_t v179 = v408;
  unint64_t v180 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
  char v181 = (void *)swift_getDynamicType(v180, v179, 1);
  LODWORD(v179) = swift_isOptionalType(v181);
  __swift_destroy_boxed_opaque_existential_1Tm(&v407._countAndFlagsBits);
  if (v179)
  {
    unint64_t v182 = v406;
    memcpy(v406, v177, v3);
    unint64_t v183 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v407, v182, v2, v183, 7uLL);
LABEL_101:
    uint64_t v184 = (uint64_t)v408;
    uint64_t v185 = v409;
    __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
    unint64_t v186 = (*(uint64_t (**)(uint64_t, uint64_t))(v185 + 8))(v184, v185);
LABEL_102:
    uint64_t v188 = v187;
    specialized String.write<A>(to:)(&v413, v186, v187);
    swift_bridgeObjectRelease(v188);
LABEL_103:
    __swift_destroy_boxed_opaque_existential_1Tm(&v407._countAndFlagsBits);
    goto LABEL_106;
  }
  unint64_t v189 = v378;
  memcpy(v378, v177, v3);
  if (swift_dynamicCast((char *)&v407, v189, v2, (const char *)&type metadata for String, 6uLL))
  {
    unint64_t v190 = v407._object;
    String.append(_:)(v407);
    swift_bridgeObjectRelease((uint64_t)v190);
  }
  else
  {
    unint64_t v282 = v372;
    memcpy(v372, v177, v3);
    uint64_t v283 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v410, v282, v2, v283, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      uint64_t v284 = (uint64_t)v408;
      uint64_t v285 = v409;
      __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v285 + 8))(&v413, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v284, v285);
      goto LABEL_103;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for TextOutputStreamable?);
    uint64_t v306 = v366;
    memcpy(v366, v177, v3);
    size_t v307 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v410, v306, v2, v307, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      uint64_t v308 = (uint64_t)v408;
      uint64_t v309 = v409;
      __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
      unint64_t v186 = (*(uint64_t (**)(uint64_t, uint64_t))(v309 + 8))(v308, v309);
      goto LABEL_102;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for CustomStringConvertible?);
    v326 = v360;
    memcpy(v360, v177, v3);
    uint64_t v327 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v410, v326, v2, v327, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      goto LABEL_101;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v411 + 1) = v2;
    v341 = __swift_allocate_boxed_opaque_existential_0Tm(&v410);
    memcpy(v341, v177, v3);
    Mirror.init(reflecting:)((uint64_t *)&v410, (uint64_t)&v407);
    uint64_t v342 = v407._object;
    uint64_t v343 = v177;
    uint64_t v344 = v409;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v343, &v407, &v413, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v344);
    swift_release((uint64_t)v342);
  }
LABEL_106:
  unint64_t v191 = HIBYTE(v414) & 0xF;
  if ((v414 & 0x2000000000000000) == 0) {
    unint64_t v191 = v413 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v192 = v388;
  if (v191 || (v413 & ~v414 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v414);
    unint64_t v413 = 8236;
    unint64_t v414 = 0xE200000000000000;
  }
  v145(3, v146, AssociatedConformanceWitness);
  uint64_t v408 = (uint64_t *)v2;
  char v193 = __swift_allocate_boxed_opaque_existential_0Tm(&v407);
  memcpy(v193, v192, v3);
  unint64_t v194 = v408;
  unint64_t v195 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
  unint64_t v196 = (void *)swift_getDynamicType(v195, v194, 1);
  LODWORD(v194) = swift_isOptionalType(v196);
  __swift_destroy_boxed_opaque_existential_1Tm(&v407._countAndFlagsBits);
  if (v194)
  {
    int64x2_t v197 = v406;
    memcpy(v406, v192, v3);
    uint64_t v198 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v407, v197, v2, v198, 7uLL);
LABEL_113:
    uint64_t v199 = (uint64_t)v408;
    uint64_t v200 = v409;
    __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
    unint64_t v201 = (*(uint64_t (**)(uint64_t, uint64_t))(v200 + 8))(v199, v200);
LABEL_114:
    uint64_t v203 = v202;
    specialized String.write<A>(to:)(&v413, v201, v202);
    swift_bridgeObjectRelease(v203);
LABEL_115:
    __swift_destroy_boxed_opaque_existential_1Tm(&v407._countAndFlagsBits);
    goto LABEL_118;
  }
  unint64_t v204 = v379;
  memcpy(v379, v192, v3);
  if (swift_dynamicCast((char *)&v407, v204, v2, (const char *)&type metadata for String, 6uLL))
  {
    unint64_t v205 = v407._object;
    String.append(_:)(v407);
    swift_bridgeObjectRelease((uint64_t)v205);
  }
  else
  {
    uint64_t v286 = v373;
    memcpy(v373, v192, v3);
    uint64_t v287 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v410, v286, v2, v287, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      uint64_t v288 = (uint64_t)v408;
      uint64_t v289 = v409;
      __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v289 + 8))(&v413, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v288, v289);
      goto LABEL_115;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for TextOutputStreamable?);
    unint64_t v310 = v367;
    memcpy(v367, v192, v3);
    unint64_t v311 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v410, v310, v2, v311, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      uint64_t v312 = (uint64_t)v408;
      uint64_t v313 = v409;
      __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
      unint64_t v201 = (*(uint64_t (**)(uint64_t, uint64_t))(v313 + 8))(v312, v313);
      goto LABEL_114;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for CustomStringConvertible?);
    uint64_t v328 = v361;
    memcpy(v361, v192, v3);
    uint64_t v329 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v410, v328, v2, v329, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      goto LABEL_113;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v411 + 1) = v2;
    v345 = __swift_allocate_boxed_opaque_existential_0Tm(&v410);
    memcpy(v345, v192, v3);
    Mirror.init(reflecting:)((uint64_t *)&v410, (uint64_t)&v407);
    uint64_t v346 = v407._object;
    uint64_t v347 = v192;
    uint64_t v348 = v409;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v347, &v407, &v413, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v348);
    swift_release((uint64_t)v346);
  }
LABEL_118:
  unint64_t v206 = HIBYTE(v414) & 0xF;
  if ((v414 & 0x2000000000000000) == 0) {
    unint64_t v206 = v413 & 0xFFFFFFFFFFFFLL;
  }
  int8x16_t v207 = v389;
  if (v206 || (v413 & ~v414 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v414);
    unint64_t v413 = 8236;
    unint64_t v414 = 0xE200000000000000;
  }
  v145(4, v146, AssociatedConformanceWitness);
  uint64_t v408 = (uint64_t *)v2;
  int8x16_t v208 = __swift_allocate_boxed_opaque_existential_0Tm(&v407);
  memcpy(v208, v207, v3);
  int8x16_t v209 = v408;
  int8x16_t v210 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
  uint64_t v211 = (void *)swift_getDynamicType(v210, v209, 1);
  LODWORD(v209) = swift_isOptionalType(v211);
  __swift_destroy_boxed_opaque_existential_1Tm(&v407._countAndFlagsBits);
  if (v209)
  {
    uint64_t v212 = v406;
    memcpy(v406, v207, v3);
    uint64_t v213 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v407, v212, v2, v213, 7uLL);
LABEL_125:
    uint64_t v214 = (uint64_t)v408;
    uint64_t v215 = v409;
    __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
    unint64_t v216 = (*(uint64_t (**)(uint64_t, uint64_t))(v215 + 8))(v214, v215);
LABEL_126:
    uint64_t v218 = v217;
    specialized String.write<A>(to:)(&v413, v216, v217);
    swift_bridgeObjectRelease(v218);
LABEL_127:
    __swift_destroy_boxed_opaque_existential_1Tm(&v407._countAndFlagsBits);
    goto LABEL_130;
  }
  unint64_t v219 = v380;
  memcpy(v380, v207, v3);
  if (swift_dynamicCast((char *)&v407, v219, v2, (const char *)&type metadata for String, 6uLL))
  {
    uint64_t v220 = v407._object;
    String.append(_:)(v407);
    swift_bridgeObjectRelease((uint64_t)v220);
  }
  else
  {
    uint64_t v290 = v374;
    memcpy(v374, v207, v3);
    v291 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v410, v290, v2, v291, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      uint64_t v292 = (uint64_t)v408;
      uint64_t v293 = v409;
      __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v293 + 8))(&v413, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v292, v293);
      goto LABEL_127;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for TextOutputStreamable?);
    unint64_t v314 = v368;
    memcpy(v368, v207, v3);
    char v315 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v410, v314, v2, v315, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      uint64_t v316 = (uint64_t)v408;
      uint64_t v317 = v409;
      __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
      unint64_t v216 = (*(uint64_t (**)(uint64_t, uint64_t))(v317 + 8))(v316, v317);
      goto LABEL_126;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for CustomStringConvertible?);
    uint64_t v330 = v362;
    memcpy(v362, v207, v3);
    uint64_t v331 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v410, v330, v2, v331, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      goto LABEL_125;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v411 + 1) = v2;
    unint64_t v349 = __swift_allocate_boxed_opaque_existential_0Tm(&v410);
    memcpy(v349, v207, v3);
    Mirror.init(reflecting:)((uint64_t *)&v410, (uint64_t)&v407);
    uint64_t v350 = v407._object;
    uint64_t v351 = v207;
    uint64_t v352 = v409;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v351, &v407, &v413, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v352);
    swift_release((uint64_t)v350);
  }
LABEL_130:
  unint64_t v221 = v382;
  unint64_t v222 = HIBYTE(v414) & 0xF;
  if ((v414 & 0x2000000000000000) == 0) {
    unint64_t v222 = v413 & 0xFFFFFFFFFFFFLL;
  }
  if (v222 || (v413 & ~v414 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v414);
    unint64_t v413 = 8236;
    unint64_t v414 = 0xE200000000000000;
  }
  v145(5, v146, AssociatedConformanceWitness);
  uint64_t v408 = (uint64_t *)v2;
  uint64_t v223 = __swift_allocate_boxed_opaque_existential_0Tm(&v407);
  memcpy(v223, v221, v3);
  uint64_t v224 = v408;
  unint64_t v225 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
  int8x16_t v226 = (void *)swift_getDynamicType(v225, v224, 1);
  LODWORD(v224) = swift_isOptionalType(v226);
  __swift_destroy_boxed_opaque_existential_1Tm(&v407._countAndFlagsBits);
  if (v224)
  {
    uint64_t v227 = v406;
    memcpy(v406, v221, v3);
    uint64_t v228 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v407, v227, v2, v228, 7uLL);
LABEL_137:
    uint64_t v229 = (uint64_t)v408;
    uint64_t v230 = v409;
    __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
    unint64_t v231 = (*(uint64_t (**)(uint64_t, uint64_t))(v230 + 8))(v229, v230);
LABEL_138:
    uint64_t v233 = v232;
    specialized String.write<A>(to:)(&v413, v231, v232);
    swift_bridgeObjectRelease(v233);
LABEL_139:
    __swift_destroy_boxed_opaque_existential_1Tm(&v407._countAndFlagsBits);
    goto LABEL_142;
  }
  char v234 = v381;
  memcpy(v381, v221, v3);
  if (swift_dynamicCast((char *)&v407, v234, v2, (const char *)&type metadata for String, 6uLL))
  {
    unint64_t v235 = v407._object;
    String.append(_:)(v407);
    swift_bridgeObjectRelease((uint64_t)v235);
  }
  else
  {
    uint64_t v294 = v375;
    memcpy(v375, v221, v3);
    unint64_t v295 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
    if (swift_dynamicCast((char *)&v410, v294, v2, v295, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      uint64_t v296 = (uint64_t)v408;
      uint64_t v297 = v409;
      __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
      (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v297 + 8))(&v413, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v296, v297);
      goto LABEL_139;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for TextOutputStreamable?);
    unint64_t v318 = v369;
    memcpy(v369, v221, v3);
    unint64_t v319 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
    if (swift_dynamicCast((char *)&v410, v318, v2, v319, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      uint64_t v320 = (uint64_t)v408;
      uint64_t v321 = v409;
      __swift_project_boxed_opaque_existential_0Tm(&v407, (uint64_t)v408);
      unint64_t v231 = (*(uint64_t (**)(uint64_t, uint64_t))(v321 + 8))(v320, v321);
      goto LABEL_138;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for CustomStringConvertible?);
    uint64_t v332 = v363;
    memcpy(v363, v221, v3);
    unint64_t v333 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    if (swift_dynamicCast((char *)&v410, v332, v2, v333, 6uLL))
    {
      outlined init with take of MirrorPath(&v410, (uint64_t)&v407);
      goto LABEL_137;
    }
    uint64_t v412 = 0;
    long long v410 = 0u;
    long long v411 = 0u;
    outlined destroy of _HasContiguousBytes?((uint64_t)&v410, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
    *((void *)&v411 + 1) = v2;
    unint64_t v353 = __swift_allocate_boxed_opaque_existential_0Tm(&v410);
    memcpy(v353, v221, v3);
    Mirror.init(reflecting:)((uint64_t *)&v410, (uint64_t)&v407);
    uint64_t v354 = v407._object;
    uint64_t v355 = v409;
    ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v221, &v407, &v413, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
    swift_release(v355);
    swift_release((uint64_t)v354);
  }
LABEL_142:
  unint64_t v236 = HIBYTE(v414) & 0xF;
  if ((v414 & 0x2000000000000000) == 0) {
    unint64_t v236 = v413 & 0xFFFFFFFFFFFFLL;
  }
  if (v236 || (v413 & ~v414 & 0x2000000000000000) != 0)
  {
    _StringGuts.append(_:)(0x202CuLL, 0xE200000000000000);
    swift_bridgeObjectRelease(0xE200000000000000);
  }
  else
  {
    swift_bridgeObjectRelease(v414);
    unint64_t v413 = 8236;
    unint64_t v414 = 0xE200000000000000;
  }
  uint64_t v237 = (uint64_t)v406;
  v145(6, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v237, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v413, 0x202CuLL, 0xE200000000000000);
  swift_bridgeObjectRelease(0xE200000000000000);
  v145(7, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v237, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v413, 0x202CuLL, 0xE200000000000000);
  swift_bridgeObjectRelease(0xE200000000000000);
  v145(8, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v237, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v413, 0x202CuLL, 0xE200000000000000);
  swift_bridgeObjectRelease(0xE200000000000000);
  v145(9, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v237, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v413, 0x202CuLL, 0xE200000000000000);
  swift_bridgeObjectRelease(0xE200000000000000);
  v145(10, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v237, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v413, 0x202CuLL, 0xE200000000000000);
  swift_bridgeObjectRelease(0xE200000000000000);
  v145(11, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v237, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v413, 0x202CuLL, 0xE200000000000000);
  swift_bridgeObjectRelease(0xE200000000000000);
  v145(12, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v237, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v413, 0x202CuLL, 0xE200000000000000);
  swift_bridgeObjectRelease(0xE200000000000000);
  v145(13, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v237, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v413, 0x202CuLL, 0xE200000000000000);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v238 = (uint64_t)v390;
  v145(14, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v238, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  specialized String.write<A>(to:)(&v413, 0x202CuLL, 0xE200000000000000);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v239 = (uint64_t)v391;
  v145(15, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v239, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v240._unint64_t countAndFlagsBits = 8236;
  v240._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v240);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v241 = (uint64_t)v392;
  v145(16, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v241, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v242._unint64_t countAndFlagsBits = 8236;
  v242._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v242);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v243 = (uint64_t)v393;
  v145(17, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v243, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v244._unint64_t countAndFlagsBits = 8236;
  v244._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v244);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v245 = (uint64_t)v394;
  v145(18, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v245, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v246._unint64_t countAndFlagsBits = 8236;
  v246._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v246);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v247 = (uint64_t)v395;
  v145(19, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v247, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v248._unint64_t countAndFlagsBits = 8236;
  v248._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v248);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v249 = (uint64_t)v396;
  v145(20, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v249, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v250._unint64_t countAndFlagsBits = 8236;
  v250._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v250);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v251 = (uint64_t)v397;
  v145(21, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v251, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v252._unint64_t countAndFlagsBits = 8236;
  v252._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v252);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v253 = (uint64_t)v398;
  v145(22, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v253, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v254._unint64_t countAndFlagsBits = 8236;
  v254._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v254);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v255 = (uint64_t)v399;
  v145(23, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v255, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v256._unint64_t countAndFlagsBits = 8236;
  v256._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v256);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v257 = (uint64_t)v400;
  v145(24, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v257, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v258._unint64_t countAndFlagsBits = 8236;
  v258._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v258);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v259 = (uint64_t)v401;
  v145(25, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v259, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v260._unint64_t countAndFlagsBits = 8236;
  v260._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v260);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v261 = (uint64_t)v402;
  v145(26, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v261, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v262._unint64_t countAndFlagsBits = 8236;
  v262._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v262);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v263 = (uint64_t)v403;
  v145(27, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v263, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v264._unint64_t countAndFlagsBits = 8236;
  v264._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v264);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v265 = (uint64_t)v404;
  v145(28, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v265, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v266._unint64_t countAndFlagsBits = 8236;
  v266._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v266);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v267 = (uint64_t)v405;
  v145(29, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v267, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v268._unint64_t countAndFlagsBits = 8236;
  v268._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v268);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v269 = (uint64_t)v383;
  v145(30, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v269, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v270._unint64_t countAndFlagsBits = 8236;
  v270._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v270);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v271 = (uint64_t)v384;
  v145(31, v146, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v271, (uint64_t)&v413, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v272._unint64_t countAndFlagsBits = 41;
  v272._unint64_t object = (void *)0xE100000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v272);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v413;
}

uint64_t SIMD32<>.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v38 = a1;
  uint64_t v36 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v33 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v32 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v30 = a7;
  uint64_t v31 = v21;
  uint64_t v37 = a3;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v23 = 0;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  do
  {
    uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v31);
    v24(v23, v25, v22);
    (*(void (**)(char *, uint64_t, void))(*(void *)(v34 + 16) + 72))(v14, v37, *(void *)(v35 + 8));
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v16, v23++, v32, AssociatedConformanceWitness);
  }
  while (v23 != 32);
  uint64_t v27 = type metadata accessor for SIMD32(0, v37, (uint64_t)v30, v26);
  return (*((uint64_t (**)(uint64_t, Class *))*(v27 - 1) + 1))(v38, v27);
}

{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  int **v17;
  const char *AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  void (*v20)(const char *, uint64_t);
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  Class *v27;
  uint64_t v29;
  uint64_t v30;
  int **v31;
  void (*v32)(uint64_t, uint64_t *, uint64_t);
  uint64_t v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;

  uint64_t v37 = a6;
  uint64_t v38 = a8;
  uint64_t v30 = a4;
  uint64_t v40 = a1;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v36 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v35 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t v31 = a7;
  uint64_t v39 = a3;
  uint64_t v34 = v21;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v23 = 0;
  uint64_t v32 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  uint64_t v33 = v22;
  uint64_t v24 = v30;
  do
  {
    uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v34);
    v32(v23, v25, v33);
    (*(void (**)(char *, uint64_t, uint64_t))(v24 + 80))(v14, v39, v37);
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v16, v23++, v35, AssociatedConformanceWitness);
  }
  while (v23 != 32);
  uint64_t v27 = type metadata accessor for SIMD32(0, v39, (uint64_t)v31, v26);
  return (*((uint64_t (**)(uint64_t, Class *))*(v27 - 1) + 1))(v40, v27);
}

uint64_t SIMD64._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage, a2);
}

uint64_t SIMD64._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
}

uint64_t (*SIMD64._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD64.scalarCount.getter()
{
  return 64;
}

uint64_t key path getter for SIMD64.subscript(_:) : <A>SIMD64<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  if ((unint64_t)*a2 >= 0x40) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x44FuLL, 0);
  }
  uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  uint64_t v4 = *(int ***)((char *)a2 + a3 - 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD64.subscript(_:) : <A>SIMD64<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + a3 - 16);
  uint64_t v5 = *(int ***)(a4 + a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v17 - v6;
  unint64_t v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 0x40) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x453uLL, 0);
  }
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v14 = *(uint64_t (**)(char *, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v15 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD64.subscript.modify(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x40) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x44FuLL, 0);
  }
  uint64_t v10 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t SIMD64.init(_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:)(const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, const void *a7, const void *a8, const void *a9, const void *a10, const void *a11, const void *a12, const void *a13, const void *a14, const void *a15, const void *a16, const void *a17, const void *a18, const void *a19, const void *a20,const void *a21,const void *a22,const void *a23,const void *a24,const void *a25,const void *a26,const void *a27,const void *a28,const void *a29,const void *a30,const void *a31,const void *a32,const void *a33,const void *a34,const void *a35,const void *a36,const void *a37,const void *a38,const void *a39,const void *a40,const void *a41,const void *a42,const void *a43,const void *a44,const void *a45,const void *a46,const void *a47,const void *a48,const void *a49,const void *a50,const void *a51,const void *a52,const void *a53,const void *a54,const void *a55,const void *a56,const void *a57,const void *a58,const void *a59,const void *a60,const void *a61,const void *a62,const void *a63)
{
  unint64_t v299 = a8;
  uint64_t v296 = a7;
  uint64_t v294 = a6;
  v291 = a5;
  uint64_t v288 = a4;
  uint64_t v285 = a3;
  uint64_t v284 = a2;
  uint64_t v385 = a63;
  v386 = a64;
  v383 = a61;
  v384 = a62;
  uint64_t v381 = a59;
  v382 = a60;
  unint64_t v379 = a58;
  uint64_t v377 = a57;
  v375 = a56;
  v373 = a55;
  v371 = a54;
  v368 = a52;
  uint64_t v369 = a53;
  unint64_t v366 = a51;
  unint64_t v364 = a50;
  unint64_t v363 = a49;
  uint64_t v361 = a48;
  uint64_t v359 = a47;
  size_t v67 = *(void *)(*(void *)(a65 - 8) + 64);
  uint64_t v355 = a46;
  uint64_t v354 = a45;
  uint64_t v352 = a44;
  uint64_t v350 = a43;
  unint64_t v349 = a42;
  uint64_t v347 = a41;
  v345 = a40;
  uint64_t v343 = a39;
  uint64_t v342 = a38;
  uint64_t v340 = a37;
  uint64_t v338 = a36;
  v337 = a35;
  uint64_t v335 = a34;
  unint64_t v333 = a33;
  uint64_t v331 = a32;
  uint64_t v330 = a31;
  uint64_t v328 = a30;
  v326 = a29;
  unint64_t v325 = a28;
  v323 = a27;
  uint64_t v321 = a26;
  unint64_t v319 = a25;
  unint64_t v318 = a24;
  uint64_t v316 = a23;
  unint64_t v314 = a22;
  uint64_t v312 = a21;
  unint64_t v311 = a20;
  uint64_t v309 = a19;
  size_t v307 = a18;
  uint64_t v306 = a17;
  uint64_t v304 = a16;
  uint64_t v302 = a15;
  uint64_t v300 = a14;
  uint64_t v298 = a13;
  unint64_t v295 = a12;
  uint64_t v292 = a11;
  uint64_t v290 = a10;
  uint64_t v287 = a9;
  uint64_t v68 = MEMORY[0x1F4188790](a1);
  uint64_t v380 = (char *)&v262 - ((v67 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v69 = MEMORY[0x1F4188790](v68);
  unint64_t v378 = (char *)&v262 - v70;
  uint64_t v71 = MEMORY[0x1F4188790](v69);
  uint64_t v376 = (char *)&v262 - v72;
  uint64_t v73 = MEMORY[0x1F4188790](v71);
  v374 = (char *)&v262 - v74;
  uint64_t v75 = MEMORY[0x1F4188790](v73);
  v372 = (char *)&v262 - v76;
  uint64_t v77 = MEMORY[0x1F4188790](v75);
  unint64_t v370 = (char *)&v262 - v78;
  uint64_t v79 = MEMORY[0x1F4188790](v77);
  v367 = (char *)&v262 - v80;
  uint64_t v81 = MEMORY[0x1F4188790](v79);
  uint64_t v365 = (char *)&v262 - v82;
  uint64_t v83 = MEMORY[0x1F4188790](v81);
  uint64_t v362 = (char *)&v262 - v84;
  uint64_t v85 = MEMORY[0x1F4188790](v83);
  v360 = (char *)&v262 - v86;
  uint64_t v87 = MEMORY[0x1F4188790](v85);
  uint64_t v358 = (char *)&v262 - v88;
  uint64_t v89 = MEMORY[0x1F4188790](v87);
  v357 = (char *)&v262 - v90;
  uint64_t v91 = MEMORY[0x1F4188790](v89);
  uint64_t v356 = (char *)&v262 - v92;
  uint64_t v93 = MEMORY[0x1F4188790](v91);
  unint64_t v353 = (char *)&v262 - v94;
  uint64_t v95 = MEMORY[0x1F4188790](v93);
  uint64_t v351 = (char *)&v262 - v96;
  uint64_t v97 = MEMORY[0x1F4188790](v95);
  uint64_t v348 = (char *)&v262 - v98;
  uint64_t v99 = MEMORY[0x1F4188790](v97);
  uint64_t v346 = (char *)&v262 - v100;
  uint64_t v101 = MEMORY[0x1F4188790](v99);
  uint64_t v344 = (char *)&v262 - v102;
  uint64_t v103 = MEMORY[0x1F4188790](v101);
  v341 = (char *)&v262 - v104;
  uint64_t v105 = MEMORY[0x1F4188790](v103);
  uint64_t v339 = (char *)&v262 - v106;
  uint64_t v107 = MEMORY[0x1F4188790](v105);
  uint64_t v336 = (char *)&v262 - v108;
  uint64_t v109 = MEMORY[0x1F4188790](v107);
  unint64_t v334 = (char *)&v262 - v110;
  uint64_t v111 = MEMORY[0x1F4188790](v109);
  uint64_t v332 = (char *)&v262 - v112;
  uint64_t v113 = MEMORY[0x1F4188790](v111);
  uint64_t v329 = (char *)&v262 - v114;
  uint64_t v115 = MEMORY[0x1F4188790](v113);
  uint64_t v327 = (char *)&v262 - v116;
  uint64_t v117 = MEMORY[0x1F4188790](v115);
  uint64_t v324 = (char *)&v262 - v118;
  uint64_t v119 = MEMORY[0x1F4188790](v117);
  v322 = (char *)&v262 - v120;
  uint64_t v121 = MEMORY[0x1F4188790](v119);
  uint64_t v320 = (char *)&v262 - v122;
  uint64_t v123 = MEMORY[0x1F4188790](v121);
  uint64_t v317 = (char *)&v262 - v124;
  uint64_t v125 = MEMORY[0x1F4188790](v123);
  char v315 = (char *)&v262 - v126;
  uint64_t v127 = MEMORY[0x1F4188790](v125);
  uint64_t v313 = (char *)&v262 - v128;
  uint64_t v129 = MEMORY[0x1F4188790](v127);
  unint64_t v310 = (char *)&v262 - v130;
  uint64_t v131 = MEMORY[0x1F4188790](v129);
  uint64_t v308 = (char *)&v262 - v132;
  uint64_t v133 = MEMORY[0x1F4188790](v131);
  uint64_t v305 = (char *)&v262 - v134;
  uint64_t v135 = MEMORY[0x1F4188790](v133);
  unint64_t v303 = (char *)&v262 - v136;
  uint64_t v137 = MEMORY[0x1F4188790](v135);
  uint64_t v301 = (char *)&v262 - v138;
  uint64_t v139 = MEMORY[0x1F4188790](v137);
  uint64_t v297 = (char *)&v262 - v140;
  uint64_t v141 = MEMORY[0x1F4188790](v139);
  uint64_t v293 = (char *)&v262 - v142;
  uint64_t v143 = MEMORY[0x1F4188790](v141);
  uint64_t v289 = (char *)&v262 - v144;
  uint64_t v145 = MEMORY[0x1F4188790](v143);
  uint64_t v286 = (char *)&v262 - v146;
  uint64_t v147 = MEMORY[0x1F4188790](v145);
  uint64_t v283 = (char *)&v262 - v148;
  uint64_t v149 = MEMORY[0x1F4188790](v147);
  unint64_t v282 = (char *)&v262 - v150;
  uint64_t v151 = MEMORY[0x1F4188790](v149);
  uint64_t v281 = (char *)&v262 - v152;
  uint64_t v153 = MEMORY[0x1F4188790](v151);
  uint64_t v280 = (char *)&v262 - v154;
  uint64_t v155 = MEMORY[0x1F4188790](v153);
  uint64_t v279 = (char *)&v262 - v156;
  uint64_t v157 = MEMORY[0x1F4188790](v155);
  unint64_t v278 = (char *)&v262 - v158;
  uint64_t v159 = MEMORY[0x1F4188790](v157);
  uint64_t v277 = (char *)&v262 - v160;
  uint64_t v161 = MEMORY[0x1F4188790](v159);
  uint64_t v276 = (char *)&v262 - v162;
  uint64_t v163 = MEMORY[0x1F4188790](v161);
  unint64_t v275 = (char *)&v262 - v164;
  uint64_t v165 = MEMORY[0x1F4188790](v163);
  unint64_t v274 = (char *)&v262 - v166;
  uint64_t v167 = MEMORY[0x1F4188790](v165);
  unint64_t v273 = (char *)&v262 - v168;
  uint64_t v169 = MEMORY[0x1F4188790](v167);
  Swift::String v272 = (char *)&v262 - v170;
  uint64_t v171 = MEMORY[0x1F4188790](v169);
  uint64_t v271 = (char *)&v262 - v172;
  uint64_t v173 = MEMORY[0x1F4188790](v171);
  Swift::String v270 = (char *)&v262 - v174;
  uint64_t v175 = MEMORY[0x1F4188790](v173);
  uint64_t v269 = (char *)&v262 - v176;
  uint64_t v177 = MEMORY[0x1F4188790](v175);
  Swift::String v268 = (char *)&v262 - v178;
  uint64_t v179 = MEMORY[0x1F4188790](v177);
  uint64_t v267 = (char *)&v262 - v180;
  uint64_t v181 = MEMORY[0x1F4188790](v179);
  Swift::String v266 = (char *)&v262 - v182;
  uint64_t v183 = MEMORY[0x1F4188790](v181);
  uint64_t v265 = (char *)&v262 - v184;
  uint64_t v185 = MEMORY[0x1F4188790](v183);
  Swift::String v264 = (char *)&v262 - v186;
  uint64_t v187 = MEMORY[0x1F4188790](v185);
  uint64_t v263 = (char *)&v262 - v188;
  uint64_t v189 = MEMORY[0x1F4188790](v187);
  unint64_t v191 = (char *)&v262 - v190;
  uint64_t v192 = MEMORY[0x1F4188790](v189);
  unint64_t v194 = (char *)&v262 - v193;
  MEMORY[0x1F4188790](v192);
  unint64_t v196 = (char *)&v262 - v195;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a66, a65, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a66, a65, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v196, a1, v67);
  uint64_t v199 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  v199(v196, 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v194, v284, v67);
  v199(v194, 1, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy(v191, v285, v67);
  v199(v191, 2, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v200 = v263;
  memcpy(v263, v288, v67);
  v199(v200, 3, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v201 = v264;
  memcpy(v264, v291, v67);
  v199(v201, 4, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v202 = v265;
  memcpy(v265, v294, v67);
  v199(v202, 5, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v203 = v266;
  memcpy(v266, v296, v67);
  v199(v203, 6, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v204 = v267;
  memcpy(v267, v299, v67);
  v199(v204, 7, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v205 = v268;
  memcpy(v268, v287, v67);
  v199(v205, 8, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v206 = v269;
  memcpy(v269, v290, v67);
  v199(v206, 9, AssociatedTypeWitness, AssociatedConformanceWitness);
  int8x16_t v207 = v270;
  memcpy(v270, v292, v67);
  v199(v207, 10, AssociatedTypeWitness, AssociatedConformanceWitness);
  int8x16_t v208 = v271;
  memcpy(v271, v295, v67);
  v199(v208, 11, AssociatedTypeWitness, AssociatedConformanceWitness);
  int8x16_t v209 = v272;
  memcpy(v272, v298, v67);
  v199(v209, 12, AssociatedTypeWitness, AssociatedConformanceWitness);
  int8x16_t v210 = v273;
  memcpy(v273, v300, v67);
  v199(v210, 13, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v211 = v274;
  memcpy(v274, v302, v67);
  v199(v211, 14, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v212 = v275;
  memcpy(v275, v304, v67);
  v199(v212, 15, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v213 = v276;
  memcpy(v276, v306, v67);
  v199(v213, 16, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v214 = v277;
  memcpy(v277, v307, v67);
  v199(v214, 17, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v215 = v278;
  memcpy(v278, v309, v67);
  v199(v215, 18, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v216 = v279;
  memcpy(v279, v311, v67);
  v199(v216, 19, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v217 = v280;
  memcpy(v280, v312, v67);
  v199(v217, 20, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v218 = v281;
  memcpy(v281, v314, v67);
  v199(v218, 21, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v219 = v282;
  memcpy(v282, v316, v67);
  v199(v219, 22, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v220 = v283;
  memcpy(v283, v318, v67);
  v199(v220, 23, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v221 = v286;
  memcpy(v286, v319, v67);
  v199(v221, 24, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v222 = v289;
  memcpy(v289, v321, v67);
  v199(v222, 25, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v223 = v293;
  memcpy(v293, v323, v67);
  v199(v223, 26, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v224 = v297;
  memcpy(v297, v325, v67);
  v199(v224, 27, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v225 = v301;
  memcpy(v301, v326, v67);
  v199(v225, 28, AssociatedTypeWitness, AssociatedConformanceWitness);
  int8x16_t v226 = v303;
  memcpy(v303, v328, v67);
  v199(v226, 29, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v227 = v305;
  memcpy(v305, v330, v67);
  v199(v227, 30, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v228 = v308;
  memcpy(v308, v331, v67);
  v199(v228, 31, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v229 = v310;
  memcpy(v310, v333, v67);
  v199(v229, 32, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v230 = v313;
  memcpy(v313, v335, v67);
  v199(v230, 33, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v231 = v315;
  memcpy(v315, v337, v67);
  v199(v231, 34, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v232 = v317;
  memcpy(v317, v338, v67);
  v199(v232, 35, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v233 = v320;
  memcpy(v320, v340, v67);
  v199(v233, 36, AssociatedTypeWitness, AssociatedConformanceWitness);
  char v234 = v322;
  memcpy(v322, v342, v67);
  v199(v234, 37, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v235 = v324;
  memcpy(v324, v343, v67);
  v199(v235, 38, AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v236 = v327;
  memcpy(v327, v345, v67);
  v199(v236, 39, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v237 = v329;
  memcpy(v329, v347, v67);
  v199(v237, 40, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v238 = v332;
  memcpy(v332, v349, v67);
  v199(v238, 41, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v239 = v334;
  memcpy(v334, v350, v67);
  v199(v239, 42, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v240 = v336;
  memcpy(v336, v352, v67);
  v199(v240, 43, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v241 = v339;
  memcpy(v339, v354, v67);
  v199(v241, 44, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v242 = v341;
  memcpy(v341, v355, v67);
  v199(v242, 45, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v243 = v344;
  memcpy(v344, v359, v67);
  v199(v243, 46, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v244 = v346;
  memcpy(v346, v361, v67);
  v199(v244, 47, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v245 = v348;
  memcpy(v348, v363, v67);
  v199(v245, 48, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v246 = v351;
  memcpy(v351, v364, v67);
  v199(v246, 49, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v247 = v353;
  memcpy(v353, v366, v67);
  v199(v247, 50, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v248 = v356;
  memcpy(v356, v368, v67);
  v199(v248, 51, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v249 = v357;
  memcpy(v357, v369, v67);
  v199(v249, 52, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v250 = v358;
  memcpy(v358, v371, v67);
  v199(v250, 53, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v251 = v360;
  memcpy(v360, v373, v67);
  v199(v251, 54, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v252 = v362;
  memcpy(v362, v375, v67);
  v199(v252, 55, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v253 = v365;
  memcpy(v365, v377, v67);
  v199(v253, 56, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v254 = v367;
  memcpy(v367, v379, v67);
  v199(v254, 57, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v255 = v370;
  memcpy(v370, v381, v67);
  v199(v255, 58, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v256 = v372;
  memcpy(v372, v382, v67);
  v199(v256, 59, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v257 = v374;
  memcpy(v374, v383, v67);
  v199(v257, 60, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v258 = v376;
  memcpy(v376, v384, v67);
  v199(v258, 61, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v259 = v378;
  memcpy(v378, v385, v67);
  v199(v259, 62, AssociatedTypeWitness, AssociatedConformanceWitness);
  Swift::String v260 = v380;
  memcpy(v380, v386, v67);
  return ((uint64_t (*)(char *, uint64_t, const char *, uint64_t))v199)(v260, 63, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t SIMD64.init(lowHalf:highHalf:)(uint64_t a1, uint64_t a2, uint64_t a3, int **a4)
{
  void (*v15)(Class *__return_ptr, uint64_t, Class *);
  uint64_t vars8;

  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  size_t v11 = type metadata accessor for SIMD64(0, a3, (uint64_t)a4, v10);
  specialized SIMD64.lowHalf.setter(a1, (uint64_t)v11);
  uint64_t v13 = type metadata accessor for SIMD32(0, a3, (uint64_t)a4, v12);
  uint64_t v15 = (void (*)(Class *__return_ptr, uint64_t, Class *))*((void *)*(v13 - 1) + 1);
  v15(v13 - 1, a1, v13);
  specialized SIMD64.highHalf.setter(a2, (uint64_t)v11);

  return ((uint64_t (*)(uint64_t, Class *))v15)(a2, v13);
}

uint64_t SIMD64.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD64.lowHalf.setter, (uint64_t (*)(void, void, void))type metadata accessor for SIMD32);
}

uint64_t SIMD64.highHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD64.highHalf.setter, (uint64_t (*)(void, void, void))type metadata accessor for SIMD32);
}

uint64_t SIMD64.lowHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = *(int ***)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v18 = AssociatedTypeWitness;
  uint64_t v19 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  size_t v11 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v12 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v13 = 0;
  uint64_t v14 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v12 + 56);
  do
  {
    uint64_t v15 = swift_checkMetadataState(0, (uint64_t)v11);
    v14(v13, v15, v12);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v6, v13++, v18, AssociatedConformanceWitness);
  }
  while (v13 != 32);
  return result;
}

uint64_t key path getter for SIMD64.lowHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD64, (uint64_t (*)(uint64_t))SIMD64.lowHalf.getter);
}

uint64_t key path setter for SIMD64.lowHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(void, void, void))type metadata accessor for SIMD64, specialized SIMD64.lowHalf.setter);
}

void (*SIMD64.lowHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD32(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD64.lowHalf.getter(a2, (uint64_t)v10);
  return SIMD64.lowHalf.modify;
}

void SIMD64.lowHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD64.highHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = *(int ***)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v18 = AssociatedTypeWitness;
  uint64_t v19 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  size_t v11 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v12 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)v11, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v13 = 0;
  uint64_t v14 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v12 + 56);
  do
  {
    uint64_t v15 = swift_checkMetadataState(0, (uint64_t)v11);
    v14(v13 + 32, v15, v12);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v6, v13++, v18, AssociatedConformanceWitness);
  }
  while (v13 != 32);
  return result;
}

uint64_t key path getter for SIMD64.highHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD64, (uint64_t (*)(uint64_t))SIMD64.highHalf.getter);
}

uint64_t key path setter for SIMD64.highHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(void, void, void))type metadata accessor for SIMD64, specialized SIMD64.highHalf.setter);
}

void (*SIMD64.highHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD32(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD64.highHalf.getter(a2, (uint64_t)v10);
  return SIMD64.highHalf.modify;
}

void SIMD64.highHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD64.evenHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = *(int ***)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v18 = AssociatedTypeWitness;
  uint64_t v19 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v17 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v11 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)v17, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v11 + 56);
  do
  {
    uint64_t v15 = swift_checkMetadataState(0, (uint64_t)v17);
    v14(v12, v15, v11);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v6, v13, v18, AssociatedConformanceWitness);
    v12 += 2;
    ++v13;
  }
  while (v13 != 32);
  return result;
}

uint64_t key path getter for SIMD64.evenHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD64, (uint64_t (*)(uint64_t))SIMD64.evenHalf.getter);
}

uint64_t key path setter for SIMD64.evenHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(void, void, void))type metadata accessor for SIMD64, specialized SIMD64.evenHalf.setter);
}

uint64_t SIMD64.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD64.evenHalf.setter, (uint64_t (*)(void, void, void))type metadata accessor for SIMD32);
}

void (*SIMD64.evenHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD32(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD64.evenHalf.getter(a2, (uint64_t)v10);
  return SIMD64.evenHalf.modify;
}

void SIMD64.evenHalf.modify(uint64_t **a1, char a2)
{
}

uint64_t SIMD64.oddHalf.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = *(int ***)(v4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v10 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v18 = AssociatedTypeWitness;
  uint64_t v19 = a2;
  v10(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v17 = swift_getAssociatedTypeWitness(255, v7, v3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v11 = swift_getAssociatedConformanceWitness((uint64_t)v7, v3, (uint64_t)v17, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v12 = 0;
  uint64_t v13 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v11 + 56);
  uint64_t v14 = 1;
  do
  {
    uint64_t v15 = swift_checkMetadataState(0, (uint64_t)v17);
    v13(v14, v15, v11);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v6, v12, v18, AssociatedConformanceWitness);
    v14 += 2;
    ++v12;
  }
  while (v12 != 32);
  return result;
}

uint64_t key path getter for SIMD64.oddHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return key path getter for SIMD4.lowHalf : <A>SIMD4<A>(a1, a2, a3, (uint64_t (*)(void, void, void))type metadata accessor for SIMD64, (uint64_t (*)(uint64_t))SIMD64.oddHalf.getter);
}

uint64_t key path setter for SIMD64.oddHalf : <A>SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return key path setter for SIMD64.oddHalf : <A>SIMD64<A>(a1, a2, a3, a4, (uint64_t (*)(void, void, void))type metadata accessor for SIMD64, specialized SIMD64.oddHalf.setter);
}

uint64_t SIMD64.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  return SIMD64.oddHalf.setter(a1, a2, (void (*)(void))specialized SIMD64.oddHalf.setter, (uint64_t (*)(void, void, void))type metadata accessor for SIMD32);
}

void (*SIMD64.oddHalf.modify(void *a1, uint64_t a2))(uint64_t **a1, char a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = a2;
  v5[1] = v2;
  uint64_t v7 = type metadata accessor for SIMD32(0, *(void *)(a2 + 16), *(void *)(a2 + 24), v6);
  v5[2] = v7;
  uint64_t v8 = (uint64_t)*(v7 - 1);
  v5[3] = v8;
  size_t v9 = *(void *)(v8 + 64);
  v5[4] = malloc(v9);
  uint64_t v10 = malloc(v9);
  v5[5] = v10;
  SIMD64.oddHalf.getter(a2, (uint64_t)v10);
  return SIMD64.oddHalf.modify;
}

void SIMD64.oddHalf.modify(uint64_t **a1, char a2)
{
}

Swift::Int SIMD64.hashValue.getter(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, protocol conformance descriptor for SIMD64<A>, a3);
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD64<A>(uint64_t a1, uint64_t a2)
{
  return protocol witness for SIMDStorage.init() in conformance SIMD2<A>(a1, a2, associated type descriptor for SIMDScalar.SIMD64Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD64<A>(unint64_t a1, uint64_t a2)
{
  if (a1 >= 0x40) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x44FuLL, 0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  size_t v9 = *(uint64_t (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v7 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD64<A>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 0x40) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x453uLL, 0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  size_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD64<A>(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 0x40) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x44FuLL, 0);
  }
  uint64_t v10 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD64<A>(void *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD64<A>, a2, a3);
  return SIMD.encode(to:)(a1, (uint64_t)a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD64<A>@<X0>(uint64_t *a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD64<A>, a2, a3);
  return SIMD.init(from:)(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD64<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD64<A>, a2, a3);

  return SIMD.hash(into:)(a1, (uint64_t)a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD64<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(a1, a2, a3, protocol conformance descriptor for SIMD64<A>);
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD64<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD64<A>, a1, a3);

  return SIMD.description.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD64<A>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD64<A>, a2, a3);

  return SIMD.init(arrayLiteral:)(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD64<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v5 = a1;
  uint64_t v43 = *(void *)(a3 + 16);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v50 = (char *)&v39 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  uint64_t v49 = (char *)&v39 - v9;
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v8);
  uint64_t v14 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v39 - v16;
  uint64_t v18 = 0;
  uint64_t v20 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v11 += 16;
  uint64_t v19 = v20;
  uint64_t v46 = (void (**)(char *, uint64_t))(v11 - 8);
  uint64_t v47 = v21;
  char v22 = 1;
  uint64_t v44 = v23;
  uint64_t v41 = v11;
  uint64_t v42 = v15;
  uint64_t v48 = v14;
  uint64_t v40 = v20;
  v20((char *)&v39 - v16, v5, v3);
  while (1)
  {
    v19(v14, a2, v3);
    if (v22)
    {
      uint64_t v25 = *(int ***)(v3 + 24);
      uint64_t v45 = v25;
      uint64_t v26 = v43;
      AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v25, v43, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v25, v26, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
      uint64_t v29 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
      uint64_t v30 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
      v29(v18, v30, AssociatedConformanceWitness);
      uint64_t v31 = *v46;
      (*v46)(v17, v47);
      uint64_t v32 = AssociatedConformanceWitness;
      uint64_t v19 = v40;
      v29(v18, v30, v32);
      uint64_t v3 = v47;
      uint64_t v14 = v48;
      v31(v48, v47);
      uint64_t v5 = v42;
      uint64_t v33 = v45;
      uint64_t v34 = swift_getAssociatedTypeWitness(255, v45, v26, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
      uint64_t v35 = (uint64_t)v33;
      a2 = v44;
      uint64_t v36 = swift_getAssociatedConformanceWitness(v35, v26, (uint64_t)v34, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      uint64_t v37 = swift_getAssociatedConformanceWitness(v36, (uint64_t)v34, v26, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      char v22 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v37 + 8) + 8))(v49, v50, v26);
    }
    else
    {
      uint64_t v24 = *v46;
      (*v46)(v14, v3);
      v24(v17, v3);
      char v22 = 0;
    }
    if (++v18 == 64) {
      break;
    }
    v19(v17, v5, v3);
  }
  return v22 & 1;
}

uint64_t SIMD64<>.init<A>(truncatingIfNeeded:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v38 = a1;
  uint64_t v36 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v33 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v32 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v30 = a7;
  uint64_t v31 = v21;
  uint64_t v37 = a3;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v23 = 0;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  do
  {
    uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v31);
    v24(v23, v25, v22);
    (*(void (**)(char *, uint64_t, void))(*(void *)(v34 + 8) + 96))(v14, v37, *(void *)(v35 + 8));
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v16, v23++, v32, AssociatedConformanceWitness);
  }
  while (v23 != 64);
  uint64_t v27 = type metadata accessor for SIMD64(0, v37, (uint64_t)v30, v26);
  return (*((uint64_t (**)(uint64_t, Class *))*(v27 - 1) + 1))(v38, v27);
}

uint64_t SIMD64<>.init<A>(clamping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v38 = a1;
  uint64_t v36 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v33 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v32 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v30 = a7;
  uint64_t v31 = v21;
  uint64_t v37 = a3;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v23 = 0;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  do
  {
    uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v31);
    v24(v23, v25, v22);
    (*(void (**)(char *, uint64_t, void))(*(void *)(v34 + 8) + 104))(v14, v37, *(void *)(v35 + 8));
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v16, v23++, v32, AssociatedConformanceWitness);
  }
  while (v23 != 64);
  uint64_t v27 = type metadata accessor for SIMD64(0, v37, (uint64_t)v30, v26);
  return (*((uint64_t (**)(uint64_t, Class *))*(v27 - 1) + 1))(v38, v27);
}

uint64_t SIMD64<>.init<A>(_:rounding:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, int **a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v34 = a8;
  uint64_t v42 = a5;
  uint64_t v43 = a7;
  uint64_t v40 = a2;
  uint64_t v46 = a1;
  uint64_t v44 = a9;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v33 - v14;
  MEMORY[0x1F4188790](v13);
  uint64_t v17 = (char *)&v33 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v19, v18, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v41 = a3;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v22 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v39 = AssociatedTypeWitness;
  v22(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v23 = v34;
  uint64_t v24 = swift_getAssociatedTypeWitness(255, v34, a4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v45 = a4;
  uint64_t v38 = v24;
  uint64_t v25 = swift_getAssociatedConformanceWitness((uint64_t)v23, a4, (uint64_t)v24, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v26 = 0;
  uint64_t v36 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v25 + 56);
  uint64_t v37 = v25;
  uint64_t v35 = AssociatedConformanceWitness + 64;
  uint64_t v27 = v43;
  uint64_t v28 = v45;
  do
  {
    uint64_t v29 = swift_checkMetadataState(0, (uint64_t)v38);
    v36(v26, v29, v37);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v27 + 16) + 304))(v40, v28);
    (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v42 + 8) + 80))(v15, v28, v27);
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v17, v26++, v39, AssociatedConformanceWitness);
  }
  while (v26 != 64);
  uint64_t v31 = type metadata accessor for SIMD64(0, v45, (uint64_t)v34, v30);
  return (*((uint64_t (**)(uint64_t, Class *))*(v31 - 1) + 1))(v46, v31);
}

uint64_t SIMD64.debugDescription.getter(uint64_t a1)
{
  uint64_t v2 = *(Class **)(a1 + 16);
  uint64_t v3 = MEMORY[0x1F4188790](a1);
  uint64_t v329 = (char *)&v267 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = MEMORY[0x1F4188790](v3);
  uint64_t v328 = (char *)&v267 - v6;
  uint64_t v7 = MEMORY[0x1F4188790](v5);
  uint64_t v327 = (char *)&v267 - v8;
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  v326 = (char *)&v267 - v10;
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  unint64_t v325 = (char *)&v267 - v12;
  uint64_t v13 = MEMORY[0x1F4188790](v11);
  uint64_t v324 = (char *)&v267 - v14;
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  v323 = (char *)&v267 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  v322 = (char *)&v267 - v18;
  uint64_t v19 = MEMORY[0x1F4188790](v17);
  uint64_t v321 = (char *)&v267 - v20;
  uint64_t v21 = MEMORY[0x1F4188790](v19);
  uint64_t v320 = (char *)&v267 - v22;
  uint64_t v23 = MEMORY[0x1F4188790](v21);
  unint64_t v319 = (char *)&v267 - v24;
  uint64_t v25 = MEMORY[0x1F4188790](v23);
  unint64_t v318 = (char *)&v267 - v26;
  uint64_t v27 = MEMORY[0x1F4188790](v25);
  uint64_t v317 = (char *)&v267 - v28;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  uint64_t v316 = (char *)&v267 - v30;
  uint64_t v31 = MEMORY[0x1F4188790](v29);
  char v315 = (char *)&v267 - v32;
  uint64_t v33 = MEMORY[0x1F4188790](v31);
  unint64_t v314 = (char *)&v267 - v34;
  uint64_t v35 = MEMORY[0x1F4188790](v33);
  uint64_t v313 = (char *)&v267 - v36;
  uint64_t v37 = MEMORY[0x1F4188790](v35);
  uint64_t v312 = (char *)&v267 - v38;
  uint64_t v39 = MEMORY[0x1F4188790](v37);
  unint64_t v311 = (char *)&v267 - v40;
  uint64_t v41 = MEMORY[0x1F4188790](v39);
  unint64_t v310 = (char *)&v267 - v42;
  uint64_t v43 = MEMORY[0x1F4188790](v41);
  uint64_t v309 = (char *)&v267 - v44;
  uint64_t v45 = MEMORY[0x1F4188790](v43);
  uint64_t v308 = (char *)&v267 - v46;
  uint64_t v47 = MEMORY[0x1F4188790](v45);
  size_t v307 = (char *)&v267 - v48;
  uint64_t v49 = MEMORY[0x1F4188790](v47);
  uint64_t v306 = (char *)&v267 - v50;
  uint64_t v51 = MEMORY[0x1F4188790](v49);
  uint64_t v305 = (char *)&v267 - v52;
  uint64_t v53 = MEMORY[0x1F4188790](v51);
  uint64_t v304 = (char *)&v267 - v54;
  uint64_t v55 = MEMORY[0x1F4188790](v53);
  unint64_t v303 = (char *)&v267 - v56;
  uint64_t v57 = MEMORY[0x1F4188790](v55);
  uint64_t v302 = (char *)&v267 - v58;
  uint64_t v59 = MEMORY[0x1F4188790](v57);
  uint64_t v301 = (char *)&v267 - v60;
  uint64_t v61 = MEMORY[0x1F4188790](v59);
  uint64_t v300 = (char *)&v267 - v62;
  uint64_t v63 = MEMORY[0x1F4188790](v61);
  unint64_t v299 = (char *)&v267 - v64;
  uint64_t v65 = MEMORY[0x1F4188790](v63);
  uint64_t v298 = (char *)&v267 - v66;
  uint64_t v67 = MEMORY[0x1F4188790](v65);
  uint64_t v297 = (char *)&v267 - v68;
  uint64_t v69 = MEMORY[0x1F4188790](v67);
  uint64_t v296 = (char *)&v267 - v70;
  uint64_t v71 = MEMORY[0x1F4188790](v69);
  unint64_t v295 = (char *)&v267 - v72;
  uint64_t v73 = MEMORY[0x1F4188790](v71);
  uint64_t v294 = (char *)&v267 - v74;
  uint64_t v75 = MEMORY[0x1F4188790](v73);
  uint64_t v293 = (char *)&v267 - v76;
  uint64_t v77 = MEMORY[0x1F4188790](v75);
  uint64_t v292 = (char *)&v267 - v78;
  uint64_t v79 = MEMORY[0x1F4188790](v77);
  v291 = (char *)&v267 - v80;
  uint64_t v81 = MEMORY[0x1F4188790](v79);
  uint64_t v290 = (char *)&v267 - v82;
  uint64_t v83 = MEMORY[0x1F4188790](v81);
  uint64_t v289 = (char *)&v267 - v84;
  uint64_t v85 = MEMORY[0x1F4188790](v83);
  uint64_t v288 = (char *)&v267 - v86;
  uint64_t v87 = MEMORY[0x1F4188790](v85);
  uint64_t v287 = (char *)&v267 - v88;
  uint64_t v89 = MEMORY[0x1F4188790](v87);
  uint64_t v286 = (char *)&v267 - v90;
  uint64_t v91 = MEMORY[0x1F4188790](v89);
  uint64_t v285 = (char *)&v267 - v92;
  uint64_t v93 = MEMORY[0x1F4188790](v91);
  uint64_t v284 = (char *)&v267 - v94;
  uint64_t v95 = MEMORY[0x1F4188790](v93);
  uint64_t v283 = (char *)&v267 - v96;
  uint64_t v97 = MEMORY[0x1F4188790](v95);
  unint64_t v282 = (char *)&v267 - v98;
  uint64_t v99 = MEMORY[0x1F4188790](v97);
  uint64_t v281 = (char *)&v267 - v100;
  uint64_t v101 = MEMORY[0x1F4188790](v99);
  uint64_t v280 = (char *)&v267 - v102;
  uint64_t v103 = MEMORY[0x1F4188790](v101);
  uint64_t v279 = (char *)&v267 - v104;
  uint64_t v105 = MEMORY[0x1F4188790](v103);
  unint64_t v278 = (char *)&v267 - v106;
  uint64_t v107 = MEMORY[0x1F4188790](v105);
  uint64_t v277 = (char *)&v267 - v108;
  uint64_t v109 = MEMORY[0x1F4188790](v107);
  uint64_t v276 = (char *)&v267 - v110;
  uint64_t v111 = MEMORY[0x1F4188790](v109);
  unint64_t v275 = (char *)&v267 - v112;
  uint64_t v113 = MEMORY[0x1F4188790](v111);
  unint64_t v274 = (char *)&v267 - v114;
  uint64_t v115 = MEMORY[0x1F4188790](v113);
  unint64_t v273 = (char *)&v267 - v116;
  uint64_t v117 = MEMORY[0x1F4188790](v115);
  Swift::String v272 = (char *)&v267 - v118;
  uint64_t v119 = MEMORY[0x1F4188790](v117);
  uint64_t v271 = (char *)&v267 - v120;
  uint64_t v121 = MEMORY[0x1F4188790](v119);
  Swift::String v270 = (char *)&v267 - v122;
  uint64_t v123 = MEMORY[0x1F4188790](v121);
  uint64_t v269 = (char *)&v267 - v124;
  uint64_t v125 = MEMORY[0x1F4188790](v123);
  Swift::String v268 = (char *)&v267 - v126;
  uint64_t v127 = MEMORY[0x1F4188790](v125);
  uint64_t v129 = (char *)&v267 - v128;
  MEMORY[0x1F4188790](v127);
  uint64_t v131 = (char *)&v267 - v130;
  v330[0] = specialized static String._createEmpty(withInitialCapacity:)(266);
  v330[1] = v132;
  v133._unint64_t countAndFlagsBits = 0x3C3436444D4953;
  v133._unint64_t object = (void *)0xE700000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v133);
  swift_bridgeObjectRelease(0xE700000000000000);
  DefaultStringInterpolation.appendInterpolation(_:)(v2);
  v134._unint64_t countAndFlagsBits = 10302;
  v134._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v134);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v135 = *(int ***)(a1 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v135, (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v135, (uint64_t)v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v138 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v139 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v138(0, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v131, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v140._unint64_t countAndFlagsBits = 8236;
  v140._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v140);
  swift_bridgeObjectRelease(0xE200000000000000);
  v138(1, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)((uint64_t)v129, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v141._unint64_t countAndFlagsBits = 8236;
  v141._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v141);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v142 = (uint64_t)v268;
  v138(2, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v142, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v143._unint64_t countAndFlagsBits = 8236;
  v143._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v143);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v144 = (uint64_t)v269;
  v138(3, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v144, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v145._unint64_t countAndFlagsBits = 8236;
  v145._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v145);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v146 = (uint64_t)v270;
  v138(4, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v146, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v147._unint64_t countAndFlagsBits = 8236;
  v147._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v147);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v148 = (uint64_t)v271;
  v138(5, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v148, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v149._unint64_t countAndFlagsBits = 8236;
  v149._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v149);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v150 = (uint64_t)v272;
  v138(6, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v150, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v151._unint64_t countAndFlagsBits = 8236;
  v151._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v151);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v152 = (uint64_t)v273;
  v138(7, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v152, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v153._unint64_t countAndFlagsBits = 8236;
  v153._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v153);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v154 = (uint64_t)v274;
  v138(8, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v154, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v155._unint64_t countAndFlagsBits = 8236;
  v155._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v155);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v156 = (uint64_t)v275;
  v138(9, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v156, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v157._unint64_t countAndFlagsBits = 8236;
  v157._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v157);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v158 = (uint64_t)v276;
  v138(10, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v158, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v159._unint64_t countAndFlagsBits = 8236;
  v159._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v159);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v160 = (uint64_t)v277;
  v138(11, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v160, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v161._unint64_t countAndFlagsBits = 8236;
  v161._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v161);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v162 = (uint64_t)v278;
  v138(12, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v162, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v163._unint64_t countAndFlagsBits = 8236;
  v163._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v163);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v164 = (uint64_t)v279;
  v138(13, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v164, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v165._unint64_t countAndFlagsBits = 8236;
  v165._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v165);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v166 = (uint64_t)v280;
  v138(14, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v166, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v167._unint64_t countAndFlagsBits = 8236;
  v167._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v167);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v168 = (uint64_t)v281;
  v138(15, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v168, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v169._unint64_t countAndFlagsBits = 8236;
  v169._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v169);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v170 = (uint64_t)v282;
  v138(16, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v170, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v171._unint64_t countAndFlagsBits = 8236;
  v171._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v171);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v172 = (uint64_t)v283;
  v138(17, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v172, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v173._unint64_t countAndFlagsBits = 8236;
  v173._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v173);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v174 = (uint64_t)v284;
  v138(18, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v174, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v175._unint64_t countAndFlagsBits = 8236;
  v175._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v175);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v176 = (uint64_t)v285;
  v138(19, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v176, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v177._unint64_t countAndFlagsBits = 8236;
  v177._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v177);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v178 = (uint64_t)v286;
  v138(20, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v178, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v179._unint64_t countAndFlagsBits = 8236;
  v179._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v179);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v180 = (uint64_t)v287;
  v138(21, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v180, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v181._unint64_t countAndFlagsBits = 8236;
  v181._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v181);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v182 = (uint64_t)v288;
  v138(22, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v182, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v183._unint64_t countAndFlagsBits = 8236;
  v183._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v183);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v184 = (uint64_t)v289;
  v138(23, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v184, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v185._unint64_t countAndFlagsBits = 8236;
  v185._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v185);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v186 = (uint64_t)v290;
  v138(24, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v186, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v187._unint64_t countAndFlagsBits = 8236;
  v187._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v187);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v188 = (uint64_t)v291;
  v138(25, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v188, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v189._unint64_t countAndFlagsBits = 8236;
  v189._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v189);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v190 = (uint64_t)v292;
  v138(26, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v190, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v191._unint64_t countAndFlagsBits = 8236;
  v191._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v191);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v192 = (uint64_t)v293;
  v138(27, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v192, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v193._unint64_t countAndFlagsBits = 8236;
  v193._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v193);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v194 = (uint64_t)v294;
  v138(28, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v194, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v195._unint64_t countAndFlagsBits = 8236;
  v195._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v195);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v196 = (uint64_t)v295;
  v138(29, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v196, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v197._unint64_t countAndFlagsBits = 8236;
  v197._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v197);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v198 = (uint64_t)v296;
  v138(30, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v198, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v199._unint64_t countAndFlagsBits = 8236;
  v199._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v199);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v200 = (uint64_t)v297;
  v138(31, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v200, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v201._unint64_t countAndFlagsBits = 8236;
  v201._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v201);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v202 = (uint64_t)v298;
  v138(32, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v202, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v203._unint64_t countAndFlagsBits = 8236;
  v203._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v203);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v204 = (uint64_t)v299;
  v138(33, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v204, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v205._unint64_t countAndFlagsBits = 8236;
  v205._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v205);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v206 = (uint64_t)v300;
  v138(34, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v206, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v207._unint64_t countAndFlagsBits = 8236;
  v207._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v207);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v208 = (uint64_t)v301;
  v138(35, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v208, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v209._unint64_t countAndFlagsBits = 8236;
  v209._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v209);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v210 = (uint64_t)v302;
  v138(36, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v210, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v211._unint64_t countAndFlagsBits = 8236;
  v211._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v211);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v212 = (uint64_t)v303;
  v138(37, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v212, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v213._unint64_t countAndFlagsBits = 8236;
  v213._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v213);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v214 = (uint64_t)v304;
  v138(38, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v214, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v215._unint64_t countAndFlagsBits = 8236;
  v215._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v215);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v216 = (uint64_t)v305;
  v138(39, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v216, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v217._unint64_t countAndFlagsBits = 8236;
  v217._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v217);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v218 = (uint64_t)v306;
  v138(40, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v218, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v219._unint64_t countAndFlagsBits = 8236;
  v219._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v219);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v220 = (uint64_t)v307;
  v138(41, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v220, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v221._unint64_t countAndFlagsBits = 8236;
  v221._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v221);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v222 = (uint64_t)v308;
  v138(42, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v222, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v223._unint64_t countAndFlagsBits = 8236;
  v223._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v223);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v224 = (uint64_t)v309;
  v138(43, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v224, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v225._unint64_t countAndFlagsBits = 8236;
  v225._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v225);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v226 = (uint64_t)v310;
  v138(44, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v226, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v227._unint64_t countAndFlagsBits = 8236;
  v227._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v227);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v228 = (uint64_t)v311;
  v138(45, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v228, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v229._unint64_t countAndFlagsBits = 8236;
  v229._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v229);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v230 = (uint64_t)v312;
  v138(46, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v230, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v231._unint64_t countAndFlagsBits = 8236;
  v231._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v231);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v232 = (uint64_t)v313;
  v138(47, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v232, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v233._unint64_t countAndFlagsBits = 8236;
  v233._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v233);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v234 = (uint64_t)v314;
  v138(48, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v234, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v235._unint64_t countAndFlagsBits = 8236;
  v235._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v235);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v236 = (uint64_t)v315;
  v138(49, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v236, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v237._unint64_t countAndFlagsBits = 8236;
  v237._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v237);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v238 = (uint64_t)v316;
  v138(50, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v238, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v239._unint64_t countAndFlagsBits = 8236;
  v239._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v239);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v240 = (uint64_t)v317;
  v138(51, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v240, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v241._unint64_t countAndFlagsBits = 8236;
  v241._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v241);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v242 = (uint64_t)v318;
  v138(52, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v242, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v243._unint64_t countAndFlagsBits = 8236;
  v243._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v243);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v244 = (uint64_t)v319;
  v138(53, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v244, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v245._unint64_t countAndFlagsBits = 8236;
  v245._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v245);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v246 = (uint64_t)v320;
  v138(54, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v246, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v247._unint64_t countAndFlagsBits = 8236;
  v247._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v247);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v248 = (uint64_t)v321;
  v138(55, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v248, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v249._unint64_t countAndFlagsBits = 8236;
  v249._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v249);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v250 = (uint64_t)v322;
  v138(56, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v250, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v251._unint64_t countAndFlagsBits = 8236;
  v251._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v251);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v252 = (uint64_t)v323;
  v138(57, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v252, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v253._unint64_t countAndFlagsBits = 8236;
  v253._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v253);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v254 = (uint64_t)v324;
  v138(58, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v254, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v255._unint64_t countAndFlagsBits = 8236;
  v255._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v255);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v256 = (uint64_t)v325;
  v138(59, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v256, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v257._unint64_t countAndFlagsBits = 8236;
  v257._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v257);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v258 = (uint64_t)v326;
  v138(60, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v258, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v259._unint64_t countAndFlagsBits = 8236;
  v259._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v259);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v260 = (uint64_t)v327;
  v138(61, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v260, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v261._unint64_t countAndFlagsBits = 8236;
  v261._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v261);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v262 = (uint64_t)v328;
  v138(62, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v262, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v263._unint64_t countAndFlagsBits = 8236;
  v263._unint64_t object = (void *)0xE200000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v263);
  swift_bridgeObjectRelease(0xE200000000000000);
  uint64_t v264 = (uint64_t)v329;
  v138(63, v139, AssociatedConformanceWitness);
  _print_unlocked<A, B>(_:_:)(v264, (uint64_t)v330, v2, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
  v265._unint64_t countAndFlagsBits = 41;
  v265._unint64_t object = (void *)0xE100000000000000;
  DefaultStringInterpolation.appendLiteral(_:)(v265);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v330[0];
}

uint64_t SIMD64<>.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v34 = a4;
  uint64_t v35 = a6;
  uint64_t v38 = a1;
  uint64_t v36 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v33 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v32 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v30 = a7;
  uint64_t v31 = v21;
  uint64_t v37 = a3;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v23 = 0;
  uint64_t v24 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  do
  {
    uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v31);
    v24(v23, v25, v22);
    (*(void (**)(char *, uint64_t, void))(*(void *)(v34 + 16) + 72))(v14, v37, *(void *)(v35 + 8));
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v16, v23++, v32, AssociatedConformanceWitness);
  }
  while (v23 != 64);
  uint64_t v27 = type metadata accessor for SIMD64(0, v37, (uint64_t)v30, v26);
  return (*((uint64_t (**)(uint64_t, Class *))*(v27 - 1) + 1))(v38, v27);
}

{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  int **v17;
  const char *AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness;
  void (*v20)(const char *, uint64_t);
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  Class *v27;
  uint64_t v29;
  uint64_t v30;
  int **v31;
  void (*v32)(uint64_t, uint64_t *, uint64_t);
  uint64_t v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;

  uint64_t v37 = a6;
  uint64_t v38 = a8;
  uint64_t v30 = a4;
  uint64_t v40 = a1;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v29 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v17, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v36 = a2;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v20 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v35 = AssociatedTypeWitness;
  v20(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
  uint64_t v31 = a7;
  uint64_t v39 = a3;
  uint64_t v34 = v21;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
  uint64_t v23 = 0;
  uint64_t v32 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v22 + 56);
  uint64_t v33 = v22;
  uint64_t v24 = v30;
  do
  {
    uint64_t v25 = swift_checkMetadataState(0, (uint64_t)v34);
    v32(v23, v25, v33);
    (*(void (**)(char *, uint64_t, uint64_t))(v24 + 80))(v14, v39, v37);
    (*(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64))(v16, v23++, v35, AssociatedConformanceWitness);
  }
  while (v23 != 64);
  uint64_t v27 = type metadata accessor for SIMD64(0, v39, (uint64_t)v31, v26);
  return (*((uint64_t (**)(uint64_t, Class *))*(v27 - 1) + 1))(v40, v27);
}

uint64_t SIMD3._storage.getter@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return LazyFilterSequence.Iterator.base.getter(a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage, a2);
}

uint64_t SIMD3._storage.setter(uint64_t a1, uint64_t a2)
{
  return EnumeratedSequence.Iterator._base.setter(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t EnumeratedSequence.Iterator._base.setter(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), *(void *)(a2 + 16), a3, a4);
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 40);

  return v7(v4, a1, AssociatedTypeWitness);
}

uint64_t (*SIMD3._storage.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t SIMD3.scalarCount.getter()
{
  return 3;
}

uint64_t key path getter for SIMD3.subscript(_:) : <A>SIMD3<A>A(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  if ((unint64_t)*a2 >= 3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x587uLL, 0);
  }
  uint64_t v5 = *(uint64_t *)((char *)a2 + a3 - 16);
  uint64_t v4 = *(int ***)((char *)a2 + a3 - 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v8(v3, v9, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD3.subscript(_:) : <A>SIMD3<A>A(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + a3 - 16);
  uint64_t v5 = *(int ***)(a4 + a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v7 = (char *)&v17 - v6;
  unint64_t v9 = *v8;
  memcpy((char *)&v17 - v6, v10, v11);
  if (v9 >= 3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x58BuLL, 0);
  }
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v14 = *(uint64_t (**)(char *, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v15 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v14(v7, v9, v15, AssociatedConformanceWitness);
}

uint64_t (*SIMD3.subscript.modify(void *a1, unint64_t a2, uint64_t a3))()
{
  uint64_t v7 = malloc(0x40uLL);
  *a1 = v7;
  *uint64_t v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x587uLL, 0);
  }
  uint64_t v10 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

void SIMD2.subscript.modify(uint64_t **a1, char a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (*a1)[6];
  uint64_t v4 = (*a1)[7];
  uint64_t v6 = (void *)(*a1)[4];
  uint64_t v5 = (void *)(*a1)[5];
  uint64_t v7 = (void *)(*a1)[3];
  uint64_t v8 = **a1;
  if (a2) {
    size_t v9 = (void *)(*a1)[3];
  }
  else {
    size_t v9 = (void *)(*a1)[4];
  }
  memcpy(v9, v5, (*a1)[2]);
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(v3 + 64))(v9, v8, v4, v3);
  free(v5);
  free(v6);
  free(v7);

  free(v2);
}

uint64_t SIMD3.init(_:_:_:)(const void *a1, const void *a2, const void *a3, uint64_t a4, int **a5)
{
  size_t v10 = *(void *)(*(void *)(a4 - 8) + 64);
  MEMORY[0x1F4188790](a1);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a5, v11, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a5, a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  (*(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), a1, v10);
  uint64_t v14 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  v14((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), 0, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), a2, v10);
  v14((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), 1, AssociatedTypeWitness, AssociatedConformanceWitness);
  memcpy((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), a3, v10);
  return ((uint64_t (*)(char *, uint64_t, const char *, uint64_t))v14)((char *)&v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), 2, AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t SIMD3.x.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 0);
}

uint64_t SIMD3.x.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 0);
}

void (*SIMD3.x.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  uint64_t v8 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  uint64_t v11 = *(void (**)(void, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v5[5] = v12;
  v11(0, v12, AssociatedConformanceWitness);
  return SIMD2.x.modify;
}

uint64_t SIMD3.y.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 1);
}

uint64_t SIMD3.y.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 1);
}

void (*SIMD3.y.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  uint64_t v8 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  uint64_t v11 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v5[5] = v12;
  v11(1, v12, AssociatedConformanceWitness);
  return SIMD2.y.modify;
}

uint64_t SIMD3.z.getter(uint64_t a1)
{
  return SIMD2.x.getter(a1, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 2);
}

uint64_t SIMD2.x.getter(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v6 = *(int ***)(a1 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a2);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v7, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a3);
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  size_t v10 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v12(a4, v10, AssociatedConformanceWitness);
}

uint64_t key path getter for SIMD2.x : <A>SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5, uint64_t a6)
{
  uint64_t v8 = *(void *)(a3 + a2 - 16);
  size_t v9 = *(int ***)(a3 + a2 - 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v9, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a4);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v9, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a5);
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v13 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v12(a6, v13, AssociatedConformanceWitness);
}

uint64_t key path setter for SIMD2.x : <A>SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, _DWORD *a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a4 + a3 - 16);
  uint64_t v11 = *(int ***)(a4 + a3 - 8);
  MEMORY[0x1F4188790](a1);
  uint64_t v13 = (char *)&v21 - v12;
  memcpy((char *)&v21 - v12, v14, v15);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v11, v10, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a5);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v11, v10, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a6);
  uint64_t v18 = *(uint64_t (**)(char *, uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v19 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v18(v13, a7, v19, AssociatedConformanceWitness);
}

uint64_t SIMD3.z.setter(uint64_t a1, uint64_t a2)
{
  return SIMD2.x.setter(a1, a2, associated type descriptor for SIMDScalar.SIMD4Storage, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage, 2);
}

uint64_t SIMD2.x.setter(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(a2 + 16);
  MEMORY[0x1F4188790](a1);
  uint64_t v11 = (char *)&v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  memcpy(v11, v12, v10);
  uint64_t v13 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v13, v9, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a3);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v13, v9, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a4);
  uint64_t v16 = *(uint64_t (**)(char *, uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v17 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  return v16(v11, a5, v17, AssociatedConformanceWitness);
}

void (*SIMD3.z.modify(void *a1, uint64_t a2))(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = malloc(0x30uLL);
  *a1 = v5;
  *uint64_t v5 = v2;
  uint64_t v6 = *(void *)(a2 + 16);
  size_t v7 = *(void *)(*(void *)(v6 - 8) + 64);
  v5[1] = v7;
  v5[2] = malloc(v7);
  v5[3] = malloc(v7);
  uint64_t v8 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v8, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v8, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v5[4] = AssociatedConformanceWitness;
  uint64_t v11 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v12 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v5[5] = v12;
  v11(2, v12, AssociatedConformanceWitness);
  return SIMD4.z.modify;
}

void SIMD2.x.modify(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void **)a1;
  uint64_t v6 = *(void *)(*(void *)a1 + 32);
  uint64_t v5 = *(void *)(*(void *)a1 + 40);
  uint64_t v8 = *(void **)(*(void *)a1 + 16);
  size_t v7 = *(void **)(*(void *)a1 + 24);
  memcpy(v8, v7, *(void *)(*(void *)a1 + 8));
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(v6 + 64))(v8, a3, v5, v6);
  free(v7);
  free(v8);

  free(v4);
}

Swift::Int SIMD3.hashValue.getter(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return SIMDMask.hashValue.getter(a1, protocol conformance descriptor for SIMD3<A>, a3);
}

Swift::Int SIMDMask.hashValue.getter(unint64_t *a1, int *a2, uint64_t a3)
{
  v6[0] = 0;
  v6[1] = _swift_stdlib_Hashing_parameters ^ 0x736F6D6570736575;
  v6[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v6[3] = _swift_stdlib_Hashing_parameters ^ 0x6C7967656E657261;
  v6[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t WitnessTable = swift_getWitnessTable(a2, a1, a3);
  SIMD.hash(into:)((uint64_t)v6, (uint64_t)a1, WitnessTable);
  return Hasher._finalize()();
}

uint64_t protocol witness for SIMDStorage.scalarCount.getter in conformance SIMD3<A>()
{
  return 3;
}

uint64_t protocol witness for SIMDStorage.init() in conformance SIMD2<A>(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v5 = *(int ***)(a1 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a3);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, a4);
  return (*(uint64_t (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48))(AssociatedTypeWitness, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance SIMD3<A>(unint64_t a1, uint64_t a2)
{
  if (a1 >= 3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x587uLL, 0);
  }
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v3, v4, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v3, v4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v9 = *(uint64_t (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  long long v7 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v9(a1, v7, AssociatedConformanceWitness);
}

uint64_t protocol witness for SIMDStorage.subscript.setter in conformance SIMD3<A>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 >= 3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x58BuLL, 0);
  }
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v5 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v5, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);

  return v11(a1, a2, v9, AssociatedConformanceWitness);
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance SIMD3<A>(void *a1, unint64_t a2, uint64_t a3))()
{
  long long v7 = malloc(0x40uLL);
  *a1 = v7;
  *long long v7 = a2;
  v7[1] = v3;
  uint64_t v8 = *(void *)(a3 + 16);
  size_t v9 = *(void *)(*(void *)(v8 - 8) + 64);
  v7[2] = v9;
  v7[3] = malloc(v9);
  v7[4] = malloc(v9);
  v7[5] = malloc(v9);
  if (a2 >= 3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SIMDVectorTypes.swift", 27, 2, 0x587uLL, 0);
  }
  size_t v10 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v8, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v8, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  v7[6] = AssociatedConformanceWitness;
  uint64_t v13 = *(void (**)(unint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v7[7] = v14;
  v13(a2, v14, AssociatedConformanceWitness);
  return SIMD2.subscript.modify;
}

uint64_t protocol witness for Encodable.encode(to:) in conformance SIMD3<A>(void *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD3<A>, a2, a3);
  return SIMD.encode(to:)(a1, (uint64_t)a2, WitnessTable);
}

uint64_t protocol witness for Decodable.init(from:) in conformance SIMD3<A>@<X0>(uint64_t *a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD3<A>, a2, a3);
  return SIMD.init(from:)(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for Hashable.hash(into:) in conformance SIMD3<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD3<A>, a2, a3);

  return SIMD.hash(into:)(a1, (uint64_t)a2, WitnessTable);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMD3<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(a1, a2, a3, protocol conformance descriptor for SIMD3<A>);
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance SIMDMask<A>(uint64_t a1, unint64_t *a2, uint64_t a3, int *a4)
{
  v7[0] = 0;
  v7[1] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575;
  v7[2] = unk_1EB208F00 ^ 0x646F72616E646F6DLL;
  v7[3] = _swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261;
  v7[4] = unk_1EB208F00 ^ 0x7465646279746573;
  long long v8 = 0u;
  long long v9 = 0u;
  uint64_t WitnessTable = swift_getWitnessTable(a4, a2, a3);
  SIMD.hash(into:)((uint64_t)v7, (uint64_t)a2, WitnessTable);
  return Hasher._finalize()();
}

unint64_t protocol witness for CustomStringConvertible.description.getter in conformance SIMD3<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD3<A>, a1, a3);

  return SIMD.description.getter((uint64_t)a1, WitnessTable);
}

uint64_t protocol witness for ExpressibleByArrayLiteral.init(arrayLiteral:) in conformance SIMD3<A>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for SIMD3<A>, a2, a3);

  return SIMD.init(arrayLiteral:)(a1, (uint64_t)a2, WitnessTable, a4);
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance SIMD3<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v5 = a1;
  uint64_t v43 = *(void *)(a3 + 16);
  uint64_t v6 = MEMORY[0x1F4188790](a1);
  uint64_t v50 = (char *)&v39 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v8 = MEMORY[0x1F4188790](v6);
  uint64_t v49 = (char *)&v39 - v9;
  uint64_t v11 = *(void *)(v10 - 8);
  uint64_t v12 = MEMORY[0x1F4188790](v8);
  uint64_t v14 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v17 = (char *)&v39 - v16;
  uint64_t v18 = 0;
  uint64_t v20 = *(void (**)(char *, uint64_t, uint64_t))(v11 + 16);
  v11 += 16;
  uint64_t v19 = v20;
  uint64_t v46 = (void (**)(char *, uint64_t))(v11 - 8);
  uint64_t v47 = v21;
  char v22 = 1;
  uint64_t v44 = v23;
  uint64_t v41 = v11;
  uint64_t v42 = v15;
  uint64_t v48 = v14;
  uint64_t v40 = v20;
  v20((char *)&v39 - v16, v5, v3);
  while (1)
  {
    v19(v14, a2, v3);
    if (v22)
    {
      uint64_t v25 = *(int ***)(v3 + 24);
      uint64_t v45 = v25;
      uint64_t v26 = v43;
      AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v25, v43, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
      uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v25, v26, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
      uint64_t v29 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
      uint64_t v30 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
      v29(v18, v30, AssociatedConformanceWitness);
      uint64_t v31 = *v46;
      (*v46)(v17, v47);
      uint64_t v32 = AssociatedConformanceWitness;
      uint64_t v19 = v40;
      v29(v18, v30, v32);
      uint64_t v3 = v47;
      uint64_t v14 = v48;
      v31(v48, v47);
      uint64_t v5 = v42;
      uint64_t v33 = v45;
      uint64_t v34 = swift_getAssociatedTypeWitness(255, v45, v26, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
      uint64_t v35 = (uint64_t)v33;
      a2 = v44;
      uint64_t v36 = swift_getAssociatedConformanceWitness(v35, v26, (uint64_t)v34, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
      uint64_t v37 = swift_getAssociatedConformanceWitness(v36, (uint64_t)v34, v26, (uint64_t)&protocol requirements base descriptor for SIMDStorage, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
      char v22 = (*(uint64_t (**)(char *, char *, uint64_t))(*(void *)(v37 + 8) + 8))(v49, v50, v26);
    }
    else
    {
      uint64_t v24 = *v46;
      (*v46)(v14, v3);
      v24(v17, v3);
      char v22 = 0;
    }
    if (++v18 == 3) {
      break;
    }
    v19(v17, v5, v3);
  }
  return v22 & 1;
}

uint64_t SIMD3<>.init<A>(truncatingIfNeeded:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void (*a4)(char *, uint64_t, uint64_t, uint64_t, uint64_t)@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v47 = a6;
  uint64_t v49 = a4;
  uint64_t v52 = a1;
  uint64_t v44 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v41 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v39 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v16, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v19 = *(void (**)(const char *))(AssociatedConformanceWitness + 48);
  uint64_t v43 = AssociatedTypeWitness;
  uint64_t v20 = AssociatedConformanceWitness;
  v19(AssociatedTypeWitness);
  uint64_t v42 = a7;
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v46 = a3;
  uint64_t v50 = v21;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v51 = v22;
  uint64_t v40 = *(void (**)(void, uint64_t *, uint64_t))(v22 + 56);
  uint64_t v23 = v40;
  uint64_t v24 = swift_checkMetadataState(0, (uint64_t)v21);
  uint64_t v25 = v41;
  v23(0, v24, v22);
  uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(*((void *)v49 + 1) + 96);
  uint64_t v48 = *((void *)v49 + 1);
  uint64_t v49 = v26;
  uint64_t v47 = *(void *)(v47 + 8);
  uint64_t v27 = v15;
  ((void (*)(char *, uint64_t))v26)(v25, a3);
  uint64_t v28 = v20;
  uint64_t v39 = v20;
  uint64_t v45 = *(void (**)(char *, uint64_t, const char *, uint64_t))(v20 + 64);
  uint64_t v29 = v43;
  v45(v15, 0, v43, v28);
  uint64_t v30 = swift_checkMetadataState(0, (uint64_t)v50);
  uint64_t v31 = v40;
  v40(1, v30, v51);
  v49(v25, v46, v47, a2, v48);
  uint64_t v32 = v39;
  v45(v27, 1, v29, v39);
  uint64_t v33 = swift_checkMetadataState(0, (uint64_t)v50);
  uint64_t v34 = v52;
  v31(2, v33, v51);
  uint64_t v35 = v46;
  v49(v25, v46, v47, a2, v48);
  v45(v27, 2, v43, v32);
  uint64_t v37 = type metadata accessor for SIMD3(0, v35, (uint64_t)v42, v36);
  return (*((uint64_t (**)(uint64_t, Class *))*(v37 - 1) + 1))(v34, v37);
}

uint64_t SIMD3<>.init<A>(clamping:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void (*a4)(char *, uint64_t, uint64_t, uint64_t, uint64_t)@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v47 = a6;
  uint64_t v49 = a4;
  uint64_t v52 = a1;
  uint64_t v44 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  uint64_t v41 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v39 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v16, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v19 = *(void (**)(const char *))(AssociatedConformanceWitness + 48);
  uint64_t v43 = AssociatedTypeWitness;
  uint64_t v20 = AssociatedConformanceWitness;
  v19(AssociatedTypeWitness);
  uint64_t v42 = a7;
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v46 = a3;
  uint64_t v50 = v21;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v51 = v22;
  uint64_t v40 = *(void (**)(void, uint64_t *, uint64_t))(v22 + 56);
  uint64_t v23 = v40;
  uint64_t v24 = swift_checkMetadataState(0, (uint64_t)v21);
  uint64_t v25 = v41;
  v23(0, v24, v22);
  uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(*((void *)v49 + 1) + 104);
  uint64_t v48 = *((void *)v49 + 1);
  uint64_t v49 = v26;
  uint64_t v47 = *(void *)(v47 + 8);
  uint64_t v27 = v15;
  ((void (*)(char *, uint64_t))v26)(v25, a3);
  uint64_t v28 = v20;
  uint64_t v39 = v20;
  uint64_t v45 = *(void (**)(char *, uint64_t, const char *, uint64_t))(v20 + 64);
  uint64_t v29 = v43;
  v45(v15, 0, v43, v28);
  uint64_t v30 = swift_checkMetadataState(0, (uint64_t)v50);
  uint64_t v31 = v40;
  v40(1, v30, v51);
  v49(v25, v46, v47, a2, v48);
  uint64_t v32 = v39;
  v45(v27, 1, v29, v39);
  uint64_t v33 = swift_checkMetadataState(0, (uint64_t)v50);
  uint64_t v34 = v52;
  v31(2, v33, v51);
  uint64_t v35 = v46;
  v49(v25, v46, v47, a2, v48);
  v45(v27, 2, v43, v32);
  uint64_t v37 = type metadata accessor for SIMD3(0, v35, (uint64_t)v42, v36);
  return (*((uint64_t (**)(uint64_t, Class *))*(v37 - 1) + 1))(v34, v37);
}

uint64_t SIMD3<>.init<A>(_:rounding:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, int **a7@<X7>, uint64_t a8@<X8>)
{
  uint64_t v62 = a1;
  uint64_t v63 = a6;
  uint64_t v54 = a4;
  uint64_t v60 = a2;
  uint64_t v49 = a8;
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  uint64_t v13 = (char *)&v44 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v51 = (char *)&v44 - v15;
  MEMORY[0x1F4188790](v14);
  uint64_t v46 = (char *)&v44 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = v17;
  uint64_t v50 = v17;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v19, v17, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, v18, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v21 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v64 = AssociatedTypeWitness;
  v21(AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v47 = a7;
  uint64_t v22 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v23 = a3;
  uint64_t v57 = v22;
  uint64_t v24 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v22, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v25 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v24 + 56);
  uint64_t v58 = v24;
  uint64_t v59 = v25;
  uint64_t v26 = swift_checkMetadataState(0, (uint64_t)v22);
  uint64_t v48 = v13;
  v25(0, v26, v24);
  uint64_t v27 = v63;
  uint64_t v28 = *(void *)(v63 + 16);
  uint64_t v29 = *(void (**)(uint64_t, uint64_t, uint64_t))(v28 + 304);
  uint64_t v55 = v28 + 304;
  uint64_t v56 = v29;
  uint64_t v30 = v51;
  uint64_t v31 = v60;
  uint64_t v32 = v23;
  uint64_t v45 = v23;
  v29(v60, v23, v28);
  uint64_t v33 = *(void *)(v54 + 8);
  uint64_t v53 = *(void (**)(char *, uint64_t, uint64_t))(v33 + 80);
  uint64_t v54 = v33;
  uint64_t v34 = v46;
  v53(v30, v32, v27);
  uint64_t v52 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  ((void (*)(char *, void, const char *))v52)(v34, 0, v64);
  uint64_t v35 = swift_checkMetadataState(0, (uint64_t)v57);
  v59(1, v35, v58);
  uint64_t v36 = v51;
  uint64_t v37 = v31;
  uint64_t v38 = v45;
  v56(v37, v45, v28);
  uint64_t v39 = v50;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v53)(v36, v38, v63, v50, v54);
  v52(v34, 1, v64, AssociatedConformanceWitness);
  uint64_t v40 = swift_checkMetadataState(0, (uint64_t)v57);
  v59(2, v40, v58);
  v56(v60, v38, v28);
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v53)(v36, v38, v63, v39, v54);
  v52(v34, 2, v64, AssociatedConformanceWitness);
  uint64_t v42 = type metadata accessor for SIMD3(0, v38, (uint64_t)v47, v41);
  return (*((uint64_t (**)(uint64_t, Class *))*(v42 - 1) + 1))(v62, v42);
}

uint64_t SIMD3.debugDescription.getter(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(Class **)(a1 + 16);
  size_t v3 = *((void *)*(v2 - 1) + 8);
  uint64_t v4 = MEMORY[0x1F4188790](a1);
  uint64_t v5 = MEMORY[0x1F4188790](v4);
  unint64_t v363 = (unint64_t *)((char *)&v355 - v6);
  uint64_t v7 = MEMORY[0x1F4188790](v5);
  v367 = (unint64_t *)((char *)&v355 - v8);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  unint64_t v370 = (unint64_t *)((char *)&v355 - v10);
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v355 - v12;
  uint64_t v14 = MEMORY[0x1F4188790](v11);
  uint64_t v359 = (unint64_t *)((char *)&v355 - v15);
  uint64_t v16 = MEMORY[0x1F4188790](v14);
  uint64_t v362 = (unint64_t *)((char *)&v355 - v17);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  unint64_t v366 = (unint64_t *)((char *)&v355 - v19);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  uint64_t v369 = (unint64_t *)((char *)&v355 - v21);
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  v373 = (char *)&v355 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  uint64_t v358 = (unint64_t *)((char *)&v355 - v25);
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  uint64_t v361 = (unint64_t *)((char *)&v355 - v27);
  uint64_t v28 = MEMORY[0x1F4188790](v26);
  uint64_t v365 = (unint64_t *)((char *)&v355 - v29);
  uint64_t v30 = MEMORY[0x1F4188790](v28);
  v368 = (unint64_t *)((char *)&v355 - v31);
  uint64_t v32 = MEMORY[0x1F4188790](v30);
  v374 = (unint64_t *)((char *)&v355 - v33);
  MEMORY[0x1F4188790](v32);
  v372 = (char *)&v355 - v34;
  unint64_t v35 = specialized static String._createEmpty(withInitialCapacity:)(21);
  unint64_t v37 = v35;
  unint64_t v38 = v36;
  unint64_t v381 = v35;
  unint64_t v382 = v36;
  if ((v36 & 0x2000000000000000) != 0) {
    uint64_t v39 = HIBYTE(v36) & 0xF;
  }
  else {
    uint64_t v39 = v35 & 0xFFFFFFFFFFFFLL;
  }
  v371 = v13;
  v360 = (unint64_t *)((char *)&v355 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (!v39 && (v35 & ~v36 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v36);
    unint64_t v381 = 0x3C33444D4953;
    unint64_t v382 = 0xE600000000000000;
    goto LABEL_25;
  }
  if ((v36 & 0x2000000000000000) != 0)
  {
    unint64_t v40 = specialized _SmallString.init(_:appending:)(v35, v36, 0x3C33444D4953uLL, 0xE600000000000000);
    if ((v42 & 1) == 0)
    {
      unint64_t v43 = v40;
      unint64_t v44 = v41;
      swift_bridgeObjectRelease(v38);
      swift_bridgeObjectRelease(0xE600000000000000);
      unint64_t v381 = v43;
      unint64_t v382 = v44;
      goto LABEL_25;
    }
  }
  swift_bridgeObjectRetain_n(0xE600000000000000, 6);
  if ((v38 & 0x1000000000000000) == 0)
  {
    BOOL v45 = __OFADD__(v39, 6);
    int64_t v46 = v39 + 6;
    if (!v45) {
      goto LABEL_11;
    }
LABEL_257:
    __break(1u);
    goto LABEL_258;
  }
  Swift::Int v353 = String.UTF8View._foreignCount()();
  int64_t v46 = v353 + 6;
  if (__OFADD__(v353, 6)) {
    goto LABEL_257;
  }
LABEL_11:
  if ((v37 & ~v38 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v38 & 0xFFFFFFFFFFFFFFFLL))
  {
    int64_t v47 = _StringGuts.nativeUnusedCapacity.getter(v37, v38);
    if (v48)
    {
      unint64_t v354 = 258;
      goto LABEL_262;
    }
    uint64_t v49 = (v38 >> 61) & 1;
    if (v47 < 6) {
      LODWORD(v49) = 1;
    }
    if (v46 <= 15 && v49)
    {
LABEL_18:
      unint64_t v364 = v2;
      uint64_t v50 = v1;
      swift_bridgeObjectRelease_n(0xE600000000000000, 5);
      swift_bridgeObjectRetain(v38);
      unint64_t v51 = _StringGuts._convertedToSmall()(v37, v38);
      unint64_t v53 = v52;
      swift_bridgeObjectRelease(v38);
      v54._rawBits = 1;
      v55._rawBits = 393217;
      v56._rawBits = _StringGuts.validateScalarRange(_:)(v54, v55, 0x3C33444D4953uLL, 0xE600000000000000);
      if (v56._rawBits < 0x10000) {
        v56._rawBits |= 3;
      }
      unint64_t v58 = specialized String.init(_:)(v56, v57, 0x3C33444D4953uLL, 0xE600000000000000);
      unint64_t v60 = v59;
      swift_bridgeObjectRelease(0xE600000000000000);
      unint64_t v61 = _StringGuts._convertedToSmall()(v58, v60);
      unint64_t v63 = v62;
      swift_bridgeObjectRelease(v60);
      unint64_t v64 = specialized _SmallString.init(_:appending:)(v51, v53, v61, v63);
      if ((v66 & 1) == 0)
      {
        unint64_t v67 = v64;
        unint64_t v68 = v65;
        swift_bridgeObjectRelease(v38);
        swift_bridgeObjectRelease(0xE600000000000000);
        unint64_t v381 = v67;
        unint64_t v382 = v68;
        uint64_t v1 = v50;
        uint64_t v2 = v364;
        goto LABEL_25;
      }
      unint64_t v354 = 266;
LABEL_262:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v354, 0);
    }
  }
  else if (v46 <= 15)
  {
    goto LABEL_18;
  }
  _StringGuts.prepareForAppendInPlace(totalCount:otherUTF8Count:)(v46, 6);
  swift_bridgeObjectRelease_n(0xE600000000000000, 6);
  Swift::String v375 = (Swift::String)xmmword_18162B040;
  uint64_t v69 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 6, (uint64_t)&v375, 6);
  _StringGuts.appendInPlace(_:isASCII:)(v69, v70, 1);
  swift_bridgeObjectRelease(0xE600000000000000);
LABEL_25:
  TypeName = (uint8x16_t *)swift_getTypeName(v2, 0);
  if (v72 < 0) {
    goto LABEL_254;
  }
  size_t v73 = v72;
  if (!v72)
  {
    uint64_t countAndFlagsBits = 0;
    unint64_t object = 0xE000000000000000;
LABEL_143:
    uint64_t v122 = v371;
    goto LABEL_144;
  }
  uint64_t v74 = (uint64_t *)TypeName;
  uint64_t v75 = TypeName;
  if ((v72 & 0xFFFFFFFFFFFFFFF0) != 0)
  {
    if (((TypeName->i64[1] | TypeName->i64[0]) & 0x8080808080808080) != 0) {
      goto LABEL_47;
    }
    uint64_t v75 = TypeName + 1;
    while (v75 < (uint8x16_t *)&TypeName->i8[v72 & 0xFFFFFFFFFFFFFFF0])
    {
      uint64_t v76 = v75->i64[0];
      uint64_t v77 = v75->i64[1];
      ++v75;
      if (((v77 | v76) & 0x8080808080808080) != 0) {
        goto LABEL_47;
      }
    }
  }
  if (v75 < (uint8x16_t *)&TypeName->i8[v72 & 0xFFFFFFFFFFFFFFF8])
  {
    if ((v75->i64[0] & 0x8080808080808080) != 0) {
      goto LABEL_47;
    }
    uint64_t v75 = (uint8x16_t *)((char *)v75 + 8);
  }
  if (v75 < (uint8x16_t *)&TypeName->i8[v72 & 0xFFFFFFFFFFFFFFFCLL])
  {
    if ((v75->i32[0] & 0x80808080) != 0) {
      goto LABEL_47;
    }
    uint64_t v75 = (uint8x16_t *)((char *)v75 + 4);
  }
  if (v75 >= (uint8x16_t *)&TypeName->i8[v72 & 0xFFFFFFFFFFFFFFFELL])
  {
LABEL_43:
    if (v75 >= (uint8x16_t *)&TypeName->i8[v72] || (v75->i8[0] & 0x80000000) == 0)
    {
      if (v72 > 15)
      {
        char v80 = 1;
LABEL_106:
        unint64_t object = specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(TypeName->i8, v72, v72, v80 & 1);
        uint64_t countAndFlagsBits = *(void *)(object + 24);
        goto LABEL_143;
      }
LABEL_107:
      unint64_t v118 = v72 - 8;
      unint64_t v119 = 8;
      if (v72 < 8) {
        unint64_t v119 = v72;
      }
      if ((v119 & 0x8000000000000000) == 0)
      {
        if (v119 >= 8)
        {
          if (v119 >= 0x10)
          {
            unint64_t v120 = v119 & 0xFFFFFFFFFFFFFFF0;
            uint16x8_t v146 = vmovl_high_u8(*TypeName);
            int8x16_t v147 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v146.i8);
            uint16x8_t v148 = vmovl_u8(*(uint8x8_t *)TypeName->i8);
            int8x16_t v149 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v148.i8);
            int8x16_t v150 = (int8x16_t)vmovl_high_u16(v146);
            int8x8_t v151 = (int8x8_t)vextq_s8(v150, v150, 8uLL).u64[0];
            int8x16_t v152 = (int8x16_t)vmovl_high_u16(v148);
            int8x8_t v153 = (int8x8_t)vextq_s8(v152, v152, 8uLL).u64[0];
            *(int8x8_t *)v152.i8 = vorr_s8(*(int8x8_t *)v152.i8, *(int8x8_t *)v150.i8);
            v154.i64[0] = v152.u32[0];
            v154.i64[1] = v152.u32[1];
            int8x16_t v155 = (int8x16_t)vshlq_u64(v154, (uint64x2_t)xmmword_18162AD00);
            *(int8x8_t *)v150.i8 = vorr_s8(*(int8x8_t *)v149.i8, *(int8x8_t *)v147.i8);
            v154.i64[0] = v150.u32[0];
            v154.i64[1] = v150.u32[1];
            int8x16_t v156 = vorrq_s8((int8x16_t)vshlq_u64(v154, (uint64x2_t)xmmword_18162ACF0), v155);
            *(int8x8_t *)v150.i8 = vorr_s8(v153, v151);
            v154.i64[0] = v150.u32[0];
            v154.i64[1] = v150.u32[1];
            int8x16_t v157 = (int8x16_t)vshlq_u64(v154, (uint64x2_t)xmmword_18162ACE0);
            *(int8x8_t *)v147.i8 = vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v149, v149, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v147, v147, 8uLL));
            v154.i64[0] = v147.u32[0];
            v154.i64[1] = v147.u32[1];
            int8x16_t v158 = vorrq_s8(v156, vorrq_s8((int8x16_t)vshlq_u64(v154, (uint64x2_t)xmmword_18162ACD0), v157));
            uint64_t countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v158.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v158, v158, 8uLL));
            if (v119 == (v119 & 0xFFFFFFFFFFFFFFF0)) {
              goto LABEL_124;
            }
            unint64_t v121 = 8 * v120;
            if ((v119 & 8) == 0) {
              goto LABEL_122;
            }
          }
          else
          {
            uint64_t countAndFlagsBits = 0;
            unint64_t v121 = 0;
            unint64_t v120 = 0;
          }
          unint64_t v123 = v120;
          int64x2_t v124 = vdupq_n_s64(v121);
          unint64_t v120 = v119 & 0xFFFFFFFFFFFFFFF8;
          unint64_t v121 = 8 * (v119 & 0xFFFFFFFFFFFFFFF8);
          int8x16_t v125 = 0uLL;
          int8x16_t v126 = (int8x16_t)(unint64_t)countAndFlagsBits;
          int64x2_t v127 = vaddq_s64(v124, (int64x2_t)xmmword_18162ACE0);
          int64x2_t v128 = vaddq_s64(v124, (int64x2_t)xmmword_18162AD00);
          int64x2_t v129 = vaddq_s64(v124, (int64x2_t)xmmword_18162ACD0);
          int64x2_t v130 = vaddq_s64(v124, (int64x2_t)xmmword_18162ACF0);
          uint64_t v131 = (uint8x8_t *)&TypeName->i8[v123];
          int8x16_t v132 = (int8x16_t)vdupq_n_s64(0x38uLL);
          unint64_t v133 = v123 - (v119 & 0xFFFFFFFFFFFFFFF8);
          int64x2_t v134 = vdupq_n_s64(0x40uLL);
          int8x16_t v135 = 0uLL;
          int8x16_t v136 = 0uLL;
          do
          {
            uint8x8_t v137 = *v131++;
            uint16x8_t v138 = vmovl_u8(v137);
            uint32x4_t v139 = vmovl_high_u16(v138);
            v140.i64[0] = v139.u32[2];
            v140.i64[1] = v139.u32[3];
            uint64x2_t v141 = v140;
            v140.i64[0] = v139.u32[0];
            v140.i64[1] = v139.u32[1];
            uint64x2_t v142 = v140;
            uint32x4_t v143 = vmovl_u16(*(uint16x4_t *)v138.i8);
            v140.i64[0] = v143.u32[2];
            v140.i64[1] = v143.u32[3];
            uint64x2_t v144 = v140;
            v140.i64[0] = v143.u32[0];
            v140.i64[1] = v143.u32[1];
            int8x16_t v136 = vorrq_s8((int8x16_t)vshlq_u64(v141, (uint64x2_t)vandq_s8((int8x16_t)v127, v132)), v136);
            int8x16_t v135 = vorrq_s8((int8x16_t)vshlq_u64(v142, (uint64x2_t)vandq_s8((int8x16_t)v128, v132)), v135);
            int8x16_t v125 = vorrq_s8((int8x16_t)vshlq_u64(v144, (uint64x2_t)vandq_s8((int8x16_t)v129, v132)), v125);
            int8x16_t v126 = vorrq_s8((int8x16_t)vshlq_u64(v140, (uint64x2_t)vandq_s8((int8x16_t)v130, v132)), v126);
            int64x2_t v128 = vaddq_s64(v128, v134);
            int64x2_t v129 = vaddq_s64(v129, v134);
            int64x2_t v130 = vaddq_s64(v130, v134);
            int64x2_t v127 = vaddq_s64(v127, v134);
            v133 += 8;
          }
          while (v133);
          int8x16_t v145 = vorrq_s8(vorrq_s8(v126, v135), vorrq_s8(v125, v136));
          uint64_t countAndFlagsBits = (uint64_t)vorr_s8(*(int8x8_t *)v145.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v145, v145, 8uLL));
          if (v119 == v120)
          {
LABEL_124:
            if (v72 < 9)
            {
              int8x8_t v163 = 0;
LABEL_140:
              unint64_t v227 = 0xA000000000000000;
              if (((*(void *)&v163 | countAndFlagsBits) & 0x8080808080808080) == 0) {
                unint64_t v227 = 0xE000000000000000;
              }
              unint64_t object = v227 | (v72 << 56) | *(void *)&v163;
              goto LABEL_143;
            }
            if (v118 < 8)
            {
              unint64_t v162 = 0;
              int8x8_t v163 = 0;
              unint64_t v164 = 0;
LABEL_138:
              uint64_t v224 = v72 - v162 - 8;
              Swift::String v225 = &TypeName->u8[v162 + 8];
              do
              {
                unsigned int v226 = *v225++;
                *(void *)&v163 |= (unint64_t)v226 << (v164 & 0x38);
                v164 += 8;
                --v224;
              }
              while (v224);
              goto LABEL_140;
            }
            if (v118 >= 0x10)
            {
              uint64_t v188 = (uint8x16_t *)&TypeName->u64[1];
              unint64_t v162 = v118 & 0xFFFFFFFFFFFFFFF0;
              int64x2_t v189 = (int64x2_t)xmmword_18162AD80;
              int64x2_t v190 = (int64x2_t)xmmword_18162AD90;
              int64x2_t v191 = (int64x2_t)xmmword_18162ADA0;
              int64x2_t v192 = (int64x2_t)xmmword_18162ADB0;
              int64x2_t v193 = (int64x2_t)xmmword_18162ACE0;
              int64x2_t v194 = (int64x2_t)xmmword_18162AD00;
              int8x16_t v195 = (int8x16_t)vdupq_n_s64(0x38uLL);
              int64x2_t v196 = vdupq_n_s64(0x80uLL);
              int64x2_t v197 = (int64x2_t)xmmword_18162ACD0;
              unint64_t v164 = 8 * (v118 & 0xFFFFFFFFFFFFFFF0);
              int8x16_t v198 = 0uLL;
              int8x16_t v199 = 0uLL;
              int64x2_t v200 = (int64x2_t)xmmword_18162ACF0;
              unint64_t v201 = v118 & 0xFFFFFFFFFFFFFFF0;
              int8x16_t v202 = 0uLL;
              int8x16_t v203 = 0uLL;
              int8x16_t v204 = 0uLL;
              int8x16_t v205 = 0uLL;
              int8x16_t v206 = 0uLL;
              int8x16_t v207 = 0uLL;
              do
              {
                uint8x16_t v208 = *v188++;
                uint16x8_t v209 = vmovl_u8(*(uint8x8_t *)v208.i8);
                uint32x4_t v210 = vmovl_high_u16(v209);
                v211.i64[0] = v210.u32[2];
                v211.i64[1] = v210.u32[3];
                uint64x2_t v212 = v211;
                uint16x8_t v213 = vmovl_high_u8(v208);
                uint32x4_t v214 = vmovl_u16(*(uint16x4_t *)v213.i8);
                v211.i64[0] = v214.u32[2];
                v211.i64[1] = v214.u32[3];
                uint64x2_t v215 = v211;
                v211.i64[0] = v214.u32[0];
                v211.i64[1] = v214.u32[1];
                uint64x2_t v216 = v211;
                v211.i64[0] = v210.u32[0];
                v211.i64[1] = v210.u32[1];
                uint64x2_t v217 = v211;
                uint32x4_t v218 = vmovl_u16(*(uint16x4_t *)v209.i8);
                v211.i64[0] = v218.u32[2];
                v211.i64[1] = v218.u32[3];
                uint64x2_t v219 = v211;
                uint32x4_t v220 = vmovl_high_u16(v213);
                v211.i64[0] = v220.u32[0];
                v211.i64[1] = v220.u32[1];
                uint64x2_t v221 = v211;
                v211.i64[0] = v218.u32[0];
                v211.i64[1] = v218.u32[1];
                uint64x2_t v222 = v211;
                v211.i64[0] = v220.u32[2];
                v211.i64[1] = v220.u32[3];
                int8x16_t v203 = vorrq_s8((int8x16_t)vshlq_u64(v212, (uint64x2_t)vandq_s8((int8x16_t)v193, v195)), v203);
                int8x16_t v205 = vorrq_s8((int8x16_t)vshlq_u64(v215, (uint64x2_t)vandq_s8((int8x16_t)v191, v195)), v205);
                int8x16_t v204 = vorrq_s8((int8x16_t)vshlq_u64(v216, (uint64x2_t)vandq_s8((int8x16_t)v192, v195)), v204);
                int8x16_t v202 = vorrq_s8((int8x16_t)vshlq_u64(v217, (uint64x2_t)vandq_s8((int8x16_t)v194, v195)), v202);
                int8x16_t v199 = vorrq_s8((int8x16_t)vshlq_u64(v219, (uint64x2_t)vandq_s8((int8x16_t)v197, v195)), v199);
                int8x16_t v206 = vorrq_s8((int8x16_t)vshlq_u64(v221, (uint64x2_t)vandq_s8((int8x16_t)v190, v195)), v206);
                int8x16_t v198 = vorrq_s8((int8x16_t)vshlq_u64(v222, (uint64x2_t)vandq_s8((int8x16_t)v200, v195)), v198);
                int8x16_t v207 = vorrq_s8((int8x16_t)vshlq_u64(v211, (uint64x2_t)vandq_s8((int8x16_t)v189, v195)), v207);
                int64x2_t v194 = vaddq_s64(v194, v196);
                int64x2_t v197 = vaddq_s64(v197, v196);
                int64x2_t v200 = vaddq_s64(v200, v196);
                int64x2_t v193 = vaddq_s64(v193, v196);
                int64x2_t v192 = vaddq_s64(v192, v196);
                int64x2_t v191 = vaddq_s64(v191, v196);
                int64x2_t v190 = vaddq_s64(v190, v196);
                int64x2_t v189 = vaddq_s64(v189, v196);
                v201 -= 16;
              }
              while (v201);
              int8x16_t v223 = vorrq_s8(vorrq_s8(vorrq_s8(v198, v204), vorrq_s8(v202, v206)), vorrq_s8(vorrq_s8(v199, v205), vorrq_s8(v203, v207)));
              int8x8_t v163 = vorr_s8(*(int8x8_t *)v223.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v223, v223, 8uLL));
              if (v118 == v162) {
                goto LABEL_140;
              }
              if ((v118 & 8) == 0) {
                goto LABEL_138;
              }
            }
            else
            {
              int8x8_t v163 = 0;
              unint64_t v164 = 0;
              unint64_t v162 = 0;
            }
            unint64_t v165 = v162;
            unint64_t v162 = v118 & 0xFFFFFFFFFFFFFFF8;
            int64x2_t v166 = vdupq_n_s64(v164);
            unint64_t v164 = 8 * (v118 & 0xFFFFFFFFFFFFFFF8);
            int8x16_t v167 = (int8x16_t)(unint64_t)v163;
            int8x16_t v168 = 0uLL;
            int64x2_t v169 = vaddq_s64(v166, (int64x2_t)xmmword_18162ACE0);
            int64x2_t v170 = vaddq_s64(v166, (int64x2_t)xmmword_18162AD00);
            int64x2_t v171 = vaddq_s64(v166, (int64x2_t)xmmword_18162ACD0);
            int64x2_t v172 = vaddq_s64(v166, (int64x2_t)xmmword_18162ACF0);
            Swift::String v173 = (uint8x8_t *)((char *)&TypeName->u64[1] + v165);
            int8x16_t v174 = (int8x16_t)vdupq_n_s64(0x38uLL);
            unint64_t v175 = v165 - (v118 & 0xFFFFFFFFFFFFFFF8);
            int64x2_t v176 = vdupq_n_s64(0x40uLL);
            int8x16_t v177 = 0uLL;
            int8x16_t v178 = 0uLL;
            do
            {
              uint8x8_t v179 = *v173++;
              uint16x8_t v180 = vmovl_u8(v179);
              uint32x4_t v181 = vmovl_high_u16(v180);
              v182.i64[0] = v181.u32[2];
              v182.i64[1] = v181.u32[3];
              uint64x2_t v183 = v182;
              v182.i64[0] = v181.u32[0];
              v182.i64[1] = v181.u32[1];
              uint64x2_t v184 = v182;
              uint32x4_t v185 = vmovl_u16(*(uint16x4_t *)v180.i8);
              v182.i64[0] = v185.u32[2];
              v182.i64[1] = v185.u32[3];
              uint64x2_t v186 = v182;
              v182.i64[0] = v185.u32[0];
              v182.i64[1] = v185.u32[1];
              int8x16_t v178 = vorrq_s8((int8x16_t)vshlq_u64(v183, (uint64x2_t)vandq_s8((int8x16_t)v169, v174)), v178);
              int8x16_t v177 = vorrq_s8((int8x16_t)vshlq_u64(v184, (uint64x2_t)vandq_s8((int8x16_t)v170, v174)), v177);
              int8x16_t v168 = vorrq_s8((int8x16_t)vshlq_u64(v186, (uint64x2_t)vandq_s8((int8x16_t)v171, v174)), v168);
              int8x16_t v167 = vorrq_s8((int8x16_t)vshlq_u64(v182, (uint64x2_t)vandq_s8((int8x16_t)v172, v174)), v167);
              int64x2_t v170 = vaddq_s64(v170, v176);
              int64x2_t v171 = vaddq_s64(v171, v176);
              int64x2_t v172 = vaddq_s64(v172, v176);
              int64x2_t v169 = vaddq_s64(v169, v176);
              v175 += 8;
            }
            while (v175);
            int8x16_t v187 = vorrq_s8(vorrq_s8(v167, v177), vorrq_s8(v168, v178));
            int8x8_t v163 = vorr_s8(*(int8x8_t *)v187.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v187, v187, 8uLL));
            if (v118 == v162) {
              goto LABEL_140;
            }
            goto LABEL_138;
          }
        }
        else
        {
          unint64_t v120 = 0;
          uint64_t countAndFlagsBits = 0;
          unint64_t v121 = 0;
        }
LABEL_122:
        Swift::String v159 = &TypeName->u8[v120];
        unint64_t v160 = v119 - v120;
        do
        {
          unsigned int v161 = *v159++;
          countAndFlagsBits |= (unint64_t)v161 << (v121 & 0x38);
          v121 += 8;
          --v160;
        }
        while (v160);
        goto LABEL_124;
      }
LABEL_259:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    goto LABEL_47;
  }
  if ((v75->i16[0] & 0x8080) == 0)
  {
    uint64_t v75 = (uint8x16_t *)((char *)v75 + 2);
    goto LABEL_43;
  }
LABEL_47:
  uint64_t v81 = 0;
  uint64_t v82 = &TypeName->u8[v72];
  char v80 = 1;
  for (i = TypeName; ; i = (uint8x16_t *)((char *)i + 3))
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          if (!i || v82 == (unsigned __int8 *)i)
          {
            if (v72 > 15) {
              goto LABEL_106;
            }
            goto LABEL_107;
          }
          unsigned int v85 = i->u8[0];
          i = (uint8x16_t *)((char *)i + 1);
          unsigned int v84 = v85;
          if ((v84 & 0x80) != 0) {
            break;
          }
          ++v81;
        }
        if ((v84 + 62) > 0x32u) {
          goto LABEL_96;
        }
        if (v84 > 0xDF) {
          break;
        }
        if (!i || v82 == (unsigned __int8 *)i || (i->i8[0] & 0xC0) != 0x80) {
          goto LABEL_96;
        }
        char v80 = 0;
        i = (uint8x16_t *)((char *)i + 1);
        v81 += 2;
      }
      if (v84 != 224) {
        break;
      }
      if (!i) {
        goto LABEL_96;
      }
      if (v82 == (unsigned __int8 *)i) {
        goto LABEL_96;
      }
      uint64_t v86 = &i->u8[1];
      if ((i->i8[0] & 0xE0) != 0xA0) {
        goto LABEL_96;
      }
LABEL_74:
      if (v86 == v82 || (*v86 & 0xC0) != 0x80) {
        goto LABEL_96;
      }
      char v80 = 0;
      i = (uint8x16_t *)((char *)i + 2);
      v81 += 3;
    }
    if (v84 <= 0xEC)
    {
LABEL_66:
      if (!i || v82 == (unsigned __int8 *)i) {
        goto LABEL_96;
      }
      uint64_t v86 = &i->u8[1];
      LOBYTE(v87) = i->i8[0];
LABEL_73:
      if ((v87 & 0xC0) != 0x80) {
        goto LABEL_96;
      }
      goto LABEL_74;
    }
    if (v84 == 237)
    {
      if (!i) {
        goto LABEL_96;
      }
      if (v82 == (unsigned __int8 *)i) {
        goto LABEL_96;
      }
      uint64_t v86 = &i->u8[1];
      unsigned int v87 = i->u8[0];
      if (v87 > 0x9F) {
        goto LABEL_96;
      }
      goto LABEL_73;
    }
    if (v84 <= 0xEF) {
      goto LABEL_66;
    }
    if (v84 != 240) {
      break;
    }
    if (!i) {
      goto LABEL_96;
    }
    if (v82 == (unsigned __int8 *)i) {
      goto LABEL_96;
    }
    uint64_t v88 = &i->u8[1];
    if ((i->i8[0] + 64) < 0xD0u) {
      goto LABEL_96;
    }
LABEL_91:
    if (v88 == v82 || (i->i8[1] & 0xC0) != 0x80 || &i->i16[1] == (__int16 *)v82 || (i->i8[2] & 0xC0) != 0x80) {
      goto LABEL_96;
    }
    char v80 = 0;
    v81 += 4;
  }
  if ((v84 + 15) <= 2u)
  {
    if (!i || v82 == (unsigned __int8 *)i) {
      goto LABEL_96;
    }
    uint64_t v88 = &i->u8[1];
    LOBYTE(v89) = i->i8[0];
    goto LABEL_90;
  }
  if (i)
  {
    if (v82 != (unsigned __int8 *)i)
    {
      uint64_t v88 = &i->u8[1];
      unsigned int v89 = i->u8[0];
      if (v89 <= 0x8F)
      {
LABEL_90:
        if ((v89 & 0xC0) != 0x80) {
          goto LABEL_96;
        }
        goto LABEL_91;
      }
    }
  }
LABEL_96:
  uint64_t v90 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v90);
  uint64_t v91 = specialized Collection.subscript.getter(v81, (uint64_t)v74, v73);
  uint64_t v96 = findInvalidRange #1 (_:) in validateUTF8(_:)(v91, v92, v93, v94);
  v375._uint64_t countAndFlagsBits = 0;
  v375._unint64_t object = (void *)0xE000000000000000;
  if (__OFADD__(v73, 15))
  {
LABEL_258:
    __break(1u);
    goto LABEL_259;
  }
  uint64_t v97 = v95;
  uint64_t v356 = v1;
  size_t v357 = v3;
  unint64_t v364 = v2;
  _StringGuts.reserveCapacity(_:)(v73 + 15);
  while (1)
  {
    uint64_t v98 = specialized Collection.subscript.getter(v96, (uint64_t)v74, v73);
    unint64_t v102 = v375._countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    if (((uint64_t)v375._object & 0x2000000000000000) != 0) {
      unint64_t v102 = ((unint64_t)v375._object >> 56) & 0xF;
    }
    BOOL v45 = __OFADD__(v102, v73);
    unint64_t v103 = v102 + v73;
    if (v45)
    {
      __break(1u);
LABEL_253:
      __break(1u);
LABEL_254:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    uint64_t v104 = v98;
    if (__OFADD__(v103, 3)) {
      goto LABEL_253;
    }
    uint64_t v105 = v99;
    uint64_t v106 = v100;
    uint64_t v107 = v101;
    _StringGuts.reserveCapacity(_:)(v103 + 3);
    uint64_t v108 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(v104, v105, v106, v107);
    _StringGuts.appendInPlace(_:isASCII:)(v108, v109, 0);
    size_t v383 = 3;
    *(void *)&long long v378 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v378, &v383, &v375);
    uint64_t v110 = specialized Collection.subscript.getter(v97, (uint64_t)v74, v73);
    uint64_t v74 = (uint64_t *)specialized UnsafeBufferPointer.init(rebasing:)(v110, v111, v112, v113);
    size_t v73 = v114;
    uint64_t v115 = validateUTF8(_:)(v74, v114);
    if ((v117 & 1) == 0) {
      break;
    }
    uint64_t v96 = v115;
    uint64_t v97 = v116;
    if (!v73) {
      goto LABEL_113;
    }
  }
  _StringGuts.appendInPlace(_:isASCII:)((char *)v74, v73, 0);
LABEL_113:
  unint64_t object = (unint64_t)v375._object;
  uint64_t countAndFlagsBits = v375._countAndFlagsBits;
  uint64_t v2 = v364;
  size_t v3 = v357;
  uint64_t v122 = v371;
  uint64_t v1 = v356;
LABEL_144:
  uint64_t v228 = v382;
  unint64_t v229 = HIBYTE(v382) & 0xF;
  if ((v382 & 0x2000000000000000) == 0) {
    unint64_t v229 = v381 & 0xFFFFFFFFFFFFLL;
  }
  if (!v229 && (v381 & ~v382 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v382);
    unint64_t v381 = countAndFlagsBits;
    unint64_t v382 = object;
    goto LABEL_157;
  }
  if ((v382 & 0x2000000000000000) != 0)
  {
    if ((object & 0x2000000000000000) != 0)
    {
      unint64_t v231 = specialized _SmallString.init(_:appending:)(v381, v382, countAndFlagsBits, object);
      if (v233) {
        goto LABEL_155;
      }
      unint64_t v234 = v231;
      unint64_t v235 = v232;
      swift_bridgeObjectRelease(v228);
      swift_bridgeObjectRelease(object);
      unint64_t v381 = v234;
      unint64_t v382 = v235;
      unint64_t object = v235;
      uint64_t countAndFlagsBits = v234;
      goto LABEL_157;
    }
LABEL_152:
    uint64_t v230 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
    goto LABEL_156;
  }
  if ((object & 0x2000000000000000) == 0) {
    goto LABEL_152;
  }
LABEL_155:
  uint64_t v230 = HIBYTE(object) & 0xF;
LABEL_156:
  swift_bridgeObjectRetain(object);
  _StringGuts.append(_:)(countAndFlagsBits, object, 0, v230);
  swift_bridgeObjectRelease_n(object, 2);
  uint64_t countAndFlagsBits = v381;
  unint64_t object = v382;
LABEL_157:
  uint64_t v236 = HIBYTE(object) & 0xF;
  if ((object & 0x2000000000000000) == 0) {
    uint64_t v236 = countAndFlagsBits & 0xFFFFFFFFFFFFLL;
  }
  if (v236 || (countAndFlagsBits & ~object & 0x2000000000000000) != 0)
  {
    if ((object & 0x2000000000000000) == 0
      || (unint64_t v237 = specialized _SmallString.init(_:appending:)(countAndFlagsBits, object, 0x283EuLL, 0xE200000000000000),
          (v239 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000);
      _StringGuts.append(_:)(10302, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      unint64_t v240 = v237;
      unint64_t v241 = v238;
      swift_bridgeObjectRelease(object);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v381 = v240;
      unint64_t v382 = v241;
    }
  }
  else
  {
    swift_bridgeObjectRelease(object);
    unint64_t v381 = 10302;
    unint64_t v382 = 0xE200000000000000;
  }
  uint64_t v242 = *(int ***)(v1 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v242, (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v242, (uint64_t)v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  Swift::String v245 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v246 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  Swift::String v247 = v372;
  v245(0, v246, AssociatedConformanceWitness);
  uint64_t v376 = (uint64_t *)v2;
  uint64_t v248 = __swift_allocate_boxed_opaque_existential_0Tm(&v375);
  memcpy(v248, v247, v3);
  Swift::String v249 = v376;
  uint64_t v250 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v375, (uint64_t)v376);
  DynamicType = (void *)swift_getDynamicType(v250, v249, 1);
  LODWORD(v249) = swift_isOptionalType(DynamicType);
  __swift_destroy_boxed_opaque_existential_1Tm(&v375._countAndFlagsBits);
  if (v249)
  {
    uint64_t v252 = v374;
    memcpy(v374, v247, v3);
    Swift::String v253 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v375, v252, v2, v253, 7uLL);
    goto LABEL_167;
  }
  Swift::String v261 = v368;
  memcpy(v368, v247, v3);
  if (swift_dynamicCast((char *)&v375, v261, v2, (const char *)&type metadata for String, 6uLL))
  {
    uint64_t v262 = v375._object;
    String.append(_:)(v375);
    swift_bridgeObjectRelease((uint64_t)v262);
    goto LABEL_176;
  }
  unint64_t v314 = v365;
  memcpy(v365, v247, v3);
  char v315 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v378, v314, v2, v315, 6uLL))
  {
    outlined init with take of MirrorPath(&v378, (uint64_t)&v375);
    uint64_t v316 = (uint64_t)v376;
    uint64_t v317 = v377;
    __swift_project_boxed_opaque_existential_0Tm(&v375, (uint64_t)v376);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v317 + 8))(&v381, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v316, v317);
LABEL_173:
    __swift_destroy_boxed_opaque_existential_1Tm(&v375._countAndFlagsBits);
    goto LABEL_176;
  }
  uint64_t v380 = 0;
  long long v378 = 0u;
  long long v379 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v378, &demangling cache variable for type metadata for TextOutputStreamable?);
  v326 = v361;
  memcpy(v361, v247, v3);
  uint64_t v327 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v378, v326, v2, v327, 6uLL))
  {
    outlined init with take of MirrorPath(&v378, (uint64_t)&v375);
    uint64_t v328 = (uint64_t)v376;
    uint64_t v329 = v377;
    __swift_project_boxed_opaque_existential_0Tm(&v375, (uint64_t)v376);
    unint64_t v256 = (*(uint64_t (**)(uint64_t, uint64_t))(v329 + 8))(v328, v329);
LABEL_168:
    unint64_t v258 = v256;
    uint64_t v259 = v257;
    unint64_t v260 = HIBYTE(v382) & 0xF;
    if ((v382 & 0x2000000000000000) == 0) {
      unint64_t v260 = v381 & 0xFFFFFFFFFFFFLL;
    }
    if (v260 || (v381 & ~v382 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v256, v257);
      swift_bridgeObjectRelease(v259);
    }
    else
    {
      swift_bridgeObjectRelease(v382);
      unint64_t v381 = v258;
      unint64_t v382 = v259;
    }
    goto LABEL_173;
  }
  uint64_t v380 = 0;
  long long v378 = 0u;
  long long v379 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v378, &demangling cache variable for type metadata for CustomStringConvertible?);
  uint64_t v338 = v358;
  memcpy(v358, v247, v3);
  uint64_t v339 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  if (swift_dynamicCast((char *)&v378, v338, v2, v339, 6uLL))
  {
    outlined init with take of MirrorPath(&v378, (uint64_t)&v375);
LABEL_167:
    uint64_t v254 = (uint64_t)v376;
    uint64_t v255 = v377;
    __swift_project_boxed_opaque_existential_0Tm(&v375, (uint64_t)v376);
    unint64_t v256 = (*(uint64_t (**)(uint64_t, uint64_t))(v255 + 8))(v254, v255);
    goto LABEL_168;
  }
  uint64_t v380 = 0;
  long long v378 = 0u;
  long long v379 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v378, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((void *)&v379 + 1) = v2;
  uint64_t v344 = __swift_allocate_boxed_opaque_existential_0Tm(&v378);
  memcpy(v344, v247, v3);
  Mirror.init(reflecting:)((uint64_t *)&v378, (uint64_t)&v375);
  v345 = v375._object;
  uint64_t v346 = v377;
  ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v247, &v375, &v381, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
  swift_release(v346);
  swift_release((uint64_t)v345);
LABEL_176:
  uint64_t v263 = v382;
  unint64_t v264 = HIBYTE(v382) & 0xF;
  if ((v382 & 0x2000000000000000) == 0) {
    unint64_t v264 = v381 & 0xFFFFFFFFFFFFLL;
  }
  if (v264 || (v381 & ~v382 & 0x2000000000000000) != 0)
  {
    if ((v382 & 0x2000000000000000) == 0
      || (unint64_t v265 = specialized _SmallString.init(_:appending:)(v381, v382, 0x202CuLL, 0xE200000000000000),
          (v267 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000);
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      unint64_t v268 = v265;
      unint64_t v269 = v266;
      swift_bridgeObjectRelease(v263);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v381 = v268;
      unint64_t v382 = v269;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v382);
    unint64_t v381 = 8236;
    unint64_t v382 = 0xE200000000000000;
  }
  Swift::String v270 = v373;
  v245(1, v246, AssociatedConformanceWitness);
  uint64_t v376 = (uint64_t *)v2;
  uint64_t v271 = __swift_allocate_boxed_opaque_existential_0Tm(&v375);
  memcpy(v271, v270, v3);
  Swift::String v272 = v376;
  unint64_t v273 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v375, (uint64_t)v376);
  unint64_t v274 = (void *)swift_getDynamicType(v273, v272, 1);
  LODWORD(v272) = swift_isOptionalType(v274);
  __swift_destroy_boxed_opaque_existential_1Tm(&v375._countAndFlagsBits);
  if (v272)
  {
    unint64_t v275 = v374;
    memcpy(v374, v270, v3);
    uint64_t v276 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v375, v275, v2, v276, 7uLL);
    goto LABEL_186;
  }
  uint64_t v284 = v369;
  memcpy(v369, v270, v3);
  if (swift_dynamicCast((char *)&v375, v284, v2, (const char *)&type metadata for String, 6uLL))
  {
    uint64_t v285 = v375._object;
    String.append(_:)(v375);
    swift_bridgeObjectRelease((uint64_t)v285);
    goto LABEL_195;
  }
  unint64_t v318 = v366;
  memcpy(v366, v270, v3);
  unint64_t v319 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v378, v318, v2, v319, 6uLL))
  {
    outlined init with take of MirrorPath(&v378, (uint64_t)&v375);
    uint64_t v320 = (uint64_t)v376;
    uint64_t v321 = v377;
    __swift_project_boxed_opaque_existential_0Tm(&v375, (uint64_t)v376);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v321 + 8))(&v381, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v320, v321);
LABEL_192:
    __swift_destroy_boxed_opaque_existential_1Tm(&v375._countAndFlagsBits);
    goto LABEL_195;
  }
  uint64_t v380 = 0;
  long long v378 = 0u;
  long long v379 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v378, &demangling cache variable for type metadata for TextOutputStreamable?);
  uint64_t v330 = v362;
  memcpy(v362, v270, v3);
  uint64_t v331 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v378, v330, v2, v331, 6uLL))
  {
    outlined init with take of MirrorPath(&v378, (uint64_t)&v375);
    uint64_t v332 = (uint64_t)v376;
    uint64_t v333 = v377;
    __swift_project_boxed_opaque_existential_0Tm(&v375, (uint64_t)v376);
    unint64_t v279 = (*(uint64_t (**)(uint64_t, uint64_t))(v333 + 8))(v332, v333);
LABEL_187:
    unint64_t v281 = v279;
    uint64_t v282 = v280;
    unint64_t v283 = HIBYTE(v382) & 0xF;
    if ((v382 & 0x2000000000000000) == 0) {
      unint64_t v283 = v381 & 0xFFFFFFFFFFFFLL;
    }
    if (v283 || (v381 & ~v382 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v279, v280);
      swift_bridgeObjectRelease(v282);
    }
    else
    {
      swift_bridgeObjectRelease(v382);
      unint64_t v381 = v281;
      unint64_t v382 = v282;
    }
    goto LABEL_192;
  }
  uint64_t v380 = 0;
  long long v378 = 0u;
  long long v379 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v378, &demangling cache variable for type metadata for CustomStringConvertible?);
  uint64_t v340 = v359;
  memcpy(v359, v270, v3);
  v341 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  if (swift_dynamicCast((char *)&v378, v340, v2, v341, 6uLL))
  {
    outlined init with take of MirrorPath(&v378, (uint64_t)&v375);
LABEL_186:
    uint64_t v277 = (uint64_t)v376;
    uint64_t v278 = v377;
    __swift_project_boxed_opaque_existential_0Tm(&v375, (uint64_t)v376);
    unint64_t v279 = (*(uint64_t (**)(uint64_t, uint64_t))(v278 + 8))(v277, v278);
    goto LABEL_187;
  }
  uint64_t v380 = 0;
  long long v378 = 0u;
  long long v379 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v378, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((void *)&v379 + 1) = v2;
  uint64_t v347 = __swift_allocate_boxed_opaque_existential_0Tm(&v378);
  memcpy(v347, v270, v3);
  Mirror.init(reflecting:)((uint64_t *)&v378, (uint64_t)&v375);
  uint64_t v348 = v375._object;
  uint64_t v349 = v377;
  ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v270, &v375, &v381, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
  swift_release(v349);
  swift_release((uint64_t)v348);
LABEL_195:
  uint64_t v286 = v382;
  unint64_t v287 = HIBYTE(v382) & 0xF;
  if ((v382 & 0x2000000000000000) == 0) {
    unint64_t v287 = v381 & 0xFFFFFFFFFFFFLL;
  }
  if (v287 || (v381 & ~v382 & 0x2000000000000000) != 0)
  {
    if ((v382 & 0x2000000000000000) == 0
      || (unint64_t v288 = specialized _SmallString.init(_:appending:)(v381, v382, 0x202CuLL, 0xE200000000000000),
          (v290 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE200000000000000);
      _StringGuts.append(_:)(8236, 0xE200000000000000, 0, 2);
      swift_bridgeObjectRelease_n(0xE200000000000000, 2);
    }
    else
    {
      unint64_t v291 = v288;
      unint64_t v292 = v289;
      swift_bridgeObjectRelease(v286);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v381 = v291;
      unint64_t v382 = v292;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v382);
    unint64_t v381 = 8236;
    unint64_t v382 = 0xE200000000000000;
  }
  v245(2, v246, AssociatedConformanceWitness);
  uint64_t v376 = (uint64_t *)v2;
  uint64_t v293 = __swift_allocate_boxed_opaque_existential_0Tm(&v375);
  memcpy(v293, v122, v3);
  uint64_t v294 = v376;
  unint64_t v295 = (swift::SwiftError **)__swift_project_boxed_opaque_existential_0Tm(&v375, (uint64_t)v376);
  uint64_t v296 = (void *)swift_getDynamicType(v295, v294, 1);
  LODWORD(v294) = swift_isOptionalType(v296);
  __swift_destroy_boxed_opaque_existential_1Tm(&v375._countAndFlagsBits);
  if (v294)
  {
    uint64_t v297 = v374;
    memcpy(v374, v122, v3);
    uint64_t v298 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
    swift_dynamicCast((char *)&v375, v297, v2, v298, 7uLL);
    goto LABEL_205;
  }
  uint64_t v306 = v370;
  memcpy(v370, v122, v3);
  if (swift_dynamicCast((char *)&v375, v306, v2, (const char *)&type metadata for String, 6uLL))
  {
    size_t v307 = v375._object;
    String.append(_:)(v375);
    swift_bridgeObjectRelease((uint64_t)v307);
    goto LABEL_214;
  }
  v322 = v367;
  memcpy(v367, v122, v3);
  v323 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for TextOutputStreamable);
  if (swift_dynamicCast((char *)&v378, v322, v2, v323, 6uLL))
  {
    outlined init with take of MirrorPath(&v378, (uint64_t)&v375);
    uint64_t v324 = (uint64_t)v376;
    uint64_t v325 = v377;
    __swift_project_boxed_opaque_existential_0Tm(&v375, (uint64_t)v376);
    (*(void (**)(unint64_t *, ValueMetadata *, _UNKNOWN **, uint64_t, uint64_t))(v325 + 8))(&v381, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation, v324, v325);
LABEL_211:
    __swift_destroy_boxed_opaque_existential_1Tm(&v375._countAndFlagsBits);
    goto LABEL_214;
  }
  uint64_t v380 = 0;
  long long v378 = 0u;
  long long v379 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v378, &demangling cache variable for type metadata for TextOutputStreamable?);
  unint64_t v334 = v363;
  memcpy(v363, v122, v3);
  uint64_t v335 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomStringConvertible);
  if (swift_dynamicCast((char *)&v378, v334, v2, v335, 6uLL))
  {
    outlined init with take of MirrorPath(&v378, (uint64_t)&v375);
    uint64_t v336 = (uint64_t)v376;
    uint64_t v337 = v377;
    __swift_project_boxed_opaque_existential_0Tm(&v375, (uint64_t)v376);
    unint64_t v301 = (*(uint64_t (**)(uint64_t, uint64_t))(v337 + 8))(v336, v337);
LABEL_206:
    unint64_t v303 = v301;
    uint64_t v304 = v302;
    unint64_t v305 = HIBYTE(v382) & 0xF;
    if ((v382 & 0x2000000000000000) == 0) {
      unint64_t v305 = v381 & 0xFFFFFFFFFFFFLL;
    }
    if (v305 || (v381 & ~v382 & 0x2000000000000000) != 0)
    {
      _StringGuts.append(_:)(v301, v302);
      swift_bridgeObjectRelease(v304);
    }
    else
    {
      swift_bridgeObjectRelease(v382);
      unint64_t v381 = v303;
      unint64_t v382 = v304;
    }
    goto LABEL_211;
  }
  uint64_t v380 = 0;
  long long v378 = 0u;
  long long v379 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v378, &demangling cache variable for type metadata for CustomStringConvertible?);
  uint64_t v342 = v360;
  memcpy(v360, v122, v3);
  uint64_t v343 = (const char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for CustomDebugStringConvertible);
  if (swift_dynamicCast((char *)&v378, v342, v2, v343, 6uLL))
  {
    outlined init with take of MirrorPath(&v378, (uint64_t)&v375);
LABEL_205:
    uint64_t v299 = (uint64_t)v376;
    uint64_t v300 = v377;
    __swift_project_boxed_opaque_existential_0Tm(&v375, (uint64_t)v376);
    unint64_t v301 = (*(uint64_t (**)(uint64_t, uint64_t))(v300 + 8))(v299, v300);
    goto LABEL_206;
  }
  uint64_t v380 = 0;
  long long v378 = 0u;
  long long v379 = 0u;
  outlined destroy of _HasContiguousBytes?((uint64_t)&v378, &demangling cache variable for type metadata for CustomDebugStringConvertible?);
  *((void *)&v379 + 1) = v2;
  uint64_t v350 = __swift_allocate_boxed_opaque_existential_0Tm(&v378);
  memcpy(v350, v122, v3);
  Mirror.init(reflecting:)((uint64_t *)&v378, (uint64_t)&v375);
  uint64_t v351 = v375._object;
  uint64_t v352 = v377;
  ((void (*)(const void *, Swift::String *, unint64_t *, void, Class *, ValueMetadata *, _UNKNOWN **))_adHocPrint_unlocked<A, B>(_:_:_:isDebugPrint:))(v122, &v375, &v381, 0, v2, &type metadata for DefaultStringInterpolation, &protocol witness table for DefaultStringInterpolation);
  swift_release(v352);
  swift_release((uint64_t)v351);
LABEL_214:
  uint64_t v308 = v382;
  unint64_t v309 = HIBYTE(v382) & 0xF;
  if ((v382 & 0x2000000000000000) == 0) {
    unint64_t v309 = v381 & 0xFFFFFFFFFFFFLL;
  }
  if (v309 || (v381 & ~v382 & 0x2000000000000000) != 0)
  {
    if ((v382 & 0x2000000000000000) == 0
      || (unint64_t v310 = specialized _SmallString.init(_:appending:)(v381, v382, 0x29uLL, 0xE100000000000000), (v311 & 1) != 0))
    {
      swift_bridgeObjectRetain(0xE100000000000000);
      _StringGuts.append(_:)(41, 0xE100000000000000, 0, 1);
      swift_bridgeObjectRelease_n(0xE100000000000000, 2);
      return v381;
    }
    else
    {
      unint64_t v312 = v310;
      swift_bridgeObjectRelease(v308);
      swift_bridgeObjectRelease(0xE100000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v382);
    return 41;
  }
  return v312;
}

uint64_t SIMD3<>.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void (*a4)(char *, uint64_t, uint64_t, uint64_t, uint64_t)@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v47 = a6;
  uint64_t v49 = a4;
  uint64_t v52 = a1;
  uint64_t v44 = a8;
  uint64_t v12 = MEMORY[0x1F4188790](a1);
  unint64_t v41 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12);
  uint64_t v15 = (char *)&v39 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v16, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v19 = *(void (**)(const char *))(AssociatedConformanceWitness + 48);
  unint64_t v43 = AssociatedTypeWitness;
  uint64_t v20 = AssociatedConformanceWitness;
  v19(AssociatedTypeWitness);
  char v42 = a7;
  uint64_t v21 = swift_getAssociatedTypeWitness(255, a7, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v46 = a3;
  uint64_t v50 = v21;
  uint64_t v22 = swift_getAssociatedConformanceWitness((uint64_t)a7, a3, (uint64_t)v21, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v51 = v22;
  unint64_t v40 = *(void (**)(void, uint64_t *, uint64_t))(v22 + 56);
  uint64_t v23 = v40;
  uint64_t v24 = swift_checkMetadataState(0, (uint64_t)v21);
  uint64_t v25 = v41;
  v23(0, v24, v22);
  uint64_t v26 = *(void (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(*((void *)v49 + 2) + 72);
  uint64_t v48 = *((void *)v49 + 2);
  uint64_t v49 = v26;
  uint64_t v47 = *(void *)(v47 + 8);
  uint64_t v27 = v15;
  ((void (*)(char *, uint64_t))v26)(v25, a3);
  uint64_t v28 = v20;
  uint64_t v39 = v20;
  BOOL v45 = *(void (**)(char *, uint64_t, const char *, uint64_t))(v20 + 64);
  uint64_t v29 = v43;
  v45(v15, 0, v43, v28);
  uint64_t v30 = swift_checkMetadataState(0, (uint64_t)v50);
  uint64_t v31 = v40;
  v40(1, v30, v51);
  v49(v25, v46, v47, a2, v48);
  uint64_t v32 = v39;
  v45(v27, 1, v29, v39);
  uint64_t v33 = swift_checkMetadataState(0, (uint64_t)v50);
  uint64_t v34 = v52;
  v31(2, v33, v51);
  uint64_t v35 = v46;
  v49(v25, v46, v47, a2, v48);
  v45(v27, 2, v43, v32);
  unint64_t v37 = type metadata accessor for SIMD3(0, v35, (uint64_t)v42, v36);
  return (*((uint64_t (**)(uint64_t, Class *))*(v37 - 1) + 1))(v34, v37);
}

uint64_t SIMD3<>.init<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int **a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v52 = a4;
  uint64_t v53 = a6;
  uint64_t v54 = a3;
  uint64_t v49 = a1;
  uint64_t v45 = a8;
  uint64_t v11 = MEMORY[0x1F4188790](a1);
  char v42 = (char *)&v39 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11);
  unint64_t v41 = (char *)&v39 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v14, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v17 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 48);
  uint64_t v44 = AssociatedTypeWitness;
  v17(AssociatedTypeWitness, AssociatedConformanceWitness);
  unint64_t v43 = a7;
  uint64_t v18 = v54;
  uint64_t v19 = swift_getAssociatedTypeWitness(255, a7, v54, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v20 = v18;
  uint64_t v48 = v19;
  uint64_t v21 = swift_getAssociatedConformanceWitness((uint64_t)a7, v18, (uint64_t)v19, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  uint64_t v22 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v21 + 56);
  uint64_t v50 = v21;
  uint64_t v51 = v22;
  uint64_t v23 = swift_checkMetadataState(0, (uint64_t)v19);
  uint64_t v24 = v42;
  v22(0, v23, v21);
  uint64_t v25 = v53;
  uint64_t v47 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(v52 + 80);
  uint64_t v26 = v41;
  v47(v24, v20, v53, a2);
  uint64_t v40 = AssociatedConformanceWitness;
  uint64_t v46 = *(void (**)(char *, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 64);
  uint64_t v27 = v44;
  v46(v26, 0, v44, AssociatedConformanceWitness);
  uint64_t v28 = swift_checkMetadataState(0, (uint64_t)v48);
  v51(1, v28, v50);
  uint64_t v29 = v25;
  uint64_t v30 = v52;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v47)(v24, v54, v29, a2, v52);
  uint64_t v31 = v40;
  v46(v26, 1, v27, v40);
  uint64_t v32 = swift_checkMetadataState(0, (uint64_t)v48);
  uint64_t v33 = v49;
  v51(2, v32, v50);
  uint64_t v34 = v24;
  uint64_t v35 = v54;
  ((void (*)(char *, uint64_t, uint64_t, uint64_t, uint64_t))v47)(v34, v54, v53, a2, v30);
  v46(v26, 2, v44, v31);
  unint64_t v37 = type metadata accessor for SIMD3(0, v35, (uint64_t)v43, v36);
  return (*((uint64_t (**)(uint64_t, Class *))*(v37 - 1) + 1))(v33, v37);
}

uint64_t UInt8.SIMD2Storage._value.setter(uint64_t result)
{
  _WORD *v1 = result;
  return result;
}

uint64_t (*UInt8.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

uint64_t UInt8.SIMD2Storage.init()()
{
  return 0;
}

uint64_t (*UInt8.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2, double a3))()
{
  LOBYTE(a3) = *v3;
  BYTE4(a3) = v3[1];
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  double v5 = a3;
  *(unsigned char *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD2Storage(uint64_t a1, uint64_t a2, double a3))()
{
  LOBYTE(a3) = *v3;
  BYTE4(a3) = v3[1];
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  double v5 = a3;
  *(unsigned char *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t UInt8.SIMD4Storage._value.setter(uint64_t result)
{
  _DWORD *v1 = result;
  return result;
}

uint64_t (*UInt8.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

uint64_t UInt8.SIMD4Storage.init()()
{
  return 0;
}

uint64_t (*UInt8.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2, uint8x8_t a3))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  a3.i32[0] = *v3;
  unint64_t v5 = vmovl_u8(a3).u64[0];
  *(unsigned char *)(a1 + 16) = *(_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF9 | (2 * (a2 & 3)));
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD4Storage(uint64_t a1, uint64_t a2, uint8x8_t a3))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  a3.i32[0] = *v3;
  unint64_t v5 = vmovl_u8(a3).u64[0];
  *(unsigned char *)(a1 + 16) = *(_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF9 | (2 * (a2 & 3)));
  return UInt8.SIMD2Storage.subscript.modify;
}

void UInt8.SIMD8Storage._value.setter(double a1)
{
  double *v1 = a1;
}

uint64_t (*UInt8.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double UInt8.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt8.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  uint64_t v4 = *v2;
  *(unsigned char *)(a1 + 16) = *(unsigned char *)((unint64_t)&v4 | a2 & 7);
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt8.SIMD8Storage@<D0>(void *a1@<X8>)
{
  double result = 0.0;
  *a1 = 0;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD8Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  uint64_t v4 = *v2;
  *(unsigned char *)(a1 + 16) = *(unsigned char *)((unint64_t)&v4 | a2 & 7);
  return UInt8.SIMD2Storage.subscript.modify;
}

void UInt8.SIMD16Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*UInt8.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double UInt8.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt8.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(unsigned char *)(a1 + 16) = *(unsigned char *)((unint64_t)&v4 | a2 & 0xF);
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt8.SIMD16Storage@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  *a1 = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD16Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(unsigned char *)(a1 + 16) = *(unsigned char *)((unint64_t)&v4 | a2 & 0xF);
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt8.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double UInt8.SIMD32Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt8.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(unsigned char *)(a1 + 16) = *((unsigned char *)&v4 + (a2 & 0x1F));
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt8.SIMD32Storage@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD32Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(unsigned char *)(a1 + 16) = *((unsigned char *)&v4 + (a2 & 0x1F));
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt8.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt8.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double UInt8.SIMD64Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt8.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  long long v3 = *v2;
  long long v4 = v2[1];
  long long v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(unsigned char *)(a1 + 16) = *((unsigned char *)v7 + (a2 & 0x3F));
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt8.SIMD64Storage@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt8.SIMD64Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  long long v3 = *v2;
  long long v4 = v2[1];
  long long v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(unsigned char *)(a1 + 16) = *((unsigned char *)v7 + (a2 & 0x3F));
  return UInt8.SIMD2Storage.subscript.modify;
}

uint64_t Int8.SIMD2Storage._value.setter(uint64_t result)
{
  _WORD *v1 = result;
  return result;
}

uint64_t (*Int8.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

uint64_t Int8.SIMD2Storage.init()()
{
  return 0;
}

uint64_t Int8.SIMD2Storage.subscript.getter(char a1, __int16 a2)
{
  LODWORD(v2) = a2;
  HIDWORD(v2) = HIBYTE(a2);
  uint64_t v4 = v2;
  return *(unsigned int *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a1 & 1)));
}

__n128 key path getter for Int8.SIMD2Storage.subscript(_:) : Int8.SIMD2Storage@<Q0>(unsigned char *a1@<X0>, _DWORD *a2@<X1>, unsigned char *a3@<X8>, double a4@<D0>)
{
  LOBYTE(a4) = *a1;
  BYTE4(a4) = a1[1];
  uint64_t v4 = (_DWORD *)((unint64_t)&v6 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1)));
  double v6 = a4;
  *a3 = *v4;
  result.n128_u32[0] = LODWORD(a4);
  result.n128_u8[4] = BYTE4(a4);
  return result;
}

unsigned char *key path setter for Int8.SIMD2Storage.subscript(_:) : Int8.SIMD2Storage(unsigned char *result, uint64_t a2, unsigned int *a3)
{
  *(unsigned char *)(a2 + *a3) = *result;
  return result;
}

uint64_t Int8.SIMD2Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(unsigned char *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2, double a3))()
{
  LOBYTE(a3) = *v3;
  BYTE4(a3) = v3[1];
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  double v5 = a3;
  *(unsigned char *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt8.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD2Storage@<Q0>(char a1@<W0>, unsigned char *a2@<X8>, double a3@<D0>)
{
  LOBYTE(a3) = *v3;
  BYTE4(a3) = v3[1];
  double v5 = a3;
  *a2 = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a1 & 1)));
  result.n128_u32[0] = LODWORD(a3);
  result.n128_u8[4] = BYTE4(a3);
  return result;
}

unsigned char *protocol witness for SIMDStorage.subscript.setter in conformance Int8.SIMD2Storage(unsigned char *result, unsigned int a2)
{
  *(unsigned char *)(v2 + a2) = *result;
  return result;
}

unsigned int *UInt8.SIMD2Storage.subscript.modify(unsigned int *result)
{
  *(unsigned char *)(*((void *)result + 1) + *result) = *((unsigned char *)result + 16);
  return result;
}

uint64_t Int8.SIMD4Storage._value.setter(uint64_t result)
{
  _DWORD *v1 = result;
  return result;
}

uint64_t (*Int8.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

uint64_t Int8.SIMD4Storage.init()()
{
  return 0;
}

uint64_t Int8.SIMD4Storage.subscript.getter(char a1, __int32 a2, int8x8_t a3)
{
  a3.i32[0] = a2;
  int8x8_t v4 = vzip1_s8(a3, a3);
  return *(unsigned __int16 *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9 | (2 * (a1 & 3)));
}

double key path getter for Int8.SIMD4Storage.subscript(_:) : Int8.SIMD4Storage@<D0>(__int32 *a1@<X0>, _DWORD *a2@<X1>, unsigned char *a3@<X8>, uint8x8_t a4@<D0>)
{
  a4.i32[0] = *a1;
  *(void *)&double result = vmovl_u8(a4).u64[0];
  double v5 = (_WORD *)((unint64_t)&v6 & 0xFFFFFFFFFFFFFFF9 | (2 * (*a2 & 3)));
  double v6 = result;
  *a3 = *v5;
  return result;
}

uint64_t Int8.SIMD4Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(unsigned char *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2, uint8x8_t a3))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  a3.i32[0] = *v3;
  unint64_t v5 = vmovl_u8(a3).u64[0];
  *(unsigned char *)(a1 + 16) = *(_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF9 | (2 * (a2 & 3)));
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD4Storage@<D0>(char a1@<W0>, unsigned char *a2@<X8>, uint8x8_t a3@<D0>)
{
  a3.i32[0] = *v3;
  *(void *)&double result = vmovl_u8(a3).u64[0];
  double v5 = result;
  *a2 = *(_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF9 | (2 * (a1 & 3)));
  return result;
}

void Int8.SIMD8Storage._value.setter(double a1)
{
  double *v1 = a1;
}

uint64_t (*Int8.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double Int8.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t Int8.SIMD8Storage.subscript.getter(char a1, double a2)
{
  double v3 = a2;
  return *(unsigned __int8 *)((unint64_t)&v3 | a1 & 7);
}

double key path getter for Int8.SIMD8Storage.subscript(_:) : Int8.SIMD8Storage@<D0>(double *a1@<X0>, _DWORD *a2@<X1>, unsigned char *a3@<X8>)
{
  double result = *a1;
  int8x8_t v4 = (unsigned char *)((unint64_t)&v5 | *a2 & 7);
  double v5 = *a1;
  *a3 = *v4;
  return result;
}

uint64_t Int8.SIMD8Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(unsigned char *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  uint64_t v4 = *v2;
  *(unsigned char *)(a1 + 16) = *(unsigned char *)((unint64_t)&v4 | a2 & 7);
  return UInt8.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD8Storage@<D0>(char a1@<W0>, unsigned char *a2@<X8>)
{
  double result = *v2;
  double v4 = *v2;
  *a2 = *(unsigned char *)((unint64_t)&v4 | a1 & 7);
  return result;
}

void Int8.SIMD16Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*Int8.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double Int8.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t Int8.SIMD16Storage.subscript.getter(char a1)
{
  return *(unsigned __int8 *)((unint64_t)&v2 | a1 & 0xF);
}

__n128 key path getter for Int8.SIMD16Storage.subscript(_:) : Int8.SIMD16Storage@<Q0>(__n128 *a1@<X0>, _DWORD *a2@<X1>, unsigned char *a3@<X8>)
{
  __n128 result = *a1;
  double v4 = (unsigned char *)((unint64_t)&v5 | *a2 & 0xF);
  __n128 v5 = *a1;
  *a3 = *v4;
  return result;
}

uint64_t Int8.SIMD16Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(unsigned char *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(unsigned char *)(a1 + 16) = *(unsigned char *)((unint64_t)&v4 | a2 & 0xF);
  return UInt8.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD16Storage@<Q0>(char a1@<W0>, unsigned char *a2@<X8>)
{
  __n128 result = *v2;
  *a2 = *(unsigned char *)((unint64_t)&v4 | a1 & 0xF);
  return result;
}

void Int8.SIMD32Storage._value.setter(__n128 a1, __n128 a2)
{
  *uint64_t v2 = a1;
  v2[1] = a2;
}

uint64_t (*Int8.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double Int8.SIMD32Storage.init()()
{
  return 0.0;
}

uint64_t Int8.SIMD32Storage.subscript.getter(char a1)
{
  return *((unsigned __int8 *)&v2 + (a1 & 0x1F));
}

__n128 key path getter for Int8.SIMD32Storage.subscript(_:) : Int8.SIMD32Storage@<Q0>(__n128 *a1@<X0>, _DWORD *a2@<X1>, unsigned char *a3@<X8>)
{
  __n128 result = *a1;
  *a3 = *((unsigned char *)&v4 + (*a2 & 0x1F));
  return result;
}

uint64_t Int8.SIMD32Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(unsigned char *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(unsigned char *)(a1 + 16) = *((unsigned char *)&v4 + (a2 & 0x1F));
  return UInt8.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD32Storage@<Q0>(char a1@<W0>, unsigned char *a2@<X8>)
{
  __n128 result = *v2;
  *a2 = *((unsigned char *)&v4 + (a1 & 0x1F));
  return result;
}

void Int8.SIMD64Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  v4[2] = a3;
  v4[3] = a4;
  *long long v4 = a1;
  v4[1] = a2;
}

uint64_t (*Int8.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int8.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double Int8.SIMD64Storage.init()()
{
  return 0.0;
}

uint64_t Int8.SIMD64Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((unsigned __int8 *)v6 + (a1 & 0x3F));
}

__n128 key path getter for Int8.SIMD64Storage.subscript(_:) : Int8.SIMD64Storage@<Q0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, unsigned char *a3@<X8>)
{
  __n128 result = *(__n128 *)a1;
  long long v4 = *(_OWORD *)(a1 + 16);
  long long v5 = *(_OWORD *)(a1 + 48);
  uint64_t v6 = *a2 & 0x3F;
  v7[2] = *(_OWORD *)(a1 + 32);
  v7[3] = v5;
  v7[0] = result;
  v7[1] = v4;
  *a3 = *((unsigned char *)v7 + v6);
  return result;
}

uint64_t Int8.SIMD64Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(unsigned char *)(v2 + a2) = result;
  return result;
}

uint64_t (*Int8.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  long long v3 = *v2;
  long long v4 = v2[1];
  long long v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(unsigned char *)(a1 + 16) = *((unsigned char *)v7 + (a2 & 0x3F));
  return UInt8.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int8.SIMD64Storage@<Q0>(char a1@<W0>, unsigned char *a2@<X8>)
{
  __n128 result = *(__n128 *)v2;
  long long v4 = *(_OWORD *)(v2 + 16);
  long long v5 = *(_OWORD *)(v2 + 48);
  v6[2] = *(_OWORD *)(v2 + 32);
  v6[3] = v5;
  v6[0] = result;
  v6[1] = v4;
  *a2 = *((unsigned char *)v6 + (a1 & 0x3F));
  return result;
}

uint64_t UInt16.SIMD2Storage._value.setter(uint64_t result)
{
  _DWORD *v1 = result;
  return result;
}

uint64_t (*UInt16.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

uint64_t UInt16.SIMD2Storage.init()()
{
  return 0;
}

uint64_t (*UInt16.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2, double a3))()
{
  LOWORD(a3) = *v3;
  WORD2(a3) = v3[1];
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  double v5 = a3;
  *(_WORD *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD2Storage(uint64_t a1, uint64_t a2, double a3))()
{
  LOWORD(a3) = *v3;
  WORD2(a3) = v3[1];
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  double v5 = a3;
  *(_WORD *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt16.SIMD2Storage.subscript.modify;
}

void UInt16.SIMD4Storage._value.setter(double a1)
{
  double *v1 = a1;
}

uint64_t (*UInt16.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double UInt16.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt16.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  uint64_t v4 = *v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9 | (2 * (a2 & 3)));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD4Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  uint64_t v4 = *v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9 | (2 * (a2 & 3)));
  return UInt16.SIMD2Storage.subscript.modify;
}

void UInt16.SIMD8Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*UInt16.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double UInt16.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt16.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF1 | (2 * (a2 & 7)));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD8Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF1 | (2 * (a2 & 7)));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt16.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double UInt16.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt16.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *((_WORD *)&v4 + (a2 & 0xF));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD16Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *((_WORD *)&v4 + (a2 & 0xF));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt16.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double UInt16.SIMD32Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt16.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  long long v3 = *v2;
  long long v4 = v2[1];
  long long v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v7 + (a2 & 0x1F));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD32Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  long long v3 = *v2;
  long long v4 = v2[1];
  long long v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v7 + (a2 & 0x1F));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt16.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt16.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double UInt16.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt16.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  long long v3 = *v2;
  long long v4 = v2[1];
  long long v5 = v2[2];
  long long v6 = v2[3];
  long long v7 = v2[4];
  long long v8 = v2[5];
  long long v9 = v2[7];
  v11[6] = v2[6];
  v11[7] = v9;
  v11[4] = v7;
  v11[5] = v8;
  v11[2] = v5;
  v11[3] = v6;
  v11[0] = v3;
  v11[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v11 + (a2 & 0x3F));
  return UInt16.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt16.SIMD64Storage@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt16.SIMD64Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  long long v3 = *v2;
  long long v4 = v2[1];
  long long v5 = v2[2];
  long long v6 = v2[3];
  long long v7 = v2[4];
  long long v8 = v2[5];
  long long v9 = v2[7];
  v11[6] = v2[6];
  v11[7] = v9;
  v11[4] = v7;
  v11[5] = v8;
  v11[2] = v5;
  v11[3] = v6;
  v11[0] = v3;
  v11[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v11 + (a2 & 0x3F));
  return UInt16.SIMD2Storage.subscript.modify;
}

uint64_t Int16.SIMD2Storage._value.setter(uint64_t result)
{
  _DWORD *v1 = result;
  return result;
}

uint64_t (*Int16.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

uint64_t Int16.SIMD2Storage.init()()
{
  return 0;
}

uint64_t Int16.SIMD2Storage.subscript.getter(char a1, __int32 a2, uint16x4_t a3)
{
  a3.i32[0] = a2;
  unint64_t v4 = vmovl_u16(a3).u64[0];
  return *(unsigned int *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a1 & 1)));
}

__n128 key path getter for Int16.SIMD2Storage.subscript(_:) : Int16.SIMD2Storage@<Q0>(_WORD *a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>, double a4@<D0>)
{
  LOWORD(a4) = *a1;
  WORD2(a4) = a1[1];
  unint64_t v4 = (_DWORD *)((unint64_t)&v6 & 0xFFFFFFFFFFFFFFFBLL | (4 * (*a2 & 1)));
  double v6 = a4;
  *a3 = *v4;
  result.n128_u32[0] = LODWORD(a4);
  result.n128_u16[2] = WORD2(a4);
  return result;
}

_WORD *key path setter for Int16.SIMD2Storage.subscript(_:) : Int16.SIMD2Storage(_WORD *result, uint64_t a2, unsigned int *a3)
{
  *(_WORD *)(a2 + 2 * *a3) = *result;
  return result;
}

uint64_t Int16.SIMD2Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_WORD *)(v2 + 2 * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2, double a3))()
{
  LOWORD(a3) = *v3;
  WORD2(a3) = v3[1];
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v3;
  double v5 = a3;
  *(_WORD *)(a1 + 16) = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a2 & 1)));
  return UInt16.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD2Storage@<Q0>(char a1@<W0>, _WORD *a2@<X8>, double a3@<D0>)
{
  LOWORD(a3) = *v3;
  WORD2(a3) = v3[1];
  double v5 = a3;
  *a2 = *(_DWORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a1 & 1)));
  result.n128_u32[0] = LODWORD(a3);
  result.n128_u16[2] = WORD2(a3);
  return result;
}

_WORD *protocol witness for SIMDStorage.subscript.setter in conformance Int16.SIMD2Storage(_WORD *result, unsigned int a2)
{
  *(_WORD *)(v2 + 2 * a2) = *result;
  return result;
}

unsigned int *UInt16.SIMD2Storage.subscript.modify(unsigned int *result)
{
  *(_WORD *)(*((void *)result + 1) + 2 * *result) = *((_WORD *)result + 8);
  return result;
}

void Int16.SIMD4Storage._value.setter(double a1)
{
  double *v1 = a1;
}

uint64_t (*Int16.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double Int16.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t Int16.SIMD4Storage.subscript.getter(char a1, double a2)
{
  double v3 = a2;
  return *(unsigned __int16 *)((unint64_t)&v3 & 0xFFFFFFFFFFFFFFF9 | (2 * (a1 & 3)));
}

double key path getter for Int16.SIMD4Storage.subscript(_:) : Int16.SIMD4Storage@<D0>(double *a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>)
{
  double result = *a1;
  unint64_t v4 = (_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF9 | (2 * (*a2 & 3)));
  double v5 = *a1;
  *a3 = *v4;
  return result;
}

uint64_t Int16.SIMD4Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_WORD *)(v2 + 2 * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  uint64_t v4 = *v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9 | (2 * (a2 & 3)));
  return UInt16.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD4Storage@<D0>(char a1@<W0>, _WORD *a2@<X8>)
{
  double result = *v2;
  double v4 = *v2;
  *a2 = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9 | (2 * (a1 & 3)));
  return result;
}

void Int16.SIMD8Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*Int16.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double Int16.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t Int16.SIMD8Storage.subscript.getter(char a1)
{
  return *(unsigned __int16 *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF1 | (2 * (a1 & 7)));
}

__n128 key path getter for Int16.SIMD8Storage.subscript(_:) : Int16.SIMD8Storage@<Q0>(__n128 *a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __n128 result = *a1;
  double v4 = (_WORD *)((unint64_t)&v5 & 0xFFFFFFFFFFFFFFF1 | (2 * (*a2 & 7)));
  __n128 v5 = *a1;
  *a3 = *v4;
  return result;
}

uint64_t Int16.SIMD8Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_WORD *)(v2 + 2 * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF1 | (2 * (a2 & 7)));
  return UInt16.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD8Storage@<Q0>(char a1@<W0>, _WORD *a2@<X8>)
{
  __n128 result = *v2;
  *a2 = *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF1 | (2 * (a1 & 7)));
  return result;
}

void Int16.SIMD16Storage._value.setter(__n128 a1, __n128 a2)
{
  *uint64_t v2 = a1;
  v2[1] = a2;
}

uint64_t (*Int16.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double Int16.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t Int16.SIMD16Storage.subscript.getter(char a1)
{
  return *((unsigned __int16 *)&v2 + (a1 & 0xF));
}

__n128 key path getter for Int16.SIMD16Storage.subscript(_:) : Int16.SIMD16Storage@<Q0>(__n128 *a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __n128 result = *a1;
  *a3 = *((_WORD *)&v4 + (*a2 & 0xF));
  return result;
}

uint64_t Int16.SIMD16Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_WORD *)(v2 + 2 * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *((_WORD *)&v4 + (a2 & 0xF));
  return UInt16.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD16Storage@<Q0>(char a1@<W0>, _WORD *a2@<X8>)
{
  __n128 result = *v2;
  *a2 = *((_WORD *)&v4 + (a1 & 0xF));
  return result;
}

void Int16.SIMD32Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  v4[2] = a3;
  v4[3] = a4;
  *long long v4 = a1;
  v4[1] = a2;
}

uint64_t (*Int16.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double Int16.SIMD32Storage.init()()
{
  return 0.0;
}

uint64_t Int16.SIMD32Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((unsigned __int16 *)v6 + (a1 & 0x1F));
}

__n128 key path getter for Int16.SIMD32Storage.subscript(_:) : Int16.SIMD32Storage@<Q0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __n128 result = *(__n128 *)a1;
  long long v4 = *(_OWORD *)(a1 + 16);
  long long v5 = *(_OWORD *)(a1 + 48);
  uint64_t v6 = *a2 & 0x1F;
  v7[2] = *(_OWORD *)(a1 + 32);
  v7[3] = v5;
  v7[0] = result;
  v7[1] = v4;
  *a3 = *((_WORD *)v7 + v6);
  return result;
}

uint64_t Int16.SIMD32Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_WORD *)(v2 + 2 * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  long long v3 = *v2;
  long long v4 = v2[1];
  long long v5 = v2[3];
  v7[2] = v2[2];
  v7[3] = v5;
  v7[0] = v3;
  v7[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v7 + (a2 & 0x1F));
  return UInt16.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD32Storage@<Q0>(char a1@<W0>, _WORD *a2@<X8>)
{
  __n128 result = *(__n128 *)v2;
  long long v4 = *(_OWORD *)(v2 + 16);
  long long v5 = *(_OWORD *)(v2 + 48);
  v6[2] = *(_OWORD *)(v2 + 32);
  v6[3] = v5;
  v6[0] = result;
  v6[1] = v4;
  *a2 = *((_WORD *)v6 + (a1 & 0x1F));
  return result;
}

__n128 Int16.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  long long v3 = *(_OWORD *)(v1 + 16);
  long long v4 = *(_OWORD *)(v1 + 32);
  long long v5 = *(_OWORD *)(v1 + 48);
  long long v6 = *(_OWORD *)(v1 + 64);
  long long v7 = *(_OWORD *)(v1 + 80);
  long long v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int16.SIMD64Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  long long v4 = *(_OWORD *)(a1 + 32);
  long long v5 = *(_OWORD *)(a1 + 48);
  long long v6 = *(_OWORD *)(a1 + 64);
  long long v7 = *(_OWORD *)(a1 + 80);
  long long v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int16.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int16.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double Int16.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int16.SIMD64Storage.subscript.getter(char a1)
{
  long long v2 = *v1;
  long long v3 = v1[1];
  long long v4 = v1[2];
  long long v5 = v1[3];
  long long v6 = v1[4];
  long long v7 = v1[5];
  long long v8 = v1[7];
  v10[6] = v1[6];
  v10[7] = v8;
  v10[4] = v6;
  v10[5] = v7;
  v10[2] = v4;
  v10[3] = v5;
  v10[0] = v2;
  v10[1] = v3;
  return *((unsigned __int16 *)v10 + (a1 & 0x3F));
}

__n128 key path getter for Int16.SIMD64Storage.subscript(_:) : Int16.SIMD64Storage@<Q0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, _WORD *a3@<X8>)
{
  __n128 result = *(__n128 *)a1;
  long long v4 = *(_OWORD *)(a1 + 16);
  long long v5 = *(_OWORD *)(a1 + 32);
  long long v6 = *(_OWORD *)(a1 + 48);
  long long v7 = *(_OWORD *)(a1 + 64);
  long long v8 = *(_OWORD *)(a1 + 80);
  long long v9 = *(_OWORD *)(a1 + 112);
  uint64_t v10 = *a2 & 0x3F;
  v11[6] = *(_OWORD *)(a1 + 96);
  v11[7] = v9;
  v11[4] = v7;
  v11[5] = v8;
  v11[2] = v5;
  v11[3] = v6;
  v11[0] = result;
  v11[1] = v4;
  *a3 = *((_WORD *)v11 + v10);
  return result;
}

uint64_t Int16.SIMD64Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_WORD *)(v2 + 2 * a2) = result;
  return result;
}

uint64_t (*Int16.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  long long v3 = *v2;
  long long v4 = v2[1];
  long long v5 = v2[2];
  long long v6 = v2[3];
  long long v7 = v2[4];
  long long v8 = v2[5];
  long long v9 = v2[7];
  v11[6] = v2[6];
  v11[7] = v9;
  v11[4] = v7;
  v11[5] = v8;
  v11[2] = v5;
  v11[3] = v6;
  v11[0] = v3;
  v11[1] = v4;
  *(_WORD *)(a1 + 16) = *((_WORD *)v11 + (a2 & 0x3F));
  return UInt16.SIMD2Storage.subscript.modify;
}

__n128 protocol witness for SIMDStorage.subscript.getter in conformance Int16.SIMD64Storage@<Q0>(char a1@<W0>, _WORD *a2@<X8>)
{
  __n128 result = *(__n128 *)v2;
  long long v4 = *(_OWORD *)(v2 + 16);
  long long v5 = *(_OWORD *)(v2 + 32);
  long long v6 = *(_OWORD *)(v2 + 48);
  long long v7 = *(_OWORD *)(v2 + 64);
  long long v8 = *(_OWORD *)(v2 + 80);
  long long v9 = *(_OWORD *)(v2 + 112);
  v10[6] = *(_OWORD *)(v2 + 96);
  v10[7] = v9;
  v10[4] = v7;
  v10[5] = v8;
  v10[2] = v5;
  v10[3] = v6;
  v10[0] = result;
  v10[1] = v4;
  *a2 = *((_WORD *)v10 + (a1 & 0x3F));
  return result;
}

void UInt32.SIMD2Storage._value.setter(double a1)
{
  double *v1 = a1;
}

uint64_t (*UInt32.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double UInt32.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt32.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 1));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD2Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 1));
  return UInt32.SIMD2Storage.subscript.modify;
}

void UInt32.SIMD4Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*UInt32.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double UInt32.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt32.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 3));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD4Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 3));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt32.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double UInt32.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt32.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 7));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD8Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 7));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt32.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double UInt32.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt32.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0xF));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD16Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0xF));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt32.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double UInt32.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt32.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x1F));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD32Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x1F));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt32.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt32.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double UInt32.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt32.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x3F));
  return UInt32.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt32.SIMD64Storage@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt32.SIMD64Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x3F));
  return UInt32.SIMD2Storage.subscript.modify;
}

void Int32.SIMD2Storage._value.setter(double a1)
{
  double *v1 = a1;
}

uint64_t (*Int32.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double Int32.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t Int32.SIMD2Storage.subscript.getter(char a1, double a2)
{
  double v3 = a2;
  return *(unsigned int *)((unint64_t)&v3 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a1 & 1)));
}

uint64_t key path getter for Int32.SIMD2Storage.subscript(_:) : Int32.SIMD2Storage@<X0>(uint64_t result@<X0>, void *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 1));
  return result;
}

_DWORD *key path setter for Int32.SIMD2Storage.subscript(_:) : Int32.SIMD2Storage(_DWORD *result, uint64_t a2, unsigned int *a3)
{
  *(_DWORD *)(a2 + 4 * *a3) = *result;
  return result;
}

uint64_t Int32.SIMD2Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_DWORD *)(v2 + 4 * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 1));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD2Storage@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *(_DWORD *)(v2 + 4 * (result & 1));
  return result;
}

_DWORD *protocol witness for SIMDStorage.subscript.setter in conformance Int32.SIMD2Storage(_DWORD *result, unsigned int a2)
{
  *(_DWORD *)(v2 + 4 * a2) = *result;
  return result;
}

unsigned int *UInt32.SIMD2Storage.subscript.modify(unsigned int *result)
{
  *(_DWORD *)(*((void *)result + 1) + 4 * *result) = result[4];
  return result;
}

void Int32.SIMD4Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*Int32.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double Int32.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t Int32.SIMD4Storage.subscript.getter(char a1)
{
  return *(unsigned int *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF3 | (4 * (a1 & 3)));
}

uint64_t key path getter for Int32.SIMD4Storage.subscript(_:) : Int32.SIMD4Storage@<X0>(uint64_t result@<X0>, void *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 3));
  return result;
}

uint64_t Int32.SIMD4Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_DWORD *)(v2 + 4 * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 3));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD4Storage@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *(_DWORD *)(v2 + 4 * (result & 3));
  return result;
}

void Int32.SIMD8Storage._value.setter(__n128 a1, __n128 a2)
{
  *uint64_t v2 = a1;
  v2[1] = a2;
}

uint64_t (*Int32.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double Int32.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t Int32.SIMD8Storage.subscript.getter(char a1)
{
  return *((unsigned int *)&v2 + (a1 & 7));
}

uint64_t key path getter for Int32.SIMD8Storage.subscript(_:) : Int32.SIMD8Storage@<X0>(uint64_t result@<X0>, void *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 7));
  return result;
}

uint64_t Int32.SIMD8Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_DWORD *)(v2 + 4 * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 7));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD8Storage@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *(_DWORD *)(v2 + 4 * (result & 7));
  return result;
}

void Int32.SIMD16Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  v4[2] = a3;
  v4[3] = a4;
  *long long v4 = a1;
  v4[1] = a2;
}

uint64_t (*Int32.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double Int32.SIMD16Storage.init()()
{
  return 0.0;
}

uint64_t Int32.SIMD16Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((unsigned int *)v6 + (a1 & 0xF));
}

uint64_t key path getter for Int32.SIMD16Storage.subscript(_:) : Int32.SIMD16Storage@<X0>(uint64_t result@<X0>, void *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 0xFLL));
  return result;
}

uint64_t Int32.SIMD16Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_DWORD *)(v2 + 4 * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0xF));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD16Storage@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *(_DWORD *)(v2 + 4 * (result & 0xF));
  return result;
}

__n128 Int32.SIMD32Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  long long v3 = *(_OWORD *)(v1 + 16);
  long long v4 = *(_OWORD *)(v1 + 32);
  long long v5 = *(_OWORD *)(v1 + 48);
  long long v6 = *(_OWORD *)(v1 + 64);
  long long v7 = *(_OWORD *)(v1 + 80);
  long long v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int32.SIMD32Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  long long v4 = *(_OWORD *)(a1 + 32);
  long long v5 = *(_OWORD *)(a1 + 48);
  long long v6 = *(_OWORD *)(a1 + 64);
  long long v7 = *(_OWORD *)(a1 + 80);
  long long v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int32.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double Int32.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int32.SIMD32Storage.subscript.getter(char a1)
{
  return *(unsigned int *)(v1 + 4 * (a1 & 0x1F));
}

uint64_t key path getter for Int32.SIMD32Storage.subscript(_:) : Int32.SIMD32Storage@<X0>(uint64_t result@<X0>, void *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 0x1FLL));
  return result;
}

uint64_t Int32.SIMD32Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_DWORD *)(v2 + 4 * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x1F));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD32Storage@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *(_DWORD *)(v2 + 4 * (result & 0x1F));
  return result;
}

__n128 Int32.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  long long v3 = *(_OWORD *)(v1 + 16);
  long long v4 = *(_OWORD *)(v1 + 32);
  long long v5 = *(_OWORD *)(v1 + 48);
  long long v6 = *(_OWORD *)(v1 + 64);
  long long v7 = *(_OWORD *)(v1 + 80);
  long long v8 = *(_OWORD *)(v1 + 96);
  long long v9 = *(_OWORD *)(v1 + 112);
  long long v10 = *(_OWORD *)(v1 + 128);
  long long v11 = *(_OWORD *)(v1 + 144);
  long long v12 = *(_OWORD *)(v1 + 160);
  long long v13 = *(_OWORD *)(v1 + 176);
  long long v14 = *(_OWORD *)(v1 + 192);
  long long v15 = *(_OWORD *)(v1 + 208);
  long long v16 = *(_OWORD *)(v1 + 240);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(v1 + 224);
  *(_OWORD *)(a1 + 240) = v16;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int32.SIMD64Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  long long v4 = *(_OWORD *)(a1 + 32);
  long long v5 = *(_OWORD *)(a1 + 48);
  long long v6 = *(_OWORD *)(a1 + 64);
  long long v7 = *(_OWORD *)(a1 + 80);
  long long v8 = *(_OWORD *)(a1 + 96);
  long long v9 = *(_OWORD *)(a1 + 112);
  long long v10 = *(_OWORD *)(a1 + 128);
  long long v11 = *(_OWORD *)(a1 + 144);
  long long v12 = *(_OWORD *)(a1 + 160);
  long long v13 = *(_OWORD *)(a1 + 176);
  long long v14 = *(_OWORD *)(a1 + 192);
  long long v15 = *(_OWORD *)(a1 + 208);
  long long v16 = *(_OWORD *)(a1 + 240);
  *(_OWORD *)(v1 + 224) = *(_OWORD *)(a1 + 224);
  *(_OWORD *)(v1 + 240) = v16;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int32.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int32.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double Int32.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int32.SIMD64Storage.subscript.getter(char a1)
{
  return *(unsigned int *)(v1 + 4 * (a1 & 0x3F));
}

uint64_t key path getter for Int32.SIMD64Storage.subscript(_:) : Int32.SIMD64Storage@<X0>(uint64_t result@<X0>, void *a2@<X1>, _DWORD *a3@<X8>)
{
  *a3 = *(_DWORD *)(result + 4 * (*a2 & 0x3FLL));
  return result;
}

uint64_t Int32.SIMD64Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(_DWORD *)(v2 + 4 * a2) = result;
  return result;
}

uint64_t (*Int32.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x3F));
  return UInt32.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int32.SIMD64Storage@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  *a2 = *(_DWORD *)(v2 + 4 * (result & 0x3F));
  return result;
}

void UInt64.SIMD2Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*UInt64.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double UInt64.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt64.SIMD2Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 1));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD2Storage(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 1));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt64.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double UInt64.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt64.SIMD4Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 3));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD4Storage(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 3));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt64.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double UInt64.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt64.SIMD8Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 7));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD8Storage(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 7));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt64.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double UInt64.SIMD16Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt64.SIMD16Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0xF));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD16Storage(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0xF));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt64.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double UInt64.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt64.SIMD32Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x1F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD32Storage(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x1F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt64.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt64.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double UInt64.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt64.SIMD64Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x3F));
  return UInt64.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance UInt64.SIMD64Storage@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance UInt64.SIMD64Storage(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x3F));
  return UInt64.SIMD2Storage.subscript.modify;
}

void Int64.SIMD2Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*Int64.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double Int64.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t (*Int64.SIMD2Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 1));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*Int64.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double Int64.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t (*Int64.SIMD4Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 3));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*Int64.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double Int64.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*Int64.SIMD8Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 7));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*Int64.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double Int64.SIMD16Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*Int64.SIMD16Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0xF));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*Int64.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double Int64.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*Int64.SIMD32Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x1F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*Int64.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int64.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double Int64.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*Int64.SIMD64Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x3F));
  return UInt64.SIMD2Storage.subscript.modify;
}

void UInt.SIMD2Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*UInt.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double UInt.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt.SIMD2Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 1));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double UInt.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt.SIMD4Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 3));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double UInt.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t (*UInt.SIMD8Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 7));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double UInt.SIMD16Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt.SIMD16Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0xF));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double UInt.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt.SIMD32Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x1F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t (*UInt.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t UInt.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double UInt.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t (*UInt.SIMD64Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x3F));
  return UInt64.SIMD2Storage.subscript.modify;
}

void Int.SIMD2Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*Int.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double Int.SIMD2Storage.init()()
{
  return 0.0;
}

uint64_t Int.SIMD2Storage.subscript.getter(char a1)
{
  return *(void *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF7 | (8 * (a1 & 1)));
}

uint64_t key path getter for Int.SIMD2Storage.subscript(_:) : Int.SIMD2Storage@<X0>(uint64_t result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *(void *)(result + 8 * (*a2 & 1));
  return result;
}

void *key path setter for Int.SIMD2Storage.subscript(_:) : Int.SIMD2Storage(void *result, uint64_t a2, unsigned int *a3)
{
  *(void *)(a2 + 8 * *a3) = *result;
  return result;
}

uint64_t Int.SIMD2Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(void *)(v2 + 8 * a2) = result;
  return result;
}

uint64_t (*Int.SIMD2Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 1));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD2Storage@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = *(void *)(v2 + 8 * (result & 1));
  return result;
}

void *protocol witness for SIMDStorage.subscript.setter in conformance Int.SIMD2Storage(void *result, unsigned int a2)
{
  *(void *)(v2 + 8 * a2) = *result;
  return result;
}

uint64_t UInt64.SIMD2Storage.subscript.modify(uint64_t result)
{
  *(void *)(*(void *)(result + 16) + 8 * *(unsigned int *)(result + 8)) = *(void *)result;
  return result;
}

void Int.SIMD4Storage._value.setter(__n128 a1, __n128 a2)
{
  *uint64_t v2 = a1;
  v2[1] = a2;
}

uint64_t (*Int.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double Int.SIMD4Storage.init()()
{
  return 0.0;
}

uint64_t Int.SIMD4Storage.subscript.getter(char a1)
{
  return *((void *)&v2 + (a1 & 3));
}

uint64_t key path getter for Int.SIMD4Storage.subscript(_:) : Int.SIMD4Storage@<X0>(uint64_t result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *(void *)(result + 8 * (*a2 & 3));
  return result;
}

uint64_t Int.SIMD4Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(void *)(v2 + 8 * a2) = result;
  return result;
}

uint64_t (*Int.SIMD4Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 3));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD4Storage@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = *(void *)(v2 + 8 * (result & 3));
  return result;
}

void Int.SIMD8Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  v4[2] = a3;
  v4[3] = a4;
  *long long v4 = a1;
  v4[1] = a2;
}

uint64_t (*Int.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double Int.SIMD8Storage.init()()
{
  return 0.0;
}

uint64_t Int.SIMD8Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((void *)v6 + (a1 & 7));
}

uint64_t key path getter for Int.SIMD8Storage.subscript(_:) : Int.SIMD8Storage@<X0>(uint64_t result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *(void *)(result + 8 * (*a2 & 7));
  return result;
}

uint64_t Int.SIMD8Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(void *)(v2 + 8 * a2) = result;
  return result;
}

uint64_t (*Int.SIMD8Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 7));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD8Storage@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = *(void *)(v2 + 8 * (result & 7));
  return result;
}

__n128 Int.SIMD16Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  long long v3 = *(_OWORD *)(v1 + 16);
  long long v4 = *(_OWORD *)(v1 + 32);
  long long v5 = *(_OWORD *)(v1 + 48);
  long long v6 = *(_OWORD *)(v1 + 64);
  long long v7 = *(_OWORD *)(v1 + 80);
  long long v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int.SIMD16Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  long long v4 = *(_OWORD *)(a1 + 32);
  long long v5 = *(_OWORD *)(a1 + 48);
  long long v6 = *(_OWORD *)(a1 + 64);
  long long v7 = *(_OWORD *)(a1 + 80);
  long long v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double Int.SIMD16Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int.SIMD16Storage.subscript.getter(char a1)
{
  return *(void *)(v1 + 8 * (a1 & 0xF));
}

uint64_t key path getter for Int.SIMD16Storage.subscript(_:) : Int.SIMD16Storage@<X0>(uint64_t result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *(void *)(result + 8 * (*a2 & 0xFLL));
  return result;
}

uint64_t Int.SIMD16Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(void *)(v2 + 8 * a2) = result;
  return result;
}

uint64_t (*Int.SIMD16Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0xF));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD16Storage@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = *(void *)(v2 + 8 * (result & 0xF));
  return result;
}

__n128 Int.SIMD32Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  long long v3 = *(_OWORD *)(v1 + 16);
  long long v4 = *(_OWORD *)(v1 + 32);
  long long v5 = *(_OWORD *)(v1 + 48);
  long long v6 = *(_OWORD *)(v1 + 64);
  long long v7 = *(_OWORD *)(v1 + 80);
  long long v8 = *(_OWORD *)(v1 + 96);
  long long v9 = *(_OWORD *)(v1 + 112);
  long long v10 = *(_OWORD *)(v1 + 128);
  long long v11 = *(_OWORD *)(v1 + 144);
  long long v12 = *(_OWORD *)(v1 + 160);
  long long v13 = *(_OWORD *)(v1 + 176);
  long long v14 = *(_OWORD *)(v1 + 192);
  long long v15 = *(_OWORD *)(v1 + 208);
  long long v16 = *(_OWORD *)(v1 + 240);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(v1 + 224);
  *(_OWORD *)(a1 + 240) = v16;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int.SIMD32Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  long long v4 = *(_OWORD *)(a1 + 32);
  long long v5 = *(_OWORD *)(a1 + 48);
  long long v6 = *(_OWORD *)(a1 + 64);
  long long v7 = *(_OWORD *)(a1 + 80);
  long long v8 = *(_OWORD *)(a1 + 96);
  long long v9 = *(_OWORD *)(a1 + 112);
  long long v10 = *(_OWORD *)(a1 + 128);
  long long v11 = *(_OWORD *)(a1 + 144);
  long long v12 = *(_OWORD *)(a1 + 160);
  long long v13 = *(_OWORD *)(a1 + 176);
  long long v14 = *(_OWORD *)(a1 + 192);
  long long v15 = *(_OWORD *)(a1 + 208);
  long long v16 = *(_OWORD *)(a1 + 240);
  *(_OWORD *)(v1 + 224) = *(_OWORD *)(a1 + 224);
  *(_OWORD *)(v1 + 240) = v16;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double Int.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int.SIMD32Storage.subscript.getter(char a1)
{
  return *(void *)(v1 + 8 * (a1 & 0x1F));
}

uint64_t key path getter for Int.SIMD32Storage.subscript(_:) : Int.SIMD32Storage@<X0>(uint64_t result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *(void *)(result + 8 * (*a2 & 0x1FLL));
  return result;
}

uint64_t Int.SIMD32Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(void *)(v2 + 8 * a2) = result;
  return result;
}

uint64_t (*Int.SIMD32Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x1F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD32Storage@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = *(void *)(v2 + 8 * (result & 0x1F));
  return result;
}

__n128 Int.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  long long v3 = *(_OWORD *)(v1 + 16);
  long long v4 = *(_OWORD *)(v1 + 32);
  long long v5 = *(_OWORD *)(v1 + 48);
  long long v6 = *(_OWORD *)(v1 + 64);
  long long v7 = *(_OWORD *)(v1 + 80);
  long long v8 = *(_OWORD *)(v1 + 96);
  long long v9 = *(_OWORD *)(v1 + 112);
  long long v10 = *(_OWORD *)(v1 + 128);
  long long v11 = *(_OWORD *)(v1 + 144);
  long long v12 = *(_OWORD *)(v1 + 160);
  long long v13 = *(_OWORD *)(v1 + 176);
  long long v14 = *(_OWORD *)(v1 + 192);
  long long v15 = *(_OWORD *)(v1 + 208);
  long long v16 = *(_OWORD *)(v1 + 224);
  long long v17 = *(_OWORD *)(v1 + 240);
  long long v18 = *(_OWORD *)(v1 + 256);
  long long v19 = *(_OWORD *)(v1 + 272);
  long long v20 = *(_OWORD *)(v1 + 288);
  long long v21 = *(_OWORD *)(v1 + 304);
  long long v22 = *(_OWORD *)(v1 + 320);
  long long v23 = *(_OWORD *)(v1 + 336);
  long long v24 = *(_OWORD *)(v1 + 352);
  long long v25 = *(_OWORD *)(v1 + 368);
  long long v26 = *(_OWORD *)(v1 + 384);
  long long v27 = *(_OWORD *)(v1 + 400);
  long long v28 = *(_OWORD *)(v1 + 416);
  long long v29 = *(_OWORD *)(v1 + 432);
  long long v30 = *(_OWORD *)(v1 + 448);
  long long v31 = *(_OWORD *)(v1 + 464);
  long long v32 = *(_OWORD *)(v1 + 496);
  *(_OWORD *)(a1 + 480) = *(_OWORD *)(v1 + 480);
  *(_OWORD *)(a1 + 496) = v32;
  *(_OWORD *)(a1 + 448) = v30;
  *(_OWORD *)(a1 + 464) = v31;
  *(_OWORD *)(a1 + 416) = v28;
  *(_OWORD *)(a1 + 432) = v29;
  *(_OWORD *)(a1 + 384) = v26;
  *(_OWORD *)(a1 + 400) = v27;
  *(_OWORD *)(a1 + 352) = v24;
  *(_OWORD *)(a1 + 368) = v25;
  *(_OWORD *)(a1 + 320) = v22;
  *(_OWORD *)(a1 + 336) = v23;
  *(_OWORD *)(a1 + 288) = v20;
  *(_OWORD *)(a1 + 304) = v21;
  *(_OWORD *)(a1 + 256) = v18;
  *(_OWORD *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 240) = v17;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Int.SIMD64Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  long long v4 = *(_OWORD *)(a1 + 32);
  long long v5 = *(_OWORD *)(a1 + 48);
  long long v6 = *(_OWORD *)(a1 + 64);
  long long v7 = *(_OWORD *)(a1 + 80);
  long long v8 = *(_OWORD *)(a1 + 96);
  long long v9 = *(_OWORD *)(a1 + 112);
  long long v10 = *(_OWORD *)(a1 + 128);
  long long v11 = *(_OWORD *)(a1 + 144);
  long long v12 = *(_OWORD *)(a1 + 160);
  long long v13 = *(_OWORD *)(a1 + 176);
  long long v14 = *(_OWORD *)(a1 + 192);
  long long v15 = *(_OWORD *)(a1 + 208);
  long long v16 = *(_OWORD *)(a1 + 224);
  long long v17 = *(_OWORD *)(a1 + 240);
  long long v18 = *(_OWORD *)(a1 + 256);
  long long v19 = *(_OWORD *)(a1 + 272);
  long long v20 = *(_OWORD *)(a1 + 288);
  long long v21 = *(_OWORD *)(a1 + 304);
  long long v22 = *(_OWORD *)(a1 + 320);
  long long v23 = *(_OWORD *)(a1 + 336);
  long long v24 = *(_OWORD *)(a1 + 352);
  long long v25 = *(_OWORD *)(a1 + 368);
  long long v26 = *(_OWORD *)(a1 + 384);
  long long v27 = *(_OWORD *)(a1 + 400);
  long long v28 = *(_OWORD *)(a1 + 416);
  long long v29 = *(_OWORD *)(a1 + 432);
  long long v30 = *(_OWORD *)(a1 + 448);
  long long v31 = *(_OWORD *)(a1 + 464);
  long long v32 = *(_OWORD *)(a1 + 496);
  *(_OWORD *)(v1 + 480) = *(_OWORD *)(a1 + 480);
  *(_OWORD *)(v1 + 496) = v32;
  *(_OWORD *)(v1 + 448) = v30;
  *(_OWORD *)(v1 + 464) = v31;
  *(_OWORD *)(v1 + 416) = v28;
  *(_OWORD *)(v1 + 432) = v29;
  *(_OWORD *)(v1 + 384) = v26;
  *(_OWORD *)(v1 + 400) = v27;
  *(_OWORD *)(v1 + 352) = v24;
  *(_OWORD *)(v1 + 368) = v25;
  *(_OWORD *)(v1 + 320) = v22;
  *(_OWORD *)(v1 + 336) = v23;
  *(_OWORD *)(v1 + 288) = v20;
  *(_OWORD *)(v1 + 304) = v21;
  *(_OWORD *)(v1 + 256) = v18;
  *(_OWORD *)(v1 + 272) = v19;
  *(_OWORD *)(v1 + 224) = v16;
  *(_OWORD *)(v1 + 240) = v17;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Int.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Int.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double Int.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t Int.SIMD64Storage.subscript.getter(char a1)
{
  return *(void *)(v1 + 8 * (a1 & 0x3F));
}

uint64_t key path getter for Int.SIMD64Storage.subscript(_:) : Int.SIMD64Storage@<X0>(uint64_t result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a3 = *(void *)(result + 8 * (*a2 & 0x3FLL));
  return result;
}

uint64_t Int.SIMD64Storage.subscript.setter(uint64_t result, unsigned int a2)
{
  *(void *)(v2 + 8 * a2) = result;
  return result;
}

uint64_t (*Int.SIMD64Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x3F));
  return UInt64.SIMD2Storage.subscript.modify;
}

uint64_t protocol witness for SIMDStorage.subscript.getter in conformance Int.SIMD64Storage@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = *(void *)(v2 + 8 * (result & 0x3F));
  return result;
}

__n128 Float16.SIMD2Storage._value.setter(__n128 result, __n128 a2)
{
  result.n128_u16[1] = a2.n128_u16[0];
  *uint64_t v2 = result.n128_u32[0];
  return result;
}

uint64_t (*Float16.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double Float16.SIMD2Storage.init()()
{
  return 0.0;
}

__int16 Float16.SIMD2Storage.subscript.getter@<H0>(char a1@<W0>, double a2@<D0>, __n128 a3@<Q1>)
{
  WORD1(a2) = a3.n128_u16[0];
  double v4 = a2;
  return *(_WORD *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF9 | (2 * (a1 & 3)));
}

__int16 key path getter for Float16.SIMD2Storage.subscript(_:) : Float16.SIMD2Storage@<H0>(uint64_t a1@<X0>, void *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result = *(_WORD *)(a1 + 2 * (*a2 & 1));
  *a3 = result;
  return result;
}

__int16 key path setter for Float16.SIMD2Storage.subscript(_:) : Float16.SIMD2Storage@<H0>(__int16 *a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>)
{
  __int16 result = *a1;
  *(_WORD *)(a2 + 2 * *a3) = *a1;
  return result;
}

uint64_t Float16.SIMD2Storage.subscript.setter(uint64_t result, __n128 a2)
{
  *(_WORD *)(v2 + 2 * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 1));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD2Storage@<H0>(char a1@<W0>, _WORD *a2@<X8>)
{
  __int16 result = *(_WORD *)(v2 + 2 * (a1 & 1));
  *a2 = result;
  return result;
}

__int16 protocol witness for SIMDStorage.subscript.setter in conformance Float16.SIMD2Storage@<H0>(__int16 *a1@<X0>, unsigned int a2@<W1>)
{
  __int16 result = *a1;
  *(_WORD *)(v2 + 2 * a2) = *a1;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD2Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 1));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 Float16.SIMD2Storage.subscript.modify@<H0>(unsigned int *a1@<X0>)
{
  __int16 result = *((_WORD *)a1 + 8);
  *(_WORD *)(*((void *)a1 + 1) + 2 * *a1) = result;
  return result;
}

void Float16.SIMD4Storage._value.setter(double a1)
{
  double *v1 = a1;
}

uint64_t (*Float16.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double Float16.SIMD4Storage.init()()
{
  return 0.0;
}

__int16 Float16.SIMD4Storage.subscript.getter@<H0>(char a1@<W0>, double a2@<D0>)
{
  double v3 = a2;
  return *(_WORD *)((unint64_t)&v3 & 0xFFFFFFFFFFFFFFF9 | (2 * (a1 & 3)));
}

__int16 key path getter for Float16.SIMD4Storage.subscript(_:) : Float16.SIMD4Storage@<H0>(uint64_t a1@<X0>, void *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result = *(_WORD *)(a1 + 2 * (*a2 & 3));
  *a3 = result;
  return result;
}

uint64_t Float16.SIMD4Storage.subscript.setter(uint64_t result, __n128 a2)
{
  *(_WORD *)(v2 + 2 * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 3));
  return Float16.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.init() in conformance Float16.SIMD4Storage@<D0>(void *a1@<X8>)
{
  double result = 0.0;
  *a1 = 0;
  return result;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD4Storage@<H0>(char a1@<W0>, _WORD *a2@<X8>)
{
  __int16 result = *(_WORD *)(v2 + 2 * (a1 & 3));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD4Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 3));
  return Float16.SIMD2Storage.subscript.modify;
}

void Float16.SIMD8Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*Float16.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double Float16.SIMD8Storage.init()()
{
  return 0.0;
}

__int16 Float16.SIMD8Storage.subscript.getter@<H0>(char a1@<W0>)
{
  return *(_WORD *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF1 | (2 * (a1 & 7)));
}

__int16 key path getter for Float16.SIMD8Storage.subscript(_:) : Float16.SIMD8Storage@<H0>(uint64_t a1@<X0>, void *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result = *(_WORD *)(a1 + 2 * (*a2 & 7));
  *a3 = result;
  return result;
}

uint64_t Float16.SIMD8Storage.subscript.setter(uint64_t result, __n128 a2)
{
  *(_WORD *)(v2 + 2 * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 7));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD8Storage@<H0>(char a1@<W0>, _WORD *a2@<X8>)
{
  __int16 result = *(_WORD *)(v2 + 2 * (a1 & 7));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD8Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 7));
  return Float16.SIMD2Storage.subscript.modify;
}

void Float16.SIMD16Storage._value.setter(__n128 a1, __n128 a2)
{
  *uint64_t v2 = a1;
  v2[1] = a2;
}

uint64_t (*Float16.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double Float16.SIMD16Storage.init()()
{
  return 0.0;
}

__int16 Float16.SIMD16Storage.subscript.getter@<H0>(char a1@<W0>)
{
  return *((_WORD *)&v2 + (a1 & 0xF));
}

__int16 key path getter for Float16.SIMD16Storage.subscript(_:) : Float16.SIMD16Storage@<H0>(uint64_t a1@<X0>, void *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result = *(_WORD *)(a1 + 2 * (*a2 & 0xFLL));
  *a3 = result;
  return result;
}

uint64_t Float16.SIMD16Storage.subscript.setter(uint64_t result, __n128 a2)
{
  *(_WORD *)(v2 + 2 * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0xF));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD16Storage@<H0>(char a1@<W0>, _WORD *a2@<X8>)
{
  __int16 result = *(_WORD *)(v2 + 2 * (a1 & 0xF));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD16Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0xF));
  return Float16.SIMD2Storage.subscript.modify;
}

void Float16.SIMD32Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  v4[2] = a3;
  v4[3] = a4;
  *double v4 = a1;
  v4[1] = a2;
}

uint64_t (*Float16.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double Float16.SIMD32Storage.init()()
{
  return 0.0;
}

__int16 Float16.SIMD32Storage.subscript.getter@<H0>(char a1@<W0>, __n128 a2@<Q0>, __n128 a3@<Q1>, __n128 a4@<Q2>, __n128 a5@<Q3>)
{
  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((_WORD *)v6 + (a1 & 0x1F));
}

__int16 key path getter for Float16.SIMD32Storage.subscript(_:) : Float16.SIMD32Storage@<H0>(uint64_t a1@<X0>, void *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result = *(_WORD *)(a1 + 2 * (*a2 & 0x1FLL));
  *a3 = result;
  return result;
}

uint64_t Float16.SIMD32Storage.subscript.setter(uint64_t result, __n128 a2)
{
  *(_WORD *)(v2 + 2 * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0x1F));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD32Storage@<H0>(char a1@<W0>, _WORD *a2@<X8>)
{
  __int16 result = *(_WORD *)(v2 + 2 * (a1 & 0x1F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD32Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0x1F));
  return Float16.SIMD2Storage.subscript.modify;
}

__n128 Float16.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  long long v3 = *(_OWORD *)(v1 + 16);
  long long v4 = *(_OWORD *)(v1 + 32);
  long long v5 = *(_OWORD *)(v1 + 48);
  long long v6 = *(_OWORD *)(v1 + 64);
  long long v7 = *(_OWORD *)(v1 + 80);
  long long v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Float16.SIMD64Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  long long v4 = *(_OWORD *)(a1 + 32);
  long long v5 = *(_OWORD *)(a1 + 48);
  long long v6 = *(_OWORD *)(a1 + 64);
  long long v7 = *(_OWORD *)(a1 + 80);
  long long v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Float16.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float16.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double Float16.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

__int16 Float16.SIMD64Storage.subscript.getter@<H0>(char a1@<W0>)
{
  return *(_WORD *)(v1 + 2 * (a1 & 0x3F));
}

__int16 key path getter for Float16.SIMD64Storage.subscript(_:) : Float16.SIMD64Storage@<H0>(uint64_t a1@<X0>, void *a2@<X1>, _WORD *a3@<X8>)
{
  __int16 result = *(_WORD *)(a1 + 2 * (*a2 & 0x3FLL));
  *a3 = result;
  return result;
}

uint64_t Float16.SIMD64Storage.subscript.setter(uint64_t result, __n128 a2)
{
  *(_WORD *)(v2 + 2 * result) = a2.n128_u16[0];
  return result;
}

uint64_t (*Float16.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0x3F));
  return Float16.SIMD2Storage.subscript.modify;
}

__int16 protocol witness for SIMDStorage.subscript.getter in conformance Float16.SIMD64Storage@<H0>(char a1@<W0>, _WORD *a2@<X8>)
{
  __int16 result = *(_WORD *)(v2 + 2 * (a1 & 0x3F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float16.SIMD64Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_WORD *)(a1 + 16) = *(_WORD *)(v2 + 2 * (a2 & 0x3F));
  return Float16.SIMD2Storage.subscript.modify;
}

void Float.SIMD2Storage._value.setter(double a1)
{
  double *v1 = a1;
}

uint64_t (*Float.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double Float.SIMD2Storage.init()()
{
  return 0.0;
}

float Float.SIMD2Storage.subscript.getter(char a1, double a2)
{
  double v3 = a2;
  return *(float *)((unint64_t)&v3 & 0xFFFFFFFFFFFFFFFBLL | (4 * (a1 & 1)));
}

float key path getter for Float.SIMD2Storage.subscript(_:) : Float.SIMD2Storage@<S0>(uint64_t a1@<X0>, void *a2@<X1>, float *a3@<X8>)
{
  float result = *(float *)(a1 + 4 * (*a2 & 1));
  *a3 = result;
  return result;
}

float key path setter for Float.SIMD2Storage.subscript(_:) : Float.SIMD2Storage(float *a1, uint64_t a2, unsigned int *a3)
{
  float result = *a1;
  *(float *)(a2 + 4 * *a3) = *a1;
  return result;
}

uint64_t Float.SIMD2Storage.subscript.setter(uint64_t result, float a2)
{
  *(float *)(v2 + 4 * result) = a2;
  return result;
}

uint64_t (*Float.SIMD2Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 1));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD2Storage@<S0>(char a1@<W0>, float *a2@<X8>)
{
  float result = *(float *)(v2 + 4 * (a1 & 1));
  *a2 = result;
  return result;
}

float protocol witness for SIMDStorage.subscript.setter in conformance Float.SIMD2Storage(float *a1, unsigned int a2)
{
  float result = *a1;
  *(float *)(v2 + 4 * a2) = *a1;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD2Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 1));
  return Float.SIMD2Storage.subscript.modify;
}

float Float.SIMD2Storage.subscript.modify(float *a1)
{
  float result = a1[4];
  *(float *)(*((void *)a1 + 1) + 4 * *(unsigned int *)a1) = result;
  return result;
}

void Float.SIMD4Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*Float.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double Float.SIMD4Storage.init()()
{
  return 0.0;
}

float Float.SIMD4Storage.subscript.getter(char a1)
{
  return *(float *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF3 | (4 * (a1 & 3)));
}

float key path getter for Float.SIMD4Storage.subscript(_:) : Float.SIMD4Storage@<S0>(uint64_t a1@<X0>, void *a2@<X1>, float *a3@<X8>)
{
  float result = *(float *)(a1 + 4 * (*a2 & 3));
  *a3 = result;
  return result;
}

uint64_t Float.SIMD4Storage.subscript.setter(uint64_t result, float a2)
{
  *(float *)(v2 + 4 * result) = a2;
  return result;
}

uint64_t (*Float.SIMD4Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 3));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD4Storage@<S0>(char a1@<W0>, float *a2@<X8>)
{
  float result = *(float *)(v2 + 4 * (a1 & 3));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD4Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 3));
  return Float.SIMD2Storage.subscript.modify;
}

void Float.SIMD8Storage._value.setter(__n128 a1, __n128 a2)
{
  *uint64_t v2 = a1;
  v2[1] = a2;
}

uint64_t (*Float.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double Float.SIMD8Storage.init()()
{
  return 0.0;
}

float Float.SIMD8Storage.subscript.getter(char a1)
{
  return *((float *)&v2 + (a1 & 7));
}

float key path getter for Float.SIMD8Storage.subscript(_:) : Float.SIMD8Storage@<S0>(uint64_t a1@<X0>, void *a2@<X1>, float *a3@<X8>)
{
  float result = *(float *)(a1 + 4 * (*a2 & 7));
  *a3 = result;
  return result;
}

uint64_t Float.SIMD8Storage.subscript.setter(uint64_t result, float a2)
{
  *(float *)(v2 + 4 * result) = a2;
  return result;
}

uint64_t (*Float.SIMD8Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 7));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD8Storage@<S0>(char a1@<W0>, float *a2@<X8>)
{
  float result = *(float *)(v2 + 4 * (a1 & 7));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD8Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 7));
  return Float.SIMD2Storage.subscript.modify;
}

void Float.SIMD16Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  v4[2] = a3;
  v4[3] = a4;
  *long long v4 = a1;
  v4[1] = a2;
}

uint64_t (*Float.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double Float.SIMD16Storage.init()()
{
  return 0.0;
}

float Float.SIMD16Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((float *)v6 + (a1 & 0xF));
}

float key path getter for Float.SIMD16Storage.subscript(_:) : Float.SIMD16Storage@<S0>(uint64_t a1@<X0>, void *a2@<X1>, float *a3@<X8>)
{
  float result = *(float *)(a1 + 4 * (*a2 & 0xFLL));
  *a3 = result;
  return result;
}

uint64_t Float.SIMD16Storage.subscript.setter(uint64_t result, float a2)
{
  *(float *)(v2 + 4 * result) = a2;
  return result;
}

uint64_t (*Float.SIMD16Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0xF));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD16Storage@<S0>(char a1@<W0>, float *a2@<X8>)
{
  float result = *(float *)(v2 + 4 * (a1 & 0xF));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD16Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0xF));
  return Float.SIMD2Storage.subscript.modify;
}

__n128 Float.SIMD32Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  long long v3 = *(_OWORD *)(v1 + 16);
  long long v4 = *(_OWORD *)(v1 + 32);
  long long v5 = *(_OWORD *)(v1 + 48);
  long long v6 = *(_OWORD *)(v1 + 64);
  long long v7 = *(_OWORD *)(v1 + 80);
  long long v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Float.SIMD32Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  long long v4 = *(_OWORD *)(a1 + 32);
  long long v5 = *(_OWORD *)(a1 + 48);
  long long v6 = *(_OWORD *)(a1 + 64);
  long long v7 = *(_OWORD *)(a1 + 80);
  long long v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Float.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double Float.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

float Float.SIMD32Storage.subscript.getter(char a1)
{
  return *(float *)(v1 + 4 * (a1 & 0x1F));
}

float key path getter for Float.SIMD32Storage.subscript(_:) : Float.SIMD32Storage@<S0>(uint64_t a1@<X0>, void *a2@<X1>, float *a3@<X8>)
{
  float result = *(float *)(a1 + 4 * (*a2 & 0x1FLL));
  *a3 = result;
  return result;
}

uint64_t Float.SIMD32Storage.subscript.setter(uint64_t result, float a2)
{
  *(float *)(v2 + 4 * result) = a2;
  return result;
}

uint64_t (*Float.SIMD32Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x1F));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD32Storage@<S0>(char a1@<W0>, float *a2@<X8>)
{
  float result = *(float *)(v2 + 4 * (a1 & 0x1F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD32Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x1F));
  return Float.SIMD2Storage.subscript.modify;
}

__n128 Float.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  long long v3 = *(_OWORD *)(v1 + 16);
  long long v4 = *(_OWORD *)(v1 + 32);
  long long v5 = *(_OWORD *)(v1 + 48);
  long long v6 = *(_OWORD *)(v1 + 64);
  long long v7 = *(_OWORD *)(v1 + 80);
  long long v8 = *(_OWORD *)(v1 + 96);
  long long v9 = *(_OWORD *)(v1 + 112);
  long long v10 = *(_OWORD *)(v1 + 128);
  long long v11 = *(_OWORD *)(v1 + 144);
  long long v12 = *(_OWORD *)(v1 + 160);
  long long v13 = *(_OWORD *)(v1 + 176);
  long long v14 = *(_OWORD *)(v1 + 192);
  long long v15 = *(_OWORD *)(v1 + 208);
  long long v16 = *(_OWORD *)(v1 + 240);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(v1 + 224);
  *(_OWORD *)(a1 + 240) = v16;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Float.SIMD64Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  long long v4 = *(_OWORD *)(a1 + 32);
  long long v5 = *(_OWORD *)(a1 + 48);
  long long v6 = *(_OWORD *)(a1 + 64);
  long long v7 = *(_OWORD *)(a1 + 80);
  long long v8 = *(_OWORD *)(a1 + 96);
  long long v9 = *(_OWORD *)(a1 + 112);
  long long v10 = *(_OWORD *)(a1 + 128);
  long long v11 = *(_OWORD *)(a1 + 144);
  long long v12 = *(_OWORD *)(a1 + 160);
  long long v13 = *(_OWORD *)(a1 + 176);
  long long v14 = *(_OWORD *)(a1 + 192);
  long long v15 = *(_OWORD *)(a1 + 208);
  long long v16 = *(_OWORD *)(a1 + 240);
  *(_OWORD *)(v1 + 224) = *(_OWORD *)(a1 + 224);
  *(_OWORD *)(v1 + 240) = v16;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Float.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Float.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double Float.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

float Float.SIMD64Storage.subscript.getter(char a1)
{
  return *(float *)(v1 + 4 * (a1 & 0x3F));
}

float key path getter for Float.SIMD64Storage.subscript(_:) : Float.SIMD64Storage@<S0>(uint64_t a1@<X0>, void *a2@<X1>, float *a3@<X8>)
{
  float result = *(float *)(a1 + 4 * (*a2 & 0x3FLL));
  *a3 = result;
  return result;
}

uint64_t Float.SIMD64Storage.subscript.setter(uint64_t result, float a2)
{
  *(float *)(v2 + 4 * result) = a2;
  return result;
}

uint64_t (*Float.SIMD64Storage.subscript.modify(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x3F));
  return Float.SIMD2Storage.subscript.modify;
}

float protocol witness for SIMDStorage.subscript.getter in conformance Float.SIMD64Storage@<S0>(char a1@<W0>, float *a2@<X8>)
{
  float result = *(float *)(v2 + 4 * (a1 & 0x3F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Float.SIMD64Storage(uint64_t a1, uint64_t a2))()
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v2 + 4 * (a2 & 0x3F));
  return Float.SIMD2Storage.subscript.modify;
}

void Double.SIMD2Storage._value.setter(__n128 a1)
{
  __n128 *v1 = a1;
}

uint64_t (*Double.SIMD2Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD2Storage.scalarCount.getter()
{
  return 2;
}

double Double.SIMD2Storage.init()()
{
  return 0.0;
}

double Double.SIMD2Storage.subscript.getter(char a1)
{
  return *(double *)((unint64_t)&v2 & 0xFFFFFFFFFFFFFFF7 | (8 * (a1 & 1)));
}

double key path getter for Double.SIMD2Storage.subscript(_:) : Double.SIMD2Storage@<D0>(uint64_t a1@<X0>, void *a2@<X1>, double *a3@<X8>)
{
  double result = *(double *)(a1 + 8 * (*a2 & 1));
  *a3 = result;
  return result;
}

double key path setter for Double.SIMD2Storage.subscript(_:) : Double.SIMD2Storage(double *a1, uint64_t a2, unsigned int *a3)
{
  double result = *a1;
  *(double *)(a2 + 8 * *a3) = *a1;
  return result;
}

uint64_t Double.SIMD2Storage.subscript.setter(uint64_t result, double a2)
{
  *(double *)(v2 + 8 * result) = a2;
  return result;
}

uint64_t (*Double.SIMD2Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 1));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD2Storage@<D0>(char a1@<W0>, double *a2@<X8>)
{
  double result = *(double *)(v2 + 8 * (a1 & 1));
  *a2 = result;
  return result;
}

double protocol witness for SIMDStorage.subscript.setter in conformance Double.SIMD2Storage(double *a1, unsigned int a2)
{
  double result = *a1;
  *(double *)(v2 + 8 * a2) = *a1;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD2Storage(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 1));
  return Double.SIMD2Storage.subscript.modify;
}

double Double.SIMD2Storage.subscript.modify(uint64_t a1)
{
  double result = *(double *)a1;
  *(void *)(*(void *)(a1 + 16) + 8 * *(unsigned int *)(a1 + 8)) = *(void *)a1;
  return result;
}

void Double.SIMD4Storage._value.setter(__n128 a1, __n128 a2)
{
  *uint64_t v2 = a1;
  v2[1] = a2;
}

uint64_t (*Double.SIMD4Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD4Storage.scalarCount.getter()
{
  return 4;
}

double Double.SIMD4Storage.init()()
{
  return 0.0;
}

double Double.SIMD4Storage.subscript.getter(char a1)
{
  return *((double *)&v2 + (a1 & 3));
}

double key path getter for Double.SIMD4Storage.subscript(_:) : Double.SIMD4Storage@<D0>(uint64_t a1@<X0>, void *a2@<X1>, double *a3@<X8>)
{
  double result = *(double *)(a1 + 8 * (*a2 & 3));
  *a3 = result;
  return result;
}

uint64_t Double.SIMD4Storage.subscript.setter(uint64_t result, double a2)
{
  *(double *)(v2 + 8 * result) = a2;
  return result;
}

uint64_t (*Double.SIMD4Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 3));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD4Storage@<D0>(char a1@<W0>, double *a2@<X8>)
{
  double result = *(double *)(v2 + 8 * (a1 & 3));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD4Storage(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 3));
  return Double.SIMD2Storage.subscript.modify;
}

void Double.SIMD8Storage._value.setter(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  v4[2] = a3;
  v4[3] = a4;
  *long long v4 = a1;
  v4[1] = a2;
}

uint64_t (*Double.SIMD8Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD8Storage.scalarCount.getter()
{
  return 8;
}

double Double.SIMD8Storage.init()()
{
  return 0.0;
}

double Double.SIMD8Storage.subscript.getter(char a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  v6[2] = a4;
  v6[3] = a5;
  v6[0] = a2;
  v6[1] = a3;
  return *((double *)v6 + (a1 & 7));
}

double key path getter for Double.SIMD8Storage.subscript(_:) : Double.SIMD8Storage@<D0>(uint64_t a1@<X0>, void *a2@<X1>, double *a3@<X8>)
{
  double result = *(double *)(a1 + 8 * (*a2 & 7));
  *a3 = result;
  return result;
}

uint64_t Double.SIMD8Storage.subscript.setter(uint64_t result, double a2)
{
  *(double *)(v2 + 8 * result) = a2;
  return result;
}

uint64_t (*Double.SIMD8Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 7));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD8Storage@<D0>(char a1@<W0>, double *a2@<X8>)
{
  double result = *(double *)(v2 + 8 * (a1 & 7));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD8Storage(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 7));
  return Double.SIMD2Storage.subscript.modify;
}

__n128 Double.SIMD16Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  long long v3 = *(_OWORD *)(v1 + 16);
  long long v4 = *(_OWORD *)(v1 + 32);
  long long v5 = *(_OWORD *)(v1 + 48);
  long long v6 = *(_OWORD *)(v1 + 64);
  long long v7 = *(_OWORD *)(v1 + 80);
  long long v8 = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(v1 + 96);
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Double.SIMD16Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  long long v4 = *(_OWORD *)(a1 + 32);
  long long v5 = *(_OWORD *)(a1 + 48);
  long long v6 = *(_OWORD *)(a1 + 64);
  long long v7 = *(_OWORD *)(a1 + 80);
  long long v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v1 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v1 + 112) = v8;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Double.SIMD16Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD16Storage.scalarCount.getter()
{
  return 16;
}

double Double.SIMD16Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

double Double.SIMD16Storage.subscript.getter(char a1)
{
  return *(double *)(v1 + 8 * (a1 & 0xF));
}

double key path getter for Double.SIMD16Storage.subscript(_:) : Double.SIMD16Storage@<D0>(uint64_t a1@<X0>, void *a2@<X1>, double *a3@<X8>)
{
  double result = *(double *)(a1 + 8 * (*a2 & 0xFLL));
  *a3 = result;
  return result;
}

uint64_t Double.SIMD16Storage.subscript.setter(uint64_t result, double a2)
{
  *(double *)(v2 + 8 * result) = a2;
  return result;
}

uint64_t (*Double.SIMD16Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0xF));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD16Storage@<D0>(char a1@<W0>, double *a2@<X8>)
{
  double result = *(double *)(v2 + 8 * (a1 & 0xF));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD16Storage(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0xF));
  return Double.SIMD2Storage.subscript.modify;
}

__n128 Double.SIMD32Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  long long v3 = *(_OWORD *)(v1 + 16);
  long long v4 = *(_OWORD *)(v1 + 32);
  long long v5 = *(_OWORD *)(v1 + 48);
  long long v6 = *(_OWORD *)(v1 + 64);
  long long v7 = *(_OWORD *)(v1 + 80);
  long long v8 = *(_OWORD *)(v1 + 96);
  long long v9 = *(_OWORD *)(v1 + 112);
  long long v10 = *(_OWORD *)(v1 + 128);
  long long v11 = *(_OWORD *)(v1 + 144);
  long long v12 = *(_OWORD *)(v1 + 160);
  long long v13 = *(_OWORD *)(v1 + 176);
  long long v14 = *(_OWORD *)(v1 + 192);
  long long v15 = *(_OWORD *)(v1 + 208);
  long long v16 = *(_OWORD *)(v1 + 240);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(v1 + 224);
  *(_OWORD *)(a1 + 240) = v16;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Double.SIMD32Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  long long v4 = *(_OWORD *)(a1 + 32);
  long long v5 = *(_OWORD *)(a1 + 48);
  long long v6 = *(_OWORD *)(a1 + 64);
  long long v7 = *(_OWORD *)(a1 + 80);
  long long v8 = *(_OWORD *)(a1 + 96);
  long long v9 = *(_OWORD *)(a1 + 112);
  long long v10 = *(_OWORD *)(a1 + 128);
  long long v11 = *(_OWORD *)(a1 + 144);
  long long v12 = *(_OWORD *)(a1 + 160);
  long long v13 = *(_OWORD *)(a1 + 176);
  long long v14 = *(_OWORD *)(a1 + 192);
  long long v15 = *(_OWORD *)(a1 + 208);
  long long v16 = *(_OWORD *)(a1 + 240);
  *(_OWORD *)(v1 + 224) = *(_OWORD *)(a1 + 224);
  *(_OWORD *)(v1 + 240) = v16;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Double.SIMD32Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD32Storage.scalarCount.getter()
{
  return 32;
}

double Double.SIMD32Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

double Double.SIMD32Storage.subscript.getter(char a1)
{
  return *(double *)(v1 + 8 * (a1 & 0x1F));
}

double key path getter for Double.SIMD32Storage.subscript(_:) : Double.SIMD32Storage@<D0>(uint64_t a1@<X0>, void *a2@<X1>, double *a3@<X8>)
{
  double result = *(double *)(a1 + 8 * (*a2 & 0x1FLL));
  *a3 = result;
  return result;
}

uint64_t Double.SIMD32Storage.subscript.setter(uint64_t result, double a2)
{
  *(double *)(v2 + 8 * result) = a2;
  return result;
}

uint64_t (*Double.SIMD32Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x1F));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD32Storage@<D0>(char a1@<W0>, double *a2@<X8>)
{
  double result = *(double *)(v2 + 8 * (a1 & 0x1F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD32Storage(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x1F));
  return Double.SIMD2Storage.subscript.modify;
}

__n128 Double.SIMD64Storage._value.getter@<Q0>(uint64_t a1@<X8>)
{
  __n128 result = *(__n128 *)v1;
  long long v3 = *(_OWORD *)(v1 + 16);
  long long v4 = *(_OWORD *)(v1 + 32);
  long long v5 = *(_OWORD *)(v1 + 48);
  long long v6 = *(_OWORD *)(v1 + 64);
  long long v7 = *(_OWORD *)(v1 + 80);
  long long v8 = *(_OWORD *)(v1 + 96);
  long long v9 = *(_OWORD *)(v1 + 112);
  long long v10 = *(_OWORD *)(v1 + 128);
  long long v11 = *(_OWORD *)(v1 + 144);
  long long v12 = *(_OWORD *)(v1 + 160);
  long long v13 = *(_OWORD *)(v1 + 176);
  long long v14 = *(_OWORD *)(v1 + 192);
  long long v15 = *(_OWORD *)(v1 + 208);
  long long v16 = *(_OWORD *)(v1 + 224);
  long long v17 = *(_OWORD *)(v1 + 240);
  long long v18 = *(_OWORD *)(v1 + 256);
  long long v19 = *(_OWORD *)(v1 + 272);
  long long v20 = *(_OWORD *)(v1 + 288);
  long long v21 = *(_OWORD *)(v1 + 304);
  long long v22 = *(_OWORD *)(v1 + 320);
  long long v23 = *(_OWORD *)(v1 + 336);
  long long v24 = *(_OWORD *)(v1 + 352);
  long long v25 = *(_OWORD *)(v1 + 368);
  long long v26 = *(_OWORD *)(v1 + 384);
  long long v27 = *(_OWORD *)(v1 + 400);
  long long v28 = *(_OWORD *)(v1 + 416);
  long long v29 = *(_OWORD *)(v1 + 432);
  long long v30 = *(_OWORD *)(v1 + 448);
  long long v31 = *(_OWORD *)(v1 + 464);
  long long v32 = *(_OWORD *)(v1 + 496);
  *(_OWORD *)(a1 + 480) = *(_OWORD *)(v1 + 480);
  *(_OWORD *)(a1 + 496) = v32;
  *(_OWORD *)(a1 + 448) = v30;
  *(_OWORD *)(a1 + 464) = v31;
  *(_OWORD *)(a1 + 416) = v28;
  *(_OWORD *)(a1 + 432) = v29;
  *(_OWORD *)(a1 + 384) = v26;
  *(_OWORD *)(a1 + 400) = v27;
  *(_OWORD *)(a1 + 352) = v24;
  *(_OWORD *)(a1 + 368) = v25;
  *(_OWORD *)(a1 + 320) = v22;
  *(_OWORD *)(a1 + 336) = v23;
  *(_OWORD *)(a1 + 288) = v20;
  *(_OWORD *)(a1 + 304) = v21;
  *(_OWORD *)(a1 + 256) = v18;
  *(_OWORD *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 240) = v17;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 Double.SIMD64Storage._value.setter(uint64_t a1)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  long long v4 = *(_OWORD *)(a1 + 32);
  long long v5 = *(_OWORD *)(a1 + 48);
  long long v6 = *(_OWORD *)(a1 + 64);
  long long v7 = *(_OWORD *)(a1 + 80);
  long long v8 = *(_OWORD *)(a1 + 96);
  long long v9 = *(_OWORD *)(a1 + 112);
  long long v10 = *(_OWORD *)(a1 + 128);
  long long v11 = *(_OWORD *)(a1 + 144);
  long long v12 = *(_OWORD *)(a1 + 160);
  long long v13 = *(_OWORD *)(a1 + 176);
  long long v14 = *(_OWORD *)(a1 + 192);
  long long v15 = *(_OWORD *)(a1 + 208);
  long long v16 = *(_OWORD *)(a1 + 224);
  long long v17 = *(_OWORD *)(a1 + 240);
  long long v18 = *(_OWORD *)(a1 + 256);
  long long v19 = *(_OWORD *)(a1 + 272);
  long long v20 = *(_OWORD *)(a1 + 288);
  long long v21 = *(_OWORD *)(a1 + 304);
  long long v22 = *(_OWORD *)(a1 + 320);
  long long v23 = *(_OWORD *)(a1 + 336);
  long long v24 = *(_OWORD *)(a1 + 352);
  long long v25 = *(_OWORD *)(a1 + 368);
  long long v26 = *(_OWORD *)(a1 + 384);
  long long v27 = *(_OWORD *)(a1 + 400);
  long long v28 = *(_OWORD *)(a1 + 416);
  long long v29 = *(_OWORD *)(a1 + 432);
  long long v30 = *(_OWORD *)(a1 + 448);
  long long v31 = *(_OWORD *)(a1 + 464);
  long long v32 = *(_OWORD *)(a1 + 496);
  *(_OWORD *)(v1 + 480) = *(_OWORD *)(a1 + 480);
  *(_OWORD *)(v1 + 496) = v32;
  *(_OWORD *)(v1 + 448) = v30;
  *(_OWORD *)(v1 + 464) = v31;
  *(_OWORD *)(v1 + 416) = v28;
  *(_OWORD *)(v1 + 432) = v29;
  *(_OWORD *)(v1 + 384) = v26;
  *(_OWORD *)(v1 + 400) = v27;
  *(_OWORD *)(v1 + 352) = v24;
  *(_OWORD *)(v1 + 368) = v25;
  *(_OWORD *)(v1 + 320) = v22;
  *(_OWORD *)(v1 + 336) = v23;
  *(_OWORD *)(v1 + 288) = v20;
  *(_OWORD *)(v1 + 304) = v21;
  *(_OWORD *)(v1 + 256) = v18;
  *(_OWORD *)(v1 + 272) = v19;
  *(_OWORD *)(v1 + 224) = v16;
  *(_OWORD *)(v1 + 240) = v17;
  *(_OWORD *)(v1 + 192) = v14;
  *(_OWORD *)(v1 + 208) = v15;
  *(_OWORD *)(v1 + 160) = v12;
  *(_OWORD *)(v1 + 176) = v13;
  *(_OWORD *)(v1 + 128) = v10;
  *(_OWORD *)(v1 + 144) = v11;
  *(_OWORD *)(v1 + 96) = v8;
  *(_OWORD *)(v1 + 112) = v9;
  *(_OWORD *)(v1 + 64) = v6;
  *(_OWORD *)(v1 + 80) = v7;
  *(_OWORD *)(v1 + 32) = v4;
  *(_OWORD *)(v1 + 48) = v5;
  *(__n128 *)uint64_t v1 = result;
  *(_OWORD *)(v1 + 16) = v3;
  return result;
}

uint64_t (*Double.SIMD64Storage._value.modify())()
{
  return EnumeratedSequence._base.modify;
}

uint64_t Double.SIMD64Storage.scalarCount.getter()
{
  return 64;
}

double Double.SIMD64Storage.init()@<D0>(_OWORD *a1@<X8>)
{
  double result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

double Double.SIMD64Storage.subscript.getter(char a1)
{
  return *(double *)(v1 + 8 * (a1 & 0x3F));
}

double key path getter for Double.SIMD64Storage.subscript(_:) : Double.SIMD64Storage@<D0>(uint64_t a1@<X0>, void *a2@<X1>, double *a3@<X8>)
{
  double result = *(double *)(a1 + 8 * (*a2 & 0x3FLL));
  *a3 = result;
  return result;
}

uint64_t Double.SIMD64Storage.subscript.setter(uint64_t result, double a2)
{
  *(double *)(v2 + 8 * result) = a2;
  return result;
}

uint64_t (*Double.SIMD64Storage.subscript.modify(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x3F));
  return Double.SIMD2Storage.subscript.modify;
}

double protocol witness for SIMDStorage.subscript.getter in conformance Double.SIMD64Storage@<D0>(char a1@<W0>, double *a2@<X8>)
{
  double result = *(double *)(v2 + 8 * (a1 & 0x3F));
  *a2 = result;
  return result;
}

uint64_t (*protocol witness for SIMDStorage.subscript.modify in conformance Double.SIMD64Storage(void *a1, uint64_t a2))()
{
  a1[1] = a2;
  a1[2] = v2;
  *a1 = *(void *)(v2 + 8 * (a2 & 0x3F));
  return Double.SIMD2Storage.subscript.modify;
}

__int16 *specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>(__int16 *result@<X0>, uint64_t a2@<X8>)
{
  __int16 v2 = *result;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 40) = &type metadata for UInt16;
  *(_WORD *)(a2 + 16) = v2;
  return result;
}

char *specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  char v2 = *result;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 40) = &type metadata for UInt8;
  *(unsigned char *)(a2 + 16) = v2;
  return result;
}

int *specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>(int *result@<X0>, uint64_t a2@<X8>)
{
  int v2 = *result;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 40) = &type metadata for Unicode.Scalar;
  *(_DWORD *)(a2 + 16) = v2;
  return result;
}

void specialized closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[5] = &unk_1ECA06270;
}

unint64_t specialized String.UTF16View._foreignIndex(after:)(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFFF0000) + 65544;
}

unint64_t specialized String.UTF16View._foreignIndex(before:)(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFFF0000) - 65528;
}

char *specialized _ArrayBuffer._copyContents(subRange:initializing:)(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if (v4 < 0) {
    goto LABEL_7;
  }
  long long v5 = (char *)(a4 + 8 * a1 + 32);
  size_t v6 = 8 * v4;
  long long v7 = &__dst[v6];
  if (v5 < &__dst[v6] && &v5[v6] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  }
  memcpy(__dst, v5, v6);
  return v7;
}

{
  size_t v4;
  char *v5;
  char *v6;

  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if ((v4 & 0x8000000000000000) != 0) {
    goto LABEL_7;
  }
  long long v5 = (char *)(a4 + a1 + 32);
  size_t v6 = &__dst[v4];
  if (v5 < &__dst[v4] && &v5[v4] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  }
  memcpy(__dst, v5, v4);
  return v6;
}

{
  uint64_t v4;
  char *v5;
  char *v6;

  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if (v4 < 0) {
    goto LABEL_7;
  }
  long long v5 = (char *)(a4 + 32 * a1 + 32);
  size_t v6 = &__dst[32 * v4];
  if (v5 < v6 && &v5[32 * v4] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  }
  swift_arrayInitWithCopy(__dst, v5, v4, (unint64_t *)&unk_1ECA06310);
  return v6;
}

{
  uint64_t v4;
  char *v5;
  size_t v6;
  char *v7;

  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if (v4 < 0) {
    goto LABEL_7;
  }
  long long v5 = (char *)(a4 + 16 * a1 + 32);
  size_t v6 = 16 * v4;
  long long v7 = &__dst[v6];
  if (v5 < &__dst[v6] && &v5[v6] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  }
  memcpy(__dst, v5, v6);
  return v7;
}

{
  uint64_t v4;
  char *v5;
  char *v6;

  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if (v4 < 0) {
    goto LABEL_7;
  }
  long long v5 = (char *)(a4 + 8 * a1 + 32);
  size_t v6 = &__dst[8 * v4];
  if (v5 < v6 && &v5[8 * v4] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  }
  swift_arrayInitWithCopy(__dst, v5, v4, qword_1ECA028E0);
  return v6;
}

unint64_t specialized Unicode._InternalNFC.Iterator.composeHangul(_:and:)(int a1, unsigned int a2)
{
  BOOL v2 = (a1 - 4352) <= 0x12 && a2 >= 0x1161;
  if (v2 && a2 >> 1 <= 0x8BA)
  {
    unsigned __int8 v3 = 0;
    unsigned int v4 = 28 * a2 + 588 * a1 - 2639516;
  }
  else
  {
    unsigned int v4 = 0;
    unsigned __int8 v3 = 1;
    if ((a1 - 44032) >> 2 <= 0xAE8
      && a2 >> 3 >= 0x235
      && a2 <= 0x11C2
      && (unsigned __int16)(a1 + 21504) == 28 * ((153391690 * (unint64_t)(unsigned __int16)(a1 + 21504)) >> 32))
    {
      unsigned __int8 v3 = 0;
      unsigned int v4 = a1 + a2 - 4519;
    }
  }
  return v4 | ((unint64_t)v3 << 32);
}

int64_t specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(char *a1, size_t a2, int64_t a3, char a4)
{
  unint64_t v6 = a2 | 0xC000000000000000;
  if ((a4 & 1) == 0) {
    unint64_t v6 = a2;
  }
  uint64_t v7 = v6 | 0x3000000000000000;
  int64_t v8 = _allocateStringStorage(codeUnitCapacity:)(a3);
  *(void *)(v8 + 16) = v9;
  *(void *)(v8 + 24) = v7;
  if (v9 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
    uint64_t v7 = *(void *)(v8 + 24);
  }
  *(unsigned char *)(v8 + 32 + (v7 & 0xFFFFFFFFFFFFLL)) = 0;
  specialized UnsafeMutablePointer.initialize(from:count:)(a1, a2, (char *)(v8 + 32));
  return v8;
}

uint64_t specialized static String._uncheckedFromUTF8(_:isASCII:)(uint8x16_t *a1, uint64_t a2, char a3)
{
  if (!a2) {
    return 0;
  }
  if (a2 > 15) {
    return *(uint64_t *)(specialized static __StringStorage.create(initializingFrom:codeUnitCapacity:isASCII:)(a1->i8, a2, a2, a3 & 1)+ 24);
  }
  uint64_t v4 = a2 - 8;
  if (a2 >= 8) {
    unint64_t v5 = 8;
  }
  else {
    unint64_t v5 = a2;
  }
  if ((v5 & 0x8000000000000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if (v5 < 8)
  {
    unint64_t v6 = 0;
    int8x8_t v3 = 0;
    unint64_t v7 = 0;
    goto LABEL_19;
  }
  if (v5 >= 0x10)
  {
    unint64_t v6 = v5 & 0xFFFFFFFFFFFFFFF0;
    uint16x8_t v31 = vmovl_high_u8(*a1);
    int8x16_t v32 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v31.i8);
    uint16x8_t v33 = vmovl_u8(*(uint8x8_t *)a1->i8);
    int8x16_t v34 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v33.i8);
    int8x16_t v35 = (int8x16_t)vmovl_high_u16(v31);
    int8x8_t v36 = (int8x8_t)vextq_s8(v35, v35, 8uLL).u64[0];
    int8x16_t v37 = (int8x16_t)vmovl_high_u16(v33);
    int8x8_t v38 = (int8x8_t)vextq_s8(v37, v37, 8uLL).u64[0];
    *(int8x8_t *)v37.i8 = vorr_s8(*(int8x8_t *)v37.i8, *(int8x8_t *)v35.i8);
    v39.i64[0] = v37.u32[0];
    v39.i64[1] = v37.u32[1];
    int8x16_t v40 = (int8x16_t)vshlq_u64(v39, (uint64x2_t)xmmword_18162AD00);
    *(int8x8_t *)v35.i8 = vorr_s8(*(int8x8_t *)v34.i8, *(int8x8_t *)v32.i8);
    v39.i64[0] = v35.u32[0];
    v39.i64[1] = v35.u32[1];
    int8x16_t v41 = vorrq_s8((int8x16_t)vshlq_u64(v39, (uint64x2_t)xmmword_18162ACF0), v40);
    *(int8x8_t *)v35.i8 = vorr_s8(v38, v36);
    v39.i64[0] = v35.u32[0];
    v39.i64[1] = v35.u32[1];
    int8x16_t v42 = (int8x16_t)vshlq_u64(v39, (uint64x2_t)xmmword_18162ACE0);
    *(int8x8_t *)v32.i8 = vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
    v39.i64[0] = v32.u32[0];
    v39.i64[1] = v32.u32[1];
    int8x16_t v43 = vorrq_s8(v41, vorrq_s8((int8x16_t)vshlq_u64(v39, (uint64x2_t)xmmword_18162ACD0), v42));
    int8x8_t v3 = vorr_s8(*(int8x8_t *)v43.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL));
    if (v5 == (v5 & 0xFFFFFFFFFFFFFFF0)) {
      goto LABEL_21;
    }
    unint64_t v7 = 8 * v6;
    if ((v5 & 8) == 0) {
      goto LABEL_19;
    }
  }
  else
  {
    int8x8_t v3 = 0;
    unint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  unint64_t v8 = v6;
  int64x2_t v9 = vdupq_n_s64(v7);
  unint64_t v6 = v5 & 0xFFFFFFFFFFFFFFF8;
  unint64_t v7 = 8 * (v5 & 0xFFFFFFFFFFFFFFF8);
  int8x16_t v10 = 0uLL;
  int8x16_t v11 = (int8x16_t)(unint64_t)v3;
  int64x2_t v12 = vaddq_s64(v9, (int64x2_t)xmmword_18162ACE0);
  int64x2_t v13 = vaddq_s64(v9, (int64x2_t)xmmword_18162AD00);
  int64x2_t v14 = vaddq_s64(v9, (int64x2_t)xmmword_18162ACD0);
  int64x2_t v15 = vaddq_s64(v9, (int64x2_t)xmmword_18162ACF0);
  long long v16 = (uint8x8_t *)&a1->i8[v8];
  int8x16_t v17 = (int8x16_t)vdupq_n_s64(0x38uLL);
  unint64_t v18 = v8 - (v5 & 0xFFFFFFFFFFFFFFF8);
  int64x2_t v19 = vdupq_n_s64(0x40uLL);
  int8x16_t v20 = 0uLL;
  int8x16_t v21 = 0uLL;
  do
  {
    uint8x8_t v22 = *v16++;
    uint16x8_t v23 = vmovl_u8(v22);
    uint32x4_t v24 = vmovl_high_u16(v23);
    v25.i64[0] = v24.u32[2];
    v25.i64[1] = v24.u32[3];
    uint64x2_t v26 = v25;
    v25.i64[0] = v24.u32[0];
    v25.i64[1] = v24.u32[1];
    uint64x2_t v27 = v25;
    uint32x4_t v28 = vmovl_u16(*(uint16x4_t *)v23.i8);
    v25.i64[0] = v28.u32[2];
    v25.i64[1] = v28.u32[3];
    uint64x2_t v29 = v25;
    v25.i64[0] = v28.u32[0];
    v25.i64[1] = v28.u32[1];
    int8x16_t v21 = vorrq_s8((int8x16_t)vshlq_u64(v26, (uint64x2_t)vandq_s8((int8x16_t)v12, v17)), v21);
    int8x16_t v20 = vorrq_s8((int8x16_t)vshlq_u64(v27, (uint64x2_t)vandq_s8((int8x16_t)v13, v17)), v20);
    int8x16_t v10 = vorrq_s8((int8x16_t)vshlq_u64(v29, (uint64x2_t)vandq_s8((int8x16_t)v14, v17)), v10);
    int8x16_t v11 = vorrq_s8((int8x16_t)vshlq_u64(v25, (uint64x2_t)vandq_s8((int8x16_t)v15, v17)), v11);
    int64x2_t v13 = vaddq_s64(v13, v19);
    int64x2_t v14 = vaddq_s64(v14, v19);
    int64x2_t v15 = vaddq_s64(v15, v19);
    int64x2_t v12 = vaddq_s64(v12, v19);
    v18 += 8;
  }
  while (v18);
  int8x16_t v30 = vorrq_s8(vorrq_s8(v11, v20), vorrq_s8(v10, v21));
  int8x8_t v3 = vorr_s8(*(int8x8_t *)v30.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
  if (v5 != v6)
  {
LABEL_19:
    uint64_t v44 = &a1->u8[v6];
    unint64_t v45 = v5 - v6;
    do
    {
      unsigned int v46 = *v44++;
      *(void *)&v3 |= (unint64_t)v46 << (v7 & 0x38);
      v7 += 8;
      --v45;
    }
    while (v45);
  }
LABEL_21:
  if (a2 >= 9)
  {
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    uint64_t v49 = &a1->u8[8];
    do
    {
      unsigned int v50 = *v49++;
      v47 |= (unint64_t)v50 << v48;
      v48 += 8;
      --v4;
    }
    while (v4);
  }
  return (uint64_t)v3;
}

uint64_t specialized static String._uncheckedFromUTF8(_:)(uint8x16_t *a1, uint64_t a2)
{
  if (!a2) {
    goto LABEL_20;
  }
  if ((uint64_t)(a2 & 0xFFFFFFFFFFFFFFF0) < 1)
  {
    BOOL v2 = a1;
  }
  else
  {
    if (((a1->i64[1] | a1->i64[0]) & 0x8080808080808080) != 0) {
      goto LABEL_22;
    }
    BOOL v2 = a1 + 1;
    while (v2 < (uint8x16_t *)&a1->i8[a2 & 0xFFFFFFFFFFFFFFF0])
    {
      uint64_t v3 = v2->i64[0];
      uint64_t v4 = v2->i64[1];
      ++v2;
      if (((v4 | v3) & 0x8080808080808080) != 0) {
        goto LABEL_22;
      }
    }
  }
  if (v2 < (uint8x16_t *)&a1->i8[a2 & 0xFFFFFFFFFFFFFFF8])
  {
    if ((v2->i64[0] & 0x8080808080808080) != 0) {
      goto LABEL_22;
    }
    BOOL v2 = (uint8x16_t *)((char *)v2 + 8);
  }
  if (v2 < (uint8x16_t *)&a1->i8[a2 & 0xFFFFFFFFFFFFFFFCLL])
  {
    if ((v2->i32[0] & 0x80808080) != 0) {
      goto LABEL_22;
    }
    BOOL v2 = (uint8x16_t *)((char *)v2 + 4);
  }
  if (v2 < (uint8x16_t *)&a1->i8[a2 & 0xFFFFFFFFFFFFFFFELL])
  {
    if ((v2->i16[0] & 0x8080) == 0)
    {
      BOOL v2 = (uint8x16_t *)((char *)v2 + 2);
      goto LABEL_18;
    }
LABEL_22:
    char v5 = 0;
    return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, a2, v5);
  }
LABEL_18:
  if (v2 < (uint8x16_t *)&a1->i8[a2] && v2->i8[0] < 0) {
    goto LABEL_22;
  }
LABEL_20:
  char v5 = 1;
  return specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, a2, v5);
}

uint64_t specialized static String._copying(_:)(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  if ((a4 & 0x1000000000000000) != 0)
  {
    int8x16_t v11 = (uint8x16_t *)specialized _copyCollectionToContiguousArray<A>(_:)(a1, a2, a3, a4);
    uint64_t v12 = specialized static String._uncheckedFromUTF8(_:)(v11 + 2, v11[1].i64[0]);
    swift_release((uint64_t)v11);
    return v12;
  }
  Swift::UInt64 v4 = a1._rawBits >> 16;
  int64_t v5 = a2._rawBits >> 16;
  if ((a4 & 0x2000000000000000) == 0)
  {
    if ((a3 & 0x1000000000000000) != 0)
    {
      id v6 = (id)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v7 = a3 & 0xFFFFFFFFFFFFLL;
      if ((uint64_t)(a3 & 0xFFFFFFFFFFFFLL) >= v5)
      {
LABEL_5:
        unint64_t v8 = (uint8x16_t *)specialized UnsafeBufferPointer.init(rebasing:)(v4, v5, (uint64_t)v6, v7);
        return specialized static String._uncheckedFromUTF8(_:)(v8, v9);
      }
    }
    else
    {
      id v6 = _StringObject.sharedUTF8.getter(a3, a4);
      uint64_t v7 = v13;
      if (v13 >= v5) {
        goto LABEL_5;
      }
    }
LABEL_14:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x745uLL, 0);
  }
  v14[0] = a3;
  v14[1] = a4 & 0xFFFFFFFFFFFFFFLL;
  if ((HIBYTE(a4) & 0xF) < (unint64_t)v5) {
    goto LABEL_14;
  }
  if ((uint64_t)(v5 - v4) < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  return specialized static String._uncheckedFromUTF8(_:)((uint8x16_t *)((char *)v14 + v4), v5 - v4);
}

uint64_t specialized static String._copying(_:)(unint64_t a1, unint64_t a2)
{
  Swift::UInt64 v2 = specialized Collection.subscript.getter(a1, a2);
  Swift::UInt64 v4 = v3;
  unint64_t v6 = v5;
  unint64_t v8 = v7;
  swift_bridgeObjectRetain(v7);
  v9._rawBits = v2;
  v10._rawBits = v4;
  uint64_t v11 = specialized static String._copying(_:)(v9, v10, v6, v8);
  swift_bridgeObjectRelease(v8);
  return v11;
}

int64_t specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(int64_t a1, unint64_t *a2)
{
  int64_t v4 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(void *)(v4 + 16) = v5;
  *(void *)(v4 + 24) = 0x3000000000000000;
  if (v5 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
    uint64_t v6 = *(void *)(v4 + 24) & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v6 = 0;
  }
  *(unsigned char *)(v4 + 32 + v6) = 0;
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  }
  uint64_t v7 = _StringGuts._foreignCopyUTF8(into:)(v4 + 32, a1, *a2, a2[1]);
  if (v8) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000029, 0x80000001816E2F80, "Swift/StringGutsRangeReplaceable.swift", 38, 2, 0x91uLL, 0);
  }
  *(void *)(v4 + 24) = v7 | 0x3000000000000000;
  *(unsigned char *)(v4 + 32 + (v7 & 0xFFFFFFFFFFFFLL)) = 0;
  return v4;
}

uint64_t specialized Slice.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3 - a1;
  if (__OFSUB__(a3, a1)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x62DuLL, 0);
  }
  if (a2 < 1)
  {
    if (v3 > 0 || v3 <= a2) {
      goto LABEL_9;
    }
    return 0;
  }
  if ((v3 & 0x8000000000000000) == 0 && v3 < (unint64_t)a2) {
    return 0;
  }
LABEL_9:
  BOOL v5 = __OFADD__(a1, a2);
  uint64_t result = a1 + a2;
  if (v5) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x635uLL, 0);
  }
  return result;
}

uint64_t specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(int64_t a1, unint64_t *a2)
{
  int64_t v4 = (void *)specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(a1, a2);
  if (v3) {
    return v2;
  }
  BOOL v5 = v4;
  uint64_t v6 = v4[3];
  Swift::Int v7 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0xFFFFFFFFFFFFLL) == 0) {
    goto LABEL_20;
  }
  char v8 = (char *)(v4 + 4);
  Swift::String::Index v9 = (char *)(v4 + 4);
  if ((v6 & 0xFFFFFFFFFFF0) != 0)
  {
    if (((v4[5] | v4[4]) & 0x8080808080808080) != 0) {
      goto LABEL_22;
    }
    Swift::String::Index v9 = (char *)(v4 + 6);
    while (v9 < (char *)v4 + (v6 & 0xFFFFFFFFFFF0) + 32)
    {
      uint64_t v10 = *(void *)v9;
      uint64_t v11 = *((void *)v9 + 1);
      v9 += 16;
      if (((v11 | v10) & 0x8080808080808080) != 0) {
        goto LABEL_22;
      }
    }
  }
  if (v9 < &v8[v6 & 0xFFFFFFFFFFF8])
  {
    if ((*(void *)v9 & 0x8080808080808080) != 0) {
      goto LABEL_22;
    }
    v9 += 8;
  }
  if (v9 < &v8[v6 & 0xFFFFFFFFFFFCLL])
  {
    if ((*(_DWORD *)v9 & 0x80808080) != 0) {
      goto LABEL_22;
    }
    v9 += 4;
  }
  if (v9 >= &v8[v6 & 0xFFFFFFFFFFFELL])
  {
LABEL_18:
    if (v9 >= &v8[v7] || (*v9 & 0x80000000) == 0)
    {
LABEL_20:
      char v12 = 1;
LABEL_21:
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v7, v12 & 1);
      return v5[3];
    }
    goto LABEL_22;
  }
  if ((*(_WORD *)v9 & 0x8080) == 0)
  {
    v9 += 2;
    goto LABEL_18;
  }
LABEL_22:
  uint64_t v13 = 0;
  int64x2_t v14 = &v8[v7];
  char v12 = 1;
  int64x2_t v15 = (unsigned __int8 *)(v4 + 4);
  long long v16 = (unsigned __int8 *)(v4 + 4);
  while (1)
  {
    int v18 = (char)*v16++;
    unsigned __int8 v17 = v18;
    if ((v18 & 0x80000000) == 0)
    {
      uint64_t v19 = 1;
      goto LABEL_25;
    }
    if ((v17 + 11) <= 0xCCu) {
      goto LABEL_68;
    }
    if (v17 < 0xE0u)
    {
      if (v16 == (unsigned __int8 *)v14 || (*v16 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      char v12 = 0;
      long long v16 = v15 + 2;
      uint64_t v19 = 2;
      goto LABEL_25;
    }
    if (v17 == 224) {
      break;
    }
    if (v17 <= 0xECu) {
      goto LABEL_50;
    }
    if (v17 == 237)
    {
      if (v16 == (unsigned __int8 *)v14) {
        goto LABEL_68;
      }
      unsigned int v22 = v15[1];
      if (v22 > 0x9F) {
        goto LABEL_68;
      }
LABEL_52:
      if ((v22 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      int8x16_t v20 = (char *)(v15 + 2);
      if (v15 + 2 == (unsigned __int8 *)v14) {
        goto LABEL_68;
      }
LABEL_54:
      if ((*v20 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      char v12 = 0;
      long long v16 = v15 + 3;
      uint64_t v19 = 3;
      goto LABEL_25;
    }
    if ((v17 + 16) >= 0xFEu)
    {
LABEL_50:
      if (v16 == (unsigned __int8 *)v14) {
        goto LABEL_68;
      }
      LOBYTE(v22) = v15[1];
      goto LABEL_52;
    }
    if (v17 == 240)
    {
      if (v16 == (unsigned __int8 *)v14 || (v15[1] + 64) < 0xD0u) {
        goto LABEL_68;
      }
    }
    else
    {
      if ((v17 + 12) >= 0xFDu)
      {
        if (v16 == (unsigned __int8 *)v14) {
          goto LABEL_68;
        }
        LOBYTE(v23) = v15[1];
      }
      else
      {
        if (v16 == (unsigned __int8 *)v14) {
          goto LABEL_68;
        }
        unsigned int v23 = v15[1];
        if (v23 > 0x8F) {
          goto LABEL_68;
        }
      }
      if ((v23 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
    }
    if (v15 + 2 == (unsigned __int8 *)v14
      || (v15[2] & 0xC0) != 0x80
      || v15 + 3 == (unsigned __int8 *)v14
      || (v15[3] & 0xC0) != 0x80)
    {
      goto LABEL_68;
    }
    char v12 = 0;
    long long v16 = v15 + 4;
    uint64_t v19 = 4;
LABEL_25:
    v13 += v19;
    int64x2_t v15 = v16;
    if (v16 == (unsigned __int8 *)v14) {
      goto LABEL_21;
    }
  }
  if (v16 != (unsigned __int8 *)v14)
  {
    int8x16_t v20 = (char *)(v15 + 2);
    if ((v15[1] + 64) >= 0xE0u && v20 != v14) {
      goto LABEL_54;
    }
  }
LABEL_68:
  uint32x4_t v24 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v24);
  uint64_t v25 = specialized Collection.subscript.getter(v13, (uint64_t)(v5 + 4), v7);
  uint64_t v29 = v25;
  uint64_t v30 = v26;
  uint64_t v31 = v27;
  uint64_t v32 = v28;
  uint64_t v33 = v25;
  if (v25 != v26)
  {
    specialized Slice.subscript.getter(v25, v25, v26, v27, v28);
    uint64_t v33 = v29 + 1;
    if (__OFADD__(v29, 1))
    {
      unint64_t v73 = 1525;
LABEL_168:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v73, 0);
    }
  }
  uint64_t v34 = 0;
  uint64_t v35 = v30 + v29 - v33;
  if (v30 <= v33) {
    uint64_t v36 = v33;
  }
  else {
    uint64_t v36 = v30;
  }
  if (v32 <= v33) {
    uint64_t v37 = v33;
  }
  else {
    uint64_t v37 = v32;
  }
  uint64_t v38 = v37 - v33;
  uint64_t v39 = v36 - v33;
  do
  {
    if (v30 - v33 == v34) {
      goto LABEL_87;
    }
    if (v33 < v29)
    {
      unint64_t v73 = 1812;
      goto LABEL_168;
    }
    if (v39 == v34)
    {
      unint64_t v73 = 1813;
      goto LABEL_168;
    }
    if (v33 < 0)
    {
      unint64_t v73 = 1781;
      goto LABEL_168;
    }
    if (v38 == v34)
    {
      unint64_t v73 = 1782;
      goto LABEL_168;
    }
    if ((*(unsigned char *)(v31 + v33 + v34) & 0xC0) != 0x80) {
      goto LABEL_86;
    }
    uint64_t v40 = v29 + v34++;
  }
  while (!__OFADD__(v40, 1));
  __break(1u);
LABEL_86:
  uint64_t v35 = v29 + v34;
LABEL_87:
  if (v35 < v29) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
  }
  uint64_t v41 = v35 + 1;
  if (__OFADD__(v35, 1))
  {
    __break(1u);
    goto LABEL_176;
  }
  if (v30 < v41)
  {
LABEL_176:
    unint64_t v73 = 1820;
    goto LABEL_168;
  }
  int64_t v42 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v29, v41, v31, v32);
  uint64_t v44 = v43;
  uint64_t v74 = (uint64_t)v5;
  uint64_t v75 = 0;
  uint64_t v45 = v5[3];
  unint64_t v76 = 0xE000000000000000;
  uint64_t v46 = v45 & 0xFFFFFFFFFFFFLL;
  if ((v45 & 0xFFFFFFFFFFFFLL) != 0)
  {
    uint64_t v47 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v48 & 1) != 0 || v47 < v46 + 15) {
      _StringGuts.grow(_:)(v46 + 15);
    }
  }
  while (2)
  {
    if (v42 < 0) {
      goto LABEL_169;
    }
    uint64_t v55 = v46;
    if (v46 < v42)
    {
      unint64_t v73 = 1861;
      goto LABEL_168;
    }
    unint64_t v56 = v76;
    uint64_t v57 = v75 & 0xFFFFFFFFFFFFLL;
    if ((v76 & 0x2000000000000000) != 0) {
      uint64_t v57 = HIBYTE(v76) & 0xF;
    }
    uint64_t v58 = v57 + v55;
    Swift::Int v59 = v58 + 3;
    if (__OFADD__(v58, 3))
    {
      __break(1u);
      goto LABEL_172;
    }
    if (v59 >= 16)
    {
      uint64_t v60 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v61 & 1) != 0 || v60 < v59)
      {
        _StringGuts.grow(_:)(v59);
        unint64_t v56 = v76;
      }
    }
    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v56 & 0xFFFFFFFFFFFFFFFLL, v8, v42, 0);
    uint64_t v75 = *(void *)((v56 & 0xFFFFFFFFFFFFFFFLL) + 0x18);
    size_t v77 = 3;
    uint64_t v78 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v78, &v77, &v75);
    if (v55 < v44) {
LABEL_169:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    if (v44 < 0)
    {
LABEL_172:
      unint64_t v73 = 1860;
      goto LABEL_168;
    }
    uint64_t v46 = v55 - v44;
    if (v55 - v44 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    unint64_t v62 = &v8[v44];
    if (_allASCII(_:)((uint64_t *)&v8[v44], v55 - v44))
    {
LABEL_161:
      _StringGuts.appendInPlace(_:isASCII:)(&v8[v44], v55 - v44, 0);
      break;
    }
    uint64_t v63 = 0;
    unint64_t v64 = (unsigned __int8 *)&v8[v55];
    if (!v8) {
      unint64_t v64 = 0;
    }
    for (i = (unsigned __int8 *)&v8[v44]; ; ++i)
    {
      while (1)
      {
LABEL_113:
        if (!i || i == v64) {
          goto LABEL_161;
        }
        unsigned int v67 = *i++;
        unsigned int v66 = v67;
        if ((v66 & 0x80) != 0) {
          break;
        }
        ++v63;
      }
      if ((v66 + 62) > 0x32u) {
        goto LABEL_95;
      }
      if (v66 > 0xDF) {
        break;
      }
      if (!i || i == v64 || (*i & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      v63 += 2;
    }
    if (v66 == 224)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      unint64_t v68 = i + 1;
      if ((*i & 0xE0) != 0xA0) {
        goto LABEL_95;
      }
      goto LABEL_140;
    }
    if (v66 < 0xED) {
      goto LABEL_136;
    }
    if (v66 == 237)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      unint64_t v68 = i + 1;
      unsigned int v69 = *i;
      if (v69 > 0x9F) {
        goto LABEL_95;
      }
      goto LABEL_139;
    }
    if (v66 < 0xF0)
    {
LABEL_136:
      if (!i || i == v64) {
        goto LABEL_95;
      }
      unint64_t v68 = i + 1;
      LOBYTE(v69) = *i;
LABEL_139:
      if ((v69 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
LABEL_140:
      if (v68 == v64 || (*v68 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      i += 2;
      v63 += 3;
      goto LABEL_113;
    }
    if (v66 == 240)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      size_t v70 = i + 1;
      if ((*i + 64) < 0xD0u) {
        goto LABEL_95;
      }
      goto LABEL_156;
    }
    if ((v66 + 15) < 3u)
    {
      if (!i || i == v64) {
        goto LABEL_95;
      }
      size_t v70 = i + 1;
      LOBYTE(v71) = *i;
      goto LABEL_155;
    }
    if (i)
    {
      if (i != v64)
      {
        size_t v70 = i + 1;
        unsigned int v71 = *i;
        if (v71 <= 0x8F)
        {
LABEL_155:
          if ((v71 & 0xC0) != 0x80) {
            goto LABEL_95;
          }
LABEL_156:
          if (v70 == v64 || (i[1] & 0xC0) != 0x80 || i + 2 == v64 || (i[2] & 0xC0) != 0x80) {
            goto LABEL_95;
          }
          i += 3;
          v63 += 4;
          goto LABEL_113;
        }
      }
    }
LABEL_95:
    uint64_t v49 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
    swift_willThrow();
    swift_errorRelease(v49);
    uint64_t v50 = specialized Collection.subscript.getter(v63, (uint64_t)&v8[v44], v55 - v44);
    int64_t v42 = findInvalidRange #1 (_:) in validateUTF8(_:)(v50, v51, v52, v53);
    uint64_t v44 = v54;
    char v8 = v62;
    if (v46) {
      continue;
    }
    break;
  }
  uint64_t v2 = v75;
  swift_release(v74);
  return v2;
}

uint64_t specialized static String._createEmpty(withInitialCapacity:)(Swift::Int a1)
{
  if (a1 < 16) {
    return 0;
  }
  _StringGuts.grow(_:)(a1);
  return 0;
}

uint64_t specialized String.init(_:)(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = a3;
  uint64_t v5 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000) == 0) {
    uint64_t v5 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (a1._rawBits >> 16 || a2._rawBits >> 16 != v5) {
    return specialized static String._copying(_:)(a1, a2, a3, a4);
  }
  swift_bridgeObjectRetain(a4);
  return v4;
}

unint64_t specialized _SmallString.init(_:appending:)(unint64_t result, unint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4 = HIBYTE(a2) & 0xF;
  uint64_t v5 = HIBYTE(a4) & 0xF;
  if ((unint64_t)(v5 + v4) > 0xF) {
    return 0;
  }
  if (v5)
  {
    char v6 = 0;
    unint64_t v7 = 0;
    do
    {
      unint64_t v8 = v4 + v7;
      unint64_t v9 = v7 + 1;
      if (v7 >= 8) {
        unint64_t v10 = a4;
      }
      else {
        unint64_t v10 = a3;
      }
      unint64_t v11 = v10 >> (v6 & 0x38);
      char v12 = (8 * v4 + v6) & 0x38;
      uint64_t v13 = (-255 << v12) - 1;
      unint64_t v14 = (unint64_t)v11 << v12;
      unint64_t v15 = v14 | v13 & a2;
      unint64_t v16 = v14 | v13 & result;
      if (v8 < 8) {
        uint64_t result = v16;
      }
      else {
        a2 = v15;
      }
      v6 += 8;
      unint64_t v7 = v9;
    }
    while (v5 != v9);
  }
  return result;
}

BOOL specialized static __CocoaSet.Index.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 < 0) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  uint64_t v8 = type metadata accessor for __CocoaSet.Index.Storage();
  if (!swift_dynamicCastClass(v7, v8)) {
    goto LABEL_11;
  }
  if (a3 >= 0) {
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if (!swift_dynamicCastClass(a3, v8)) {
LABEL_11:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  if (*(void *)(v7 + 16) != *(void *)(a3 + 16)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Comparing indexes from different sets", 37, 2, "Swift/SetBridging.swift", 23, 2, 0x1FFuLL, 0);
  }
  return a2 < a4;
}

BOOL specialized _StringGutsSlice._isScalarNFCQC(_:_:)(unsigned int a1, unsigned char *a2)
{
  if (a1 >= 0x300) {
    unsigned int NormData = _swift_stdlib_getNormData(a1);
  }
  else {
    unsigned int NormData = 0;
  }
  char v4 = NormData >> 3;
  if (v4) {
    BOOL v5 = *a2 <= (NormData >> 3);
  }
  else {
    BOOL v5 = 1;
  }
  BOOL result = (NormData & 6) == 0 && v5;
  if (result) {
    *a2 = v4;
  }
  return result;
}

uint64_t specialized _ArrayBuffer._nonNative.getter(uint64_t result)
{
  if (result >= 0) {
    return result & 0xFFFFFFFFFFFFFF8;
  }
  return result;
}

uint64_t specialized static Hasher._hash(seed:_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = unk_1EB208F00 ^ a2 ^ 0x7465646279746573;
  uint64_t v3 = ((_swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575) + (unk_1EB208F00 ^ 0x646F72616E646F6DLL)) ^ __ROR8__(unk_1EB208F00 ^ 0x646F72616E646F6DLL, 51);
  uint64_t v4 = (_swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261) + v2;
  uint64_t v5 = __ROR8__(v2, 48);
  uint64_t v6 = __ROR8__((_swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575) + (unk_1EB208F00 ^ 0x646F72616E646F6DLL), 32)+ (v4 ^ v5);
  uint64_t v7 = v6 ^ __ROR8__(v4 ^ v5, 43);
  uint64_t v8 = v3 + v4;
  uint64_t v9 = __ROR8__(v8, 32);
  uint64_t v10 = v8 ^ __ROR8__(v3, 47);
  uint64_t v11 = (v6 ^ a2) + v10;
  uint64_t v12 = __ROR8__(v11, 32);
  uint64_t v13 = v11 ^ __ROR8__(v10, 51);
  uint64_t v14 = (v7 ^ 0x800000000000000) + v9;
  *((void *)&v15 + 1) = v7;
  *(void *)&long long v15 = v7 ^ 0x800000000000000;
  uint64_t v16 = (v15 >> 48) ^ v14;
  uint64_t v17 = v16 + v12;
  uint64_t v18 = (v16 + v12) ^ __ROR8__(v16, 43);
  uint64_t v19 = v14 + v13;
  uint64_t v20 = v19 ^ __ROR8__(v13, 47);
  uint64_t v21 = (v17 ^ 0x800000000000000) + v20;
  uint64_t v22 = v21 ^ __ROR8__(v20, 51);
  uint64_t v23 = (__ROR8__(v19, 32) ^ 0xFFLL) + v18;
  *(void *)&long long v15 = __ROR8__(v18, 48);
  uint64_t v24 = __ROR8__(v21, 32) + (v23 ^ v15);
  uint64_t v25 = v24 ^ __ROR8__(v23 ^ v15, 43);
  uint64_t v26 = v22 + v23;
  uint64_t v27 = __ROR8__(v26, 32);
  uint64_t v28 = v26 ^ __ROR8__(v22, 47);
  uint64_t v29 = v24 + v28;
  uint64_t v30 = (v24 + v28) ^ __ROR8__(v28, 51);
  uint64_t v31 = v27 + v25;
  uint64_t v32 = (v27 + v25) ^ __ROR8__(v25, 48);
  uint64_t v33 = __ROR8__(v29, 32) + v32;
  uint64_t v34 = v33 ^ __ROR8__(v32, 43);
  uint64_t v35 = v30 + v31;
  uint64_t v36 = v35 ^ __ROR8__(v30, 47);
  uint64_t v37 = __ROR8__(v35, 32) + v34;
  uint64_t v38 = (v33 + v36) ^ __ROR8__(v36, 51);
  return __ROR8__(v37 ^ __ROR8__(v34, 48), 43) ^ __ROR8__(v38 + v37, 32) ^ (v38 + v37) ^ __ROR8__(v38, 47);
}

uint64_t specialized static Hasher._hash(seed:bytes:count:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2 | (a3 << 56);
  uint64_t v4 = v3 ^ 0x7465646279746573 ^ unk_1EB208F00;
  uint64_t v5 = ((_swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575) + (unk_1EB208F00 ^ 0x646F72616E646F6DLL)) ^ __ROR8__(unk_1EB208F00 ^ 0x646F72616E646F6DLL, 51);
  uint64_t v6 = (_swift_stdlib_Hashing_parameters ^ a1 ^ 0x6C7967656E657261) + v4;
  uint64_t v7 = __ROR8__(v4, 48);
  uint64_t v8 = __ROR8__((_swift_stdlib_Hashing_parameters ^ a1 ^ 0x736F6D6570736575) + (unk_1EB208F00 ^ 0x646F72616E646F6DLL), 32)+ (v6 ^ v7);
  uint64_t v9 = v8 ^ __ROR8__(v6 ^ v7, 43);
  uint64_t v10 = v5 + v6;
  uint64_t v11 = v10 ^ __ROR8__(v5, 47);
  uint64_t v12 = (v8 ^ v3) + v11;
  uint64_t v13 = v12 ^ __ROR8__(v11, 51);
  uint64_t v14 = (__ROR8__(v10, 32) ^ 0xFFLL) + v9;
  uint64_t v15 = __ROR8__(v9, 48);
  uint64_t v16 = __ROR8__(v12, 32) + (v14 ^ v15);
  uint64_t v17 = v16 ^ __ROR8__(v14 ^ v15, 43);
  uint64_t v18 = v13 + v14;
  uint64_t v19 = __ROR8__(v18, 32);
  uint64_t v20 = v18 ^ __ROR8__(v13, 47);
  uint64_t v21 = v16 + v20;
  uint64_t v22 = v21 ^ __ROR8__(v20, 51);
  uint64_t v23 = v19 + v17;
  uint64_t v24 = (v19 + v17) ^ __ROR8__(v17, 48);
  uint64_t v25 = __ROR8__(v21, 32) + v24;
  uint64_t v26 = v25 ^ __ROR8__(v24, 43);
  uint64_t v27 = v22 + v23;
  uint64_t v28 = v27 ^ __ROR8__(v22, 47);
  uint64_t v29 = __ROR8__(v27, 32) + v26;
  uint64_t v30 = (v25 + v28) ^ __ROR8__(v28, 51);
  return __ROR8__(v29 ^ __ROR8__(v26, 48), 43) ^ __ROR8__(v30 + v29, 32) ^ (v30 + v29) ^ __ROR8__(v30, 47);
}

uint64_t specialized ArraySlice._checkSubscript(_:wasNativeTypeChecked:)(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (result < a4 || (uint64_t)(a5 >> 1) <= result) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/SliceBuffer.swift", 23, 2, 0x132uLL, 0);
  }
  return result;
}

BOOL specialized static __CocoaDictionary.Index.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 < 0) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  uint64_t v8 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v7, v8)) {
    goto LABEL_11;
  }
  if (a3 >= 0) {
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if (!swift_dynamicCastClass(a3, v8)) {
LABEL_11:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  if (*(void *)(v7 + 16) != *(void *)(a3 + 16)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Comparing indexes from different dictionaries", 45, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x2AFuLL, 0);
  }
  return a2 < a4;
}

uint64_t specialized AnyCollection.endIndex.getter(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t specialized AnyCollection.startIndex.getter(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

unint64_t specialized Substring.UTF8View._failEarlyRangeCheck(_:bounds:)(unint64_t result, unint64_t a2, unint64_t a3, unint64_t a4)
{
  if (result >> 14 < a3 >> 14 || a4 >> 14 < a2 >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  }
  return result;
}

uint64_t specialized KeyPathBuffer.init(base:)(uint64_t a1)
{
  if ((a1 & 3) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  }
  return a1 + 8;
}

uint64_t specialized static AnyKeyPath.== infix(_:_:)(void *a1, void *a2)
{
  if (a1 == a2) {
    return 1;
  }
  if (*a1 != *a2) {
    return 0;
  }
  uint64_t v3 = specialized KeyPathBuffer.init(base:)((uint64_t)(a1 + 3));
  uint64_t v5 = v4;
  int v7 = v6;
  uint64_t v42 = v3;
  uint64_t v43 = v4;
  uint64_t v8 = specialized KeyPathBuffer.init(base:)((uint64_t)(a2 + 3));
  uint64_t v40 = v8;
  uint64_t v41 = v9;
  if (((v7 ^ v10) & 0x100) != 0) {
    return 0;
  }
  if (v3 && v5 != v3)
  {
    while (1)
    {
      uint64_t v13 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v42, 1);
      if (!v13) {
        goto LABEL_82;
      }
      uint64_t v14 = *v13;
      uint64_t v15 = v42;
      unsigned int v16 = BYTE3(v14) & 0x7F;
      if (v16 == 1) {
        goto LABEL_19;
      }
      if (v16 != 2) {
        break;
      }
      uint64_t v17 = 28;
      if ((v14 & 0x400000) == 0) {
        uint64_t v17 = 20;
      }
      if ((v14 & 0x80000) != 0)
      {
        if (!v42) {
          goto LABEL_82;
        }
        uint64_t v20 = 24;
        if ((v14 & 0x400000) == 0) {
          uint64_t v20 = 16;
        }
        uint64_t v21 = v42 + v20 + 4;
        if ((v21 & 7) != 0) {
          goto LABEL_77;
        }
        uint64_t v22 = v17 + 16;
        uint64_t v23 = *(void *)v21;
        BOOL v24 = __OFADD__(v22, v23);
        uint64_t v17 = v22 + v23;
        if (v24)
        {
          __break(1u);
LABEL_79:
          __break(1u);
LABEL_80:
          __break(1u);
LABEL_81:
          __break(1u);
LABEL_82:
          _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
        }
        if ((v14 & 0x10) != 0)
        {
          BOOL v24 = __OFADD__(v17, 8);
          v17 += 8;
          if (v24) {
            goto LABEL_80;
          }
        }
        if (v17 < 0) {
          goto LABEL_76;
        }
        goto LABEL_36;
      }
LABEL_26:
      if (!v42) {
        goto LABEL_83;
      }
LABEL_36:
      uint64_t v19 = v42 + v17;
      uint64_t v18 = v17;
LABEL_37:
      specialized _pop<A>(from:as:count:)(&v42, v18);
      if (v42 && v43 != v42)
      {
        uint64_t v26 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v42, 1);
        if (!v26) {
          goto LABEL_82;
        }
        uint64_t v25 = *v26;
      }
      else
      {
        uint64_t v25 = 0;
      }
      uint64_t v27 = (unsigned int *)specialized _pop<A>(from:as:count:)(&v40, 1);
      if (!v27) {
        goto LABEL_82;
      }
      uint64_t v28 = *v27;
      uint64_t v29 = v40;
      unsigned int v30 = BYTE3(v28) & 0x7F;
      if (v30 == 1 || v30 == 3)
      {
        if ((~v28 & 0x7FFFFF) == 0)
        {
          uint64_t v31 = 4;
LABEL_60:
          if (!v40) {
LABEL_83:
          }
            _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer has a nil start and nonzero count", 56, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x486uLL, 0);
LABEL_63:
          uint64_t v36 = v40 + v31;
          uint64_t v37 = v31;
          goto LABEL_64;
        }
      }
      else if (v30 == 2)
      {
        uint64_t v31 = 28;
        if ((v28 & 0x400000) == 0) {
          uint64_t v31 = 20;
        }
        if ((v28 & 0x80000) == 0) {
          goto LABEL_60;
        }
        if (!v40) {
          goto LABEL_82;
        }
        uint64_t v32 = 24;
        if ((v28 & 0x400000) == 0) {
          uint64_t v32 = 16;
        }
        uint64_t v33 = v40 + v32 + 4;
        if ((v33 & 7) != 0) {
LABEL_77:
        }
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
        uint64_t v34 = v31 + 16;
        uint64_t v35 = *(void *)v33;
        BOOL v24 = __OFADD__(v34, v35);
        uint64_t v31 = v34 + v35;
        if (v24) {
          goto LABEL_79;
        }
        if ((v28 & 0x10) != 0)
        {
          BOOL v24 = __OFADD__(v31, 8);
          v31 += 8;
          if (v24) {
            goto LABEL_81;
          }
        }
        if (v31 < 0) {
LABEL_76:
        }
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
        goto LABEL_63;
      }
      uint64_t v31 = 0;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      if (v40) {
        goto LABEL_63;
      }
LABEL_64:
      specialized _pop<A>(from:as:count:)(&v40, v37);
      if (v40 && v41 != v40)
      {
        uint64_t v39 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v40, 1);
        if (!v39) {
          goto LABEL_82;
        }
        uint64_t v38 = *v39;
        if (((v28 ^ v14) & 0x80000000) != 0) {
          return 0;
        }
      }
      else
      {
        uint64_t v38 = 0;
        if (((v28 ^ v14) & 0x80000000) != 0) {
          return 0;
        }
      }
      RawKeyPathComponent.value.getter(v14, v15, v19, v44);
      RawKeyPathComponent.value.getter(v28, v29, v36, v45);
      if ((((uint64_t (*)(uint64_t *, uint64_t *))specialized static KeyPathComponent.== infix(_:_:))(v44, v45) & 1) == 0) {
        return 0;
      }
      if (!v25) {
        return v38 == 0;
      }
      uint64_t result = 0;
      if (!v38 || v25 != v38) {
        return result;
      }
    }
    if (v16 != 3) {
      goto LABEL_21;
    }
LABEL_19:
    if ((~v14 & 0x7FFFFF) != 0)
    {
LABEL_21:
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      if (!v42) {
        goto LABEL_37;
      }
      goto LABEL_36;
    }
    uint64_t v17 = 4;
    goto LABEL_26;
  }
  return !v8 || v9 == v8;
}

BOOL specialized static __CocoaSet.Index.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 < 0) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  uint64_t v8 = type metadata accessor for __CocoaSet.Index.Storage();
  if (!swift_dynamicCastClass(v7, v8)) {
    goto LABEL_11;
  }
  if (a3 >= 0) {
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if (!swift_dynamicCastClass(a3, v8)) {
LABEL_11:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  if (*(void *)(v7 + 16) != *(void *)(a3 + 16)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Comparing indexes from different sets", 37, 2, "Swift/SetBridging.swift", 23, 2, 0x1F5uLL, 0);
  }
  return a2 == a4;
}

BOOL specialized _StringGuts.checkIfInEmojiSequence(at:with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(a1, a2, a3);
  if ((v6 & 1) == 0)
  {
    uint64_t v7 = v5;
    while (1)
    {
      unsigned int v8 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(v7, a2, a3);
      if ((v10 & 1) != 0 || v8 < 0x20) {
        break;
      }
      uint64_t v11 = 0;
      int32x4_t v12 = vdupq_n_s32(v8);
      if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v12, (int32x4_t)xmmword_18162B050), (uint32x4_t)xmmword_18162B070), (int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v12, (int32x4_t)xmmword_18162B060), (uint32x4_t)xmmword_18162B080)))) & 1) != 0|| v8 < 0x7F|| v8 == 8205)
      {
        return v11;
      }
      if (v8 - 131070 > 0xFFFFFC01) {
        return 1;
      }
      if (v8 - 921600 > 0xFFFFF1EF) {
        return 0;
      }
      uint64_t v7 = v9;
      int GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(v8);
      if (GraphemeBreakProperty != 1) {
        return (GraphemeBreakProperty - 4) <= 1;
      }
    }
  }
  return 0;
}

uint64_t specialized _StringGuts.checkIfInIndicSequence(at:with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(a1, a2, a3);
  if ((v7 & 1) == 0)
  {
    int v8 = v5;
    unsigned int v9 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(v6, a2, a3);
    if ((v11 & 1) == 0)
    {
      unsigned int v12 = v9;
      uint64_t v13 = v10;
      HIDWORD(v14) = v8 - 2381;
      LODWORD(v14) = v8 - 2381;
      unsigned int v15 = ((v14 >> 7) < 9) & (0x15Bu >> (v14 >> 7));
      while (1)
      {
        if (v12 < 0x20)
        {
LABEL_20:
          LOBYTE(v16) = 1;
          goto LABEL_22;
        }
        if (v12 < 0x7F) {
          goto LABEL_21;
        }
        if (v12 == 8205)
        {
          LOBYTE(v16) = 12;
          goto LABEL_22;
        }
        LOBYTE(v16) = 4;
        if (v12 - 4448 <= 0xFFFFFF9F && v12 - 43389 < 0xFFFFFFE3)
        {
          LOBYTE(v16) = 11;
          if (v12 - 4520 <= 0xFFFFFFB7 && v12 - 55239 <= 0xFFFFFFE8)
          {
            LOBYTE(v16) = 10;
            if (v12 - 4608 <= 0xFFFFFFA7 && v12 - 55292 <= 0xFFFFFFCE)
            {
              if (v12 - 55204 > 0xFFFFD45B)
              {
                HIDWORD(v25) = -1227133513 * ((unsigned __int16)v12 - 16);
                LODWORD(v25) = HIDWORD(v25);
                if ((v25 >> 2) < 0x9249249) {
                  LOBYTE(v16) = 5;
                }
                else {
                  LOBYTE(v16) = 6;
                }
              }
              else if (v12 - 127488 > 0xFFFFFFE5)
              {
                LOBYTE(v16) = 8;
              }
              else
              {
                if (v12 - 131070 <= 0xFFFFFC01)
                {
                  if (v12 - 921600 > 0xFFFFF1EF) {
                    goto LABEL_20;
                  }
                  unsigned int GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(v12);
                  if (GraphemeBreakProperty < 6)
                  {
                    unint64_t v16 = 0x30309070201uLL >> (8 * GraphemeBreakProperty);
                    goto LABEL_22;
                  }
LABEL_21:
                  LOBYTE(v16) = 0;
                  goto LABEL_22;
                }
                LOBYTE(v16) = 3;
              }
            }
          }
        }
LABEL_22:
        if (_swift_stdlib_isLinkingConsonant(v12))
        {
          char v19 = v15;
          return v19 & 1;
        }
        if (v16 == 2)
        {
          if (v12 < 0x300) {
            break;
          }
          char v19 = _swift_stdlib_getNormData(v12) >> 3;
          if (!v19) {
            return v19 & 1;
          }
          HIDWORD(v22) = v12 - 2381;
          LODWORD(v22) = v12 - 2381;
          unsigned int v21 = v22 >> 7;
          BOOL v23 = v21 > 8;
          unsigned int v24 = (0x15Bu >> v21) | v15;
          if (!v23) {
            unsigned int v15 = v24;
          }
        }
        else if (v16 != 12)
        {
          break;
        }
        unsigned int v12 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(v13, a2, a3);
        uint64_t v13 = v18;
        char v19 = 0;
        if (v20) {
          return v19 & 1;
        }
      }
    }
  }
  char v19 = 0;
  return v19 & 1;
}

{
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  unsigned int GraphemeBreakProperty;
  char v17;
  unsigned int v18;
  unint64_t v19;
  BOOL v20;
  unsigned int v21;
  unint64_t v22;

  if (a2 >= a1) {
    return 0;
  }
  int v5 = a1;
  uint64_t v6 = a3 - 1;
  do
    char v7 = *(unsigned char *)(v6 + v5--) & 0xC0;
  while (v7 == 128);
  int v8 = _decodeScalar(_:startingAt:)(a3, a2, v5);
  if (v5 <= a2)
  {
LABEL_40:
    uint64_t v17 = 0;
    return v17 & 1;
  }
  HIDWORD(v10) = v8 - 2381;
  LODWORD(v10) = v8 - 2381;
  char v11 = ((v10 >> 7) < 9) & (0x15Bu >> (v10 >> 7));
  while (1)
  {
    do
      unsigned int v12 = *(unsigned char *)(v6 + v5--) & 0xC0;
    while (v12 == 128);
    uint64_t v13 = _decodeScalar(_:startingAt:)(a3, v9, v5);
    unint64_t v14 = v13;
    if (v13 < 0x20)
    {
LABEL_23:
      LOBYTE(v15) = 1;
      goto LABEL_25;
    }
    if (v13 < 0x7F) {
      goto LABEL_24;
    }
    if (v13 == 8205)
    {
      LOBYTE(v15) = 12;
      goto LABEL_25;
    }
    LOBYTE(v15) = 4;
    if (v13 - 4448 <= 0xFFFFFF9F && v13 - 43389 < 0xFFFFFFE3)
    {
      LOBYTE(v15) = 11;
      if (v13 - 4520 <= 0xFFFFFFB7 && v13 - 55239 <= 0xFFFFFFE8)
      {
        LOBYTE(v15) = 10;
        if (v13 - 4608 <= 0xFFFFFFA7 && v13 - 55292 <= 0xFFFFFFCE)
        {
          if (v13 - 55204 > 0xFFFFD45B)
          {
            HIDWORD(v22) = -1227133513 * ((unsigned __int16)v13 - 16);
            LODWORD(v22) = HIDWORD(v22);
            if ((v22 >> 2) < 0x9249249) {
              LOBYTE(v15) = 5;
            }
            else {
              LOBYTE(v15) = 6;
            }
          }
          else if (v13 - 127488 > 0xFFFFFFE5)
          {
            LOBYTE(v15) = 8;
          }
          else
          {
            if (v13 - 131070 <= 0xFFFFFC01)
            {
              if (v13 - 921600 > 0xFFFFF1EF) {
                goto LABEL_23;
              }
              unsigned int GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(v13);
              if (GraphemeBreakProperty < 6)
              {
                unsigned int v15 = 0x30309070201uLL >> (8 * GraphemeBreakProperty);
                goto LABEL_25;
              }
LABEL_24:
              LOBYTE(v15) = 0;
              goto LABEL_25;
            }
            LOBYTE(v15) = 3;
          }
        }
      }
    }
LABEL_25:
    if (_swift_stdlib_isLinkingConsonant(v14)) {
      break;
    }
    if (v15 == 2)
    {
      if (v14 < 0x300) {
        goto LABEL_40;
      }
      uint64_t v17 = _swift_stdlib_getNormData(v14) >> 3;
      if (!v17) {
        return v17 & 1;
      }
      HIDWORD(v19) = v14 - 2381;
      LODWORD(v19) = v14 - 2381;
      uint64_t v18 = v19 >> 7;
      char v20 = v18 > 8;
      unsigned int v21 = (0x15Bu >> v18) | v11;
      if (!v20) {
        char v11 = v21;
      }
    }
    else if (v15 != 12)
    {
      goto LABEL_40;
    }
    uint64_t v17 = 0;
    if (v5 <= a2) {
      return v17 & 1;
    }
  }
  uint64_t v17 = v11;
  return v17 & 1;
}

uint64_t specialized _StringGuts.countRIs(at:with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(a1, a2, a3);
  if (v6) {
    return 0;
  }
  for (uint64_t i = 0; ; ++i)
  {
    unsigned int v8 = closure #1 in _StringGuts._foreignPreviousWordIndex(endingAt:)(v5, a2, a3);
    if ((v9 & 1) != 0
      || v8 < 0x20
      || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)vaddq_s32(vdupq_n_s32(v8), (int32x4_t)xmmword_18162B050), (uint32x4_t)xmmword_18162B070))) & 1) != 0|| v8 - 4608 > 0xFFFFFFA7|| v8 - 55292 > 0xFFFFFFCE|| v8 - 55204 > 0xFFFFD45B|| v8 < 0x7F|| v8 == 8205)
    {
      break;
    }
    if (v8 - 127488 <= 0xFFFFFFE5)
    {
      if (v8 - 131070 <= 0xFFFFFC01 && v8 - 921600 <= 0xFFFFF1EF) {
        _swift_stdlib_getGraphemeBreakProperty(v8);
      }
      return i & 1;
    }
    if (__OFADD__(i, 1))
    {
      __break(1u);
      return 0;
    }
  }
  return i & 1;
}

uint64_t specialized _StringGuts.shouldBreakWithLookback(between:and:at:with:)(unsigned int a1, unsigned int a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a1 == 13 && a2 == 10)
  {
LABEL_15:
    char v12 = 0;
    return v12 & 1;
  }
  int32x4_t v10 = vdupq_n_s32(a1);
  if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v10, (int32x4_t)xmmword_18162AF60), (uint32x4_t)xmmword_18162AF80), (int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v10, (int32x4_t)xmmword_18162AF70), (uint32x4_t)xmmword_18162AF90)))) & 1) != 0|| a1 - 65438 > 0xFFFFFF62|| a1 < 0x300)
  {
    int32x4_t v11 = vdupq_n_s32(a2);
    char v12 = 1;
    if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_18162AF60), (uint32x4_t)xmmword_18162AF80), (int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_18162AF70), (uint32x4_t)xmmword_18162AF90)))) & 1) != 0|| a2 - 65438 > 0xFFFFFF62|| a2 <= 0x2FF)
    {
      return v12 & 1;
    }
  }
  swift_bridgeObjectRetain_n(a5, 4);
  char v13 = Unicode._GraphemeBreakProperty.init(from:)(a1);
  char v14 = Unicode._GraphemeBreakProperty.init(from:)(a2);
  if (v13 == 1)
  {
LABEL_32:
    swift_bridgeObjectRelease_n(a5, 4);
    char v12 = 1;
    return v12 & 1;
  }
  if (!v13)
  {
    switch(v14)
    {
      case 0:
      case 1:
        goto LABEL_32;
      case 2:
      case 9:
      case 12:
        goto LABEL_14;
      default:
        goto LABEL_12;
    }
  }
  switch(v14)
  {
    case 1:
      goto LABEL_32;
    case 2:
    case 9:
    case 12:
      goto LABEL_14;
    case 4:
      switch(v13)
      {
        case 4:
        case 7:
          goto LABEL_14;
        case 8:
          goto LABEL_12;
        case 12:
          goto LABEL_36;
        default:
          goto LABEL_25;
      }
    case 5:
      switch(v13)
      {
        case 4:
        case 7:
          goto LABEL_14;
        case 8:
          goto LABEL_12;
        case 12:
          goto LABEL_36;
        default:
          goto LABEL_25;
      }
    case 6:
      switch(v13)
      {
        case 4:
        case 7:
          goto LABEL_14;
        case 8:
          goto LABEL_12;
        case 12:
          goto LABEL_36;
        default:
          goto LABEL_25;
      }
    case 10:
      switch(v13)
      {
        case 5:
        case 6:
        case 7:
        case 10:
        case 11:
          goto LABEL_14;
        case 8:
          goto LABEL_12;
        case 12:
          goto LABEL_36;
        default:
          goto LABEL_25;
      }
    case 11:
      switch(v13)
      {
        case 4:
        case 5:
        case 7:
        case 11:
          goto LABEL_14;
        case 8:
          goto LABEL_12;
        case 12:
          goto LABEL_36;
        default:
          goto LABEL_25;
      }
    default:
      if (v13 == 12)
      {
        if (v14 == 3)
        {
          swift_bridgeObjectRetain(a5);
          char v17 = specialized _StringGuts.checkIfInEmojiSequence(at:with:)(a3, a4, a5);
LABEL_38:
          char v18 = v17;
          swift_bridgeObjectRelease_n(a5, 5);
          char v12 = v18 ^ 1;
          return v12 & 1;
        }
LABEL_36:
        if (!_swift_stdlib_isLinkingConsonant(a2)) {
          goto LABEL_32;
        }
LABEL_37:
        swift_bridgeObjectRetain(a5);
        char v17 = specialized _StringGuts.checkIfInIndicSequence(at:with:)(a3, a4, a5);
        goto LABEL_38;
      }
      if (v13 != 8)
      {
        if (v13 == 7)
        {
LABEL_14:
          swift_bridgeObjectRelease_n(a5, 4);
          goto LABEL_15;
        }
LABEL_25:
        BOOL isLinkingConsonant = _swift_stdlib_isLinkingConsonant(a2);
        if (v13 == 12)
        {
          if (!isLinkingConsonant) {
            goto LABEL_32;
          }
        }
        else if (v13 != 2 {
               || !isLinkingConsonant
        }
               || a1 < 0x300
               || !(_swift_stdlib_getNormData(a1) >> 3))
        {
          goto LABEL_32;
        }
        goto LABEL_37;
      }
      if (v14 != 8)
      {
LABEL_12:
        _swift_stdlib_isLinkingConsonant(a2);
        goto LABEL_32;
      }
      swift_bridgeObjectRetain(a5);
      char v19 = specialized _StringGuts.countRIs(at:with:)(a3, a4, a5);
      swift_bridgeObjectRelease_n(a5, 5);
      return v19 & 1;
  }
}

BOOL specialized _StringGuts.checkIfInEmojiSequence(at:with:)(uint64_t a1, uint64_t a2)
{
  if (a1 < 1) {
    return 0;
  }
  uint64_t v3 = a1;
  uint64_t v4 = a2 - 1;
  do
    int v5 = *(unsigned char *)(v4 + v3--) & 0xC0;
  while (v5 == 128);
  _decodeScalar(_:startingAt:)(a2, a2, v3);
  while (v3 >= 1)
  {
    do
      int v7 = *(unsigned char *)(v4 + v3--) & 0xC0;
    while (v7 == 128);
    unsigned int v8 = _decodeScalar(_:startingAt:)(a2, v6, v3);
    if (v8 < 0x20) {
      break;
    }
    unsigned int v9 = v8;
    BOOL result = 0;
    int32x4_t v11 = vdupq_n_s32(v9);
    if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_18162B050), (uint32x4_t)xmmword_18162B070), (int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_18162B060), (uint32x4_t)xmmword_18162B080)))) & 1) != 0|| v9 < 0x7F|| v9 == 8205)
    {
      return result;
    }
    if (v9 - 131070 > 0xFFFFFC01) {
      return 1;
    }
    if (v9 - 921600 > 0xFFFFF1EF) {
      return 0;
    }
    int GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(v9);
    if (GraphemeBreakProperty != 1) {
      return (GraphemeBreakProperty - 4) <= 1;
    }
  }
  return 0;
}

uint64_t specialized _StringGuts.checkIfInIndicSequence(at:with:)(uint64_t a1, uint64_t a2)
{
  if (a1 < 1) {
    return 0;
  }
  uint64_t v3 = a1;
  uint64_t v4 = a2 - 1;
  do
    int v5 = *(unsigned char *)(v4 + v3--) & 0xC0;
  while (v5 == 128);
  int v6 = _decodeScalar(_:startingAt:)(a2, a2, v3);
  if (v3 < 1)
  {
LABEL_39:
    char v15 = 0;
    return v15 & 1;
  }
  HIDWORD(v8) = v6 - 2381;
  LODWORD(v8) = v6 - 2381;
  unsigned int v9 = ((v8 >> 7) < 9) & (0x15Bu >> (v8 >> 7));
  while (1)
  {
    do
      int v10 = *(unsigned char *)(v4 + v3--) & 0xC0;
    while (v10 == 128);
    unsigned int v11 = _decodeScalar(_:startingAt:)(a2, v7, v3);
    unsigned int v12 = v11;
    if (v11 < 0x20)
    {
LABEL_23:
      LOBYTE(v13) = 1;
      goto LABEL_25;
    }
    if (v11 < 0x7F) {
      goto LABEL_24;
    }
    if (v11 == 8205)
    {
      LOBYTE(v13) = 12;
      goto LABEL_25;
    }
    LOBYTE(v13) = 4;
    if (v11 - 4448 <= 0xFFFFFF9F && v11 - 43389 < 0xFFFFFFE3)
    {
      LOBYTE(v13) = 11;
      if (v11 - 4520 <= 0xFFFFFFB7 && v11 - 55239 <= 0xFFFFFFE8)
      {
        LOBYTE(v13) = 10;
        if (v11 - 4608 <= 0xFFFFFFA7 && v11 - 55292 <= 0xFFFFFFCE)
        {
          if (v11 - 55204 > 0xFFFFD45B)
          {
            HIDWORD(v20) = -1227133513 * ((unsigned __int16)v11 - 16);
            LODWORD(v20) = HIDWORD(v20);
            if ((v20 >> 2) < 0x9249249) {
              LOBYTE(v13) = 5;
            }
            else {
              LOBYTE(v13) = 6;
            }
          }
          else if (v11 - 127488 > 0xFFFFFFE5)
          {
            LOBYTE(v13) = 8;
          }
          else
          {
            if (v11 - 131070 <= 0xFFFFFC01)
            {
              if (v11 - 921600 > 0xFFFFF1EF) {
                goto LABEL_23;
              }
              unsigned int GraphemeBreakProperty = _swift_stdlib_getGraphemeBreakProperty(v11);
              if (GraphemeBreakProperty < 6)
              {
                unint64_t v13 = 0x30309070201uLL >> (8 * GraphemeBreakProperty);
                goto LABEL_25;
              }
LABEL_24:
              LOBYTE(v13) = 0;
              goto LABEL_25;
            }
            LOBYTE(v13) = 3;
          }
        }
      }
    }
LABEL_25:
    if (_swift_stdlib_isLinkingConsonant(v12)) {
      break;
    }
    if (v13 == 2)
    {
      if (v12 < 0x300) {
        goto LABEL_39;
      }
      char v15 = _swift_stdlib_getNormData(v12) >> 3;
      if (!v15) {
        return v15 & 1;
      }
      HIDWORD(v17) = v12 - 2381;
      LODWORD(v17) = v12 - 2381;
      unsigned int v16 = v17 >> 7;
      BOOL v18 = v16 > 8;
      unsigned int v19 = (0x15Bu >> v16) | v9;
      if (!v18) {
        unsigned int v9 = v19;
      }
    }
    else if (v13 != 12)
    {
      goto LABEL_39;
    }
    char v15 = 0;
    if (v3 <= 0) {
      return v15 & 1;
    }
  }
  char v15 = v9;
  return v15 & 1;
}

uint64_t specialized _StringGuts.countRIs(at:with:)(uint64_t a1, uint64_t a2)
{
  if (a1 < 1) {
    return 0;
  }
  uint64_t v3 = a1;
  uint64_t v4 = a2 - 1;
  do
    int v5 = *(unsigned char *)(v4 + v3--) & 0xC0;
  while (v5 == 128);
  _decodeScalar(_:startingAt:)(a2, a2, v3);
  for (uint64_t i = 0; v3 >= 1; ++i)
  {
    do
      int v8 = *(unsigned char *)(v4 + v3--) & 0xC0;
    while (v8 == 128);
    unsigned int v9 = _decodeScalar(_:startingAt:)(a2, v6, v3);
    if (v9 < 0x20
      || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)vaddq_s32(vdupq_n_s32(v9), (int32x4_t)xmmword_18162B050), (uint32x4_t)xmmword_18162B070))) & 1) != 0|| v9 - 4608 > 0xFFFFFFA7|| v9 - 55292 > 0xFFFFFFCE|| v9 - 55204 > 0xFFFFD45B|| v9 < 0x7F|| v9 == 8205)
    {
      break;
    }
    if (v9 - 127488 <= 0xFFFFFFE5)
    {
      if (v9 - 131070 <= 0xFFFFFC01 && v9 - 921600 <= 0xFFFFF1EF) {
        _swift_stdlib_getGraphemeBreakProperty(v9);
      }
      return i & 1;
    }
    if (__OFADD__(i, 1))
    {
      __break(1u);
      return 0;
    }
  }
  return i & 1;
}

uint64_t specialized _StringGuts.shouldBreakWithLookback(between:and:at:with:)(unsigned int a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  if (a1 == 13 && a2 == 10)
  {
LABEL_3:
    LOBYTE(v8) = 0;
    return v8 & 1;
  }
  int32x4_t v10 = vdupq_n_s32(a1);
  if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v10, (int32x4_t)xmmword_18162AEA0), (uint32x4_t)xmmword_18162AEB0), (int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v10, (int32x4_t)xmmword_18162AF70), (uint32x4_t)xmmword_18162AF90)))) & 1) != 0|| a1 - 65438 > 0xFFFFFF62|| a1 < 0x300)
  {
    int32x4_t v11 = vdupq_n_s32(a2);
    LOBYTE(v8) = 1;
    if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16((int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_18162AF60), (uint32x4_t)xmmword_18162AF80), (int16x8_t)vcgtq_u32((uint32x4_t)vaddq_s32(v11, (int32x4_t)xmmword_18162AF70), (uint32x4_t)xmmword_18162AF90)))) & 1) != 0|| a2 - 65438 > 0xFFFFFF62|| a2 <= 0x2FF)
    {
      return v8 & 1;
    }
  }
  unsigned __int8 v12 = Unicode._GraphemeBreakProperty.init(from:)(a1);
  char v13 = Unicode._GraphemeBreakProperty.init(from:)(a2);
  LOBYTE(v8) = v12;
  if (v12 == 1) {
    return v8 & 1;
  }
  if (!v12)
  {
    if ((0x1207u >> v13))
    {
      unsigned int v8 = (0xDFBu >> v13) & 1;
      return v8 & 1;
    }
LABEL_14:
    _swift_stdlib_isLinkingConsonant(a2);
LABEL_15:
    LOBYTE(v8) = 1;
    return v8 & 1;
  }
  LOBYTE(v8) = 1;
  switch(v13)
  {
    case 1:
      return v8 & 1;
    case 2:
    case 9:
    case 12:
      goto LABEL_3;
    case 4:
      LOBYTE(v8) = 0;
      switch(v12)
      {
        case 4u:
        case 7u:
          return v8 & 1;
        case 8u:
          goto LABEL_14;
        case 0xCu:
          goto LABEL_33;
        default:
          goto LABEL_35;
      }
      return v8 & 1;
    case 5:
      LOBYTE(v8) = 0;
      switch(v12)
      {
        case 4u:
        case 7u:
          return v8 & 1;
        case 8u:
          goto LABEL_14;
        case 0xCu:
          goto LABEL_33;
        default:
          goto LABEL_35;
      }
      return v8 & 1;
    case 6:
      LOBYTE(v8) = 0;
      switch(v12)
      {
        case 4u:
        case 7u:
          return v8 & 1;
        case 8u:
          goto LABEL_14;
        case 0xCu:
          goto LABEL_33;
        default:
          goto LABEL_35;
      }
      return v8 & 1;
    case 10:
      int v14 = v12;
      if (v12 > 0xCu) {
        goto LABEL_35;
      }
      if (((1 << v12) & 0xCE0) == 0) {
        goto LABEL_31;
      }
      goto LABEL_3;
    case 11:
      int v14 = v12;
      if (v12 > 0xCu) {
        goto LABEL_35;
      }
      if (((1 << v12) & 0x8B0) != 0) {
        goto LABEL_3;
      }
LABEL_31:
      if (v14 == 8) {
        goto LABEL_14;
      }
      if (v14 == 12) {
        goto LABEL_33;
      }
      goto LABEL_35;
    default:
      if (v12 == 7) {
        goto LABEL_3;
      }
      if (v12 != 8)
      {
        if (v12 == 12)
        {
          if (v13 == 3)
          {
            LOBYTE(v8) = !specialized _StringGuts.checkIfInEmojiSequence(at:with:)(a3, a4);
            return v8 & 1;
          }
LABEL_33:
          if (!_swift_stdlib_isLinkingConsonant(a2)) {
            goto LABEL_15;
          }
        }
        else
        {
LABEL_35:
          BOOL isLinkingConsonant = _swift_stdlib_isLinkingConsonant(a2);
          if (v12 == 12)
          {
            if (!isLinkingConsonant) {
              goto LABEL_15;
            }
          }
          else
          {
            if (v12 != 2) {
              goto LABEL_15;
            }
            BOOL v16 = a1 > 0x2FF && isLinkingConsonant;
            if (!v16 || !(_swift_stdlib_getNormData(a1) >> 3)) {
              goto LABEL_15;
            }
          }
        }
        LOBYTE(v8) = specialized _StringGuts.checkIfInIndicSequence(at:with:)(a3, a4) ^ 1;
        return v8 & 1;
      }
      if (v13 != 8) {
        goto LABEL_14;
      }
      return specialized _StringGuts.countRIs(at:with:)(a3, a4);
  }
}

BOOL specialized static __CocoaDictionary.Index.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 < 0) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  uint64_t v8 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v7, v8)) {
    goto LABEL_11;
  }
  if (a3 >= 0) {
    a3 &= 0xFFFFFFFFFFFFFF8uLL;
  }
  if (!swift_dynamicCastClass(a3, v8)) {
LABEL_11:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  if (*(void *)(v7 + 16) != *(void *)(a3 + 16)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Comparing indexes from different dictionaries", 45, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x2A2uLL, 0);
  }
  return a2 == a4;
}

BOOL specialized static Unicode._CharacterRecognizer.== infix(_:_:)(uint64_t a1, uint64_t a2)
{
  return ((*(_DWORD *)a1 != *(_DWORD *)a2) | ((*(unsigned char *)(a1 + 4) ^ *(unsigned char *)(a2 + 4)) | (*(unsigned char *)(a1 + 5) ^ *(unsigned char *)(a2 + 5))) & 1 | ((*(unsigned char *)(a1 + 6) ^ *(unsigned char *)(a2 + 6)) | (*(unsigned char *)(a2 + 7) ^ *(unsigned char *)(a1 + 7))) & 1) == 0;
}

uint64_t specialized closure #1 in _StringGuts._foreignOpaqueCharacterStride(endingAt:in:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 >= a1) {
    return 0;
  }
  v7._Swift::UInt64 rawBits = _StringGuts.validateInclusiveScalarIndex(_:)((Swift::String::Index)(a1 << 16))._rawBits;
  if (!(v7._rawBits >> 14)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index is out of bounds", 29, 2, "Swift/StringUnicodeScalarView.swift", 35, 2, 0x84uLL, 0);
  }
  if ((a4 & 0x1000000000000000) != 0)
  {
    Swift::UInt64 rawBits = String.UnicodeScalarView._foreignIndex(before:)(v7)._rawBits;
    v21._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)rawBits)._rawBits;
    LODWORD(result) = _StringGuts.foreignErrorCorrectedScalar(startingAt:)((Swift::String::Index)(v21._rawBits & 0xFFFFFFFFFFFF0000))._0._value;
  }
  else
  {
    if ((a4 & 0x2000000000000000) != 0)
    {
      uint64_t v25 = a3;
      uint64_t v26 = a4 & 0xFFFFFFFFFFFFFFLL;
      char v13 = (char *)&v25 + (v7._rawBits >> 16);
      if ((*(v13 - 1) & 0xC0) == 0x80)
      {
        uint64_t v14 = 0;
        char v15 = v13 - 2;
        do
          int v16 = v15[v14--] & 0xC0;
        while (v16 == 128);
        uint64_t v12 = 1 - v14;
      }
      else
      {
        uint64_t v12 = 1;
      }
    }
    else
    {
      if ((a3 & 0x1000000000000000) != 0)
      {
        id v8 = (id)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else
      {
        Swift::UInt64 v22 = v7._rawBits;
        id v8 = _StringObject.sharedUTF8.getter(a3, a4);
        v7._Swift::UInt64 rawBits = v22;
      }
      uint64_t v9 = 0;
      Swift::UInt64 v10 = (Swift::UInt64)v8 + (v7._rawBits >> 16) - 1;
      do
        int v11 = *(unsigned char *)(v10 + v9--) & 0xC0;
      while (v11 == 128);
      uint64_t v12 = -v9;
    }
    v18._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)((v7._rawBits - (v12 << 16)) & 0xFFFFFFFFFFFF0000 | 5))._rawBits >> 16;
    if ((a4 & 0x2000000000000000) != 0)
    {
      uint64_t v25 = a3;
      uint64_t v26 = a4 & 0xFFFFFFFFFFFFFFLL;
      unsigned int v19 = &v25;
    }
    else if ((a3 & 0x1000000000000000) != 0)
    {
      unsigned int v19 = (void *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      uint64_t v23 = a4;
      Swift::UInt64 v24 = v18._rawBits;
      unsigned int v19 = _StringObject.sharedUTF8.getter(a3, v23);
      v18._Swift::UInt64 rawBits = v24;
    }
    LODWORD(result) = _decodeScalar(_:startingAt:)((uint64_t)v19, v17._rawBits, v18._rawBits);
  }
  return result;
}

uint64_t specialized closure #1 in closure #1 in _StringGuts._opaqueCharacterStride(endingAt:in:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 >= a1) {
    return 0;
  }
  uint64_t v4 = a1;
  do
    int v5 = *(unsigned char *)(a3 - 1 + v4--) & 0xC0;
  while (v5 == 128);
  return _decodeScalar(_:startingAt:)(a3, a2, v4);
}

uint64_t specialized _UIntBuffer._elementWidth.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result < a2 || result >= a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
  }
  return result;
}

unint64_t specialized Substring.UTF8View._failEarlyRangeCheck(_:bounds:)(unint64_t result, unint64_t a2, unint64_t a3)
{
  if (result >> 14 < a2 >> 14 || result >> 14 >= a3 >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
  }
  return result;
}

uint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)(uint64_t result, uint64_t a2)
{
  if (a2 < result || HIDWORD(a2) >= result) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
  }
  return result;
}

uint64_t specialized __CocoaDictionary.Index.key.getter(uint64_t a1, uint64_t a2)
{
  if (a1 < 0) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  uint64_t v4 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v3, v4)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  uint64_t v5 = *(void *)(v3 + 24);
  if (*(void *)(v5 + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
  }
  return *(void *)(v5 + 8 * a2 + 24);
}

uint64_t specialized __CocoaDictionary.key(at:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 < 0) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  uint64_t v6 = type metadata accessor for __CocoaDictionary.Index.Storage();
  if (!swift_dynamicCastClass(v5, v6)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  if (*(void *)(v5 + 16) != a3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Invalid index", 13, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x225uLL, 0);
  }
  uint64_t v7 = *(void *)(v5 + 24);
  if (*(void *)(v7 + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Dictionary elements using an invalid index", 63, 2, "Swift/DictionaryBridging.swift", 30, 2, 0x28BuLL, 0);
  }
  return *(void *)(v7 + 8 * a2 + 24);
}

uint64_t specialized __CocoaSet.Index.element.getter(uint64_t a1, uint64_t a2)
{
  if (a1 < 0) {
    uint64_t v3 = a1;
  }
  else {
    uint64_t v3 = a1 & 0xFFFFFFFFFFFFFF8;
  }
  uint64_t v4 = type metadata accessor for __CocoaSet.Index.Storage();
  if (!swift_dynamicCastClass(v3, v4)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "invalid unsafeDowncast", 22, 2, "Swift/Builtin.swift", 19, 2, 0x10DuLL, 0);
  }
  uint64_t v5 = *(void *)(v3 + 24);
  if (*(void *)(v5 + 16) <= a2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Attempting to access Set elements using an invalid index", 56, 2, "Swift/SetBridging.swift", 23, 2, 0x1E1uLL, 0);
  }
  return *(void *)(v5 + 8 * a2 + 24);
}

Swift::UInt64 specialized String.UnicodeScalarView.subscript.getter(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  Swift::UInt64 rawBits = a2._rawBits;
  Swift::UInt64 v7 = a1._rawBits;
  uint64_t v8 = (a3 >> 59) & 1;
  if ((a4 & 0x1000000000000000) == 0) {
    LOBYTE(v8) = 1;
  }
  uint64_t v9 = a1._rawBits & 0xC;
  uint64_t v10 = 4 << v8;
  uint64_t v11 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v9 == v10 || (a2._rawBits & 1) == 0 || v11 == v10)
  {
    if (v11 == v10)
    {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      if (v9 != v10) {
        goto LABEL_13;
      }
    }
    else if (v9 != v10)
    {
      goto LABEL_13;
    }
    Swift::UInt64 v7 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v7)._rawBits;
LABEL_13:
    uint64_t v14 = a3 & 0xFFFFFFFFFFFFLL;
    if ((a4 & 0x2000000000000000) != 0) {
      uint64_t v14 = HIBYTE(a4) & 0xF;
    }
    if (rawBits >> 14 > 4 * v14 || rawBits >> 14 < v7 >> 14)
    {
      unint64_t v13 = 80;
LABEL_21:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index range is out of bounds", 35, 2, "Swift/StringIndexValidation.swift", 33, 2, v13, 0);
    }
    if (v7)
    {
      if (rawBits) {
        return v7;
      }
    }
    else
    {
      Swift::UInt64 v7 = v7 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v7)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
      if (rawBits) {
        return v7;
      }
    }
    _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
    return v7;
  }
  Swift::UInt64 v12 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000) == 0) {
    Swift::UInt64 v12 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (v12 < a2._rawBits >> 16)
  {
    unint64_t v13 = 210;
    goto LABEL_21;
  }
  return v7;
}

Swift::UInt64 specialized String.UTF8View.subscript.getter(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4)
{
  Swift::UInt64 rawBits = a2._rawBits;
  uint64_t v8 = (a3 >> 59) & 1;
  if ((a4 & 0x1000000000000000) == 0) {
    LOBYTE(v8) = 1;
  }
  uint64_t v9 = 4 << v8;
  if ((a2._rawBits & 0xC) == 4 << v8) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
  }
  if ((a1._rawBits & 0xC) == v9) {
    a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  uint64_t v10 = a3 & 0xFFFFFFFFFFFFLL;
  if ((a4 & 0x2000000000000000) != 0) {
    uint64_t v10 = HIBYTE(a4) & 0xF;
  }
  if (rawBits >> 14 > 4 * v10 || rawBits >> 14 < a1._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index range is out of bounds", 35, 2, "Swift/StringIndexValidation.swift", 33, 2, 0x50uLL, 0);
  }
  return a1._rawBits;
}

Swift::UInt64 specialized Substring.UTF8View.subscript.getter(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6)
{
  Swift::UInt64 rawBits = a2._rawBits;
  uint64_t v10 = (a5 >> 59) & 1;
  if ((a6 & 0x1000000000000000) == 0) {
    LOBYTE(v10) = 1;
  }
  uint64_t v11 = 4 << v10;
  if ((a2._rawBits & 0xC) == 4 << v10) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
  }
  if ((a1._rawBits & 0xC) == v11) {
    a1._Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  if (a1._rawBits >> 14 < a3 >> 14 || rawBits >> 14 < a1._rawBits >> 14 || a4 >> 14 < rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Substring index range is out of bounds", 38, 2, "Swift/StringIndexValidation.swift", 33, 2, 0x63uLL, 0);
  }
  return a1._rawBits;
}

Swift::UInt64 specialized Substring.subscript.getter(Swift::String::Index a1, Swift::String::Index a2, unint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6)
{
  Swift::UInt64 rawBits = a2._rawBits;
  Swift::UInt64 v9 = a1._rawBits;
  uint64_t v10 = (a5 >> 59) & 1;
  if ((a6 & 0x1000000000000000) == 0) {
    LOBYTE(v10) = 1;
  }
  uint64_t v11 = a1._rawBits & 0xC;
  uint64_t v12 = 4 << v10;
  uint64_t v13 = a2._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v11 == v12 || (a2._rawBits & 1) == 0 || v13 == v12)
  {
    if (v13 == v12)
    {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a2)._rawBits;
      if (v11 != v12) {
        goto LABEL_12;
      }
    }
    else if (v11 != v12)
    {
LABEL_12:
      if (v9 >> 14 < a3 >> 14 || rawBits >> 14 < v9 >> 14 || a4 >> 14 < rawBits >> 14) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Substring index range is out of bounds", 38, 2, "Swift/StringIndexValidation.swift", 33, 2, 0x63uLL, 0);
      }
      if (rawBits)
      {
        if (v9) {
          return v9;
        }
      }
      else
      {
        _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits;
        if (v9) {
          return v9;
        }
      }
      return v9 & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v9)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    }
    Swift::UInt64 v9 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v9)._rawBits;
    goto LABEL_12;
  }
  if (a1._rawBits >> 14 < a3 >> 14 || a4 >> 14 < a2._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index range is out of bounds", 35, 2, "Swift/StringIndexValidation.swift", 33, 2, 0xECuLL, 0);
  }
  return v9;
}

uint64_t specialized _SliceBuffer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  }
  return a3;
}

uint64_t specialized ContiguousArray.subscript.getter(Swift::Int a1, Swift::Int a2, uint64_t a3)
{
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  }
  return a3;
}

uint64_t specialized _ContiguousArrayBuffer.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  }
  return a3;
}

uint64_t specialized CollectionDifference.index(after:)(uint64_t a1)
{
  BOOL v1 = __OFADD__(a1, 1);
  uint64_t result = a1 + 1;
  if (v1) {
    __break(1u);
  }
  return result;
}

uint64_t specialized static Duration.+ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v4 = __CFADD__(a1, a3);
  uint64_t result = a1 + a3;
  int v6 = v4;
  if (__OFADD__(a2, a4) || v6 && a2 + a4 == 0x7FFFFFFFFFFFFFFFLL) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x25EuLL, 0);
  }
  return result;
}

unint64_t specialized static Duration.- infix(_:_:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  BOOL v4 = __OFSUB__(a2, a4);
  uint64_t v5 = a2 - a4;
  int v6 = v4;
  BOOL v7 = a1 >= a3;
  unint64_t result = a1 - a3;
  if (v7)
  {
    if (v6) {
      goto LABEL_8;
    }
  }
  else
  {
    if (v5 == 0x8000000000000000) {
      LOBYTE(v6) = 1;
    }
    if (v6) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x252uLL, 0);
  }
  return result;
}

unint64_t specialized String.UTF16View._foreignDistance(from:to:)(unint64_t a1, unint64_t a2)
{
  return (a2 >> 16) - (a1 >> 16);
}

unint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)(unint64_t result, unint64_t a2, unint64_t a3)
{
  if (result >> 14 < a2 >> 14 || a3 >> 14 < result >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  }
  return result;
}

unint64_t specialized RandomAccessCollection<>.distance(from:to:)(unint64_t a1, unint64_t a2)
{
  if (a1 >= 2 || a2 >= 2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  }
  return a2 - a1;
}

{
  if (a1 >= 3 || a2 >= 3) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  }
  return a2 - a1;
}

void **specialized _CocoaArrayWrapper._copyContents(subRange:initializing:)(void **result, uint64_t a2, void **a3, id a4)
{
  if (__OFSUB__(a2, result))
  {
    __break(1u);
  }
  else
  {
    BOOL v4 = a3;
    uint64_t v6 = (uint64_t)result;
    [a4 objects:a3 range:result];
    uint64_t v7 = a2 - v6;
    if (a2 != v6)
    {
      if (a2 <= v6) {
        uint64_t v8 = v6;
      }
      else {
        uint64_t v8 = a2;
      }
      uint64_t v9 = v8 - v6;
      do
      {
        if (!v9) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        }
        uint64_t v10 = *v4++;
        swift_unknownObjectRetain(v10);
        --v9;
        --v7;
      }
      while (v7);
    }
    return v4;
  }
  return result;
}

uint64_t specialized UnsafeBufferPointer.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t v5 = a3 - a1;
  if (__OFSUB__(a3, a1)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a4, 0);
  }
  if (a2 < 1)
  {
    if (v5 > 0 || v5 <= a2) {
      goto LABEL_9;
    }
    return 0;
  }
  if ((v5 & 0x8000000000000000) == 0 && v5 < (unint64_t)a2) {
    return 0;
  }
LABEL_9:
  BOOL v7 = __OFADD__(a1, a2);
  uint64_t result = a1 + a2;
  if (v7) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, a5, 0);
  }
  return result;
}

uint64_t specialized Array.index(_:offsetBy:limitedBy:)(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3 - result;
  if (__OFSUB__(a3, result))
  {
    __break(1u);
    goto LABEL_12;
  }
  if (a2 >= 1)
  {
    if (v3 < 0 || v3 >= (unint64_t)a2) {
      goto LABEL_9;
    }
    return 0;
  }
  if (v3 <= 0 && v3 > a2) {
    return 0;
  }
LABEL_9:
  BOOL v4 = __OFADD__(result, a2);
  result += a2;
  if (v4) {
LABEL_12:
  }
    __break(1u);
  return result;
}

unint64_t specialized RandomAccessCollection.index(_:offsetBy:limitedBy:)(unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 >= 2 || a3 >= 2) {
LABEL_3:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  uint64_t v3 = a3 - a1;
  if (a2 >= 1)
  {
    if (v3 < 0 || v3 >= (unint64_t)a2) {
      goto LABEL_11;
    }
    return 0;
  }
  if (v3 <= 0 && v3 > a2) {
    return 0;
  }
LABEL_11:
  BOOL v5 = __OFADD__(a1, a2);
  unint64_t result = a1 + a2;
  if (v5)
  {
    __break(1u);
  }
  else if (result >= 2)
  {
    goto LABEL_3;
  }
  return result;
}

{
  uint64_t v3;
  unint64_t result;
  BOOL v5;

  if (a1 >= 3 || a3 >= 3) {
LABEL_3:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  uint64_t v3 = a3 - a1;
  if (a2 >= 1)
  {
    if (v3 < 0 || v3 >= (unint64_t)a2) {
      goto LABEL_11;
    }
    return 0;
  }
  if (v3 <= 0 && v3 > a2) {
    return 0;
  }
LABEL_11:
  BOOL v5 = __OFADD__(a1, a2);
  unint64_t result = a1 + a2;
  if (v5)
  {
    __break(1u);
  }
  else if (result >= 3)
  {
    goto LABEL_3;
  }
  return result;
}

unint64_t specialized RandomAccessCollection<>.index(_:offsetBy:)(uint64_t a1, uint64_t a2)
{
  BOOL v2 = __OFADD__(a1, a2);
  unint64_t result = a1 + a2;
  if (v2)
  {
    __break(1u);
  }
  else if (result >= 2)
  {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  }
  return result;
}

{
  BOOL v2;
  unint64_t result;

  BOOL v2 = __OFADD__(a1, a2);
  unint64_t result = a1 + a2;
  if (v2)
  {
    __break(1u);
  }
  else if (result >= 3)
  {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  }
  return result;
}

char *specialized _BidirectionalCollectionBox.init(_base:)(uint64_t a1)
{
  BOOL v2 = v1;
  uint64_t v4 = *(void *)v2;
  uint64_t v5 = *(void *)(*(void *)(*(void *)v2 + 376) + 8);
  uint64_t v6 = *(void *)(*(void *)v2 + 368);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v18 - v9;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v6 - 8) + 16))(&v2[*(void *)(v4 + 384)], a1, v6);
  (*(void (**)(uint64_t, uint64_t))(v5 + 64))(v6, v5);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = (char *)swift_allocObject((unint64_t *)v13, *((unsigned int *)v13 + 12), *((unsigned __int16 *)v13 + 26));
  char v15 = *(void (**)(char *, char *, const char *))(v8 + 32);
  v15(&v14[*(void *)(*(void *)v14 + 96)], v10, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v5 + 72))(v6, v5);
  int v16 = (char *)swift_allocObject((unint64_t *)v13, *((unsigned int *)v13 + 12), *((unsigned __int16 *)v13 + 26));
  v15(&v16[*(void *)(*(void *)v16 + 96)], v10, AssociatedTypeWitness);
  *((void *)v2 + 2) = v14;
  *((void *)v2 + 3) = &protocol witness table for _IndexBox<A>;
  *((void *)v2 + 4) = v16;
  *((void *)v2 + 5) = &protocol witness table for _IndexBox<A>;
  return v2;
}

char *specialized _RandomAccessCollectionBox.init(_base:)(uint64_t a1)
{
  BOOL v2 = v1;
  uint64_t v4 = *(void *)v2;
  uint64_t v5 = *(void *)(*(void *)(*(void *)(*(void *)v2 + 384) + 8) + 8);
  uint64_t v6 = *(void *)(*(void *)v2 + 376);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v18 - v9;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v6 - 8) + 16))(&v2[*(void *)(v4 + 392)], a1, v6);
  (*(void (**)(uint64_t, uint64_t))(v5 + 64))(v6, v5);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = (char *)swift_allocObject((unint64_t *)v13, *((unsigned int *)v13 + 12), *((unsigned __int16 *)v13 + 26));
  char v15 = *(void (**)(char *, char *, const char *))(v8 + 32);
  v15(&v14[*(void *)(*(void *)v14 + 96)], v10, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v5 + 72))(v6, v5);
  int v16 = (char *)swift_allocObject((unint64_t *)v13, *((unsigned int *)v13 + 12), *((unsigned __int16 *)v13 + 26));
  v15(&v16[*(void *)(*(void *)v16 + 96)], v10, AssociatedTypeWitness);
  *((void *)v2 + 2) = v14;
  *((void *)v2 + 3) = &protocol witness table for _IndexBox<A>;
  *((void *)v2 + 4) = v16;
  *((void *)v2 + 5) = &protocol witness table for _IndexBox<A>;
  return v2;
}

char *specialized _CollectionBox.init(_base:)(uint64_t a1)
{
  BOOL v2 = v1;
  uint64_t v4 = *(void *)v2;
  uint64_t v5 = *(void *)(*(void *)v2 + 352);
  uint64_t v6 = *(void *)(*(void *)v2 + 344);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v5, v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v10 = (char *)&v18 - v9;
  (*(void (**)(char *, uint64_t, uint64_t))(*(void *)(v6 - 8) + 16))(&v2[*(void *)(v4 + 360)], a1, v6);
  (*(void (**)(uint64_t, uint64_t))(v5 + 64))(v6, v5);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v13 = type metadata accessor for _IndexBox(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v12);
  uint64_t v14 = (char *)swift_allocObject((unint64_t *)v13, *((unsigned int *)v13 + 12), *((unsigned __int16 *)v13 + 26));
  char v15 = *(void (**)(char *, char *, const char *))(v8 + 32);
  v15(&v14[*(void *)(*(void *)v14 + 96)], v10, AssociatedTypeWitness);
  (*(void (**)(uint64_t, uint64_t))(v5 + 72))(v6, v5);
  int v16 = (char *)swift_allocObject((unint64_t *)v13, *((unsigned int *)v13 + 12), *((unsigned __int16 *)v13 + 26));
  v15(&v16[*(void *)(*(void *)v16 + 96)], v10, AssociatedTypeWitness);
  *((void *)v2 + 2) = v14;
  *((void *)v2 + 3) = &protocol witness table for _IndexBox<A>;
  *((void *)v2 + 4) = v16;
  *((void *)v2 + 5) = &protocol witness table for _IndexBox<A>;
  return v2;
}

uint64_t specialized _UInt128.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(char *, uint64_t, uint64_t), unint64_t a5)
{
  MEMORY[0x1F4188790](a1);
  uint64_t v10 = (char *)&v14 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v11 + 16))(v10);
  uint64_t result = a4(v10, a2, a3);
  if (v13) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000028, 0x80000001816DFAC0, "Swift/LegacyInt128.swift", 24, 2, a5, 0);
  }
  return result;
}

uint64_t specialized UInt128.init<A>(_:)(uint64_t a1, uint64_t a2, void *a3)
{
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v7 + 16))(v6);
  uint64_t result = UInt128.init<A>(exactly:)((uint64_t)v6, a2, a3);
  if (v9) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000052, 0x80000001816E2990, "Swift/UInt128.swift", 19, 2, 0x96uLL, 0);
  }
  return result;
}

uint64_t specialized Int128.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x1F4188790](a1);
  uint64_t v6 = (char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  (*(void (**)(char *))(v7 + 16))(v6);
  uint64_t result = Int128.init<A>(exactly:)((uint64_t)v6, a2, a3);
  if (v9) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000051, 0x80000001816E2A20, "Swift/Int128.swift", 18, 2, 0x99uLL, 0);
  }
  return result;
}

__objc2_class **specialized DiscontiguousSlice._copyToContiguousArray()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a3, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.SubSequence);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  unint64_t v56 = (char *)&v47 - v6;
  uint64_t v7 = swift_getAssociatedTypeWitness(255, (int **)a3, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a3, a2, (uint64_t)v7, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v54 = type metadata accessor for Range(0, (uint64_t)v7, AssociatedConformanceWitness, v8);
  uint64_t v9 = (uint64_t)*(v54 - 1);
  uint64_t v10 = MEMORY[0x1F4188790](v54);
  uint64_t v53 = (char *)&v47 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v10);
  uint64_t v52 = (char *)&v47 - v12;
  char v13 = (uint64_t *)swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 8), a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  _swift_isClassOrObjCExistentialType((uint64_t)v13, v13);
  uint64_t v14 = _ArrayBuffer.requestNativeBuffer()((unint64_t)&_swiftEmptyArrayStorage, v13);
  if (v14)
  {
    Swift::String::Index v17 = (__objc2_class **)v14;
  }
  else
  {
    char v61 = (atomic_ullong *)&_swiftEmptyArrayStorage;
    uint64_t v18 = (unint64_t *)type metadata accessor for Array(0, (uint64_t)v13, v15, v16);
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for [A], v18, v19);
    Swift::String::Index v17 = _copyCollectionToContiguousArray<A>(_:)((uint64_t)&v61, (uint64_t)v18, WitnessTable);
  }
  swift_bridgeObjectRelease((uint64_t)&_swiftEmptyArrayStorage);
  uint64_t v63 = v17;
  uint64_t v22 = *((int *)type metadata accessor for DiscontiguousSlice(0, a2, a3, v21) + 9);
  uint64_t v58 = a1;
  char v61 = *(atomic_ullong **)(a1 + v22);
  unint64_t v62 = 0;
  unint64_t v23 = v61[2];
  Swift::UInt64 v24 = swift_retain(v61);
  if (v23)
  {
    unint64_t v25 = 0;
    uint64_t v26 = v9 + 16;
    uint64_t v50 = v9 + 32;
    uint64_t v51 = (char *)&v62;
    uint64_t v49 = a3 + 88;
    uint64_t v27 = v9 + 8;
    do
    {
      if (v25 >= v23) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/ContiguousArrayBuffer.swift", 33, 2, 0x2A3uLL, 0);
      }
      unint64_t v28 = (unint64_t)v24
          + ((*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80))
          + *(void *)(v9 + 72) * v25;
      uint64_t v29 = *(void (**)(char *, unint64_t, Class *))(v9 + 16);
      unsigned int v30 = v53;
      uint64_t v48 = v27;
      uint64_t v31 = v54;
      uint64_t v59 = v26;
      v29(v53, v28, v54);
      v60[0] = 0;
      v60[1] = v23;
      uint64_t v33 = (unint64_t *)type metadata accessor for RangeSet.Ranges(0, (uint64_t)v7, AssociatedConformanceWitness, v32);
      uint64_t v35 = (int **)swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, v33, v34);
      specialized Collection._failEarlyRangeCheck(_:bounds:)(v51, (uint64_t)v60, (uint64_t)v33, v35);
      unint64_t v62 = v25 + 1;
      uint64_t v36 = v52;
      (*(void (**)(char *, char *, Class *))(v9 + 32))(v52, v30, v31);
      uint64_t v37 = v7;
      uint64_t v38 = v56;
      (*(void (**)(char *, uint64_t, uint64_t))(a3 + 88))(v36, a2, a3);
      uint64_t v39 = v31;
      uint64_t v27 = v48;
      (*(void (**)(char *, Class *))(v9 + 8))(v36, v39);
      uint64_t v42 = type metadata accessor for ContiguousArray(0, (uint64_t)v13, v40, v41);
      uint64_t v43 = AssociatedTypeWitness;
      uint64_t v44 = *(void *)(swift_getAssociatedConformanceWitness(a3, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection)+ 8);
      uint64_t v45 = (void (*)(void, void, void))v38;
      uint64_t v7 = v37;
      ContiguousArray.append<A>(contentsOf:)(v45, (uint64_t)v42, (uint64_t)v43, v44);
      uint64_t v26 = v59;
      Swift::UInt64 v24 = v61;
      unint64_t v25 = v62;
      unint64_t v23 = v61[2];
    }
    while (v62 != v23);
    Swift::String::Index v17 = v63;
  }
  swift_release((uint64_t)v24);
  return v17;
}

uint64_t specialized AnyBidirectionalCollection._copyToContiguousArray()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 144))();
}

void *specialized AnyBidirectionalCollection._copyContents(initializing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (*(uint64_t (**)(void))(*(void *)a3 + 152))();
  uint64_t v8 = (unint64_t *)type metadata accessor for AnyIterator(255, a4, v6, v7);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for AnyIterator<A>, v8, v9);
  uint64_t v12 = (unint64_t *)type metadata accessor for _IteratorBox(0, (uint64_t)v8, WitnessTable, v11);
  uint64_t result = swift_allocObject(v12, 0x18uLL, 7uLL);
  result[2] = v5;
  return result;
}

uint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3, int **a4)
{
  uint64_t v33 = a1;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v36 = (char *)&v29 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  uint64_t v12 = (char *)&v29 - v11;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v15 = type metadata accessor for ClosedRange(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v16 = (uint64_t)*(v15 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v29 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v29 - v20;
  uint64_t v34 = v16;
  uint64_t v32 = *(void (**)(char *, uint64_t, Class *))(v16 + 16);
  v32((char *)&v29 - v20, a2, v15);
  uint64_t v35 = v8;
  uint64_t v22 = *(void (**)(char *, uint64_t, const char *))(v8 + 16);
  v22(v12, v33, AssociatedTypeWitness);
  unint64_t v23 = *(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 24);
  uint64_t v33 = AssociatedConformanceWitness;
  uint64_t v31 = v23;
  LOBYTE(AssociatedConformanceWitness) = v23(v21, v12, AssociatedTypeWitness, AssociatedConformanceWitness);
  unsigned int v30 = v12;
  v22(v36, (uint64_t)v12, AssociatedTypeWitness);
  v32(v19, (uint64_t)v21, v15);
  if ((AssociatedConformanceWitness & 1) == 0)
  {
    (*(void (**)(char *, Class *))(v34 + 8))(v19, v15);
    (*(void (**)(char *, const char *))(v35 + 8))(v36, AssociatedTypeWitness);
LABEL_5:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2D2uLL, 0);
  }
  Swift::UInt64 v24 = v36;
  char v25 = v31(v36, &v19[*((int *)v15 + 9)], AssociatedTypeWitness, v33);
  uint64_t v26 = *(void (**)(char *, Class *))(v34 + 8);
  v26(v19, v15);
  uint64_t v27 = *(void (**)(char *, const char *))(v35 + 8);
  v27(v24, AssociatedTypeWitness);
  if ((v25 & 1) == 0) {
    goto LABEL_5;
  }
  v27(v30, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, Class *))v26)(v21, v15);
}

uint64_t specialized Range<>.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a4, a3, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v12 = (char *)&v15 - v11;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 40))(a2, a3, a4);
  uint64_t v13 = specialized numericCast<A, B>(_:)((uint64_t)v12, (uint64_t)AssociatedTypeWitness, *(void *)(a5 + 8));
  (*(void (**)(char *, const char *))(v10 + 8))(v12, AssociatedTypeWitness);
  return v13;
}

uint64_t specialized static AnyIndex.== infix(_:_:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v9 = (*(uint64_t (**)(unint64_t, uint64_t))(a2 + 8))(ObjectType, a2);
  unint64_t v10 = swift_getObjectType(a3);
  if (v9 != (*(uint64_t (**)(unint64_t, uint64_t))(a4 + 8))(v10, a4)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Base index types differ", 23, 2, "Swift/ExistentialCollection.swift", 33, 2, 0x747uLL, 0);
  }
  unint64_t v11 = swift_getObjectType(a1);
  return (*(uint64_t (**)(unint64_t, uint64_t, unint64_t, uint64_t))(a2 + 24))(a3, a4, v11, a2) & 1;
}

uint64_t specialized static AnyHashable.== infix(_:_:)(void *a1, void *a2)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v4 + 8))(v11, v3, v4);
  uint64_t v5 = v12;
  uint64_t v6 = v13;
  __swift_project_boxed_opaque_existential_0Tm(v11, v12);
  uint64_t v7 = a2[3];
  uint64_t v8 = a2[4];
  __swift_project_boxed_opaque_existential_0Tm(a2, v7);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v8 + 8))(v10, v7, v8);
  LOBYTE(a2) = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v6 + 16))(v10, v5, v6);
  __swift_destroy_boxed_opaque_existential_1Tm(v10);
  __swift_destroy_boxed_opaque_existential_1Tm(v11);
  return a2 & 1;
}

uint64_t specialized Collection._failEarlyRangeCheck(_:bounds:)(char *a1, uint64_t a2, uint64_t a3, int **a4)
{
  uint64_t v34 = a1;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a4, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  unint64_t v10 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v9);
  uint64_t v11 = (uint64_t)*(v10 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v33 = (char *)&v31 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v14 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v31 - v15;
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v31 - v18;
  MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v31 - v20;
  uint64_t v22 = *(void (**)(char *, uint64_t, Class *))(v11 + 16);
  v22((char *)&v31 - v20, a2, v10);
  v22(v19, (uint64_t)v34, v10);
  uint64_t v31 = *(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 24);
  uint64_t v32 = AssociatedConformanceWitness;
  LOBYTE(AssociatedConformanceWitness) = v31(v21, v19, AssociatedTypeWitness, AssociatedConformanceWitness);
  uint64_t v34 = v16;
  unint64_t v23 = v16;
  Swift::UInt64 v24 = v33;
  v22(v23, (uint64_t)v19, v10);
  v22(v24, (uint64_t)v21, v10);
  if ((AssociatedConformanceWitness & 1) == 0)
  {
    unsigned int v30 = *(void (**)(char *, Class *))(v11 + 8);
    v30(v24, v10);
    v30(v34, v10);
LABEL_5:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2DAuLL, 0);
  }
  char v25 = v34;
  char v26 = v31(&v34[*((int *)v10 + 9)], &v24[*((int *)v10 + 9)], AssociatedTypeWitness, v32);
  uint64_t v27 = v24;
  unint64_t v28 = *(void (**)(char *, Class *))(v11 + 8);
  v28(v27, v10);
  v28(v25, v10);
  if ((v26 & 1) == 0) {
    goto LABEL_5;
  }
  v28(v19, v10);
  return ((uint64_t (*)(char *, Class *))v28)(v21, v10);
}

{
  const char *AssociatedTypeWitness;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t AssociatedConformanceWitness;
  uint64_t v14;
  Class *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  void (*v22)(char *, char *, const char *);
  char *v23;
  char v24;
  void (*v25)(char *, Class *);
  void (*v26)(char *, const char *);
  uint64_t v28;
  void (*v29)(char *, uint64_t, Class *);
  char *v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;

  unsigned int v30 = a1;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, a4, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v33 = (char *)&v28 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  uint64_t v12 = (char *)&v28 - v11;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)a4, a3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v15 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v14);
  uint64_t v16 = (uint64_t)*(v15 - 1);
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v19 = (char *)&v28 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v17);
  uint64_t v21 = (char *)&v28 - v20;
  uint64_t v31 = v16;
  uint64_t v29 = *(void (**)(char *, uint64_t, Class *))(v16 + 16);
  v29((char *)&v28 - v20, a2, v15);
  uint64_t v32 = v8;
  uint64_t v22 = *(void (**)(char *, char *, const char *))(v8 + 16);
  v22(v12, v30, AssociatedTypeWitness);
  LOBYTE(a2) = (*(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 24))(v21, v12, AssociatedTypeWitness, AssociatedConformanceWitness);
  unsigned int v30 = v12;
  v22(v33, v12, AssociatedTypeWitness);
  v29(v19, (uint64_t)v21, v15);
  if ((a2 & 1) == 0)
  {
    (*(void (**)(char *, Class *))(v31 + 8))(v19, v15);
    (*(void (**)(char *, const char *))(v32 + 8))(v33, AssociatedTypeWitness);
LABEL_5:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of bounds", 19, 2, "Swift/Collection.swift", 22, 2, 0x2CAuLL, 0);
  }
  unint64_t v23 = v33;
  Swift::UInt64 v24 = (*(uint64_t (**)(char *, char *, const char *, uint64_t))(AssociatedConformanceWitness + 16))(v33, &v19[*((int *)v15 + 9)], AssociatedTypeWitness, AssociatedConformanceWitness);
  char v25 = *(void (**)(char *, Class *))(v31 + 8);
  v25(v19, v15);
  char v26 = *(void (**)(char *, const char *))(v32 + 8);
  v26(v23, AssociatedTypeWitness);
  if ((v24 & 1) == 0) {
    goto LABEL_5;
  }
  v26(v30, AssociatedTypeWitness);
  return ((uint64_t (*)(char *, Class *))v25)(v21, v15);
}

uint64_t specialized static AnyIndex.< infix(_:_:)(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t ObjectType = swift_getObjectType(a1);
  uint64_t v9 = (*(uint64_t (**)(unint64_t, uint64_t))(a2 + 8))(ObjectType, a2);
  unint64_t v10 = swift_getObjectType(a3);
  if (v9 != (*(uint64_t (**)(unint64_t, uint64_t))(a4 + 8))(v10, a4)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Base index types differ", 23, 2, "Swift/ExistentialCollection.swift", 33, 2, 0x755uLL, 0);
  }
  unint64_t v11 = swift_getObjectType(a1);
  return (*(uint64_t (**)(unint64_t, uint64_t, unint64_t, uint64_t))(a2 + 32))(a3, a4, v11, a2) & 1;
}

uint64_t specialized UInt128.init<A>(truncatingIfNeeded:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 - 8);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  uint64_t v9 = (char *)&v16 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v17 = 64;
  unint64_t v11 = *(void (**)(uint64_t, uint64_t *, ValueMetadata *, unint64_t, uint64_t, uint64_t))(v10 + 240);
  unint64_t v13 = lazy protocol witness table accessor for type Int and conformance Int(v7, v12, v10);
  v11(a1, &v17, &type metadata for Int, v13, a2, a3);
  uint64_t v14 = *(void (**)(uint64_t, uint64_t))(a3 + 120);
  v14(a2, a3);
  (*(void (**)(char *, uint64_t))(v6 + 8))(v9, a2);
  return ((uint64_t (*)(uint64_t, uint64_t))v14)(a2, a3);
}

void *specialized static _Int128.+= infix(_:_:)(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[1];
  BOOL v4 = __CFADD__(*result, a2);
  BOOL v5 = __OFADD__(v3, a3);
  uint64_t v6 = v3 + a3;
  if (v5 || (v4 ? (BOOL v7 = v6 == 0x7FFFFFFFFFFFFFFFLL) : (BOOL v7 = 0), v7)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x264uLL, 0);
  }
  *result += a2;
  result[1] = v6 + v4;
  return result;
}

void *specialized static Duration.+= infix(_:_:)(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[1];
  BOOL v4 = __CFADD__(*result, a2);
  BOOL v5 = __OFADD__(v3, a3);
  uint64_t v6 = v3 + a3;
  if (v5 || (v4 ? (BOOL v7 = v6 == 0x7FFFFFFFFFFFFFFFLL) : (BOOL v7 = 0), v7)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x25EuLL, 0);
  }
  *result += a2;
  result[1] = v6 + v4;
  return result;
}

void *specialized static _UInt128.+= infix(_:_:)(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[1];
  BOOL v4 = __CFADD__(*result, a2);
  BOOL v5 = __CFADD__(v3, a3);
  uint64_t v6 = v3 + a3;
  if (v5 || (v4 ? (BOOL v7 = v6 == -1) : (BOOL v7 = 0), v7)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in +=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x71uLL, 0);
  }
  *result += a2;
  result[1] = v6 + v4;
  return result;
}

char *partial apply for closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)(char *a1, uint64_t a2)
{
  return partial apply for closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)(a1, a2);
}

{
  uint64_t v2;

  return closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)(a1, a2, *(void *)(v2 + 48), *(char **)(v2 + 56), *(void *)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32));
}

Class *type metadata accessor for _ArrayBuffer(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _ArrayBuffer.Flags, &flag for loading of canonical specialized generic type metadata for _ArrayBuffer);
}

char *specialized _ContiguousArrayBuffer._copyContents(subRange:initializing:)(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4, unint64_t *a5)
{
  uint64_t v5 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  uint64_t v7 = *(void *)(*(a5 - 1) + 72);
  if (v5 < 0) {
    goto LABEL_9;
  }
  uint64_t v6 = *(unsigned __int8 *)(*(a5 - 1) + 80);
  uint64_t v8 = (char *)(a4 + ((v6 + 32) & ~v6) + v7 * a1);
  uint64_t v9 = v7 * v5;
  uint64_t v10 = &__dst[v9];
  unint64_t v11 = (unint64_t)&v8[v9];
  if (v8 < v10 && v11 > (unint64_t)__dst) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  }
  swift_arrayInitWithCopy(__dst, v8, v5, a5);
  return v10;
}

char *specialized _ArrayBuffer._copyContents(subRange:initializing:)(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_9:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if (v5 < 0) {
    goto LABEL_9;
  }
  uint64_t v7 = (char *)(a4 + 40 * a1 + 32);
  uint64_t v8 = &a3[40 * v5];
  if (v7 < v8 && &v7[40 * v5] > a3) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  }
  uint64_t v10 = (unint64_t *)__swift_instantiateConcreteTypeFromMangledName(a5);
  swift_arrayInitWithCopy(a3, v7, v5, v10);
  return v8;
}

uint64_t specialized _ArrayBuffer.owner.getter(uint64_t a1, uint64_t *a2)
{
  if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2) && (a1 < 0 || (a1 & 0x4000000000000000) != 0))
  {
    if (a1 < 0) {
      return a1;
    }
    else {
      return a1 & 0xFFFFFFFFFFFFFF8;
    }
  }
  else if (_swift_isClassOrObjCExistentialType((uint64_t)a2, a2))
  {
    return a1 & 0xFFFFFFFFFFFFFF8;
  }
  else
  {
    return a1;
  }
}

Class *type metadata accessor for CollectionOfOne(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for CollectionOfOne.Flags, &flag for loading of canonical specialized generic type metadata for CollectionOfOne);
}

void specialized _ArrayBuffer.subscript.setter()
{
}

uint64_t partial apply for closure #1 in MutableCollection<>.partition(by:)@<X0>(void *a1@<X8>)
{
  return closure #1 in MutableCollection<>.partition(by:)(*(uint64_t (**)(char *))(v1 + 40), *(void *)(v1 + 48), *(void *)(v1 + 16), *(void *)(v1 + 24), a1);
}

Class *type metadata accessor for ClosedRange(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for ClosedRange.Flags, &flag for loading of canonical specialized generic type metadata for ClosedRange);
}

Class *type metadata accessor for Range(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Range.Flags, &flag for loading of canonical specialized generic type metadata for Range);
}

uint64_t type metadata accessor for __StaticArrayStorage()
{
  return self;
}

uint64_t type metadata accessor for __SwiftDeferredNSArray()
{
  return self;
}

Class *type metadata accessor for __SwiftDeferredStaticNSArray(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for __SwiftDeferredStaticNSArray.Flags);
}

Class *type metadata accessor for _ContiguousArrayStorage(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _ContiguousArrayStorage.Flags, &flag for loading of canonical specialized generic type metadata for _ContiguousArrayStorage);
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<String>()
{
  return self;
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>()
{
  return self;
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Swift.AnyObject>()
{
  return self;
}

void partial apply for closure #1 in _assertionFailure(_:_:flags:)(const char *a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(v2 + 16);
  unint64_t v6 = *(void *)(v2 + 24);
  int v7 = *(_DWORD *)(v2 + 32);
  swift_bridgeObjectRetain(v6);
  if ((v6 & 0x1000000000000000) != 0)
  {
    uint64_t v5 = specialized static String._copying(_:)(v5, v6);
    unint64_t v11 = v10;
    swift_bridgeObjectRelease(v6);
    unint64_t v6 = v11;
    if ((v11 & 0x2000000000000000) == 0) {
      goto LABEL_3;
    }
LABEL_9:
    v12[0] = v5;
    v12[1] = v6 & 0xFFFFFFFFFFFFFFLL;
    closure #1 in closure #1 in _assertionFailure(_:_:flags:)((const char *)v12, HIBYTE(v6) & 0xF, a1, a2, v7);
    swift_bridgeObjectRelease(v6);
    return;
  }
  if ((v6 & 0x2000000000000000) != 0) {
    goto LABEL_9;
  }
LABEL_3:
  if ((v5 & 0x1000000000000000) != 0)
  {
    uint64_t v8 = (const char *)((v6 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v9 = v5 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v8 = (const char *)_StringObject.sharedUTF8.getter(v5, v6);
  }
  closure #1 in closure #1 in _assertionFailure(_:_:flags:)(v8, v9, a1, a2, v7);

  swift_bridgeObjectRelease(v6);
}

Class *type metadata accessor for UnsafePointer(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for UnsafePointer.Flags, &flag for loading of canonical specialized generic type metadata for UnsafePointer);
}

Class *type metadata accessor for ContiguousArray(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for ContiguousArray.Flags, &flag for loading of canonical specialized generic type metadata for ContiguousArray);
}

Class *type metadata accessor for Array(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Array.Flags, &flag for loading of canonical specialized generic type metadata for Array);
}

_OWORD *outlined init with take of Any(_OWORD *a1, _OWORD *a2)
{
  long long v2 = a1[1];
  *a2 = *a1;
  a2[1] = v2;
  return a2;
}

Class *type metadata accessor for ArraySlice(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for ArraySlice.Flags);
}

uint64_t partial apply for closure #1 in Array.withContiguousStorageIfAvailable<A>(_:)()
{
  return (*(uint64_t (**)(void))(v0 + 32))();
}

uint64_t specialized static _HashTable.scale(forCapacity:)(uint64_t result)
{
  if (result <= 1) {
    uint64_t v1 = 1;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v2 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v2 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  BOOL v3 = __OFADD__(v1, 1);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
  }
  else
  {
    if (v4 <= (uint64_t)v2) {
      uint64_t v4 = (uint64_t)v2;
    }
    unsigned int v5 = 64 - __clz(v4 - 1);
    if ((unint64_t)v4 <= 2) {
      return 1;
    }
    else {
      return v5;
    }
  }
  return result;
}

uint64_t specialized static _HashTable.capacity(forScale:)(char a1)
{
  double v1 = (double)(1 << a1) * 0.75;
  if ((~*(void *)&v1 & 0x7FF0000000000000) == 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  }
  if (v1 <= -9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  }
  if (v1 >= 9.22337204e18) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  }
  return (uint64_t)v1;
}

uint64_t specialized static _DictionaryStorage.resize(original:capacity:move:)(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result <= 1) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = result;
  }
  double v5 = ceil((double)v4 / 0.75);
  if ((~*(void *)&v5 & 0x7FF0000000000000) == 0) {
    goto LABEL_23;
  }
  if (v5 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v5 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v6 = __OFADD__(v4, 1);
  uint64_t v7 = v4 + 1;
  if (v6)
  {
    __break(1u);
    return result;
  }
  if (v7 <= (uint64_t)v5) {
    uint64_t v7 = (uint64_t)v5;
  }
  char v10 = 64 - __clz(v7 - 1);
  unsigned __int8 v11 = (unint64_t)v7 <= 2 ? 1 : v10;
  uint64_t v12 = 1 << v11;
  unint64_t v13 = (unint64_t)((1 << v11) + 63) >> 6;
  uint64_t v14 = (unint64_t *)type metadata accessor for _DictionaryStorage(0, a2, a3, a4);
  uint64_t v15 = *(unsigned __int8 *)(*(void *)(a2 - 8) + 80);
  uint64_t v16 = v15 + 8 * v13;
  uint64_t v17 = *(void *)(*(void *)(a2 - 8) + 72) << v11;
  uint64_t v18 = *(unsigned __int8 *)(*(void *)(a3 - 8) + 80);
  uint64_t v19 = v17 + v18;
  uint64_t v20 = (int64x2_t *)swift_allocObject(v14, ((((v16 + 64) & ~v15) + v17 + v18) & ~v18) + (*(void *)(*(void *)(a3 - 8) + 72) << v11), v15 | v18 | 7);
  v20[1].i64[0] = 0;
  double v21 = (double)(1 << v11) * 0.75;
  if ((~*(void *)&v21 & 0x7FF0000000000000) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v21 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v21 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  uint64_t v22 = (uint64_t *)v20;
  unint64_t v23 = v20 + 4;
  uint64_t v24 = ((unint64_t)v20[4].u64 + v16) & ~v15;
  v20[1].i64[1] = (uint64_t)v21;
  v20[2].i8[0] = v11;
  v20[2].i8[1] = 0;
  v20[2].i16[1] = 0;
  v20[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v20);
  if ((_BYTE)qword_1EB208F08) {
    char v25 = (uint64_t *)v11;
  }
  else {
    char v25 = v22;
  }
  v22[5] = (uint64_t)v25;
  v22[6] = v24;
  v22[7] = (v24 + v19) & ~v18;
  if (v12 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v13, v23);
  }
  else {
    v23->i64[0] = -1 << v12;
  }
  return (uint64_t)v22;
}

void specialized EmptyCollection.subscript.setter()
{
}

char *specialized _ContiguousArrayBuffer._copyContents(subRange:initializing:)(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if (v4 < 0) {
    goto LABEL_7;
  }
  double v5 = (char *)(a4 + 16 * a1 + 32);
  BOOL v6 = &__dst[16 * v4];
  if (v5 < v6 && &v5[16 * v4] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  }
  swift_arrayInitWithCopy(__dst, v5, v4, (unint64_t *)&type metadata for String);
  return v6;
}

{
  uint64_t v4;
  char *v5;
  size_t v6;
  char *v7;

  uint64_t v4 = a2 - a1;
  if (__OFSUB__(a2, a1))
  {
    __break(1u);
LABEL_7:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize with negative count", 51, 2, "Swift/UnsafePointer.swift", 25, 2, 0x442uLL, 0);
  }
  if (v4 < 0) {
    goto LABEL_7;
  }
  double v5 = (char *)(a4 + 4 * a1 + 32);
  BOOL v6 = 4 * v4;
  uint64_t v7 = &__dst[v6];
  if (v5 < &__dst[v6] && &v5[v6] > __dst) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutablePointer.initialize overlapping range", 49, 2, "Swift/UnsafePointer.swift", 25, 2, 0x444uLL, 0);
  }
  memcpy(__dst, v5, v6);
  return v7;
}

Class *type metadata accessor for EmptyCollection(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for EmptyCollection.Flags, &flag for loading of canonical specialized generic type metadata for EmptyCollection);
}

uint64_t specialized Collection.subscript.getter(Swift::String::Index a1, unint64_t a2, unint64_t a3)
{
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v6 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000) == 0) {
    LOBYTE(v6) = 1;
  }
  uint64_t v7 = 4 << v6;
  uint64_t v8 = a1._rawBits & 0xC;
  if ((a1._rawBits & 1) == 0 || v8 == v7)
  {
    if (v8 == v7) {
      Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
    }
    uint64_t v11 = HIBYTE(a3) & 0xF;
    if ((a3 & 0x2000000000000000) == 0) {
      uint64_t v11 = a2 & 0xFFFFFFFFFFFFLL;
    }
    if (4 * v11 < rawBits >> 14)
    {
      unint64_t v10 = 80;
LABEL_15:
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index range is out of bounds", 35, 2, "Swift/StringIndexValidation.swift", 33, 2, v10, 0);
    }
    if ((rawBits & 1) == 0) {
      _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits);
    }
  }
  else
  {
    Swift::UInt64 v9 = HIBYTE(a3) & 0xF;
    if ((a3 & 0x2000000000000000) == 0) {
      Swift::UInt64 v9 = a2 & 0xFFFFFFFFFFFFLL;
    }
    if (v9 < a1._rawBits >> 16)
    {
      unint64_t v10 = 210;
      goto LABEL_15;
    }
  }
  return 15;
}

unint64_t specialized static String.+ infix(_:_:)(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v8 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0) {
    uint64_t v8 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (!v8 && (a1 & ~a2 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRetain(a4);
    return a3;
  }
  if ((a2 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRetain(a2);
    if ((a4 & 0x2000000000000000) != 0) {
      goto LABEL_12;
    }
LABEL_9:
    uint64_t v9 = a3 & 0xFFFFFFFFFFFFLL;
LABEL_13:
    _StringGuts.append(_:)(a3, a4, 0, v9);
    return a1;
  }
  swift_bridgeObjectRetain(a2);
  if ((a4 & 0x2000000000000000) == 0) {
    goto LABEL_9;
  }
  unint64_t v10 = specialized _SmallString.init(_:appending:)(a1, a2, a3, a4);
  if (v11)
  {
LABEL_12:
    uint64_t v9 = HIBYTE(a4) & 0xF;
    goto LABEL_13;
  }
  unint64_t v12 = v10;
  swift_bridgeObjectRelease(a2);
  return v12;
}

Swift::UInt64 specialized Collection.subscript.getter(Swift::String::Index a1, unint64_t a2, unint64_t a3)
{
  uint64_t v3 = a2 & 0xFFFFFFFFFFFFLL;
  if ((a3 & 0x2000000000000000) != 0) {
    uint64_t v3 = HIBYTE(a3) & 0xF;
  }
  uint64_t v4 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000) == 0) {
    LODWORD(v4) = 1;
  }
  uint64_t v5 = 11;
  if (v4) {
    uint64_t v5 = 7;
  }
  unint64_t v6 = 4 * v3;
  Swift::UInt64 v7 = a1._rawBits >> 14;
  if (4 * v3 < a1._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  Swift::UInt64 rawBits = a1._rawBits;
  Swift::UInt64 v9 = v5 | (v3 << 16);
  uint64_t v10 = a1._rawBits & 0xC;
  uint64_t v11 = 4 << v4;
  uint64_t v12 = v5 & 0xC;
  if ((a1._rawBits & 1) == 0 || v10 == v11 || v12 == v11)
  {
    if (v12 == v11)
    {
      Swift::UInt64 v9 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v9)._rawBits;
      if (v10 != v11) {
        goto LABEL_13;
      }
    }
    else if (v10 != v11)
    {
LABEL_13:
      if (v6 < v9 >> 14 || v9 >> 14 < v7) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index range is out of bounds", 35, 2, "Swift/StringIndexValidation.swift", 33, 2, 0x50uLL, 0);
      }
      if (rawBits)
      {
        if (v9) {
          return rawBits;
        }
      }
      else
      {
        Swift::UInt64 rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
        if (v9) {
          return rawBits;
        }
      }
      _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v9)._rawBits;
      return rawBits;
    }
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
    Swift::UInt64 v7 = rawBits >> 14;
    goto LABEL_13;
  }
  return rawBits;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  Swift::UInt64 v7;
  Swift::UInt64 rawBits;
  Swift::UInt64 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  uint64_t v3 = a2 & 0xFFFFFFFFFFFFLL;
  if ((a3 & 0x2000000000000000) != 0) {
    uint64_t v3 = HIBYTE(a3) & 0xF;
  }
  uint64_t v4 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000) == 0) {
    LODWORD(v4) = 1;
  }
  uint64_t v5 = 11;
  if (v4) {
    uint64_t v5 = 7;
  }
  unint64_t v6 = 4 * v3;
  Swift::UInt64 v7 = a1._rawBits >> 14;
  if (4 * v3 < a1._rawBits >> 14) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  Swift::UInt64 rawBits = a1._rawBits;
  Swift::UInt64 v9 = v5 | (v3 << 16);
  uint64_t v10 = a1._rawBits & 0xC;
  uint64_t v11 = 4 << v4;
  uint64_t v12 = v5 & 0xC;
  if ((a1._rawBits & 1) != 0 && v10 != v11 && v12 != v11) {
    goto LABEL_17;
  }
  if (v12 == v11)
  {
    Swift::UInt64 v9 = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)v9)._rawBits;
    if (v10 != v11) {
      goto LABEL_13;
    }
  }
  else if (v10 != v11)
  {
    goto LABEL_13;
  }
  Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)((Swift::String::Index)rawBits)._rawBits;
  Swift::UInt64 v7 = rawBits >> 14;
LABEL_13:
  if (v6 < v9 >> 14 || v9 >> 14 < v7) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "String index range is out of bounds", 35, 2, "Swift/StringIndexValidation.swift", 33, 2, 0x50uLL, 0);
  }
  if (rawBits)
  {
    if (v9) {
      goto LABEL_17;
    }
  }
  else
  {
    Swift::UInt64 rawBits = rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)rawBits)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    if (v9) {
      goto LABEL_17;
    }
  }
  _StringGuts.scalarAlignSlow(_:)((Swift::String::Index)v9)._rawBits;
LABEL_17:
  if (rawBits >= 0x10000) {
    return rawBits;
  }
  else {
    return rawBits | 3;
  }
}

Swift::Int specialized LazyMapSequence<>.formIndex(after:)(Swift::String::Index *a1, uint64_t a2, unint64_t a3)
{
  v6._Swift::UInt64 rawBits = _StringGuts.validateCharacterIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  Swift::UInt64 v7 = (v6._rawBits >> 8) & 0x3F;
  uint64_t v8 = a3 & 0x2000000000000000;
  uint64_t v9 = HIBYTE(a3) & 0xF;
  uint64_t v10 = a2 & 0xFFFFFFFFFFFFLL;
  if (v7) {
    goto LABEL_27;
  }
  if (v8) {
    uint64_t v11 = HIBYTE(a3) & 0xF;
  }
  else {
    uint64_t v11 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v6._rawBits >> 14 == 4 * v11)
  {
    Swift::UInt64 v7 = 0;
    goto LABEL_27;
  }
  Swift::UInt64 v12 = v6._rawBits >> 16;
  if ((a3 & 0x1000000000000000) != 0) {
    goto LABEL_56;
  }
  if (!v8)
  {
    if ((a2 & 0x1000000000000000) != 0)
    {
      unint64_t v13 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      uint64_t v14 = a2 & 0xFFFFFFFFFFFFLL;
    }
    else
    {
      unint64_t v13 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
      Swift::UInt64 v12 = v6._rawBits >> 16;
    }
    if (v12 + 1 != v14)
    {
      if (!v13) {
        goto LABEL_59;
      }
      int v15 = *(unsigned __int16 *)&v13[v12];
      if (v15 == 2573 || (v15 & 0x80808080) != 0) {
        goto LABEL_56;
      }
    }
    uint64_t v8 = 0;
LABEL_26:
    Swift::UInt64 v7 = 1;
    goto LABEL_27;
  }
  uint64_t v31 = a2;
  uint64_t v32 = a3 & 0xFFFFFFFFFFFFFFLL;
  if (v12 + 1 == v9
    || ((int v17 = *(unsigned __int16 *)((char *)&v31 + v12), v17 != 2573) ? (v18 = (v17 & 0x80808080) == 0) : (v18 = 0), v18))
  {
    uint64_t v8 = 1;
    goto LABEL_26;
  }
LABEL_56:
  Swift::UInt64 v7 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v12);
LABEL_27:
  Swift::UInt64 v19 = v6._rawBits + (v7 << 16);
  unint64_t v20 = v19 & 0xFFFFFFFFFFFF0000;
  if (v8) {
    uint64_t v21 = HIBYTE(a3) & 0xF;
  }
  else {
    uint64_t v21 = a2 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v22 = a3 & 0x1000000000000000;
  if (v20 >> 14 == 4 * v21)
  {
    Swift::Int result = 0;
LABEL_47:
    v20 |= result << 8;
    goto LABEL_48;
  }
  Swift::Int v24 = v19 >> 16;
  if (!v22)
  {
    if (v8)
    {
      uint64_t v31 = a2;
      uint64_t v32 = a3 & 0xFFFFFFFFFFFFFFLL;
      if (v24 + 1 == v9) {
        goto LABEL_46;
      }
      int v25 = *(unsigned __int16 *)((char *)&v31 + v24);
LABEL_41:
      if (v25 == 2573 || (v25 & 0x8080) != 0) {
        goto LABEL_54;
      }
LABEL_46:
      uint64_t v22 = 0;
      Swift::Int result = 1;
      goto LABEL_47;
    }
    if ((a2 & 0x1000000000000000) != 0)
    {
      char v26 = (char *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      char v26 = (char *)_StringObject.sharedUTF8.getter(a2, a3);
      uint64_t v10 = v30;
    }
    if (v24 + 1 == v10) {
      goto LABEL_46;
    }
    if (v26)
    {
      int v25 = *(unsigned __int16 *)&v26[v24];
      goto LABEL_41;
    }
LABEL_59:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
LABEL_54:
  Swift::Int result = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v24);
  if (result <= 63) {
    goto LABEL_47;
  }
LABEL_48:
  BOOL v28 = (a2 & 0x800000000000000) != 0 || v22 == 0;
  uint64_t v29 = 7;
  if (!v28) {
    uint64_t v29 = 11;
  }
  a1->_Swift::UInt64 rawBits = v20 | v29;
  return result;
}

uint64_t specialized LazyMapSequence<>.distance(from:to:)(Swift::String::Index a1, Swift::String::Index a2, uint64_t a3, unint64_t a4)
{
  v7._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(a1)._rawBits;
  v8._Swift::UInt64 rawBits = _StringGuts.validateInclusiveCharacterIndex_5_7(_:)(a2)._rawBits;
  uint64_t v9 = v7._rawBits >> 16;
  if (v7._rawBits >> 14 < v8._rawBits >> 14)
  {
    int64_t v10 = v8._rawBits >> 16;
    if (v9 < v8._rawBits >> 16)
    {
      uint64_t v11 = 1;
      if ((a4 & 0x1000000000000000) == 0) {
        goto LABEL_6;
      }
LABEL_19:
      int64_t v14 = _StringGuts._opaqueComplexCharacterStride(startingAt:)(v9) + v9;
      while (v14 < v10)
      {
        ++v11;
        uint64_t v9 = v14;
        if ((a4 & 0x1000000000000000) != 0) {
          goto LABEL_19;
        }
LABEL_6:
        if ((a4 & 0x2000000000000000) != 0)
        {
          uint64_t v25 = a3;
          uint64_t v26 = a4 & 0xFFFFFFFFFFFFFFLL;
          int64_t v14 = v9 + 1;
          if (v9 + 1 != (HIBYTE(a4) & 0xF))
          {
            int v16 = *(unsigned __int16 *)((char *)&v25 + v9);
            if (v16 == 2573 || (v16 & 0x80808080) != 0) {
              goto LABEL_19;
            }
          }
        }
        else
        {
          Swift::UInt64 v12 = (char *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v13 = a3 & 0xFFFFFFFFFFFFLL;
          if ((a3 & 0x1000000000000000) == 0) {
            Swift::UInt64 v12 = (char *)_StringObject.sharedUTF8.getter(a3, a4);
          }
          int64_t v14 = v9 + 1;
          if (v9 + 1 != v13)
          {
            if (!v12) {
              goto LABEL_43;
            }
            int v15 = *(unsigned __int16 *)&v12[v9];
            if (v15 == 2573 || (v15 & 0x80808080) != 0) {
              goto LABEL_19;
            }
          }
        }
      }
      return v11;
    }
    return 0;
  }
  if (v8._rawBits >> 14 >= v7._rawBits >> 14) {
    return 0;
  }
  int64_t v18 = v8._rawBits >> 16;
  if (v8._rawBits >> 16 >= v9) {
    return 0;
  }
  uint64_t v11 = -1;
  if (v9 >= 2) {
    goto LABEL_28;
  }
  while (1)
  {
    Swift::Int v19 = 1;
LABEL_26:
    v9 -= v19;
    if (v18 >= v9) {
      return v11;
    }
    while (1)
    {
      --v11;
      if (v9 < 2) {
        break;
      }
LABEL_28:
      if ((a4 & 0x1000000000000000) != 0) {
        goto LABEL_41;
      }
      if ((a4 & 0x2000000000000000) != 0)
      {
        uint64_t v25 = a3;
        uint64_t v26 = a4 & 0xFFFFFFFFFFFFFFLL;
        uint64_t v21 = (char *)&v25 + v9;
      }
      else
      {
        unint64_t v20 = (char *)((a4 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((a3 & 0x1000000000000000) == 0)
        {
          unint64_t v20 = (char *)_StringObject.sharedUTF8.getter(a3, a4);
          if (!v20) {
LABEL_43:
          }
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
        }
        uint64_t v21 = &v20[v9];
      }
      int v22 = *((unsigned __int16 *)v21 - 1);
      if (v22 == 2573 || (v22 & 0x80808080) != 0)
      {
LABEL_41:
        Swift::Int v19 = _StringGuts._opaqueComplexCharacterStride(endingAt:)(v9);
        goto LABEL_26;
      }
      if (v18 >= --v9) {
        return v11;
      }
    }
  }
}

unint64_t specialized _StringGuts.uniqueNativeReplaceSubrange(_:with:isASCII:)(unint64_t result, unint64_t a2, char *a3, size_t a4)
{
  uint64_t v5 = result >> 16;
  unint64_t v6 = (result >> 16) + a4;
  if (__OFADD__(result >> 16, a4))
  {
    __break(1u);
  }
  else
  {
    Swift::String::Index v7 = v4;
    uint64_t v8 = a2 >> 16;
    unint64_t v9 = v4[1];
    if ((v9 & 0x2000000000000000) != 0) {
      uint64_t v10 = HIBYTE(v9) & 0xF;
    }
    else {
      uint64_t v10 = *v4 & 0xFFFFFFFFFFFFLL;
    }
    uint64_t v11 = v10 - v8;
    Swift::Int result = v6 + v11;
    if (!__OFADD__(v6, v11))
    {
      _StringGuts.reserveCapacity(_:)(result);
      uint64_t v14 = v4[1] & 0xFFFFFFFFFFFFFFFLL;
      __StringStorage.replace(from:to:with:)(v5, v8, a3, a4);
      *Swift::String::Index v7 = *(void *)(v14 + 24);
      return v5;
    }
  }
  __break(1u);
  return result;
}

void *specialized _ArrayBufferProtocol._arrayOutOfPlaceReplace<A>(_:with:count:)(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2 - (void)result;
  if (__OFSUB__(a2, result))
  {
    __break(1u);
    goto LABEL_7;
  }
  uint64_t v10 = a4 - v8;
  if (__OFSUB__(a4, v8))
  {
LABEL_7:
    __break(1u);
    goto LABEL_8;
  }
  int v16 = result;
  uint64_t v17 = *(void *)(*(void *)(a7 + 8) + 8);
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 112))(a5, v17);
  BOOL v19 = __OFADD__(v18, v10);
  Swift::Int result = (void *)(v18 + v10);
  if (v19)
  {
LABEL_8:
    __break(1u);
    goto LABEL_9;
  }
  unint64_t v20 = _ArrayBufferProtocol._forceCreateUniqueMutableBuffer(newCount:requiredCapacity:)((uint64_t)result, (uint64_t)result, a5, a7);
  Swift::Int v24 = v20;
  Swift::Int result = (*(void *(**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v17 + 64))(&v23, a5, v17);
  if (!__OFSUB__(v16, v23))
  {
    MEMORY[0x1F4188790](result);
    v22[2] = a5;
    v22[3] = a6;
    v22[4] = a7;
    v22[5] = a8;
    v22[6] = a3;
    _ArrayBufferProtocol._arrayOutOfPlaceUpdate(_:_:_:_:)((atomic_ullong **)&v24, v21, a4, (void (*)(char *, uint64_t))partial apply for closure #1 in _ArrayBufferProtocol._arrayOutOfPlaceReplace<A>(_:with:count:), (uint64_t)v22, a5, a7);
    return (void *)swift_release((uint64_t)v20);
  }
LABEL_9:
  __break(1u);
  return result;
}

uint64_t specialized _UIntBuffer.capacity.getter(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (*(uint64_t (**)(void))(a2 + 56))();
  if (!v2) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Division by zero", 16, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3829uLL, 0);
  }
  return 32 / v2;
}

Swift::UInt64 specialized LazyMapSequence<>.formIndex(after:)(Swift::String::Index *a1, uint64_t a2, uint64_t a3)
{
  v6._Swift::UInt64 rawBits = _StringGuts.validateScalarIndex(_:)((Swift::String::Index)a1->_rawBits)._rawBits;
  if ((a3 & 0x1000000000000000) != 0)
  {
    Swift::UInt64 result = String.UnicodeScalarView._foreignIndex(after:)(v6)._rawBits;
  }
  else
  {
    Swift::UInt64 v7 = v6._rawBits >> 16;
    if ((a3 & 0x2000000000000000) != 0)
    {
      v13[0] = a2;
      v13[1] = a3 & 0xFFFFFFFFFFFFFFLL;
      int v9 = *((unsigned __int8 *)v13 + v7);
    }
    else
    {
      if ((a2 & 0x1000000000000000) != 0) {
        uint64_t v8 = (unsigned __int8 *)((a3 & 0xFFFFFFFFFFFFFFFLL) + 32);
      }
      else {
        uint64_t v8 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a2, a3);
      }
      int v9 = v8[v7];
    }
    int v10 = (char)v9;
    unsigned int v11 = __clz(v9 ^ 0xFF) - 24;
    if (v10 >= 0) {
      LOBYTE(v11) = 1;
    }
    Swift::UInt64 result = ((v7 + v11) << 16) | 5;
  }
  a1->_Swift::UInt64 rawBits = result;
  return result;
}

uint64_t specialized RangeReplaceableCollection.insert<A>(contentsOf:at:)(uint64_t a1, Swift::String::Index a2, uint64_t a3, uint64_t a4)
{
  Swift::UInt64 v9 = _StringGuts.validateScalarRange_5_7(_:)(a2, a2, *v4, v4[1]);

  return _StringGuts.replaceSubrange<A>(_:with:)(v9, v10, a1, a3, a4);
}

uint64_t specialized RangeReplaceableCollection.insert<A>(contentsOf:at:)(int a1, Swift::String::Index a2)
{
  return Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(a2, a2);
}

void specialized RangeReplaceableCollection.insert<A>(contentsOf:at:)(uint64_t a1, Swift::UInt64 a2, ValueMetadata *a3, unint64_t a4)
{
}

Class *type metadata accessor for PartialRangeFrom(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for PartialRangeFrom.Flags, &flag for loading of canonical specialized generic type metadata for PartialRangeFrom);
}

void sub_1814E8214()
{
  swift_deallocObject(v0);
}

uint64_t partial apply for closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return closure #1 in Mirror.init<A, B>(_:unlabeledChildren:displayStyle:ancestorRepresentation:)(a1, *(void *)(v2 + 24), *(void *)(v2 + 32), a2);
}

uint64_t __swift_instantiateConcreteTypeFromMangledNameAbstract(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContextInMetadataState2(255, (unsigned __int8 *)a1 + (int)result, -(result >> 32), 0, 0);
    *a1 = result;
  }
  return result;
}

Class *type metadata accessor for LazyMapSequence(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for LazyMapSequence.Flags);
}

Class *type metadata accessor for _CollectionBox(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _CollectionBox.Flags);
}

uint64_t canonical specialized generic type metadata accessor for _IndexBox<Int>()
{
  return self;
}

uint64_t __swift_instantiateConcreteTypeFromMangledName(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContext2((unsigned __int8 *)a1 + (int)result, -(result >> 32), 0, 0);
    *a1 = result;
  }
  return result;
}

Class *type metadata accessor for LazySequence(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for LazySequence.Flags);
}

unint64_t outlined consume of Mirror.AncestorRepresentation(unint64_t result, uint64_t a2)
{
  if (result >= 2) {
    return swift_release(a2);
  }
  return result;
}

void sub_1814E8338()
{
  swift_deallocObject(v0);
}

Class *type metadata accessor for _IndexBox(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _IndexBox.Flags, flag for loading of canonical specialized generic type metadata for _IndexBox);
}

unint64_t specialized static String._uncheckedFromASCII(_:)(uint8x16_t *a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 > 15)
  {
    unint64_t v4 = a2 | 0xF000000000000000;
    int64_t v5 = _allocateStringStorage(codeUnitCapacity:)(a2);
    *(void *)(v5 + 16) = v6;
    *(void *)(v5 + 24) = v4;
    if (v6 < 0)
    {
      *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
      unint64_t v4 = *(void *)(v5 + 24);
    }
    *(unsigned char *)(v5 + 32 + (v4 & 0xFFFFFFFFFFFFLL)) = 0;
    specialized UnsafeMutablePointer.initialize(from:count:)(a1->i8, a2, (char *)(v5 + 32));
    return *(void *)(v5 + 24);
  }
  uint64_t v8 = a2 - 8;
  unint64_t v9 = 8;
  if (a2 < 8) {
    unint64_t v9 = a2;
  }
  if ((v9 & 0x8000000000000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if (v9 < 8)
  {
    unint64_t v10 = 0;
    unint64_t result = 0;
    unint64_t v11 = 0;
    goto LABEL_20;
  }
  if (v9 >= 0x10)
  {
    unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFF0;
    uint16x8_t v35 = vmovl_high_u8(*a1);
    int8x16_t v36 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v35.i8);
    uint16x8_t v37 = vmovl_u8(*(uint8x8_t *)a1->i8);
    int8x16_t v38 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v37.i8);
    int8x16_t v39 = (int8x16_t)vmovl_high_u16(v35);
    int8x8_t v40 = (int8x8_t)vextq_s8(v39, v39, 8uLL).u64[0];
    int8x16_t v41 = (int8x16_t)vmovl_high_u16(v37);
    int8x8_t v42 = (int8x8_t)vextq_s8(v41, v41, 8uLL).u64[0];
    *(int8x8_t *)v41.i8 = vorr_s8(*(int8x8_t *)v41.i8, *(int8x8_t *)v39.i8);
    v43.i64[0] = v41.u32[0];
    v43.i64[1] = v41.u32[1];
    int8x16_t v44 = (int8x16_t)vshlq_u64(v43, (uint64x2_t)xmmword_18162AD00);
    *(int8x8_t *)v39.i8 = vorr_s8(*(int8x8_t *)v38.i8, *(int8x8_t *)v36.i8);
    v43.i64[0] = v39.u32[0];
    v43.i64[1] = v39.u32[1];
    int8x16_t v45 = vorrq_s8((int8x16_t)vshlq_u64(v43, (uint64x2_t)xmmword_18162ACF0), v44);
    *(int8x8_t *)v39.i8 = vorr_s8(v42, v40);
    v43.i64[0] = v39.u32[0];
    v43.i64[1] = v39.u32[1];
    int8x16_t v46 = (int8x16_t)vshlq_u64(v43, (uint64x2_t)xmmword_18162ACE0);
    *(int8x8_t *)v36.i8 = vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL));
    v43.i64[0] = v36.u32[0];
    v43.i64[1] = v36.u32[1];
    int8x16_t v47 = vorrq_s8(v45, vorrq_s8((int8x16_t)vshlq_u64(v43, (uint64x2_t)xmmword_18162ACD0), v46));
    unint64_t result = (unint64_t)vorr_s8(*(int8x8_t *)v47.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL));
    if (v9 == (v9 & 0xFFFFFFFFFFFFFFF0)) {
      goto LABEL_22;
    }
    unint64_t v11 = 8 * v10;
    if ((v9 & 8) == 0) {
      goto LABEL_20;
    }
  }
  else
  {
    unint64_t result = 0;
    unint64_t v11 = 0;
    unint64_t v10 = 0;
  }
  unint64_t v12 = v10;
  int64x2_t v13 = vdupq_n_s64(v11);
  unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFF8;
  unint64_t v11 = 8 * (v9 & 0xFFFFFFFFFFFFFFF8);
  int8x16_t v14 = 0uLL;
  int8x16_t v15 = (int8x16_t)result;
  int64x2_t v16 = vaddq_s64(v13, (int64x2_t)xmmword_18162ACE0);
  int64x2_t v17 = vaddq_s64(v13, (int64x2_t)xmmword_18162AD00);
  int64x2_t v18 = vaddq_s64(v13, (int64x2_t)xmmword_18162ACD0);
  int64x2_t v19 = vaddq_s64(v13, (int64x2_t)xmmword_18162ACF0);
  unint64_t v20 = (uint8x8_t *)&a1->i8[v12];
  int8x16_t v21 = (int8x16_t)vdupq_n_s64(0x38uLL);
  unint64_t v22 = v12 - (v9 & 0xFFFFFFFFFFFFFFF8);
  int64x2_t v23 = vdupq_n_s64(0x40uLL);
  int8x16_t v24 = 0uLL;
  int8x16_t v25 = 0uLL;
  do
  {
    uint8x8_t v26 = *v20++;
    uint16x8_t v27 = vmovl_u8(v26);
    uint32x4_t v28 = vmovl_high_u16(v27);
    v29.i64[0] = v28.u32[2];
    v29.i64[1] = v28.u32[3];
    uint64x2_t v30 = v29;
    v29.i64[0] = v28.u32[0];
    v29.i64[1] = v28.u32[1];
    uint64x2_t v31 = v29;
    uint32x4_t v32 = vmovl_u16(*(uint16x4_t *)v27.i8);
    v29.i64[0] = v32.u32[2];
    v29.i64[1] = v32.u32[3];
    uint64x2_t v33 = v29;
    v29.i64[0] = v32.u32[0];
    v29.i64[1] = v32.u32[1];
    int8x16_t v25 = vorrq_s8((int8x16_t)vshlq_u64(v30, (uint64x2_t)vandq_s8((int8x16_t)v16, v21)), v25);
    int8x16_t v24 = vorrq_s8((int8x16_t)vshlq_u64(v31, (uint64x2_t)vandq_s8((int8x16_t)v17, v21)), v24);
    int8x16_t v14 = vorrq_s8((int8x16_t)vshlq_u64(v33, (uint64x2_t)vandq_s8((int8x16_t)v18, v21)), v14);
    int8x16_t v15 = vorrq_s8((int8x16_t)vshlq_u64(v29, (uint64x2_t)vandq_s8((int8x16_t)v19, v21)), v15);
    int64x2_t v17 = vaddq_s64(v17, v23);
    int64x2_t v18 = vaddq_s64(v18, v23);
    int64x2_t v19 = vaddq_s64(v19, v23);
    int64x2_t v16 = vaddq_s64(v16, v23);
    v22 += 8;
  }
  while (v22);
  int8x16_t v34 = vorrq_s8(vorrq_s8(v15, v24), vorrq_s8(v14, v25));
  unint64_t result = (unint64_t)vorr_s8(*(int8x8_t *)v34.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
  if (v9 != v10)
  {
LABEL_20:
    unint64_t v48 = v9 - v10;
    uint64_t v49 = &a1->u8[v10];
    do
    {
      unsigned int v50 = *v49++;
      result |= (unint64_t)v50 << (v11 & 0x38);
      v11 += 8;
      --v48;
    }
    while (v48);
  }
LABEL_22:
  if (a2 >= 9)
  {
    uint64_t v51 = 0;
    uint64_t v52 = 0;
    uint64_t v53 = &a1->u8[8];
    do
    {
      unsigned int v54 = *v53++;
      v51 |= (unint64_t)v54 << v52;
      v52 += 8;
      --v8;
    }
    while (v8);
  }
  return result;
}

unint64_t specialized static _UInt128.* infix(_:_:)(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  BOOL v4 = !is_mul_ok(a2, a3);
  BOOL v5 = !is_mul_ok(a1, a4);
  BOOL v6 = __CFADD__(a2 * a3, a1 * a4);
  BOOL v7 = __CFADD__(a2 * a3 + a1 * a4, (a3 * (unsigned __int128)a1) >> 64);
  if (a4) {
    BOOL v8 = a2 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8 || v4 || v5 || v6 || v7) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in *", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0xA3uLL, 0);
  }
  return a3 * a1;
}

double specialized Double.init(sign:exponentBitPattern:significandBitPattern:)(uint64_t a1, __int16 a2, uint64_t a3)
{
  *(void *)&double result = ((unint64_t)(a2 & 0x7FF) << 52) | (a1 << 63) | a3 & 0xFFFFFFFFFFFFFLL;
  return result;
}

uint64_t specialized UnsafeMutableBufferPointer.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3 - a1;
  if (__OFSUB__(a3, a1)) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x10FuLL, 0);
  }
  if (a2 < 1)
  {
    if (v3 > 0 || v3 <= a2) {
      goto LABEL_9;
    }
    return 0;
  }
  if ((v3 & 0x8000000000000000) == 0 && v3 < (unint64_t)a2) {
    return 0;
  }
LABEL_9:
  BOOL v5 = __OFADD__(a1, a2);
  uint64_t result = a1 + a2;
  if (v5) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x117uLL, 0);
  }
  return result;
}

uint64_t specialized UInt8.init(ascii:)(uint64_t result)
{
  if (result >= 0x80) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Code point value does not fit into ASCII", 40, 2, "Swift/UnicodeScalar.swift", 25, 2, 0x16BuLL, 0);
  }
  return result;
}

int64_t specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(int64_t a1, uint64_t a2, char a3, uint64_t a4, unint64_t a5)
{
  int64_t v11 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(void *)(v11 + 16) = v12;
  *(void *)(v11 + 24) = 0x3000000000000000;
  if (v12 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
    uint64_t v13 = *(void *)(v11 + 24) & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v13 = 0;
  }
  *(unsigned char *)(v11 + 32 + v13) = 0;
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  }
  closure #1 in StaticBigInt.debugDescription.getter(v11 + 32, a1, a2, a3 & 1, a4, a5);
  if (v5)
  {
    swift_release(v11);
  }
  else
  {
    *(void *)(v11 + 24) = a2 | 0x3000000000000000;
    *(unsigned char *)(v11 + 32 + (a2 & 0xFFFFFFFFFFFFLL)) = 0;
  }
  return v11;
}

uint64_t specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(int64_t a1, uint64_t a2, char a3, uint64_t a4, unint64_t a5)
{
  BOOL v7 = (void *)specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(a1, a2, a3, a4, a5);
  if (v6) {
    return v5;
  }
  BOOL v8 = v7;
  uint64_t v9 = v7[3];
  Swift::Int v10 = v9 & 0xFFFFFFFFFFFFLL;
  if ((v9 & 0xFFFFFFFFFFFFLL) == 0) {
    goto LABEL_20;
  }
  int64_t v11 = (char *)(v7 + 4);
  uint64_t v12 = (char *)(v7 + 4);
  if ((v9 & 0xFFFFFFFFFFF0) != 0)
  {
    if (((v7[5] | v7[4]) & 0x8080808080808080) != 0) {
      goto LABEL_22;
    }
    uint64_t v12 = (char *)(v7 + 6);
    while (v12 < (char *)v7 + (v9 & 0xFFFFFFFFFFF0) + 32)
    {
      uint64_t v13 = *(void *)v12;
      uint64_t v14 = *((void *)v12 + 1);
      v12 += 16;
      if (((v14 | v13) & 0x8080808080808080) != 0) {
        goto LABEL_22;
      }
    }
  }
  if (v12 < &v11[v9 & 0xFFFFFFFFFFF8])
  {
    if ((*(void *)v12 & 0x8080808080808080) != 0) {
      goto LABEL_22;
    }
    v12 += 8;
  }
  if (v12 < &v11[v9 & 0xFFFFFFFFFFFCLL])
  {
    if ((*(_DWORD *)v12 & 0x80808080) != 0) {
      goto LABEL_22;
    }
    v12 += 4;
  }
  if (v12 >= &v11[v9 & 0xFFFFFFFFFFFELL])
  {
LABEL_18:
    if (v12 >= &v11[v10] || (*v12 & 0x80000000) == 0)
    {
LABEL_20:
      char v15 = 1;
LABEL_21:
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v10, v15 & 1);
      return v8[3];
    }
    goto LABEL_22;
  }
  if ((*(_WORD *)v12 & 0x8080) == 0)
  {
    v12 += 2;
    goto LABEL_18;
  }
LABEL_22:
  uint64_t v16 = 0;
  int64x2_t v17 = &v11[v10];
  char v15 = 1;
  int64x2_t v18 = (unsigned __int8 *)(v7 + 4);
  int64x2_t v19 = (unsigned __int8 *)(v7 + 4);
  while (1)
  {
    int v21 = (char)*v19++;
    unsigned __int8 v20 = v21;
    if ((v21 & 0x80000000) == 0)
    {
      uint64_t v22 = 1;
      goto LABEL_25;
    }
    if ((v20 + 11) <= 0xCCu) {
      goto LABEL_68;
    }
    if (v20 < 0xE0u)
    {
      if (v19 == (unsigned __int8 *)v17 || (*v19 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      char v15 = 0;
      int64x2_t v19 = v18 + 2;
      uint64_t v22 = 2;
      goto LABEL_25;
    }
    if (v20 == 224) {
      break;
    }
    if (v20 <= 0xECu) {
      goto LABEL_50;
    }
    if (v20 == 237)
    {
      if (v19 == (unsigned __int8 *)v17) {
        goto LABEL_68;
      }
      unsigned int v25 = v18[1];
      if (v25 > 0x9F) {
        goto LABEL_68;
      }
LABEL_52:
      if ((v25 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      int64x2_t v23 = (char *)(v18 + 2);
      if (v18 + 2 == (unsigned __int8 *)v17) {
        goto LABEL_68;
      }
LABEL_54:
      if ((*v23 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      char v15 = 0;
      int64x2_t v19 = v18 + 3;
      uint64_t v22 = 3;
      goto LABEL_25;
    }
    if ((v20 + 16) >= 0xFEu)
    {
LABEL_50:
      if (v19 == (unsigned __int8 *)v17) {
        goto LABEL_68;
      }
      LOBYTE(v25) = v18[1];
      goto LABEL_52;
    }
    if (v20 == 240)
    {
      if (v19 == (unsigned __int8 *)v17 || (v18[1] + 64) < 0xD0u) {
        goto LABEL_68;
      }
    }
    else
    {
      if ((v20 + 12) >= 0xFDu)
      {
        if (v19 == (unsigned __int8 *)v17) {
          goto LABEL_68;
        }
        LOBYTE(v26) = v18[1];
      }
      else
      {
        if (v19 == (unsigned __int8 *)v17) {
          goto LABEL_68;
        }
        unsigned int v26 = v18[1];
        if (v26 > 0x8F) {
          goto LABEL_68;
        }
      }
      if ((v26 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
    }
    if (v18 + 2 == (unsigned __int8 *)v17
      || (v18[2] & 0xC0) != 0x80
      || v18 + 3 == (unsigned __int8 *)v17
      || (v18[3] & 0xC0) != 0x80)
    {
      goto LABEL_68;
    }
    char v15 = 0;
    int64x2_t v19 = v18 + 4;
    uint64_t v22 = 4;
LABEL_25:
    v16 += v22;
    int64x2_t v18 = v19;
    if (v19 == (unsigned __int8 *)v17) {
      goto LABEL_21;
    }
  }
  if (v19 != (unsigned __int8 *)v17)
  {
    int64x2_t v23 = (char *)(v18 + 2);
    if ((v18[1] + 64) >= 0xE0u && v23 != v17) {
      goto LABEL_54;
    }
  }
LABEL_68:
  uint16x8_t v27 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v27);
  uint64_t v28 = specialized Collection.subscript.getter(v16, (uint64_t)(v8 + 4), v10);
  uint64_t v32 = v28;
  uint64_t v33 = v29;
  uint64_t v34 = v30;
  uint64_t v35 = v31;
  uint64_t v36 = v28;
  if (v28 != v29)
  {
    specialized Slice.subscript.getter(v28, v28, v29, v30, v31);
    uint64_t v36 = v32 + 1;
    if (__OFADD__(v32, 1))
    {
      unint64_t v76 = 1525;
LABEL_168:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v76, 0);
    }
  }
  uint64_t v37 = 0;
  uint64_t v38 = v33 + v32 - v36;
  if (v33 <= v36) {
    uint64_t v39 = v36;
  }
  else {
    uint64_t v39 = v33;
  }
  if (v35 <= v36) {
    uint64_t v40 = v36;
  }
  else {
    uint64_t v40 = v35;
  }
  uint64_t v41 = v40 - v36;
  uint64_t v42 = v39 - v36;
  do
  {
    if (v33 - v36 == v37) {
      goto LABEL_87;
    }
    if (v36 < v32)
    {
      unint64_t v76 = 1812;
      goto LABEL_168;
    }
    if (v42 == v37)
    {
      unint64_t v76 = 1813;
      goto LABEL_168;
    }
    if (v36 < 0)
    {
      unint64_t v76 = 1781;
      goto LABEL_168;
    }
    if (v41 == v37)
    {
      unint64_t v76 = 1782;
      goto LABEL_168;
    }
    if ((*(unsigned char *)(v34 + v36 + v37) & 0xC0) != 0x80) {
      goto LABEL_86;
    }
    uint64_t v43 = v32 + v37++;
  }
  while (!__OFADD__(v43, 1));
  __break(1u);
LABEL_86:
  uint64_t v38 = v32 + v37;
LABEL_87:
  if (v38 < v32) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
  }
  uint64_t v44 = v38 + 1;
  if (__OFADD__(v38, 1))
  {
    __break(1u);
    goto LABEL_176;
  }
  if (v33 < v44)
  {
LABEL_176:
    unint64_t v76 = 1820;
    goto LABEL_168;
  }
  int64_t v45 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v32, v44, v34, v35);
  uint64_t v47 = v46;
  uint64_t v77 = (uint64_t)v8;
  uint64_t v78 = 0;
  uint64_t v48 = v8[3];
  unint64_t v79 = 0xE000000000000000;
  uint64_t v49 = v48 & 0xFFFFFFFFFFFFLL;
  if ((v48 & 0xFFFFFFFFFFFFLL) != 0)
  {
    uint64_t v50 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v51 & 1) != 0 || v50 < v49 + 15) {
      _StringGuts.grow(_:)(v49 + 15);
    }
  }
  while (2)
  {
    if (v45 < 0) {
      goto LABEL_169;
    }
    uint64_t v58 = v49;
    if (v49 < v45)
    {
      unint64_t v76 = 1861;
      goto LABEL_168;
    }
    unint64_t v59 = v79;
    uint64_t v60 = v78 & 0xFFFFFFFFFFFFLL;
    if ((v79 & 0x2000000000000000) != 0) {
      uint64_t v60 = HIBYTE(v79) & 0xF;
    }
    uint64_t v61 = v60 + v58;
    Swift::Int v62 = v61 + 3;
    if (__OFADD__(v61, 3))
    {
      __break(1u);
      goto LABEL_172;
    }
    if (v62 >= 16)
    {
      uint64_t v63 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v64 & 1) != 0 || v63 < v62)
      {
        _StringGuts.grow(_:)(v62);
        unint64_t v59 = v79;
      }
    }
    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v59 & 0xFFFFFFFFFFFFFFFLL, v11, v45, 0);
    uint64_t v78 = *(void *)((v59 & 0xFFFFFFFFFFFFFFFLL) + 0x18);
    size_t v80 = 3;
    uint64_t v81 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v81, &v80, &v78);
    if (v58 < v47) {
LABEL_169:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    if (v47 < 0)
    {
LABEL_172:
      unint64_t v76 = 1860;
      goto LABEL_168;
    }
    uint64_t v49 = v58 - v47;
    if (v58 - v47 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    unint64_t v65 = &v11[v47];
    if (_allASCII(_:)((uint64_t *)&v11[v47], v58 - v47))
    {
LABEL_161:
      _StringGuts.appendInPlace(_:isASCII:)(&v11[v47], v58 - v47, 0);
      break;
    }
    uint64_t v66 = 0;
    unsigned int v67 = (unsigned __int8 *)&v11[v58];
    if (!v11) {
      unsigned int v67 = 0;
    }
    for (uint64_t i = (unsigned __int8 *)&v11[v47]; ; ++i)
    {
      while (1)
      {
LABEL_113:
        if (!i || i == v67) {
          goto LABEL_161;
        }
        unsigned int v70 = *i++;
        unsigned int v69 = v70;
        if ((v69 & 0x80) != 0) {
          break;
        }
        ++v66;
      }
      if ((v69 + 62) > 0x32u) {
        goto LABEL_95;
      }
      if (v69 > 0xDF) {
        break;
      }
      if (!i || i == v67 || (*i & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      v66 += 2;
    }
    if (v69 == 224)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v67) {
        goto LABEL_95;
      }
      unsigned int v71 = i + 1;
      if ((*i & 0xE0) != 0xA0) {
        goto LABEL_95;
      }
      goto LABEL_140;
    }
    if (v69 < 0xED) {
      goto LABEL_136;
    }
    if (v69 == 237)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v67) {
        goto LABEL_95;
      }
      unsigned int v71 = i + 1;
      unsigned int v72 = *i;
      if (v72 > 0x9F) {
        goto LABEL_95;
      }
      goto LABEL_139;
    }
    if (v69 < 0xF0)
    {
LABEL_136:
      if (!i || i == v67) {
        goto LABEL_95;
      }
      unsigned int v71 = i + 1;
      LOBYTE(v72) = *i;
LABEL_139:
      if ((v72 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
LABEL_140:
      if (v71 == v67 || (*v71 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      i += 2;
      v66 += 3;
      goto LABEL_113;
    }
    if (v69 == 240)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v67) {
        goto LABEL_95;
      }
      unint64_t v73 = i + 1;
      if ((*i + 64) < 0xD0u) {
        goto LABEL_95;
      }
      goto LABEL_156;
    }
    if ((v69 + 15) < 3u)
    {
      if (!i || i == v67) {
        goto LABEL_95;
      }
      unint64_t v73 = i + 1;
      LOBYTE(v74) = *i;
      goto LABEL_155;
    }
    if (i)
    {
      if (i != v67)
      {
        unint64_t v73 = i + 1;
        unsigned int v74 = *i;
        if (v74 <= 0x8F)
        {
LABEL_155:
          if ((v74 & 0xC0) != 0x80) {
            goto LABEL_95;
          }
LABEL_156:
          if (v73 == v67 || (i[1] & 0xC0) != 0x80 || i + 2 == v67 || (i[2] & 0xC0) != 0x80) {
            goto LABEL_95;
          }
          i += 3;
          v66 += 4;
          goto LABEL_113;
        }
      }
    }
LABEL_95:
    uint64_t v52 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
    swift_willThrow();
    swift_errorRelease(v52);
    uint64_t v53 = specialized Collection.subscript.getter(v66, (uint64_t)&v11[v47], v58 - v47);
    int64_t v45 = findInvalidRange #1 (_:) in validateUTF8(_:)(v53, v54, v55, v56);
    uint64_t v47 = v57;
    int64_t v11 = v65;
    if (v49) {
      continue;
    }
    break;
  }
  uint64_t v5 = v78;
  swift_release(v77);
  return v5;
}

unint64_t specialized String.init(validatingUTF8:)(uint64_t a1)
{
  int64_t v2 = _swift_stdlib_strlen((const char *)a1);
  if (v2 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  uint64_t v3 = v2;
  if (!v2) {
    return 0;
  }
  BOOL v4 = (uint64_t *)a1;
  if ((v2 & 0xFFFFFFFFFFFFFFF0) != 0)
  {
    if (((*(void *)(a1 + 8) | *(void *)a1) & 0x8080808080808080) != 0) {
      goto LABEL_23;
    }
    BOOL v4 = (uint64_t *)(a1 + 16);
    while ((unint64_t)v4 < a1 + (v2 & 0xFFFFFFFFFFFFFFF0))
    {
      uint64_t v5 = *v4;
      uint64_t v6 = v4[1];
      v4 += 2;
      if (((v6 | v5) & 0x8080808080808080) != 0) {
        goto LABEL_23;
      }
    }
  }
  if ((unint64_t)v4 < a1 + (v2 & 0xFFFFFFFFFFFFFFF8))
  {
    if ((*v4 & 0x8080808080808080) != 0) {
      goto LABEL_23;
    }
    ++v4;
  }
  if ((unint64_t)v4 < a1 + (v2 & 0xFFFFFFFFFFFFFFFCLL))
  {
    if ((*(_DWORD *)v4 & 0x80808080) != 0) {
      goto LABEL_23;
    }
    BOOL v4 = (uint64_t *)((char *)v4 + 4);
  }
  if ((unint64_t)v4 >= a1 + (v2 & 0xFFFFFFFFFFFFFFFELL))
  {
LABEL_19:
    if ((unint64_t)v4 >= a1 + v2 || (*(char *)v4 & 0x80000000) == 0)
    {
      if (v2 > 15) {
        goto LABEL_94;
      }
LABEL_98:
      unint64_t v42 = v2 - 8;
      uint64_t v43 = 8;
      if (v2 < 8) {
        uint64_t v43 = v2;
      }
      if ((v43 & (unint64_t)~(v43 >> 63)) <= v43 - 1) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
      }
      if ((unint64_t)v43 < 8)
      {
        unint64_t v44 = 0;
        unint64_t result = 0;
        unint64_t v45 = 0;
        goto LABEL_114;
      }
      if ((unint64_t)v43 >= 0x10)
      {
        unint64_t v44 = v43 & 0xFFFFFFFFFFFFFFF0;
        int64x2_t v69 = (int64x2_t)xmmword_18162AD80;
        int64x2_t v70 = (int64x2_t)xmmword_18162AD90;
        int64x2_t v71 = (int64x2_t)xmmword_18162ADA0;
        int64x2_t v72 = (int64x2_t)xmmword_18162ADB0;
        unint64_t v45 = 8 * (v43 & 0xFFFFFFFFFFFFFFF0);
        int8x16_t v73 = 0uLL;
        int8x16_t v74 = (int8x16_t)vdupq_n_s64(0x38uLL);
        int64x2_t v75 = vdupq_n_s64(0x80uLL);
        unint64_t v76 = v43 & 0xFFFFFFFFFFFFFFF0;
        uint64_t v77 = (uint8x16_t *)a1;
        int64x2_t v78 = (int64x2_t)xmmword_18162ACE0;
        int8x16_t v79 = 0uLL;
        int8x16_t v80 = 0uLL;
        int64x2_t v81 = (int64x2_t)xmmword_18162AD00;
        int8x16_t v82 = 0uLL;
        int8x16_t v83 = 0uLL;
        int64x2_t v84 = (int64x2_t)xmmword_18162ACD0;
        int8x16_t v85 = 0uLL;
        int8x16_t v86 = 0uLL;
        int64x2_t v87 = (int64x2_t)xmmword_18162ACF0;
        int8x16_t v88 = 0uLL;
        do
        {
          uint8x16_t v89 = *v77++;
          uint16x8_t v90 = vmovl_u8(*(uint8x8_t *)v89.i8);
          uint32x4_t v91 = vmovl_high_u16(v90);
          v92.i64[0] = v91.u32[2];
          v92.i64[1] = v91.u32[3];
          uint64x2_t v93 = v92;
          uint16x8_t v94 = vmovl_high_u8(v89);
          uint32x4_t v95 = vmovl_u16(*(uint16x4_t *)v94.i8);
          v92.i64[0] = v95.u32[2];
          v92.i64[1] = v95.u32[3];
          uint64x2_t v96 = v92;
          v92.i64[0] = v95.u32[0];
          v92.i64[1] = v95.u32[1];
          uint64x2_t v97 = v92;
          v92.i64[0] = v91.u32[0];
          v92.i64[1] = v91.u32[1];
          uint64x2_t v98 = v92;
          uint32x4_t v99 = vmovl_u16(*(uint16x4_t *)v90.i8);
          v92.i64[0] = v99.u32[2];
          v92.i64[1] = v99.u32[3];
          uint64x2_t v100 = v92;
          uint32x4_t v101 = vmovl_high_u16(v94);
          v92.i64[0] = v101.u32[0];
          v92.i64[1] = v101.u32[1];
          uint64x2_t v102 = v92;
          v92.i64[0] = v99.u32[0];
          v92.i64[1] = v99.u32[1];
          uint64x2_t v103 = v92;
          v92.i64[0] = v101.u32[2];
          v92.i64[1] = v101.u32[3];
          int8x16_t v82 = vorrq_s8((int8x16_t)vshlq_u64(v93, (uint64x2_t)vandq_s8((int8x16_t)v78, v74)), v82);
          int8x16_t v85 = vorrq_s8((int8x16_t)vshlq_u64(v96, (uint64x2_t)vandq_s8((int8x16_t)v71, v74)), v85);
          int8x16_t v83 = vorrq_s8((int8x16_t)vshlq_u64(v97, (uint64x2_t)vandq_s8((int8x16_t)v72, v74)), v83);
          int8x16_t v80 = vorrq_s8((int8x16_t)vshlq_u64(v98, (uint64x2_t)vandq_s8((int8x16_t)v81, v74)), v80);
          int8x16_t v79 = vorrq_s8((int8x16_t)vshlq_u64(v100, (uint64x2_t)vandq_s8((int8x16_t)v84, v74)), v79);
          int8x16_t v86 = vorrq_s8((int8x16_t)vshlq_u64(v102, (uint64x2_t)vandq_s8((int8x16_t)v70, v74)), v86);
          int8x16_t v73 = vorrq_s8((int8x16_t)vshlq_u64(v103, (uint64x2_t)vandq_s8((int8x16_t)v87, v74)), v73);
          int8x16_t v88 = vorrq_s8((int8x16_t)vshlq_u64(v92, (uint64x2_t)vandq_s8((int8x16_t)v69, v74)), v88);
          int64x2_t v81 = vaddq_s64(v81, v75);
          int64x2_t v84 = vaddq_s64(v84, v75);
          int64x2_t v87 = vaddq_s64(v87, v75);
          int64x2_t v78 = vaddq_s64(v78, v75);
          int64x2_t v72 = vaddq_s64(v72, v75);
          int64x2_t v71 = vaddq_s64(v71, v75);
          int64x2_t v70 = vaddq_s64(v70, v75);
          int64x2_t v69 = vaddq_s64(v69, v75);
          v76 -= 16;
        }
        while (v76);
        int8x16_t v104 = vorrq_s8(vorrq_s8(vorrq_s8(v73, v83), vorrq_s8(v80, v86)), vorrq_s8(vorrq_s8(v79, v85), vorrq_s8(v82, v88)));
        unint64_t result = (unint64_t)vorr_s8(*(int8x8_t *)v104.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v104, v104, 8uLL));
        if (v43 == v44) {
          goto LABEL_116;
        }
        if ((v43 & 8) == 0)
        {
LABEL_114:
          uint64_t v105 = (unsigned __int8 *)(a1 + v44);
          unint64_t v106 = v43 - v44;
          do
          {
            unsigned int v107 = *v105++;
            result |= (unint64_t)v107 << (v45 & 0x38);
            v45 += 8;
            --v106;
          }
          while (v106);
          goto LABEL_116;
        }
      }
      else
      {
        unint64_t result = 0;
        unint64_t v45 = 0;
        unint64_t v44 = 0;
      }
      unint64_t v46 = v44;
      int64x2_t v47 = vdupq_n_s64(v45);
      unint64_t v44 = v43 & 0xFFFFFFFFFFFFFFF8;
      unint64_t v45 = 8 * (v43 & 0xFFFFFFFFFFFFFFF8);
      int8x16_t v48 = 0uLL;
      int8x16_t v49 = (int8x16_t)result;
      int64x2_t v50 = vaddq_s64(v47, (int64x2_t)xmmword_18162ACE0);
      int64x2_t v51 = vaddq_s64(v47, (int64x2_t)xmmword_18162AD00);
      int64x2_t v52 = vaddq_s64(v47, (int64x2_t)xmmword_18162ACD0);
      int64x2_t v53 = vaddq_s64(v47, (int64x2_t)xmmword_18162ACF0);
      uint64_t v54 = (uint8x8_t *)(a1 + v46);
      int8x16_t v55 = (int8x16_t)vdupq_n_s64(0x38uLL);
      unint64_t v56 = v46 - (v43 & 0xFFFFFFFFFFFFFFF8);
      int64x2_t v57 = vdupq_n_s64(0x40uLL);
      int8x16_t v58 = 0uLL;
      int8x16_t v59 = 0uLL;
      do
      {
        uint8x8_t v60 = *v54++;
        uint16x8_t v61 = vmovl_u8(v60);
        uint32x4_t v62 = vmovl_high_u16(v61);
        v63.i64[0] = v62.u32[2];
        v63.i64[1] = v62.u32[3];
        uint64x2_t v64 = v63;
        v63.i64[0] = v62.u32[0];
        v63.i64[1] = v62.u32[1];
        uint64x2_t v65 = v63;
        uint32x4_t v66 = vmovl_u16(*(uint16x4_t *)v61.i8);
        v63.i64[0] = v66.u32[2];
        v63.i64[1] = v66.u32[3];
        uint64x2_t v67 = v63;
        v63.i64[0] = v66.u32[0];
        v63.i64[1] = v66.u32[1];
        int8x16_t v59 = vorrq_s8((int8x16_t)vshlq_u64(v64, (uint64x2_t)vandq_s8((int8x16_t)v50, v55)), v59);
        int8x16_t v58 = vorrq_s8((int8x16_t)vshlq_u64(v65, (uint64x2_t)vandq_s8((int8x16_t)v51, v55)), v58);
        int8x16_t v48 = vorrq_s8((int8x16_t)vshlq_u64(v67, (uint64x2_t)vandq_s8((int8x16_t)v52, v55)), v48);
        int8x16_t v49 = vorrq_s8((int8x16_t)vshlq_u64(v63, (uint64x2_t)vandq_s8((int8x16_t)v53, v55)), v49);
        int64x2_t v51 = vaddq_s64(v51, v57);
        int64x2_t v52 = vaddq_s64(v52, v57);
        int64x2_t v53 = vaddq_s64(v53, v57);
        int64x2_t v50 = vaddq_s64(v50, v57);
        v56 += 8;
      }
      while (v56);
      int8x16_t v68 = vorrq_s8(vorrq_s8(v49, v58), vorrq_s8(v48, v59));
      unint64_t result = (unint64_t)vorr_s8(*(int8x8_t *)v68.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v68, v68, 8uLL));
      if (v43 != v44) {
        goto LABEL_114;
      }
LABEL_116:
      if (v3 < 9) {
        return result;
      }
      if (v42 < 8)
      {
        unint64_t v108 = 0;
        int8x8_t v109 = 0;
        unint64_t v110 = 0;
        goto LABEL_130;
      }
      if (v42 >= 0x10)
      {
        int64x2_t v134 = (uint8x16_t *)(a1 + 8);
        unint64_t v108 = v42 & 0xFFFFFFFFFFFFFFF0;
        int64x2_t v135 = (int64x2_t)xmmword_18162AD80;
        int64x2_t v136 = (int64x2_t)xmmword_18162AD90;
        int64x2_t v137 = (int64x2_t)xmmword_18162ADA0;
        int64x2_t v138 = (int64x2_t)xmmword_18162ADB0;
        int64x2_t v139 = (int64x2_t)xmmword_18162ACE0;
        int64x2_t v140 = (int64x2_t)xmmword_18162AD00;
        int8x16_t v141 = (int8x16_t)vdupq_n_s64(0x38uLL);
        int64x2_t v142 = vdupq_n_s64(0x80uLL);
        int64x2_t v143 = (int64x2_t)xmmword_18162ACD0;
        unint64_t v110 = 8 * (v42 & 0xFFFFFFFFFFFFFFF0);
        int8x16_t v144 = 0uLL;
        int8x16_t v145 = 0uLL;
        int64x2_t v146 = (int64x2_t)xmmword_18162ACF0;
        unint64_t v147 = v42 & 0xFFFFFFFFFFFFFFF0;
        int8x16_t v148 = 0uLL;
        int8x16_t v149 = 0uLL;
        int8x16_t v150 = 0uLL;
        int8x16_t v151 = 0uLL;
        int8x16_t v152 = 0uLL;
        int8x16_t v153 = 0uLL;
        do
        {
          uint8x16_t v154 = *v134++;
          uint16x8_t v155 = vmovl_u8(*(uint8x8_t *)v154.i8);
          uint32x4_t v156 = vmovl_high_u16(v155);
          v157.i64[0] = v156.u32[2];
          v157.i64[1] = v156.u32[3];
          uint64x2_t v158 = v157;
          uint16x8_t v159 = vmovl_high_u8(v154);
          uint32x4_t v160 = vmovl_u16(*(uint16x4_t *)v159.i8);
          v157.i64[0] = v160.u32[2];
          v157.i64[1] = v160.u32[3];
          uint64x2_t v161 = v157;
          v157.i64[0] = v160.u32[0];
          v157.i64[1] = v160.u32[1];
          uint64x2_t v162 = v157;
          v157.i64[0] = v156.u32[0];
          v157.i64[1] = v156.u32[1];
          uint64x2_t v163 = v157;
          uint32x4_t v164 = vmovl_u16(*(uint16x4_t *)v155.i8);
          v157.i64[0] = v164.u32[2];
          v157.i64[1] = v164.u32[3];
          uint64x2_t v165 = v157;
          uint32x4_t v166 = vmovl_high_u16(v159);
          v157.i64[0] = v166.u32[0];
          v157.i64[1] = v166.u32[1];
          uint64x2_t v167 = v157;
          v157.i64[0] = v164.u32[0];
          v157.i64[1] = v164.u32[1];
          uint64x2_t v168 = v157;
          v157.i64[0] = v166.u32[2];
          v157.i64[1] = v166.u32[3];
          int8x16_t v149 = vorrq_s8((int8x16_t)vshlq_u64(v158, (uint64x2_t)vandq_s8((int8x16_t)v139, v141)), v149);
          int8x16_t v151 = vorrq_s8((int8x16_t)vshlq_u64(v161, (uint64x2_t)vandq_s8((int8x16_t)v137, v141)), v151);
          int8x16_t v150 = vorrq_s8((int8x16_t)vshlq_u64(v162, (uint64x2_t)vandq_s8((int8x16_t)v138, v141)), v150);
          int8x16_t v148 = vorrq_s8((int8x16_t)vshlq_u64(v163, (uint64x2_t)vandq_s8((int8x16_t)v140, v141)), v148);
          int8x16_t v145 = vorrq_s8((int8x16_t)vshlq_u64(v165, (uint64x2_t)vandq_s8((int8x16_t)v143, v141)), v145);
          int8x16_t v152 = vorrq_s8((int8x16_t)vshlq_u64(v167, (uint64x2_t)vandq_s8((int8x16_t)v136, v141)), v152);
          int8x16_t v144 = vorrq_s8((int8x16_t)vshlq_u64(v168, (uint64x2_t)vandq_s8((int8x16_t)v146, v141)), v144);
          int8x16_t v153 = vorrq_s8((int8x16_t)vshlq_u64(v157, (uint64x2_t)vandq_s8((int8x16_t)v135, v141)), v153);
          int64x2_t v140 = vaddq_s64(v140, v142);
          int64x2_t v143 = vaddq_s64(v143, v142);
          int64x2_t v146 = vaddq_s64(v146, v142);
          int64x2_t v139 = vaddq_s64(v139, v142);
          int64x2_t v138 = vaddq_s64(v138, v142);
          int64x2_t v137 = vaddq_s64(v137, v142);
          int64x2_t v136 = vaddq_s64(v136, v142);
          int64x2_t v135 = vaddq_s64(v135, v142);
          v147 -= 16;
        }
        while (v147);
        int8x16_t v169 = vorrq_s8(vorrq_s8(vorrq_s8(v144, v150), vorrq_s8(v148, v152)), vorrq_s8(vorrq_s8(v145, v151), vorrq_s8(v149, v153)));
        int8x8_t v109 = vorr_s8(*(int8x8_t *)v169.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v169, v169, 8uLL));
        if (v42 == v108) {
          return result;
        }
        if ((v42 & 8) == 0)
        {
LABEL_130:
          uint64_t v170 = v3 - v108 - 8;
          int64x2_t v171 = (unsigned __int8 *)(v108 + a1 + 8);
          do
          {
            unsigned int v172 = *v171++;
            *(void *)&v109 |= (unint64_t)v172 << (v110 & 0x38);
            v110 += 8;
            --v170;
          }
          while (v170);
          return result;
        }
      }
      else
      {
        int8x8_t v109 = 0;
        unint64_t v110 = 0;
        unint64_t v108 = 0;
      }
      unint64_t v111 = v108;
      unint64_t v108 = v42 & 0xFFFFFFFFFFFFFFF8;
      int64x2_t v112 = vdupq_n_s64(v110);
      unint64_t v110 = 8 * (v42 & 0xFFFFFFFFFFFFFFF8);
      int8x16_t v113 = (int8x16_t)(unint64_t)v109;
      int8x16_t v114 = 0uLL;
      int64x2_t v115 = vaddq_s64(v112, (int64x2_t)xmmword_18162ACE0);
      int64x2_t v116 = vaddq_s64(v112, (int64x2_t)xmmword_18162AD00);
      int64x2_t v117 = vaddq_s64(v112, (int64x2_t)xmmword_18162ACD0);
      int64x2_t v118 = vaddq_s64(v112, (int64x2_t)xmmword_18162ACF0);
      unint64_t v119 = (uint8x8_t *)(v111 + a1 + 8);
      int8x16_t v120 = (int8x16_t)vdupq_n_s64(0x38uLL);
      unint64_t v121 = v111 - (v42 & 0xFFFFFFFFFFFFFFF8);
      int64x2_t v122 = vdupq_n_s64(0x40uLL);
      int8x16_t v123 = 0uLL;
      int8x16_t v124 = 0uLL;
      do
      {
        uint8x8_t v125 = *v119++;
        uint16x8_t v126 = vmovl_u8(v125);
        uint32x4_t v127 = vmovl_high_u16(v126);
        v128.i64[0] = v127.u32[2];
        v128.i64[1] = v127.u32[3];
        uint64x2_t v129 = v128;
        v128.i64[0] = v127.u32[0];
        v128.i64[1] = v127.u32[1];
        uint64x2_t v130 = v128;
        uint32x4_t v131 = vmovl_u16(*(uint16x4_t *)v126.i8);
        v128.i64[0] = v131.u32[2];
        v128.i64[1] = v131.u32[3];
        uint64x2_t v132 = v128;
        v128.i64[0] = v131.u32[0];
        v128.i64[1] = v131.u32[1];
        int8x16_t v124 = vorrq_s8((int8x16_t)vshlq_u64(v129, (uint64x2_t)vandq_s8((int8x16_t)v115, v120)), v124);
        int8x16_t v123 = vorrq_s8((int8x16_t)vshlq_u64(v130, (uint64x2_t)vandq_s8((int8x16_t)v116, v120)), v123);
        int8x16_t v114 = vorrq_s8((int8x16_t)vshlq_u64(v132, (uint64x2_t)vandq_s8((int8x16_t)v117, v120)), v114);
        int8x16_t v113 = vorrq_s8((int8x16_t)vshlq_u64(v128, (uint64x2_t)vandq_s8((int8x16_t)v118, v120)), v113);
        int64x2_t v116 = vaddq_s64(v116, v122);
        int64x2_t v117 = vaddq_s64(v117, v122);
        int64x2_t v118 = vaddq_s64(v118, v122);
        int64x2_t v115 = vaddq_s64(v115, v122);
        v121 += 8;
      }
      while (v121);
      int8x16_t v133 = vorrq_s8(vorrq_s8(v113, v123), vorrq_s8(v114, v124));
      int8x8_t v109 = vorr_s8(*(int8x8_t *)v133.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v133, v133, 8uLL));
      if (v42 == v108) {
        return result;
      }
      goto LABEL_130;
    }
    goto LABEL_23;
  }
  if ((*(_WORD *)v4 & 0x8080) == 0)
  {
    BOOL v4 = (uint64_t *)((char *)v4 + 2);
    goto LABEL_19;
  }
LABEL_23:
  uint64_t v8 = 0;
  uint64_t v9 = (unsigned char *)(a1 + v2);
  char v10 = 1;
  int64_t v11 = (unsigned char *)a1;
  uint64_t v12 = (unsigned char *)a1;
  do
  {
    int v14 = (char)*v12++;
    unsigned __int8 v13 = v14;
    if ((v14 & 0x80000000) == 0)
    {
      uint64_t v15 = 1;
      goto LABEL_26;
    }
    if ((v13 + 11) <= 0xCCu) {
      goto LABEL_69;
    }
    if (v13 <= 0xDFu)
    {
      if (v12 == v9 || (*v12 & 0xC0) != 0x80) {
        goto LABEL_69;
      }
      char v10 = 0;
      uint64_t v12 = v11 + 2;
      uint64_t v15 = 2;
    }
    else
    {
      if (v13 == 224)
      {
        if (v12 == v9
          || ((uint64_t v16 = v11 + 2, (v11[1] + 64) >= 0xE0u) ? (v17 = v16 == v9) : (v17 = 1), v17))
        {
LABEL_69:
          unsigned __int8 v20 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
          swift_willThrow();
          swift_errorRelease(v20);
          uint64_t v21 = specialized Collection.subscript.getter(v8, a1, v3);
          uint64_t v25 = v21;
          uint64_t v26 = v22;
          uint64_t v27 = v23;
          uint64_t v28 = v24;
          uint64_t v29 = v21;
          if (v21 != v22
            && (specialized Slice.subscript.getter(v21, v21, v22, v23, v24), uint64_t v29 = v25 + 1, __OFADD__(v25, 1)))
          {
            unint64_t v173 = 1525;
          }
          else
          {
            uint64_t v30 = 0;
            uint64_t v31 = v26 + v25 - v29;
            if (v26 <= v29) {
              uint64_t v32 = v29;
            }
            else {
              uint64_t v32 = v26;
            }
            if (v28 <= v29) {
              uint64_t v33 = v29;
            }
            else {
              uint64_t v33 = v28;
            }
            uint64_t v34 = v33 - v29;
            uint64_t v35 = v32 - v29;
            do
            {
              if (v26 - v29 == v30) {
                goto LABEL_88;
              }
              if (v29 < v25)
              {
                unint64_t v173 = 1812;
                goto LABEL_137;
              }
              if (v35 == v30)
              {
                unint64_t v173 = 1813;
                goto LABEL_137;
              }
              if (v29 < 0)
              {
                unint64_t v173 = 1781;
                goto LABEL_137;
              }
              if (v34 == v30)
              {
                unint64_t v173 = 1782;
                goto LABEL_137;
              }
              if ((*(unsigned char *)(v27 + v29 + v30) & 0xC0) != 0x80) {
                goto LABEL_87;
              }
              uint64_t v36 = v25 + v30++;
            }
            while (!__OFADD__(v36, 1));
            __break(1u);
LABEL_87:
            uint64_t v31 = v25 + v30;
LABEL_88:
            if (v31 < v25) {
              _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
            }
            uint64_t v37 = v31 + 1;
            if (__OFADD__(v31, 1))
            {
              __break(1u);
            }
            else if (v26 >= v37)
            {
              _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v25, v37, v27, v28);
              return 0;
            }
            unint64_t v173 = 1820;
          }
LABEL_137:
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v173, 0);
        }
        goto LABEL_55;
      }
      if (v13 <= 0xECu) {
        goto LABEL_51;
      }
      if (v13 == 237)
      {
        if (v12 == v9) {
          goto LABEL_69;
        }
        unsigned int v18 = v11[1];
        if (v18 > 0x9F) {
          goto LABEL_69;
        }
LABEL_53:
        if ((v18 & 0xC0) != 0x80) {
          goto LABEL_69;
        }
        uint64_t v16 = v11 + 2;
        if (v11 + 2 == v9) {
          goto LABEL_69;
        }
LABEL_55:
        if ((*v16 & 0xC0) != 0x80) {
          goto LABEL_69;
        }
        char v10 = 0;
        uint64_t v12 = v11 + 3;
        uint64_t v15 = 3;
        goto LABEL_26;
      }
      if ((v13 + 16) >= 0xFEu)
      {
LABEL_51:
        if (v12 == v9) {
          goto LABEL_69;
        }
        LOBYTE(v18) = v11[1];
        goto LABEL_53;
      }
      if (v13 == 240)
      {
        if (v12 == v9 || (v11[1] + 64) < 0xD0u) {
          goto LABEL_69;
        }
      }
      else
      {
        if ((v13 + 12) >= 0xFDu)
        {
          if (v12 == v9) {
            goto LABEL_69;
          }
          LOBYTE(v19) = v11[1];
        }
        else
        {
          if (v12 == v9) {
            goto LABEL_69;
          }
          unsigned int v19 = v11[1];
          if (v19 > 0x8F) {
            goto LABEL_69;
          }
        }
        if ((v19 & 0xC0) != 0x80) {
          goto LABEL_69;
        }
      }
      if (v11 + 2 == v9 || (v11[2] & 0xC0) != 0x80 || v11 + 3 == v9 || (v11[3] & 0xC0) != 0x80) {
        goto LABEL_69;
      }
      char v10 = 0;
      uint64_t v12 = v11 + 4;
      uint64_t v15 = 4;
    }
LABEL_26:
    v8 += v15;
    int64_t v11 = v12;
  }
  while (v12 != v9);
  if (v2 <= 15) {
    goto LABEL_98;
  }
  unint64_t v38 = v2;
  if (v10) {
LABEL_94:
  }
    unint64_t v38 = v2 | 0xC000000000000000;
  uint64_t v39 = v38 | 0x3000000000000000;
  int64_t v40 = _allocateStringStorage(codeUnitCapacity:)(v2);
  *(void *)(v40 + 16) = v41;
  *(void *)(v40 + 24) = v39;
  if (v41 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
    uint64_t v39 = *(void *)(v40 + 24);
  }
  *(unsigned char *)(v40 + 32 + (v39 & 0xFFFFFFFFFFFFLL)) = 0;
  specialized UnsafeMutablePointer.initialize(from:count:)((char *)a1, v3, (char *)(v40 + 32));
  return *(void *)(v40 + 24);
}

uint64_t specialized Collection._makeKeyValuePairDescription<A, B>(withTypeName:)(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v6 = a3;
  uint64x2_t v217 = *(char ***)(a3 - 8);
  uint64_t v8 = MEMORY[0x1F4188790](a1);
  uint32x4_t v218 = (char *)&v197 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  *(void *)&long long v216 = *(void *)(v10 - 8);
  MEMORY[0x1F4188790](v8);
  uint32x4_t v214 = (char *)&v197 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v213 = v12;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(255, v12, v13, "key value ", 0);
  uint32x4_t v210 = type metadata accessor for Optional(0, (uint64_t)TupleTypeMetadata2, v14, v15);
  uint64x2_t v215 = (char *)*(v210 - 1);
  uint64_t v16 = MEMORY[0x1F4188790](v210);
  uint16x8_t v209 = (char *)&v197 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v18 = MEMORY[0x1F4188790](v16);
  unsigned __int8 v20 = (char *)&v197 - v19;
  uint64_t v21 = *(void *)(a1 - 8);
  MEMORY[0x1F4188790](v18);
  uint64_t v23 = (char *)&v197 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v24 = *(void *)(a4 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v24, a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v25 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v27 = (char *)&v197 - v26;
  if ((*(uint64_t (**)(uint64_t, uint64_t))(a4 + 104))(a1, a4)) {
    return 6109787;
  }
  uint64_t v198 = v25;
  uint64_t v222 = 91;
  unint64_t v223 = 0xE100000000000000;
  (*(void (**)(char *, uint64_t, uint64_t))(v21 + 16))(v23, v4, a1);
  uint64_t v29 = *(void (**)(uint64_t, uint64_t))(v24 + 32);
  int8x16_t v207 = v27;
  v29(a1, v24);
  uint64_t v30 = AssociatedTypeWitness;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v24, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  int8x16_t v204 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v205 = AssociatedConformanceWitness + 16;
  int8x16_t v203 = (void (**)(char *, char *, Class *))(v215 + 32);
  uint64_t v31 = TupleTypeMetadata2;
  int8x16_t v202 = TupleTypeMetadata2 - 1;
  uint64x2_t v212 = (void (**)(char *, char *, uint64_t))(v216 + 32);
  v217 += 4;
  char v32 = 1;
  long long v216 = xmmword_18162AC80;
  long long v200 = xmmword_18162AD30;
  long long v199 = xmmword_18162AC90;
  unint64_t v201 = v6;
  uint64_t v33 = v213;
  uint64_t v34 = v214;
  while (1)
  {
    uint64_t v37 = v209;
    v204(v30, AssociatedConformanceWitness);
    (*v203)(v20, v37, v210);
    if ((*(unsigned int (**)(char *, uint64_t, uint64_t *))(*(v31 - 1) + 48))(v20, 1, v31) == 1) {
      break;
    }
    unint64_t v38 = &v20[*((int *)v31 + 12)];
    uint64_t v28 = (uint64_t)v212;
    uint64_t v39 = *v212;
    (*v212)(v34, v20, v33);
    uint64x2_t v215 = *v217;
    ((void (*)(char *, char *, unint64_t))v215)(v218, v38, v6);
    if (v32) {
      goto LABEL_77;
    }
    uint64_t v41 = v222;
    uint64_t v40 = v223;
    unint64_t v42 = HIBYTE(v223) & 0xF;
    uint64_t v43 = v222 & 0xFFFFFFFFFFFFLL;
    if ((v223 & 0x2000000000000000) != 0) {
      unint64_t v44 = HIBYTE(v223) & 0xF;
    }
    else {
      unint64_t v44 = v222 & 0xFFFFFFFFFFFFLL;
    }
    if (!v44 && (v222 & ~v223 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v223);
      uint64_t v222 = 8236;
      unint64_t v223 = 0xE200000000000000;
      goto LABEL_70;
    }
    if ((v223 & 0x2000000000000000) != 0 && v42 <= 0xD)
    {
      unint64_t v45 = 8 * (HIBYTE(v223) & 7);
      uint64_t v46 = (-255 << v45) - 1;
      uint64_t v47 = 44 << v45;
      char v48 = v42 + 1;
      if (v42 >= 8)
      {
        uint64_t v49 = v47 | v46 & v223;
        uint64_t v33 = v213;
LABEL_59:
        uint64_t v82 = (32 << (8 * (v48 & 7u))) | ((-255 << (8 * (v48 & 7u))) - 1) & v49;
      }
      else
      {
        uint64_t v41 = v47 | v46 & v222;
        uint64_t v33 = v213;
        if (v42 == 7)
        {
          char v48 = 8;
          uint64_t v49 = v223;
          goto LABEL_59;
        }
        uint64_t v41 = (32 << (8 * (v48 & 7u))) | ((-255 << (8 * (v48 & 7u))) - 1) & v41;
        uint64_t v82 = v223;
      }
      swift_bridgeObjectRelease(v223);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v89 = 0xE000000000000000;
      if (v41 & 0x8080808080808080 | v82 & 0x80808080808080) {
        unint64_t v89 = 0xA000000000000000;
      }
      uint64_t v222 = v41;
      unint64_t v223 = (v89 & 0xFF00000000000000 | (v42 << 56) | v82 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000;
      unint64_t v6 = v201;
LABEL_75:
      uint64_t v34 = v214;
      goto LABEL_76;
    }
    swift_bridgeObjectRetain_n(0xE200000000000000, 6);
    if ((v40 & 0x1000000000000000) != 0) {
      unint64_t v44 = String.UTF8View._foreignCount()();
    }
    BOOL v50 = __OFADD__(v44, 2);
    uint64_t v51 = v44 + 2;
    uint64_t v34 = v214;
    if (v50) {
      goto LABEL_228;
    }
    uint64_t v52 = v41 & ~v40;
    if ((v52 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v40 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v53 = _StringGuts.nativeUnusedCapacity.getter(v41, v40);
      if (v54) {
        goto LABEL_244;
      }
      if (v51 <= 15)
      {
        if ((v40 & 0x2000000000000000) != 0)
        {
          swift_bridgeObjectRelease_n(0xE200000000000000, 5);
LABEL_29:
          unint64_t v55 = v40;
          goto LABEL_30;
        }
        if (v53 <= 1) {
          goto LABEL_28;
        }
      }
    }
    else if (v51 <= 15)
    {
LABEL_28:
      swift_bridgeObjectRelease_n(0xE200000000000000, 5);
      if ((v40 & 0x2000000000000000) != 0) {
        goto LABEL_29;
      }
      if ((v40 & 0x1000000000000000) != 0)
      {
        uint64_t v41 = _StringGuts._foreignConvertedToSmall()(v41, v40);
        unint64_t v55 = v152;
      }
      else
      {
        if ((v41 & 0x1000000000000000) != 0)
        {
          int8x16_t v145 = (unsigned __int8 *)((v40 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else
        {
          int8x16_t v145 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v41, v40);
          uint64_t v43 = v153;
        }
        swift_bridgeObjectRetain(v40);
        closure #1 in _StringGuts._convertedToSmall()(v145, v43, &v221);
        swift_bridgeObjectRelease(v40);
        unint64_t v55 = *((void *)&v221 + 1);
        uint64_t v41 = v221;
      }
LABEL_30:
      v56._Swift::UInt64 rawBits = 1;
      v57._Swift::UInt64 rawBits = 131073;
      v58._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v56, v57, 0x202CuLL, 0xE200000000000000);
      if (v58._rawBits < 0x10000) {
        v58._rawBits |= 3;
      }
      unint64_t v60 = specialized String.init(_:)(v58, v59, 0x202CuLL, 0xE200000000000000);
      unint64_t v62 = v61;
      swift_bridgeObjectRelease(0xE200000000000000);
      if ((v62 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v62);
      }
      else if ((v62 & 0x1000000000000000) != 0)
      {
        unint64_t v60 = _StringGuts._foreignConvertedToSmall()(v60, v62);
        unint64_t v151 = v150;
        swift_bridgeObjectRelease(v62);
        unint64_t v62 = v151;
      }
      else
      {
        if ((v60 & 0x1000000000000000) != 0)
        {
          int64x2_t v143 = (unsigned __int8 *)((v62 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v144 = v60 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          int64x2_t v143 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v60, v62);
        }
        closure #1 in _StringGuts._convertedToSmall()(v143, v144, &v221);
        swift_bridgeObjectRelease(v62);
        unint64_t v62 = *((void *)&v221 + 1);
        unint64_t v60 = v221;
      }
      uint64_t v63 = HIBYTE(v55) & 0xF;
      uint64_t v64 = HIBYTE(v62) & 0xF;
      uint64_t v65 = v64 + v63;
      if ((unint64_t)(v64 + v63) > 0xF) {
        goto LABEL_243;
      }
      if (v64)
      {
        char v66 = 0;
        unint64_t v67 = 0;
        do
        {
          unint64_t v68 = v63 + v67;
          unint64_t v69 = v67 + 1;
          if (v67 >= 8) {
            unint64_t v70 = v62;
          }
          else {
            unint64_t v70 = v60;
          }
          unint64_t v71 = v70 >> (v66 & 0x38);
          char v72 = (8 * v63 + v66) & 0x38;
          uint64_t v73 = (-255 << v72) - 1;
          unint64_t v74 = (unint64_t)v71 << v72;
          unint64_t v75 = v74 | v73 & v55;
          unint64_t v76 = v74 | v73 & v41;
          if (v68 < 8) {
            uint64_t v41 = v76;
          }
          else {
            unint64_t v55 = v75;
          }
          v66 += 8;
          unint64_t v67 = v69;
        }
        while (v64 != v69);
      }
      swift_bridgeObjectRelease(v40);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v77 = 0xE000000000000000;
      if (v41 & 0x8080808080808080 | v55 & 0x80808080808080) {
        unint64_t v77 = 0xA000000000000000;
      }
      uint64_t v222 = v41;
      unint64_t v223 = v77 & 0xFF00000000000000 | (v65 << 56) | v55 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v6 = v201;
LABEL_70:
      uint64_t v33 = v213;
      goto LABEL_75;
    }
    int64_t v78 = _StringGuts.nativeUnusedCapacity.getter(v41, v40);
    BOOL v81 = (v79 & 1) == 0 && v78 > 1;
    if ((v52 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v40 & 0xFFFFFFFFFFFFFFFLL))
    {
      unint64_t v6 = v201;
      if (v81) {
        goto LABEL_68;
      }
LABEL_61:
      uint64_t v83 = _StringGuts.nativeCapacity.getter(v41, v40);
      if (v84) {
        uint64_t v85 = 0;
      }
      else {
        uint64_t v85 = v83;
      }
      if (v85 + 0x4000000000000000 < 0) {
        goto LABEL_230;
      }
      uint64_t v86 = 2 * v85;
      if (v86 > v51) {
        uint64_t v51 = v86;
      }
      goto LABEL_67;
    }
    unint64_t v6 = v201;
    if (!v81) {
      goto LABEL_61;
    }
LABEL_67:
    _StringGuts.grow(_:)(v51);
LABEL_68:
    swift_bridgeObjectRelease_n(0xE200000000000000, 6);
    long long v221 = v199;
    int64x2_t v87 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v221, 2);
    _StringGuts.appendInPlace(_:isASCII:)(v87, v88, 1);
    swift_bridgeObjectRelease(0xE200000000000000);
    uint64_t v33 = v213;
LABEL_76:
    uint64_t v28 = (uint64_t)v212;
LABEL_77:
    uint64_t v90 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Any>();
    inited = swift_initStackObject(v90, &v220);
    *((_OWORD *)inited + 1) = v216;
    inited[7] = v33;
    boxed_opaque_existential_0Tm = (char *)__swift_allocate_boxed_opaque_existential_0Tm(inited + 4);
    v39(boxed_opaque_existential_0Tm, v34, v33);
    specialized _debugPrint<A>(_:separator:terminator:to:)((uint64_t)inited, 0x20uLL, 0xE100000000000000, 0, 0xE000000000000000, &v222);
    swift_bridgeObjectRelease((uint64_t)inited);
    swift_bridgeObjectRelease(0xE000000000000000);
    swift_bridgeObjectRelease(0xE100000000000000);
    uint64_t v94 = v222;
    uint64_t v93 = v223;
    unint64_t v95 = HIBYTE(v223) & 0xF;
    uint64_t v40 = v222 & 0xFFFFFFFFFFFFLL;
    if ((v223 & 0x2000000000000000) != 0) {
      unint64_t v96 = HIBYTE(v223) & 0xF;
    }
    else {
      unint64_t v96 = v222 & 0xFFFFFFFFFFFFLL;
    }
    if (!v96 && (v222 & ~v223 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v223);
      uint64_t v222 = 8250;
      unint64_t v223 = 0xE200000000000000;
LABEL_5:
      uint64_t v33 = v213;
      goto LABEL_6;
    }
    if ((v223 & 0x2000000000000000) == 0 || v95 > 0xD)
    {
      swift_bridgeObjectRetain_n(0xE200000000000000, 6);
      if ((v93 & 0x1000000000000000) != 0)
      {
        Swift::Int v139 = String.UTF8View._foreignCount()();
        uint64_t v51 = v139 + 2;
        if (__OFADD__(v139, 2))
        {
LABEL_227:
          __break(1u);
LABEL_228:
          __break(1u);
LABEL_229:
          __break(1u);
LABEL_230:
          __break(1u);
LABEL_231:
          Swift::Int v188 = String.UTF8View._foreignCount()();
          uint64_t v155 = v188 + 1;
          if (!__OFADD__(v188, 1)) {
            goto LABEL_181;
          }
LABEL_233:
          __break(1u);
LABEL_234:
          if ((v155 & 0x1000000000000000) != 0)
          {
            uint64_t v51 = _StringGuts._foreignConvertedToSmall()(v51, v155);
            uint64_t v194 = v193;
            swift_bridgeObjectRelease(v155);
            uint64_t v155 = v194;
          }
          else
          {
            if ((v51 & 0x1000000000000000) != 0)
            {
              int64x2_t v189 = (unsigned __int8 *)((v155 & 0xFFFFFFFFFFFFFFFLL) + 32);
              uint64_t v190 = v51 & 0xFFFFFFFFFFFFLL;
            }
            else
            {
              int64x2_t v189 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v51, v155);
            }
            closure #1 in _StringGuts._convertedToSmall()(v189, v190, &v221);
            swift_bridgeObjectRelease(v155);
            uint64_t v155 = *((void *)&v221 + 1);
            uint64_t v51 = v221;
          }
          goto LABEL_204;
        }
      }
      else
      {
        BOOL v50 = __OFADD__(v96, 2);
        uint64_t v51 = v96 + 2;
        if (v50) {
          goto LABEL_227;
        }
      }
      uint64_t v102 = v94 & ~v93;
      if ((v102 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v93 & 0xFFFFFFFFFFFFFFFLL))
      {
        int64_t v103 = _StringGuts.nativeUnusedCapacity.getter(v94, v93);
        if (v104) {
          goto LABEL_244;
        }
        if (v51 > 15) {
          goto LABEL_115;
        }
        if ((v93 & 0x2000000000000000) == 0)
        {
          if (v103 <= 1) {
            goto LABEL_95;
          }
LABEL_115:
          int64_t v128 = _StringGuts.nativeUnusedCapacity.getter(v94, v93);
          uint64_t v40 = (v129 & 1) == 0 && v128 > 1;
          if ((v102 & 0x2000000000000000) != 0
            && swift_isUniquelyReferenced_nonNull_native(v93 & 0xFFFFFFFFFFFFFFFLL))
          {
            unint64_t v6 = v201;
            if (v40) {
              goto LABEL_135;
            }
LABEL_128:
            uint64_t v132 = _StringGuts.nativeCapacity.getter(v94, v93);
            if (v133) {
              uint64_t v134 = 0;
            }
            else {
              uint64_t v134 = v132;
            }
            if (v134 + 0x4000000000000000 < 0) {
              goto LABEL_229;
            }
            uint64_t v135 = 2 * v134;
            if (v135 > v51) {
              uint64_t v51 = v135;
            }
          }
          else
          {
            unint64_t v6 = v201;
            if ((v40 & 1) == 0) {
              goto LABEL_128;
            }
          }
          _StringGuts.grow(_:)(v51);
LABEL_135:
          swift_bridgeObjectRelease_n(0xE200000000000000, 6);
          long long v221 = v200;
          int64x2_t v136 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 2, (uint64_t)&v221, 2);
          _StringGuts.appendInPlace(_:isASCII:)(v136, v137, 1);
          swift_bridgeObjectRelease(0xE200000000000000);
          goto LABEL_5;
        }
        swift_bridgeObjectRelease_n(0xE200000000000000, 5);
LABEL_96:
        unint64_t v105 = v93;
      }
      else
      {
        if (v51 > 15) {
          goto LABEL_115;
        }
LABEL_95:
        swift_bridgeObjectRelease_n(0xE200000000000000, 5);
        if ((v93 & 0x2000000000000000) != 0) {
          goto LABEL_96;
        }
        if ((v93 & 0x1000000000000000) != 0)
        {
          uint64_t v94 = _StringGuts._foreignConvertedToSmall()(v94, v93);
          unint64_t v105 = v148;
        }
        else
        {
          if ((v94 & 0x1000000000000000) != 0)
          {
            int64x2_t v142 = (unsigned __int8 *)((v93 & 0xFFFFFFFFFFFFFFFLL) + 32);
          }
          else
          {
            int64x2_t v142 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v94, v93);
            uint64_t v40 = v149;
          }
          swift_bridgeObjectRetain(v93);
          closure #1 in _StringGuts._convertedToSmall()(v142, v40, &v221);
          swift_bridgeObjectRelease(v93);
          unint64_t v105 = *((void *)&v221 + 1);
          uint64_t v94 = v221;
        }
      }
      v106._Swift::UInt64 rawBits = 1;
      v107._Swift::UInt64 rawBits = 131073;
      v108._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v106, v107, 0x203AuLL, 0xE200000000000000);
      if (v108._rawBits < 0x10000) {
        v108._rawBits |= 3;
      }
      unint64_t v110 = specialized String.init(_:)(v108, v109, 0x203AuLL, 0xE200000000000000);
      unint64_t v112 = v111;
      swift_bridgeObjectRelease(0xE200000000000000);
      if ((v112 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease(v112);
      }
      else if ((v112 & 0x1000000000000000) != 0)
      {
        unint64_t v110 = _StringGuts._foreignConvertedToSmall()(v110, v112);
        unint64_t v147 = v146;
        swift_bridgeObjectRelease(v112);
        unint64_t v112 = v147;
      }
      else
      {
        if ((v110 & 0x1000000000000000) != 0)
        {
          int64x2_t v140 = (unsigned __int8 *)((v112 & 0xFFFFFFFFFFFFFFFLL) + 32);
          uint64_t v141 = v110 & 0xFFFFFFFFFFFFLL;
        }
        else
        {
          int64x2_t v140 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v110, v112);
        }
        closure #1 in _StringGuts._convertedToSmall()(v140, v141, &v221);
        swift_bridgeObjectRelease(v112);
        unint64_t v112 = *((void *)&v221 + 1);
        unint64_t v110 = v221;
      }
      uint64_t v113 = HIBYTE(v105) & 0xF;
      uint64_t v114 = HIBYTE(v112) & 0xF;
      uint64_t v115 = v114 + v113;
      if ((unint64_t)(v114 + v113) > 0xF) {
        goto LABEL_243;
      }
      if (v114)
      {
        char v116 = 0;
        unint64_t v117 = 0;
        do
        {
          unint64_t v118 = v113 + v117;
          unint64_t v119 = v117 + 1;
          if (v117 >= 8) {
            unint64_t v120 = v112;
          }
          else {
            unint64_t v120 = v110;
          }
          unint64_t v121 = v120 >> (v116 & 0x38);
          char v122 = (8 * v113 + v116) & 0x38;
          uint64_t v123 = (-255 << v122) - 1;
          unint64_t v124 = (unint64_t)v121 << v122;
          unint64_t v125 = v124 | v123 & v105;
          unint64_t v126 = v124 | v123 & v94;
          if (v118 < 8) {
            uint64_t v94 = v126;
          }
          else {
            unint64_t v105 = v125;
          }
          v116 += 8;
          unint64_t v117 = v119;
        }
        while (v114 != v119);
      }
      swift_bridgeObjectRelease(v93);
      swift_bridgeObjectRelease(0xE200000000000000);
      unint64_t v127 = 0xE000000000000000;
      if (v94 & 0x8080808080808080 | v105 & 0x80808080808080) {
        unint64_t v127 = 0xA000000000000000;
      }
      uint64_t v222 = v94;
      unint64_t v223 = v127 & 0xFF00000000000000 | (v115 << 56) | v105 & 0xFFFFFFFFFFFFFFLL;
      unint64_t v6 = v201;
      goto LABEL_5;
    }
    unint64_t v97 = 8 * (HIBYTE(v223) & 7);
    uint64_t v98 = (-255 << v97) - 1;
    uint64_t v99 = 58 << v97;
    char v100 = v95 + 1;
    if (v95 >= 8)
    {
      uint64_t v101 = v99 | v98 & v223;
      uint64_t v33 = v213;
    }
    else
    {
      uint64_t v94 = v99 | v98 & v222;
      uint64_t v33 = v213;
      if (v95 != 7)
      {
        uint64_t v94 = (32 << (8 * (v100 & 7u))) | ((-255 << (8 * (v100 & 7u))) - 1) & v94;
        uint64_t v131 = v223;
        goto LABEL_137;
      }
      char v100 = 8;
      uint64_t v101 = v223;
    }
    uint64_t v131 = (32 << (8 * (v100 & 7u))) | ((-255 << (8 * (v100 & 7u))) - 1) & v101;
LABEL_137:
    swift_bridgeObjectRelease(v223);
    swift_bridgeObjectRelease(0xE200000000000000);
    unint64_t v138 = 0xE000000000000000;
    if (v94 & 0x8080808080808080 | v131 & 0x80808080808080) {
      unint64_t v138 = 0xA000000000000000;
    }
    uint64_t v222 = v94;
    unint64_t v223 = (v138 & 0xFF00000000000000 | (v95 << 56) | v131 & 0xFFFFFFFFFFFFFFLL) + 0x200000000000000;
LABEL_6:
    uint64_t v35 = swift_initStackObject(v90, v219);
    *((_OWORD *)v35 + 1) = v216;
    v35[7] = v6;
    uint64_t v36 = __swift_allocate_boxed_opaque_existential_0Tm(v35 + 4);
    ((void (*)(void *, char *, unint64_t))v215)(v36, v218, v6);
    specialized _debugPrint<A>(_:separator:terminator:to:)((uint64_t)v35, 0x20uLL, 0xE100000000000000, 0, 0xE000000000000000, &v222);
    swift_bridgeObjectRelease((uint64_t)v35);
    swift_bridgeObjectRelease(0xE000000000000000);
    swift_bridgeObjectRelease(0xE100000000000000);
    char v32 = 0;
    uint64_t v34 = v214;
    uint64_t v31 = TupleTypeMetadata2;
    uint64_t v30 = AssociatedTypeWitness;
  }
  (*(void (**)(char *, const char *))(v198 + 8))(v207, v30);
  uint64_t v28 = v222;
  uint64_t v40 = v223;
  uint64_t v51 = HIBYTE(v223) & 0xF;
  unint64_t v6 = v222 & 0xFFFFFFFFFFFFLL;
  if ((v223 & 0x2000000000000000) != 0) {
    unint64_t v154 = HIBYTE(v223) & 0xF;
  }
  else {
    unint64_t v154 = v222 & 0xFFFFFFFFFFFFLL;
  }
  if (!v154 && (v222 & ~v223 & 0x2000000000000000) == 0)
  {
    swift_bridgeObjectRelease(v223);
    return 93;
  }
  if ((v223 & 0x2000000000000000) == 0 || v51 == 15)
  {
    swift_bridgeObjectRetain_n(0xE100000000000000, 6);
    if ((v40 & 0x1000000000000000) != 0) {
      goto LABEL_231;
    }
    BOOL v50 = __OFADD__(v154, 1);
    uint64_t v155 = v154 + 1;
    if (v50) {
      goto LABEL_233;
    }
LABEL_181:
    uint64_t v156 = v28 & ~v40;
    if ((v156 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v40 & 0xFFFFFFFFFFFFFFFLL))
    {
      int64_t v157 = _StringGuts.nativeUnusedCapacity.getter(v28, v40);
      if (v158)
      {
LABEL_244:
        unint64_t v192 = 258;
LABEL_245:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringGutsRangeReplaceable.swift", 38, 2, v192, 0);
      }
      if (v155 > 15) {
        goto LABEL_187;
      }
      if ((v40 & 0x2000000000000000) != 0)
      {
        swift_bridgeObjectRelease_n(0xE100000000000000, 5);
        goto LABEL_199;
      }
      if (v157 > 0)
      {
LABEL_187:
        int64_t v159 = _StringGuts.nativeUnusedCapacity.getter(v28, v40);
        BOOL v162 = (v160 & 1) == 0 && v159 > 0;
        if ((v156 & 0x2000000000000000) != 0 && swift_isUniquelyReferenced_nonNull_native(v40 & 0xFFFFFFFFFFFFFFFLL))
        {
          if (v162) {
            goto LABEL_223;
          }
        }
        else if (v162)
        {
LABEL_222:
          _StringGuts.grow(_:)(v155);
LABEL_223:
          swift_bridgeObjectRelease_n(0xE100000000000000, 6);
          long long v221 = xmmword_18162ACA0;
          uint32x4_t v185 = (char *)specialized UnsafeBufferPointer.init(rebasing:)(0, 1, (uint64_t)&v221, 1);
          _StringGuts.appendInPlace(_:isASCII:)(v185, v186, 1);
          swift_bridgeObjectRelease(0xE100000000000000);
          return v222;
        }
        uint64_t v181 = _StringGuts.nativeCapacity.getter(v28, v40);
        if (v182) {
          uint64_t v183 = 0;
        }
        else {
          uint64_t v183 = v181;
        }
        if (v183 + 0x4000000000000000 >= 0)
        {
          uint64_t v184 = 2 * v183;
          if (v184 > v155) {
            uint64_t v155 = v184;
          }
          goto LABEL_222;
        }
        __break(1u);
        goto LABEL_243;
      }
    }
    else if (v155 > 15)
    {
      goto LABEL_187;
    }
    swift_bridgeObjectRelease_n(0xE100000000000000, 5);
    if ((v40 & 0x2000000000000000) == 0)
    {
      if ((v40 & 0x1000000000000000) != 0)
      {
        uint64_t v28 = _StringGuts._foreignConvertedToSmall()(v28, v40);
        unint64_t v6 = v195;
      }
      else
      {
        if ((v28 & 0x1000000000000000) != 0)
        {
          int64x2_t v191 = (unsigned __int8 *)((v40 & 0xFFFFFFFFFFFFFFFLL) + 32);
        }
        else
        {
          int64x2_t v191 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(v28, v40);
          unint64_t v6 = v196;
        }
        swift_bridgeObjectRetain(v40);
        closure #1 in _StringGuts._convertedToSmall()(v191, v6, &v221);
        swift_bridgeObjectRelease(v40);
        unint64_t v6 = *((void *)&v221 + 1);
        uint64_t v28 = v221;
      }
      goto LABEL_200;
    }
LABEL_199:
    unint64_t v6 = v40;
LABEL_200:
    v163._Swift::UInt64 rawBits = 65537;
    v164._Swift::UInt64 rawBits = 1;
    v165._Swift::UInt64 rawBits = _StringGuts.validateScalarRange(_:)(v164, v163, 0x5DuLL, 0xE100000000000000);
    if (v165._rawBits < 0x10000) {
      v165._rawBits |= 3;
    }
    uint64_t v51 = specialized String.init(_:)(v165, v166, 0x5DuLL, 0xE100000000000000);
    uint64_t v155 = v167;
    swift_bridgeObjectRelease(0xE100000000000000);
    if ((v155 & 0x2000000000000000) == 0) {
      goto LABEL_234;
    }
    swift_bridgeObjectRelease(v155);
LABEL_204:
    uint64_t v168 = HIBYTE(v6) & 0xF;
    uint64_t v169 = HIBYTE(v155) & 0xF;
    if ((unint64_t)(v169 + v168) <= 0xF)
    {
      if (v169)
      {
        char v170 = 0;
        unint64_t v171 = 0;
        do
        {
          unint64_t v172 = v168 + v171;
          unint64_t v173 = v171 + 1;
          if (v171 >= 8) {
            unint64_t v174 = v155;
          }
          else {
            unint64_t v174 = v51;
          }
          unint64_t v175 = v174 >> (v170 & 0x38);
          char v176 = (8 * v168 + v170) & 0x38;
          uint64_t v177 = (-255 << v176) - 1;
          unint64_t v178 = (unint64_t)v175 << v176;
          unint64_t v179 = v178 | v177 & v6;
          unint64_t v180 = v178 | v177 & v28;
          if (v172 < 8) {
            uint64_t v28 = v180;
          }
          else {
            unint64_t v6 = v179;
          }
          v170 += 8;
          unint64_t v171 = v173;
        }
        while (v169 != v173);
      }
      swift_bridgeObjectRelease(v40);
      swift_bridgeObjectRelease(0xE100000000000000);
      return v28;
    }
LABEL_243:
    unint64_t v192 = 266;
    goto LABEL_245;
  }
  if ((unint64_t)v51 < 8) {
    uint64_t v28 = (93 << (8 * (HIBYTE(v223) & 7u))) | ((-255 << (8 * (HIBYTE(v223) & 7u))) - 1) & v222;
  }
  swift_bridgeObjectRelease(v223);
  swift_bridgeObjectRelease(0xE100000000000000);
  return v28;
}

uint64_t partial apply for closure #1 in Array.withUnsafeBytes<A>(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(uint64_t (**)(uint64_t))(v2 + 32);
  uint64_t v4 = UnsafeRawBufferPointer.init<A>(_:)(a1, a2, *(void *)(v2 + 16));
  return v3(v4);
}

uint64_t specialized _bridgeCocoaArray<A>(_:)(unint64_t a1)
{
  return ~(a1 >> 1) & 0x4000000000000000 | a1;
}

Class *type metadata accessor for _ArrayAnyHashableBox(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _ArrayAnyHashableBox.Flags);
}

BOOL specialized _deallocateUninitializedArray<A>(_:)(uint64_t a1, uint64_t *a2)
{
  BOOL result = _swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
  uint64_t v4 = a1 & 0xFFFFFFFFFFFFFF8;
  if (!result) {
    uint64_t v4 = a1;
  }
  *(void *)(v4 + 16) = 0;
  return result;
}

uint64_t type metadata accessor for __ContiguousArrayStorageBase()
{
  return self;
}

Class *type metadata accessor for _SliceBuffer(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _SliceBuffer.Flags, &flag for loading of canonical specialized generic type metadata for _SliceBuffer);
}

Class *type metadata accessor for IteratorSequence(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for IteratorSequence.Flags);
}

void sub_1814EB2D8()
{
  swift_deallocObject(v0);
}

Class *type metadata accessor for _ContiguousArrayBuffer(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _ContiguousArrayBuffer.Flags);
}

void partial apply for closure #1 in _assertionFailure(_:_:file:line:flags:)(const char *a1, uint64_t a2)
{
  uint64_t v6 = *(void *)(v2 + 16);
  unint64_t v5 = *(void *)(v2 + 24);
  uint64_t v8 = *(const char **)(v2 + 32);
  uint64_t v7 = *(void *)(v2 + 40);
  char v9 = *(unsigned char *)(v2 + 48);
  unint64_t v10 = *(void *)(v2 + 56);
  int v11 = *(_DWORD *)(v2 + 64);
  swift_bridgeObjectRetain(v5);
  if ((v5 & 0x1000000000000000) != 0)
  {
    uint64_t v6 = specialized static String._copying(_:)(v6, v5);
    unint64_t v15 = v14;
    swift_bridgeObjectRelease(v5);
    unint64_t v5 = v15;
    if ((v15 & 0x2000000000000000) == 0) {
      goto LABEL_3;
    }
LABEL_9:
    v16[0] = v6;
    v16[1] = v5 & 0xFFFFFFFFFFFFFFLL;
    closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)((const char *)v16, HIBYTE(v5) & 0xF, v8, v7, v9, a1, a2, v10, v11);
    swift_bridgeObjectRelease(v5);
    return;
  }
  if ((v5 & 0x2000000000000000) != 0) {
    goto LABEL_9;
  }
LABEL_3:
  if ((v6 & 0x1000000000000000) != 0)
  {
    uint64_t v12 = (const char *)((v5 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v13 = v6 & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v12 = (const char *)_StringObject.sharedUTF8.getter(v6, v5);
  }
  closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)(v12, v13, v8, v7, v9, a1, a2, v10, v11);

  swift_bridgeObjectRelease(v5);
}

uint64_t partial apply for closure #1 in _assertionFailure(_:_:file:line:flags:)(const char *a1, uint64_t a2)
{
  return closure #1 in _assertionFailure(_:_:file:line:flags:)(a1, a2, *(const char **)(v2 + 16), *(void *)(v2 + 24), *(unsigned char *)(v2 + 32), *(const char **)(v2 + 40), *(void *)(v2 + 48), *(unsigned char *)(v2 + 56), *(void *)(v2 + 64), *(_DWORD *)(v2 + 72));
}

uint64_t partial apply for closure #1 in StaticString.withUTF8Buffer<A>(_:)()
{
  return (*(uint64_t (**)(void))(v0 + 24))();
}

void partial apply for closure #1 in _unimplementedInitializer(className:initName:file:line:column:)(const char *a1, uint64_t a2)
{
  closure #1 in _unimplementedInitializer(className:initName:file:line:column:)(a1, a2, *(const char **)(v2 + 16), *(void *)(v2 + 24), *(unsigned char *)(v2 + 32), *(const char **)(v2 + 40), *(void *)(v2 + 48), *(unsigned char *)(v2 + 56), *(void *)(v2 + 64), *(void *)(v2 + 72));
}

Class *type metadata accessor for StrideToIterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for StrideToIterator.Flags);
}

unint64_t lazy protocol witness table accessor for type Int and conformance Int(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int and conformance Int;
  if (!lazy protocol witness table cache variable for type Int and conformance Int)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int, (unint64_t *)&type metadata for Int, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int and conformance Int);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int and conformance Int;
  if (!lazy protocol witness table cache variable for type Int and conformance Int)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int, (unint64_t *)&type metadata for Int, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int and conformance Int);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int and conformance Int;
  if (!lazy protocol witness table cache variable for type Int and conformance Int)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int, (unint64_t *)&type metadata for Int, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int and conformance Int);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int and conformance Int;
  if (!lazy protocol witness table cache variable for type Int and conformance Int)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int, (unint64_t *)&type metadata for Int, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int and conformance Int);
  }
  return result;
}

uint64_t type metadata accessor for _SwiftNSMutableArray()
{
  return self;
}

uint64_t outlined destroy of Any?(uint64_t a1)
{
  uint64_t v2 = type metadata for Any;
  if (!((unsigned int (*)(uint64_t, uint64_t, void *))type metadata for Any[6])(a1, 1, &unk_1ECA06310)) {
    ((void (*)(uint64_t, void *))v2[1])(a1, &unk_1ECA06310);
  }
  return a1;
}

Class *type metadata accessor for AutoreleasingUnsafeMutablePointer(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for AutoreleasingUnsafeMutablePointer.Flags);
}

void sub_1814EB640()
{
  swift_deallocObject(v0);
}

void *__swift_allocate_boxed_opaque_existential_0Tm(void *a1)
{
  double v1 = a1;
  unint64_t v2 = a1[3];
  if ((*(unsigned char *)(*(void *)(v2 - 8) + 82) & 2) != 0)
  {
    void *v1 = swift_allocBox(v2);
    return (void *)v3;
  }
  return v1;
}

Class *type metadata accessor for _KeyedEncodingContainerBox(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _KeyedEncodingContainerBox.Flags);
}

Class *type metadata accessor for _KeyedDecodingContainerBox(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _KeyedDecodingContainerBox.Flags);
}

void *outlined init with copy of EncodingError(void *a1, void *a2)
{
  return initializeWithCopy for EncodingError(a2, a1);
}

uint64_t __swift_destroy_boxed_opaque_existential_1Tm(uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[3] - 8);
  if ((*(unsigned char *)(v1 + 82) & 2) != 0) {
    return swift_release(*a1);
  }
  else {
    return (*(uint64_t (**)(void))(v1 + 8))();
  }
}

Class *type metadata accessor for _DictionaryStorage(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _DictionaryStorage.Flags, &flag for loading of canonical specialized generic type metadata for _DictionaryStorage);
}

Class *type metadata accessor for Dictionary._Variant(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Dictionary._Variant.Flags);
}

uint64_t outlined init with copy of DecodingError(uint64_t a1, uint64_t a2)
{
  return initializeWithCopy for DecodingError(a2, a1);
}

uint64_t outlined destroy of DecodingError(uint64_t a1)
{
  return a1;
}

void *__swift_project_boxed_opaque_existential_0Tm(void *result, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(a2 - 8) + 80) & 0x20000) != 0) {
    return (void *)(*result
  }
                    + ((*(_DWORD *)(*(void *)(a2 - 8) + 80) + 16) & ~(unint64_t)*(_DWORD *)(*(void *)(a2 - 8) + 80)));
  return result;
}

unint64_t specialized RangeReplaceableCollection.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOs6UInt32VIsgnrzr_xSayAIGAGSTRzAIRsd__AGRsd_0_r_0_lIetMgnozo_Tp5((void (*)(uint64_t *__return_ptr, char *))protocol witness for ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:) in conformance Unicode.Scalar, 0, a2, a3);
  unint64_t v4 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v3, 1);
  unint64_t v6 = v5;
  swift_bridgeObjectRelease((uint64_t)v3);
  if (!v6) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/String.swift", 18, 2, 0x1C9uLL, 0);
  }
  unint64_t v7 = specialized static String.+ infix(_:_:)(0, 0xE000000000000000, v4, v6);
  swift_bridgeObjectRelease(v6);
  return v7;
}

unint64_t specialized _GenericIndexKey.init(intValue:)(uint64_t a1)
{
  unint64_t v2 = specialized static String._createEmpty(withInitialCapacity:)(8);
  uint64_t v4 = v3;
  unint64_t v26 = v2;
  unint64_t v27 = v3;
  uint64_t v5 = HIBYTE(v3) & 0xF;
  if ((v3 & 0x2000000000000000) == 0) {
    uint64_t v5 = v2 & 0xFFFFFFFFFFFFLL;
  }
  if (v5 || (v2 & ~v3 & 0x2000000000000000) != 0)
  {
    if ((v3 & 0x2000000000000000) == 0
      || (unint64_t v6 = specialized _SmallString.init(_:appending:)(v2, v3, 0x207865646E49uLL, 0xE600000000000000),
          (v8 & 1) != 0))
    {
      _StringGuts.append(_:)(0x207865646E49, 0xE600000000000000, 0, 6);
      unint64_t v9 = v26;
      unint64_t v10 = v27;
      goto LABEL_11;
    }
    unint64_t v9 = v6;
    unint64_t v10 = v7;
    swift_bridgeObjectRelease(v4);
  }
  else
  {
    unint64_t v9 = 0x207865646E49;
    swift_bridgeObjectRelease(v3);
    unint64_t v10 = 0xE600000000000000;
  }
  unint64_t v26 = v9;
  unint64_t v27 = v10;
LABEL_11:
  unint64_t v12 = _int64ToString(_:radix:uppercase:)(a1, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
  unint64_t v13 = v11;
  uint64_t v14 = HIBYTE(v10) & 0xF;
  if ((v10 & 0x2000000000000000) == 0) {
    uint64_t v14 = v9 & 0xFFFFFFFFFFFFLL;
  }
  if (v14 || (v9 & ~v10 & 0x2000000000000000) != 0)
  {
    if ((v10 & 0x2000000000000000) != 0)
    {
      if ((v11 & 0x2000000000000000) != 0)
      {
        unint64_t v16 = specialized _SmallString.init(_:appending:)(v9, v10, v12, v11);
        if ((v18 & 1) == 0)
        {
          unint64_t v19 = v16;
          unint64_t v20 = v17;
          swift_bridgeObjectRelease(v10);
          swift_bridgeObjectRelease(v13);
          unint64_t v26 = v19;
          unint64_t v13 = v20;
          unint64_t v12 = v19;
          goto LABEL_24;
        }
        goto LABEL_22;
      }
    }
    else if ((v11 & 0x2000000000000000) != 0)
    {
LABEL_22:
      uint64_t v15 = HIBYTE(v13) & 0xF;
      goto LABEL_23;
    }
    uint64_t v15 = v12 & 0xFFFFFFFFFFFFLL;
LABEL_23:
    _StringGuts.append(_:)(v12, v13, 0, v15);
    swift_bridgeObjectRelease(v13);
    unint64_t v12 = v26;
    unint64_t v13 = v27;
    goto LABEL_24;
  }
  swift_bridgeObjectRelease(v10);
  unint64_t v26 = v12;
LABEL_24:
  uint64_t v21 = HIBYTE(v13) & 0xF;
  if ((v13 & 0x2000000000000000) == 0) {
    uint64_t v21 = v12 & 0xFFFFFFFFFFFFLL;
  }
  if (v21 || (v12 & ~v13 & 0x2000000000000000) != 0)
  {
    if ((v13 & 0x2000000000000000) == 0
      || (unint64_t v22 = specialized _SmallString.init(_:appending:)(v12, v13, 0, 0xE000000000000000), (v23 & 1) != 0))
    {
      _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
      swift_bridgeObjectRelease(0xE000000000000000);
      return v26;
    }
    else
    {
      unint64_t v24 = v22;
      swift_bridgeObjectRelease(v13);
      swift_bridgeObjectRelease(0xE000000000000000);
    }
  }
  else
  {
    swift_bridgeObjectRelease(v13);
    return 0;
  }
  return v24;
}

void sub_1814EBB30()
{
  swift_bridgeObjectRelease(*(void *)(v0 + 24));

  swift_deallocObject(v0);
}

uint64_t *__swift_mutable_project_boxed_opaque_existential_1(uint64_t *result, unint64_t a2)
{
  uint64_t v2 = *(void *)(a2 - 8);
  if ((*(_DWORD *)(v2 + 80) & 0x20000) != 0)
  {
    swift_makeBoxUnique(result, a2, *(_DWORD *)(v2 + 80));
    return (uint64_t *)v3;
  }
  return result;
}

float specialized Float16.init(from:)(uint64_t *a1)
{
  outlined init with copy of MirrorPath((uint64_t)a1, (uint64_t)&v40);
  uint64_t v4 = v42;
  uint64_t v5 = v43;
  __swift_project_boxed_opaque_existential_0Tm(&v40, v42);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v5 + 40))(v37, v4, v5);
  if (v1)
  {
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v40);
  }
  else
  {
    uint64_t v6 = v38;
    uint64_t v7 = v39;
    __swift_project_boxed_opaque_existential_0Tm(v37, v38);
    _S8 = (*(float (**)(uint64_t, uint64_t))(v7 + 48))(v6, v7);
    __swift_destroy_boxed_opaque_existential_1Tm(v37);
    __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)&v40);
    __asm { FCVT            H9, S8 }
    if ((LOWORD(_S9) & 0x7FFF) == 0x7C00 && (~LODWORD(_S8) & 0x7F800000) != 0)
    {
      swift_allocError((uint64_t)&type metadata for DecodingError, (uint64_t)&protocol witness table for DecodingError, 0, 0);
      uint64_t v15 = v14;
      uint64_t v16 = a1[3];
      uint64_t v17 = a1[4];
      __swift_project_boxed_opaque_existential_0Tm(a1, v16);
      uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 8))(v16, v17);
      unint64_t v19 = specialized static String._createEmpty(withInitialCapacity:)(46);
      uint64_t v21 = v20;
      unint64_t v40 = v19;
      unint64_t v41 = v20;
      uint64_t v22 = HIBYTE(v20) & 0xF;
      if ((v20 & 0x2000000000000000) == 0) {
        uint64_t v22 = v19 & 0xFFFFFFFFFFFFLL;
      }
      if (v22 || (v19 & ~v20 & 0x2000000000000000) != 0)
      {
        if ((v20 & 0x2000000000000000) != 0
          && ((unint64_t)"ffer is not allowed" & 0x2000000000000000) != 0
          && (unint64_t v23 = specialized _SmallString.init(_:appending:)(v19, v20, 0xD000000000000013, 0x80000001816E31E0),
              (v25 & 1) == 0))
        {
          unint64_t v26 = v23;
          unint64_t v27 = v24;
          swift_bridgeObjectRelease(v21);
          unint64_t v40 = v26;
          unint64_t v41 = v27;
        }
        else
        {
          if (((unint64_t)"ffer is not allowed" & 0x2000000000000000) != 0) {
            unint64_t v28 = (0x80000001816E31E0 >> 56) & 0xF;
          }
          else {
            unint64_t v28 = 19;
          }
          _StringGuts.append(_:)(0xD000000000000013, 0x80000001816E31E0, 0, v28);
        }
      }
      else
      {
        swift_bridgeObjectRelease(v20);
        unint64_t v40 = 0xD000000000000013;
        unint64_t v41 = 0x80000001816E31E0;
      }
      specialized Float.write<A>(to:)();
      uint64_t v29 = v41;
      unint64_t v30 = HIBYTE(v41) & 0xF;
      if ((v41 & 0x2000000000000000) == 0) {
        unint64_t v30 = v40 & 0xFFFFFFFFFFFFLL;
      }
      if (v30 || (v40 & ~v41 & 0x2000000000000000) != 0)
      {
        if ((v41 & 0x2000000000000000) != 0
          && ((unint64_t)"Parsed JSON number " & 0x2000000000000000) != 0
          && (unint64_t v31 = specialized _SmallString.init(_:appending:)(v40, v41, 0xD000000000000019, 0x80000001816E3200),
              (v33 & 1) == 0))
        {
          unint64_t v34 = v31;
          unint64_t v35 = v32;
          swift_bridgeObjectRelease(v29);
        }
        else
        {
          if (((unint64_t)"Parsed JSON number " & 0x2000000000000000) != 0) {
            unint64_t v36 = (0x80000001816E3200 >> 56) & 0xF;
          }
          else {
            unint64_t v36 = 25;
          }
          _StringGuts.append(_:)(0xD000000000000019, 0x80000001816E3200, 0, v36);
          unint64_t v34 = v40;
          unint64_t v35 = v41;
        }
      }
      else
      {
        swift_bridgeObjectRelease(v41);
        unint64_t v34 = 0xD000000000000019;
        unint64_t v35 = 0x80000001816E3200;
      }
      *(void *)uint64_t v15 = v18;
      *(void *)(v15 + 8) = v34;
      *(void *)(v15 + 16) = v35;
      *(void *)(v15 + 24) = 0;
      *(unsigned char *)(v15 + 72) = 3;
      swift_willThrow();
    }
  }
  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return _S9;
}

uint64_t type metadata accessor for __CocoaSet.Iterator()
{
  return self;
}

Class *type metadata accessor for Set._Variant(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Set._Variant.Flags);
}

unint64_t lazy protocol witness table accessor for type UInt8 and conformance UInt8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt8 and conformance UInt8;
  if (!lazy protocol witness table cache variable for type UInt8 and conformance UInt8)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt8, (unint64_t *)&type metadata for UInt8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt8 and conformance UInt8);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt8 and conformance UInt8;
  if (!lazy protocol witness table cache variable for type UInt8 and conformance UInt8)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt8, (unint64_t *)&type metadata for UInt8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt8 and conformance UInt8);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt8 and conformance UInt8;
  if (!lazy protocol witness table cache variable for type UInt8 and conformance UInt8)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt8, (unint64_t *)&type metadata for UInt8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt8 and conformance UInt8);
  }
  return result;
}

uint64_t specialized _DictionaryCodingKey.init(stringValue:)(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = HIBYTE(a2) & 0xF;
  uint64_t v5 = a1 & 0xFFFFFFFFFFFFLL;
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v6 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v6)
  {
    if ((a2 & 0x1000000000000000) != 0)
    {
      swift_bridgeObjectRetain(a2);
      specialized _parseInteger<A, B>(ascii:radix:)(a1, a2, 10, (uint64_t (*)(void *, uint64_t, uint64_t))specialized closure #1 in _parseInteger<A, B>(ascii:radix:));
      goto LABEL_86;
    }
    if ((a2 & 0x2000000000000000) == 0)
    {
      if ((a1 & 0x1000000000000000) != 0)
      {
        uint64_t v7 = (unsigned __int8 *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
        if ((a1 & 0xFFFFFFFFFFFFLL) != 0) {
          goto LABEL_9;
        }
      }
      else
      {
        uint64_t v7 = (unsigned __int8 *)_StringObject.sharedUTF8.getter(a1, a2);
        uint64_t v5 = v74;
        if (v74 > 0)
        {
LABEL_9:
          int v8 = *v7;
          if (v8 == 43)
          {
            swift_bridgeObjectRetain(a2);
            char v9 = 1;
            uint64_t v36 = specialized Collection.subscript.getter(1, (uint64_t)v7, v5);
            unint64_t v40 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v36, v37, v38, v39);
            if (!v41) {
              goto LABEL_82;
            }
            if (v40)
            {
              uint64_t v42 = 0;
              while (1)
              {
                unsigned int v43 = *v40 - 48;
                if (v43 > 9) {
                  goto LABEL_76;
                }
                uint64_t v44 = (unsigned __int128)(v42 * (__int128)10) >> 64;
                uint64_t v45 = 10 * v42;
                BOOL v46 = v44 != v45 >> 63;
                BOOL v21 = __OFADD__(v45, v43);
                uint64_t v42 = v45 + v43;
                char v47 = v21;
                char v9 = 1;
                if (!v46 && (v47 & 1) == 0)
                {
                  char v9 = 0;
                  ++v40;
                  if (--v41) {
                    continue;
                  }
                }
                goto LABEL_82;
              }
            }
          }
          else
          {
            if (v8 != 45)
            {
              uint64_t v48 = 0;
              while (1)
              {
                unsigned int v49 = *v7 - 48;
                if (v49 > 9) {
                  break;
                }
                uint64_t v50 = (unsigned __int128)(v48 * (__int128)10) >> 64;
                uint64_t v51 = 10 * v48;
                BOOL v52 = v50 != v51 >> 63;
                BOOL v21 = __OFADD__(v51, v49);
                uint64_t v48 = v51 + v49;
                char v53 = v21;
                char v9 = 1;
                if (v52 || (v53 & 1) != 0) {
                  goto LABEL_81;
                }
                ++v7;
                if (!--v5)
                {
                  char v9 = 0;
                  goto LABEL_81;
                }
              }
              char v9 = 1;
LABEL_81:
              swift_bridgeObjectRetain(a2);
              goto LABEL_82;
            }
            swift_bridgeObjectRetain(a2);
            char v9 = 1;
            uint64_t v10 = specialized Collection.subscript.getter(1, (uint64_t)v7, v5);
            uint64_t v14 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v10, v11, v12, v13);
            if (!v15)
            {
LABEL_82:
              char v76 = v9;
LABEL_86:
              swift_bridgeObjectRelease(a2);
              return a1;
            }
            if (v14)
            {
              uint64_t v16 = 0;
              while (1)
              {
                unsigned int v17 = *v14 - 48;
                if (v17 > 9) {
                  break;
                }
                uint64_t v18 = (unsigned __int128)(v16 * (__int128)10) >> 64;
                uint64_t v19 = 10 * v16;
                BOOL v20 = v18 != v19 >> 63;
                BOOL v21 = __OFSUB__(v19, v17);
                uint64_t v16 = v19 - v17;
                char v22 = v21;
                char v9 = 1;
                if (!v20 && (v22 & 1) == 0)
                {
                  char v9 = 0;
                  ++v14;
                  if (--v15) {
                    continue;
                  }
                }
                goto LABEL_82;
              }
LABEL_76:
              char v9 = 1;
              goto LABEL_82;
            }
          }
          char v9 = 0;
          goto LABEL_82;
        }
      }
LABEL_91:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x6F6uLL, 0);
    }
    v75[0] = a1;
    v75[1] = a2 & 0xFFFFFFFFFFFFFFLL;
    if (!v4) {
      goto LABEL_91;
    }
    if (a1 == 43)
    {
      swift_bridgeObjectRetain(a2);
      char v23 = 1;
      uint64_t v54 = specialized Collection.subscript.getter(1, (uint64_t)v75, v4);
      Swift::String::Index v58 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v54, v55, v56, v57);
      if (!v59) {
        goto LABEL_85;
      }
      if (v58)
      {
        uint64_t v60 = 0;
        while (1)
        {
          unsigned int v61 = *v58 - 48;
          if (v61 > 9) {
            goto LABEL_77;
          }
          uint64_t v62 = (unsigned __int128)(v60 * (__int128)10) >> 64;
          uint64_t v63 = 10 * v60;
          BOOL v64 = v62 != v63 >> 63;
          BOOL v21 = __OFADD__(v63, v61);
          uint64_t v60 = v63 + v61;
          char v65 = v21;
          char v23 = 1;
          if (!v64 && (v65 & 1) == 0)
          {
            char v23 = 0;
            ++v58;
            if (--v59) {
              continue;
            }
          }
          goto LABEL_85;
        }
      }
    }
    else
    {
      if (a1 != 45)
      {
        uint64_t v66 = 0;
        unint64_t v67 = (unsigned __int8 *)v75;
        while (1)
        {
          unsigned int v68 = *v67 - 48;
          if (v68 > 9) {
            break;
          }
          uint64_t v69 = (unsigned __int128)(v66 * (__int128)10) >> 64;
          uint64_t v70 = 10 * v66;
          BOOL v71 = v69 != v70 >> 63;
          BOOL v21 = __OFADD__(v70, v68);
          uint64_t v66 = v70 + v68;
          char v72 = v21;
          char v23 = 1;
          if (v71 || (v72 & 1) != 0) {
            goto LABEL_84;
          }
          ++v67;
          if (!--v4)
          {
            char v23 = 0;
            goto LABEL_84;
          }
        }
        char v23 = 1;
LABEL_84:
        swift_bridgeObjectRetain(a2);
        goto LABEL_85;
      }
      swift_bridgeObjectRetain(a2);
      char v23 = 1;
      uint64_t v24 = specialized Collection.subscript.getter(1, (uint64_t)v75, v4);
      unint64_t v28 = (unsigned __int8 *)specialized UnsafeBufferPointer.init(rebasing:)(v24, v25, v26, v27);
      if (!v29)
      {
LABEL_85:
        char v76 = v23;
        goto LABEL_86;
      }
      if (v28)
      {
        uint64_t v30 = 0;
        while (1)
        {
          unsigned int v31 = *v28 - 48;
          if (v31 > 9) {
            break;
          }
          uint64_t v32 = (unsigned __int128)(v30 * (__int128)10) >> 64;
          uint64_t v33 = 10 * v30;
          BOOL v34 = v32 != v33 >> 63;
          BOOL v21 = __OFSUB__(v33, v31);
          uint64_t v30 = v33 - v31;
          char v35 = v21;
          char v23 = 1;
          if (!v34 && (v35 & 1) == 0)
          {
            char v23 = 0;
            ++v28;
            if (--v29) {
              continue;
            }
          }
          goto LABEL_85;
        }
LABEL_77:
        char v23 = 1;
        goto LABEL_85;
      }
    }
    char v23 = 0;
    goto LABEL_85;
  }
  return a1;
}

unint64_t specialized _DictionaryCodingKey.init(intValue:)(uint64_t a1)
{
  uint64_t v2 = specialized static String._createEmpty(withInitialCapacity:)(2);
  unint64_t v4 = v2;
  unint64_t v5 = v3;
  unint64_t v22 = v2;
  unint64_t v23 = v3;
  uint64_t v6 = HIBYTE(v3) & 0xF;
  uint64_t v7 = v2 & 0xFFFFFFFFFFFFLL;
  if ((v3 & 0x2000000000000000) != 0) {
    uint64_t v7 = HIBYTE(v3) & 0xF;
  }
  if (v7 || (v2 & ~v3 & 0x2000000000000000) != 0)
  {
    if ((v3 & 0x2000000000000000) == 0)
    {
      _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
      unint64_t v4 = v22;
      unint64_t v8 = v23;
      goto LABEL_12;
    }
    swift_bridgeObjectRelease(v3);
    unint64_t v9 = 0xA000000000000000;
    if (!(v5 & 0x80808080808080 | v4 & 0x8080808080808080)) {
      unint64_t v9 = 0xE000000000000000;
    }
    unint64_t v8 = v9 & 0xFF00000000000000 | (v6 << 56) | v5 & 0xFFFFFFFFFFFFFFLL;
    unint64_t v22 = v4;
  }
  else
  {
    swift_bridgeObjectRelease(v3);
    unint64_t v4 = 0;
    unint64_t v8 = 0xE000000000000000;
    unint64_t v22 = 0;
  }
  unint64_t v23 = v8;
LABEL_12:
  unint64_t v11 = _int64ToString(_:radix:uppercase:)(a1, 10, 0, (uint64_t (*)(long long *, uint64_t, uint64_t, uint64_t, void))swift_int64ToString);
  unint64_t v12 = v10;
  uint64_t v13 = HIBYTE(v8) & 0xF;
  if ((v8 & 0x2000000000000000) == 0) {
    uint64_t v13 = v4 & 0xFFFFFFFFFFFFLL;
  }
  if (v13 || (v4 & ~v8 & 0x2000000000000000) != 0)
  {
    if ((v8 & 0x2000000000000000) != 0)
    {
      if ((v10 & 0x2000000000000000) != 0)
      {
        unint64_t v15 = specialized _SmallString.init(_:appending:)(v4, v8, v11, v10);
        if ((v17 & 1) == 0)
        {
          unint64_t v18 = v15;
          unint64_t v19 = v16;
          swift_bridgeObjectRelease(v8);
          swift_bridgeObjectRelease(v12);
          unint64_t v22 = v18;
          unint64_t v12 = v19;
          unint64_t v11 = v18;
          goto LABEL_25;
        }
        goto LABEL_23;
      }
    }
    else if ((v10 & 0x2000000000000000) != 0)
    {
LABEL_23:
      uint64_t v14 = HIBYTE(v12) & 0xF;
      goto LABEL_24;
    }
    uint64_t v14 = v11 & 0xFFFFFFFFFFFFLL;
LABEL_24:
    _StringGuts.append(_:)(v11, v12, 0, v14);
    swift_bridgeObjectRelease(v12);
    unint64_t v11 = v22;
    unint64_t v12 = v23;
    goto LABEL_25;
  }
  swift_bridgeObjectRelease(v8);
  unint64_t v22 = v11;
LABEL_25:
  uint64_t v20 = v11 & 0xFFFFFFFFFFFFLL;
  if ((v12 & 0x2000000000000000) != 0) {
    uint64_t v20 = HIBYTE(v12) & 0xF;
  }
  if (v20 || (v11 & ~v12 & 0x2000000000000000) != 0)
  {
    if ((v12 & 0x2000000000000000) != 0)
    {
      swift_bridgeObjectRelease(v12);
    }
    else
    {
      _StringGuts.append(_:)(0, 0xE000000000000000, 0, 0);
      return v22;
    }
  }
  else
  {
    swift_bridgeObjectRelease(v12);
    return 0;
  }
  return v11;
}

uint64_t specialized Int.init<A>(codingKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 40))(a2, a3);
}

uint64_t specialized String.init<A>(codingKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 24))(a2, a3);
}

uint64_t type metadata accessor for __CocoaDictionary.Iterator()
{
  return self;
}

Class *type metadata accessor for _NativeDictionary(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _NativeDictionary.Flags);
}

Class *type metadata accessor for Slice(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Slice.Flags);
}

uint64_t partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error)(uint64_t a1, void *a2)
{
  return partial apply for thunk for @callee_guaranteed (@in_guaranteed A.Sequence.Element) -> (@out A1, @error @owned Error)(a1, a2);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  unint64_t result = (*(uint64_t (**)(void))(v2 + 40))();
  if (v3) {
    *a2 = v3;
  }
  return result;
}

void sub_1814EC73C()
{
  swift_bridgeObjectRelease(*(void *)(v0 + 16));

  swift_deallocObject(v0);
}

uint64_t partial apply for closure #1 in Collection<>.split(separator:maxSplits:omittingEmptySubsequences:)(uint64_t a1)
{
  return partial apply for closure #1 in Collection<>.split(separator:maxSplits:omittingEmptySubsequences:)(a1) & 1;
}

{
  void *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  unint64_t v3 = v1[2];
  unint64_t v4 = v1[3];
  uint64_t v6 = v1[4];
  unint64_t v5 = v1[5];
  swift_getAssociatedTypeWitness(0, *(int ***)(v4 + 8), v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 8))(a1, v5) & 1;
}

uint64_t partial apply for closure #1 in BidirectionalCollection.last(where:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return closure #1 in BidirectionalCollection.last(where:)(a1, *(void *)(v2 + 16), *(void *)(v2 + 24), a2);
}

uint64_t partial apply for closure #1 in BidirectionalCollection<>.lastIndex(of:)(uint64_t a1)
{
  uint64_t v3 = v1[2];
  uint64_t v4 = v1[3];
  uint64_t v6 = v1[4];
  uint64_t v5 = v1[5];
  swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(v4 + 8) + 8), v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 8))(a1, v5) & 1;
}

uint64_t specialized static _UInt128.% infix(_:_:)(Swift::UInt64 a1, Swift::UInt64 a2, unint64_t a3, unint64_t a4)
{
  if (!(a4 | a3)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in %=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x1DCuLL, 0);
  }
  v10.Swift::UInt64 low = a2;
  v10.Swift::UInt64 high = (Swift::UInt64)&v7;
  specialized _wideDivide22<A>(_:by:)(&v9, &v8, v10, a1, a4, a3);
  return v7;
}

uint64_t specialized Array.init(repeating:count:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t))
{
  uint64_t v5 = a2;
  uint64_t v7 = a4(a2, a3);
  if (v5 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  uint64_t v9 = v7;
  if (v5)
  {
    uint64_t v10 = v8;
    uint64_t v11 = *(void *)(a3 - 8);
    unint64_t v12 = *(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 16);
    do
    {
      v12(v10, a1, a3);
      v10 += *(void *)(v11 + 72);
      --v5;
    }
    while (v5);
  }
  return v9;
}

uint64_t outlined init with copy of Any(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v3;
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

uint64_t outlined init with copy of Any?(uint64_t a1, uint64_t a2)
{
  return initializeWithCopy for ClosedRange<>.Index(a2, a1, &unk_1ECA01E10);
}

void sub_1814ECB00()
{
  swift_deallocObject(v0);
}

uint64_t partial apply for closure #1 in Substring.withUnsafeBytes<A>(_:)(uint64_t a1, uint64_t a2)
{
  return closure #1 in Substring.withUnsafeBytes<A>(_:)(a1, a2, *(uint64_t (**)(uint64_t, uint64_t))(v2 + 24));
}

Class *type metadata accessor for ClosedRange<>.Index(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for ClosedRange<>.Index.Flags);
}

Class *type metadata accessor for DefaultIndices(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for DefaultIndices.Flags);
}

uint64_t specialized _ContiguousArrayStorage.countByEnumerating(with:objects:count:)(void *a1)
{
  if (*a1) {
    return 0;
  }
  uint64_t v3 = v1[2];
  uint64_t v4 = (char *)v1
     + ((*(unsigned __int8 *)(*(void *)(*(void *)(*v1 + 144) - 8) + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*(void *)(*v1 + 144) - 8) + 80));
  *a1 = 1;
  a1[1] = v4;
  a1[2] = &_fastEnumerationStorageMutationsTarget;
  return v3;
}

void specialized _ContiguousArrayBuffer.subscript.setter()
{
}

uint64_t partial apply for closure #1 in _StringGuts.withCString<A>(_:)()
{
  return partial apply for closure #1 in _StringGuts.withCString<A>(_:)();
}

{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 24))();
}

uint64_t partial apply for thunk for @callee_guaranteed (@unowned UnsafeBufferPointer<Int8>) -> (@out A, @error @owned Error)(uint64_t a1, uint64_t a2, void *a3)
{
  return partial apply for thunk for @callee_guaranteed (@unowned UnsafeBufferPointer<Int8>) -> (@out A, @error @owned Error)(a1, a2, a3);
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  unint64_t result = (*(uint64_t (**)(void))(v3 + 24))();
  if (v4) {
    *a3 = v4;
  }
  return result;
}

Class *type metadata accessor for UnsafeBufferPointer(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for UnsafeBufferPointer.Flags, &flag for loading of canonical specialized generic type metadata for UnsafeBufferPointer);
}

uint64_t specialized _StringGuts._slowWithCString<A>(_:)(unint64_t a1, unint64_t a2, int a3)
{
  uint64_t v4 = String.utf8CString.getter(a1, a2);
  LOBYTE(a3) = _swift_stdlib_NSObject_isKindOfClass(a3, (char *)v4 + 32);
  swift_release((uint64_t)v4);
  return a3 & 1;
}

id specialized String.withCString<A>(_:)(unint64_t a1, unint64_t a2, void *a3)
{
  if ((a2 & 0x1000000000000000) != 0 || !(a2 & 0x2000000000000000 | a1 & 0x1000000000000000)) {
    return (id)(specialized _StringGuts._slowWithCString<A>(_:)(a1, a2, (int)a3) & 1);
  }
  if ((a2 & 0x2000000000000000) != 0)
  {
    v9[0] = a1;
    v9[1] = a2 & 0xFFFFFFFFFFFFFFLL;
    int v7 = swift_unknownObjectRetain(a3);
    char isKindOfClass = _swift_stdlib_NSObject_isKindOfClass(v7, (char *)v9);
    swift_unknownObjectRelease(a3);
  }
  else
  {
    if ((a1 & 0x1000000000000000) != 0)
    {
      uint64_t v4 = (char *)((a2 & 0xFFFFFFFFFFFFFFFLL) + 32);
    }
    else
    {
      uint64_t v4 = (char *)_StringObject.sharedUTF8.getter(a1, a2);
      if (!v4)
      {
        id result = swift_unknownObjectRetain(a3);
        __break(1u);
        return result;
      }
    }
    int v5 = swift_unknownObjectRetain(a3);
    char isKindOfClass = _swift_stdlib_NSObject_isKindOfClass(v5, v4);
    swift_unknownObjectRelease(a3);
  }
  return (id)(isKindOfClass & 1);
}

uint64_t specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(unint64_t a1, char a2)
{
  uint64_t v4 = (uint8x16_t *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 16);
  swift_bridgeObjectRetain(a1);
  if (_allASCII(_:)(v4->i64, v5) && (unint64_t v6 = specialized static String._uncheckedFromASCII(_:)(v4, v5), v7))
  {
    uint64_t v8 = v6;
    swift_bridgeObjectRelease(a1);
  }
  else
  {
    uint64_t v8 = specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)(a1, a2 & 1);
    swift_bridgeObjectRelease(a1);
  }
  return v8;
}

unint64_t specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(uint8x16_t *a1, uint64_t a2, ValueMetadata *a3, char a4)
{
  if (&full type metadata for UnsafeBufferPointer<UInt16> == &full type metadata for UnsafeBufferPointer<UInt8>
    && a3 == &type metadata for Unicode.ASCII)
  {
    return specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(a1, a2, a4 & 1);
  }
  if (&full type metadata for UnsafeBufferPointer<UInt16> == &full type metadata for [UInt8]
    && a3 == &type metadata for Unicode.ASCII)
  {
    return specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)((unint64_t)a1, a4 & 1);
  }
  return specialized static String._slowFromCodeUnits<A, B>(_:encoding:repair:)((unsigned __int16 *)a1, a2, a4 & 1);
}

unint64_t partial apply for closure #2 in static String._fromCodeUnits<A, B>(_:encoding:repair:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(v3 + 32) + 8), *(void *)(v3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v8 = (uint64_t *)UnsafeRawBufferPointer.init<A>(_:)(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = (uint8x16_t *)v8;
  if (v8)
  {
    uint64_t v11 = v9 - (void)v8;
    if (v9 - (uint64_t)v8 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  if (_allASCII(_:)(v8, v11))
  {
    unint64_t result = specialized static String._uncheckedFromASCII(_:)(v10, v11);
  }
  else
  {
    unint64_t result = 0;
    unint64_t v13 = 0;
  }
  *a3 = result;
  a3[1] = v13;
  return result;
}

uint64_t partial apply for closure #1 in String.withCString<A, B>(encodedAs:_:)()
{
  return partial apply for closure #1 in String.withCString<A, B>(encodedAs:_:)();
}

{
  uint64_t v0;

  return (*(uint64_t (**)(void))(v0 + 40))();
}

uint64_t outlined init with copy of AnyHashable?(uint64_t a1, uint64_t a2)
{
  return initializeWithCopy for ClosedRange<>.Index(a2, a1, &unk_1ECA01BC0);
}

uint64_t *outlined destroy of AnyHashable?(uint64_t *a1)
{
  if ((unint64_t)a1[3] >= 0xFFFFFFFF) {
    __swift_destroy_boxed_opaque_existential_1Tm(a1);
  }
  return a1;
}

uint64_t *outlined destroy of AnyHashable(uint64_t *a1)
{
  return a1;
}

unint64_t specialized String.init(repeating:count:)(unint64_t a1, unint64_t a2, unint64_t a3)
{
  if ((a3 & 0x8000000000000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative count not allowed", 26, 2, "Swift/StringLegacy.swift", 24, 2, 0x1FuLL, 0);
  }
  unint64_t v3 = a3;
  unint64_t v5 = a1;
  if (a3 >= 2)
  {
    unint64_t v15 = 0;
    unint64_t v16 = 0xE000000000000000;
    if ((a2 & 0x2000000000000000) != 0) {
      uint64_t v6 = HIBYTE(a2) & 0xF;
    }
    else {
      uint64_t v6 = a1 & 0xFFFFFFFFFFFFLL;
    }
    String.reserveCapacity(_:)(v6 * a3);
    while (1)
    {
      while (1)
      {
        if (!v3) {
          _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/Range.swift", 17, 2, 0x131uLL, 0);
        }
        uint64_t v7 = HIBYTE(v16) & 0xF;
        if ((v16 & 0x2000000000000000) == 0) {
          uint64_t v7 = v15 & 0xFFFFFFFFFFFFLL;
        }
        if (v7 || (v15 & ~v16 & 0x2000000000000000) != 0) {
          break;
        }
        swift_bridgeObjectRetain(a2);
        swift_bridgeObjectRelease(v16);
        unint64_t v15 = v5;
        unint64_t v16 = a2;
        if (!--v3)
        {
LABEL_23:
          swift_bridgeObjectRelease(a2);
          return v15;
        }
      }
      uint64_t v8 = v5 & 0xFFFFFFFFFFFFLL;
      if ((v16 & 0x2000000000000000) == 0) {
        break;
      }
      if ((a2 & 0x2000000000000000) != 0)
      {
        unint64_t v9 = specialized _SmallString.init(_:appending:)(v15, v16, v5, a2);
        if (v11) {
          goto LABEL_19;
        }
        unint64_t v12 = v9;
        unint64_t v13 = v10;
        swift_bridgeObjectRelease(v16);
        unint64_t v15 = v12;
        unint64_t v16 = v13;
        if (!--v3) {
          goto LABEL_23;
        }
      }
      else
      {
LABEL_20:
        _StringGuts.append(_:)(v5, a2, 0, v8);
        if (!--v3) {
          goto LABEL_23;
        }
      }
    }
    if ((a2 & 0x2000000000000000) == 0) {
      goto LABEL_20;
    }
LABEL_19:
    uint64_t v8 = HIBYTE(a2) & 0xF;
    goto LABEL_20;
  }
  if (!a3)
  {
    swift_bridgeObjectRelease(a2);
    return 0;
  }
  return v5;
}

uint64_t outlined init with copy of AnyHashable(uint64_t a1, uint64_t a2)
{
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 24) = v3;
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

unint64_t specialized static _DebuggerSupport.stringForPrintObject(_:)(uint64_t a1)
{
  uint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v6 = &_swiftEmptySetSingleton;
  v5[0] = 0;
  v5[1] = 0xE000000000000000;
  outlined init with copy of Any(a1, (uint64_t)v4);
  outlined init with copy of Any(a1, (uint64_t)v3);
  Mirror.init(reflecting:)(v3, (uint64_t)v8);
  specialized static _DebuggerSupport.printForDebuggerImpl<A>(value:mirror:name:indent:maxDepth:isRoot:parentCollectionStatus:refsAlreadySeen:maxItemCounter:target:)((uint64_t)v4, (uint64_t)v8, 0, 0, 0, 0x7FFFFFFFFFFFFFFFLL, 1, 0, (uint64_t *)&v6, &v7, v5);
  outlined release of Mirror((uint64_t)v8);
  outlined destroy of Any?((uint64_t)v4);
  swift_bridgeObjectRelease((uint64_t)v6);
  return v5[0];
}

Class *type metadata accessor for Dictionary(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Dictionary.Flags, &flag for loading of canonical specialized generic type metadata for Dictionary);
}

uint64_t partial apply for closure #1 in Dictionary.init<A>(uniqueKeysWithValues:)()
{
  return swift_willThrow();
}

void specialized _NativeDictionary.merge<A>(_:isUnique:uniquingKeysWith:)(uint64_t a1, char a2, void (*a3)(char *, char *), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v104 = a4;
  int64_t v103 = a3;
  uint64_t v119 = a1;
  uint64_t v94 = *(void *)(*(void *)(a5 + 24) - 8);
  uint64_t v10 = MEMORY[0x1F4188790](a1);
  unint64_t v112 = (char *)&v93 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  uint64_t v14 = (char *)&v93 - v13;
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v102 = (char *)&v93 - v16;
  uint64_t v17 = MEMORY[0x1F4188790](v15);
  uint64_t v120 = v18;
  unint64_t v121 = (char *)&v93 - v19;
  uint64_t v105 = *(void *)(*(void *)(v18 + 16) - 8);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v101 = (char *)&v93 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v20);
  uint64_t v123 = (char *)&v93 - v23;
  unint64_t v124 = v22;
  uint64_t v122 = v24;
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(255, (uint64_t)v22, v24, 0, 0);
  uint64_t v27 = type metadata accessor for Optional(0, (uint64_t)TupleTypeMetadata2, v25, v26);
  uint64_t v28 = MEMORY[0x1F4188790](v27 - 1);
  uint64_t v30 = (char *)&v93 - v29;
  uint64_t v31 = *(void *)(a6 - 8);
  MEMORY[0x1F4188790](v28);
  uint64_t v33 = (char *)&v93 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v35 = v34;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)a7, v34, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v95 = *((void *)AssociatedTypeWitness - 1);
  MEMORY[0x1F4188790](AssociatedTypeWitness);
  uint64_t v38 = (char *)&v93 - v37;
  (*(void (**)(char *, uint64_t, uint64_t))(v31 + 16))(v33, v119, v35);
  uint64_t v39 = TupleTypeMetadata2;
  (*(void (**)(uint64_t))(a7 + 32))(v35);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a7, v35, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
  uint64_t v41 = *(void (**)(const char *, uint64_t))(AssociatedConformanceWitness + 16);
  uint64_t v114 = v38;
  uint64_t v115 = AssociatedTypeWitness;
  uint64_t v110 = AssociatedConformanceWitness + 16;
  uint64_t v111 = AssociatedConformanceWitness;
  Swift::String::Index v109 = v41;
  ((void (*)(const char *))v41)(AssociatedTypeWitness);
  uint64_t v42 = *(v39 - 1);
  unsigned int v43 = *(unsigned int (**)(char *, uint64_t, uint64_t *))(v42 + 48);
  uint64_t v107 = v42 + 48;
  Swift::String::Index v108 = v43;
  if (v43(v30, 1, v39) == 1)
  {
LABEL_2:
    (*(void (**)(char *, const char *))(v95 + 8))(v114, v115);
    return;
  }
  unint64_t v118 = *(void (**)(uint64_t, char *, Class *))(v105 + 32);
  uint64_t v44 = v94;
  unint64_t v117 = (void (**)(char *, char *, uint64_t))(v94 + 32);
  uint64_t v99 = v94 + 16;
  char v100 = (void (**)(char *, uint64_t))(v94 + 8);
  uint64_t v119 = v105 + 32;
  uint64_t v98 = (void (**)(uint64_t, Class *))(v105 + 8);
  unint64_t v96 = (void (**)(unint64_t, char *, uint64_t))(v94 + 40);
  Swift::String::Index v106 = v30;
  unint64_t v97 = v14;
  while (1)
  {
    uint64_t v45 = &v30[*((int *)v39 + 12)];
    uint64_t v46 = (uint64_t)v123;
    char v47 = v30;
    uint64_t v48 = v124;
    v118((uint64_t)v123, v47, v124);
    unsigned int v49 = *v117;
    (*v117)(v121, v45, v122);
    uint64_t v50 = *(void **)v125;
    uint64_t v51 = *(void *)(v120 + 32);
    unint64_t v53 = __RawDictionaryStorage.find<A>(_:)(v46, (uint64_t)v48, v51);
    uint64_t v54 = v50[2];
    BOOL v55 = (v52 & 1) == 0;
    Swift::Int v56 = v54 + v55;
    if (__OFADD__(v54, v55))
    {
      __break(1u);
LABEL_19:
      __break(1u);
LABEL_20:
      KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)((unint64_t)v124);
    }
    char v57 = v52;
    if (v50[3] >= v56)
    {
      uint64_t v60 = v121;
      if ((a2 & 1) == 0) {
        _NativeDictionary.copy()();
      }
    }
    else
    {
      _NativeDictionary._copyOrMoveAndResize(capacity:moveElements:)(v56, a2 & 1);
      unint64_t v58 = __RawDictionaryStorage.find<A>(_:)((uint64_t)v123, (uint64_t)v124, v51);
      if ((v57 & 1) != (v59 & 1)) {
        goto LABEL_20;
      }
      unint64_t v53 = v58;
      uint64_t v60 = v121;
    }
    unsigned int v61 = *(void **)v125;
    if (v57) {
      break;
    }
    unint64_t v67 = v60;
    unsigned int v68 = v101;
    uint64_t v69 = v124;
    uint64_t v70 = (void (*)(unint64_t, char *, Class *))v118;
    v118((uint64_t)v101, v123, v124);
    v49(v112, v67, v122);
    v61[(v53 >> 6) + 8] |= 1 << v53;
    v70(v61[6] + *(void *)(v105 + 72) * v53, v68, v69);
    v49((char *)(v61[7] + *(void *)(v44 + 72) * v53), v112, v122);
    uint64_t v71 = v61[2];
    BOOL v72 = __OFADD__(v71, 1);
    uint64_t v73 = v71 + 1;
    if (v72) {
      goto LABEL_19;
    }
    v61[2] = v73;
    uint64_t v14 = v97;
LABEL_4:
    uint64_t v30 = v106;
    v109(v115, v111);
    a2 = 1;
    uint64_t v39 = TupleTypeMetadata2;
    if (v108(v30, 1, TupleTypeMetadata2) == 1) {
      goto LABEL_2;
    }
  }
  unint64_t v62 = *(void *)(v44 + 72) * v53;
  uint64_t v63 = v122;
  (*(void (**)(char *, unint64_t, uint64_t))(v44 + 16))(v14, v61[7] + v62, v122);
  BOOL v64 = v102;
  char v65 = v113;
  v103(v14, v60);
  if (!v65)
  {
    uint64_t v113 = 0;
    uint64_t v66 = *v100;
    (*v100)(v14, v63);
    v66(v60, v63);
    (*v98)((uint64_t)v123, v124);
    (*v96)(*(void *)(*(void *)v125 + 56) + v62, v64, v63);
    goto LABEL_4;
  }
  uint64_t v74 = *v100;
  (*v100)(v14, v63);
  id v128 = v65;
  swift_errorRetain(v65);
  unint64_t v75 = (char *)__swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Error);
  if (swift_dynamicCast(v75, (unint64_t *)&v128, (Class *)v75, (const char *)&type metadata for _MergeError, 0))
  {
    unint64_t v76 = specialized static String._createEmpty(withInitialCapacity:)(30);
    uint64_t v78 = v77;
    unint64_t v126 = v76;
    unint64_t v127 = v77;
    uint64_t v79 = HIBYTE(v77) & 0xF;
    if ((v77 & 0x2000000000000000) == 0) {
      uint64_t v79 = v76 & 0xFFFFFFFFFFFFLL;
    }
    if (v79 || (v76 & ~v77 & 0x2000000000000000) != 0)
    {
      if ((v77 & 0x2000000000000000) != 0
        && ((unint64_t)"ment" & 0x2000000000000000) != 0
        && (unint64_t v80 = specialized _SmallString.init(_:appending:)(v76, v77, 0xD00000000000001BLL, 0x80000001816E30D0),
            (v82 & 1) == 0))
      {
        unint64_t v83 = v80;
        unint64_t v84 = v81;
        swift_bridgeObjectRelease(v78);
        unint64_t v126 = v83;
        unint64_t v127 = v84;
      }
      else
      {
        if (((unint64_t)"ment" & 0x2000000000000000) != 0) {
          unint64_t v85 = (0x80000001816E30D0 >> 56) & 0xF;
        }
        else {
          unint64_t v85 = 27;
        }
        _StringGuts.append(_:)(0xD00000000000001BLL, 0x80000001816E30D0, 0, v85);
      }
    }
    else
    {
      swift_bridgeObjectRelease(v77);
      unint64_t v126 = 0xD00000000000001BLL;
      unint64_t v127 = 0x80000001816E30D0;
    }
    _print_unlocked<A, B>(_:_:)((uint64_t)v123, (uint64_t)&v126, v124, (uint64_t)&type metadata for DefaultStringInterpolation, (uint64_t)&protocol witness table for DefaultStringInterpolation);
    uint64_t v86 = v127;
    unint64_t v87 = HIBYTE(v127) & 0xF;
    if ((v127 & 0x2000000000000000) == 0) {
      unint64_t v87 = v126 & 0xFFFFFFFFFFFFLL;
    }
    if (v87 || (v126 & ~v127 & 0x2000000000000000) != 0)
    {
      if ((v127 & 0x2000000000000000) == 0
        || (unint64_t v90 = specialized _SmallString.init(_:appending:)(v126, v127, 0x27uLL, 0xE100000000000000), (v92 & 1) != 0))
      {
        _StringGuts.append(_:)(39, 0xE100000000000000, 0, 1);
        uint64_t v89 = v126;
        unint64_t v88 = v127;
      }
      else
      {
        uint64_t v89 = v90;
        unint64_t v88 = v91;
        swift_bridgeObjectRelease(v86);
      }
    }
    else
    {
      swift_bridgeObjectRelease(v127);
      unint64_t v88 = 0xE100000000000000;
      uint64_t v89 = 39;
    }
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v89, v88, "Swift/NativeDictionary.swift", 28, 2, 0x30FuLL, 0);
  }
  v74(v60, v63);
  (*v98)((uint64_t)v123, v124);
  (*(void (**)(char *, const char *))(v95 + 8))(v114, v115);
  swift_errorRelease(v128);
}

uint64_t type metadata accessor for __BridgingBufferStorage(__int16 a1)
{
  return type metadata accessor for __BridgingBufferStorage(a1, (uint64_t *)&type metadata singleton initialization cache for __BridgingBufferStorage, &nominal type descriptor for __BridgingBufferStorage);
}

uint64_t type metadata accessor for __CocoaDictionary.Index.Storage()
{
  return self;
}

void sub_1814EDF50()
{
  swift_deallocObject(v0);
}

void sub_1814EDF64()
{
  swift_release(*(void *)(v0 + 48));

  swift_deallocObject(v0);
}

void sub_1814EDFA0()
{
  swift_deallocObject(v0);
}

uint64_t partial apply for closure #1 in Dictionary.merge(_:uniquingKeysWith:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(v4 + 16);
  uint64_t v9 = *(void *)(v4 + 24);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v8 - 8) + 16))(a1, a3);
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 16);

  return v10(a2, a4, v9);
}

uint64_t partial apply for thunk for @escaping @callee_guaranteed (@in_guaranteed A, @in_guaranteed B) -> (@out A, @out B)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return thunk for @escaping @callee_guaranteed (@in_guaranteed A, @in_guaranteed B) -> (@out A, @out B)(a1, *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v2 + 40), *(void *)(v2 + 16), *(void *)(v2 + 24), a2);
}

uint64_t specialized static _DictionaryStorage.resize(original:capacity:move:)(uint64_t result)
{
  if (result <= 1) {
    uint64_t v1 = 1;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000) == 0) {
    goto LABEL_23;
  }
  if (v2 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v2 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v3 = __OFADD__(v1, 1);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }
  if (v4 <= (uint64_t)v2) {
    uint64_t v4 = (uint64_t)v2;
  }
  char v5 = 64 - __clz(v4 - 1);
  unsigned __int8 v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  uint64_t v7 = 1 << v6;
  unint64_t v8 = (unint64_t)((1 << v6) + 63) >> 6;
  uint64_t v9 = (unint64_t *)canonical specialized generic type metadata accessor for _DictionaryStorage<String, String>();
  uint64_t v10 = (int64x2_t *)swift_allocObject(v9, (((16 << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8) + (16 << v6), 7uLL);
  v10[1].i64[0] = 0;
  double v11 = (double)(1 << v6) * 0.75;
  if ((~*(void *)&v11 & 0x7FF0000000000000) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v11 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v11 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  uint64_t v12 = (uint64_t *)v10;
  uint64_t v13 = v10 + 4;
  uint64_t v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v10);
  if ((_BYTE)qword_1EB208F08) {
    uint64_t v15 = (uint64_t *)v6;
  }
  else {
    uint64_t v15 = v12;
  }
  v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 16 * v7;
  if (v7 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v8, v13);
  }
  else {
    v13->i64[0] = -1 << v7;
  }
  return (uint64_t)v12;
}

{
  uint64_t v1;
  double v2;
  BOOL v3;
  uint64_t v4;
  char v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  int64x2_t *v10;
  double v11;
  uint64_t *v12;
  int64x2_t *v13;
  uint64_t v14;
  uint64_t *v15;

  if (result <= 1) {
    uint64_t v1 = 1;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000) == 0) {
    goto LABEL_23;
  }
  if (v2 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v2 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v3 = __OFADD__(v1, 1);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }
  if (v4 <= (uint64_t)v2) {
    uint64_t v4 = (uint64_t)v2;
  }
  char v5 = 64 - __clz(v4 - 1);
  unsigned __int8 v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  uint64_t v7 = 1 << v6;
  unint64_t v8 = (unint64_t)((1 << v6) + 63) >> 6;
  uint64_t v9 = (unint64_t *)canonical specialized generic type metadata accessor for _DictionaryStorage<String, AnyHashable>();
  uint64_t v10 = (int64x2_t *)swift_allocObject(v9, (((16 << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8) + (40 << v6), 7uLL);
  v10[1].i64[0] = 0;
  double v11 = (double)(1 << v6) * 0.75;
  if ((~*(void *)&v11 & 0x7FF0000000000000) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v11 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v11 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  uint64_t v12 = (uint64_t *)v10;
  uint64_t v13 = v10 + 4;
  uint64_t v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v10);
  if ((_BYTE)qword_1EB208F08) {
    uint64_t v15 = (uint64_t *)v6;
  }
  else {
    uint64_t v15 = v12;
  }
  v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 16 * v7;
  if (v7 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v8, v13);
  }
  else {
    v13->i64[0] = -1 << v7;
  }
  return (uint64_t)v12;
}

{
  uint64_t v1;
  double v2;
  BOOL v3;
  uint64_t v4;
  char v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  int64x2_t *v10;
  double v11;
  uint64_t *v12;
  int64x2_t *v13;
  uint64_t v14;
  uint64_t *v15;

  if (result <= 1) {
    uint64_t v1 = 1;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000) == 0) {
    goto LABEL_23;
  }
  if (v2 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v2 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v3 = __OFADD__(v1, 1);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }
  if (v4 <= (uint64_t)v2) {
    uint64_t v4 = (uint64_t)v2;
  }
  char v5 = 64 - __clz(v4 - 1);
  unsigned __int8 v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  uint64_t v7 = 1 << v6;
  unint64_t v8 = (unint64_t)((1 << v6) + 63) >> 6;
  uint64_t v9 = (unint64_t *)canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, String>();
  uint64_t v10 = (int64x2_t *)swift_allocObject(v9, (((40 << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8) + (16 << v6), 7uLL);
  v10[1].i64[0] = 0;
  double v11 = (double)(1 << v6) * 0.75;
  if ((~*(void *)&v11 & 0x7FF0000000000000) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v11 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v11 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  uint64_t v12 = (uint64_t *)v10;
  uint64_t v13 = v10 + 4;
  uint64_t v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v10);
  if ((_BYTE)qword_1EB208F08) {
    uint64_t v15 = (uint64_t *)v6;
  }
  else {
    uint64_t v15 = v12;
  }
  v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 40 * v7;
  if (v7 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v8, v13);
  }
  else {
    v13->i64[0] = -1 << v7;
  }
  return (uint64_t)v12;
}

{
  uint64_t v1;
  double v2;
  BOOL v3;
  uint64_t v4;
  char v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  int64x2_t *v10;
  double v11;
  uint64_t *v12;
  int64x2_t *v13;
  uint64_t v14;
  uint64_t *v15;

  if (result <= 1) {
    uint64_t v1 = 1;
  }
  else {
    uint64_t v1 = result;
  }
  double v2 = ceil((double)v1 / 0.75);
  if ((~*(void *)&v2 & 0x7FF0000000000000) == 0) {
    goto LABEL_23;
  }
  if (v2 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v2 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v3 = __OFADD__(v1, 1);
  uint64_t v4 = v1 + 1;
  if (v3)
  {
    __break(1u);
    return result;
  }
  if (v4 <= (uint64_t)v2) {
    uint64_t v4 = (uint64_t)v2;
  }
  char v5 = 64 - __clz(v4 - 1);
  unsigned __int8 v6 = (unint64_t)v4 <= 2 ? 1 : v5;
  uint64_t v7 = 1 << v6;
  unint64_t v8 = (unint64_t)((1 << v6) + 63) >> 6;
  uint64_t v9 = (unint64_t *)canonical specialized generic type metadata accessor for _DictionaryStorage<String, Int>();
  uint64_t v10 = (int64x2_t *)swift_allocObject(v9, (((16 << v6) + 8 * v8 + 71) & 0xFFFFFFFFFFFFFFF8) + (8 << v6), 7uLL);
  v10[1].i64[0] = 0;
  double v11 = (double)(1 << v6) * 0.75;
  if ((~*(void *)&v11 & 0x7FF0000000000000) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v11 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v11 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  uint64_t v12 = (uint64_t *)v10;
  uint64_t v13 = v10 + 4;
  uint64_t v14 = (uint64_t)&v10[4].i64[v8];
  v10[1].i64[1] = (uint64_t)v11;
  v10[2].i8[0] = v6;
  v10[2].i8[1] = 0;
  v10[2].i16[1] = 0;
  v10[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v10);
  if ((_BYTE)qword_1EB208F08) {
    uint64_t v15 = (uint64_t *)v6;
  }
  else {
    uint64_t v15 = v12;
  }
  v12[5] = (uint64_t)v15;
  v12[6] = v14;
  v12[7] = v14 + 16 * v7;
  if (v7 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v8, v13);
  }
  else {
    v13->i64[0] = -1 << v7;
  }
  return (uint64_t)v12;
}

uint64_t partial apply for closure #1 in Sequence<>.contains(_:)(uint64_t a1)
{
  return partial apply for closure #1 in Sequence<>.contains(_:)(a1) & 1;
}

{
  void *v1;
  int **v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  uint64_t v4 = v1[2];
  BOOL v3 = (int **)v1[3];
  unsigned __int8 v6 = v1[4];
  char v5 = v1[5];
  swift_getAssociatedTypeWitness(0, v3, v4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v6 + 8))(a1, v5) & 1;
}

Class *type metadata accessor for Dictionary.Keys(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Dictionary.Keys.Flags);
}

Class *type metadata accessor for _DictionaryAnyHashableBox(__int16 a1, uint64_t a2)
{
  return swift_getCanonicalPrespecializedGenericMetadata(a1, a2, &nominal type descriptor for _DictionaryAnyHashableBox.Flags, &flag for loading of canonical specialized generic type metadata for _DictionaryAnyHashableBox);
}

Class *type metadata accessor for Dictionary.Iterator._Variant(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Dictionary.Iterator._Variant.Flags);
}

Class *type metadata accessor for _SwiftDeferredNSDictionary(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _SwiftDeferredNSDictionary.Flags);
}

Class *type metadata accessor for DiscontiguousSlice(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for DiscontiguousSlice.Flags);
}

Class *type metadata accessor for DiscontiguousSlice.Index(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for DiscontiguousSlice.Index.Flags);
}

Class *type metadata accessor for RangeSet.Ranges(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for RangeSet.Ranges.Flags);
}

uint64_t partial apply for closure #1 in DiscontiguousSlice.distance(from:to:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return closure #1 in DiscontiguousSlice.distance(from:to:)(a1, a2, *(void *)(v3 + 16), *(void *)(v3 + 24), a3);
}

uint64_t partial apply for closure #1 in DiscontiguousSlice._index(of:)(uint64_t a1)
{
  uint64_t v3 = v1[2];
  uint64_t v4 = (int **)v1[3];
  uint64_t v5 = v1[4];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v4, v3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v9 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v8);
  return (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(AssociatedConformanceWitness + 32))(a1 + *((int *)v9 + 9), v5, AssociatedTypeWitness, AssociatedConformanceWitness) & 1;
}

Class *type metadata accessor for EnumeratedSequence(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for EnumeratedSequence.Flags);
}

Class *type metadata accessor for RangeSet(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for RangeSet.Flags);
}

Class *type metadata accessor for LazyDropWhileSequence(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for LazyDropWhileSequence.Flags);
}

Class *type metadata accessor for LazyDropWhileSequence.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for LazyDropWhileSequence.Iterator.Flags);
}

uint64_t specialized _SwiftDictionaryNSEnumerator.countByEnumerating(with:objects:count:)(uint64_t a1, atomic_ullong **a2)
{
  unint64_t v5 = *(void *)a1;
  unsigned __int8 v6 = *(atomic_ullong ***)(a1 + 8);
  uint64_t v7 = *(Swift::UInt **)(a1 + 16);
  long long v8 = *(_OWORD *)(a1 + 24);
  long long v9 = *(_OWORD *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t offset = v2[4].offset;
  if (offset == v2[5].offset)
  {
    uint64_t result = 0;
  }
  else
  {
    long long v18 = v9;
    long long v19 = v8;
    uint64_t v13 = _SwiftDictionaryNSEnumerator.bridgedKey(at:)(offset);
    *a2 = v13;
    swift_unknownObjectRelease(v13);
    v14.uint64_t offset = _HashTable.occupiedBucket(after:)(v2[4]).offset;
    long long v9 = v18;
    long long v8 = v19;
    v2[4].uint64_t offset = v14.offset;
    uint64_t result = 1;
  }
  if (v5 <= 1) {
    uint64_t v15 = 1;
  }
  else {
    uint64_t v15 = v5;
  }
  if (v5) {
    uint64_t v16 = v6;
  }
  else {
    uint64_t v16 = a2;
  }
  *(void *)a1 = v15;
  *(void *)(a1 + 8) = v16;
  uint64_t v17 = &_fastEnumerationStorageMutationsTarget;
  if (v5) {
    uint64_t v17 = v7;
  }
  *(void *)(a1 + 16) = v17;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 4swift_allocError((uint64_t)&type metadata for _MergeError, (uint64_t)&protocol witness table for _MergeError, 0, 0) = v9;
  *(void *)(a1 + 56) = v10;
  return result;
}

void specialized _SwiftDictionaryNSEnumerator.init(coder:)()
{
}

void specialized _SwiftDeferredNSDictionary.init(objects:forKeys:count:)()
{
  *(void *)(v0 + 16) = 0;
  *(void *)(v0 + 24) = 0;
  swift_release(v0);
  __break(1u);
}

uint64_t specialized _SwiftDeferredNSDictionary.enumerateKeysAndObjects(options:using:)(uint64_t a1)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  uint64_t v60 = *(uint64_t **)(*v1 + 104);
  uint64_t v2 = *(v60 - 1);
  uint64_t v3 = MEMORY[0x1F4188790](a1);
  uint64_t v44 = (id *)((char *)&v42 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v50 = v4;
  uint64_t v5 = MEMORY[0x1F4188790](v3);
  unsigned int v61 = (atomic_ullong **)((char *)&v42 - v6);
  long long v8 = *(uint64_t **)(v7 + 96);
  uint64_t v9 = *(v8 - 1);
  uint64_t v10 = MEMORY[0x1F4188790](v5);
  uint64_t v46 = (id *)((char *)&v42 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v51 = v11;
  uint64_t v12 = (const void *)MEMORY[0x1F4188790](v10);
  unint64_t v62 = (id *)((char *)&v42 - v13);
  Swift::_HashTable::Bucket v14 = (void (**)(void *, void *, atomic_ullong *, unsigned char *))_Block_copy(v12);
  uint64_t v15 = (char *)_SwiftDeferredNSDictionary.bridgeKeys()((uint64_t)v14);
  uint64_t v16 = (char *)_SwiftDeferredNSDictionary.bridgeValues()((uint64_t)v15);
  uint64_t v63 = v1;
  uint64_t v17 = v1[4];
  uint64_t v18 = *(void *)(v17 + 64);
  uint64_t v56 = v17 + 64;
  uint64_t v19 = 1 << *(unsigned char *)(v17 + 32);
  uint64_t v20 = -1;
  char v67 = 0;
  if (v19 < 64) {
    uint64_t v20 = ~(-1 << v19);
  }
  unint64_t v21 = v20 & v18;
  uint64_t v65 = (uint64_t)v15;
  int64_t v66 = (unint64_t)(v19 + 63) >> 6;
  unint64_t v58 = v15 + 40;
  uint64_t v54 = v9 + 16;
  uint64_t v45 = (void (**)(char *, id *, uint64_t *))(v9 + 32);
  uint64_t v55 = v9;
  unsigned int v49 = (void (**)(id *, uint64_t *))(v9 + 8);
  uint64_t v64 = (uint64_t)v16;
  char v57 = v16 + 40;
  uint64_t v52 = v2 + 16;
  unsigned int v43 = (void (**)(id *, atomic_ullong **, uint64_t *))(v2 + 32);
  uint64_t v53 = v2;
  uint64_t v48 = (void (**)(atomic_ullong **, uint64_t *))(v2 + 8);
  uint64_t v47 = v17;
  swift_retain_n(v17, 2);
  int64_t v22 = 0;
  uint64_t v23 = v49;
  if (!v21) {
    goto LABEL_7;
  }
LABEL_4:
  unint64_t v24 = __clz(__rbit64(v21));
  v21 &= v21 - 1;
  unint64_t v25 = v24 | (v22 << 6);
  if (v65)
  {
LABEL_5:
    uint64_t v26 = *(void **)&v58[8 * v25];
    swift_unknownObjectRetain(v26);
    if (v64) {
      goto LABEL_20;
    }
LABEL_22:
    uint64_t v36 = v60;
    (*(void (**)(atomic_ullong **, unint64_t, uint64_t *))(v53 + 16))(v61, *(void *)(v63[4] + 56) + *(void *)(v53 + 72) * v25, v60);
    if (!_swift_isClassOrObjCExistentialType((uint64_t)v36, v36))
    {
      uint64_t v39 = v44;
      unint64_t v40 = v60;
      (*v43)(v44, v61, v60);
      uint64_t v34 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v39, v40);
      goto LABEL_25;
    }
    if (v50 == 8)
    {
      uint64_t v37 = v61;
      uint64_t v34 = *v61;
      unint64_t v59 = v21;
      uint64_t v38 = *v48;
      swift_unknownObjectRetain(v34);
      v38(v37, v60);
      unint64_t v21 = v59;
      goto LABEL_25;
    }
LABEL_33:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
  }
  while (1)
  {
    (*(void (**)(id *, unint64_t, uint64_t *))(v55 + 16))(v62, *(void *)(v63[4] + 48) + *(void *)(v55 + 72) * v25, v8);
    if (_swift_isClassOrObjCExistentialType((uint64_t)v8, v8))
    {
      if (v51 != 8) {
        goto LABEL_33;
      }
      unint64_t v30 = v21;
      uint64_t v31 = v62;
      uint64_t v26 = *v62;
      uint64_t v32 = *v23;
      swift_unknownObjectRetain(*v62);
      uint64_t v33 = v31;
      unint64_t v21 = v30;
      v32(v33, v8);
      if (!v64) {
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v35 = v46;
      (*v45)((char *)v46, v62, v8);
      uint64_t v26 = _bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(v35, v8);
      if (!v64) {
        goto LABEL_22;
      }
    }
LABEL_20:
    uint64_t v34 = *(atomic_ullong **)&v57[8 * v25];
    swift_unknownObjectRetain(v34);
LABEL_25:
    v14[2](v14, v26, v34, &v67);
    if (v67)
    {
      swift_release_n(v47, 2);
      _Block_release(v14);
      swift_unknownObjectRelease(v26);
      swift_unknownObjectRelease(v34);
      swift_release(v64);
      return swift_release(v65);
    }
    swift_unknownObjectRelease(v26);
    swift_unknownObjectRelease(v34);
    if (v21) {
      goto LABEL_4;
    }
LABEL_7:
    if (__OFADD__(v22++, 1)) {
      __break(1u);
    }
    if (v22 >= v66) {
      break;
    }
    unint64_t v28 = *(void *)(v56 + 8 * v22);
    if (!v28)
    {
      int64_t v29 = v22 + 1;
      if (v22 + 1 >= v66) {
        break;
      }
      unint64_t v28 = *(void *)(v56 + 8 * v29);
      if (!v28)
      {
        while (1)
        {
          int64_t v22 = v29 + 1;
          if (__OFADD__(v29, 1)) {
            break;
          }
          if (v22 >= v66) {
            goto LABEL_29;
          }
          unint64_t v28 = *(void *)(v56 + 8 * v22);
          ++v29;
          if (v28) {
            goto LABEL_16;
          }
        }
        __break(1u);
        goto LABEL_33;
      }
      ++v22;
    }
LABEL_16:
    unint64_t v21 = (v28 - 1) & v28;
    unint64_t v25 = __clz(__rbit64(v28)) + (v22 << 6);
    if (v65) {
      goto LABEL_5;
    }
  }
LABEL_29:
  _Block_release(v14);
  swift_release(v64);
  swift_release_n(v47, 2);
  return swift_release(v65);
}

uint64_t specialized static _DictionaryStorage.resize(original:capacity:move:)(uint64_t result, uint64_t (*a2)(void))
{
  if (result <= 1) {
    uint64_t v2 = 1;
  }
  else {
    uint64_t v2 = result;
  }
  double v3 = ceil((double)v2 / 0.75);
  if ((~*(void *)&v3 & 0x7FF0000000000000) == 0) {
    goto LABEL_23;
  }
  if (v3 <= -9.22337204e18) {
    goto LABEL_24;
  }
  if (v3 >= 9.22337204e18) {
    goto LABEL_25;
  }
  BOOL v4 = __OFADD__(v2, 1);
  uint64_t v5 = v2 + 1;
  if (v4)
  {
    __break(1u);
    return result;
  }
  if (v5 <= (uint64_t)v3) {
    uint64_t v5 = (uint64_t)v3;
  }
  char v6 = 64 - __clz(v5 - 1);
  unsigned __int8 v7 = (unint64_t)v5 <= 2 ? 1 : v6;
  uint64_t v8 = 1 << v7;
  unint64_t v9 = (unint64_t)((1 << v7) + 63) >> 6;
  uint64_t v10 = (unint64_t *)a2(0);
  uint64_t v11 = (int64x2_t *)swift_allocObject(v10, (((8 << v7) + 8 * v9 + 71) & 0xFFFFFFFFFFFFFFF8) + (8 << v7), 7uLL);
  v11[1].i64[0] = 0;
  double v12 = (double)(1 << v7) * 0.75;
  if ((~*(void *)&v12 & 0x7FF0000000000000) == 0) {
LABEL_23:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because it is either infinite or NaN", 76, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3735uLL, 0);
  if (v12 <= -9.22337204e18) {
LABEL_24:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be less than Int.min", 85, 2, "Swift/IntegerTypes.swift", 24, 2, 0x3738uLL, 0);
  if (v12 >= 9.22337204e18) {
LABEL_25:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Double value cannot be converted to Int because the result would be greater than Int.max", 88, 2, "Swift/IntegerTypes.swift", 24, 2, 0x373BuLL, 0);
  uint64_t v13 = (uint64_t *)v11;
  Swift::_HashTable::Bucket v14 = v11 + 4;
  uint64_t v15 = (uint64_t)&v11[4].i64[v9];
  v11[1].i64[1] = (uint64_t)v12;
  v11[2].i8[0] = v7;
  v11[2].i8[1] = 0;
  v11[2].i16[1] = 0;
  v11[2].i32[1] = specialized static Hasher._hash(seed:_:)(0, (uint64_t)v11);
  if ((_BYTE)qword_1EB208F08) {
    uint64_t v16 = (uint64_t *)v7;
  }
  else {
    uint64_t v16 = v13;
  }
  v13[5] = (uint64_t)v16;
  v13[6] = v15;
  v13[7] = v15 + 8 * v8;
  if (v8 > 63) {
    specialized UnsafeMutablePointer.assign(repeating:count:)(0, v9, v14);
  }
  else {
    v14->i64[0] = -1 << v8;
  }
  return (uint64_t)v13;
}

uint64_t specialized RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)(uint64_t a1, void *a2, char a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = type metadata accessor for Range(0, a4, a5, a4);
  uint64_t v11 = (uint64_t)*(v10 - 1);
  uint64_t v12 = MEMORY[0x1F4188790](v10);
  Swift::_HashTable::Bucket v14 = (char *)&v35 - v13;
  Swift::Int v15 = a2[2];
  if ((unint64_t)v15 < 2)
  {
    if (v15)
    {
      (*(void (**)(char *, unint64_t, Class *))(v11 + 16))(v14, (unint64_t)a2+ ((*(unsigned __int8 *)(v11 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80)), v10);
      if (((*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(a5 + 16))(a1 + *((int *)v10 + 9), v14, a4, a5) & 1) == 0)
      {
        char v29 = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(a5 + 40))(a1, &v14[*((int *)v10 + 9)], a4, a5);
        (*(void (**)(char *, Class *))(v11 + 8))(v14, v10);
        return v29 & 1;
      }
      (*(void (**)(char *, Class *))(v11 + 8))(v14, v10);
    }
    return 0;
  }
  else
  {
    uint64_t v36 = &v35;
    v41[2] = a2;
    MEMORY[0x1F4188790](v12);
    uint64_t v31 = a4;
    uint64_t v32 = a5;
    LOBYTE(v33) = a3 & 1;
    uint64_t v34 = a1;
    uint64_t v18 = (unint64_t *)type metadata accessor for ContiguousArray(0, (uint64_t)v10, v16, v17);
    uint64_t v35 = a1;
    uint64_t v19 = (uint64_t)v18;
    uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for ContiguousArray<A>, v18, v20);
    Collection._partitioningIndex(where:)((uint64_t (*)(char *))partial apply for closure #1 in RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:), (uint64_t)(&v35 - 6), v19, WitnessTable, (char *)&v42);
    uint64_t v22 = v42;
    if (v15 < v42) {
      goto LABEL_4;
    }
    ContiguousArray._checkIndex(_:)(v42);
    ContiguousArray._checkIndex(_:)(v15);
    uint64_t v36 = &v35;
    id v37 = a2;
    uint64_t v38 = (char *)a2 + ((*(unsigned __int8 *)(v11 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v11 + 80));
    uint64_t v39 = v22;
    uint64_t v40 = (2 * v15) | 1;
    MEMORY[0x1F4188790](v23);
    uint64_t v31 = a4;
    uint64_t v32 = a5;
    LOBYTE(v33) = a3 & 1;
    uint64_t v34 = v35;
    uint64_t v26 = (unint64_t *)type metadata accessor for ArraySlice(0, (uint64_t)v10, v24, v25);
    swift_retain(a2);
    uint64_t v28 = swift_getWitnessTable(protocol conformance descriptor for ArraySlice<A>, v26, v27);
    Collection._partitioningIndex(where:)((uint64_t (*)(char *))partial apply for closure #2 in RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:), (uint64_t)(&v35 - 6), (uint64_t)v26, v28, (char *)v41);
    swift_unknownObjectRelease(v37);
    if (v41[0] < v22) {
LABEL_4:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  return v22;
}

uint64_t specialized EmptyCollection.subscript.setter(uint64_t result, uint64_t a2)
{
  if (result | a2) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Index out of range", 18, 2, "Swift/EmptyCollection.swift", 27, 2, 0x76uLL, 0);
  }
  return result;
}

uint64_t type metadata accessor for __SharedStringStorage()
{
  return self;
}

Class *type metadata accessor for _IteratorBox(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _IteratorBox.Flags);
}

Class *type metadata accessor for _ClosureBasedIterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _ClosureBasedIterator.Flags);
}

Class *type metadata accessor for DropFirstSequence(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for DropFirstSequence.Flags);
}

Class *type metadata accessor for _SequenceBox(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _SequenceBox.Flags);
}

Class *type metadata accessor for DropWhileSequence(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for DropWhileSequence.Flags);
}

Class *type metadata accessor for PrefixSequence(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for PrefixSequence.Flags);
}

Class *type metadata accessor for _BidirectionalCollectionBox(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _BidirectionalCollectionBox.Flags);
}

Class *type metadata accessor for _RandomAccessCollectionBox(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _RandomAccessCollectionBox.Flags);
}

Class *type metadata accessor for _ClosureBasedSequence(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _ClosureBasedSequence.Flags);
}

uint64_t partial apply for thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @owned Error)(uint64_t a1, void *a2)
{
  return partial apply for thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @owned Error)(a1, a2);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  uint64_t result = (*(uint64_t (**)(void))(v2 + 32))();
  if (v3) {
    *a2 = v3;
  }
  return result;
}

void *partial apply for specialized thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)(uint64_t a1)
{
  return specialized thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)(a1, *(uint64_t (**)(uint64_t, uint64_t *))(v1 + 32));
}

Class *type metadata accessor for _AnyBidirectionalCollectionBox(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _AnyBidirectionalCollectionBox.Flags);
}

Class *type metadata accessor for _AnyRandomAccessCollectionBox(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _AnyRandomAccessCollectionBox.Flags);
}

Class *type metadata accessor for LazyFilterSequence(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for LazyFilterSequence.Flags);
}

Class *type metadata accessor for LazyFilterSequence.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for LazyFilterSequence.Iterator.Flags);
}

void sub_1814EFBF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(v4 + 16);
  char v6 = (int *)(type metadata accessor for LazyFilterSequence(0, v5, *(void *)(v4 + 24), a4) - 1);
  unint64_t v7 = (*(unsigned __int8 *)(*(void *)v6 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(*(void *)v6 + 80);
  unint64_t v8 = (*(void *)(*(void *)v6 + 64) + v7 + 7) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v9 = v4 + v7;
  (*(void (**)(unint64_t, uint64_t))(*(void *)(v5 - 8) + 8))(v4 + v7, v5);
  swift_release(*(void *)(v9 + v6[11] + 8));
  swift_release(*(void *)(v4 + v8 + 8));

  swift_deallocObject(v4);
}

uint64_t partial apply for closure #1 in LazyFilterSequence.filter(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(v4 + 16);
  unint64_t v7 = *(int ***)(v4 + 24);
  uint64_t v8 = (uint64_t)*(type metadata accessor for LazyFilterSequence(0, v6, (uint64_t)v7, a4) - 1);
  unint64_t v9 = (*(unsigned __int8 *)(v8 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80);
  uint64_t v10 = v4 + v9;
  uint64_t v11 = v4 + ((*(void *)(v8 + 64) + v9 + 7) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v12 = *(uint64_t (**)(char *))v11;
  uint64_t v13 = *(void *)(v11 + 8);

  return closure #1 in LazyFilterSequence.filter(_:)(a1, v10, v12, v13, v6, v7);
}

void sub_1814EFDC0()
{
  swift_deallocObject(v0);
}

void sub_1814EFDD4()
{
  swift_deallocObject(v0);
}

uint64_t partial apply for closure #2 in LazySequenceProtocol.compactMap<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return closure #2 in LazySequenceProtocol.compactMap<A>(_:)(a1, *(void *)(v2 + 24), *(void *)(v2 + 32), a2);
}

Class *type metadata accessor for FlattenSequence.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for FlattenSequence.Iterator.Flags);
}

Class *type metadata accessor for FlattenSequence<>.Index(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for FlattenSequence<>.Index.Flags);
}

float specialized Float16.init(sign:exponentBitPattern:significandBitPattern:)(int a1, char a2, __int16 a3)
{
  LODWORD(result) = (a1 << 15) | ((a2 & 0x1F) << 10) | a3 & 0x3FF;
  return result;
}

float specialized Float.init(sign:exponentBitPattern:significandBitPattern:)(int a1, unsigned __int8 a2, int a3)
{
  LODWORD(result) = (a1 << 31) | (a2 << 23) | a3 & 0x7FFFFF;
  return result;
}

Class *type metadata accessor for _ConcreteHashableBox(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _ConcreteHashableBox.Flags, &flag for loading of canonical specialized generic type metadata for _ConcreteHashableBox);
}

uint64_t outlined assign with take of AnyHashable(long long *a1, uint64_t a2)
{
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a2);
  long long v4 = *a1;
  long long v5 = a1[1];
  *(void *)(a2 + 32) = *((void *)a1 + 4);
  *(_OWORD *)a2 = v4;
  *(_OWORD *)(a2 + 16) = v5;
  return a2;
}

uint64_t partial apply for closure #1 in FixedWidthInteger.init<A>(_:radix:)@<X0>(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return closure #1 in FixedWidthInteger.init<A>(_:radix:)(a1, a2, v3[6], v3[2], v3[4], a3);
}

unint64_t lazy protocol witness table accessor for type UInt16 and conformance UInt16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt16 and conformance UInt16;
  if (!lazy protocol witness table cache variable for type UInt16 and conformance UInt16)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt16, (unint64_t *)&type metadata for UInt16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt16 and conformance UInt16);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt16 and conformance UInt16;
  if (!lazy protocol witness table cache variable for type UInt16 and conformance UInt16)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt16, (unint64_t *)&type metadata for UInt16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt16 and conformance UInt16);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt16 and conformance UInt16;
  if (!lazy protocol witness table cache variable for type UInt16 and conformance UInt16)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt16, (unint64_t *)&type metadata for UInt16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt16 and conformance UInt16);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type UInt and conformance UInt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt and conformance UInt;
  if (!lazy protocol witness table cache variable for type UInt and conformance UInt)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt, (unint64_t *)&type metadata for UInt, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt and conformance UInt);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt and conformance UInt;
  if (!lazy protocol witness table cache variable for type UInt and conformance UInt)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt, (unint64_t *)&type metadata for UInt, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt and conformance UInt);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt and conformance UInt;
  if (!lazy protocol witness table cache variable for type UInt and conformance UInt)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt, (unint64_t *)&type metadata for UInt, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt and conformance UInt);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type UInt64 and conformance UInt64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt64 and conformance UInt64;
  if (!lazy protocol witness table cache variable for type UInt64 and conformance UInt64)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt64, (unint64_t *)&type metadata for UInt64, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt64 and conformance UInt64);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt64 and conformance UInt64;
  if (!lazy protocol witness table cache variable for type UInt64 and conformance UInt64)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt64, (unint64_t *)&type metadata for UInt64, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt64 and conformance UInt64);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt64 and conformance UInt64;
  if (!lazy protocol witness table cache variable for type UInt64 and conformance UInt64)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt64, (unint64_t *)&type metadata for UInt64, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt64 and conformance UInt64);
  }
  return result;
}

Class *type metadata accessor for JoinedSequence(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for JoinedSequence.Flags);
}

Class *type metadata accessor for JoinedSequence.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for JoinedSequence.Iterator.Flags);
}

uint64_t specialized static _Int128./= infix(_:_:)(void *a1, Swift::_Int128 dividingBy)
{
  if (dividingBy.high == -1)
  {
    if (dividingBy.low == -1 && a1[1] == 0x8000000000000000 && *a1 == 0) {
LABEL_11:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in /=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x3CEuLL, 0);
  }
  else if (!dividingBy.high && !dividingBy.low)
  {
    goto LABEL_11;
  }
  *(_OWORD *)&uint64_t result = (unsigned __int128)_Int128.quotientAndRemainder(dividingBy:)(dividingBy);
  *a1 = result;
  a1[1] = v5;
  return result;
}

Swift::UInt64 specialized static _UInt128./ infix(_:_:)(Swift::UInt64 a1, Swift::UInt64 a2, unint64_t a3, unint64_t a4)
{
  if (!(a4 | a3)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in /=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x1CEuLL, 0);
  }
  v10.Swift::UInt64 low = a2;
  v10.Swift::UInt64 high = (Swift::UInt64)&v7;
  specialized _wideDivide22<A>(_:by:)(&v9, &v8, v10, a1, a4, a3);
  return v9;
}

unint64_t specialized static _Int128.* infix(_:_:)(unint64_t a1, int64_t a2, unint64_t a3, unint64_t a4)
{
  if (a2)
  {
    if (!a4)
    {
      int64_t v5 = (unsigned __int128)-(__int128)__PAIR128__(v4, a1) >> 64;
      a4 = 0;
      if (a2 >= 0)
      {
        LODWORD(v5) = 0;
      }
      else
      {
        a1 = -(uint64_t)a1;
        a2 = v5;
        LODWORD(v5) = a3 != 0;
      }
      goto LABEL_19;
    }
    if (((a4 ^ a2) & 0x8000000000000000) == 0)
    {
      if (a2 < 0)
      {
LABEL_17:
        int64_t v5 = (a4 ^ a2) >> 63;
        BOOL v6 = a1 == 0;
        a1 = -(uint64_t)a1;
        a2 = -(a2 + !v6);
        if ((a4 & 0x8000000000000000) == 0) {
          goto LABEL_19;
        }
        goto LABEL_18;
      }
      goto LABEL_9;
    }
    if (a2 < 0) {
      goto LABEL_17;
    }
    LODWORD(v5) = 1;
    if ((a4 & 0x8000000000000000) == 0) {
      goto LABEL_19;
    }
  }
  else
  {
    if ((a4 & 0x8000000000000000) == 0 || !a1)
    {
LABEL_9:
      LODWORD(v5) = 0;
      if ((a4 & 0x8000000000000000) == 0) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }
    a2 = 0;
    LODWORD(v5) = 1;
  }
LABEL_18:
  BOOL v6 = a3 == 0;
  a3 = -(uint64_t)a3;
  a4 = -(uint64_t)(a4 + !v6);
LABEL_19:
  BOOL v7 = !is_mul_ok(a2, a3);
  BOOL v8 = !is_mul_ok(a1, a4);
  BOOL v9 = __CFADD__(a2 * a3, a1 * a4);
  unint64_t v10 = a1 * a3;
  uint64_t v11 = (__PAIR128__(a4, a3) * __PAIR128__(a2, a1)) >> 64;
  BOOL v12 = __CFADD__(a2 * a3 + a1 * a4, (a1 * (unsigned __int128)a3) >> 64);
  if (a4) {
    BOOL v13 = a2 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13 || v7 || v8 || v9)
  {
    if (!v5) {
      goto LABEL_47;
    }
    unint64_t v14 = -v11;
    BOOL v12 = 1;
    BOOL v6 = v10 == 0;
    uint64_t v15 = -(uint64_t)v10;
    if (v6) {
      goto LABEL_40;
    }
    goto LABEL_39;
  }
  if (!v5) {
    goto LABEL_44;
  }
  unint64_t v14 = -v11;
  BOOL v6 = v10 == 0;
  uint64_t v15 = -(uint64_t)v10;
  if (!v6) {
LABEL_39:
  }
    --v14;
LABEL_40:
  BOOL v6 = v15 != 0;
  unint64_t v16 = v15 - 1;
  uint64_t v17 = !v6;
  uint64_t v11 = (__PAIR128__(v14, v16) + __PAIR128__(v17 << 63 >> 63, 1)) >> 64;
  unint64_t v10 = v16 + 1;
LABEL_44:
  if (v12 || ((v5 ^ (v11 >= 0)) & 1) == 0) {
LABEL_47:
  }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in *", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x29AuLL, 0);
  return v10;
}

uint64_t *specialized static _UInt128.&>>= infix(_:_:)(uint64_t *result, char a2)
{
  unint64_t v2 = *result;
  unint64_t v3 = result[1];
  unint64_t v4 = v3 >> a2;
  uint64_t v5 = (v3 << -a2) | ((unint64_t)*result >> a2);
  if ((a2 & 0x7F) != 0)
  {
    v3 >>= a2;
    unint64_t v2 = v5;
  }
  if ((a2 & 0x7Fu) > 0x3FuLL)
  {
    unint64_t v3 = 0;
    unint64_t v2 = v4;
  }
  *uint64_t result = v2;
  result[1] = v3;
  return result;
}

uint64_t *specialized static _Int128.&<<= infix(_:_:)(uint64_t *result, char a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  if ((a2 & 0x7F) != 0)
  {
    uint64_t v3 = (v3 << a2) | ((unint64_t)*result >> -a2);
    uint64_t v2 = *result << a2;
  }
  if ((a2 & 0x7Fu) > 0x3FuLL)
  {
    uint64_t v3 = *result << a2;
    uint64_t v2 = 0;
  }
  *uint64_t result = v2;
  result[1] = v3;
  return result;
}

void **specialized RawKeyPathComponent._projectMutableAddress<A, B>(_:from:to:isRoot:keepAlive:)(void **a1, char **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t v62 = a2;
  BOOL v13 = type metadata accessor for Optional(0, a7, a3, a4);
  uint64_t v57 = (uint64_t)*(v13 - 1);
  uint64_t v14 = MEMORY[0x1F4188790](v13);
  unint64_t v16 = (char *)&v56 - v15;
  uint64_t v59 = *(void *)(a6 - 8);
  uint64_t v17 = MEMORY[0x1F4188790](v14);
  uint64_t v19 = (char *)&v56 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v17);
  uint64_t v22 = (char *)&v56 - v21;
  uint64_t v61 = *(void *)(a7 - 8);
  MEMORY[0x1F4188790](v20);
  uint64_t v60 = (char *)&v56 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
  RawKeyPathComponent.value.getter(a3, a4, a5, (uint64_t *)v63);
  outlined init with take of KeyPathComponent(v63, (uint64_t)&v64);
  switch(v65 >> 61)
  {
    case 1uLL:
      v65 &= 0x1FFFFFFFFFFFFFFFuLL;
      uint64_t v38 = *a1;
      a1 = (void **)((char *)*a1 + v64);
      uint64_t v39 = v62;
      uint64_t v40 = (uint64_t)*v62;
      uint64_t v41 = (unint64_t *)type metadata accessor for ClassHolder(0, a7, v24, v25);
      Swift::Int v42 = (char *)swift_allocObject(v41, 0x38uLL, 7uLL);
      *((void *)v42 + 2) = v40;
      *((void *)v42 + 3) = v38;
      swift_beginAccess((uint64_t)a1, (void *)v42 + 4, 0x21uLL, v58);
      *uint64_t v39 = v42;
      swift_unknownObjectRetain(v38);
      break;
    case 2uLL:
      __break(1u);
      JUMPOUT(0x1814F0A14);
    case 3uLL:
      v65 &= 0x1FFFFFFFFFFFFFFFuLL;
      uint64_t v43 = v66;
      if (v69) {
        BOOL v44 = v67 == 0;
      }
      else {
        BOOL v44 = 1;
      }
      if (v44) {
        uint64_t v45 = 0;
      }
      else {
        uint64_t v45 = v68 - v67;
      }
      if (v44) {
        uint64_t v46 = v66;
      }
      else {
        uint64_t v46 = v67;
      }
      uint64_t v47 = v62;
      uint64_t v58 = (uint64_t)*v62;
      uint64_t v57 = ComputedAccessorsPtr.mutatingSetter<A, B>()(v66, a6, a7);
      uint64_t v48 = (void (*)(char *, uint64_t, uint64_t))ComputedAccessorsPtr.getter<A, B>()(v43, a6, a7);
      uint64_t v49 = v59;
      (*(void (**)(char *, void **, uint64_t))(v59 + 16))(v22, a1, a6);
      uint64_t v50 = v60;
      v48(v22, v46, v45);
      (*(void (**)(char *, uint64_t))(v49 + 8))(v22, a6);
      uint64_t v52 = type metadata accessor for MutatingWritebackBuffer(0, a6, a7, v51);
      uint64_t v53 = (char *)swift_allocObject((unint64_t *)v52, *((unsigned int *)v52 + 12), *((unsigned __int16 *)v52 + 26));
      *((void *)v53 + 2) = v58;
      *((void *)v53 + 3) = a1;
      *((void *)v53 + 4) = v57;
      *((void *)v53 + 5) = v46;
      *((void *)v53 + 6) = v45;
      a1 = (void **)&v53[*(void *)(*(void *)v53 + 136)];
      (*(void (**)(void **, char *, uint64_t))(v61 + 32))(a1, v50, a7);
      char *v47 = v53;
      break;
    case 4uLL:
      v65 &= 0x1FFFFFFFFFFFFFFFuLL;
      uint64_t v26 = v66;
      uint64_t v27 = v67;
      uint64_t v57 = v69;
      uint64_t v58 = v68;
      uint64_t v28 = v59;
      char v29 = *(void (**)(char *, void **, uint64_t))(v59 + 16);
      v29(v19, a1, a6);
      if (v57) {
        BOOL v30 = v27 == 0;
      }
      else {
        BOOL v30 = 1;
      }
      if (v30) {
        uint64_t v31 = 0;
      }
      else {
        uint64_t v31 = v58 - v27;
      }
      if (v30) {
        uint64_t v27 = v26;
      }
      uint64_t v58 = (uint64_t)*v62;
      v29(v22, (void **)v19, a6);
      uint64_t v32 = ComputedAccessorsPtr.nonmutatingSetter<A, B>()(v26, a6, a7);
      int v33 = (void (*)(char *, uint64_t, uint64_t))ComputedAccessorsPtr.getter<A, B>()(v26, a6, a7);
      uint64_t v34 = v60;
      v33(v19, v27, v31);
      (*(void (**)(char *, uint64_t))(v28 + 8))(v19, a6);
      uint64_t v36 = type metadata accessor for NonmutatingWritebackBuffer(0, a6, a7, v35);
      id v37 = (char *)swift_allocObject((unint64_t *)v36, *((unsigned int *)v36 + 12), *((unsigned __int16 *)v36 + 26));
      *((void *)v37 + 2) = v58;
      (*(void (**)(char *, char *, uint64_t))(v28 + 32))(&v37[*(void *)(*(void *)v37 + 104)], v22, a6);
      *(void *)&v37[*(void *)(*(void *)v37 + 112)] = v32;
      *(void *)&v37[*(void *)(*(void *)v37 + 120)] = v27;
      *(void *)&v37[*(void *)(*(void *)v37 + 128)] = v31;
      a1 = (void **)&v37[*(void *)(*(void *)v37 + 136)];
      (*(void (**)(void **, char *, uint64_t))(v61 + 32))(a1, v34, a7);
      id *v62 = v37;
      break;
    case 5uLL:
      uint64_t v54 = v57;
      (*(void (**)(char *, void **, Class *))(v57 + 16))(v16, a1, v13);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v61 + 48))(v16, 1, a7) == 1) {
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/KeyPath.swift", 19, 2, 0x72EuLL, 0);
      }
      (*(void (**)(char *, Class *))(v54 + 8))(v16, v13);
      break;
    default:
      a1 = (void **)((char *)a1 + v64);
      break;
  }
  return a1;
}

Class *type metadata accessor for RawKeyPathComponent.ProjectionResult(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for RawKeyPathComponent.ProjectionResult.Flags);
}

Class *type metadata accessor for KeyPath(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for KeyPath.Flags);
}

Class *type metadata accessor for PartialKeyPath(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for PartialKeyPath.Flags);
}

Class *type metadata accessor for ReferenceWritableKeyPath(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for ReferenceWritableKeyPath.Flags);
}

void partial apply for closure #1 in closure #1 in closure #1 in _appendingKeyPaths<A, B, C, D>(root:leaf:)(char *a1, void *a2)
{
  uint64_t v3 = *(void *)(v2 + 48);
  unint64_t v4 = *(uint64_t **)(v2 + 56);
  uint64_t v6 = *(void *)(v2 + 64);
  uint64_t v5 = *(void *)(v2 + 72);
  uint64_t v7 = *v4;
  uint64_t v8 = *v4;
  if (*(uint64_t *)(v2 + 32) >= 1)
  {
    if (!a1) {
      goto LABEL_30;
    }
    **(void **)(v2 + 4swift_allocError((uint64_t)&type metadata for _MergeError, (uint64_t)&protocol witness table for _MergeError, 0, 0) = &a1[v3];
    a1 = (char *)specialized UnsafeMutableRawBufferPointer.init<A>(_:)((uint64_t)a1, v3);
    uint64_t v7 = *v4;
  }
  into._position.value._rawValue = a1;
  into._end.value._rawValue = a2;
  unsigned __int8 v9 = (*(uint64_t (**)(void))(v7 + 160))();
  if (__OFSUB__(v3, 8))
  {
    __break(1u);
LABEL_30:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
  }
  if (*(unsigned char *)(v6 + 16) == 1) {
    char v10 = *(unsigned char *)(v5 + 16);
  }
  else {
    char v10 = 0;
  }
  int v11 = v9;
  uint64_t v12 = specialized KeyPathBuffer.Header.init(size:trivial:hasReferencePrefix:)(v3 - 8, v10, *(unsigned char *)(v6 + 17) & 1u | (v9 == 2));
  Swift::UnsafeMutableRawBufferPointer v13 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(4, 4);
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(v12, 0, (uint64_t)v13._position.value._rawValue, (uint64_t)v13._end.value._rawValue);
  KeyPathBuffer.Builder.pushRaw(size:alignment:)(4, 4);
  char v14 = *(unsigned char *)(v5 + 17);
  int v16 = KeyPathBuffer.next()();
  if (v15)
  {
    uint64_t v17 = v15;
    do
    {
      if (v16 < 0) {
        char v18 = v14 ^ 1;
      }
      else {
        char v18 = 0;
      }
      RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, v18);
      Swift::UnsafeMutableRawBufferPointer v19 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(8, 8);
      if (!v19._position.value._rawValue
        || (char *)v19._end.value._rawValue - (char *)v19._position.value._rawValue <= 7)
      {
LABEL_28:
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawBufferPointer.storeBytes out of bounds", 54, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x1BDuLL, 0);
      }
      *(void *)v19._position.value._rawValue = v17;
      int v16 = KeyPathBuffer.next()();
      uint64_t v17 = v20;
    }
    while (v20);
  }
  if (v11 == 2) {
    char v21 = 1;
  }
  else {
    char v21 = v14;
  }
  if (v21) {
    char v22 = v14 ^ 1;
  }
  else {
    char v22 = v16 < 0;
  }
  RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, v22);
  uint64_t v23 = *(void *)(v8 + 144);
  Swift::UnsafeMutableRawBufferPointer v24 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(8, 8);
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(v23, 0, (uint64_t)v24._position.value._rawValue, (uint64_t)v24._end.value._rawValue);
  while (1)
  {
    int v25 = KeyPathBuffer.next()();
    uint64_t v27 = v26;
    RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, v25 < 0);
    if (!v27) {
      break;
    }
    Swift::UnsafeMutableRawBufferPointer v28 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(8, 8);
    if (!v28._position.value._rawValue || (char *)v28._end.value._rawValue - (char *)v28._position.value._rawValue <= 7) {
      goto LABEL_28;
    }
    *(void *)v28._position.value._rawValue = v27;
  }
}

Class *type metadata accessor for WritableKeyPath(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for WritableKeyPath.Flags);
}

unint64_t partial apply for closure #1 in _swift_getKeyPath(pattern:arguments:)(_DWORD *a1, unsigned char *a2)
{
  uint64_t v3 = *(void *)(v2 + 16);
  unint64_t result = _instantiateKeyPathBuffer(_:_:_:_:)(*(void *)(v2 + 24), a1, a2, *(void **)(v2 + 32), *(void **)(v2 + 40));
  *(_DWORD *)uint64_t v3 = result;
  *(unsigned char *)(v3 + 4) = BYTE4(result) & 1;
  return result;
}

void partial apply for closure #2 in _rerootKeyPath<A>(_:to:)(void *a1, void *a2)
{
  unint64_t v3 = *(void *)(v2 + 16);
  char v4 = *(unsigned char *)(v2 + 24);
  char v5 = *(unsigned char *)(v2 + 25);
  uint64_t v6 = *(void *)(v2 + 32);
  into._position.value._rawValue = a1;
  into._end.value._rawValue = a2;
  uint64_t v7 = specialized KeyPathBuffer.Header.init(size:trivial:hasReferencePrefix:)(v3, v4, v5);
  Swift::UnsafeMutableRawBufferPointer v8 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(4, 4);
  specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(v7, 0, (uint64_t)v8._position.value._rawValue, (uint64_t)v8._end.value._rawValue);
  KeyPathBuffer.Builder.pushRaw(size:alignment:)(4, 4);
  if ((((_BYTE)v6 + 24) & 3) != 0) {
LABEL_32:
  }
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "load from misaligned raw pointer", 32, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x1B8uLL, 0);
  uint64_t v9 = v6 + 32 + (*(_DWORD *)(v6 + 24) & 0xFFFFFF);
  uint64_t v25 = v6 + 32;
  uint64_t v26 = v9;
  while (1)
  {
    char v10 = (int *)_ss12MemoryLayoutOsRi_zrlE26_roundingUpBaseToAlignmentyS2WFZs19RawKeyPathComponentV6HeaderV_Tgm5(v25, v26);
    if (!v10) {
      goto LABEL_35;
    }
    unint64_t v12 = v11 - (void)v10 - 4;
    if (__OFSUB__(v11 - (void)v10, 4))
    {
      __break(1u);
      goto LABEL_32;
    }
    if ((v12 & 0x8000000000000000) != 0) {
      goto LABEL_30;
    }
    Swift::UnsafeMutableRawBufferPointer v13 = v10 + 1;
    int v14 = *v10;
    int v15 = HIBYTE(*v10) & 0x7F;
    if (v15 != 1)
    {
      if (v15 == 2)
      {
        if ((v14 & 0x400000) != 0) {
          unint64_t v16 = 28;
        }
        else {
          unint64_t v16 = 20;
        }
        if ((v14 & 0x80000) != 0)
        {
          if ((v14 & 0x400000) != 0) {
            uint64_t v17 = 6;
          }
          else {
            uint64_t v17 = 4;
          }
          uint64_t v18 = (uint64_t)&v10[v17 + 2];
          if ((v18 & 7) != 0) {
            goto LABEL_32;
          }
          unint64_t v19 = v16 + 16;
          uint64_t v20 = *(void *)v18;
          BOOL v21 = __OFADD__(v19, v20);
          unint64_t v16 = v19 + v20;
          if (v21)
          {
            __break(1u);
LABEL_34:
            __break(1u);
LABEL_35:
            _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "unsafelyUnwrapped of nil optional", 33, 2, "Swift/Optional.swift", 20, 2, 0x163uLL, 0);
          }
          if ((v14 & 0x10) != 0)
          {
            BOOL v21 = __OFADD__(v16, 8);
            v16 += 8;
            if (v21) {
              goto LABEL_34;
            }
          }
          if ((v16 & 0x8000000000000000) != 0) {
            goto LABEL_30;
          }
        }
        goto LABEL_22;
      }
      if (v15 != 3)
      {
        unint64_t v16 = 0;
        uint64_t v22 = (uint64_t)(v10 + 1);
        goto LABEL_25;
      }
    }
    unint64_t v16 = 4 * ((~v14 & 0x7FFFFF) == 0);
LABEL_22:
    if (v12 < v16) {
LABEL_30:
    }
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeRawBufferPointer with negative count", 42, 2, "Swift/UnsafeRawBufferPointer.swift", 34, 2, 0x485uLL, 0);
    uint64_t v22 = (uint64_t)v13 + v16;
LABEL_25:
    uint64_t v25 = v22;
    uint64_t v26 = (uint64_t)v13 + v12;
    if (v12 == v16) {
      break;
    }
    uint64_t v23 = (uint64_t *)specialized _pop<A>(from:as:count:)(&v25, 1);
    if (!v23) {
      goto LABEL_35;
    }
    uint64_t v24 = *v23;
    RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, v14 < 0);
    if (!v24) {
      return;
    }
  }
  RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, v14 < 0);
}

Class *type metadata accessor for KeyValuePairs(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for KeyValuePairs.Flags);
}

uint64_t partial apply for closure #1 in closure #1 in ManagedBufferPointer.init(bufferClass:minimumCapacity:makingHeaderWith:)(void *a1)
{
  return closure #1 in closure #1 in ManagedBufferPointer.init(bufferClass:minimumCapacity:makingHeaderWith:)(a1, *(void *)(v1 + 16), *(void *)(v1 + 24));
}

Class *type metadata accessor for ManagedBuffer(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for ManagedBuffer.Flags);
}

Class *type metadata accessor for LazyMapSequence.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for LazyMapSequence.Iterator.Flags);
}

void sub_1814F12E8()
{
  uint64_t v1 = v0[2];
  uint64_t v2 = (int *)(type metadata accessor for LazyMapSequence(0, v1, v0[3], v0[5]) - 1);
  unint64_t v3 = (*(unsigned __int8 *)(*(void *)v2 + 80) + 64) & ~(unint64_t)*(unsigned __int8 *)(*(void *)v2 + 80);
  swift_release(v0[7]);
  char v4 = (char *)v0 + v3;
  (*(void (**)(char *, uint64_t))(*(void *)(v1 - 8) + 8))(v4, v1);
  swift_release(*(void *)&v4[v2[13] + 8]);

  swift_deallocObject((uint64_t)v0);
}

uint64_t partial apply for closure #1 in LazyMapSequence.map<A>(_:)(uint64_t a1)
{
  uint64_t v3 = v1[2];
  uint64_t v4 = v1[3];
  uint64_t v5 = (uint64_t)*(type metadata accessor for LazyMapSequence(0, v3, v4, v1[5]) - 1);
  uint64_t v6 = (void (*)(char *))v1[6];
  uint64_t v7 = v1[7];
  uint64_t v8 = (uint64_t)v1 + ((*(unsigned __int8 *)(v5 + 80) + 64) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80));

  return closure #1 in LazyMapSequence.map<A>(_:)(a1, v6, v7, v8, v3, v4);
}

void sub_1814F14A0()
{
  uint64_t v1 = v0[2];
  uint64_t v2 = (int *)(type metadata accessor for LazyMapSequence(0, v1, v0[3], *(void *)(v0[5] + 8)) - 1);
  unint64_t v3 = (*(unsigned __int8 *)(*(void *)v2 + 80) + 64) & ~(unint64_t)*(unsigned __int8 *)(*(void *)v2 + 80);
  swift_release(v0[7]);
  uint64_t v4 = (char *)v0 + v3;
  (*(void (**)(char *, uint64_t))(*(void *)(v1 - 8) + 8))(v4, v1);
  swift_release(*(void *)&v4[v2[13] + 8]);

  swift_deallocObject((uint64_t)v0);
}

uint64_t partial apply for closure #1 in LazyMapSequence<>.map<A>(_:)(uint64_t a1)
{
  uint64_t v3 = v1[2];
  uint64_t v4 = v1[3];
  uint64_t v5 = (uint64_t)*(type metadata accessor for LazyMapSequence(0, v3, v4, *(void *)(v1[5] + 8)) - 1);
  uint64_t v6 = (void (*)(char *))v1[6];
  uint64_t v7 = v1[7];
  uint64_t v8 = (uint64_t)v1 + ((*(unsigned __int8 *)(v5 + 80) + 64) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80));

  return closure #1 in LazyMapSequence<>.map<A>(_:)(a1, v6, v7, v8, v3, v4);
}

uint64_t specialized RawKeyPathComponent.Header.init(computedWithIDKind:mutating:settable:hasArguments:instantiatedFromExternalWithArguments:)(char a1, char a2, char a3, char a4, char a5)
{
  if ((a2 & 1) == 0)
  {
    if ((a3 & 1) == 0)
    {
      int v7 = 0;
      if (a4) {
        int v5 = 0x80000;
      }
      else {
        int v5 = 0;
      }
      if ((a5 & 1) == 0) {
        goto LABEL_24;
      }
      goto LABEL_22;
    }
    if ((a4 & 1) == 0)
    {
      int v5 = 0x400000;
      if (a5) {
        goto LABEL_22;
      }
LABEL_23:
      int v7 = 0;
      goto LABEL_24;
    }
    int v5 = 4718592;
LABEL_14:
    if (a5) {
      goto LABEL_22;
    }
    goto LABEL_23;
  }
  if (a3) {
    int v5 = 13107200;
  }
  else {
    int v5 = 8912896;
  }
  if (a3) {
    int v6 = 12582912;
  }
  else {
    int v6 = 0x800000;
  }
  if (a4) {
    goto LABEL_14;
  }
  int v5 = v6;
  if ((a5 & 1) == 0) {
    goto LABEL_23;
  }
LABEL_22:
  int v7 = 16;
LABEL_24:
  int v8 = v5 | v7;
  if (a1)
  {
    int v9 = v8 | 0x200000;
    v8 |= 0x100000u;
    if (a1 == 1) {
      int v8 = v9;
    }
  }
  return v8 | 0x2000000u;
}

uint64_t specialized KeyPathBuffer.Header.init(size:trivial:hasReferencePrefix:)(unint64_t a1, char a2, char a3)
{
  if ((a1 & 0x8000000000000000) != 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  }
  if (HIDWORD(a1)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
  }
  if ((a2 & 1) == 0)
  {
    if (a3) {
      goto LABEL_5;
    }
LABEL_7:
    int v3 = 0;
    return a1 | v3;
  }
  LODWORD(a1) = a1 | 0x80000000;
  if ((a3 & 1) == 0) {
    goto LABEL_7;
  }
LABEL_5:
  int v3 = 0x40000000;
  return a1 | v3;
}

uint64_t specialized GetKeyPathClassAndInstanceSizeFromPattern.visitComputedComponent(mutating:idKind:idResolution:idValueBase:idValue:getter:setter:arguments:externalArgs:)(uint64_t result, uint64_t a2, uint64_t (*a3)(void), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8)
{
  if (a2)
  {
    if (result) {
      goto LABEL_6;
    }
    char v11 = 2;
  }
  else
  {
    char v11 = 0;
  }
  *(unsigned char *)(v8 + 8) = v11;
LABEL_6:
  uint64_t v12 = *(void *)v8 + 4;
  if (__OFADD__(*(void *)v8, 4))
  {
    __break(1u);
    goto LABEL_36;
  }
  *(void *)uint64_t v8 = v12;
  BOOL v13 = __OFADD__(v12, 7);
  uint64_t v14 = v12 + 7;
  if (v13)
  {
LABEL_36:
    __break(1u);
    goto LABEL_37;
  }
  unint64_t v15 = v14 & 0xFFFFFFFFFFFFFFF8;
  BOOL v13 = __OFADD__(v15, 16);
  unint64_t v16 = v15 + 16;
  if (v13)
  {
LABEL_37:
    __break(1u);
    goto LABEL_38;
  }
  *(void *)uint64_t v8 = v16;
  if (!a2) {
    goto LABEL_12;
  }
  BOOL v13 = __OFADD__(v16, 8);
  v16 += 8;
  if (v13)
  {
LABEL_38:
    __break(1u);
    goto LABEL_39;
  }
  *(void *)uint64_t v8 = v16;
LABEL_12:
  if (a3)
  {
    unint64_t v9 = v16 + 16;
    LOBYTE(v16) = __OFADD__(v16, 16);
    if (a8) {
      goto LABEL_31;
    }
    if ((v16 & 1) == 0)
    {
      unint64_t result = a3(*(void *)(v8 + 40));
      unint64_t v17 = v9 + result;
      if (!__OFADD__(v9, result))
      {
        *(void *)uint64_t v8 = v17;
        BOOL v13 = __OFADD__(v17, 7);
        unint64_t v18 = v17 + 7;
        if (!v13)
        {
          unint64_t v19 = v18 & 0xFFFFFFFFFFFFFFF8;
          BOOL v13 = __OFADD__(v19, 8);
          unint64_t v20 = v19 + 8;
          if (!v13)
          {
            if ((unint64_t)(a7 - 0x1000000000000000) >> 61 == 7)
            {
              BOOL v13 = __OFADD__(v20, 8 * a7);
              unint64_t v16 = v20 + 8 * a7;
              if (!v13) {
                goto LABEL_33;
              }
              __break(1u);
              goto LABEL_25;
            }
LABEL_43:
            __break(1u);
            goto LABEL_44;
          }
LABEL_42:
          __break(1u);
          goto LABEL_43;
        }
LABEL_41:
        __break(1u);
        goto LABEL_42;
      }
LABEL_40:
      __break(1u);
      goto LABEL_41;
    }
LABEL_39:
    __break(1u);
    goto LABEL_40;
  }
LABEL_25:
  if (a8) {
    return result;
  }
  BOOL v13 = __OFADD__(v16, 16);
  unint64_t v21 = v16 + 16;
  if (v13) {
    goto LABEL_46;
  }
  if ((unint64_t)(a7 - 0x1000000000000000) >> 61 != 7)
  {
LABEL_47:
    __break(1u);
    return result;
  }
  BOOL v13 = __OFADD__(v21, 8 * a7);
  unint64_t v16 = v21 + 8 * a7;
  if (!v13) {
    goto LABEL_33;
  }
  __break(1u);
LABEL_31:
  if (v16)
  {
LABEL_44:
    __break(1u);
    goto LABEL_45;
  }
  unint64_t result = a3(*(void *)(v8 + 40));
  unint64_t v16 = v9 + result;
  if (__OFADD__(v9, result))
  {
LABEL_45:
    __break(1u);
LABEL_46:
    __break(1u);
    goto LABEL_47;
  }
LABEL_33:
  *(void *)uint64_t v8 = v16;
  return result;
}

uint64_t specialized MutableCollection<>.subscript.setter(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v9 = (unint64_t *)type metadata accessor for Slice(0, a3, *(void *)(a4 + 8), a4);
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for Slice<A>, v9, v10);

  return _writeBackMutableSlice<A, B>(_:bounds:slice:)(v4, a2, a1, a3, (uint64_t)v9, a4, WitnessTable);
}

uint64_t partial apply for closure #1 in MutableCollection.moveSubranges(_:to:)(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(int ***)(*(void *)(v1 + 24) + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v8 = type metadata accessor for RangeSet.Ranges(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v7);
  return RangeSet.Ranges._contains(_:)(a1, (uint64_t)v8) & 1;
}

BOOL partial apply for closure #2 in MutableCollection.moveSubranges(_:to:)(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(int ***)(*(void *)(v1 + 24) + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v4, v3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v4, v3, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v8 = type metadata accessor for RangeSet.Ranges(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v7);
  return (RangeSet.Ranges._contains(_:)(a1, (uint64_t)v8) & 1) == 0;
}

Class *type metadata accessor for _SetStorage(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _SetStorage.Flags, &flag for loading of canonical specialized generic type metadata for _SetStorage);
}

Class *type metadata accessor for _NativeSet(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _NativeSet.Flags);
}

uint64_t type metadata accessor for __CocoaSet.Index.Storage()
{
  return self;
}

Class *type metadata accessor for _NewtypeWrapperAnyHashableBox(__int16 a1, uint64_t a2)
{
  return swift_getGenericMetadata(a1, a2, &nominal type descriptor for _NewtypeWrapperAnyHashableBox.Flags);
}

atomic_ullong *outlined copy of (@escaping @callee_guaranteed (@guaranteed String) -> ())?(atomic_ullong *result, atomic_ullong *a2)
{
  if (result) {
    return swift_retain(a2);
  }
  return result;
}

uint64_t outlined consume of (@escaping @callee_guaranteed (@guaranteed String) -> ())?(uint64_t result, uint64_t a2)
{
  if (result) {
    return swift_release(a2);
  }
  return result;
}

Class *type metadata accessor for LazyPrefixWhileSequence(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for LazyPrefixWhileSequence.Flags);
}

Class *type metadata accessor for LazyPrefixWhileSequence.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for LazyPrefixWhileSequence.Iterator.Flags);
}

Class *type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for LazyPrefixWhileSequence<>._IndexRepresentation.Flags);
}

Class *type metadata accessor for LazyPrefixWhileSequence<>.Index(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for LazyPrefixWhileSequence<>.Index.Flags);
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<AnyHashable>()
{
  return self;
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int64>()
{
  return self;
}

void specialized MutableCollection.subscript.setter()
{
}

Swift::UInt64 specialized Collection.subscript.getter(unint64_t a1, unint64_t a2)
{
  uint64_t v4 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0) {
    uint64_t v4 = a1;
  }
  uint64_t v5 = 7;
  if (((a2 >> 60) & ((a1 & 0x800000000000000) == 0)) != 0) {
    uint64_t v5 = 11;
  }
  v6._Swift::UInt64 rawBits = v5 | (v4 << 16);
  v7._Swift::UInt64 rawBits = 15;
  Swift::UInt64 result = _StringGuts.validateScalarRange(_:)(v7, v6, a1, a2);
  if (result < 0x10000) {
    result |= 3uLL;
  }
  return result;
}

void specialized _SliceBuffer.subscript.setter()
{
}

uint64_t specialized Slice<>.subscript.setter(uint64_t a1, char *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v12 = a4;
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a3, (uint64_t)&v12);
  uint64_t v10 = swift_getWitnessTable(protocol conformance descriptor for Slice<A>, a3, v9);
  return _writeBackMutableSlice<A, B>(_:bounds:slice:)(v4, a2, a1, (uint64_t)a3, (uint64_t)a3, WitnessTable, v10);
}

uint64_t specialized MutableCollection.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = *(int ***)(a5 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v12, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(a6, a4, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for RangeExpression, associated conformance descriptor for RangeExpression.RangeExpression.Bound: Comparable);
  unint64_t v16 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v15);
  MEMORY[0x1F4188790](v16 - 1);
  unint64_t v18 = (char *)&v20 - v17;
  (*(void (**)(uint64_t, uint64_t, int **, uint64_t, uint64_t))(a6 + 24))(v6, a3, v12, a4, a6);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t))(a5 + 40))(a1, v18, a3, a5);
}

uint64_t specialized MutableCollection.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v68 = a1;
  uint64_t v69 = a3;
  uint64_t v5 = *(void *)(a3 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, (int **)v5, a2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  TupleTypeMetadata2 = swift_getTupleTypeMetadata2(0, (uint64_t)AssociatedTypeWitness, (uint64_t)AssociatedTypeWitness, "lower upper ", 0);
  uint64_t v7 = MEMORY[0x1F4188790](TupleTypeMetadata2);
  uint64_t v67 = (char *)v59 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v7);
  uint64_t v61 = (char *)v59 - v9;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(v5, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
  uint64_t v12 = type metadata accessor for Range(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v11);
  uint64_t v64 = (uint64_t)*(v12 - 1);
  unint64_t v65 = v12;
  uint64_t v13 = MEMORY[0x1F4188790](v12);
  unint64_t v62 = (char *)v59 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = MEMORY[0x1F4188790](v13);
  uint64_t v63 = (char *)v59 - v16;
  uint64_t v17 = (void *)*((void *)AssociatedTypeWitness - 1);
  uint64_t v18 = MEMORY[0x1F4188790](v15);
  uint64_t v71 = (char *)v59 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v20 = MEMORY[0x1F4188790](v18);
  unint64_t v75 = (char *)v59 - v21;
  uint64_t v22 = MEMORY[0x1F4188790](v20);
  BOOL v72 = (char *)v59 - v23;
  uint64_t v24 = MEMORY[0x1F4188790](v22);
  unint64_t v76 = (char *)v59 - v25;
  uint64_t v26 = MEMORY[0x1F4188790](v24);
  Swift::UnsafeMutableRawBufferPointer v28 = (char *)v59 - v27;
  MEMORY[0x1F4188790](v26);
  BOOL v30 = (char *)v59 - v29;
  uint64_t v32 = type metadata accessor for PartialRangeFrom(0, (uint64_t)AssociatedTypeWitness, AssociatedConformanceWitness, v31);
  uint64_t v60 = (uint64_t)*(v32 - 1);
  MEMORY[0x1F4188790](v32);
  uint64_t v34 = (char *)v59 - v33;
  uint64_t v35 = *(void (**)(uint64_t, uint64_t))(v5 + 64);
  uint64_t v77 = a2;
  uint64_t v78 = v3;
  uint64_t v70 = v5;
  uint64_t v36 = v5;
  uint64_t v37 = AssociatedConformanceWitness;
  v35(a2, v36);
  uint64_t v74 = (void (*)(char *, char *, const char *))v17[2];
  v74(v28, v30, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, const char *))(*(void *)(AssociatedConformanceWitness + 8) + 8))(v28, v28, AssociatedTypeWitness) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range cannot have an unordered lower bound.", 43, 2, "Swift/Range.swift", 17, 2, 0x34FuLL, 0); {
  v59[0] = v32;
  }
  uint64_t v38 = (char *)(v17 + 1);
  uint64_t v73 = (void (*)(char *, const char *))v17[1];
  v73(v28, AssociatedTypeWitness);
  uint64_t v39 = (void (*)(char *, char *, const char *))v17[4];
  v59[1] = v17 + 4;
  v39(v34, v30, AssociatedTypeWitness);
  uint64_t v40 = v76;
  uint64_t v41 = v74;
  v74(v76, v34, AssociatedTypeWitness);
  Swift::Int v42 = v72;
  (*(void (**)(uint64_t))(v70 + 72))(v77);
  uint64_t v43 = v75;
  v41(v75, v40, AssociatedTypeWitness);
  BOOL v44 = v71;
  v41(v71, v42, AssociatedTypeWitness);
  if (((*(uint64_t (**)(char *, char *, const char *, uint64_t))(v37 + 24))(v43, v44, AssociatedTypeWitness, v37) & 1) == 0)_assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0); {
  uint64_t v45 = v73;
  }
  v73(v44, AssociatedTypeWitness);
  v45(v75, AssociatedTypeWitness);
  (*(void (**)(char *, void))(v60 + 8))(v34, v59[0]);
  uint64_t v46 = TupleTypeMetadata2;
  uint64_t v47 = v61;
  uint64_t v48 = &v61[*((int *)TupleTypeMetadata2 + 12)];
  uint64_t v49 = v76;
  unint64_t v76 = v38;
  v39(v61, v49, AssociatedTypeWitness);
  v39(v48, v42, AssociatedTypeWitness);
  uint64_t v50 = v67;
  uint64_t v51 = &v67[*((int *)v46 + 12)];
  uint64_t v52 = v74;
  v74(v67, v47, AssociatedTypeWitness);
  v52(v51, v48, AssociatedTypeWitness);
  uint64_t v53 = v62;
  v39(v62, v50, AssociatedTypeWitness);
  uint64_t v54 = v73;
  v73(v51, AssociatedTypeWitness);
  uint64_t v55 = &v50[*((int *)v46 + 12)];
  v39(v50, v47, AssociatedTypeWitness);
  v39(v55, v48, AssociatedTypeWitness);
  uint64_t v56 = v65;
  v39(&v53[*((int *)v65 + 9)], v55, AssociatedTypeWitness);
  v54(v50, AssociatedTypeWitness);
  uint64_t v57 = v63;
  (*(void (**)(char *, char *, Class *))(v64 + 32))(v63, v53, v56);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v69 + 40))(v68, v57, v77);
}

Class *type metadata accessor for Repeated(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Repeated.Flags, flag for loading of canonical specialized generic type metadata for Repeated);
}

uint64_t partial apply for closure #1 in RangeSet.Ranges.init(_unorderedRanges:)()
{
  return (*(uint64_t (**)(void))(*(void *)(v0 + 24) + 16))() & 1;
}

uint64_t partial apply for closure #1 in RangeSet.Ranges._contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = v4[2];
  uint64_t v7 = v4[3];
  uint64_t v8 = v4[4];
  uint64_t v9 = type metadata accessor for Range(0, v6, v7, a4);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v7 + 40))(a1 + *((int *)v9 + 9), v8, v6, v7) & 1;
}

Class *type metadata accessor for _Pair(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _Pair.Flags);
}

uint64_t partial apply for closure #1 in RangeSet.isSubset(of:)(uint64_t a1)
{
  return closure #1 in RangeSet.isSubset(of:)(a1, v1[4], v1[2], v1[3]) & 1;
}

Class *type metadata accessor for Zip2Sequence(__int16 a1, uint64_t a2)
{
  return swift_getGenericMetadata(a1, a2, &nominal type descriptor for Zip2Sequence.Flags);
}

Class *type metadata accessor for Zip2Sequence.Iterator(__int16 a1, uint64_t a2)
{
  return swift_getGenericMetadata(a1, a2, &nominal type descriptor for Zip2Sequence.Iterator.Flags);
}

void partial apply for closure #1 in MutableCollection<>.sort(by:)(uint64_t a1)
{
  closure #1 in MutableCollection<>.sort(by:)(a1, *(uint64_t (**)(char *, char *))(v1 + 40), *(void *)(v1 + 48), *(void *)(v1 + 16), *(void *)(v1 + 24));
}

void partial apply for closure #1 in _forEachFieldWithKeyPath<A>(of:options:body:)(void *a1, void *a2)
{
  uint64_t v3 = *(void *)(v2 + 16);
  unint64_t v4 = *(void *)(v2 + 32);
  into._position.value._rawValue = a1;
  into._end.value._rawValue = a2;
  BOOL v5 = __OFSUB__(v3, 8);
  unint64_t v6 = v3 - 8;
  if (!v5)
  {
    if ((v6 & 0x8000000000000000) == 0)
    {
      if (HIDWORD(v6)) {
        goto LABEL_8;
      }
      uint64_t v7 = v6 | 0x80000000;
      Swift::UnsafeMutableRawBufferPointer v8 = KeyPathBuffer.Builder.pushRaw(size:alignment:)(4, 4);
      specialized _swift_se0349_UnsafeMutableRawBufferPointer_storeBytes(v7, 0, (uint64_t)v8._position.value._rawValue, (uint64_t)v8._end.value._rawValue);
      KeyPathBuffer.Builder.pushRaw(size:alignment:)(4, 4);
      if ((v4 & 0x8000000000000000) == 0)
      {
        if (!HIDWORD(v4))
        {
          RawKeyPathComponent.clone(into:endOfReferencePrefix:)(&into, 0);
          return;
        }
LABEL_8:
        _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Not enough bits to represent the passed value", 45, 2, "Swift/Integers.swift", 20, 2, 0xD7FuLL, 0);
      }
    }
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Negative value is not representable", 35, 2, "Swift/Integers.swift", 20, 2, 0xD7BuLL, 0);
  }
  __break(1u);
}

Class *type metadata accessor for Result(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Result.Flags);
}

Class *type metadata accessor for ReversedCollection.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for ReversedCollection.Iterator.Flags);
}

Class *type metadata accessor for ReversedCollection.Index(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for ReversedCollection.Index.Flags);
}

Class *type metadata accessor for PrefixSequence.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for PrefixSequence.Iterator.Flags);
}

Class *type metadata accessor for DropWhileSequence.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for DropWhileSequence.Iterator.Flags);
}

unint64_t specialized RangeReplaceableCollection.init(repeating:count:)(int a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Repetition count should be non-negative", 39, 2, "Swift/Repeat.swift", 18, 2, 0x28uLL, 0);
  }
  uint64_t v2 = _sSTsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lFxq0_q_Ri_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lyADs5NeverOs6UInt32VIsgnrzr_xSayAIGAGSTRzAIRsd__AGRsd_0_r_0_lIetMgnozo_Tp5s8RepeatedVys7UnicodeO6ScalarVG_Tg506_sSS17gh42ViewV6append10contentsOfyx_tSTRzs0A0O0B0V7b7RtzlFs6E8VAHXEfU_Tf1cn_n(a2, a1);
  unint64_t v3 = specialized static String._fromCodeUnits<A, B>(_:encoding:repair:)(v2, 1);
  unint64_t v5 = v4;
  swift_bridgeObjectRelease((uint64_t)v2);
  if (!v5) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/String.swift", 18, 2, 0x1C9uLL, 0);
  }
  unint64_t v6 = specialized static String.+ infix(_:_:)(0, 0xE000000000000000, v3, v5);
  swift_bridgeObjectRelease(v5);
  return v6;
}

uint64_t specialized RangeReplaceableCollection.init(repeating:count:)(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 15;
  }
  uint64_t v2 = a2;
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Repetition count should be non-negative", 39, 2, "Swift/Repeat.swift", 18, 2, 0x28uLL, 0);
  }
  do
  {
    v3._Swift::UInt64 rawBits = 7;
    v4._Swift::UInt64 rawBits = 7;
    specialized Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)(v3, v4);
    --v2;
  }
  while (v2);
  return 15;
}

uint64_t specialized RangeReplaceableCollection.init(repeating:count:)(unint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a3)
  {
    if (a3 < 0) {
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Repetition count should be non-negative", 39, 2, "Swift/Repeat.swift", 18, 2, 0x28uLL, 0);
    }
    specialized String.append<A>(contentsOf:)(a3, a1, a2);
    swift_bridgeObjectRelease(a2);
  }
  else
  {
    swift_bridgeObjectRelease(a2);
  }
  return 15;
}

uint64_t specialized RangeReplaceableCollection.init(repeating:count:)(char a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Repetition count should be non-negative", 39, 2, "Swift/Repeat.swift", 18, 2, 0x28uLL, 0);
  }
  LODWORD(result) = 0;
  int v4 = (a1 + 1);
  do
  {
    if (BYTE3(result)) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/ValidUTF8Buffer.swift", 27, 2, 0xA7uLL, 0);
    }
    uint64_t result = (v4 << (-(__clz(result) & 0x18) & 0x18)) | result;
    --a2;
  }
  while (a2);
  return result;
}

__objc2_class **specialized Set.init(_nonEmptyArrayLiteral:)(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = a1;
  uint64_t v62 = *(a2 - 1);
  uint64_t v7 = MEMORY[0x1F4188790](a1);
  uint64_t v64 = (char *)&v50 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  uint64_t v69 = (char *)&v50 - v10;
  uint64_t v11 = MEMORY[0x1F4188790](v9);
  uint64_t v13 = (char *)&v50 - v12;
  uint64_t v51 = v14;
  MEMORY[0x1F4188790](v11);
  uint64_t v16 = (char *)&v50 - v15;
  Swift::Int v17 = Array._getCount()();
  if (v17)
  {
    Swift::Int v19 = v17;
    uint64_t v20 = type metadata accessor for _SetStorage(0, (uint64_t)a2, a3, v18);
    uint64_t v21 = v19;
    uint64_t v3 = (uint64_t)v20;
    uint64_t v22 = (__objc2_class **)static _SetStorage.allocate(capacity:)(v21);
  }
  else
  {
    uint64_t v22 = &_swiftEmptySetSingleton;
  }
  Swift::Int v59 = Array._getCount()();
  if (v59)
  {
    unint64_t v23 = 0;
    uint64_t v24 = (void (**)(char *, char *, uint64_t *))(v62 + 32);
    uint64_t v55 = a3;
    uint64_t v56 = a3 + 32;
    uint64_t v67 = (void (**)(char *, unint64_t, uint64_t *))(v62 + 16);
    uint64_t v68 = v22 + 7;
    uint64_t v63 = (void (**)(char *, uint64_t *))(v62 + 8);
    uint64_t v52 = v13;
    uint64_t v53 = v6;
    uint64_t v54 = v16;
    uint64_t v66 = v22;
    uint64_t v57 = (void (**)(char *, char *, uint64_t *))(v62 + 32);
    unint64_t v58 = v6 & 0xC000000000000001;
    while (1)
    {
      BOOL v25 = v58 == 0;
      char v26 = v25 | ~_swift_isClassOrObjCExistentialType((uint64_t)a2, a2);
      Array._checkSubscript(_:wasNativeTypeChecked:)(v23, v26 & 1);
      if (v26)
      {
        unint64_t v27 = v6
            + ((*(unsigned __int8 *)(v62 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v62 + 80))
            + *(void *)(v62 + 72) * v23;
        unint64_t v65 = *(void (**)(char *, unint64_t, uint64_t *))(v62 + 16);
        v65(v13, v27, a2);
      }
      else
      {
        id v48 = _ArrayBuffer._getElementSlowPath(_:)(v23, v6, a2);
        uint64_t v3 = (uint64_t)v48;
        if (v51 != 8) {
          goto LABEL_24;
        }
        v70[0] = v48;
        unint64_t v65 = *v67;
        v65(v13, (unint64_t)v70, a2);
        swift_unknownObjectRelease((id)v3);
      }
      Swift::UnsafeMutableRawBufferPointer v28 = *v24;
      (*v24)(v16, v13, a2);
      BOOL v29 = __OFADD__(v23++, 1);
      if (v29) {
        break;
      }
      uint64_t v61 = v28;
      v28(v69, v16, a2);
      uint64_t v30 = (*(uint64_t (**)(__objc2_class *, uint64_t *, uint64_t))(a3 + 32))(v22[5], a2, a3);
      uint64_t v31 = -1 << *((unsigned char *)v22 + 32);
      unint64_t v32 = v30 & ~v31;
      uint64_t v3 = v32 >> 6;
      uint64_t v33 = 1 << v32;
      if (((1 << v32) & (unint64_t)v68[v32 >> 6]) != 0)
      {
        unint64_t v60 = v23;
        uint64_t v34 = ~v31;
        uint64_t v35 = *(void *)(a3 + 8);
        uint64_t v36 = *(uint64_t (**)(char *, char *, uint64_t *, uint64_t))(v35 + 8);
        uint64_t v37 = *(void *)(v62 + 72);
        while (1)
        {
          uint64_t v38 = v64;
          v65(v64, (unint64_t)v66[6] + v37 * v32, a2);
          uint64_t v3 = v36(v38, v69, a2, v35);
          uint64_t v39 = *v63;
          (*v63)(v38, a2);
          if (v3) {
            break;
          }
          unint64_t v32 = (v32 + 1) & v34;
          uint64_t v3 = v32 >> 6;
          uint64_t v33 = 1 << v32;
          if (((unint64_t)v68[v32 >> 6] & (1 << v32)) == 0)
          {
            uint64_t v41 = v52;
            uint64_t v40 = v53;
            unint64_t v23 = v60;
            goto LABEL_17;
          }
        }
        v39(v69, a2);
        uint64_t v16 = v54;
        a3 = v55;
        uint64_t v13 = v52;
        uint64_t v6 = v53;
        uint64_t v22 = v66;
        unint64_t v23 = v60;
        uint64_t v24 = v57;
      }
      else
      {
        uint64_t v41 = v13;
        uint64_t v40 = v6;
LABEL_17:
        Swift::Int v42 = v64;
        uint64_t v43 = v57;
        BOOL v44 = v61;
        v61(v64, v69, a2);
        v68[v3] = (__objc2_class *)((unint64_t)v68[v3] | v33);
        uint64_t v22 = v66;
        unint64_t v45 = (unint64_t)v66[6] + *(void *)(v62 + 72) * v32;
        uint64_t v24 = v43;
        v44((char *)v45, v42, a2);
        uint64_t v46 = v22[2];
        BOOL v29 = __OFADD__(v46, 1);
        uint64_t v47 = (__objc2_class *)((char *)&v46->isa + 1);
        if (v29) {
          goto LABEL_23;
        }
        v22[2] = v47;
        uint64_t v6 = v40;
        uint64_t v13 = v41;
        uint64_t v16 = v54;
        a3 = v55;
      }
      if (v23 == v59) {
        return v22;
      }
    }
    __break(1u);
LABEL_23:
    __break(1u);
LABEL_24:
    swift_unknownObjectRelease((id)v3);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Can't unsafeBitCast between types of different sizes", 52, 2, "Swift/Builtin.swift", 19, 2, 0x5FuLL, 0);
  }
  return v22;
}

Class *type metadata accessor for _SetAnyHashableBox(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _SetAnyHashableBox.Flags, &flag for loading of canonical specialized generic type metadata for _SetAnyHashableBox);
}

Class *type metadata accessor for Set(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Set.Flags, &flag for loading of canonical specialized generic type metadata for Set);
}

Class *type metadata accessor for Set.Iterator._Variant(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Set.Iterator._Variant.Flags);
}

void sub_1814F33B0()
{
  swift_deallocObject(v0);
}

Class *type metadata accessor for Set.Index(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Set.Index.Flags);
}

uint64_t outlined init with take of AnyHashable?(uint64_t a1, uint64_t a2)
{
  return initializeWithTake for ClosedRange<>.Index(a2, a1, &unk_1ECA01BC0);
}

Class *type metadata accessor for _SwiftDeferredNSSet(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _SwiftDeferredNSSet.Flags);
}

uint64_t partial apply for implicit closure #1 in Sequence<>.sorted()(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(v2 + 32);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(v5 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(v2 + 24), *(void *)(v2 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  return v6(a1, a2, AssociatedTypeWitness, v5) & 1;
}

uint64_t partial apply for implicit closure #1 in MutableCollection<>.sort()(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = v2[5];
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(v5 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(v2[3] + 8) + 8), v2[2], (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  return v6(a1, a2, AssociatedTypeWitness, v5) & 1;
}

Class *type metadata accessor for StrideTo(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for StrideTo.Flags);
}

Class *type metadata accessor for StrideThroughIterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for StrideThroughIterator.Flags);
}

Class *type metadata accessor for StrideThrough(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for StrideThrough.Flags);
}

uint64_t partial apply for closure #1 in String.init<A, B>(decoding:as:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return closure #1 in String.init<A, B>(decoding:as:)(a1, a2, *(void *)(v3 + 16), *(void *)(v3 + 32), a3);
}

Class *type metadata accessor for Unicode.ParseResult(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Unicode.ParseResult.Flags);
}

unint64_t partial apply for closure #1 in String.init<A, B>(validating:as:)@<X0>(uint8x16_t *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t result = static String._validate<A>(_:as:)(a1, a2, *(ValueMetadata **)(v3 + 16), *(void *)(v3 + 16), *(void *)(v3 + 32));
  *a3 = result;
  a3[1] = v6;
  return result;
}

{
  uint64_t v3;

  return closure #1 in String.init<A, B>(validating:as:)(a1, a2, *(ValueMetadata **)(v3 + 16), *(void *)(v3 + 32), a3);
}

Class *type metadata accessor for UnsafeBufferPointer.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for UnsafeBufferPointer.Iterator.Flags);
}

void partial apply for closure #1 in String._slowWithCString<A, B>(encodedAs:_:)(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  closure #1 in String._slowWithCString<A, B>(encodedAs:_:)(a1, a2, *(void *)(v3 + 40), *(void *)(v3 + 48), *(void (**)(unint64_t))(v3 + 64), *(void *)(v3 + 72), *(uint64_t (***)(char *, const char *))(v3 + 16), *(void *)(v3 + 24), a3, *(void *)(v3 + 32));
}

uint64_t specialized _SwiftSetNSEnumerator.countByEnumerating(with:objects:count:)(uint64_t a1, atomic_ullong **a2)
{
  unint64_t v5 = *(void *)a1;
  unint64_t v6 = *(atomic_ullong ***)(a1 + 8);
  uint64_t v7 = *(Swift::UInt **)(a1 + 16);
  long long v8 = *(_OWORD *)(a1 + 24);
  long long v9 = *(_OWORD *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t offset = v2[4].offset;
  if (offset == v2[5].offset)
  {
    uint64_t result = 0;
  }
  else
  {
    long long v18 = v9;
    long long v19 = v8;
    uint64_t v13 = _SwiftDictionaryNSEnumerator.bridgedKey(at:)(offset);
    *a2 = v13;
    swift_unknownObjectRelease(v13);
    v14.uint64_t offset = _HashTable.occupiedBucket(after:)(v2[4]).offset;
    long long v9 = v18;
    long long v8 = v19;
    v2[4].uint64_t offset = v14.offset;
    uint64_t result = 1;
  }
  if (v5 <= 1) {
    uint64_t v15 = 1;
  }
  else {
    uint64_t v15 = v5;
  }
  if (v5) {
    uint64_t v16 = v6;
  }
  else {
    uint64_t v16 = a2;
  }
  *(void *)a1 = v15;
  *(void *)(a1 + 8) = v16;
  Swift::Int v17 = &_fastEnumerationStorageMutationsTarget;
  if (v5) {
    Swift::Int v17 = v7;
  }
  *(void *)(a1 + 16) = v17;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 4_assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0x6C706D6920746F6ELL, 0xEF6465746E656D65, "Swift/SliceBuffer.swift", 23, 2, 0x198uLL, 0) = v9;
  *(void *)(a1 + 56) = v10;
  return result;
}

void specialized _SwiftSetNSEnumerator.init(coder:)()
{
}

void specialized _SwiftDeferredNSSet.init(objects:count:)()
{
  *(void *)(v0 + 16) = 0;
  swift_release(v0);
  __break(1u);
}

void specialized _SetStorage.init(objects:count:)()
{
  swift_release(v0);
  __break(1u);
}

uint64_t specialized _SetStorage.copy(with:)()
{
  return v0;
}

uint64_t specialized Substring.init<A>(_:)(uint64_t result)
{
  if (&full type metadata for [Character] == &full type metadata for String)
  {
    __break(1u);
  }
  else if (&full type metadata for [Character] != &full type metadata for Substring)
  {
    uint64_t v1 = result;
    specialized String.append<A>(contentsOf:)(result);
    swift_bridgeObjectRelease(v1);
    return 15;
  }
  __break(1u);
  return result;
}

unint64_t specialized _SmallString.init(taggedCocoa:)(void *a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  long long v8 = xmmword_18162AE10;
  uint64_t v3 = _NSStringCopyBytes(_:encoding:into:)(a1, a2, (uint64_t)&v8, (unint64_t)&v8 | 0xF);
  char v5 = v4;
  swift_unknownObjectRelease(a1);
  if (v5) {
    return 0;
  }
  if (v3 < 1)
  {
    if (v3) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/SmallString.swift", 23, 2, 0x109uLL, 0);
    }
    return 0;
  }
  else
  {
    char v6 = 8;
    if (v3 < 8) {
      char v6 = v3;
    }
    return v8 & (0xFFFFFFFFFFFFFFFFLL >> ((56 * v6) & 0x38));
  }
}

int64_t specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(int64_t a1, uint64_t (*a2)(int64_t, int64_t))
{
  int64_t v5 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(void *)(v5 + 16) = v6;
  *(void *)(v5 + 24) = 0x3000000000000000;
  if (v6 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
    uint64_t v7 = *(void *)(v5 + 24) & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v7 = 0;
  }
  *(unsigned char *)(v5 + 32 + v7) = 0;
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  }
  uint64_t v8 = a2(v5 + 32, a1);
  if (v2)
  {
    swift_release(v5);
  }
  else
  {
    *(void *)(v5 + 24) = v8 | 0x3000000000000000;
    *(unsigned char *)(v5 + 32 + (v8 & 0xFFFFFFFFFFFFLL)) = 0;
  }
  return v5;
}

uint64_t specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(int64_t a1, uint64_t (*a2)(int64_t, int64_t))
{
  char v4 = (void *)specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(a1, a2);
  if (v3) {
    return v2;
  }
  int64_t v5 = v4;
  uint64_t v6 = v4[3];
  Swift::Int v7 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0xFFFFFFFFFFFFLL) == 0) {
    goto LABEL_20;
  }
  uint64_t v8 = (char *)(v4 + 4);
  uint64_t v9 = (char *)(v4 + 4);
  if ((v6 & 0xFFFFFFFFFFF0) != 0)
  {
    if (((v4[5] | v4[4]) & 0x8080808080808080) != 0) {
      goto LABEL_22;
    }
    uint64_t v9 = (char *)(v4 + 6);
    while (v9 < (char *)v4 + (v6 & 0xFFFFFFFFFFF0) + 32)
    {
      uint64_t v10 = *(void *)v9;
      uint64_t v11 = *((void *)v9 + 1);
      v9 += 16;
      if (((v11 | v10) & 0x8080808080808080) != 0) {
        goto LABEL_22;
      }
    }
  }
  if (v9 < &v8[v6 & 0xFFFFFFFFFFF8])
  {
    if ((*(void *)v9 & 0x8080808080808080) != 0) {
      goto LABEL_22;
    }
    v9 += 8;
  }
  if (v9 < &v8[v6 & 0xFFFFFFFFFFFCLL])
  {
    if ((*(_DWORD *)v9 & 0x80808080) != 0) {
      goto LABEL_22;
    }
    v9 += 4;
  }
  if (v9 >= &v8[v6 & 0xFFFFFFFFFFFELL])
  {
LABEL_18:
    if (v9 >= &v8[v7] || (*v9 & 0x80000000) == 0)
    {
LABEL_20:
      char v12 = 1;
LABEL_21:
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v7, v12 & 1);
      return v5[3];
    }
    goto LABEL_22;
  }
  if ((*(_WORD *)v9 & 0x8080) == 0)
  {
    v9 += 2;
    goto LABEL_18;
  }
LABEL_22:
  uint64_t v13 = 0;
  Swift::_HashTable::Bucket v14 = &v8[v7];
  char v12 = 1;
  uint64_t v15 = (unsigned __int8 *)(v4 + 4);
  uint64_t v16 = (unsigned __int8 *)(v4 + 4);
  while (1)
  {
    int v18 = (char)*v16++;
    unsigned __int8 v17 = v18;
    if ((v18 & 0x80000000) == 0)
    {
      uint64_t v19 = 1;
      goto LABEL_25;
    }
    if ((v17 + 11) < 0xCDu) {
      goto LABEL_68;
    }
    if (v17 <= 0xDFu)
    {
      if (v16 == (unsigned __int8 *)v14 || (*v16 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      char v12 = 0;
      uint64_t v16 = v15 + 2;
      uint64_t v19 = 2;
      goto LABEL_25;
    }
    if (v17 == 224) {
      break;
    }
    if (v17 <= 0xECu) {
      goto LABEL_50;
    }
    if (v17 == 237)
    {
      if (v16 == (unsigned __int8 *)v14) {
        goto LABEL_68;
      }
      unsigned int v22 = v15[1];
      if (v22 > 0x9F) {
        goto LABEL_68;
      }
LABEL_52:
      if ((v22 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      uint64_t v20 = (char *)(v15 + 2);
      if (v15 + 2 == (unsigned __int8 *)v14) {
        goto LABEL_68;
      }
LABEL_54:
      if ((*v20 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      char v12 = 0;
      uint64_t v16 = v15 + 3;
      uint64_t v19 = 3;
      goto LABEL_25;
    }
    if ((v17 + 16) >= 0xFEu)
    {
LABEL_50:
      if (v16 == (unsigned __int8 *)v14) {
        goto LABEL_68;
      }
      LOBYTE(v22) = v15[1];
      goto LABEL_52;
    }
    if (v17 == 240)
    {
      if (v16 == (unsigned __int8 *)v14 || (v15[1] + 64) < 0xD0u) {
        goto LABEL_68;
      }
    }
    else
    {
      if ((v17 + 12) >= 0xFDu)
      {
        if (v16 == (unsigned __int8 *)v14) {
          goto LABEL_68;
        }
        LOBYTE(v23) = v15[1];
      }
      else
      {
        if (v16 == (unsigned __int8 *)v14) {
          goto LABEL_68;
        }
        unsigned int v23 = v15[1];
        if (v23 > 0x8F) {
          goto LABEL_68;
        }
      }
      if ((v23 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
    }
    if (v15 + 2 == (unsigned __int8 *)v14
      || (v15[2] & 0xC0) != 0x80
      || v15 + 3 == (unsigned __int8 *)v14
      || (v15[3] & 0xC0) != 0x80)
    {
      goto LABEL_68;
    }
    char v12 = 0;
    uint64_t v16 = v15 + 4;
    uint64_t v19 = 4;
LABEL_25:
    v13 += v19;
    uint64_t v15 = v16;
    if (v16 == (unsigned __int8 *)v14) {
      goto LABEL_21;
    }
  }
  if (v16 != (unsigned __int8 *)v14)
  {
    uint64_t v20 = (char *)(v15 + 2);
    if ((v15[1] + 64) >= 0xE0u && v20 != v14) {
      goto LABEL_54;
    }
  }
LABEL_68:
  uint64_t v24 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v24);
  uint64_t v25 = specialized Collection.subscript.getter(v13, (uint64_t)(v5 + 4), v7);
  uint64_t v29 = v25;
  uint64_t v30 = v26;
  uint64_t v31 = v27;
  uint64_t v32 = v28;
  uint64_t v33 = v25;
  if (v25 != v26)
  {
    specialized Slice.subscript.getter(v25, v25, v26, v27, v28);
    uint64_t v33 = v29 + 1;
    if (__OFADD__(v29, 1))
    {
      unint64_t v73 = 1525;
LABEL_168:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v73, 0);
    }
  }
  uint64_t v34 = 0;
  uint64_t v35 = v30 + v29 - v33;
  if (v30 <= v33) {
    uint64_t v36 = v33;
  }
  else {
    uint64_t v36 = v30;
  }
  if (v32 <= v33) {
    uint64_t v37 = v33;
  }
  else {
    uint64_t v37 = v32;
  }
  uint64_t v38 = v37 - v33;
  uint64_t v39 = v36 - v33;
  do
  {
    if (v30 - v33 == v34) {
      goto LABEL_87;
    }
    if (v33 < v29)
    {
      unint64_t v73 = 1812;
      goto LABEL_168;
    }
    if (v39 == v34)
    {
      unint64_t v73 = 1813;
      goto LABEL_168;
    }
    if (v33 < 0)
    {
      unint64_t v73 = 1781;
      goto LABEL_168;
    }
    if (v38 == v34)
    {
      unint64_t v73 = 1782;
      goto LABEL_168;
    }
    if ((*(unsigned char *)(v31 + v33 + v34) & 0xC0) != 0x80) {
      goto LABEL_86;
    }
    uint64_t v40 = v29 + v34++;
  }
  while (!__OFADD__(v40, 1));
  __break(1u);
LABEL_86:
  uint64_t v35 = v29 + v34;
LABEL_87:
  if (v35 < v29) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
  }
  uint64_t v41 = v35 + 1;
  if (__OFADD__(v35, 1))
  {
    __break(1u);
    goto LABEL_176;
  }
  if (v30 < v41)
  {
LABEL_176:
    unint64_t v73 = 1820;
    goto LABEL_168;
  }
  int64_t v42 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v29, v41, v31, v32);
  uint64_t v44 = v43;
  uint64_t v74 = (uint64_t)v5;
  uint64_t v75 = 0;
  uint64_t v45 = v5[3];
  unint64_t v76 = 0xE000000000000000;
  uint64_t v46 = v45 & 0xFFFFFFFFFFFFLL;
  if ((v45 & 0xFFFFFFFFFFFFLL) != 0)
  {
    uint64_t v47 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v48 & 1) != 0 || v47 < v46 + 15) {
      _StringGuts.grow(_:)(v46 + 15);
    }
  }
  while (2)
  {
    if (v42 < 0) {
      goto LABEL_169;
    }
    uint64_t v55 = v46;
    if (v46 < v42)
    {
      unint64_t v73 = 1861;
      goto LABEL_168;
    }
    unint64_t v56 = v76;
    uint64_t v57 = v75 & 0xFFFFFFFFFFFFLL;
    if ((v76 & 0x2000000000000000) != 0) {
      uint64_t v57 = HIBYTE(v76) & 0xF;
    }
    uint64_t v58 = v57 + v55;
    Swift::Int v59 = v58 + 3;
    if (__OFADD__(v58, 3))
    {
      __break(1u);
      goto LABEL_172;
    }
    if (v59 >= 16)
    {
      uint64_t v60 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v61 & 1) != 0 || v60 < v59)
      {
        _StringGuts.grow(_:)(v59);
        unint64_t v56 = v76;
      }
    }
    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v56 & 0xFFFFFFFFFFFFFFFLL, v8, v42, 0);
    uint64_t v75 = *(void *)((v56 & 0xFFFFFFFFFFFFFFFLL) + 0x18);
    size_t v77 = 3;
    uint64_t v78 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v78, &v77, &v75);
    if (v55 < v44) {
LABEL_169:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    if (v44 < 0)
    {
LABEL_172:
      unint64_t v73 = 1860;
      goto LABEL_168;
    }
    uint64_t v46 = v55 - v44;
    if (v55 - v44 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    uint64_t v62 = &v8[v44];
    if (_allASCII(_:)((uint64_t *)&v8[v44], v55 - v44))
    {
LABEL_161:
      _StringGuts.appendInPlace(_:isASCII:)(&v8[v44], v55 - v44, 0);
      break;
    }
    uint64_t v63 = 0;
    uint64_t v64 = (unsigned __int8 *)&v8[v55];
    if (!v8) {
      uint64_t v64 = 0;
    }
    for (uint64_t i = (unsigned __int8 *)&v8[v44]; ; ++i)
    {
      while (1)
      {
LABEL_113:
        if (!i || i == v64) {
          goto LABEL_161;
        }
        unsigned int v67 = *i++;
        unsigned int v66 = v67;
        if ((v66 & 0x80) != 0) {
          break;
        }
        ++v63;
      }
      if ((v66 + 62) >= 0x33u) {
        goto LABEL_95;
      }
      if (v66 > 0xDF) {
        break;
      }
      if (!i || i == v64 || (*i & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      v63 += 2;
    }
    if (v66 == 224)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      uint64_t v68 = i + 1;
      if ((*i & 0xE0) != 0xA0) {
        goto LABEL_95;
      }
      goto LABEL_140;
    }
    if (v66 <= 0xEC) {
      goto LABEL_136;
    }
    if (v66 == 237)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      uint64_t v68 = i + 1;
      unsigned int v69 = *i;
      if (v69 > 0x9F) {
        goto LABEL_95;
      }
      goto LABEL_139;
    }
    if (v66 <= 0xEF)
    {
LABEL_136:
      if (!i || i == v64) {
        goto LABEL_95;
      }
      uint64_t v68 = i + 1;
      LOBYTE(v69) = *i;
LABEL_139:
      if ((v69 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
LABEL_140:
      if (v68 == v64 || (*v68 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      i += 2;
      v63 += 3;
      goto LABEL_113;
    }
    if (v66 == 240)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      uint64_t v70 = i + 1;
      if ((*i + 64) < 0xD0u) {
        goto LABEL_95;
      }
      goto LABEL_156;
    }
    if ((v66 + 15) <= 2u)
    {
      if (!i || i == v64) {
        goto LABEL_95;
      }
      uint64_t v70 = i + 1;
      LOBYTE(v71) = *i;
      goto LABEL_155;
    }
    if (i)
    {
      if (i != v64)
      {
        uint64_t v70 = i + 1;
        unsigned int v71 = *i;
        if (v71 <= 0x8F)
        {
LABEL_155:
          if ((v71 & 0xC0) != 0x80) {
            goto LABEL_95;
          }
LABEL_156:
          if (v70 == v64 || (i[1] & 0xC0) != 0x80 || i + 2 == v64 || (i[2] & 0xC0) != 0x80) {
            goto LABEL_95;
          }
          i += 3;
          v63 += 4;
          goto LABEL_113;
        }
      }
    }
LABEL_95:
    uint64_t v49 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
    swift_willThrow();
    swift_errorRelease(v49);
    uint64_t v50 = specialized Collection.subscript.getter(v63, (uint64_t)&v8[v44], v55 - v44);
    int64_t v42 = findInvalidRange #1 (_:) in validateUTF8(_:)(v50, v51, v52, v53);
    uint64_t v44 = v54;
    uint64_t v8 = v62;
    if (v46) {
      continue;
    }
    break;
  }
  uint64_t v2 = v75;
  swift_release(v74);
  return v2;
}

int64_t specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(unint64_t a1, int8x16_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int64_t v9 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(void *)(v9 + 16) = v10;
  *(void *)(v9 + 24) = 0x3000000000000000;
  if (v10 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
    uint64_t v11 = *(void *)(v9 + 24) & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v11 = 0;
  }
  *(unsigned char *)(v9 + 32 + v11) = 0;
  if ((a1 & 0x8000000000000000) != 0)
  {
    swift_bridgeObjectRelease(a5);
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  }
  if (a3 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if (a3)
  {
    unint64_t v12 = a3 - 1;
    if (a3 - 1 >= a1) {
      unint64_t v12 = a1;
    }
    unint64_t v13 = v12 + 1;
    if (v13 > 0x10 && (unint64_t)(v9 - (void)a2 + 32) >= 0x10)
    {
      uint64_t v15 = v13 & 0xF;
      if ((v13 & 0xF) == 0) {
        uint64_t v15 = 16;
      }
      unint64_t v14 = v13 - v15;
      v16.i64[0] = -1;
      v16.i64[1] = -1;
      v17.i64[0] = 0x3F3F3F3F3F3F3F3FLL;
      v17.i64[1] = 0x3F3F3F3F3F3F3F3FLL;
      uint64x2_t v18 = (uint64x2_t)vdupq_n_s64(0x3FFE000000000uLL);
      v19.i64[0] = 0x2020202020202020;
      v19.i64[1] = 0x2020202020202020;
      unint64_t v20 = v14;
      uint64_t v21 = (int8x16_t *)(v9 + 32);
      unsigned int v22 = a2;
      do
      {
        int8x16_t v23 = *v22++;
        uint8x16_t v24 = (uint8x16_t)vandq_s8((int8x16_t)vshrq_n_u8((uint8x16_t)vaddq_s8(v23, v16), 1uLL), v17);
        uint16x8_t v25 = vmovl_u8(*(uint8x8_t *)v24.i8);
        uint32x4_t v26 = vmovl_u16(*(uint16x4_t *)v25.i8);
        v27.i64[0] = v26.u32[0];
        v27.i64[1] = v26.u32[1];
        int64x2_t v28 = v27;
        uint32x4_t v29 = vmovl_high_u16(v25);
        uint16x8_t v30 = vmovl_high_u8(v24);
        v27.i64[0] = v29.u32[0];
        v27.i64[1] = v29.u32[1];
        int64x2_t v31 = v27;
        uint32x4_t v32 = vmovl_u16(*(uint16x4_t *)v30.i8);
        v27.i64[0] = v32.u32[0];
        v27.i64[1] = v32.u32[1];
        int64x2_t v33 = v27;
        int8x16_t v34 = (int8x16_t)vmovl_high_u16(v30);
        v27.i64[0] = v34.u32[0];
        v27.i64[1] = v34.u32[1];
        v41.val[3] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0, (uint32x4_t)v34));
        v41.val[1] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0, v32));
        v41.val[2] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v27));
        v41.val[0] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v33));
        v42.val[3] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0, v29));
        v42.val[1] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0, v26));
        v42.val[2] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v31));
        v42.val[0] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v28));
        v34.i64[0] = vqtbl4q_s8(v42, (int8x16_t)xmmword_18162AE20).u64[0];
        v34.i64[1] = vqtbl4q_s8(v41, (int8x16_t)xmmword_18162AE20).u64[0];
        *v21++ = vaddq_s8(vandq_s8(v34, v19), v23);
        v20 -= 16;
      }
      while (v20);
    }
    else
    {
      unint64_t v14 = 0;
    }
    unint64_t v35 = a1 - v14;
    uint64_t v36 = &a2->u8[v14];
    uint64_t v37 = (unsigned char *)(v14 + v9 + 32);
    uint64_t v38 = a3 - v14;
    do
    {
      if (!v35) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20EuLL, 0);
      }
      int v39 = *v36++;
      *v37++ = ((0x3FFE000000000uLL >> ((v39 - 1) >> 1)) & 0x20) + v39;
      --v35;
      --v38;
    }
    while (v38);
  }
  *(void *)(v9 + 24) = a3 | 0x3000000000000000;
  *(unsigned char *)(v9 + 32 + (a3 & 0xFFFFFFFFFFFFLL)) = 0;
  return v9;
}

{
  int64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int8x16_t v16;
  int8x16_t v17;
  uint64x2_t v18;
  int8x16_t v19;
  unint64_t v20;
  int8x16_t *v21;
  int8x16_t *v22;
  int8x16_t v23;
  uint8x16_t v24;
  uint16x8_t v25;
  uint32x4_t v26;
  int64x2_t v27;
  int64x2_t v28;
  uint32x4_t v29;
  uint16x8_t v30;
  int64x2_t v31;
  uint32x4_t v32;
  int64x2_t v33;
  int8x16_t v34;
  unint64_t v35;
  unsigned __int8 *v36;
  unsigned char *v37;
  uint64_t v38;
  int v39;
  int8x16x4_t v41;
  int8x16x4_t v42;

  int64_t v9 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(void *)(v9 + 16) = v10;
  *(void *)(v9 + 24) = 0x3000000000000000;
  if (v10 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
    uint64_t v11 = *(void *)(v9 + 24) & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v11 = 0;
  }
  *(unsigned char *)(v9 + 32 + v11) = 0;
  if ((a1 & 0x8000000000000000) != 0)
  {
    swift_bridgeObjectRelease(a5);
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  }
  if (a3 < 0) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
  }
  if (a3)
  {
    unint64_t v12 = a3 - 1;
    if (a3 - 1 >= a1) {
      unint64_t v12 = a1;
    }
    unint64_t v13 = v12 + 1;
    if (v13 > 0x10 && (unint64_t)(v9 - (void)a2 + 32) >= 0x10)
    {
      uint64_t v15 = v13 & 0xF;
      if ((v13 & 0xF) == 0) {
        uint64_t v15 = 16;
      }
      unint64_t v14 = v13 - v15;
      v16.i64[0] = -1;
      v16.i64[1] = -1;
      v17.i64[0] = 0x3F3F3F3F3F3F3F3FLL;
      v17.i64[1] = 0x3F3F3F3F3F3F3F3FLL;
      uint64x2_t v18 = (uint64x2_t)vdupq_n_s64(0x1FFF000000000000uLL);
      v19.i64[0] = 0x2020202020202020;
      v19.i64[1] = 0x2020202020202020;
      unint64_t v20 = v14;
      uint64_t v21 = (int8x16_t *)(v9 + 32);
      unsigned int v22 = a2;
      do
      {
        int8x16_t v23 = *v22++;
        uint8x16_t v24 = (uint8x16_t)vandq_s8((int8x16_t)vshrq_n_u8((uint8x16_t)vaddq_s8(v23, v16), 1uLL), v17);
        uint16x8_t v25 = vmovl_u8(*(uint8x8_t *)v24.i8);
        uint32x4_t v26 = vmovl_u16(*(uint16x4_t *)v25.i8);
        v27.i64[0] = v26.u32[0];
        v27.i64[1] = v26.u32[1];
        int64x2_t v28 = v27;
        uint32x4_t v29 = vmovl_high_u16(v25);
        uint16x8_t v30 = vmovl_high_u8(v24);
        v27.i64[0] = v29.u32[0];
        v27.i64[1] = v29.u32[1];
        int64x2_t v31 = v27;
        uint32x4_t v32 = vmovl_u16(*(uint16x4_t *)v30.i8);
        v27.i64[0] = v32.u32[0];
        v27.i64[1] = v32.u32[1];
        int64x2_t v33 = v27;
        int8x16_t v34 = (int8x16_t)vmovl_high_u16(v30);
        v27.i64[0] = v34.u32[0];
        v27.i64[1] = v34.u32[1];
        v41.val[3] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0, (uint32x4_t)v34));
        v41.val[1] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0, v32));
        v41.val[2] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v27));
        v41.val[0] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v33));
        v42.val[3] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0, v29));
        v42.val[1] = (int8x16_t)vshlq_u64(v18, vsubw_high_u32((uint64x2_t)0, v26));
        v42.val[2] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v31));
        v42.val[0] = (int8x16_t)vshlq_u64(v18, (uint64x2_t)vnegq_s64(v28));
        v34.i64[0] = vqtbl4q_s8(v42, (int8x16_t)xmmword_18162AE20).u64[0];
        v34.i64[1] = vqtbl4q_s8(v41, (int8x16_t)xmmword_18162AE20).u64[0];
        *v21++ = vsubq_s8(v23, vandq_s8(vshlq_n_s8(v34, 5uLL), v19));
        v20 -= 16;
      }
      while (v20);
    }
    else
    {
      unint64_t v14 = 0;
    }
    unint64_t v35 = a1 - v14;
    uint64_t v36 = &a2->u8[v14];
    uint64_t v37 = (unsigned char *)(v14 + v9 + 32);
    uint64_t v38 = a3 - v14;
    do
    {
      if (!v35) {
        _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x20EuLL, 0);
      }
      int v39 = *v36++;
      *v37++ = v39 - 32 * ((0x1FFF000000000000uLL >> ((v39 - 1) >> 1)) & 1);
      --v35;
      --v38;
    }
    while (v38);
  }
  *(void *)(v9 + 24) = a3 | 0x3000000000000000;
  *(unsigned char *)(v9 + 32 + (a3 & 0xFFFFFFFFFFFFLL)) = 0;
  return v9;
}

uint64_t specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(void))
{
  int64_t v9 = (void *)a6();
  if (v7) {
    return v6;
  }
  uint64_t v10 = v9;
  uint64_t v11 = v9[3];
  Swift::Int v12 = v11 & 0xFFFFFFFFFFFFLL;
  if ((v11 & 0xFFFFFFFFFFFFLL) == 0) {
    goto LABEL_20;
  }
  unint64_t v13 = (char *)(v9 + 4);
  unint64_t v14 = (char *)(v9 + 4);
  if ((v11 & 0xFFFFFFFFFFF0) != 0)
  {
    if (((v9[5] | v9[4]) & 0x8080808080808080) != 0) {
      goto LABEL_22;
    }
    unint64_t v14 = (char *)(v9 + 6);
    while (v14 < (char *)v9 + (v11 & 0xFFFFFFFFFFF0) + 32)
    {
      uint64_t v15 = *(void *)v14;
      uint64_t v16 = *((void *)v14 + 1);
      v14 += 16;
      if (((v16 | v15) & 0x8080808080808080) != 0) {
        goto LABEL_22;
      }
    }
  }
  if (v14 < &v13[v11 & 0xFFFFFFFFFFF8])
  {
    if ((*(void *)v14 & 0x8080808080808080) != 0) {
      goto LABEL_22;
    }
    v14 += 8;
  }
  if (v14 < &v13[v11 & 0xFFFFFFFFFFFCLL])
  {
    if ((*(_DWORD *)v14 & 0x80808080) != 0) {
      goto LABEL_22;
    }
    v14 += 4;
  }
  if (v14 >= &v13[v11 & 0xFFFFFFFFFFFELL])
  {
LABEL_18:
    if (v14 >= &v13[v12] || (*v14 & 0x80000000) == 0)
    {
LABEL_20:
      char v17 = 1;
LABEL_21:
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v12, v17 & 1);
      return v10[3];
    }
    goto LABEL_22;
  }
  if ((*(_WORD *)v14 & 0x8080) == 0)
  {
    v14 += 2;
    goto LABEL_18;
  }
LABEL_22:
  uint64_t v18 = 0;
  int8x16_t v19 = &v13[v12];
  char v17 = 1;
  unint64_t v20 = (unsigned __int8 *)(v9 + 4);
  uint64_t v21 = (unsigned __int8 *)(v9 + 4);
  while (1)
  {
    int v23 = (char)*v21++;
    unsigned __int8 v22 = v23;
    if ((v23 & 0x80000000) == 0)
    {
      uint64_t v24 = 1;
      goto LABEL_25;
    }
    if ((v22 + 11) <= 0xCCu) {
      goto LABEL_68;
    }
    if (v22 < 0xE0u)
    {
      if (v21 == (unsigned __int8 *)v19 || (*v21 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      char v17 = 0;
      uint64_t v21 = v20 + 2;
      uint64_t v24 = 2;
      goto LABEL_25;
    }
    if (v22 == 224) {
      break;
    }
    if (v22 <= 0xECu) {
      goto LABEL_50;
    }
    if (v22 == 237)
    {
      if (v21 == (unsigned __int8 *)v19) {
        goto LABEL_68;
      }
      unsigned int v27 = v20[1];
      if (v27 > 0x9F) {
        goto LABEL_68;
      }
LABEL_52:
      if ((v27 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      uint16x8_t v25 = (char *)(v20 + 2);
      if (v20 + 2 == (unsigned __int8 *)v19) {
        goto LABEL_68;
      }
LABEL_54:
      if ((*v25 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      char v17 = 0;
      uint64_t v21 = v20 + 3;
      uint64_t v24 = 3;
      goto LABEL_25;
    }
    if ((v22 + 16) >= 0xFEu)
    {
LABEL_50:
      if (v21 == (unsigned __int8 *)v19) {
        goto LABEL_68;
      }
      LOBYTE(v27) = v20[1];
      goto LABEL_52;
    }
    if (v22 == 240)
    {
      if (v21 == (unsigned __int8 *)v19 || (v20[1] + 64) < 0xD0u) {
        goto LABEL_68;
      }
    }
    else
    {
      if ((v22 + 12) >= 0xFDu)
      {
        if (v21 == (unsigned __int8 *)v19) {
          goto LABEL_68;
        }
        LOBYTE(v28) = v20[1];
      }
      else
      {
        if (v21 == (unsigned __int8 *)v19) {
          goto LABEL_68;
        }
        unsigned int v28 = v20[1];
        if (v28 > 0x8F) {
          goto LABEL_68;
        }
      }
      if ((v28 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
    }
    if (v20 + 2 == (unsigned __int8 *)v19
      || (v20[2] & 0xC0) != 0x80
      || v20 + 3 == (unsigned __int8 *)v19
      || (v20[3] & 0xC0) != 0x80)
    {
      goto LABEL_68;
    }
    char v17 = 0;
    uint64_t v21 = v20 + 4;
    uint64_t v24 = 4;
LABEL_25:
    v18 += v24;
    unint64_t v20 = v21;
    if (v21 == (unsigned __int8 *)v19) {
      goto LABEL_21;
    }
  }
  if (v21 != (unsigned __int8 *)v19)
  {
    uint16x8_t v25 = (char *)(v20 + 2);
    if ((v20[1] + 64) >= 0xE0u && v25 != v19) {
      goto LABEL_54;
    }
  }
LABEL_68:
  uint32x4_t v29 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v29);
  uint64_t v30 = specialized Collection.subscript.getter(v18, (uint64_t)(v10 + 4), v12);
  uint64_t v34 = v30;
  uint64_t v35 = v31;
  uint64_t v36 = v32;
  uint64_t v37 = v33;
  uint64_t v38 = v30;
  if (v30 != v31)
  {
    specialized Slice.subscript.getter(v30, v30, v31, v32, v33);
    uint64_t v38 = v34 + 1;
    if (__OFADD__(v34, 1))
    {
      swift_bridgeObjectRelease(a5);
      unint64_t v78 = 1525;
LABEL_168:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v78, 0);
    }
  }
  uint64_t v39 = 0;
  uint64_t v40 = v35 + v34 - v38;
  if (v35 <= v38) {
    uint64_t v41 = v38;
  }
  else {
    uint64_t v41 = v35;
  }
  if (v37 <= v38) {
    uint64_t v42 = v38;
  }
  else {
    uint64_t v42 = v37;
  }
  uint64_t v43 = v42 - v38;
  uint64_t v44 = v41 - v38;
  do
  {
    if (v35 - v38 == v39) {
      goto LABEL_87;
    }
    if (v38 < v34)
    {
      swift_bridgeObjectRelease(a5);
      unint64_t v78 = 1812;
      goto LABEL_168;
    }
    if (v44 == v39)
    {
      swift_bridgeObjectRelease(a5);
      unint64_t v78 = 1813;
      goto LABEL_168;
    }
    if (v38 < 0)
    {
      swift_bridgeObjectRelease(a5);
      unint64_t v78 = 1781;
      goto LABEL_168;
    }
    if (v43 == v39)
    {
      swift_bridgeObjectRelease(a5);
      unint64_t v78 = 1782;
      goto LABEL_168;
    }
    if ((*(unsigned char *)(v36 + v38 + v39) & 0xC0) != 0x80) {
      goto LABEL_86;
    }
    uint64_t v45 = v34 + v39++;
  }
  while (!__OFADD__(v45, 1));
  __break(1u);
LABEL_86:
  uint64_t v40 = v34 + v39;
LABEL_87:
  if (v40 < v34)
  {
    swift_bridgeObjectRelease(a5);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
  }
  uint64_t v46 = v40 + 1;
  if (__OFADD__(v40, 1))
  {
    __break(1u);
    goto LABEL_176;
  }
  if (v35 < v46)
  {
LABEL_176:
    unint64_t v78 = 1820;
    goto LABEL_168;
  }
  uint64_t v79 = a5;
  int64_t v47 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v34, v46, v36, v37);
  uint64_t v49 = v48;
  uint64_t v80 = (uint64_t)v10;
  uint64_t v81 = 0;
  uint64_t v50 = v10[3];
  unint64_t v82 = 0xE000000000000000;
  uint64_t v51 = v50 & 0xFFFFFFFFFFFFLL;
  if ((v50 & 0xFFFFFFFFFFFFLL) != 0)
  {
    uint64_t v52 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v53 & 1) != 0 || v52 < v51 + 15) {
      _StringGuts.grow(_:)(v51 + 15);
    }
  }
  while (2)
  {
    if (v47 < 0) {
      goto LABEL_169;
    }
    uint64_t v60 = v51;
    if (v51 < v47)
    {
      swift_bridgeObjectRelease(v79);
      unint64_t v78 = 1861;
      goto LABEL_168;
    }
    unint64_t v61 = v82;
    uint64_t v62 = v81 & 0xFFFFFFFFFFFFLL;
    if ((v82 & 0x2000000000000000) != 0) {
      uint64_t v62 = HIBYTE(v82) & 0xF;
    }
    uint64_t v63 = v62 + v60;
    Swift::Int v64 = v63 + 3;
    if (__OFADD__(v63, 3))
    {
      __break(1u);
      goto LABEL_172;
    }
    if (v64 >= 16)
    {
      uint64_t v65 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v66 & 1) != 0 || v65 < v64)
      {
        _StringGuts.grow(_:)(v64);
        unint64_t v61 = v82;
      }
    }
    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v61 & 0xFFFFFFFFFFFFFFFLL, v13, v47, 0);
    uint64_t v81 = *(void *)((v61 & 0xFFFFFFFFFFFFFFFLL) + 0x18);
    size_t v83 = 3;
    uint64_t v84 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v84, &v83, &v81);
    if (v60 < v49)
    {
LABEL_169:
      swift_bridgeObjectRelease(v79);
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    }
    if (v49 < 0)
    {
LABEL_172:
      swift_bridgeObjectRelease(v79);
      unint64_t v78 = 1860;
      goto LABEL_168;
    }
    uint64_t v51 = v60 - v49;
    if (v60 - v49 < 0)
    {
      swift_bridgeObjectRelease(v79);
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    unsigned int v67 = &v13[v49];
    if (_allASCII(_:)((uint64_t *)&v13[v49], v60 - v49))
    {
LABEL_161:
      _StringGuts.appendInPlace(_:isASCII:)(&v13[v49], v60 - v49, 0);
      break;
    }
    uint64_t v68 = 0;
    unsigned int v69 = (unsigned __int8 *)&v13[v60];
    if (!v13) {
      unsigned int v69 = 0;
    }
    for (uint64_t i = (unsigned __int8 *)&v13[v49]; ; ++i)
    {
      while (1)
      {
LABEL_113:
        if (!i || i == v69) {
          goto LABEL_161;
        }
        unsigned int v72 = *i++;
        unsigned int v71 = v72;
        if ((v71 & 0x80) != 0) {
          break;
        }
        ++v68;
      }
      if ((v71 + 62) > 0x32u) {
        goto LABEL_95;
      }
      if (v71 > 0xDF) {
        break;
      }
      if (!i || i == v69 || (*i & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      v68 += 2;
    }
    if (v71 == 224)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v69) {
        goto LABEL_95;
      }
      unint64_t v73 = i + 1;
      if ((*i & 0xE0) != 0xA0) {
        goto LABEL_95;
      }
      goto LABEL_140;
    }
    if (v71 < 0xED) {
      goto LABEL_136;
    }
    if (v71 == 237)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v69) {
        goto LABEL_95;
      }
      unint64_t v73 = i + 1;
      unsigned int v74 = *i;
      if (v74 > 0x9F) {
        goto LABEL_95;
      }
      goto LABEL_139;
    }
    if (v71 < 0xF0)
    {
LABEL_136:
      if (!i || i == v69) {
        goto LABEL_95;
      }
      unint64_t v73 = i + 1;
      LOBYTE(v74) = *i;
LABEL_139:
      if ((v74 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
LABEL_140:
      if (v73 == v69 || (*v73 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      i += 2;
      v68 += 3;
      goto LABEL_113;
    }
    if (v71 == 240)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v69) {
        goto LABEL_95;
      }
      uint64_t v75 = i + 1;
      if ((*i + 64) < 0xD0u) {
        goto LABEL_95;
      }
      goto LABEL_156;
    }
    if ((v71 + 15) < 3u)
    {
      if (!i || i == v69) {
        goto LABEL_95;
      }
      uint64_t v75 = i + 1;
      LOBYTE(v76) = *i;
      goto LABEL_155;
    }
    if (i)
    {
      if (i != v69)
      {
        uint64_t v75 = i + 1;
        unsigned int v76 = *i;
        if (v76 <= 0x8F)
        {
LABEL_155:
          if ((v76 & 0xC0) != 0x80) {
            goto LABEL_95;
          }
LABEL_156:
          if (v75 == v69 || (i[1] & 0xC0) != 0x80 || i + 2 == v69 || (i[2] & 0xC0) != 0x80) {
            goto LABEL_95;
          }
          i += 3;
          v68 += 4;
          goto LABEL_113;
        }
      }
    }
LABEL_95:
    uint64_t v54 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
    swift_willThrow();
    swift_errorRelease(v54);
    uint64_t v55 = specialized Collection.subscript.getter(v68, (uint64_t)&v13[v49], v60 - v49);
    int64_t v47 = findInvalidRange #1 (_:) in validateUTF8(_:)(v55, v56, v57, v58);
    uint64_t v49 = v59;
    unint64_t v13 = v67;
    if (v51) {
      continue;
    }
    break;
  }
  uint64_t v6 = v81;
  swift_release(v80);
  return v6;
}

uint64_t type metadata accessor for __StringStorage()
{
  return self;
}

int64_t specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(int64_t a1, unsigned int a2)
{
  int64_t v4 = _allocateStringStorage(codeUnitCapacity:)(a1);
  *(void *)(v4 + 16) = v5;
  *(void *)(v4 + 24) = 0x3000000000000000;
  if (v5 < 0)
  {
    *(void *)__StringStorage._breadcrumbsAddress.getter() = 0;
    uint64_t v6 = *(void *)(v4 + 24) & 0xFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v6 = 0;
  }
  *(unsigned char *)(v4 + 32 + v6) = 0;
  if (a1 < 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableBufferPointer with negative count", 46, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x47uLL, 0);
  }
  uint64_t ScalarName = _swift_stdlib_getScalarName(a2, v4 + 32, a1);
  *(void *)(v4 + 24) = ScalarName | 0x3000000000000000;
  *(unsigned char *)(v4 + 32 + (ScalarName & 0xFFFFFFFFFFFFLL)) = 0;
  return v4;
}

uint64_t specialized static String._fromLargeUTF8Repairing(uninitializedCapacity:initializingWith:)(int64_t a1, unsigned int a2)
{
  int64_t v4 = (void *)specialized static __StringStorage.create(uninitializedCodeUnitCapacity:initializingUncheckedUTF8With:)(a1, a2);
  if (v3) {
    return v2;
  }
  uint64_t v5 = v4;
  uint64_t v6 = v4[3];
  Swift::Int v7 = v6 & 0xFFFFFFFFFFFFLL;
  if ((v6 & 0xFFFFFFFFFFFFLL) == 0) {
    goto LABEL_20;
  }
  uint64_t v8 = (char *)(v4 + 4);
  int64_t v9 = (char *)(v4 + 4);
  if ((v6 & 0xFFFFFFFFFFF0) != 0)
  {
    if (((v4[5] | v4[4]) & 0x8080808080808080) != 0) {
      goto LABEL_22;
    }
    int64_t v9 = (char *)(v4 + 6);
    while (v9 < (char *)v4 + (v6 & 0xFFFFFFFFFFF0) + 32)
    {
      uint64_t v10 = *(void *)v9;
      uint64_t v11 = *((void *)v9 + 1);
      v9 += 16;
      if (((v11 | v10) & 0x8080808080808080) != 0) {
        goto LABEL_22;
      }
    }
  }
  if (v9 < &v8[v6 & 0xFFFFFFFFFFF8])
  {
    if ((*(void *)v9 & 0x8080808080808080) != 0) {
      goto LABEL_22;
    }
    v9 += 8;
  }
  if (v9 < &v8[v6 & 0xFFFFFFFFFFFCLL])
  {
    if ((*(_DWORD *)v9 & 0x80808080) != 0) {
      goto LABEL_22;
    }
    v9 += 4;
  }
  if (v9 >= &v8[v6 & 0xFFFFFFFFFFFELL])
  {
LABEL_18:
    if (v9 >= &v8[v7] || (*v9 & 0x80000000) == 0)
    {
LABEL_20:
      char v12 = 1;
LABEL_21:
      __StringStorage._updateCountAndFlags(newCount:newIsASCII:)(v7, v12 & 1);
      return v5[3];
    }
    goto LABEL_22;
  }
  if ((*(_WORD *)v9 & 0x8080) == 0)
  {
    v9 += 2;
    goto LABEL_18;
  }
LABEL_22:
  uint64_t v13 = 0;
  unint64_t v14 = &v8[v7];
  char v12 = 1;
  uint64_t v15 = (unsigned __int8 *)(v4 + 4);
  uint64_t v16 = (unsigned __int8 *)(v4 + 4);
  while (1)
  {
    int v18 = (char)*v16++;
    unsigned __int8 v17 = v18;
    if ((v18 & 0x80000000) == 0)
    {
      uint64_t v19 = 1;
      goto LABEL_25;
    }
    if ((v17 + 11) <= 0xCCu) {
      goto LABEL_68;
    }
    if (v17 < 0xE0u)
    {
      if (v16 == (unsigned __int8 *)v14 || (*v16 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      char v12 = 0;
      uint64_t v16 = v15 + 2;
      uint64_t v19 = 2;
      goto LABEL_25;
    }
    if (v17 == 224) {
      break;
    }
    if (v17 <= 0xECu) {
      goto LABEL_50;
    }
    if (v17 == 237)
    {
      if (v16 == (unsigned __int8 *)v14) {
        goto LABEL_68;
      }
      unsigned int v22 = v15[1];
      if (v22 > 0x9F) {
        goto LABEL_68;
      }
LABEL_52:
      if ((v22 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      unint64_t v20 = (char *)(v15 + 2);
      if (v15 + 2 == (unsigned __int8 *)v14) {
        goto LABEL_68;
      }
LABEL_54:
      if ((*v20 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
      char v12 = 0;
      uint64_t v16 = v15 + 3;
      uint64_t v19 = 3;
      goto LABEL_25;
    }
    if ((v17 + 16) >= 0xFEu)
    {
LABEL_50:
      if (v16 == (unsigned __int8 *)v14) {
        goto LABEL_68;
      }
      LOBYTE(v22) = v15[1];
      goto LABEL_52;
    }
    if (v17 == 240)
    {
      if (v16 == (unsigned __int8 *)v14 || (v15[1] + 64) < 0xD0u) {
        goto LABEL_68;
      }
    }
    else
    {
      if ((v17 + 12) >= 0xFDu)
      {
        if (v16 == (unsigned __int8 *)v14) {
          goto LABEL_68;
        }
        LOBYTE(v23) = v15[1];
      }
      else
      {
        if (v16 == (unsigned __int8 *)v14) {
          goto LABEL_68;
        }
        unsigned int v23 = v15[1];
        if (v23 > 0x8F) {
          goto LABEL_68;
        }
      }
      if ((v23 & 0xC0) != 0x80) {
        goto LABEL_68;
      }
    }
    if (v15 + 2 == (unsigned __int8 *)v14
      || (v15[2] & 0xC0) != 0x80
      || v15 + 3 == (unsigned __int8 *)v14
      || (v15[3] & 0xC0) != 0x80)
    {
      goto LABEL_68;
    }
    char v12 = 0;
    uint64_t v16 = v15 + 4;
    uint64_t v19 = 4;
LABEL_25:
    v13 += v19;
    uint64_t v15 = v16;
    if (v16 == (unsigned __int8 *)v14) {
      goto LABEL_21;
    }
  }
  if (v16 != (unsigned __int8 *)v14)
  {
    unint64_t v20 = (char *)(v15 + 2);
    if ((v15[1] + 64) >= 0xE0u && v20 != v14) {
      goto LABEL_54;
    }
  }
LABEL_68:
  uint64_t v24 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
  swift_willThrow();
  swift_errorRelease(v24);
  uint64_t v25 = specialized Collection.subscript.getter(v13, (uint64_t)(v5 + 4), v7);
  uint64_t v29 = v25;
  uint64_t v30 = v26;
  uint64_t v31 = v27;
  uint64_t v32 = v28;
  uint64_t v33 = v25;
  if (v25 != v26)
  {
    specialized Slice.subscript.getter(v25, v25, v26, v27, v28);
    uint64_t v33 = v29 + 1;
    if (__OFADD__(v29, 1))
    {
      unint64_t v73 = 1525;
LABEL_168:
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, v73, 0);
    }
  }
  uint64_t v34 = 0;
  uint64_t v35 = v30 + v29 - v33;
  if (v30 <= v33) {
    uint64_t v36 = v33;
  }
  else {
    uint64_t v36 = v30;
  }
  if (v32 <= v33) {
    uint64_t v37 = v33;
  }
  else {
    uint64_t v37 = v32;
  }
  uint64_t v38 = v37 - v33;
  uint64_t v39 = v36 - v33;
  do
  {
    if (v30 - v33 == v34) {
      goto LABEL_87;
    }
    if (v33 < v29)
    {
      unint64_t v73 = 1812;
      goto LABEL_168;
    }
    if (v39 == v34)
    {
      unint64_t v73 = 1813;
      goto LABEL_168;
    }
    if (v33 < 0)
    {
      unint64_t v73 = 1781;
      goto LABEL_168;
    }
    if (v38 == v34)
    {
      unint64_t v73 = 1782;
      goto LABEL_168;
    }
    if ((*(unsigned char *)(v31 + v33 + v34) & 0xC0) != 0x80) {
      goto LABEL_86;
    }
    uint64_t v40 = v29 + v34++;
  }
  while (!__OFADD__(v40, 1));
  __break(1u);
LABEL_86:
  uint64_t v35 = v29 + v34;
LABEL_87:
  if (v35 < v29) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/ClosedRange.swift", 23, 2, 0x15BuLL, 0);
  }
  uint64_t v41 = v35 + 1;
  if (__OFADD__(v35, 1))
  {
    __break(1u);
    goto LABEL_176;
  }
  if (v30 < v41)
  {
LABEL_176:
    unint64_t v73 = 1820;
    goto LABEL_168;
  }
  int64_t v42 = _legacyNarrowIllegalRange #1 (buf:) in validateUTF8(_:)(v29, v41, v31, v32);
  uint64_t v44 = v43;
  uint64_t v74 = (uint64_t)v5;
  uint64_t v75 = 0;
  uint64_t v45 = v5[3];
  unint64_t v76 = 0xE000000000000000;
  uint64_t v46 = v45 & 0xFFFFFFFFFFFFLL;
  if ((v45 & 0xFFFFFFFFFFFFLL) != 0)
  {
    uint64_t v47 = _StringGuts.uniqueNativeCapacity.getter();
    if ((v48 & 1) != 0 || v47 < v46 + 15) {
      _StringGuts.grow(_:)(v46 + 15);
    }
  }
  while (2)
  {
    if (v42 < 0) {
      goto LABEL_169;
    }
    uint64_t v55 = v46;
    if (v46 < v42)
    {
      unint64_t v73 = 1861;
      goto LABEL_168;
    }
    unint64_t v56 = v76;
    uint64_t v57 = v75 & 0xFFFFFFFFFFFFLL;
    if ((v76 & 0x2000000000000000) != 0) {
      uint64_t v57 = HIBYTE(v76) & 0xF;
    }
    uint64_t v58 = v57 + v55;
    Swift::Int v59 = v58 + 3;
    if (__OFADD__(v58, 3))
    {
      __break(1u);
      goto LABEL_172;
    }
    if (v59 >= 16)
    {
      uint64_t v60 = _StringGuts.uniqueNativeCapacity.getter();
      if ((v61 & 1) != 0 || v60 < v59)
      {
        _StringGuts.grow(_:)(v59);
        unint64_t v56 = v76;
      }
    }
    closure #1 in _StringGuts.appendInPlace(_:isASCII:)(v56 & 0xFFFFFFFFFFFFFFFLL, v8, v42, 0);
    uint64_t v75 = *(void *)((v56 & 0xFFFFFFFFFFFFFFFLL) + 0x18);
    size_t v77 = 3;
    uint64_t v78 = 12435439;
    specialized closure #1 in Unicode.Scalar.withUTF8CodeUnits<A>(_:)((char *)&v78, &v77, &v75);
    if (v55 < v44) {
LABEL_169:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Range requires lowerBound <= upperBound", 39, 2, "Swift/Range.swift", 17, 2, 0x2F2uLL, 0);
    if (v44 < 0)
    {
LABEL_172:
      unint64_t v73 = 1860;
      goto LABEL_168;
    }
    uint64_t v46 = v55 - v44;
    if (v55 - v44 < 0) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
    }
    uint64_t v62 = &v8[v44];
    if (_allASCII(_:)((uint64_t *)&v8[v44], v55 - v44))
    {
LABEL_161:
      _StringGuts.appendInPlace(_:isASCII:)(&v8[v44], v55 - v44, 0);
      break;
    }
    uint64_t v63 = 0;
    Swift::Int v64 = (unsigned __int8 *)&v8[v55];
    if (!v8) {
      Swift::Int v64 = 0;
    }
    for (uint64_t i = (unsigned __int8 *)&v8[v44]; ; ++i)
    {
      while (1)
      {
LABEL_113:
        if (!i || i == v64) {
          goto LABEL_161;
        }
        unsigned int v67 = *i++;
        unsigned int v66 = v67;
        if ((v66 & 0x80) != 0) {
          break;
        }
        ++v63;
      }
      if ((v66 + 62) > 0x32u) {
        goto LABEL_95;
      }
      if (v66 > 0xDF) {
        break;
      }
      if (!i || i == v64 || (*i & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      v63 += 2;
    }
    if (v66 == 224)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      uint64_t v68 = i + 1;
      if ((*i & 0xE0) != 0xA0) {
        goto LABEL_95;
      }
      goto LABEL_140;
    }
    if (v66 < 0xED) {
      goto LABEL_136;
    }
    if (v66 == 237)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      uint64_t v68 = i + 1;
      unsigned int v69 = *i;
      if (v69 > 0x9F) {
        goto LABEL_95;
      }
      goto LABEL_139;
    }
    if (v66 < 0xF0)
    {
LABEL_136:
      if (!i || i == v64) {
        goto LABEL_95;
      }
      uint64_t v68 = i + 1;
      LOBYTE(v69) = *i;
LABEL_139:
      if ((v69 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
LABEL_140:
      if (v68 == v64 || (*v68 & 0xC0) != 0x80) {
        goto LABEL_95;
      }
      i += 2;
      v63 += 3;
      goto LABEL_113;
    }
    if (v66 == 240)
    {
      if (!i) {
        goto LABEL_95;
      }
      if (i == v64) {
        goto LABEL_95;
      }
      uint64_t v70 = i + 1;
      if ((*i + 64) < 0xD0u) {
        goto LABEL_95;
      }
      goto LABEL_156;
    }
    if ((v66 + 15) < 3u)
    {
      if (!i || i == v64) {
        goto LABEL_95;
      }
      uint64_t v70 = i + 1;
      LOBYTE(v71) = *i;
      goto LABEL_155;
    }
    if (i)
    {
      if (i != v64)
      {
        uint64_t v70 = i + 1;
        unsigned int v71 = *i;
        if (v71 <= 0x8F)
        {
LABEL_155:
          if ((v71 & 0xC0) != 0x80) {
            goto LABEL_95;
          }
LABEL_156:
          if (v70 == v64 || (i[1] & 0xC0) != 0x80 || i + 2 == v64 || (i[2] & 0xC0) != 0x80) {
            goto LABEL_95;
          }
          i += 3;
          v63 += 4;
          goto LABEL_113;
        }
      }
    }
LABEL_95:
    uint64_t v49 = swift_allocError((uint64_t)&unk_1EC9FFB80, (uint64_t)&protocol witness table for UTF8ValidationError, 0, 0);
    swift_willThrow();
    swift_errorRelease(v49);
    uint64_t v50 = specialized Collection.subscript.getter(v63, (uint64_t)&v8[v44], v55 - v44);
    int64_t v42 = findInvalidRange #1 (_:) in validateUTF8(_:)(v50, v51, v52, v53);
    uint64_t v44 = v54;
    uint64_t v8 = v62;
    if (v46) {
      continue;
    }
    break;
  }
  uint64_t v2 = v75;
  swift_release(v74);
  return v2;
}

uint64_t specialized static StringProtocol.== infix<A>(_:_:)(unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v6 = a2 >> 16;
  if ((a6 & 0x2000000000000000) != 0) {
    uint64_t v7 = HIBYTE(a6) & 0xF;
  }
  else {
    uint64_t v7 = a5 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v8 = a1 >> 16;
  if (a3 == a5 && a4 == a6 && !v8 && v6 == v7) {
    return 1;
  }
  else {
    return _stringCompareInternal(_:_:_:_:expecting:)(a3, a4, v8, v6, a5, a6, 0, v7, 0) & 1;
  }
}

uint64_t specialized static StringProtocol.== infix<A>(_:_:)(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v7 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v8 = a4 >> 16;
  uint64_t v9 = a3 >> 16;
  if (a1 == a5 && a2 == a6 && !v9 && v7 == v8) {
    return 1;
  }
  else {
    return _stringCompareInternal(_:_:_:_:expecting:)(a1, a2, 0, v7, a5, a6, v9, v8, 0) & 1;
  }
}

uint64_t specialized static StringProtocol.== infix<A>(_:_:)(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v5 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if ((a4 & 0x2000000000000000) != 0) {
    uint64_t v6 = HIBYTE(a4) & 0xF;
  }
  else {
    uint64_t v6 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (a1 == a3 && a2 == a4 && v5 == v6) {
    return 1;
  }
  else {
    return _stringCompareInternal(_:_:_:_:expecting:)(a1, a2, 0, v5, a3, a4, 0, v6, 0) & 1;
  }
}

uint64_t specialized static StringProtocol.< infix<A>(_:_:)(unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  uint64_t v6 = a2 >> 16;
  if ((a6 & 0x2000000000000000) != 0) {
    uint64_t v7 = HIBYTE(a6) & 0xF;
  }
  else {
    uint64_t v7 = a5 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v8 = a1 >> 16;
  if (a3 == a5 && a4 == a6 && !v8 && v6 == v7) {
    return 0;
  }
  else {
    return _stringCompareInternal(_:_:_:_:expecting:)(a3, a4, v8, v6, a5, a6, 0, v7, 1) & 1;
  }
}

uint64_t specialized static StringProtocol.< infix<A>(_:_:)(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v7 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v7 = a1 & 0xFFFFFFFFFFFFLL;
  }
  uint64_t v8 = a4 >> 16;
  uint64_t v9 = a3 >> 16;
  if (a1 == a5 && a2 == a6 && !v9 && v7 == v8) {
    return 0;
  }
  else {
    return _stringCompareInternal(_:_:_:_:expecting:)(a1, a2, 0, v7, a5, a6, v9, v8, 1) & 1;
  }
}

uint64_t specialized static StringProtocol.< infix<A>(_:_:)(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  if ((a2 & 0x2000000000000000) != 0) {
    uint64_t v5 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v5 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if ((a4 & 0x2000000000000000) != 0) {
    uint64_t v6 = HIBYTE(a4) & 0xF;
  }
  else {
    uint64_t v6 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (a1 == a3 && a2 == a4 && v5 == v6) {
    return 0;
  }
  else {
    return _stringCompareInternal(_:_:_:_:expecting:)(a1, a2, 0, v5, a3, a4, 0, v6, 1) & 1;
  }
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.UTF16.ForwardParser, (unint64_t *)&type metadata for Unicode.UTF16.ForwardParser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.UTF16.ForwardParser, (unint64_t *)&type metadata for Unicode.UTF16.ForwardParser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF16.ForwardParser and conformance Unicode.UTF16.ForwardParser);
  }
  return result;
}

Class *type metadata accessor for ReversedCollection(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for ReversedCollection.Flags);
}

Swift::UInt64 specialized String.Index.init(_:within:)(Swift::String::Index a1, unint64_t a2, uint64_t a3)
{
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v5 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000) == 0) {
    LOBYTE(v5) = 1;
  }
  if ((a1._rawBits & 0xC) == 4 << v5) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  Swift::Bool v6 = String._isValidIndex(_:)((Swift::String::Index)rawBits);
  swift_bridgeObjectRelease(a3);
  if (v6) {
    return rawBits | 3;
  }
  else {
    return 0;
  }
}

Swift::UInt64 specialized String.Index.init(_:within:)(Swift::String::Index a1, unint64_t a2, unint64_t a3)
{
  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v6 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((a1._rawBits & 0xC) == 4 << v6) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  unint64_t v7 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000) == 0) {
    unint64_t v7 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 >= rawBits >> 16)
  {
    if ((a3 & 0x1000000000000000) != 0)
    {
      v9._Swift::UInt64 rawBits = rawBits;
      BOOL v10 = String.Index._foreignIsWithin(_:)(a2, a3, v9);
      swift_bridgeObjectRelease(a3);
      if (v10) {
        return rawBits;
      }
    }
    else
    {
      swift_bridgeObjectRelease(a3);
      if ((rawBits & 0xC000) == 0) {
        return rawBits;
      }
    }
  }
  else
  {
    swift_bridgeObjectRelease(a3);
  }
  return 0;
}

{
  Swift::UInt64 rawBits;
  uint64_t v6;
  unint64_t v7;
  BOOL v8;
  BOOL v9;

  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v6 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((a1._rawBits & 0xC) == 4 << v6) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  unint64_t v7 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000) == 0) {
    unint64_t v7 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 >= rawBits >> 16)
  {
    if ((a3 & 0x1000000000000000) != 0)
    {
      uint64_t v8 = specialized String.Index._foreignIsWithin(_:)(rawBits);
    }
    else
    {
      if ((rawBits & 0xC000) != 0)
      {
        swift_bridgeObjectRelease(a3);
        return rawBits;
      }
      uint64_t v8 = _StringGuts.isOnUnicodeScalarBoundary(_:)((Swift::String::Index)rawBits);
    }
    Swift::String::Index v9 = v8;
    swift_bridgeObjectRelease(a3);
    if (v9) {
      return rawBits;
    }
  }
  else
  {
    swift_bridgeObjectRelease(a3);
  }
  return 0;
}

{
  Swift::UInt64 rawBits;
  uint64_t v6;
  unint64_t v7;
  Swift::Bool v8;

  Swift::UInt64 rawBits = a1._rawBits;
  uint64_t v6 = (a2 >> 59) & 1;
  if ((a3 & 0x1000000000000000) == 0) {
    LOBYTE(v6) = 1;
  }
  if ((a1._rawBits & 0xC) == 4 << v6) {
    Swift::UInt64 rawBits = _StringGuts._slowEnsureMatchingEncoding(_:)(a1)._rawBits;
  }
  unint64_t v7 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000) == 0) {
    unint64_t v7 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v7 < rawBits >> 16)
  {
    swift_bridgeObjectRelease(a3);
    return 0;
  }
  uint64_t v8 = _StringGuts.isOnUnicodeScalarBoundary(_:)((Swift::String::Index)rawBits);
  swift_bridgeObjectRelease(a3);
  if (!v8) {
    return 0;
  }
  return rawBits;
}

BOOL specialized String.Index._foreignIsWithin(_:)(__int16 a1)
{
  return (a1 & 0xC000) == 0;
}

double specialized _StringGuts.decidePostFormatBackward(between:and:with:)(char a1, unsigned __int8 a2, uint64_t a3, __n128 a4)
{
  *(unsigned char *)(a3 + 57) = 18;
  switch(a1)
  {
    case 0:
      switch(a2)
      {
        case 0u:
        case 5u:
        case 7u:
        case 0xDu:
          goto LABEL_25;
        case 9u:
        case 0xBu:
        case 0xFu:
          goto LABEL_10;
        default:
          return a4.n128_f64[0];
      }
      return a4.n128_f64[0];
    case 2:
      if (a2 == 7)
      {
        uint64_t v4 = *(void *)(a3 + 40);
        a4 = (__n128)xmmword_18162B090;
        goto LABEL_36;
      }
      return a4.n128_f64[0];
    case 5:
      if (a2 <= 0xDu && (((1 << a2) & 0x2181) != 0 || a2 == 5)) {
        goto LABEL_25;
      }
      return a4.n128_f64[0];
    case 7:
      switch(a2)
      {
        case 0u:
        case 5u:
        case 7u:
        case 0xDu:
        case 0xFu:
          goto LABEL_25;
        case 2u:
          if (*(unsigned char *)(a3 + 32)) {
            return a4.n128_f64[0];
          }
          if ((*(unsigned char *)(a3 + 16) & 1) != 0 && *(_OWORD *)a3 >= 2uLL) {
            goto LABEL_53;
          }
          *(void *)(a3 + 4_assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0x6C706D6920746F6ELL, 0xEF6465746E656D65, "Swift/SliceBuffer.swift", 23, 2, 0x198uLL, 0) = *(void *)(a3 + 24);
          break;
        case 9u:
        case 0xBu:
LABEL_10:
          if (*(unsigned char *)(a3 + 32)) {
            return a4.n128_f64[0];
          }
          if ((*(unsigned char *)(a3 + 16) & 1) != 0 && *(_OWORD *)a3 == 0) {
            goto LABEL_53;
          }
          *(void *)(a3 + 4_assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0x6C706D6920746F6ELL, 0xEF6465746E656D65, "Swift/SliceBuffer.swift", 23, 2, 0x198uLL, 0) = *(void *)(a3 + 24);
          break;
        default:
          return a4.n128_f64[0];
      }
      return a4.n128_f64[0];
    case 8:
      if (a2 == 5 || a2 == 8) {
        goto LABEL_25;
      }
      return a4.n128_f64[0];
    case 9:
      int v5 = a2;
      if (a2) {
        goto LABEL_33;
      }
      goto LABEL_34;
    case 10:
      int v6 = a2;
      goto LABEL_22;
    case 11:
      int v6 = a2;
      if (!a2 || a2 == 7) {
        goto LABEL_34;
      }
LABEL_22:
      if (v6 == 13) {
        goto LABEL_35;
      }
      return a4.n128_f64[0];
    case 13:
      switch(a2)
      {
        case 0u:
        case 5u:
        case 7u:
        case 0xDu:
          goto LABEL_25;
        case 0xAu:
        case 0xBu:
        case 0xFu:
          if ((*(unsigned char *)(a3 + 32) & 1) == 0)
          {
            if ((*(unsigned char *)(a3 + 16) & 1) != 0 && !(*(void *)a3 ^ 1 | *(void *)(a3 + 8)))
            {
LABEL_53:
              a4.n128_u64[0] = 0;
              *(_OWORD *)a3 = 0u;
              *(_OWORD *)(a3 + 16) = 0u;
              *(unsigned char *)(a3 + 32) = 1;
              *(void *)(a3 + 48) = 0;
              *(unsigned char *)(a3 + 56) = 1;
            }
            else
            {
              *(void *)(a3 + 4_assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0x6C706D6920746F6ELL, 0xEF6465746E656D65, "Swift/SliceBuffer.swift", 23, 2, 0x198uLL, 0) = *(void *)(a3 + 24);
            }
          }
          break;
        default:
          return a4.n128_f64[0];
      }
      return a4.n128_f64[0];
    case 14:
      if (a2 == 14)
      {
        uint64_t v7 = *(void *)(a3 + 40);
        if (*(unsigned char *)(a3 + 32))
        {
          uint64_t v8 = 0;
          uint64_t v9 = *(void *)(a3 + 48);
          if (*(unsigned char *)(a3 + 56)) {
            uint64_t v9 = *(void *)(a3 + 40);
          }
        }
        else if (*(unsigned char *)(a3 + 16))
        {
          uint64_t v8 = 0;
          uint64_t v9 = *(void *)(a3 + 40);
        }
        else
        {
          uint64_t v8 = *(void *)a3 + 1;
          if (__OFADD__(*(void *)a3, 1))
          {
            __break(1u);
            JUMPOUT(0x1814F65A8);
          }
          uint64_t v9 = *(void *)(a3 + 24);
          if (*(void *)a3) {
            uint64_t v7 = *(void *)(a3 + 8);
          }
        }
        *(void *)a3 = v8;
        *(void *)(a3 + 8) = v7;
        *(void *)(a3 + 16) = 0;
        *(void *)(a3 + 24) = v9;
        *(unsigned char *)(a3 + 32) = 0;
LABEL_25:
        *(void *)(a3 + 48) = 0;
        *(unsigned char *)(a3 + 56) = 1;
      }
      return a4.n128_f64[0];
    case 15:
      int v5 = a2;
      if (!a2) {
        goto LABEL_34;
      }
      if (a2 == 13)
      {
LABEL_35:
        uint64_t v4 = *(void *)(a3 + 40);
        a4 = (__n128)xmmword_18162AD50;
LABEL_36:
        *(__n128 *)a3 = a4;
      }
      else
      {
LABEL_33:
        if (v5 != 7) {
          return a4.n128_f64[0];
        }
LABEL_34:
        uint64_t v4 = *(void *)(a3 + 40);
        *(void *)a3 = 0;
        *(void *)(a3 + 8) = 0;
      }
      *(void *)(a3 + 16) = 1;
      *(void *)(a3 + 24) = v4;
      *(unsigned char *)(a3 + 32) = 0;
      return a4.n128_f64[0];
    default:
      return a4.n128_f64[0];
  }
}

uint64_t specialized _StringGuts.nextWordBoundary(startingAt:nextScalar:)(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v6 = HIBYTE(a3) & 0xF;
  if ((a3 & 0x2000000000000000) == 0) {
    uint64_t v6 = a2 & 0xFFFFFFFFFFFFLL;
  }
  if (v6 <= a1)
  {
    swift_bridgeObjectRelease(a5);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/StringWordBreaking.swift", 30, 2, 0x9AuLL, 0);
  }
  unsigned int v8 = closure #1 in _StringGuts._foreignNextWordIndex(startingAt:)(a1, a4, a5);
  if (v10)
  {
    swift_bridgeObjectRelease(a5);
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/StringWordBreaking.swift", 30, 2, 0x9CuLL, 0);
  }
  unsigned int v11 = v8;
  uint64_t v12 = v9;
  unsigned int v13 = closure #1 in _StringGuts._foreignNextWordIndex(startingAt:)(v9, a4, a5);
  if (v15) {
    return v12;
  }
  uint64_t v16 = v14;
  int v36 = 0;
  uint64_t v17 = 0;
  unint64_t v37 = 0;
  char v38 = 0;
  int v18 = 18;
  char v19 = 1;
  do
  {
    unsigned int v23 = v11;
    unsigned int v11 = v13;
    if (v23 == 13 && v13 == 10) {
      goto LABEL_9;
    }
    if (v23 - 10 < 4 || v23 == 133 || v23 - 8234 >= 0xFFFFFFFE) {
      break;
    }
    switch(v23)
    {
      case 0x200Du:
        if (v13 >= 0xA)
        {
          if (v13 < 0xE || v13 == 133) {
            goto LABEL_281;
          }
          if (v13 >> 3 >= 0x405)
          {
            if (v13 < 0x202A) {
              goto LABEL_281;
            }
            int v25 = 17;
            if (v13 - 127488 < 0xFFFFFFE6)
            {
              LOBYTE(v24) = 17;
              goto LABEL_67;
            }
            goto LABEL_226;
          }
        }
        int v24 = 17;
        break;
      case 0x27u:
        if (v13 >= 0xA)
        {
          if (v13 < 0xE || v13 == 133) {
            goto LABEL_281;
          }
          if (v13 >> 3 >= 0x405)
          {
            if (v13 < 0x202A) {
              goto LABEL_281;
            }
            int v25 = 15;
            if (v13 - 127488 < 0xFFFFFFE6)
            {
              LOBYTE(v24) = 15;
              goto LABEL_67;
            }
LABEL_226:
            int v30 = 0;
            char v26 = 0;
            char v27 = 0;
            unsigned int v28 = 14;
            goto LABEL_232;
          }
        }
        int v24 = 15;
        break;
      case 0x22u:
        if (v13 >= 0xA)
        {
          if (v13 < 0xE || v13 == 133) {
            goto LABEL_281;
          }
          if (v13 >> 3 >= 0x405)
          {
            if (v13 < 0x202A) {
              goto LABEL_281;
            }
            int v25 = 2;
            if (v13 - 127488 < 0xFFFFFFE6)
            {
              LOBYTE(v24) = 2;
              goto LABEL_67;
            }
            goto LABEL_226;
          }
        }
        int v24 = 2;
        break;
      default:
        if (v23 - 127488 < 0xFFFFFFE6)
        {
          switch(_swift_stdlib_getWordBreakProperty(v23))
          {
            case 0u:
              if (v11 < 0xA) {
                goto LABEL_45;
              }
              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 < 0x405)
              {
LABEL_45:
                int v24 = 3;
                goto LABEL_33;
              }
              if (v11 < 0x202A) {
                goto LABEL_281;
              }
              int v25 = 3;
              if (v11 - 127488 >= 0xFFFFFFE6) {
                goto LABEL_226;
              }
              LOBYTE(v24) = 3;
              goto LABEL_67;
            case 1u:
              if (v11 < 0xA) {
                goto LABEL_89;
              }
              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 < 0x405)
              {
LABEL_89:
                int v24 = 6;
                goto LABEL_33;
              }
              if (v11 < 0x202A) {
                goto LABEL_281;
              }
              int v25 = 6;
              if (v11 - 127488 >= 0xFFFFFFE6) {
                goto LABEL_226;
              }
              LOBYTE(v24) = 6;
              goto LABEL_67;
            case 2u:
              if (v11 < 0xA)
              {
                int v24 = 8;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                int v25 = 8;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_198;
                }
                goto LABEL_226;
              }
              int v25 = 8;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205) {
                  goto LABEL_69;
                }
LABEL_198:
                LOBYTE(v24) = 8;
                goto LABEL_67;
              }
              goto LABEL_230;
            case 3u:
              if (v11 < 0xA)
              {
                int v24 = 7;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                int v25 = 7;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_201;
                }
                goto LABEL_226;
              }
              int v25 = 7;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205) {
                  goto LABEL_69;
                }
LABEL_201:
                LOBYTE(v24) = 7;
                goto LABEL_67;
              }
              goto LABEL_230;
            case 4u:
              if (v11 < 0xA)
              {
                int v25 = 0;
                LOBYTE(v24) = 0;
                goto LABEL_34;
              }
              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_204;
                }
                int v30 = 0;
                char v26 = 0;
                char v27 = 0;
                int v25 = 0;
                unsigned int v28 = 14;
                goto LABEL_232;
              }
              if (v11 == 34)
              {
                char v26 = 0;
                char v27 = 0;
                int v25 = 0;
                goto LABEL_38;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  int v18 = 0;
                  goto LABEL_9;
                }
LABEL_204:
                int v25 = 0;
                LOBYTE(v24) = 0;
                goto LABEL_67;
              }
              int v25 = 0;
              goto LABEL_230;
            case 5u:
              if (v11 < 0xA)
              {
                int v24 = 11;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                int v25 = 11;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_207;
                }
                goto LABEL_226;
              }
              int v25 = 11;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  int v18 = 11;
                  goto LABEL_9;
                }
LABEL_207:
                LOBYTE(v24) = 11;
                goto LABEL_67;
              }
              goto LABEL_230;
            case 6u:
              if (v11 < 0xA)
              {
                int v24 = 9;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                int v25 = 9;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_210;
                }
                goto LABEL_226;
              }
              int v25 = 9;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  int v18 = 9;
                  goto LABEL_9;
                }
LABEL_210:
                LOBYTE(v24) = 9;
                goto LABEL_67;
              }
              goto LABEL_230;
            case 7u:
              if (v11 < 0xA)
              {
                int v24 = 10;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                int v25 = 10;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_213;
                }
                goto LABEL_226;
              }
              int v25 = 10;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  int v18 = 10;
                  goto LABEL_9;
                }
LABEL_213:
                LOBYTE(v24) = 10;
                goto LABEL_67;
              }
              goto LABEL_230;
            case 8u:
              if (v11 < 0xA)
              {
                int v24 = 13;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                int v25 = 13;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_216;
                }
                goto LABEL_226;
              }
              int v25 = 13;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  int v18 = 13;
                  goto LABEL_9;
                }
LABEL_216:
                LOBYTE(v24) = 13;
                goto LABEL_67;
              }
              goto LABEL_230;
            case 9u:
              if (v11 < 0xA)
              {
                int v24 = 5;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                int v25 = 5;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_219;
                }
                goto LABEL_226;
              }
              int v25 = 5;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  int v18 = 5;
                  goto LABEL_9;
                }
LABEL_219:
                LOBYTE(v24) = 5;
                goto LABEL_67;
              }
              goto LABEL_230;
            case 0xAu:
              if (v11 < 0xA)
              {
                int v24 = 16;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                int v25 = 16;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_222;
                }
                goto LABEL_226;
              }
              int v25 = 16;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  int v18 = 16;
                  goto LABEL_9;
                }
LABEL_222:
                LOBYTE(v24) = 16;
                goto LABEL_67;
              }
              goto LABEL_230;
            case 0xBu:
              if (v11 < 0xA)
              {
                int v24 = 4;
                goto LABEL_33;
              }
              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                int v25 = 4;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_225;
                }
                goto LABEL_226;
              }
              int v25 = 4;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  int v18 = 4;
                  goto LABEL_9;
                }
LABEL_225:
                LOBYTE(v24) = 4;
                goto LABEL_67;
              }
              break;
            default:
              if (v11 < 0xA)
              {
                LOBYTE(v24) = 1;
                int v25 = 1;
                goto LABEL_67;
              }
              if (v11 < 0xE || v11 == 133) {
                goto LABEL_281;
              }
              if (v11 >> 3 > 0x404)
              {
                if (v11 < 0x202A) {
                  goto LABEL_281;
                }
                int v25 = 1;
                if (v11 - 127488 < 0xFFFFFFE6) {
                  goto LABEL_195;
                }
                goto LABEL_226;
              }
              int v25 = 1;
              if (v11 == 34) {
                goto LABEL_37;
              }
              if (v11 != 39)
              {
                if (v11 == 8205)
                {
                  int v18 = 1;
                  goto LABEL_9;
                }
LABEL_195:
                LOBYTE(v24) = 1;
                goto LABEL_67;
              }
              goto LABEL_230;
          }
          goto LABEL_230;
        }
        if (v13 < 0xA)
        {
          LOBYTE(v24) = 14;
          int v25 = 14;
          goto LABEL_67;
        }
        if (v13 < 0xE || v13 == 133) {
          goto LABEL_281;
        }
        if (v13 >> 3 > 0x404)
        {
          if (v13 < 0x202A) {
            goto LABEL_281;
          }
          int v25 = 14;
          if (v13 - 127488 >= 0xFFFFFFE6) {
            goto LABEL_226;
          }
        }
        else
        {
          int v25 = 14;
          switch(v13)
          {
            case 0x22u:
              goto LABEL_37;
            case 0x27u:
              goto LABEL_230;
            case 0x200Du:
              int v18 = 14;
              goto LABEL_9;
          }
        }
        LOBYTE(v24) = 14;
        goto LABEL_67;
    }
LABEL_33:
    int v25 = v24;
LABEL_34:
    if (v11 != 8205)
    {
      if (v11 != 39)
      {
        if (v11 == 34)
        {
LABEL_37:
          char v26 = 0;
          char v27 = 0;
LABEL_38:
          unsigned int v28 = 2;
LABEL_231:
          int v30 = 1;
LABEL_232:
          if (v18 == 18) {
            int v31 = v25;
          }
          else {
            int v31 = v18;
          }
          switch(v31)
          {
            case 0:
              if (v28 > 0xF) {
                goto LABEL_281;
              }
              int v32 = 1 << v28;
              if ((v32 & 0x20A1) != 0) {
                goto LABEL_272;
              }
              if ((v32 & 0x8A00) == 0) {
                goto LABEL_281;
              }
              goto LABEL_255;
            case 2:
              if ((v27 & 1) == 0) {
                goto LABEL_281;
              }
              if (v19) {
                return v12;
              }
              if ((v38 & 1) == 0) {
                return v17;
              }
              uint64_t v12 = v17;
              if (v37 < 2) {
                return v12;
              }
              goto LABEL_8;
            case 5:
              if (v28 > 0xD || ((1 << v28) & 0x21A1) == 0) {
                goto LABEL_281;
              }
              goto LABEL_272;
            case 7:
              if (v28 > 0xF) {
                goto LABEL_281;
              }
              if (((1 << v28) & 0xA0A1) != 0) {
                goto LABEL_272;
              }
              if (((1 << v28) & 0xA00) != 0)
              {
LABEL_255:
                unint64_t v37 = 0;
                char v19 = 0;
                int v18 = 18;
              }
              else
              {
                if (v28 != 2) {
                  goto LABEL_281;
                }
                char v19 = 0;
                int v18 = 18;
                uint64_t v34 = 2;
LABEL_279:
                unint64_t v37 = v34;
              }
              char v38 = 1;
              uint64_t v17 = v12;
              goto LABEL_9;
            case 8:
              int v18 = 18;
              if (v28 != 5 && v28 != 8) {
                goto LABEL_281;
              }
              goto LABEL_9;
            case 9:
              if (v28 && v28 != 7) {
                goto LABEL_281;
              }
              goto LABEL_261;
            case 10:
              if ((v26 & 1) == 0) {
                goto LABEL_281;
              }
              goto LABEL_266;
            case 11:
            case 15:
              if (!v28 || v28 == 7)
              {
LABEL_261:
                if (v19) {
                  return v12;
                }
                if ((v38 & 1) == 0) {
                  return v17;
                }
                uint64_t v12 = v17;
                if (v37) {
                  return v12;
                }
              }
              else
              {
                if (v28 != 13) {
                  goto LABEL_281;
                }
LABEL_266:
                if (v19) {
                  return v12;
                }
                if ((v38 & 1) == 0) {
                  return v17;
                }
                uint64_t v12 = v17;
                if (v37 != 1) {
                  return v12;
                }
              }
LABEL_8:
              unint64_t v37 = 0;
              char v38 = 0;
              uint64_t v17 = 0;
              int v18 = 18;
              char v19 = 1;
              break;
            case 13:
              if (v28 > 0xF) {
                goto LABEL_281;
              }
              int v33 = 1 << v28;
              if ((v33 & 0x20A1) != 0)
              {
LABEL_272:
                int v18 = 18;
                goto LABEL_9;
              }
              if ((v33 & 0x8C00) == 0) {
                goto LABEL_281;
              }
              char v19 = 0;
              int v18 = 18;
              uint64_t v34 = 1;
              goto LABEL_279;
            case 14:
              if ((v30 | v36)) {
                goto LABEL_281;
              }
              int v18 = 18;
              int v36 = 1;
              goto LABEL_9;
            default:
              goto LABEL_281;
          }
          goto LABEL_9;
        }
LABEL_67:
        int WordBreakProperty = _swift_stdlib_getWordBreakProperty(v11);
        char v26 = 0;
        char v27 = 0;
        unsigned int v28 = 8;
        int v30 = 1;
        switch(WordBreakProperty)
        {
          case 0:
          case 1:
            goto LABEL_68;
          case 2:
            goto LABEL_232;
          case 3:
            char v26 = 0;
            unsigned int v28 = 7;
            char v27 = 1;
            goto LABEL_232;
          case 4:
            char v26 = 0;
            char v27 = 0;
            unsigned int v28 = 0;
            goto LABEL_232;
          case 5:
            char v26 = 0;
            char v27 = 0;
            unsigned int v28 = 11;
            goto LABEL_232;
          case 6:
            char v26 = 0;
            char v27 = 0;
            unsigned int v28 = 9;
            goto LABEL_232;
          case 7:
            char v26 = 0;
            char v27 = 0;
            unsigned int v28 = 10;
            goto LABEL_232;
          case 8:
            char v27 = 0;
            unsigned int v28 = 13;
            char v26 = 1;
            goto LABEL_232;
          case 9:
            char v26 = 0;
            char v27 = 0;
            unsigned int v28 = 5;
            goto LABEL_232;
          case 10:
            if (v25 == 16) {
              goto LABEL_9;
            }
            char v26 = 0;
            char v27 = 0;
            unsigned int v28 = 16;
            break;
          case 11:
            if (v25 == 17) {
              goto LABEL_9;
            }
            char v26 = 0;
            char v27 = 0;
            unsigned int v28 = 4;
            break;
          default:
            if (v25 == 1) {
              goto LABEL_281;
            }
            char v26 = 0;
            char v27 = 0;
            int v30 = 1;
            unsigned int v28 = 1;
            break;
        }
        goto LABEL_232;
      }
LABEL_230:
      char v26 = 0;
      char v27 = 0;
      unsigned int v28 = 15;
      goto LABEL_231;
    }
LABEL_68:
    if (((1 << v24) & 0x20048) == 0) {
LABEL_69:
    }
      int v18 = v25;
LABEL_9:
    uint64_t v12 = v16;
    unsigned int v13 = closure #1 in _StringGuts._foreignNextWordIndex(startingAt:)(v16, a4, a5);
    uint64_t v16 = v21;
  }
  while ((v22 & 1) == 0);
LABEL_281:
  uint64_t v20 = v12;
  uint64_t v12 = v17;
  if (v19) {
    return v20;
  }
  return v12;
}

id outlined copy of _StringRepresentation._Form(id result, unsigned __int8 a2)
{
  if (a2 <= 1u) {
    return swift_unknownObjectRetain(result);
  }
  return result;
}

void outlined consume of _StringRepresentation._Form(id a1, unsigned __int8 a2)
{
  if (a2 <= 1u) {
    swift_unknownObjectRelease(a1);
  }
}

Class *type metadata accessor for SIMDMask(__int16 a1, uint64_t a2)
{
  return swift_getGenericMetadata(a1, a2, &nominal type descriptor for SIMDMask.Flags);
}

BOOL partial apply for specialized closure #1 in Sequence<>.contains(_:)(_DWORD *a1)
{
  return *a1 == **(_DWORD **)(v1 + 16);
}

uint64_t specialized Substring.init(cString:)(uint8x16_t *a1)
{
  size_t v2 = _swift_stdlib_strlen(a1->i8);
  if ((v2 & 0x8000000000000000) != 0) {
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  int64_t v3 = v2;
  int64_t v4 = validateUTF8(_:)(a1->i64, v2);
  if (v6) {
    repairUTF8(_:firstKnownBrokenRange:)(a1->i8, v3, v4, v5);
  }
  else {
    specialized static String._uncheckedFromUTF8(_:isASCII:)(a1, v3, v4 & 1);
  }
  return 15;
}

Swift::UInt64 specialized Substring.init(_:)(Swift::String::Index a1, Swift::String::Index a2)
{
  Swift::UInt64 rawBits = a1._rawBits;
  if ((a1._rawBits & 1) == 0)
  {
    Swift::UInt64 rawBits = a1._rawBits & 0xC | _StringGuts.scalarAlignSlow(_:)(a1)._rawBits & 0xFFFFFFFFFFFFFFF3 | 1;
    if (a2._rawBits) {
      return rawBits;
    }
LABEL_5:
    _StringGuts.scalarAlignSlow(_:)(a2)._rawBits;
    return rawBits;
  }
  if ((a2._rawBits & 1) == 0) {
    goto LABEL_5;
  }
  return rawBits;
}

uint64_t partial apply for closure #1 in Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)()
{
  return _StringGuts.replaceSubrange<A>(_:with:)(*(void *)(v0 + 32), *(void *)(v0 + 40), *(void *)(v0 + 48), *(void *)(v0 + 16), *(void *)(v0 + 24));
}

unint64_t lazy protocol witness table accessor for type UInt32 and conformance UInt32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt32 and conformance UInt32;
  if (!lazy protocol witness table cache variable for type UInt32 and conformance UInt32)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt32, (unint64_t *)&type metadata for UInt32, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt32 and conformance UInt32);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt32 and conformance UInt32;
  if (!lazy protocol witness table cache variable for type UInt32 and conformance UInt32)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt32, (unint64_t *)&type metadata for UInt32, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt32 and conformance UInt32);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt32 and conformance UInt32;
  if (!lazy protocol witness table cache variable for type UInt32 and conformance UInt32)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt32, (unint64_t *)&type metadata for UInt32, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt32 and conformance UInt32);
  }
  return result;
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt8>()
{
  return self;
}

Class *type metadata accessor for UnsafeMutablePointer(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for UnsafeMutablePointer.Flags);
}

Class *type metadata accessor for _UIntBuffer(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _UIntBuffer.Flags);
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.UTF8.ForwardParser, (unint64_t *)&type metadata for Unicode.UTF8.ForwardParser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.UTF8.ForwardParser, (unint64_t *)&type metadata for Unicode.UTF8.ForwardParser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF8.ForwardParser and conformance Unicode.UTF8.ForwardParser);
  }
  return result;
}

void sub_1814F80E0()
{
  swift_deallocObject(v0);
}

BOOL partial apply for closure #1 in LazySequenceProtocol.compactMap<A>(_:)(uint64_t a1)
{
  return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)(*(void *)(v1 + 24) - 8) + 48))(a1, 1) != 1;
}

void sub_1814F813C()
{
  swift_deallocObject(v0);
}

uint64_t outlined destroy of _PlaygroundQuickLook?(uint64_t a1)
{
  if (*(unsigned __int8 *)(a1 + 32) <= 0x12u) {
    destroy for _PlaygroundQuickLook(a1);
  }
  return a1;
}

uint64_t outlined init with take of _PlaygroundQuickLook(long long *a1, uint64_t a2)
{
  long long v2 = *a1;
  long long v3 = a1[1];
  *(unsigned char *)(a2 + 32) = *((unsigned char *)a1 + 32);
  *(_OWORD *)a2 = v2;
  *(_OWORD *)(a2 + 16) = v3;
  return a2;
}

Class *type metadata accessor for CollectionDifference.Change(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for CollectionDifference.Change.Flags);
}

void partial apply for closure #3 in CollectionDifference<A>.inferringMoves()(uint64_t a1@<X0>, void *a2@<X8>)
{
  closure #3 in CollectionDifference<A>.inferringMoves()(a1, v2[4], v2[5], v2[2], v2[3], a2);
}

Class *type metadata accessor for CollectionDifference.Change<A>._CodingKeys(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for CollectionDifference.Change<A>._CodingKeys.Flags);
}

unint64_t lazy protocol witness table accessor for type Int? and conformance <A> A?()
{
  unint64_t result = lazy protocol witness table cache variable for type Int? and conformance <A> A?;
  if (!lazy protocol witness table cache variable for type Int? and conformance <A> A?)
  {
    uint64_t v1 = &protocol witness table for Int;
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for <A> A?, qword_1ECA01F50, (uint64_t)&v1);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int? and conformance <A> A?);
  }
  return result;
}

{
  unint64_t result;
  _UNKNOWN **v1;

  unint64_t result = lazy protocol witness table cache variable for type Int? and conformance <A> A?;
  if (!lazy protocol witness table cache variable for type Int? and conformance <A> A?)
  {
    uint64_t v1 = &protocol witness table for Int;
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for <A> A?, qword_1ECA01F50, (uint64_t)&v1);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int? and conformance <A> A?);
  }
  return result;
}

Class *type metadata accessor for CollectionDifference.CodingKeys(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for CollectionDifference.CodingKeys.Flags);
}

uint64_t *partial apply for closure #1 in RangeReplaceableCollection.applying(_:)(uint64_t a1)
{
  return closure #1 in RangeReplaceableCollection.applying(_:)(a1, *(void **)(v1 + 32), *(void *)(v1 + 40), *(void *)(v1 + 48), *(void *)(v1 + 56), *(void (**)(char *, unsigned __int8 *, const char *))(v1 + 64), *(unsigned __int8 **)(v1 + 72), *(void *)(v1 + 16), *(void *)(v1 + 24));
}

Class *type metadata accessor for CollectionDifference(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for CollectionDifference.Flags);
}

void partial apply for closure #1 in _myers<A, B>(from:to:using:)(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
}

{
  uint64_t *v2;

  closure #1 in _myers<A, B>(from:to:using:)(a1, v2[6], v2[2], v2[3], v2[4], a2);
}

uint64_t partial apply for implicit closure #1 in BidirectionalCollection<>.difference<A>(from:)(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = v2[6];
  char v6 = *(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(v5 + 8);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(v2[4] + 8) + 8), v2[2], (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  return v6(a1, a2, AssociatedTypeWitness, v5) & 1;
}

unint64_t lazy protocol witness table accessor for type Int64 and conformance Int64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int64 and conformance Int64;
  if (!lazy protocol witness table cache variable for type Int64 and conformance Int64)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int64, (unint64_t *)&type metadata for Int64, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int64 and conformance Int64);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int64 and conformance Int64;
  if (!lazy protocol witness table cache variable for type Int64 and conformance Int64)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int64, (unint64_t *)&type metadata for Int64, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int64 and conformance Int64);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int64 and conformance Int64;
  if (!lazy protocol witness table cache variable for type Int64 and conformance Int64)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int64, (unint64_t *)&type metadata for Int64, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int64 and conformance Int64);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int64 and conformance Int64;
  if (!lazy protocol witness table cache variable for type Int64 and conformance Int64)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int64, (unint64_t *)&type metadata for Int64, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int64 and conformance Int64);
  }
  return result;
}

__objc2_class *specialized _SwiftNSMutableArray.countByEnumerating(with:objects:count:)(void *a1)
{
  if (*a1) {
    return 0;
  }
  uint64_t v4 = a1[3];
  uint64_t v5 = a1[4];
  uint64_t v6 = a1[5];
  uint64_t v7 = a1[6];
  uint64_t v8 = a1[7];
  unint64_t v9 = *(void *)(v1 + 16);
  if ((v9 & 0x8000000000000000) != 0 || (v9 & 0x4000000000000000) != 0)
  {
    unint64_t v11 = swift_bridgeObjectRetain(*(void *)(v1 + 16));
    uint64_t v12 = specialized _copyCollectionToContiguousArray<A>(_:)(v11);
    long long v2 = v12[2];
    *a1 = 1;
    a1[1] = v12 + 4;
    a1[2] = &_fastEnumerationStorageMutationsTarget;
    a1[3] = v4;
    a1[4] = v5;
    a1[5] = v6;
    a1[6] = v7;
    a1[7] = v8;
    swift_release((uint64_t)v12);
  }
  else
  {
    long long v2 = *(__objc2_class **)((v9 & 0xFFFFFFFFFFFFFF8) + 0x10);
    *a1 = 1;
    a1[1] = (v9 & 0xFFFFFFFFFFFFFF8) + 32;
    a1[2] = &_fastEnumerationStorageMutationsTarget;
    swift_bridgeObjectRetain(v9);
  }
  swift_bridgeObjectRelease(v9);
  return v2;
}

__objc2_class **specialized _SwiftNSMutableArray.copy(with:)()
{
  uint64_t v1 = *(void *)(v0 + 16);
  if ((unint64_t)v1 >> 62)
  {
    if (v1 < 0) {
      uint64_t v4 = *(void *)(v0 + 16);
    }
    else {
      uint64_t v4 = v1 & 0xFFFFFFFFFFFFFF8;
    }
    swift_bridgeObjectRetain(v1);
  }
  else
  {
    uint64_t v2 = one-time initialization token for _bridgeInitializedSuccessfully;
    swift_bridgeObjectRetain_n(v1, 2);
    if (v2 != -1) {
      swift_once(&one-time initialization token for _bridgeInitializedSuccessfully, (dispatch_function_t)one-time initialization function for _bridgeInitializedSuccessfully, v3);
    }
    if (!_bridgeInitializedSuccessfully) {
      _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "", 0, 2, "Swift/BridgeObjectiveC.swift", 28, 2, 0x82uLL, 0);
    }
    uint64_t v4 = v1 & 0xFFFFFFFFFFFFFF8;
    _orphanedFoundationSubclassesReparented = 1;
    if (*(void *)((v1 & 0xFFFFFFFFFFFFFF8) + 0x10))
    {
      uint64_t v5 = canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Swift.AnyObject>();
      swift_bridgeObjectRetain(v1);
      _swift_setClassMetadata(v5, (void *)(v1 & 0xFFFFFFFFFFFFFF8));
      swift_bridgeObjectRelease_n(v1, 2);
    }
    else
    {
      swift_bridgeObjectRelease_n(v1, 2);
      return &_swiftEmptyArrayStorage;
    }
  }
  return (__objc2_class **)v4;
}

uint64_t specialized static Unicode.UTF16.encode(_:into:)(unsigned int a1, void (*a2)(__int16 *))
{
  if (HIWORD(a1))
  {
    unsigned int v5 = ((a1 + 983040) >> 10) & 0x3FF | ((a1 & 0x3FF) << 16) | 0xDC00D800;
    __int16 v7 = ((a1 + 983040) >> 10) & 0x3FF | 0xD800;
    a2(&v7);
    __int16 v6 = HIWORD(v5);
    long long v3 = &v6;
  }
  else
  {
    __int16 v7 = a1;
    long long v3 = &v7;
  }
  return ((uint64_t (*)(__int16 *))a2)(v3);
}

uint64_t specialized Duration.init(_:scale:)(Swift::UInt64 a1, double a2)
{
  double v4 = trunc(a2);
  specialized static FixedWidthInteger._convert<A>(from:)((uint64_t)&v64, v4);
  if (v66)
  {
    unint64_t v10 = specialized static String._createEmpty(withInitialCapacity:)(80);
    unint64_t v12 = v11;
    unint64_t v64 = v10;
    unint64_t v65 = v11;
    TypeName = (uint64_t *)swift_getTypeName((Class *)&type metadata for Double, 0);
    if (v14 < 0) {
      goto LABEL_70;
    }
    char v15 = (uint8x16_t *)TypeName;
    int64_t v16 = v14;
    int64_t v17 = validateUTF8(_:)(TypeName, v14);
    if (v19) {
      unint64_t v20 = repairUTF8(_:firstKnownBrokenRange:)(v15->i8, v16, v17, v18);
    }
    else {
      unint64_t v20 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v15, v16, v17 & 1);
    }
    unint64_t v22 = v20;
    unint64_t v23 = v21;
    uint64_t v24 = HIBYTE(v12) & 0xF;
    if ((v12 & 0x2000000000000000) == 0) {
      uint64_t v24 = v10 & 0xFFFFFFFFFFFFLL;
    }
    if (!v24 && (v10 & ~v12 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v12);
      unint64_t v64 = v22;
      unint64_t v65 = v23;
      goto LABEL_25;
    }
    if ((v12 & 0x2000000000000000) != 0)
    {
      if ((v21 & 0x2000000000000000) != 0)
      {
        unint64_t v26 = specialized _SmallString.init(_:appending:)(v10, v12, v20, v21);
        if ((v28 & 1) == 0)
        {
          unint64_t v29 = v26;
          unint64_t v30 = v27;
          swift_bridgeObjectRelease(v12);
          swift_bridgeObjectRelease(v23);
          unint64_t v64 = v29;
          unint64_t v65 = v30;
          unint64_t v23 = v30;
          unint64_t v22 = v29;
          goto LABEL_25;
        }
        goto LABEL_23;
      }
    }
    else if ((v21 & 0x2000000000000000) != 0)
    {
LABEL_23:
      uint64_t v25 = HIBYTE(v23) & 0xF;
      goto LABEL_24;
    }
    uint64_t v25 = v20 & 0xFFFFFFFFFFFFLL;
LABEL_24:
    _StringGuts.append(_:)(v22, v23, 0, v25);
    swift_bridgeObjectRelease(v23);
    unint64_t v22 = v64;
    unint64_t v23 = v65;
LABEL_25:
    uint64_t v31 = HIBYTE(v23) & 0xF;
    if ((v23 & 0x2000000000000000) == 0) {
      uint64_t v31 = v22 & 0xFFFFFFFFFFFFLL;
    }
    if (v31 || (v22 & ~v23 & 0x2000000000000000) != 0)
    {
      if ((v23 & 0x2000000000000000) != 0
        && (0x80000001816DE7E0 & 0x2000000000000000) != 0
        && (unint64_t v32 = specialized _SmallString.init(_:appending:)(v22, v23, 0xD00000000000001ELL, 0x80000001816DE7E0 | 0x8000000000000000), (v34 & 1) == 0))
      {
        unint64_t v35 = v32;
        unint64_t v36 = v33;
        swift_bridgeObjectRelease(v23);
        swift_bridgeObjectRelease(0x80000001816DE7E0 | 0x8000000000000000);
        unint64_t v64 = v35;
        unint64_t v65 = v36;
      }
      else
      {
        if ((0x80000001816DE7E0 & 0x2000000000000000) != 0) {
          unint64_t v37 = (0x80000001816DE7E0 >> 56) & 0xF;
        }
        else {
          unint64_t v37 = 30;
        }
        _StringGuts.append(_:)(0xD00000000000001ELL, 0x80000001816DE7E0 | 0x8000000000000000, 0, v37);
        swift_bridgeObjectRelease(0x80000001816DE7E0 | 0x8000000000000000);
      }
    }
    else
    {
      swift_bridgeObjectRelease(v23);
      unint64_t v64 = 0xD00000000000001ELL;
      unint64_t v65 = 0x80000001816DE7E0 | 0x8000000000000000;
    }
    char v38 = (uint64_t *)swift_getTypeName((Class *)&type metadata for _Int128, 0);
    if ((v39 & 0x8000000000000000) == 0)
    {
      uint64_t v40 = (uint8x16_t *)v38;
      int64_t v41 = v39;
      int64_t v42 = validateUTF8(_:)(v38, v39);
      if (v44) {
        unint64_t v45 = repairUTF8(_:firstKnownBrokenRange:)(v40->i8, v41, v42, v43);
      }
      else {
        unint64_t v45 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v40, v41, v42 & 1);
      }
      unint64_t v47 = v45;
      unint64_t v48 = v46;
      uint64_t v49 = v65;
      unint64_t v50 = HIBYTE(v65) & 0xF;
      if ((v65 & 0x2000000000000000) == 0) {
        unint64_t v50 = v64 & 0xFFFFFFFFFFFFLL;
      }
      if (!v50 && (v64 & ~v65 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v65);
        unint64_t v64 = v47;
        unint64_t v65 = v48;
        goto LABEL_56;
      }
      if ((v65 & 0x2000000000000000) != 0)
      {
        if ((v46 & 0x2000000000000000) != 0)
        {
          unint64_t v52 = specialized _SmallString.init(_:appending:)(v64, v65, v45, v46);
          if ((v54 & 1) == 0)
          {
            unint64_t v55 = v52;
            unint64_t v56 = v53;
            swift_bridgeObjectRelease(v49);
            swift_bridgeObjectRelease(v48);
            unint64_t v64 = v55;
            unint64_t v65 = v56;
            unint64_t v48 = v56;
            unint64_t v47 = v55;
            goto LABEL_56;
          }
          goto LABEL_54;
        }
      }
      else if ((v46 & 0x2000000000000000) != 0)
      {
LABEL_54:
        uint64_t v51 = HIBYTE(v48) & 0xF;
        goto LABEL_55;
      }
      uint64_t v51 = v45 & 0xFFFFFFFFFFFFLL;
LABEL_55:
      _StringGuts.append(_:)(v47, v48, 0, v51);
      swift_bridgeObjectRelease(v48);
      unint64_t v47 = v64;
      unint64_t v48 = v65;
LABEL_56:
      uint64_t v57 = HIBYTE(v48) & 0xF;
      if ((v48 & 0x2000000000000000) == 0) {
        uint64_t v57 = v47 & 0xFFFFFFFFFFFFLL;
      }
      if (v57 || (v47 & ~v48 & 0x2000000000000000) != 0)
      {
        if ((v48 & 0x2000000000000000) != 0
          && (0x80000001816DE800 & 0x2000000000000000) != 0
          && (unint64_t v60 = specialized _SmallString.init(_:appending:)(v47, v48, 0xD00000000000002ELL, 0x80000001816DE800 | 0x8000000000000000), (v62 & 1) == 0))
        {
          uint64_t v59 = v60;
          unint64_t v58 = v61;
          swift_bridgeObjectRelease(v48);
          swift_bridgeObjectRelease(0x80000001816DE800 | 0x8000000000000000);
        }
        else
        {
          if ((0x80000001816DE800 & 0x2000000000000000) != 0) {
            unint64_t v63 = (0x80000001816DE800 >> 56) & 0xF;
          }
          else {
            unint64_t v63 = 46;
          }
          _StringGuts.append(_:)(0xD00000000000002ELL, 0x80000001816DE800 | 0x8000000000000000, 0, v63);
          swift_bridgeObjectRelease(0x80000001816DE800 | 0x8000000000000000);
          uint64_t v59 = v64;
          unint64_t v58 = v65;
        }
      }
      else
      {
        swift_bridgeObjectRelease(v48);
        unint64_t v58 = 0x80000001816DE800 | 0x8000000000000000;
        uint64_t v59 = 0xD00000000000002ELL;
      }
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v59, v58, "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
    }
LABEL_70:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  Swift::tuple_partialValue__Int128_overflow_Bool v68 = _Int128.multipliedReportingOverflow(by:)(a1);
  if (v68.overflow) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in multiplication", 26, 2, "Swift/LegacyInt128.swift", 24, 2, 0x30CuLL, 0);
  }
  Swift::UInt64 low = v68.partialValue.low;
  Swift::Int64 high = v68.partialValue.high;
  unint64_t v8 = specialized FixedWidthInteger.init<A>(_:)(round((a2 - v4) * (double)a1));

  return specialized static Duration.+ infix(_:_:)(low, high, v8, v7);
}

uint64_t specialized Duration.init(from:)(uint64_t *a1)
{
  uint64_t v2 = a1[3];
  uint64_t v3 = a1[4];
  __swift_project_boxed_opaque_existential_0Tm(a1, v2);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(v3 + 32))(v10, v2, v3);
  unint64_t v4 = v11;
  uint64_t v5 = v12;
  __swift_mutable_project_boxed_opaque_existential_1(v10, v11);
  (*(void (**)(unint64_t, uint64_t))(v5 + 112))(v4, v5);
  unint64_t v6 = v11;
  uint64_t v7 = v12;
  __swift_mutable_project_boxed_opaque_existential_1(v10, v11);
  uint64_t v8 = (*(uint64_t (**)(unint64_t, uint64_t))(v7 + 160))(v6, v7);
  __swift_destroy_boxed_opaque_existential_1Tm(v10);
  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  return v8;
}

unint64_t *specialized static Duration.-= infix(_:_:)(unint64_t *result, unint64_t a2, uint64_t a3)
{
  unint64_t v4 = *result;
  unint64_t v3 = result[1];
  BOOL v5 = __OFSUB__(v3, a3);
  unint64_t v6 = v3 - a3;
  int v7 = v5;
  BOOL v8 = v4 >= a2;
  unint64_t v9 = v4 - a2;
  if (v8)
  {
    if (v7) {
      goto LABEL_8;
    }
  }
  else
  {
    if (v6 == 0x8000000000000000) {
      LOBYTE(v7) = 1;
    }
    if (v7) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -", 13, 2, "Swift/LegacyInt128.swift", 24, 2, 0x252uLL, 0);
    --v6;
  }
  *unint64_t result = v9;
  result[1] = v6;
  return result;
}

uint64_t specialized static Duration./ infix(_:_:)(unint64_t a1, uint64_t a2, double a3)
{
  specialized static BinaryFloatingPoint<>._convert<A>(from:)((unint64_t *)&v59, a1, a2);
  specialized static FixedWidthInteger._convert<A>(from:)((uint64_t)&v59, v59 / a3);
  if (v61)
  {
    *(double *)&unint64_t v5 = COERCE_DOUBLE(specialized static String._createEmpty(withInitialCapacity:)(80));
    unint64_t v7 = v6;
    double v59 = *(double *)&v5;
    unint64_t v60 = v6;
    TypeName = (uint64_t *)swift_getTypeName((Class *)&type metadata for Double, 0);
    if (v9 < 0) {
      goto LABEL_66;
    }
    unint64_t v10 = (uint8x16_t *)TypeName;
    int64_t v11 = v9;
    int64_t v12 = validateUTF8(_:)(TypeName, v9);
    if (v14) {
      unint64_t v15 = repairUTF8(_:firstKnownBrokenRange:)(v10->i8, v11, v12, v13);
    }
    else {
      unint64_t v15 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v10, v11, v12 & 1);
    }
    unint64_t v17 = v15;
    unint64_t v18 = v16;
    uint64_t v19 = HIBYTE(v7) & 0xF;
    if ((v7 & 0x2000000000000000) == 0) {
      uint64_t v19 = v5 & 0xFFFFFFFFFFFFLL;
    }
    if (!v19 && (v5 & ~v7 & 0x2000000000000000) == 0)
    {
      swift_bridgeObjectRelease(v7);
      double v59 = *(double *)&v17;
      unint64_t v60 = v18;
      goto LABEL_21;
    }
    if ((v7 & 0x2000000000000000) != 0)
    {
      if ((v16 & 0x2000000000000000) != 0)
      {
        unint64_t v21 = specialized _SmallString.init(_:appending:)(v5, v7, v15, v16);
        if ((v23 & 1) == 0)
        {
          double v24 = *(double *)&v21;
          unint64_t v25 = v22;
          swift_bridgeObjectRelease(v7);
          swift_bridgeObjectRelease(v18);
          double v59 = v24;
          unint64_t v60 = v25;
          unint64_t v18 = v25;
          *(double *)&unint64_t v17 = v24;
          goto LABEL_21;
        }
        goto LABEL_19;
      }
    }
    else if ((v16 & 0x2000000000000000) != 0)
    {
LABEL_19:
      uint64_t v20 = HIBYTE(v18) & 0xF;
      goto LABEL_20;
    }
    uint64_t v20 = v15 & 0xFFFFFFFFFFFFLL;
LABEL_20:
    _StringGuts.append(_:)(v17, v18, 0, v20);
    swift_bridgeObjectRelease(v18);
    *(double *)&unint64_t v17 = v59;
    unint64_t v18 = v60;
LABEL_21:
    uint64_t v26 = HIBYTE(v18) & 0xF;
    if ((v18 & 0x2000000000000000) == 0) {
      uint64_t v26 = v17 & 0xFFFFFFFFFFFFLL;
    }
    if (v26 || (v17 & ~v18 & 0x2000000000000000) != 0)
    {
      if ((v18 & 0x2000000000000000) != 0
        && (0x80000001816DE7E0 & 0x2000000000000000) != 0
        && (unint64_t v27 = specialized _SmallString.init(_:appending:)(v17, v18, 0xD00000000000001ELL, 0x80000001816DE7E0 | 0x8000000000000000), (v29 & 1) == 0))
      {
        double v30 = *(double *)&v27;
        unint64_t v31 = v28;
        swift_bridgeObjectRelease(v18);
        swift_bridgeObjectRelease(0x80000001816DE7E0 | 0x8000000000000000);
        double v59 = v30;
        unint64_t v60 = v31;
      }
      else
      {
        if ((0x80000001816DE7E0 & 0x2000000000000000) != 0) {
          unint64_t v32 = (0x80000001816DE7E0 >> 56) & 0xF;
        }
        else {
          unint64_t v32 = 30;
        }
        _StringGuts.append(_:)(0xD00000000000001ELL, 0x80000001816DE7E0 | 0x8000000000000000, 0, v32);
        swift_bridgeObjectRelease(0x80000001816DE7E0 | 0x8000000000000000);
      }
    }
    else
    {
      swift_bridgeObjectRelease(v18);
      double v59 = -2.31584178e77;
      unint64_t v60 = 0x80000001816DE7E0 | 0x8000000000000000;
    }
    unint64_t v33 = (uint64_t *)swift_getTypeName((Class *)&type metadata for _Int128, 0);
    if ((v34 & 0x8000000000000000) == 0)
    {
      unint64_t v35 = (uint8x16_t *)v33;
      int64_t v36 = v34;
      int64_t v37 = validateUTF8(_:)(v33, v34);
      if (v39) {
        unint64_t v40 = repairUTF8(_:firstKnownBrokenRange:)(v35->i8, v36, v37, v38);
      }
      else {
        unint64_t v40 = specialized static String._uncheckedFromUTF8(_:isASCII:)(v35, v36, v37 & 1);
      }
      unint64_t v42 = v40;
      unint64_t v43 = v41;
      uint64_t v44 = v60;
      unint64_t v45 = HIBYTE(v60) & 0xF;
      if ((v60 & 0x2000000000000000) == 0) {
        unint64_t v45 = *(void *)&v59 & 0xFFFFFFFFFFFFLL;
      }
      if (!v45 && (*(void *)&v59 & ~v60 & 0x2000000000000000) == 0)
      {
        swift_bridgeObjectRelease(v60);
        double v59 = *(double *)&v42;
        unint64_t v60 = v43;
        goto LABEL_52;
      }
      if ((v60 & 0x2000000000000000) != 0)
      {
        if ((v41 & 0x2000000000000000) != 0)
        {
          unint64_t v47 = specialized _SmallString.init(_:appending:)(*(unint64_t *)&v59, v60, v40, v41);
          if ((v49 & 1) == 0)
          {
            double v50 = *(double *)&v47;
            unint64_t v51 = v48;
            swift_bridgeObjectRelease(v44);
            swift_bridgeObjectRelease(v43);
            double v59 = v50;
            unint64_t v60 = v51;
            unint64_t v43 = v51;
            *(double *)&unint64_t v42 = v50;
            goto LABEL_52;
          }
          goto LABEL_50;
        }
      }
      else if ((v41 & 0x2000000000000000) != 0)
      {
LABEL_50:
        uint64_t v46 = HIBYTE(v43) & 0xF;
        goto LABEL_51;
      }
      uint64_t v46 = v40 & 0xFFFFFFFFFFFFLL;
LABEL_51:
      _StringGuts.append(_:)(v42, v43, 0, v46);
      swift_bridgeObjectRelease(v43);
      *(double *)&unint64_t v42 = v59;
      unint64_t v43 = v60;
LABEL_52:
      uint64_t v52 = HIBYTE(v43) & 0xF;
      if ((v43 & 0x2000000000000000) == 0) {
        uint64_t v52 = v42 & 0xFFFFFFFFFFFFLL;
      }
      if (v52 || (v42 & ~v43 & 0x2000000000000000) != 0)
      {
        if ((v43 & 0x2000000000000000) != 0
          && (0x80000001816DE800 & 0x2000000000000000) != 0
          && (unint64_t v55 = specialized _SmallString.init(_:appending:)(v42, v43, 0xD00000000000002ELL, 0x80000001816DE800 | 0x8000000000000000), (v57 & 1) == 0))
        {
          uint64_t v54 = v55;
          unint64_t v53 = v56;
          swift_bridgeObjectRelease(v43);
          swift_bridgeObjectRelease(0x80000001816DE800 | 0x8000000000000000);
        }
        else
        {
          if ((0x80000001816DE800 & 0x2000000000000000) != 0) {
            unint64_t v58 = (0x80000001816DE800 >> 56) & 0xF;
          }
          else {
            unint64_t v58 = 46;
          }
          _StringGuts.append(_:)(0xD00000000000002ELL, 0x80000001816DE800 | 0x8000000000000000, 0, v58);
          swift_bridgeObjectRelease(0x80000001816DE800 | 0x8000000000000000);
          uint64_t v54 = *(void *)&v59;
          unint64_t v53 = v60;
        }
      }
      else
      {
        swift_bridgeObjectRelease(v43);
        unint64_t v53 = 0x80000001816DE800 | 0x8000000000000000;
        uint64_t v54 = 0xD00000000000002ELL;
      }
      _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, v54, v53, "Swift/Integers.swift", 20, 2, 0xBFFuLL, 0);
    }
LABEL_66:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeBufferPointer with negative count", 39, 2, "Swift/UnsafeBufferPointer.swift", 31, 2, 0x53FuLL, 0);
  }
  return *(void *)&v59;
}

uint64_t specialized Int128.init<A>(_:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  MEMORY[0x1F4188790](a1);
  unint64_t v6 = (char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  char v11 = 4;
  (*(void (**)(char *))(*(void *)(v7 + 16) + 304))(&v11);
  uint64_t result = Int128.init<A>(exactly:)(v6, a2, a3);
  if (v9) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000051, 0x80000001816E2A20, "Swift/Int128.swift", 18, 2, 0xD4uLL, 0);
  }
  return result;
}

void sub_1814F942C()
{
  swift_release(*(void *)(v0 + 24));
  swift_release(*(void *)(v0 + 48));

  swift_deallocObject(v0);
}

uint64_t outlined init with take of MirrorPath(long long *a1, uint64_t a2)
{
  long long v2 = *a1;
  long long v3 = a1[1];
  *(void *)(a2 + 32) = *((void *)a1 + 4);
  *(_OWORD *)a2 = v2;
  *(_OWORD *)(a2 + 16) = v3;
  return a2;
}

uint64_t outlined retain of Mirror(uint64_t a1)
{
  long long v2 = *(atomic_ullong **)(a1 + 32);
  swift_retain(*(atomic_ullong **)(a1 + 8));
  swift_retain(v2);
  return a1;
}

uint64_t specialized UInt128.init<A>(_:)(uint64_t a1, uint64_t a2, unint64_t a3)
{
  MEMORY[0x1F4188790](a1);
  unint64_t v6 = (char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  char v11 = 4;
  (*(void (**)(char *))(*(void *)(v7 + 16) + 304))(&v11);
  uint64_t result = UInt128.init<A>(exactly:)(v6, a2, a3);
  if (v9) {
    _assertionFailure(_:_:file:line:flags:)("Fatal error", 11, 2, 0xD000000000000052, 0x80000001816E2990, "Swift/UInt128.swift", 19, 2, 0xC6uLL, 0);
  }
  return result;
}

void sub_1814F95C0()
{
  swift_release(*(void *)(v0 + 32));

  swift_deallocObject(v0);
}

uint64_t partial apply for closure #1 in sequence<A>(first:next:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return closure #1 in sequence<A>(first:next:)(a1, *(void (**)(uint64_t))(v2 + 24), *(void *)(v2 + 32), *(void *)(v2 + 16), a2);
}

Class *type metadata accessor for UnfoldSequence(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for UnfoldSequence.Flags);
}

void *partial apply for closure #1 in UnsafeMutableRawBufferPointer.copyBytes<A>(from:)(const void *a1, size_t a2)
{
  return closure #1 in UnsafeMutableRawBufferPointer.copyBytes<A>(from:)(a1, a2, *(void *)(v2 + 32), *(void *)(v2 + 40), *(void *)(v2 + 48), *(void **)(v2 + 56), *(void *)(v2 + 16), *(void *)(v2 + 24));
}

uint64_t type metadata accessor for __VaListBuilder()
{
  return self;
}

void partial apply for closure #1 in SIMD.description.getter(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  closure #1 in SIMD.description.getter(a1, *(void *)(v2 + 16), *(void *)(v2 + 24), a2);
}

BOOL partial apply for specialized closure #1 in Sequence<>.contains(_:)(unsigned __int16 *a1)
{
  return *a1 == **(unsigned __int16 **)(v1 + 16);
}

unsigned char *partial apply for closure #1 in closure #1 in Float.init<A>(_:)@<X0>(unsigned char *a1@<X0>, BOOL *a2@<X8>)
{
  return partial apply for closure #1 in closure #1 in Float.init<A>(_:)(a1, (uint64_t (*)(void))_swift_stdlib_strtof_clocale, a2);
}

unsigned char *partial apply for closure #1 in closure #1 in Double.init<A>(_:)@<X0>(unsigned char *a1@<X0>, BOOL *a2@<X8>)
{
  return partial apply for closure #1 in closure #1 in Float.init<A>(_:)(a1, (uint64_t (*)(void))_swift_stdlib_strtod_clocale, a2);
}

__int16 specialized Float16.init(sign:exponent:significand:)@<H0>(char a1@<W0>, uint64_t a2@<X1>, float a3@<S0>)
{
  *(short float *)&__int16 result = -*(short float *)&a3;
  if ((a1 & 1) == 0) {
    __int16 result = SLOWORD(a3);
  }
  int v5 = (LODWORD(a3) >> 10) & 0x1F;
  if (v5 != 31 && (v5 | LOWORD(a3) & 0x3FF) != 0)
  {
    if (a2 > -15)
    {
      if (a2 >= 16)
      {
        if (a2 >= 45) {
          a2 = 45;
        }
        do
        {
          a2 -= 15;
          *(short float *)&__int16 result = *(short float *)&result * COERCE_SHORT_FLOAT(30720);
        }
        while ((unint64_t)a2 > 0xF);
      }
    }
    else
    {
      uint64_t v7 = -42;
      if (a2 > -42) {
        uint64_t v7 = a2;
      }
      do
      {
        LOWORD(a2) = v7 + 14;
        *(short float *)&__int16 result = *(short float *)&result * COERCE_SHORT_FLOAT(1024);
        BOOL v8 = __CFADD__(v7, 28);
        v7 += 14;
      }
      while (!v8);
    }
    *(short float *)&__int16 result = *(short float *)&result * COERCE_SHORT_FLOAT((((_WORD)a2 << 10) + 15360) & 0x7C00);
  }
  return result;
}

float _stdlib_squareRootf(float a1)
{
  return sqrtf(a1);
}

float specialized Float.init(sign:exponent:significand:)(char a1, uint64_t a2, float a3)
{
  float result = -a3;
  if ((a1 & 1) == 0) {
    float result = a3;
  }
  int v5 = (LODWORD(a3) >> 23);
  if (v5 != 255 && v5 | LODWORD(a3) & 0x7FFFFF)
  {
    if (a2 > -127)
    {
      if (a2 >= 128)
      {
        if (a2 >= 381) {
          a2 = 381;
        }
        do
        {
          a2 -= 127;
          float result = result * 1.7014e38;
        }
        while ((unint64_t)a2 > 0x7F);
      }
    }
    else
    {
      if (a2 <= -378) {
        uint64_t v6 = -378;
      }
      else {
        uint64_t v6 = a2;
      }
      do
      {
        LODWORD(a2) = v6 + 126;
        float result = result * 1.1755e-38;
        BOOL v7 = __CFADD__(v6, 252);
        v6 += 126;
      }
      while (!v7);
    }
    return result * COERCE_FLOAT(((a2 << 23) + 1065353216) & 0x7F800000);
  }
  return result;
}

double specialized Double.init(sign:exponent:significand:)(char a1, uint64_t a2, double a3)
{
  double result = -a3;
  if ((a1 & 1) == 0) {
    double result = a3;
  }
  uint64_t v5 = (*(void *)&a3 >> 52) & 0x7FFLL;
  if (v5 != 2047 && v5 | *(void *)&a3 & 0xFFFFFFFFFFFFFLL)
  {
    if (a2 > -1023)
    {
      if (a2 >= 1024)
      {
        if (a2 >= 3069) {
          a2 = 3069;
        }
        do
        {
          a2 -= 1023;
          double result = result * 8.98846567e307;
        }
        while ((unint64_t)a2 > 0x3FF);
      }
    }
    else
    {
      if (a2 <= -3066) {
        uint64_t v6 = -3066;
      }
      else {
        uint64_t v6 = a2;
      }
      do
      {
        a2 = v6 + 1022;
        double result = result * 2.22507386e-308;
        BOOL v7 = __CFADD__(v6, 2044);
        v6 += 1022;
      }
      while (!v7);
    }
    return result * COERCE_DOUBLE(((a2 << 52) + 0x3FF0000000000000) & 0x7FF0000000000000);
  }
  return result;
}

double _stdlib_squareRoot(double a1)
{
  return sqrt(a1);
}

Class *type metadata accessor for UnsafeMutableBufferPointer(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for UnsafeMutableBufferPointer.Flags);
}

uint64_t partial apply for thunk for @callee_guaranteed (@unowned UnsafeMutableBufferPointer<A1>) -> (@out B1, @error @owned Error)(uint64_t a1, uint64_t a2, void *a3)
{
  return partial apply for thunk for @callee_guaranteed (@unowned UnsafeMutableBufferPointer<A1>) -> (@out B1, @error @owned Error)(a1, a2, a3);
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  double result = (*(uint64_t (**)(void))(v3 + 40))();
  if (v4) {
    *a3 = v4;
  }
  return result;
}

uint64_t partial apply for thunk for @callee_guaranteed (@unowned UnsafeBufferPointer<A1>) -> (@out B1, @error @owned Error)(uint64_t a1, uint64_t a2, void *a3)
{
  return partial apply for thunk for @callee_guaranteed (@unowned UnsafeMutableBufferPointer<A1>) -> (@out B1, @error @owned Error)(a1, a2, a3);
}

Class *type metadata accessor for SIMD2(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for SIMD2.Flags);
}

unint64_t *specialized static _UInt128.-= infix(_:_:)(unint64_t *result, unint64_t a2, unint64_t a3)
{
  unint64_t v4 = *result;
  unint64_t v3 = result[1];
  BOOL v5 = v3 >= a3;
  unint64_t v6 = v3 - a3;
  int v7 = !v5;
  BOOL v5 = v4 >= a2;
  unint64_t v8 = v4 - a2;
  if (v5)
  {
    if (v7) {
      goto LABEL_8;
    }
  }
  else
  {
    if (!v6) {
      LOBYTE(v7) = 1;
    }
    if (v7) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x65uLL, 0);
    --v6;
  }
  *double result = v8;
  result[1] = v6;
  return result;
}

unint64_t *specialized static _UInt128.*= infix(_:_:)(unint64_t *result, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = *result;
  unint64_t v4 = result[1];
  BOOL v5 = !is_mul_ok(v4, a2);
  BOOL v6 = !is_mul_ok(*result, a3);
  unint64_t v7 = v4 * a2 + *result * a3;
  BOOL v8 = __CFADD__(v4 * a2, *result * a3);
  uint64_t v9 = (v3 * (unsigned __int128)a2) >> 64;
  BOOL v10 = __CFADD__(v7, v9);
  unint64_t v11 = v7 + v9;
  int v12 = v10;
  if (a3) {
    BOOL v13 = v4 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13 || v5 || v6 || v8 || v12) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in *=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0xA9uLL, 0);
  }
  *double result = v3 * a2;
  result[1] = v11;
  return result;
}

Swift::UInt64 specialized static _UInt128./= infix(_:_:)(Swift::UInt64 *a1, unint64_t a2, unint64_t a3)
{
  if (!(a3 | a2)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in /=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x1CEuLL, 0);
  }
  v9.Swift::UInt64 low = a1[1];
  v9.Swift::Int64 high = (Swift::UInt64)&v6;
  Swift::UInt64 result = specialized _wideDivide22<A>(_:by:)(&v8, &v7, v9, *a1, a3, a2);
  *a1 = v8;
  a1[1] = result;
  return result;
}

Swift::UInt64 specialized static _UInt128.%= infix(_:_:)(Swift::UInt64 *a1, unint64_t a2, unint64_t a3)
{
  if (!(a3 | a2)) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in %=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x1DCuLL, 0);
  }
  v10.Swift::UInt64 low = a1[1];
  v10.Swift::Int64 high = (Swift::UInt64)&v7;
  Swift::UInt64 result = specialized _wideDivide22<A>(_:by:)(&v9, &v8, v10, *a1, a3, a2);
  Swift::UInt64 v6 = v8;
  *a1 = v7;
  a1[1] = v6;
  return result;
}

unint64_t *specialized static _Int128.-= infix(_:_:)(unint64_t *result, unint64_t a2, uint64_t a3)
{
  unint64_t v4 = *result;
  unint64_t v3 = result[1];
  BOOL v5 = __OFSUB__(v3, a3);
  unint64_t v6 = v3 - a3;
  int v7 = v5;
  BOOL v8 = v4 >= a2;
  unint64_t v9 = v4 - a2;
  if (v8)
  {
    if (v7) {
      goto LABEL_8;
    }
  }
  else
  {
    if (v6 == 0x8000000000000000) {
      LOBYTE(v7) = 1;
    }
    if (v7) {
LABEL_8:
    }
      _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Overflow in -=", 14, 2, "Swift/LegacyInt128.swift", 24, 2, 0x258uLL, 0);
    --v6;
  }
  *Swift::UInt64 result = v9;
  result[1] = v6;
  return result;
}

Class *type metadata accessor for SIMD4(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for SIMD4.Flags);
}

uint64_t specialized SIMD4.lowHalf.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v22 = a4;
  v21[1] = a1;
  uint64_t v5 = *(void *)(a2 + 16);
  MEMORY[0x1F4188790](a1);
  int v7 = (char *)v21 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  unint64_t v9 = *(int ***)(v8 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v9, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v9, v5, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD2Storage: SIMDStorage);
  v21[0] = *(void *)(AssociatedConformanceWitness + 56);
  int v12 = (void (*)(void, uint64_t *, uint64_t))v21[0];
  BOOL v13 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  v12(0, v13, AssociatedConformanceWitness);
  char v14 = swift_getAssociatedTypeWitness(255, v9, v5, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t v15 = swift_getAssociatedConformanceWitness((uint64_t)v9, v5, (uint64_t)v14, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  unint64_t v16 = *(void (**)(char *, uint64_t, uint64_t *, uint64_t))(v15 + 64);
  unint64_t v17 = swift_checkMetadataState(0, (uint64_t)v14);
  v16(v7, a3, v17, v15);
  unint64_t v18 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  ((void (*)(uint64_t, uint64_t *, uint64_t))v21[0])(1, v18, AssociatedConformanceWitness);
  uint64_t v19 = swift_checkMetadataState(0, (uint64_t)v14);
  return ((uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t))v16)(v7, v22, v19, v15);
}

Class *type metadata accessor for SIMD8(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for SIMD8.Flags);
}

uint64_t specialized SIMD8.lowHalf.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v36 = a5;
  uint64_t v37 = a6;
  uint64_t v34 = a3;
  uint64_t v35 = a4;
  uint64_t v38 = a1;
  uint64_t v6 = *(void *)(a2 + 16);
  MEMORY[0x1F4188790](a1);
  uint64_t v8 = (char *)&v30 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  Swift::tuple_high_UInt64_low_UInt64 v10 = *(int ***)(v9 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v10, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v10, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD4Storage: SIMDStorage);
  unint64_t v33 = *(void (**)(void, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  BOOL v13 = v33;
  char v14 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v31 = AssociatedConformanceWitness;
  v13(0, v14, AssociatedConformanceWitness);
  uint64_t v15 = swift_getAssociatedTypeWitness(255, v10, v6, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t v16 = swift_getAssociatedConformanceWitness((uint64_t)v10, v6, (uint64_t)v15, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  double v30 = *(void (**)(char *, uint64_t, uint64_t *, uint64_t))(v16 + 64);
  unint64_t v17 = v30;
  unint64_t v18 = swift_checkMetadataState(0, (uint64_t)v15);
  v17(v8, v34, v18, v16);
  unint64_t v32 = AssociatedTypeWitness;
  uint64_t v19 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v20 = AssociatedConformanceWitness;
  unint64_t v21 = v33;
  v33(1, v19, v20);
  uint64_t v22 = swift_checkMetadataState(0, (uint64_t)v15);
  char v23 = v30;
  v30(v8, v35, v22, v16);
  double v24 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
  uint64_t v25 = v31;
  v21(2, v24, v31);
  uint64_t v26 = swift_checkMetadataState(0, (uint64_t)v15);
  v23(v8, v36, v26, v16);
  unint64_t v27 = swift_checkMetadataState(0, (uint64_t)v32);
  v21(3, v27, v25);
  unint64_t v28 = swift_checkMetadataState(0, (uint64_t)v15);
  return ((uint64_t (*)(char *, uint64_t, uint64_t *, uint64_t))v23)(v8, v37, v28, v16);
}

uint64_t specialized SIMD16.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1F4188790](a1);
  unint64_t v4 = (char *)&v15 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = *(int ***)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v8 = 0;
  uint64_t v16 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v17 = AssociatedConformanceWitness;
  do
  {
    uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
    v16(v8, v9, v17);
    Swift::tuple_high_UInt64_low_UInt64 v10 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
    uint64_t v11 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
    int v12 = *(uint64_t (**)(char *, uint64_t, uint64_t *, uint64_t))(v11 + 64);
    BOOL v13 = swift_checkMetadataState(0, (uint64_t)v10);
    uint64_t result = v12(v4, v8++, v13, v11);
  }
  while (v8 != 8);
  return result;
}

Class *type metadata accessor for SIMD16(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for SIMD16.Flags);
}

uint64_t specialized SIMD16.highHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1F4188790](a1);
  unint64_t v4 = (char *)&v15 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = *(int ***)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v8 = 0;
  uint64_t v15 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
    v15(v8, v9, AssociatedConformanceWitness);
    Swift::tuple_high_UInt64_low_UInt64 v10 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
    uint64_t v11 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
    int v12 = *(uint64_t (**)(char *, uint64_t, uint64_t *, uint64_t))(v11 + 64);
    BOOL v13 = swift_checkMetadataState(0, (uint64_t)v10);
    uint64_t result = v12(v4, v8 + 8, v13, v11);
    ++v8;
  }
  while (v8 != 8);
  return result;
}

uint64_t specialized SIMD16.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1F4188790](a1);
  unint64_t v4 = (char *)&v17 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = *(int ***)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  unint64_t v18 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v19 = AssociatedConformanceWitness;
  do
  {
    uint64_t v10 = v9 + 1;
    uint64_t v11 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
    v18(v9, v11, v19);
    int v12 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
    uint64_t v13 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
    char v14 = *(uint64_t (**)(char *, uint64_t, uint64_t *, uint64_t))(v13 + 64);
    uint64_t v15 = swift_checkMetadataState(0, (uint64_t)v12);
    uint64_t result = v14(v4, v8, v15, v13);
    v8 += 2;
    uint64_t v9 = v10;
  }
  while (v10 != 8);
  return result;
}

uint64_t specialized SIMD16.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1F4188790](a1);
  unint64_t v4 = (char *)&v17 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = *(int ***)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD8Storage: SIMDStorage);
  uint64_t v8 = 0;
  unint64_t v18 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v19 = AssociatedConformanceWitness;
  uint64_t v9 = 1;
  do
  {
    uint64_t v10 = v8 + 1;
    uint64_t v11 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
    v18(v8, v11, v19);
    int v12 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
    uint64_t v13 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
    char v14 = *(uint64_t (**)(char *, uint64_t, uint64_t *, uint64_t))(v13 + 64);
    uint64_t v15 = swift_checkMetadataState(0, (uint64_t)v12);
    uint64_t result = v14(v4, v9, v15, v13);
    v9 += 2;
    uint64_t v8 = v10;
  }
  while (v10 != 8);
  return result;
}

uint64_t specialized SIMD32.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1F4188790](a1);
  unint64_t v4 = (char *)&v15 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = *(int ***)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v8 = 0;
  uint64_t v16 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v17 = AssociatedConformanceWitness;
  do
  {
    uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
    v16(v8, v9, v17);
    uint64_t v10 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
    uint64_t v11 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
    int v12 = *(uint64_t (**)(char *, uint64_t, uint64_t *, uint64_t))(v11 + 64);
    uint64_t v13 = swift_checkMetadataState(0, (uint64_t)v10);
    uint64_t result = v12(v4, v8++, v13, v11);
  }
  while (v8 != 16);
  return result;
}

Class *type metadata accessor for SIMD32(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for SIMD32.Flags);
}

uint64_t specialized SIMD32.highHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1F4188790](a1);
  unint64_t v4 = (char *)&v15 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = *(int ***)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v8 = 0;
  uint64_t v15 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
    v15(v8, v9, AssociatedConformanceWitness);
    uint64_t v10 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
    uint64_t v11 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
    int v12 = *(uint64_t (**)(char *, uint64_t, uint64_t *, uint64_t))(v11 + 64);
    uint64_t v13 = swift_checkMetadataState(0, (uint64_t)v10);
    uint64_t result = v12(v4, v8 + 16, v13, v11);
    ++v8;
  }
  while (v8 != 16);
  return result;
}