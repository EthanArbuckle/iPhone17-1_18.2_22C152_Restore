uint64_t specialized SIMD32.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  int **v6;
  uint64_t AssociatedConformanceWitness;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  const char *v12;
  uint64_t v13;
  uint64_t (*v14)(char *, uint64_t, uint64_t *, uint64_t);
  uint64_t *v15;
  uint64_t result;
  uint64_t v17;
  void (*v18)(uint64_t, uint64_t *, uint64_t);
  uint64_t v19;
  const char *AssociatedTypeWitness;
  uint64_t v21;

  v21 = a1;
  v2 = *(void *)(a2 + 16);
  MEMORY[0x1F4188790](a1);
  v4 = (char *)&v17 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(int ***)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  v8 = 0;
  v9 = 0;
  v18 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  v19 = AssociatedConformanceWitness;
  do
  {
    v10 = v9 + 1;
    v11 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
    v18(v9, v11, v19);
    v12 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
    v13 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
    v14 = *(uint64_t (**)(char *, uint64_t, uint64_t *, uint64_t))(v13 + 64);
    v15 = swift_checkMetadataState(0, (uint64_t)v12);
    result = v14(v4, v8, v15, v13);
    v8 += 2;
    v9 = v10;
  }
  while (v10 != 16);
  return result;
}

uint64_t specialized SIMD32.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1F4188790](a1);
  v4 = (char *)&v17 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(int ***)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);
  uint64_t v8 = 0;
  v18 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v19 = AssociatedConformanceWitness;
  uint64_t v9 = 1;
  do
  {
    uint64_t v10 = v8 + 1;
    v11 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
    v18(v8, v11, v19);
    v12 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
    uint64_t v13 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
    v14 = *(uint64_t (**)(char *, uint64_t, uint64_t *, uint64_t))(v13 + 64);
    v15 = swift_checkMetadataState(0, (uint64_t)v12);
    uint64_t result = v14(v4, v9, v15, v13);
    v9 += 2;
    uint64_t v8 = v10;
  }
  while (v10 != 16);
  return result;
}

uint64_t specialized SIMD64.lowHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1F4188790](a1);
  v4 = (char *)&v15 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(int ***)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v8 = 0;
  v16 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v17 = AssociatedConformanceWitness;
  do
  {
    uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
    v16(v8, v9, v17);
    uint64_t v10 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
    uint64_t v11 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
    v12 = *(uint64_t (**)(char *, uint64_t, uint64_t *, uint64_t))(v11 + 64);
    uint64_t v13 = swift_checkMetadataState(0, (uint64_t)v10);
    uint64_t result = v12(v4, v8++, v13, v11);
  }
  while (v8 != 32);
  return result;
}

Class *type metadata accessor for SIMD64(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for SIMD64.Flags);
}

uint64_t specialized SIMD64.highHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1F4188790](a1);
  v4 = (char *)&v15 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(int ***)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v8 = 0;
  uint64_t v15 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  do
  {
    uint64_t v9 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
    v15(v8, v9, AssociatedConformanceWitness);
    uint64_t v10 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
    uint64_t v11 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
    v12 = *(uint64_t (**)(char *, uint64_t, uint64_t *, uint64_t))(v11 + 64);
    uint64_t v13 = swift_checkMetadataState(0, (uint64_t)v10);
    uint64_t result = v12(v4, v8 + 32, v13, v11);
    ++v8;
  }
  while (v8 != 32);
  return result;
}

uint64_t specialized SIMD64.evenHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1F4188790](a1);
  v4 = (char *)&v17 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(int ***)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  v18 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v19 = AssociatedConformanceWitness;
  do
  {
    uint64_t v10 = v9 + 1;
    uint64_t v11 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
    v18(v9, v11, v19);
    v12 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
    uint64_t v13 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
    v14 = *(uint64_t (**)(char *, uint64_t, uint64_t *, uint64_t))(v13 + 64);
    uint64_t v15 = swift_checkMetadataState(0, (uint64_t)v12);
    uint64_t result = v14(v4, v8, v15, v13);
    v8 += 2;
    uint64_t v9 = v10;
  }
  while (v10 != 32);
  return result;
}

uint64_t specialized SIMD64.oddHalf.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = a1;
  uint64_t v2 = *(void *)(a2 + 16);
  MEMORY[0x1F4188790](a1);
  v4 = (char *)&v17 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v6 = *(int ***)(v5 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD32Storage: SIMDStorage);
  uint64_t v8 = 0;
  v18 = *(void (**)(uint64_t, uint64_t *, uint64_t))(AssociatedConformanceWitness + 56);
  uint64_t v19 = AssociatedConformanceWitness;
  uint64_t v9 = 1;
  do
  {
    uint64_t v10 = v8 + 1;
    uint64_t v11 = swift_checkMetadataState(0, (uint64_t)AssociatedTypeWitness);
    v18(v8, v11, v19);
    v12 = swift_getAssociatedTypeWitness(255, v6, v2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
    uint64_t v13 = swift_getAssociatedConformanceWitness((uint64_t)v6, v2, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD64Storage: SIMDStorage);
    v14 = *(uint64_t (**)(char *, uint64_t, uint64_t *, uint64_t))(v13 + 64);
    uint64_t v15 = swift_checkMetadataState(0, (uint64_t)v12);
    uint64_t result = v14(v4, v9, v15, v13);
    v9 += 2;
    uint64_t v8 = v10;
  }
  while (v10 != 32);
  return result;
}

Class *type metadata accessor for SIMD3(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for SIMD3.Flags);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in EnumeratedSequence<A>.Iterator(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable((int *)"xM\r", a1, a3);
}

uint64_t instantiation function for generic protocol witness table for _ArrayBuffer<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>(a1, a2, a3, protocol conformance descriptor for _ArrayBuffer<A>, protocol conformance descriptor for _ArrayBuffer<A>);
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for _ArrayBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for _ArrayBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for _ArrayBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in _ArrayBuffer<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ArrayBuffer<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ArrayBuffer<A>(a1, a2, a3, protocol conformance descriptor for <> Range<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _ArrayBuffer<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in _ArrayBuffer<A>()
{
  return &protocol witness table for Int;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in _ArrayBuffer<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ArrayBuffer<A>(a1, a2, a3, protocol conformance descriptor for <> Range<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in _ArrayBuffer<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in _ArrayBuffer<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ArrayBuffer<A>(a1, a2, a3, protocol conformance descriptor for <> Range<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _ArrayBuffer<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _ArrayBuffer<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for IndexingIterator<A>, a1, a3);
}

uint64_t associated type witness table accessor for _ArrayProtocol._Buffer : _ArrayBufferProtocol in [A](unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for _ArrayBuffer<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for [A](uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>(a1, a2, a3, protocol conformance descriptor for [A], protocol conformance descriptor for [A]);
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for [A], a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for [A], a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for [A], a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in [A](unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for ArraySlice<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in [A](unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for ArraySlice<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in [A](unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for ArraySlice<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in [A](unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for ArraySlice<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RangeReplaceableCollection in [A](unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for ArraySlice<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for <A> [A](uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)a3 + 8);
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <A> [A], a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for _ArrayProtocol._Buffer : _ArrayBufferProtocol in ArraySlice<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for ArraySlice<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>(a1, a2, a3, protocol conformance descriptor for ArraySlice<A>, protocol conformance descriptor for ArraySlice<A>);
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for ArraySlice<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for ArraySlice<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for ArraySlice<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for <A> ArraySlice<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)a3 + 8);
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <A> ArraySlice<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type CollectionOfOne<UInt8> and conformance CollectionOfOne<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type CollectionOfOne<UInt8> and conformance CollectionOfOne<A>;
  if (!lazy protocol witness table cache variable for type CollectionOfOne<UInt8> and conformance CollectionOfOne<A>)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, qword_1EC9FFC78, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type CollectionOfOne<UInt8> and conformance CollectionOfOne<A>);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.ASCII.Parser and conformance Unicode.ASCII.Parser(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.ASCII.Parser and conformance Unicode.ASCII.Parser;
  if (!lazy protocol witness table cache variable for type Unicode.ASCII.Parser and conformance Unicode.ASCII.Parser)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.ASCII.Parser, (unint64_t *)&type metadata for Unicode.ASCII.Parser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.ASCII.Parser and conformance Unicode.ASCII.Parser);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.ASCII and conformance Unicode.ASCII(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.ASCII and conformance Unicode.ASCII;
  if (!lazy protocol witness table cache variable for type Unicode.ASCII and conformance Unicode.ASCII)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.ASCII, (unint64_t *)&type metadata for Unicode.ASCII, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.ASCII and conformance Unicode.ASCII);
  }
  return result;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _UnsafeBitset()
{
  return &protocol witness table for _UnsafeBitset.Iterator;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _UnsafeBitset.Word()
{
  return &protocol witness table for _UnsafeBitset.Word;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByBooleanLiteral.BooleanLiteralType : _ExpressibleByBuiltinBooleanLiteral in Bool()
{
  return &protocol witness table for Bool;
}

_UNKNOWN **associated type witness table accessor for Strideable.Stride : SignedNumeric in AutoreleasingUnsafeMutablePointer<A>()
{
  return &protocol witness table for Int;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByExtendedGraphemeClusterLiteral.ExtendedGraphemeClusterLiteralType : _ExpressibleByBuiltinExtendedGraphemeClusterLiteral in Character()
{
  return &protocol witness table for Character;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByUnicodeScalarLiteral.UnicodeScalarLiteralType : _ExpressibleByBuiltinUnicodeScalarLiteral in Character()
{
  return &protocol witness table for Character;
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in _CocoaArrayWrapper(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return lazy protocol witness table accessor for type Range<Int> and conformance <> Range<A>(&lazy protocol witness table cache variable for type Range<Int> and conformance <> Range<A>, protocol conformance descriptor for <> Range<A>, a3);
}

unint64_t lazy protocol witness table accessor for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>;
  if (!lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, qword_1EC9FFC38, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>;
  if (!lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, qword_1EC9FFC38, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>;
  if (!lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, qword_1EC9FFC38, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _SliceBuffer<Swift.AnyObject> and conformance _SliceBuffer<A>);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for _CocoaArrayWrapper(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper;
  if (!lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _CocoaArrayWrapper, (unint64_t *)&type metadata for _CocoaArrayWrapper, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper;
  if (!lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _CocoaArrayWrapper, (unint64_t *)&type metadata for _CocoaArrayWrapper, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper;
  if (!lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _CocoaArrayWrapper, (unint64_t *)&type metadata for _CocoaArrayWrapper, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _CocoaArrayWrapper and conformance _CocoaArrayWrapper);
  }
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in _CocoaArrayWrapper(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return lazy protocol witness table accessor for type Range<Int> and conformance <> Range<A>(&lazy protocol witness table cache variable for type Range<Int> and conformance <> Range<A>, protocol conformance descriptor for <> Range<A>, a3);
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in _CocoaArrayWrapper(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return lazy protocol witness table accessor for type Range<Int> and conformance <> Range<A>(&lazy protocol witness table cache variable for type Range<Int> and conformance <> Range<A>, protocol conformance descriptor for <> Range<A>, a3);
}

uint64_t lazy protocol witness table accessor for type Range<Int> and conformance <> Range<A>(unint64_t *a1, int *a2, uint64_t a3)
{
  uint64_t result = *a1;
  if (!result)
  {
    v6[0] = &protocol witness table for Int;
    v6[1] = lazy protocol witness table accessor for type Int and conformance Int(0, (uint64_t)a2, a3);
    uint64_t result = swift_getWitnessTable(a2, qword_1EC9FFE50, (uint64_t)v6);
    atomic_store(result, a1);
  }
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _CocoaArrayWrapper()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<_CocoaArrayWrapper>, protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t associated type witness table accessor for _ArrayProtocol._Buffer : _ArrayBufferProtocol in ContiguousArray<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for _ContiguousArrayBuffer<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for ContiguousArray<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>(a1, a2, a3, protocol conformance descriptor for ContiguousArray<A>, protocol conformance descriptor for ContiguousArray<A>);
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for ContiguousArray<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for ContiguousArray<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for ContiguousArray<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for <A> ContiguousArray<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)a3 + 8);
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <A> ContiguousArray<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for RangeExpression.Bound : Comparable in ClosedRange<A>(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 24);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in <> ClosedRange<A>()
{
  return &protocol witness table for ClosedRange<A><>.Index;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in <> ClosedRange<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for DefaultIndices<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in <> ClosedRange<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for Slice<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for <> ClosedRange<A>(uint64_t a1, unint64_t *a2, long long *a3)
{
  long long v5 = *a3;
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <> ClosedRange<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  long long v5;

  long long v5 = *a3;
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <> ClosedRange<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  long long v5;

  long long v5 = *a3;
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <> ClosedRange<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>(a1, a2, a3, protocol conformance descriptor for <> ClosedRange<A>, protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> ClosedRange<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>(a1, a2, a3, protocol conformance descriptor for <> ClosedRange<A>, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in <> ClosedRange<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>(a1, a2, a3, protocol conformance descriptor for <> ClosedRange<A>, protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> ClosedRange<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>(a1, a2, a3, protocol conformance descriptor for <> ClosedRange<A>, protocol conformance descriptor for <> Slice<A>);
}

uint64_t instantiation function for generic protocol witness table for _ContiguousArrayBuffer<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>(a1, a2, a3, protocol conformance descriptor for _ContiguousArrayBuffer<A>, protocol conformance descriptor for _ContiguousArrayBuffer<A>);
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for _ContiguousArrayBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for _ContiguousArrayBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for _ContiguousArrayBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in __CocoaDictionary()
{
  return &protocol witness table for __CocoaDictionary.Iterator;
}

uint64_t instantiation function for generic protocol witness table for <> DiscontiguousSlice<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)a3 + 8);
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <> DiscontiguousSlice<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for DiscontiguousSlice<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in DiscontiguousSlice<A>()
{
  return &protocol witness table for DiscontiguousSlice<A>.Index;
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in DiscontiguousSlice<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for DiscontiguousSlice<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for DiscontiguousSlice<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for DiscontiguousSlice<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, protocol conformance descriptor for <> DiscontiguousSlice<A>, protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> DiscontiguousSlice<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(protocol conformance descriptor for <> DiscontiguousSlice<A>, a1, (uint64_t)&v4);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in LazyDropWhileSequence<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for LazyDropWhileSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in LazyDropWhileSequence<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for LazyDropWhileSequence<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for LazyDropWhileSequence<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  uint64_t v5 = *(void *)(*(void *)a3 + 8);
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <> LazyDropWhileSequence<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> LazyDropWhileSequence<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, protocol conformance descriptor for <> LazyDropWhileSequence<A>, protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> LazyDropWhileSequence<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, protocol conformance descriptor for <> LazyDropWhileSequence<A>, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Collection in <> LazyDropWhileSequence<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(protocol conformance descriptor for <> LazyDropWhileSequence<A>, a1, (uint64_t)&v4);
}

uint64_t instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  return instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>(a1, a2, a3, protocol conformance descriptor for <> LazyDropWhileSequence<A>, protocol conformance descriptor for LazyDropWhileSequence<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in EmptyCollection<A>.Iterator(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in EmptyCollection<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for EmptyCollection<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in EmptyCollection<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in EmptyCollection<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in EmptyCollection<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for EmptyCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in AnyIterator<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for AnyIterator<A>, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in AnyCollection<A>()
{
  return &protocol witness table for AnyIndex;
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in AnyCollection<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for AnyCollection<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for AnyCollection<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for AnyCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for AnyCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in AnyBidirectionalCollection<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for AnyBidirectionalCollection<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> DefaultIndices<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in AnyBidirectionalCollection<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for AnyBidirectionalCollection<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for AnyBidirectionalCollection<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for AnyBidirectionalCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for AnyBidirectionalCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in AnyBidirectionalCollection<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for AnyBidirectionalCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in AnyRandomAccessCollection<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for AnyRandomAccessCollection<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> DefaultIndices<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in AnyRandomAccessCollection<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for AnyRandomAccessCollection<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for AnyRandomAccessCollection<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for AnyRandomAccessCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for AnyRandomAccessCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for AnyRandomAccessCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in AnyRandomAccessCollection<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for AnyRandomAccessCollection<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> DefaultIndices<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in AnyRandomAccessCollection<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for AnyRandomAccessCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in AnyRandomAccessCollection<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for AnyRandomAccessCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in LazyFilterSequence<A>.Iterator(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for LazyFilterSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in LazyFilterSequence<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for LazyFilterSequence<A>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection, protocol conformance descriptor for <> LazyFilterSequence<A>);
}

uint64_t instantiation function for generic protocol witness table for <> LazyFilterSequence<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for LazyFilterSequence<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  uint64_t v5 = *(void *)(*(void *)a3 + 8);
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <> LazyFilterSequence<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Collection in <> LazyFilterSequence<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(protocol conformance descriptor for <> LazyFilterSequence<A>, a1, (uint64_t)&v4);
}

uint64_t instantiation function for generic protocol witness table for <> LazyFilterSequence<A>(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  return instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>(a1, a2, a3, protocol conformance descriptor for <> LazyFilterSequence<A>, protocol conformance descriptor for LazyFilterSequence<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> LazyFilterSequence<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, protocol conformance descriptor for <> LazyFilterSequence<A>, protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> LazyFilterSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for BidirectionalCollection, associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection, protocol conformance descriptor for <> LazyFilterSequence<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in FlattenSequence<A>.Iterator(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for FlattenSequence<A>.Iterator, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in <> FlattenSequence<A>()
{
  return &protocol witness table for FlattenSequence<A><>.Index;
}

uint64_t instantiation function for generic protocol witness table for <> FlattenSequence<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for FlattenSequence<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> FlattenSequence<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>(a1, a2, a3, protocol conformance descriptor for <> FlattenSequence<A>, protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> FlattenSequence<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>(a1, a2, a3, protocol conformance descriptor for <> FlattenSequence<A>, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> ClosedRange<A>(unint64_t *a1, unint64_t *a2, uint64_t a3, int *a4, int *a5)
{
  int8x16_t v9 = vextq_s8(*(int8x16_t *)(a3 - 16), *(int8x16_t *)(a3 - 16), 8uLL);
  uint64_t WitnessTable = swift_getWitnessTable(a4, a2, (uint64_t)&v9);
  return swift_getWitnessTable(a5, a1, (uint64_t)&WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for <> FlattenSequence<A>(uint64_t a1, unint64_t *a2, void *a3)
{
  return instantiation function for generic protocol witness table for <> FlattenSequence<A>(a1, a2, a3, protocol conformance descriptor for <> FlattenSequence<A>);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _HashTable()
{
  return &protocol witness table for _HashTable.Iterator;
}

uint64_t associated type witness table accessor for Collection.Index : Comparable in DefaultIndices<A>(uint64_t a1, uint64_t a2)
{
  return swift_getAssociatedConformanceWitness(*(void *)(a2 + 24), *(void *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
}

uint64_t instantiation function for generic protocol witness table for DefaultIndices<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for DefaultIndices<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> DefaultIndices<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(protocol conformance descriptor for <> DefaultIndices<A>, a1, (uint64_t)&v4);
}

uint64_t instantiation function for generic protocol witness table for <> DefaultIndices<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for DefaultIndices<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  uint64_t v5 = *(void *)(*(void *)a3 + 8);
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <> DefaultIndices<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> DefaultIndices<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(protocol conformance descriptor for <> DefaultIndices<A>, a1, (uint64_t)&v4);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in JoinedSequence<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for JoinedSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in KeyValuePairs<A, B>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for KeyValuePairs<A, B>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in KeyValuePairs<A, B>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for KeyValuePairs<A, B>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.Index : Comparable in <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getAssociatedConformanceWitness(*(void *)(a3 - 8), *(void *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Index: Comparable);
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getAssociatedConformanceWitness(*(void *)(a3 - 8), *(void *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Indices: Collection);
}

uint64_t instantiation function for generic protocol witness table for <> LazySequence<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for LazySequence<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  uint64_t v5 = *(void *)(*(void *)a3 + 8);
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <> LazySequence<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  uint64_t v5 = *(void *)(*(void *)a3 + 8);
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <> LazySequence<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Collection in <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(void *)(a3 - 8);
}

uint64_t instantiation function for generic protocol witness table for <> LazySequence<A>(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  return instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>(a1, a2, a3, protocol conformance descriptor for <> LazySequence<A>, protocol conformance descriptor for LazySequence<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getAssociatedConformanceWitness(*(void *)(a3 - 8), *(void *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for BidirectionalCollection, associated conformance descriptor for BidirectionalCollection.Collection.Indices: BidirectionalCollection);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> LazySequence<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, protocol conformance descriptor for <> LazySequence<A>, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in <> LazySequence<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return swift_getAssociatedConformanceWitness(*(void *)(a3 - 8), *(void *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for RandomAccessCollection, associated conformance descriptor for RandomAccessCollection.Collection.Indices: RandomAccessCollection);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> LazySequence<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, protocol conformance descriptor for <> LazySequence<A>, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in <> Slice<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for Slice<A>, a1, a3);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in <> ReversedCollection<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for ReversedCollection<A>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in LazySequence<A>(uint64_t a1, uint64_t a2)
{
  return swift_getAssociatedConformanceWitness(*(void *)(a2 + 24), *(void *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for Sequence, associated conformance descriptor for Sequence.Sequence.Iterator: IteratorProtocol);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in LazyMapSequence<A, B>.Iterator(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for LazyMapSequence<A, B>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in LazyMapSequence<A, B>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for LazyMapSequence<A, B>, a1, a3);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in <> LazyMapSequence<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.SubSequence: Collection, protocol conformance descriptor for <> LazyMapSequence<A, B>);
}

uint64_t instantiation function for generic protocol witness table for <> LazyMapSequence<A, B>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for LazyMapSequence<A, B>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  uint64_t v5 = *(void *)(*(void *)a3 + 8);
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <> LazyMapSequence<A, B>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  uint64_t v5 = *(void *)(*(void *)a3 + 8);
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <> LazyMapSequence<A, B>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> LazyMapSequence<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for BidirectionalCollection, associated conformance descriptor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection, protocol conformance descriptor for <> LazyMapSequence<A, B>);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Collection in <> LazyMapSequence<A, B>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(protocol conformance descriptor for <> LazyMapSequence<A, B>, a1, (uint64_t)&v4);
}

uint64_t instantiation function for generic protocol witness table for <> LazyMapSequence<A, B>(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  return instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>(a1, a2, a3, protocol conformance descriptor for <> LazyMapSequence<A, B>, protocol conformance descriptor for LazyMapSequence<A, B>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> LazyMapSequence<A, B>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for RandomAccessCollection, associated conformance descriptor for RandomAccessCollection.Collection.SubSequence: RandomAccessCollection, protocol conformance descriptor for <> LazyMapSequence<A, B>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in <> LazyFilterSequence<A>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, int *a6)
{
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness(*(void *)(a3 - 8), *(void *)(a2 + 16), *(void *)(a1 + 16), a4, a5);
  return swift_getWitnessTable(a6, (unint64_t *)a1, (uint64_t)&AssociatedConformanceWitness);
}

_UNKNOWN **associated type witness table accessor for ExpressibleByUnicodeScalarLiteral.UnicodeScalarLiteralType : _ExpressibleByBuiltinUnicodeScalarLiteral in Unicode.Scalar()
{
  return &protocol witness table for Unicode.Scalar;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Unicode.Scalar.UTF16View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF16View>, (uint64_t (*)(void))lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View, protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.Scalar.UTF16View, (unint64_t *)&type metadata for Unicode.Scalar.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.Scalar.UTF16View, (unint64_t *)&type metadata for Unicode.Scalar.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.Scalar.UTF16View, (unint64_t *)&type metadata for Unicode.Scalar.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.Scalar.UTF16View, (unint64_t *)&type metadata for Unicode.Scalar.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Unicode.Scalar.UTF16View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Unicode.Scalar.UTF16View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF16View>, (uint64_t (*)(void))lazy protocol witness table accessor for type Unicode.Scalar.UTF16View and conformance Unicode.Scalar.UTF16View, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Unicode.Scalar.UTF16View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF16View> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF16View>, protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Unicode.Scalar.UTF16View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Unicode.Scalar.UTF16View> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Unicode.Scalar.UTF16View>, protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Unicode.Scalar.UTF8View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF8View> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF8View>, (uint64_t (*)(void))lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View, protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.Scalar.UTF8View, (unint64_t *)&type metadata for Unicode.Scalar.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.Scalar.UTF8View, (unint64_t *)&type metadata for Unicode.Scalar.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.Scalar.UTF8View, (unint64_t *)&type metadata for Unicode.Scalar.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View;
  if (!lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.Scalar.UTF8View, (unint64_t *)&type metadata for Unicode.Scalar.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Unicode.Scalar.UTF8View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Unicode.Scalar.UTF8View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF8View> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF8View>, (uint64_t (*)(void))lazy protocol witness table accessor for type Unicode.Scalar.UTF8View and conformance Unicode.Scalar.UTF8View, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Unicode.Scalar.UTF8View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<Unicode.Scalar.UTF8View> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<Unicode.Scalar.UTF8View>, protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Unicode.Scalar.UTF8View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Unicode.Scalar.UTF8View> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Unicode.Scalar.UTF8View>, protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _NativeDictionary<A, B>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for _NativeDictionary<A, B>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _NativeSet<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for _NativeSet<A>.Iterator, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for <A> A?(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)a3 + 8);
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <A> A?, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Identifiable.ID : Hashable in Never()
{
  return &protocol witness table for Never;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in LazyPrefixWhileSequence<A>.Iterator(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for LazyPrefixWhileSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Sequence in LazyPrefixWhileSequence<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for LazyPrefixWhileSequence<A>, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in <> LazyPrefixWhileSequence<A>()
{
  return &protocol witness table for LazyPrefixWhileSequence<A><>.Index;
}

uint64_t instantiation function for generic protocol witness table for <> LazyPrefixWhileSequence<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for LazyPrefixWhileSequence<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  uint64_t v5 = *(void *)(*(void *)a3 + 8);
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <> LazyPrefixWhileSequence<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for LazySequenceProtocol.Elements : Collection in <> LazyPrefixWhileSequence<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(protocol conformance descriptor for <> LazyPrefixWhileSequence<A>, a1, (uint64_t)&v4);
}

uint64_t instantiation function for generic protocol witness table for <> LazyPrefixWhileSequence<A>(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  return instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>(a1, a2, a3, protocol conformance descriptor for <> LazyPrefixWhileSequence<A>, protocol conformance descriptor for LazyPrefixWhileSequence<A>);
}

uint64_t instantiation function for generic protocol witness table for <> LazyDropWhileSequence<A>(uint64_t a1, unint64_t *a2, uint64_t *a3, int *a4, int *a5)
{
  uint64_t v10 = *a3;
  *(void *)(a1 + 8) = swift_getWitnessTable(a4, a2, (uint64_t)&v10);
  uint64_t result = swift_getWitnessTable(a5, a2, v8);
  *(void *)(a1 + 16) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> LazyPrefixWhileSequence<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, protocol conformance descriptor for <> LazyPrefixWhileSequence<A>, protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> LazyPrefixWhileSequence<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, protocol conformance descriptor for <> LazyPrefixWhileSequence<A>, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in <> Range<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  int8x16_t v4 = vextq_s8(*(int8x16_t *)(a3 - 16), *(int8x16_t *)(a3 - 16), 8uLL);
  return swift_getWitnessTable(protocol conformance descriptor for <> Range<A>, a1, (uint64_t)&v4);
}

uint64_t instantiation function for generic protocol witness table for <> Range<A>(uint64_t a1, unint64_t *a2, long long *a3)
{
  long long v5 = *a3;
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <> Range<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  long long v5;

  long long v5 = *a3;
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <> Range<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  long long v5;

  long long v5 = *a3;
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <> Range<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> Range<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  int8x16_t v4 = vextq_s8(*(int8x16_t *)(a3 - 16), *(int8x16_t *)(a3 - 16), 8uLL);
  return swift_getWitnessTable(protocol conformance descriptor for <> Range<A>, a1, (uint64_t)&v4);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> Range<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  int8x16_t v4 = vextq_s8(*(int8x16_t *)(a3 - 16), *(int8x16_t *)(a3 - 16), 8uLL);
  return swift_getWitnessTable(protocol conformance descriptor for <> Range<A>, a1, (uint64_t)&v4);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in <> PartialRangeFrom<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for PartialRangeFrom<A><>.Iterator, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for RangeSet<A>.Ranges(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in RangeSet<A>.Ranges(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in RangeSet<A>.Ranges(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for RangeSet<A>.Ranges, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Repeated<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for Repeated<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for Repeated<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for Repeated<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for Repeated<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for Repeated<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Repeated<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for Repeated<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for <> Result<A, B>(uint64_t a1, unint64_t *a2, void *a3)
{
  return instantiation function for generic protocol witness table for <> FlattenSequence<A>(a1, a2, a3, protocol conformance descriptor for <> Result<A, B>);
}

uint64_t instantiation function for generic protocol witness table for <> FlattenSequence<A>(uint64_t a1, unint64_t *a2, void *a3, int *a4)
{
  uint64_t v5 = *(void *)(a3[1] + 8);
  v7[0] = *(void *)(*a3 + 8);
  v7[1] = v5;
  uint64_t result = swift_getWitnessTable(a4, a2, (uint64_t)v7);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in ReversedCollection<A>.Iterator(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for ReversedCollection<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in ReversedCollection<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for ReversedCollection<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> DefaultIndices<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in ReversedCollection<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for ReversedCollection<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for ReversedCollection<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for ReversedCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for ReversedCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in ReversedCollection<A>()
{
  return &protocol witness table for ReversedCollection<A>.Index;
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in <> ReversedCollection<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, protocol conformance descriptor for <> ReversedCollection<A>, protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> ReversedCollection<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  return associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(a1, a2, a3, protocol conformance descriptor for <> ReversedCollection<A>, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in <> DiscontiguousSlice<A>(unint64_t *a1, unint64_t *a2, uint64_t a3, int *a4, int *a5)
{
  uint64_t v9 = *(void *)(a3 - 8);
  uint64_t WitnessTable = swift_getWitnessTable(a4, a2, (uint64_t)&v9);
  return swift_getWitnessTable(a5, a1, (uint64_t)&WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for <> ReversedCollection<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for ReversedCollection<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in PrefixSequence<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for PrefixSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in DropWhileSequence<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for DropWhileSequence<A>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in IteratorSequence<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for IteratorSequence<A>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Set<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for Set<A>.Iterator, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in Set<A>()
{
  return &protocol witness table for Set<A>.Index;
}

uint64_t instantiation function for generic protocol witness table for Set<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for Set<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for Set<A>, a2, a3);
  *(void *)(a1 + 16) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in __CocoaSet()
{
  return &protocol witness table for __CocoaSet.Iterator;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in Slice<A>(uint64_t a1, uint64_t a2)
{
  return swift_getAssociatedConformanceWitness(*(void *)(a2 + 24), *(void *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for Collection, associated conformance descriptor for Collection.Collection.Indices: Collection);
}

uint64_t instantiation function for generic protocol witness table for Slice<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for Slice<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in <> Slice<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&v4);
}

uint64_t instantiation function for generic protocol witness table for <> Slice<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for Slice<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;
  uint64_t v5;

  uint64_t v5 = *(void *)(*(void *)a3 + 8);
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in <> Slice<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&v4);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in <> Slice<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&v4);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RangeReplaceableCollection in <> Slice<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&v4);
}

unint64_t lazy protocol witness table accessor for type _SmallString and conformance _SmallString(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type _SmallString and conformance _SmallString;
  if (!lazy protocol witness table cache variable for type _SmallString and conformance _SmallString)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _SmallString, (unint64_t *)&type metadata for _SmallString, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _SmallString and conformance _SmallString);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _SmallString and conformance _SmallString;
  if (!lazy protocol witness table cache variable for type _SmallString and conformance _SmallString)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _SmallString, (unint64_t *)&type metadata for _SmallString, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _SmallString and conformance _SmallString);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _SmallString and conformance _SmallString;
  if (!lazy protocol witness table cache variable for type _SmallString and conformance _SmallString)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _SmallString, (unint64_t *)&type metadata for _SmallString, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _SmallString and conformance _SmallString);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _SmallString and conformance _SmallString;
  if (!lazy protocol witness table cache variable for type _SmallString and conformance _SmallString)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _SmallString, (unint64_t *)&type metadata for _SmallString, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _SmallString and conformance _SmallString);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _SmallString and conformance _SmallString;
  if (!lazy protocol witness table cache variable for type _SmallString and conformance _SmallString)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _SmallString, (unint64_t *)&type metadata for _SmallString, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _SmallString and conformance _SmallString);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for _SmallString(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type _SmallString and conformance _SmallString(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type _SmallString and conformance _SmallString(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type _SmallString and conformance _SmallString(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _SmallString()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<_SmallString> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<_SmallString>, protocol conformance descriptor for IndexingIterator<A>);
}

_UNKNOWN **associated type witness table accessor for ExpressibleByUnicodeScalarLiteral.UnicodeScalarLiteralType : _ExpressibleByBuiltinUnicodeScalarLiteral in StaticString()
{
  return &protocol witness table for StaticString;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByExtendedGraphemeClusterLiteral.ExtendedGraphemeClusterLiteralType : _ExpressibleByBuiltinExtendedGraphemeClusterLiteral in StaticString()
{
  return &protocol witness table for StaticString;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByStringLiteral.StringLiteralType : _ExpressibleByBuiltinStringLiteral in StaticString()
{
  return &protocol witness table for StaticString;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in StrideTo<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for StrideToIterator<A>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in StrideThrough<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for StrideThroughIterator<A>, a1, a3);
}

_UNKNOWN **associated type witness table accessor for ExpressibleByStringLiteral.StringLiteralType : _ExpressibleByBuiltinStringLiteral in String()
{
  return &protocol witness table for String;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByExtendedGraphemeClusterLiteral.ExtendedGraphemeClusterLiteralType : _ExpressibleByBuiltinExtendedGraphemeClusterLiteral in String()
{
  return &protocol witness table for String;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByUnicodeScalarLiteral.UnicodeScalarLiteralType : _ExpressibleByBuiltinUnicodeScalarLiteral in String()
{
  return &protocol witness table for String;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in String()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type DefaultIndices<String> and conformance <> DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<String>, (uint64_t (*)(void))lazy protocol witness table accessor for type String and conformance String, protocol conformance descriptor for <> DefaultIndices<A>);
}

unint64_t lazy protocol witness table accessor for type String and conformance String(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type String and conformance String;
  if (!lazy protocol witness table cache variable for type String and conformance String)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for String, (unint64_t *)&type metadata for String, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String and conformance String);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type String and conformance String;
  if (!lazy protocol witness table cache variable for type String and conformance String)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for String, (unint64_t *)&type metadata for String, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String and conformance String);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Substring and conformance Substring(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Substring and conformance Substring;
  if (!lazy protocol witness table cache variable for type Substring and conformance Substring)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Substring, (unint64_t *)&type metadata for Substring, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring and conformance Substring);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Substring and conformance Substring;
  if (!lazy protocol witness table cache variable for type Substring and conformance Substring)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Substring, (unint64_t *)&type metadata for Substring, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring and conformance Substring);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Substring and conformance Substring;
  if (!lazy protocol witness table cache variable for type Substring and conformance Substring)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Substring, (unint64_t *)&type metadata for Substring, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring and conformance Substring);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Substring and conformance Substring;
  if (!lazy protocol witness table cache variable for type Substring and conformance Substring)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Substring, (unint64_t *)&type metadata for Substring, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring and conformance Substring);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Substring and conformance Substring;
  if (!lazy protocol witness table cache variable for type Substring and conformance Substring)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Substring, (unint64_t *)&type metadata for Substring, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring and conformance Substring);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for String(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type String and conformance String(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type String and conformance String(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in String()
{
  return &protocol witness table for String.Index;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in String()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type DefaultIndices<String> and conformance DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<String>, protocol conformance descriptor for DefaultIndices<A>);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in String()
{
  return &protocol witness table for String.Iterator;
}

unint64_t lazy protocol witness table accessor for type String.UTF16View and conformance String.UTF16View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View;
  if (!lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for String.UTF16View, (unint64_t *)&type metadata for String.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View;
  if (!lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for String.UTF16View, (unint64_t *)&type metadata for String.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String.UTF16View and conformance String.UTF16View);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type String.UTF8View and conformance String.UTF8View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View;
  if (!lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for String.UTF8View, (unint64_t *)&type metadata for String.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View;
  if (!lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for String.UTF8View, (unint64_t *)&type metadata for String.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View;
  if (!lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for String.UTF8View, (unint64_t *)&type metadata for String.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String.UTF8View and conformance String.UTF8View);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type String.UnicodeScalarView and conformance String.UnicodeScalarView(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for String.UnicodeScalarView, (unint64_t *)&type metadata for String.UnicodeScalarView, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for String.UnicodeScalarView, (unint64_t *)&type metadata for String.UnicodeScalarView, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type String.UnicodeScalarView and conformance String.UnicodeScalarView);
  }
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByStringInterpolation.StringInterpolation : StringInterpolationProtocol in String()
{
  return &protocol witness table for DefaultStringInterpolation;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in String.UnicodeScalarView()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type DefaultIndices<String.UnicodeScalarView> and conformance <> DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<String.UnicodeScalarView>, (uint64_t (*)(void))lazy protocol witness table accessor for type String.UnicodeScalarView and conformance String.UnicodeScalarView, protocol conformance descriptor for <> DefaultIndices<A>);
}

unint64_t lazy protocol witness table accessor for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Substring.UnicodeScalarView, (unint64_t *)&type metadata for Substring.UnicodeScalarView, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Substring.UnicodeScalarView, (unint64_t *)&type metadata for Substring.UnicodeScalarView, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Substring.UnicodeScalarView, (unint64_t *)&type metadata for Substring.UnicodeScalarView, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView;
  if (!lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Substring.UnicodeScalarView, (unint64_t *)&type metadata for Substring.UnicodeScalarView, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for String.UnicodeScalarView(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type String.UnicodeScalarView and conformance String.UnicodeScalarView(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in String.UnicodeScalarView()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type DefaultIndices<String.UnicodeScalarView> and conformance DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<String.UnicodeScalarView>, protocol conformance descriptor for DefaultIndices<A>);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in String.UnicodeScalarView()
{
  return &protocol witness table for String.UnicodeScalarView.Iterator;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in String.UTF16View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type DefaultIndices<String.UTF16View> and conformance <> DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<String.UTF16View>, (uint64_t (*)(void))lazy protocol witness table accessor for type String.UTF16View and conformance String.UTF16View, protocol conformance descriptor for <> DefaultIndices<A>);
}

unint64_t lazy protocol witness table accessor for type Substring.UTF16View and conformance Substring.UTF16View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View;
  if (!lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Substring.UTF16View, (unint64_t *)&type metadata for Substring.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View;
  if (!lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Substring.UTF16View, (unint64_t *)&type metadata for Substring.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View;
  if (!lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Substring.UTF16View, (unint64_t *)&type metadata for Substring.UTF16View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF16View and conformance Substring.UTF16View);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for String.UTF16View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type String.UTF16View and conformance String.UTF16View(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in String.UTF16View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type DefaultIndices<String.UTF16View> and conformance DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<String.UTF16View>, protocol conformance descriptor for DefaultIndices<A>);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in String.UTF16View()
{
  return &protocol witness table for String.UTF16View.Iterator;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in String.UTF8View()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type DefaultIndices<String.UTF8View> and conformance <> DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<String.UTF8View>, (uint64_t (*)(void))lazy protocol witness table accessor for type String.UTF8View and conformance String.UTF8View, protocol conformance descriptor for <> DefaultIndices<A>);
}

unint64_t lazy protocol witness table accessor for type Substring.UTF8View and conformance Substring.UTF8View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View;
  if (!lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Substring.UTF8View, (unint64_t *)&type metadata for Substring.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View;
  if (!lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Substring.UTF8View, (unint64_t *)&type metadata for Substring.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View;
  if (!lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Substring.UTF8View, (unint64_t *)&type metadata for Substring.UTF8View, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Substring.UTF8View and conformance Substring.UTF8View);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for String.UTF8View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type String.UTF8View and conformance String.UTF8View(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type String.UTF8View and conformance String.UTF8View(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in String.UTF8View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type DefaultIndices<String.UTF8View> and conformance DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<String.UTF8View>, protocol conformance descriptor for DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in String.UTF8View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<String.UTF8View> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<String.UTF8View>, protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Substring(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Substring and conformance Substring(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Substring and conformance Substring(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Substring and conformance Substring(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in Substring()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type DefaultIndices<Substring> and conformance <> DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<Substring>, (uint64_t (*)(void))lazy protocol witness table accessor for type Substring and conformance Substring, protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in Substring()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type DefaultIndices<Substring> and conformance DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<Substring>, protocol conformance descriptor for DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Substring()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Substring> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Substring>, protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Substring.UTF8View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Substring.UTF8View and conformance Substring.UTF8View(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Substring.UTF8View and conformance Substring.UTF8View(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Substring.UTF8View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Substring.UTF8View> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Substring.UTF8View>, protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Substring.UTF16View(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Substring.UTF16View and conformance Substring.UTF16View(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Substring.UTF16View and conformance Substring.UTF16View(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Substring.UTF16View()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Substring.UTF16View> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Substring.UTF16View>, protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Substring.UnicodeScalarView(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Substring.UnicodeScalarView and conformance Substring.UnicodeScalarView(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Substring.UnicodeScalarView()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Substring.UnicodeScalarView> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Substring.UnicodeScalarView>, protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _UIntBuffer<A>.Iterator(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>.Iterator, a1, a3);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in _UIntBuffer<A>()
{
  return &protocol witness table for _UIntBuffer<A>.Index;
}

uint64_t instantiation function for generic protocol witness table for _UIntBuffer<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in _UIntBuffer<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> DefaultIndices<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _UIntBuffer<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in _UIntBuffer<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> DefaultIndices<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _UIntBuffer<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RangeReplaceableCollection in _UIntBuffer<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _UIntBuffer<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Unicode._NFD()
{
  return &protocol witness table for Unicode._NFD.Iterator;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Unicode._NFC()
{
  return &protocol witness table for Unicode._NFC.Iterator;
}

_UNKNOWN **_sSPyxGSxsRi_zrl6StrideSx_s13SignedNumericPWT()
{
  return &protocol witness table for Int;
}

unint64_t lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer;
  if (!lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _ValidUTF8Buffer, (unint64_t *)&type metadata for _ValidUTF8Buffer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer;
  if (!lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _ValidUTF8Buffer, (unint64_t *)&type metadata for _ValidUTF8Buffer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer;
  if (!lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _ValidUTF8Buffer, (unint64_t *)&type metadata for _ValidUTF8Buffer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer;
  if (!lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _ValidUTF8Buffer, (unint64_t *)&type metadata for _ValidUTF8Buffer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.UTF8.ReverseParser, (unint64_t *)&type metadata for Unicode.UTF8.ReverseParser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.UTF8.ReverseParser, (unint64_t *)&type metadata for Unicode.UTF8.ReverseParser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF8.ReverseParser and conformance Unicode.UTF8.ReverseParser);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF8 and conformance Unicode.UTF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF8 and conformance Unicode.UTF8;
  if (!lazy protocol witness table cache variable for type Unicode.UTF8 and conformance Unicode.UTF8)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.UTF8, (unint64_t *)&type metadata for Unicode.UTF8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF8 and conformance Unicode.UTF8);
  }
  return result;
}

uint64_t associated type witness table accessor for _UnicodeEncoding.EncodedScalar : BidirectionalCollection in Unicode.UTF16()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type _UIntBuffer<UInt16> and conformance _UIntBuffer<A>, &demangling cache variable for type metadata for _UIntBuffer<UInt16>, protocol conformance descriptor for _UIntBuffer<A>);
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.UTF16.ReverseParser, (unint64_t *)&type metadata for Unicode.UTF16.ReverseParser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.UTF16.ReverseParser, (unint64_t *)&type metadata for Unicode.UTF16.ReverseParser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF16.ReverseParser and conformance Unicode.UTF16.ReverseParser);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF16 and conformance Unicode.UTF16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF16 and conformance Unicode.UTF16;
  if (!lazy protocol witness table cache variable for type Unicode.UTF16 and conformance Unicode.UTF16)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.UTF16, (unint64_t *)&type metadata for Unicode.UTF16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF16 and conformance Unicode.UTF16);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type CollectionOfOne<UInt32> and conformance CollectionOfOne<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type CollectionOfOne<UInt32> and conformance CollectionOfOne<A>;
  if (!lazy protocol witness table cache variable for type CollectionOfOne<UInt32> and conformance CollectionOfOne<A>)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, qword_1EC9FFBA8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type CollectionOfOne<UInt32> and conformance CollectionOfOne<A>);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF32.Parser and conformance Unicode.UTF32.Parser(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF32.Parser and conformance Unicode.UTF32.Parser;
  if (!lazy protocol witness table cache variable for type Unicode.UTF32.Parser and conformance Unicode.UTF32.Parser)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.UTF32.Parser, (unint64_t *)&type metadata for Unicode.UTF32.Parser, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF32.Parser and conformance Unicode.UTF32.Parser);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Unicode.UTF32 and conformance Unicode.UTF32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Unicode.UTF32 and conformance Unicode.UTF32;
  if (!lazy protocol witness table cache variable for type Unicode.UTF32 and conformance Unicode.UTF32)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Unicode.UTF32, (unint64_t *)&type metadata for Unicode.UTF32, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Unicode.UTF32 and conformance Unicode.UTF32);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Unicode.UTF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Unicode.UTF8 and conformance Unicode.UTF8(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

unint64_t instantiation function for generic protocol witness table for Unicode.UTF16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Unicode.UTF16 and conformance Unicode.UTF16(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

unint64_t instantiation function for generic protocol witness table for Unicode.UTF32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Unicode.UTF32 and conformance Unicode.UTF32(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _ValidUTF8Buffer.Iterator()
{
  return &protocol witness table for _ValidUTF8Buffer.Iterator;
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in _ValidUTF8Buffer()
{
  return &protocol witness table for _ValidUTF8Buffer.Index;
}

uint64_t associated type witness table accessor for Collection.Indices : Collection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type DefaultIndices<_ValidUTF8Buffer> and conformance DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<_ValidUTF8Buffer>, protocol conformance descriptor for DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<_ValidUTF8Buffer> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<_ValidUTF8Buffer>, protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Collection.Indices : BidirectionalCollection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type DefaultIndices<_ValidUTF8Buffer> and conformance <> DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<_ValidUTF8Buffer>, (uint64_t (*)(void))lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer, protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<_ValidUTF8Buffer> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<_ValidUTF8Buffer>, (uint64_t (*)(void))lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer, protocol conformance descriptor for <> Slice<A>);
}

unint64_t instantiation function for generic protocol witness table for _ValidUTF8Buffer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type DefaultIndices<_ValidUTF8Buffer> and conformance <> DefaultIndices<A>, &demangling cache variable for type metadata for DefaultIndices<_ValidUTF8Buffer>, (uint64_t (*)(void))lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer, protocol conformance descriptor for <> DefaultIndices<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<_ValidUTF8Buffer> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<_ValidUTF8Buffer>, (uint64_t (*)(void))lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RangeReplaceableCollection in _ValidUTF8Buffer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<_ValidUTF8Buffer> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<_ValidUTF8Buffer>, (uint64_t (*)(void))lazy protocol witness table accessor for type _ValidUTF8Buffer and conformance _ValidUTF8Buffer, protocol conformance descriptor for <> Slice<A>);
}

_UNKNOWN **associated type witness table accessor for Collection.Index : Comparable in CollectionDifference<A>()
{
  return &protocol witness table for CollectionDifference<A>.Index;
}

uint64_t instantiation function for generic protocol witness table for CollectionDifference<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for CollectionDifference<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for <A> CollectionDifference<A>.Change(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)a3 + 8);
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <A> CollectionDifference<A>.Change, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for <A> CollectionDifference<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)a3 + 8);
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for <A> CollectionDifference<A>, a2, (uint64_t)&v5);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in CollectionOfOne<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for CollectionOfOne<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in CollectionOfOne<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in CollectionOfOne<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in CollectionOfOne<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for CollectionOfOne<A>.Iterator, a1, a3);
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Int128()
{
  return &protocol witness table for Int128;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in Int128()
{
  return &protocol witness table for UInt128;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in Int128()
{
  return &protocol witness table for UInt128;
}

unint64_t lazy protocol witness table accessor for type UInt128 and conformance UInt128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt128 and conformance UInt128;
  if (!lazy protocol witness table cache variable for type UInt128 and conformance UInt128)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt128, (unint64_t *)&type metadata for UInt128, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt128 and conformance UInt128);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt128 and conformance UInt128;
  if (!lazy protocol witness table cache variable for type UInt128 and conformance UInt128)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt128, (unint64_t *)&type metadata for UInt128, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt128 and conformance UInt128);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt128 and conformance UInt128;
  if (!lazy protocol witness table cache variable for type UInt128 and conformance UInt128)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt128, (unint64_t *)&type metadata for UInt128, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt128 and conformance UInt128);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words;
  if (!lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt128.Words, (unint64_t *)&type metadata for UInt128.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words;
  if (!lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt128.Words, (unint64_t *)&type metadata for UInt128.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words;
  if (!lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt128.Words, (unint64_t *)&type metadata for UInt128.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words;
  if (!lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt128.Words, (unint64_t *)&type metadata for UInt128.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt128.Words and conformance UInt128.Words);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type Int128 and conformance Int128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int128 and conformance Int128;
  if (!lazy protocol witness table cache variable for type Int128 and conformance Int128)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int128, (unint64_t *)&type metadata for Int128, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int128 and conformance Int128);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int128 and conformance Int128(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for _SliceBuffer<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for _ArrayBuffer<A>(a1, a2, a3, protocol conformance descriptor for _SliceBuffer<A>, protocol conformance descriptor for _SliceBuffer<A>);
}

{
  uint64_t result;

  unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _SliceBuffer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t instantiation function for generic protocol witness table for _ArrayBuffer<A>(uint64_t a1, unint64_t *a2, uint64_t a3, int *a4, int *a5)
{
  *(void *)(a1 + 8) = swift_getWitnessTable(a4, a2, a3);
  uint64_t result = swift_getWitnessTable(a5, a2, v8);
  *(void *)(a1 + 16) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in StaticBigInt()
{
  return &protocol witness table for StaticBigInt;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt128()
{
  return &protocol witness table for UInt128;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt128.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt128.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt128.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words, protocol conformance descriptor for <> Slice<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt128.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt128.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt128.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt128.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt128.Words and conformance UInt128.Words, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt128.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<UInt128.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<UInt128.Words>, protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt128.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<UInt128.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<UInt128.Words>, protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt128 and conformance UInt128(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UnfoldSequence<A, B>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for UnfoldSequence<A, B>, a1, a3);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Zip2Sequence<A, B>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for Zip2Sequence<A, B>.Iterator, a1, a3);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage.SIMDStorage.Scalar : FixedWidthInteger in SIMDMask<A>(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 32);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage.SIMDStorage.Scalar : SignedInteger in SIMDMask<A>(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 40);
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMDMask<A>()
{
  return &protocol witness table for Bool;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in SIMDMask<A>()
{
  return &protocol witness table for Bool;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in SIMDMask<A>()
{
  return &protocol witness table for Bool;
}

unint64_t instantiation function for generic protocol witness table for Float16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Float16 and conformance Float16(a1, a2, a3);
  *(void *)(a1 + 16) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type Float16 and conformance Float16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Float16 and conformance Float16;
  if (!lazy protocol witness table cache variable for type Float16 and conformance Float16)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Float16, (unint64_t *)&type metadata for Float16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Float16 and conformance Float16);
  }
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByFloatLiteral.FloatLiteralType : _ExpressibleByBuiltinFloatLiteral in Float16()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in Float16()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in Float16()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Float16()
{
  return &protocol witness table for Int64;
}

_UNKNOWN **associated type witness table accessor for Strideable.Stride : SignedNumeric in Float16()
{
  return &protocol witness table for Float16;
}

unint64_t instantiation function for generic protocol witness table for Float(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Float and conformance Float(a1, a2, a3);
  *(void *)(a1 + 16) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type Float and conformance Float(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Float and conformance Float;
  if (!lazy protocol witness table cache variable for type Float and conformance Float)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Float, (unint64_t *)&type metadata for Float, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Float and conformance Float);
  }
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByFloatLiteral.FloatLiteralType : _ExpressibleByBuiltinFloatLiteral in Float()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in Float()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in Float()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for Strideable.Stride : SignedNumeric in Float()
{
  return &protocol witness table for Float;
}

unint64_t instantiation function for generic protocol witness table for Double(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Double and conformance Double(a1, a2, a3);
  *(void *)(a1 + 16) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type Double and conformance Double(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Double and conformance Double;
  if (!lazy protocol witness table cache variable for type Double and conformance Double)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Double, (unint64_t *)&type metadata for Double, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Double and conformance Double);
  }
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByFloatLiteral.FloatLiteralType : _ExpressibleByBuiltinFloatLiteral in Double()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in Double()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in Double()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for Strideable.Stride : SignedNumeric in Double()
{
  return &protocol witness table for Double;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt8.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt8.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt8.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words, protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words;
  if (!lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt8.Words, (unint64_t *)&type metadata for UInt8.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words;
  if (!lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt8.Words, (unint64_t *)&type metadata for UInt8.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words;
  if (!lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt8.Words, (unint64_t *)&type metadata for UInt8.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words;
  if (!lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt8.Words, (unint64_t *)&type metadata for UInt8.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt8.Words and conformance UInt8.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for UInt8.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt8.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt8.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt8.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt8.Words and conformance UInt8.Words, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt8.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<UInt8.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<UInt8.Words>, protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt8.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<UInt8.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<UInt8.Words>, protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt8 and conformance UInt8(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in UInt8()
{
  return &protocol witness table for UInt8;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in UInt8()
{
  return &protocol witness table for UInt8;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt8()
{
  return &protocol witness table for UInt8;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Int8.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int8.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int8.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words, protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words;
  if (!lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int8.Words, (unint64_t *)&type metadata for Int8.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words;
  if (!lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int8.Words, (unint64_t *)&type metadata for Int8.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words;
  if (!lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int8.Words, (unint64_t *)&type metadata for Int8.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words;
  if (!lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int8.Words, (unint64_t *)&type metadata for Int8.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int8.Words and conformance Int8.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int8.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Int8.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int8.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int8.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int8.Words and conformance Int8.Words, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Int8.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<Int8.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<Int8.Words>, protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Int8.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Int8.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Int8.Words>, protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t lazy protocol witness table accessor for type Int8 and conformance Int8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int8 and conformance Int8;
  if (!lazy protocol witness table cache variable for type Int8 and conformance Int8)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int8, (unint64_t *)&type metadata for Int8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int8 and conformance Int8);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int8 and conformance Int8;
  if (!lazy protocol witness table cache variable for type Int8 and conformance Int8)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int8, (unint64_t *)&type metadata for Int8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int8 and conformance Int8);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int8 and conformance Int8;
  if (!lazy protocol witness table cache variable for type Int8 and conformance Int8)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int8, (unint64_t *)&type metadata for Int8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int8 and conformance Int8);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int8 and conformance Int8;
  if (!lazy protocol witness table cache variable for type Int8 and conformance Int8)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int8, (unint64_t *)&type metadata for Int8, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int8 and conformance Int8);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int8 and conformance Int8(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Int8()
{
  return &protocol witness table for Int8;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt16.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt16.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt16.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words, protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words;
  if (!lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt16.Words, (unint64_t *)&type metadata for UInt16.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words;
  if (!lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt16.Words, (unint64_t *)&type metadata for UInt16.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words;
  if (!lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt16.Words, (unint64_t *)&type metadata for UInt16.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words;
  if (!lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt16.Words, (unint64_t *)&type metadata for UInt16.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt16.Words and conformance UInt16.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for UInt16.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt16.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt16.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt16.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt16.Words and conformance UInt16.Words, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt16.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<UInt16.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<UInt16.Words>, protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt16.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<UInt16.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<UInt16.Words>, protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt16 and conformance UInt16(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in UInt16()
{
  return &protocol witness table for UInt16;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in UInt16()
{
  return &protocol witness table for UInt16;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt16()
{
  return &protocol witness table for UInt16;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Int16.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int16.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int16.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words, protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words;
  if (!lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int16.Words, (unint64_t *)&type metadata for Int16.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words;
  if (!lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int16.Words, (unint64_t *)&type metadata for Int16.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words;
  if (!lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int16.Words, (unint64_t *)&type metadata for Int16.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words;
  if (!lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int16.Words, (unint64_t *)&type metadata for Int16.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int16.Words and conformance Int16.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int16.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Int16.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int16.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int16.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int16.Words and conformance Int16.Words, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Int16.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<Int16.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<Int16.Words>, protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Int16.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Int16.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Int16.Words>, protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t lazy protocol witness table accessor for type Int16 and conformance Int16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int16 and conformance Int16;
  if (!lazy protocol witness table cache variable for type Int16 and conformance Int16)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int16, (unint64_t *)&type metadata for Int16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int16 and conformance Int16);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int16 and conformance Int16;
  if (!lazy protocol witness table cache variable for type Int16 and conformance Int16)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int16, (unint64_t *)&type metadata for Int16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int16 and conformance Int16);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int16 and conformance Int16;
  if (!lazy protocol witness table cache variable for type Int16 and conformance Int16)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int16, (unint64_t *)&type metadata for Int16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int16 and conformance Int16);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int16 and conformance Int16;
  if (!lazy protocol witness table cache variable for type Int16 and conformance Int16)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int16, (unint64_t *)&type metadata for Int16, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int16 and conformance Int16);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int16 and conformance Int16(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Int16()
{
  return &protocol witness table for Int16;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt32.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt32.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt32.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words, protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words;
  if (!lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt32.Words, (unint64_t *)&type metadata for UInt32.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words;
  if (!lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt32.Words, (unint64_t *)&type metadata for UInt32.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words;
  if (!lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt32.Words, (unint64_t *)&type metadata for UInt32.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words;
  if (!lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt32.Words, (unint64_t *)&type metadata for UInt32.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt32.Words and conformance UInt32.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for UInt32.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt32.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt32.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt32.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt32.Words and conformance UInt32.Words, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt32.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<UInt32.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<UInt32.Words>, protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt32.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<UInt32.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<UInt32.Words>, protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt32 and conformance UInt32(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in UInt32()
{
  return &protocol witness table for UInt32;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in UInt32()
{
  return &protocol witness table for UInt32;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt32()
{
  return &protocol witness table for UInt32;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Int32.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int32.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int32.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words, protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words;
  if (!lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int32.Words, (unint64_t *)&type metadata for Int32.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words;
  if (!lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int32.Words, (unint64_t *)&type metadata for Int32.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words;
  if (!lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int32.Words, (unint64_t *)&type metadata for Int32.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words;
  if (!lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int32.Words, (unint64_t *)&type metadata for Int32.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int32.Words and conformance Int32.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int32.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Int32.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int32.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int32.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int32.Words and conformance Int32.Words, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Int32.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<Int32.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<Int32.Words>, protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Int32.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Int32.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Int32.Words>, protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t lazy protocol witness table accessor for type Int32 and conformance Int32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int32 and conformance Int32;
  if (!lazy protocol witness table cache variable for type Int32 and conformance Int32)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int32, (unint64_t *)&type metadata for Int32, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int32 and conformance Int32);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int32 and conformance Int32;
  if (!lazy protocol witness table cache variable for type Int32 and conformance Int32)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int32, (unint64_t *)&type metadata for Int32, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int32 and conformance Int32);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int32 and conformance Int32;
  if (!lazy protocol witness table cache variable for type Int32 and conformance Int32)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int32, (unint64_t *)&type metadata for Int32, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int32 and conformance Int32);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int32 and conformance Int32;
  if (!lazy protocol witness table cache variable for type Int32 and conformance Int32)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int32, (unint64_t *)&type metadata for Int32, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int32 and conformance Int32);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int32 and conformance Int32(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Int32()
{
  return &protocol witness table for Int32;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt64.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt64.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt64.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words, protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words;
  if (!lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt64.Words, (unint64_t *)&type metadata for UInt64.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words;
  if (!lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt64.Words, (unint64_t *)&type metadata for UInt64.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words;
  if (!lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt64.Words, (unint64_t *)&type metadata for UInt64.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words;
  if (!lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt64.Words, (unint64_t *)&type metadata for UInt64.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt64.Words and conformance UInt64.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for UInt64.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt64.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt64.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt64.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt64.Words and conformance UInt64.Words, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt64.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<UInt64.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<UInt64.Words>, protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt64.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<UInt64.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<UInt64.Words>, protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt64 and conformance UInt64(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in UInt64()
{
  return &protocol witness table for UInt64;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in UInt64()
{
  return &protocol witness table for UInt64;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt64()
{
  return &protocol witness table for UInt64;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Int64.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int64.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int64.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words, protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words;
  if (!lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int64.Words, (unint64_t *)&type metadata for Int64.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words;
  if (!lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int64.Words, (unint64_t *)&type metadata for Int64.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words;
  if (!lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int64.Words, (unint64_t *)&type metadata for Int64.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words;
  if (!lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int64.Words, (unint64_t *)&type metadata for Int64.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int64.Words and conformance Int64.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int64.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Int64.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int64.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int64.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int64.Words and conformance Int64.Words, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Int64.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<Int64.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<Int64.Words>, protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Int64.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Int64.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Int64.Words>, protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Int64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int64 and conformance Int64(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UInt.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words, protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words;
  if (!lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt.Words, (unint64_t *)&type metadata for UInt.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words;
  if (!lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt.Words, (unint64_t *)&type metadata for UInt.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words;
  if (!lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt.Words, (unint64_t *)&type metadata for UInt.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words;
  if (!lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UInt.Words, (unint64_t *)&type metadata for UInt.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UInt.Words and conformance UInt.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for UInt.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UInt.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UInt.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UInt.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type UInt.Words and conformance UInt.Words, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UInt.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<UInt.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<UInt.Words>, protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UInt.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<UInt.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<UInt.Words>, protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for UInt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UInt and conformance UInt(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in UInt()
{
  return &protocol witness table for UInt;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in UInt()
{
  return &protocol witness table for UInt;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in UInt()
{
  return &protocol witness table for UInt;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in Int.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int.Words and conformance Int.Words, protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type Int.Words and conformance Int.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type Int.Words and conformance Int.Words;
  if (!lazy protocol witness table cache variable for type Int.Words and conformance Int.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int.Words, (unint64_t *)&type metadata for Int.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int.Words and conformance Int.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int.Words and conformance Int.Words;
  if (!lazy protocol witness table cache variable for type Int.Words and conformance Int.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int.Words, (unint64_t *)&type metadata for Int.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int.Words and conformance Int.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int.Words and conformance Int.Words;
  if (!lazy protocol witness table cache variable for type Int.Words and conformance Int.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int.Words, (unint64_t *)&type metadata for Int.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int.Words and conformance Int.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type Int.Words and conformance Int.Words;
  if (!lazy protocol witness table cache variable for type Int.Words and conformance Int.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for Int.Words, (unint64_t *)&type metadata for Int.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type Int.Words and conformance Int.Words);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for Int.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int.Words and conformance Int.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Int.Words and conformance Int.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type Int.Words and conformance Int.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in Int.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<Int.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<Int.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type Int.Words and conformance Int.Words, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in Int.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<Int.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<Int.Words>, protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Int.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<Int.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<Int.Words>, protocol conformance descriptor for IndexingIterator<A>);
}

unint64_t instantiation function for generic protocol witness table for Int(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type Int and conformance Int(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

_UNKNOWN **associated type witness table accessor for ExpressibleByIntegerLiteral.IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral in Int()
{
  return &protocol witness table for Int;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UnsafeMutableBufferPointer<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for UnsafeBufferPointer<A>.Iterator, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for UnsafeMutableBufferPointer<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in UnsafeMutableBufferPointer<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UnsafeMutableBufferPointer<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UnsafeMutableBufferPointer<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for UnsafeMutableBufferPointer<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for UnsafeBufferPointer<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for UnsafeBufferPointer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for UnsafeBufferPointer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for UnsafeBufferPointer<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UnsafeBufferPointer<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for UnsafeBufferPointer<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UnsafeBufferPointer<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for UnsafeBufferPointer<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in UnsafeMutableRawBufferPointer()
{
  return &protocol witness table for UnsafeRawBufferPointer.Iterator;
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in UnsafeMutableRawBufferPointer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UnsafeMutableRawBufferPointer> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UnsafeMutableRawBufferPointer>, (uint64_t (*)(void))lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer, protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UnsafeMutableRawBufferPointer, (unint64_t *)&type metadata for UnsafeMutableRawBufferPointer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UnsafeMutableRawBufferPointer, (unint64_t *)&type metadata for UnsafeMutableRawBufferPointer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UnsafeMutableRawBufferPointer, (unint64_t *)&type metadata for UnsafeMutableRawBufferPointer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UnsafeMutableRawBufferPointer, (unint64_t *)&type metadata for UnsafeMutableRawBufferPointer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer);
  }
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UnsafeMutableRawBufferPointer()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<UnsafeMutableRawBufferPointer> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<UnsafeMutableRawBufferPointer>, protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UnsafeMutableRawBufferPointer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UnsafeMutableRawBufferPointer> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UnsafeMutableRawBufferPointer>, (uint64_t (*)(void))lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer, protocol conformance descriptor for <> Slice<A>);
}

unint64_t instantiation function for generic protocol witness table for UnsafeMutableRawBufferPointer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UnsafeMutableRawBufferPointer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UnsafeMutableRawBufferPointer> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UnsafeMutableRawBufferPointer>, (uint64_t (*)(void))lazy protocol witness table accessor for type UnsafeMutableRawBufferPointer and conformance UnsafeMutableRawBufferPointer, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in UnsafeRawBufferPointer()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<UnsafeRawBufferPointer> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<UnsafeRawBufferPointer>, protocol conformance descriptor for Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in UnsafeRawBufferPointer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UnsafeRawBufferPointer> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UnsafeRawBufferPointer>, (uint64_t (*)(void))lazy protocol witness table accessor for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer, protocol conformance descriptor for <> Slice<A>);
}

unint64_t lazy protocol witness table accessor for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UnsafeRawBufferPointer, (unint64_t *)&type metadata for UnsafeRawBufferPointer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UnsafeRawBufferPointer, (unint64_t *)&type metadata for UnsafeRawBufferPointer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer;
  if (!lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for UnsafeRawBufferPointer, (unint64_t *)&type metadata for UnsafeRawBufferPointer, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for UnsafeRawBufferPointer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in UnsafeRawBufferPointer()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<UnsafeRawBufferPointer> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<UnsafeRawBufferPointer>, (uint64_t (*)(void))lazy protocol witness table accessor for type UnsafeRawBufferPointer and conformance UnsafeRawBufferPointer, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD2<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for SIMD2<A>, a1, a3);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage.SIMDStorage.Scalar : FixedWidthInteger in SIMD2<A>(uint64_t a1, uint64_t a2)
{
  return swift_getAssociatedConformanceWitness(*(void *)(a2 + 24), *(void *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMDMaskScalar: FixedWidthInteger);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage.SIMDStorage.Scalar : SignedInteger in SIMD2<A>(uint64_t a1, uint64_t a2)
{
  return swift_getAssociatedConformanceWitness(*(void *)(a2 + 24), *(void *)(a2 + 16), a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMDMaskScalar: SignedInteger);
}

uint64_t instantiation function for generic protocol witness table for SIMD2<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>(a1, a2, a3, protocol conformance descriptor for SIMD2<A>, protocol conformance descriptor for SIMD2<A>);
}

uint64_t associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMD2<A>(a1, a2, a3, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Decodable);
}

uint64_t associated type witness table accessor for SIMDStorage.Scalar : Encodable in SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMD2<A>(a1, a2, a3, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Encodable);
}

uint64_t associated type witness table accessor for SIMDStorage.Scalar : Hashable in SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMD2<A>(a1, a2, a3, associated conformance descriptor for SIMDStorage.SIMDStorage.Scalar: Hashable);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD4<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for SIMD4<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD4<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>(a1, a2, a3, protocol conformance descriptor for SIMD4<A>, protocol conformance descriptor for SIMD4<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD8<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for SIMD8<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD8<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>(a1, a2, a3, protocol conformance descriptor for SIMD8<A>, protocol conformance descriptor for SIMD8<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD16<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for SIMD16<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD16<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>(a1, a2, a3, protocol conformance descriptor for SIMD16<A>, protocol conformance descriptor for SIMD16<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD32<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for SIMD32<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD32<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>(a1, a2, a3, protocol conformance descriptor for SIMD32<A>, protocol conformance descriptor for SIMD32<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD64<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for SIMD64<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD64<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>(a1, a2, a3, protocol conformance descriptor for SIMD64<A>, protocol conformance descriptor for SIMD64<A>);
}

uint64_t associated type witness table accessor for SIMD.MaskStorage : SIMD in SIMD3<A>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for SIMD3<A>, a1, a3);
}

uint64_t instantiation function for generic protocol witness table for SIMD3<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  return instantiation function for generic protocol witness table for SIMD2<A>(a1, a2, a3, protocol conformance descriptor for SIMD3<A>, protocol conformance descriptor for SIMD3<A>);
}

uint64_t instantiation function for generic protocol witness table for SIMD2<A>(uint64_t a1, unint64_t *a2, uint64_t a3, int *a4, int *a5)
{
  *(void *)(a1 + 32) = swift_getWitnessTable(a4, a2, a3);
  uint64_t result = swift_getWitnessTable(a5, a2, v8);
  *(void *)(a1 + 48) = result;
  return result;
}

uint64_t associated type witness table accessor for SIMDStorage.Scalar : Decodable in SIMD2<A>(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  v6 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v6, a1, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness((uint64_t)v6, a1, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated conformance descriptor for SIMDScalar.SIMDScalar.SIMD16Storage: SIMDStorage);

  return swift_getAssociatedConformanceWitness(AssociatedConformanceWitness, (uint64_t)AssociatedTypeWitness, a1, (uint64_t)&protocol requirements base descriptor for SIMDStorage, a4);
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in UInt8.SIMD2Storage()
{
  return &protocol witness table for UInt8;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in UInt8.SIMD2Storage()
{
  return &protocol witness table for UInt8;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in UInt8.SIMD2Storage()
{
  return &protocol witness table for UInt8;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in UInt8()
{
  return &protocol witness table for UInt8.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Int8.SIMD2Storage()
{
  return &protocol witness table for Int8;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Int8.SIMD2Storage()
{
  return &protocol witness table for Int8;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Int8.SIMD2Storage()
{
  return &protocol witness table for Int8;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Int8()
{
  return &protocol witness table for Int8.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in UInt16.SIMD2Storage()
{
  return &protocol witness table for UInt16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in UInt16.SIMD2Storage()
{
  return &protocol witness table for UInt16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in UInt16.SIMD2Storage()
{
  return &protocol witness table for UInt16;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in UInt16()
{
  return &protocol witness table for UInt16.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Int16.SIMD2Storage()
{
  return &protocol witness table for Int16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Int16.SIMD2Storage()
{
  return &protocol witness table for Int16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Int16.SIMD2Storage()
{
  return &protocol witness table for Int16;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Int16()
{
  return &protocol witness table for Int16.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in UInt32.SIMD2Storage()
{
  return &protocol witness table for UInt32;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in UInt32.SIMD2Storage()
{
  return &protocol witness table for UInt32;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in UInt32.SIMD2Storage()
{
  return &protocol witness table for UInt32;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in UInt32()
{
  return &protocol witness table for UInt32.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Int32.SIMD2Storage()
{
  return &protocol witness table for Int32;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Int32.SIMD2Storage()
{
  return &protocol witness table for Int32;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Int32.SIMD2Storage()
{
  return &protocol witness table for Int32;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Int32()
{
  return &protocol witness table for Int32.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in UInt64.SIMD2Storage()
{
  return &protocol witness table for UInt64;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in UInt64.SIMD2Storage()
{
  return &protocol witness table for UInt64;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in UInt64.SIMD2Storage()
{
  return &protocol witness table for UInt64;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in UInt64()
{
  return &protocol witness table for UInt64.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Int64.SIMD2Storage()
{
  return &protocol witness table for Int64;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Int64.SIMD2Storage()
{
  return &protocol witness table for Int64;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Int64.SIMD2Storage()
{
  return &protocol witness table for Int64;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Int64()
{
  return &protocol witness table for Int64.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in UInt.SIMD2Storage()
{
  return &protocol witness table for UInt;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in UInt.SIMD2Storage()
{
  return &protocol witness table for UInt;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in UInt.SIMD2Storage()
{
  return &protocol witness table for UInt;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in UInt()
{
  return &protocol witness table for UInt.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Int.SIMD2Storage()
{
  return &protocol witness table for Int;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Int.SIMD2Storage()
{
  return &protocol witness table for Int;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Int.SIMD2Storage()
{
  return &protocol witness table for Int;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Int()
{
  return &protocol witness table for Int.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Float16.SIMD2Storage()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Float16.SIMD2Storage()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Float16.SIMD2Storage()
{
  return &protocol witness table for Float16;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Float16()
{
  return &protocol witness table for Float16.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Float.SIMD2Storage()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Float.SIMD2Storage()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Float.SIMD2Storage()
{
  return &protocol witness table for Float;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Float()
{
  return &protocol witness table for Float.SIMD8Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Decodable in Double.SIMD2Storage()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Encodable in Double.SIMD2Storage()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for SIMDStorage.Scalar : Hashable in Double.SIMD2Storage()
{
  return &protocol witness table for Double;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD16Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD16Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD2Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD2Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD32Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD32Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD4Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD4Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD64Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD64Storage;
}

_UNKNOWN **associated type witness table accessor for SIMDScalar.SIMD8Storage : SIMDStorage in Double()
{
  return &protocol witness table for Double.SIMD8Storage;
}

uint64_t sub_181504B10()
{
  return 8;
}

void *sub_181504B1C(void *result, void *a2)
{
  *a2 = *result;
  return result;
}

uint64_t sub_181504B28()
{
  return 8;
}

uint64_t sub_181504B34()
{
  return 8;
}

uint64_t sub_181504B40()
{
  return 8;
}

uint64_t sub_181504B4C()
{
  return 8;
}

uint64_t sub_181504B58()
{
  return 8;
}

uint64_t sub_181504B64()
{
  return 8;
}

uint64_t sub_181504B70()
{
  return 8;
}

uint64_t sub_181504B7C()
{
  return 8;
}

uint64_t sub_181504B88()
{
  return 8;
}

uint64_t sub_181504B94()
{
  return 8;
}

uint64_t sub_181504BA0()
{
  return 8;
}

uint64_t sub_181504BAC()
{
  return 8;
}

uint64_t sub_181504BB8()
{
  return 8;
}

uint64_t sub_181504BC4()
{
  return 8;
}

uint64_t sub_181504BD0()
{
  return 24;
}

__n128 sub_181504BDC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_181504BF0()
{
  return 24;
}

__n128 sub_181504BFC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_181504C10()
{
  return 24;
}

__n128 sub_181504C1C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_181504C30()
{
  return 24;
}

__n128 sub_181504C3C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_181504C50()
{
  return 24;
}

__n128 sub_181504C5C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_181504C70()
{
  return 24;
}

__n128 sub_181504C7C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_181504C90()
{
  return 24;
}

__n128 sub_181504C9C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_181504CB0()
{
  return 16;
}

__n128 sub_181504CBC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504CC8()
{
  return 8;
}

uint64_t sub_181504CD4()
{
  return 8;
}

uint64_t sub_181504CE0()
{
  return 16;
}

__n128 sub_181504CEC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504CF8()
{
  return 16;
}

__n128 sub_181504D04(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504D10()
{
  return 16;
}

__n128 sub_181504D1C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504D28()
{
  return 16;
}

__n128 sub_181504D34(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504D40()
{
  return 24;
}

__n128 sub_181504D4C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  a2[1].n128_u64[0] = a1[1].n128_u64[0];
  *a2 = result;
  return result;
}

uint64_t sub_181504D60()
{
  return 32;
}

__n128 sub_181504D6C(uint64_t a1, _OWORD *a2)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  *a2 = *(_OWORD *)a1;
  a2[1] = v3;
  return result;
}

uint64_t sub_181504D78()
{
  return 16;
}

__n128 sub_181504D84(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504D90()
{
  return 16;
}

__n128 sub_181504D9C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504DA8()
{
  return 16;
}

__n128 sub_181504DB4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504DC0()
{
  return 16;
}

__n128 sub_181504DCC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504DD8()
{
  return 16;
}

__n128 sub_181504DE4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504DF0()
{
  return 0;
}

uint64_t sub_181504E00()
{
  return 0;
}

uint64_t sub_181504E10()
{
  return 8;
}

uint64_t sub_181504E1C()
{
  return 8;
}

uint64_t sub_181504E28()
{
  return 8;
}

uint64_t sub_181504E34()
{
  return 8;
}

uint64_t sub_181504E40()
{
  return 8;
}

uint64_t sub_181504E4C()
{
  return 8;
}

uint64_t sub_181504E58()
{
  return 8;
}

uint64_t sub_181504E64()
{
  return 8;
}

uint64_t sub_181504E70()
{
  return 8;
}

uint64_t sub_181504E7C()
{
  return 32;
}

__n128 sub_181504E88(uint64_t a1, _OWORD *a2)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  *a2 = *(_OWORD *)a1;
  a2[1] = v3;
  return result;
}

uint64_t sub_181504E94()
{
  return 8;
}

uint64_t sub_181504EA0()
{
  return 8;
}

uint64_t sub_181504EAC()
{
  return 8;
}

uint64_t sub_181504EB8()
{
  return 0;
}

uint64_t sub_181504EC8()
{
  return 0;
}

uint64_t sub_181504ED8()
{
  return 0;
}

uint64_t sub_181504EE8()
{
  return 0;
}

uint64_t sub_181504EF8()
{
  return 16;
}

__n128 sub_181504F04(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504F10()
{
  return 16;
}

__n128 sub_181504F1C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504F28()
{
  return 16;
}

__n128 sub_181504F34(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504F40()
{
  return 16;
}

__n128 sub_181504F4C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504F58()
{
  return 16;
}

__n128 sub_181504F64(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504F70()
{
  return 16;
}

__n128 sub_181504F7C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504F88()
{
  return 16;
}

__n128 sub_181504F94(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504FA0()
{
  return 16;
}

__n128 sub_181504FAC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504FB8()
{
  return 16;
}

__n128 sub_181504FC4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504FD0()
{
  return 16;
}

__n128 sub_181504FDC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181504FE8()
{
  return 16;
}

__n128 sub_181504FF4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505000()
{
  return 16;
}

__n128 sub_18150500C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505018()
{
  return 16;
}

__n128 sub_181505024(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505030()
{
  return 16;
}

__n128 sub_18150503C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505048()
{
  return 16;
}

__n128 sub_181505054(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505060()
{
  return 16;
}

__n128 sub_18150506C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505078()
{
  return 16;
}

__n128 sub_181505084(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505090()
{
  return 16;
}

__n128 sub_18150509C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815050A8()
{
  return 16;
}

__n128 sub_1815050B4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815050C0()
{
  return 16;
}

__n128 sub_1815050CC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815050D8()
{
  return 16;
}

__n128 sub_1815050E4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815050F0()
{
  return 16;
}

__n128 sub_1815050FC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505108()
{
  return 16;
}

__n128 sub_181505114(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505120()
{
  return 16;
}

__n128 sub_18150512C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505138()
{
  return 16;
}

__n128 sub_181505144(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505150()
{
  return 16;
}

__n128 sub_18150515C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505168()
{
  return 16;
}

__n128 sub_181505174(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505180()
{
  return 16;
}

__n128 sub_18150518C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505198()
{
  return 16;
}

__n128 sub_1815051A4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815051B0()
{
  return 16;
}

__n128 sub_1815051BC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815051C8()
{
  return 16;
}

__n128 sub_1815051D4(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815051E0()
{
  return 16;
}

__n128 sub_1815051EC(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_1815051F8()
{
  return 16;
}

__n128 sub_181505204(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505210()
{
  return 16;
}

__n128 sub_18150521C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505228()
{
  return 16;
}

__n128 sub_181505234(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505240()
{
  return 16;
}

__n128 sub_18150524C(__n128 *a1, __n128 *a2)
{
  __n128 result = *a1;
  *a2 = *a1;
  return result;
}

uint64_t sub_181505258()
{
  return 0;
}

uint64_t sub_181505268()
{
  return 0;
}

uint64_t sub_181505278()
{
  return 0;
}

uint64_t sub_181505288()
{
  return 0;
}

uint64_t sub_181505298()
{
  return 0;
}

uint64_t sub_1815052A8()
{
  return 0;
}

uint64_t sub_1815052B8()
{
  return 0;
}

uint64_t sub_1815052C8()
{
  return 0;
}

uint64_t sub_1815052D8()
{
  return 0;
}

uint64_t sub_1815052E8()
{
  return 0;
}

uint64_t sub_1815052F8()
{
  return 0;
}

uint64_t sub_181505308()
{
  return 0;
}

uint64_t sub_181505318()
{
  return 0;
}

uint64_t sub_181505328()
{
  return 0;
}

uint64_t sub_181505338()
{
  return 0;
}

uint64_t sub_181505348()
{
  return 0;
}

uint64_t sub_181505358()
{
  return 0;
}

uint64_t sub_181505368()
{
  return 0;
}

uint64_t sub_181505378()
{
  return 0;
}

uint64_t sub_181505388()
{
  return 0;
}

uint64_t sub_181505398()
{
  return 0;
}

uint64_t sub_1815053A8()
{
  return 0;
}

uint64_t sub_1815053B8()
{
  return 0;
}

uint64_t sub_1815053C8()
{
  return 0;
}

uint64_t sub_1815053D8()
{
  return 0;
}

uint64_t sub_1815053E8()
{
  return 0;
}

uint64_t sub_1815053F8()
{
  return 0;
}

uint64_t sub_181505408()
{
  return 0;
}

uint64_t sub_181505418()
{
  return 0;
}

uint64_t sub_181505428()
{
  return 0;
}

uint64_t sub_181505438()
{
  return 0;
}

uint64_t sub_181505448()
{
  return 0;
}

uint64_t sub_181505458()
{
  return 0;
}

uint64_t sub_181505468()
{
  return 0;
}

uint64_t sub_181505478()
{
  return 0;
}

uint64_t sub_181505488()
{
  return 0;
}

uint64_t sub_181505498()
{
  return 0;
}

uint64_t sub_1815054A8()
{
  return 0;
}

uint64_t sub_1815054B8()
{
  return 0;
}

uint64_t sub_1815054C8()
{
  return 0;
}

uint64_t sub_1815054D8()
{
  return 0;
}

uint64_t sub_1815054E8()
{
  return 0;
}

uint64_t sub_1815054F8()
{
  return 0;
}

uint64_t sub_181505508()
{
  return 0;
}

uint64_t sub_181505518()
{
  return 0;
}

uint64_t sub_181505528()
{
  return 0;
}

uint64_t sub_181505538()
{
  return 0;
}

uint64_t sub_181505548()
{
  return 0;
}

uint64_t sub_181505558()
{
  return 0;
}

uint64_t sub_181505568()
{
  return 0;
}

uint64_t sub_181505578()
{
  return 0;
}

uint64_t sub_181505588()
{
  return 0;
}

uint64_t sub_181505598()
{
  return 0;
}

uint64_t sub_1815055A8()
{
  return 0;
}

uint64_t sub_1815055B8()
{
  return 0;
}

uint64_t sub_1815055C8()
{
  return 0;
}

uint64_t sub_1815055D8()
{
  return 0;
}

uint64_t sub_1815055E8()
{
  return 0;
}

uint64_t sub_1815055F8()
{
  return 0;
}

uint64_t sub_181505608()
{
  return 0;
}

uint64_t sub_181505618()
{
  return 0;
}

uint64_t sub_181505628()
{
  return 0;
}

uint64_t sub_181505638()
{
  return 0;
}

uint64_t sub_181505648()
{
  return 0;
}

uint64_t sub_181505658()
{
  return 0;
}

uint64_t sub_181505668()
{
  return 0;
}

uint64_t sub_181505678()
{
  return 0;
}

uint64_t sub_181505688()
{
  return 0;
}

uint64_t sub_181505698()
{
  return 0;
}

uint64_t sub_1815056A8()
{
  return 0;
}

uint64_t sub_1815056B8()
{
  return 0;
}

uint64_t sub_1815056C8()
{
  return 0;
}

uint64_t sub_1815056D8()
{
  return 0;
}

uint64_t sub_1815056E8()
{
  return 0;
}

uint64_t sub_1815056F8()
{
  return 0;
}

uint64_t sub_181505708()
{
  return 0;
}

uint64_t sub_181505718()
{
  return 0;
}

uint64_t sub_181505728()
{
  return 0;
}

void *type metadata instantiation function for EnumeratedSequence(_DWORD *a1, const void *a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, 32);
}

const char *type metadata completion function for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator, (uint64_t)&value witness table for Builtin.Int64.size);
}

atomic_ullong **initializeBufferWithCopyOfBuffer for EnumeratedSequence.Iterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t destroy for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator(a1, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t initializeWithCopy for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t assignWithCopy for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t initializeWithTake for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t assignWithTake for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t getEnumTagSinglePayload for EnumeratedSequence.Iterator(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

void storeEnumTagSinglePayload for EnumeratedSequence.Iterator(_DWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
}

__n128 __swift_memcpy16_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

ValueMetadata *type metadata accessor for _ArrayBody()
{
  return &type metadata for _ArrayBody;
}

void *type metadata instantiation function for _ArrayBuffer(_DWORD *a1, const void *a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, 24);
}

uint64_t dispatch thunk of _ArrayBufferProtocol.init()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.init(_buffer:shiftedToStartIndex:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.init(copying:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol._copyContents(subRange:initializing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 48))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.requestUniqueMutableBackingBuffer(minimumCapacity:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.isMutableAndUniquelyReferenced()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.requestNativeBuffer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return (*(uint64_t (**)(void))(a8 + 80))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 88))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.withUnsafeBufferPointer<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 96))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.withUnsafeMutableBufferPointer<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 104))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.count.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 112))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.count.modify(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.capacity.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.owner.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 136))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.firstElementAddress.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 144))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.firstElementAddressIfContiguous.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 152))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.subscriptBaseAddress.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 160))();
}

uint64_t dispatch thunk of _ArrayBufferProtocol.identity.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 168))();
}

ValueMetadata *type metadata accessor for _DependenceToken()
{
  return &type metadata for _DependenceToken;
}

__n128 __swift_memcpy32_8(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t assignWithTake for ArraySlice(uint64_t a1, _OWORD *a2)
{
  swift_unknownObjectRelease(*(id *)a1);
  long long v4 = a2[1];
  *(_OWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 16) = v4;
  return a1;
}

uint64_t dispatch thunk of _ArrayProtocol.capacity.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t dispatch thunk of _ArrayProtocol._owner.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

uint64_t dispatch thunk of _ArrayProtocol._baseAddressIfContiguous.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t dispatch thunk of _ArrayProtocol.init(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

uint64_t dispatch thunk of _ArrayProtocol._buffer.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

ValueMetadata *type metadata accessor for Unicode.ASCII()
{
  return &type metadata for Unicode.ASCII;
}

ValueMetadata *type metadata accessor for Unicode.ASCII.Parser()
{
  return &type metadata for Unicode.ASCII.Parser;
}

uint64_t default associated conformance accessor for BidirectionalCollection.Collection.Indices: BidirectionalCollection(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return swift_getWitnessTable(protocol conformance descriptor for <> DefaultIndices<A>, a1, (uint64_t)&v4);
}

uint64_t default associated conformance accessor for BidirectionalCollection.Collection.SubSequence: BidirectionalCollection(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&v4);
}

uint64_t dispatch thunk of BidirectionalCollection.index(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of BidirectionalCollection.formIndex(before:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of BidirectionalCollection.index(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 48))();
}

uint64_t dispatch thunk of BidirectionalCollection.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 56))();
}

uint64_t dispatch thunk of BidirectionalCollection.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 64))();
}

ValueMetadata *type metadata accessor for _UnsafeBitset()
{
  return &type metadata for _UnsafeBitset;
}

ValueMetadata *type metadata accessor for _UnsafeBitset.Iterator()
{
  return &type metadata for _UnsafeBitset.Iterator;
}

ValueMetadata *type metadata accessor for _UnsafeBitset.Word()
{
  return &type metadata for _UnsafeBitset.Word;
}

unsigned char *__swift_memcpy1_1(unsigned char *result, unsigned char *a2)
{
  *__n128 result = *a2;
  return result;
}

ValueMetadata *type metadata accessor for Bool()
{
  return &type metadata for Bool;
}

uint64_t dispatch thunk of _ObjectiveCBridgeable._bridgeToObjectiveC()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of static _ObjectiveCBridgeable._forceBridgeFromObjectiveC(_:result:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

uint64_t dispatch thunk of static _ObjectiveCBridgeable._conditionallyBridgeFromObjectiveC(_:result:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t dispatch thunk of static _ObjectiveCBridgeable._unconditionallyBridgeFromObjectiveC(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

void *__swift_memcpy8_8(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

ValueMetadata *type metadata accessor for _BridgeableMetatype()
{
  return &type metadata for _BridgeableMetatype;
}

Class *type metadata accessor for _BridgeStorage(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _BridgeStorage.Flags);
}

void *initializeBufferWithCopyOfBuffer for Character(void *a1, void *a2)
{
  unint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

void destroy for Character(uint64_t a1)
{
}

void *assignWithTake for Character(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  uint64_t v4 = a1[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRelease(v4);
  return a1;
}

ValueMetadata *type metadata accessor for Character()
{
  return &type metadata for Character;
}

ValueMetadata *type metadata accessor for _CocoaArrayWrapper()
{
  return &type metadata for _CocoaArrayWrapper;
}

uint64_t dispatch thunk of Encodable.encode(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of Decodable.init(from:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of CodingKey.stringValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of CodingKey.init(stringValue:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t dispatch thunk of CodingKey.intValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t dispatch thunk of CodingKey.init(intValue:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 48))();
}

uint64_t dispatch thunk of Encoder.codingPath.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of Encoder.userInfo.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of Encoder.container<A>(keyedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 24))();
}

uint64_t dispatch thunk of Encoder.unkeyedContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of Encoder.singleValueContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t dispatch thunk of Decoder.codingPath.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of Decoder.userInfo.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of Decoder.container<A>(keyedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 24))();
}

uint64_t dispatch thunk of Decoder.unkeyedContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of Decoder.singleValueContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.codingPath.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeNil(forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encode(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 40))();
}

{
  return (*(uint64_t (**)(void))(a4 + 72))();
}

{
  return (*(uint64_t (**)(void))(a4 + 80))();
}

{
  return (*(uint64_t (**)(void))(a4 + 88))();
}

{
  return (*(uint64_t (**)(void))(a4 + 96))();
}

{
  return (*(uint64_t (**)(void))(a4 + 104))();
}

{
  return (*(uint64_t (**)(void))(a4 + 120))();
}

{
  return (*(uint64_t (**)(void))(a4 + 128))();
}

{
  return (*(uint64_t (**)(void))(a4 + 136))();
}

{
  return (*(uint64_t (**)(void))(a4 + 144))();
}

{
  return (*(uint64_t (**)(void))(a4 + 152))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encode(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 48))();
}

{
  return (*(uint64_t (**)(void))(a5 + 112))();
}

{
  return (*(uint64_t (**)(void))(a5 + 160))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encode(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encode<A>(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 168))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeConditional<A>(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 176))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 184))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 192))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, void))(a5 + 200))(a1, a2 & 1);
}

{
  return (*(uint64_t (**)(uint64_t, void))(a5 + 216))(a1, a2 & 1);
}

{
  return (*(uint64_t (**)(uint64_t, void))(a5 + 248))(a1, a2 & 1);
}

{
  return (*(uint64_t (**)(uint64_t, void))(a5 + 264))(a1, a2 & 1);
}

{
  return (*(uint64_t (**)(uint64_t, void))(a5 + 296))(a1, a2 & 1);
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(unint64_t))(a4 + 208))(a1 | ((HIDWORD(a1) & 1) << 32));
}

{
  return (*(uint64_t (**)(unint64_t))(a4 + 240))(a1 | ((HIDWORD(a1) & 1) << 32));
}

{
  return (*(uint64_t (**)(unint64_t))(a4 + 288))(a1 | ((HIDWORD(a1) & 1) << 32));
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 224))(a1 & 0x1FF);
}

{
  return (*(uint64_t (**)(void))(a4 + 272))(a1 & 0x1FF);
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 232))(a1 & 0x1FFFF);
}

{
  return (*(uint64_t (**)(void))(a4 + 280))(a1 & 0x1FFFF);
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent(_:forKey:)(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a6 + 256))(a1, a2, a3 & 1);
}

{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a6 + 304))(a1, a2, a3 & 1);
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.encodeIfPresent<A>(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 312))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.nestedContainer<A>(keyedBy:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 320))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.nestedUnkeyedContainer(forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 328))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.superEncoder()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 336))();
}

uint64_t dispatch thunk of KeyedEncodingContainerProtocol.superEncoder(forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 344))();
}

Class *type metadata accessor for KeyedEncodingContainer(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for KeyedEncodingContainer.Flags);
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.codingPath.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.allKeys.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decodeNil(forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 48))() & 1;
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decode(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))() & 1;
}

{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

{
  return (*(uint64_t (**)(void))(a3 + 72))();
}

{
  return (*(uint64_t (**)(void))(a3 + 80))();
}

{
  return (*(uint64_t (**)(void))(a3 + 88))();
}

{
  return (*(uint64_t (**)(void))(a3 + 96))();
}

{
  return (*(uint64_t (**)(void))(a3 + 104))();
}

{
  return (*(uint64_t (**)(void))(a3 + 112))();
}

{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

{
  return (*(uint64_t (**)(void))(a3 + 128))();
}

{
  return (*(uint64_t (**)(void))(a3 + 136))();
}

{
  return (*(uint64_t (**)(void))(a3 + 144))();
}

{
  return (*(uint64_t (**)(void))(a3 + 152))();
}

{
  return (*(uint64_t (**)(void))(a3 + 160))();
}

{
  return (*(uint64_t (**)(void))(a3 + 168))();
}

{
  return (*(uint64_t (**)(void))(a3 + 176))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decode<A>(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 184))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decodeIfPresent(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 192))();
}

{
  return (*(uint64_t (**)(void))(a3 + 200))();
}

{
  return (*(uint64_t (**)(void))(a3 + 208))();
}

{
  unint64_t v3;

  uint64_t v3 = (*(uint64_t (**)(void))(a3 + 216))();
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a3 + 224))();
}

{
  return (*(uint64_t (**)(void))(a3 + 232))() & 0x1FF;
}

{
  return (*(uint64_t (**)(void))(a3 + 240))() & 0x1FFFF;
}

{
  unint64_t v3;

  uint64_t v3 = (*(uint64_t (**)(void))(a3 + 248))();
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a3 + 256))();
}

{
  return (*(uint64_t (**)(void))(a3 + 264))();
}

{
  return (*(uint64_t (**)(void))(a3 + 272))();
}

{
  return (*(uint64_t (**)(void))(a3 + 280))() & 0x1FF;
}

{
  return (*(uint64_t (**)(void))(a3 + 288))() & 0x1FFFF;
}

{
  unint64_t v3;

  uint64_t v3 = (*(uint64_t (**)(void))(a3 + 296))();
  return v3 | ((HIDWORD(v3) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a3 + 304))();
}

{
  return (*(uint64_t (**)(void))(a3 + 312))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.decodeIfPresent<A>(_:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 320))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.nestedContainer<A>(keyedBy:forKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 328))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.nestedUnkeyedContainer(forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 336))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.superDecoder()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 344))();
}

uint64_t dispatch thunk of KeyedDecodingContainerProtocol.superDecoder(forKey:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 352))();
}

Class *type metadata accessor for KeyedDecodingContainer(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for KeyedDecodingContainer.Flags);
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.codingPath.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.count.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encodeNil()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

{
  return (*(uint64_t (**)(void))(a3 + 72))();
}

{
  return (*(uint64_t (**)(void))(a3 + 80))();
}

{
  return (*(uint64_t (**)(void))(a3 + 88))();
}

{
  return (*(uint64_t (**)(void))(a3 + 96))();
}

{
  return (*(uint64_t (**)(void))(a3 + 112))();
}

{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

{
  return (*(uint64_t (**)(void))(a3 + 128))();
}

{
  return (*(uint64_t (**)(void))(a3 + 136))();
}

{
  return (*(uint64_t (**)(void))(a3 + 144))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 40))();
}

{
  return (*(uint64_t (**)(void))(a4 + 104))();
}

{
  return (*(uint64_t (**)(void))(a4 + 152))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 160))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encodeConditional<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 168))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode<A>(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 176))();
}

{
  return (*(uint64_t (**)(void))(a5 + 184))();
}

{
  return (*(uint64_t (**)(void))(a5 + 192))();
}

{
  return (*(uint64_t (**)(void))(a5 + 200))();
}

{
  return (*(uint64_t (**)(void))(a5 + 208))();
}

{
  return (*(uint64_t (**)(void))(a5 + 216))();
}

{
  return (*(uint64_t (**)(void))(a5 + 224))();
}

{
  return (*(uint64_t (**)(void))(a5 + 232))();
}

{
  return (*(uint64_t (**)(void))(a5 + 240))();
}

{
  return (*(uint64_t (**)(void))(a5 + 248))();
}

{
  return (*(uint64_t (**)(void))(a5 + 256))();
}

{
  return (*(uint64_t (**)(void))(a5 + 264))();
}

{
  return (*(uint64_t (**)(void))(a5 + 272))();
}

{
  return (*(uint64_t (**)(void))(a5 + 280))();
}

{
  return (*(uint64_t (**)(void))(a5 + 288))();
}

{
  return (*(uint64_t (**)(void))(a5 + 296))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.encode<A>(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 304))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.nestedContainer<A>(keyedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 312))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.nestedUnkeyedContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 320))();
}

uint64_t dispatch thunk of UnkeyedEncodingContainer.superEncoder()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 328))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.codingPath.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.count.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.isAtEnd.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.currentIndex.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decodeNil()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))() & 1;
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decode(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))() & 1;
}

{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

{
  return (*(uint64_t (**)(void))(a2 + 80))();
}

{
  return (*(uint64_t (**)(void))(a2 + 88))();
}

{
  return (*(uint64_t (**)(void))(a2 + 96))();
}

{
  return (*(uint64_t (**)(void))(a2 + 104))();
}

{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

{
  return (*(uint64_t (**)(void))(a2 + 120))();
}

{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

{
  return (*(uint64_t (**)(void))(a2 + 136))();
}

{
  return (*(uint64_t (**)(void))(a2 + 144))();
}

{
  return (*(uint64_t (**)(void))(a2 + 152))();
}

{
  return (*(uint64_t (**)(void))(a2 + 160))();
}

{
  return (*(uint64_t (**)(void))(a2 + 168))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 176))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decodeIfPresent(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 184))();
}

{
  return (*(uint64_t (**)(void))(a2 + 192))();
}

{
  return (*(uint64_t (**)(void))(a2 + 200))();
}

{
  unint64_t v2;

  uint64_t v2 = (*(uint64_t (**)(void))(a2 + 208))();
  return v2 | ((HIDWORD(v2) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a2 + 216))();
}

{
  return (*(uint64_t (**)(void))(a2 + 224))() & 0x1FF;
}

{
  return (*(uint64_t (**)(void))(a2 + 232))() & 0x1FFFF;
}

{
  unint64_t v2;

  uint64_t v2 = (*(uint64_t (**)(void))(a2 + 240))();
  return v2 | ((HIDWORD(v2) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a2 + 248))();
}

{
  return (*(uint64_t (**)(void))(a2 + 256))();
}

{
  return (*(uint64_t (**)(void))(a2 + 264))();
}

{
  return (*(uint64_t (**)(void))(a2 + 272))() & 0x1FF;
}

{
  return (*(uint64_t (**)(void))(a2 + 280))() & 0x1FFFF;
}

{
  unint64_t v2;

  uint64_t v2 = (*(uint64_t (**)(void))(a2 + 288))();
  return v2 | ((HIDWORD(v2) & 1) << 32);
}

{
  return (*(uint64_t (**)(void))(a2 + 296))();
}

{
  return (*(uint64_t (**)(void))(a2 + 304))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.decodeIfPresent<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 312))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.nestedContainer<A>(keyedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 320))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.nestedUnkeyedContainer()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 328))();
}

uint64_t dispatch thunk of UnkeyedDecodingContainer.superDecoder()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 336))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.codingPath.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encodeNil()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

{
  return (*(uint64_t (**)(void))(a3 + 72))();
}

{
  return (*(uint64_t (**)(void))(a3 + 80))();
}

{
  return (*(uint64_t (**)(void))(a3 + 88))();
}

{
  return (*(uint64_t (**)(void))(a3 + 104))();
}

{
  return (*(uint64_t (**)(void))(a3 + 112))();
}

{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

{
  return (*(uint64_t (**)(void))(a3 + 128))();
}

{
  return (*(uint64_t (**)(void))(a3 + 136))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

{
  return (*(uint64_t (**)(void))(a4 + 96))();
}

{
  return (*(uint64_t (**)(void))(a4 + 144))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encode(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

uint64_t dispatch thunk of SingleValueEncodingContainer.encode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 152))();
}

uint64_t dispatch thunk of SingleValueDecodingContainer.codingPath.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of SingleValueDecodingContainer.decodeNil()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of SingleValueDecodingContainer.decode(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))() & 1;
}

{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

{
  return (*(uint64_t (**)(void))(a2 + 80))();
}

{
  return (*(uint64_t (**)(void))(a2 + 88))();
}

{
  return (*(uint64_t (**)(void))(a2 + 96))();
}

{
  return (*(uint64_t (**)(void))(a2 + 104))();
}

{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

{
  return (*(uint64_t (**)(void))(a2 + 120))();
}

{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

{
  return (*(uint64_t (**)(void))(a2 + 136))();
}

{
  return (*(uint64_t (**)(void))(a2 + 144))();
}

uint64_t dispatch thunk of SingleValueDecodingContainer.decode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 152))();
}

ValueMetadata *type metadata accessor for CodingUserInfoKey()
{
  return &type metadata for CodingUserInfoKey;
}

void destroy for EncodingError(uint64_t *a1)
{
  __swift_destroy_boxed_opaque_existential_1Tm(a1);
  swift_bridgeObjectRelease(a1[4]);
  swift_bridgeObjectRelease(a1[6]);
  uint64_t v2 = (void *)a1[7];

  swift_errorRelease(v2);
}

void *initializeWithCopy for EncodingError(void *a1, void *a2)
{
  uint64_t v4 = a2[3];
  a1[3] = v4;
  (**(void (***)(void))(v4 - 8))();
  unint64_t v5 = a2[4];
  uint64_t v6 = a2[5];
  a1[4] = v5;
  a1[5] = v6;
  unint64_t v8 = a2[6];
  v7 = (void *)a2[7];
  a1[6] = v8;
  swift_bridgeObjectRetain(v5);
  swift_bridgeObjectRetain(v8);
  swift_errorRetain(v7);
  a1[7] = v7;
  return a1;
}

uint64_t *assignWithCopy for EncodingError(uint64_t *a1, void *a2)
{
  __swift_assign_boxed_opaque_existential_0(a1, (uint64_t)a2);
  unint64_t v4 = a2[4];
  uint64_t v5 = a1[4];
  a1[4] = v4;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  a1[5] = a2[5];
  unint64_t v6 = a2[6];
  uint64_t v7 = a1[6];
  a1[6] = v6;
  swift_bridgeObjectRetain(v6);
  swift_bridgeObjectRelease(v7);
  unint64_t v8 = (void *)a1[7];
  uint64_t v9 = (void *)a2[7];
  swift_errorRetain(v9);
  a1[7] = (uint64_t)v9;
  swift_errorRelease(v8);
  return a1;
}

uint64_t *__swift_assign_boxed_opaque_existential_0(uint64_t *result, uint64_t a2)
{
  if (result != (uint64_t *)a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = result[3];
    uint64_t v5 = *(void *)(a2 + 24);
    if (v4 == v5)
    {
      uint64_t v10 = *(void *)(v4 - 8);
      if ((*(unsigned char *)(v10 + 82) & 2) != 0)
      {
        uint64_t v13 = *result;
        v14 = *(atomic_ullong **)a2;
        swift_retain(*(atomic_ullong **)a2);
        __n128 result = (uint64_t *)swift_release(v13);
        *uint64_t v3 = v14;
      }
      else
      {
        uint64_t v11 = *(uint64_t (**)(void))(v10 + 24);
        return (uint64_t *)v11();
      }
    }
    else
    {
      result[3] = v5;
      uint64_t v6 = *(void *)(v4 - 8);
      uint64_t v7 = *(void *)(v5 - 8);
      uint64_t v8 = v7;
      int v9 = *(_DWORD *)(v7 + 80);
      if ((*(unsigned char *)(v6 + 82) & 2) != 0)
      {
        uint64_t v12 = *result;
        if ((v9 & 0x20000) != 0)
        {
          v16 = *(atomic_ullong **)a2;
          *uint64_t v3 = *(void *)a2;
          swift_retain(v16);
        }
        else
        {
          (*(void (**)(uint64_t *, uint64_t, uint64_t))(v7 + 16))(result, a2, v5);
        }
        return (uint64_t *)swift_release(v12);
      }
      else
      {
        (*(void (**)(unsigned char *, uint64_t *, uint64_t))(v6 + 32))(v17, result, v4);
        if ((v9 & 0x20000) != 0)
        {
          uint64_t v15 = *(atomic_ullong **)a2;
          *uint64_t v3 = *(void *)a2;
          swift_retain(v15);
        }
        else
        {
          (*(void (**)(void *, uint64_t, uint64_t))(v8 + 16))(v3, a2, v5);
        }
        return (uint64_t *)(*(uint64_t (**)(unsigned char *, uint64_t))(v6 + 8))(v17, v4);
      }
    }
  }
  return result;
}

__n128 __swift_memcpy64_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t assignWithTake for EncodingError(uint64_t a1, uint64_t a2)
{
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  uint64_t v5 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  swift_bridgeObjectRelease(v5);
  uint64_t v6 = *(void *)(a2 + 48);
  uint64_t v7 = *(void *)(a1 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v6;
  swift_bridgeObjectRelease(v7);
  uint64_t v8 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  swift_errorRelease(v8);
  return a1;
}

uint64_t getEnumTagSinglePayload for EncodingError(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 64)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for EncodingError(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 56) = 0;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 64) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 24) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 64) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for EncodingError()
{
  return &type metadata for EncodingError;
}

ValueMetadata *type metadata accessor for EncodingError.Context()
{
  return &type metadata for EncodingError.Context;
}

void destroy for DecodingError(uint64_t a1)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 72);
  if (v2 >= 4) {
    unsigned int v2 = *(_DWORD *)a1 + 4;
  }
  switch(v2)
  {
    case 2u:
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
      swift_bridgeObjectRelease(*(void *)(a1 + 40));
      swift_bridgeObjectRelease(*(void *)(a1 + 56));
      long long v3 = (void **)(a1 + 64);
      break;
    case 3u:
      swift_bridgeObjectRelease(*(void *)a1);
      swift_bridgeObjectRelease(*(void *)(a1 + 16));
      long long v3 = (void **)(a1 + 24);
      break;
    default:
      swift_bridgeObjectRelease(*(void *)(a1 + 8));
      swift_bridgeObjectRelease(*(void *)(a1 + 24));
      long long v3 = (void **)(a1 + 32);
      break;
  }
  long long v4 = *v3;

  swift_errorRelease(v4);
}

uint64_t initializeWithCopy for DecodingError(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(unsigned __int8 *)(a2 + 72);
  if (v4 >= 4) {
    unsigned int v4 = *(_DWORD *)a2 + 4;
  }
  switch(v4)
  {
    case 1u:
      unint64_t v18 = *(void *)(a2 + 8);
      *(void *)a1 = *(void *)a2;
      *(void *)(a1 + 8) = v18;
      unint64_t v19 = *(void *)(a2 + 24);
      *(void *)(a1 + 16) = *(void *)(a2 + 16);
      *(void *)(a1 + 24) = v19;
      v20 = *(void **)(a2 + 32);
      swift_bridgeObjectRetain(v18);
      swift_bridgeObjectRetain(v19);
      swift_errorRetain(v20);
      *(void *)(a1 + 32) = v20;
      char v8 = 1;
      break;
    case 2u:
      long long v9 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v9;
      (**(void (***)(uint64_t, uint64_t))(v9 - 8))(a1, a2);
      unint64_t v10 = *(void *)(a2 + 40);
      uint64_t v11 = *(void *)(a2 + 48);
      *(void *)(a1 + 40) = v10;
      *(void *)(a1 + 48) = v11;
      unint64_t v13 = *(void *)(a2 + 56);
      uint64_t v12 = *(void **)(a2 + 64);
      *(void *)(a1 + 56) = v13;
      swift_bridgeObjectRetain(v10);
      swift_bridgeObjectRetain(v13);
      swift_errorRetain(v12);
      *(void *)(a1 + 64) = v12;
      char v8 = 2;
      break;
    case 3u:
      unint64_t v14 = *(void *)a2;
      uint64_t v15 = *(void *)(a2 + 8);
      *(void *)a1 = *(void *)a2;
      *(void *)(a1 + 8) = v15;
      unint64_t v17 = *(void *)(a2 + 16);
      v16 = *(void **)(a2 + 24);
      *(void *)(a1 + 16) = v17;
      swift_bridgeObjectRetain(v14);
      swift_bridgeObjectRetain(v17);
      swift_errorRetain(v16);
      *(void *)(a1 + 24) = v16;
      char v8 = 3;
      break;
    default:
      unint64_t v5 = *(void *)(a2 + 8);
      *(void *)a1 = *(void *)a2;
      *(void *)(a1 + 8) = v5;
      unint64_t v6 = *(void *)(a2 + 24);
      *(void *)(a1 + 16) = *(void *)(a2 + 16);
      *(void *)(a1 + 24) = v6;
      uint64_t v7 = *(void **)(a2 + 32);
      swift_bridgeObjectRetain(v5);
      swift_bridgeObjectRetain(v6);
      swift_errorRetain(v7);
      char v8 = 0;
      *(void *)(a1 + 32) = v7;
      break;
  }
  *(unsigned char *)(a1 + 72) = v8;
  return a1;
}

uint64_t assignWithCopy for DecodingError(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unsigned int v4 = *(unsigned __int8 *)(a1 + 72);
    if (v4 >= 4) {
      unsigned int v4 = *(_DWORD *)a1 + 4;
    }
    switch(v4)
    {
      case 2u:
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
        swift_bridgeObjectRelease(*(void *)(a1 + 40));
        swift_bridgeObjectRelease(*(void *)(a1 + 56));
        unint64_t v5 = (id *)(a1 + 64);
        break;
      case 3u:
        swift_bridgeObjectRelease(*(void *)a1);
        swift_bridgeObjectRelease(*(void *)(a1 + 16));
        unint64_t v5 = (id *)(a1 + 24);
        break;
      default:
        swift_bridgeObjectRelease(*(void *)(a1 + 8));
        swift_bridgeObjectRelease(*(void *)(a1 + 24));
        unint64_t v5 = (id *)(a1 + 32);
        break;
    }
    swift_errorRelease(*v5);
    unsigned int v6 = *(unsigned __int8 *)(a2 + 72);
    if (v6 >= 4) {
      unsigned int v6 = *(_DWORD *)a2 + 4;
    }
    switch(v6)
    {
      case 1u:
        *(void *)a1 = *(void *)a2;
        unint64_t v11 = *(void *)(a2 + 8);
        *(void *)(a1 + 8) = v11;
        *(void *)(a1 + 16) = *(void *)(a2 + 16);
        unint64_t v12 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v12;
        unint64_t v13 = *(void **)(a2 + 32);
        swift_bridgeObjectRetain(v11);
        swift_bridgeObjectRetain(v12);
        swift_errorRetain(v13);
        *(void *)(a1 + 32) = v13;
        char v10 = 1;
        break;
      case 2u:
        uint64_t v14 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v14;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        (**(void (***)(uint64_t, uint64_t))(v14 - 8))(a1, a2);
        unint64_t v15 = *(void *)(a2 + 40);
        *(void *)(a1 + 40) = v15;
        *(void *)(a1 + 48) = *(void *)(a2 + 48);
        unint64_t v16 = *(void *)(a2 + 56);
        *(void *)(a1 + 56) = v16;
        unint64_t v17 = *(void **)(a2 + 64);
        swift_bridgeObjectRetain(v15);
        swift_bridgeObjectRetain(v16);
        swift_errorRetain(v17);
        *(void *)(a1 + 64) = v17;
        char v10 = 2;
        break;
      case 3u:
        unint64_t v18 = *(void *)a2;
        *(void *)a1 = *(void *)a2;
        *(void *)(a1 + 8) = *(void *)(a2 + 8);
        unint64_t v19 = *(void *)(a2 + 16);
        *(void *)(a1 + 16) = v19;
        v20 = *(void **)(a2 + 24);
        swift_bridgeObjectRetain(v18);
        swift_bridgeObjectRetain(v19);
        swift_errorRetain(v20);
        *(void *)(a1 + 24) = v20;
        char v10 = 3;
        break;
      default:
        *(void *)a1 = *(void *)a2;
        unint64_t v7 = *(void *)(a2 + 8);
        *(void *)(a1 + 8) = v7;
        *(void *)(a1 + 16) = *(void *)(a2 + 16);
        unint64_t v8 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v8;
        long long v9 = *(void **)(a2 + 32);
        swift_bridgeObjectRetain(v7);
        swift_bridgeObjectRetain(v8);
        swift_errorRetain(v9);
        char v10 = 0;
        *(void *)(a1 + 32) = v9;
        break;
    }
    *(unsigned char *)(a1 + 72) = v10;
  }
  return a1;
}

__n128 __swift_memcpy73_8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  long long v3 = *(_OWORD *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 57) = *(_OWORD *)(a2 + 57);
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t assignWithTake for DecodingError(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unsigned int v4 = *(unsigned __int8 *)(a1 + 72);
    if (v4 >= 4) {
      unsigned int v4 = *(_DWORD *)a1 + 4;
    }
    switch(v4)
    {
      case 2u:
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
        swift_bridgeObjectRelease(*(void *)(a1 + 40));
        swift_bridgeObjectRelease(*(void *)(a1 + 56));
        unint64_t v5 = (id *)(a1 + 64);
        break;
      case 3u:
        swift_bridgeObjectRelease(*(void *)a1);
        swift_bridgeObjectRelease(*(void *)(a1 + 16));
        unint64_t v5 = (id *)(a1 + 24);
        break;
      default:
        swift_bridgeObjectRelease(*(void *)(a1 + 8));
        swift_bridgeObjectRelease(*(void *)(a1 + 24));
        unint64_t v5 = (id *)(a1 + 32);
        break;
    }
    swift_errorRelease(*v5);
    unsigned int v6 = *(unsigned __int8 *)(a2 + 72);
    if (v6 >= 4) {
      unsigned int v6 = *(_DWORD *)a2 + 4;
    }
    switch(v6)
    {
      case 1u:
        long long v9 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v9;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        char v7 = 1;
        break;
      case 2u:
        long long v10 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a1 + 48) = v10;
        *(void *)(a1 + 64) = *(void *)(a2 + 64);
        long long v11 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v11;
        char v7 = 2;
        break;
      case 3u:
        long long v12 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v12;
        char v7 = 3;
        break;
      default:
        char v7 = 0;
        long long v8 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v8;
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        break;
    }
    *(unsigned char *)(a1 + 72) = v7;
  }
  return a1;
}

uint64_t getEnumTagSinglePayload for DecodingError(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFD && *(unsigned char *)(a1 + 73)) {
    return (*(_DWORD *)a1 + 253);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 72);
  if (v3 >= 4) {
    return (v3 ^ 0xFF) + 1;
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for DecodingError(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFC)
  {
    *(_OWORD *)(result + 57) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)__n128 result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)__n128 result = a2 - 253;
    if (a3 >= 0xFD) {
      *(unsigned char *)(result + 73) = 1;
    }
  }
  else
  {
    if (a3 >= 0xFD) {
      *(unsigned char *)(result + 73) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 72) = -(char)a2;
    }
  }
  return result;
}

uint64_t getEnumTag for DecodingError(uint64_t a1)
{
  uint64_t result = *(unsigned __int8 *)(a1 + 72);
  if (result >= 4) {
    return (*(_DWORD *)a1 + 4);
  }
  return result;
}

uint64_t destructiveInjectEnumTag for DecodingError(uint64_t result, unsigned int a2)
{
  if (a2 > 3)
  {
    *(void *)(result + 64) = 0;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)uint64_t result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)uint64_t result = a2 - 4;
    LOBYTE(a2) = 4;
  }
  *(unsigned char *)(result + 72) = a2;
  return result;
}

ValueMetadata *type metadata accessor for DecodingError()
{
  return &type metadata for DecodingError;
}

void destroy for EncodingError.Context(uint64_t *a1)
{
  swift_bridgeObjectRelease(*a1);
  swift_bridgeObjectRelease(a1[2]);
  unsigned int v2 = (void *)a1[3];

  swift_errorRelease(v2);
}

unint64_t *initializeWithCopy for EncodingError.Context(unint64_t *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  unint64_t v5 = a2[2];
  unsigned int v6 = (void *)a2[3];
  a1[2] = v5;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRetain(v5);
  swift_errorRetain(v6);
  a1[3] = (unint64_t)v6;
  return a1;
}

uint64_t *assignWithCopy for EncodingError.Context(uint64_t *a1, unint64_t *a2)
{
  unint64_t v4 = *a2;
  uint64_t v5 = *a1;
  *a1 = *a2;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  a1[1] = a2[1];
  unint64_t v6 = a2[2];
  uint64_t v7 = a1[2];
  a1[2] = v6;
  swift_bridgeObjectRetain(v6);
  swift_bridgeObjectRelease(v7);
  long long v8 = (void *)a1[3];
  long long v9 = (void *)a2[3];
  swift_errorRetain(v9);
  a1[3] = (uint64_t)v9;
  swift_errorRelease(v8);
  return a1;
}

uint64_t *assignWithTake for EncodingError.Context(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  *a1 = *(void *)a2;
  swift_bridgeObjectRelease(v4);
  a1[1] = *(void *)(a2 + 8);
  swift_bridgeObjectRelease(a1[2]);
  uint64_t v5 = (void *)a1[3];
  *((_OWORD *)a1 + 1) = *(_OWORD *)(a2 + 16);
  swift_errorRelease(v5);
  return a1;
}

ValueMetadata *type metadata accessor for DecodingError.Context()
{
  return &type metadata for DecodingError.Context;
}

uint64_t type metadata accessor for _KeyedEncodingContainerBase()
{
  return self;
}

void *type metadata completion function for _KeyedEncodingContainerBox(uint64_t a1)
{
  uint64_t result = swift_checkMetadataState(319, *(void *)(a1 + 416));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    uint64_t result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 432);
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t type metadata accessor for _KeyedDecodingContainerBase()
{
  return self;
}

void *type metadata completion function for _KeyedDecodingContainerBox(uint64_t a1)
{
  uint64_t result = swift_checkMetadataState(319, *(void *)(a1 + 424));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    uint64_t result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 440);
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t dispatch thunk of CodingKeyRepresentable.codingKey.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of CodingKeyRepresentable.init<A>(codingKey:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 16))();
}

void *type metadata completion function for IndexingIterator(uint64_t a1)
{
  unsigned int v2 = swift_checkMetadataState(319, *(void *)(a1 + 16));
  unint64_t v3 = v2;
  if (v4 <= 0x3F)
  {
    v8[0] = *(v2 - 1) + 64;
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(319, *(int ***)(a1 + 24), (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
    unint64_t v3 = (void *)AssociatedTypeWitness;
    if (v6 <= 0x3F)
    {
      v8[1] = *((void *)AssociatedTypeWitness - 1) + 64;
      swift_initStructMetadata(a1, 0, 2uLL, (uint64_t)v8, a1 + 32);
      return 0;
    }
  }
  return v3;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for IndexingIterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void *)(v6 + 64);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = *(_DWORD *)(v9 + 80);
  uint64_t v11 = v7 + v10;
  uint64_t v12 = (*(unsigned char *)(v6 + 80) | *(unsigned char *)(v9 + 80));
  if (v12 > 7
    || ((*(_DWORD *)(v6 + 80) | *(_DWORD *)(v9 + 80)) & 0x100000) != 0
    || (v11 & (unint64_t)~v10) + *(void *)(*((void *)AssociatedTypeWitness - 1) + 64) > 0x18)
  {
    unint64_t v15 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v15 + ((v12 + 16) & ~v12));
    swift_retain(v15);
  }
  else
  {
    unint64_t v16 = AssociatedTypeWitness;
    uint64_t v17 = ~v10;
    (*(void (**)(atomic_ullong **, atomic_ullong **, uint64_t))(v6 + 16))(a1, a2, v5);
    (*(void (**)(unint64_t, unint64_t, const char *))(v9 + 16))(((unint64_t)a1 + v11) & v17, ((unint64_t)a2 + v11) & v17, v16);
  }
  return a1;
}

uint64_t destroy for IndexingIterator(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8) + 8;
  (*(void (**)(uint64_t, uint64_t))v5)(a1, v4);
  uint64_t v6 = *(void *)(v5 + 56) + a1;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = *(uint64_t (**)(unint64_t, const char *))(v8 + 8);
  uint64_t v10 = AssociatedTypeWitness;
  unint64_t v11 = (v6 + *(unsigned __int8 *)(v8 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80);

  return v9(v11, v10);
}

uint64_t initializeWithCopy for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8) + 16;
  (*(void (**)(uint64_t, uint64_t, uint64_t))v7)(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v10 + 16))((v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8) + 24;
  (*(void (**)(uint64_t, uint64_t, uint64_t))v7)(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 40);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v10 + 24))((v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8) + 32;
  (*(void (**)(uint64_t, uint64_t, uint64_t))v7)(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 32);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v10 + 32))((v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for IndexingIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8) + 40;
  (*(void (**)(uint64_t, uint64_t, uint64_t))v7)(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v10 + 40))((v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for IndexingIterator(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(unsigned int *)(v6 + 84);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  unsigned int v10 = *(_DWORD *)(v9 + 84);
  if (v10 <= v7) {
    unsigned int v11 = v7;
  }
  else {
    unsigned int v11 = *(_DWORD *)(v9 + 84);
  }
  uint64_t v12 = *(unsigned __int8 *)(v9 + 80);
  if (!a2) {
    return 0;
  }
  uint64_t v13 = *(void *)(v6 + 64) + v12;
  if (a2 <= v11) {
    goto LABEL_24;
  }
  uint64_t v14 = (v13 & ~v12) + *(void *)(*((void *)AssociatedTypeWitness - 1) + 64);
  char v15 = 8 * v14;
  if (v14 <= 3)
  {
    unsigned int v17 = ((a2 - v11 + ~(-1 << v15)) >> v15) + 1;
    if (HIWORD(v17))
    {
      int v16 = *(_DWORD *)((char *)a1 + v14);
      if (!v16) {
        goto LABEL_24;
      }
      goto LABEL_14;
    }
    if (v17 > 0xFF)
    {
      int v16 = *(unsigned __int16 *)((char *)a1 + v14);
      if (!*(unsigned __int16 *)((char *)a1 + v14)) {
        goto LABEL_24;
      }
      goto LABEL_14;
    }
    if (v17 < 2)
    {
LABEL_24:
      if (v11)
      {
        if (v7 >= v10)
        {
          v23 = *(uint64_t (**)(unsigned __int16 *, uint64_t, uint64_t))(v6 + 48);
          return v23(a1, v7, v5);
        }
        else
        {
          uint64_t v21 = *(uint64_t (**)(unint64_t))(v9 + 48);
          return v21(((unint64_t)a1 + v13) & ~v12);
        }
      }
      return 0;
    }
  }
  int v16 = *((unsigned __int8 *)a1 + v14);
  if (!*((unsigned char *)a1 + v14)) {
    goto LABEL_24;
  }
LABEL_14:
  int v18 = (v16 - 1) << v15;
  if (v14 > 3) {
    int v18 = 0;
  }
  if (v14)
  {
    if (v14 <= 3) {
      int v19 = v14;
    }
    else {
      int v19 = 4;
    }
    switch(v19)
    {
      case 2:
        int v20 = *a1;
        break;
      case 3:
        int v20 = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        int v20 = *(_DWORD *)a1;
        break;
      default:
        int v20 = *(unsigned __int8 *)a1;
        break;
    }
  }
  else
  {
    int v20 = 0;
  }
  return v11 + (v20 | v18) + 1;
}

void storeEnumTagSinglePayload for IndexingIterator(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v24 = v8;
  uint64_t v9 = *(unsigned int *)(v8 + 84);
  uint64_t v10 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 24), v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index)- 1);
  uint64_t v11 = v10;
  unsigned int v12 = *(_DWORD *)(v10 + 84);
  if (v12 <= v9) {
    unsigned int v13 = v9;
  }
  else {
    unsigned int v13 = *(_DWORD *)(v10 + 84);
  }
  uint64_t v14 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v15 = *(void *)(v8 + 64) + v14;
  size_t v16 = (v15 & ~v14) + *(void *)(v10 + 64);
  if (a3 <= v13)
  {
    int v17 = 0;
  }
  else if (v16 <= 3)
  {
    unsigned int v20 = ((a3 - v13 + ~(-1 << (8 * v16))) >> (8 * v16)) + 1;
    if (HIWORD(v20))
    {
      int v17 = 4;
    }
    else if (v20 >= 0x100)
    {
      int v17 = 2;
    }
    else
    {
      int v17 = v20 > 1;
    }
  }
  else
  {
    int v17 = 1;
  }
  if (v13 < a2)
  {
    unsigned int v18 = ~v13 + a2;
    if (v16 < 4)
    {
      int v19 = (v18 >> (8 * v16)) + 1;
      if (v16)
      {
        int v21 = v18 & ~(-1 << (8 * v16));
        bzero(a1, v16);
        if (v16 == 3)
        {
          *(_WORD *)a1 = v21;
          a1[2] = BYTE2(v21);
        }
        else if (v16 == 2)
        {
          *(_WORD *)a1 = v21;
        }
        else
        {
          *a1 = v21;
        }
      }
    }
    else
    {
      bzero(a1, v16);
      *(_DWORD *)a1 = v18;
      int v19 = 1;
    }
    switch(v17)
    {
      case 1:
        a1[v16] = v19;
        return;
      case 2:
        *(_WORD *)&a1[v16] = v19;
        return;
      case 3:
        goto LABEL_41;
      case 4:
        *(_DWORD *)&a1[v16] = v19;
        return;
      default:
        return;
    }
  }
  switch(v17)
  {
    case 1:
      a1[v16] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 2:
      *(_WORD *)&a1[v16] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 3:
LABEL_41:
      __break(1u);
      JUMPOUT(0x181509AD0);
    case 4:
      *(_DWORD *)&a1[v16] = 0;
      goto LABEL_23;
    default:
LABEL_23:
      if (a2)
      {
LABEL_24:
        if (v9 >= v12)
        {
          v23 = *(void (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(v24 + 56);
          v23(a1, a2, v9, v7);
        }
        else
        {
          v22 = *(void (**)(unint64_t, uint64_t))(v11 + 56);
          v22((unint64_t)&a1[v15] & ~v14, a2);
        }
      }
      return;
  }
}

uint64_t dispatch thunk of Collection.startIndex.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

uint64_t dispatch thunk of Collection.endIndex.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

uint64_t dispatch thunk of Collection.subscript.read(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 80))();
}

uint64_t dispatch thunk of Collection.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 88))();
}

uint64_t dispatch thunk of Collection.indices.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 96))();
}

uint64_t dispatch thunk of Collection.isEmpty.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 104))();
}

uint64_t dispatch thunk of Collection.count.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

uint64_t dispatch thunk of Collection._customIndexOfEquatableElement(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

uint64_t dispatch thunk of Collection._customLastIndexOfEquatableElement(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 128))();
}

uint64_t dispatch thunk of Collection.index(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 136))();
}

uint64_t dispatch thunk of Collection.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 144))();
}

uint64_t dispatch thunk of Collection.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 152))();
}

uint64_t dispatch thunk of Collection._failEarlyRangeCheck(_:bounds:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 160))();
}

{
  return (*(uint64_t (**)(void))(a4 + 168))();
}

{
  return (*(uint64_t (**)(void))(a4 + 176))();
}

uint64_t dispatch thunk of Collection.index(after:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 184))();
}

uint64_t dispatch thunk of Collection.formIndex(after:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 192))();
}

uint64_t dispatch thunk of static Comparable.< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 16))();
}

uint64_t dispatch thunk of static Comparable.<= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

uint64_t dispatch thunk of static Comparable.>= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t dispatch thunk of static Comparable.> infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 40))();
}

uint64_t dispatch thunk of RawRepresentable.init(rawValue:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 16))();
}

uint64_t dispatch thunk of RawRepresentable.rawValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t default associated conformance accessor for CaseIterable.CaseIterable.AllCases: Collection(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  return swift_getWitnessTable(protocol conformance descriptor for [A], a1, a3);
}

uint64_t dispatch thunk of static CaseIterable.allCases.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of ExpressibleByNilLiteral.init(nilLiteral:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 8))();
}

uint64_t dispatch thunk of ExpressibleByIntegerLiteral.init(integerLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of _ExpressibleByBuiltinFloatLiteral.init(_builtinFloatLiteral:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of ExpressibleByFloatLiteral.init(floatLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of _ExpressibleByBuiltinBooleanLiteral.init(_builtinBooleanLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of ExpressibleByBooleanLiteral.init(BOOLeanLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of _ExpressibleByBuiltinUnicodeScalarLiteral.init(_builtinUnicodeScalarLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of _ExpressibleByBuiltinExtendedGraphemeClusterLiteral.init(_builtinExtendedGraphemeClusterLiteral:utf8CodeUnitCount:isASCII:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 16))();
}

uint64_t dispatch thunk of ExpressibleByExtendedGraphemeClusterLiteral.init(extendedGraphemeClusterLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of _ExpressibleByBuiltinStringLiteral.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 16))();
}

uint64_t dispatch thunk of ExpressibleByStringLiteral.init(stringLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of ExpressibleByArrayLiteral.init(arrayLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 16))();
}

uint64_t dispatch thunk of ExpressibleByDictionaryLiteral.init(dictionaryLiteral:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of ExpressibleByStringInterpolation.init(stringInterpolation:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of StringInterpolationProtocol.init(literalCapacity:interpolationCount:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

uint64_t dispatch thunk of StringInterpolationProtocol.appendLiteral(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of _ExpressibleByColorLiteral.init(_colorLiteralRed:green:blue:alpha:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of _ExpressibleByImageLiteral.init(imageLiteralResourceName:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 8))();
}

uint64_t dispatch thunk of _ExpressibleByFileReferenceLiteral.init(fileReferenceLiteralResourceName:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 8))();
}

uint64_t dispatch thunk of _HasContiguousBytes.withUnsafeBytes<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 8))();
}

uint64_t dispatch thunk of _HasContiguousBytes._providesContiguousBytesNoCopy.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t type metadata accessor for __EmptyArrayStorage()
{
  return self;
}

uint64_t method lookup function for __EmptyArrayStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for __EmptyArrayStorage.Flags);
}

uint64_t dispatch thunk of __EmptyArrayStorage.__allocating_init(_doNotCallMe:)()
{
  return (*(uint64_t (**)(void))(v0 + 144))();
}

uint64_t method lookup function for __StaticArrayStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for __StaticArrayStorage.Flags);
}

uint64_t dispatch thunk of __StaticArrayStorage.__allocating_init(_doNotCallMe:)()
{
  return (*(uint64_t (**)(void))(v0 + 144))();
}

swift *type metadata completion function for _ContiguousArrayStorage(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0, (uint64_t)v2, a1 + 152);
}

uint64_t initializeBufferWithCopyOfBuffer for _UnsafePartiallyInitializedContiguousArrayBuffer(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(atomic_ullong **)a2;
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  swift_retain(v3);
  return a1;
}

uint64_t *assignWithCopy for _UnsafePartiallyInitializedContiguousArrayBuffer(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *(atomic_ullong **)a2;
  uint64_t v5 = *a1;
  *a1 = *(void *)a2;
  swift_retain(v4);
  swift_release(v5);
  a1[1] = *(void *)(a2 + 8);
  a1[2] = *(void *)(a2 + 16);
  return a1;
}

__n128 __swift_memcpy24_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  *a1 = result;
  return result;
}

uint64_t *assignWithTake for _UnsafePartiallyInitializedContiguousArrayBuffer(uint64_t *a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  a1[2] = *(void *)(a2 + 16);
  return a1;
}

Class *type metadata accessor for _UnsafePartiallyInitializedContiguousArrayBuffer(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _UnsafePartiallyInitializedContiguousArrayBuffer.Flags);
}

ValueMetadata *type metadata accessor for OpaquePointer()
{
  return &type metadata for OpaquePointer;
}

ValueMetadata *type metadata accessor for CVaListPointer()
{
  return &type metadata for CVaListPointer;
}

ValueMetadata *type metadata accessor for _DebuggerSupport()
{
  return &type metadata for _DebuggerSupport;
}

void *type metadata instantiation function for Dictionary(_DWORD *a1, const void *a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, 40);
}

Class *type metadata accessor for Dictionary.Values(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Dictionary.Values.Flags);
}

atomic_ullong *initializeBufferWithCopyOfBuffer for Dictionary.Keys.Iterator(atomic_ullong **a1, atomic_ullong **a2)
{
  unsigned int v2 = *a2;
  *a1 = *a2;
  unint64_t v3 = v2 + 2;
  swift_retain(v2);
  return v3;
}

uint64_t destroy for Dictionary.Keys.Iterator(void *a1, uint64_t a2)
{
  return destroy for Dictionary.Keys.Iterator(a1, a2, (uint64_t (*)(void, void, void, void, void))outlined consume of [A : B].Iterator._Variant<A, B>);
}

void *initializeWithCopy for Dictionary.Keys.Iterator(void *a1, void *a2, uint64_t a3)
{
  return initializeWithCopy for Dictionary.Keys.Iterator(a1, a2, a3, (void (*)(void, uint64_t, uint64_t, uint64_t, uint64_t))outlined copy of [A : B].Iterator._Variant<A, B>);
}

uint64_t *assignWithCopy for Dictionary.Keys.Iterator(uint64_t *a1, void *a2, uint64_t a3)
{
  return assignWithCopy for Dictionary.Keys.Iterator(a1, a2, a3, (void (*)(void, uint64_t, uint64_t, uint64_t, uint64_t))outlined copy of [A : B].Iterator._Variant<A, B>, (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))outlined consume of [A : B].Iterator._Variant<A, B>);
}

__n128 __swift_memcpy40_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

void *assignWithTake for Dictionary.Keys.Iterator(void *a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for Dictionary.Keys.Iterator(a1, a2, a3, (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))outlined consume of [A : B].Iterator._Variant<A, B>);
}

Class *type metadata accessor for Dictionary.Keys.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Dictionary.Keys.Iterator.Flags);
}

Class *type metadata accessor for Dictionary.Values.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Dictionary.Values.Iterator.Flags);
}

ValueMetadata *type metadata accessor for _MergeError()
{
  return &type metadata for _MergeError;
}

uint64_t initializeBufferWithCopyOfBuffer for Dictionary.Index(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for Dictionary.Index(a1, a2, a3, (void (*)(void, uint64_t, uint64_t))outlined copy of [A : B].Index._Variant<A, B>);
}

uint64_t *assignWithCopy for Dictionary.Index(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return assignWithCopy for Dictionary.Index(a1, a2, a3, (void (*)(void, uint64_t, uint64_t))outlined copy of [A : B].Index._Variant<A, B>, (void (*)(uint64_t, uint64_t, uint64_t))outlined consume of [A : B].Index._Variant<A, B>);
}

__n128 __swift_memcpy17_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u8[0] = a2[1].n128_u8[0];
  *a1 = result;
  return result;
}

uint64_t *assignWithTake for Dictionary.Index(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for Dictionary.Index(a1, a2, a3, (void (*)(uint64_t, uint64_t, uint64_t))outlined consume of [A : B].Index._Variant<A, B>);
}

Class *type metadata accessor for Dictionary.Index(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Dictionary.Index.Flags, &flag for loading of canonical specialized generic type metadata for Dictionary.Index);
}

void destroy for Dictionary.Index._Variant(uint64_t a1)
{
}

uint64_t getEnumTag for Dictionary.Index._Variant(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 16);
}

uint64_t destructiveInjectEnumTag for Dictionary.Index._Variant(uint64_t result, char a2)
{
  *(unsigned char *)(result + 16) = a2 & 1;
  return result;
}

Class *type metadata accessor for Dictionary.Index._Variant(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Dictionary.Index._Variant.Flags);
}

Class *type metadata accessor for Dictionary.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Dictionary.Iterator.Flags, &flag for loading of canonical specialized generic type metadata for Dictionary.Iterator);
}

uint64_t getEnumTag for Dictionary.Iterator._Variant(void *a1)
{
  return *a1 >> 63;
}

void *destructiveProjectEnumData for Dictionary.Iterator._Variant(void *result)
{
  *result &= ~0x8000000000000000;
  return result;
}

uint64_t *destructiveInjectEnumTag for Dictionary.Iterator._Variant(uint64_t *result, uint64_t a2)
{
  *__n128 result = *result & 0xFFFFFFFFFFFFFF8 | (a2 << 63);
  return result;
}

swift *type metadata completion function for _SwiftDictionaryNSEnumerator(uint64_t a1)
{
  v2[0] = &unk_1ECA04A78;
  v2[1] = "\b";
  v2[2] = &value witness table for Builtin.Int64.size;
  v2[3] = &value witness table for Builtin.Int64.size;
  return swift_initClassMetadata2(a1, 0, 4uLL, (uint64_t)v2, a1 + 120);
}

Class *type metadata accessor for _SwiftDictionaryNSEnumerator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _SwiftDictionaryNSEnumerator.Flags);
}

swift *type metadata completion function for _SwiftDeferredNSDictionary(uint64_t a1)
{
  v2[0] = "\b";
  v2[1] = "\b";
  v2[2] = &unk_1ECA04A78;
  return swift_initClassMetadata2(a1, 0, 3uLL, (uint64_t)v2, a1 + 120);
}

ValueMetadata *type metadata accessor for __CocoaDictionary()
{
  return &type metadata for __CocoaDictionary;
}

ValueMetadata *type metadata accessor for __CocoaDictionary.Index()
{
  return &type metadata for __CocoaDictionary.Index;
}

uint64_t method lookup function for __CocoaDictionary.Iterator(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for __CocoaDictionary.Iterator.Flags);
}

Class *type metadata accessor for _DictionaryBuilder(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _DictionaryBuilder.Flags);
}

uint64_t type metadata accessor for __RawDictionaryStorage()
{
  return self;
}

uint64_t method lookup function for __RawDictionaryStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for __RawDictionaryStorage.Flags);
}

uint64_t type metadata accessor for __EmptyDictionarySingleton()
{
  return self;
}

uint64_t method lookup function for __EmptyDictionarySingleton(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for __EmptyDictionarySingleton.Flags);
}

swift *type metadata completion function for _DictionaryStorage(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0, (uint64_t)v2, a1 + 200);
}

uint64_t method lookup function for _DictionaryStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for _DictionaryStorage.Flags);
}

uint64_t *type metadata completion function for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for DiscontiguousSlice(a1, a2, a3, (uint64_t)&unk_1ECA04A78);
}

const char *type metadata completion function for DiscontiguousSlice.Index(uint64_t a1)
{
  v4[0] = &value witness table for Builtin.Int64.size;
  __n128 result = swift_getAssociatedTypeWitness(319, *(int ***)(a1 + 24), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  if (v3 <= 0x3F)
  {
    v4[1] = *((void *)result - 1) + 64;
    swift_initStructMetadata(a1, 0, 2uLL, (uint64_t)v4, a1 + 32);
    return 0;
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for DiscontiguousSlice.Index(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v7 = *(_DWORD *)(v6 + 80);
  if (v7 > 7
    || (*(_DWORD *)(v6 + 80) & 0x100000) != 0
    || ((v7 + 8) & (unint64_t)~v7) + *(void *)(*((void *)AssociatedTypeWitness - 1) + 64) > 0x18)
  {
    uint64_t v10 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v10 + ((v7 & 0xF8 ^ 0x1F8) & (v7 + 16)));
    swift_retain(v10);
  }
  else
  {
    *a1 = *a2;
    (*(void (**)(unint64_t, unint64_t, const char *))(v6 + 16))(((unint64_t)a1 + v7 + 8) & ~v7, ((unint64_t)a2 + v7 + 8) & ~v7, AssociatedTypeWitness);
  }
  return a1;
}

uint64_t destroy for DiscontiguousSlice.Index(uint64_t a1, uint64_t a2)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v4 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v5 = *(uint64_t (**)(unint64_t, const char *))(v4 + 8);
  uint64_t v6 = AssociatedTypeWitness;
  unint64_t v7 = (a1 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80);

  return v5(v7, v6);
}

void *initializeWithCopy for DiscontiguousSlice.Index(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v6 + 16))(((unint64_t)a1 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), ((unint64_t)a2 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), AssociatedTypeWitness);
  return a1;
}

void *assignWithCopy for DiscontiguousSlice.Index(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v6 + 24))(((unint64_t)a1 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), ((unint64_t)a2 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), AssociatedTypeWitness);
  return a1;
}

void *initializeWithTake for DiscontiguousSlice.Index(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v6 + 32))(((unint64_t)a1 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), ((unint64_t)a2 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), AssociatedTypeWitness);
  return a1;
}

void *assignWithTake for DiscontiguousSlice.Index(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v6 + 40))(((unint64_t)a1 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), ((unint64_t)a2 + *(unsigned __int8 *)(v6 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for DiscontiguousSlice.Index(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  uint64_t v8 = *(unsigned __int8 *)(v6 + 80);
  if (!a2) {
    return 0;
  }
  if (a2 <= v7) {
    goto LABEL_19;
  }
  uint64_t v9 = ((v8 + 8) & ~v8) + *(void *)(*((void *)AssociatedTypeWitness - 1) + 64);
  char v10 = 8 * v9;
  if (v9 <= 3)
  {
    unsigned int v12 = ((a2 - v7 + ~(-1 << v10)) >> v10) + 1;
    if (HIWORD(v12))
    {
      int v11 = *(_DWORD *)((char *)a1 + v9);
      if (!v11) {
        goto LABEL_19;
      }
      goto LABEL_11;
    }
    if (v12 > 0xFF)
    {
      int v11 = *(unsigned __int16 *)((char *)a1 + v9);
      if (!*(unsigned __int16 *)((char *)a1 + v9)) {
        goto LABEL_19;
      }
      goto LABEL_11;
    }
    if (v12 < 2)
    {
LABEL_19:
      if (v7)
      {
        uint64_t v14 = *(uint64_t (**)(unint64_t))(v6 + 48);
        return v14(((unint64_t)a1 + v8 + 8) & ~v8);
      }
      return 0;
    }
  }
  int v11 = *((unsigned __int8 *)a1 + v9);
  if (!*((unsigned char *)a1 + v9)) {
    goto LABEL_19;
  }
LABEL_11:
  int v13 = (v11 - 1) << v10;
  if (v9 > 3) {
    int v13 = 0;
  }
  if (v9)
  {
    if (v9 > 3) {
      LODWORD(v9) = 4;
    }
    switch((int)v9)
    {
      case 2:
        LODWORD(v9) = *a1;
        break;
      case 3:
        LODWORD(v9) = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        LODWORD(v9) = *(_DWORD *)a1;
        break;
      default:
        LODWORD(v9) = *(unsigned __int8 *)a1;
        break;
    }
  }
  return v7 + (v9 | v13) + 1;
}

void storeEnumTagSinglePayload for DiscontiguousSlice.Index(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 24), *(void *)(a4 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index)- 1);
  unsigned int v8 = *(_DWORD *)(v7 + 84);
  uint64_t v9 = *(unsigned __int8 *)(v7 + 80);
  size_t v10 = ((v9 + 8) & ~v9) + *(void *)(v7 + 64);
  if (a3 <= v8)
  {
    int v11 = 0;
  }
  else if (v10 <= 3)
  {
    unsigned int v14 = ((a3 - v8 + ~(-1 << (8 * v10))) >> (8 * v10)) + 1;
    if (HIWORD(v14))
    {
      int v11 = 4;
    }
    else if (v14 >= 0x100)
    {
      int v11 = 2;
    }
    else
    {
      int v11 = v14 > 1;
    }
  }
  else
  {
    int v11 = 1;
  }
  if (v8 < a2)
  {
    unsigned int v12 = ~v8 + a2;
    if (v10 < 4)
    {
      int v13 = (v12 >> (8 * v10)) + 1;
      if (v10)
      {
        int v15 = v12 & ~(-1 << (8 * v10));
        bzero(a1, v10);
        if (v10 == 3)
        {
          *(_WORD *)a1 = v15;
          a1[2] = BYTE2(v15);
        }
        else if (v10 == 2)
        {
          *(_WORD *)a1 = v15;
        }
        else
        {
          *a1 = v15;
        }
      }
    }
    else
    {
      bzero(a1, v10);
      *(_DWORD *)a1 = v12;
      int v13 = 1;
    }
    switch(v11)
    {
      case 1:
        a1[v10] = v13;
        return;
      case 2:
        *(_WORD *)&a1[v10] = v13;
        return;
      case 3:
        goto LABEL_34;
      case 4:
        *(_DWORD *)&a1[v10] = v13;
        return;
      default:
        return;
    }
  }
  switch(v11)
  {
    case 1:
      a1[v10] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_21;
    case 2:
      *(_WORD *)&a1[v10] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_21;
    case 3:
LABEL_34:
      __break(1u);
      JUMPOUT(0x18150AE38);
    case 4:
      *(_DWORD *)&a1[v10] = 0;
      goto LABEL_20;
    default:
LABEL_20:
      if (a2)
      {
LABEL_21:
        size_t v16 = *(void (**)(unint64_t, uint64_t))(v7 + 56);
        v16((unint64_t)&a1[v9 + 8] & ~v9, a2);
      }
      return;
  }
}

uint64_t *type metadata completion function for LazyDropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for DiscontiguousSlice(a1, a2, a3, (uint64_t)&unk_1ECA05CB0);
}

void *type metadata instantiation function for EmptyCollection(_DWORD *a1, const void *a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, 16);
}

Class *type metadata accessor for EmptyCollection.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for EmptyCollection.Iterator.Flags);
}

uint64_t dispatch thunk of static Equatable.== infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 8))();
}

uint64_t dispatch thunk of Error._domain.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of Error._code.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of Error._userInfo.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of Error._getEmbeddedNSError()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

Class *type metadata accessor for AnyIterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for AnyIterator.Flags);
}

void *initializeBufferWithCopyOfBuffer for _ClosureBasedIterator(void *a1, void *a2)
{
  unint64_t v3 = (atomic_ullong *)a2[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_retain(v3);
  return a1;
}

uint64_t destroy for _ClosureBasedIterator(uint64_t a1)
{
  return swift_release(*(void *)(a1 + 8));
}

uint64_t assignWithTake for _ClosureBasedIterator(uint64_t a1, _OWORD *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *(_OWORD *)a1 = *a2;
  swift_release(v3);
  return a1;
}

Class *type metadata accessor for _AnyIteratorBoxBase(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _AnyIteratorBoxBase.Flags);
}

uint64_t method lookup function for _AnyIteratorBoxBase(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for _AnyIteratorBoxBase.Flags);
}

uint64_t dispatch thunk of _AnyIteratorBoxBase.__allocating_init()()
{
  return (*(uint64_t (**)(void))(v0 + 88))();
}

uint64_t dispatch thunk of _AnyIteratorBoxBase.next()()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 96))();
}

void *type metadata completion function for _IteratorBox(uint64_t a1)
{
  __n128 result = swift_checkMetadataState(319, *(void *)(a1 + 104));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    __n128 result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 120);
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t method lookup function for _IteratorBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for _IteratorBox.Flags);
}

uint64_t dispatch thunk of _IteratorBox.__allocating_init(_:)()
{
  return (*(uint64_t (**)(void))(v0 + 128))();
}

swift *type metadata completion function for _AnyIteratorBoxBase(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0, (uint64_t)v2, a1 + 88);
}

Class *type metadata accessor for _AnySequenceBox(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _AnySequenceBox.Flags);
}

uint64_t method lookup function for _AnySequenceBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for _AnySequenceBox.Flags);
}

uint64_t dispatch thunk of _AnySequenceBox.__allocating_init()()
{
  return (*(uint64_t (**)(void))(v0 + 88))();
}

uint64_t dispatch thunk of _AnySequenceBox._makeIterator()()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 96))();
}

uint64_t dispatch thunk of _AnySequenceBox._underestimatedCount.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 104))();
}

uint64_t dispatch thunk of _AnySequenceBox._map<A>(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 112))();
}

uint64_t dispatch thunk of _AnySequenceBox._filter(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 120))();
}

uint64_t dispatch thunk of _AnySequenceBox._forEach(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 128))();
}

uint64_t dispatch thunk of _AnySequenceBox.__customContainsEquatableElement(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 136))();
}

uint64_t dispatch thunk of _AnySequenceBox.__copyToContiguousArray()()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 144))();
}

uint64_t dispatch thunk of _AnySequenceBox.__copyContents(initializing:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 152))();
}

uint64_t dispatch thunk of _AnySequenceBox._drop(while:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 160))();
}

uint64_t dispatch thunk of _AnySequenceBox._dropFirst(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 168))();
}

uint64_t dispatch thunk of _AnySequenceBox._dropLast(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 176))();
}

uint64_t dispatch thunk of _AnySequenceBox._prefix(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 184))();
}

uint64_t dispatch thunk of _AnySequenceBox._prefix(while:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 192))();
}

uint64_t dispatch thunk of _AnySequenceBox._suffix(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 200))();
}

swift *type metadata completion function for _AnyCollectionBox(uint64_t a1)
{
  v2[0] = &unk_181633558;
  v2[1] = &unk_181633558;
  return swift_initClassMetadata2(a1, 0, 2uLL, (uint64_t)v2, a1 + 216);
}

Class *type metadata accessor for _AnyCollectionBox(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _AnyCollectionBox.Flags);
}

uint64_t method lookup function for _AnyCollectionBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for _AnyCollectionBox.Flags);
}

uint64_t dispatch thunk of _AnyCollectionBox._dropLast(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 232))();
}

uint64_t dispatch thunk of _AnyCollectionBox._prefix(while:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 240))();
}

uint64_t dispatch thunk of _AnyCollectionBox._suffix(_:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 248))();
}

uint64_t dispatch thunk of _AnyCollectionBox.subscript.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 256))();
}

{
  uint64_t v0;

  return (*(uint64_t (**)(void))(*(void *)v0 + 336))();
}

uint64_t dispatch thunk of _AnyCollectionBox._index(after:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 264))();
}

uint64_t dispatch thunk of _AnyCollectionBox._formIndex(after:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 272))();
}

uint64_t dispatch thunk of _AnyCollectionBox._index(_:offsetBy:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 280))();
}

uint64_t dispatch thunk of _AnyCollectionBox._index(_:offsetBy:limitedBy:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 288))();
}

uint64_t dispatch thunk of _AnyCollectionBox._formIndex(_:offsetBy:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 296))();
}

uint64_t dispatch thunk of _AnyCollectionBox._formIndex(_:offsetBy:limitedBy:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 304))();
}

uint64_t dispatch thunk of _AnyCollectionBox._distance(from:to:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 312))();
}

uint64_t dispatch thunk of _AnyCollectionBox._count.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 320))();
}

uint64_t dispatch thunk of _AnyCollectionBox.__allocating_init(_startIndex:endIndex:)()
{
  return (*(uint64_t (**)(void))(v0 + 328))();
}

swift *type metadata completion function for _AnyBidirectionalCollectionBox(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0, (uint64_t)v2, a1 + 352);
}

uint64_t method lookup function for _AnyBidirectionalCollectionBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for _AnyBidirectionalCollectionBox.Flags);
}

uint64_t dispatch thunk of _AnyBidirectionalCollectionBox._index(before:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 352))();
}

uint64_t dispatch thunk of _AnyBidirectionalCollectionBox._formIndex(before:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 360))();
}

swift *type metadata completion function for _AnyRandomAccessCollectionBox(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0, (uint64_t)v2, a1 + 376);
}

void *type metadata completion function for _SequenceBox(uint64_t a1)
{
  __n128 result = swift_checkMetadataState(319, *(void *)(a1 + 208));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    __n128 result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 224);
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t method lookup function for _SequenceBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for _SequenceBox.Flags);
}

uint64_t dispatch thunk of _SequenceBox.__allocating_init(_base:)()
{
  return (*(uint64_t (**)(void))(v0 + 232))();
}

void *type metadata completion function for _CollectionBox(uint64_t a1)
{
  __n128 result = swift_checkMetadataState(319, *(void *)(a1 + 344));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    __n128 result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 360);
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t method lookup function for _CollectionBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for _CollectionBox.Flags);
}

uint64_t dispatch thunk of _CollectionBox.__allocating_init(_base:)()
{
  return (*(uint64_t (**)(void))(v0 + 368))();
}

void *type metadata completion function for _BidirectionalCollectionBox(uint64_t a1)
{
  __n128 result = swift_checkMetadataState(319, *(void *)(a1 + 368));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    __n128 result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 384);
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t method lookup function for _BidirectionalCollectionBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for _BidirectionalCollectionBox.Flags);
}

uint64_t dispatch thunk of _BidirectionalCollectionBox.__allocating_init(_base:)()
{
  return (*(uint64_t (**)(void))(v0 + 392))();
}

void *type metadata completion function for _RandomAccessCollectionBox(uint64_t a1)
{
  __n128 result = swift_checkMetadataState(319, *(void *)(a1 + 376));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    __n128 result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 392);
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t method lookup function for _RandomAccessCollectionBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for _RandomAccessCollectionBox.Flags);
}

uint64_t dispatch thunk of _RandomAccessCollectionBox.__allocating_init(_base:)()
{
  return (*(uint64_t (**)(void))(v0 + 400))();
}

void *assignWithCopy for _ClosureBasedIterator(void *a1, void *a2)
{
  unint64_t v3 = (atomic_ullong *)a2[1];
  uint64_t v4 = a1[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_retain(v3);
  swift_release(v4);
  return a1;
}

Class *type metadata accessor for AnySequence(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for AnySequence.Flags);
}

uint64_t dispatch thunk of _AnyIndexBox._typeID.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of _AnyIndexBox._unbox<A>()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 16))();
}

uint64_t dispatch thunk of _AnyIndexBox._isEqual(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

uint64_t dispatch thunk of _AnyIndexBox._isLess(than:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t method lookup function for _IndexBox(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for _IndexBox.Flags);
}

uint64_t dispatch thunk of _IndexBox.__allocating_init(_base:)()
{
  return (*(uint64_t (**)(void))(v0 + 104))();
}

long long *initializeBufferWithCopyOfBuffer for AnyIndex(long long *a1, long long *a2)
{
  long long v3 = *a2;
  *a1 = *a2;
  swift_unknownObjectRetain((id)v3);
  return a1;
}

uint64_t assignWithCopy for AnyIndex(uint64_t a1, uint64_t a2)
{
  long long v3 = *(void **)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = *(void *)a2;
  swift_unknownObjectRetain(v3);
  swift_unknownObjectRelease(v5);
  *(void *)(a1 + 8) = v4;
  return a1;
}

id *assignWithTake for AnyIndex(id *a1, _OWORD *a2)
{
  *(_OWORD *)a1 = *a2;
  return a1;
}

ValueMetadata *type metadata accessor for AnyIndex()
{
  return &type metadata for AnyIndex;
}

uint64_t dispatch thunk of _AnyCollectionProtocol._boxID.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

Class *type metadata accessor for AnyCollection(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for AnyCollection.Flags);
}

Class *type metadata accessor for AnyBidirectionalCollection(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for AnyBidirectionalCollection.Flags);
}

Class *type metadata accessor for AnyRandomAccessCollection(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for AnyRandomAccessCollection.Flags);
}

const char *type metadata completion function for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator, (uint64_t)&unk_1ECA05CB0);
}

atomic_ullong **initializeBufferWithCopyOfBuffer for LazyFilterSequence.Iterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v7 = *(void *)(v6 + 64);
  int v8 = *(_DWORD *)(v6 + 80);
  if ((v8 & 0x1000F8) != 0 || ((v7 + 7) & 0xFFFFFFFFFFFFFFF8) + 16 > 0x18)
  {
    int v11 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v11 + ((unsigned __int16)((v8 & 0xF8) + 23) & (unsigned __int16)~(v8 & 0xF8) & 0x1F8));
  }
  else
  {
    (*(void (**)(atomic_ullong **, atomic_ullong **, const char *))(v6 + 16))(a1, a2, AssociatedTypeWitness);
    size_t v10 = (void *)(((unint64_t)a2 + v7 + 7) & 0xFFFFFFFFFFFFFFF8);
    int v11 = (atomic_ullong *)v10[1];
    unsigned int v12 = (void *)(((unint64_t)a1 + v7 + 7) & 0xFFFFFFFFFFFFFFF8);
    void *v12 = *v10;
    v12[1] = v11;
  }
  swift_retain(v11);
  return a1;
}

uint64_t destroy for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v4 = *((void *)AssociatedTypeWitness - 1) + 8;
  (*(void (**)(uint64_t, const char *))v4)(a1, AssociatedTypeWitness);
  uint64_t v5 = *(void *)(((a1 + *(void *)(v4 + 56) + 7) & 0xFFFFFFFFFFFFFFF8) + 8);

  return swift_release(v5);
}

uint64_t initializeWithCopy for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1) + 16;
  (*(void (**)(uint64_t, uint64_t, const char *))v6)(a1, a2, AssociatedTypeWitness);
  uint64_t v7 = *(void *)(v6 + 48) + 7;
  int v8 = (void *)((v7 + a1) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v9 = (void *)((v7 + a2) & 0xFFFFFFFFFFFFFFF8);
  size_t v10 = (atomic_ullong *)v9[1];
  *int v8 = *v9;
  v8[1] = v10;
  swift_retain(v10);
  return a1;
}

uint64_t assignWithCopy for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1) + 24;
  (*(void (**)(uint64_t, uint64_t, const char *))v6)(a1, a2, AssociatedTypeWitness);
  uint64_t v7 = *(void *)(v6 + 40) + 7;
  int v8 = (void *)((v7 + a1) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v9 = (void *)((v7 + a2) & 0xFFFFFFFFFFFFFFF8);
  size_t v10 = (atomic_ullong *)v9[1];
  uint64_t v11 = v8[1];
  *int v8 = *v9;
  v8[1] = v10;
  swift_retain(v10);
  swift_release(v11);
  return a1;
}

uint64_t initializeWithTake for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1) + 32;
  (*(void (**)(uint64_t, uint64_t, const char *))v6)(a1, a2, AssociatedTypeWitness);
  *(_OWORD *)((*(void *)(v6 + 32) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *(_OWORD *)((*(void *)(v6 + 32) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t assignWithTake for LazyFilterSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1) + 40;
  (*(void (**)(uint64_t, uint64_t, const char *))v6)(a1, a2, AssociatedTypeWitness);
  uint64_t v7 = *(void *)(v6 + 24) + 7;
  unint64_t v8 = (v7 + a1) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v9 = *(void *)(v8 + 8);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)((v7 + a2) & 0xFFFFFFFFFFFFFFF8);
  swift_release(v9);
  return a1;
}

uint64_t getEnumTagSinglePayload for LazyFilterSequence.Iterator(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  if (v7 <= 0x7FFFFFFF) {
    unsigned int v8 = 0x7FFFFFFF;
  }
  else {
    unsigned int v8 = *(_DWORD *)(v6 + 84);
  }
  uint64_t v9 = *(void *)(*((void *)AssociatedTypeWitness - 1) + 64);
  if (!a2) {
    return 0;
  }
  if (v8 < a2)
  {
    unint64_t v10 = ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
    uint64_t v11 = v10 & 0xFFFFFFF8;
    if ((v10 & 0xFFFFFFF8) != 0) {
      unsigned int v12 = 2;
    }
    else {
      unsigned int v12 = a2 - v8 + 1;
    }
    if (v12 >= 0x10000) {
      unsigned int v13 = 4;
    }
    else {
      unsigned int v13 = 2;
    }
    if (v12 < 0x100) {
      unsigned int v13 = 1;
    }
    if (v12 >= 2) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0;
    }
    switch(v14)
    {
      case 1:
        int v15 = *((unsigned __int8 *)a1 + v10);
        if (!v15) {
          break;
        }
        goto LABEL_22;
      case 2:
        int v15 = *(unsigned __int16 *)((char *)a1 + v10);
        if (v15) {
          goto LABEL_22;
        }
        break;
      case 3:
        __break(1u);
        JUMPOUT(0x18150C23CLL);
      case 4:
        int v15 = *(_DWORD *)((char *)a1 + v10);
        if (!v15) {
          break;
        }
LABEL_22:
        int v17 = v15 - 1;
        if (v11)
        {
          int v17 = 0;
          LODWORD(v11) = *a1;
        }
        return v8 + (v11 | v17) + 1;
      default:
        break;
    }
  }
  if (v7 < 0x7FFFFFFF)
  {
    unint64_t v19 = *(void *)(((unint64_t)a1 + v9 + 7) & 0xFFFFFFFFFFFFFFF8);
    if (v19 >= 0xFFFFFFFF) {
      LODWORD(v19) = -1;
    }
    return (v19 + 1);
  }
  else
  {
    unsigned int v18 = *(uint64_t (**)(_DWORD *))(v6 + 48);
    return v18(a1);
  }
}

void storeEnumTagSinglePayload for LazyFilterSequence.Iterator(_DWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 24), *(void *)(a4 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator)- 1);
  unsigned int v8 = *(_DWORD *)(v7 + 84);
  uint64_t v9 = *(void *)(v7 + 64);
  if (v8 <= 0x7FFFFFFF) {
    unsigned int v10 = 0x7FFFFFFF;
  }
  else {
    unsigned int v10 = *(_DWORD *)(v7 + 84);
  }
  size_t v11 = ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
  if (((v9 + 7) & 0xFFFFFFF8) == 0xFFFFFFF0) {
    unsigned int v12 = a3 - v10 + 1;
  }
  else {
    unsigned int v12 = 2;
  }
  if (v12 >= 0x10000) {
    int v13 = 4;
  }
  else {
    int v13 = 2;
  }
  if (v12 < 0x100) {
    int v13 = 1;
  }
  if (v12 >= 2) {
    unsigned int v14 = v13;
  }
  else {
    unsigned int v14 = 0;
  }
  if (v10 < a3) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 0;
  }
  if (a2 > v10)
  {
    if (((v9 + 7) & 0xFFFFFFF8) == 0xFFFFFFF0) {
      int v16 = a2 - v10;
    }
    else {
      int v16 = 1;
    }
    if (((v9 + 7) & 0xFFFFFFF8) != 0xFFFFFFF0)
    {
      int v17 = ~v10 + a2;
      bzero(a1, v11);
      *a1 = v17;
    }
    switch(v15)
    {
      case 1:
        *((unsigned char *)a1 + v11) = v16;
        return;
      case 2:
        *(_WORD *)((char *)a1 + v11) = v16;
        return;
      case 3:
        goto LABEL_44;
      case 4:
        *(_DWORD *)((char *)a1 + v11) = v16;
        return;
      default:
        return;
    }
  }
  switch(v15)
  {
    case 1:
      *((unsigned char *)a1 + v11) = 0;
      if (!a2) {
        return;
      }
      goto LABEL_33;
    case 2:
      *(_WORD *)((char *)a1 + v11) = 0;
      if (!a2) {
        return;
      }
      goto LABEL_33;
    case 3:
LABEL_44:
      __break(1u);
      JUMPOUT(0x18150C450);
    case 4:
      *(_DWORD *)((char *)a1 + v11) = 0;
      goto LABEL_32;
    default:
LABEL_32:
      if (a2)
      {
LABEL_33:
        if (v8 < 0x7FFFFFFF)
        {
          unint64_t v19 = (void *)(((unint64_t)a1 + v9 + 7) & 0xFFFFFFFFFFFFFFF8);
          if ((a2 & 0x80000000) != 0)
          {
            uint64_t v20 = a2 ^ 0x80000000;
            v19[1] = 0;
          }
          else
          {
            uint64_t v20 = (a2 - 1);
          }
          *unint64_t v19 = v20;
        }
        else
        {
          unsigned int v18 = *(void (**)(_DWORD *, uint64_t))(v7 + 56);
          v18(a1, a2);
        }
      }
      return;
  }
}

Class *type metadata accessor for FlattenSequence(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for FlattenSequence.Flags);
}

void *type metadata completion function for FlattenSequence.Iterator(void *a1)
{
  uint64_t v3 = a1[2];
  unsigned int v2 = (int **)a1[3];
  __n128 result = swift_getAssociatedTypeWitness(319, v2, v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  if (v5 <= 0x3F)
  {
    v12[0] = *(result - 1) + 64;
    uint64_t v6 = (int **)a1[4];
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v2, v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
    unsigned int v8 = swift_getAssociatedTypeWitness(255, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
    __n128 result = type metadata accessor for Optional(319, (uint64_t)v8, v9, v10);
    if (v11 <= 0x3F)
    {
      v12[1] = *(result - 1) + 64;
      swift_initStructMetadata((uint64_t)a1, 0, 2uLL, (uint64_t)v12, (uint64_t)(a1 + 5));
      return 0;
    }
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for FlattenSequence.Iterator(atomic_ullong **a1, atomic_ullong **a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (int **)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (int **)a3[4];
  unsigned int v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  int v13 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = *(_DWORD *)(v14 + 80);
  uint64_t v16 = v10 + v15;
  if (*(_DWORD *)(v14 + 84)) {
    size_t v17 = *(void *)(v14 + 64);
  }
  else {
    size_t v17 = *(void *)(v14 + 64) + 1;
  }
  uint64_t v18 = (*(unsigned char *)(v9 + 80) | *(unsigned char *)(v14 + 80));
  if (v18 > 7
    || ((*(_DWORD *)(v9 + 80) | *(_DWORD *)(v14 + 80)) & 0x100000) != 0
    || ((v10 + v15) & ~v15) + v17 > 0x18)
  {
    int v21 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v21 + ((v18 + 16) & ~v18));
    swift_retain(v21);
  }
  else
  {
    v22 = v13;
    uint64_t v23 = ~v15;
    (*(void (**)(atomic_ullong **, atomic_ullong **, const char *))(v9 + 16))(a1, a2, AssociatedTypeWitness);
    uint64_t v24 = (const void *)(((unint64_t)a2 + v16) & v23);
    if ((*(unsigned int (**)(const void *, uint64_t, const char *))(v14 + 48))(v24, 1, v22))
    {
      memcpy((void *)(((unint64_t)a1 + v16) & v23), v24, v17);
    }
    else
    {
      (*(void (**)(unint64_t, const void *, const char *))(v14 + 16))(((unint64_t)a1 + v16) & v23, v24, v22);
      (*(void (**)(unint64_t, void, uint64_t, const char *))(v14 + 56))(((unint64_t)a1 + v16) & v23, 0, 1, v22);
    }
  }
  return a1;
}

uint64_t destroy for FlattenSequence.Iterator(uint64_t a1, void *a2)
{
  uint64_t v5 = a2[2];
  uint64_t v4 = (int **)a2[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v4, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1) + 8;
  (*(void (**)(uint64_t, const char *))v7)(a1, AssociatedTypeWitness);
  uint64_t v8 = *(void *)(v7 + 56);
  uint64_t v9 = (int **)a2[4];
  uint64_t v10 = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v11 = swift_getAssociatedTypeWitness(0, v9, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v12 = *((void *)v11 - 1);
  unint64_t v13 = (v8 + a1 + *(unsigned __int8 *)(v12 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80);
  uint64_t v16 = v12;
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, const char *))(v12 + 48))(v13, 1, v11);
  if (!result)
  {
    uint64_t v15 = *(uint64_t (**)(unint64_t, const char *))(v16 + 8);
    return v15(v13, v11);
  }
  return result;
}

uint64_t initializeWithCopy for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (int **)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1) + 16;
  (*(void (**)(uint64_t, uint64_t, const char *))v9)(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 48);
  unint64_t v11 = (int **)a3[4];
  uint64_t v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  uint64_t v16 = (void *)((v10 + v15 + a1) & ~v15);
  size_t v17 = (const void *)((v10 + v15 + a2) & ~v15);
  if ((*(unsigned int (**)(const void *, uint64_t, const char *))(v14 + 48))(v17, 1, v13))
  {
    if (*(_DWORD *)(v14 + 84)) {
      size_t v18 = *(void *)(v14 + 64);
    }
    else {
      size_t v18 = *(void *)(v14 + 64) + 1;
    }
    memcpy(v16, v17, v18);
  }
  else
  {
    (*(void (**)(void *, const void *, const char *))(v14 + 16))(v16, v17, v13);
    (*(void (**)(void *, void, uint64_t, const char *))(v14 + 56))(v16, 0, 1, v13);
  }
  return a1;
}

uint64_t assignWithCopy for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (int **)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1) + 24;
  (*(void (**)(uint64_t, uint64_t, const char *))v9)(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 40);
  unint64_t v11 = (int **)a3[4];
  uint64_t v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  uint64_t v16 = (void *)((v10 + v15 + a1) & ~v15);
  size_t v17 = (void *)((v10 + v15 + a2) & ~v15);
  size_t v18 = *(uint64_t (**)(void *, uint64_t, const char *))(v14 + 48);
  LODWORD(v7) = v18(v16, 1, v13);
  int v19 = v18(v17, 1, v13);
  if (v7)
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, const char *))(v14 + 16))(v16, v17, v13);
      (*(void (**)(void *, void, uint64_t, const char *))(v14 + 56))(v16, 0, 1, v13);
      return a1;
    }
    int v20 = *(_DWORD *)(v14 + 84);
    size_t v21 = *(void *)(v14 + 64);
  }
  else
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, const char *))(v14 + 24))(v16, v17, v13);
      return a1;
    }
    uint64_t v23 = *(void (**)(void *, const char *))(v14 + 8);
    uint64_t v22 = v14 + 8;
    v23(v16, v13);
    int v20 = *(_DWORD *)(v22 + 76);
    size_t v21 = *(void *)(v22 + 56);
  }
  if (v20) {
    size_t v24 = v21;
  }
  else {
    size_t v24 = v21 + 1;
  }
  memcpy(v16, v17, v24);
  return a1;
}

uint64_t initializeWithTake for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (int **)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1) + 32;
  (*(void (**)(uint64_t, uint64_t, const char *))v9)(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 32);
  unint64_t v11 = (int **)a3[4];
  uint64_t v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  uint64_t v16 = (void *)((v10 + v15 + a1) & ~v15);
  size_t v17 = (const void *)((v10 + v15 + a2) & ~v15);
  if ((*(unsigned int (**)(const void *, uint64_t, const char *))(v14 + 48))(v17, 1, v13))
  {
    if (*(_DWORD *)(v14 + 84)) {
      size_t v18 = *(void *)(v14 + 64);
    }
    else {
      size_t v18 = *(void *)(v14 + 64) + 1;
    }
    memcpy(v16, v17, v18);
  }
  else
  {
    (*(void (**)(void *, const void *, const char *))(v14 + 32))(v16, v17, v13);
    (*(void (**)(void *, void, uint64_t, const char *))(v14 + 56))(v16, 0, 1, v13);
  }
  return a1;
}

uint64_t assignWithTake for FlattenSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (int **)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1) + 40;
  (*(void (**)(uint64_t, uint64_t, const char *))v9)(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 24);
  unint64_t v11 = (int **)a3[4];
  uint64_t v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  uint64_t v16 = (void *)((v10 + v15 + a1) & ~v15);
  size_t v17 = (void *)((v10 + v15 + a2) & ~v15);
  size_t v18 = *(uint64_t (**)(void *, uint64_t, const char *))(v14 + 48);
  LODWORD(v7) = v18(v16, 1, v13);
  int v19 = v18(v17, 1, v13);
  if (v7)
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, const char *))(v14 + 32))(v16, v17, v13);
      (*(void (**)(void *, void, uint64_t, const char *))(v14 + 56))(v16, 0, 1, v13);
      return a1;
    }
    int v20 = *(_DWORD *)(v14 + 84);
    size_t v21 = *(void *)(v14 + 64);
  }
  else
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, const char *))(v14 + 40))(v16, v17, v13);
      return a1;
    }
    uint64_t v23 = *(void (**)(void *, const char *))(v14 + 8);
    uint64_t v22 = v14 + 8;
    v23(v16, v13);
    int v20 = *(_DWORD *)(v22 + 76);
    size_t v21 = *(void *)(v22 + 56);
  }
  if (v20) {
    size_t v24 = v21;
  }
  else {
    size_t v24 = v21 + 1;
  }
  memcpy(v16, v17, v24);
  return a1;
}

uint64_t getEnumTagSinglePayload for FlattenSequence.Iterator(unsigned __int16 *a1, unsigned int a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (int **)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  v32 = AssociatedTypeWitness;
  uint64_t v10 = *(unsigned int *)(v9 + 84);
  unint64_t v11 = (int **)a3[4];
  uint64_t v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v13 = *((void *)swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator)- 1);
  uint64_t v14 = v13;
  int v15 = *(_DWORD *)(v13 + 84);
  if (v15) {
    unsigned int v16 = v15 - 1;
  }
  else {
    unsigned int v16 = 0;
  }
  if (v16 <= v10) {
    unsigned int v17 = v10;
  }
  else {
    unsigned int v17 = v16;
  }
  uint64_t v18 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v19 = *(void *)(v13 + 64);
  if (v15) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = v19 + 1;
  }
  if (!a2) {
    return 0;
  }
  uint64_t v21 = *(void *)(v9 + 64) + v18;
  if (a2 <= v17) {
    goto LABEL_30;
  }
  uint64_t v22 = v20 + (v21 & ~v18);
  char v23 = 8 * v22;
  if (v22 <= 3)
  {
    unsigned int v25 = ((a2 - v17 + ~(-1 << v23)) >> v23) + 1;
    if (HIWORD(v25))
    {
      int v24 = *(_DWORD *)((char *)a1 + v22);
      if (!v24) {
        goto LABEL_30;
      }
      goto LABEL_20;
    }
    if (v25 > 0xFF)
    {
      int v24 = *(unsigned __int16 *)((char *)a1 + v22);
      if (!*(unsigned __int16 *)((char *)a1 + v22)) {
        goto LABEL_30;
      }
      goto LABEL_20;
    }
    if (v25 < 2)
    {
LABEL_30:
      if (v17)
      {
        if (v10 >= v16)
        {
          v31 = *(uint64_t (**)(unsigned __int16 *, uint64_t, const char *))(v9 + 48);
          return v31(a1, v10, v32);
        }
        else
        {
          unsigned int v29 = (*(uint64_t (**)(unint64_t))(v14 + 48))(((unint64_t)a1 + v21) & ~v18);
          if (v29 >= 2) {
            return v29 - 1;
          }
          else {
            return 0;
          }
        }
      }
      return 0;
    }
  }
  int v24 = *((unsigned __int8 *)a1 + v22);
  if (!*((unsigned char *)a1 + v22)) {
    goto LABEL_30;
  }
LABEL_20:
  int v26 = (v24 - 1) << v23;
  if (v22 > 3) {
    int v26 = 0;
  }
  if (v22)
  {
    if (v22 <= 3) {
      int v27 = v22;
    }
    else {
      int v27 = 4;
    }
    switch(v27)
    {
      case 2:
        int v28 = *a1;
        break;
      case 3:
        int v28 = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        int v28 = *(_DWORD *)a1;
        break;
      default:
        int v28 = *(unsigned __int8 *)a1;
        break;
    }
  }
  else
  {
    int v28 = 0;
  }
  return v17 + (v28 | v26) + 1;
}

void storeEnumTagSinglePayload for FlattenSequence.Iterator(unsigned char *a1, uint64_t a2, unsigned int a3, void *a4)
{
  uint64_t v8 = a4[2];
  uint64_t v7 = (int **)a4[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v8, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  v36 = AssociatedTypeWitness;
  uint64_t v11 = *(unsigned int *)(v10 + 84);
  uint64_t v12 = (int **)a4[4];
  uint64_t v13 = swift_getAssociatedTypeWitness(255, v7, v8, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  int v14 = 0;
  uint64_t v15 = *((void *)swift_getAssociatedTypeWitness(0, v12, (uint64_t)v13, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator)- 1);
  uint64_t v16 = v15;
  int v17 = *(_DWORD *)(v15 + 84);
  unsigned int v18 = v17 - 1;
  if (!v17) {
    unsigned int v18 = 0;
  }
  if (v18 <= v11) {
    unsigned int v19 = v11;
  }
  else {
    unsigned int v19 = v18;
  }
  uint64_t v20 = *(unsigned __int8 *)(v15 + 80);
  uint64_t v21 = *(void *)(v10 + 64) + v20;
  size_t v22 = *(void *)(v15 + 64);
  if (v17) {
    size_t v23 = v22;
  }
  else {
    size_t v23 = v22 + 1;
  }
  size_t v24 = (v21 & ~v20) + v23;
  if (a3 <= v19) {
    goto LABEL_17;
  }
  if (v24 <= 3)
  {
    unsigned int v25 = ((a3 - v19 + ~(-1 << (8 * v24))) >> (8 * v24)) + 1;
    if (HIWORD(v25))
    {
      int v14 = 4;
      if (v19 >= a2) {
        goto LABEL_25;
      }
      goto LABEL_18;
    }
    if (v25 >= 0x100) {
      int v14 = 2;
    }
    else {
      int v14 = v25 > 1;
    }
LABEL_17:
    if (v19 >= a2) {
      goto LABEL_25;
    }
    goto LABEL_18;
  }
  int v14 = 1;
  if (v19 >= a2)
  {
LABEL_25:
    uint64_t v29 = ~v20;
    switch(v14)
    {
      case 1:
        a1[v24] = 0;
        if (!a2) {
          return;
        }
        goto LABEL_30;
      case 2:
        *(_WORD *)&a1[v24] = 0;
        if (!a2) {
          return;
        }
        goto LABEL_30;
      case 3:
        goto LABEL_59;
      case 4:
        *(_DWORD *)&a1[v24] = 0;
        goto LABEL_29;
      default:
LABEL_29:
        if (a2)
        {
LABEL_30:
          if (v11 >= v18)
          {
            v34 = *(void (**)(unsigned char *, uint64_t, uint64_t, const char *))(v10 + 56);
            v34(a1, a2, v11, v36);
          }
          else
          {
            v30 = (unsigned char *)((unint64_t)&a1[v21] & v29);
            if (v18 >= a2)
            {
              v35 = *(void (**)(unint64_t, void))(v16 + 56);
              v35((unint64_t)&a1[v21] & v29, (a2 + 1));
            }
            else
            {
              if (v23 <= 3) {
                int v31 = ~(-1 << (8 * v23));
              }
              else {
                int v31 = -1;
              }
              if (v23)
              {
                int v32 = v31 & (~v18 + a2);
                if (v23 <= 3) {
                  int v33 = v23;
                }
                else {
                  int v33 = 4;
                }
                bzero(v30, v23);
                switch(v33)
                {
                  case 2:
                    *(_WORD *)v30 = v32;
                    break;
                  case 3:
                    *(_WORD *)v30 = v32;
                    v30[2] = BYTE2(v32);
                    break;
                  case 4:
                    *(_DWORD *)v30 = v32;
                    break;
                  default:
                    unsigned char *v30 = v32;
                    break;
                }
              }
            }
          }
        }
        break;
    }
    return;
  }
LABEL_18:
  unsigned int v26 = ~v19 + a2;
  if (v24 < 4)
  {
    int v27 = (v26 >> (8 * v24)) + 1;
    if (v24)
    {
      int v28 = v26 & ~(-1 << (8 * v24));
      bzero(a1, (v21 & ~v20) + v23);
      if (v24 == 3)
      {
        *(_WORD *)a1 = v28;
        a1[2] = BYTE2(v28);
      }
      else if (v24 == 2)
      {
        *(_WORD *)a1 = v28;
      }
      else
      {
        *a1 = v28;
      }
    }
  }
  else
  {
    bzero(a1, (v21 & ~v20) + v23);
    *(_DWORD *)a1 = v26;
    int v27 = 1;
  }
  switch(v14)
  {
    case 1:
      a1[v24] = v27;
      break;
    case 2:
      *(_WORD *)&a1[v24] = v27;
      break;
    case 3:
LABEL_59:
      __break(1u);
      JUMPOUT(0x18150D7ECLL);
    case 4:
      *(_DWORD *)&a1[v24] = v27;
      break;
    default:
      return;
  }
}

void *type metadata completion function for FlattenSequence<>.Index(void *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1[3];
  uint64_t result = swift_getAssociatedTypeWitness(319, (int **)v3, v2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  if (v5 <= 0x3F)
  {
    v12[0] = *(result - 1) + 64;
    uint64_t v6 = (int **)a1[4];
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(v3 + 8), v2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
    uint64_t v8 = swift_getAssociatedTypeWitness(255, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
    uint64_t result = type metadata accessor for Optional(319, (uint64_t)v8, v9, v10);
    if (v11 <= 0x3F)
    {
      v12[1] = *(result - 1) + 64;
      swift_initStructMetadata((uint64_t)a1, 0, 2uLL, (uint64_t)v12, (uint64_t)(a1 + 5));
      return 0;
    }
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for FlattenSequence<>.Index(atomic_ullong **a1, atomic_ullong **a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (int **)a3[4];
  uint64_t v12 = swift_getAssociatedTypeWitness(255, *(int ***)(v6 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v13 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = *(_DWORD *)(v14 + 80);
  uint64_t v16 = v10 + v15;
  if (*(_DWORD *)(v14 + 84)) {
    size_t v17 = *(void *)(v14 + 64);
  }
  else {
    size_t v17 = *(void *)(v14 + 64) + 1;
  }
  uint64_t v18 = (*(unsigned char *)(v9 + 80) | *(unsigned char *)(v14 + 80));
  if (v18 > 7
    || ((*(_DWORD *)(v9 + 80) | *(_DWORD *)(v14 + 80)) & 0x100000) != 0
    || ((v10 + v15) & ~v15) + v17 > 0x18)
  {
    uint64_t v21 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v21 + ((v18 + 16) & ~v18));
    swift_retain(v21);
  }
  else
  {
    size_t v22 = v13;
    uint64_t v23 = ~v15;
    (*(void (**)(atomic_ullong **, atomic_ullong **, const char *))(v9 + 16))(a1, a2, AssociatedTypeWitness);
    size_t v24 = (const void *)(((unint64_t)a2 + v16) & v23);
    if ((*(unsigned int (**)(const void *, uint64_t, const char *))(v14 + 48))(v24, 1, v22))
    {
      memcpy((void *)(((unint64_t)a1 + v16) & v23), v24, v17);
    }
    else
    {
      (*(void (**)(unint64_t, const void *, const char *))(v14 + 16))(((unint64_t)a1 + v16) & v23, v24, v22);
      (*(void (**)(unint64_t, void, uint64_t, const char *))(v14 + 56))(((unint64_t)a1 + v16) & v23, 0, 1, v22);
    }
  }
  return a1;
}

uint64_t destroy for FlattenSequence<>.Index(uint64_t a1, void *a2)
{
  uint64_t v5 = a2[2];
  uint64_t v4 = a2[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v4, v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1) + 8;
  (*(void (**)(uint64_t, const char *))v7)(a1, AssociatedTypeWitness);
  uint64_t v8 = *(void *)(v7 + 56) + a1;
  uint64_t v9 = (int **)a2[4];
  uint64_t v10 = swift_getAssociatedTypeWitness(255, *(int ***)(v4 + 8), v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v11 = swift_getAssociatedTypeWitness(0, v9, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v12 = *((void *)v11 - 1);
  unint64_t v13 = (v8 + *(unsigned __int8 *)(v12 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80);
  uint64_t v16 = v12;
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, const char *))(v12 + 48))(v13, 1, v11);
  if (!result)
  {
    uint64_t v15 = *(uint64_t (**)(unint64_t, const char *))(v16 + 8);
    return v15(v13, v11);
  }
  return result;
}

uint64_t initializeWithCopy for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1) + 16;
  (*(void (**)(uint64_t, uint64_t, const char *))v9)(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 48);
  unint64_t v11 = (int **)a3[4];
  uint64_t v12 = swift_getAssociatedTypeWitness(255, *(int ***)(v6 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  uint64_t v16 = (void *)((v10 + v15 + a1) & ~v15);
  size_t v17 = (const void *)((v10 + v15 + a2) & ~v15);
  if ((*(unsigned int (**)(const void *, uint64_t, const char *))(v14 + 48))(v17, 1, v13))
  {
    if (*(_DWORD *)(v14 + 84)) {
      size_t v18 = *(void *)(v14 + 64);
    }
    else {
      size_t v18 = *(void *)(v14 + 64) + 1;
    }
    memcpy(v16, v17, v18);
  }
  else
  {
    (*(void (**)(void *, const void *, const char *))(v14 + 16))(v16, v17, v13);
    (*(void (**)(void *, void, uint64_t, const char *))(v14 + 56))(v16, 0, 1, v13);
  }
  return a1;
}

uint64_t assignWithCopy for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1) + 24;
  (*(void (**)(uint64_t, uint64_t, const char *))v9)(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 40);
  unint64_t v11 = (int **)a3[4];
  uint64_t v12 = swift_getAssociatedTypeWitness(255, *(int ***)(v6 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  uint64_t v16 = (void *)((v10 + v15 + a1) & ~v15);
  size_t v17 = (void *)((v10 + v15 + a2) & ~v15);
  size_t v18 = *(uint64_t (**)(void *, uint64_t, const char *))(v14 + 48);
  LODWORD(v7) = v18(v16, 1, v13);
  int v19 = v18(v17, 1, v13);
  if (v7)
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, const char *))(v14 + 16))(v16, v17, v13);
      (*(void (**)(void *, void, uint64_t, const char *))(v14 + 56))(v16, 0, 1, v13);
      return a1;
    }
    int v20 = *(_DWORD *)(v14 + 84);
    size_t v21 = *(void *)(v14 + 64);
  }
  else
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, const char *))(v14 + 24))(v16, v17, v13);
      return a1;
    }
    uint64_t v23 = *(void (**)(void *, const char *))(v14 + 8);
    uint64_t v22 = v14 + 8;
    v23(v16, v13);
    int v20 = *(_DWORD *)(v22 + 76);
    size_t v21 = *(void *)(v22 + 56);
  }
  if (v20) {
    size_t v24 = v21;
  }
  else {
    size_t v24 = v21 + 1;
  }
  memcpy(v16, v17, v24);
  return a1;
}

uint64_t initializeWithTake for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1) + 32;
  (*(void (**)(uint64_t, uint64_t, const char *))v9)(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 32);
  unint64_t v11 = (int **)a3[4];
  uint64_t v12 = swift_getAssociatedTypeWitness(255, *(int ***)(v6 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  uint64_t v16 = (void *)((v10 + v15 + a1) & ~v15);
  size_t v17 = (const void *)((v10 + v15 + a2) & ~v15);
  if ((*(unsigned int (**)(const void *, uint64_t, const char *))(v14 + 48))(v17, 1, v13))
  {
    if (*(_DWORD *)(v14 + 84)) {
      size_t v18 = *(void *)(v14 + 64);
    }
    else {
      size_t v18 = *(void *)(v14 + 64) + 1;
    }
    memcpy(v16, v17, v18);
  }
  else
  {
    (*(void (**)(void *, const void *, const char *))(v14 + 32))(v16, v17, v13);
    (*(void (**)(void *, void, uint64_t, const char *))(v14 + 56))(v16, 0, 1, v13);
  }
  return a1;
}

uint64_t assignWithTake for FlattenSequence<>.Index(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1) + 40;
  (*(void (**)(uint64_t, uint64_t, const char *))v9)(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 24);
  unint64_t v11 = (int **)a3[4];
  uint64_t v12 = swift_getAssociatedTypeWitness(255, *(int ***)(v6 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  uint64_t v16 = (void *)((v10 + v15 + a1) & ~v15);
  size_t v17 = (void *)((v10 + v15 + a2) & ~v15);
  size_t v18 = *(uint64_t (**)(void *, uint64_t, const char *))(v14 + 48);
  LODWORD(v7) = v18(v16, 1, v13);
  int v19 = v18(v17, 1, v13);
  if (v7)
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, const char *))(v14 + 32))(v16, v17, v13);
      (*(void (**)(void *, void, uint64_t, const char *))(v14 + 56))(v16, 0, 1, v13);
      return a1;
    }
    int v20 = *(_DWORD *)(v14 + 84);
    size_t v21 = *(void *)(v14 + 64);
  }
  else
  {
    if (!v19)
    {
      (*(void (**)(void *, void *, const char *))(v14 + 40))(v16, v17, v13);
      return a1;
    }
    uint64_t v23 = *(void (**)(void *, const char *))(v14 + 8);
    uint64_t v22 = v14 + 8;
    v23(v16, v13);
    int v20 = *(_DWORD *)(v22 + 76);
    size_t v21 = *(void *)(v22 + 56);
  }
  if (v20) {
    size_t v24 = v21;
  }
  else {
    size_t v24 = v21 + 1;
  }
  memcpy(v16, v17, v24);
  return a1;
}

uint64_t getEnumTagSinglePayload for FlattenSequence<>.Index(unsigned __int16 *a1, unsigned int a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v6, v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  int v32 = AssociatedTypeWitness;
  uint64_t v10 = *(unsigned int *)(v9 + 84);
  unint64_t v11 = (int **)a3[4];
  uint64_t v12 = swift_getAssociatedTypeWitness(255, *(int ***)(v6 + 8), v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v13 = *((void *)swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index)- 1);
  uint64_t v14 = v13;
  int v15 = *(_DWORD *)(v13 + 84);
  if (v15) {
    unsigned int v16 = v15 - 1;
  }
  else {
    unsigned int v16 = 0;
  }
  if (v16 <= v10) {
    unsigned int v17 = v10;
  }
  else {
    unsigned int v17 = v16;
  }
  uint64_t v18 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v19 = *(void *)(v13 + 64);
  if (v15) {
    uint64_t v20 = v19;
  }
  else {
    uint64_t v20 = v19 + 1;
  }
  if (!a2) {
    return 0;
  }
  uint64_t v21 = *(void *)(v9 + 64) + v18;
  if (a2 <= v17) {
    goto LABEL_30;
  }
  uint64_t v22 = v20 + (v21 & ~v18);
  char v23 = 8 * v22;
  if (v22 <= 3)
  {
    unsigned int v25 = ((a2 - v17 + ~(-1 << v23)) >> v23) + 1;
    if (HIWORD(v25))
    {
      int v24 = *(_DWORD *)((char *)a1 + v22);
      if (!v24) {
        goto LABEL_30;
      }
      goto LABEL_20;
    }
    if (v25 > 0xFF)
    {
      int v24 = *(unsigned __int16 *)((char *)a1 + v22);
      if (!*(unsigned __int16 *)((char *)a1 + v22)) {
        goto LABEL_30;
      }
      goto LABEL_20;
    }
    if (v25 < 2)
    {
LABEL_30:
      if (v17)
      {
        if (v10 >= v16)
        {
          int v31 = *(uint64_t (**)(unsigned __int16 *, uint64_t, const char *))(v9 + 48);
          return v31(a1, v10, v32);
        }
        else
        {
          unsigned int v29 = (*(uint64_t (**)(unint64_t))(v14 + 48))(((unint64_t)a1 + v21) & ~v18);
          if (v29 >= 2) {
            return v29 - 1;
          }
          else {
            return 0;
          }
        }
      }
      return 0;
    }
  }
  int v24 = *((unsigned __int8 *)a1 + v22);
  if (!*((unsigned char *)a1 + v22)) {
    goto LABEL_30;
  }
LABEL_20:
  int v26 = (v24 - 1) << v23;
  if (v22 > 3) {
    int v26 = 0;
  }
  if (v22)
  {
    if (v22 <= 3) {
      int v27 = v22;
    }
    else {
      int v27 = 4;
    }
    switch(v27)
    {
      case 2:
        int v28 = *a1;
        break;
      case 3:
        int v28 = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        int v28 = *(_DWORD *)a1;
        break;
      default:
        int v28 = *(unsigned __int8 *)a1;
        break;
    }
  }
  else
  {
    int v28 = 0;
  }
  return v17 + (v28 | v26) + 1;
}

void storeEnumTagSinglePayload for FlattenSequence<>.Index(unsigned char *a1, uint64_t a2, unsigned int a3, void *a4)
{
  uint64_t v8 = a4[2];
  uint64_t v7 = a4[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, (int **)v7, v8, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  v36 = AssociatedTypeWitness;
  uint64_t v11 = *(unsigned int *)(v10 + 84);
  uint64_t v12 = (int **)a4[4];
  uint64_t v13 = swift_getAssociatedTypeWitness(255, *(int ***)(v7 + 8), v8, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  int v14 = 0;
  uint64_t v15 = *((void *)swift_getAssociatedTypeWitness(0, v12, (uint64_t)v13, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index)- 1);
  uint64_t v16 = v15;
  int v17 = *(_DWORD *)(v15 + 84);
  unsigned int v18 = v17 - 1;
  if (!v17) {
    unsigned int v18 = 0;
  }
  if (v18 <= v11) {
    unsigned int v19 = v11;
  }
  else {
    unsigned int v19 = v18;
  }
  uint64_t v20 = *(unsigned __int8 *)(v15 + 80);
  uint64_t v21 = *(void *)(v10 + 64) + v20;
  size_t v22 = *(void *)(v15 + 64);
  if (v17) {
    size_t v23 = v22;
  }
  else {
    size_t v23 = v22 + 1;
  }
  size_t v24 = (v21 & ~v20) + v23;
  if (a3 <= v19) {
    goto LABEL_17;
  }
  if (v24 <= 3)
  {
    unsigned int v25 = ((a3 - v19 + ~(-1 << (8 * v24))) >> (8 * v24)) + 1;
    if (HIWORD(v25))
    {
      int v14 = 4;
      if (v19 >= a2) {
        goto LABEL_25;
      }
      goto LABEL_18;
    }
    if (v25 >= 0x100) {
      int v14 = 2;
    }
    else {
      int v14 = v25 > 1;
    }
LABEL_17:
    if (v19 >= a2) {
      goto LABEL_25;
    }
    goto LABEL_18;
  }
  int v14 = 1;
  if (v19 >= a2)
  {
LABEL_25:
    uint64_t v29 = ~v20;
    switch(v14)
    {
      case 1:
        a1[v24] = 0;
        if (!a2) {
          return;
        }
        goto LABEL_30;
      case 2:
        *(_WORD *)&a1[v24] = 0;
        if (!a2) {
          return;
        }
        goto LABEL_30;
      case 3:
        goto LABEL_59;
      case 4:
        *(_DWORD *)&a1[v24] = 0;
        goto LABEL_29;
      default:
LABEL_29:
        if (a2)
        {
LABEL_30:
          if (v11 >= v18)
          {
            v34 = *(void (**)(unsigned char *, uint64_t, uint64_t, const char *))(v10 + 56);
            v34(a1, a2, v11, v36);
          }
          else
          {
            v30 = (unsigned char *)((unint64_t)&a1[v21] & v29);
            if (v18 >= a2)
            {
              v35 = *(void (**)(unint64_t, void))(v16 + 56);
              v35((unint64_t)&a1[v21] & v29, (a2 + 1));
            }
            else
            {
              if (v23 <= 3) {
                int v31 = ~(-1 << (8 * v23));
              }
              else {
                int v31 = -1;
              }
              if (v23)
              {
                int v32 = v31 & (~v18 + a2);
                if (v23 <= 3) {
                  int v33 = v23;
                }
                else {
                  int v33 = 4;
                }
                bzero(v30, v23);
                switch(v33)
                {
                  case 2:
                    *(_WORD *)v30 = v32;
                    break;
                  case 3:
                    *(_WORD *)v30 = v32;
                    v30[2] = BYTE2(v32);
                    break;
                  case 4:
                    *(_DWORD *)v30 = v32;
                    break;
                  default:
                    unsigned char *v30 = v32;
                    break;
                }
              }
            }
          }
        }
        break;
    }
    return;
  }
LABEL_18:
  unsigned int v26 = ~v19 + a2;
  if (v24 < 4)
  {
    int v27 = (v26 >> (8 * v24)) + 1;
    if (v24)
    {
      int v28 = v26 & ~(-1 << (8 * v24));
      bzero(a1, (v21 & ~v20) + v23);
      if (v24 == 3)
      {
        *(_WORD *)a1 = v28;
        a1[2] = BYTE2(v28);
      }
      else if (v24 == 2)
      {
        *(_WORD *)a1 = v28;
      }
      else
      {
        *a1 = v28;
      }
    }
  }
  else
  {
    bzero(a1, (v21 & ~v20) + v23);
    *(_DWORD *)a1 = v26;
    int v27 = 1;
  }
  switch(v14)
  {
    case 1:
      a1[v24] = v27;
      break;
    case 2:
      *(_WORD *)&a1[v24] = v27;
      break;
    case 3:
LABEL_59:
      __break(1u);
      JUMPOUT(0x18150EB98);
    case 4:
      *(_DWORD *)&a1[v24] = v27;
      break;
    default:
      return;
  }
}

uint64_t dispatch thunk of FloatingPoint.init(sign:exponent:significand:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 48))(a1 & 1);
}

uint64_t dispatch thunk of FloatingPoint.init(signOf:magnitudeOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 56))();
}

uint64_t dispatch thunk of FloatingPoint.init(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

uint64_t dispatch thunk of FloatingPoint.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 72))();
}

uint64_t dispatch thunk of FloatingPoint.init<A>(exactly:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 80))();
}

uint64_t dispatch thunk of static FloatingPoint.radix.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 88))();
}

uint64_t dispatch thunk of static FloatingPoint.nan.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 96))();
}

uint64_t dispatch thunk of static FloatingPoint.signalingNaN.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 104))();
}

uint64_t dispatch thunk of static FloatingPoint.infinity.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

uint64_t dispatch thunk of static FloatingPoint.greatestFiniteMagnitude.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 120))();
}

uint64_t dispatch thunk of static FloatingPoint.pi.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

uint64_t dispatch thunk of FloatingPoint.ulp.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 136))();
}

uint64_t dispatch thunk of static FloatingPoint.ulpOfOne.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 144))();
}

uint64_t dispatch thunk of static FloatingPoint.leastNormalMagnitude.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 152))();
}

uint64_t dispatch thunk of static FloatingPoint.leastNonzeroMagnitude.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 160))();
}

uint64_t dispatch thunk of FloatingPoint.sign.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 168))() & 1;
}

uint64_t dispatch thunk of FloatingPoint.exponent.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 176))();
}

uint64_t dispatch thunk of FloatingPoint.significand.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 184))();
}

uint64_t dispatch thunk of static FloatingPoint./ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 192))();
}

uint64_t dispatch thunk of static FloatingPoint./= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 200))();
}

uint64_t dispatch thunk of FloatingPoint.remainder(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 208))();
}

uint64_t dispatch thunk of FloatingPoint.formRemainder(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 216))();
}

uint64_t dispatch thunk of FloatingPoint.truncatingRemainder(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 224))();
}

uint64_t dispatch thunk of FloatingPoint.formTruncatingRemainder(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 232))();
}

uint64_t dispatch thunk of FloatingPoint.squareRoot()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 240))();
}

uint64_t dispatch thunk of FloatingPoint.formSquareRoot()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 248))();
}

uint64_t dispatch thunk of FloatingPoint.addingProduct(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 256))();
}

uint64_t dispatch thunk of FloatingPoint.addProduct(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 264))();
}

uint64_t dispatch thunk of static FloatingPoint.minimum(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 272))();
}

uint64_t dispatch thunk of static FloatingPoint.maximum(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 280))();
}

uint64_t dispatch thunk of static FloatingPoint.minimumMagnitude(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 288))();
}

uint64_t dispatch thunk of static FloatingPoint.maximumMagnitude(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 296))();
}

uint64_t dispatch thunk of FloatingPoint.rounded(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 304))();
}

uint64_t dispatch thunk of FloatingPoint.round(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 312))();
}

uint64_t dispatch thunk of FloatingPoint.nextUp.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 320))();
}

uint64_t dispatch thunk of FloatingPoint.nextDown.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 328))();
}

uint64_t dispatch thunk of FloatingPoint.isEqual(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 336))();
}

uint64_t dispatch thunk of FloatingPoint.isLess(than:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 344))();
}

uint64_t dispatch thunk of FloatingPoint.isLessThanOrEqualTo(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 352))();
}

uint64_t dispatch thunk of FloatingPoint.isTotallyOrdered(belowOrEqualTo:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 360))();
}

uint64_t dispatch thunk of FloatingPoint.isNormal.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 368))();
}

uint64_t dispatch thunk of FloatingPoint.isFinite.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 376))();
}

uint64_t dispatch thunk of FloatingPoint.isZero.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 384))();
}

uint64_t dispatch thunk of FloatingPoint.isSubnormal.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 392))();
}

uint64_t dispatch thunk of FloatingPoint.isInfinite.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 400))();
}

uint64_t dispatch thunk of FloatingPoint.isNaN.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 408))();
}

uint64_t dispatch thunk of FloatingPoint.isSignalingNaN.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 416))();
}

uint64_t dispatch thunk of FloatingPoint.floatingPointClass.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 424))();
}

uint64_t dispatch thunk of FloatingPoint.isCanonical.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 432))();
}

unsigned char *destructiveInjectEnumTag for FloatingPointSign(unsigned char *result, char a2)
{
  *uint64_t result = a2 & 1;
  return result;
}

ValueMetadata *type metadata accessor for FloatingPointSign()
{
  return &type metadata for FloatingPointSign;
}

uint64_t getEnumTagSinglePayload for FloatingPointClassification(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xF7) {
    goto LABEL_17;
  }
  if (a2 + 9 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 9) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 9;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 9;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 9;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 0xA;
  int v8 = v6 - 10;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for FloatingPointClassification(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 9 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 9) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xF7) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xF6)
  {
    unsigned int v6 = ((a2 - 247) >> 8) + 1;
    *uint64_t result = a2 + 9;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x18150F148);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *uint64_t result = a2 + 9;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for FloatingPointClassification()
{
  return &type metadata for FloatingPointClassification;
}

uint64_t getEnumTagSinglePayload for FloatingPointRoundingRule(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFB) {
    goto LABEL_17;
  }
  if (a2 + 5 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 5) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 5;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 5;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 5;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 6;
  int v8 = v6 - 6;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for FloatingPointRoundingRule(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 5 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 5) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFB) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFA)
  {
    unsigned int v6 = ((a2 - 251) >> 8) + 1;
    *uint64_t result = a2 + 5;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x18150F2DCLL);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *uint64_t result = a2 + 5;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for FloatingPointRoundingRule()
{
  return &type metadata for FloatingPointRoundingRule;
}

uint64_t dispatch thunk of BinaryFloatingPoint.init(sign:exponentBitPattern:significandBitPattern:)(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 56))(a1 & 1);
}

uint64_t dispatch thunk of BinaryFloatingPoint.init(_:)(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 80))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.init<A>(exactly:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 88))();
}

uint64_t dispatch thunk of static BinaryFloatingPoint.exponentBitCount.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 96))();
}

uint64_t dispatch thunk of static BinaryFloatingPoint.significandBitCount.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 104))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.exponentBitPattern.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.significandBitPattern.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 120))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.binade.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

uint64_t dispatch thunk of BinaryFloatingPoint.significandWidth.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 136))();
}

uint64_t dispatch thunk of Hashable.hashValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of Hashable.hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of Hashable._rawHashValue(seed:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of _HasCustomAnyHashableRepresentation._toCustomAnyHashable()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of _AnyHashableBox._canonicalBox.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of _AnyHashableBox._isEqual(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 16))();
}

uint64_t dispatch thunk of _AnyHashableBox._hashValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of _AnyHashableBox._hash(into:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of _AnyHashableBox._rawHashValue(_seed:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of _AnyHashableBox._base.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

uint64_t dispatch thunk of _AnyHashableBox._unbox<A>()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 56))();
}

uint64_t dispatch thunk of _AnyHashableBox._downCastConditional<A>(into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 64))();
}

uint64_t destroy for AnyHashable(uint64_t *a1)
{
  return __swift_destroy_boxed_opaque_existential_1Tm(a1);
}

uint64_t initializeWithCopy for AnyHashable(uint64_t a1, uint64_t a2)
{
  long long v3 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 24) = v3;
  (**(void (***)(void))(v3 - 8))();
  return a1;
}

uint64_t *assignWithCopy for AnyHashable(uint64_t *a1, uint64_t a2)
{
  return a1;
}

uint64_t *__swift_assign_boxed_opaque_existential_1(uint64_t *result, uint64_t a2)
{
  if (result != (uint64_t *)a2)
  {
    long long v3 = result;
    uint64_t v4 = result[3];
    uint64_t v5 = *(void *)(a2 + 24);
    if (v4 == v5)
    {
      uint64_t v10 = *(void *)(v4 - 8);
      if ((*(unsigned char *)(v10 + 82) & 2) != 0)
      {
        uint64_t v13 = *result;
        int v14 = *(atomic_ullong **)a2;
        swift_retain(*(atomic_ullong **)a2);
        uint64_t result = (uint64_t *)swift_release(v13);
        *long long v3 = v14;
      }
      else
      {
        uint64_t v11 = *(uint64_t (**)(void))(v10 + 24);
        return (uint64_t *)v11();
      }
    }
    else
    {
      result[3] = v5;
      result[4] = *(void *)(a2 + 32);
      uint64_t v6 = *(void *)(v4 - 8);
      uint64_t v7 = *(void *)(v5 - 8);
      uint64_t v8 = v7;
      int v9 = *(_DWORD *)(v7 + 80);
      if ((*(unsigned char *)(v6 + 82) & 2) != 0)
      {
        uint64_t v12 = *result;
        if ((v9 & 0x20000) != 0)
        {
          uint64_t v16 = *(atomic_ullong **)a2;
          *long long v3 = *(void *)a2;
          swift_retain(v16);
        }
        else
        {
          (*(void (**)(uint64_t *, uint64_t, uint64_t))(v7 + 16))(result, a2, v5);
        }
        return (uint64_t *)swift_release(v12);
      }
      else
      {
        (*(void (**)(unsigned char *, uint64_t *, uint64_t))(v6 + 32))(v17, result, v4);
        if ((v9 & 0x20000) != 0)
        {
          uint64_t v15 = *(atomic_ullong **)a2;
          *long long v3 = *(void *)a2;
          swift_retain(v15);
        }
        else
        {
          (*(void (**)(void *, uint64_t, uint64_t))(v8 + 16))(v3, a2, v5);
        }
        return (uint64_t *)(*(uint64_t (**)(unsigned char *, uint64_t))(v6 + 8))(v17, v4);
      }
    }
  }
  return result;
}

uint64_t assignWithTake for AnyHashable(uint64_t a1, uint64_t a2)
{
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  return a1;
}

uint64_t getEnumTagSinglePayload for AnyHashable(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 40)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for AnyHashable(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(void *)uint64_t result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 40) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 24) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 40) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for AnyHashable()
{
  return &type metadata for AnyHashable;
}

ValueMetadata *type metadata accessor for Hasher._TailBuffer()
{
  return &type metadata for Hasher._TailBuffer;
}

__n128 __swift_memcpy72_8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  long long v3 = *(_OWORD *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t getEnumTagSinglePayload for Hasher._Core(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 72)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for Hasher._Core(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 72) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Hasher._Core()
{
  return &type metadata for Hasher._Core;
}

ValueMetadata *type metadata accessor for Hasher()
{
  return &type metadata for Hasher;
}

uint64_t type metadata accessor for __SwiftEmptyNSEnumerator()
{
  return self;
}

uint64_t type metadata accessor for __BridgingHashBuffer(__int16 a1)
{
  return type metadata accessor for __BridgingBufferStorage(a1, (uint64_t *)&type metadata singleton initialization cache for __BridgingHashBuffer, &nominal type descriptor for __BridgingHashBuffer);
}

uint64_t type metadata accessor for __BridgingBufferStorage(__int16 a1, uint64_t *a2, _DWORD *a3)
{
  uint64_t result = *a2;
  if (!*a2) {
    return swift_getSingletonMetadata(a1, a3);
  }
  return result;
}

swift *type metadata completion function for __BridgingBufferStorage(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 256, 0, (uint64_t)v2, a1 + 112);
}

uint64_t dispatch thunk of _HashTableDelegate.hashValue(at:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of _HashTableDelegate.moveEntry(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 16))();
}

uint64_t getEnumTagSinglePayload for _UnsafeBitset(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 != 1 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 2);
  }
  if (*(void *)a1) {
    int v3 = -1;
  }
  else {
    int v3 = 0;
  }
  return (v3 + 1);
}

uint64_t storeEnumTagSinglePayload for _UnsafeBitset(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *(void *)uint64_t result = a2 - 2;
    *(void *)(result + 8) = 0;
    if (a3 >= 2) {
      *(unsigned char *)(result + 16) = 1;
    }
  }
  else
  {
    if (a3 >= 2) {
      *(unsigned char *)(result + 16) = 0;
    }
    if (a2) {
      *(void *)uint64_t result = 0;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for _HashTable()
{
  return &type metadata for _HashTable;
}

ValueMetadata *type metadata accessor for _HashTable.Bucket()
{
  return &type metadata for _HashTable.Bucket;
}

uint64_t __swift_memcpy12_8(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(_DWORD *)(result + 8) = *((_DWORD *)a2 + 2);
  *(void *)uint64_t result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for _HashTable.Index(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 12)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for _HashTable.Index(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(_DWORD *)(result + 8) = 0;
    *(void *)uint64_t result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 12) = v3;
  return result;
}

ValueMetadata *type metadata accessor for _HashTable.Index()
{
  return &type metadata for _HashTable.Index;
}

uint64_t getEnumTagSinglePayload for _UnsafeBitset.Iterator(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 != 1 && *(unsigned char *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 2);
  }
  if (*(void *)a1) {
    int v3 = -1;
  }
  else {
    int v3 = 0;
  }
  return (v3 + 1);
}

uint64_t storeEnumTagSinglePayload for _UnsafeBitset.Iterator(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(void *)uint64_t result = a2 - 2;
    *(void *)(result + 8) = 0;
    if (a3 >= 2) {
      *(unsigned char *)(result + 32) = 1;
    }
  }
  else
  {
    if (a3 >= 2) {
      *(unsigned char *)(result + 32) = 0;
    }
    if (a2) {
      *(void *)uint64_t result = 0;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for _HashTable.Iterator()
{
  return &type metadata for _HashTable.Iterator;
}

uint64_t dispatch thunk of Identifiable.id.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

void *type metadata completion function for DefaultIndices(uint64_t a1)
{
  uint64_t v2 = swift_checkMetadataState(319, *(void *)(a1 + 16));
  int v3 = v2;
  if (v4 <= 0x3F)
  {
    uint64_t v8 = *(v2 - 1) + 64;
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(319, *(int ***)(a1 + 24), (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
    int v3 = (void *)AssociatedTypeWitness;
    if (v6 <= 0x3F)
    {
      uint64_t v9 = *((void *)AssociatedTypeWitness - 1) + 64;
      uint64_t v10 = v9;
      swift_initStructMetadata(a1, 0, 3uLL, (uint64_t)&v8, a1 + 32);
      return 0;
    }
  }
  return v3;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for DefaultIndices(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void *)(v6 + 64);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = *(_DWORD *)(v9 + 80);
  uint64_t v11 = v7 + v10;
  uint64_t v12 = (v7 + v10) & ~v10;
  uint64_t v13 = *(void *)(v9 + 64);
  uint64_t v14 = v13 + v10;
  unint64_t v15 = ((v12 + v13 + v10) & ~v10) + v13;
  uint64_t v16 = (*(unsigned char *)(v6 + 80) | *(unsigned char *)(v9 + 80));
  if (v16 > 7 || ((*(_DWORD *)(v6 + 80) | *(_DWORD *)(v9 + 80)) & 0x100000) != 0 || v15 > 0x18)
  {
    unsigned int v19 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v19 + ((v16 + 16) & ~v16));
    swift_retain(v19);
  }
  else
  {
    uint64_t v20 = AssociatedTypeWitness;
    uint64_t v21 = ~v10;
    (*(void (**)(atomic_ullong **, atomic_ullong **, uint64_t))(v6 + 16))(a1, a2, v5);
    unint64_t v22 = ((unint64_t)a2 + v11) & v21;
    size_t v23 = *(void (**)(unint64_t, unint64_t, const char *))(v9 + 16);
    v23(((unint64_t)a1 + v11) & v21, v22, v20);
    v23(((((unint64_t)a1 + v11) & v21) + v14) & v21, (v22 + v14) & v21, v20);
  }
  return a1;
}

uint64_t destroy for DefaultIndices(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8) + 8;
  (*(void (**)(uint64_t, uint64_t))v5)(a1, v4);
  uint64_t v6 = *(void *)(v5 + 56) + a1;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v13 = v8 + 8;
  uint64_t v14 = *(void (**)(uint64_t, const char *))(v8 + 8);
  uint64_t v9 = *(unsigned __int8 *)(v8 + 80);
  uint64_t v10 = (v6 + v9) & ~v9;
  v14(v10, AssociatedTypeWitness);
  uint64_t v11 = (*(void *)(v13 + 56) + v9 + v10) & ~v9;

  return ((uint64_t (*)(uint64_t, const char *))v14)(v11, AssociatedTypeWitness);
}

uint64_t initializeWithCopy for DefaultIndices(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8) + 16;
  (*(void (**)(uint64_t, uint64_t, uint64_t))v7)(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = *(void (**)(uint64_t, uint64_t, const char *))(v10 + 16);
  uint64_t v12 = v10 + 16;
  uint64_t v13 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v14 = (v8 + v13 + a2) & ~v13;
  v11((v8 + v13 + a1) & ~v13, v14, AssociatedTypeWitness);
  v11((*(void *)(v12 + 48) + v13 + ((v8 + v13 + a1) & ~v13)) & ~v13, (*(void *)(v12 + 48) + v13 + v14) & ~v13, AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for DefaultIndices(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8) + 24;
  (*(void (**)(uint64_t, uint64_t, uint64_t))v7)(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 40);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = *(void (**)(uint64_t, uint64_t, const char *))(v10 + 24);
  uint64_t v12 = v10 + 24;
  uint64_t v13 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v14 = (v8 + v13 + a2) & ~v13;
  v11((v8 + v13 + a1) & ~v13, v14, AssociatedTypeWitness);
  v11((*(void *)(v12 + 40) + v13 + ((v8 + v13 + a1) & ~v13)) & ~v13, (*(void *)(v12 + 40) + v13 + v14) & ~v13, AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for DefaultIndices(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8) + 32;
  (*(void (**)(uint64_t, uint64_t, uint64_t))v7)(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 32);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = *(void (**)(uint64_t, uint64_t, const char *))(v10 + 32);
  uint64_t v12 = v10 + 32;
  uint64_t v13 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v14 = (v8 + v13 + a2) & ~v13;
  v11((v8 + v13 + a1) & ~v13, v14, AssociatedTypeWitness);
  v11((*(void *)(v12 + 32) + v13 + ((v8 + v13 + a1) & ~v13)) & ~v13, (*(void *)(v12 + 32) + v13 + v14) & ~v13, AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for DefaultIndices(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8) + 40;
  (*(void (**)(uint64_t, uint64_t, uint64_t))v7)(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = *(void (**)(uint64_t, uint64_t, const char *))(v10 + 40);
  uint64_t v12 = v10 + 40;
  uint64_t v13 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v14 = (v8 + v13 + a2) & ~v13;
  v11((v8 + v13 + a1) & ~v13, v14, AssociatedTypeWitness);
  v11((*(void *)(v12 + 24) + v13 + ((v8 + v13 + a1) & ~v13)) & ~v13, (*(void *)(v12 + 24) + v13 + v14) & ~v13, AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for DefaultIndices(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(unsigned int *)(v6 + 84);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  unsigned int v10 = *(_DWORD *)(v9 + 84);
  if (v10 <= v7) {
    unsigned int v11 = v7;
  }
  else {
    unsigned int v11 = *(_DWORD *)(v9 + 84);
  }
  uint64_t v12 = *(unsigned __int8 *)(v9 + 80);
  if (!a2) {
    return 0;
  }
  uint64_t v13 = *(void *)(v6 + 64) + v12;
  if (a2 <= v11) {
    goto LABEL_24;
  }
  uint64_t v14 = ((*(void *)(*((void *)AssociatedTypeWitness - 1) + 64) + v12 + (v13 & ~v12)) & ~v12)
      + *(void *)(*((void *)AssociatedTypeWitness - 1) + 64);
  char v15 = 8 * v14;
  if (v14 <= 3)
  {
    unsigned int v17 = ((a2 - v11 + ~(-1 << v15)) >> v15) + 1;
    if (HIWORD(v17))
    {
      int v16 = *(_DWORD *)((char *)a1 + v14);
      if (!v16) {
        goto LABEL_24;
      }
      goto LABEL_14;
    }
    if (v17 > 0xFF)
    {
      int v16 = *(unsigned __int16 *)((char *)a1 + v14);
      if (!*(unsigned __int16 *)((char *)a1 + v14)) {
        goto LABEL_24;
      }
      goto LABEL_14;
    }
    if (v17 < 2)
    {
LABEL_24:
      if (v11)
      {
        if (v7 >= v10)
        {
          size_t v23 = *(uint64_t (**)(unsigned __int16 *, uint64_t, uint64_t))(v6 + 48);
          return v23(a1, v7, v5);
        }
        else
        {
          uint64_t v21 = *(uint64_t (**)(unint64_t))(v9 + 48);
          return v21(((unint64_t)a1 + v13) & ~v12);
        }
      }
      return 0;
    }
  }
  int v16 = *((unsigned __int8 *)a1 + v14);
  if (!*((unsigned char *)a1 + v14)) {
    goto LABEL_24;
  }
LABEL_14:
  int v18 = (v16 - 1) << v15;
  if (v14 > 3) {
    int v18 = 0;
  }
  if (v14)
  {
    if (v14 <= 3) {
      int v19 = v14;
    }
    else {
      int v19 = 4;
    }
    switch(v19)
    {
      case 2:
        int v20 = *a1;
        break;
      case 3:
        int v20 = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        int v20 = *(_DWORD *)a1;
        break;
      default:
        int v20 = *(unsigned __int8 *)a1;
        break;
    }
  }
  else
  {
    int v20 = 0;
  }
  return v11 + (v20 | v18) + 1;
}

void storeEnumTagSinglePayload for DefaultIndices(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v24 = v8;
  uint64_t v9 = *(unsigned int *)(v8 + 84);
  uint64_t v10 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 24), v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index)- 1);
  uint64_t v11 = v10;
  unsigned int v12 = *(_DWORD *)(v10 + 84);
  if (v12 <= v9) {
    unsigned int v13 = v9;
  }
  else {
    unsigned int v13 = *(_DWORD *)(v10 + 84);
  }
  uint64_t v14 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v15 = *(void *)(v8 + 64) + v14;
  size_t v16 = ((*(void *)(v10 + 64) + v14 + (v15 & ~v14)) & ~v14) + *(void *)(v10 + 64);
  if (a3 <= v13)
  {
    int v17 = 0;
  }
  else if (v16 <= 3)
  {
    unsigned int v20 = ((a3 - v13 + ~(-1 << (8 * v16))) >> (8 * v16)) + 1;
    if (HIWORD(v20))
    {
      int v17 = 4;
    }
    else if (v20 >= 0x100)
    {
      int v17 = 2;
    }
    else
    {
      int v17 = v20 > 1;
    }
  }
  else
  {
    int v17 = 1;
  }
  if (v13 < a2)
  {
    unsigned int v18 = ~v13 + a2;
    if (v16 < 4)
    {
      int v19 = (v18 >> (8 * v16)) + 1;
      if (v16)
      {
        int v21 = v18 & ~(-1 << (8 * v16));
        bzero(a1, v16);
        if (v16 == 3)
        {
          *(_WORD *)a1 = v21;
          a1[2] = BYTE2(v21);
        }
        else if (v16 == 2)
        {
          *(_WORD *)a1 = v21;
        }
        else
        {
          *a1 = v21;
        }
      }
    }
    else
    {
      bzero(a1, v16);
      *(_DWORD *)a1 = v18;
      int v19 = 1;
    }
    switch(v17)
    {
      case 1:
        a1[v16] = v19;
        return;
      case 2:
        *(_WORD *)&a1[v16] = v19;
        return;
      case 3:
        goto LABEL_41;
      case 4:
        *(_DWORD *)&a1[v16] = v19;
        return;
      default:
        return;
    }
  }
  switch(v17)
  {
    case 1:
      a1[v16] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 2:
      *(_WORD *)&a1[v16] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 3:
LABEL_41:
      __break(1u);
      JUMPOUT(0x18151098CLL);
    case 4:
      *(_DWORD *)&a1[v16] = 0;
      goto LABEL_23;
    default:
LABEL_23:
      if (a2)
      {
LABEL_24:
        if (v9 >= v12)
        {
          size_t v23 = *(void (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(v24 + 56);
          v23(a1, a2, v9, v7);
        }
        else
        {
          unint64_t v22 = *(void (**)(unint64_t, uint64_t))(v11 + 56);
          v22((unint64_t)&a1[v15] & ~v14, a2);
        }
      }
      return;
  }
}

uint64_t dispatch thunk of static AdditiveArithmetic.zero.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of static AdditiveArithmetic.+ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

uint64_t dispatch thunk of static AdditiveArithmetic.+= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t dispatch thunk of static AdditiveArithmetic.- infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 40))();
}

uint64_t dispatch thunk of static AdditiveArithmetic.-= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 48))();
}

uint64_t dispatch thunk of Numeric.init<A>(exactly:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 48))();
}

uint64_t dispatch thunk of Numeric.magnitude.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t dispatch thunk of static Numeric.* infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 64))();
}

uint64_t dispatch thunk of static Numeric.*= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 72))();
}

uint64_t dispatch thunk of static SignedNumeric.- prefix(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 16))();
}

uint64_t dispatch thunk of SignedNumeric.negate()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of static BinaryInteger.isSigned.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

uint64_t dispatch thunk of BinaryInteger.init<A>(exactly:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 72))();
}

uint64_t dispatch thunk of BinaryInteger.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 80))();
}

{
  return (*(uint64_t (**)(void))(a5 + 88))();
}

uint64_t dispatch thunk of BinaryInteger.init<A>(truncatingIfNeeded:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 96))();
}

uint64_t dispatch thunk of BinaryInteger.init<A>(clamping:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 104))();
}

uint64_t dispatch thunk of BinaryInteger.words.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

uint64_t dispatch thunk of BinaryInteger._lowWord.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 120))();
}

uint64_t dispatch thunk of BinaryInteger.bitWidth.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

uint64_t dispatch thunk of BinaryInteger._binaryLogarithm()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 136))();
}

uint64_t dispatch thunk of BinaryInteger.trailingZeroBitCount.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 144))();
}

uint64_t dispatch thunk of static BinaryInteger./ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 152))();
}

uint64_t dispatch thunk of static BinaryInteger./= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 160))();
}

uint64_t dispatch thunk of static BinaryInteger.% infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 168))();
}

uint64_t dispatch thunk of static BinaryInteger.%= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 176))();
}

uint64_t dispatch thunk of static BinaryInteger.~ prefix(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 184))();
}

uint64_t dispatch thunk of static BinaryInteger.& infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 192))();
}

uint64_t dispatch thunk of static BinaryInteger.&= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 200))();
}

uint64_t dispatch thunk of static BinaryInteger.| infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 208))();
}

uint64_t dispatch thunk of static BinaryInteger.|= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 216))();
}

uint64_t dispatch thunk of static BinaryInteger.^ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 224))();
}

uint64_t dispatch thunk of static BinaryInteger.^= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 232))();
}

uint64_t dispatch thunk of static BinaryInteger.>> infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 240))();
}

uint64_t dispatch thunk of static BinaryInteger.>>= infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 248))();
}

uint64_t dispatch thunk of static BinaryInteger.<< infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 256))();
}

uint64_t dispatch thunk of static BinaryInteger.<<= infix<A>(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 264))();
}

uint64_t dispatch thunk of BinaryInteger.quotientAndRemainder(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 272))();
}

uint64_t dispatch thunk of BinaryInteger.isMultiple(of:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 280))();
}

uint64_t dispatch thunk of BinaryInteger.signum()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 288))();
}

uint64_t dispatch thunk of static FixedWidthInteger.bitWidth.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t dispatch thunk of static FixedWidthInteger.max.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 64))();
}

uint64_t dispatch thunk of static FixedWidthInteger.min.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 72))();
}

uint64_t dispatch thunk of FixedWidthInteger.addingReportingOverflow(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 80))();
}

uint64_t dispatch thunk of FixedWidthInteger.subtractingReportingOverflow(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 88))();
}

uint64_t dispatch thunk of FixedWidthInteger.multipliedReportingOverflow(by:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 96))();
}

uint64_t dispatch thunk of FixedWidthInteger.dividedReportingOverflow(by:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 104))();
}

uint64_t dispatch thunk of FixedWidthInteger.remainderReportingOverflow(dividingBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 112))();
}

uint64_t dispatch thunk of FixedWidthInteger.multipliedFullWidth(by:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 120))();
}

uint64_t dispatch thunk of FixedWidthInteger.dividingFullWidth(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 128))();
}

uint64_t dispatch thunk of FixedWidthInteger.init(_truncatingBits:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 136))();
}

uint64_t dispatch thunk of FixedWidthInteger.nonzeroBitCount.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 144))();
}

uint64_t dispatch thunk of FixedWidthInteger.leadingZeroBitCount.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 152))();
}

uint64_t dispatch thunk of FixedWidthInteger.init(bigEndian:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 160))();
}

uint64_t dispatch thunk of FixedWidthInteger.init(littleEndian:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 168))();
}

uint64_t dispatch thunk of FixedWidthInteger.bigEndian.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 176))();
}

uint64_t dispatch thunk of FixedWidthInteger.littleEndian.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 184))();
}

uint64_t dispatch thunk of FixedWidthInteger.byteSwapped.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 192))();
}

uint64_t dispatch thunk of static FixedWidthInteger.&>> infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 200))();
}

uint64_t dispatch thunk of static FixedWidthInteger.&>>= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 208))();
}

uint64_t dispatch thunk of static FixedWidthInteger.&<< infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 216))();
}

uint64_t dispatch thunk of static FixedWidthInteger.&<<= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 224))();
}

uint64_t dispatch thunk of static FixedWidthInteger.&* infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 232))();
}

uint64_t dispatch thunk of static SignedInteger._maskingAdd(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

uint64_t dispatch thunk of static SignedInteger._maskingSubtract(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t *type metadata completion function for JoinedSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for JoinedSequence(a1, a2, a3, (uint64_t)&unk_1ECA04A78);
}

atomic_ullong **initializeBufferWithCopyOfBuffer for DiscontiguousSlice(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  uint64_t v4 = a1;
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8);
  uint64_t v6 = *(void *)(v5 + 64);
  int v7 = *(_DWORD *)(v5 + 80);
  if ((v7 & 0x1000F8) != 0 || ((v6 + 7) & 0xFFFFFFFFFFFFFFF8) + 8 > 0x18)
  {
    uint64_t v10 = *a2;
    atomic_ullong *v4 = *a2;
    uint64_t v4 = (atomic_ullong **)((char *)v10 + ((unsigned __int16)((v7 & 0xF8) + 23) & (unsigned __int16)~(v7 & 0xF8) & 0x1F8));
  }
  else
  {
    (*(void (**)(atomic_ullong **, atomic_ullong **))(v5 + 16))(a1, a2);
    uint64_t v9 = (atomic_ullong **)(((unint64_t)a2 + v6 + 7) & 0xFFFFFFFFFFFFFFF8);
    uint64_t v10 = *v9;
    *(void *)(((unint64_t)v4 + v6 + 7) & 0xFFFFFFFFFFFFFFF8) = *v9;
  }
  swift_retain(v10);
  return v4;
}

uint64_t destroy for DiscontiguousSlice(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(a2 + 16) - 8) + 8;
  (*(void (**)(void))v3)();
  uint64_t v4 = *(void *)((a1 + *(void *)(v3 + 56) + 7) & 0xFFFFFFFFFFFFFFF8);

  return swift_release(v4);
}

uint64_t initializeWithCopy for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8) + 16;
  (*(void (**)(void))v5)();
  uint64_t v6 = *(void *)(v5 + 48) + 7;
  int v7 = (void *)((v6 + a1) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v8 = (atomic_ullong **)((v6 + a2) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v9 = *v8;
  void *v7 = *v8;
  swift_retain(v9);
  return a1;
}

uint64_t assignWithCopy for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8) + 24;
  (*(void (**)(void))v5)();
  uint64_t v6 = *(void *)(v5 + 40) + 7;
  int v7 = (uint64_t *)((v6 + a1) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v8 = (atomic_ullong **)((v6 + a2) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v9 = *v8;
  uint64_t v10 = *v7;
  uint64_t *v7 = (uint64_t)*v8;
  swift_retain(v9);
  swift_release(v10);
  return a1;
}

uint64_t assignWithTake for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8) + 40;
  (*(void (**)(void))v5)();
  uint64_t v6 = *(void *)(v5 + 24) + 7;
  int v7 = (uint64_t *)((v6 + a1) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v8 = *v7;
  uint64_t *v7 = *(void *)((v6 + a2) & 0xFFFFFFFFFFFFFFF8);
  swift_release(v8);
  return a1;
}

uint64_t getEnumTagSinglePayload for DiscontiguousSlice(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  uint64_t v6 = *(void *)(v4 + 64);
  if (v5 <= 0x7FFFFFFF) {
    unsigned int v7 = 0x7FFFFFFF;
  }
  else {
    unsigned int v7 = *(_DWORD *)(v4 + 84);
  }
  if (!a2) {
    return 0;
  }
  if (v7 < a2)
  {
    unint64_t v8 = ((v6 + 7) & 0xFFFFFFFFFFFFFFF8) + 8;
    unsigned int v9 = a2 - v7;
    uint64_t v10 = v8 & 0xFFFFFFF8;
    if ((v8 & 0xFFFFFFF8) != 0) {
      unsigned int v11 = 2;
    }
    else {
      unsigned int v11 = v9 + 1;
    }
    if (v11 >= 0x10000) {
      unsigned int v12 = 4;
    }
    else {
      unsigned int v12 = 2;
    }
    if (v11 < 0x100) {
      unsigned int v12 = 1;
    }
    if (v11 >= 2) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = 0;
    }
    switch(v13)
    {
      case 1:
        int v14 = *((unsigned __int8 *)a1 + v8);
        if (!v14) {
          break;
        }
        goto LABEL_22;
      case 2:
        int v14 = *(unsigned __int16 *)((char *)a1 + v8);
        if (v14) {
          goto LABEL_22;
        }
        break;
      case 3:
        __break(1u);
        JUMPOUT(0x18151131CLL);
      case 4:
        int v14 = *(_DWORD *)((char *)a1 + v8);
        if (!v14) {
          break;
        }
LABEL_22:
        int v16 = v14 - 1;
        if (v10)
        {
          int v16 = 0;
          LODWORD(v10) = *a1;
        }
        return v7 + (v10 | v16) + 1;
      default:
        break;
    }
  }
  if (v5 >= 0x7FFFFFFF) {
    return (*(uint64_t (**)(void))(v4 + 48))();
  }
  unint64_t v17 = *(void *)(((unint64_t)a1 + v6 + 7) & 0xFFFFFFFFFFFFFFF8);
  if (v17 >= 0xFFFFFFFF) {
    LODWORD(v17) = -1;
  }
  return (v17 + 1);
}

void storeEnumTagSinglePayload for DiscontiguousSlice(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 16) - 8);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  if (v7 <= 0x7FFFFFFF) {
    unsigned int v8 = 0x7FFFFFFF;
  }
  else {
    unsigned int v8 = *(_DWORD *)(v6 + 84);
  }
  uint64_t v9 = *(void *)(*(void *)(*(void *)(a4 + 16) - 8) + 64);
  unint64_t v10 = ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 8;
  if (((v9 + 7) & 0xFFFFFFF8) == 0xFFFFFFF8) {
    unsigned int v11 = a3 - v8 + 1;
  }
  else {
    unsigned int v11 = 2;
  }
  if (v11 >= 0x10000) {
    int v12 = 4;
  }
  else {
    int v12 = 2;
  }
  if (v11 < 0x100) {
    int v12 = 1;
  }
  if (v11 >= 2) {
    unsigned int v13 = v12;
  }
  else {
    unsigned int v13 = 0;
  }
  if (v8 < a3) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  if (a2 > v8)
  {
    if (((v9 + 7) & 0xFFFFFFF8) == 0xFFFFFFF8) {
      int v15 = a2 - v8;
    }
    else {
      int v15 = 1;
    }
    if (((v9 + 7) & 0xFFFFFFF8) != 0xFFFFFFF8)
    {
      int v16 = ~v8 + a2;
      bzero(a1, ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 8);
      *(_DWORD *)a1 = v16;
    }
    switch(v14)
    {
      case 1:
        a1[v10] = v15;
        return;
      case 2:
        *(_WORD *)&a1[v10] = v15;
        return;
      case 3:
        goto LABEL_44;
      case 4:
        *(_DWORD *)&a1[v10] = v15;
        return;
      default:
        return;
    }
  }
  switch(v14)
  {
    case 1:
      a1[v10] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_33;
    case 2:
      *(_WORD *)&a1[v10] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_33;
    case 3:
LABEL_44:
      __break(1u);
      JUMPOUT(0x18151150CLL);
    case 4:
      *(_DWORD *)&a1[v10] = 0;
      goto LABEL_32;
    default:
LABEL_32:
      if (a2)
      {
LABEL_33:
        if (v7 < 0x7FFFFFFF)
        {
          unsigned int v18 = (void *)((unint64_t)&a1[v9 + 7] & 0xFFFFFFFFFFFFFFF8);
          if ((a2 & 0x80000000) != 0) {
            uint64_t v19 = a2 ^ 0x80000000;
          }
          else {
            uint64_t v19 = a2 - 1;
          }
          *unsigned int v18 = v19;
        }
        else
        {
          unint64_t v17 = *(void (**)(void))(v6 + 56);
          v17();
        }
      }
      return;
  }
}

void *type metadata instantiation function for JoinedSequence.Iterator(_DWORD *a1, const void *a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, 56);
}

void *type metadata completion function for JoinedSequence.Iterator(void *a1)
{
  uint64_t v3 = a1[2];
  uint64_t v2 = (int **)a1[3];
  uint64_t result = swift_getAssociatedTypeWitness(319, v2, v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  if (v5 <= 0x3F)
  {
    v12[0] = *(result - 1) + 64;
    uint64_t v6 = (int **)a1[4];
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v2, v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
    unsigned int v8 = swift_getAssociatedTypeWitness(255, v6, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
    uint64_t result = type metadata accessor for Optional(319, (uint64_t)v8, v9, v10);
    if (v11 <= 0x3F)
    {
      v12[1] = *(result - 1) + 64;
      void v12[2] = &unk_1ECA04A78;
      v12[3] = &unk_181633B88;
      v12[4] = &unk_181633BA0;
      swift_initStructMetadata((uint64_t)a1, 0, 5uLL, (uint64_t)v12, (uint64_t)(a1 + 5));
      return 0;
    }
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for JoinedSequence.Iterator(atomic_ullong **a1, atomic_ullong **a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (int **)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = *(void *)(v9 + 64);
  unint64_t v11 = (int **)a3[4];
  int v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unsigned int v13 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = *(_DWORD *)(v14 + 80);
  uint64_t v16 = v10 + v15;
  if (*(_DWORD *)(v14 + 84)) {
    size_t v17 = *(void *)(v14 + 64);
  }
  else {
    size_t v17 = *(void *)(v14 + 64) + 1;
  }
  unsigned int v18 = v15 | *(_DWORD *)(v9 + 80) & 0xF8;
  if (v18 > 7
    || ((*(_DWORD *)(v9 + 80) | *(_DWORD *)(v14 + 80)) & 0x100000) != 0
    || ((((v17 + ((v10 + v15) & ~v15) + 7) & 0xFFFFFFFFFFFFFFF8) + 15) & 0xFFFFFFFFFFFFFFF8) + 17 > 0x18)
  {
    int v21 = *a2;
    *a1 = v21;
    a1 = (atomic_ullong **)((char *)v21 + (((v18 | 7) + 16) & ~(unint64_t)(v18 | 7)));
  }
  else
  {
    unint64_t v22 = v13;
    uint64_t v23 = ~v15;
    (*(void (**)(atomic_ullong **, atomic_ullong **, const char *))(v9 + 16))(a1, a2, AssociatedTypeWitness);
    uint64_t v24 = (const void *)(((unint64_t)a2 + v16) & v23);
    if ((*(unsigned int (**)(const void *, uint64_t, const char *))(v14 + 48))(v24, 1, v22))
    {
      memcpy((void *)(((unint64_t)a1 + v16) & v23), v24, v17);
    }
    else
    {
      (*(void (**)(unint64_t, const void *, const char *))(v14 + 16))(((unint64_t)a1 + v16) & v23, v24, v22);
      (*(void (**)(unint64_t, void, uint64_t, const char *))(v14 + 56))(((unint64_t)a1 + v16) & v23, 0, 1, v22);
    }
    unsigned int v25 = (void *)(((((unint64_t)a1 + v16) & v23) + v17 + 7) & 0xFFFFFFFFFFFFFFF8);
    unsigned int v26 = (atomic_ullong **)(((unint64_t)v24 + v17 + 7) & 0xFFFFFFFFFFFFFFF8);
    int v27 = *v26;
    *unsigned int v25 = *v26;
    unint64_t v28 = ((unint64_t)v25 + 15) & 0xFFFFFFFFFFFFFFF8;
    unint64_t v29 = ((unint64_t)v26 + 15) & 0xFFFFFFFFFFFFFFF8;
    int v21 = *(atomic_ullong **)v29;
    *(void *)unint64_t v28 = *(void *)v29;
    *(void *)(v28 + 8) = *(void *)(v29 + 8);
    *(unsigned char *)(v28 + 16) = *(unsigned char *)(v29 + 16);
    swift_retain(v27);
  }
  swift_retain(v21);
  return a1;
}

uint64_t destroy for JoinedSequence.Iterator(uint64_t a1, void *a2)
{
  uint64_t v5 = a2[2];
  uint64_t v4 = (int **)a2[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v4, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1) + 8;
  (*(void (**)(uint64_t, const char *))v7)(a1, AssociatedTypeWitness);
  uint64_t v8 = *(void *)(v7 + 56);
  uint64_t v9 = (int **)a2[4];
  uint64_t v10 = swift_getAssociatedTypeWitness(255, v4, v5, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v11 = swift_getAssociatedTypeWitness(0, v9, (uint64_t)v10, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v12 = *((void *)v11 - 1);
  unint64_t v13 = (v8 + a1 + *(unsigned __int8 *)(v12 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v12 + 80);
  if (!(*(unsigned int (**)(unint64_t, uint64_t, const char *))(v12 + 48))(v13, 1, v11)) {
    (*(void (**)(unint64_t, const char *))(v12 + 8))(v13, v11);
  }
  unint64_t v14 = v13 + *(void *)(v12 + 64);
  if (!*(_DWORD *)(v12 + 84)) {
    ++v14;
  }
  unint64_t v15 = v14 + 7;
  unint64_t v16 = (v15 & 0xFFFFFFFFFFFFFFF8) + 15;
  swift_release(*(void *)(v15 & 0xFFFFFFFFFFFFFFF8));
  uint64_t v17 = *(void *)(v16 & 0xFFFFFFFFFFFFFFF8);

  return swift_release(v17);
}

uint64_t initializeWithCopy for JoinedSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (int **)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1) + 16;
  (*(void (**)(uint64_t, uint64_t, const char *))v9)(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 48);
  unint64_t v11 = (int **)a3[4];
  uint64_t v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  unint64_t v16 = (void *)((v10 + v15 + a1) & ~v15);
  uint64_t v17 = (const void *)((v10 + v15 + a2) & ~v15);
  if ((*(unsigned int (**)(const void *, uint64_t, const char *))(v14 + 48))(v17, 1, v13))
  {
    int v18 = *(_DWORD *)(v14 + 84);
    size_t v19 = *(void *)(v14 + 64);
    if (v18) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v19 + 1;
    }
    memcpy(v16, v17, v20);
  }
  else
  {
    (*(void (**)(void *, const void *, const char *))(v14 + 16))(v16, v17, v13);
    unint64_t v22 = *(void (**)(void *, void, uint64_t, const char *))(v14 + 56);
    uint64_t v21 = v14 + 56;
    v22(v16, 0, 1, v13);
    int v18 = *(_DWORD *)(v21 + 28);
    size_t v19 = *(void *)(v21 + 8);
  }
  if (v18) {
    size_t v23 = v19;
  }
  else {
    size_t v23 = v19 + 1;
  }
  uint64_t v24 = (void *)(((unint64_t)v16 + v23 + 7) & 0xFFFFFFFFFFFFFFF8);
  unsigned int v25 = (atomic_ullong **)(((unint64_t)v17 + v23 + 7) & 0xFFFFFFFFFFFFFFF8);
  unsigned int v26 = *v25;
  *uint64_t v24 = *v25;
  unint64_t v27 = ((unint64_t)v24 + 15) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v28 = ((unint64_t)v25 + 15) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v29 = *(atomic_ullong **)v28;
  *(void *)unint64_t v27 = *(void *)v28;
  *(void *)(v27 + 8) = *(void *)(v28 + 8);
  *(unsigned char *)(v27 + 16) = *(unsigned char *)(v28 + 16);
  swift_retain(v26);
  swift_retain(v29);
  return a1;
}

uint64_t assignWithCopy for JoinedSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (int **)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1) + 24;
  (*(void (**)(uint64_t, uint64_t, const char *))v9)(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 40);
  unint64_t v11 = (int **)a3[4];
  uint64_t v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  unint64_t v16 = (void *)((v10 + v15 + a1) & ~v15);
  uint64_t v17 = (void *)((v10 + v15 + a2) & ~v15);
  int v18 = *(uint64_t (**)(void *, uint64_t, const char *))(v14 + 48);
  int v19 = v18(v16, 1, v13);
  int v20 = v18(v17, 1, v13);
  if (v19)
  {
    if (!v20)
    {
      (*(void (**)(void *, void *, const char *))(v14 + 16))(v16, v17, v13);
      (*(void (**)(void *, void, uint64_t, const char *))(v14 + 56))(v16, 0, 1, v13);
      goto LABEL_12;
    }
    int v21 = *(_DWORD *)(v14 + 84);
    size_t v22 = *(void *)(v14 + 64);
  }
  else
  {
    if (!v20)
    {
      (*(void (**)(void *, void *, const char *))(v14 + 24))(v16, v17, v13);
      goto LABEL_12;
    }
    (*(void (**)(void *, const char *))(v14 + 8))(v16, v13);
    int v21 = *(_DWORD *)(v14 + 84);
    size_t v22 = *(void *)(v14 + 64);
  }
  if (v21) {
    size_t v23 = v22;
  }
  else {
    size_t v23 = v22 + 1;
  }
  memcpy(v16, v17, v23);
LABEL_12:
  if (*(_DWORD *)(v14 + 84)) {
    uint64_t v24 = *(void *)(v14 + 64);
  }
  else {
    uint64_t v24 = *(void *)(v14 + 64) + 1;
  }
  uint64_t v25 = (uint64_t)v16 + v24 + 7;
  uint64_t v26 = (uint64_t)v17 + v24 + 7;
  unint64_t v28 = (v26 & 0xFFFFFFFFFFFFFFF8) + 15;
  unint64_t v27 = *(atomic_ullong **)(v26 & 0xFFFFFFFFFFFFFFF8);
  uint64_t v29 = *(void *)(v25 & 0xFFFFFFFFFFFFFFF8);
  *(void *)(v25 & 0xFFFFFFFFFFFFFFF8) = v27;
  unint64_t v30 = (v25 & 0xFFFFFFFFFFFFFFF8) + 15;
  swift_retain(v27);
  swift_release(v29);
  v30 &= 0xFFFFFFFFFFFFFFF8;
  v28 &= 0xFFFFFFFFFFFFFFF8;
  int v31 = *(atomic_ullong **)v28;
  uint64_t v32 = *(void *)v30;
  *(void *)unint64_t v30 = *(void *)v28;
  swift_retain(v31);
  swift_release(v32);
  *(void *)(v30 + 8) = *(void *)(v28 + 8);
  *(unsigned char *)(v30 + 16) = *(unsigned char *)(v28 + 16);
  return a1;
}

uint64_t initializeWithTake for JoinedSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (int **)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1) + 32;
  (*(void (**)(uint64_t, uint64_t, const char *))v9)(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 32);
  unint64_t v11 = (int **)a3[4];
  uint64_t v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  unint64_t v16 = (void *)((v10 + v15 + a1) & ~v15);
  uint64_t v17 = (const void *)((v10 + v15 + a2) & ~v15);
  if ((*(unsigned int (**)(const void *, uint64_t, const char *))(v14 + 48))(v17, 1, v13))
  {
    int v18 = *(_DWORD *)(v14 + 84);
    size_t v19 = *(void *)(v14 + 64);
    if (v18) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v19 + 1;
    }
    memcpy(v16, v17, v20);
  }
  else
  {
    (*(void (**)(void *, const void *, const char *))(v14 + 32))(v16, v17, v13);
    size_t v22 = *(void (**)(void *, void, uint64_t, const char *))(v14 + 56);
    uint64_t v21 = v14 + 56;
    v22(v16, 0, 1, v13);
    int v18 = *(_DWORD *)(v21 + 28);
    size_t v19 = *(void *)(v21 + 8);
  }
  if (v18) {
    size_t v23 = v19;
  }
  else {
    size_t v23 = v19 + 1;
  }
  uint64_t v24 = (void *)(((unint64_t)v16 + v23 + 7) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v25 = (void *)(((unint64_t)v17 + v23 + 7) & 0xFFFFFFFFFFFFFFF8);
  *uint64_t v24 = *v25;
  unint64_t v26 = ((unint64_t)v24 + 15) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v27 = ((unint64_t)v25 + 15) & 0xFFFFFFFFFFFFFFF8;
  *(_OWORD *)unint64_t v26 = *(_OWORD *)v27;
  *(unsigned char *)(v26 + 16) = *(unsigned char *)(v27 + 16);
  return a1;
}

uint64_t assignWithTake for JoinedSequence.Iterator(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (int **)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1) + 40;
  (*(void (**)(uint64_t, uint64_t, const char *))v9)(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 24);
  unint64_t v11 = (int **)a3[4];
  uint64_t v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  unint64_t v13 = swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v14 = *((void *)v13 - 1);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 80);
  unint64_t v16 = (void *)((v10 + v15 + a1) & ~v15);
  uint64_t v17 = (void *)((v10 + v15 + a2) & ~v15);
  int v18 = *(uint64_t (**)(void *, uint64_t, const char *))(v14 + 48);
  int v19 = v18(v16, 1, v13);
  int v20 = v18(v17, 1, v13);
  if (v19)
  {
    if (!v20)
    {
      (*(void (**)(void *, void *, const char *))(v14 + 32))(v16, v17, v13);
      (*(void (**)(void *, void, uint64_t, const char *))(v14 + 56))(v16, 0, 1, v13);
      goto LABEL_12;
    }
    int v21 = *(_DWORD *)(v14 + 84);
    size_t v22 = *(void *)(v14 + 64);
  }
  else
  {
    if (!v20)
    {
      (*(void (**)(void *, void *, const char *))(v14 + 40))(v16, v17, v13);
      goto LABEL_12;
    }
    (*(void (**)(void *, const char *))(v14 + 8))(v16, v13);
    int v21 = *(_DWORD *)(v14 + 84);
    size_t v22 = *(void *)(v14 + 64);
  }
  if (v21) {
    size_t v23 = v22;
  }
  else {
    size_t v23 = v22 + 1;
  }
  memcpy(v16, v17, v23);
LABEL_12:
  if (*(_DWORD *)(v14 + 84)) {
    uint64_t v24 = *(void *)(v14 + 64);
  }
  else {
    uint64_t v24 = *(void *)(v14 + 64) + 1;
  }
  uint64_t v25 = (uint64_t)v16 + v24 + 7;
  unint64_t v26 = (void *)(((unint64_t)v17 + v24 + 7) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v27 = *(void *)(v25 & 0xFFFFFFFFFFFFFFF8);
  *(void *)(v25 & 0xFFFFFFFFFFFFFFF8) = *v26;
  unint64_t v28 = (v25 & 0xFFFFFFFFFFFFFFF8) + 15;
  swift_release(v27);
  v28 &= 0xFFFFFFFFFFFFFFF8;
  unint64_t v29 = ((unint64_t)v26 + 15) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v30 = *(void *)v28;
  *(void *)unint64_t v28 = *(void *)v29;
  swift_release(v30);
  *(void *)(v28 + 8) = *(void *)(v29 + 8);
  *(unsigned char *)(v28 + 16) = *(unsigned char *)(v29 + 16);
  return a1;
}

uint64_t getEnumTagSinglePayload for JoinedSequence.Iterator(unsigned __int8 *a1, unsigned int a2, void *a3)
{
  uint64_t v7 = a3[2];
  uint64_t v6 = (int **)a3[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  v34 = AssociatedTypeWitness;
  uint64_t v10 = *(unsigned int *)(v9 + 84);
  unint64_t v11 = (int **)a3[4];
  uint64_t v12 = swift_getAssociatedTypeWitness(255, v6, v7, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v13 = *((void *)swift_getAssociatedTypeWitness(0, v11, (uint64_t)v12, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator)- 1);
  uint64_t v14 = v13;
  unsigned int v15 = *(_DWORD *)(v13 + 84);
  if (v15) {
    unsigned int v16 = v15 - 1;
  }
  else {
    unsigned int v16 = 0;
  }
  if (v16 <= v10) {
    unsigned int v17 = v10;
  }
  else {
    unsigned int v17 = v16;
  }
  if (v17 <= 0x7FFFFFFF) {
    unsigned int v17 = 0x7FFFFFFF;
  }
  uint64_t v18 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v19 = *(void *)(v13 + 64);
  if (!v15) {
    ++v19;
  }
  if (!a2) {
    return 0;
  }
  uint64_t v20 = *(void *)(v9 + 64) + v18;
  uint64_t v21 = v19 + 7;
  if (v17 < a2)
  {
    unint64_t v22 = ((((v21 + (v20 & ~v18)) & 0xFFFFFFFFFFFFFFF8) + 15) & 0xFFFFFFFFFFFFFFF8) + 17;
    if (v22 < 4) {
      unsigned int v23 = ((a2 - v17 + 255) >> (8 * v22)) + 1;
    }
    else {
      unsigned int v23 = 2;
    }
    if (v23 >= 0x10000) {
      unsigned int v24 = 4;
    }
    else {
      unsigned int v24 = 2;
    }
    if (v23 < 0x100) {
      unsigned int v24 = 1;
    }
    if (v23 >= 2) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = 0;
    }
    switch(v25)
    {
      case 1:
        int v26 = a1[v22];
        if (!a1[v22]) {
          break;
        }
        goto LABEL_28;
      case 2:
        int v26 = *(unsigned __int16 *)&a1[v22];
        if (*(_WORD *)&a1[v22]) {
          goto LABEL_28;
        }
        break;
      case 3:
        __break(1u);
        JUMPOUT(0x18151268CLL);
      case 4:
        int v26 = *(_DWORD *)&a1[v22];
        if (!v26) {
          break;
        }
LABEL_28:
        int v27 = (v26 - 1) << (8 * v22);
        if (v22 >= 4) {
          int v27 = 0;
        }
        if (v22 == 1) {
          int v28 = *a1;
        }
        else {
          int v28 = *(_DWORD *)a1;
        }
        return v17 + (v28 | v27) + 1;
      default:
        break;
    }
  }
  if (v10 == v17)
  {
    unint64_t v29 = *(uint64_t (**)(unsigned __int8 *, uint64_t, const char *))(v9 + 48);
    return v29(a1, v10, v34);
  }
  unint64_t v31 = (unint64_t)&a1[v20] & ~v18;
  if (v16 == v17)
  {
    if (v15 >= 2)
    {
      unsigned int v33 = (*(uint64_t (**)(unint64_t))(v14 + 48))(v31);
      if (v33 >= 2) {
        return v33 - 1;
      }
      else {
        return 0;
      }
    }
    return 0;
  }
  unint64_t v32 = *(void *)((v21 + v31) & 0xFFFFFFFFFFFFFFF8);
  if (v32 >= 0xFFFFFFFF) {
    LODWORD(v32) = -1;
  }
  return (v32 + 1);
}

void storeEnumTagSinglePayload for JoinedSequence.Iterator(unsigned char *a1, uint64_t a2, unsigned int a3, void *a4)
{
  uint64_t v8 = a4[2];
  uint64_t v7 = (int **)a4[3];
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v8, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  v38 = AssociatedTypeWitness;
  uint64_t v11 = *(unsigned int *)(v10 + 84);
  uint64_t v12 = (int **)a4[4];
  uint64_t v13 = swift_getAssociatedTypeWitness(255, v7, v8, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  int v14 = 0;
  uint64_t v15 = *((void *)swift_getAssociatedTypeWitness(0, v12, (uint64_t)v13, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator)- 1);
  uint64_t v16 = v15;
  int v17 = *(_DWORD *)(v15 + 84);
  unsigned int v18 = v17 - 1;
  if (!v17) {
    unsigned int v18 = 0;
  }
  uint64_t v19 = *(unsigned __int8 *)(v15 + 80);
  uint64_t v20 = *(void *)(v15 + 64);
  if (v18 <= v11) {
    unsigned int v21 = v11;
  }
  else {
    unsigned int v21 = v18;
  }
  if (v21 <= 0x7FFFFFFF) {
    unsigned int v21 = 0x7FFFFFFF;
  }
  uint64_t v22 = *(void *)(v10 + 64) + v19;
  if (!v17) {
    ++v20;
  }
  uint64_t v23 = v20 + 7;
  size_t v24 = ((((v23 + (v22 & ~v19)) & 0xFFFFFFFFFFFFFFF8) + 15) & 0xFFFFFFFFFFFFFFF8) + 17;
  char v25 = 8 * v24;
  if (v21 < a3)
  {
    if (v24 <= 3) {
      unsigned int v26 = ((a3 - v21 + 255) >> v25) + 1;
    }
    else {
      unsigned int v26 = 2;
    }
    if (v26 >= 0x10000) {
      int v27 = 4;
    }
    else {
      int v27 = 2;
    }
    if (v26 < 0x100) {
      int v27 = 1;
    }
    if (v26 >= 2) {
      int v14 = v27;
    }
    else {
      int v14 = 0;
    }
  }
  if (v21 < a2)
  {
    unsigned int v28 = ~v21 + a2;
    unsigned int v29 = (~(_BYTE)v21 + a2);
    if (v24 < 4) {
      int v30 = (v28 >> v25) + 1;
    }
    else {
      int v30 = 1;
    }
    if (v24 >= 4) {
      unsigned int v31 = v28;
    }
    else {
      unsigned int v31 = v29;
    }
    bzero(a1, v24);
    if (v24 == 1) {
      *a1 = v31;
    }
    else {
      *(_DWORD *)a1 = v31;
    }
    switch(v14)
    {
      case 1:
        a1[v24] = v30;
        return;
      case 2:
        *(_WORD *)&a1[v24] = v30;
        return;
      case 3:
        goto LABEL_56;
      case 4:
        *(_DWORD *)&a1[v24] = v30;
        return;
      default:
        return;
    }
  }
  uint64_t v32 = ~v19;
  switch(v14)
  {
    case 1:
      a1[v24] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_39;
    case 2:
      *(_WORD *)&a1[v24] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_39;
    case 3:
LABEL_56:
      __break(1u);
      JUMPOUT(0x181512A04);
    case 4:
      *(_DWORD *)&a1[v24] = 0;
      goto LABEL_38;
    default:
LABEL_38:
      if (a2)
      {
LABEL_39:
        if (v11 == v21)
        {
          unsigned int v33 = *(void (**)(unsigned char *, uint64_t, uint64_t, const char *))(v10 + 56);
          v33(a1, a2, v11, v38);
        }
        else
        {
          unint64_t v34 = (unint64_t)&a1[v22] & v32;
          if (v18 == v21)
          {
            v35 = *(void (**)(unint64_t, void))(v16 + 56);
            v35(v34, (a2 + 1));
          }
          else
          {
            v36 = (void *)((v23 + v34) & 0xFFFFFFFFFFFFFFF8);
            if ((a2 & 0x80000000) != 0) {
              uint64_t v37 = a2 ^ 0x80000000;
            }
            else {
              uint64_t v37 = (a2 - 1);
            }
            void *v36 = v37;
          }
        }
      }
      return;
  }
}

Class *type metadata accessor for JoinedSequence.Iterator._JoinIteratorState(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for JoinedSequence.Iterator._JoinIteratorState.Flags);
}

uint64_t type metadata accessor for AnyKeyPath()
{
  return self;
}

uint64_t method lookup function for AnyKeyPath(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for AnyKeyPath.Flags);
}

uint64_t dispatch thunk of AnyKeyPath._kvcKeyPathString.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 104))();
}

uint64_t dispatch thunk of static AnyKeyPath._rootAndValueType.getter()
{
  return (*(uint64_t (**)(void))(v0 + 120))();
}

uint64_t dispatch thunk of AnyKeyPath._storedInlineOffset.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 128))();
}

swift *type metadata completion function for PartialKeyPath(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0, (uint64_t)v2, a1 + 144);
}

swift *type metadata completion function for KeyPath(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0, (uint64_t)v2, a1 + 160);
}

uint64_t method lookup function for KeyPath(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for KeyPath.Flags);
}

uint64_t method lookup function for WritableKeyPath(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for WritableKeyPath.Flags);
}

uint64_t dispatch thunk of WritableKeyPath._projectMutableAddress(from:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 184))();
}

swift *type metadata completion function for ReferenceWritableKeyPath(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0, (uint64_t)v2, a1 + 208);
}

swift *type metadata completion function for ClassHolder(uint64_t a1)
{
  v2[0] = "\b";
  v2[1] = &value witness table for Builtin.UnknownObject.size;
  return swift_initClassMetadata2(a1, 0, 2uLL, (uint64_t)v2, a1 + 88);
}

Class *type metadata accessor for ClassHolder(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for ClassHolder.Flags);
}

void *type metadata completion function for MutatingWritebackBuffer(uint64_t a1)
{
  v4[0] = "\b";
  v4[1] = &unk_1ECA04B28;
  void v4[2] = &unk_1ECA04B28;
  v4[3] = &unk_1ECA04B28;
  v4[4] = &value witness table for Builtin.Int64.size;
  uint64_t result = swift_checkMetadataState(319, *(void *)(a1 + 88));
  if (v3 <= 0x3F)
  {
    v4[5] = *(result - 1) + 64;
    uint64_t result = swift_initClassMetadata2(a1, 0, 6uLL, (uint64_t)v4, a1 + 96);
    if (!result) {
      return 0;
    }
  }
  return result;
}

Class *type metadata accessor for MutatingWritebackBuffer(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for MutatingWritebackBuffer.Flags);
}

void *type metadata completion function for NonmutatingWritebackBuffer(uint64_t a1)
{
  v5[0] = "\b";
  uint64_t result = swift_checkMetadataState(319, *(void *)(a1 + 80));
  if (v3 <= 0x3F)
  {
    v5[1] = *(result - 1) + 64;
    v5[2] = &unk_1ECA04B28;
    v5[3] = &unk_1ECA04B28;
    v5[4] = &value witness table for Builtin.Int64.size;
    uint64_t result = swift_checkMetadataState(319, *(void *)(a1 + 88));
    if (v4 <= 0x3F)
    {
      v5[5] = *(result - 1) + 64;
      uint64_t result = swift_initClassMetadata2(a1, 0, 6uLL, (uint64_t)v5, a1 + 96);
      if (!result) {
        return 0;
      }
    }
  }
  return result;
}

Class *type metadata accessor for NonmutatingWritebackBuffer(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for NonmutatingWritebackBuffer.Flags);
}

uint64_t default associated conformance accessor for LazyCollectionProtocol.LazySequenceProtocol.Elements: Collection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, *(int ***)(a3 + 16), a2, (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol, associated type descriptor for LazySequenceProtocol.Elements);

  return swift_getAssociatedConformanceWitness(a3, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for LazyCollectionProtocol, associated conformance descriptor for LazyCollectionProtocol.LazySequenceProtocol.Elements: Collection);
}

uint64_t default associated conformance accessor for LazySequenceProtocol.LazySequenceProtocol.Elements: Sequence(uint64_t a1, uint64_t a2, int **a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, a3, a2, (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol, associated type descriptor for LazySequenceProtocol.Elements);

  return swift_getAssociatedConformanceWitness((uint64_t)a3, a2, (uint64_t)AssociatedTypeWitness, (uint64_t)&protocol requirements base descriptor for LazySequenceProtocol, associated conformance descriptor for LazySequenceProtocol.LazySequenceProtocol.Elements: Sequence);
}

uint64_t dispatch thunk of LazySequenceProtocol.elements.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

void *type metadata completion function for _IndexBox(uint64_t a1)
{
  uint64_t result = swift_checkMetadataState(319, *(void *)(a1 + 80));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    uint64_t result = swift_initClassMetadata2(a1, 0, 1uLL, (uint64_t)&v4, a1 + 96);
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t method lookup function for ManagedBuffer(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for ManagedBuffer.Flags);
}

uint64_t dispatch thunk of ManagedBuffer.__allocating_init(_doNotCallMe:)()
{
  return (*(uint64_t (**)(void))(v0 + 104))();
}

Class *type metadata accessor for ManagedBufferPointer(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for ManagedBufferPointer.Flags);
}

uint64_t *type metadata completion function for LazyMapSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for JoinedSequence(a1, a2, a3, (uint64_t)&unk_1ECA05CB0);
}

uint64_t *type metadata completion function for JoinedSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = swift_checkMetadataState(319, *(void *)(a1 + 16));
  if (v7 <= 0x3F)
  {
    v8[0] = *(result - 1) + 64;
    v8[1] = a4;
    swift_initStructMetadata(a1, 0, 2uLL, (uint64_t)v8, a1 + 40);
    return 0;
  }
  return result;
}

const char *type metadata completion function for LazyMapSequence.Iterator(uint64_t a1)
{
  uint64_t result = swift_getAssociatedTypeWitness(319, *(int ***)(a1 + 32), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  if (v3 <= 0x3F)
  {
    v4[0] = *((void *)result - 1) + 64;
    v4[1] = &unk_1ECA05CB0;
    swift_initStructMetadata(a1, 0, 2uLL, (uint64_t)v4, a1 + 40);
    return 0;
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for LazyMapSequence.Iterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 32), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v7 = *(void *)(v6 + 64);
  int v8 = *(_DWORD *)(v6 + 80);
  if ((v8 & 0x1000F8) != 0 || ((v7 + 7) & 0xFFFFFFFFFFFFFFF8) + 16 > 0x18)
  {
    uint64_t v11 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v11 + ((unsigned __int16)((v8 & 0xF8) + 23) & (unsigned __int16)~(v8 & 0xF8) & 0x1F8));
  }
  else
  {
    (*(void (**)(atomic_ullong **, atomic_ullong **, const char *))(v6 + 16))(a1, a2, AssociatedTypeWitness);
    uint64_t v10 = (void *)(((unint64_t)a2 + v7 + 7) & 0xFFFFFFFFFFFFFFF8);
    uint64_t v11 = (atomic_ullong *)v10[1];
    uint64_t v12 = (void *)(((unint64_t)a1 + v7 + 7) & 0xFFFFFFFFFFFFFFF8);
    void *v12 = *v10;
    v12[1] = v11;
  }
  swift_retain(v11);
  return a1;
}

uint64_t destroy for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 32), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v4 = *((void *)AssociatedTypeWitness - 1) + 8;
  (*(void (**)(uint64_t, const char *))v4)(a1, AssociatedTypeWitness);
  uint64_t v5 = *(void *)(((a1 + *(void *)(v4 + 56) + 7) & 0xFFFFFFFFFFFFFFF8) + 8);

  return swift_release(v5);
}

uint64_t initializeWithCopy for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 32), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1) + 16;
  (*(void (**)(uint64_t, uint64_t, const char *))v6)(a1, a2, AssociatedTypeWitness);
  uint64_t v7 = *(void *)(v6 + 48) + 7;
  int v8 = (void *)((v7 + a1) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v9 = (void *)((v7 + a2) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v10 = (atomic_ullong *)v9[1];
  *int v8 = *v9;
  v8[1] = v10;
  swift_retain(v10);
  return a1;
}

uint64_t assignWithCopy for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 32), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1) + 24;
  (*(void (**)(uint64_t, uint64_t, const char *))v6)(a1, a2, AssociatedTypeWitness);
  uint64_t v7 = *(void *)(v6 + 40) + 7;
  int v8 = (void *)((v7 + a1) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v9 = (void *)((v7 + a2) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v10 = (atomic_ullong *)v9[1];
  uint64_t v11 = v8[1];
  *int v8 = *v9;
  v8[1] = v10;
  swift_retain(v10);
  swift_release(v11);
  return a1;
}

uint64_t initializeWithTake for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 32), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1) + 32;
  (*(void (**)(uint64_t, uint64_t, const char *))v6)(a1, a2, AssociatedTypeWitness);
  *(_OWORD *)((*(void *)(v6 + 32) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *(_OWORD *)((*(void *)(v6 + 32) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t assignWithTake for LazyMapSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 32), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1) + 40;
  (*(void (**)(uint64_t, uint64_t, const char *))v6)(a1, a2, AssociatedTypeWitness);
  uint64_t v7 = *(void *)(v6 + 24) + 7;
  unint64_t v8 = (v7 + a1) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v9 = *(void *)(v8 + 8);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)((v7 + a2) & 0xFFFFFFFFFFFFFFF8);
  swift_release(v9);
  return a1;
}

uint64_t getEnumTagSinglePayload for LazyMapSequence.Iterator(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 32), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  if (v7 <= 0x7FFFFFFF) {
    unsigned int v8 = 0x7FFFFFFF;
  }
  else {
    unsigned int v8 = *(_DWORD *)(v6 + 84);
  }
  uint64_t v9 = *(void *)(*((void *)AssociatedTypeWitness - 1) + 64);
  if (!a2) {
    return 0;
  }
  if (v8 < a2)
  {
    unint64_t v10 = ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
    uint64_t v11 = v10 & 0xFFFFFFF8;
    if ((v10 & 0xFFFFFFF8) != 0) {
      unsigned int v12 = 2;
    }
    else {
      unsigned int v12 = a2 - v8 + 1;
    }
    if (v12 >= 0x10000) {
      unsigned int v13 = 4;
    }
    else {
      unsigned int v13 = 2;
    }
    if (v12 < 0x100) {
      unsigned int v13 = 1;
    }
    if (v12 >= 2) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0;
    }
    switch(v14)
    {
      case 1:
        int v15 = *((unsigned __int8 *)a1 + v10);
        if (!v15) {
          break;
        }
        goto LABEL_22;
      case 2:
        int v15 = *(unsigned __int16 *)((char *)a1 + v10);
        if (v15) {
          goto LABEL_22;
        }
        break;
      case 3:
        __break(1u);
        JUMPOUT(0x181513760);
      case 4:
        int v15 = *(_DWORD *)((char *)a1 + v10);
        if (!v15) {
          break;
        }
LABEL_22:
        int v17 = v15 - 1;
        if (v11)
        {
          int v17 = 0;
          LODWORD(v11) = *a1;
        }
        return v8 + (v11 | v17) + 1;
      default:
        break;
    }
  }
  if (v7 < 0x7FFFFFFF)
  {
    unint64_t v19 = *(void *)(((unint64_t)a1 + v9 + 7) & 0xFFFFFFFFFFFFFFF8);
    if (v19 >= 0xFFFFFFFF) {
      LODWORD(v19) = -1;
    }
    return (v19 + 1);
  }
  else
  {
    unsigned int v18 = *(uint64_t (**)(_DWORD *))(v6 + 48);
    return v18(a1);
  }
}

void storeEnumTagSinglePayload for LazyMapSequence.Iterator(_DWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 32), *(void *)(a4 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator)- 1);
  unsigned int v8 = *(_DWORD *)(v7 + 84);
  uint64_t v9 = *(void *)(v7 + 64);
  if (v8 <= 0x7FFFFFFF) {
    unsigned int v10 = 0x7FFFFFFF;
  }
  else {
    unsigned int v10 = *(_DWORD *)(v7 + 84);
  }
  size_t v11 = ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
  if (((v9 + 7) & 0xFFFFFFF8) == 0xFFFFFFF0) {
    unsigned int v12 = a3 - v10 + 1;
  }
  else {
    unsigned int v12 = 2;
  }
  if (v12 >= 0x10000) {
    int v13 = 4;
  }
  else {
    int v13 = 2;
  }
  if (v12 < 0x100) {
    int v13 = 1;
  }
  if (v12 >= 2) {
    unsigned int v14 = v13;
  }
  else {
    unsigned int v14 = 0;
  }
  if (v10 < a3) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 0;
  }
  if (a2 > v10)
  {
    if (((v9 + 7) & 0xFFFFFFF8) == 0xFFFFFFF0) {
      int v16 = a2 - v10;
    }
    else {
      int v16 = 1;
    }
    if (((v9 + 7) & 0xFFFFFFF8) != 0xFFFFFFF0)
    {
      int v17 = ~v10 + a2;
      bzero(a1, v11);
      *a1 = v17;
    }
    switch(v15)
    {
      case 1:
        *((unsigned char *)a1 + v11) = v16;
        return;
      case 2:
        *(_WORD *)((char *)a1 + v11) = v16;
        return;
      case 3:
        goto LABEL_44;
      case 4:
        *(_DWORD *)((char *)a1 + v11) = v16;
        return;
      default:
        return;
    }
  }
  switch(v15)
  {
    case 1:
      *((unsigned char *)a1 + v11) = 0;
      if (!a2) {
        return;
      }
      goto LABEL_33;
    case 2:
      *(_WORD *)((char *)a1 + v11) = 0;
      if (!a2) {
        return;
      }
      goto LABEL_33;
    case 3:
LABEL_44:
      __break(1u);
      JUMPOUT(0x181513978);
    case 4:
      *(_DWORD *)((char *)a1 + v11) = 0;
      goto LABEL_32;
    default:
LABEL_32:
      if (a2)
      {
LABEL_33:
        if (v8 < 0x7FFFFFFF)
        {
          unint64_t v19 = (void *)(((unint64_t)a1 + v9 + 7) & 0xFFFFFFFFFFFFFFF8);
          if ((a2 & 0x80000000) != 0)
          {
            uint64_t v20 = a2 ^ 0x80000000;
            v19[1] = 0;
          }
          else
          {
            uint64_t v20 = (a2 - 1);
          }
          *unint64_t v19 = v20;
        }
        else
        {
          unsigned int v18 = *(void (**)(_DWORD *, uint64_t))(v7 + 56);
          v18(a1, a2);
        }
      }
      return;
  }
}

Class *type metadata accessor for MemoryLayout(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for MemoryLayout.Flags);
}

ValueMetadata *type metadata accessor for Unicode.Scalar()
{
  return &type metadata for Unicode.Scalar;
}

ValueMetadata *type metadata accessor for Unicode.Scalar.UTF16View()
{
  return &type metadata for Unicode.Scalar.UTF16View;
}

ValueMetadata *type metadata accessor for Unicode.Scalar.UTF8View()
{
  return &type metadata for Unicode.Scalar.UTF8View;
}

uint64_t default associated conformance accessor for MutableCollection.Collection.SubSequence: MutableCollection(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&v4);
}

uint64_t dispatch thunk of MutableCollection.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

{
  return (*(uint64_t (**)(void))(a4 + 40))();
}

uint64_t dispatch thunk of MutableCollection.subscript.modify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

{
  return (*(uint64_t (**)(void))(a4 + 48))();
}

uint64_t dispatch thunk of MutableCollection.partition(by:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 56))();
}

uint64_t dispatch thunk of MutableCollection.swapAt(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 64))();
}

uint64_t dispatch thunk of MutableCollection._withUnsafeMutableBufferPointerIfSupported<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 72))();
}

uint64_t dispatch thunk of MutableCollection.withContiguousMutableStorageIfAvailable<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 80))();
}

Class *type metadata accessor for _NativeDictionary.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _NativeDictionary.Iterator.Flags);
}

uint64_t destroy for _NativeSet.Iterator(uint64_t *a1)
{
  return swift_release(*a1);
}

uint64_t initializeWithCopy for _NativeSet.Iterator(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(atomic_ullong **)a2;
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  swift_retain(v3);
  return a1;
}

uint64_t *assignWithCopy for _NativeDictionary.Iterator(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *(atomic_ullong **)a2;
  uint64_t v5 = *a1;
  *a1 = *(void *)a2;
  swift_retain(v4);
  swift_release(v5);
  a1[1] = *(void *)(a2 + 8);
  a1[2] = *(void *)(a2 + 16);
  a1[3] = *(void *)(a2 + 24);
  a1[4] = *(void *)(a2 + 32);
  return a1;
}

uint64_t assignWithTake for _NativeDictionary.Iterator(uint64_t a1, uint64_t a2)
{
  swift_release(*(void *)a1);
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  return a1;
}

uint64_t getEnumTagSinglePayload for _NativeDictionary.Iterator(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 40)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for _NativeDictionary.Iterator(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(void *)uint64_t result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 40) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)uint64_t result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 40) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

Class *type metadata accessor for _NativeSet.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _NativeSet.Iterator.Flags);
}

ValueMetadata *type metadata accessor for ObjectIdentifier()
{
  return &type metadata for ObjectIdentifier;
}

uint64_t *type metadata completion function for ClosedRange<>.Index(uint64_t a1)
{
  uint64_t result = swift_checkMetadataState(319, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    swift_initEnumMetadataSinglePayload(a1, 0, *(result - 1) + 64, 1u);
    return 0;
  }
  return result;
}

uint64_t getEnumTag for ClosedRange<>.Index(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a2 + 16) - 8) + 48))(a1, 1);
}

uint64_t destructiveInjectEnumTag for ClosedRange<>.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(*(void *)(a3 + 16) - 8) + 56))(a1, a2, 1);
}

ValueMetadata *type metadata accessor for _OptionalNilComparisonType()
{
  return &type metadata for _OptionalNilComparisonType;
}

uint64_t dispatch thunk of OptionSet.init(rawValue:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 24))();
}

uint64_t dispatch thunk of TextOutputStream._lock()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of TextOutputStream._unlock()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of TextOutputStream.write(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

uint64_t dispatch thunk of TextOutputStream._writeASCII(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t dispatch thunk of TextOutputStreamable.write<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 8))();
}

uint64_t dispatch thunk of CustomStringConvertible.description.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of LosslessStringConvertible.init(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 16))();
}

uint64_t dispatch thunk of CustomDebugStringConvertible.debugDescription.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of _Pointer._rawValue.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

uint64_t dispatch thunk of _Pointer.init(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

ValueMetadata *type metadata accessor for Never()
{
  return &type metadata for Never;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for LazyDropWhileSequence(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  long long v4 = a1;
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8);
  uint64_t v6 = *(void *)(v5 + 64);
  int v7 = *(_DWORD *)(v5 + 80);
  if ((v7 & 0x1000F8) != 0 || ((v6 + 7) & 0xFFFFFFFFFFFFFFF8) + 16 > 0x18)
  {
    unsigned int v10 = *a2;
    atomic_ullong *v4 = *a2;
    long long v4 = (atomic_ullong **)((char *)v10 + ((unsigned __int16)((v7 & 0xF8) + 23) & (unsigned __int16)~(v7 & 0xF8) & 0x1F8));
  }
  else
  {
    (*(void (**)(atomic_ullong **, atomic_ullong **))(v5 + 16))(a1, a2);
    uint64_t v9 = (void *)(((unint64_t)a2 + v6 + 7) & 0xFFFFFFFFFFFFFFF8);
    unsigned int v10 = (atomic_ullong *)v9[1];
    size_t v11 = (void *)(((unint64_t)v4 + v6 + 7) & 0xFFFFFFFFFFFFFFF8);
    void *v11 = *v9;
    v11[1] = v10;
  }
  swift_retain(v10);
  return v4;
}

uint64_t destroy for LazyDropWhileSequence(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(a2 + 16) - 8) + 8;
  (*(void (**)(void))v3)();
  uint64_t v4 = *(void *)(((a1 + *(void *)(v3 + 56) + 7) & 0xFFFFFFFFFFFFFFF8) + 8);

  return swift_release(v4);
}

uint64_t initializeWithCopy for LazyDropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8) + 16;
  (*(void (**)(void))v5)();
  uint64_t v6 = *(void *)(v5 + 48) + 7;
  int v7 = (void *)((v6 + a1) & 0xFFFFFFFFFFFFFFF8);
  unsigned int v8 = (void *)((v6 + a2) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v9 = (atomic_ullong *)v8[1];
  void *v7 = *v8;
  v7[1] = v9;
  swift_retain(v9);
  return a1;
}

uint64_t assignWithCopy for LazyDropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8) + 24;
  (*(void (**)(void))v5)();
  uint64_t v6 = *(void *)(v5 + 40) + 7;
  int v7 = (void *)((v6 + a1) & 0xFFFFFFFFFFFFFFF8);
  unsigned int v8 = (void *)((v6 + a2) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v9 = (atomic_ullong *)v8[1];
  uint64_t v10 = v7[1];
  void *v7 = *v8;
  v7[1] = v9;
  swift_retain(v9);
  swift_release(v10);
  return a1;
}

uint64_t initializeWithTake for LazyDropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8) + 32;
  (*(void (**)(void))v5)();
  *(_OWORD *)((*(void *)(v5 + 32) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *(_OWORD *)((*(void *)(v5 + 32) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t assignWithTake for LazyDropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8) + 40;
  (*(void (**)(void))v5)();
  uint64_t v6 = *(void *)(v5 + 24) + 7;
  unint64_t v7 = (v6 + a1) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v8 = *(void *)(v7 + 8);
  *(_OWORD *)unint64_t v7 = *(_OWORD *)((v6 + a2) & 0xFFFFFFFFFFFFFFF8);
  swift_release(v8);
  return a1;
}

uint64_t getEnumTagSinglePayload for LazyDropWhileSequence(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  uint64_t v6 = *(void *)(v4 + 64);
  if (v5 <= 0x7FFFFFFF) {
    unsigned int v7 = 0x7FFFFFFF;
  }
  else {
    unsigned int v7 = *(_DWORD *)(v4 + 84);
  }
  if (!a2) {
    return 0;
  }
  if (v7 < a2)
  {
    unint64_t v8 = ((v6 + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
    unsigned int v9 = a2 - v7;
    uint64_t v10 = v8 & 0xFFFFFFF8;
    if ((v8 & 0xFFFFFFF8) != 0) {
      unsigned int v11 = 2;
    }
    else {
      unsigned int v11 = v9 + 1;
    }
    if (v11 >= 0x10000) {
      unsigned int v12 = 4;
    }
    else {
      unsigned int v12 = 2;
    }
    if (v11 < 0x100) {
      unsigned int v12 = 1;
    }
    if (v11 >= 2) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = 0;
    }
    switch(v13)
    {
      case 1:
        int v14 = *((unsigned __int8 *)a1 + v8);
        if (!v14) {
          break;
        }
        goto LABEL_22;
      case 2:
        int v14 = *(unsigned __int16 *)((char *)a1 + v8);
        if (v14) {
          goto LABEL_22;
        }
        break;
      case 3:
        __break(1u);
        JUMPOUT(0x18151436CLL);
      case 4:
        int v14 = *(_DWORD *)((char *)a1 + v8);
        if (!v14) {
          break;
        }
LABEL_22:
        int v16 = v14 - 1;
        if (v10)
        {
          int v16 = 0;
          LODWORD(v10) = *a1;
        }
        return v7 + (v10 | v16) + 1;
      default:
        break;
    }
  }
  if (v5 >= 0x7FFFFFFF) {
    return (*(uint64_t (**)(void))(v4 + 48))();
  }
  unint64_t v17 = *(void *)(((unint64_t)a1 + v6 + 7) & 0xFFFFFFFFFFFFFFF8);
  if (v17 >= 0xFFFFFFFF) {
    LODWORD(v17) = -1;
  }
  return (v17 + 1);
}

void storeEnumTagSinglePayload for LazyDropWhileSequence(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 16) - 8);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  if (v7 <= 0x7FFFFFFF) {
    unsigned int v8 = 0x7FFFFFFF;
  }
  else {
    unsigned int v8 = *(_DWORD *)(v6 + 84);
  }
  uint64_t v9 = *(void *)(*(void *)(*(void *)(a4 + 16) - 8) + 64);
  unint64_t v10 = ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 16;
  if (((v9 + 7) & 0xFFFFFFF8) == 0xFFFFFFF0) {
    unsigned int v11 = a3 - v8 + 1;
  }
  else {
    unsigned int v11 = 2;
  }
  if (v11 >= 0x10000) {
    int v12 = 4;
  }
  else {
    int v12 = 2;
  }
  if (v11 < 0x100) {
    int v12 = 1;
  }
  if (v11 >= 2) {
    unsigned int v13 = v12;
  }
  else {
    unsigned int v13 = 0;
  }
  if (v8 < a3) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  if (a2 > v8)
  {
    if (((v9 + 7) & 0xFFFFFFF8) == 0xFFFFFFF0) {
      int v15 = a2 - v8;
    }
    else {
      int v15 = 1;
    }
    if (((v9 + 7) & 0xFFFFFFF8) != 0xFFFFFFF0)
    {
      int v16 = ~v8 + a2;
      bzero(a1, ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 16);
      *(_DWORD *)a1 = v16;
    }
    switch(v14)
    {
      case 1:
        a1[v10] = v15;
        return;
      case 2:
        *(_WORD *)&a1[v10] = v15;
        return;
      case 3:
        goto LABEL_44;
      case 4:
        *(_DWORD *)&a1[v10] = v15;
        return;
      default:
        return;
    }
  }
  switch(v14)
  {
    case 1:
      a1[v10] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_33;
    case 2:
      *(_WORD *)&a1[v10] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_33;
    case 3:
LABEL_44:
      __break(1u);
      JUMPOUT(0x181514560);
    case 4:
      *(_DWORD *)&a1[v10] = 0;
      goto LABEL_32;
    default:
LABEL_32:
      if (a2)
      {
LABEL_33:
        if (v7 < 0x7FFFFFFF)
        {
          unsigned int v18 = (void *)((unint64_t)&a1[v9 + 7] & 0xFFFFFFFFFFFFFFF8);
          if ((a2 & 0x80000000) != 0)
          {
            uint64_t v19 = a2 ^ 0x80000000;
            v18[1] = 0;
          }
          else
          {
            uint64_t v19 = a2 - 1;
          }
          *unsigned int v18 = v19;
        }
        else
        {
          unint64_t v17 = *(void (**)(void))(v6 + 56);
          v17();
        }
      }
      return;
  }
}

const char *type metadata completion function for LazyDropWhileSequence.Iterator(uint64_t a1)
{
  v4[0] = &unk_1816333A8;
  uint64_t result = swift_getAssociatedTypeWitness(319, *(int ***)(a1 + 24), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  if (v3 <= 0x3F)
  {
    v4[1] = *((void *)result - 1) + 64;
    void v4[2] = &unk_1ECA05CB0;
    swift_initStructMetadata(a1, 0, 3uLL, (uint64_t)v4, a1 + 32);
    return 0;
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for LazyDropWhileSequence.Iterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v7 = *(_DWORD *)(v6 + 80);
  uint64_t v8 = *(void *)(v6 + 64) + 7;
  if (v7 > 7
    || (*(_DWORD *)(v6 + 80) & 0x100000) != 0
    || ((v8 + ((v7 + 1) & ~v7)) & 0xFFFFFFFFFFFFFFF8) + 16 > 0x18)
  {
    unint64_t v17 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v17 + ((v7 & 0xF8 ^ 0x1F8) & (v7 + 16)));
  }
  else
  {
    uint64_t v11 = ~v7;
    *(unsigned char *)a1 = *(unsigned char *)a2;
    int v12 = (char *)a1 + v7;
    unsigned int v13 = (char *)a2 + v7;
    uint64_t v14 = (unint64_t)(v12 + 1) & v11;
    uint64_t v15 = (unint64_t)(v13 + 1) & v11;
    (*(void (**)(uint64_t, uint64_t, const char *))(v6 + 16))(v14, v15, AssociatedTypeWitness);
    int v16 = (void *)((v8 + v15) & 0xFFFFFFFFFFFFFFF8);
    unint64_t v17 = (atomic_ullong *)v16[1];
    unsigned int v18 = (void *)((v8 + v14) & 0xFFFFFFFFFFFFFFF8);
    *unsigned int v18 = *v16;
    v18[1] = v17;
  }
  swift_retain(v17);
  return a1;
}

uint64_t destroy for LazyDropWhileSequence.Iterator(uint64_t a1, uint64_t a2)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v4 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v5 = v4 + 8;
  unint64_t v6 = (a1 + *(unsigned __int8 *)(v4 + 80) + 1) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80);
  (*(void (**)(unint64_t, const char *))(v4 + 8))(v6, AssociatedTypeWitness);
  uint64_t v7 = *(void *)(((*(void *)(v5 + 56) + v6 + 7) & 0xFFFFFFFFFFFFFFF8) + 8);

  return swift_release(v7);
}

unsigned char *initializeWithCopy for LazyDropWhileSequence.Iterator(unsigned char *a1, unsigned char *a2, uint64_t a3)
{
  *a1 = *a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v7 = v6 + 16;
  uint64_t v8 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v9 = (unint64_t)&a1[v8 + 1] & ~v8;
  uint64_t v10 = (unint64_t)&a2[v8 + 1] & ~v8;
  (*(void (**)(uint64_t, uint64_t, const char *))(v6 + 16))(v9, v10, AssociatedTypeWitness);
  uint64_t v11 = *(void *)(v7 + 48) + 7;
  int v12 = (void *)((v11 + v9) & 0xFFFFFFFFFFFFFFF8);
  unsigned int v13 = (void *)((v11 + v10) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v14 = (atomic_ullong *)v13[1];
  void *v12 = *v13;
  v12[1] = v14;
  swift_retain(v14);
  return a1;
}

unsigned char *assignWithCopy for LazyDropWhileSequence.Iterator(unsigned char *a1, unsigned char *a2, uint64_t a3)
{
  *a1 = *a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v7 = v6 + 24;
  uint64_t v8 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v9 = (unint64_t)&a1[v8 + 1] & ~v8;
  uint64_t v10 = (unint64_t)&a2[v8 + 1] & ~v8;
  (*(void (**)(uint64_t, uint64_t, const char *))(v6 + 24))(v9, v10, AssociatedTypeWitness);
  uint64_t v11 = *(void *)(v7 + 40) + 7;
  int v12 = (void *)((v11 + v9) & 0xFFFFFFFFFFFFFFF8);
  unsigned int v13 = (void *)((v11 + v10) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v14 = (atomic_ullong *)v13[1];
  uint64_t v15 = v12[1];
  void *v12 = *v13;
  v12[1] = v14;
  swift_retain(v14);
  swift_release(v15);
  return a1;
}

unsigned char *initializeWithTake for LazyDropWhileSequence.Iterator(unsigned char *a1, unsigned char *a2, uint64_t a3)
{
  *a1 = *a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v7 = v6 + 32;
  uint64_t v8 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v9 = (unint64_t)&a1[v8 + 1] & ~v8;
  uint64_t v10 = (unint64_t)&a2[v8 + 1] & ~v8;
  (*(void (**)(uint64_t, uint64_t, const char *))(v6 + 32))(v9, v10, AssociatedTypeWitness);
  *(_OWORD *)((*(void *)(v7 + 32) + 7 + v9) & 0xFFFFFFFFFFFFFFF8) = *(_OWORD *)((*(void *)(v7 + 32) + 7 + v10) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

unsigned char *assignWithTake for LazyDropWhileSequence.Iterator(unsigned char *a1, unsigned char *a2, uint64_t a3)
{
  *a1 = *a2;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v7 = v6 + 40;
  uint64_t v8 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v9 = (unint64_t)&a1[v8 + 1] & ~v8;
  uint64_t v10 = (unint64_t)&a2[v8 + 1] & ~v8;
  (*(void (**)(uint64_t, uint64_t, const char *))(v6 + 40))(v9, v10, AssociatedTypeWitness);
  uint64_t v11 = *(void *)(v7 + 24) + 7;
  unint64_t v12 = (v11 + v9) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v13 = *(void *)(v12 + 8);
  *(_OWORD *)unint64_t v12 = *(_OWORD *)((v11 + v10) & 0xFFFFFFFFFFFFFFF8);
  swift_release(v13);
  return a1;
}

uint64_t getEnumTagSinglePayload for LazyDropWhileSequence.Iterator(int *a1, unsigned int a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v7 = v6;
  unsigned int v8 = *(_DWORD *)(v6 + 84);
  if (v8 <= 0x7FFFFFFF) {
    unsigned int v9 = 0x7FFFFFFF;
  }
  else {
    unsigned int v9 = *(_DWORD *)(v6 + 84);
  }
  uint64_t v10 = *(unsigned __int8 *)(v6 + 80);
  if (!a2) {
    return 0;
  }
  uint64_t v11 = *(void *)(*((void *)AssociatedTypeWitness - 1) + 64) + 7;
  if (v9 < a2)
  {
    unint64_t v12 = ((v11 + ((v10 + 1) & ~v10)) & 0xFFFFFFFFFFFFFFF8) + 16;
    uint64_t v13 = v12 & 0xFFFFFFF8;
    if ((v12 & 0xFFFFFFF8) != 0) {
      unsigned int v14 = 2;
    }
    else {
      unsigned int v14 = a2 - v9 + 1;
    }
    if (v14 >= 0x10000) {
      unsigned int v15 = 4;
    }
    else {
      unsigned int v15 = 2;
    }
    if (v14 < 0x100) {
      unsigned int v15 = 1;
    }
    if (v14 >= 2) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = 0;
    }
    switch(v16)
    {
      case 1:
        int v17 = *((unsigned __int8 *)a1 + v12);
        if (!v17) {
          break;
        }
        goto LABEL_22;
      case 2:
        int v17 = *(unsigned __int16 *)((char *)a1 + v12);
        if (v17) {
          goto LABEL_22;
        }
        break;
      case 3:
        __break(1u);
        JUMPOUT(0x181514CE0);
      case 4:
        int v17 = *(int *)((char *)a1 + v12);
        if (!v17) {
          break;
        }
LABEL_22:
        int v19 = v17 - 1;
        if (v13)
        {
          int v19 = 0;
          int v20 = *a1;
        }
        else
        {
          int v20 = 0;
        }
        return v9 + (v20 | v19) + 1;
      default:
        break;
    }
  }
  uint64_t v21 = ((unint64_t)a1 + v10 + 1) & ~v10;
  if (v8 < 0x7FFFFFFF)
  {
    unint64_t v23 = *(void *)((v11 + v21) & 0xFFFFFFFFFFFFFFF8);
    if (v23 >= 0xFFFFFFFF) {
      LODWORD(v23) = -1;
    }
    return (v23 + 1);
  }
  else
  {
    uint64_t v22 = *(uint64_t (**)(uint64_t))(v7 + 48);
    return v22(v21);
  }
}

void storeEnumTagSinglePayload for LazyDropWhileSequence.Iterator(_DWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 24), *(void *)(a4 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator)- 1);
  unsigned int v8 = *(_DWORD *)(v7 + 84);
  uint64_t v9 = *(unsigned __int8 *)(v7 + 80);
  if (v8 <= 0x7FFFFFFF) {
    unsigned int v10 = 0x7FFFFFFF;
  }
  else {
    unsigned int v10 = *(_DWORD *)(v7 + 84);
  }
  uint64_t v11 = *(void *)(v7 + 64) + 7;
  size_t v12 = ((v11 + ((v9 + 1) & ~v9)) & 0xFFFFFFFFFFFFFFF8) + 16;
  if (v10 >= a3)
  {
    int v15 = 0;
    int v16 = a2 - v10;
    if (a2 <= v10)
    {
LABEL_17:
      switch(v15)
      {
        case 1:
          *((unsigned char *)a1 + v12) = 0;
          if (!a2) {
            return;
          }
          goto LABEL_30;
        case 2:
          *(_WORD *)((char *)a1 + v12) = 0;
          if (!a2) {
            return;
          }
          goto LABEL_30;
        case 3:
          goto LABEL_43;
        case 4:
          *(_DWORD *)((char *)a1 + v12) = 0;
          goto LABEL_29;
        default:
LABEL_29:
          if (a2)
          {
LABEL_30:
            uint64_t v19 = ((unint64_t)a1 + v9 + 1) & ~v9;
            if (v8 < 0x7FFFFFFF)
            {
              uint64_t v21 = (void *)((v11 + v19) & 0xFFFFFFFFFFFFFFF8);
              if ((a2 & 0x80000000) != 0)
              {
                uint64_t v22 = a2 ^ 0x80000000;
                v21[1] = 0;
              }
              else
              {
                uint64_t v22 = (a2 - 1);
              }
              *uint64_t v21 = v22;
            }
            else
            {
              int v20 = *(void (**)(uint64_t, uint64_t))(v7 + 56);
              v20(v19, a2);
            }
          }
          break;
      }
      return;
    }
  }
  else
  {
    if (((v11 + ((v9 + 1) & ~v9)) & 0xFFFFFFF8) == 0xFFFFFFF0) {
      unsigned int v13 = a3 - v10 + 1;
    }
    else {
      unsigned int v13 = 2;
    }
    if (v13 >= 0x10000) {
      int v14 = 4;
    }
    else {
      int v14 = 2;
    }
    if (v13 < 0x100) {
      int v14 = 1;
    }
    if (v13 >= 2) {
      int v15 = v14;
    }
    else {
      int v15 = 0;
    }
    int v16 = a2 - v10;
    if (a2 <= v10) {
      goto LABEL_17;
    }
  }
  if (((v11 + ((v9 + 1) & ~v9)) & 0xFFFFFFF8) == 0xFFFFFFF0) {
    int v17 = v16;
  }
  else {
    int v17 = 1;
  }
  if (((v11 + ((v9 + 1) & ~v9)) & 0xFFFFFFF8) != 0xFFFFFFF0)
  {
    int v18 = ~v10 + a2;
    bzero(a1, v12);
    *a1 = v18;
  }
  switch(v15)
  {
    case 1:
      *((unsigned char *)a1 + v12) = v17;
      break;
    case 2:
      *(_WORD *)((char *)a1 + v12) = v17;
      break;
    case 3:
LABEL_43:
      __break(1u);
      JUMPOUT(0x181514F18);
    case 4:
      *(_DWORD *)((char *)a1 + v12) = v17;
      break;
    default:
      return;
  }
}

const char *type metadata completion function for LazyPrefixWhileSequence<>._IndexRepresentation(uint64_t a1)
{
  uint64_t result = swift_getAssociatedTypeWitness(319, *(int ***)(a1 + 24), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  if (v3 <= 0x3F)
  {
    swift_initEnumMetadataSinglePayload(a1, 0, *((void *)result - 1) + 64, 1u);
    return 0;
  }
  return result;
}

uint64_t getEnumTag for LazyPrefixWhileSequence<>._IndexRepresentation(uint64_t a1, uint64_t a2)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 48);

  return v4(a1, 1, AssociatedTypeWitness);
}

uint64_t destructiveInjectEnumTag for LazyPrefixWhileSequence<>._IndexRepresentation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 56);

  return v6(a1, a2, 1, AssociatedTypeWitness);
}

Class *type metadata completion function for LazyPrefixWhileSequence<>.Index(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = type metadata accessor for LazyPrefixWhileSequence<>._IndexRepresentation(319, *(void *)(a1 + 16), *(void *)(a1 + 24), a4);
  if (v6 <= 0x3F)
  {
    uint64_t v7 = (uint64_t)*(result - 1) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, (uint64_t)&v7, a1 + 32);
    return 0;
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for LazyPrefixWhileSequence<>._IndexRepresentation(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  if (*(_DWORD *)(v6 + 84)) {
    size_t v7 = *(void *)(v6 + 64);
  }
  else {
    size_t v7 = *(void *)(v6 + 64) + 1;
  }
  uint64_t v8 = *(_DWORD *)(v6 + 80);
  if (v8 > 7 || (*(_DWORD *)(v6 + 80) & 0x100000) != 0 || v7 > 0x18)
  {
    uint64_t v11 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v11 + ((v8 + 16) & ~v8));
    swift_retain(v11);
  }
  else
  {
    size_t v12 = AssociatedTypeWitness;
    if ((*(unsigned int (**)(atomic_ullong **, uint64_t, const char *))(v6 + 48))(a2, 1, AssociatedTypeWitness))
    {
      memcpy(a1, a2, v7);
    }
    else
    {
      (*(void (**)(atomic_ullong **, atomic_ullong **, const char *))(v6 + 16))(a1, a2, v12);
      (*(void (**)(atomic_ullong **, void, uint64_t, const char *))(v6 + 56))(a1, 0, 1, v12);
    }
  }
  return a1;
}

uint64_t destroy for LazyPrefixWhileSequence<>._IndexRepresentation(uint64_t a1, uint64_t a2)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, const char *))(v6 + 48))(a1, 1, AssociatedTypeWitness);
  if (!result)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t, const char *))(v6 + 8);
    return v5(a1, AssociatedTypeWitness);
  }
  return result;
}

void *initializeWithCopy for LazyPrefixWhileSequence<>._IndexRepresentation(void *a1, const void *a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  if ((*(unsigned int (**)(const void *, uint64_t, const char *))(v6 + 48))(a2, 1, AssociatedTypeWitness))
  {
    if (*(_DWORD *)(v6 + 84)) {
      size_t v7 = *(void *)(v6 + 64);
    }
    else {
      size_t v7 = *(void *)(v6 + 64) + 1;
    }
    memcpy(a1, a2, v7);
  }
  else
  {
    (*(void (**)(void *, const void *, const char *))(v6 + 16))(a1, a2, AssociatedTypeWitness);
    (*(void (**)(void *, void, uint64_t, const char *))(v6 + 56))(a1, 0, 1, AssociatedTypeWitness);
  }
  return a1;
}

void *assignWithCopy for LazyPrefixWhileSequence<>._IndexRepresentation(void *a1, void *a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  size_t v7 = *(uint64_t (**)(void *, uint64_t, const char *))(v6 + 48);
  int v8 = v7(a1, 1, AssociatedTypeWitness);
  int v9 = v7(a2, 1, AssociatedTypeWitness);
  if (v8)
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, const char *))(v6 + 16))(a1, a2, AssociatedTypeWitness);
      (*(void (**)(void *, void, uint64_t, const char *))(v6 + 56))(a1, 0, 1, AssociatedTypeWitness);
      return a1;
    }
    int v10 = *(_DWORD *)(v6 + 84);
    size_t v11 = *(void *)(v6 + 64);
  }
  else
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, const char *))(v6 + 24))(a1, a2, AssociatedTypeWitness);
      return a1;
    }
    unsigned int v13 = *(void (**)(void *, const char *))(v6 + 8);
    uint64_t v12 = v6 + 8;
    v13(a1, AssociatedTypeWitness);
    int v10 = *(_DWORD *)(v12 + 76);
    size_t v11 = *(void *)(v12 + 56);
  }
  if (v10) {
    size_t v14 = v11;
  }
  else {
    size_t v14 = v11 + 1;
  }
  memcpy(a1, a2, v14);
  return a1;
}

void *initializeWithTake for LazyPrefixWhileSequence<>._IndexRepresentation(void *a1, const void *a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  if ((*(unsigned int (**)(const void *, uint64_t, const char *))(v6 + 48))(a2, 1, AssociatedTypeWitness))
  {
    if (*(_DWORD *)(v6 + 84)) {
      size_t v7 = *(void *)(v6 + 64);
    }
    else {
      size_t v7 = *(void *)(v6 + 64) + 1;
    }
    memcpy(a1, a2, v7);
  }
  else
  {
    (*(void (**)(void *, const void *, const char *))(v6 + 32))(a1, a2, AssociatedTypeWitness);
    (*(void (**)(void *, void, uint64_t, const char *))(v6 + 56))(a1, 0, 1, AssociatedTypeWitness);
  }
  return a1;
}

void *assignWithTake for LazyPrefixWhileSequence<>._IndexRepresentation(void *a1, void *a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  size_t v7 = *(uint64_t (**)(void *, uint64_t, const char *))(v6 + 48);
  int v8 = v7(a1, 1, AssociatedTypeWitness);
  int v9 = v7(a2, 1, AssociatedTypeWitness);
  if (v8)
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, const char *))(v6 + 32))(a1, a2, AssociatedTypeWitness);
      (*(void (**)(void *, void, uint64_t, const char *))(v6 + 56))(a1, 0, 1, AssociatedTypeWitness);
      return a1;
    }
    int v10 = *(_DWORD *)(v6 + 84);
    size_t v11 = *(void *)(v6 + 64);
  }
  else
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, const char *))(v6 + 40))(a1, a2, AssociatedTypeWitness);
      return a1;
    }
    unsigned int v13 = *(void (**)(void *, const char *))(v6 + 8);
    uint64_t v12 = v6 + 8;
    v13(a1, AssociatedTypeWitness);
    int v10 = *(_DWORD *)(v12 + 76);
    size_t v11 = *(void *)(v12 + 56);
  }
  if (v10) {
    size_t v14 = v11;
  }
  else {
    size_t v14 = v11 + 1;
  }
  memcpy(a1, a2, v14);
  return a1;
}

uint64_t getEnumTagSinglePayload for LazyPrefixWhileSequence<>._IndexRepresentation(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  unsigned int v8 = v7 - 1;
  if (!v7) {
    unsigned int v8 = 0;
  }
  uint64_t v9 = *(void *)(*((void *)AssociatedTypeWitness - 1) + 64);
  if (!v7) {
    ++v9;
  }
  if (!a2) {
    return 0;
  }
  if (a2 > v8)
  {
    char v10 = 8 * v9;
    if (v9 > 3) {
      goto LABEL_8;
    }
    unsigned int v12 = ((a2 - v8 + ~(-1 << v10)) >> v10) + 1;
    if (HIWORD(v12))
    {
      int v11 = *(_DWORD *)((char *)a1 + v9);
      if (v11) {
        goto LABEL_15;
      }
    }
    else
    {
      if (v12 <= 0xFF)
      {
        if (v12 < 2) {
          goto LABEL_23;
        }
LABEL_8:
        int v11 = *((unsigned __int8 *)a1 + v9);
        if (!*((unsigned char *)a1 + v9)) {
          goto LABEL_23;
        }
LABEL_15:
        int v13 = (v11 - 1) << v10;
        if (v9 > 3) {
          int v13 = 0;
        }
        if (v9)
        {
          if (v9 > 3) {
            LODWORD(v9) = 4;
          }
          switch((int)v9)
          {
            case 2:
              LODWORD(v9) = *a1;
              break;
            case 3:
              LODWORD(v9) = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
              break;
            case 4:
              LODWORD(v9) = *(_DWORD *)a1;
              break;
            default:
              LODWORD(v9) = *(unsigned __int8 *)a1;
              break;
          }
        }
        return v8 + (v9 | v13) + 1;
      }
      int v11 = *(unsigned __int16 *)((char *)a1 + v9);
      if (*(unsigned __int16 *)((char *)a1 + v9)) {
        goto LABEL_15;
      }
    }
  }
LABEL_23:
  if (v7 < 2) {
    return 0;
  }
  unsigned int v15 = (*(uint64_t (**)(unsigned __int16 *))(v6 + 48))(a1);
  if (v15 >= 2) {
    return v15 - 1;
  }
  else {
    return 0;
  }
}

void storeEnumTagSinglePayload for LazyPrefixWhileSequence<>._IndexRepresentation(unsigned char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  int v7 = 0;
  uint64_t v8 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 24), *(void *)(a4 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index)- 1);
  unsigned int v9 = *(_DWORD *)(v8 + 84);
  unsigned int v10 = v9 - 1;
  if (v9)
  {
    size_t v11 = *(void *)(v8 + 64);
  }
  else
  {
    unsigned int v10 = 0;
    size_t v11 = *(void *)(v8 + 64) + 1;
  }
  if (a3 <= v10) {
    goto LABEL_12;
  }
  if (v11 <= 3)
  {
    unsigned int v12 = ((a3 - v10 + ~(-1 << (8 * v11))) >> (8 * v11)) + 1;
    if (HIWORD(v12))
    {
      int v7 = 4;
      if (v10 >= a2) {
        goto LABEL_20;
      }
      goto LABEL_13;
    }
    if (v12 >= 0x100) {
      int v7 = 2;
    }
    else {
      int v7 = v12 > 1;
    }
LABEL_12:
    if (v10 >= a2) {
      goto LABEL_20;
    }
    goto LABEL_13;
  }
  int v7 = 1;
  if (v10 >= a2)
  {
LABEL_20:
    switch(v7)
    {
      case 1:
        a1[v11] = 0;
        if (!a2) {
          return;
        }
        goto LABEL_25;
      case 2:
        *(_WORD *)&a1[v11] = 0;
        if (!a2) {
          return;
        }
        goto LABEL_25;
      case 3:
        goto LABEL_38;
      case 4:
        *(_DWORD *)&a1[v11] = 0;
        goto LABEL_24;
      default:
LABEL_24:
        if (a2)
        {
LABEL_25:
          if (v9 >= 2)
          {
            int v16 = *(void (**)(unsigned char *, void))(v8 + 56);
            v16(a1, a2 + 1);
          }
        }
        break;
    }
    return;
  }
LABEL_13:
  unsigned int v13 = ~v10 + a2;
  if (v11 < 4)
  {
    int v14 = (v13 >> (8 * v11)) + 1;
    if (v11)
    {
      int v15 = v13 & ~(-1 << (8 * v11));
      bzero(a1, v11);
      if (v11 == 3)
      {
        *(_WORD *)a1 = v15;
        a1[2] = BYTE2(v15);
      }
      else if (v11 == 2)
      {
        *(_WORD *)a1 = v15;
      }
      else
      {
        *a1 = v15;
      }
    }
  }
  else
  {
    bzero(a1, v11);
    *(_DWORD *)a1 = v13;
    int v14 = 1;
  }
  switch(v7)
  {
    case 1:
      a1[v11] = v14;
      break;
    case 2:
      *(_WORD *)&a1[v11] = v14;
      break;
    case 3:
LABEL_38:
      __break(1u);
      JUMPOUT(0x181515CB4);
    case 4:
      *(_DWORD *)&a1[v11] = v14;
      break;
    default:
      return;
  }
}

uint64_t dispatch thunk of RandomNumberGenerator.next()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

ValueMetadata *type metadata accessor for SystemRandomNumberGenerator()
{
  return &type metadata for SystemRandomNumberGenerator;
}

uint64_t default associated conformance accessor for RandomAccessCollection.Collection.Indices: RandomAccessCollection(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return swift_getWitnessTable(protocol conformance descriptor for <> DefaultIndices<A>, a1, (uint64_t)&v4);
}

uint64_t default associated conformance accessor for RandomAccessCollection.Collection.SubSequence: RandomAccessCollection(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&v4);
}

uint64_t dispatch thunk of RandomAccessCollection.index(_:offsetBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t dispatch thunk of RandomAccessCollection.index(_:offsetBy:limitedBy:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 40))();
}

uint64_t dispatch thunk of RandomAccessCollection.distance(from:to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 48))();
}

uint64_t dispatch thunk of RangeExpression.relative<A>(to:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 24))();
}

uint64_t dispatch thunk of RangeExpression.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t *type metadata completion function for ClosedRange(uint64_t a1)
{
  uint64_t result = swift_checkMetadataState(319, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4[0] = *(result - 1) + 64;
    v4[1] = v4[0];
    swift_initStructMetadata(a1, 0, 2uLL, (uint64_t)v4, a1 + 32);
    return 0;
  }
  return result;
}

Class *type metadata accessor for PartialRangeUpTo(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for PartialRangeUpTo.Flags);
}

Class *type metadata accessor for PartialRangeThrough(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for PartialRangeThrough.Flags);
}

uint64_t *type metadata completion function for FlattenSequence(uint64_t a1)
{
  uint64_t result = swift_checkMetadataState(319, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, (uint64_t)&v4, a1 + 40);
    return 0;
  }
  return result;
}

Class *type metadata accessor for PartialRangeFrom<>.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for PartialRangeFrom<>.Iterator.Flags);
}

ValueMetadata *type metadata accessor for UnboundedRange_()
{
  return &type metadata for UnboundedRange_;
}

uint64_t default associated conformance accessor for RangeReplaceableCollection.Collection.SubSequence: RangeReplaceableCollection(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&v4);
}

uint64_t dispatch thunk of RangeReplaceableCollection.init()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.replaceSubrange<A>(_:with:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 32))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.reserveCapacity(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.init(repeating:count:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 48))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 56))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.append(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.append<A>(contentsOf:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 72))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.insert(_:at:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 80))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.insert<A>(contentsOf:at:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 88))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.remove(at:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 96))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.removeSubrange(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 104))();
}

uint64_t dispatch thunk of RangeReplaceableCollection._customRemoveLast()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 112))();
}

uint64_t dispatch thunk of RangeReplaceableCollection._customRemoveLast(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.removeFirst()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.removeFirst(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 136))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.removeAll(keepingCapacity:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 144))();
}

uint64_t dispatch thunk of RangeReplaceableCollection.removeAll(where:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 152))();
}

ValueMetadata *type metadata accessor for _EachFieldOptions()
{
  return &type metadata for _EachFieldOptions;
}

uint64_t getEnumTagSinglePayload for _MetadataKind(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xF1) {
    goto LABEL_17;
  }
  if (a2 + 15 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 15) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 15;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 15;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 15;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 0x10;
  int v8 = v6 - 16;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for _MetadataKind(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 15 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 15) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xF1) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xF0)
  {
    unsigned int v6 = ((a2 - 241) >> 8) + 1;
    *uint64_t result = a2 + 15;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x181516270);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *uint64_t result = a2 + 15;
        break;
    }
  }
  return result;
}

unsigned char *destructiveInjectEnumTag for _MetadataKind(unsigned char *result, char a2)
{
  *uint64_t result = a2;
  return result;
}

ValueMetadata *type metadata accessor for _MetadataKind()
{
  return &type metadata for _MetadataKind;
}

uint64_t *type metadata completion function for Repeated(uint64_t a1)
{
  v4[0] = &value witness table for Builtin.Int64.size;
  uint64_t result = swift_checkMetadataState(319, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4[1] = *(result - 1) + 64;
    swift_initStructMetadata(a1, 0, 2uLL, (uint64_t)v4, a1 + 24);
    return 0;
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for Repeated(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  unint64_t v3 = a1;
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  uint64_t v5 = *(_DWORD *)(v4 + 80);
  if (v5 > 7
    || (*(_DWORD *)(v4 + 80) & 0x100000) != 0
    || ((v5 + 8) & (unint64_t)~v5) + *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64) > 0x18)
  {
    int v8 = *a2;
    *unint64_t v3 = *a2;
    unint64_t v3 = (atomic_ullong **)((char *)v8 + ((v5 & 0xF8 ^ 0x1F8) & (v5 + 16)));
    swift_retain(v8);
  }
  else
  {
    *a1 = *a2;
    (*(void (**)(unint64_t, unint64_t))(v4 + 16))(((unint64_t)a1 + v5 + 8) & ~v5, ((unint64_t)a2 + v5 + 8) & ~v5);
  }
  return v3;
}

uint64_t destroy for Repeated(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(unint64_t))(*(void *)(*(void *)(a2 + 16) - 8) + 8))((a1 + *(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8) + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8) + 80));
}

void *initializeWithCopy for Repeated(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  (*(void (**)(unint64_t, unint64_t))(v4 + 16))(((unint64_t)a1 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80), ((unint64_t)a2 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80));
  return a1;
}

void *assignWithCopy for Repeated(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  (*(void (**)(unint64_t, unint64_t))(v4 + 24))(((unint64_t)a1 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80), ((unint64_t)a2 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80));
  return a1;
}

void *initializeWithTake for Repeated(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  (*(void (**)(unint64_t, unint64_t))(v4 + 32))(((unint64_t)a1 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80), ((unint64_t)a2 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80));
  return a1;
}

void *assignWithTake for Repeated(void *a1, void *a2, uint64_t a3)
{
  *a1 = *a2;
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  (*(void (**)(unint64_t, unint64_t))(v4 + 40))(((unint64_t)a1 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80), ((unint64_t)a2 + *(unsigned __int8 *)(v4 + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80));
  return a1;
}

uint64_t getEnumTagSinglePayload for Repeated(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  uint64_t v6 = *(unsigned __int8 *)(v4 + 80);
  if (!a2) {
    return 0;
  }
  unsigned int v7 = a2 - v5;
  if (a2 <= v5) {
    goto LABEL_19;
  }
  uint64_t v8 = ((v6 + 8) & ~v6) + *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
  char v9 = 8 * v8;
  if (v8 <= 3)
  {
    unsigned int v11 = ((v7 + ~(-1 << v9)) >> v9) + 1;
    if (HIWORD(v11))
    {
      int v10 = *(_DWORD *)((char *)a1 + v8);
      if (!v10) {
        goto LABEL_19;
      }
      goto LABEL_11;
    }
    if (v11 > 0xFF)
    {
      int v10 = *(unsigned __int16 *)((char *)a1 + v8);
      if (!*(unsigned __int16 *)((char *)a1 + v8)) {
        goto LABEL_19;
      }
      goto LABEL_11;
    }
    if (v11 < 2)
    {
LABEL_19:
      if (v5) {
        return (*(uint64_t (**)(unint64_t))(v4 + 48))(((unint64_t)a1 + v6 + 8) & ~v6);
      }
      return 0;
    }
  }
  int v10 = *((unsigned __int8 *)a1 + v8);
  if (!*((unsigned char *)a1 + v8)) {
    goto LABEL_19;
  }
LABEL_11:
  int v12 = (v10 - 1) << v9;
  if (v8 > 3) {
    int v12 = 0;
  }
  if (v8)
  {
    if (v8 > 3) {
      LODWORD(v8) = 4;
    }
    switch((int)v8)
    {
      case 2:
        LODWORD(v8) = *a1;
        break;
      case 3:
        LODWORD(v8) = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        LODWORD(v8) = *(_DWORD *)a1;
        break;
      default:
        LODWORD(v8) = *(unsigned __int8 *)a1;
        break;
    }
  }
  return v5 + (v8 | v12) + 1;
}

void storeEnumTagSinglePayload for Repeated(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 16) - 8);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  uint64_t v8 = *(unsigned __int8 *)(v6 + 80);
  size_t v9 = ((v8 + 8) & ~v8) + *(void *)(v6 + 64);
  BOOL v10 = a3 >= v7;
  unsigned int v11 = a3 - v7;
  if (v11 != 0 && v10)
  {
    if (v9 <= 3)
    {
      unsigned int v15 = ((v11 + ~(-1 << (8 * v9))) >> (8 * v9)) + 1;
      if (HIWORD(v15))
      {
        int v12 = 4;
      }
      else if (v15 >= 0x100)
      {
        int v12 = 2;
      }
      else
      {
        int v12 = v15 > 1;
      }
    }
    else
    {
      int v12 = 1;
    }
  }
  else
  {
    int v12 = 0;
  }
  if (v7 < a2)
  {
    unsigned int v13 = ~v7 + a2;
    if (v9 < 4)
    {
      int v14 = (v13 >> (8 * v9)) + 1;
      if (v9)
      {
        int v16 = v13 & ~(-1 << (8 * v9));
        bzero(a1, v9);
        if (v9 == 3)
        {
          *(_WORD *)a1 = v16;
          a1[2] = BYTE2(v16);
        }
        else if (v9 == 2)
        {
          *(_WORD *)a1 = v16;
        }
        else
        {
          *a1 = v16;
        }
      }
    }
    else
    {
      bzero(a1, v9);
      *(_DWORD *)a1 = v13;
      int v14 = 1;
    }
    switch(v12)
    {
      case 1:
        a1[v9] = v14;
        return;
      case 2:
        *(_WORD *)&a1[v9] = v14;
        return;
      case 3:
        goto LABEL_34;
      case 4:
        *(_DWORD *)&a1[v9] = v14;
        return;
      default:
        return;
    }
  }
  switch(v12)
  {
    case 1:
      a1[v9] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_21;
    case 2:
      *(_WORD *)&a1[v9] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_21;
    case 3:
LABEL_34:
      __break(1u);
      JUMPOUT(0x1815169E8);
    case 4:
      *(_DWORD *)&a1[v9] = 0;
      goto LABEL_20;
    default:
LABEL_20:
      if (a2)
      {
LABEL_21:
        unint64_t v17 = (unint64_t)&a1[v8 + 8] & ~v8;
        int v18 = *(void (**)(unint64_t))(v6 + 56);
        v18(v17);
      }
      return;
  }
}

void *type metadata completion function for ReversedCollection.Iterator(uint64_t a1)
{
  int v2 = swift_checkMetadataState(319, *(void *)(a1 + 16));
  unint64_t v3 = v2;
  if (v4 <= 0x3F)
  {
    v8[0] = *(v2 - 1) + 64;
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(319, *(int ***)(*(void *)(a1 + 24) + 8), (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
    unint64_t v3 = (void *)AssociatedTypeWitness;
    if (v6 <= 0x3F)
    {
      v8[1] = *((void *)AssociatedTypeWitness - 1) + 64;
      swift_initStructMetadata(a1, 0, 2uLL, (uint64_t)v8, a1 + 32);
      return 0;
    }
  }
  return v3;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for ReversedCollection.Iterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void *)(v6 + 64);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a3 + 24) + 8), v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = *(_DWORD *)(v9 + 80);
  uint64_t v11 = v7 + v10;
  uint64_t v12 = (*(unsigned char *)(v6 + 80) | *(unsigned char *)(v9 + 80));
  if (v12 > 7
    || ((*(_DWORD *)(v6 + 80) | *(_DWORD *)(v9 + 80)) & 0x100000) != 0
    || (v11 & (unint64_t)~v10) + *(void *)(*((void *)AssociatedTypeWitness - 1) + 64) > 0x18)
  {
    unsigned int v15 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v15 + ((v12 + 16) & ~v12));
    swift_retain(v15);
  }
  else
  {
    int v16 = AssociatedTypeWitness;
    uint64_t v17 = ~v10;
    (*(void (**)(atomic_ullong **, atomic_ullong **, uint64_t))(v6 + 16))(a1, a2, v5);
    (*(void (**)(unint64_t, unint64_t, const char *))(v9 + 16))(((unint64_t)a1 + v11) & v17, ((unint64_t)a2 + v11) & v17, v16);
  }
  return a1;
}

uint64_t destroy for ReversedCollection.Iterator(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8) + 8;
  (*(void (**)(uint64_t, uint64_t))v5)(a1, v4);
  uint64_t v6 = *(void *)(v5 + 56) + a1;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a2 + 24) + 8), v4, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = *(uint64_t (**)(unint64_t, const char *))(v8 + 8);
  uint64_t v10 = AssociatedTypeWitness;
  unint64_t v11 = (v6 + *(unsigned __int8 *)(v8 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80);

  return v9(v11, v10);
}

uint64_t initializeWithCopy for ReversedCollection.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8) + 16;
  (*(void (**)(uint64_t, uint64_t, uint64_t))v7)(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 48);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a3 + 24) + 8), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v10 + 16))((v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for ReversedCollection.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8) + 24;
  (*(void (**)(uint64_t, uint64_t, uint64_t))v7)(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 40);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a3 + 24) + 8), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v10 + 24))((v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for ReversedCollection.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8) + 32;
  (*(void (**)(uint64_t, uint64_t, uint64_t))v7)(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 32);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a3 + 24) + 8), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v10 + 32))((v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for ReversedCollection.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8) + 40;
  (*(void (**)(uint64_t, uint64_t, uint64_t))v7)(a1, a2, v6);
  uint64_t v8 = *(void *)(v7 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a3 + 24) + 8), v6, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v10 + 40))((v8 + *(unsigned __int8 *)(v10 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), (v8 + *(unsigned __int8 *)(v10 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for ReversedCollection.Iterator(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(unsigned int *)(v6 + 84);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a3 + 24) + 8), v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  unsigned int v10 = *(_DWORD *)(v9 + 84);
  if (v10 <= v7) {
    unsigned int v11 = v7;
  }
  else {
    unsigned int v11 = *(_DWORD *)(v9 + 84);
  }
  uint64_t v12 = *(unsigned __int8 *)(v9 + 80);
  if (!a2) {
    return 0;
  }
  uint64_t v13 = *(void *)(v6 + 64) + v12;
  if (a2 <= v11) {
    goto LABEL_24;
  }
  uint64_t v14 = (v13 & ~v12) + *(void *)(*((void *)AssociatedTypeWitness - 1) + 64);
  char v15 = 8 * v14;
  if (v14 <= 3)
  {
    unsigned int v17 = ((a2 - v11 + ~(-1 << v15)) >> v15) + 1;
    if (HIWORD(v17))
    {
      int v16 = *(_DWORD *)((char *)a1 + v14);
      if (!v16) {
        goto LABEL_24;
      }
      goto LABEL_14;
    }
    if (v17 > 0xFF)
    {
      int v16 = *(unsigned __int16 *)((char *)a1 + v14);
      if (!*(unsigned __int16 *)((char *)a1 + v14)) {
        goto LABEL_24;
      }
      goto LABEL_14;
    }
    if (v17 < 2)
    {
LABEL_24:
      if (v11)
      {
        if (v7 >= v10)
        {
          unint64_t v23 = *(uint64_t (**)(unsigned __int16 *, uint64_t, uint64_t))(v6 + 48);
          return v23(a1, v7, v5);
        }
        else
        {
          uint64_t v21 = *(uint64_t (**)(unint64_t))(v9 + 48);
          return v21(((unint64_t)a1 + v13) & ~v12);
        }
      }
      return 0;
    }
  }
  int v16 = *((unsigned __int8 *)a1 + v14);
  if (!*((unsigned char *)a1 + v14)) {
    goto LABEL_24;
  }
LABEL_14:
  int v18 = (v16 - 1) << v15;
  if (v14 > 3) {
    int v18 = 0;
  }
  if (v14)
  {
    if (v14 <= 3) {
      int v19 = v14;
    }
    else {
      int v19 = 4;
    }
    switch(v19)
    {
      case 2:
        int v20 = *a1;
        break;
      case 3:
        int v20 = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        int v20 = *(_DWORD *)a1;
        break;
      default:
        int v20 = *(unsigned __int8 *)a1;
        break;
    }
  }
  else
  {
    int v20 = 0;
  }
  return v11 + (v20 | v18) + 1;
}

void storeEnumTagSinglePayload for ReversedCollection.Iterator(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v24 = v8;
  uint64_t v9 = *(unsigned int *)(v8 + 84);
  uint64_t v10 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a4 + 24) + 8), v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index)- 1);
  uint64_t v11 = v10;
  unsigned int v12 = *(_DWORD *)(v10 + 84);
  if (v12 <= v9) {
    unsigned int v13 = v9;
  }
  else {
    unsigned int v13 = *(_DWORD *)(v10 + 84);
  }
  uint64_t v14 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v15 = *(void *)(v8 + 64) + v14;
  size_t v16 = (v15 & ~v14) + *(void *)(v10 + 64);
  if (a3 <= v13)
  {
    int v17 = 0;
  }
  else if (v16 <= 3)
  {
    unsigned int v20 = ((a3 - v13 + ~(-1 << (8 * v16))) >> (8 * v16)) + 1;
    if (HIWORD(v20))
    {
      int v17 = 4;
    }
    else if (v20 >= 0x100)
    {
      int v17 = 2;
    }
    else
    {
      int v17 = v20 > 1;
    }
  }
  else
  {
    int v17 = 1;
  }
  if (v13 < a2)
  {
    unsigned int v18 = ~v13 + a2;
    if (v16 < 4)
    {
      int v19 = (v18 >> (8 * v16)) + 1;
      if (v16)
      {
        int v21 = v18 & ~(-1 << (8 * v16));
        bzero(a1, v16);
        if (v16 == 3)
        {
          *(_WORD *)a1 = v21;
          a1[2] = BYTE2(v21);
        }
        else if (v16 == 2)
        {
          *(_WORD *)a1 = v21;
        }
        else
        {
          *a1 = v21;
        }
      }
    }
    else
    {
      bzero(a1, v16);
      *(_DWORD *)a1 = v18;
      int v19 = 1;
    }
    switch(v17)
    {
      case 1:
        a1[v16] = v19;
        return;
      case 2:
        *(_WORD *)&a1[v16] = v19;
        return;
      case 3:
        goto LABEL_41;
      case 4:
        *(_DWORD *)&a1[v16] = v19;
        return;
      default:
        return;
    }
  }
  switch(v17)
  {
    case 1:
      a1[v16] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 2:
      *(_WORD *)&a1[v16] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 3:
LABEL_41:
      __break(1u);
      JUMPOUT(0x181517698);
    case 4:
      *(_DWORD *)&a1[v16] = 0;
      goto LABEL_23;
    default:
LABEL_23:
      if (a2)
      {
LABEL_24:
        if (v9 >= v12)
        {
          unint64_t v23 = *(void (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(v24 + 56);
          v23(a1, a2, v9, v7);
        }
        else
        {
          uint64_t v22 = *(void (**)(unint64_t, uint64_t))(v11 + 56);
          v22((unint64_t)&a1[v15] & ~v14, a2);
        }
      }
      return;
  }
}

const char *type metadata completion function for ReversedCollection.Index(uint64_t a1)
{
  uint64_t result = swift_getAssociatedTypeWitness(319, *(int ***)(*(void *)(a1 + 24) + 8), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *((void *)result - 1) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, (uint64_t)&v4, a1 + 32);
    return 0;
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for ReversedCollection.Index(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a3 + 24) + 8), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v7 = *(_DWORD *)(v6 + 80);
  if (v7 <= 7
    && *(void *)(*((void *)AssociatedTypeWitness - 1) + 64) <= 0x18uLL
    && (*(_DWORD *)(v6 + 80) & 0x100000) == 0)
  {
    (*(void (**)(atomic_ullong **, atomic_ullong **, const char *))(v6 + 16))(a1, a2, AssociatedTypeWitness);
  }
  else
  {
    uint64_t v10 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v10 + ((v7 + 16) & ~v7));
    swift_retain(v10);
  }
  return a1;
}

uint64_t destroy for ReversedCollection.Index(uint64_t a1, uint64_t a2)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a2 + 24) + 8), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v4 = *(uint64_t (**)(uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 8);

  return v4(a1, AssociatedTypeWitness);
}

uint64_t initializeWithCopy for ReversedCollection.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a3 + 24) + 8), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16))(a1, a2, AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for ReversedCollection.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a3 + 24) + 8), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 24))(a1, a2, AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for ReversedCollection.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a3 + 24) + 8), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 32))(a1, a2, AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for ReversedCollection.Index(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a3 + 24) + 8), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 40))(a1, a2, AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for ReversedCollection.Index(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a3 + 24) + 8), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index)- 1);
  unsigned int v6 = *(_DWORD *)(v5 + 84);
  uint64_t v7 = *(void *)(v5 + 64);
  if (!a2) {
    return 0;
  }
  if (a2 <= v6) {
    goto LABEL_19;
  }
  char v8 = 8 * v7;
  if (v7 <= 3)
  {
    unsigned int v10 = ((a2 - v6 + ~(-1 << v8)) >> v8) + 1;
    if (HIWORD(v10))
    {
      int v9 = *(_DWORD *)((char *)a1 + v7);
      if (!v9) {
        goto LABEL_19;
      }
      goto LABEL_11;
    }
    if (v10 > 0xFF)
    {
      int v9 = *(unsigned __int16 *)((char *)a1 + v7);
      if (!*(unsigned __int16 *)((char *)a1 + v7)) {
        goto LABEL_19;
      }
      goto LABEL_11;
    }
    if (v10 < 2)
    {
LABEL_19:
      if (v6)
      {
        unsigned int v12 = *(uint64_t (**)(unsigned __int16 *))(v5 + 48);
        return v12(a1);
      }
      return 0;
    }
  }
  int v9 = *((unsigned __int8 *)a1 + v7);
  if (!*((unsigned char *)a1 + v7)) {
    goto LABEL_19;
  }
LABEL_11:
  int v11 = (v9 - 1) << v8;
  if (v7 > 3) {
    int v11 = 0;
  }
  if (v7)
  {
    if (v7 > 3) {
      LODWORD(v7) = 4;
    }
    switch((int)v7)
    {
      case 2:
        LODWORD(v7) = *a1;
        break;
      case 3:
        LODWORD(v7) = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        LODWORD(v7) = *(_DWORD *)a1;
        break;
      default:
        LODWORD(v7) = *(unsigned __int8 *)a1;
        break;
    }
  }
  return v6 + (v7 | v11) + 1;
}

void storeEnumTagSinglePayload for ReversedCollection.Index(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(*(void *)(a4 + 24) + 8), *(void *)(a4 + 16), (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index)- 1);
  unsigned int v8 = *(_DWORD *)(v7 + 84);
  size_t v9 = *(void *)(v7 + 64);
  if (a3 <= v8)
  {
    int v10 = 0;
  }
  else if (v9 <= 3)
  {
    unsigned int v13 = ((a3 - v8 + ~(-1 << (8 * v9))) >> (8 * v9)) + 1;
    if (HIWORD(v13))
    {
      int v10 = 4;
    }
    else if (v13 >= 0x100)
    {
      int v10 = 2;
    }
    else
    {
      int v10 = v13 > 1;
    }
  }
  else
  {
    int v10 = 1;
  }
  if (v8 < a2)
  {
    unsigned int v11 = ~v8 + a2;
    if (v9 < 4)
    {
      int v12 = (v11 >> (8 * v9)) + 1;
      if (v9)
      {
        int v14 = v11 & ~(-1 << (8 * v9));
        bzero(a1, v9);
        if (v9 == 3)
        {
          *(_WORD *)a1 = v14;
          a1[2] = BYTE2(v14);
        }
        else if (v9 == 2)
        {
          *(_WORD *)a1 = v14;
        }
        else
        {
          *a1 = v14;
        }
      }
    }
    else
    {
      bzero(a1, v9);
      *(_DWORD *)a1 = v11;
      int v12 = 1;
    }
    switch(v10)
    {
      case 1:
        a1[v9] = v12;
        return;
      case 2:
        *(_WORD *)&a1[v9] = v12;
        return;
      case 3:
        goto LABEL_34;
      case 4:
        *(_DWORD *)&a1[v9] = v12;
        return;
      default:
        return;
    }
  }
  switch(v10)
  {
    case 1:
      a1[v9] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_21;
    case 2:
      *(_WORD *)&a1[v9] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_21;
    case 3:
LABEL_34:
      __break(1u);
      JUMPOUT(0x181517EA4);
    case 4:
      *(_DWORD *)&a1[v9] = 0;
      goto LABEL_20;
    default:
LABEL_20:
      if (a2)
      {
LABEL_21:
        uint64_t v15 = *(void (**)(unsigned char *, uint64_t))(v7 + 56);
        v15(a1, a2);
      }
      return;
  }
}

uint64_t type metadata accessor for __SwiftNativeNSArray()
{
  return self;
}

uint64_t method lookup function for __SwiftNativeNSArray(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for __SwiftNativeNSArray.Flags);
}

uint64_t dispatch thunk of __SwiftNativeNSArray.__allocating_init()()
{
  return (*(uint64_t (**)(void))(v0 + 80))();
}

uint64_t type metadata accessor for _SwiftNativeNSMutableArray()
{
  return self;
}

uint64_t method lookup function for _SwiftNativeNSMutableArray(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for _SwiftNativeNSMutableArray.Flags);
}

uint64_t dispatch thunk of _SwiftNativeNSMutableArray.__allocating_init()()
{
  return (*(uint64_t (**)(void))(v0 + 80))();
}

uint64_t type metadata accessor for __SwiftNativeNSDictionary()
{
  return self;
}

uint64_t method lookup function for __SwiftNativeNSDictionary(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for __SwiftNativeNSDictionary.Flags);
}

uint64_t dispatch thunk of __SwiftNativeNSDictionary.__allocating_init(coder:)()
{
  return (*(uint64_t (**)(void))(v0 + 88))();
}

uint64_t type metadata accessor for __SwiftNativeNSSet()
{
  return self;
}

uint64_t method lookup function for __SwiftNativeNSSet(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for __SwiftNativeNSSet.Flags);
}

uint64_t dispatch thunk of __SwiftNativeNSSet.__allocating_init(coder:)()
{
  return (*(uint64_t (**)(void))(v0 + 88))();
}

uint64_t type metadata accessor for __SwiftNativeNSEnumerator()
{
  return self;
}

uint64_t type metadata accessor for __stdlib_ReturnAutoreleasedDummy()
{
  return self;
}

uint64_t storeEnumTagSinglePayload for Hasher._State(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 56) = 0;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)uint64_t result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 64) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Hasher._State()
{
  return &type metadata for Hasher._State;
}

uint64_t dispatch thunk of IteratorProtocol.next()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of Sequence.makeIterator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of Sequence.underestimatedCount.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t dispatch thunk of Sequence._customContainsEquatableElement(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 48))();
}

uint64_t dispatch thunk of Sequence._copyToContiguousArray()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 56))();
}

uint64_t dispatch thunk of Sequence._copyContents(initializing:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 64))();
}

uint64_t dispatch thunk of Sequence.withContiguousStorageIfAvailable<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 72))();
}

uint64_t *type metadata completion function for DropFirstSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for DiscontiguousSlice(a1, a2, a3, (uint64_t)&value witness table for Builtin.Int64.size);
}

uint64_t *type metadata completion function for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = swift_checkMetadataState(319, *(void *)(a1 + 16));
  if (v7 <= 0x3F)
  {
    v8[0] = *(result - 1) + 64;
    v8[1] = a4;
    swift_initStructMetadata(a1, 0, 2uLL, (uint64_t)v8, a1 + 32);
    return 0;
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for DropFirstSequence(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  uint64_t v4 = a1;
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8);
  uint64_t v6 = *(void *)(v5 + 64);
  int v7 = *(_DWORD *)(v5 + 80);
  if ((v7 & 0x1000F8) != 0 || ((v6 + 7) & 0xFFFFFFFFFFFFFFF8) + 8 > 0x18)
  {
    size_t v9 = *a2;
    atomic_ullong *v4 = *a2;
    uint64_t v4 = (atomic_ullong **)((char *)v9 + ((unsigned __int16)((v7 & 0xF8) + 23) & (unsigned __int16)~(v7 & 0xF8) & 0x1F8));
    swift_retain(v9);
  }
  else
  {
    (*(void (**)(atomic_ullong **, atomic_ullong **))(v5 + 16))(a1, a2);
    *(void *)(((unint64_t)v4 + v6 + 7) & 0xFFFFFFFFFFFFFFF8) = *(void *)(((unint64_t)a2 + v6 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  return v4;
}

uint64_t initializeWithCopy for DropFirstSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8) + 16;
  (*(void (**)(void))v5)();
  *(void *)((*(void *)(v5 + 48) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *(void *)((*(void *)(v5 + 48) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t assignWithCopy for DropFirstSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8) + 24;
  (*(void (**)(void))v5)();
  *(void *)((*(void *)(v5 + 40) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *(void *)((*(void *)(v5 + 40) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t initializeWithTake for DiscontiguousSlice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8) + 32;
  (*(void (**)(void))v5)();
  *(void *)((*(void *)(v5 + 32) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *(void *)((*(void *)(v5 + 32) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t assignWithTake for DropFirstSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8) + 40;
  (*(void (**)(void))v5)();
  *(void *)((*(void *)(v5 + 24) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *(void *)((*(void *)(v5 + 24) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t getEnumTagSinglePayload for DropFirstSequence(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  if (!a2) {
    return 0;
  }
  if (v5 < a2)
  {
    unint64_t v6 = ((*(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64) + 7) & 0xFFFFFFFFFFFFFFF8) + 8;
    unsigned int v7 = a2 - v5;
    uint64_t v8 = v6 & 0xFFFFFFF8;
    if ((v6 & 0xFFFFFFF8) != 0) {
      unsigned int v9 = 2;
    }
    else {
      unsigned int v9 = v7 + 1;
    }
    if (v9 >= 0x10000) {
      unsigned int v10 = 4;
    }
    else {
      unsigned int v10 = 2;
    }
    if (v9 < 0x100) {
      unsigned int v10 = 1;
    }
    if (v9 >= 2) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = 0;
    }
    switch(v11)
    {
      case 1:
        int v12 = *((unsigned __int8 *)a1 + v6);
        if (!v12) {
          break;
        }
        goto LABEL_18;
      case 2:
        int v12 = *(unsigned __int16 *)((char *)a1 + v6);
        if (v12) {
          goto LABEL_18;
        }
        break;
      case 3:
        __break(1u);
        JUMPOUT(0x1815185FCLL);
      case 4:
        int v12 = *(_DWORD *)((char *)a1 + v6);
        if (!v12) {
          break;
        }
LABEL_18:
        int v13 = v12 - 1;
        if (v8)
        {
          int v13 = 0;
          LODWORD(v8) = *a1;
        }
        return v5 + (v8 | v13) + 1;
      default:
        break;
    }
  }
  if (v5) {
    return (*(uint64_t (**)(void))(v4 + 48))();
  }
  else {
    return 0;
  }
}

void storeEnumTagSinglePayload for DropFirstSequence(unsigned char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 16) - 8);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  size_t v8 = ((*(void *)(v6 + 64) + 7) & 0xFFFFFFFFFFFFFFF8) + 8;
  if (v7 >= a3)
  {
    int v12 = 0;
    int v13 = a2 - v7;
    if (a2 <= v7)
    {
LABEL_14:
      switch(v12)
      {
        case 1:
          a1[v8] = 0;
          if (!a2) {
            return;
          }
          goto LABEL_27;
        case 2:
          *(_WORD *)&a1[v8] = 0;
          if (!a2) {
            return;
          }
          goto LABEL_27;
        case 3:
          goto LABEL_34;
        case 4:
          *(_DWORD *)&a1[v8] = 0;
          goto LABEL_26;
        default:
LABEL_26:
          if (a2)
          {
LABEL_27:
            size_t v16 = *(void (**)(void))(v6 + 56);
            v16();
          }
          break;
      }
      return;
    }
  }
  else
  {
    unsigned int v9 = a3 - v7;
    if (((*(_DWORD *)(v6 + 64) + 7) & 0xFFFFFFF8) == 0xFFFFFFF8) {
      unsigned int v10 = v9 + 1;
    }
    else {
      unsigned int v10 = 2;
    }
    if (v10 >= 0x10000) {
      int v11 = 4;
    }
    else {
      int v11 = 2;
    }
    if (v10 < 0x100) {
      int v11 = 1;
    }
    if (v10 >= 2) {
      int v12 = v11;
    }
    else {
      int v12 = 0;
    }
    int v13 = a2 - v7;
    if (a2 <= v7) {
      goto LABEL_14;
    }
  }
  if (((*(_DWORD *)(v6 + 64) + 7) & 0xFFFFFFF8) == 0xFFFFFFF8) {
    int v14 = v13;
  }
  else {
    int v14 = 1;
  }
  if (((*(_DWORD *)(v6 + 64) + 7) & 0xFFFFFFF8) != 0xFFFFFFF8)
  {
    unsigned int v15 = ~v7 + a2;
    bzero(a1, v8);
    *(_DWORD *)a1 = v15;
  }
  switch(v12)
  {
    case 1:
      a1[v8] = v14;
      break;
    case 2:
      *(_WORD *)&a1[v8] = v14;
      break;
    case 3:
LABEL_34:
      __break(1u);
      JUMPOUT(0x1815187BCLL);
    case 4:
      *(_DWORD *)&a1[v8] = v14;
      break;
    default:
      return;
  }
}

const char *type metadata completion function for PrefixSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator, (uint64_t)&value witness table for Builtin.Int64.size);
}

const char *type metadata completion function for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, uint64_t a6)
{
  uint64_t result = swift_getAssociatedTypeWitness(319, *(int ***)(a1 + 24), *(void *)(a1 + 16), a4, a5);
  if (v9 <= 0x3F)
  {
    v10[0] = *((void *)result - 1) + 64;
    v10[1] = a6;
    swift_initStructMetadata(a1, 0, 2uLL, (uint64_t)v10, a1 + 32);
    return 0;
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for PrefixSequence.Iterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

atomic_ullong **initializeBufferWithCopyOfBuffer for EnumeratedSequence.Iterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = *(void *)(v8 + 64);
  int v10 = *(_DWORD *)(v8 + 80);
  if ((v10 & 0x1000F8) != 0 || ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 8 > 0x18)
  {
    int v12 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v12
                          + ((unsigned __int16)((v10 & 0xF8) + 23) & (unsigned __int16)~(v10 & 0xF8) & 0x1F8));
    swift_retain(v12);
  }
  else
  {
    (*(void (**)(atomic_ullong **, atomic_ullong **, const char *))(v8 + 16))(a1, a2, AssociatedTypeWitness);
    *(void *)(((unint64_t)a1 + v9 + 7) & 0xFFFFFFFFFFFFFFF8) = *(void *)(((unint64_t)a2 + v9 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  return a1;
}

uint64_t destroy for PrefixSequence.Iterator(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator(a1, a2, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t initializeWithCopy for PrefixSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t initializeWithCopy for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1) + 16;
  (*(void (**)(uint64_t, uint64_t, const char *))v8)(a1, a2, AssociatedTypeWitness);
  *(void *)((*(void *)(v8 + 48) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *(void *)((*(void *)(v8 + 48) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t assignWithCopy for PrefixSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t assignWithCopy for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1) + 24;
  (*(void (**)(uint64_t, uint64_t, const char *))v8)(a1, a2, AssociatedTypeWitness);
  *(void *)((*(void *)(v8 + 40) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *(void *)((*(void *)(v8 + 40) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t initializeWithTake for PrefixSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t initializeWithTake for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1) + 32;
  (*(void (**)(uint64_t, uint64_t, const char *))v8)(a1, a2, AssociatedTypeWitness);
  *(void *)((*(void *)(v8 + 32) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *(void *)((*(void *)(v8 + 32) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t assignWithTake for PrefixSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t assignWithTake for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1) + 40;
  (*(void (**)(uint64_t, uint64_t, const char *))v8)(a1, a2, AssociatedTypeWitness);
  *(void *)((*(void *)(v8 + 24) + 7 + a1) & 0xFFFFFFFFFFFFFFF8) = *(void *)((*(void *)(v8 + 24) + 7 + a2) & 0xFFFFFFFFFFFFFFF8);
  return a1;
}

uint64_t getEnumTagSinglePayload for PrefixSequence.Iterator(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for EnumeratedSequence.Iterator(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
}

uint64_t getEnumTagSinglePayload for EnumeratedSequence.Iterator(_DWORD *a1, unsigned int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  unsigned int v9 = *(_DWORD *)(v8 + 84);
  if (!a2) {
    return 0;
  }
  if (v9 < a2)
  {
    unint64_t v10 = ((*(void *)(*((void *)AssociatedTypeWitness - 1) + 64) + 7) & 0xFFFFFFFFFFFFFFF8) + 8;
    uint64_t v11 = v10 & 0xFFFFFFF8;
    if ((v10 & 0xFFFFFFF8) != 0) {
      unsigned int v12 = 2;
    }
    else {
      unsigned int v12 = a2 - v9 + 1;
    }
    if (v12 >= 0x10000) {
      unsigned int v13 = 4;
    }
    else {
      unsigned int v13 = 2;
    }
    if (v12 < 0x100) {
      unsigned int v13 = 1;
    }
    if (v12 >= 2) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0;
    }
    switch(v14)
    {
      case 1:
        int v15 = *((unsigned __int8 *)a1 + v10);
        if (!v15) {
          break;
        }
        goto LABEL_18;
      case 2:
        int v15 = *(unsigned __int16 *)((char *)a1 + v10);
        if (v15) {
          goto LABEL_18;
        }
        break;
      case 3:
        __break(1u);
        JUMPOUT(0x181518DC0);
      case 4:
        int v15 = *(_DWORD *)((char *)a1 + v10);
        if (!v15) {
          break;
        }
LABEL_18:
        int v16 = v15 - 1;
        if (v11)
        {
          int v16 = 0;
          LODWORD(v11) = *a1;
        }
        return v9 + (v11 | v16) + 1;
      default:
        break;
    }
  }
  if (!v9) {
    return 0;
  }
  unsigned int v18 = *(uint64_t (**)(_DWORD *))(v8 + 48);

  return v18(a1);
}

void storeEnumTagSinglePayload for PrefixSequence.Iterator(_DWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
}

void storeEnumTagSinglePayload for EnumeratedSequence.Iterator(_DWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v9 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 24), *(void *)(a4 + 16), a5, a6) - 1);
  unsigned int v10 = *(_DWORD *)(v9 + 84);
  size_t v11 = ((*(void *)(v9 + 64) + 7) & 0xFFFFFFFFFFFFFFF8) + 8;
  if (v10 >= a3)
  {
    int v14 = 0;
    int v15 = a2 - v10;
    if (a2 <= v10)
    {
LABEL_14:
      switch(v14)
      {
        case 1:
          *((unsigned char *)a1 + v11) = 0;
          if (!a2) {
            return;
          }
          goto LABEL_27;
        case 2:
          *(_WORD *)((char *)a1 + v11) = 0;
          if (!a2) {
            return;
          }
          goto LABEL_27;
        case 3:
          goto LABEL_34;
        case 4:
          *(_DWORD *)((char *)a1 + v11) = 0;
          goto LABEL_26;
        default:
LABEL_26:
          if (a2)
          {
LABEL_27:
            unsigned int v18 = *(void (**)(_DWORD *, uint64_t))(v9 + 56);
            v18(a1, a2);
          }
          break;
      }
      return;
    }
  }
  else
  {
    if (((*(_DWORD *)(v9 + 64) + 7) & 0xFFFFFFF8) == 0xFFFFFFF8) {
      unsigned int v12 = a3 - v10 + 1;
    }
    else {
      unsigned int v12 = 2;
    }
    if (v12 >= 0x10000) {
      int v13 = 4;
    }
    else {
      int v13 = 2;
    }
    if (v12 < 0x100) {
      int v13 = 1;
    }
    if (v12 >= 2) {
      int v14 = v13;
    }
    else {
      int v14 = 0;
    }
    int v15 = a2 - v10;
    if (a2 <= v10) {
      goto LABEL_14;
    }
  }
  if (((*(_DWORD *)(v9 + 64) + 7) & 0xFFFFFFF8) == 0xFFFFFFF8) {
    int v16 = v15;
  }
  else {
    int v16 = 1;
  }
  if (((*(_DWORD *)(v9 + 64) + 7) & 0xFFFFFFF8) != 0xFFFFFFF8)
  {
    int v17 = ~v10 + a2;
    bzero(a1, v11);
    *a1 = v17;
  }
  switch(v14)
  {
    case 1:
      *((unsigned char *)a1 + v11) = v16;
      break;
    case 2:
      *(_WORD *)((char *)a1 + v11) = v16;
      break;
    case 3:
LABEL_34:
      __break(1u);
      JUMPOUT(0x181518FB0);
    case 4:
      *(_DWORD *)((char *)a1 + v11) = v16;
      break;
    default:
      return;
  }
}

void *type metadata completion function for DropWhileSequence(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 16);
  int v2 = *(int ***)(a1 + 24);
  uint64_t result = swift_getAssociatedTypeWitness(319, v2, v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  if (v5 <= 0x3F)
  {
    v10[0] = *(result - 1) + 64;
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(255, v2, v3, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
    uint64_t result = type metadata accessor for Optional(319, (uint64_t)AssociatedTypeWitness, v7, v8);
    if (v9 <= 0x3F)
    {
      v10[1] = *(result - 1) + 64;
      swift_initStructMetadata(a1, 0, 2uLL, (uint64_t)v10, a1 + 32);
      return 0;
    }
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for DropWhileSequence(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t v5 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = *(void *)(v8 + 64);
  unsigned int v10 = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v11 = *((void *)v10 - 1);
  uint64_t v12 = *(_DWORD *)(v11 + 80);
  uint64_t v13 = v9 + v12;
  if (*(_DWORD *)(v11 + 84)) {
    size_t v14 = *(void *)(v11 + 64);
  }
  else {
    size_t v14 = *(void *)(v11 + 64) + 1;
  }
  uint64_t v15 = (*(unsigned char *)(v8 + 80) | *(unsigned char *)(v11 + 80));
  if (v15 > 7
    || ((*(_DWORD *)(v8 + 80) | *(_DWORD *)(v11 + 80)) & 0x100000) != 0
    || (v13 & ~v12) + v14 > 0x18)
  {
    unsigned int v18 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v18 + ((v15 + 16) & ~v15));
    swift_retain(v18);
  }
  else
  {
    int v19 = v10;
    uint64_t v20 = ~v12;
    (*(void (**)(atomic_ullong **, atomic_ullong **, const char *))(v8 + 16))(a1, a2, AssociatedTypeWitness);
    int v21 = (const void *)(((unint64_t)a2 + v13) & v20);
    if ((*(unsigned int (**)(const void *, uint64_t, const char *))(v11 + 48))(v21, 1, v19))
    {
      memcpy((void *)(((unint64_t)a1 + v13) & v20), v21, v14);
    }
    else
    {
      (*(void (**)(unint64_t, const void *, const char *))(v11 + 16))(((unint64_t)a1 + v13) & v20, v21, v19);
      (*(void (**)(unint64_t, void, uint64_t, const char *))(v11 + 56))(((unint64_t)a1 + v13) & v20, 0, 1, v19);
    }
  }
  return a1;
}

uint64_t destroy for DropWhileSequence(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v3 = *(int ***)(a2 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v3, v4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1) + 8;
  (*(void (**)(uint64_t, const char *))v6)(a1, AssociatedTypeWitness);
  uint64_t v7 = *(void *)(v6 + 56);
  uint64_t v8 = swift_getAssociatedTypeWitness(0, v3, v4, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v9 = *((void *)v8 - 1);
  unint64_t v10 = (v7 + a1 + *(unsigned __int8 *)(v9 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80);
  uint64_t v13 = v9;
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, const char *))(v9 + 48))(v10, 1, v8);
  if (!result)
  {
    uint64_t v12 = *(uint64_t (**)(unint64_t, const char *))(v13 + 8);
    return v12(v10, v8);
  }
  return result;
}

uint64_t initializeWithCopy for DropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t v5 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1) + 16;
  (*(void (**)(uint64_t, uint64_t, const char *))v8)(a1, a2, AssociatedTypeWitness);
  uint64_t v9 = *(void *)(v8 + 48);
  unint64_t v10 = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v11 = *((void *)v10 - 1);
  uint64_t v12 = *(unsigned __int8 *)(v11 + 80);
  uint64_t v13 = (void *)((v9 + v12 + a1) & ~v12);
  size_t v14 = (const void *)((v9 + v12 + a2) & ~v12);
  if ((*(unsigned int (**)(const void *, uint64_t, const char *))(v11 + 48))(v14, 1, v10))
  {
    if (*(_DWORD *)(v11 + 84)) {
      size_t v15 = *(void *)(v11 + 64);
    }
    else {
      size_t v15 = *(void *)(v11 + 64) + 1;
    }
    memcpy(v13, v14, v15);
  }
  else
  {
    (*(void (**)(void *, const void *, const char *))(v11 + 16))(v13, v14, v10);
    (*(void (**)(void *, void, uint64_t, const char *))(v11 + 56))(v13, 0, 1, v10);
  }
  return a1;
}

uint64_t assignWithCopy for DropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t v5 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1) + 24;
  (*(void (**)(uint64_t, uint64_t, const char *))v8)(a1, a2, AssociatedTypeWitness);
  uint64_t v9 = *(void *)(v8 + 40);
  unint64_t v10 = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v11 = *((void *)v10 - 1);
  uint64_t v12 = *(unsigned __int8 *)(v11 + 80);
  uint64_t v13 = (void *)((v9 + v12 + a1) & ~v12);
  size_t v14 = (void *)((v9 + v12 + a2) & ~v12);
  size_t v15 = *(uint64_t (**)(void *, uint64_t, const char *))(v11 + 48);
  int v16 = v15(v13, 1, v10);
  int v17 = v15(v14, 1, v10);
  if (v16)
  {
    if (!v17)
    {
      (*(void (**)(void *, void *, const char *))(v11 + 16))(v13, v14, v10);
      (*(void (**)(void *, void, uint64_t, const char *))(v11 + 56))(v13, 0, 1, v10);
      return a1;
    }
    int v18 = *(_DWORD *)(v11 + 84);
    size_t v19 = *(void *)(v11 + 64);
  }
  else
  {
    if (!v17)
    {
      (*(void (**)(void *, void *, const char *))(v11 + 24))(v13, v14, v10);
      return a1;
    }
    int v21 = *(void (**)(void *, const char *))(v11 + 8);
    uint64_t v20 = v11 + 8;
    v21(v13, v10);
    int v18 = *(_DWORD *)(v20 + 76);
    size_t v19 = *(void *)(v20 + 56);
  }
  if (v18) {
    size_t v22 = v19;
  }
  else {
    size_t v22 = v19 + 1;
  }
  memcpy(v13, v14, v22);
  return a1;
}

uint64_t initializeWithTake for DropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t v5 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1) + 32;
  (*(void (**)(uint64_t, uint64_t, const char *))v8)(a1, a2, AssociatedTypeWitness);
  uint64_t v9 = *(void *)(v8 + 32);
  unint64_t v10 = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v11 = *((void *)v10 - 1);
  uint64_t v12 = *(unsigned __int8 *)(v11 + 80);
  uint64_t v13 = (void *)((v9 + v12 + a1) & ~v12);
  size_t v14 = (const void *)((v9 + v12 + a2) & ~v12);
  if ((*(unsigned int (**)(const void *, uint64_t, const char *))(v11 + 48))(v14, 1, v10))
  {
    if (*(_DWORD *)(v11 + 84)) {
      size_t v15 = *(void *)(v11 + 64);
    }
    else {
      size_t v15 = *(void *)(v11 + 64) + 1;
    }
    memcpy(v13, v14, v15);
  }
  else
  {
    (*(void (**)(void *, const void *, const char *))(v11 + 32))(v13, v14, v10);
    (*(void (**)(void *, void, uint64_t, const char *))(v11 + 56))(v13, 0, 1, v10);
  }
  return a1;
}

uint64_t assignWithTake for DropWhileSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t v5 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1) + 40;
  (*(void (**)(uint64_t, uint64_t, const char *))v8)(a1, a2, AssociatedTypeWitness);
  uint64_t v9 = *(void *)(v8 + 24);
  unint64_t v10 = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v11 = *((void *)v10 - 1);
  uint64_t v12 = *(unsigned __int8 *)(v11 + 80);
  uint64_t v13 = (void *)((v9 + v12 + a1) & ~v12);
  size_t v14 = (void *)((v9 + v12 + a2) & ~v12);
  size_t v15 = *(uint64_t (**)(void *, uint64_t, const char *))(v11 + 48);
  int v16 = v15(v13, 1, v10);
  int v17 = v15(v14, 1, v10);
  if (v16)
  {
    if (!v17)
    {
      (*(void (**)(void *, void *, const char *))(v11 + 32))(v13, v14, v10);
      (*(void (**)(void *, void, uint64_t, const char *))(v11 + 56))(v13, 0, 1, v10);
      return a1;
    }
    int v18 = *(_DWORD *)(v11 + 84);
    size_t v19 = *(void *)(v11 + 64);
  }
  else
  {
    if (!v17)
    {
      (*(void (**)(void *, void *, const char *))(v11 + 40))(v13, v14, v10);
      return a1;
    }
    int v21 = *(void (**)(void *, const char *))(v11 + 8);
    uint64_t v20 = v11 + 8;
    v21(v13, v10);
    int v18 = *(_DWORD *)(v20 + 76);
    size_t v19 = *(void *)(v20 + 56);
  }
  if (v18) {
    size_t v22 = v19;
  }
  else {
    size_t v22 = v19 + 1;
  }
  memcpy(v13, v14, v22);
  return a1;
}

uint64_t getEnumTagSinglePayload for DropWhileSequence(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  unint64_t v5 = *(int ***)(a3 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = *(unsigned int *)(v8 + 84);
  unint64_t v10 = swift_getAssociatedTypeWitness(0, v5, v6, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  uint64_t v11 = *((void *)v10 - 1);
  int v12 = *(_DWORD *)(v11 + 84);
  if (v12) {
    unsigned int v13 = v12 - 1;
  }
  else {
    unsigned int v13 = 0;
  }
  if (v13 <= v9) {
    unsigned int v14 = v9;
  }
  else {
    unsigned int v14 = v13;
  }
  uint64_t v15 = *(unsigned __int8 *)(v11 + 80);
  if (v12) {
    uint64_t v16 = *(void *)(*((void *)v10 - 1) + 64);
  }
  else {
    uint64_t v16 = *(void *)(*((void *)v10 - 1) + 64) + 1;
  }
  if (!a2) {
    return 0;
  }
  uint64_t v17 = *(void *)(v8 + 64) + v15;
  if (a2 <= v14) {
    goto LABEL_30;
  }
  uint64_t v18 = v16 + (v17 & ~v15);
  char v19 = 8 * v18;
  if (v18 <= 3)
  {
    unsigned int v21 = ((a2 - v14 + ~(-1 << v19)) >> v19) + 1;
    if (HIWORD(v21))
    {
      int v20 = *(_DWORD *)((char *)a1 + v18);
      if (!v20) {
        goto LABEL_30;
      }
      goto LABEL_20;
    }
    if (v21 > 0xFF)
    {
      int v20 = *(unsigned __int16 *)((char *)a1 + v18);
      if (!*(unsigned __int16 *)((char *)a1 + v18)) {
        goto LABEL_30;
      }
      goto LABEL_20;
    }
    if (v21 < 2)
    {
LABEL_30:
      if (v14)
      {
        if (v9 >= v13)
        {
          int v27 = *(uint64_t (**)(unsigned __int16 *, uint64_t, const char *))(v8 + 48);
          return v27(a1, v9, AssociatedTypeWitness);
        }
        else
        {
          unsigned int v25 = (*(uint64_t (**)(unint64_t))(v11 + 48))(((unint64_t)a1 + v17) & ~v15);
          if (v25 >= 2) {
            return v25 - 1;
          }
          else {
            return 0;
          }
        }
      }
      return 0;
    }
  }
  int v20 = *((unsigned __int8 *)a1 + v18);
  if (!*((unsigned char *)a1 + v18)) {
    goto LABEL_30;
  }
LABEL_20:
  int v22 = (v20 - 1) << v19;
  if (v18 > 3) {
    int v22 = 0;
  }
  if (v18)
  {
    if (v18 <= 3) {
      int v23 = v18;
    }
    else {
      int v23 = 4;
    }
    switch(v23)
    {
      case 2:
        int v24 = *a1;
        break;
      case 3:
        int v24 = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        int v24 = *(_DWORD *)a1;
        break;
      default:
        int v24 = *(unsigned __int8 *)a1;
        break;
    }
  }
  else
  {
    int v24 = 0;
  }
  return v14 + (v24 | v22) + 1;
}

void storeEnumTagSinglePayload for DropWhileSequence(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a4 + 16);
  uint64_t v7 = *(int ***)(a4 + 24);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, v7, v8, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = *(unsigned int *)(v10 + 84);
  int v12 = swift_getAssociatedTypeWitness(0, v7, v8, (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Element);
  int v13 = 0;
  uint64_t v14 = *((void *)v12 - 1);
  int v15 = *(_DWORD *)(v14 + 84);
  unsigned int v16 = v15 - 1;
  if (!v15) {
    unsigned int v16 = 0;
  }
  if (v16 <= v11) {
    unsigned int v17 = v11;
  }
  else {
    unsigned int v17 = v16;
  }
  uint64_t v18 = *(unsigned __int8 *)(v14 + 80);
  uint64_t v19 = *(void *)(v10 + 64) + v18;
  if (v15) {
    size_t v20 = *(void *)(*((void *)v12 - 1) + 64);
  }
  else {
    size_t v20 = *(void *)(*((void *)v12 - 1) + 64) + 1;
  }
  size_t v21 = (v19 & ~v18) + v20;
  if (a3 <= v17) {
    goto LABEL_17;
  }
  if (v21 <= 3)
  {
    unsigned int v22 = ((a3 - v17 + ~(-1 << (8 * v21))) >> (8 * v21)) + 1;
    if (HIWORD(v22))
    {
      int v13 = 4;
      if (v17 >= a2) {
        goto LABEL_25;
      }
      goto LABEL_18;
    }
    if (v22 >= 0x100) {
      int v13 = 2;
    }
    else {
      int v13 = v22 > 1;
    }
LABEL_17:
    if (v17 >= a2) {
      goto LABEL_25;
    }
    goto LABEL_18;
  }
  int v13 = 1;
  if (v17 >= a2)
  {
LABEL_25:
    switch(v13)
    {
      case 1:
        a1[v21] = 0;
        if (!a2) {
          return;
        }
        goto LABEL_30;
      case 2:
        *(_WORD *)&a1[v21] = 0;
        if (!a2) {
          return;
        }
        goto LABEL_30;
      case 3:
        goto LABEL_59;
      case 4:
        *(_DWORD *)&a1[v21] = 0;
        goto LABEL_29;
      default:
LABEL_29:
        if (a2)
        {
LABEL_30:
          if (v11 >= v16)
          {
            int v30 = *(void (**)(unsigned char *, uint64_t, uint64_t, const char *))(v10 + 56);
            v30(a1, a2, v11, AssociatedTypeWitness);
          }
          else
          {
            unsigned int v26 = (unsigned char *)((unint64_t)&a1[v19] & ~v18);
            if (v16 >= a2)
            {
              unsigned int v31 = *(void (**)(unsigned char *, void))(v14 + 56);
              v31(v26, (a2 + 1));
            }
            else
            {
              if (v20 <= 3) {
                int v27 = ~(-1 << (8 * v20));
              }
              else {
                int v27 = -1;
              }
              if (v20)
              {
                int v28 = v27 & (~v16 + a2);
                if (v20 <= 3) {
                  int v29 = v20;
                }
                else {
                  int v29 = 4;
                }
                bzero(v26, v20);
                switch(v29)
                {
                  case 2:
                    *(_WORD *)unsigned int v26 = v28;
                    break;
                  case 3:
                    *(_WORD *)unsigned int v26 = v28;
                    v26[2] = BYTE2(v28);
                    break;
                  case 4:
                    *(_DWORD *)unsigned int v26 = v28;
                    break;
                  default:
                    *unsigned int v26 = v28;
                    break;
                }
              }
            }
          }
        }
        break;
    }
    return;
  }
LABEL_18:
  unsigned int v23 = ~v17 + a2;
  if (v21 < 4)
  {
    int v24 = (v23 >> (8 * v21)) + 1;
    if (v21)
    {
      int v25 = v23 & ~(-1 << (8 * v21));
      bzero(a1, (v19 & ~v18) + v20);
      if (v21 == 3)
      {
        *(_WORD *)a1 = v25;
        a1[2] = BYTE2(v25);
      }
      else if (v21 == 2)
      {
        *(_WORD *)a1 = v25;
      }
      else
      {
        *a1 = v25;
      }
    }
  }
  else
  {
    bzero(a1, (v19 & ~v18) + v20);
    *(_DWORD *)a1 = v23;
    int v24 = 1;
  }
  switch(v13)
  {
    case 1:
      a1[v21] = v24;
      break;
    case 2:
      *(_WORD *)&a1[v21] = v24;
      break;
    case 3:
LABEL_59:
      __break(1u);
      JUMPOUT(0x18151A224);
    case 4:
      *(_DWORD *)&a1[v21] = v24;
      break;
    default:
      return;
  }
}

uint64_t initializeBufferWithCopyOfBuffer for Set.Index(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for Dictionary.Index(a1, a2, a3, (void (*)(void, uint64_t, uint64_t))outlined copy of Set<A>.Index._Variant<A>);
}

uint64_t *assignWithCopy for Set.Index(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return assignWithCopy for Dictionary.Index(a1, a2, a3, (void (*)(void, uint64_t, uint64_t))outlined copy of Set<A>.Index._Variant<A>, (void (*)(uint64_t, uint64_t, uint64_t))outlined consume of Set<A>.Index._Variant<A>);
}

uint64_t *assignWithTake for Set.Index(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for Dictionary.Index(a1, a2, a3, (void (*)(uint64_t, uint64_t, uint64_t))outlined consume of Set<A>.Index._Variant<A>);
}

Class *type metadata accessor for Set.Index._Variant(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Set.Index._Variant.Flags);
}

uint64_t destroy for Set.Iterator(void *a1, uint64_t a2)
{
  return destroy for Dictionary.Keys.Iterator(a1, a2, (uint64_t (*)(void, void, void, void, void))outlined consume of Set<String>.Iterator._Variant);
}

void *initializeWithCopy for Set.Iterator(void *a1, void *a2, uint64_t a3)
{
  return initializeWithCopy for Dictionary.Keys.Iterator(a1, a2, a3, (void (*)(void, uint64_t, uint64_t, uint64_t, uint64_t))outlined copy of Set<A>.Iterator._Variant<A>);
}

uint64_t *assignWithCopy for Set.Iterator(uint64_t *a1, void *a2, uint64_t a3)
{
  return assignWithCopy for Dictionary.Keys.Iterator(a1, a2, a3, (void (*)(void, uint64_t, uint64_t, uint64_t, uint64_t))outlined copy of Set<A>.Iterator._Variant<A>, (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))outlined consume of Set<String>.Iterator._Variant);
}

void *assignWithTake for Set.Iterator(void *a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for Dictionary.Keys.Iterator(a1, a2, a3, (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))outlined consume of Set<String>.Iterator._Variant);
}

Class *type metadata accessor for Set.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Set.Iterator.Flags, &flag for loading of canonical specialized generic type metadata for Set.Iterator);
}

uint64_t dispatch thunk of SetAlgebra.init()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 32))();
}

uint64_t dispatch thunk of SetAlgebra.contains(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of SetAlgebra.union(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 48))();
}

uint64_t dispatch thunk of SetAlgebra.intersection(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

uint64_t dispatch thunk of SetAlgebra.symmetricDifference(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 64))();
}

uint64_t dispatch thunk of SetAlgebra.insert(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 72))();
}

uint64_t dispatch thunk of SetAlgebra.remove(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 80))();
}

uint64_t dispatch thunk of SetAlgebra.update(with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 88))();
}

uint64_t dispatch thunk of SetAlgebra.formUnion(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 96))();
}

uint64_t dispatch thunk of SetAlgebra.formIntersection(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 104))();
}

uint64_t dispatch thunk of SetAlgebra.formSymmetricDifference(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 112))();
}

uint64_t dispatch thunk of SetAlgebra.subtracting(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 120))();
}

uint64_t dispatch thunk of SetAlgebra.isSubset(of:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 128))();
}

uint64_t dispatch thunk of SetAlgebra.isDisjoint(with:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 136))();
}

uint64_t dispatch thunk of SetAlgebra.isSuperset(of:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 144))();
}

uint64_t dispatch thunk of SetAlgebra.isEmpty.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 152))();
}

uint64_t dispatch thunk of SetAlgebra.init<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 160))();
}

uint64_t dispatch thunk of SetAlgebra.subtract(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 168))();
}

swift *type metadata completion function for _SwiftSetNSEnumerator(uint64_t a1)
{
  v2[0] = &unk_1ECA04A78;
  v2[1] = "\b";
  void v2[2] = &value witness table for Builtin.Int64.size;
  void v2[3] = &value witness table for Builtin.Int64.size;
  return swift_initClassMetadata2(a1, 0, 4uLL, (uint64_t)v2, a1 + 112);
}

Class *type metadata accessor for _SwiftSetNSEnumerator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _SwiftSetNSEnumerator.Flags);
}

swift *type metadata completion function for _SwiftDeferredNSSet(uint64_t a1)
{
  v2[0] = "\b";
  v2[1] = &unk_1ECA04A78;
  return swift_initClassMetadata2(a1, 0, 2uLL, (uint64_t)v2, a1 + 112);
}

ValueMetadata *type metadata accessor for __CocoaSet()
{
  return &type metadata for __CocoaSet;
}

unint64_t *initializeBufferWithCopyOfBuffer for __CocoaSet.Index(unint64_t *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  swift_bridgeObjectRetain(v3);
  return a1;
}

void destroy for __CocoaSet.Index(uint64_t *a1)
{
}

uint64_t *assignWithCopy for __CocoaDictionary.Index(uint64_t *a1, unint64_t *a2)
{
  unint64_t v4 = *a2;
  uint64_t v5 = *a1;
  *a1 = *a2;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  a1[1] = a2[1];
  return a1;
}

uint64_t *assignWithTake for __CocoaSet.Index(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a1;
  *a1 = *a2;
  swift_bridgeObjectRelease(v4);
  a1[1] = a2[1];
  return a1;
}

ValueMetadata *type metadata accessor for __CocoaSet.Index()
{
  return &type metadata for __CocoaSet.Index;
}

uint64_t method lookup function for __CocoaSet.Iterator(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for __CocoaSet.Iterator.Flags);
}

void *initializeBufferWithCopyOfBuffer for _SetBuilder(void *a1, uint64_t a2)
{
  unint64_t v3 = *(atomic_ullong **)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  *a1 = *(void *)a2;
  a1[1] = v4;
  swift_retain(v3);
  return a1;
}

uint64_t *assignWithCopy for _DictionaryBuilder(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *(atomic_ullong **)a2;
  uint64_t v5 = *a1;
  *a1 = *(void *)a2;
  swift_retain(v4);
  swift_release(v5);
  a1[1] = *(void *)(a2 + 8);
  return a1;
}

uint64_t *assignWithTake for _SetBuilder(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a1;
  *a1 = *a2;
  swift_release(v4);
  a1[1] = a2[1];
  return a1;
}

Class *type metadata accessor for _SetBuilder(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _SetBuilder.Flags);
}

uint64_t type metadata accessor for __RawSetStorage()
{
  return self;
}

uint64_t method lookup function for __RawSetStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for __RawSetStorage.Flags);
}

uint64_t type metadata accessor for __EmptySetSingleton()
{
  return self;
}

uint64_t method lookup function for __EmptySetSingleton(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for __EmptySetSingleton.Flags);
}

swift *type metadata completion function for WritableKeyPath(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0, (uint64_t)v2, a1 + 184);
}

uint64_t method lookup function for _SetStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for _SetStorage.Flags);
}

void *type metadata completion function for Slice(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t result = swift_getAssociatedTypeWitness(319, *(int ***)(a1 + 24), v2, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  if (v4 <= 0x3F)
  {
    v6[0] = *(result - 1) + 64;
    v6[1] = v6[0];
    uint64_t result = swift_checkMetadataState(319, v2);
    if (v5 <= 0x3F)
    {
      void v6[2] = *(result - 1) + 64;
      swift_initStructMetadata(a1, 0, 3uLL, (uint64_t)v6, a1 + 32);
      return 0;
    }
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for Slice(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = *(void *)(v7 + 64);
  unint64_t v9 = *(_DWORD *)(v7 + 80);
  uint64_t v10 = v8 + v9;
  uint64_t v11 = *(void *)(v5 - 8);
  uint64_t v12 = *(_DWORD *)(v11 + 80);
  uint64_t v13 = v8 + v12;
  unint64_t v14 = ((v8 + v12 + ((v8 + v9) & ~v9)) & ~v12) + *(void *)(v11 + 64);
  if ((v12 | v9) > 7 || ((*(_DWORD *)(v11 + 80) | *(_DWORD *)(v7 + 80)) & 0x100000) != 0 || v14 > 0x18)
  {
    unsigned int v17 = *a2;
    *a1 = *a2;
    unsigned int v23 = (atomic_ullong **)((char *)v17 + (((v12 | v9) + 16) & ~(v12 | v9)));
    swift_retain(v17);
  }
  else
  {
    uint64_t v18 = AssociatedTypeWitness;
    uint64_t v19 = ~v9;
    uint64_t v25 = ~v12;
    size_t v20 = *(void (**)(atomic_ullong **, atomic_ullong **, const char *))(v7 + 16);
    v20(a1, a2, AssociatedTypeWitness);
    unsigned int v26 = a1;
    unint64_t v21 = ((unint64_t)a1 + v10) & v19;
    unint64_t v22 = ((unint64_t)a2 + v10) & v19;
    v20((atomic_ullong **)v21, (atomic_ullong **)v22, v18);
    unsigned int v23 = v26;
    (*(void (**)(unint64_t, unint64_t, uint64_t))(v11 + 16))((v21 + v13) & v25, (v22 + v13) & v25, v5);
  }
  return v23;
}

uint64_t destroy for Slice(unint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), v3, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v5 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v6 = *(void (**)(unint64_t, const char *))(v5 + 8);
  uint64_t v7 = v5 + 8;
  v6(a1, AssociatedTypeWitness);
  uint64_t v8 = *(void *)(v7 + 56);
  unint64_t v9 = (v8 + a1 + *(unsigned __int8 *)(v7 + 72)) & ~(unint64_t)*(unsigned __int8 *)(v7 + 72);
  v6(v9, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v3 - 8);
  uint64_t v11 = *(uint64_t (**)(unint64_t, uint64_t))(v10 + 8);
  unint64_t v12 = (v9 + v8 + *(unsigned __int8 *)(v10 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80);

  return v11(v12, v3);
}

uint64_t initializeWithCopy for Slice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, const char *))(v7 + 16);
  uint64_t v9 = v7 + 16;
  v8(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 48);
  uint64_t v11 = *(unsigned __int8 *)(v9 + 64);
  uint64_t v12 = (v10 + v11 + a1) & ~v11;
  uint64_t v13 = (v10 + v11 + a2) & ~v11;
  v8(v12, v13, AssociatedTypeWitness);
  uint64_t v14 = *(void *)(v5 - 8);
  (*(void (**)(unint64_t, unint64_t, uint64_t))(v14 + 16))((v10 + *(unsigned __int8 *)(v14 + 80) + v12) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80), (v10 + *(unsigned __int8 *)(v14 + 80) + v13) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80), v5);
  return a1;
}

uint64_t assignWithCopy for Slice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, const char *))(v7 + 24);
  uint64_t v9 = v7 + 24;
  v8(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 40);
  uint64_t v11 = *(unsigned __int8 *)(v9 + 56);
  uint64_t v12 = (v10 + v11 + a1) & ~v11;
  uint64_t v13 = (v10 + v11 + a2) & ~v11;
  v8(v12, v13, AssociatedTypeWitness);
  uint64_t v14 = *(void *)(v5 - 8);
  (*(void (**)(unint64_t, unint64_t, uint64_t))(v14 + 24))((v10 + *(unsigned __int8 *)(v14 + 80) + v12) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80), (v10 + *(unsigned __int8 *)(v14 + 80) + v13) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80), v5);
  return a1;
}

uint64_t initializeWithTake for Slice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, const char *))(v7 + 32);
  uint64_t v9 = v7 + 32;
  v8(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 32);
  uint64_t v11 = *(unsigned __int8 *)(v9 + 48);
  uint64_t v12 = (v10 + v11 + a1) & ~v11;
  uint64_t v13 = (v10 + v11 + a2) & ~v11;
  v8(v12, v13, AssociatedTypeWitness);
  uint64_t v14 = *(void *)(v5 - 8);
  (*(void (**)(unint64_t, unint64_t, uint64_t))(v14 + 32))((v10 + *(unsigned __int8 *)(v14 + 80) + v12) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80), (v10 + *(unsigned __int8 *)(v14 + 80) + v13) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80), v5);
  return a1;
}

uint64_t assignWithTake for Slice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, const char *))(v7 + 40);
  uint64_t v9 = v7 + 40;
  v8(a1, a2, AssociatedTypeWitness);
  uint64_t v10 = *(void *)(v9 + 24);
  uint64_t v11 = *(unsigned __int8 *)(v9 + 40);
  uint64_t v12 = (v10 + v11 + a1) & ~v11;
  uint64_t v13 = (v10 + v11 + a2) & ~v11;
  v8(v12, v13, AssociatedTypeWitness);
  uint64_t v14 = *(void *)(v5 - 8);
  (*(void (**)(unint64_t, unint64_t, uint64_t))(v14 + 40))((v10 + *(unsigned __int8 *)(v14 + 80) + v12) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80), (v10 + *(unsigned __int8 *)(v14 + 80) + v13) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80), v5);
  return a1;
}

uint64_t getEnumTagSinglePayload for Slice(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v5, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index)- 1);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  uint64_t v8 = *(void *)(v5 - 8);
  uint64_t v9 = *(unsigned int *)(v8 + 84);
  uint64_t v10 = *(void *)(v6 + 64);
  uint64_t v11 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v12 = *(unsigned __int8 *)(v8 + 80);
  if (v9 <= v7) {
    unsigned int v13 = *(_DWORD *)(v6 + 84);
  }
  else {
    unsigned int v13 = *(_DWORD *)(v8 + 84);
  }
  if (!a2) {
    return 0;
  }
  uint64_t v14 = v10 + v11;
  uint64_t v15 = v10 + v12;
  if (a2 <= v13) {
    goto LABEL_24;
  }
  uint64_t v16 = ((v15 + (v14 & ~v11)) & ~v12) + *(void *)(*(void *)(v5 - 8) + 64);
  char v17 = 8 * v16;
  if (v16 <= 3)
  {
    unsigned int v19 = ((a2 - v13 + ~(-1 << v17)) >> v17) + 1;
    if (HIWORD(v19))
    {
      int v18 = *(_DWORD *)((char *)a1 + v16);
      if (!v18) {
        goto LABEL_24;
      }
      goto LABEL_14;
    }
    if (v19 > 0xFF)
    {
      int v18 = *(unsigned __int16 *)((char *)a1 + v16);
      if (!*(unsigned __int16 *)((char *)a1 + v16)) {
        goto LABEL_24;
      }
      goto LABEL_14;
    }
    if (v19 < 2)
    {
LABEL_24:
      if (v13)
      {
        if (v7 >= v9)
        {
          uint64_t v25 = *(uint64_t (**)(unsigned __int16 *))(v6 + 48);
          return v25(a1);
        }
        else
        {
          unsigned int v23 = *(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v8 + 48);
          return v23((v15 + (((unint64_t)a1 + v14) & ~v11)) & ~v12, v9, v5);
        }
      }
      return 0;
    }
  }
  int v18 = *((unsigned __int8 *)a1 + v16);
  if (!*((unsigned char *)a1 + v16)) {
    goto LABEL_24;
  }
LABEL_14:
  int v20 = (v18 - 1) << v17;
  if (v16 > 3) {
    int v20 = 0;
  }
  if (v16)
  {
    if (v16 <= 3) {
      int v21 = ((v15 + (v14 & ~v11)) & ~v12) + *(_DWORD *)(*(void *)(v5 - 8) + 64);
    }
    else {
      int v21 = 4;
    }
    switch(v21)
    {
      case 2:
        int v22 = *a1;
        break;
      case 3:
        int v22 = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        int v22 = *(_DWORD *)a1;
        break;
      default:
        int v22 = *(unsigned __int8 *)a1;
        break;
    }
  }
  else
  {
    int v22 = 0;
  }
  return v13 + (v22 | v20) + 1;
}

void storeEnumTagSinglePayload for Slice(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v8 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 24), v7, (uint64_t)&protocol requirements base descriptor for Collection, associated type descriptor for Collection.Index)- 1);
  unsigned int v9 = *(_DWORD *)(v8 + 84);
  uint64_t v10 = *(void *)(v7 - 8);
  uint64_t v11 = *(unsigned int *)(v10 + 84);
  uint64_t v12 = *(void *)(v8 + 64);
  uint64_t v13 = *(unsigned __int8 *)(v8 + 80);
  uint64_t v14 = *(unsigned __int8 *)(v10 + 80);
  if (v11 <= v9) {
    unsigned int v15 = *(_DWORD *)(v8 + 84);
  }
  else {
    unsigned int v15 = *(_DWORD *)(v10 + 84);
  }
  uint64_t v16 = v12 + v13;
  uint64_t v17 = (v12 + v13) & ~v13;
  uint64_t v18 = v12 + v14;
  size_t v19 = ((v18 + v17) & ~v14) + *(void *)(*(void *)(v7 - 8) + 64);
  if (a3 <= v15)
  {
    int v20 = 0;
  }
  else if (v19 <= 3)
  {
    unsigned int v23 = ((a3 - v15 + ~(-1 << (8 * v19))) >> (8 * v19)) + 1;
    if (HIWORD(v23))
    {
      int v20 = 4;
    }
    else if (v23 >= 0x100)
    {
      int v20 = 2;
    }
    else
    {
      int v20 = v23 > 1;
    }
  }
  else
  {
    int v20 = 1;
  }
  if (v15 < a2)
  {
    unsigned int v21 = ~v15 + a2;
    if (v19 < 4)
    {
      int v22 = (v21 >> (8 * v19)) + 1;
      if (v19)
      {
        int v24 = v21 & ~(-1 << (8 * v19));
        bzero(a1, v19);
        if (v19 == 3)
        {
          *(_WORD *)a1 = v24;
          a1[2] = BYTE2(v24);
        }
        else if (v19 == 2)
        {
          *(_WORD *)a1 = v24;
        }
        else
        {
          *a1 = v24;
        }
      }
    }
    else
    {
      bzero(a1, v19);
      *(_DWORD *)a1 = v21;
      int v22 = 1;
    }
    switch(v20)
    {
      case 1:
        a1[v19] = v22;
        return;
      case 2:
        *(_WORD *)&a1[v19] = v22;
        return;
      case 3:
        goto LABEL_41;
      case 4:
        *(_DWORD *)&a1[v19] = v22;
        return;
      default:
        return;
    }
  }
  switch(v20)
  {
    case 1:
      a1[v19] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 2:
      *(_WORD *)&a1[v19] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 3:
LABEL_41:
      __break(1u);
      JUMPOUT(0x18151B5C4);
    case 4:
      *(_DWORD *)&a1[v19] = 0;
      goto LABEL_23;
    default:
LABEL_23:
      if (a2)
      {
LABEL_24:
        if (v9 >= v11)
        {
          unsigned int v26 = *(void (**)(unsigned char *, uint64_t))(v8 + 56);
          v26(a1, a2);
        }
        else
        {
          uint64_t v25 = *(void (**)(unint64_t, uint64_t, uint64_t, uint64_t))(v10 + 56);
          v25((v18 + ((unint64_t)&a1[v16] & ~v13)) & ~v14, a2, v11, v7);
        }
      }
      return;
  }
}

ValueMetadata *type metadata accessor for _SmallString()
{
  return &type metadata for _SmallString;
}

uint64_t getEnumTagSinglePayload for StaticString(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 17)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for StaticString(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(unsigned char *)(result + 16) = 0;
    *(void *)uint64_t result = (a2 - 1);
    *(void *)(result + 8) = 0;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 17) = v3;
  return result;
}

ValueMetadata *type metadata accessor for StaticString()
{
  return &type metadata for StaticString;
}

uint64_t dispatch thunk of Strideable.distance(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of Strideable.advanced(by:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 48))();
}

uint64_t dispatch thunk of static Strideable._step(after:from:by:)(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a8 + 56))(a1, a2, a3 & 1);
}

void *type metadata completion function for StrideToIterator(uint64_t a1)
{
  uint64_t v2 = swift_checkMetadataState(319, *(void *)(a1 + 16));
  char v3 = v2;
  if (v4 <= 0x3F)
  {
    uint64_t v5 = *(v2 - 1) + 64;
    v10[0] = v5;
    v10[1] = v5;
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(319, *(int ***)(a1 + 24), (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
    char v3 = (void *)AssociatedTypeWitness;
    if (v7 <= 0x3F)
    {
      void v10[2] = *((void *)AssociatedTypeWitness - 1) + 64;
      swift_getTupleTypeLayout2((uint64_t)v9, (uint64_t)"\t", v5);
      v10[3] = v9;
      swift_initStructMetadata(a1, 0, 4uLL, (uint64_t)v10, a1 + 32);
      return 0;
    }
  }
  return v3;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for StrideToIterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = *(void *)(v4 + 64);
  int v6 = *(_DWORD *)(v4 + 80);
  uint64_t v7 = v6;
  uint64_t v8 = v5 + v6;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v3, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = *(_DWORD *)(v10 + 80);
  uint64_t v12 = v5 + v11;
  uint64_t v13 = *(void *)(v10 + 64) + (v6 | 7);
  uint64_t v14 = v6 + 9;
  if ((v11 | (unint64_t)v6) > 7
    || ((*(_DWORD *)(v10 + 80) | v6) & 0x100000) != 0
    || ((v6 + 9) & ~(unint64_t)v6)
     + v5
     + ((v13 + ((v5 + v11 + ((v5 + v6) & ~(unint64_t)v6)) & ~v11)) & ~(v6 | 7)) > 0x18)
  {
    uint64_t v17 = *a2;
    *a1 = *a2;
    int v20 = (atomic_ullong **)((char *)v17
                           + (((v11 | v6) & 0xF8 ^ 0x1F8) & ((v11 | v6)
                                                                                          + 16)));
    swift_retain(v17);
  }
  else
  {
    uint64_t v29 = ~v11;
    int v30 = AssociatedTypeWitness;
    uint64_t v31 = ~(v6 | 7);
    unint64_t v32 = ~(unint64_t)v6;
    uint64_t v18 = *(void (**)(atomic_ullong **, atomic_ullong **, uint64_t))(v4 + 16);
    uint64_t v19 = v3;
    int v20 = a1;
    v18(a1, a2, v19);
    unint64_t v21 = ((unint64_t)a1 + v8) & ~v7;
    unint64_t v22 = ((unint64_t)a2 + v8) & v32;
    v18((atomic_ullong **)v21, (atomic_ullong **)v22, v19);
    unint64_t v23 = (v21 + v12) & v29;
    unint64_t v24 = (v22 + v12) & v29;
    (*(void (**)(unint64_t, unint64_t, const char *))(v10 + 16))(v23, v24, v30);
    uint64_t v25 = (v13 + v23) & v31;
    uint64_t v26 = (v13 + v24) & v31;
    char v27 = *(unsigned char *)(v26 + 8);
    *(void *)uint64_t v25 = *(void *)v26;
    *(unsigned char *)(v25 + 8) = v27;
    v18((atomic_ullong **)((v14 + v25) & v32), (atomic_ullong **)((v14 + v26) & v32), v19);
  }
  return v20;
}

uint64_t initializeWithCopy for StrideToIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 16);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v13 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v14 = v13 + 16;
  uint64_t v15 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v16 = (v9 + v15 + ((v9 + v10 + a1) & ~v10)) & ~v15;
  uint64_t v17 = (v9 + v15 + v11) & ~v15;
  (*(void (**)(uint64_t, uint64_t, const char *))(v13 + 16))(v16, v17, AssociatedTypeWitness);
  uint64_t v18 = *(void *)(v14 + 48) + (v10 | 7);
  uint64_t v19 = (v18 + v16) & ~(v10 | 7);
  uint64_t v20 = (v18 + v17) & ~(v10 | 7);
  char v21 = *(unsigned char *)(v20 + 8);
  *(void *)uint64_t v19 = *(void *)v20;
  *(unsigned char *)(v19 + 8) = v21;
  v8((v10 + 9 + v19) & ~v10, (v10 + 9 + v20) & ~v10, v6);
  return a1;
}

uint64_t assignWithCopy for StrideToIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 24);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v13 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v14 = v13 + 24;
  uint64_t v15 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v16 = (v9 + v15 + ((v9 + v10 + a1) & ~v10)) & ~v15;
  uint64_t v17 = (v9 + v15 + v11) & ~v15;
  (*(void (**)(uint64_t, uint64_t, const char *))(v13 + 24))(v16, v17, AssociatedTypeWitness);
  uint64_t v18 = *(void *)(v14 + 40) + (v10 | 7);
  uint64_t v19 = (v18 + v16) & ~(v10 | 7);
  uint64_t v20 = (v18 + v17) & ~(v10 | 7);
  char v21 = *(unsigned char *)(v20 + 8);
  *(void *)uint64_t v19 = *(void *)v20;
  *(unsigned char *)(v19 + 8) = v21;
  v8((v10 + 9 + v19) & ~v10, (v10 + 9 + v20) & ~v10, v6);
  return a1;
}

uint64_t initializeWithTake for StrideToIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v13 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v14 = v13 + 32;
  uint64_t v15 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v16 = (v9 + v15 + ((v9 + v10 + a1) & ~v10)) & ~v15;
  uint64_t v17 = (v9 + v15 + v11) & ~v15;
  (*(void (**)(uint64_t, uint64_t, const char *))(v13 + 32))(v16, v17, AssociatedTypeWitness);
  uint64_t v18 = *(void *)(v14 + 32) + (v10 | 7);
  uint64_t v19 = (v18 + v16) & ~(v10 | 7);
  uint64_t v20 = (v18 + v17) & ~(v10 | 7);
  char v21 = *(unsigned char *)(v20 + 8);
  *(void *)uint64_t v19 = *(void *)v20;
  *(unsigned char *)(v19 + 8) = v21;
  v8((v10 + 9 + v19) & ~v10, (v10 + 9 + v20) & ~v10, v6);
  return a1;
}

uint64_t assignWithTake for StrideToIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 40);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v13 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v14 = v13 + 40;
  uint64_t v15 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v16 = (v9 + v15 + ((v9 + v10 + a1) & ~v10)) & ~v15;
  uint64_t v17 = (v9 + v15 + v11) & ~v15;
  (*(void (**)(uint64_t, uint64_t, const char *))(v13 + 40))(v16, v17, AssociatedTypeWitness);
  uint64_t v18 = *(void *)(v14 + 24) + (v10 | 7);
  uint64_t v19 = (v18 + v16) & ~(v10 | 7);
  uint64_t v20 = (v18 + v17) & ~(v10 | 7);
  char v21 = *(unsigned char *)(v20 + 8);
  *(void *)uint64_t v19 = *(void *)v20;
  *(unsigned char *)(v19 + 8) = v21;
  v8((v10 + 9 + v19) & ~v10, (v10 + 9 + v20) & ~v10, v6);
  return a1;
}

uint64_t getEnumTagSinglePayload for StrideToIterator(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(unsigned int *)(v6 + 84);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v5, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  unsigned int v10 = *(_DWORD *)(v9 + 84);
  uint64_t v11 = *(void *)(v6 + 64);
  uint64_t v12 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v13 = *(unsigned __int8 *)(v9 + 80);
  if (v10 <= v7) {
    unsigned int v14 = v7;
  }
  else {
    unsigned int v14 = *(_DWORD *)(v9 + 84);
  }
  if (!a2) {
    return 0;
  }
  uint64_t v15 = v11 + v12;
  if (a2 <= v14) {
    goto LABEL_24;
  }
  uint64_t v16 = ((v12 + 9) & ~v12)
      + v11
      + (((v12 | 7) + *(void *)(*((void *)AssociatedTypeWitness - 1) + 64) + ((v11 + v13 + (v15 & ~v12)) & ~v13)) & ~(v12 | 7));
  char v17 = 8 * v16;
  if (v16 <= 3)
  {
    unsigned int v19 = ((a2 - v14 + ~(-1 << v17)) >> v17) + 1;
    if (HIWORD(v19))
    {
      int v18 = *(_DWORD *)((char *)a1 + v16);
      if (!v18) {
        goto LABEL_24;
      }
      goto LABEL_14;
    }
    if (v19 > 0xFF)
    {
      int v18 = *(unsigned __int16 *)((char *)a1 + v16);
      if (!*(unsigned __int16 *)((char *)a1 + v16)) {
        goto LABEL_24;
      }
      goto LABEL_14;
    }
    if (v19 < 2)
    {
LABEL_24:
      if (v14)
      {
        if (v7 >= v10)
        {
          uint64_t v25 = *(uint64_t (**)(unsigned __int16 *, uint64_t, uint64_t))(v6 + 48);
          return v25(a1, v7, v5);
        }
        else
        {
          unint64_t v23 = *(uint64_t (**)(unint64_t))(v9 + 48);
          return v23(((((unint64_t)a1 + v15) & ~v12) + v11 + v13) & ~v13);
        }
      }
      return 0;
    }
  }
  int v18 = *((unsigned __int8 *)a1 + v16);
  if (!*((unsigned char *)a1 + v16)) {
    goto LABEL_24;
  }
LABEL_14:
  int v20 = (v18 - 1) << v17;
  if (v16 > 3) {
    int v20 = 0;
  }
  if (v16)
  {
    if (v16 <= 3) {
      int v21 = v16;
    }
    else {
      int v21 = 4;
    }
    switch(v21)
    {
      case 2:
        int v22 = *a1;
        break;
      case 3:
        int v22 = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        int v22 = *(_DWORD *)a1;
        break;
      default:
        int v22 = *(unsigned __int8 *)a1;
        break;
    }
  }
  else
  {
    int v22 = 0;
  }
  return v14 + (v22 | v20) + 1;
}

void storeEnumTagSinglePayload for StrideToIterator(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v27 = v8;
  uint64_t v9 = *(unsigned int *)(v8 + 84);
  uint64_t v10 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 24), v7, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride)- 1);
  uint64_t v11 = v10;
  unsigned int v12 = *(_DWORD *)(v10 + 84);
  if (v12 <= v9) {
    unsigned int v13 = v9;
  }
  else {
    unsigned int v13 = *(_DWORD *)(v10 + 84);
  }
  uint64_t v14 = *(void *)(v8 + 64);
  uint64_t v15 = *(unsigned __int8 *)(v8 + 80);
  uint64_t v16 = v14 + v15;
  uint64_t v17 = *(unsigned __int8 *)(v10 + 80);
  size_t v18 = ((v15 + 9) & ~v15)
      + v14
      + (((v15 | 7) + *(void *)(v10 + 64) + ((v14 + v17 + ((v14 + v15) & ~v15)) & ~v17)) & ~(v15 | 7));
  if (a3 <= v13)
  {
    int v19 = 0;
  }
  else if (v18 <= 3)
  {
    unsigned int v23 = ((a3 - v13 + ~(-1 << (8 * v18))) >> (8 * v18)) + 1;
    if (HIWORD(v23))
    {
      int v19 = 4;
    }
    else if (v23 >= 0x100)
    {
      int v19 = 2;
    }
    else
    {
      int v19 = v23 > 1;
    }
  }
  else
  {
    int v19 = 1;
  }
  if (v13 < a2)
  {
    unsigned int v20 = ~v13 + a2;
    if (v18 < 4)
    {
      int v21 = (v20 >> (8 * v18)) + 1;
      if (v18)
      {
        int v24 = v20 & ~(-1 << (8 * v18));
        bzero(a1, v18);
        if (v18 == 3)
        {
          *(_WORD *)a1 = v24;
          a1[2] = BYTE2(v24);
        }
        else if (v18 == 2)
        {
          *(_WORD *)a1 = v24;
        }
        else
        {
          *a1 = v24;
        }
      }
    }
    else
    {
      bzero(a1, v18);
      *(_DWORD *)a1 = v20;
      int v21 = 1;
    }
    switch(v19)
    {
      case 1:
        a1[v18] = v21;
        return;
      case 2:
        *(_WORD *)&a1[v18] = v21;
        return;
      case 3:
        goto LABEL_41;
      case 4:
        *(_DWORD *)&a1[v18] = v21;
        return;
      default:
        return;
    }
  }
  uint64_t v22 = ~v15;
  switch(v19)
  {
    case 1:
      a1[v18] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 2:
      *(_WORD *)&a1[v18] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 3:
LABEL_41:
      __break(1u);
      JUMPOUT(0x18151C604);
    case 4:
      *(_DWORD *)&a1[v18] = 0;
      goto LABEL_23;
    default:
LABEL_23:
      if (a2)
      {
LABEL_24:
        if (v9 >= v12)
        {
          uint64_t v26 = *(void (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(v27 + 56);
          v26(a1, a2, v9, v7);
        }
        else
        {
          uint64_t v25 = *(void (**)(unint64_t, uint64_t))(v11 + 56);
          v25((((unint64_t)&a1[v16] & v22) + v14 + v17) & ~v17, a2);
        }
      }
      return;
  }
}

void *type metadata instantiation function for StrideThroughIterator(_DWORD *a1, const void *a2, uint64_t a3)
{
  return swift_allocateGenericValueMetadata(a1, a2, a3, 48);
}

void *type metadata completion function for StrideThroughIterator(uint64_t a1)
{
  uint64_t v2 = swift_checkMetadataState(319, *(void *)(a1 + 16));
  uint64_t v3 = v2;
  if (v4 <= 0x3F)
  {
    uint64_t v5 = *(v2 - 1) + 64;
    v10[0] = v5;
    v10[1] = v5;
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(319, *(int ***)(a1 + 24), (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
    uint64_t v3 = (void *)AssociatedTypeWitness;
    if (v7 <= 0x3F)
    {
      void v10[2] = *((void *)AssociatedTypeWitness - 1) + 64;
      swift_getTupleTypeLayout2((uint64_t)v9, (uint64_t)"\t", v5);
      v10[3] = v9;
      void v10[4] = &unk_1816333A8;
      swift_initStructMetadata(a1, 0, 5uLL, (uint64_t)v10, a1 + 32);
      return 0;
    }
  }
  return v3;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for StrideThroughIterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = *(void *)(v4 + 64);
  int v6 = *(_DWORD *)(v4 + 80);
  uint64_t v7 = v5 + v6;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v3, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = *(_DWORD *)(v9 + 80);
  uint64_t v11 = v5 + v10;
  uint64_t v12 = *(void *)(v9 + 64) + (v6 | 7);
  uint64_t v13 = ((v6 + 9) & ~(unint64_t)v6) + v5;
  if ((v10 | (unint64_t)v6) > 7
    || ((*(_DWORD *)(v9 + 80) | v6) & 0x100000) != 0
    || v13
     + ((v12 + ((v5 + v10 + ((v5 + v6) & ~(unint64_t)v6)) & ~v10)) & ~(v6 | 7))
     + 1 > 0x18)
  {
    uint64_t v16 = *a2;
    *a1 = *a2;
    uint64_t v27 = (atomic_ullong **)((char *)v16
                           + (((v10 | v6) & 0xF8 ^ 0x1F8) & ((v10 | v6)
                                                                                          + 16)));
    swift_retain(v16);
  }
  else
  {
    unint64_t v17 = ~(unint64_t)v6;
    uint64_t v29 = ~v10;
    int v30 = AssociatedTypeWitness;
    uint64_t v32 = ~(v6 | 7);
    uint64_t v33 = v13;
    size_t v18 = *(void (**)(atomic_ullong **, atomic_ullong **, uint64_t))(v4 + 16);
    uint64_t v31 = v6 + 9;
    v18(a1, a2, v3);
    unint64_t v19 = ((unint64_t)a1 + v7) & v17;
    unint64_t v20 = ((unint64_t)a2 + v7) & v17;
    v18((atomic_ullong **)v19, (atomic_ullong **)v20, v3);
    unint64_t v21 = (v19 + v11) & v29;
    unint64_t v22 = (v20 + v11) & v29;
    (*(void (**)(unint64_t, unint64_t, const char *))(v9 + 16))(v21, v22, v30);
    uint64_t v23 = (v12 + v21) & v32;
    uint64_t v24 = (v12 + v22) & v32;
    char v25 = *(unsigned char *)(v24 + 8);
    *(void *)uint64_t v23 = *(void *)v24;
    *(unsigned char *)(v23 + 8) = v25;
    v18((atomic_ullong **)((v31 + v23) & v17), (atomic_ullong **)((v31 + v24) & v17), v3);
    char v26 = *(unsigned char *)(v24 + v33);
    uint64_t v27 = a1;
    *(unsigned char *)(v23 + v33) = v26;
  }
  return v27;
}

uint64_t destroy for StrideToIterator(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 8);
  v15(a1, v4);
  uint64_t v6 = *(void *)(v5 + 64);
  uint64_t v7 = *(unsigned __int8 *)(v5 + 80);
  uint64_t v8 = (v6 + a1 + v7) & ~v7;
  v15(v8, v4);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), v4, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = v10 + 8;
  unint64_t v12 = (v8 + v6 + *(unsigned __int8 *)(v10 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80);
  (*(void (**)(unint64_t, const char *))(v10 + 8))(v12, AssociatedTypeWitness);
  uint64_t v13 = (v7 + ((*(void *)(v11 + 56) + (v7 | 7) + v12) & ~(v7 | 7)) + 9) & ~v7;

  return v15(v13, v4);
}

uint64_t initializeWithCopy for StrideThroughIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 16);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v13 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v14 = v13 + 16;
  uint64_t v15 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v16 = (v9 + v15 + ((v9 + v10 + a1) & ~v10)) & ~v15;
  uint64_t v17 = (v9 + v15 + v11) & ~v15;
  (*(void (**)(uint64_t, uint64_t, const char *))(v13 + 16))(v16, v17, AssociatedTypeWitness);
  uint64_t v18 = *(void *)(v14 + 48) + (v10 | 7);
  uint64_t v19 = (v18 + v16) & ~(v10 | 7);
  uint64_t v20 = (v18 + v17) & ~(v10 | 7);
  LOBYTE(v18) = *(unsigned char *)(v20 + 8);
  *(void *)uint64_t v19 = *(void *)v20;
  *(unsigned char *)(v19 + 8) = v18;
  v8((v10 + 9 + v19) & ~v10, (v10 + 9 + v20) & ~v10, v6);
  *(unsigned char *)(v19 + ((v10 + 9) & ~v10) + v9) = *(unsigned char *)(v20 + ((v10 + 9) & ~v10) + v9);
  return a1;
}

uint64_t assignWithCopy for StrideThroughIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 24);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v13 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v14 = v13 + 24;
  uint64_t v15 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v16 = (v9 + v15 + ((v9 + v10 + a1) & ~v10)) & ~v15;
  uint64_t v17 = (v9 + v15 + v11) & ~v15;
  (*(void (**)(uint64_t, uint64_t, const char *))(v13 + 24))(v16, v17, AssociatedTypeWitness);
  uint64_t v18 = *(void *)(v14 + 40) + (v10 | 7);
  uint64_t v19 = (v18 + v16) & ~(v10 | 7);
  uint64_t v20 = (v18 + v17) & ~(v10 | 7);
  LOBYTE(v18) = *(unsigned char *)(v20 + 8);
  *(void *)uint64_t v19 = *(void *)v20;
  *(unsigned char *)(v19 + 8) = v18;
  v8((v10 + 9 + v19) & ~v10, (v10 + 9 + v20) & ~v10, v6);
  *(unsigned char *)(v19 + ((v10 + 9) & ~v10) + v9) = *(unsigned char *)(v20 + ((v10 + 9) & ~v10) + v9);
  return a1;
}

uint64_t initializeWithTake for StrideThroughIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v13 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v14 = v13 + 32;
  uint64_t v15 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v16 = (v9 + v15 + ((v9 + v10 + a1) & ~v10)) & ~v15;
  uint64_t v17 = (v9 + v15 + v11) & ~v15;
  (*(void (**)(uint64_t, uint64_t, const char *))(v13 + 32))(v16, v17, AssociatedTypeWitness);
  uint64_t v18 = *(void *)(v14 + 32) + (v10 | 7);
  uint64_t v19 = (v18 + v16) & ~(v10 | 7);
  uint64_t v20 = (v18 + v17) & ~(v10 | 7);
  LOBYTE(v18) = *(unsigned char *)(v20 + 8);
  *(void *)uint64_t v19 = *(void *)v20;
  *(unsigned char *)(v19 + 8) = v18;
  v8((v10 + 9 + v19) & ~v10, (v10 + 9 + v20) & ~v10, v6);
  *(unsigned char *)(v19 + ((v10 + 9) & ~v10) + v9) = *(unsigned char *)(v20 + ((v10 + 9) & ~v10) + v9);
  return a1;
}

uint64_t assignWithTake for StrideThroughIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  uint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 40);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a2) & ~v10;
  v8((v9 + v10 + a1) & ~v10, v11, v6);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v13 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v14 = v13 + 40;
  uint64_t v15 = *(unsigned __int8 *)(v13 + 80);
  uint64_t v16 = (v9 + v15 + ((v9 + v10 + a1) & ~v10)) & ~v15;
  uint64_t v17 = (v9 + v15 + v11) & ~v15;
  (*(void (**)(uint64_t, uint64_t, const char *))(v13 + 40))(v16, v17, AssociatedTypeWitness);
  uint64_t v18 = *(void *)(v14 + 24) + (v10 | 7);
  uint64_t v19 = (v18 + v16) & ~(v10 | 7);
  uint64_t v20 = (v18 + v17) & ~(v10 | 7);
  LOBYTE(v18) = *(unsigned char *)(v20 + 8);
  *(void *)uint64_t v19 = *(void *)v20;
  *(unsigned char *)(v19 + 8) = v18;
  v8((v10 + 9 + v19) & ~v10, (v10 + 9 + v20) & ~v10, v6);
  *(unsigned char *)(v19 + ((v10 + 9) & ~v10) + v9) = *(unsigned char *)(v20 + ((v10 + 9) & ~v10) + v9);
  return a1;
}

uint64_t getEnumTagSinglePayload for StrideThroughIterator(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(unsigned int *)(v6 + 84);
  uint64_t v8 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v5, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride)- 1);
  uint64_t v9 = v8;
  unsigned int v10 = *(_DWORD *)(v8 + 84);
  if (v10 <= v7) {
    unsigned int v11 = v7;
  }
  else {
    unsigned int v11 = *(_DWORD *)(v8 + 84);
  }
  uint64_t v12 = *(void *)(v6 + 64);
  uint64_t v13 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v14 = *(unsigned __int8 *)(v8 + 80);
  uint64_t v15 = *(void *)(v8 + 64);
  if (v11 <= 0xFE) {
    unsigned int v16 = 254;
  }
  else {
    unsigned int v16 = v11;
  }
  if (!a2) {
    return 0;
  }
  uint64_t v17 = v12 + v13;
  uint64_t v18 = v13 | 7;
  uint64_t v19 = (v13 | 7) + v15;
  uint64_t v20 = ((v13 + 9) & ~v13) + v12;
  if (a2 > v16)
  {
    uint64_t v21 = v20 + ((v19 + ((v12 + v14 + (v17 & ~v13)) & ~v14)) & ~v18) + 1;
    char v22 = 8 * v21;
    if (v21 > 3) {
      goto LABEL_10;
    }
    unsigned int v24 = ((a2 - v16 + ~(-1 << v22)) >> v22) + 1;
    if (HIWORD(v24))
    {
      int v23 = *(_DWORD *)((char *)a1 + v21);
      if (!v23) {
        goto LABEL_27;
      }
      goto LABEL_17;
    }
    if (v24 > 0xFF)
    {
      int v23 = *(unsigned __int16 *)((char *)a1 + v21);
      if (!*(unsigned __int16 *)((char *)a1 + v21)) {
        goto LABEL_27;
      }
      goto LABEL_17;
    }
    if (v24 >= 2)
    {
LABEL_10:
      int v23 = *((unsigned __int8 *)a1 + v21);
      if (!*((unsigned char *)a1 + v21)) {
        goto LABEL_27;
      }
LABEL_17:
      int v25 = (v23 - 1) << v22;
      if (v21 > 3) {
        int v25 = 0;
      }
      if (v21)
      {
        if (v21 <= 3) {
          int v26 = v21;
        }
        else {
          int v26 = 4;
        }
        switch(v26)
        {
          case 2:
            int v27 = *a1;
            break;
          case 3:
            int v27 = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
            break;
          case 4:
            int v27 = *(_DWORD *)a1;
            break;
          default:
            int v27 = *(unsigned __int8 *)a1;
            break;
        }
      }
      else
      {
        int v27 = 0;
      }
      int v33 = v16 + (v27 | v25);
      return (v33 + 1);
    }
  }
LABEL_27:
  if (v7 == v16)
  {
    int v28 = *(uint64_t (**)(unsigned __int16 *, uint64_t, uint64_t))(v6 + 48);
    return v28(a1, v7, v5);
  }
  unint64_t v30 = ((((unint64_t)a1 + v17) & ~v13) + v12 + v14) & ~v14;
  if (v10 != v16)
  {
    unsigned int v32 = *(unsigned __int8 *)(((v19 + v30) & ~v18) + v20);
    if (v32 < 2) {
      return 0;
    }
    int v33 = (v32 + 2147483646) & 0x7FFFFFFF;
    return (v33 + 1);
  }
  uint64_t v31 = *(uint64_t (**)(unint64_t))(v9 + 48);

  return v31(v30);
}

void storeEnumTagSinglePayload for StrideThroughIterator(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v30 = v8;
  uint64_t v9 = *(unsigned int *)(v8 + 84);
  uint64_t v10 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 24), v7, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride)- 1);
  uint64_t v11 = v10;
  unsigned int v12 = *(_DWORD *)(v10 + 84);
  if (v12 <= v9) {
    unsigned int v13 = v9;
  }
  else {
    unsigned int v13 = *(_DWORD *)(v10 + 84);
  }
  uint64_t v14 = *(void *)(v8 + 64);
  uint64_t v15 = *(unsigned __int8 *)(v8 + 80);
  uint64_t v16 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v17 = *(void *)(v10 + 64);
  if (v13 <= 0xFE) {
    unsigned int v18 = 254;
  }
  else {
    unsigned int v18 = v13;
  }
  uint64_t v19 = (v15 | 7) + v17;
  uint64_t v20 = ((v15 + 9) & ~v15) + v14;
  size_t v21 = v20 + ((v19 + ((v14 + v16 + ((v14 + v15) & ~v15)) & ~v16)) & ~(v15 | 7)) + 1;
  if (a3 <= v18)
  {
    int v22 = 0;
  }
  else if (v21 <= 3)
  {
    unsigned int v25 = ((a3 - v18 + ~(-1 << (8 * v21))) >> (8 * v21)) + 1;
    if (HIWORD(v25))
    {
      int v22 = 4;
    }
    else if (v25 >= 0x100)
    {
      int v22 = 2;
    }
    else
    {
      int v22 = v25 > 1;
    }
  }
  else
  {
    int v22 = 1;
  }
  if (v18 < a2)
  {
    unsigned int v23 = ~v18 + a2;
    if (v21 < 4)
    {
      int v24 = (v23 >> (8 * v21)) + 1;
      if (v20
         + ((v19 + ((v14 + v16 + ((v14 + v15) & ~v15)) & ~v16)) & ~(v15 | 7)) != -1)
      {
        int v26 = v23 & ~(-1 << (8 * v21));
        bzero(a1, v21);
        if (v21 == 3)
        {
          *(_WORD *)a1 = v26;
          a1[2] = BYTE2(v26);
        }
        else if (v21 == 2)
        {
          *(_WORD *)a1 = v26;
        }
        else
        {
          *a1 = v26;
        }
      }
    }
    else
    {
      bzero(a1, v21);
      *(_DWORD *)a1 = v23;
      int v24 = 1;
    }
    switch(v22)
    {
      case 1:
        a1[v21] = v24;
        return;
      case 2:
        *(_WORD *)&a1[v21] = v24;
        return;
      case 3:
        goto LABEL_46;
      case 4:
        *(_DWORD *)&a1[v21] = v24;
        return;
      default:
        return;
    }
  }
  switch(v22)
  {
    case 1:
      a1[v21] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_27;
    case 2:
      *(_WORD *)&a1[v21] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_27;
    case 3:
LABEL_46:
      __break(1u);
      JUMPOUT(0x18151D7A8);
    case 4:
      *(_DWORD *)&a1[v21] = 0;
      goto LABEL_26;
    default:
LABEL_26:
      if (a2)
      {
LABEL_27:
        if (v9 == v18)
        {
          int v27 = *(void (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(v30 + 56);
          v27(a1, a2, v9, v7);
        }
        else
        {
          unint64_t v28 = (((unint64_t)&a1[v14 + v15] & ~v15) + v14 + v16) & ~v16;
          if (v12 == v18)
          {
            uint64_t v29 = *(void (**)(unint64_t, uint64_t))(v11 + 56);
            v29(v28, a2);
          }
          else
          {
            *(unsigned char *)(((v19 + v28) & ~(v15 | 7)) + v20) = a2 + 1;
          }
        }
      }
      return;
  }
}

void *type metadata completion function for StrideTo(uint64_t a1)
{
  uint64_t v2 = swift_checkMetadataState(319, *(void *)(a1 + 16));
  uint64_t v3 = v2;
  if (v4 <= 0x3F)
  {
    v8[0] = *(v2 - 1) + 64;
    v8[1] = v8[0];
    AssociatedTypeWitness = swift_getAssociatedTypeWitness(319, *(int ***)(a1 + 24), (uint64_t)v2, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
    uint64_t v3 = (void *)AssociatedTypeWitness;
    if (v6 <= 0x3F)
    {
      void v8[2] = *((void *)AssociatedTypeWitness - 1) + 64;
      swift_initStructMetadata(a1, 0, 3uLL, (uint64_t)v8, a1 + 32);
      return 0;
    }
  }
  return v3;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for StrideTo(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void *)(v6 + 64);
  int v8 = *(_DWORD *)(v6 + 80);
  uint64_t v9 = v7 + v8;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v5, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v11 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = *(_DWORD *)(v11 + 80);
  uint64_t v13 = v7 + v12;
  if ((v12 | (unint64_t)v8) > 7
    || ((*(_DWORD *)(v11 + 80) | v8) & 0x100000) != 0
    || ((v13 + (v9 & ~(unint64_t)v8)) & ~v12)
     + *(void *)(*((void *)AssociatedTypeWitness - 1) + 64) > 0x18)
  {
    uint64_t v16 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v16 + (((v12 | v8) + 16) & ~(v12 | v8)));
    swift_retain(v16);
  }
  else
  {
    uint64_t v21 = ~v12;
    int v22 = AssociatedTypeWitness;
    uint64_t v17 = *(void (**)(atomic_ullong **, atomic_ullong **, uint64_t))(v6 + 16);
    v17(a1, a2, v5);
    unint64_t v18 = ((unint64_t)a1 + v9) & ~(unint64_t)v8;
    unint64_t v19 = ((unint64_t)a2 + v9) & ~(unint64_t)v8;
    v17((atomic_ullong **)v18, (atomic_ullong **)v19, v5);
    (*(void (**)(unint64_t, unint64_t, const char *))(v11 + 16))((v18 + v13) & v21, (v19 + v13) & v21, v22);
  }
  return a1;
}

uint64_t destroy for StrideTo(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = *(void (**)(uint64_t, uint64_t))(v5 + 8);
  v6(a1, v4);
  uint64_t v7 = *(void *)(v5 + 64);
  unint64_t v8 = (v7 + a1 + *(unsigned __int8 *)(v5 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80);
  v6(v8, v4);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), v4, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = *(uint64_t (**)(unint64_t, const char *))(v10 + 8);
  uint64_t v12 = AssociatedTypeWitness;
  unint64_t v13 = (v8 + v7 + *(unsigned __int8 *)(v10 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v10 + 80);

  return v11(v13, v12);
}

uint64_t initializeWithCopy for StrideTo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  unint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 16);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a1) & ~v10;
  uint64_t v12 = (v9 + v10 + a2) & ~v10;
  v8(v11, v12, v6);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v14 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v14 + 16))((v9 + *(unsigned __int8 *)(v14 + 80) + v11) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80), (v9 + *(unsigned __int8 *)(v14 + 80) + v12) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for StrideTo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  unint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 24);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a1) & ~v10;
  uint64_t v12 = (v9 + v10 + a2) & ~v10;
  v8(v11, v12, v6);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v14 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v14 + 24))((v9 + *(unsigned __int8 *)(v14 + 80) + v11) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80), (v9 + *(unsigned __int8 *)(v14 + 80) + v12) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for StrideTo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  unint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 32);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a1) & ~v10;
  uint64_t v12 = (v9 + v10 + a2) & ~v10;
  v8(v11, v12, v6);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v14 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v14 + 32))((v9 + *(unsigned __int8 *)(v14 + 80) + v11) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80), (v9 + *(unsigned __int8 *)(v14 + 80) + v12) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for StrideTo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16);
  uint64_t v7 = *(void *)(v6 - 8);
  unint64_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(v7 + 40);
  v8(a1, a2, v6);
  uint64_t v9 = *(void *)(v7 + 64);
  uint64_t v10 = *(unsigned __int8 *)(v7 + 80);
  uint64_t v11 = (v9 + v10 + a1) & ~v10;
  uint64_t v12 = (v9 + v10 + a2) & ~v10;
  v8(v11, v12, v6);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v6, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v14 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v14 + 40))((v9 + *(unsigned __int8 *)(v14 + 80) + v11) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80), (v9 + *(unsigned __int8 *)(v14 + 80) + v12) & ~(unint64_t)*(unsigned __int8 *)(v14 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for StrideTo(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(unsigned int *)(v6 + 84);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), v5, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  unsigned int v10 = *(_DWORD *)(v9 + 84);
  uint64_t v11 = *(void *)(v6 + 64);
  uint64_t v12 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v13 = *(unsigned __int8 *)(v9 + 80);
  if (v10 <= v7) {
    unsigned int v14 = v7;
  }
  else {
    unsigned int v14 = *(_DWORD *)(v9 + 84);
  }
  if (!a2) {
    return 0;
  }
  uint64_t v15 = v11 + v12;
  if (a2 <= v14) {
    goto LABEL_24;
  }
  uint64_t v16 = ((v11 + v13 + (v15 & ~v12)) & ~v13) + *(void *)(*((void *)AssociatedTypeWitness - 1) + 64);
  char v17 = 8 * v16;
  if (v16 <= 3)
  {
    unsigned int v19 = ((a2 - v14 + ~(-1 << v17)) >> v17) + 1;
    if (HIWORD(v19))
    {
      int v18 = *(_DWORD *)((char *)a1 + v16);
      if (!v18) {
        goto LABEL_24;
      }
      goto LABEL_14;
    }
    if (v19 > 0xFF)
    {
      int v18 = *(unsigned __int16 *)((char *)a1 + v16);
      if (!*(unsigned __int16 *)((char *)a1 + v16)) {
        goto LABEL_24;
      }
      goto LABEL_14;
    }
    if (v19 < 2)
    {
LABEL_24:
      if (v14)
      {
        if (v7 >= v10)
        {
          unsigned int v25 = *(uint64_t (**)(unsigned __int16 *, uint64_t, uint64_t))(v6 + 48);
          return v25(a1, v7, v5);
        }
        else
        {
          unsigned int v23 = *(uint64_t (**)(unint64_t))(v9 + 48);
          return v23(((((unint64_t)a1 + v15) & ~v12) + v11 + v13) & ~v13);
        }
      }
      return 0;
    }
  }
  int v18 = *((unsigned __int8 *)a1 + v16);
  if (!*((unsigned char *)a1 + v16)) {
    goto LABEL_24;
  }
LABEL_14:
  int v20 = (v18 - 1) << v17;
  if (v16 > 3) {
    int v20 = 0;
  }
  if (v16)
  {
    if (v16 <= 3) {
      int v21 = v16;
    }
    else {
      int v21 = 4;
    }
    switch(v21)
    {
      case 2:
        int v22 = *a1;
        break;
      case 3:
        int v22 = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        int v22 = *(_DWORD *)a1;
        break;
      default:
        int v22 = *(unsigned __int8 *)a1;
        break;
    }
  }
  else
  {
    int v22 = 0;
  }
  return v14 + (v22 | v20) + 1;
}

void storeEnumTagSinglePayload for StrideTo(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a4 + 16);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v27 = v8;
  uint64_t v9 = *(unsigned int *)(v8 + 84);
  uint64_t v10 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 24), v7, (uint64_t)&protocol requirements base descriptor for Strideable, associated type descriptor for Strideable.Stride)- 1);
  uint64_t v11 = v10;
  unsigned int v12 = *(_DWORD *)(v10 + 84);
  if (v12 <= v9) {
    unsigned int v13 = v9;
  }
  else {
    unsigned int v13 = *(_DWORD *)(v10 + 84);
  }
  uint64_t v14 = *(void *)(v8 + 64);
  uint64_t v15 = *(unsigned __int8 *)(v8 + 80);
  uint64_t v16 = v14 + v15;
  uint64_t v17 = *(unsigned __int8 *)(v10 + 80);
  size_t v18 = ((v14 + v17 + ((v14 + v15) & ~v15)) & ~v17) + *(void *)(v10 + 64);
  if (a3 <= v13)
  {
    int v19 = 0;
  }
  else if (v18 <= 3)
  {
    unsigned int v23 = ((a3 - v13 + ~(-1 << (8 * v18))) >> (8 * v18)) + 1;
    if (HIWORD(v23))
    {
      int v19 = 4;
    }
    else if (v23 >= 0x100)
    {
      int v19 = 2;
    }
    else
    {
      int v19 = v23 > 1;
    }
  }
  else
  {
    int v19 = 1;
  }
  if (v13 < a2)
  {
    unsigned int v20 = ~v13 + a2;
    if (v18 < 4)
    {
      int v21 = (v20 >> (8 * v18)) + 1;
      if (v18)
      {
        int v24 = v20 & ~(-1 << (8 * v18));
        bzero(a1, v18);
        if (v18 == 3)
        {
          *(_WORD *)a1 = v24;
          a1[2] = BYTE2(v24);
        }
        else if (v18 == 2)
        {
          *(_WORD *)a1 = v24;
        }
        else
        {
          *a1 = v24;
        }
      }
    }
    else
    {
      bzero(a1, v18);
      *(_DWORD *)a1 = v20;
      int v21 = 1;
    }
    switch(v19)
    {
      case 1:
        a1[v18] = v21;
        return;
      case 2:
        *(_WORD *)&a1[v18] = v21;
        return;
      case 3:
        goto LABEL_41;
      case 4:
        *(_DWORD *)&a1[v18] = v21;
        return;
      default:
        return;
    }
  }
  uint64_t v22 = ~v15;
  switch(v19)
  {
    case 1:
      a1[v18] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 2:
      *(_WORD *)&a1[v18] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 3:
LABEL_41:
      __break(1u);
      JUMPOUT(0x18151E59CLL);
    case 4:
      *(_DWORD *)&a1[v18] = 0;
      goto LABEL_23;
    default:
LABEL_23:
      if (a2)
      {
LABEL_24:
        if (v9 >= v12)
        {
          int v26 = *(void (**)(unsigned char *, uint64_t, uint64_t, uint64_t))(v27 + 56);
          v26(a1, a2, v9, v7);
        }
        else
        {
          unsigned int v25 = *(void (**)(unint64_t, uint64_t))(v11 + 56);
          v25((((unint64_t)&a1[v16] & v22) + v14 + v17) & ~v17, a2);
        }
      }
      return;
  }
}

ValueMetadata *type metadata accessor for String()
{
  return &type metadata for String;
}

uint64_t type metadata accessor for _StringBreadcrumbs()
{
  return self;
}

uint64_t type metadata accessor for __SwiftNativeNSString()
{
  return self;
}

uint64_t method lookup function for __SwiftNativeNSString(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for __SwiftNativeNSString.Flags);
}

ValueMetadata *type metadata accessor for String.Iterator()
{
  return &type metadata for String.Iterator;
}

ValueMetadata *type metadata accessor for _StringComparisonResult()
{
  return &type metadata for _StringComparisonResult;
}

ValueMetadata *type metadata accessor for _StringGuts()
{
  return &type metadata for _StringGuts;
}

ValueMetadata *type metadata accessor for _StringObject()
{
  return &type metadata for _StringObject;
}

ValueMetadata *type metadata accessor for _StringObject.Nibbles()
{
  return &type metadata for _StringObject.Nibbles;
}

ValueMetadata *type metadata accessor for _StringObject.CountAndFlags()
{
  return &type metadata for _StringObject.CountAndFlags;
}

uint64_t dispatch thunk of StringProtocol.utf8.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 120))();
}

uint64_t dispatch thunk of StringProtocol.utf16.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 128))();
}

uint64_t dispatch thunk of StringProtocol.unicodeScalars.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 136))();
}

uint64_t dispatch thunk of StringProtocol.hasPrefix(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 144))();
}

uint64_t dispatch thunk of StringProtocol.hasSuffix(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 152))();
}

uint64_t dispatch thunk of StringProtocol.lowercased()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 160))();
}

uint64_t dispatch thunk of StringProtocol.uppercased()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 168))();
}

uint64_t dispatch thunk of StringProtocol.init<A, B>(decoding:as:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return (*(uint64_t (**)(void))(a8 + 176))();
}

uint64_t dispatch thunk of StringProtocol.init(cString:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 184))();
}

uint64_t dispatch thunk of StringProtocol.init<A>(decodingCString:as:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 192))();
}

uint64_t dispatch thunk of StringProtocol.withCString<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 200))();
}

uint64_t dispatch thunk of StringProtocol.withCString<A, B>(encodedAs:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return (*(uint64_t (**)(void))(a8 + 208))();
}

ValueMetadata *type metadata accessor for String.Index()
{
  return &type metadata for String.Index;
}

ValueMetadata *type metadata accessor for DefaultStringInterpolation()
{
  return &type metadata for DefaultStringInterpolation;
}

ValueMetadata *type metadata accessor for _OpaqueStringSwitchCache()
{
  return &type metadata for _OpaqueStringSwitchCache;
}

void destroy for _StringRepresentation(uint64_t a1)
{
}

uint64_t initializeWithCopy for _StringRepresentation(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  uint64_t v3 = *(void **)(a2 + 24);
  unsigned __int8 v4 = *(unsigned char *)(a2 + 32);
  outlined copy of _StringRepresentation._Form(v3, v4);
  *(void *)(a1 + 24) = v3;
  *(unsigned char *)(a1 + 32) = v4;
  return a1;
}

uint64_t assignWithCopy for _StringRepresentation(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  uint64_t v3 = *(void **)(a2 + 24);
  unsigned __int8 v4 = *(unsigned char *)(a2 + 32);
  outlined copy of _StringRepresentation._Form(v3, v4);
  uint64_t v5 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = v3;
  unsigned __int8 v6 = *(unsigned char *)(a1 + 32);
  *(unsigned char *)(a1 + 32) = v4;
  outlined consume of _StringRepresentation._Form(v5, v6);
  return a1;
}

__n128 __swift_memcpy33_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t assignWithTake for _StringRepresentation(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  char v3 = *(unsigned char *)(a2 + 32);
  unsigned __int8 v4 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  unsigned __int8 v5 = *(unsigned char *)(a1 + 32);
  *(unsigned char *)(a1 + 32) = v3;
  outlined consume of _StringRepresentation._Form(v4, v5);
  return a1;
}

uint64_t getEnumTagSinglePayload for _StringRepresentation(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFF && a1[33]) {
    return (*(_DWORD *)a1 + 255);
  }
  unsigned int v3 = *a1;
  BOOL v4 = v3 >= 2;
  int v5 = (v3 + 2147483646) & 0x7FFFFFFF;
  if (!v4) {
    int v5 = -1;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for _StringRepresentation(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(unsigned char *)(result + 32) = 0;
    *(void *)__n128 result = a2 - 255;
    *(void *)(result + 8) = 0;
    if (a3 >= 0xFF) {
      *(unsigned char *)(result + 33) = 1;
    }
  }
  else
  {
    if (a3 >= 0xFF) {
      *(unsigned char *)(result + 33) = 0;
    }
    if (a2) {
      *(unsigned char *)__n128 result = a2 + 1;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for _StringRepresentation()
{
  return &type metadata for _StringRepresentation;
}

uint64_t initializeBufferWithCopyOfBuffer for _StringRepresentation._Form(uint64_t a1, uint64_t a2)
{
  id v3 = *(id *)a2;
  unsigned __int8 v4 = *(unsigned char *)(a2 + 8);
  outlined copy of _StringRepresentation._Form(*(id *)a2, v4);
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 8) = v4;
  return a1;
}

void destroy for _StringRepresentation._Form(uint64_t a1)
{
}

uint64_t assignWithCopy for _StringRepresentation._Form(uint64_t a1, uint64_t a2)
{
  id v3 = *(id *)a2;
  unsigned __int8 v4 = *(unsigned char *)(a2 + 8);
  outlined copy of _StringRepresentation._Form(*(id *)a2, v4);
  int v5 = *(void **)a1;
  *(void *)a1 = v3;
  unsigned __int8 v6 = *(unsigned char *)(a1 + 8);
  *(unsigned char *)(a1 + 8) = v4;
  outlined consume of _StringRepresentation._Form(v5, v6);
  return a1;
}

uint64_t __swift_memcpy9_8(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(unsigned char *)(result + 8) = *((unsigned char *)a2 + 8);
  *(void *)__n128 result = v2;
  return result;
}

uint64_t assignWithTake for _StringRepresentation._Form(uint64_t a1, uint64_t a2)
{
  char v3 = *(unsigned char *)(a2 + 8);
  unsigned __int8 v4 = *(void **)a1;
  *(void *)a1 = *(void *)a2;
  unsigned __int8 v5 = *(unsigned char *)(a1 + 8);
  *(unsigned char *)(a1 + 8) = v3;
  outlined consume of _StringRepresentation._Form(v4, v5);
  return a1;
}

uint64_t getEnumTagSinglePayload for _StringRepresentation._Form(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFD && *(unsigned char *)(a1 + 9)) {
    return (*(_DWORD *)a1 + 253);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 8);
  if (v3 <= 3) {
    int v4 = -1;
  }
  else {
    int v4 = v3 ^ 0xFF;
  }
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for _StringRepresentation._Form(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFC)
  {
    *(unsigned char *)(result + 8) = 0;
    *(void *)__n128 result = a2 - 253;
    if (a3 >= 0xFD) {
      *(unsigned char *)(result + 9) = 1;
    }
  }
  else
  {
    if (a3 >= 0xFD) {
      *(unsigned char *)(result + 9) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 8) = -(char)a2;
    }
  }
  return result;
}

uint64_t getEnumTag for _StringRepresentation._Form(uint64_t a1)
{
  if (*(unsigned __int8 *)(a1 + 8) <= 2u) {
    return *(unsigned __int8 *)(a1 + 8);
  }
  else {
    return (*(_DWORD *)a1 + 3);
  }
}

uint64_t destructiveInjectEnumTag for _StringRepresentation._Form(uint64_t result, unsigned int a2)
{
  if (a2 >= 3)
  {
    *(void *)__n128 result = a2 - 3;
    LOBYTE(a2) = 3;
  }
  *(unsigned char *)(result + 8) = a2;
  return result;
}

ValueMetadata *type metadata accessor for _StringRepresentation._Form()
{
  return &type metadata for _StringRepresentation._Form;
}

ValueMetadata *type metadata accessor for String.UnicodeScalarView()
{
  return &type metadata for String.UnicodeScalarView;
}

uint64_t initializeWithCopy for String.Iterator(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v3;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  swift_bridgeObjectRetain(v3);
  return a1;
}

void *assignWithCopy for String.Iterator(void *a1, void *a2)
{
  *a1 = *a2;
  unint64_t v4 = a2[1];
  uint64_t v5 = a1[1];
  a1[1] = v4;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  a1[2] = a2[2];
  a1[3] = a2[3];
  return a1;
}

uint64_t assignWithTake for String.Iterator(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  swift_bridgeObjectRelease(v5);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  return a1;
}

uint64_t getEnumTagSinglePayload for String.Iterator(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 32)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for String.Iterator(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0;
    if (a3 < 0) {
      *(unsigned char *)(result + 32) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 32) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for String.UnicodeScalarView.Iterator()
{
  return &type metadata for String.UnicodeScalarView.Iterator;
}

ValueMetadata *type metadata accessor for String.UTF16View()
{
  return &type metadata for String.UTF16View;
}

uint64_t initializeWithCopy for String.UTF16View.Iterator(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v3;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_WORD *)(a1 + 32) = *(_WORD *)(a2 + 32);
  *(unsigned char *)(a1 + 34) = *(unsigned char *)(a2 + 34);
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for String.UTF16View.Iterator(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  unint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = v4;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  __int16 v6 = *(_WORD *)(a2 + 32);
  *(unsigned char *)(a1 + 34) = *(unsigned char *)(a2 + 34);
  *(_WORD *)(a1 + 32) = v6;
  return a1;
}

__n128 __swift_memcpy35_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 31) = *(_DWORD *)(a2 + 31);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t assignWithTake for String.UTF16View.Iterator(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  swift_bridgeObjectRelease(v5);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_WORD *)(a1 + 32) = *(_WORD *)(a2 + 32);
  *(unsigned char *)(a1 + 34) = *(unsigned char *)(a2 + 34);
  return a1;
}

uint64_t getEnumTagSinglePayload for String.UTF16View.Iterator(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 35)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for String.UTF16View.Iterator(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(unsigned char *)(result + 34) = 0;
    *(_WORD *)(result + 32) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0;
    if (a3 < 0) {
      *(unsigned char *)(result + 35) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 35) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for String.UTF16View.Iterator()
{
  return &type metadata for String.UTF16View.Iterator;
}

void *assignWithCopy for Character(void *a1, void *a2)
{
  *a1 = *a2;
  unint64_t v3 = a2[1];
  uint64_t v4 = a1[1];
  a1[1] = v3;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for Character(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 16)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Character(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0;
    if (a3 < 0) {
      *(unsigned char *)(result + 16) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 16) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for String.UTF8View()
{
  return &type metadata for String.UTF8View;
}

ValueMetadata *type metadata accessor for Substring()
{
  return &type metadata for Substring;
}

ValueMetadata *type metadata accessor for Substring.UTF8View()
{
  return &type metadata for Substring.UTF8View;
}

ValueMetadata *type metadata accessor for Substring.UTF16View()
{
  return &type metadata for Substring.UTF16View;
}

void destroy for Substring.UnicodeScalarView(uint64_t a1)
{
}

ValueMetadata *type metadata accessor for Substring.UnicodeScalarView()
{
  return &type metadata for Substring.UnicodeScalarView;
}

uint64_t type metadata accessor for __SwiftNativeNSArrayWithContiguousStorage()
{
  return self;
}

uint64_t method lookup function for __SwiftNativeNSArrayWithContiguousStorage(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for __SwiftNativeNSArrayWithContiguousStorage.Flags);
}

uint64_t method lookup function for _SwiftNSMutableArray(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for _SwiftNSMutableArray.Flags);
}

uint64_t method lookup function for __SwiftDeferredNSArray(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for __SwiftDeferredNSArray.Flags);
}

uint64_t dispatch thunk of __SwiftDeferredNSArray.__allocating_init(_nativeStorage:)()
{
  return (*(uint64_t (**)(void))(v0 + 112))();
}

swift *type metadata completion function for __SwiftDeferredStaticNSArray(uint64_t a1)
{
  return swift_initClassMetadata2(a1, 0, 0, (uint64_t)v2, a1 + 128);
}

uint64_t method lookup function for __ContiguousArrayStorageBase(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for __ContiguousArrayStorageBase.Flags);
}

uint64_t dispatch thunk of __ContiguousArrayStorageBase.__allocating_init(_doNotCallMeBase:)()
{
  return (*(uint64_t (**)(void))(v0 + 104))();
}

uint64_t dispatch thunk of __ContiguousArrayStorageBase.canStoreElements(ofDynamicType:)()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 128))();
}

uint64_t dispatch thunk of __ContiguousArrayStorageBase.staticElementType.getter()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 136))();
}

uint64_t __swift_memcpy5_4(uint64_t result, int *a2)
{
  int v2 = *a2;
  *(unsigned char *)(result + 4) = *((unsigned char *)a2 + 4);
  *(_DWORD *)__n128 result = v2;
  return result;
}

uint64_t getEnumTagSinglePayload for _UIntBuffer.Iterator(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 5)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for _UIntBuffer.Iterator(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(unsigned char *)(result + 4) = 0;
    *(_DWORD *)__n128 result = a2 - 1;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 5) = v3;
  return result;
}

Class *type metadata accessor for _UIntBuffer.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _UIntBuffer.Iterator.Flags);
}

Class *type metadata accessor for _UIntBuffer.Index(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _UIntBuffer.Index.Flags);
}

uint64_t dispatch thunk of static _UnicodeEncoding.encodedReplacementCharacter.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 80))();
}

uint64_t dispatch thunk of static _UnicodeEncoding.decode(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 88))();
}

uint64_t dispatch thunk of static _UnicodeEncoding.encode(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 96))();
}

uint64_t dispatch thunk of static _UnicodeEncoding.transcode<A>(_:from:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(void))(a6 + 104))();
}

uint64_t dispatch thunk of static _UnicodeEncoding._isScalar(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 112))();
}

uint64_t *type metadata completion function for Unicode.ParseResult(uint64_t a1)
{
  __n128 result = swift_checkMetadataState(319, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    v4[0] = *(result - 1) + 64;
    v4[1] = &value witness table for Builtin.Int64.size;
    swift_initEnumMetadataMultiPayload(a1, 0, 2, (uint64_t)v4);
    return 0;
  }
  return result;
}

void *initializeBufferWithCopyOfBuffer for Unicode.ParseResult(unsigned char *__dst, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v3 = __dst;
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  if (*(void *)(v4 + 64) <= 8uLL) {
    uint64_t v5 = 8;
  }
  else {
    uint64_t v5 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
  }
  int v6 = *(_DWORD *)(v4 + 80);
  if ((v6 & 0x1000F8) != 0 || (unint64_t)(v5 + 1) > 0x18)
  {
    uint64_t v8 = *(atomic_ullong **)a2;
    *unint64_t v3 = *(void *)a2;
    unint64_t v3 = (atomic_ullong *)((char *)v8 + ((unsigned __int16)((v6 & 0xF8) + 23) & (unsigned __int16)~(v6 & 0xF8) & 0x1F8));
    swift_retain(v8);
  }
  else
  {
    unsigned int v9 = a2[v5];
    unsigned int v10 = v9 - 2;
    if (v9 >= 2)
    {
      if (v5 <= 3) {
        uint64_t v11 = v5;
      }
      else {
        uint64_t v11 = 4;
      }
      switch(v11)
      {
        case 1:
          int v12 = *a2;
          goto LABEL_19;
        case 2:
          int v12 = *(unsigned __int16 *)a2;
          goto LABEL_19;
        case 3:
          int v12 = *(unsigned __int16 *)a2 | (a2[2] << 16);
          goto LABEL_19;
        case 4:
          int v12 = *(_DWORD *)a2;
LABEL_19:
          int v13 = (v12 | (v10 << (8 * v5))) + 2;
          unsigned int v9 = v12 + 2;
          if (v5 < 4) {
            unsigned int v9 = v13;
          }
          break;
        default:
          break;
      }
    }
    if (v9 == 1)
    {
      *(void *)__dst = *(void *)a2;
      __dst[v5] = 1;
    }
    else if (v9)
    {
      memcpy(__dst, a2, v5 + 1);
    }
    else
    {
      (*(void (**)(unsigned char *))(v4 + 16))(__dst);
      *((unsigned char *)v3 + v5) = 0;
    }
  }
  return v3;
}

unsigned __int8 *destroy for Unicode.ParseResult(unsigned __int8 *result, uint64_t a2)
{
  unint64_t v2 = *(void *)(*(void *)(*(void *)(a2 + 16) - 8) + 64);
  if (v2 <= 8) {
    unint64_t v2 = 8;
  }
  unsigned int v3 = result[v2];
  unsigned int v4 = v3 - 2;
  if (v3 >= 2)
  {
    if (v2 <= 3) {
      uint64_t v5 = v2;
    }
    else {
      uint64_t v5 = 4;
    }
    switch(v5)
    {
      case 1:
        int v6 = *result;
        goto LABEL_12;
      case 2:
        int v6 = *(unsigned __int16 *)result;
        goto LABEL_12;
      case 3:
        int v6 = *(unsigned __int16 *)result | (result[2] << 16);
        goto LABEL_12;
      case 4:
        int v6 = *(_DWORD *)result;
LABEL_12:
        int v7 = (v6 | (v4 << (8 * v2))) + 2;
        unsigned int v3 = v6 + 2;
        if (v2 < 4) {
          unsigned int v3 = v7;
        }
        break;
      default:
        return result;
    }
  }
  if (!v3) {
    return (unsigned __int8 *)(*(uint64_t (**)(void))(*(void *)(*(void *)(a2 + 16) - 8) + 8))();
  }
  return result;
}

unsigned char *initializeWithCopy for Unicode.ParseResult(unsigned char *__dst, unsigned __int8 *a2, uint64_t a3)
{
  if (*(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64) <= 8uLL) {
    uint64_t v4 = 8;
  }
  else {
    uint64_t v4 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
  }
  unsigned int v5 = a2[v4];
  unsigned int v6 = v5 - 2;
  if (v5 >= 2)
  {
    if (v4 <= 3) {
      uint64_t v7 = v4;
    }
    else {
      uint64_t v7 = 4;
    }
    switch(v7)
    {
      case 1:
        int v8 = *a2;
        goto LABEL_13;
      case 2:
        int v8 = *(unsigned __int16 *)a2;
        goto LABEL_13;
      case 3:
        int v8 = *(unsigned __int16 *)a2 | (a2[2] << 16);
        goto LABEL_13;
      case 4:
        int v8 = *(_DWORD *)a2;
LABEL_13:
        int v9 = (v8 | (v6 << (8 * v4))) + 2;
        unsigned int v5 = v8 + 2;
        if (v4 < 4) {
          unsigned int v5 = v9;
        }
        break;
      default:
        break;
    }
  }
  if (v5 == 1)
  {
    *(void *)__dst = *(void *)a2;
    __dst[v4] = 1;
  }
  else if (v5)
  {
    memcpy(__dst, a2, v4 + 1);
  }
  else
  {
    (*(void (**)(unsigned char *))(*(void *)(*(void *)(a3 + 16) - 8) + 16))(__dst);
    __dst[v4] = 0;
  }
  return __dst;
}

unsigned __int8 *assignWithCopy for Unicode.ParseResult(unsigned __int8 *__dst, unsigned __int8 *__src, uint64_t a3)
{
  if (__dst != __src)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = *(void *)(v5 - 8);
    if (*(void *)(v6 + 64) <= 8uLL) {
      uint64_t v7 = 8;
    }
    else {
      uint64_t v7 = *(void *)(v6 + 64);
    }
    unsigned int v8 = __dst[v7];
    unsigned int v9 = v8 - 2;
    if (v8 >= 2)
    {
      if (v7 <= 3) {
        uint64_t v10 = v7;
      }
      else {
        uint64_t v10 = 4;
      }
      switch(v10)
      {
        case 1:
          int v11 = *__dst;
          goto LABEL_14;
        case 2:
          int v11 = *(unsigned __int16 *)__dst;
          goto LABEL_14;
        case 3:
          int v11 = *(unsigned __int16 *)__dst | (__dst[2] << 16);
          goto LABEL_14;
        case 4:
          int v11 = *(_DWORD *)__dst;
LABEL_14:
          int v12 = (v11 | (v9 << (8 * v7))) + 2;
          unsigned int v8 = v11 + 2;
          if (v7 < 4) {
            unsigned int v8 = v12;
          }
          break;
        default:
          goto LABEL_18;
      }
    }
    if (!v8) {
      (*(void (**)(unsigned __int8 *, uint64_t))(v6 + 8))(__dst, v5);
    }
LABEL_18:
    unsigned int v13 = __src[v7];
    unsigned int v14 = v13 - 2;
    if (v13 >= 2)
    {
      if (v7 <= 3) {
        uint64_t v15 = v7;
      }
      else {
        uint64_t v15 = 4;
      }
      switch(v15)
      {
        case 1:
          int v16 = *__src;
          goto LABEL_27;
        case 2:
          int v16 = *(unsigned __int16 *)__src;
          goto LABEL_27;
        case 3:
          int v16 = *(unsigned __int16 *)__src | (__src[2] << 16);
          goto LABEL_27;
        case 4:
          int v16 = *(_DWORD *)__src;
LABEL_27:
          int v17 = (v16 | (v14 << (8 * v7))) + 2;
          unsigned int v13 = v16 + 2;
          if (v7 < 4) {
            unsigned int v13 = v17;
          }
          break;
        default:
          break;
      }
    }
    if (v13 == 1)
    {
      *(void *)__dst = *(void *)__src;
      __dst[v7] = 1;
    }
    else if (v13)
    {
      memcpy(__dst, __src, v7 + 1);
    }
    else
    {
      (*(void (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(v6 + 16))(__dst, __src, v5);
      __dst[v7] = 0;
    }
  }
  return __dst;
}

unsigned char *initializeWithTake for Unicode.ParseResult(unsigned char *__dst, unsigned __int8 *a2, uint64_t a3)
{
  if (*(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64) <= 8uLL) {
    uint64_t v4 = 8;
  }
  else {
    uint64_t v4 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
  }
  unsigned int v5 = a2[v4];
  unsigned int v6 = v5 - 2;
  if (v5 >= 2)
  {
    if (v4 <= 3) {
      uint64_t v7 = v4;
    }
    else {
      uint64_t v7 = 4;
    }
    switch(v7)
    {
      case 1:
        int v8 = *a2;
        goto LABEL_13;
      case 2:
        int v8 = *(unsigned __int16 *)a2;
        goto LABEL_13;
      case 3:
        int v8 = *(unsigned __int16 *)a2 | (a2[2] << 16);
        goto LABEL_13;
      case 4:
        int v8 = *(_DWORD *)a2;
LABEL_13:
        int v9 = (v8 | (v6 << (8 * v4))) + 2;
        unsigned int v5 = v8 + 2;
        if (v4 < 4) {
          unsigned int v5 = v9;
        }
        break;
      default:
        break;
    }
  }
  if (v5 == 1)
  {
    *(void *)__dst = *(void *)a2;
    __dst[v4] = 1;
  }
  else if (v5)
  {
    memcpy(__dst, a2, v4 + 1);
  }
  else
  {
    (*(void (**)(unsigned char *))(*(void *)(*(void *)(a3 + 16) - 8) + 32))(__dst);
    __dst[v4] = 0;
  }
  return __dst;
}

unsigned __int8 *assignWithTake for Unicode.ParseResult(unsigned __int8 *__dst, unsigned __int8 *__src, uint64_t a3)
{
  if (__dst != __src)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = *(void *)(v5 - 8);
    if (*(void *)(v6 + 64) <= 8uLL) {
      uint64_t v7 = 8;
    }
    else {
      uint64_t v7 = *(void *)(v6 + 64);
    }
    unsigned int v8 = __dst[v7];
    unsigned int v9 = v8 - 2;
    if (v8 >= 2)
    {
      if (v7 <= 3) {
        uint64_t v10 = v7;
      }
      else {
        uint64_t v10 = 4;
      }
      switch(v10)
      {
        case 1:
          int v11 = *__dst;
          goto LABEL_14;
        case 2:
          int v11 = *(unsigned __int16 *)__dst;
          goto LABEL_14;
        case 3:
          int v11 = *(unsigned __int16 *)__dst | (__dst[2] << 16);
          goto LABEL_14;
        case 4:
          int v11 = *(_DWORD *)__dst;
LABEL_14:
          int v12 = (v11 | (v9 << (8 * v7))) + 2;
          unsigned int v8 = v11 + 2;
          if (v7 < 4) {
            unsigned int v8 = v12;
          }
          break;
        default:
          goto LABEL_18;
      }
    }
    if (!v8) {
      (*(void (**)(unsigned __int8 *, uint64_t))(v6 + 8))(__dst, v5);
    }
LABEL_18:
    unsigned int v13 = __src[v7];
    unsigned int v14 = v13 - 2;
    if (v13 >= 2)
    {
      if (v7 <= 3) {
        uint64_t v15 = v7;
      }
      else {
        uint64_t v15 = 4;
      }
      switch(v15)
      {
        case 1:
          int v16 = *__src;
          goto LABEL_27;
        case 2:
          int v16 = *(unsigned __int16 *)__src;
          goto LABEL_27;
        case 3:
          int v16 = *(unsigned __int16 *)__src | (__src[2] << 16);
          goto LABEL_27;
        case 4:
          int v16 = *(_DWORD *)__src;
LABEL_27:
          int v17 = (v16 | (v14 << (8 * v7))) + 2;
          unsigned int v13 = v16 + 2;
          if (v7 < 4) {
            unsigned int v13 = v17;
          }
          break;
        default:
          break;
      }
    }
    if (v13 == 1)
    {
      *(void *)__dst = *(void *)__src;
      __dst[v7] = 1;
    }
    else if (v13)
    {
      memcpy(__dst, __src, v7 + 1);
    }
    else
    {
      (*(void (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(v6 + 32))(__dst, __src, v5);
      __dst[v7] = 0;
    }
  }
  return __dst;
}

uint64_t getEnumTagSinglePayload for Unicode.ParseResult(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a3 + 16) - 8);
  uint64_t v4 = 8;
  if (*(void *)(v3 + 64) > 8uLL) {
    uint64_t v4 = *(void *)(v3 + 64);
  }
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFE) {
    goto LABEL_22;
  }
  uint64_t v5 = v4 + 1;
  char v6 = 8 * (v4 + 1);
  if ((v4 + 1) <= 3)
  {
    unsigned int v9 = ((a2 + ~(-1 << v6) - 253) >> v6) + 1;
    if (HIWORD(v9))
    {
      int v7 = *(_DWORD *)((char *)a1 + v5);
      if (!v7) {
        goto LABEL_22;
      }
      goto LABEL_14;
    }
    if (v9 > 0xFF)
    {
      int v7 = *(unsigned __int16 *)((char *)a1 + v5);
      if (!*(unsigned __int16 *)((char *)a1 + v5)) {
        goto LABEL_22;
      }
      goto LABEL_14;
    }
    if (v9 < 2)
    {
LABEL_22:
      unsigned int v11 = *((unsigned __int8 *)a1 + v4);
      if (v11 >= 3) {
        return (v11 ^ 0xFF) + 1;
      }
      else {
        return 0;
      }
    }
  }
  int v7 = *((unsigned __int8 *)a1 + v5);
  if (!*((unsigned char *)a1 + v5)) {
    goto LABEL_22;
  }
LABEL_14:
  int v10 = (v7 - 1) << v6;
  if (v5 > 3) {
    int v10 = 0;
  }
  if (v5)
  {
    if (v5 > 3) {
      LODWORD(v5) = 4;
    }
    switch((int)v5)
    {
      case 2:
        LODWORD(v5) = *a1;
        break;
      case 3:
        LODWORD(v5) = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        LODWORD(v5) = *(_DWORD *)a1;
        break;
      default:
        LODWORD(v5) = *(unsigned __int8 *)a1;
        break;
    }
  }
  return (v5 | v10) + 254;
}

void storeEnumTagSinglePayload for Unicode.ParseResult(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  unint64_t v5 = *(void *)(*(void *)(*(void *)(a4 + 16) - 8) + 64);
  if (v5 <= 8) {
    unint64_t v5 = 8;
  }
  size_t v6 = v5 + 1;
  if (a3 < 0xFE)
  {
    int v7 = 0;
  }
  else if (v6 <= 3)
  {
    unsigned int v10 = ((a3 + ~(-1 << (8 * v6)) - 253) >> (8 * v6)) + 1;
    if (HIWORD(v10))
    {
      int v7 = 4;
    }
    else if (v10 >= 0x100)
    {
      int v7 = 2;
    }
    else
    {
      int v7 = v10 > 1;
    }
  }
  else
  {
    int v7 = 1;
  }
  if (a2 > 0xFD)
  {
    unsigned int v8 = a2 - 254;
    if (v6 < 4)
    {
      int v9 = (v8 >> (8 * v6)) + 1;
      if (v5 != -1)
      {
        int v11 = v8 & ~(-1 << (8 * v6));
        bzero(a1, v6);
        if (v6 == 3)
        {
          *(_WORD *)a1 = v11;
          a1[2] = BYTE2(v11);
        }
        else if (v6 == 2)
        {
          *(_WORD *)a1 = v11;
        }
        else
        {
          *a1 = v11;
        }
      }
    }
    else
    {
      bzero(a1, v5 + 1);
      *(_DWORD *)a1 = v8;
      int v9 = 1;
    }
    switch(v7)
    {
      case 1:
        a1[v6] = v9;
        break;
      case 2:
        *(_WORD *)&a1[v6] = v9;
        break;
      case 3:
LABEL_34:
        __break(1u);
        JUMPOUT(0x18151FF34);
      case 4:
        *(_DWORD *)&a1[v6] = v9;
        break;
      default:
        return;
    }
  }
  else
  {
    switch(v7)
    {
      case 1:
        a1[v6] = 0;
        if (!a2) {
          return;
        }
        goto LABEL_23;
      case 2:
        *(_WORD *)&a1[v6] = 0;
        goto LABEL_22;
      case 3:
        goto LABEL_34;
      case 4:
        *(_DWORD *)&a1[v6] = 0;
        if (!a2) {
          return;
        }
        goto LABEL_23;
      default:
LABEL_22:
        if (a2) {
LABEL_23:
        }
          a1[v5] = -(char)a2;
        break;
    }
  }
}

uint64_t getEnumTag for Unicode.ParseResult(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a2 + 16) - 8);
  uint64_t v3 = 8;
  if (*(void *)(v2 + 64) > 8uLL) {
    uint64_t v3 = *(void *)(v2 + 64);
  }
  uint64_t v4 = a1[v3];
  int v5 = v4 - 2;
  if (v4 >= 2)
  {
    if (v3 <= 3) {
      uint64_t v6 = v3;
    }
    else {
      uint64_t v6 = 4;
    }
    switch(v6)
    {
      case 1:
        int v7 = *a1;
        goto LABEL_12;
      case 2:
        int v7 = *(unsigned __int16 *)a1;
        goto LABEL_12;
      case 3:
        int v7 = *(unsigned __int16 *)a1 | (a1[2] << 16);
        goto LABEL_12;
      case 4:
        int v7 = *(_DWORD *)a1;
LABEL_12:
        unsigned int v8 = (v7 | (v5 << (8 * v3))) + 2;
        LODWORD(v4) = v7 + 2;
        if (v3 >= 4) {
          uint64_t v4 = v4;
        }
        else {
          uint64_t v4 = v8;
        }
        break;
      default:
        return v4;
    }
  }
  return v4;
}

void destructiveInjectEnumTag for Unicode.ParseResult(unsigned char *a1, unsigned int a2, uint64_t a3)
{
  if (*(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64) <= 8uLL) {
    size_t v4 = 8;
  }
  else {
    size_t v4 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
  }
  if (a2 > 1)
  {
    unsigned int v5 = a2 - 2;
    if (v4 < 4)
    {
      unsigned int v6 = v5 >> (8 * v4);
      int v7 = v5 & ~(-1 << (8 * v4));
      a1[v4] = v6 + 2;
      bzero(a1, v4);
      if (v4 == 3)
      {
        *(_WORD *)a1 = v7;
        a1[2] = BYTE2(v7);
      }
      else if (v4 == 2)
      {
        *(_WORD *)a1 = v7;
      }
      else
      {
        *a1 = v7;
      }
    }
    else
    {
      a1[v4] = 2;
      bzero(a1, v4);
      *(_DWORD *)a1 = v5;
    }
  }
  else
  {
    a1[v4] = a2;
  }
}

uint64_t dispatch thunk of _UnicodeParser.init()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))();
}

uint64_t dispatch thunk of _UnicodeParser.parseScalar<A>(from:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 32))();
}

ValueMetadata *type metadata accessor for Unicode.Scalar.Properties()
{
  return &type metadata for Unicode.Scalar.Properties;
}

uint64_t getEnumTagSinglePayload for Unicode.GeneralCategory(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xE3) {
    goto LABEL_17;
  }
  if (a2 + 29 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 29) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 29;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 29;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 29;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 0x1E;
  int v8 = v6 - 30;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for Unicode.GeneralCategory(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 29 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 29) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xE3) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xE2)
  {
    unsigned int v6 = ((a2 - 227) >> 8) + 1;
    *__n128 result = a2 + 29;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x181520280);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *__n128 result = a2 + 29;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Unicode.GeneralCategory()
{
  return &type metadata for Unicode.GeneralCategory;
}

ValueMetadata *type metadata accessor for Unicode.CanonicalCombiningClass()
{
  return &type metadata for Unicode.CanonicalCombiningClass;
}

ValueMetadata *type metadata accessor for Unicode.NumericType()
{
  return &type metadata for Unicode.NumericType;
}

ValueMetadata *type metadata accessor for Unicode._NFD()
{
  return &type metadata for Unicode._NFD;
}

void destroy for Unicode._NFD.Iterator(uint64_t *a1)
{
  swift_bridgeObjectRelease(*a1);
  uint64_t v2 = a1[6];

  swift_bridgeObjectRelease(v2);
}

uint64_t initializeWithCopy for Unicode._NFD.Iterator(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)a2;
  *(void *)a1 = *(void *)a2;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  long long v4 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = v4;
  unint64_t v5 = *(void *)(a2 + 48);
  *(void *)(a1 + 48) = v5;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRetain(v5);
  return a1;
}

uint64_t assignWithCopy for Unicode._NFD.Iterator(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)a2;
  uint64_t v5 = *(void *)a1;
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  unint64_t v6 = *(void *)(a2 + 48);
  uint64_t v7 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = v6;
  swift_bridgeObjectRetain(v6);
  swift_bridgeObjectRelease(v7);
  return a1;
}

__n128 __swift_memcpy56_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 32) = v4;
  *(__n128 *)a1 = result;
  return result;
}

uint64_t assignWithTake for Unicode._NFD.Iterator(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a1;
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRelease(v4);
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  long long v5 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = v5;
  uint64_t v6 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  swift_bridgeObjectRelease(v6);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._NFD.Iterator(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 56)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Unicode._NFD.Iterator(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 56) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 56) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Unicode._NFD.Iterator()
{
  return &type metadata for Unicode._NFD.Iterator;
}

uint64_t initializeWithCopy for Substring(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  unint64_t v3 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = v3;
  swift_bridgeObjectRetain(v3);
  return a1;
}

void *assignWithCopy for Substring(void *a1, void *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  unint64_t v3 = a2[3];
  uint64_t v4 = a1[3];
  a1[3] = v3;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t assignWithTake for Substring(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v3 = *(void *)(a2 + 24);
  uint64_t v4 = *(void *)(a1 + 24);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = v3;
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for Substring(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 32)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 24);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Substring(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0;
    if (a3 < 0) {
      *(unsigned char *)(result + 32) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 24) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 32) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Unicode._NFC()
{
  return &type metadata for Unicode._NFC;
}

void destroy for Unicode._NFC.Iterator(uint64_t *a1)
{
  swift_bridgeObjectRelease(*a1);
  swift_bridgeObjectRelease(a1[3]);
  uint64_t v2 = a1[9];

  swift_bridgeObjectRelease(v2);
}

uint64_t initializeWithCopy for Unicode._NFC.Iterator(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)a2;
  *(void *)a1 = *(void *)a2;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  unint64_t v4 = *(void *)(a2 + 24);
  *(void *)(a1 + 24) = v4;
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  unint64_t v5 = *(void *)(a2 + 72);
  *(void *)(a1 + 72) = v5;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRetain(v5);
  return a1;
}

uint64_t assignWithCopy for Unicode._NFC.Iterator(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)a2;
  uint64_t v5 = *(void *)a1;
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  int v6 = *(_DWORD *)(a2 + 12);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  *(_DWORD *)(a1 + 12) = v6;
  unint64_t v7 = *(void *)(a2 + 24);
  uint64_t v8 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v7;
  swift_bridgeObjectRetain(v7);
  swift_bridgeObjectRelease(v8);
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  unint64_t v9 = *(void *)(a2 + 72);
  uint64_t v10 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = v9;
  swift_bridgeObjectRetain(v9);
  swift_bridgeObjectRelease(v10);
  return a1;
}

__n128 __swift_memcpy80_8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  long long v3 = *(_OWORD *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = v4;
  *(__n128 *)(a1 + 16) = result;
  *(_OWORD *)(a1 + 32) = v3;
  return result;
}

uint64_t assignWithTake for Unicode._NFC.Iterator(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a1;
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRelease(v4);
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  uint64_t v5 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  swift_bridgeObjectRelease(v5);
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  uint64_t v6 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  swift_bridgeObjectRelease(v6);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._NFC.Iterator(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 80)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Unicode._NFC.Iterator(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 72) = 0;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 80) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 80) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Unicode._NFC.Iterator()
{
  return &type metadata for Unicode._NFC.Iterator;
}

uint64_t getEnumTagSinglePayload for _BridgeableMetatype(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 8)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for _BridgeableMetatype(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 8) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 8) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

Class *type metadata accessor for Unmanaged(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateCanonicalPrespecializedGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Unmanaged.Flags, &flag for loading of canonical specialized generic type metadata for Unmanaged);
}

ValueMetadata *type metadata accessor for UnsafeRawPointer()
{
  return &type metadata for UnsafeRawPointer;
}

ValueMetadata *type metadata accessor for UnsafeMutableRawPointer()
{
  return &type metadata for UnsafeMutableRawPointer;
}

uint64_t dispatch thunk of _UTFParser._parseMultipleCodeUnits()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 24))() & 0xFFFFFF01;
}

uint64_t dispatch thunk of _UTFParser._bufferedScalar(bitCount:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 32))();
}

uint64_t dispatch thunk of _UTFParser._buffer.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))() & 0xFFFFFFFFFFLL;
}

uint64_t dispatch thunk of _UTFParser._buffer.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(a3 + 48))(a1 & 0xFFFFFFFFFFLL);
}

uint64_t dispatch thunk of _UTFParser._buffer.modify(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

ValueMetadata *type metadata accessor for Unicode.UTF8()
{
  return &type metadata for Unicode.UTF8;
}

ValueMetadata *type metadata accessor for Unicode.UTF8.ForwardParser()
{
  return &type metadata for Unicode.UTF8.ForwardParser;
}

ValueMetadata *type metadata accessor for Unicode.UTF8.ReverseParser()
{
  return &type metadata for Unicode.UTF8.ReverseParser;
}

ValueMetadata *type metadata accessor for Unicode.UTF16()
{
  return &type metadata for Unicode.UTF16;
}

ValueMetadata *type metadata accessor for Unicode.UTF16.ForwardParser()
{
  return &type metadata for Unicode.UTF16.ForwardParser;
}

ValueMetadata *type metadata accessor for Unicode.UTF16.ReverseParser()
{
  return &type metadata for Unicode.UTF16.ReverseParser;
}

ValueMetadata *type metadata accessor for Unicode.UTF32()
{
  return &type metadata for Unicode.UTF32;
}

ValueMetadata *type metadata accessor for Unicode.UTF32.Parser()
{
  return &type metadata for Unicode.UTF32.Parser;
}

uint64_t getEnumTag for UnicodeDecodingResult(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 4)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t destructiveInjectEnumTag for UnicodeDecodingResult(uint64_t result, int a2)
{
  if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(unsigned char *)(result + 4) = 1;
  }
  else
  {
    *(unsigned char *)(result + 4) = 0;
  }
  return result;
}

ValueMetadata *type metadata accessor for UnicodeDecodingResult()
{
  return &type metadata for UnicodeDecodingResult;
}

uint64_t dispatch thunk of UnicodeCodec.init()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t dispatch thunk of UnicodeCodec.decode<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5 = (*(uint64_t (**)(void))(a5 + 24))();
  return v5 | ((HIDWORD(v5) & 1) << 32);
}

uint64_t dispatch thunk of static UnicodeCodec.encode(_:into:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void))(a5 + 32))();
}

uint64_t dispatch thunk of static UnicodeCodec._nullCodeUnitOffset(in:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of static _StringElement._toUTF16CodeUnit(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 8))();
}

uint64_t dispatch thunk of static _StringElement._fromUTF16CodeUnit(_:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 16))();
}

ValueMetadata *type metadata accessor for Unicode()
{
  return &type metadata for Unicode;
}

void *__swift_memcpy8_4(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

uint64_t getEnumTagSinglePayload for Unicode._CharacterRecognizer(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFF && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 255);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 4);
  BOOL v4 = v3 >= 2;
  int v5 = (v3 + 2147483646) & 0x7FFFFFFF;
  if (!v4) {
    int v5 = -1;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for Unicode._CharacterRecognizer(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(void *)__n128 result = a2 - 255;
    if (a3 >= 0xFF) {
      *(unsigned char *)(result + 8) = 1;
    }
  }
  else
  {
    if (a3 >= 0xFF) {
      *(unsigned char *)(result + 8) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 4) = a2 + 1;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Unicode._CharacterRecognizer()
{
  return &type metadata for Unicode._CharacterRecognizer;
}

ValueMetadata *type metadata accessor for _ValidUTF8Buffer()
{
  return &type metadata for _ValidUTF8Buffer;
}

ValueMetadata *type metadata accessor for _ValidUTF8Buffer.Iterator()
{
  return &type metadata for _ValidUTF8Buffer.Iterator;
}

ValueMetadata *type metadata accessor for _ValidUTF8Buffer.Index()
{
  return &type metadata for _ValidUTF8Buffer.Index;
}

void destroy for _PlaygroundQuickLook(uint64_t a1)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 32);
  if (v2 >= 0x13) {
    unsigned int v2 = *(_DWORD *)a1 + 19;
  }
  switch(v2)
  {
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 0xAu:
    case 0xBu:
    case 0xCu:
    case 0xDu:
    case 0xEu:
      return;
    case 5u:
    case 6u:
    case 7u:
    case 8u:
    case 9u:
    case 0xFu:
    case 0x10u:
      __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
      break;
    case 0x12u:
      swift_bridgeObjectRelease(*(void *)a1);
      uint64_t v3 = *(void *)(a1 + 16);
      goto LABEL_7;
    default:
      uint64_t v3 = *(void *)(a1 + 8);
LABEL_7:
      swift_bridgeObjectRelease(v3);
      break;
  }
}

uint64_t initializeWithCopy for _PlaygroundQuickLook(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(unsigned __int8 *)(a2 + 32);
  if (v3 >= 0x13) {
    unsigned int v3 = *(_DWORD *)a2 + 19;
  }
  switch(v3)
  {
    case 1u:
      *(void *)a1 = *(void *)a2;
      *(unsigned char *)(a1 + 32) = 1;
      return a1;
    case 2u:
      *(void *)a1 = *(void *)a2;
      *(unsigned char *)(a1 + 32) = 2;
      return a1;
    case 3u:
      *(_DWORD *)a1 = *(_DWORD *)a2;
      *(unsigned char *)(a1 + 32) = 3;
      return a1;
    case 4u:
      *(void *)a1 = *(void *)a2;
      *(unsigned char *)(a1 + 32) = 4;
      return a1;
    case 5u:
      uint64_t v5 = *(void *)(a2 + 24);
      *(void *)(a1 + 24) = v5;
      (**(void (***)(uint64_t))(v5 - 8))(a1);
      *(unsigned char *)(a1 + 32) = 5;
      return a1;
    case 6u:
      uint64_t v6 = *(void *)(a2 + 24);
      *(void *)(a1 + 24) = v6;
      (**(void (***)(uint64_t))(v6 - 8))(a1);
      *(unsigned char *)(a1 + 32) = 6;
      return a1;
    case 7u:
      uint64_t v7 = *(void *)(a2 + 24);
      *(void *)(a1 + 24) = v7;
      (**(void (***)(uint64_t))(v7 - 8))(a1);
      *(unsigned char *)(a1 + 32) = 7;
      return a1;
    case 8u:
      uint64_t v8 = *(void *)(a2 + 24);
      *(void *)(a1 + 24) = v8;
      (**(void (***)(uint64_t))(v8 - 8))(a1);
      *(unsigned char *)(a1 + 32) = 8;
      return a1;
    case 9u:
      uint64_t v9 = *(void *)(a2 + 24);
      *(void *)(a1 + 24) = v9;
      (**(void (***)(uint64_t))(v9 - 8))(a1);
      *(unsigned char *)(a1 + 32) = 9;
      return a1;
    case 0xAu:
      long long v10 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 16) = v10;
      *(unsigned char *)(a1 + 32) = 10;
      return a1;
    case 0xBu:
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(unsigned char *)(a1 + 32) = 11;
      return a1;
    case 0xCu:
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(unsigned char *)(a1 + 32) = 12;
      return a1;
    case 0xDu:
      *(unsigned char *)a1 = *(unsigned char *)a2;
      *(unsigned char *)(a1 + 32) = 13;
      return a1;
    case 0xEu:
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(unsigned char *)(a1 + 32) = 14;
      return a1;
    case 0xFu:
      uint64_t v11 = *(void *)(a2 + 24);
      *(void *)(a1 + 24) = v11;
      (**(void (***)(uint64_t))(v11 - 8))(a1);
      *(unsigned char *)(a1 + 32) = 15;
      return a1;
    case 0x10u:
      uint64_t v12 = *(void *)(a2 + 24);
      *(void *)(a1 + 24) = v12;
      (**(void (***)(uint64_t))(v12 - 8))(a1);
      *(unsigned char *)(a1 + 32) = 16;
      return a1;
    case 0x11u:
      unint64_t v4 = *(void *)(a2 + 8);
      *(void *)a1 = *(void *)a2;
      *(void *)(a1 + 8) = v4;
      *(unsigned char *)(a1 + 32) = 17;
      goto LABEL_23;
    case 0x12u:
      unint64_t v13 = *(void *)a2;
      uint64_t v14 = *(void *)(a2 + 8);
      *(void *)a1 = *(void *)a2;
      *(void *)(a1 + 8) = v14;
      unint64_t v15 = *(void *)(a2 + 16);
      *(void *)(a1 + 16) = v15;
      *(unsigned char *)(a1 + 32) = 18;
      swift_bridgeObjectRetain(v13);
      unint64_t v4 = v15;
      goto LABEL_23;
    default:
      unint64_t v4 = *(void *)(a2 + 8);
      *(void *)a1 = *(void *)a2;
      *(void *)(a1 + 8) = v4;
      *(unsigned char *)(a1 + 32) = 0;
LABEL_23:
      swift_bridgeObjectRetain(v4);
      return a1;
  }
}

uint64_t assignWithCopy for _PlaygroundQuickLook(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unsigned int v4 = *(unsigned __int8 *)(a1 + 32);
    if (v4 >= 0x13) {
      unsigned int v4 = *(_DWORD *)a1 + 19;
    }
    switch(v4)
    {
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
        break;
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 9u:
      case 0xFu:
      case 0x10u:
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
        break;
      case 0x12u:
        swift_bridgeObjectRelease(*(void *)a1);
        uint64_t v5 = *(void *)(a1 + 16);
        goto LABEL_8;
      default:
        uint64_t v5 = *(void *)(a1 + 8);
LABEL_8:
        swift_bridgeObjectRelease(v5);
        break;
    }
    unsigned int v6 = *(unsigned __int8 *)(a2 + 32);
    if (v6 >= 0x13) {
      unsigned int v6 = *(_DWORD *)a2 + 19;
    }
    switch(v6)
    {
      case 1u:
        *(void *)a1 = *(void *)a2;
        *(unsigned char *)(a1 + 32) = 1;
        return a1;
      case 2u:
        *(void *)a1 = *(void *)a2;
        *(unsigned char *)(a1 + 32) = 2;
        return a1;
      case 3u:
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(unsigned char *)(a1 + 32) = 3;
        return a1;
      case 4u:
        *(void *)a1 = *(void *)a2;
        *(unsigned char *)(a1 + 32) = 4;
        return a1;
      case 5u:
        uint64_t v8 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v8;
        (**(void (***)(uint64_t, uint64_t))(v8 - 8))(a1, a2);
        *(unsigned char *)(a1 + 32) = 5;
        return a1;
      case 6u:
        uint64_t v9 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v9;
        (**(void (***)(uint64_t, uint64_t))(v9 - 8))(a1, a2);
        *(unsigned char *)(a1 + 32) = 6;
        return a1;
      case 7u:
        uint64_t v10 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v10;
        (**(void (***)(uint64_t, uint64_t))(v10 - 8))(a1, a2);
        *(unsigned char *)(a1 + 32) = 7;
        return a1;
      case 8u:
        uint64_t v11 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v11;
        (**(void (***)(uint64_t, uint64_t))(v11 - 8))(a1, a2);
        *(unsigned char *)(a1 + 32) = 8;
        return a1;
      case 9u:
        uint64_t v12 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v12;
        (**(void (***)(uint64_t, uint64_t))(v12 - 8))(a1, a2);
        *(unsigned char *)(a1 + 32) = 9;
        return a1;
      case 0xAu:
        long long v13 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v13;
        *(unsigned char *)(a1 + 32) = 10;
        return a1;
      case 0xBu:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(unsigned char *)(a1 + 32) = 11;
        return a1;
      case 0xCu:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(unsigned char *)(a1 + 32) = 12;
        return a1;
      case 0xDu:
        *(unsigned char *)a1 = *(unsigned char *)a2;
        *(unsigned char *)(a1 + 32) = 13;
        return a1;
      case 0xEu:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(unsigned char *)(a1 + 32) = 14;
        return a1;
      case 0xFu:
        uint64_t v14 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v14;
        (**(void (***)(uint64_t, uint64_t))(v14 - 8))(a1, a2);
        *(unsigned char *)(a1 + 32) = 15;
        return a1;
      case 0x10u:
        uint64_t v15 = *(void *)(a2 + 24);
        *(void *)(a1 + 24) = v15;
        (**(void (***)(uint64_t, uint64_t))(v15 - 8))(a1, a2);
        *(unsigned char *)(a1 + 32) = 16;
        return a1;
      case 0x11u:
        *(void *)a1 = *(void *)a2;
        unint64_t v7 = *(void *)(a2 + 8);
        *(void *)(a1 + 8) = v7;
        *(unsigned char *)(a1 + 32) = 17;
        goto LABEL_31;
      case 0x12u:
        unint64_t v16 = *(void *)a2;
        *(void *)a1 = *(void *)a2;
        *(void *)(a1 + 8) = *(void *)(a2 + 8);
        unint64_t v17 = *(void *)(a2 + 16);
        *(void *)(a1 + 16) = v17;
        *(unsigned char *)(a1 + 32) = 18;
        swift_bridgeObjectRetain(v16);
        unint64_t v7 = v17;
        goto LABEL_31;
      default:
        *(void *)a1 = *(void *)a2;
        unint64_t v7 = *(void *)(a2 + 8);
        *(void *)(a1 + 8) = v7;
        *(unsigned char *)(a1 + 32) = 0;
LABEL_31:
        swift_bridgeObjectRetain(v7);
        break;
    }
  }
  return a1;
}

uint64_t assignWithTake for _PlaygroundQuickLook(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unsigned int v4 = *(unsigned __int8 *)(a1 + 32);
    if (v4 >= 0x13) {
      unsigned int v4 = *(_DWORD *)a1 + 19;
    }
    switch(v4)
    {
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
        break;
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 9u:
      case 0xFu:
      case 0x10u:
        __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)a1);
        break;
      case 0x12u:
        swift_bridgeObjectRelease(*(void *)a1);
        uint64_t v5 = *(void *)(a1 + 16);
        goto LABEL_8;
      default:
        uint64_t v5 = *(void *)(a1 + 8);
LABEL_8:
        swift_bridgeObjectRelease(v5);
        break;
    }
    unsigned int v6 = *(unsigned __int8 *)(a2 + 32);
    if (v6 >= 0x13) {
      unsigned int v6 = *(_DWORD *)a2 + 19;
    }
    switch(v6)
    {
      case 1u:
        *(void *)a1 = *(void *)a2;
        char v7 = 1;
        break;
      case 2u:
        *(void *)a1 = *(void *)a2;
        char v7 = 2;
        break;
      case 3u:
        *(_DWORD *)a1 = *(_DWORD *)a2;
        char v7 = 3;
        break;
      case 4u:
        *(void *)a1 = *(void *)a2;
        char v7 = 4;
        break;
      case 5u:
        long long v8 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v8;
        char v7 = 5;
        break;
      case 6u:
        long long v9 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v9;
        char v7 = 6;
        break;
      case 7u:
        long long v10 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v10;
        char v7 = 7;
        break;
      case 8u:
        long long v11 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v11;
        char v7 = 8;
        break;
      case 9u:
        long long v12 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v12;
        char v7 = 9;
        break;
      case 0xAu:
        long long v13 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v13;
        char v7 = 10;
        break;
      case 0xBu:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        char v7 = 11;
        break;
      case 0xCu:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        char v7 = 12;
        break;
      case 0xDu:
        *(unsigned char *)a1 = *(unsigned char *)a2;
        char v7 = 13;
        break;
      case 0xEu:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        char v7 = 14;
        break;
      case 0xFu:
        long long v14 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v14;
        char v7 = 15;
        break;
      case 0x10u:
        long long v15 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v15;
        char v7 = 16;
        break;
      case 0x11u:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        char v7 = 17;
        break;
      case 0x12u:
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(void *)(a1 + 16) = *(void *)(a2 + 16);
        char v7 = 18;
        break;
      default:
        char v7 = 0;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        break;
    }
    *(unsigned char *)(a1 + 32) = v7;
  }
  return a1;
}

uint64_t getEnumTagSinglePayload for _PlaygroundQuickLook(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xEE && *(unsigned char *)(a1 + 33)) {
    return (*(_DWORD *)a1 + 238);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 32);
  if (v3 >= 0x13) {
    return (v3 ^ 0xFF) + 1;
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for _PlaygroundQuickLook(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xED)
  {
    *(unsigned char *)(result + 32) = 0;
    *(_OWORD *)__n128 result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)__n128 result = a2 - 238;
    if (a3 >= 0xEE) {
      *(unsigned char *)(result + 33) = 1;
    }
  }
  else
  {
    if (a3 >= 0xEE) {
      *(unsigned char *)(result + 33) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 32) = -(char)a2;
    }
  }
  return result;
}

uint64_t getEnumTag for _PlaygroundQuickLook(uint64_t a1)
{
  uint64_t result = *(unsigned __int8 *)(a1 + 32);
  if (result >= 0x13) {
    return (*(_DWORD *)a1 + 19);
  }
  return result;
}

uint64_t destructiveInjectEnumTag for _PlaygroundQuickLook(uint64_t result, unsigned int a2)
{
  if (a2 > 0x12)
  {
    *(_OWORD *)uint64_t result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_DWORD *)uint64_t result = a2 - 19;
    LOBYTE(a2) = 19;
  }
  *(unsigned char *)(result + 32) = a2;
  return result;
}

ValueMetadata *type metadata accessor for _PlaygroundQuickLook()
{
  return &type metadata for _PlaygroundQuickLook;
}

uint64_t dispatch thunk of _CustomPlaygroundQuickLookable.customPlaygroundQuickLook.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of __DefaultCustomPlaygroundQuickLookable._defaultCustomPlaygroundQuickLook.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t *type metadata completion function for CollectionDifference.Change(uint64_t a1)
{
  uint64_t result = swift_checkMetadataState(319, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    swift_getTupleTypeLayout3((uint64_t)v6, (uint64_t)&value witness table for Builtin.Int64.size, v4, (uint64_t)"\t");
    v7[0] = v6;
    swift_getTupleTypeLayout3((uint64_t)v5, (uint64_t)&value witness table for Builtin.Int64.size, v4, (uint64_t)"\t");
    v7[1] = v5;
    swift_initEnumMetadataMultiPayload(a1, 0, 2, (uint64_t)v7);
    return 0;
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for CollectionDifference.Change(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  unint64_t v3 = a1;
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  uint64_t v5 = *(_DWORD *)(v4 + 80);
  uint64_t v6 = *(void *)(v4 + 64) + 7;
  unint64_t v7 = (v6 + ((v5 + 8) & ~v5)) & 0xFFFFFFFFFFFFFFF8;
  if (v5 > 7 || (*(_DWORD *)(v4 + 80) & 0x100000) != 0 || v7 + 10 > 0x18)
  {
    long long v10 = *a2;
    *unint64_t v3 = *a2;
    unint64_t v3 = (atomic_ullong **)((char *)v10 + ((v5 & 0xF8 ^ 0x1F8) & (v5 + 16)));
    swift_retain(v10);
    return v3;
  }
  uint64_t v11 = ~v5;
  unint64_t v12 = v7 + 9;
  unsigned int v13 = *((unsigned __int8 *)a2 + v7 + 9);
  if (v13 >= 2)
  {
    if (v7 == -8)
    {
      int v14 = *(unsigned __int8 *)a2;
LABEL_14:
      unsigned int v13 = (v14 | ((v13 - 2) << (8 * v12))) + 2;
      goto LABEL_16;
    }
    int v14 = *(_DWORD *)a2;
    if (v12 < 4) {
      goto LABEL_14;
    }
    unsigned int v13 = v14 + 2;
  }
LABEL_16:
  *a1 = *a2;
  uint64_t v15 = ((unint64_t)a1 + v5 + 8) & v11;
  uint64_t v16 = ((unint64_t)a2 + v5 + 8) & v11;
  (*(void (**)(uint64_t, uint64_t))(v4 + 16))(v15, v16);
  unint64_t v17 = (v6 + v16) & 0xFFFFFFFFFFFFFFF8;
  char v18 = *(unsigned char *)(v17 + 8);
  unint64_t v19 = (v6 + v15) & 0xFFFFFFFFFFFFFFF8;
  *(void *)unint64_t v19 = *(void *)v17;
  *(unsigned char *)(v19 + 8) = v18;
  *((unsigned char *)v3 + v12) = v13 == 1;
  return v3;
}

void *initializeWithCopy for CollectionDifference.Change(void *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  uint64_t v5 = *(unsigned __int8 *)(v4 + 80);
  uint64_t v6 = ~v5;
  uint64_t v7 = *(void *)(v4 + 64) + 7;
  unint64_t v8 = ((v7 + ((v5 + 8) & ~v5)) & 0xFFFFFFFFFFFFFFF8) + 9;
  unsigned int v9 = a2[v8];
  unsigned int v10 = v9 - 2;
  if (v9 >= 2)
  {
    if (((v7 + ((v5 + 8) & ~v5)) & 0xFFFFFFF8) == 0xFFFFFFF8)
    {
      int v11 = *a2;
    }
    else
    {
      int v11 = *(_DWORD *)a2;
      if (v8 >= 4)
      {
        unsigned int v9 = v11 + 2;
        goto LABEL_7;
      }
    }
    unsigned int v9 = (v11 | (v10 << (8 * v8))) + 2;
  }
LABEL_7:
  BOOL v12 = v9 == 1;
  *a1 = *(void *)a2;
  uint64_t v13 = ((unint64_t)a1 + v5 + 8) & v6;
  uint64_t v14 = (unint64_t)&a2[v5 + 8] & v6;
  (*(void (**)(uint64_t, uint64_t))(v4 + 16))(v13, v14);
  unint64_t v15 = (v7 + v14) & 0xFFFFFFFFFFFFFFF8;
  char v16 = *(unsigned char *)(v15 + 8);
  unint64_t v17 = (v7 + v13) & 0xFFFFFFFFFFFFFFF8;
  *(void *)unint64_t v17 = *(void *)v15;
  *(unsigned char *)(v17 + 8) = v16;
  *((unsigned char *)a1 + v8) = v12;
  return a1;
}

unsigned __int8 *assignWithCopy for CollectionDifference.Change(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = *(void *)(v5 - 8);
    uint64_t v7 = v6;
    uint64_t v8 = *(unsigned __int8 *)(v6 + 80);
    uint64_t v9 = *(void *)(v6 + 64) + 7;
    unint64_t v10 = ((v9 + ((v8 + 8) & ~v8)) & 0xFFFFFFFFFFFFFFF8) + 9;
    uint64_t v11 = (unint64_t)&a1[v8 + 8] & ~v8;
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(v11, v5);
    unsigned int v12 = a2[v10];
    unsigned int v13 = v12 - 2;
    if (v12 >= 2)
    {
      if (((v9 + ((v8 + 8) & ~v8)) & 0xFFFFFFF8) == 0xFFFFFFF8)
      {
        int v14 = *a2;
      }
      else
      {
        int v14 = *(_DWORD *)a2;
        if (v10 >= 4)
        {
          unsigned int v12 = v14 + 2;
          goto LABEL_8;
        }
      }
      unsigned int v12 = (v14 | (v13 << (8 * v10))) + 2;
    }
LABEL_8:
    BOOL v15 = v12 == 1;
    *(void *)a1 = *(void *)a2;
    uint64_t v16 = (unint64_t)&a2[v8 + 8] & ~v8;
    (*(void (**)(unint64_t, uint64_t, uint64_t))(v7 + 16))((unint64_t)&a1[v8 + 8] & ~v8, v16, v5);
    unint64_t v17 = (v9 + v16) & 0xFFFFFFFFFFFFFFF8;
    char v18 = *(unsigned char *)(v17 + 8);
    unint64_t v19 = (v9 + v11) & 0xFFFFFFFFFFFFFFF8;
    *(void *)unint64_t v19 = *(void *)v17;
    *(unsigned char *)(v19 + 8) = v18;
    a1[v10] = v15;
  }
  return a1;
}

void *initializeWithTake for CollectionDifference.Change(void *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  uint64_t v5 = *(unsigned __int8 *)(v4 + 80);
  uint64_t v6 = ~v5;
  uint64_t v7 = *(void *)(v4 + 64) + 7;
  unint64_t v8 = ((v7 + ((v5 + 8) & ~v5)) & 0xFFFFFFFFFFFFFFF8) + 9;
  unsigned int v9 = a2[v8];
  unsigned int v10 = v9 - 2;
  if (v9 >= 2)
  {
    if (((v7 + ((v5 + 8) & ~v5)) & 0xFFFFFFF8) == 0xFFFFFFF8)
    {
      int v11 = *a2;
    }
    else
    {
      int v11 = *(_DWORD *)a2;
      if (v8 >= 4)
      {
        unsigned int v9 = v11 + 2;
        goto LABEL_7;
      }
    }
    unsigned int v9 = (v11 | (v10 << (8 * v8))) + 2;
  }
LABEL_7:
  BOOL v12 = v9 == 1;
  *a1 = *(void *)a2;
  uint64_t v13 = ((unint64_t)a1 + v5 + 8) & v6;
  uint64_t v14 = (unint64_t)&a2[v5 + 8] & v6;
  (*(void (**)(uint64_t, uint64_t))(v4 + 32))(v13, v14);
  unint64_t v15 = (v7 + v14) & 0xFFFFFFFFFFFFFFF8;
  char v16 = *(unsigned char *)(v15 + 8);
  unint64_t v17 = (v7 + v13) & 0xFFFFFFFFFFFFFFF8;
  *(void *)unint64_t v17 = *(void *)v15;
  *(unsigned char *)(v17 + 8) = v16;
  *((unsigned char *)a1 + v8) = v12;
  return a1;
}

unsigned __int8 *assignWithTake for CollectionDifference.Change(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = *(void *)(v5 - 8);
    uint64_t v7 = v6;
    uint64_t v8 = *(unsigned __int8 *)(v6 + 80);
    uint64_t v9 = *(void *)(v6 + 64) + 7;
    unint64_t v10 = ((v9 + ((v8 + 8) & ~v8)) & 0xFFFFFFFFFFFFFFF8) + 9;
    uint64_t v11 = (unint64_t)&a1[v8 + 8] & ~v8;
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(v11, v5);
    unsigned int v12 = a2[v10];
    unsigned int v13 = v12 - 2;
    if (v12 >= 2)
    {
      if (((v9 + ((v8 + 8) & ~v8)) & 0xFFFFFFF8) == 0xFFFFFFF8)
      {
        int v14 = *a2;
      }
      else
      {
        int v14 = *(_DWORD *)a2;
        if (v10 >= 4)
        {
          unsigned int v12 = v14 + 2;
          goto LABEL_8;
        }
      }
      unsigned int v12 = (v14 | (v13 << (8 * v10))) + 2;
    }
LABEL_8:
    BOOL v15 = v12 == 1;
    *(void *)a1 = *(void *)a2;
    uint64_t v16 = (unint64_t)&a2[v8 + 8] & ~v8;
    (*(void (**)(unint64_t, uint64_t, uint64_t))(v7 + 32))((unint64_t)&a1[v8 + 8] & ~v8, v16, v5);
    unint64_t v17 = (v9 + v16) & 0xFFFFFFFFFFFFFFF8;
    char v18 = *(unsigned char *)(v17 + 8);
    unint64_t v19 = (v9 + v11) & 0xFFFFFFFFFFFFFFF8;
    *(void *)unint64_t v19 = *(void *)v17;
    *(unsigned char *)(v19 + 8) = v18;
    a1[v10] = v15;
  }
  return a1;
}

uint64_t getEnumTagSinglePayload for CollectionDifference.Change(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a3 + 16) - 8);
  uint64_t v4 = *(unsigned __int8 *)(v3 + 80);
  uint64_t v5 = *(void *)(v3 + 64);
  if (!a2) {
    return 0;
  }
  unint64_t v6 = (v5 + ((v4 + 8) & ~v4) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (a2 >= 0xFF)
  {
    unint64_t v7 = v6 + 10;
    if ((v6 + 10) <= 3) {
      unsigned int v8 = ((a2 + 65281) >> (8 * (v6 + 10))) + 1;
    }
    else {
      unsigned int v8 = 2;
    }
    if (v8 >= 0x10000) {
      unsigned int v9 = 4;
    }
    else {
      unsigned int v9 = 2;
    }
    if (v8 < 0x100) {
      unsigned int v9 = 1;
    }
    if (v8 >= 2) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0;
    }
    switch(v10)
    {
      case 1:
        int v11 = *((unsigned __int8 *)a1 + v7);
        if (!*((unsigned char *)a1 + v7)) {
          break;
        }
        goto LABEL_19;
      case 2:
        int v11 = *(unsigned __int16 *)((char *)a1 + v7);
        if (*(unsigned __int16 *)((char *)a1 + v7)) {
          goto LABEL_19;
        }
        break;
      case 3:
        __break(1u);
        JUMPOUT(0x181522278);
      case 4:
        int v11 = *(_DWORD *)((char *)a1 + v7);
        if (!v11) {
          break;
        }
LABEL_19:
        int v13 = (v11 - 1) << (8 * (v6 + 10));
        if (v7 <= 3)
        {
          int v14 = *a1;
        }
        else
        {
          int v13 = 0;
          int v14 = *(_DWORD *)a1;
        }
        return (v14 | v13) + 255;
      default:
        break;
    }
  }
  unsigned int v15 = *((unsigned __int8 *)a1 + v6 + 9);
  if (v15 >= 2) {
    return (v15 ^ 0xFF) + 1;
  }
  else {
    return 0;
  }
}

void storeEnumTagSinglePayload for CollectionDifference.Change(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  unint64_t v5 = (*(void *)(*(void *)(*(void *)(a4 + 16) - 8) + 64)
      + ((*(unsigned __int8 *)(*(void *)(*(void *)(a4 + 16) - 8) + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*(void *)(a4 + 16) - 8) + 80))
      + 7) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v6 = v5 + 10;
  char v7 = 8 * (v5 + 10);
  if (a3 < 0xFF)
  {
    int v10 = 0;
    if (a2 > 0xFE) {
      goto LABEL_14;
    }
  }
  else
  {
    if (v6 <= 3) {
      unsigned int v8 = ((a3 + 65281) >> v7) + 1;
    }
    else {
      unsigned int v8 = 2;
    }
    if (v8 >= 0x10000) {
      int v9 = 4;
    }
    else {
      int v9 = 2;
    }
    if (v8 < 0x100) {
      int v9 = 1;
    }
    if (v8 >= 2) {
      int v10 = v9;
    }
    else {
      int v10 = 0;
    }
    if (a2 > 0xFE)
    {
LABEL_14:
      unsigned int v11 = a2 - 255;
      unsigned int v12 = (a2 - 255) >> v7;
      bzero(a1, v5 + 10);
      if (v6 <= 3) {
        int v13 = v12 + 1;
      }
      else {
        int v13 = 1;
      }
      if (v6 > 3) {
        *(_DWORD *)a1 = v11;
      }
      else {
        *(_WORD *)a1 = v11;
      }
      switch(v10)
      {
        case 1:
          a1[v6] = v13;
          return;
        case 2:
          *(_WORD *)&a1[v6] = v13;
          return;
        case 3:
          goto LABEL_34;
        case 4:
          *(_DWORD *)&a1[v6] = v13;
          return;
        default:
          return;
      }
    }
  }
  unint64_t v14 = v5 + 9;
  switch(v10)
  {
    case 1:
      a1[v6] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_28;
    case 2:
      *(_WORD *)&a1[v6] = 0;
      goto LABEL_27;
    case 3:
LABEL_34:
      __break(1u);
      JUMPOUT(0x181522430);
    case 4:
      *(_DWORD *)&a1[v6] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_28;
    default:
LABEL_27:
      if (a2) {
LABEL_28:
      }
        a1[v14] = -(char)a2;
      return;
  }
}

uint64_t getEnumTag for CollectionDifference.Change(unsigned __int8 *a1, uint64_t a2)
{
  unint64_t v2 = ((*(void *)(*(void *)(*(void *)(a2 + 16) - 8) + 64)
       + ((*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8) + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8) + 80))
       + 7) & 0xFFFFFFFFFFFFFFF8)
     + 9;
  uint64_t v3 = a1[v2];
  int v4 = v3 - 2;
  if (v3 >= 2)
  {
    if (((*(_DWORD *)(*(void *)(*(void *)(a2 + 16) - 8) + 64)
         + ((*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8) + 80) + 8) & ~*(unsigned __int8 *)(*(void *)(*(void *)(a2 + 16) - 8) + 80))
         + 7) & 0xFFFFFFF8) == 0xFFFFFFF8)
    {
      int v5 = *a1;
    }
    else
    {
      int v5 = *(_DWORD *)a1;
      if (v2 >= 4) {
        return (v5 + 2);
      }
    }
    v5 |= v4 << (8 * v2);
    return (v5 + 2);
  }
  return v3;
}

void destructiveInjectEnumTag for CollectionDifference.Change(unsigned char *a1, unsigned int a2, uint64_t a3)
{
  unint64_t v4 = (*(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64)
      + 7
      + ((*(unsigned __int8 *)(*(void *)(*(void *)(a3 + 16) - 8) + 80) + 8) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*(void *)(a3 + 16) - 8) + 80))) & 0xFFFFFFFFFFFFFFF8;
  if (a2 > 1)
  {
    size_t v5 = v4 + 9;
    unsigned int v6 = ((a2 - 2) >> (8 * (v4 + 9))) + 2;
    if ((v4 + 9) < 4)
    {
      unsigned int v7 = (a2 - 2);
    }
    else
    {
      LOBYTE(v6) = 2;
      unsigned int v7 = a2 - 2;
    }
    a1[v5] = v6;
    bzero(a1, v5);
    if (v5 == 1) {
      *a1 = v7;
    }
    else {
      *(_DWORD *)a1 = v7;
    }
  }
  else
  {
    a1[v4 + 9] = a2;
  }
}

Class *type metadata accessor for CollectionDifference.Index(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for CollectionDifference.Index.Flags);
}

uint64_t *type metadata completion function for CollectionOfOne(uint64_t a1)
{
  uint64_t result = swift_checkMetadataState(319, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, (uint64_t)&v4, a1 + 24);
    return 0;
  }
  return result;
}

Class *type metadata completion function for CollectionOfOne.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = type metadata accessor for Optional(319, *(void *)(a1 + 16), a3, a4);
  if (v6 <= 0x3F)
  {
    uint64_t v7 = (uint64_t)*(result - 1) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, (uint64_t)&v7, a1 + 24);
    return 0;
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for ClosedRange<>.Index(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  if (*(_DWORD *)(v6 + 84)) {
    size_t v7 = *(void *)(v6 + 64);
  }
  else {
    size_t v7 = *(void *)(v6 + 64) + 1;
  }
  uint64_t v8 = *(_DWORD *)(v6 + 80);
  if (v8 > 7 || (*(_DWORD *)(v6 + 80) & 0x100000) != 0 || v7 > 0x18)
  {
    unsigned int v11 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v11 + ((v8 + 16) & ~v8));
    swift_retain(v11);
  }
  else if ((*(unsigned int (**)(atomic_ullong **, uint64_t, uint64_t))(v6 + 48))(a2, 1, v5))
  {
    memcpy(a1, a2, v7);
  }
  else
  {
    (*(void (**)(atomic_ullong **, atomic_ullong **, uint64_t))(v6 + 16))(a1, a2, v5);
    (*(void (**)(atomic_ullong **, void, uint64_t, uint64_t))(v6 + 56))(a1, 0, 1, v5);
  }
  return a1;
}

uint64_t destroy for ClosedRange<>.Index(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(v3 - 8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v6 + 48))(a1, 1, v3);
  if (!result)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 8);
    return v5(a1, v3);
  }
  return result;
}

void *initializeWithCopy for ClosedRange<>.Index(void *a1, const void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  if ((*(unsigned int (**)(const void *, uint64_t, uint64_t))(v6 + 48))(a2, 1, v5))
  {
    if (*(_DWORD *)(v6 + 84)) {
      size_t v7 = *(void *)(v6 + 64);
    }
    else {
      size_t v7 = *(void *)(v6 + 64) + 1;
    }
    memcpy(a1, a2, v7);
  }
  else
  {
    (*(void (**)(void *, const void *, uint64_t))(v6 + 16))(a1, a2, v5);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v6 + 56))(a1, 0, 1, v5);
  }
  return a1;
}

void *assignWithCopy for ClosedRange<>.Index(void *a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  size_t v7 = *(uint64_t (**)(void *, uint64_t, uint64_t))(v6 + 48);
  int v8 = v7(a1, 1, v5);
  int v9 = v7(a2, 1, v5);
  if (v8)
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, uint64_t))(v6 + 16))(a1, a2, v5);
      (*(void (**)(void *, void, uint64_t, uint64_t))(v6 + 56))(a1, 0, 1, v5);
      return a1;
    }
    int v10 = *(_DWORD *)(v6 + 84);
    size_t v11 = *(void *)(v6 + 64);
  }
  else
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, uint64_t))(v6 + 24))(a1, a2, v5);
      return a1;
    }
    int v13 = *(void (**)(void *, uint64_t))(v6 + 8);
    uint64_t v12 = v6 + 8;
    v13(a1, v5);
    int v10 = *(_DWORD *)(v12 + 76);
    size_t v11 = *(void *)(v12 + 56);
  }
  if (v10) {
    size_t v14 = v11;
  }
  else {
    size_t v14 = v11 + 1;
  }
  memcpy(a1, a2, v14);
  return a1;
}

void *initializeWithTake for ClosedRange<>.Index(void *a1, const void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  if ((*(unsigned int (**)(const void *, uint64_t, uint64_t))(v6 + 48))(a2, 1, v5))
  {
    if (*(_DWORD *)(v6 + 84)) {
      size_t v7 = *(void *)(v6 + 64);
    }
    else {
      size_t v7 = *(void *)(v6 + 64) + 1;
    }
    memcpy(a1, a2, v7);
  }
  else
  {
    (*(void (**)(void *, const void *, uint64_t))(v6 + 32))(a1, a2, v5);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v6 + 56))(a1, 0, 1, v5);
  }
  return a1;
}

void *assignWithTake for ClosedRange<>.Index(void *a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  size_t v7 = *(uint64_t (**)(void *, uint64_t, uint64_t))(v6 + 48);
  int v8 = v7(a1, 1, v5);
  int v9 = v7(a2, 1, v5);
  if (v8)
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, uint64_t))(v6 + 32))(a1, a2, v5);
      (*(void (**)(void *, void, uint64_t, uint64_t))(v6 + 56))(a1, 0, 1, v5);
      return a1;
    }
    int v10 = *(_DWORD *)(v6 + 84);
    size_t v11 = *(void *)(v6 + 64);
  }
  else
  {
    if (!v9)
    {
      (*(void (**)(void *, void *, uint64_t))(v6 + 40))(a1, a2, v5);
      return a1;
    }
    int v13 = *(void (**)(void *, uint64_t))(v6 + 8);
    uint64_t v12 = v6 + 8;
    v13(a1, v5);
    int v10 = *(_DWORD *)(v12 + 76);
    size_t v11 = *(void *)(v12 + 56);
  }
  if (v10) {
    size_t v14 = v11;
  }
  else {
    size_t v14 = v11 + 1;
  }
  memcpy(a1, a2, v14);
  return a1;
}

uint64_t getEnumTagSinglePayload for ClosedRange<>.Index(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  unsigned int v6 = v5 - 1;
  if (!v5) {
    unsigned int v6 = 0;
  }
  uint64_t v7 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
  if (!v5) {
    ++v7;
  }
  if (!a2) {
    return 0;
  }
  int v8 = a2 - v6;
  if (a2 > v6)
  {
    char v9 = 8 * v7;
    if (v7 > 3) {
      goto LABEL_8;
    }
    unsigned int v11 = ((v8 + ~(-1 << v9)) >> v9) + 1;
    if (HIWORD(v11))
    {
      int v10 = *(_DWORD *)((char *)a1 + v7);
      if (v10) {
        goto LABEL_15;
      }
    }
    else
    {
      if (v11 <= 0xFF)
      {
        if (v11 < 2) {
          goto LABEL_25;
        }
LABEL_8:
        int v10 = *((unsigned __int8 *)a1 + v7);
        if (!*((unsigned char *)a1 + v7)) {
          goto LABEL_25;
        }
LABEL_15:
        int v12 = (v10 - 1) << v9;
        if (v7 > 3) {
          int v12 = 0;
        }
        if (v7)
        {
          if (v7 <= 3) {
            int v13 = v7;
          }
          else {
            int v13 = 4;
          }
          switch(v13)
          {
            case 2:
              int v14 = *a1;
              break;
            case 3:
              int v14 = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
              break;
            case 4:
              int v14 = *(_DWORD *)a1;
              break;
            default:
              int v14 = *(unsigned __int8 *)a1;
              break;
          }
        }
        else
        {
          int v14 = 0;
        }
        return v6 + (v14 | v12) + 1;
      }
      int v10 = *(unsigned __int16 *)((char *)a1 + v7);
      if (*(unsigned __int16 *)((char *)a1 + v7)) {
        goto LABEL_15;
      }
    }
  }
LABEL_25:
  if (v5 < 2) {
    return 0;
  }
  unsigned int v16 = (*(uint64_t (**)(void))(v4 + 48))();
  if (v16 >= 2) {
    return v16 - 1;
  }
  else {
    return 0;
  }
}

void storeEnumTagSinglePayload for ClosedRange<>.Index(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  int v6 = 0;
  uint64_t v7 = *(void *)(*(void *)(a4 + 16) - 8);
  unsigned int v8 = *(_DWORD *)(v7 + 84);
  unsigned int v9 = v8 - 1;
  if (v8)
  {
    size_t v10 = *(void *)(v7 + 64);
  }
  else
  {
    unsigned int v9 = 0;
    size_t v10 = *(void *)(v7 + 64) + 1;
  }
  BOOL v11 = a3 >= v9;
  unsigned int v12 = a3 - v9;
  if (v12 == 0 || !v11)
  {
LABEL_13:
    if (v9 < a2) {
      goto LABEL_14;
    }
    goto LABEL_21;
  }
  if (v10 > 3)
  {
    int v6 = 1;
    if (v9 < a2) {
      goto LABEL_14;
    }
    goto LABEL_21;
  }
  unsigned int v13 = ((v12 + ~(-1 << (8 * v10))) >> (8 * v10)) + 1;
  if (!HIWORD(v13))
  {
    if (v13 >= 0x100) {
      int v6 = 2;
    }
    else {
      int v6 = v13 > 1;
    }
    goto LABEL_13;
  }
  int v6 = 4;
  if (v9 < a2)
  {
LABEL_14:
    unsigned int v14 = ~v9 + a2;
    if (v10 < 4)
    {
      int v15 = (v14 >> (8 * v10)) + 1;
      if (v10)
      {
        int v16 = v14 & ~(-1 << (8 * v10));
        bzero(a1, v10);
        if (v10 == 3)
        {
          *(_WORD *)a1 = v16;
          a1[2] = BYTE2(v16);
        }
        else if (v10 == 2)
        {
          *(_WORD *)a1 = v16;
        }
        else
        {
          *a1 = v16;
        }
      }
    }
    else
    {
      bzero(a1, v10);
      *(_DWORD *)a1 = v14;
      int v15 = 1;
    }
    switch(v6)
    {
      case 1:
        a1[v10] = v15;
        return;
      case 2:
        *(_WORD *)&a1[v10] = v15;
        return;
      case 3:
        goto LABEL_39;
      case 4:
        *(_DWORD *)&a1[v10] = v15;
        return;
      default:
        return;
    }
  }
LABEL_21:
  switch(v6)
  {
    case 1:
      a1[v10] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_26;
    case 2:
      *(_WORD *)&a1[v10] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_26;
    case 3:
LABEL_39:
      __break(1u);
      JUMPOUT(0x1815231B4);
    case 4:
      *(_DWORD *)&a1[v10] = 0;
      goto LABEL_25;
    default:
LABEL_25:
      if (a2)
      {
LABEL_26:
        if (v8 >= 2)
        {
          unint64_t v17 = *(void (**)(void))(v7 + 56);
          v17();
        }
      }
      return;
  }
}

Class *type metadata accessor for CollectionOfOne.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for CollectionOfOne.Iterator.Flags);
}

ValueMetadata *type metadata accessor for Duration()
{
  return &type metadata for Duration;
}

uint64_t dispatch thunk of static DurationProtocol./ infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 24))();
}

{
  return (*(uint64_t (**)(void))(a4 + 56))();
}

uint64_t dispatch thunk of static DurationProtocol./= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 32))();
}

uint64_t dispatch thunk of static DurationProtocol.* infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 40))();
}

uint64_t dispatch thunk of static DurationProtocol.*= infix(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 48))();
}

uint64_t dispatch thunk of InstantProtocol.advanced(by:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 40))();
}

uint64_t dispatch thunk of InstantProtocol.duration(to:)(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 48))();
}

ValueMetadata *type metadata accessor for Int128()
{
  return &type metadata for Int128;
}

__n128 __swift_memcpy41_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 25) = *(_OWORD *)(a2 + 25);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Mirror()
{
  return &type metadata for Mirror;
}

void *destroy for Mirror.AncestorRepresentation(void *result)
{
  if (*result >= 0xFFFFFFFFuLL) {
    return (void *)swift_release(result[1]);
  }
  return result;
}

uint64_t initializeBufferWithCopyOfBuffer for Mirror.AncestorRepresentation(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2 < 0xFFFFFFFFuLL)
  {
    *(_OWORD *)a1 = *(_OWORD *)a2;
  }
  else
  {
    long long v3 = *(atomic_ullong **)(a2 + 8);
    *(void *)a1 = *(void *)a2;
    *(void *)(a1 + 8) = v3;
    swift_retain(v3);
  }
  return a1;
}

unint64_t *assignWithCopy for Mirror.AncestorRepresentation(unint64_t *a1, unint64_t *a2)
{
  unint64_t v4 = *a2;
  if (*a1 < 0xFFFFFFFF)
  {
    if (v4 >= 0xFFFFFFFF)
    {
      uint64_t v7 = (atomic_ullong *)a2[1];
      *a1 = v4;
      a1[1] = (unint64_t)v7;
      swift_retain(v7);
      return a1;
    }
LABEL_7:
    *(_OWORD *)a1 = *(_OWORD *)a2;
    return a1;
  }
  if (v4 < 0xFFFFFFFF)
  {
    swift_release(a1[1]);
    goto LABEL_7;
  }
  unsigned int v5 = (atomic_ullong *)a2[1];
  uint64_t v6 = a1[1];
  *a1 = v4;
  a1[1] = (unint64_t)v5;
  swift_retain(v5);
  swift_release(v6);
  return a1;
}

unint64_t *assignWithTake for Mirror.AncestorRepresentation(unint64_t *a1, unint64_t *a2)
{
  unint64_t v4 = *a2;
  if (*a1 < 0xFFFFFFFF)
  {
    if (v4 >= 0xFFFFFFFF)
    {
      unint64_t v7 = a2[1];
      *a1 = v4;
      a1[1] = v7;
      return a1;
    }
LABEL_7:
    *(_OWORD *)a1 = *(_OWORD *)a2;
    return a1;
  }
  if (v4 < 0xFFFFFFFF)
  {
    swift_release(a1[1]);
    goto LABEL_7;
  }
  unint64_t v5 = a2[1];
  uint64_t v6 = a1[1];
  *a1 = v4;
  a1[1] = v5;
  swift_release(v6);
  return a1;
}

uint64_t getEnumTagSinglePayload for Mirror.AncestorRepresentation(uint64_t *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0x7FFFFFFE && *((unsigned char *)a1 + 16)) {
    return (*(_DWORD *)a1 + 2147483646);
  }
  uint64_t v3 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v3) = -1;
  }
  unsigned int v4 = v3 + 1;
  unsigned int v5 = v3 - 1;
  if (v4 >= 3) {
    return v5;
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for Mirror.AncestorRepresentation(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFD)
  {
    *(void *)__n128 result = 0;
    *(void *)(result + 8) = 0;
    *(_DWORD *)__n128 result = a2 - 2147483646;
    if (a3 >= 0x7FFFFFFE) {
      *(unsigned char *)(result + 16) = 1;
    }
  }
  else
  {
    if (a3 >= 0x7FFFFFFE) {
      *(unsigned char *)(result + 16) = 0;
    }
    if (a2) {
      *(void *)__n128 result = a2 + 1;
    }
  }
  return result;
}

uint64_t getEnumTag for Mirror.AncestorRepresentation(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v1) = -1;
  }
  return (v1 + 1);
}

void *destructiveInjectEnumTag for Mirror.AncestorRepresentation(void *result, int a2)
{
  if (a2 < 0)
  {
    uint64_t v2 = a2 ^ 0x80000000;
    result[1] = 0;
  }
  else
  {
    if (!a2) {
      return result;
    }
    uint64_t v2 = (a2 - 1);
  }
  *__n128 result = v2;
  return result;
}

ValueMetadata *type metadata accessor for Mirror.AncestorRepresentation()
{
  return &type metadata for Mirror.AncestorRepresentation;
}

uint64_t getEnumTagSinglePayload for Mirror.DisplayStyle(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xF9) {
    goto LABEL_17;
  }
  if (a2 + 7 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 7) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 7;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 7;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 7;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 8;
  int v8 = v6 - 8;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for Mirror.DisplayStyle(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 7 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 7) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xF9) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xF8)
  {
    unsigned int v6 = ((a2 - 249) >> 8) + 1;
    *__n128 result = a2 + 7;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x1815236B0);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *__n128 result = a2 + 7;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Mirror.DisplayStyle()
{
  return &type metadata for Mirror.DisplayStyle;
}

uint64_t dispatch thunk of CustomReflectable.customMirror.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of CustomPlaygroundDisplayConvertible.playgroundDescription.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

ValueMetadata *type metadata accessor for CommandLine()
{
  return &type metadata for CommandLine;
}

uint64_t initializeWithCopy for ArraySlice(uint64_t a1, uint64_t a2)
{
  int v3 = *(void **)a2;
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  swift_unknownObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for ArraySlice(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(void **)a2;
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = *(void *)a2;
  swift_unknownObjectRetain(v4);
  swift_unknownObjectRelease(v5);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  return a1;
}

uint64_t getEnumTagSinglePayload for ArraySlice(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 32)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for ArraySlice(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0;
    if (a3 < 0) {
      *(unsigned char *)(result + 32) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 32) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for StaticBigInt()
{
  return &type metadata for StaticBigInt;
}

ValueMetadata *type metadata accessor for UInt128()
{
  return &type metadata for UInt128;
}

ValueMetadata *type metadata accessor for UInt128.Words()
{
  return &type metadata for UInt128.Words;
}

uint64_t *type metadata completion function for UnfoldSequence(uint64_t a1)
{
  __n128 result = swift_checkMetadataState(319, *(void *)(a1 + 24));
  if (v3 <= 0x3F)
  {
    v4[0] = *(result - 1) + 64;
    v4[1] = &unk_1ECA05CB0;
    void v4[2] = &unk_1816333A8;
    swift_initStructMetadata(a1, 0, 3uLL, (uint64_t)v4, a1 + 32);
    return 0;
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for UnfoldSequence(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  unsigned int v4 = a1;
  uint64_t v5 = *(void *)(*(void *)(a3 + 24) - 8);
  uint64_t v6 = *(void *)(v5 + 64);
  int v7 = *(_DWORD *)(v5 + 80);
  if ((v7 & 0x1000F8) != 0 || ((v6 + 7) & 0xFFFFFFFFFFFFFFF8) + 17 > 0x18)
  {
    BOOL v11 = *a2;
    void *v4 = *a2;
    unsigned int v4 = (atomic_ullong **)((char *)v11 + ((unsigned __int16)((v7 & 0xF8) + 23) & (unsigned __int16)~(v7 & 0xF8) & 0x1F8));
  }
  else
  {
    (*(void (**)(atomic_ullong **, atomic_ullong **))(v5 + 16))(a1, a2);
    unint64_t v9 = ((unint64_t)v4 + v6 + 7) & 0xFFFFFFFFFFFFFFF8;
    unint64_t v10 = ((unint64_t)a2 + v6 + 7) & 0xFFFFFFFFFFFFFFF8;
    BOOL v11 = *(atomic_ullong **)(v10 + 8);
    *(void *)unint64_t v9 = *(void *)v10;
    *(void *)(v9 + 8) = v11;
    *(unsigned char *)(v9 + 16) = *(unsigned char *)(v10 + 16);
  }
  swift_retain(v11);
  return v4;
}

uint64_t destroy for UnfoldSequence(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(a2 + 24) - 8) + 8;
  (*(void (**)(void))v3)();
  uint64_t v4 = *(void *)(((a1 + *(void *)(v3 + 56) + 7) & 0xFFFFFFFFFFFFFFF8) + 8);

  return swift_release(v4);
}

uint64_t initializeWithCopy for UnfoldSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 24) - 8) + 16;
  (*(void (**)(void))v5)();
  uint64_t v6 = *(void *)(v5 + 48) + 7;
  unint64_t v7 = (v6 + a1) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v8 = (v6 + a2) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v9 = *(atomic_ullong **)(v8 + 8);
  *(void *)unint64_t v7 = *(void *)v8;
  *(void *)(v7 + 8) = v9;
  *(unsigned char *)(v7 + 16) = *(unsigned char *)(v8 + 16);
  swift_retain(v9);
  return a1;
}

uint64_t assignWithCopy for UnfoldSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 24) - 8) + 24;
  (*(void (**)(void))v5)();
  uint64_t v6 = *(void *)(v5 + 40) + 7;
  unint64_t v7 = (v6 + a1) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v8 = (v6 + a2) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v9 = *(atomic_ullong **)(v8 + 8);
  uint64_t v10 = *(void *)(v7 + 8);
  *(void *)unint64_t v7 = *(void *)v8;
  *(void *)(v7 + 8) = v9;
  swift_retain(v9);
  swift_release(v10);
  *(unsigned char *)(v7 + 16) = *(unsigned char *)(v8 + 16);
  return a1;
}

uint64_t initializeWithTake for UnfoldSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 24) - 8) + 32;
  (*(void (**)(void))v5)();
  uint64_t v6 = *(void *)(v5 + 32) + 7;
  unint64_t v7 = (v6 + a1) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v8 = (v6 + a2) & 0xFFFFFFFFFFFFFFF8;
  *(_OWORD *)unint64_t v7 = *(_OWORD *)v8;
  *(unsigned char *)(v7 + 16) = *(unsigned char *)(v8 + 16);
  return a1;
}

uint64_t assignWithTake for UnfoldSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a3 + 24) - 8) + 40;
  (*(void (**)(void))v5)();
  uint64_t v6 = *(void *)(v5 + 24) + 7;
  unint64_t v7 = (v6 + a1) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v8 = (v6 + a2) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v9 = *(void *)(v7 + 8);
  *(_OWORD *)unint64_t v7 = *(_OWORD *)v8;
  swift_release(v9);
  *(unsigned char *)(v7 + 16) = *(unsigned char *)(v8 + 16);
  return a1;
}

uint64_t getEnumTagSinglePayload for UnfoldSequence(unsigned __int8 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 24) - 8);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  uint64_t v6 = *(void *)(v4 + 64);
  if (v5 <= 0x7FFFFFFF) {
    unsigned int v7 = 0x7FFFFFFF;
  }
  else {
    unsigned int v7 = *(_DWORD *)(v4 + 84);
  }
  if (!a2) {
    return 0;
  }
  if (v7 < a2)
  {
    unint64_t v8 = ((v6 + 7) & 0xFFFFFFFFFFFFFFF8) + 17;
    unsigned int v9 = (a2 - v7 + 255) >> (8 * v8);
    if (v8 < 4) {
      unsigned int v10 = v9 + 1;
    }
    else {
      unsigned int v10 = 2;
    }
    if (v10 >= 0x10000) {
      unsigned int v11 = 4;
    }
    else {
      unsigned int v11 = 2;
    }
    if (v10 < 0x100) {
      unsigned int v11 = 1;
    }
    if (v10 >= 2) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = 0;
    }
    switch(v12)
    {
      case 1:
        int v13 = a1[v8];
        if (!a1[v8]) {
          break;
        }
        goto LABEL_22;
      case 2:
        int v13 = *(unsigned __int16 *)&a1[v8];
        if (*(_WORD *)&a1[v8]) {
          goto LABEL_22;
        }
        break;
      case 3:
        __break(1u);
        JUMPOUT(0x181523E2CLL);
      case 4:
        int v13 = *(_DWORD *)&a1[v8];
        if (!v13) {
          break;
        }
LABEL_22:
        int v15 = (v13 - 1) << (8 * v8);
        if (v8 >= 4) {
          int v15 = 0;
        }
        if (((v6 + 7) & 0xFFFFFFF8) == 0xFFFFFFF0) {
          int v16 = *a1;
        }
        else {
          int v16 = *(_DWORD *)a1;
        }
        return v7 + (v16 | v15) + 1;
      default:
        break;
    }
  }
  if (v5 >= 0x7FFFFFFF) {
    return (*(uint64_t (**)(void))(v4 + 48))();
  }
  unint64_t v17 = *(void *)((unint64_t)&a1[v6 + 7] & 0xFFFFFFFFFFFFFFF8);
  if (v17 >= 0xFFFFFFFF) {
    LODWORD(v17) = -1;
  }
  return (v17 + 1);
}

void storeEnumTagSinglePayload for UnfoldSequence(unsigned char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 24) - 8);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  if (v7 <= 0x7FFFFFFF) {
    unsigned int v8 = 0x7FFFFFFF;
  }
  else {
    unsigned int v8 = *(_DWORD *)(v6 + 84);
  }
  uint64_t v9 = *(void *)(*(void *)(*(void *)(a4 + 24) - 8) + 64);
  size_t v10 = ((v9 + 7) & 0xFFFFFFFFFFFFFFF8) + 17;
  char v11 = 8 * v10;
  if (v8 >= a3)
  {
    int v15 = 0;
    if (v8 >= a2)
    {
LABEL_17:
      switch(v15)
      {
        case 1:
          a1[v10] = 0;
          if (!a2) {
            return;
          }
          goto LABEL_34;
        case 2:
          *(_WORD *)&a1[v10] = 0;
          if (!a2) {
            return;
          }
          goto LABEL_34;
        case 3:
          goto LABEL_47;
        case 4:
          *(_DWORD *)&a1[v10] = 0;
          goto LABEL_33;
        default:
LABEL_33:
          if (a2)
          {
LABEL_34:
            if (v7 < 0x7FFFFFFF)
            {
              int v21 = (void *)((unint64_t)&a1[v9 + 7] & 0xFFFFFFFFFFFFFFF8);
              if ((a2 & 0x80000000) != 0)
              {
                uint64_t v22 = a2 ^ 0x80000000;
                v21[1] = 0;
              }
              else
              {
                uint64_t v22 = a2 - 1;
              }
              *int v21 = v22;
            }
            else
            {
              unsigned int v20 = *(void (**)(void))(v6 + 56);
              v20();
            }
          }
          break;
      }
      return;
    }
  }
  else
  {
    unsigned int v12 = (a3 - v8 + 255) >> v11;
    if (v10 <= 3) {
      unsigned int v13 = v12 + 1;
    }
    else {
      unsigned int v13 = 2;
    }
    if (v13 >= 0x10000) {
      int v14 = 4;
    }
    else {
      int v14 = 2;
    }
    if (v13 < 0x100) {
      int v14 = 1;
    }
    if (v13 >= 2) {
      int v15 = v14;
    }
    else {
      int v15 = 0;
    }
    if (v8 >= a2) {
      goto LABEL_17;
    }
  }
  unsigned int v16 = ~v8 + a2;
  unsigned int v17 = (~(_BYTE)v8 + a2);
  if (v10 < 4) {
    int v18 = (v16 >> v11) + 1;
  }
  else {
    int v18 = 1;
  }
  if (v10 >= 4) {
    unsigned int v19 = v16;
  }
  else {
    unsigned int v19 = v17;
  }
  bzero(a1, v10);
  if (v10 == 1) {
    *a1 = v19;
  }
  else {
    *(_DWORD *)a1 = v19;
  }
  switch(v15)
  {
    case 1:
      a1[v10] = v18;
      break;
    case 2:
      *(_WORD *)&a1[v10] = v18;
      break;
    case 3:
LABEL_47:
      __break(1u);
      JUMPOUT(0x181524054);
    case 4:
      *(_DWORD *)&a1[v10] = v18;
      break;
    default:
      return;
  }
}

uint64_t dispatch thunk of CVarArg._cVarArgEncoding.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 8))();
}

uint64_t dispatch thunk of _CVarArgAligned._cVarArgAlignment.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 16))();
}

uint64_t method lookup function for __VaListBuilder(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for __VaListBuilder.Flags);
}

uint64_t dispatch thunk of __VaListBuilder.__allocating_init()()
{
  return (*(uint64_t (**)(void))(v0 + 112))();
}

const char *type metadata completion function for Zip2Sequence.Iterator(uint64_t a1)
{
  __n128 result = swift_getAssociatedTypeWitness(319, *(int ***)(a1 + 32), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  if (v3 <= 0x3F)
  {
    v5[0] = *((void *)result - 1) + 64;
    __n128 result = swift_getAssociatedTypeWitness(319, *(int ***)(a1 + 40), *(void *)(a1 + 24), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
    if (v4 <= 0x3F)
    {
      v5[1] = *((void *)result - 1) + 64;
      v5[2] = &unk_1816333A8;
      swift_initStructMetadata(a1, 0, 3uLL, (uint64_t)v5, a1 + 48);
      return 0;
    }
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for Zip2Sequence.Iterator(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 32), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = *(void *)(v7 + 64);
  uint64_t v9 = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 40), *(void *)(a3 + 24), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *((void *)v9 - 1);
  uint64_t v11 = *(_DWORD *)(v10 + 80);
  uint64_t v12 = v8 + v11;
  uint64_t v13 = *(void *)(v10 + 64);
  uint64_t v14 = (*(unsigned char *)(v7 + 80) | *(unsigned char *)(v10 + 80));
  if (v14 > 7
    || ((*(_DWORD *)(v7 + 80) | *(_DWORD *)(v10 + 80)) & 0x100000) != 0
    || v13 + (v12 & (unint64_t)~v11) + 1 > 0x18)
  {
    unsigned int v17 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v17 + ((v14 + 16) & ~v14));
    swift_retain(v17);
  }
  else
  {
    int v18 = v9;
    uint64_t v19 = ~v11;
    (*(void (**)(atomic_ullong **, atomic_ullong **, const char *))(v7 + 16))(a1, a2, AssociatedTypeWitness);
    unint64_t v20 = ((unint64_t)a2 + v12) & v19;
    (*(void (**)(unint64_t, unint64_t, const char *))(v10 + 16))(((unint64_t)a1 + v12) & v19, v20, v18);
    *(unsigned char *)((((unint64_t)a1 + v12) & v19) + v13) = *(unsigned char *)(v20 + v13);
  }
  return a1;
}

uint64_t destroy for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 32), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v5 = *((void *)AssociatedTypeWitness - 1) + 8;
  (*(void (**)(uint64_t, const char *))v5)(a1, AssociatedTypeWitness);
  uint64_t v6 = *(void *)(v5 + 56) + a1;
  uint64_t v7 = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 40), *(void *)(a2 + 24), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v8 = *((void *)v7 - 1);
  uint64_t v9 = *(uint64_t (**)(unint64_t, const char *))(v8 + 8);
  uint64_t v10 = v7;
  unint64_t v11 = (v6 + *(unsigned __int8 *)(v8 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80);

  return v9(v11, v10);
}

uint64_t initializeWithCopy for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 32), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1) + 16;
  (*(void (**)(uint64_t, uint64_t, const char *))v7)(a1, a2, AssociatedTypeWitness);
  uint64_t v8 = *(void *)(v7 + 48);
  uint64_t v9 = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 40), *(void *)(a3 + 24), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *((void *)v9 - 1);
  uint64_t v11 = v10 + 16;
  uint64_t v12 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v13 = (v8 + v12 + a1) & ~v12;
  uint64_t v14 = (v8 + v12 + a2) & ~v12;
  (*(void (**)(uint64_t, uint64_t, const char *))(v10 + 16))(v13, v14, v9);
  *(unsigned char *)(*(void *)(v11 + 48) + v13) = *(unsigned char *)(*(void *)(v11 + 48) + v14);
  return a1;
}

uint64_t assignWithCopy for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 32), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1) + 24;
  (*(void (**)(uint64_t, uint64_t, const char *))v7)(a1, a2, AssociatedTypeWitness);
  uint64_t v8 = *(void *)(v7 + 40);
  uint64_t v9 = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 40), *(void *)(a3 + 24), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *((void *)v9 - 1);
  uint64_t v11 = v10 + 24;
  uint64_t v12 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v13 = (v8 + v12 + a1) & ~v12;
  uint64_t v14 = (v8 + v12 + a2) & ~v12;
  (*(void (**)(uint64_t, uint64_t, const char *))(v10 + 24))(v13, v14, v9);
  *(unsigned char *)(*(void *)(v11 + 40) + v13) = *(unsigned char *)(*(void *)(v11 + 40) + v14);
  return a1;
}

uint64_t initializeWithTake for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 32), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1) + 32;
  (*(void (**)(uint64_t, uint64_t, const char *))v7)(a1, a2, AssociatedTypeWitness);
  uint64_t v8 = *(void *)(v7 + 32);
  uint64_t v9 = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 40), *(void *)(a3 + 24), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *((void *)v9 - 1);
  uint64_t v11 = v10 + 32;
  uint64_t v12 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v13 = (v8 + v12 + a1) & ~v12;
  uint64_t v14 = (v8 + v12 + a2) & ~v12;
  (*(void (**)(uint64_t, uint64_t, const char *))(v10 + 32))(v13, v14, v9);
  *(unsigned char *)(*(void *)(v11 + 32) + v13) = *(unsigned char *)(*(void *)(v11 + 32) + v14);
  return a1;
}

uint64_t assignWithTake for Zip2Sequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 32), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1) + 40;
  (*(void (**)(uint64_t, uint64_t, const char *))v7)(a1, a2, AssociatedTypeWitness);
  uint64_t v8 = *(void *)(v7 + 24);
  uint64_t v9 = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 40), *(void *)(a3 + 24), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *((void *)v9 - 1);
  uint64_t v11 = v10 + 40;
  uint64_t v12 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v13 = (v8 + v12 + a1) & ~v12;
  uint64_t v14 = (v8 + v12 + a2) & ~v12;
  (*(void (**)(uint64_t, uint64_t, const char *))(v10 + 40))(v13, v14, v9);
  *(unsigned char *)(*(void *)(v11 + 24) + v13) = *(unsigned char *)(*(void *)(v11 + 24) + v14);
  return a1;
}

uint64_t getEnumTagSinglePayload for Zip2Sequence.Iterator(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 32), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v8 = *(unsigned int *)(v7 + 84);
  uint64_t v9 = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 40), *(void *)(a3 + 24), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v10 = *((void *)v9 - 1);
  unsigned int v11 = *(_DWORD *)(v10 + 84);
  if (v11 <= v8) {
    unsigned int v12 = v8;
  }
  else {
    unsigned int v12 = *(_DWORD *)(v10 + 84);
  }
  uint64_t v13 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v14 = *(void *)(*((void *)v9 - 1) + 64);
  if (v12 <= 0xFE) {
    unsigned int v15 = 254;
  }
  else {
    unsigned int v15 = v12;
  }
  if (!a2) {
    return 0;
  }
  uint64_t v16 = *(void *)(v7 + 64) + v13;
  if (a2 > v15)
  {
    uint64_t v17 = v14 + (v16 & ~v13) + 1;
    char v18 = 8 * v17;
    if (v17 > 3) {
      goto LABEL_10;
    }
    unsigned int v20 = ((a2 - v15 + ~(-1 << v18)) >> v18) + 1;
    if (HIWORD(v20))
    {
      int v19 = *(_DWORD *)((char *)a1 + v17);
      if (!v19) {
        goto LABEL_27;
      }
      goto LABEL_17;
    }
    if (v20 > 0xFF)
    {
      int v19 = *(unsigned __int16 *)((char *)a1 + v17);
      if (!*(unsigned __int16 *)((char *)a1 + v17)) {
        goto LABEL_27;
      }
      goto LABEL_17;
    }
    if (v20 >= 2)
    {
LABEL_10:
      int v19 = *((unsigned __int8 *)a1 + v17);
      if (!*((unsigned char *)a1 + v17)) {
        goto LABEL_27;
      }
LABEL_17:
      int v21 = (v19 - 1) << v18;
      if (v17 > 3) {
        int v21 = 0;
      }
      if (v17)
      {
        if (v17 <= 3) {
          int v22 = v17;
        }
        else {
          int v22 = 4;
        }
        switch(v22)
        {
          case 2:
            int v23 = *a1;
            break;
          case 3:
            int v23 = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
            break;
          case 4:
            int v23 = *(_DWORD *)a1;
            break;
          default:
            int v23 = *(unsigned __int8 *)a1;
            break;
        }
      }
      else
      {
        int v23 = 0;
      }
      int v29 = v15 + (v23 | v21);
      return (v29 + 1);
    }
  }
LABEL_27:
  if (v8 == v15)
  {
    int v24 = *(uint64_t (**)(unsigned __int16 *, uint64_t, const char *))(v7 + 48);
    return v24(a1, v8, AssociatedTypeWitness);
  }
  unint64_t v26 = ((unint64_t)a1 + v16) & ~v13;
  if (v11 != v15)
  {
    unsigned int v28 = *(unsigned __int8 *)(v26 + v14);
    if (v28 < 2) {
      return 0;
    }
    int v29 = (v28 + 2147483646) & 0x7FFFFFFF;
    return (v29 + 1);
  }
  uint64_t v27 = *(uint64_t (**)(unint64_t))(v10 + 48);

  return v27(v26);
}

void storeEnumTagSinglePayload for Zip2Sequence.Iterator(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 32), *(void *)(a4 + 16), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v10 = *(unsigned int *)(v9 + 84);
  uint64_t v11 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 40), *(void *)(a4 + 24), (uint64_t)&protocol requirements base descriptor for Sequence, associated type descriptor for Sequence.Iterator)- 1);
  uint64_t v12 = v11;
  unsigned int v13 = *(_DWORD *)(v11 + 84);
  if (v13 <= v10) {
    unsigned int v14 = v10;
  }
  else {
    unsigned int v14 = *(_DWORD *)(v11 + 84);
  }
  uint64_t v15 = *(void *)(v9 + 64);
  uint64_t v16 = *(unsigned __int8 *)(v11 + 80);
  uint64_t v17 = *(void *)(v11 + 64);
  if (v14 <= 0xFE) {
    unsigned int v18 = 254;
  }
  else {
    unsigned int v18 = v14;
  }
  uint64_t v19 = v15 + v16;
  size_t v20 = v17 + ((v15 + v16) & ~v16) + 1;
  if (a3 <= v18)
  {
    int v21 = 0;
  }
  else if (v20 <= 3)
  {
    unsigned int v25 = ((a3 - v18 + ~(-1 << (8 * v20))) >> (8 * v20)) + 1;
    if (HIWORD(v25))
    {
      int v21 = 4;
    }
    else if (v25 >= 0x100)
    {
      int v21 = 2;
    }
    else
    {
      int v21 = v25 > 1;
    }
  }
  else
  {
    int v21 = 1;
  }
  if (v18 < a2)
  {
    unsigned int v22 = ~v18 + a2;
    if (v20 < 4)
    {
      int v23 = (v22 >> (8 * v20)) + 1;
      if (v20)
      {
        int v26 = v22 & ~(-1 << (8 * v20));
        bzero(a1, v20);
        if (v20 == 3)
        {
          *(_WORD *)a1 = v26;
          a1[2] = BYTE2(v26);
        }
        else if (v20 == 2)
        {
          *(_WORD *)a1 = v26;
        }
        else
        {
          *a1 = v26;
        }
      }
    }
    else
    {
      bzero(a1, v20);
      *(_DWORD *)a1 = v22;
      int v23 = 1;
    }
    switch(v21)
    {
      case 1:
        a1[v20] = v23;
        return;
      case 2:
        *(_WORD *)&a1[v20] = v23;
        return;
      case 3:
        goto LABEL_46;
      case 4:
        *(_DWORD *)&a1[v20] = v23;
        return;
      default:
        return;
    }
  }
  uint64_t v24 = ~v16;
  switch(v21)
  {
    case 1:
      a1[v20] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_27;
    case 2:
      *(_WORD *)&a1[v20] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_27;
    case 3:
LABEL_46:
      __break(1u);
      JUMPOUT(0x181524F5CLL);
    case 4:
      *(_DWORD *)&a1[v20] = 0;
      goto LABEL_26;
    default:
LABEL_26:
      if (a2)
      {
LABEL_27:
        if (v10 == v18)
        {
          uint64_t v27 = *(void (**)(unsigned char *, uint64_t, uint64_t, const char *))(v9 + 56);
          v27(a1, a2, v10, AssociatedTypeWitness);
        }
        else
        {
          unint64_t v28 = (unint64_t)&a1[v19] & v24;
          if (v13 == v18)
          {
            int v29 = *(void (**)(unint64_t, uint64_t))(v12 + 56);
            v29(v28, a2);
          }
          else
          {
            *(unsigned char *)(v28 + v17) = a2 + 1;
          }
        }
      }
      return;
  }
}

uint64_t dispatch thunk of SIMDStorage.scalarCount.getter(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 40))();
}

uint64_t dispatch thunk of SIMDStorage.init()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(a2 + 48))();
}

uint64_t dispatch thunk of SIMDStorage.subscript.getter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(a3 + 56))();
}

uint64_t dispatch thunk of SIMDStorage.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 64))();
}

uint64_t dispatch thunk of SIMDStorage.subscript.modify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(a4 + 72))();
}

uint64_t type metadata accessor for _stdlib_AtomicInt()
{
  return self;
}

uint64_t method lookup function for _stdlib_AtomicInt(uint64_t a1, uint64_t a2)
{
  return swift_lookUpClassMethod(a1, a2, &nominal type descriptor for _stdlib_AtomicInt.Flags);
}

uint64_t dispatch thunk of _stdlib_AtomicInt.__allocating_init(_:)()
{
  return (*(uint64_t (**)(void))(v0 + 88))();
}

ValueMetadata *type metadata accessor for Float16()
{
  return &type metadata for Float16;
}

ValueMetadata *type metadata accessor for Float()
{
  return &type metadata for Float;
}

ValueMetadata *type metadata accessor for Double()
{
  return &type metadata for Double;
}

ValueMetadata *type metadata accessor for Float80()
{
  return &type metadata for Float80;
}

ValueMetadata *type metadata accessor for UInt8()
{
  return &type metadata for UInt8;
}

ValueMetadata *type metadata accessor for UInt8.Words()
{
  return &type metadata for UInt8.Words;
}

ValueMetadata *type metadata accessor for Int8()
{
  return &type metadata for Int8;
}

ValueMetadata *type metadata accessor for Int8.Words()
{
  return &type metadata for Int8.Words;
}

ValueMetadata *type metadata accessor for UInt16()
{
  return &type metadata for UInt16;
}

ValueMetadata *type metadata accessor for UInt16.Words()
{
  return &type metadata for UInt16.Words;
}

ValueMetadata *type metadata accessor for Int16()
{
  return &type metadata for Int16;
}

ValueMetadata *type metadata accessor for Int16.Words()
{
  return &type metadata for Int16.Words;
}

ValueMetadata *type metadata accessor for UInt32()
{
  return &type metadata for UInt32;
}

ValueMetadata *type metadata accessor for UInt32.Words()
{
  return &type metadata for UInt32.Words;
}

ValueMetadata *type metadata accessor for Int32()
{
  return &type metadata for Int32;
}

ValueMetadata *type metadata accessor for Int32.Words()
{
  return &type metadata for Int32.Words;
}

ValueMetadata *type metadata accessor for UInt64()
{
  return &type metadata for UInt64;
}

ValueMetadata *type metadata accessor for UInt64.Words()
{
  return &type metadata for UInt64.Words;
}

ValueMetadata *type metadata accessor for Int64()
{
  return &type metadata for Int64;
}

ValueMetadata *type metadata accessor for Int64.Words()
{
  return &type metadata for Int64.Words;
}

ValueMetadata *type metadata accessor for UInt()
{
  return &type metadata for UInt;
}

ValueMetadata *type metadata accessor for UInt.Words()
{
  return &type metadata for UInt.Words;
}

ValueMetadata *type metadata accessor for Int()
{
  return &type metadata for Int;
}

ValueMetadata *type metadata accessor for Int.Words()
{
  return &type metadata for Int.Words;
}

uint64_t getEnumTagSinglePayload for UnsafeBufferPointer.Iterator(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for UnsafeBufferPointer.Iterator(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)__n128 result = (a2 - 1);
    *(void *)(result + 8) = 0;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 16) = v3;
  return result;
}

ValueMetadata *type metadata accessor for UnsafeMutableRawBufferPointer()
{
  return &type metadata for UnsafeMutableRawBufferPointer;
}

ValueMetadata *type metadata accessor for UnsafeRawBufferPointer()
{
  return &type metadata for UnsafeRawBufferPointer;
}

ValueMetadata *type metadata accessor for UnsafeRawBufferPointer.Iterator()
{
  return &type metadata for UnsafeRawBufferPointer.Iterator;
}

const char *type metadata completion function for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
}

atomic_ullong **initializeBufferWithCopyOfBuffer for SIMD2(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
}

uint64_t destroy for SIMD2(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
}

uint64_t initializeWithCopy for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
}

uint64_t assignWithCopy for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
}

uint64_t initializeWithTake for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
}

uint64_t assignWithTake for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
}

uint64_t getEnumTagSinglePayload for SIMD2(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD2Storage);
}

void storeEnumTagSinglePayload for SIMD2(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
}

const char *type metadata completion function for SIMD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
}

atomic_ullong **initializeBufferWithCopyOfBuffer for SIMD4(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t destroy for SIMD4(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t initializeWithCopy for SIMD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t assignWithCopy for SIMD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t initializeWithTake for SIMD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t assignWithTake for SIMD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
}

uint64_t getEnumTagSinglePayload for SIMD4(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD4Storage);
}

void storeEnumTagSinglePayload for SIMD4(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
}

const char *type metadata completion function for SIMD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
}

atomic_ullong **initializeBufferWithCopyOfBuffer for SIMD8(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
}

uint64_t destroy for SIMD8(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
}

uint64_t initializeWithCopy for SIMD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
}

uint64_t assignWithCopy for SIMD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
}

uint64_t initializeWithTake for SIMD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
}

uint64_t assignWithTake for SIMD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
}

uint64_t getEnumTagSinglePayload for SIMD8(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD8Storage);
}

void storeEnumTagSinglePayload for SIMD8(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
}

const char *type metadata completion function for SIMD16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
}

atomic_ullong **initializeBufferWithCopyOfBuffer for SIMD16(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
}

uint64_t destroy for SIMD16(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
}

uint64_t initializeWithCopy for SIMD16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
}

uint64_t assignWithCopy for SIMD16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
}

uint64_t initializeWithTake for SIMD16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
}

uint64_t assignWithTake for SIMD16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
}

uint64_t getEnumTagSinglePayload for SIMD16(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD16Storage);
}

void storeEnumTagSinglePayload for SIMD16(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
}

const char *type metadata completion function for SIMD32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
}

atomic_ullong **initializeBufferWithCopyOfBuffer for SIMD32(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
}

uint64_t destroy for SIMD32(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
}

uint64_t initializeWithCopy for SIMD32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
}

uint64_t assignWithCopy for SIMD32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
}

uint64_t initializeWithTake for SIMD32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
}

uint64_t assignWithTake for SIMD32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
}

uint64_t getEnumTagSinglePayload for SIMD32(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD32Storage);
}

void storeEnumTagSinglePayload for SIMD32(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
}

const char *type metadata completion function for SIMD64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
}

atomic_ullong **initializeBufferWithCopyOfBuffer for SIMD64(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
}

uint64_t destroy for SIMD64(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator(a1, a2, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
}

uint64_t initializeWithCopy for SIMD64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
}

uint64_t assignWithCopy for SIMD64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
}

uint64_t initializeWithTake for SIMD64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
}

uint64_t assignWithTake for SIMD64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
}

uint64_t getEnumTagSinglePayload for SIMD64(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for SIMDScalar, associated type descriptor for SIMDScalar.SIMD64Storage);
}

void storeEnumTagSinglePayload for SIMD64(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
}

ValueMetadata *type metadata accessor for UInt8.SIMD2Storage()
{
  return &type metadata for UInt8.SIMD2Storage;
}

ValueMetadata *type metadata accessor for UInt8.SIMD4Storage()
{
  return &type metadata for UInt8.SIMD4Storage;
}

ValueMetadata *type metadata accessor for UInt8.SIMD8Storage()
{
  return &type metadata for UInt8.SIMD8Storage;
}

ValueMetadata *type metadata accessor for UInt8.SIMD16Storage()
{
  return &type metadata for UInt8.SIMD16Storage;
}

__n128 __swift_memcpy32_16(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

ValueMetadata *type metadata accessor for UInt8.SIMD32Storage()
{
  return &type metadata for UInt8.SIMD32Storage;
}

__n128 __swift_memcpy64_16(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

ValueMetadata *type metadata accessor for UInt8.SIMD64Storage()
{
  return &type metadata for UInt8.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Int8.SIMD2Storage()
{
  return &type metadata for Int8.SIMD2Storage;
}

ValueMetadata *type metadata accessor for Int8.SIMD4Storage()
{
  return &type metadata for Int8.SIMD4Storage;
}

ValueMetadata *type metadata accessor for Int8.SIMD8Storage()
{
  return &type metadata for Int8.SIMD8Storage;
}

ValueMetadata *type metadata accessor for Int8.SIMD16Storage()
{
  return &type metadata for Int8.SIMD16Storage;
}

ValueMetadata *type metadata accessor for Int8.SIMD32Storage()
{
  return &type metadata for Int8.SIMD32Storage;
}

ValueMetadata *type metadata accessor for Int8.SIMD64Storage()
{
  return &type metadata for Int8.SIMD64Storage;
}

ValueMetadata *type metadata accessor for UInt16.SIMD2Storage()
{
  return &type metadata for UInt16.SIMD2Storage;
}

ValueMetadata *type metadata accessor for UInt16.SIMD4Storage()
{
  return &type metadata for UInt16.SIMD4Storage;
}

ValueMetadata *type metadata accessor for UInt16.SIMD8Storage()
{
  return &type metadata for UInt16.SIMD8Storage;
}

ValueMetadata *type metadata accessor for UInt16.SIMD16Storage()
{
  return &type metadata for UInt16.SIMD16Storage;
}

ValueMetadata *type metadata accessor for UInt16.SIMD32Storage()
{
  return &type metadata for UInt16.SIMD32Storage;
}

__n128 __swift_memcpy128_16(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  long long v3 = a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  __n128 result = (__n128)a2[4];
  long long v6 = a2[5];
  long long v7 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v7;
  *(__n128 *)(a1 + 64) = result;
  *(_OWORD *)(a1 + 80) = v6;
  return result;
}

ValueMetadata *type metadata accessor for UInt16.SIMD64Storage()
{
  return &type metadata for UInt16.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Int16.SIMD2Storage()
{
  return &type metadata for Int16.SIMD2Storage;
}

ValueMetadata *type metadata accessor for Int16.SIMD4Storage()
{
  return &type metadata for Int16.SIMD4Storage;
}

ValueMetadata *type metadata accessor for Int16.SIMD8Storage()
{
  return &type metadata for Int16.SIMD8Storage;
}

ValueMetadata *type metadata accessor for Int16.SIMD16Storage()
{
  return &type metadata for Int16.SIMD16Storage;
}

ValueMetadata *type metadata accessor for Int16.SIMD32Storage()
{
  return &type metadata for Int16.SIMD32Storage;
}

ValueMetadata *type metadata accessor for Int16.SIMD64Storage()
{
  return &type metadata for Int16.SIMD64Storage;
}

ValueMetadata *type metadata accessor for UInt32.SIMD2Storage()
{
  return &type metadata for UInt32.SIMD2Storage;
}

ValueMetadata *type metadata accessor for UInt32.SIMD4Storage()
{
  return &type metadata for UInt32.SIMD4Storage;
}

ValueMetadata *type metadata accessor for UInt32.SIMD8Storage()
{
  return &type metadata for UInt32.SIMD8Storage;
}

ValueMetadata *type metadata accessor for UInt32.SIMD16Storage()
{
  return &type metadata for UInt32.SIMD16Storage;
}

ValueMetadata *type metadata accessor for UInt32.SIMD32Storage()
{
  return &type metadata for UInt32.SIMD32Storage;
}

__n128 __swift_memcpy256_16(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  long long v3 = a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  long long v5 = a2[4];
  long long v6 = a2[5];
  long long v7 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v7;
  *(_OWORD *)(a1 + 64) = v5;
  *(_OWORD *)(a1 + 80) = v6;
  long long v8 = a2[8];
  long long v9 = a2[9];
  long long v10 = a2[11];
  *(_OWORD *)(a1 + 160) = a2[10];
  *(_OWORD *)(a1 + 176) = v10;
  *(_OWORD *)(a1 + 128) = v8;
  *(_OWORD *)(a1 + 144) = v9;
  __n128 result = (__n128)a2[12];
  long long v12 = a2[13];
  long long v13 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 240) = v13;
  *(__n128 *)(a1 + 192) = result;
  *(_OWORD *)(a1 + 208) = v12;
  return result;
}

ValueMetadata *type metadata accessor for UInt32.SIMD64Storage()
{
  return &type metadata for UInt32.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Int32.SIMD2Storage()
{
  return &type metadata for Int32.SIMD2Storage;
}

ValueMetadata *type metadata accessor for Int32.SIMD4Storage()
{
  return &type metadata for Int32.SIMD4Storage;
}

ValueMetadata *type metadata accessor for Int32.SIMD8Storage()
{
  return &type metadata for Int32.SIMD8Storage;
}

ValueMetadata *type metadata accessor for Int32.SIMD16Storage()
{
  return &type metadata for Int32.SIMD16Storage;
}

ValueMetadata *type metadata accessor for Int32.SIMD32Storage()
{
  return &type metadata for Int32.SIMD32Storage;
}

ValueMetadata *type metadata accessor for Int32.SIMD64Storage()
{
  return &type metadata for Int32.SIMD64Storage;
}

ValueMetadata *type metadata accessor for UInt64.SIMD2Storage()
{
  return &type metadata for UInt64.SIMD2Storage;
}

ValueMetadata *type metadata accessor for UInt64.SIMD4Storage()
{
  return &type metadata for UInt64.SIMD4Storage;
}

ValueMetadata *type metadata accessor for UInt64.SIMD8Storage()
{
  return &type metadata for UInt64.SIMD8Storage;
}

ValueMetadata *type metadata accessor for UInt64.SIMD16Storage()
{
  return &type metadata for UInt64.SIMD16Storage;
}

ValueMetadata *type metadata accessor for UInt64.SIMD32Storage()
{
  return &type metadata for UInt64.SIMD32Storage;
}

void *__swift_memcpy512_16(void *a1, const void *a2)
{
  return memcpy(a1, a2, 0x200uLL);
}

ValueMetadata *type metadata accessor for UInt64.SIMD64Storage()
{
  return &type metadata for UInt64.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Int64.SIMD2Storage()
{
  return &type metadata for Int64.SIMD2Storage;
}

ValueMetadata *type metadata accessor for Int64.SIMD4Storage()
{
  return &type metadata for Int64.SIMD4Storage;
}

ValueMetadata *type metadata accessor for Int64.SIMD8Storage()
{
  return &type metadata for Int64.SIMD8Storage;
}

ValueMetadata *type metadata accessor for Int64.SIMD16Storage()
{
  return &type metadata for Int64.SIMD16Storage;
}

ValueMetadata *type metadata accessor for Int64.SIMD32Storage()
{
  return &type metadata for Int64.SIMD32Storage;
}

ValueMetadata *type metadata accessor for Int64.SIMD64Storage()
{
  return &type metadata for Int64.SIMD64Storage;
}

ValueMetadata *type metadata accessor for UInt.SIMD2Storage()
{
  return &type metadata for UInt.SIMD2Storage;
}

ValueMetadata *type metadata accessor for UInt.SIMD4Storage()
{
  return &type metadata for UInt.SIMD4Storage;
}

ValueMetadata *type metadata accessor for UInt.SIMD8Storage()
{
  return &type metadata for UInt.SIMD8Storage;
}

ValueMetadata *type metadata accessor for UInt.SIMD16Storage()
{
  return &type metadata for UInt.SIMD16Storage;
}

ValueMetadata *type metadata accessor for UInt.SIMD32Storage()
{
  return &type metadata for UInt.SIMD32Storage;
}

ValueMetadata *type metadata accessor for UInt.SIMD64Storage()
{
  return &type metadata for UInt.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Int.SIMD2Storage()
{
  return &type metadata for Int.SIMD2Storage;
}

ValueMetadata *type metadata accessor for Int.SIMD4Storage()
{
  return &type metadata for Int.SIMD4Storage;
}

ValueMetadata *type metadata accessor for Int.SIMD8Storage()
{
  return &type metadata for Int.SIMD8Storage;
}

ValueMetadata *type metadata accessor for Int.SIMD16Storage()
{
  return &type metadata for Int.SIMD16Storage;
}

ValueMetadata *type metadata accessor for Int.SIMD32Storage()
{
  return &type metadata for Int.SIMD32Storage;
}

ValueMetadata *type metadata accessor for Int.SIMD64Storage()
{
  return &type metadata for Int.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Float16.SIMD2Storage()
{
  return &type metadata for Float16.SIMD2Storage;
}

ValueMetadata *type metadata accessor for Float16.SIMD4Storage()
{
  return &type metadata for Float16.SIMD4Storage;
}

ValueMetadata *type metadata accessor for Float16.SIMD8Storage()
{
  return &type metadata for Float16.SIMD8Storage;
}

ValueMetadata *type metadata accessor for Float16.SIMD16Storage()
{
  return &type metadata for Float16.SIMD16Storage;
}

ValueMetadata *type metadata accessor for Float16.SIMD32Storage()
{
  return &type metadata for Float16.SIMD32Storage;
}

ValueMetadata *type metadata accessor for Float16.SIMD64Storage()
{
  return &type metadata for Float16.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Float.SIMD2Storage()
{
  return &type metadata for Float.SIMD2Storage;
}

ValueMetadata *type metadata accessor for Float.SIMD4Storage()
{
  return &type metadata for Float.SIMD4Storage;
}

ValueMetadata *type metadata accessor for Float.SIMD8Storage()
{
  return &type metadata for Float.SIMD8Storage;
}

ValueMetadata *type metadata accessor for Float.SIMD16Storage()
{
  return &type metadata for Float.SIMD16Storage;
}

ValueMetadata *type metadata accessor for Float.SIMD32Storage()
{
  return &type metadata for Float.SIMD32Storage;
}

ValueMetadata *type metadata accessor for Float.SIMD64Storage()
{
  return &type metadata for Float.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Double.SIMD2Storage()
{
  return &type metadata for Double.SIMD2Storage;
}

uint64_t getEnumTagSinglePayload for Double.SIMD4Storage(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for Double.SIMD4Storage(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(void *)__n128 result = (a2 - 1);
    *(void *)(result + 8) = 0;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 32) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Double.SIMD4Storage()
{
  return &type metadata for Double.SIMD4Storage;
}

uint64_t getEnumTagSinglePayload for Double.SIMD8Storage(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 64)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

ValueMetadata *type metadata accessor for Double.SIMD8Storage()
{
  return &type metadata for Double.SIMD8Storage;
}

uint64_t getEnumTagSinglePayload for Double.SIMD16Storage(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 128)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for Double.SIMD16Storage(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 120) = 0;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 128) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Double.SIMD16Storage()
{
  return &type metadata for Double.SIMD16Storage;
}

uint64_t getEnumTagSinglePayload for Double.SIMD32Storage(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 256)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for Double.SIMD32Storage(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 248) = 0;
    *(_OWORD *)(result + 232) = 0u;
    *(_OWORD *)(result + 216) = 0u;
    *(_OWORD *)(result + 200) = 0u;
    *(_OWORD *)(result + 184) = 0u;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 256) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Double.SIMD32Storage()
{
  return &type metadata for Double.SIMD32Storage;
}

uint64_t getEnumTagSinglePayload for Double.SIMD64Storage(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 512)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for Double.SIMD64Storage(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 504) = 0;
    *(_OWORD *)(result + 248) = 0u;
    *(_OWORD *)(result + 232) = 0u;
    *(_OWORD *)(result + 216) = 0u;
    *(_OWORD *)(result + 200) = 0u;
    *(_OWORD *)(result + 184) = 0u;
    *(_OWORD *)(result + 168) = 0u;
    *(_OWORD *)(result + 152) = 0u;
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 488) = 0u;
    *(_OWORD *)(result + 472) = 0u;
    *(_OWORD *)(result + 456) = 0u;
    *(_OWORD *)(result + 440) = 0u;
    *(_OWORD *)(result + 424) = 0u;
    *(_OWORD *)(result + 408) = 0u;
    *(_OWORD *)(result + 392) = 0u;
    *(_OWORD *)(result + 376) = 0u;
    *(_OWORD *)(result + 360) = 0u;
    *(_OWORD *)(result + 344) = 0u;
    *(_OWORD *)(result + 328) = 0u;
    *(_OWORD *)(result + 312) = 0u;
    *(_OWORD *)(result + 296) = 0u;
    *(_OWORD *)(result + 280) = 0u;
    *(_OWORD *)(result + 264) = 0u;
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 512) = v3;
  return result;
}

ValueMetadata *type metadata accessor for Double.SIMD64Storage()
{
  return &type metadata for Double.SIMD64Storage;
}

ValueMetadata *type metadata accessor for Mirror._DefaultDescendantRepresentation()
{
  return &type metadata for Mirror._DefaultDescendantRepresentation;
}

_DWORD *__swift_memcpy4_1(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

uint64_t getEnumTagSinglePayload for _GraphemeBreakingState(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFF && a1[4]) {
    return (*(_DWORD *)a1 + 255);
  }
  unsigned int v3 = *a1;
  BOOL v4 = v3 >= 2;
  int v5 = (v3 + 2147483646) & 0x7FFFFFFF;
  if (!v4) {
    int v5 = -1;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for _GraphemeBreakingState(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(_DWORD *)__n128 result = a2 - 255;
    if (a3 >= 0xFF) {
      *(unsigned char *)(result + 4) = 1;
    }
  }
  else
  {
    if (a3 >= 0xFF) {
      *(unsigned char *)(result + 4) = 0;
    }
    if (a2) {
      *(unsigned char *)__n128 result = a2 + 1;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for _GraphemeBreakingState()
{
  return &type metadata for _GraphemeBreakingState;
}

Class *type metadata accessor for Unicode._InternalNFC(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Unicode._InternalNFC.Flags);
}

Class *type metadata completion function for Unicode._InternalNFC.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v7[0] = &unk_181635B10;
  v7[1] = &unk_181635B28;
  __n128 result = type metadata accessor for Unicode._InternalNFD.Iterator(319, *(void *)(a1 + 16), *(void *)(a1 + 24), a4);
  if (v6 <= 0x3F)
  {
    void v7[2] = (char *)*(result - 1) + 64;
    swift_initStructMetadata(a1, 0, 3uLL, (uint64_t)v7, a1 + 32);
    return 0;
  }
  return result;
}

unint64_t initializeBufferWithCopyOfBuffer for Unicode._InternalNFC.Iterator(unint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v7 = *(_DWORD *)(v6 + 80);
  uint64_t v8 = ~(v7 | 7);
  uint64_t v9 = v7 + 24;
  unint64_t v10 = ((v7 + 24) & ~v7) + *(void *)(v6 + 64) + (((v7 | 7) + 17) & v8);
  int v11 = *(_DWORD *)(v6 + 80) & 0x100000;
  long long v12 = *(atomic_ullong **)a2;
  *(void *)a1 = *(void *)a2;
  if (v7 > 7 || v11 != 0 || v10 > 0x18)
  {
    a1 = (unint64_t)v12 + ((v7 + 16) & v8);
    swift_retain(v12);
  }
  else
  {
    uint64_t v15 = ~v7;
    *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
    unint64_t v16 = a1 & 0xFFFFFFFFFFFFFFFCLL;
    int v17 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFFCLL) + 12);
    *(unsigned char *)(v16 + 16) = *(unsigned char *)((a2 & 0xFFFFFFFFFFFFFFFCLL) + 16);
    *(_DWORD *)(v16 + 12) = v17;
    uint64_t v18 = (a1 + 24) & v8;
    uint64_t v19 = (a2 + 24) & v8;
    unint64_t v20 = *(void *)v19;
    *(void *)uint64_t v18 = *(void *)v19;
    *(unsigned char *)(v18 + 8) = *(unsigned char *)(v19 + 8);
    *(void *)(v18 + 16) = *(void *)(v19 + 16);
    uint64_t v21 = (v9 + v18) & v15;
    uint64_t v22 = (v9 + v19) & v15;
    int v23 = *(void (**)(uint64_t, uint64_t, const char *))(v6 + 16);
    swift_bridgeObjectRetain((unint64_t)v12);
    swift_bridgeObjectRetain(v20);
    v23(v21, v22, AssociatedTypeWitness);
  }
  return a1;
}

uint64_t destroy for Unicode._InternalNFC.Iterator(uint64_t *a1, uint64_t a2)
{
  swift_bridgeObjectRelease(*a1);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v5 = *(unsigned __int8 *)(v9 + 80);
  uint64_t v6 = (uint64_t *)((((unint64_t)a1 & 0xFFFFFFFFFFFFFFFCLL) + (v5 | 7) + 17) & ~(v5 | 7));
  swift_bridgeObjectRelease(*v6);
  uint64_t v7 = *(uint64_t (**)(unint64_t, const char *))(v9 + 8);

  return v7(((unint64_t)v6 + v5 + 24) & ~v5, AssociatedTypeWitness);
}

uint64_t initializeWithCopy for Unicode._InternalNFC.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(void *)a2;
  *(void *)a1 = *(void *)a2;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  unint64_t v5 = a1 & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v6 = a2 & 0xFFFFFFFFFFFFFFFCLL;
  int v7 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFFCLL) + 12);
  *(unsigned char *)(v5 + 16) = *(unsigned char *)((a2 & 0xFFFFFFFFFFFFFFFCLL) + 16);
  *(_DWORD *)(v5 + 12) = v7;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  unint64_t v10 = *(void (**)(uint64_t, uint64_t, const char *))(v9 + 16);
  uint64_t v11 = *(unsigned __int8 *)(v9 + 80);
  uint64_t v12 = (v11 | 7) + 17;
  uint64_t v13 = (v12 + v5) & ~(v11 | 7);
  uint64_t v14 = (v12 + v6) & ~(v11 | 7);
  unint64_t v15 = *(void *)v14;
  *(void *)uint64_t v13 = *(void *)v14;
  *(unsigned char *)(v13 + 8) = *(unsigned char *)(v14 + 8);
  *(void *)(v13 + 16) = *(void *)(v14 + 0x10);
  uint64_t v16 = (v11 + 24 + v13) & ~v11;
  uint64_t v17 = (v11 + 24 + v14) & ~v11;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRetain(v15);
  v10(v16, v17, AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for Unicode._InternalNFC.Iterator(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v4 = (unint64_t)a2;
  unint64_t v6 = *a2;
  uint64_t v7 = *(void *)a1;
  *(void *)a1 = *a2;
  swift_bridgeObjectRetain(v6);
  swift_bridgeObjectRelease(v7);
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(v4 + 8);
  unint64_t v8 = a1 & 0xFFFFFFFFFFFFFFFCLL;
  v4 &= 0xFFFFFFFFFFFFFFFCLL;
  int v9 = *(_DWORD *)(v4 + 12);
  *(unsigned char *)(v8 + 16) = *(unsigned char *)(v4 + 16);
  *(_DWORD *)(v8 + 12) = v9;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v11 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v12 = *(unsigned __int8 *)(v11 + 80);
  uint64_t v13 = (v12 | 7) + 17;
  unint64_t v14 = (v13 + (a1 & 0xFFFFFFFFFFFFFFFCLL)) & ~(v12 | 7);
  uint64_t v15 = (v13 + v4) & ~(v12 | 7);
  unint64_t v16 = *(void *)v15;
  uint64_t v17 = *(void *)v14;
  *(void *)unint64_t v14 = *(void *)v15;
  swift_bridgeObjectRetain(v16);
  swift_bridgeObjectRelease(v17);
  *(unsigned char *)(v14 + 8) = *(unsigned char *)(v15 + 8);
  *(void *)(v14 + 16) = *(void *)(v15 + 16);
  (*(void (**)(unint64_t, uint64_t, const char *))(v11 + 24))((v12 + 24 + v14) & ~v12, (v12 + 24 + v15) & ~v12, AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for Unicode._InternalNFC.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = *(void *)a2;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  unint64_t v4 = a1 & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v5 = a2 & 0xFFFFFFFFFFFFFFFCLL;
  int v6 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFFCLL) + 12);
  *(unsigned char *)(v4 + 16) = *(unsigned char *)((a2 & 0xFFFFFFFFFFFFFFFCLL) + 16);
  *(_DWORD *)(v4 + 12) = v6;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  int v9 = *(void (**)(uint64_t, uint64_t, const char *))(v8 + 32);
  uint64_t v10 = *(unsigned __int8 *)(v8 + 80);
  uint64_t v11 = (v10 | 7) + 17;
  uint64_t v12 = (v11 + v4) & ~(v10 | 7);
  uint64_t v13 = (v11 + v5) & ~(v10 | 7);
  LOBYTE(v11) = *(unsigned char *)(v13 + 8);
  *(void *)uint64_t v12 = *(void *)v13;
  *(unsigned char *)(v12 + 8) = v11;
  *(void *)(v12 + 16) = *(void *)(v13 + 16);
  v9((v10 + 24 + v12) & ~v10, (v10 + 24 + v13) & ~v10, AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for Unicode._InternalNFC.Iterator(uint64_t a1, void *a2, uint64_t a3)
{
  unint64_t v4 = (unint64_t)a2;
  uint64_t v6 = *(void *)a1;
  *(void *)a1 = *a2;
  swift_bridgeObjectRelease(v6);
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(v4 + 8);
  unint64_t v7 = a1 & 0xFFFFFFFFFFFFFFFCLL;
  v4 &= 0xFFFFFFFFFFFFFFFCLL;
  int v8 = *(_DWORD *)(v4 + 12);
  *(unsigned char *)(v7 + 16) = *(unsigned char *)(v4 + 16);
  *(_DWORD *)(v7 + 12) = v8;
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v10 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v11 = *(unsigned __int8 *)(v10 + 80);
  uint64_t v12 = (v11 | 7) + 17;
  unint64_t v13 = (v12 + (a1 & 0xFFFFFFFFFFFFFFFCLL)) & ~(v11 | 7);
  uint64_t v14 = (v12 + v4) & ~(v11 | 7);
  uint64_t v15 = *(void *)v13;
  *(void *)unint64_t v13 = *(void *)v14;
  swift_bridgeObjectRelease(v15);
  *(unsigned char *)(v13 + 8) = *(unsigned char *)(v14 + 8);
  *(void *)(v13 + 16) = *(void *)(v14 + 16);
  (*(void (**)(unint64_t, uint64_t, const char *))(v10 + 40))((v11 + 24 + v13) & ~v11, (v11 + 24 + v14) & ~v11, AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._InternalNFC.Iterator(unint64_t a1, unsigned int a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  int v7 = *(_DWORD *)(v6 + 84);
  uint64_t v8 = *(unsigned __int8 *)(v6 + 80);
  if (v7 <= 0x7FFFFFFF) {
    int v9 = 0x7FFFFFFF;
  }
  else {
    int v9 = *(_DWORD *)(v6 + 84);
  }
  if (v7 >= 0) {
    unsigned int v10 = 0x7FFFFFFF;
  }
  else {
    unsigned int v10 = v9;
  }
  if (!a2) {
    return 0;
  }
  uint64_t v11 = v8 | 7;
  uint64_t v12 = v8 + 24;
  if (a2 <= v10) {
    goto LABEL_28;
  }
  uint64_t v13 = (v12 & ~v8) + *(void *)(*((void *)AssociatedTypeWitness - 1) + 64) + ((v11 + 17) & ~v11);
  char v14 = 8 * v13;
  if (v13 <= 3)
  {
    unsigned int v17 = ((a2 - v10 + ~(-1 << v14)) >> v14) + 1;
    if (HIWORD(v17))
    {
      int v15 = *(_DWORD *)(a1 + v13);
      if (!v15) {
        goto LABEL_28;
      }
      goto LABEL_18;
    }
    if (v17 > 0xFF)
    {
      int v15 = *(unsigned __int16 *)(a1 + v13);
      if (!*(_WORD *)(a1 + v13)) {
        goto LABEL_28;
      }
      goto LABEL_18;
    }
    if (v17 < 2)
    {
LABEL_28:
      if (v10 == 0x7FFFFFFF)
      {
        uint64_t v21 = *(void *)a1;
        if (*(void *)a1 >= 0xFFFFFFFFuLL) {
          LODWORD(v21) = -1;
        }
        return (v21 + 1);
      }
      else
      {
        uint64_t v22 = *(uint64_t (**)(unint64_t))(v6 + 48);
        return v22((v12 + (((a1 & 0xFFFFFFFFFFFFFFFCLL) + v11 + 17) & ~v11)) & ~v8);
      }
    }
  }
  int v15 = *(unsigned __int8 *)(a1 + v13);
  if (!*(unsigned char *)(a1 + v13)) {
    goto LABEL_28;
  }
LABEL_18:
  int v18 = (v15 - 1) << v14;
  if (v13 > 3) {
    int v18 = 0;
  }
  if (v13)
  {
    if (v13 <= 3) {
      int v19 = v13;
    }
    else {
      int v19 = 4;
    }
    switch(v19)
    {
      case 2:
        int v20 = *(unsigned __int16 *)a1;
        break;
      case 3:
        int v20 = *(unsigned __int16 *)a1 | (*(unsigned __int8 *)(a1 + 2) << 16);
        break;
      case 4:
        int v20 = *(_DWORD *)a1;
        break;
      default:
        int v20 = *(unsigned __int8 *)a1;
        break;
    }
  }
  else
  {
    int v20 = 0;
  }
  return v10 + (v20 | v18) + 1;
}

void storeEnumTagSinglePayload for Unicode._InternalNFC.Iterator(unint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 24), *(void *)(a4 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView)- 1);
  int v8 = *(_DWORD *)(v7 + 84);
  uint64_t v9 = *(unsigned __int8 *)(v7 + 80);
  if (v8 <= 0x7FFFFFFF) {
    int v10 = 0x7FFFFFFF;
  }
  else {
    int v10 = *(_DWORD *)(v7 + 84);
  }
  if (v8 >= 0) {
    unsigned int v11 = 0x7FFFFFFF;
  }
  else {
    unsigned int v11 = v10;
  }
  uint64_t v12 = v9 | 7;
  uint64_t v13 = v9 + 24;
  size_t v14 = ((v9 + 24) & ~v9) + *(void *)(v7 + 64) + (((v9 | 7) + 17) & ~(v9 | 7));
  if (a3 <= v11)
  {
    int v15 = 0;
  }
  else if (v14 <= 3)
  {
    unsigned int v19 = ((a3 - v11 + ~(-1 << (8 * v14))) >> (8 * v14)) + 1;
    if (HIWORD(v19))
    {
      int v15 = 4;
    }
    else if (v19 >= 0x100)
    {
      int v15 = 2;
    }
    else
    {
      int v15 = v19 > 1;
    }
  }
  else
  {
    int v15 = 1;
  }
  if (v11 < a2)
  {
    unsigned int v16 = ~v11 + a2;
    if (v14 < 4)
    {
      int v17 = (v16 >> (8 * v14)) + 1;
      if (v14)
      {
        int v20 = v16 & ~(-1 << (8 * v14));
        bzero((void *)a1, v14);
        if (v14 == 3)
        {
          *(_WORD *)a1 = v20;
          *(unsigned char *)(a1 + 2) = BYTE2(v20);
        }
        else if (v14 == 2)
        {
          *(_WORD *)a1 = v20;
        }
        else
        {
          *(unsigned char *)a1 = v20;
        }
      }
    }
    else
    {
      bzero((void *)a1, v14);
      *(_DWORD *)a1 = v16;
      int v17 = 1;
    }
    switch(v15)
    {
      case 1:
        *(unsigned char *)(a1 + v14) = v17;
        return;
      case 2:
        *(_WORD *)(a1 + v14) = v17;
        return;
      case 3:
        goto LABEL_45;
      case 4:
        *(_DWORD *)(a1 + v14) = v17;
        return;
      default:
        return;
    }
  }
  uint64_t v18 = ~v9;
  switch(v15)
  {
    case 1:
      *(unsigned char *)(a1 + v14) = 0;
      if (!a2) {
        return;
      }
      goto LABEL_27;
    case 2:
      *(_WORD *)(a1 + v14) = 0;
      if (!a2) {
        return;
      }
      goto LABEL_27;
    case 3:
LABEL_45:
      __break(1u);
      JUMPOUT(0x181526B08);
    case 4:
      *(_DWORD *)(a1 + v14) = 0;
      goto LABEL_26;
    default:
LABEL_26:
      if (a2)
      {
LABEL_27:
        if (v11 == 0x7FFFFFFF)
        {
          if ((a2 & 0x80000000) != 0)
          {
            uint64_t v21 = a2 ^ 0x80000000;
            *(unsigned char *)(a1 + 8) = 0;
          }
          else
          {
            uint64_t v21 = (a2 - 1);
          }
          *(void *)a1 = v21;
        }
        else
        {
          uint64_t v22 = *(void (**)(unint64_t, uint64_t))(v7 + 56);
          v22((v13 + (((a1 & 0xFFFFFFFFFFFFFFFCLL) + v12 + 17) & ~v12)) & v18, a2);
        }
      }
      return;
  }
}

Class *type metadata accessor for Unicode._InternalNFC.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Unicode._InternalNFC.Iterator.Flags);
}

Class *type metadata accessor for Unicode._InternalNFD.Iterator(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Unicode._InternalNFD.Iterator.Flags);
}

const char *type metadata completion function for Unicode._InternalNFD(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return type metadata completion function for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
}

const char *type metadata completion function for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  __n128 result = swift_getAssociatedTypeWitness(319, *(int ***)(a1 + 24), *(void *)(a1 + 16), a4, a5);
  if (v7 <= 0x3F)
  {
    uint64_t v8 = *((void *)result - 1) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, (uint64_t)&v8, a1 + 32);
    return 0;
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for Unicode._InternalNFD(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  return initializeBufferWithCopyOfBuffer for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
}

atomic_ullong **initializeBufferWithCopyOfBuffer for SIMD2(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v9 = *(_DWORD *)(v8 + 80);
  if (v9 <= 7
    && *(void *)(*((void *)AssociatedTypeWitness - 1) + 64) <= 0x18uLL
    && (*(_DWORD *)(v8 + 80) & 0x100000) == 0)
  {
    (*(void (**)(atomic_ullong **, atomic_ullong **, const char *))(v8 + 16))(a1, a2, AssociatedTypeWitness);
  }
  else
  {
    uint64_t v12 = *a2;
    *a1 = *a2;
    a1 = (atomic_ullong **)((char *)v12 + ((v9 + 16) & ~v9));
    swift_retain(v12);
  }
  return a1;
}

uint64_t destroy for Unicode._InternalNFD(uint64_t a1, uint64_t a2)
{
  return destroy for EnumeratedSequence.Iterator(a1, a2, (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
}

uint64_t destroy for EnumeratedSequence.Iterator(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), *(void *)(a2 + 16), a3, a4);
  uint64_t v6 = *(uint64_t (**)(uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 8);

  return v6(a1, AssociatedTypeWitness);
}

uint64_t initializeWithCopy for Unicode._InternalNFD(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithCopy for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
}

uint64_t initializeWithCopy for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 16))(a1, a2, AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for Unicode._InternalNFD(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithCopy for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
}

uint64_t assignWithCopy for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 24))(a1, a2, AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for Unicode._InternalNFD(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return initializeWithTake for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
}

uint64_t initializeWithTake for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 32))(a1, a2, AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for Unicode._InternalNFD(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return assignWithTake for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
}

uint64_t assignWithTake for SIMD2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), a4, a5);
  (*(void (**)(uint64_t, uint64_t, const char *))(*((void *)AssociatedTypeWitness - 1) + 40))(a1, a2, AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._InternalNFD(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  return getEnumTagSinglePayload for SIMD2(a1, a2, a3, (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
}

uint64_t getEnumTagSinglePayload for SIMD2(unsigned __int16 *a1, unsigned int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v7 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), a4, a5) - 1);
  unsigned int v8 = *(_DWORD *)(v7 + 84);
  uint64_t v9 = *(void *)(v7 + 64);
  if (!a2) {
    return 0;
  }
  if (a2 <= v8) {
    goto LABEL_19;
  }
  char v10 = 8 * v9;
  if (v9 <= 3)
  {
    unsigned int v12 = ((a2 - v8 + ~(-1 << v10)) >> v10) + 1;
    if (HIWORD(v12))
    {
      int v11 = *(_DWORD *)((char *)a1 + v9);
      if (!v11) {
        goto LABEL_19;
      }
      goto LABEL_11;
    }
    if (v12 > 0xFF)
    {
      int v11 = *(unsigned __int16 *)((char *)a1 + v9);
      if (!*(unsigned __int16 *)((char *)a1 + v9)) {
        goto LABEL_19;
      }
      goto LABEL_11;
    }
    if (v12 < 2)
    {
LABEL_19:
      if (v8)
      {
        size_t v14 = *(uint64_t (**)(unsigned __int16 *))(v7 + 48);
        return v14(a1);
      }
      return 0;
    }
  }
  int v11 = *((unsigned __int8 *)a1 + v9);
  if (!*((unsigned char *)a1 + v9)) {
    goto LABEL_19;
  }
LABEL_11:
  int v13 = (v11 - 1) << v10;
  if (v9 > 3) {
    int v13 = 0;
  }
  if (v9)
  {
    if (v9 > 3) {
      LODWORD(v9) = 4;
    }
    switch((int)v9)
    {
      case 2:
        LODWORD(v9) = *a1;
        break;
      case 3:
        LODWORD(v9) = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        LODWORD(v9) = *(_DWORD *)a1;
        break;
      default:
        LODWORD(v9) = *(unsigned __int8 *)a1;
        break;
    }
  }
  return v8 + (v9 | v13) + 1;
}

void storeEnumTagSinglePayload for Unicode._InternalNFD(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
}

void storeEnumTagSinglePayload for SIMD2(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v9 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 24), *(void *)(a4 + 16), a5, a6) - 1);
  unsigned int v10 = *(_DWORD *)(v9 + 84);
  size_t v11 = *(void *)(v9 + 64);
  if (a3 <= v10)
  {
    int v12 = 0;
  }
  else if (v11 <= 3)
  {
    unsigned int v15 = ((a3 - v10 + ~(-1 << (8 * v11))) >> (8 * v11)) + 1;
    if (HIWORD(v15))
    {
      int v12 = 4;
    }
    else if (v15 >= 0x100)
    {
      int v12 = 2;
    }
    else
    {
      int v12 = v15 > 1;
    }
  }
  else
  {
    int v12 = 1;
  }
  if (v10 < a2)
  {
    unsigned int v13 = ~v10 + a2;
    if (v11 < 4)
    {
      int v14 = (v13 >> (8 * v11)) + 1;
      if (v11)
      {
        int v16 = v13 & ~(-1 << (8 * v11));
        bzero(a1, v11);
        if (v11 == 3)
        {
          *(_WORD *)a1 = v16;
          a1[2] = BYTE2(v16);
        }
        else if (v11 == 2)
        {
          *(_WORD *)a1 = v16;
        }
        else
        {
          *a1 = v16;
        }
      }
    }
    else
    {
      bzero(a1, v11);
      *(_DWORD *)a1 = v13;
      int v14 = 1;
    }
    switch(v12)
    {
      case 1:
        a1[v11] = v14;
        return;
      case 2:
        *(_WORD *)&a1[v11] = v14;
        return;
      case 3:
        goto LABEL_34;
      case 4:
        *(_DWORD *)&a1[v11] = v14;
        return;
      default:
        return;
    }
  }
  switch(v12)
  {
    case 1:
      a1[v11] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_21;
    case 2:
      *(_WORD *)&a1[v11] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_21;
    case 3:
LABEL_34:
      __break(1u);
      JUMPOUT(0x181527358);
    case 4:
      *(_DWORD *)&a1[v11] = 0;
      goto LABEL_20;
    default:
LABEL_20:
      if (a2)
      {
LABEL_21:
        int v17 = *(void (**)(unsigned char *, uint64_t))(v9 + 56);
        v17(a1, a2);
      }
      return;
  }
}

Class *type metadata accessor for Unicode._InternalNFD(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for Unicode._InternalNFD.Flags);
}

const char *type metadata completion function for Unicode._InternalNFD.Iterator(uint64_t a1)
{
  v4[0] = &unk_181635B10;
  v4[1] = &value witness table for Builtin.Int64.size;
  __n128 result = swift_getAssociatedTypeWitness(319, *(int ***)(a1 + 24), *(void *)(a1 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  if (v3 <= 0x3F)
  {
    void v4[2] = *((void *)result - 1) + 64;
    swift_initStructMetadata(a1, 0, 3uLL, (uint64_t)v4, a1 + 32);
    return 0;
  }
  return result;
}

unint64_t initializeBufferWithCopyOfBuffer for Unicode._InternalNFD.Iterator(unint64_t a1, uint64_t a2, uint64_t a3)
{
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v6 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v7 = *(_DWORD *)(v6 + 80);
  unint64_t v8 = ((v7 + 24) & ~v7) + *(void *)(v6 + 64);
  int v9 = *(_DWORD *)(v6 + 80) & 0x100000;
  unsigned int v10 = *(atomic_ullong **)a2;
  *(void *)a1 = *(void *)a2;
  if (v7 > 7 || v9 != 0 || v8 > 0x18)
  {
    a1 = (unint64_t)v10 + ((v7 & 0xF8 ^ 0x1F8) & (v7 + 16));
    swift_retain(v10);
  }
  else
  {
    uint64_t v13 = ~v7;
    *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
    *(void *)((a1 & 0xFFFFFFFFFFFFFFF8) + 16) = *(void *)((a2 & 0xFFFFFFFFFFFFFFF8) + 16);
    uint64_t v14 = (a1 & 0xFFFFFFFFFFFFFFF8) + v7;
    uint64_t v15 = (a2 & 0xFFFFFFFFFFFFFFF8) + v7;
    uint64_t v16 = (v14 + 24) & v13;
    uint64_t v17 = (v15 + 24) & v13;
    uint64_t v18 = *(void (**)(uint64_t, uint64_t, const char *))(v6 + 16);
    swift_bridgeObjectRetain((unint64_t)v10);
    v18(v16, v17, AssociatedTypeWitness);
  }
  return a1;
}

uint64_t destroy for Unicode._InternalNFD.Iterator(uint64_t *a1, uint64_t a2)
{
  swift_bridgeObjectRelease(*a1);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a2 + 24), *(void *)(a2 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v5 = *((void *)AssociatedTypeWitness - 1);
  uint64_t v6 = *(uint64_t (**)(unint64_t, const char *))(v5 + 8);
  uint64_t v7 = AssociatedTypeWitness;
  unint64_t v8 = (((unint64_t)a1 & 0xFFFFFFFFFFFFFFF8) + *(unsigned __int8 *)(v5 + 80) + 24) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80);

  return v6(v8, v7);
}

uint64_t initializeWithCopy for Unicode._InternalNFD.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(void *)a2;
  *(void *)a1 = *(void *)a2;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  unint64_t v5 = a1 & 0xFFFFFFFFFFFFFFF8;
  unint64_t v6 = a2 & 0xFFFFFFFFFFFFFFF8;
  *(void *)((a1 & 0xFFFFFFFFFFFFFFF8) + 16) = *(void *)((a2 & 0xFFFFFFFFFFFFFFF8) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  int v9 = *(void (**)(uint64_t, uint64_t, const char *))(v8 + 16);
  uint64_t v10 = *(unsigned __int8 *)(v8 + 80);
  uint64_t v11 = (v10 + 24 + v5) & ~v10;
  uint64_t v12 = (v10 + 24 + v6) & ~v10;
  swift_bridgeObjectRetain(v4);
  v9(v11, v12, AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithCopy for Unicode._InternalNFD.Iterator(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v4 = (unint64_t)a2;
  unint64_t v6 = *a2;
  uint64_t v7 = *(void *)a1;
  *(void *)a1 = *a2;
  swift_bridgeObjectRetain(v6);
  swift_bridgeObjectRelease(v7);
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(v4 + 8);
  v4 &= 0xFFFFFFFFFFFFFFF8;
  *(void *)((a1 & 0xFFFFFFFFFFFFFFF8) + 16) = *(void *)(v4 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v9 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v9 + 24))((*(unsigned __int8 *)(v9 + 80) + 24 + (a1 & 0xFFFFFFFFFFFFFFF8)) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80), (*(unsigned __int8 *)(v9 + 80) + 24 + v4) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t initializeWithTake for Unicode._InternalNFD.Iterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = *(void *)a2;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  unint64_t v4 = a1 & 0xFFFFFFFFFFFFFFF8;
  unint64_t v5 = a2 & 0xFFFFFFFFFFFFFFF8;
  *(void *)((a1 & 0xFFFFFFFFFFFFFFF8) + 16) = *(void *)((a2 & 0xFFFFFFFFFFFFFFF8) + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v7 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v7 + 32))((*(unsigned __int8 *)(v7 + 80) + 24 + v4) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80), (*(unsigned __int8 *)(v7 + 80) + 24 + v5) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t assignWithTake for Unicode._InternalNFD.Iterator(uint64_t a1, void *a2, uint64_t a3)
{
  unint64_t v4 = (unint64_t)a2;
  uint64_t v6 = *(void *)a1;
  *(void *)a1 = *a2;
  swift_bridgeObjectRelease(v6);
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(v4 + 8);
  v4 &= 0xFFFFFFFFFFFFFFF8;
  *(void *)((a1 & 0xFFFFFFFFFFFFFFF8) + 16) = *(void *)(v4 + 16);
  AssociatedTypeWitness = swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView);
  uint64_t v8 = *((void *)AssociatedTypeWitness - 1);
  (*(void (**)(unint64_t, unint64_t, const char *))(v8 + 40))((*(unsigned __int8 *)(v8 + 80) + 24 + (a1 & 0xFFFFFFFFFFFFFFF8)) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80), (*(unsigned __int8 *)(v8 + 80) + 24 + v4) & ~(unint64_t)*(unsigned __int8 *)(v8 + 80), AssociatedTypeWitness);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._InternalNFD.Iterator(unint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a3 + 24), *(void *)(a3 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView)- 1);
  uint64_t v6 = v5;
  unsigned int v7 = *(_DWORD *)(v5 + 84);
  if (v7 <= 0x7FFFFFFF) {
    unsigned int v8 = 0x7FFFFFFF;
  }
  else {
    unsigned int v8 = *(_DWORD *)(v5 + 84);
  }
  uint64_t v9 = *(unsigned __int8 *)(v5 + 80);
  uint64_t v10 = *(void *)(v5 + 64);
  if (!a2) {
    return 0;
  }
  if (a2 <= v8) {
    goto LABEL_23;
  }
  uint64_t v11 = ((v9 + 24) & ~v9) + v10;
  char v12 = 8 * v11;
  if (v11 <= 3)
  {
    unsigned int v15 = ((a2 - v8 + ~(-1 << v12)) >> v12) + 1;
    if (HIWORD(v15))
    {
      int v13 = *(_DWORD *)(a1 + v11);
      if (!v13) {
        goto LABEL_23;
      }
      goto LABEL_15;
    }
    if (v15 > 0xFF)
    {
      int v13 = *(unsigned __int16 *)(a1 + v11);
      if (!*(_WORD *)(a1 + v11)) {
        goto LABEL_23;
      }
      goto LABEL_15;
    }
    if (v15 < 2)
    {
LABEL_23:
      if ((v7 & 0x80000000) != 0)
      {
        uint64_t v18 = *(uint64_t (**)(unint64_t))(v6 + 48);
        return v18(((a1 & 0xFFFFFFFFFFFFFFF8) + v9 + 24) & ~v9);
      }
      else
      {
        uint64_t v17 = *(void *)a1;
        if (*(void *)a1 >= 0xFFFFFFFFuLL) {
          LODWORD(v17) = -1;
        }
        return (v17 + 1);
      }
    }
  }
  int v13 = *(unsigned __int8 *)(a1 + v11);
  if (!*(unsigned char *)(a1 + v11)) {
    goto LABEL_23;
  }
LABEL_15:
  int v16 = (v13 - 1) << v12;
  if (v11 > 3) {
    int v16 = 0;
  }
  if (v11)
  {
    if (v11 > 3) {
      LODWORD(v11) = 4;
    }
    switch((int)v11)
    {
      case 2:
        LODWORD(v11) = *(unsigned __int16 *)a1;
        break;
      case 3:
        LODWORD(v11) = *(unsigned __int16 *)a1 | (*(unsigned __int8 *)(a1 + 2) << 16);
        break;
      case 4:
        LODWORD(v11) = *(_DWORD *)a1;
        break;
      default:
        LODWORD(v11) = *(unsigned __int8 *)a1;
        break;
    }
  }
  return v8 + (v11 | v16) + 1;
}

void storeEnumTagSinglePayload for Unicode._InternalNFD.Iterator(unint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *((void *)swift_getAssociatedTypeWitness(0, *(int ***)(a4 + 24), *(void *)(a4 + 16), (uint64_t)&protocol requirements base descriptor for StringProtocol, associated type descriptor for StringProtocol.UnicodeScalarView)- 1);
  unsigned int v8 = *(_DWORD *)(v7 + 84);
  uint64_t v9 = *(unsigned __int8 *)(v7 + 80);
  if (v8 <= 0x7FFFFFFF) {
    unsigned int v10 = 0x7FFFFFFF;
  }
  else {
    unsigned int v10 = *(_DWORD *)(v7 + 84);
  }
  size_t v11 = ((v9 + 24) & ~v9) + *(void *)(v7 + 64);
  if (a3 <= v10)
  {
    int v12 = 0;
  }
  else if (v11 <= 3)
  {
    unsigned int v15 = ((a3 - v10 + ~(-1 << (8 * v11))) >> (8 * v11)) + 1;
    if (HIWORD(v15))
    {
      int v12 = 4;
    }
    else if (v15 >= 0x100)
    {
      int v12 = 2;
    }
    else
    {
      int v12 = v15 > 1;
    }
  }
  else
  {
    int v12 = 1;
  }
  if (v10 < a2)
  {
    unsigned int v13 = ~v10 + a2;
    if (v11 < 4)
    {
      int v14 = (v13 >> (8 * v11)) + 1;
      if (v11)
      {
        int v16 = v13 & ~(-1 << (8 * v11));
        bzero((void *)a1, v11);
        if (v11 == 3)
        {
          *(_WORD *)a1 = v16;
          *(unsigned char *)(a1 + 2) = BYTE2(v16);
        }
        else if (v11 == 2)
        {
          *(_WORD *)a1 = v16;
        }
        else
        {
          *(unsigned char *)a1 = v16;
        }
      }
    }
    else
    {
      bzero((void *)a1, v11);
      *(_DWORD *)a1 = v13;
      int v14 = 1;
    }
    switch(v12)
    {
      case 1:
        *(unsigned char *)(a1 + v11) = v14;
        return;
      case 2:
        *(_WORD *)(a1 + v11) = v14;
        return;
      case 3:
        goto LABEL_42;
      case 4:
        *(_DWORD *)(a1 + v11) = v14;
        return;
      default:
        return;
    }
  }
  switch(v12)
  {
    case 1:
      *(unsigned char *)(a1 + v11) = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 2:
      *(_WORD *)(a1 + v11) = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 3:
LABEL_42:
      __break(1u);
      JUMPOUT(0x181527D9CLL);
    case 4:
      *(_DWORD *)(a1 + v11) = 0;
      goto LABEL_23;
    default:
LABEL_23:
      if (a2)
      {
LABEL_24:
        if ((v8 & 0x80000000) != 0)
        {
          uint64_t v18 = *(void (**)(unint64_t, uint64_t))(v7 + 56);
          v18(((a1 & 0xFFFFFFFFFFFFFFF8) + v9 + 24) & ~v9, a2);
        }
        else
        {
          if ((a2 & 0x80000000) != 0)
          {
            uint64_t v17 = a2 ^ 0x80000000;
            *(unsigned char *)(a1 + 8) = 0;
          }
          else
          {
            uint64_t v17 = (a2 - 1);
          }
          *(void *)a1 = v17;
        }
      }
      return;
  }
}

void *type metadata accessor for _CapacityAndFlags()
{
  return &unk_1EC9FF288;
}

uint64_t initializeBufferWithCopyOfBuffer for __BridgingHashBuffer.Header(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void **)a2;
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  swift_unknownObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for __BridgingHashBuffer.Header(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void **)a2;
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = *(void *)a2;
  swift_unknownObjectRetain(v4);
  swift_unknownObjectRelease(v5);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  return a1;
}

uint64_t assignWithTake for __BridgingHashBuffer.Header(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  return a1;
}

uint64_t getEnumTagSinglePayload for _UnsafePartiallyInitializedContiguousArrayBuffer(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 24)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for _UnsafePartiallyInitializedContiguousArrayBuffer(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 24) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 24) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for __BridgingHashBuffer.Header()
{
  return &type metadata for __BridgingHashBuffer.Header;
}

__n128 __swift_memcpy128_8(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  long long v3 = a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  __n128 result = (__n128)a2[4];
  long long v6 = a2[5];
  long long v7 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v7;
  *(__n128 *)(a1 + 64) = result;
  *(_OWORD *)(a1 + 80) = v6;
  return result;
}

ValueMetadata *type metadata accessor for _CocoaFastEnumerationStackBuf()
{
  return &type metadata for _CocoaFastEnumerationStackBuf;
}

void type metadata accessor for _SwiftNSFastEnumerationState(uint64_t a1)
{
}

ValueMetadata *type metadata accessor for _BridgingBufferHeader()
{
  return &type metadata for _BridgingBufferHeader;
}

void type metadata accessor for _SwiftArrayBodyStorage(uint64_t a1)
{
}

void type metadata accessor for _SwiftStdlibVersion(uint64_t a1)
{
}

void type metadata accessor for _SwiftNSFastEnumerationState(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  if (!*a2)
  {
    unint64_t ForeignTypeMetadata = swift_getForeignTypeMetadata(0, a3);
    if (!v5) {
      atomic_store(ForeignTypeMetadata, a2);
    }
  }
}

Class *type metadata accessor for _IntegerAnyHashableBox(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _IntegerAnyHashableBox.Flags);
}

ValueMetadata *type metadata accessor for _DoubleAnyHashableBox()
{
  return &type metadata for _DoubleAnyHashableBox;
}

ValueMetadata *type metadata accessor for _FloatAnyHashableBox()
{
  return &type metadata for _FloatAnyHashableBox;
}

uint64_t destroy for Mirror(uint64_t a1)
{
  swift_release(*(void *)(a1 + 8));
  uint64_t v2 = *(void *)(a1 + 32);

  return swift_release(v2);
}

uint64_t initializeWithCopy for Mirror(uint64_t a1, uint64_t a2)
{
  long long v3 = *(atomic_ullong **)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v3;
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  long long v4 = *(atomic_ullong **)(a2 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v4;
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  swift_retain(v3);
  swift_retain(v4);
  return a1;
}

uint64_t assignWithCopy for Mirror(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  long long v4 = *(atomic_ullong **)(a2 + 8);
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = v4;
  swift_retain(v4);
  swift_release(v5);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  long long v6 = *(atomic_ullong **)(a2 + 32);
  uint64_t v7 = *(void *)(a1 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v6;
  swift_retain(v6);
  swift_release(v7);
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  return a1;
}

uint64_t assignWithTake for Mirror(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  swift_release(v4);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  uint64_t v5 = *(void *)(a1 + 32);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  swift_release(v5);
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  return a1;
}

uint64_t getEnumTagSinglePayload for Mirror(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 41)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Mirror(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(unsigned char *)(result + 40) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 41) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 41) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Mirror._Dummy()
{
  return &type metadata for Mirror._Dummy;
}

ValueMetadata *type metadata accessor for _Int128()
{
  return &type metadata for _Int128;
}

uint64_t getEnumTagSinglePayload for FloatingPointSign(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFF) {
    goto LABEL_17;
  }
  if (a2 + 1 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 1) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 1;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 2;
  int v8 = v6 - 2;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for FloatingPointSign(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 1 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFF) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFE)
  {
    unsigned int v6 = ((a2 - 255) >> 8) + 1;
    *__n128 result = a2 + 1;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x1815283C8);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *__n128 result = a2 + 1;
        break;
    }
  }
  return result;
}

uint64_t getEnumTagSinglePayload for JoinedSequence.Iterator._JoinIteratorState(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFD) {
    goto LABEL_17;
  }
  if (a2 + 3 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 3) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 3;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 3;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 3;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 4;
  int v8 = v6 - 4;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for JoinedSequence.Iterator._JoinIteratorState(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 3 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 3) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFD) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFC)
  {
    unsigned int v6 = ((a2 - 253) >> 8) + 1;
    *__n128 result = a2 + 3;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x181528554);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *__n128 result = a2 + 3;
        break;
    }
  }
  return result;
}

void destroy for _SetAnyHashableBox(uint64_t *a1)
{
  swift_bridgeObjectRelease(*a1);
  uint64_t v2 = a1[1];

  swift_bridgeObjectRelease(v2);
}

uint64_t *type metadata completion function for _Pair(uint64_t a1)
{
  __n128 result = swift_checkMetadataState(319, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    swift_getTupleTypeLayout2((uint64_t)v4, *(result - 1) + 64, *(result - 1) + 64);
    uint64_t v5 = v4;
    swift_initStructMetadata(a1, 0, 1uLL, (uint64_t)&v5, a1 + 24);
    return 0;
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for ClosedRange(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  unsigned int v4 = a1;
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void *)(v6 + 64);
  uint64_t v8 = *(_DWORD *)(v6 + 80);
  uint64_t v9 = ~v8;
  uint64_t v10 = v7 + v8;
  unint64_t v11 = ((v7 + v8) & ~v8) + v7;
  if (v8 > 7 || (*(_DWORD *)(v6 + 80) & 0x100000) != 0 || v11 > 0x18)
  {
    int v14 = *a2;
    atomic_ullong *v4 = *a2;
    unsigned int v4 = (atomic_ullong **)((char *)v14 + ((v8 + 16) & v9));
    swift_retain(v14);
  }
  else
  {
    unsigned int v15 = *(void (**)(atomic_ullong **, atomic_ullong **, uint64_t))(v6 + 16);
    v15(a1, a2, v5);
    v15((atomic_ullong **)(((unint64_t)v4 + v10) & v9), (atomic_ullong **)(((unint64_t)a2 + v10) & v9), v5);
  }
  return v4;
}

uint64_t destroy for ClosedRange(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(v3 - 8) + 8;
  uint64_t v7 = *(uint64_t (**)(unint64_t, uint64_t))v6;
  (*(void (**)(uint64_t, uint64_t))v6)(a1, v3);
  unint64_t v4 = (*(void *)(v6 + 56) + a1 + *(unsigned __int8 *)(v6 + 72)) & ~(unint64_t)*(unsigned __int8 *)(v6 + 72);

  return v7(v4, v3);
}

unint64_t initializeWithCopy for ClosedRange(unint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(unint64_t, unint64_t, uint64_t))(v6 + 16);
  uint64_t v8 = v6 + 16;
  v7(a1, a2, v5);
  v7((*(void *)(v8 + 48) + *(unsigned __int8 *)(v8 + 64) + a1) & ~(unint64_t)*(unsigned __int8 *)(v8 + 64), (*(void *)(v8 + 48) + *(unsigned __int8 *)(v8 + 64) + a2) & ~(unint64_t)*(unsigned __int8 *)(v8 + 64), v5);
  return a1;
}

unint64_t assignWithCopy for ClosedRange(unint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(unint64_t, unint64_t, uint64_t))(v6 + 24);
  uint64_t v8 = v6 + 24;
  v7(a1, a2, v5);
  v7((*(void *)(v8 + 40) + *(unsigned __int8 *)(v8 + 56) + a1) & ~(unint64_t)*(unsigned __int8 *)(v8 + 56), (*(void *)(v8 + 40) + *(unsigned __int8 *)(v8 + 56) + a2) & ~(unint64_t)*(unsigned __int8 *)(v8 + 56), v5);
  return a1;
}

unint64_t initializeWithTake for ClosedRange(unint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(unint64_t, unint64_t, uint64_t))(v6 + 32);
  uint64_t v8 = v6 + 32;
  v7(a1, a2, v5);
  v7((*(void *)(v8 + 32) + *(unsigned __int8 *)(v8 + 48) + a1) & ~(unint64_t)*(unsigned __int8 *)(v8 + 48), (*(void *)(v8 + 32) + *(unsigned __int8 *)(v8 + 48) + a2) & ~(unint64_t)*(unsigned __int8 *)(v8 + 48), v5);
  return a1;
}

unint64_t assignWithTake for ClosedRange(unint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(unint64_t, unint64_t, uint64_t))(v6 + 40);
  uint64_t v8 = v6 + 40;
  v7(a1, a2, v5);
  v7((*(void *)(v8 + 24) + *(unsigned __int8 *)(v8 + 40) + a1) & ~(unint64_t)*(unsigned __int8 *)(v8 + 40), (*(void *)(v8 + 24) + *(unsigned __int8 *)(v8 + 40) + a2) & ~(unint64_t)*(unsigned __int8 *)(v8 + 40), v5);
  return a1;
}

uint64_t getEnumTagSinglePayload for ClosedRange(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  if (!a2) {
    return 0;
  }
  unsigned int v7 = a2 - v5;
  if (a2 <= v5) {
    goto LABEL_19;
  }
  uint64_t v6 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
  uint64_t v8 = ((v6 + *(unsigned __int8 *)(v4 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80)) + v6;
  char v9 = 8 * v8;
  if (v8 <= 3)
  {
    unsigned int v11 = ((v7 + ~(-1 << v9)) >> v9) + 1;
    if (HIWORD(v11))
    {
      int v10 = *(_DWORD *)((char *)a1 + v8);
      if (!v10) {
        goto LABEL_19;
      }
      goto LABEL_11;
    }
    if (v11 > 0xFF)
    {
      int v10 = *(unsigned __int16 *)((char *)a1 + v8);
      if (!*(unsigned __int16 *)((char *)a1 + v8)) {
        goto LABEL_19;
      }
      goto LABEL_11;
    }
    if (v11 < 2)
    {
LABEL_19:
      if (v5) {
        return (*(uint64_t (**)(void))(v4 + 48))();
      }
      return 0;
    }
  }
  int v10 = *((unsigned __int8 *)a1 + v8);
  if (!*((unsigned char *)a1 + v8)) {
    goto LABEL_19;
  }
LABEL_11:
  int v12 = (v10 - 1) << v9;
  if (v8 > 3) {
    int v12 = 0;
  }
  if (v8)
  {
    if (v8 > 3) {
      LODWORD(v8) = 4;
    }
    switch((int)v8)
    {
      case 2:
        LODWORD(v8) = *a1;
        break;
      case 3:
        LODWORD(v8) = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        LODWORD(v8) = *(_DWORD *)a1;
        break;
      default:
        LODWORD(v8) = *(unsigned __int8 *)a1;
        break;
    }
  }
  return v5 + (v8 | v12) + 1;
}

void storeEnumTagSinglePayload for ClosedRange(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 16) - 8);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  size_t v8 = ((*(void *)(v6 + 64) + *(unsigned __int8 *)(v6 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v6 + 80))
     + *(void *)(v6 + 64);
  BOOL v9 = a3 >= v7;
  unsigned int v10 = a3 - v7;
  if (v10 != 0 && v9)
  {
    if (v8 <= 3)
    {
      unsigned int v14 = ((v10 + ~(-1 << (8 * v8))) >> (8 * v8)) + 1;
      if (HIWORD(v14))
      {
        int v11 = 4;
      }
      else if (v14 >= 0x100)
      {
        int v11 = 2;
      }
      else
      {
        int v11 = v14 > 1;
      }
    }
    else
    {
      int v11 = 1;
    }
  }
  else
  {
    int v11 = 0;
  }
  if (v7 < a2)
  {
    unsigned int v12 = ~v7 + a2;
    if (v8 < 4)
    {
      int v13 = (v12 >> (8 * v8)) + 1;
      if (v8)
      {
        int v15 = v12 & ~(-1 << (8 * v8));
        bzero(a1, v8);
        if (v8 == 3)
        {
          *(_WORD *)a1 = v15;
          a1[2] = BYTE2(v15);
        }
        else if (v8 == 2)
        {
          *(_WORD *)a1 = v15;
        }
        else
        {
          *a1 = v15;
        }
      }
    }
    else
    {
      bzero(a1, v8);
      *(_DWORD *)a1 = v12;
      int v13 = 1;
    }
    switch(v11)
    {
      case 1:
        a1[v8] = v13;
        return;
      case 2:
        *(_WORD *)&a1[v8] = v13;
        return;
      case 3:
        goto LABEL_34;
      case 4:
        *(_DWORD *)&a1[v8] = v13;
        return;
      default:
        return;
    }
  }
  switch(v11)
  {
    case 1:
      a1[v8] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_21;
    case 2:
      *(_WORD *)&a1[v8] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_21;
    case 3:
LABEL_34:
      __break(1u);
      JUMPOUT(0x181528DF8);
    case 4:
      *(_DWORD *)&a1[v8] = 0;
      goto LABEL_20;
    default:
LABEL_20:
      if (a2)
      {
LABEL_21:
        int v16 = *(void (**)(void))(v6 + 56);
        v16();
      }
      return;
  }
}

uint64_t *type metadata completion function for SIMDMask(uint64_t a1)
{
  __n128 result = swift_checkMetadataState(319, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, (uint64_t)&v4, a1 + 48);
    return 0;
  }
  return result;
}

uint64_t *type metadata completion function for Result(uint64_t a1)
{
  __n128 result = swift_checkMetadataState(319, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    v5[0] = *(result - 1) + 64;
    __n128 result = swift_checkMetadataState(319, *(void *)(a1 + 24));
    if (v4 <= 0x3F)
    {
      v5[1] = *(result - 1) + 64;
      swift_initEnumMetadataMultiPayload(a1, 0, 2, (uint64_t)v5);
      return 0;
    }
  }
  return result;
}

void *initializeBufferWithCopyOfBuffer for Result(void *a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v3 = a1;
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  uint64_t v5 = *(void *)(*(void *)(a3 + 24) - 8);
  if (*(void *)(v5 + 64) <= *(void *)(v4 + 64)) {
    uint64_t v6 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
  }
  else {
    uint64_t v6 = *(void *)(v5 + 64);
  }
  uint64_t v7 = (*(unsigned char *)(v5 + 80) | *(unsigned char *)(v4 + 80));
  if (v7 <= 7
    && (unint64_t)(v6 + 1) <= 0x18
    && ((*(_DWORD *)(v5 + 80) | *(_DWORD *)(v4 + 80)) & 0x100000) == 0)
  {
    unsigned int v11 = a2[v6];
    unsigned int v12 = v11 - 2;
    if (v11 >= 2)
    {
      if (v6 <= 3) {
        uint64_t v13 = v6;
      }
      else {
        uint64_t v13 = 4;
      }
      switch(v13)
      {
        case 1:
          int v14 = *a2;
          goto LABEL_21;
        case 2:
          int v14 = *(unsigned __int16 *)a2;
          goto LABEL_21;
        case 3:
          int v14 = *(unsigned __int16 *)a2 | (a2[2] << 16);
          goto LABEL_21;
        case 4:
          int v14 = *(_DWORD *)a2;
LABEL_21:
          int v15 = (v14 | (v12 << (8 * v6))) + 2;
          unsigned int v11 = v14 + 2;
          if (v6 < 4) {
            unsigned int v11 = v15;
          }
          break;
        default:
          break;
      }
    }
    if (v11 == 1)
    {
      (*(void (**)(void *))(v5 + 16))(a1);
      *((unsigned char *)v3 + v6) = 1;
    }
    else
    {
      (*(void (**)(void *))(v4 + 16))(a1);
      *((unsigned char *)v3 + v6) = 0;
    }
  }
  else
  {
    unsigned int v10 = *(atomic_ullong **)a2;
    *unint64_t v3 = *(void *)a2;
    unint64_t v3 = (atomic_ullong *)((char *)v10 + ((v7 + 16) & ~v7));
    swift_retain(v10);
  }
  return v3;
}

uint64_t destroy for Result(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 24) - 8;
  uint64_t v3 = *(void *)v2;
  unint64_t v4 = *(void *)(*(void *)v2 + 64);
  if (v4 <= *(void *)(*(void *)(*(void *)(a2 + 16) - 8) + 64)) {
    unint64_t v4 = *(void *)(*(void *)(*(void *)(a2 + 16) - 8) + 64);
  }
  unsigned int v5 = a1[v4];
  unsigned int v6 = v5 - 2;
  if (v5 >= 2)
  {
    if (v4 <= 3) {
      uint64_t v7 = v4;
    }
    else {
      uint64_t v7 = 4;
    }
    switch(v7)
    {
      case 1:
        int v8 = *a1;
        goto LABEL_12;
      case 2:
        int v8 = *(unsigned __int16 *)a1;
        goto LABEL_12;
      case 3:
        int v8 = *(unsigned __int16 *)a1 | (a1[2] << 16);
        goto LABEL_12;
      case 4:
        int v8 = *(_DWORD *)a1;
LABEL_12:
        int v9 = (v8 | (v6 << (8 * v4))) + 2;
        unsigned int v5 = v8 + 2;
        if (v4 < 4) {
          unsigned int v5 = v9;
        }
        break;
      default:
        break;
    }
  }
  if (v5 == 1) {
    uint64_t v10 = v3;
  }
  else {
    uint64_t v10 = *(void *)(*(void *)(a2 + 16) - 8);
  }
  return (*(uint64_t (**)(void))(v10 + 8))();
}

uint64_t initializeWithCopy for Result(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 + 24);
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8);
  if (*(void *)(*(void *)(v4 - 8) + 64) <= *(void *)(v5 + 64)) {
    uint64_t v6 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
  }
  else {
    uint64_t v6 = *(void *)(*(void *)(v4 - 8) + 64);
  }
  unsigned int v7 = a2[v6];
  unsigned int v8 = v7 - 2;
  if (v7 >= 2)
  {
    if (v6 <= 3) {
      uint64_t v9 = v6;
    }
    else {
      uint64_t v9 = 4;
    }
    switch(v9)
    {
      case 1:
        int v10 = *a2;
        goto LABEL_13;
      case 2:
        int v10 = *(unsigned __int16 *)a2;
        goto LABEL_13;
      case 3:
        int v10 = *(unsigned __int16 *)a2 | (a2[2] << 16);
        goto LABEL_13;
      case 4:
        int v10 = *(_DWORD *)a2;
LABEL_13:
        int v11 = (v10 | (v8 << (8 * v6))) + 2;
        unsigned int v7 = v10 + 2;
        if (v6 < 4) {
          unsigned int v7 = v11;
        }
        break;
      default:
        break;
    }
  }
  BOOL v12 = v7 == 1;
  if (v7 == 1) {
    uint64_t v5 = *(void *)(v4 - 8);
  }
  (*(void (**)(uint64_t))(v5 + 16))(a1);
  *(unsigned char *)(a1 + v6) = v12;
  return a1;
}

unsigned __int8 *assignWithCopy for Result(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = *(void *)(a3 + 24);
    uint64_t v7 = *(void *)(v5 - 8);
    uint64_t v8 = *(void *)(v6 - 8);
    if (*(void *)(v8 + 64) <= *(void *)(v7 + 64)) {
      uint64_t v9 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
    }
    else {
      uint64_t v9 = *(void *)(*(void *)(v6 - 8) + 64);
    }
    unsigned int v10 = a1[v9];
    unsigned int v11 = v10 - 2;
    if (v10 >= 2)
    {
      if (v9 <= 3) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = 4;
      }
      switch(v12)
      {
        case 1:
          int v13 = *a1;
          goto LABEL_14;
        case 2:
          int v13 = *(unsigned __int16 *)a1;
          goto LABEL_14;
        case 3:
          int v13 = *(unsigned __int16 *)a1 | (a1[2] << 16);
          goto LABEL_14;
        case 4:
          int v13 = *(_DWORD *)a1;
LABEL_14:
          int v14 = (v13 | (v11 << (8 * v9))) + 2;
          unsigned int v10 = v13 + 2;
          if (v9 < 4) {
            unsigned int v10 = v14;
          }
          break;
        default:
          break;
      }
    }
    if (v10 == 1) {
      uint64_t v15 = *(void *)(v6 - 8);
    }
    else {
      uint64_t v15 = *(void *)(*(void *)(a3 + 16) - 8);
    }
    if (v10 == 1) {
      uint64_t v16 = *(void *)(a3 + 24);
    }
    else {
      uint64_t v16 = *(void *)(a3 + 16);
    }
    (*(void (**)(unsigned __int8 *, uint64_t))(v15 + 8))(a1, v16);
    unsigned int v17 = a2[v9];
    unsigned int v18 = v17 - 2;
    if (v17 >= 2)
    {
      if (v9 <= 3) {
        uint64_t v19 = v9;
      }
      else {
        uint64_t v19 = 4;
      }
      switch(v19)
      {
        case 1:
          int v20 = *a2;
          goto LABEL_31;
        case 2:
          int v20 = *(unsigned __int16 *)a2;
          goto LABEL_31;
        case 3:
          int v20 = *(unsigned __int16 *)a2 | (a2[2] << 16);
          goto LABEL_31;
        case 4:
          int v20 = *(_DWORD *)a2;
LABEL_31:
          int v21 = (v20 | (v18 << (8 * v9))) + 2;
          unsigned int v17 = v20 + 2;
          if (v9 < 4) {
            unsigned int v17 = v21;
          }
          break;
        default:
          break;
      }
    }
    BOOL v22 = v17 == 1;
    if (v17 == 1) {
      uint64_t v23 = v8;
    }
    else {
      uint64_t v23 = v7;
    }
    if (v17 == 1) {
      uint64_t v24 = v6;
    }
    else {
      uint64_t v24 = v5;
    }
    (*(void (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(v23 + 16))(a1, a2, v24);
    a1[v9] = v22;
  }
  return a1;
}

uint64_t initializeWithTake for Result(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 + 24);
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8);
  if (*(void *)(*(void *)(v4 - 8) + 64) <= *(void *)(v5 + 64)) {
    uint64_t v6 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
  }
  else {
    uint64_t v6 = *(void *)(*(void *)(v4 - 8) + 64);
  }
  unsigned int v7 = a2[v6];
  unsigned int v8 = v7 - 2;
  if (v7 >= 2)
  {
    if (v6 <= 3) {
      uint64_t v9 = v6;
    }
    else {
      uint64_t v9 = 4;
    }
    switch(v9)
    {
      case 1:
        int v10 = *a2;
        goto LABEL_13;
      case 2:
        int v10 = *(unsigned __int16 *)a2;
        goto LABEL_13;
      case 3:
        int v10 = *(unsigned __int16 *)a2 | (a2[2] << 16);
        goto LABEL_13;
      case 4:
        int v10 = *(_DWORD *)a2;
LABEL_13:
        int v11 = (v10 | (v8 << (8 * v6))) + 2;
        unsigned int v7 = v10 + 2;
        if (v6 < 4) {
          unsigned int v7 = v11;
        }
        break;
      default:
        break;
    }
  }
  BOOL v12 = v7 == 1;
  if (v7 == 1) {
    uint64_t v5 = *(void *)(v4 - 8);
  }
  (*(void (**)(uint64_t))(v5 + 32))(a1);
  *(unsigned char *)(a1 + v6) = v12;
  return a1;
}

unsigned __int8 *assignWithTake for Result(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = *(void *)(a3 + 16);
    uint64_t v6 = *(void *)(a3 + 24);
    uint64_t v7 = *(void *)(v5 - 8);
    uint64_t v8 = *(void *)(v6 - 8);
    if (*(void *)(v8 + 64) <= *(void *)(v7 + 64)) {
      uint64_t v9 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
    }
    else {
      uint64_t v9 = *(void *)(*(void *)(v6 - 8) + 64);
    }
    unsigned int v10 = a1[v9];
    unsigned int v11 = v10 - 2;
    if (v10 >= 2)
    {
      if (v9 <= 3) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = 4;
      }
      switch(v12)
      {
        case 1:
          int v13 = *a1;
          goto LABEL_14;
        case 2:
          int v13 = *(unsigned __int16 *)a1;
          goto LABEL_14;
        case 3:
          int v13 = *(unsigned __int16 *)a1 | (a1[2] << 16);
          goto LABEL_14;
        case 4:
          int v13 = *(_DWORD *)a1;
LABEL_14:
          int v14 = (v13 | (v11 << (8 * v9))) + 2;
          unsigned int v10 = v13 + 2;
          if (v9 < 4) {
            unsigned int v10 = v14;
          }
          break;
        default:
          break;
      }
    }
    if (v10 == 1) {
      uint64_t v15 = *(void *)(v6 - 8);
    }
    else {
      uint64_t v15 = *(void *)(*(void *)(a3 + 16) - 8);
    }
    if (v10 == 1) {
      uint64_t v16 = *(void *)(a3 + 24);
    }
    else {
      uint64_t v16 = *(void *)(a3 + 16);
    }
    (*(void (**)(unsigned __int8 *, uint64_t))(v15 + 8))(a1, v16);
    unsigned int v17 = a2[v9];
    unsigned int v18 = v17 - 2;
    if (v17 >= 2)
    {
      if (v9 <= 3) {
        uint64_t v19 = v9;
      }
      else {
        uint64_t v19 = 4;
      }
      switch(v19)
      {
        case 1:
          int v20 = *a2;
          goto LABEL_31;
        case 2:
          int v20 = *(unsigned __int16 *)a2;
          goto LABEL_31;
        case 3:
          int v20 = *(unsigned __int16 *)a2 | (a2[2] << 16);
          goto LABEL_31;
        case 4:
          int v20 = *(_DWORD *)a2;
LABEL_31:
          int v21 = (v20 | (v18 << (8 * v9))) + 2;
          unsigned int v17 = v20 + 2;
          if (v9 < 4) {
            unsigned int v17 = v21;
          }
          break;
        default:
          break;
      }
    }
    BOOL v22 = v17 == 1;
    if (v17 == 1) {
      uint64_t v23 = v8;
    }
    else {
      uint64_t v23 = v7;
    }
    if (v17 == 1) {
      uint64_t v24 = v6;
    }
    else {
      uint64_t v24 = v5;
    }
    (*(void (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(v23 + 32))(a1, a2, v24);
    a1[v9] = v22;
  }
  return a1;
}

uint64_t getEnumTagSinglePayload for Result(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(*(void *)(*(void *)(a3 + 24) - 8) + 64);
  if (v3 <= *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64)) {
    unint64_t v3 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
  }
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFF) {
    goto LABEL_22;
  }
  unint64_t v4 = v3 + 1;
  char v5 = 8 * (v3 + 1);
  if ((v3 + 1) <= 3)
  {
    unsigned int v8 = ((a2 + ~(-1 << v5) - 254) >> v5) + 1;
    if (HIWORD(v8))
    {
      int v6 = *(_DWORD *)((char *)a1 + v4);
      if (!v6) {
        goto LABEL_22;
      }
      goto LABEL_14;
    }
    if (v8 > 0xFF)
    {
      int v6 = *(unsigned __int16 *)((char *)a1 + v4);
      if (!*(unsigned __int16 *)((char *)a1 + v4)) {
        goto LABEL_22;
      }
      goto LABEL_14;
    }
    if (v8 < 2)
    {
LABEL_22:
      unsigned int v10 = *((unsigned __int8 *)a1 + v3);
      if (v10 >= 2) {
        return (v10 ^ 0xFF) + 1;
      }
      else {
        return 0;
      }
    }
  }
  int v6 = *((unsigned __int8 *)a1 + v4);
  if (!*((unsigned char *)a1 + v4)) {
    goto LABEL_22;
  }
LABEL_14:
  int v9 = (v6 - 1) << v5;
  if (v4 > 3) {
    int v9 = 0;
  }
  if (v4)
  {
    if (v4 > 3) {
      LODWORD(v4) = 4;
    }
    switch((int)v4)
    {
      case 2:
        LODWORD(v4) = *a1;
        break;
      case 3:
        LODWORD(v4) = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        LODWORD(v4) = *(_DWORD *)a1;
        break;
      default:
        LODWORD(v4) = *(unsigned __int8 *)a1;
        break;
    }
  }
  return (v4 | v9) + 255;
}

void storeEnumTagSinglePayload for Result(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  unint64_t v5 = *(void *)(*(void *)(*(void *)(a4 + 16) - 8) + 64);
  if (*(void *)(*(void *)(*(void *)(a4 + 24) - 8) + 64) > v5) {
    unint64_t v5 = *(void *)(*(void *)(*(void *)(a4 + 24) - 8) + 64);
  }
  size_t v6 = v5 + 1;
  if (a3 < 0xFF)
  {
    int v7 = 0;
  }
  else if (v6 <= 3)
  {
    unsigned int v10 = ((a3 + ~(-1 << (8 * v6)) - 254) >> (8 * v6)) + 1;
    if (HIWORD(v10))
    {
      int v7 = 4;
    }
    else if (v10 >= 0x100)
    {
      int v7 = 2;
    }
    else
    {
      int v7 = v10 > 1;
    }
  }
  else
  {
    int v7 = 1;
  }
  if (a2 > 0xFE)
  {
    unsigned int v8 = a2 - 255;
    if (v6 < 4)
    {
      int v9 = (v8 >> (8 * v6)) + 1;
      if (v5 != -1)
      {
        int v11 = v8 & ~(-1 << (8 * v6));
        bzero(a1, v6);
        if (v6 == 3)
        {
          *(_WORD *)a1 = v11;
          a1[2] = BYTE2(v11);
        }
        else if (v6 == 2)
        {
          *(_WORD *)a1 = v11;
        }
        else
        {
          *a1 = v11;
        }
      }
    }
    else
    {
      bzero(a1, v5 + 1);
      *(_DWORD *)a1 = v8;
      int v9 = 1;
    }
    switch(v7)
    {
      case 1:
        a1[v6] = v9;
        break;
      case 2:
        *(_WORD *)&a1[v6] = v9;
        break;
      case 3:
LABEL_34:
        __break(1u);
        JUMPOUT(0x181529D34);
      case 4:
        *(_DWORD *)&a1[v6] = v9;
        break;
      default:
        return;
    }
  }
  else
  {
    switch(v7)
    {
      case 1:
        a1[v6] = 0;
        if (!a2) {
          return;
        }
        goto LABEL_23;
      case 2:
        *(_WORD *)&a1[v6] = 0;
        goto LABEL_22;
      case 3:
        goto LABEL_34;
      case 4:
        *(_DWORD *)&a1[v6] = 0;
        if (!a2) {
          return;
        }
        goto LABEL_23;
      default:
LABEL_22:
        if (a2) {
LABEL_23:
        }
          a1[v5] = -(char)a2;
        break;
    }
  }
}

uint64_t getEnumTag for Result(unsigned __int8 *a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(*(void *)(*(void *)(a2 + 24) - 8) + 64);
  if (v2 <= *(void *)(*(void *)(*(void *)(a2 + 16) - 8) + 64)) {
    unint64_t v2 = *(void *)(*(void *)(*(void *)(a2 + 16) - 8) + 64);
  }
  uint64_t v3 = a1[v2];
  int v4 = v3 - 2;
  if (v3 >= 2)
  {
    if (v2 <= 3) {
      uint64_t v5 = v2;
    }
    else {
      uint64_t v5 = 4;
    }
    switch(v5)
    {
      case 1:
        int v6 = *a1;
        goto LABEL_12;
      case 2:
        int v6 = *(unsigned __int16 *)a1;
        goto LABEL_12;
      case 3:
        int v6 = *(unsigned __int16 *)a1 | (a1[2] << 16);
        goto LABEL_12;
      case 4:
        int v6 = *(_DWORD *)a1;
LABEL_12:
        unsigned int v7 = (v6 | (v4 << (8 * v2))) + 2;
        LODWORD(v3) = v6 + 2;
        if (v2 >= 4) {
          uint64_t v3 = v3;
        }
        else {
          uint64_t v3 = v7;
        }
        break;
      default:
        return v3;
    }
  }
  return v3;
}

void destructiveInjectEnumTag for Result(unsigned char *a1, unsigned int a2, uint64_t a3)
{
  if (a2 > 1)
  {
    uint64_t v6 = *(void *)(*(void *)(a3 + 24) - 8);
    if (*(void *)(v6 + 64) <= *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64)) {
      size_t v7 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
    }
    else {
      size_t v7 = *(void *)(v6 + 64);
    }
    unsigned int v8 = a2 - 2;
    if (v7 < 4)
    {
      unsigned int v9 = v8 >> (8 * v7);
      int v10 = v8 & ~(-1 << (8 * v7));
      a1[v7] = v9 + 2;
      bzero(a1, v7);
      if (v7 == 3)
      {
        *(_WORD *)a1 = v10;
        a1[2] = BYTE2(v10);
      }
      else if (v7 == 2)
      {
        *(_WORD *)a1 = v10;
      }
      else
      {
        *a1 = v10;
      }
    }
    else
    {
      a1[v7] = 2;
      bzero(a1, v7);
      *(_DWORD *)a1 = v8;
    }
  }
  else
  {
    uint64_t v4 = *(void *)(*(void *)(a3 + 24) - 8);
    unint64_t v5 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
    if (*(void *)(v4 + 64) > v5) {
      unint64_t v5 = *(void *)(v4 + 64);
    }
    a1[v5] = a2;
  }
}

uint64_t *type metadata completion function for EnumeratedSequence(uint64_t a1)
{
  __n128 result = swift_checkMetadataState(319, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    uint64_t v4 = *(result - 1) + 64;
    swift_initStructMetadata(a1, 0, 1uLL, (uint64_t)&v4, a1 + 32);
    return 0;
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for EnumeratedSequence(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  unint64_t v3 = a1;
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  uint64_t v5 = *(_DWORD *)(v4 + 80);
  if (v5 <= 7
    && *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64) <= 0x18uLL
    && (*(_DWORD *)(v4 + 80) & 0x100000) == 0)
  {
    (*(void (**)(atomic_ullong **))(v4 + 16))(a1);
  }
  else
  {
    unsigned int v8 = *a2;
    *unint64_t v3 = *a2;
    unint64_t v3 = (atomic_ullong **)((char *)v8 + ((v5 + 16) & ~v5));
    swift_retain(v8);
  }
  return v3;
}

uint64_t destroy for EnumeratedSequence(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a2 + 16) - 8) + 8))();
}

uint64_t initializeWithCopy for EnumeratedSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

uint64_t assignWithCopy for EnumeratedSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

uint64_t initializeWithTake for EnumeratedSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

uint64_t assignWithTake for EnumeratedSequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

uint64_t getEnumTagSinglePayload for EnumeratedSequence(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  uint64_t v6 = *(void *)(v4 + 64);
  if (!a2) {
    return 0;
  }
  unsigned int v7 = a2 - v5;
  if (a2 <= v5) {
    goto LABEL_19;
  }
  char v8 = 8 * v6;
  if (v6 <= 3)
  {
    unsigned int v10 = ((v7 + ~(-1 << v8)) >> v8) + 1;
    if (HIWORD(v10))
    {
      int v9 = *(_DWORD *)((char *)a1 + v6);
      if (!v9) {
        goto LABEL_19;
      }
      goto LABEL_11;
    }
    if (v10 > 0xFF)
    {
      int v9 = *(unsigned __int16 *)((char *)a1 + v6);
      if (!*(unsigned __int16 *)((char *)a1 + v6)) {
        goto LABEL_19;
      }
      goto LABEL_11;
    }
    if (v10 < 2)
    {
LABEL_19:
      if (v5) {
        return (*(uint64_t (**)(void))(v4 + 48))();
      }
      return 0;
    }
  }
  int v9 = *((unsigned __int8 *)a1 + v6);
  if (!*((unsigned char *)a1 + v6)) {
    goto LABEL_19;
  }
LABEL_11:
  int v11 = (v9 - 1) << v8;
  if (v6 > 3) {
    int v11 = 0;
  }
  if (v6)
  {
    if (v6 > 3) {
      LODWORD(v6) = 4;
    }
    switch((int)v6)
    {
      case 2:
        LODWORD(v6) = *a1;
        break;
      case 3:
        LODWORD(v6) = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        LODWORD(v6) = *(_DWORD *)a1;
        break;
      default:
        LODWORD(v6) = *(unsigned __int8 *)a1;
        break;
    }
  }
  return v5 + (v6 | v11) + 1;
}

void storeEnumTagSinglePayload for EnumeratedSequence(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 16) - 8);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  size_t v8 = *(void *)(v6 + 64);
  BOOL v9 = a3 >= v7;
  unsigned int v10 = a3 - v7;
  if (v10 != 0 && v9)
  {
    if (v8 <= 3)
    {
      unsigned int v14 = ((v10 + ~(-1 << (8 * v8))) >> (8 * v8)) + 1;
      if (HIWORD(v14))
      {
        int v11 = 4;
      }
      else if (v14 >= 0x100)
      {
        int v11 = 2;
      }
      else
      {
        int v11 = v14 > 1;
      }
    }
    else
    {
      int v11 = 1;
    }
  }
  else
  {
    int v11 = 0;
  }
  if (v7 < a2)
  {
    unsigned int v12 = ~v7 + a2;
    if (v8 < 4)
    {
      int v13 = (v12 >> (8 * v8)) + 1;
      if (v8)
      {
        int v15 = v12 & ~(-1 << (8 * v8));
        bzero(a1, v8);
        if (v8 == 3)
        {
          *(_WORD *)a1 = v15;
          a1[2] = BYTE2(v15);
        }
        else if (v8 == 2)
        {
          *(_WORD *)a1 = v15;
        }
        else
        {
          *a1 = v15;
        }
      }
    }
    else
    {
      bzero(a1, v8);
      *(_DWORD *)a1 = v12;
      int v13 = 1;
    }
    switch(v11)
    {
      case 1:
        a1[v8] = v13;
        return;
      case 2:
        *(_WORD *)&a1[v8] = v13;
        return;
      case 3:
        goto LABEL_34;
      case 4:
        *(_DWORD *)&a1[v8] = v13;
        return;
      default:
        return;
    }
  }
  switch(v11)
  {
    case 1:
      a1[v8] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_21;
    case 2:
      *(_WORD *)&a1[v8] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_21;
    case 3:
LABEL_34:
      __break(1u);
      JUMPOUT(0x18152A57CLL);
    case 4:
      *(_DWORD *)&a1[v8] = 0;
      goto LABEL_20;
    default:
LABEL_20:
      if (a2)
      {
LABEL_21:
        uint64_t v16 = *(void (**)(void))(v6 + 56);
        v16();
      }
      return;
  }
}

ValueMetadata *type metadata accessor for _Stdout()
{
  return &type metadata for _Stdout;
}

unint64_t *initializeBufferWithCopyOfBuffer for CollectionDifference(unint64_t *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  *a1 = *a2;
  a1[1] = v4;
  swift_bridgeObjectRetain(v3);
  swift_bridgeObjectRetain(v4);
  return a1;
}

uint64_t *assignWithCopy for CollectionDifference(uint64_t *a1, unint64_t *a2)
{
  unint64_t v4 = *a2;
  uint64_t v5 = *a1;
  *a1 = *a2;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  unint64_t v6 = a2[1];
  uint64_t v7 = a1[1];
  a1[1] = v6;
  swift_bridgeObjectRetain(v6);
  swift_bridgeObjectRelease(v7);
  return a1;
}

uint64_t *assignWithTake for CollectionDifference(uint64_t *a1, _OWORD *a2)
{
  swift_bridgeObjectRelease(*a1);
  uint64_t v4 = a1[1];
  *(_OWORD *)a1 = *a2;
  swift_bridgeObjectRelease(v4);
  return a1;
}

uint64_t getEnumTagSinglePayload for __CocoaDictionary.Index(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 16)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for __CocoaDictionary.Index(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 8) = 0;
    if (a3 < 0) {
      *(unsigned char *)(result + 16) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)__n128 result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 16) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

__n128 __swift_memcpy25_8(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  *(_OWORD *)(a1 + 9) = *(_OWORD *)(a2 + 9);
  *(__n128 *)a1 = result;
  return result;
}

ValueMetadata *type metadata accessor for _DictionaryCodingKey()
{
  return &type metadata for _DictionaryCodingKey;
}

uint64_t initializeWithCopy for _DictionaryCodingKey(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for _DictionaryCodingKey(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  unint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = v4;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  uint64_t v6 = *(void *)(a2 + 16);
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(void *)(a1 + 16) = v6;
  return a1;
}

uint64_t assignWithTake for _DictionaryCodingKey(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  swift_bridgeObjectRelease(v5);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  return a1;
}

uint64_t getEnumTagSinglePayload for _DictionaryCodingKey(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 25)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for _DictionaryCodingKey(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(unsigned char *)(result + 24) = 0;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 25) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 8) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 25) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for _GenericIndexKey()
{
  return &type metadata for _GenericIndexKey;
}

void *type metadata accessor for UTF8ValidationError()
{
  return &unk_1EC9FFB80;
}

uint64_t destroy for Dictionary.Keys.Iterator(void *a1, uint64_t a2, uint64_t (*a3)(void, void, void, void, void))
{
  return a3(*a1, a1[1], a1[2], a1[3], a1[4]);
}

void *initializeWithCopy for Dictionary.Keys.Iterator(void *a1, void *a2, uint64_t a3, void (*a4)(void, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  uint64_t v7 = a2[2];
  uint64_t v8 = a2[3];
  uint64_t v9 = a2[4];
  a4(*a2, v6, v7, v8, v9);
  *a1 = v5;
  a1[1] = v6;
  a1[2] = v7;
  a1[3] = v8;
  a1[4] = v9;
  return a1;
}

uint64_t *assignWithCopy for Dictionary.Keys.Iterator(uint64_t *a1, void *a2, uint64_t a3, void (*a4)(void, uint64_t, uint64_t, uint64_t, uint64_t), void (*a5)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1];
  uint64_t v9 = a2[2];
  uint64_t v10 = a2[3];
  uint64_t v11 = a2[4];
  a4(*a2, v8, v9, v10, v11);
  uint64_t v12 = *a1;
  uint64_t v13 = a1[1];
  uint64_t v14 = a1[2];
  uint64_t v15 = a1[3];
  uint64_t v16 = a1[4];
  *a1 = v7;
  a1[1] = v8;
  a1[2] = v9;
  a1[3] = v10;
  a1[4] = v11;
  a5(v12, v13, v14, v15, v16);
  return a1;
}

void *assignWithTake for Dictionary.Keys.Iterator(void *a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v6 = *(void *)(a2 + 32);
  uint64_t v7 = *a1;
  uint64_t v9 = a1[1];
  uint64_t v8 = a1[2];
  uint64_t v10 = a1[3];
  uint64_t v11 = a1[4];
  long long v12 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *((_OWORD *)a1 + 1) = v12;
  a1[4] = v6;
  a4(v7, v9, v8, v10, v11);
  return a1;
}

uint64_t getEnumTagSinglePayload for Dictionary.Keys.Iterator(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0x7F && *(unsigned char *)(a1 + 40)) {
    return (*(_DWORD *)a1 + 127);
  }
  unsigned int v3 = (((*(void *)a1 >> 57) >> 6) | (2 * ((*(void *)a1 >> 57) & 0x38 | *(void *)a1 & 7))) ^ 0x7F;
  if (v3 >= 0x7E) {
    unsigned int v3 = -1;
  }
  return v3 + 1;
}

uint64_t storeEnumTagSinglePayload for Dictionary.Keys.Iterator(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7E)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(void *)__n128 result = a2 - 127;
    if (a3 >= 0x7F) {
      *(unsigned char *)(result + 40) = 1;
    }
  }
  else
  {
    if (a3 >= 0x7F) {
      *(unsigned char *)(result + 40) = 0;
    }
    if (a2)
    {
      uint64_t v3 = (-a2 >> 1) & 0x3F | ((-a2 & 0x7F) << 6);
      *(void *)__n128 result = (v3 | (v3 << 57)) & 0xF000000000000007;
      *(_OWORD *)(result + 8) = 0u;
      *(_OWORD *)(result + 24) = 0u;
    }
  }
  return result;
}

uint64_t initializeBufferWithCopyOfBuffer for Dictionary.Index(uint64_t a1, uint64_t *a2, uint64_t a3, void (*a4)(void, uint64_t, uint64_t))
{
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  uint64_t v7 = *((unsigned __int8 *)a2 + 16);
  a4(*a2, v6, v7);
  *(void *)a1 = v5;
  *(void *)(a1 + 8) = v6;
  *(unsigned char *)(a1 + 16) = v7;
  return a1;
}

uint64_t *assignWithCopy for Dictionary.Index(uint64_t *a1, uint64_t *a2, uint64_t a3, void (*a4)(void, uint64_t, uint64_t), void (*a5)(uint64_t, uint64_t, uint64_t))
{
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1];
  uint64_t v9 = *((unsigned __int8 *)a2 + 16);
  a4(*a2, v8, v9);
  uint64_t v10 = *a1;
  uint64_t v11 = a1[1];
  uint64_t v12 = *((unsigned __int8 *)a1 + 16);
  *a1 = v7;
  a1[1] = v8;
  *((unsigned char *)a1 + 16) = v9;
  a5(v10, v11, v12);
  return a1;
}

uint64_t *assignWithTake for Dictionary.Index(uint64_t *a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t, uint64_t, uint64_t))
{
  char v5 = *(unsigned char *)(a2 + 16);
  uint64_t v6 = *a1;
  uint64_t v7 = a1[1];
  uint64_t v8 = *((unsigned __int8 *)a1 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *((unsigned char *)a1 + 16) = v5;
  a4(v6, v7, v8);
  return a1;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _Pair<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t instantiation function for generic protocol witness table for _Pair<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _Pair<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _Pair<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

unint64_t instantiation function for generic protocol witness table for _Int128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type _Int128 and conformance _Int128(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type _Int128 and conformance _Int128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type _Int128 and conformance _Int128;
  if (!lazy protocol witness table cache variable for type _Int128 and conformance _Int128)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _Int128, (unint64_t *)&type metadata for _Int128, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _Int128 and conformance _Int128);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _Int128 and conformance _Int128;
  if (!lazy protocol witness table cache variable for type _Int128 and conformance _Int128)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _Int128, (unint64_t *)&type metadata for _Int128, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _Int128 and conformance _Int128);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for _UInt128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type _UInt128 and conformance _UInt128(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

unint64_t lazy protocol witness table accessor for type _UInt128 and conformance _UInt128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128;
  if (!lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _UInt128, (unint64_t *)&type metadata for _UInt128, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128;
  if (!lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _UInt128, (unint64_t *)&type metadata for _UInt128, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128;
  if (!lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _UInt128, (unint64_t *)&type metadata for _UInt128, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _UInt128 and conformance _UInt128);
  }
  return result;
}

unint64_t lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words;
  if (!lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _Int128.Words, (unint64_t *)&type metadata for _Int128.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words;
  if (!lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _Int128.Words, (unint64_t *)&type metadata for _Int128.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words;
  if (!lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _Int128.Words, (unint64_t *)&type metadata for _Int128.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words;
  if (!lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _Int128.Words, (unint64_t *)&type metadata for _Int128.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _Int128.Words and conformance _Int128.Words);
  }
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _Int128.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<_Int128.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<_Int128.Words>, protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in _Int128.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<_Int128.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<_Int128.Words>, protocol conformance descriptor for Slice<A>);
}

unint64_t instantiation function for generic protocol witness table for _Int128.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _Int128.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<_Int128.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<_Int128.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _Int128.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<_Int128.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<_Int128.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type _Int128.Words and conformance _Int128.Words, protocol conformance descriptor for <> Slice<A>);
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Comparable in _Int128()
{
  return &protocol witness table for _UInt128;
}

_UNKNOWN **associated type witness table accessor for Numeric.Magnitude : Numeric in _Int128()
{
  return &protocol witness table for _UInt128;
}

unint64_t lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words;
  if (!lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _UInt128.Words, (unint64_t *)&type metadata for _UInt128.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words;
  if (!lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _UInt128.Words, (unint64_t *)&type metadata for _UInt128.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words;
  if (!lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _UInt128.Words, (unint64_t *)&type metadata for _UInt128.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words);
  }
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words;
  if (!lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words)
  {
    unint64_t result = swift_getWitnessTable(protocol conformance descriptor for _UInt128.Words, (unint64_t *)&type metadata for _UInt128.Words, a3);
    atomic_store(result, (unint64_t *)&lazy protocol witness table cache variable for type _UInt128.Words and conformance _UInt128.Words);
  }
  return result;
}

uint64_t associated type witness table accessor for Sequence.Iterator : IteratorProtocol in _UInt128.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type IndexingIterator<_UInt128.Words> and conformance IndexingIterator<A>, &demangling cache variable for type metadata for IndexingIterator<_UInt128.Words>, protocol conformance descriptor for IndexingIterator<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : Collection in _UInt128.Words()
{
  return lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(&lazy protocol witness table cache variable for type Slice<_UInt128.Words> and conformance Slice<A>, &demangling cache variable for type metadata for Slice<_UInt128.Words>, protocol conformance descriptor for Slice<A>);
}

uint64_t lazy protocol witness table accessor for type IndexingIterator<_CocoaArrayWrapper> and conformance IndexingIterator<A>(unint64_t *a1, uint64_t *a2, int *a3)
{
  uint64_t result = *a1;
  if (!result)
  {
    uint64_t v6 = (unint64_t *)__swift_instantiateConcreteTypeFromMangledNameAbstract(a2);
    uint64_t result = swift_getWitnessTable(a3, v6, v7);
    atomic_store(result, a1);
  }
  return result;
}

unint64_t instantiation function for generic protocol witness table for _UInt128.Words(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  unint64_t result;

  unint64_t result = lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words(a1, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _UInt128.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<_UInt128.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<_UInt128.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words, protocol conformance descriptor for <> Slice<A>);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _UInt128.Words()
{
  return lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(&lazy protocol witness table cache variable for type Slice<_UInt128.Words> and conformance <> Slice<A>, &demangling cache variable for type metadata for Slice<_UInt128.Words>, (uint64_t (*)(void))lazy protocol witness table accessor for type _UInt128.Words and conformance _UInt128.Words, protocol conformance descriptor for <> Slice<A>);
}

uint64_t lazy protocol witness table accessor for type Slice<Unicode.Scalar.UTF16View> and conformance <> Slice<A>(unint64_t *a1, uint64_t *a2, uint64_t (*a3)(void), int *a4)
{
  uint64_t result = *a1;
  if (!result)
  {
    uint64_t v8 = (unint64_t *)__swift_instantiateConcreteTypeFromMangledNameAbstract(a2);
    uint64_t v9 = a3();
    uint64_t result = swift_getWitnessTable(a4, v8, (uint64_t)&v9);
    atomic_store(result, a1);
  }
  return result;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Unicode._InternalNFD<A>()
{
  return &protocol witness table for Unicode._InternalNFD<A>.Iterator;
}

_UNKNOWN **associated type witness table accessor for Sequence.Iterator : IteratorProtocol in Unicode._InternalNFC<A>()
{
  return &protocol witness table for Unicode._InternalNFC<A>.Iterator;
}

uint64_t instantiation function for generic protocol witness table for _FixedArray16<A>(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for _FixedArray16<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for _FixedArray16<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

{
  uint64_t result;

  uint64_t result = swift_getWitnessTable(protocol conformance descriptor for _FixedArray16<A>, a2, a3);
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t associated type witness table accessor for Collection.SubSequence : BidirectionalCollection in _FixedArray16<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _FixedArray16<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.SubSequence : MutableCollection in _FixedArray16<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _FixedArray16<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t associated type witness table accessor for Collection.Indices : RandomAccessCollection in _ArrayBuffer<A>(unint64_t *a1, uint64_t a2, uint64_t a3, int *a4)
{
  v7[0] = &protocol witness table for Int;
  v7[1] = lazy protocol witness table accessor for type Int and conformance Int((uint64_t)a1, a2, a3);
  return swift_getWitnessTable(a4, a1, (uint64_t)v7);
}

uint64_t associated type witness table accessor for Collection.SubSequence : RandomAccessCollection in _FixedArray16<A>(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t WitnessTable = swift_getWitnessTable(protocol conformance descriptor for _FixedArray16<A>, a2, a3);
  return swift_getWitnessTable(protocol conformance descriptor for <> Slice<A>, a1, (uint64_t)&WitnessTable);
}

uint64_t outlined destroy of _HasContiguousBytes?(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, AnyHashable>()
{
  return self;
}

uint64_t partial apply for closure #1 in _FixedArray16.subscript.setter(uint64_t a1)
{
  return partial apply for closure #1 in _FixedArray16.subscript.setter(a1);
}

{
  void *v1;

  return (*(uint64_t (**)(uint64_t, void))(*(void *)(v1[2] - 8) + 24))(a1 + *(void *)(*(void *)(v1[2] - 8) + 72) * v1[3], v1[4]);
}

uint64_t outlined init with take of KeyPathComponent(long long *a1, uint64_t a2)
{
  long long v2 = *a1;
  long long v3 = a1[1];
  long long v4 = a1[2];
  *(void *)(a2 + 48) = *((void *)a1 + 6);
  *(_OWORD *)(a2 + 16) = v3;
  *(_OWORD *)(a2 + 32) = v4;
  *(_OWORD *)a2 = v2;
  return a2;
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt>()
{
  return self;
}

char *partial apply for specialized closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)(char *a1, uint64_t a2)
{
  return specialized closure #1 in _ArrayBufferProtocol.replaceSubrange<A>(_:with:elementsOf:)(a1, a2, *(void *)(v2 + 16), *(char **)(v2 + 24));
}

__n128 partial apply for closure #1 in __SwiftNativeNSArrayWithContiguousStorage.countByEnumerating(with:objects:count:)@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = *(void *)(v3 + 16);
  uint64_t v5 = *(void *)(v3 + 24);
  *(void *)(v4 + 8) = a1;
  *(void *)(v4 + 16) = &_fastEnumerationStorageMutationsTarget;
  *(void *)uint64_t v4 = 1;
  uint64_t v6 = *(void *)(v4 + 56);
  __n128 result = *(__n128 *)(v4 + 24);
  long long v8 = *(_OWORD *)(v4 + 40);
  *(void *)uint64_t v5 = 1;
  *(void *)(v5 + 8) = a1;
  *(void *)(v5 + 16) = &_fastEnumerationStorageMutationsTarget;
  *(__n128 *)(v5 + 24) = result;
  *(_OWORD *)(v5 + 40) = v8;
  *(void *)(v5 + 56) = v6;
  *a3 = a2;
  return result;
}

char *partial apply for closure #1 in __SwiftNativeNSArrayWithContiguousStorage.getObjects(_:range:)(char *result, uint64_t a2)
{
  uint64_t v3 = v2[2];
  if (v3 < 0 || v3 > a2)
  {
    unint64_t v8 = 104;
    goto LABEL_15;
  }
  uint64_t v4 = v2[3];
  uint64_t v5 = v3 + v4;
  if (__OFADD__(v3, v4))
  {
    __break(1u);
LABEL_18:
    __break(1u);
LABEL_19:
    _fatalErrorMessage(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "UnsafeMutableRawPointer.copyMemory with negative count", 54, 2, "Swift/UnsafeRawPointer.swift", 28, 2, 0x60DuLL, 0);
  }
  if (v5 < 0 || v5 > a2)
  {
    unint64_t v8 = 108;
LABEL_15:
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Array index out of range", 24, 2, "Swift/SwiftNativeNSArray.swift", 30, 2, v8, 0);
  }
  if (!a2) {
    return result;
  }
  if (!result) {
    _assertionFailure(_:_:file:line:flags:)((unint64_t)"Fatal error", 11, 2, "Unexpectedly found nil while unwrapping an Optional value", 57, 2, "Swift/SwiftNativeNSArray.swift", 30, 2, 0x77uLL, 0);
  }
  if ((unint64_t)(v4 - 0x1000000000000000) >> 61 != 7) {
    goto LABEL_18;
  }
  if (8 * v4 < 0) {
    goto LABEL_19;
  }
  uint64_t v6 = &result[8 * v3];
  uint64_t v7 = (void *)v2[4];

  return (char *)memmove(v7, v6, 8 * v4);
}

uint64_t partial apply for closure #1 in __SwiftNativeNSArrayWithContiguousStorage._objectAt(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return closure #1 in __SwiftNativeNSArrayWithContiguousStorage._objectAt(_:)(a1, a2, *(void *)(v3 + 16), a3);
}

uint64_t partial apply for thunk for @callee_guaranteed (@unowned UnsafePointer<UInt8>) -> (@unowned Bool)@<X0>(unsigned char *a1@<X8>)
{
  uint64_t result = (*(uint64_t (**)(void))(v1 + 16))();
  *a1 = result & 1;
  return result;
}

BOOL partial apply for specialized closure #1 in _AbstractStringStorage._isEqual(_:)(void *__s2)
{
  size_t v2 = *(void *)(v1 + 16);
  uint64_t v3 = *(void *)(v1 + 24);
  if ((*(void *)(v3 + 32) & 0xFFFFFFFFFFFFLL) != v2) {
    return 0;
  }
  uint64_t v5 = *(void **)(v3 + 24);
  return v5 == __s2 || memcmp(v5, __s2, v2) == 0;
}

{
  uint64_t v1;
  size_t v2;
  uint64_t v3;

  size_t v2 = *(void *)(v1 + 16);
  uint64_t v3 = *(void *)(v1 + 24);
  if ((*(void *)(v3 + 24) & 0xFFFFFFFFFFFFLL) != v2) {
    return 0;
  }
  if ((void *)(v3 + 32) == __s2) {
    return 1;
  }
  return memcmp((const void *)(v3 + 32), __s2, v2) == 0;
}

uint64_t partial apply for specialized closure #1 in _arrayForceCast<A, B>(_:)@<X0>(uint64_t a1@<X0>, char *a2@<X8>)
{
  return specialized closure #1 in _arrayForceCast<A, B>(_:)(a1, *(Class **)(v2 + 16), a2);
}

uint64_t partial apply for specialized closure #1 in MutableCollection<>.partition(by:)@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = specialized MutableCollection<>._partitionImpl(by:)(*(uint64_t (**)(char *))(v1 + 16));
  if (!v2) {
    *a1 = result;
  }
  return result;
}

void *partial apply for specialized closure #1 in _StringGuts.withCString<A>(_:)@<X0>(unsigned char *a1@<X8>)
{
  return partial apply for specialized closure #1 in _StringGuts.withCString<A>(_:)(a1);
}

{
  uint64_t v1;
  uint64_t v2;
  void *result;
  uint64_t v5;

  uint64_t result = (*(void *(**)(uint64_t *__return_ptr))(v1 + 16))(&v5);
  if (!v2) {
    *a1 = v5;
  }
  return result;
}

unsigned char *partial apply for closure #1 in closure #1 in Float.init<A>(_:)@<X0>(unsigned char *result@<X0>, uint64_t (*a2)(void)@<X1>, BOOL *a3@<X8>)
{
  unsigned int v4 = *result;
  BOOL v5 = v4 > 0x20;
  uint64_t v6 = (1 << v4) & 0x100003E01;
  BOOL v7 = v5 || v6 == 0;
  BOOL v8 = v7 && (result = (unsigned char *)a2()) != 0 && *result == 0;
  *a3 = v8;
  return result;
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Unicode.Scalar>()
{
  return self;
}

uint64_t partial apply for specialized closure #1 in Substring.UnicodeScalarView.replaceSubrange<A>(_:with:)()
{
  return specialized _StringGuts.replaceSubrange<A>(_:with:)(*(void *)(v0 + 16), *(void *)(v0 + 24), **(_DWORD **)(v0 + 32));
}

{
  uint64_t v0;

  return specialized _StringGuts.replaceSubrange<A>(_:with:)(*(void *)(v0 + 16), *(void *)(v0 + 24));
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt32>()
{
  return self;
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<UInt16>()
{
  return self;
}

uint64_t partial apply for closure #1 in Slice.withContiguousStorageIfAvailable<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return closure #1 in Slice.withContiguousStorageIfAvailable<A>(_:)(a1, a2, *(char **)(v3 + 40), *(uint64_t (**)(uint64_t))(v3 + 48), *(void *)(v3 + 56), *(void *)(v3 + 16), *(void *)(v3 + 32), a3);
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Character>()
{
  return self;
}

void *partial apply for closure #2 in Slice<>.withContiguousMutableStorageIfAvailable<A>(_:)(uint64_t *a1)
{
  return closure #2 in Slice<>.withContiguousMutableStorageIfAvailable<A>(_:)(a1, *(void *)(v1 + 40), *(void *)(v1 + 48), *(void (**)(void *))(v1 + 56), *(void *)(v1 + 64), *(void *)(v1 + 16), *(void *)(v1 + 24), *(void *)(v1 + 32));
}

char *partial apply for closure #1 in Slice._copyContents(initializing:)@<X0>(char *a1@<X0>, uint64_t a2@<X1>, char **a3@<X8>)
{
  return closure #1 in Slice._copyContents(initializing:)(a1, a2, *(char **)(v3 + 32), *(void *)(v3 + 40), *(void *)(v3 + 16), *(void *)(v3 + 24), a3);
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<_HashTable.Bucket>()
{
  return self;
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int>()
{
  return self;
}

double partial apply for closure #1 in closure #1 in _myers<A, B>(from:to:using:)@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  return closure #1 in closure #1 in _myers<A, B>(from:to:using:)(a1, a2, *(void *)(v3 + 48), *(__objc2_class **)(v3 + 56), *(uint64_t (**)(char *, char *))(v3 + 64), *(void *)(v3 + 72), *(void *)(v3 + 16), *(void *)(v3 + 32), a3);
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<_V>()
{
  return self;
}

BOOL partial apply for closure #1 in closure #2 in CollectionDifference<A>.inferringMoves()(uint64_t a1, uint64_t a2, char a3)
{
  return (a3 & 1) == 0;
}

uint64_t partial apply for thunk for @callee_guaranteed (@in_guaranteed A, @unowned Int?) -> (@unowned Bool)(uint64_t a1, uint64_t a2)
{
  return partial apply for thunk for @callee_guaranteed (@in_guaranteed A, @unowned Int?) -> (@unowned Bool)(a1, a2) & 1;
}

{
  uint64_t v2;

  return (*(uint64_t (**)(uint64_t, void, void))(v2 + 32))(a1, *(void *)a2, *(unsigned __int8 *)(a2 + 8)) & 1;
}

BOOL partial apply for closure #1 in CollectionDifference.init<A>(_validatedChanges:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return closure #1 in CollectionDifference.init<A>(_validatedChanges:)(a1, a2, *(void *)(v4 + 16), a4);
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<Int, Int>()
{
  return self;
}

uint64_t canonical specialized generic type metadata accessor for _SetStorage<Int>()
{
  return self;
}

uint64_t outlined retain of Substring(uint64_t a1)
{
  return a1;
}

uint64_t outlined release of Substring(uint64_t a1)
{
  return a1;
}

uint64_t canonical specialized generic type metadata accessor for _IndexBox<String.Index>()
{
  return self;
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<String.Index>()
{
  return self;
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<String, Int>()
{
  return self;
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Int8>()
{
  return self;
}

uint64_t partial apply for closure #1 in closure #1 in String._slowWithCString<A, B>(encodedAs:_:)(uint64_t a1)
{
  return closure #1 in closure #1 in String._slowWithCString<A, B>(encodedAs:_:)(a1, *(void *)(v1 + 40), *(void *)(v1 + 24), *(int ***)(v1 + 32));
}

uint64_t partial apply for closure #1 in static String._fromNonContiguousUnsafeBitcastUTF8Repairing<A>(_:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return closure #1 in static String._fromNonContiguousUnsafeBitcastUTF8Repairing<A>(_:)(a1, a2, *(void *)(v3 + 16), *(void *)(v3 + 24), a3);
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Range<Int>>()
{
  return self;
}

uint64_t partial apply for closure #1 in RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(v4 + 16);
  uint64_t v5 = *(void *)(v4 + 24);
  int v7 = *(unsigned __int8 *)(v4 + 32);
  uint64_t v8 = *(void *)(v4 + 40);
  uint64_t v9 = a1 + *((int *)type metadata accessor for Range(0, v6, v5, a4) + 9);
  if (v7 == 1) {
    char v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v5 + 32))(v9, v8, v6, v5);
  }
  else {
    char v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v5 + 40))(v9, v8, v6, v5);
  }
  return v10 & 1;
}

uint64_t partial apply for closure #2 in RangeSet.Ranges._indicesOfRange(_:in:includeAdjacent:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(v4 + 16);
  uint64_t v6 = *(void *)(v4 + 24);
  int v8 = *(unsigned __int8 *)(v4 + 32);
  uint64_t v9 = *(void *)(v4 + 40);
  uint64_t v10 = v9 + *((int *)type metadata accessor for Range(0, v7, v6, a4) + 9);
  if (v8 == 1) {
    char v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v6 + 40))(a1, v10, v7, v6);
  }
  else {
    char v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v6 + 32))(a1, v10, v7, v6);
  }
  return v11 & 1;
}

uint64_t canonical specialized generic type metadata accessor for _SetStorage<AnyHashable>()
{
  return self;
}

uint64_t canonical specialized generic type metadata accessor for _SetStorage<String>()
{
  return self;
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, String>()
{
  return self;
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<AnyHashable, Any>()
{
  return self;
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<String, Any>()
{
  return self;
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<String, AnyHashable>()
{
  return self;
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<String, String>()
{
  return self;
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<Bool>()
{
  return self;
}

uint64_t outlined init with take of (key: AnyHashable, value: AnyHashable)?(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

uint64_t outlined consume of Mirror?(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (result)
  {
    swift_release(a2);
    return swift_release(a5);
  }
  return result;
}

uint64_t canonical specialized generic type metadata accessor for _DictionaryStorage<ObjectIdentifier, Int>()
{
  return self;
}

uint64_t outlined release of Mirror(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  swift_release(*(void *)(a1 + 32));
  swift_release(v2);
  return a1;
}

uint64_t canonical specialized generic type metadata accessor for _SetStorage<ObjectIdentifier>()
{
  return self;
}

uint64_t outlined init with take of Mirror?(uint64_t a1, uint64_t a2)
{
  return initializeWithTake for ClosedRange<>.Index(a2, a1, &unk_1ECA02EA8);
}

void sub_18152C6C4()
{
  __swift_destroy_boxed_opaque_existential_1Tm((uint64_t *)(v0 + 16));

  swift_deallocObject(v0);
}

_OWORD *partial apply for closure #1 in Mirror.init(internalReflecting:subjectType:customAncestor:)@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(unint64_t **)(v2 + 48);
  uint64_t v5 = *a1;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  swift_reflectionMirror_subscript((swift::SwiftError **)(v2 + 16), v4, v5, &v14, &v13, (unint64_t *)&unk_1ECA06310, v12);
  uint64_t v6 = v14;
  if (!v14)
  {
    unint64_t v7 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = v13;
    if (!v13) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  unint64_t v7 = specialized String.init(validatingUTF8:)((uint64_t)v14);
  uint64_t v9 = v8;
  uint64_t v10 = v13;
  if (v13) {
LABEL_3:
  }
    ((void (*)(char *))v10)(v6);
LABEL_4:
  uint64_t result = outlined init with take of Any(v12, (_OWORD *)(a2 + 16));
  *(void *)a2 = v7;
  *(void *)(a2 + 8) = v9;
  return result;
}

void sub_18152C7A4()
{
  if (v0[3])
  {
    swift_release(v0[4]);
    swift_release(v0[7]);
  }
  __swift_destroy_boxed_opaque_existential_1Tm(v0 + 9);

  swift_deallocObject((uint64_t)v0);
}

atomic_ullong *partial apply for closure #2 in Mirror.init(internalReflecting:subjectType:customAncestor:)@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = *(uint64_t **)(v1 + 16);
  outlined init with take of Mirror?(v1 + 24, (uint64_t)v21);
  uint64_t v4 = v22;
  uint64_t v5 = v23;
  if (swift_isClassType(v3)) {
    uint64_t result = v3;
  }
  else {
    uint64_t result = 0;
  }
  if (!result || (uint64_t result = (atomic_ullong *)_swift_class_getSuperclass((swift *)result)) == 0)
  {
    *(_OWORD *)(a1 + 25) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    return result;
  }
  unint64_t v7 = result;
  outlined init with take of Mirror?(v1 + 24, (uint64_t)v24);
  if (!v24[0]) {
    goto LABEL_11;
  }
  uint64_t v8 = v24[1];
  uint64_t v9 = v25;
  uint64_t v11 = v26;
  uint64_t v10 = v27;
  char v12 = v28;
  if ((atomic_ullong *)v24[0] == v7)
  {
    *(void *)a1 = v7;
    *(void *)(a1 + 8) = v8;
    *(void *)(a1 + 16) = v9;
    *(void *)(a1 + 24) = v11;
    *(void *)(a1 + 32) = v10;
    *(unsigned char *)(a1 + 40) = v12;
    goto LABEL_13;
  }
  if (!v28)
  {
LABEL_11:
    outlined init with copy of Any(v1 + 72, (uint64_t)v16);
    outlined init with take of Mirror?(v1 + 24, (uint64_t)v15);
    outlined retain of Mirror?(v1 + 24);
    uint64_t result = Mirror.init(internalReflecting:subjectType:customAncestor:)(&v17, v16, v7, v15);
    uint64_t v13 = v18;
    char v14 = v20;
    *(_OWORD *)a1 = v17;
    *(void *)(a1 + 16) = v13;
    *(_OWORD *)(a1 + 24) = v19;
    *(unsigned char *)(a1 + 40) = v14;
    return result;
  }
  *(void *)a1 = v24[0];
  *(void *)(a1 + 8) = v8;
  *(void *)(a1 + 16) = v9;
  *(void *)(a1 + 24) = v11;
  *(void *)(a1 + 32) = v10;
  *(unsigned char *)(a1 + 40) = 1;
LABEL_13:
  swift_retain(v4);
  return swift_retain(v5);
}

uint64_t outlined retain of Mirror?(uint64_t a1)
{
  return a1;
}

atomic_ullong *outlined copy of Mirror?(atomic_ullong *result, atomic_ullong *a2, uint64_t a3, uint64_t a4, atomic_ullong *a5)
{
  if (result)
  {
    swift_retain(a2);
    return swift_retain(a5);
  }
  return result;
}

uint64_t canonical specialized generic type metadata accessor for _ContiguousArrayStorage<_DictionaryCodingKey>()
{
  return self;
}

uint64_t outlined init with copy of MirrorPath(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v3;
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

uint64_t outlined init with copy of (String, Any)(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (String, Any));
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

void partial apply for closure #1 in closure #1 in _unimplementedInitializer(className:initName:file:line:column:)(const char *a1, uint64_t a2)
{
  closure #1 in closure #1 in _unimplementedInitializer(className:initName:file:line:column:)(a1, a2, *(const char **)(v2 + 16), *(void *)(v2 + 24), *(unsigned char *)(v2 + 32), *(const char **)(v2 + 40), *(void *)(v2 + 48), *(void *)(v2 + 56), *(void *)(v2 + 64));
}

void partial apply for closure #1 in closure #1 in closure #1 in _unimplementedInitializer(className:initName:file:line:column:)(const char *a1, uint64_t a2)
{
  closure #1 in closure #1 in closure #1 in _unimplementedInitializer(className:initName:file:line:column:)(a1, a2, *(const char **)(v2 + 16), *(void *)(v2 + 24), *(const char **)(v2 + 32), *(void *)(v2 + 40), *(void *)(v2 + 48), *(void *)(v2 + 56));
}

uint64_t partial apply for closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)(const char *a1, uint64_t a2)
{
  return closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)(a1, a2, *(const char **)(v2 + 16), *(void *)(v2 + 24), *(unsigned char *)(v2 + 32), *(const char **)(v2 + 40), *(void *)(v2 + 48), *(void *)(v2 + 56), *(_DWORD *)(v2 + 64));
}

void partial apply for closure #1 in closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)(const char *a1, uint64_t a2)
{
  closure #1 in closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)(a1, a2, *(const char **)(v2 + 16), *(void *)(v2 + 24), *(const char **)(v2 + 32), *(void *)(v2 + 40), *(void *)(v2 + 48), *(_DWORD *)(v2 + 56));
}

{
  uint64_t v2;

  closure #1 in closure #1 in closure #1 in _assertionFailure(_:_:file:line:flags:)(a1, a2, *(const char **)(v2 + 16), *(void *)(v2 + 24), *(const char **)(v2 + 32), *(void *)(v2 + 40), *(void *)(v2 + 48), *(_DWORD *)(v2 + 56));
}

uint64_t partial apply for closure #1 in _ArrayBufferProtocol._arrayOutOfPlaceReplace<A>(_:with:count:)(uint64_t a1, uint64_t a2)
{
  return closure #1 in _ArrayBufferProtocol._arrayOutOfPlaceReplace<A>(_:with:count:)(a1, a2, v2[6], v2[2], v2[3], v2[4], v2[5]);
}

void sub_18152CB68()
{
  uint64_t v1 = *(void *)(v0 + 16);
  uint64_t v2 = *(void *)(v1 - 8);
  unint64_t v3 = (*(unsigned __int8 *)(v2 + 80) + 48) & ~(unint64_t)*(unsigned __int8 *)(v2 + 80);
  swift_release(*(void *)(v0 + 32));
  (*(void (**)(unint64_t, uint64_t))(v2 + 8))(v0 + v3, v1);

  swift_deallocObject(v0);
}

void *partial apply for closure #2 in static Mirror._superclassIterator<A>(_:_:)@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *(swift::SwiftError **)(v1 + 16);
  uint64_t v5 = *((void *)v4 - 1);
  uint64_t v6 = *(unsigned __int8 *)(v5 + 80);
  unint64_t v7 = *(uint64_t **)(v1 + 40);
  uint64_t result = (*(void *(**)(uint64_t **__return_ptr))(v1 + 24))(&v21);
  uint64_t v10 = v21;
  uint64_t v9 = v22;
  uint64_t v11 = v23;
  uint64_t v12 = v24;
  uint64_t v13 = v25;
  char v14 = v26;
  if (v21 != v7 && (v26 & 1) == 0)
  {
    uint64_t v15 = v2 + ((v6 + 48) & ~v6);
    v20[3] = v4;
    uint64_t v16 = v22;
    boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v20);
    (*(void (**)(void *, uint64_t, swift::SwiftError *))(v5 + 16))(boxed_opaque_existential_0Tm, v15, v4);
    v18[0] = v10;
    v18[1] = v16;
    v18[2] = v11;
    v18[3] = v12;
    v18[4] = v13;
    char v19 = 0;
    uint64_t result = (void *)Mirror.init(internalReflecting:subjectType:customAncestor:)(v20, v7, (uint64_t)v18, (uint64_t)&v21);
    uint64_t v10 = v21;
    uint64_t v9 = v22;
    LODWORD(v11) = v23;
    uint64_t v12 = v24;
    uint64_t v13 = v25;
    char v14 = v26;
  }
  *(void *)a1 = v10;
  *(void *)(a1 + 8) = v9;
  *(void *)(a1 + 16) = v11;
  *(void *)(a1 + 24) = v12;
  *(void *)(a1 + 32) = v13;
  *(unsigned char *)(a1 + 40) = v14;
  return result;
}

void sub_18152CD58()
{
  (*(void (**)(unint64_t))(*(void *)(*(void *)(v0 + 16) - 8) + 8))(v0+ ((*(unsigned __int8 *)(*(void *)(*(void *)(v0 + 16) - 8) + 80) + 24) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*(void *)(v0 + 16) - 8) + 80)));

  swift_deallocObject(v0);
}

double partial apply for closure #1 in static Mirror._superclassIterator<A>(_:_:)@<D0>(uint64_t a1@<X8>)
{
  unint64_t v3 = *(swift::SwiftError **)(v1 + 16);
  uint64_t v4 = *((void *)v3 - 1);
  unint64_t v5 = (*(unsigned __int8 *)(v4 + 80) + 24) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80);
  uint64_t v6 = v1 + v5;
  unint64_t v7 = *(uint64_t **)(v1 + ((*(void *)(v4 + 64) + v5 + 7) & 0xFFFFFFFFFFFFFFF8));
  v13[3] = v3;
  boxed_opaque_existential_0Tm = __swift_allocate_boxed_opaque_existential_0Tm(v13);
  (*(void (**)(void *, uint64_t, swift::SwiftError *))(v4 + 16))(boxed_opaque_existential_0Tm, v6, v3);
  memset(v12, 0, 41);
  Mirror.init(internalReflecting:subjectType:customAncestor:)(v13, v7, (uint64_t)v12, (uint64_t)&v14);
  uint64_t v9 = v15;
  char v10 = v17;
  *(_OWORD *)a1 = v14;
  *(void *)(a1 + 16) = v9;
  double result = *(double *)&v16;
  *(_OWORD *)(a1 + 24) = v16;
  *(unsigned char *)(a1 + 40) = v10;
  return result;
}

void sub_18152CEF0()
{
  swift_deallocObject(v0);
}

Class *__swift_instantiateGenericMetadata(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5)
{
  v6[0] = a2;
  v6[1] = a3;
  void v6[2] = a4;
  return swift_getGenericMetadata(a1, (uint64_t)v6, a5);
}

Class *__swift_instantiateCanonicalPrespecializedGenericMetadata(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, dispatch_once_t *a6)
{
  v7[0] = a2;
  v7[1] = a3;
  void v7[2] = a4;
  return swift_getCanonicalPrespecializedGenericMetadata(a1, (uint64_t)v7, a5, a6);
}

uint64_t *type metadata completion function for Zip2Sequence(uint64_t a1)
{
  double result = swift_checkMetadataState(319, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    v5[0] = *(result - 1) + 64;
    double result = swift_checkMetadataState(319, *(void *)(a1 + 24));
    if (v4 <= 0x3F)
    {
      v5[1] = *(result - 1) + 64;
      swift_initStructMetadata(a1, 0, 2uLL, (uint64_t)v5, a1 + 48);
      return 0;
    }
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for Zip2Sequence(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  unint64_t v4 = a1;
  uint64_t v5 = *(void *)(*(void *)(a3 + 16) - 8);
  uint64_t v6 = *(void *)(v5 + 64);
  uint64_t v7 = *(void *)(a3 + 24);
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = *(_DWORD *)(v8 + 80);
  uint64_t v10 = v6 + v9;
  unint64_t v11 = ((v6 + v9) & ~v9) + *(void *)(v8 + 64);
  uint64_t v12 = (*(unsigned char *)(v5 + 80) | *(unsigned char *)(v8 + 80));
  if (v12 > 7 || ((*(_DWORD *)(v5 + 80) | *(_DWORD *)(v8 + 80)) & 0x100000) != 0 || v11 > 0x18)
  {
    unsigned __int8 v15 = *a2;
    swift::SwiftError *v4 = *a2;
    unint64_t v4 = (atomic_ullong **)((char *)v15 + ((v12 + 16) & ~v12));
    swift_retain(v15);
  }
  else
  {
    uint64_t v16 = ~v9;
    (*(void (**)(atomic_ullong **, atomic_ullong **))(v5 + 16))(a1, a2);
    (*(void (**)(unint64_t, unint64_t, uint64_t))(v8 + 16))(((unint64_t)v4 + v10) & v16, ((unint64_t)a2 + v10) & v16, v7);
  }
  return v4;
}

uint64_t destroy for Zip2Sequence(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(*(void *)(a2 + 16) - 8) + 8;
  (*(void (**)(void))v4)();
  uint64_t v5 = *(void *)(*(void *)(a2 + 24) - 8);
  uint64_t v6 = *(uint64_t (**)(unint64_t))(v5 + 8);
  unint64_t v7 = (*(void *)(v4 + 56) + a1 + *(unsigned __int8 *)(v5 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80);

  return v6(v7);
}

uint64_t initializeWithCopy for Zip2Sequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(*(void *)(a3 + 16) - 8) + 16;
  (*(void (**)(void))v6)();
  uint64_t v7 = *(void *)(*(void *)(a3 + 24) - 8);
  (*(void (**)(unint64_t, unint64_t))(v7 + 16))((*(void *)(v6 + 48) + *(unsigned __int8 *)(v7 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80), (*(void *)(v6 + 48) + *(unsigned __int8 *)(v7 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80));
  return a1;
}

uint64_t assignWithCopy for Zip2Sequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(*(void *)(a3 + 16) - 8) + 24;
  (*(void (**)(void))v6)();
  uint64_t v7 = *(void *)(*(void *)(a3 + 24) - 8);
  (*(void (**)(unint64_t, unint64_t))(v7 + 24))((*(void *)(v6 + 40) + *(unsigned __int8 *)(v7 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80), (*(void *)(v6 + 40) + *(unsigned __int8 *)(v7 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80));
  return a1;
}

uint64_t initializeWithTake for Zip2Sequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(*(void *)(a3 + 16) - 8) + 32;
  (*(void (**)(void))v6)();
  uint64_t v7 = *(void *)(*(void *)(a3 + 24) - 8);
  (*(void (**)(unint64_t, unint64_t))(v7 + 32))((*(void *)(v6 + 32) + *(unsigned __int8 *)(v7 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80), (*(void *)(v6 + 32) + *(unsigned __int8 *)(v7 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80));
  return a1;
}

uint64_t assignWithTake for Zip2Sequence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(*(void *)(a3 + 16) - 8) + 40;
  (*(void (**)(void))v6)();
  uint64_t v7 = *(void *)(*(void *)(a3 + 24) - 8);
  (*(void (**)(unint64_t, unint64_t))(v7 + 40))((*(void *)(v6 + 24) + *(unsigned __int8 *)(v7 + 80) + a1) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80), (*(void *)(v6 + 24) + *(unsigned __int8 *)(v7 + 80) + a2) & ~(unint64_t)*(unsigned __int8 *)(v7 + 80));
  return a1;
}

uint64_t getEnumTagSinglePayload for Zip2Sequence(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  uint64_t v5 = *(void *)(a3 + 24);
  unsigned int v6 = *(_DWORD *)(v4 + 84);
  uint64_t v7 = *(void *)(v5 - 8);
  uint64_t v8 = *(unsigned int *)(v7 + 84);
  uint64_t v9 = *(unsigned __int8 *)(v7 + 80);
  if (v8 <= v6) {
    unsigned int v10 = *(_DWORD *)(v4 + 84);
  }
  else {
    unsigned int v10 = *(_DWORD *)(v7 + 84);
  }
  if (!a2) {
    return 0;
  }
  uint64_t v11 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64) + v9;
  unsigned int v12 = a2 - v10;
  if (a2 <= v10) {
    goto LABEL_24;
  }
  uint64_t v13 = (v11 & ~v9) + *(void *)(*(void *)(v5 - 8) + 64);
  char v14 = 8 * v13;
  if (v13 <= 3)
  {
    unsigned int v16 = ((v12 + ~(-1 << v14)) >> v14) + 1;
    if (HIWORD(v16))
    {
      int v15 = *(_DWORD *)((char *)a1 + v13);
      if (!v15) {
        goto LABEL_24;
      }
      goto LABEL_14;
    }
    if (v16 > 0xFF)
    {
      int v15 = *(unsigned __int16 *)((char *)a1 + v13);
      if (!*(unsigned __int16 *)((char *)a1 + v13)) {
        goto LABEL_24;
      }
      goto LABEL_14;
    }
    if (v16 < 2)
    {
LABEL_24:
      if (v10)
      {
        if (v6 >= v8) {
          return (*(uint64_t (**)(void))(v4 + 48))();
        }
        else {
          return (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v7 + 48))(((unint64_t)a1 + v11) & ~v9, v8, v5);
        }
      }
      return 0;
    }
  }
  int v15 = *((unsigned __int8 *)a1 + v13);
  if (!*((unsigned char *)a1 + v13)) {
    goto LABEL_24;
  }
LABEL_14:
  int v17 = (v15 - 1) << v14;
  if (v13 > 3) {
    int v17 = 0;
  }
  if (v13)
  {
    if (v13 <= 3) {
      int v18 = v13;
    }
    else {
      int v18 = 4;
    }
    switch(v18)
    {
      case 2:
        int v19 = *a1;
        break;
      case 3:
        int v19 = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        int v19 = *(_DWORD *)a1;
        break;
      default:
        int v19 = *(unsigned __int8 *)a1;
        break;
    }
  }
  else
  {
    int v19 = 0;
  }
  return v10 + (v19 | v17) + 1;
}

void storeEnumTagSinglePayload for Zip2Sequence(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 16) - 8);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  uint64_t v8 = *(void *)(a4 + 24);
  uint64_t v9 = *(void *)(v8 - 8);
  unsigned int v10 = *(_DWORD *)(v9 + 84);
  uint64_t v11 = *(unsigned __int8 *)(v9 + 80);
  if (v10 <= v7) {
    unsigned int v12 = *(_DWORD *)(v6 + 84);
  }
  else {
    unsigned int v12 = *(_DWORD *)(v9 + 84);
  }
  uint64_t v13 = *(void *)(*(void *)(*(void *)(a4 + 16) - 8) + 64) + v11;
  size_t v14 = (v13 & ~v11) + *(void *)(*(void *)(v8 - 8) + 64);
  BOOL v15 = a3 >= v12;
  unsigned int v16 = a3 - v12;
  if (v16 != 0 && v15)
  {
    if (v14 <= 3)
    {
      unsigned int v20 = ((v16 + ~(-1 << (8 * v14))) >> (8 * v14)) + 1;
      if (HIWORD(v20))
      {
        int v17 = 4;
      }
      else if (v20 >= 0x100)
      {
        int v17 = 2;
      }
      else
      {
        int v17 = v20 > 1;
      }
    }
    else
    {
      int v17 = 1;
    }
  }
  else
  {
    int v17 = 0;
  }
  if (v12 < a2)
  {
    unsigned int v18 = ~v12 + a2;
    if (v14 < 4)
    {
      int v19 = (v18 >> (8 * v14)) + 1;
      if (v14)
      {
        int v21 = v18 & ~(-1 << (8 * v14));
        bzero(a1, v14);
        if (v14 == 3)
        {
          *(_WORD *)a1 = v21;
          a1[2] = BYTE2(v21);
        }
        else if (v14 == 2)
        {
          *(_WORD *)a1 = v21;
        }
        else
        {
          *a1 = v21;
        }
      }
    }
    else
    {
      bzero(a1, v14);
      *(_DWORD *)a1 = v18;
      int v19 = 1;
    }
    switch(v17)
    {
      case 1:
        a1[v14] = v19;
        return;
      case 2:
        *(_WORD *)&a1[v14] = v19;
        return;
      case 3:
        goto LABEL_41;
      case 4:
        *(_DWORD *)&a1[v14] = v19;
        return;
      default:
        return;
    }
  }
  switch(v17)
  {
    case 1:
      a1[v14] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 2:
      *(_WORD *)&a1[v14] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_24;
    case 3:
LABEL_41:
      __break(1u);
      JUMPOUT(0x18152D99CLL);
    case 4:
      *(_DWORD *)&a1[v14] = 0;
      goto LABEL_23;
    default:
LABEL_23:
      if (a2)
      {
LABEL_24:
        if (v7 >= v10)
        {
          uint64_t v24 = *(void (**)(void))(v6 + 56);
          v24();
        }
        else
        {
          unint64_t v22 = (unint64_t)&a1[v13] & ~v11;
          unsigned __int8 v23 = *(void (**)(unint64_t))(v9 + 56);
          v23(v22);
        }
      }
      return;
  }
}

Class *type metadata accessor for _TeeStream(__int16 a1, uint64_t a2)
{
  return swift_getCanonicalPrespecializedGenericMetadata(a1, a2, &nominal type descriptor for _TeeStream.Flags, &flag for loading of canonical specialized generic type metadata for _TeeStream);
}

uint64_t getEnumTagSinglePayload for _MergeError(unsigned int *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if ((a2 + 1) >= 0x10000) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 1) < 0x100) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4) {
    return *a1;
  }
  if (v3 == 2) {
    return *(unsigned __int16 *)a1;
  }
  return *(unsigned __int8 *)a1;
}

unsigned char *storeEnumTagSinglePayload for _MergeError(unsigned char *result, int a2, int a3)
{
  if ((a3 + 1) >= 0x10000) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) < 0x100) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2)
  {
    switch(v5)
    {
      case 1:
        *double result = a2;
        return result;
      case 2:
        *(_WORD *)double result = a2;
        return result;
      case 3:
        goto LABEL_19;
      case 4:
        *(_DWORD *)double result = a2;
        return result;
      default:
        return result;
    }
  }
  switch(v5)
  {
    case 1:
      *double result = 0;
      break;
    case 2:
      *(_WORD *)double result = 0;
      break;
    case 3:
LABEL_19:
      __break(1u);
      JUMPOUT(0x18152DAD8);
    case 4:
      *(_DWORD *)double result = 0;
      break;
    default:
      return result;
  }
  return result;
}

void *type metadata accessor for _ApplicationError()
{
  return &unk_1ECA028B8;
}

void *type metadata accessor for _V()
{
  return &unk_1ECA028E0;
}

uint64_t *type metadata completion function for _FixedArray16(uint64_t a1)
{
  double result = swift_checkMetadataState(319, *(void *)(a1 + 16));
  if (v3 <= 0x3F)
  {
    unsigned int v4 = (uint64_t *)(*(result - 1) + 64);
    p_size = v4;
    uint64_t v6 = v4;
    unsigned int v7 = v4;
    uint64_t v8 = v4;
    uint64_t v9 = v4;
    unsigned int v10 = v4;
    uint64_t v11 = v4;
    unsigned int v12 = v4;
    uint64_t v13 = v4;
    size_t v14 = v4;
    BOOL v15 = v4;
    unsigned int v16 = v4;
    int v17 = v4;
    unsigned int v18 = v4;
    int v19 = v4;
    swift_getTupleTypeLayout((uint64_t)v20, 0, 0x10u, (uint64_t)&v4);
    unsigned int v4 = (uint64_t *)v20;
    p_size = &value witness table for Builtin.Int8.size;
    swift_initStructMetadata(a1, 0, 2uLL, (uint64_t)&v4, a1 + 24);
    return 0;
  }
  return result;
}

atomic_ullong **initializeBufferWithCopyOfBuffer for _FixedArray16(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  unsigned int v4 = a1;
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void *)(v6 + 64);
  uint64_t v8 = *(_DWORD *)(v6 + 80);
  uint64_t v9 = ~v8;
  BOOL v10 = v8 <= 7 && (*(_DWORD *)(v6 + 80) & 0x100000) == 0;
  if (v10
    && (uint64_t v11 = v7 + v8,
        uint64_t v12 = ((v7
              + v8
              + ((v7
                + v8
                + ((v7
                  + v8
                  + ((v7
                    + v8
                    + ((v7
                      + v8
                      + ((v7
                        + v8
                        + ((v7
                          + v8
                          + ((v7
                            + v8
                            + ((v7
                              + v8
                              + ((v7
                                + v8
                                + ((v7
                                  + v8
                                  + ((v7 + v8 + ((v7 + v8 + ((v7 + v8 + ((v7 + v8) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)
            + v7,
        (unint64_t)(v12 + 1) <= 0x18))
  {
    uint64_t v13 = *(void (**)(atomic_ullong **, atomic_ullong **, uint64_t))(v6 + 16);
    v13(a1, a2, v5);
    v13((atomic_ullong **)(((unint64_t)v4 + v11) & v9), (atomic_ullong **)(((unint64_t)a2 + v11) & v9), v5);
    unint64_t v14 = (v11 + (((unint64_t)a2 + v11) & v9)) & v9;
    v13((atomic_ullong **)((v11 + (((unint64_t)v4 + v11) & v9)) & v9), (atomic_ullong **)v14, v5);
    unint64_t v15 = (v11 + v14) & v9;
    v13((atomic_ullong **)((v11 + ((v11 + (((unint64_t)v4 + v11) & v9)) & v9)) & v9), (atomic_ullong **)v15, v5);
    unint64_t v16 = (v11 + v15) & v9;
    v13((atomic_ullong **)((v11 + ((v11 + ((v11 + (((unint64_t)v4 + v11) & v9)) & v9)) & v9)) & v9), (atomic_ullong **)v16, v5);
    uint64_t v17 = (v11 + v16) & v9;
    v13((atomic_ullong **)((v11 + ((v11 + ((v11 + ((v11 + (((unint64_t)v4 + v11) & v9)) & v9)) & v9)) & v9)) & v9), (atomic_ullong **)v17, v5);
    uint64_t v18 = (v11 + v17) & v9;
    v13((atomic_ullong **)((v11+ ((v11 + ((v11 + ((v11 + ((v11 + (((unint64_t)v4 + v11) & v9)) & v9)) & v9)) & v9)) & v9)) & v9), (atomic_ullong **)v18, v5);
    uint64_t v19 = (v11 + v18) & v9;
    v13((atomic_ullong **)((v11+ ((v11+ ((v11 + ((v11 + ((v11 + ((v11 + (((unint64_t)v4 + v11) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9), (atomic_ullong **)v19, v5);
    uint64_t v20 = (v11 + v19) & v9;
    v13((atomic_ullong **)((v11+ ((v11+ ((v11+ ((v11 + ((v11 + ((v11 + ((v11 + (((unint64_t)v4 + v11) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9), (atomic_ullong **)v20, v5);
    uint64_t v21 = (v11 + v20) & v9;
    v13((atomic_ullong **)((v11+ ((v11+ ((v11+ ((v11+ ((v11 + ((v11 + ((v11 + ((v11 + (((unint64_t)v4 + v11) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9), (atomic_ullong **)v21, v5);
    uint64_t v22 = (v11 + v21) & v9;
    v13((atomic_ullong **)((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11 + ((v11 + ((v11 + (((unint64_t)v4 + v11) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9), (atomic_ullong **)v22, v5);
    uint64_t v23 = (v11 + v22) & v9;
    v13((atomic_ullong **)((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11 + ((v11 + ((v11 + (((unint64_t)v4 + v11) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9), (atomic_ullong **)v23, v5);
    uint64_t v24 = (v11 + v23) & v9;
    v13((atomic_ullong **)((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11 + ((v11 + ((v11 + (((unint64_t)v4 + v11) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9), (atomic_ullong **)v24, v5);
    uint64_t v25 = (v11 + v24) & v9;
    v13((atomic_ullong **)((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11 + ((v11 + ((v11 + (((unint64_t)v4 + v11) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9), (atomic_ullong **)v25, v5);
    uint64_t v26 = (v11 + v25) & v9;
    v13((atomic_ullong **)((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11 + ((v11 + ((v11 + (((unint64_t)v4 + v11) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9), (atomic_ullong **)v26, v5);
    v13((atomic_ullong **)((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11+ ((v11 + ((v11 + ((v11 + (((unint64_t)v4 + v11) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9)) & v9), (atomic_ullong **)((v11 + v26) & v9), v5);
    *((unsigned char *)v4 + v12) = *((unsigned char *)a2 + v12);
  }
  else
  {
    uint64_t v27 = *a2;
    uint64_t *v4 = *a2;
    unsigned int v4 = (atomic_ullong **)((char *)v27 + ((v8 + 16) & v9));
    swift_retain(v27);
  }
  return v4;
}

uint64_t destroy for _FixedArray16(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v22 = *(void (**)(uint64_t, uint64_t))(v4 + 8);
  v22(a1, v3);
  uint64_t v5 = *(unsigned __int8 *)(v4 + 80);
  uint64_t v6 = *(void *)(v4 + 64) + v5;
  uint64_t v7 = (v6 + a1) & ~v5;
  v22(v7, v3);
  uint64_t v8 = (v6 + v7) & ~v5;
  v22(v8, v3);
  uint64_t v9 = (v6 + v8) & ~v5;
  v22(v9, v3);
  uint64_t v10 = (v6 + v9) & ~v5;
  v22(v10, v3);
  uint64_t v11 = (v6 + v10) & ~v5;
  v22(v11, v3);
  uint64_t v12 = (v6 + v11) & ~v5;
  v22(v12, v3);
  uint64_t v13 = (v6 + v12) & ~v5;
  v22(v13, v3);
  uint64_t v14 = (v6 + v13) & ~v5;
  v22(v14, v3);
  uint64_t v15 = (v6 + v14) & ~v5;
  v22(v15, v3);
  uint64_t v16 = (v6 + v15) & ~v5;
  v22(v16, v3);
  uint64_t v17 = (v6 + v16) & ~v5;
  v22(v17, v3);
  uint64_t v18 = (v6 + v17) & ~v5;
  v22(v18, v3);
  uint64_t v19 = (v6 + v18) & ~v5;
  v22(v19, v3);
  uint64_t v20 = (v6 + v19) & ~v5;
  v22(v20, v3);

  return ((uint64_t (*)(uint64_t, uint64_t))v22)((v6 + v20) & ~v5, v3);
}

uint64_t initializeWithCopy for _FixedArray16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 16);
  v7(a1, a2, v5);
  uint64_t v8 = *(void *)(v6 + 64);
  uint64_t v9 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v10 = v8 + v9;
  v7((v8 + v9 + a1) & ~v9, (v8 + v9 + a2) & ~v9, v5);
  uint64_t v11 = (v8 + v9 + ((v8 + v9 + a2) & ~v9)) & ~v9;
  v7((v8 + v9 + ((v8 + v9 + a1) & ~v9)) & ~v9, v11, v5);
  uint64_t v12 = (v8 + v9 + v11) & ~v9;
  v7((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9, v12, v5);
  uint64_t v13 = (v8 + v9 + v12) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9, v13, v5);
  uint64_t v14 = (v8 + v9 + v13) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v14, v5);
  uint64_t v15 = (v8 + v9 + v14) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v15, v5);
  uint64_t v16 = (v8 + v9 + v15) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v16, v5);
  uint64_t v17 = (v8 + v9 + v16) & ~v9;
  v7((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v17, v5);
  uint64_t v18 = (v8 + v9 + v17) & ~v9;
  v7((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v18, v5);
  uint64_t v19 = (v8 + v9 + v18) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v19, v5);
  uint64_t v20 = (v8 + v9 + v19) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v20, v5);
  uint64_t v21 = (v8 + v9 + v20) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v21, v5);
  uint64_t v22 = (v8 + v9 + v21) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v22, v5);
  uint64_t v23 = (v8 + v9 + v22) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v23, v5);
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, (v10 + v23) & ~v9, v5);
  uint64_t v24 = ((v10
        + ((v10
          + ((v10
            + ((v10
              + ((v10
                + ((v10
                  + ((v10
                    + ((v10
                      + ((v10
                        + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + (v10 & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)
      + v8;
  *(unsigned char *)(v24 + a1) = *(unsigned char *)(v24 + a2);
  return a1;
}

uint64_t assignWithCopy for _FixedArray16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 24);
  v7(a1, a2, v5);
  uint64_t v8 = *(void *)(v6 + 64);
  uint64_t v9 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v10 = v8 + v9;
  v7((v8 + v9 + a1) & ~v9, (v8 + v9 + a2) & ~v9, v5);
  uint64_t v11 = (v8 + v9 + ((v8 + v9 + a2) & ~v9)) & ~v9;
  v7((v8 + v9 + ((v8 + v9 + a1) & ~v9)) & ~v9, v11, v5);
  uint64_t v12 = (v8 + v9 + v11) & ~v9;
  v7((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9, v12, v5);
  uint64_t v13 = (v8 + v9 + v12) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9, v13, v5);
  uint64_t v14 = (v8 + v9 + v13) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v14, v5);
  uint64_t v15 = (v8 + v9 + v14) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v15, v5);
  uint64_t v16 = (v8 + v9 + v15) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v16, v5);
  uint64_t v17 = (v8 + v9 + v16) & ~v9;
  v7((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v17, v5);
  uint64_t v18 = (v8 + v9 + v17) & ~v9;
  v7((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v18, v5);
  uint64_t v19 = (v8 + v9 + v18) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v19, v5);
  uint64_t v20 = (v8 + v9 + v19) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v20, v5);
  uint64_t v21 = (v8 + v9 + v20) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v21, v5);
  uint64_t v22 = (v8 + v9 + v21) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v22, v5);
  uint64_t v23 = (v8 + v9 + v22) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v23, v5);
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, (v10 + v23) & ~v9, v5);
  uint64_t v24 = ((v10
        + ((v10
          + ((v10
            + ((v10
              + ((v10
                + ((v10
                  + ((v10
                    + ((v10
                      + ((v10
                        + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + (v10 & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)
      + v8;
  *(unsigned char *)(v24 + a1) = *(unsigned char *)(v24 + a2);
  return a1;
}

uint64_t initializeWithTake for _FixedArray16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 32);
  v7(a1, a2, v5);
  uint64_t v8 = *(void *)(v6 + 64);
  uint64_t v9 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v10 = v8 + v9;
  v7((v8 + v9 + a1) & ~v9, (v8 + v9 + a2) & ~v9, v5);
  uint64_t v11 = (v8 + v9 + ((v8 + v9 + a2) & ~v9)) & ~v9;
  v7((v8 + v9 + ((v8 + v9 + a1) & ~v9)) & ~v9, v11, v5);
  uint64_t v12 = (v8 + v9 + v11) & ~v9;
  v7((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9, v12, v5);
  uint64_t v13 = (v8 + v9 + v12) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9, v13, v5);
  uint64_t v14 = (v8 + v9 + v13) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v14, v5);
  uint64_t v15 = (v8 + v9 + v14) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v15, v5);
  uint64_t v16 = (v8 + v9 + v15) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v16, v5);
  uint64_t v17 = (v8 + v9 + v16) & ~v9;
  v7((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v17, v5);
  uint64_t v18 = (v8 + v9 + v17) & ~v9;
  v7((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v18, v5);
  uint64_t v19 = (v8 + v9 + v18) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v19, v5);
  uint64_t v20 = (v8 + v9 + v19) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v20, v5);
  uint64_t v21 = (v8 + v9 + v20) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v21, v5);
  uint64_t v22 = (v8 + v9 + v21) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v22, v5);
  uint64_t v23 = (v8 + v9 + v22) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v23, v5);
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, (v10 + v23) & ~v9, v5);
  uint64_t v24 = ((v10
        + ((v10
          + ((v10
            + ((v10
              + ((v10
                + ((v10
                  + ((v10
                    + ((v10
                      + ((v10
                        + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + (v10 & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)
      + v8;
  *(unsigned char *)(v24 + a1) = *(unsigned char *)(v24 + a2);
  return a1;
}

uint64_t assignWithTake for _FixedArray16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 16);
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 40);
  v7(a1, a2, v5);
  uint64_t v8 = *(void *)(v6 + 64);
  uint64_t v9 = *(unsigned __int8 *)(v6 + 80);
  uint64_t v10 = v8 + v9;
  v7((v8 + v9 + a1) & ~v9, (v8 + v9 + a2) & ~v9, v5);
  uint64_t v11 = (v8 + v9 + ((v8 + v9 + a2) & ~v9)) & ~v9;
  v7((v8 + v9 + ((v8 + v9 + a1) & ~v9)) & ~v9, v11, v5);
  uint64_t v12 = (v8 + v9 + v11) & ~v9;
  v7((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9, v12, v5);
  uint64_t v13 = (v8 + v9 + v12) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9, v13, v5);
  uint64_t v14 = (v8 + v9 + v13) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v14, v5);
  uint64_t v15 = (v8 + v9 + v14) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v15, v5);
  uint64_t v16 = (v8 + v9 + v15) & ~v9;
  v7((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v16, v5);
  uint64_t v17 = (v8 + v9 + v16) & ~v9;
  v7((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v17, v5);
  uint64_t v18 = (v8 + v9 + v17) & ~v9;
  v7((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v18, v5);
  uint64_t v19 = (v8 + v9 + v18) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v19, v5);
  uint64_t v20 = (v8 + v9 + v19) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v20, v5);
  uint64_t v21 = (v8 + v9 + v20) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v21, v5);
  uint64_t v22 = (v8 + v9 + v21) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v22, v5);
  uint64_t v23 = (v8 + v9 + v22) & ~v9;
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, v23, v5);
  v7((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10+ ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + ((v8 + v9 + a1) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9, (v10 + v23) & ~v9, v5);
  uint64_t v24 = ((v10
        + ((v10
          + ((v10
            + ((v10
              + ((v10
                + ((v10
                  + ((v10
                    + ((v10
                      + ((v10
                        + ((v10 + ((v10 + ((v10 + ((v10 + ((v10 + (v10 & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)
      + v8;
  *(unsigned char *)(v24 + a1) = *(unsigned char *)(v24 + a2);
  return a1;
}

uint64_t getEnumTagSinglePayload for _FixedArray16(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a3 + 16) - 8);
  unsigned int v5 = *(_DWORD *)(v4 + 84);
  if (!a2) {
    return 0;
  }
  unsigned int v7 = a2 - v5;
  if (a2 <= v5) {
    goto LABEL_19;
  }
  uint64_t v8 = *(unsigned __int8 *)(v4 + 80);
  uint64_t v6 = *(void *)(*(void *)(*(void *)(a3 + 16) - 8) + 64);
  uint64_t v9 = v6
     + ((v6
       + v8
       + ((v6
         + v8
         + ((v6
           + v8
           + ((v6
             + v8
             + ((v6
               + v8
               + ((v6
                 + v8
                 + ((v6
                   + v8
                   + ((v6
                     + v8
                     + ((v6
                       + v8
                       + ((v6
                         + v8
                         + ((v6 + v8 + ((v6 + v8 + ((v6 + v8 + ((v6 + v8 + ((v6 + v8) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)) & ~v8)
     + 1;
  char v10 = 8 * v9;
  if (v9 <= 3)
  {
    unsigned int v12 = ((v7 + ~(-1 << v10)) >> v10) + 1;
    if (HIWORD(v12))
    {
      int v11 = *(_DWORD *)((char *)a1 + v9);
      if (!v11) {
        goto LABEL_19;
      }
      goto LABEL_11;
    }
    if (v12 > 0xFF)
    {
      int v11 = *(unsigned __int16 *)((char *)a1 + v9);
      if (!*(unsigned __int16 *)((char *)a1 + v9)) {
        goto LABEL_19;
      }
      goto LABEL_11;
    }
    if (v12 < 2)
    {
LABEL_19:
      if (v5) {
        return (*(uint64_t (**)(void))(v4 + 48))();
      }
      return 0;
    }
  }
  int v11 = *((unsigned __int8 *)a1 + v9);
  if (!*((unsigned char *)a1 + v9)) {
    goto LABEL_19;
  }
LABEL_11:
  int v13 = (v11 - 1) << v10;
  if (v9 > 3) {
    int v13 = 0;
  }
  if (v9)
  {
    if (v9 > 3) {
      LODWORD(v9) = 4;
    }
    switch((int)v9)
    {
      case 2:
        LODWORD(v9) = *a1;
        break;
      case 3:
        LODWORD(v9) = *a1 | (*((unsigned __int8 *)a1 + 2) << 16);
        break;
      case 4:
        LODWORD(v9) = *(_DWORD *)a1;
        break;
      default:
        LODWORD(v9) = *(unsigned __int8 *)a1;
        break;
    }
  }
  return v5 + (v9 | v13) + 1;
}

void storeEnumTagSinglePayload for _FixedArray16(char *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)(a4 + 16) - 8);
  unsigned int v7 = *(_DWORD *)(v6 + 84);
  uint64_t v8 = *(void *)(v6 + 64);
  uint64_t v9 = *(unsigned __int8 *)(v6 + 80);
  size_t v10 = v8
      + ((v8
        + v9
        + ((v8
          + v9
          + ((v8
            + v9
            + ((v8
              + v9
              + ((v8
                + v9
                + ((v8
                  + v9
                  + ((v8
                    + v9
                    + ((v8
                      + v9
                      + ((v8
                        + v9
                        + ((v8
                          + v9
                          + ((v8 + v9 + ((v8 + v9 + ((v8 + v9 + ((v8 + v9 + ((v8 + v9) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)
      + 1;
  BOOL v11 = a3 >= v7;
  unsigned int v12 = a3 - v7;
  if (v12 != 0 && v11)
  {
    if (v10 <= 3)
    {
      unsigned int v16 = ((v12 + ~(-1 << (8 * v10))) >> (8 * v10)) + 1;
      if (HIWORD(v16))
      {
        int v13 = 4;
      }
      else if (v16 >= 0x100)
      {
        int v13 = 2;
      }
      else
      {
        int v13 = v16 > 1;
      }
    }
    else
    {
      int v13 = 1;
    }
  }
  else
  {
    int v13 = 0;
  }
  if (v7 < a2)
  {
    unsigned int v14 = ~v7 + a2;
    if (v10 < 4)
    {
      int v15 = (v14 >> (8 * v10)) + 1;
      if (v8
         + ((v8
           + v9
           + ((v8
             + v9
             + ((v8
               + v9
               + ((v8
                 + v9
                 + ((v8
                   + v9
                   + ((v8
                     + v9
                     + ((v8
                       + v9
                       + ((v8
                         + v9
                         + ((v8
                           + v9
                           + ((v8
                             + v9
                             + ((v8
                               + v9
                               + ((v8
                                 + v9
                                 + ((v8
                                   + v9
                                   + ((v8 + v9 + ((v8 + v9) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9)) & ~v9) != -1)
      {
        int v17 = v14 & ~(-1 << (8 * v10));
        bzero(a1, v10);
        if (v10 == 3)
        {
          *(_WORD *)a1 = v17;
          a1[2] = BYTE2(v17);
        }
        else if (v10 == 2)
        {
          *(_WORD *)a1 = v17;
        }
        else
        {
          *a1 = v17;
        }
      }
    }
    else
    {
      bzero(a1, v10);
      *(_DWORD *)a1 = v14;
      int v15 = 1;
    }
    switch(v13)
    {
      case 1:
        a1[v10] = v15;
        return;
      case 2:
        *(_WORD *)&a1[v10] = v15;
        return;
      case 3:
        goto LABEL_34;
      case 4:
        *(_DWORD *)&a1[v10] = v15;
        return;
      default:
        return;
    }
  }
  switch(v13)
  {
    case 1:
      a1[v10] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_21;
    case 2:
      *(_WORD *)&a1[v10] = 0;
      if (!a2) {
        return;
      }
      goto LABEL_21;
    case 3:
LABEL_34:
      __break(1u);
      JUMPOUT(0x18152F3F4);
    case 4:
      *(_DWORD *)&a1[v10] = 0;
      goto LABEL_20;
    default:
LABEL_20:
      if (a2)
      {
LABEL_21:
        uint64_t v18 = *(void (**)(void))(v6 + 56);
        v18();
      }
      return;
  }
}

Class *type metadata accessor for _FixedArray16(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return __swift_instantiateGenericMetadata(a1, a2, a3, a4, &nominal type descriptor for _FixedArray16.Flags);
}

uint64_t getEnumTagSinglePayload for KeyPathComponent(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 56)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *(void *)(a1 + 8) >> 2;
  if (v2 > 0x80000000) {
    int v3 = ~v2;
  }
  else {
    int v3 = -1;
  }
  return (v3 + 1);
}

double storeEnumTagSinglePayload for KeyPathComponent(uint64_t a1, int a2, int a3)
{
  if (a2 < 0)
  {
    double result = 0.0;
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 24) = 0u;
    *(_OWORD *)(a1 + 8) = 0u;
    *(void *)a1 = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(a1 + 56) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 4 * -a2;
      double result = 0.0;
      *(_OWORD *)(a1 + 16) = 0u;
      *(_OWORD *)(a1 + 32) = 0u;
      *(void *)(a1 + 48) = 0;
      return result;
    }
    *(unsigned char *)(a1 + 56) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t getEnumTag for KeyPathComponent(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8) >> 61;
  if (v1 <= 4) {
    return v1;
  }
  else {
    return (*(_DWORD *)a1 + 5);
  }
}

uint64_t destructiveProjectEnumData for KeyPathComponent(uint64_t result)
{
  *(void *)(result + 8) &= 0x1FFFFFFFFFFFFFFFuLL;
  return result;
}

uint64_t destructiveInjectEnumTag for KeyPathComponent(uint64_t result, uint64_t a2)
{
  if (a2 < 5)
  {
    *(void *)(result + 8) = *(void *)(result + 8) & 3 | (a2 << 61);
  }
  else
  {
    *(void *)double result = (a2 - 5);
    *(void *)(result + 8) = 0xA000000000000000;
    *(_OWORD *)(result + 16) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(void *)(result + 48) = 0;
  }
  return result;
}

ValueMetadata *type metadata accessor for KeyPathComponent()
{
  return &type metadata for KeyPathComponent;
}

ValueMetadata *type metadata accessor for Unicode._NormData()
{
  return &type metadata for Unicode._NormData;
}

uint64_t getEnumTagSinglePayload for Dictionary.Index(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFF && *(unsigned char *)(a1 + 17)) {
    return (*(_DWORD *)a1 + 255);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 16);
  if (v3 <= 1) {
    int v4 = -1;
  }
  else {
    int v4 = v3 ^ 0xFF;
  }
  return (v4 + 1);
}

uint64_t storeEnumTagSinglePayload for Dictionary.Index(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFE)
  {
    *(unsigned char *)(result + 16) = 0;
    *(void *)double result = a2 - 255;
    *(void *)(result + 8) = 0;
    if (a3 >= 0xFF) {
      *(unsigned char *)(result + 17) = 1;
    }
  }
  else
  {
    if (a3 >= 0xFF) {
      *(unsigned char *)(result + 17) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 16) = -(char)a2;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for UTF8ValidationResult()
{
  return &type metadata for UTF8ValidationResult;
}

uint64_t storeEnumTagSinglePayload for _WordQuestion(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)double result = 0;
    *(void *)(result + 8) = 0;
    *(unsigned char *)(result + 16) = 0;
    *(_DWORD *)double result = a2 - 1;
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 17) = v3;
  return result;
}

uint64_t getEnumTag for _WordQuestion(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t destructiveInjectEnumTag for _WordQuestion(uint64_t result, int a2)
{
  if (a2)
  {
    *(void *)double result = (a2 - 1);
    *(void *)(result + 8) = 0;
    *(unsigned char *)(result + 16) = 1;
  }
  else
  {
    *(unsigned char *)(result + 16) = 0;
  }
  return result;
}

ValueMetadata *type metadata accessor for _WordQuestion()
{
  return &type metadata for _WordQuestion;
}

ValueMetadata *type metadata accessor for _UInt128.Words()
{
  return &type metadata for _UInt128.Words;
}

ValueMetadata *type metadata accessor for _Int128.Words()
{
  return &type metadata for _Int128.Words;
}

ValueMetadata *type metadata accessor for _UInt128()
{
  return &type metadata for _UInt128;
}

uint64_t initializeBufferWithCopyOfBuffer for Unicode._NormDataBuffer(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)a2;
  *(void *)a1 = *(void *)a2;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  swift_bridgeObjectRetain(v3);
  return a1;
}

uint64_t assignWithCopy for Unicode._NormDataBuffer(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)a2;
  uint64_t v5 = *(void *)a1;
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRetain(v4);
  swift_bridgeObjectRelease(v5);
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  return a1;
}

uint64_t assignWithTake for Unicode._NormDataBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a1;
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRelease(v4);
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  return a1;
}

uint64_t getEnumTagSinglePayload for Unicode._NormDataBuffer(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 9)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for Unicode._NormDataBuffer(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(unsigned char *)(result + 8) = 0;
    *(void *)double result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 9) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)double result = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 9) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Unicode._NormDataBuffer()
{
  return &type metadata for Unicode._NormDataBuffer;
}

uint64_t getEnumTagSinglePayload for RawKeyPathComponent(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 24)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t storeEnumTagSinglePayload for RawKeyPathComponent(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(void *)double result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 24) = v3;
  return result;
}

ValueMetadata *type metadata accessor for RawKeyPathComponent()
{
  return &type metadata for RawKeyPathComponent;
}

ValueMetadata *type metadata accessor for RawKeyPathComponent.Header()
{
  return &type metadata for RawKeyPathComponent.Header;
}

uint64_t getEnumTagSinglePayload for KeyPathComponent.ArgumentRef(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 != 1 && *(unsigned char *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 2);
  }
  if (*(void *)(a1 + 16)) {
    int v3 = -1;
  }
  else {
    int v3 = 0;
  }
  return (v3 + 1);
}

uint64_t storeEnumTagSinglePayload for KeyPathComponent.ArgumentRef(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(void *)double result = a2 - 2;
    *(void *)(result + 8) = 0;
    if (a3 >= 2) {
      *(unsigned char *)(result + 32) = 1;
    }
  }
  else
  {
    if (a3 >= 2) {
      *(unsigned char *)(result + 32) = 0;
    }
    if (a2) {
      *(void *)(result + 16) = 0;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for KeyPathComponent.ArgumentRef()
{
  return &type metadata for KeyPathComponent.ArgumentRef;
}

ValueMetadata *type metadata accessor for ComputedAccessorsPtr()
{
  return &type metadata for ComputedAccessorsPtr;
}

uint64_t getEnumTagSinglePayload for ComputedPropertyID(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFE && *(unsigned char *)(a1 + 9)) {
    return (*(_DWORD *)a1 + 254);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 8);
  BOOL v4 = v3 >= 3;
  int v5 = v3 - 3;
  if (!v4) {
    int v5 = -1;
  }
  return (v5 + 1);
}

uint64_t storeEnumTagSinglePayload for ComputedPropertyID(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFD)
  {
    *(unsigned char *)(result + 8) = 0;
    *(void *)double result = a2 - 254;
    if (a3 >= 0xFE) {
      *(unsigned char *)(result + 9) = 1;
    }
  }
  else
  {
    if (a3 >= 0xFE) {
      *(unsigned char *)(result + 9) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 8) = a2 + 2;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for ComputedPropertyID()
{
  return &type metadata for ComputedPropertyID;
}

uint64_t getEnumTagSinglePayload for Bool(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFF) {
    goto LABEL_17;
  }
  if (a2 + 1 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 1) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 1;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 2;
  int v8 = (v6 + 2147483646) & 0x7FFFFFFF;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for Bool(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 1 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFF) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFE)
  {
    unsigned int v6 = ((a2 - 255) >> 8) + 1;
    *double result = a2 + 1;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x18152FB20);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *double result = a2 + 1;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for UTF8ExtraInfo()
{
  return &type metadata for UTF8ExtraInfo;
}

uint64_t getEnumTagSinglePayload for AutoreleasingUnsafeMutablePointer(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 != 1 && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 2);
  }
  if (*(void *)a1) {
    int v3 = -1;
  }
  else {
    int v3 = 0;
  }
  return (v3 + 1);
}

uint64_t storeEnumTagSinglePayload for AutoreleasingUnsafeMutablePointer(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 1)
  {
    *(void *)double result = a2 - 2;
    if (a3 >= 2) {
      *(unsigned char *)(result + 8) = 1;
    }
  }
  else
  {
    if (a3 >= 2) {
      *(unsigned char *)(result + 8) = 0;
    }
    if (a2) {
      *(void *)double result = 0;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for ComputedArgumentWitnessesPtr()
{
  return &type metadata for ComputedArgumentWitnessesPtr;
}

uint64_t getEnumTagSinglePayload for Unicode.NumericType(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFE) {
    goto LABEL_17;
  }
  if (a2 + 2 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 2) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 2;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 3;
  int v8 = v6 - 3;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned char *storeEnumTagSinglePayload for Unicode.NumericType(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 2 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 2) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFE) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFD)
  {
    unsigned int v6 = ((a2 - 254) >> 8) + 1;
    *double result = a2 + 2;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x18152FD4CLL);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *double result = a2 + 2;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for KeyPathComputedIDKind()
{
  return &type metadata for KeyPathComputedIDKind;
}

uint64_t closure #1 in Substring.withUnsafeBytes<A>(_:)partial apply(uint64_t a1, uint64_t a2)
{
  return partial apply for closure #1 in Substring.withUnsafeBytes<A>(_:)(a1, a2);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Substring@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Substring.UnicodeScalarView(a1, a2);
}

void *thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)specialized partial apply(uint64_t a1)
{
  return partial apply for specialized thunk for @callee_guaranteed (@in_guaranteed A) -> (@out A1, @error @out B1)(a1);
}

void preconditionFailure(_:file:line:)(uint64_t (*a1)(void), uint64_t a2, const char *a3, uint64_t a4, char a5, unint64_t a6)
{
}

uint64_t closure #1 in String.init<A, B>(decoding:as:)partial apply@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return partial apply for closure #1 in String.init<A, B>(decoding:as:)(a1, a2, a3);
}

uint64_t closure #1 in __SwiftNativeNSArrayWithContiguousStorage._objectAt(_:)partial apply@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return partial apply for closure #1 in __SwiftNativeNSArrayWithContiguousStorage._objectAt(_:)(a1, a2, a3);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance _CocoaArrayWrapper@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Int.Words(a1, a2);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Unicode.Scalar.UTF16View@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance _ValidUTF8Buffer.Iterator(a1, a2);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UInt8.Words@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Int8.Words(a1, a2);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UInt16.Words@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance Int16.Words(a1, a2);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance _UnsafeBitset@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  return protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance String.UnicodeScalarView(a1, a2);
}

BOOL closure #1 in Sequence<>.contains(_:)specialized partial apply(_DWORD *a1)
{
  return partial apply for specialized closure #1 in Sequence<>.contains(_:)(a1);
}

uint64_t protocol witness for Decodable.init(from:) in conformance <> PartialRangeThrough<A>@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  return protocol witness for Decodable.init(from:) in conformance <> PartialRangeFrom<A>(a1, a2, a3, a4);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance <> Range<A>(void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Encodable.encode(to:) in conformance <> ClosedRange<A>(a1, a2, a3);
}

uint64_t protocol witness for Encodable.encode(to:) in conformance <> PartialRangeThrough<A>(void *a1, uint64_t a2, uint64_t a3)
{
  return protocol witness for Encodable.encode(to:) in conformance <> PartialRangeFrom<A>(a1, a2, a3);
}

uint64_t protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UnsafeMutableBufferPointer<A>@<X0>(uint64_t (*a1)(uint64_t, uint64_t)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  return protocol witness for Sequence.withContiguousStorageIfAvailable<A>(_:) in conformance UnsafeBufferPointer<A>(a1, a2, a3);
}

uint64_t swift::getOverride_dynamicCast(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 8);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_dynamicCastClass(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 16);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_dynamicCastClassUnconditional(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 24);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_dynamicCastUnknownClass(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 32);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_dynamicCastUnknownClassUnconditional(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 40);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_dynamicCastMetatype(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 48);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_dynamicCastMetatypeUnconditional(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 56);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_dynamicCastForeignClassMetatype(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 64);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_dynamicCastForeignClassMetatypeUnconditional(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 72);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_conformsToProtocol(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 80);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_conformsToProtocol2(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 88);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_conformsToProtocolCommon(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 96);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_getKeyPath(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 104);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_getTypeByMangledNode(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 112);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_getTypeByMangledName(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 120);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_getAssociatedTypeWitnessSlow(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 128);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_getAssociatedConformanceWitnessSlow(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 136);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_dynamicCastObjCClass(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 144);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_dynamicCastObjCClassUnconditional(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 152);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_dynamicCastObjCClassMetatype(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 160);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_dynamicCastObjCClassMetatypeUnconditional(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 168);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_dynamicCastForeignClass(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 176);
  }
  else {
    return 0;
  }
}

uint64_t swift::getOverride_dynamicCastForeignClassUnconditional(swift *this)
{
  if (getOverrideSectionPtr(void)::OverrideSectionPtr) {
    return *(void *)(getOverrideSectionPtr(void)::OverrideSectionPtr + 184);
  }
  else {
    return 0;
  }
}

uint8_t *getOverrideSectionPtr(void)::$_0::__invoke()
{
  unint64_t size = 0;
  uint64_t v0 = _NSGetMachExecuteHeader();
  double result = getsectiondata(v0, "__DATA", "__swift60_hooks", &size);
  if (!result || size <= 0xBF) {
    double result = 0;
  }
  getOverrideSectionPtr(void)::OverrideSectionPtr = (uint64_t)result;
  return result;
}

uint64_t swift::hashable_support::findHashableBaseTypeOfHashableType(uint64_t a1)
{
  atomic_fetch_add_explicit(&HashableConformances, 1u, memory_order_acquire);
  do
  {
    unint64_t explicit = atomic_load_explicit(&qword_1EB1F8718, memory_order_acquire);
    unint64_t v3 = atomic_load_explicit(&qword_1EB1F8720, memory_order_acquire);
    unint64_t v4 = atomic_load_explicit(&dword_1EB1F8714, memory_order_acquire);
  }
  while (explicit != atomic_load_explicit(&qword_1EB1F8718, memory_order_acquire));
  uint64_t v34 = a1;
  if (explicit) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  BOOL v6 = v5 || v4 == 0;
  if (v6
  {
    atomic_fetch_add_explicit(&HashableConformances, 0xFFFFFFFF, memory_order_release);
    uint64_t v9 = *(void *)swift_conformsToProtocolCommon(a1, (uint64_t)&protocol descriptor for Hashable);
    if (v9) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t ConformingSuperclass = swift::findConformingSuperclass(a1, v10);
    uint64_t v34 = a1;
    os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB1F8728);
    uint64_t v11 = qword_1EB1F8720;
    unsigned int v12 = 4;
    if ((qword_1EB1F8720 & 3) != 0 && (qword_1EB1F8720 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
      unsigned int v12 = *(unsigned __int8 *)(qword_1EB1F8720 & 0xFFFFFFFFFFFFFFFCLL);
    }
    unint64_t v13 = dword_1EB1F8714;
    unsigned int v14 = (_DWORD *)qword_1EB1F8718;
    if (qword_1EB1F8718) {
      uint64_t v15 = qword_1EB1F8718 + 8;
    }
    else {
      uint64_t v15 = 0;
    }
    {
      __dmb(0xBu);
      if (HashableConformances)
      {
LABEL_52:
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB1F8728);
        return ConformingSuperclass;
      }
      int v17 = (void **)qword_1EB1F8730;
      if (qword_1EB1F8730)
      {
        do
        {
          uint64_t v18 = (void **)*v17;
          free(v17[1]);
          free(v17);
          int v17 = v18;
        }
        while (v18);
      }
LABEL_51:
      qword_1EB1F8730 = 0;
      goto LABEL_52;
    }
    uint64_t v33 = (v13 + 1);
    if ((1 << v12) / (unint64_t)((1 << v12) - v33) < 4)
    {
      unsigned int v20 = v16;
      if (!v14) {
        goto LABEL_31;
      }
    }
    else
    {
      unsigned int v20 = v19;
      if (!v14) {
        goto LABEL_31;
      }
    }
    unint64_t v21 = (unint64_t)v14;
    if (v13 < *v14)
    {
LABEL_37:
      unint64_t v26 = v21 + 16 * v13;
      *(void *)(v26 + 8) = a1;
      *(void *)(v26 + 16) = ConformingSuperclass;
      atomic_store(v33, (unsigned int *)&dword_1EB1F8714);
      switch(v11 & 3)
      {
        case 1:
          unint64_t v27 = v11 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v11 & 3) == 0) {
            unint64_t v27 = 0;
          }
          atomic_store(v13 + 1, (unsigned __int8 *)(v27 + v20));
          break;
        case 2:
          unint64_t v28 = v11 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v11 & 3) == 0) {
            unint64_t v28 = 0;
          }
          atomic_store(v13 + 1, (unsigned __int16 *)(v28 + 2 * v20));
          break;
        case 3:
          unint64_t v29 = v11 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v11 & 3) == 0) {
            unint64_t v29 = 0;
          }
          atomic_store(v33, (unsigned int *)(v29 + 4 * v20));
          break;
        default:
          atomic_store((v33 << (4 * v20)) | v11, (unint64_t *)&qword_1EB1F8720);
          break;
      }
      __dmb(0xBu);
      if (HashableConformances) {
        goto LABEL_52;
      }
      uint64_t v30 = (void **)qword_1EB1F8730;
      if (qword_1EB1F8730)
      {
        do
        {
          uint64_t v31 = (void **)*v30;
          free(v30[1]);
          free(v30);
          uint64_t v30 = v31;
        }
        while (v31);
      }
      goto LABEL_51;
    }
LABEL_31:
    unint64_t v22 = v13 + (v13 >> 2);
    if (v22 <= v13 + 1) {
      unint64_t v22 = v13 + 1;
    }
    size_t v23 = malloc_good_size((16 * v22) | 8);
    uint64_t v24 = malloc_type_malloc(v23, 0x1000D770uLL);
    if (!v24) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    unint64_t v21 = (unint64_t)v24;
    *uint64_t v24 = (v23 + 0xFFFFFFFF8) >> 4;
    if (v14)
    {
      memcpy(v24 + 2, v14 + 2, 16 * v13);
      uint64_t v25 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
      *uint64_t v25 = qword_1EB1F8730;
      v25[1] = v14;
      qword_1EB1F8730 = (uint64_t)v25;
    }
    atomic_store(v21, (unint64_t *)&qword_1EB1F8718);
    goto LABEL_37;
  }
  uint64_t ConformingSuperclass = *(void *)(v7 + 8);
  atomic_fetch_add_explicit(&HashableConformances, 0xFFFFFFFF, memory_order_release);
  return ConformingSuperclass;
}

uint64_t swift::hashable_support::findHashableBaseType(uint64_t a1)
{
  atomic_fetch_add_explicit(&HashableConformances, 1u, memory_order_acquire);
  do
  {
    unint64_t explicit = atomic_load_explicit(&qword_1EB1F8718, memory_order_acquire);
    unint64_t v3 = atomic_load_explicit(&qword_1EB1F8720, memory_order_acquire);
    unint64_t v4 = atomic_load_explicit(&dword_1EB1F8714, memory_order_acquire);
  }
  while (explicit != atomic_load_explicit(&qword_1EB1F8718, memory_order_acquire));
  uint64_t v34 = a1;
  if (explicit) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  BOOL v6 = v5 || v4 == 0;
  if (v6
  {
    atomic_fetch_add_explicit(&HashableConformances, 0xFFFFFFFF, memory_order_release);
    uint64_t v9 = (uint64_t *)swift_conformsToProtocolCommon(a1, (uint64_t)&protocol descriptor for Hashable);
    if (!v9) {
      return 0;
    }
    if (*v9) {
      uint64_t v10 = *v9;
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t ConformingSuperclass = swift::findConformingSuperclass(a1, v10);
    uint64_t v34 = a1;
    os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB1F8728);
    uint64_t v11 = qword_1EB1F8720;
    unsigned int v12 = 4;
    if ((qword_1EB1F8720 & 3) != 0 && (qword_1EB1F8720 & 0xFFFFFFFFFFFFFFFCLL) != 0) {
      unsigned int v12 = *(unsigned __int8 *)(qword_1EB1F8720 & 0xFFFFFFFFFFFFFFFCLL);
    }
    unint64_t v13 = dword_1EB1F8714;
    unsigned int v14 = (_DWORD *)qword_1EB1F8718;
    if (qword_1EB1F8718) {
      uint64_t v15 = qword_1EB1F8718 + 8;
    }
    else {
      uint64_t v15 = 0;
    }
    {
      __dmb(0xBu);
      if (HashableConformances)
      {
LABEL_54:
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB1F8728);
        return ConformingSuperclass;
      }
      int v17 = (void **)qword_1EB1F8730;
      if (qword_1EB1F8730)
      {
        do
        {
          uint64_t v18 = (void **)*v17;
          free(v17[1]);
          free(v17);
          int v17 = v18;
        }
        while (v18);
      }
LABEL_53:
      qword_1EB1F8730 = 0;
      goto LABEL_54;
    }
    uint64_t v33 = (v13 + 1);
    if ((1 << v12) / (unint64_t)((1 << v12) - v33) < 4)
    {
      unsigned int v20 = v16;
      if (!v14) {
        goto LABEL_33;
      }
    }
    else
    {
      unsigned int v20 = v19;
      if (!v14) {
        goto LABEL_33;
      }
    }
    unint64_t v21 = (unint64_t)v14;
    if (v13 < *v14)
    {
LABEL_39:
      unint64_t v26 = v21 + 16 * v13;
      *(void *)(v26 + 8) = a1;
      *(void *)(v26 + 16) = ConformingSuperclass;
      atomic_store(v33, (unsigned int *)&dword_1EB1F8714);
      switch(v11 & 3)
      {
        case 1:
          unint64_t v27 = v11 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v11 & 3) == 0) {
            unint64_t v27 = 0;
          }
          atomic_store(v13 + 1, (unsigned __int8 *)(v27 + v20));
          break;
        case 2:
          unint64_t v28 = v11 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v11 & 3) == 0) {
            unint64_t v28 = 0;
          }
          atomic_store(v13 + 1, (unsigned __int16 *)(v28 + 2 * v20));
          break;
        case 3:
          unint64_t v29 = v11 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v11 & 3) == 0) {
            unint64_t v29 = 0;
          }
          atomic_store(v33, (unsigned int *)(v29 + 4 * v20));
          break;
        default:
          atomic_store((v33 << (4 * v20)) | v11, (unint64_t *)&qword_1EB1F8720);
          break;
      }
      __dmb(0xBu);
      if (HashableConformances) {
        goto LABEL_54;
      }
      uint64_t v30 = (void **)qword_1EB1F8730;
      if (qword_1EB1F8730)
      {
        do
        {
          uint64_t v31 = (void **)*v30;
          free(v30[1]);
          free(v30);
          uint64_t v30 = v31;
        }
        while (v31);
      }
      goto LABEL_53;
    }
LABEL_33:
    unint64_t v22 = v13 + (v13 >> 2);
    if (v22 <= v13 + 1) {
      unint64_t v22 = v13 + 1;
    }
    size_t v23 = malloc_good_size((16 * v22) | 8);
    uint64_t v24 = malloc_type_malloc(v23, 0x1000D770uLL);
    if (!v24) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    unint64_t v21 = (unint64_t)v24;
    *uint64_t v24 = (v23 + 0xFFFFFFFF8) >> 4;
    if (v14)
    {
      memcpy(v24 + 2, v14 + 2, 16 * v13);
      uint64_t v25 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
      *uint64_t v25 = qword_1EB1F8730;
      v25[1] = v14;
      qword_1EB1F8730 = (uint64_t)v25;
    }
    atomic_store(v21, (unint64_t *)&qword_1EB1F8718);
    goto LABEL_39;
  }
  uint64_t ConformingSuperclass = *(void *)(v7 + 8);
  atomic_fetch_add_explicit(&HashableConformances, 0xFFFFFFFF, memory_order_release);
  return ConformingSuperclass;
}

uint64_t _swift_makeAnyHashableUpcastingToHashableBaseType(swift **a1, objc_object *a2, uint64_t *a3, uint64_t a4)
{
  while (1)
  {
    uint64_t v8 = *a3;
    if ((unint64_t)*a3 > 0x7FF) {
      LODWORD(v8) = 0;
    }
    if ((v8 - 515) >= 2 && v8 != 773 && v8 != 0)
    {
      uint64_t v17 = (uint64_t)a1;
      uint64_t v18 = (uint64_t)a2;
      uint64_t HashableBaseTypeOfHashableType = (uint64_t)a3;
      goto LABEL_13;
    }
    AsSwiftValue = swift::getAsSwiftValue(*a1, a2);
    if (!AsSwiftValue) {
      break;
    }
    uint64_t ValueFromSwiftValue = swift::getValueFromSwiftValue(AsSwiftValue, v11);
    unsigned int v14 = v13;
    uint64_t v15 = swift_conformsToProtocolCommon(ValueFromSwiftValue, (uint64_t)&protocol descriptor for Hashable);
    if (!v15) {
      break;
    }
    a1 = v14;
    a3 = (uint64_t *)ValueFromSwiftValue;
    a4 = v15;
  }
  uint64_t HashableBaseTypeOfHashableType = swift::hashable_support::findHashableBaseTypeOfHashableType((uint64_t)a3);
  uint64_t v17 = (uint64_t)a1;
  uint64_t v18 = (uint64_t)a2;
LABEL_13:

  return _swift_makeAnyHashableUsingDefaultRepresentation(v17, v18, HashableBaseTypeOfHashableType, a4);
}

uint64_t swift::ConcurrentReadableHashMap<anonymous namespace'::HashableConformanceEntry,swift::LazyMutex>::find<anonymous namespace'::HashableConformanceKey>(unint64_t *a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v4 = *a1;
  BOOL v5 = &unk_1EB1F3000;
  {
    unint64_t v22 = a1;
    uint64_t v20 = a4;
    unint64_t v18 = a3;
    unint64_t v21 = a2;
    unint64_t v19 = v4;
    BOOL v5 = &unk_1EB1F3000;
    a3 = v18;
    unint64_t v4 = v19;
    a4 = v20;
    int v16 = v15;
    a2 = v21;
    a1 = v22;
    if (v16)
    {
      unint64_t v17 = __swift::__runtime::llvm::hashing::detail::fixed_seed_override;
      if (!__swift::__runtime::llvm::hashing::detail::fixed_seed_override) {
        unint64_t v17 = 0xFF51AFD7ED558CCDLL;
      }
      __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed = v17;
      BOOL v5 = (void *)&unk_1EB1F3000;
      a3 = v18;
      unint64_t v4 = v19;
      a2 = v21;
      a1 = v22;
      a4 = v20;
    }
  }
  uint64_t v6 = (v5[38] + 8 * v4) ^ HIDWORD(v4);
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(v4) ^ ((0x9DDFEA08EB382D69 * v6) >> 47) ^ (0x9DDFEA08EB382D69 * v6));
  uint64_t v8 = 0x1DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  uint64_t v9 = (char *)(a2 & 0xFFFFFFFFFFFFFFFCLL);
  char v10 = 4;
  if ((a2 & 3) != 0 && v9) {
    char v10 = *v9;
  }
  if ((a2 & 3) == 0) {
    uint64_t v9 = 0;
  }
  while (2)
  {
    unint64_t v11 = v8 & ~(-1 << v10);
    if (v11 <= 1) {
      unint64_t v11 = 1;
    }
    switch(a2 & 3)
    {
      case 1uLL:
        LODWORD(v12) = v9 + v11;
        LOBYTE(v12) = atomic_load_explicit(&v9[v11], memory_order_acquire);
        if (v12) {
          goto LABEL_19;
        }
        return 0;
      case 2uLL:
        LODWORD(v12) = v9 + 2 * v11;
        LOWORD(v12) = atomic_load_explicit((atomic_ushort *volatile)&v9[2 * v11], memory_order_acquire);
        if (!v12) {
          return 0;
        }
        goto LABEL_19;
      case 3uLL:
        LODWORD(v12) = atomic_load_explicit((atomic_uint *volatile)&v9[4 * v11], memory_order_acquire);
        if (v12) {
          goto LABEL_19;
        }
        return 0;
      default:
        uint64_t v12 = (a2 >> (4 * v11)) & 0xF;
        if (v12)
        {
LABEL_19:
          unint64_t v13 = (v12 - 1);
          if (v13 < a3 && *(void *)(a4 + 16 * v13) == *a1) {
            return a4 + 16 * v13;
          }
          uint64_t v8 = v11 + 1;
          continue;
        }
        return 0;
    }
  }
}

unint64_t swift::ConcurrentReadableHashMap<anonymous namespace'::HashableConformanceEntry,swift::LazyMutex>::resize(unint64_t a1, unsigned int a2, uint64_t a3)
{
  char v6 = a2 + 1;
  unsigned int v7 = (a2 + 1);
  if (v7 >= 0x11) {
    unsigned int v8 = 4;
  }
  else {
    unsigned int v8 = 2;
  }
  if (v7 < 9) {
    size_t v9 = 1;
  }
  else {
    size_t v9 = v8;
  }
  unint64_t v10 = (unint64_t)malloc_type_calloc(2 << a2, v9, 0x4269077AuLL);
  if (!v10) {
    swift::hashable_support::findHashableBaseTypeOfHashableType();
  }
  if (v9 != 1)
  {
    if (v9 == 4) {
      size_t v9 = 3;
    }
    else {
      size_t v9 = 2;
    }
  }
  unint64_t v11 = v9 | v10;
  *(unsigned char *)unint64_t v10 = v6;
  if (a2)
  {
    uint64_t v12 = a2;
    uint64_t v13 = ~(-2 << a2);
    uint64_t v14 = a1 & 3;
    uint64_t v15 = v14;
    unint64_t v16 = a1 & 0xFFFFFFFFFFFFFFFCLL;
    if ((a1 & 3) != 0) {
      unint64_t v17 = a1 & 0xFFFFFFFFFFFFFFFCLL;
    }
    else {
      unint64_t v17 = 0;
    }
    unint64_t v18 = v11 & 3;
    unint64_t v19 = v10 & 0xFFFFFFFFFFFFFFFCLL;
    if ((v11 & 3) == 0) {
      unint64_t v19 = 0;
    }
    uint64_t v20 = 1;
    unint64_t v21 = (void *)&unk_1EB1F3000;
    while (2)
    {
      switch(v14)
      {
        case 0:
          uint64_t v23 = (a1 >> (4 * v20)) & 0xF;
          if (!v23) {
            goto LABEL_20;
          }
          goto LABEL_29;
        case 1:
          LODWORD(v23) = *(unsigned __int8 *)(v17 + v20);
          if (*(unsigned char *)(v17 + v20)) {
            goto LABEL_29;
          }
          goto LABEL_20;
        case 2:
          LODWORD(v23) = *(unsigned __int16 *)(v17 + 2 * v20);
          if (!*(_WORD *)(v17 + 2 * v20)) {
            goto LABEL_20;
          }
          goto LABEL_29;
        case 3:
          LODWORD(v23) = *(_DWORD *)(v17 + 4 * v20);
          if (!v23) {
            goto LABEL_20;
          }
LABEL_29:
          unint64_t v24 = *(void *)(a3 + 16 * (v23 - 1));
          if ((atomic_load_explicit((atomic_uchar *volatile)v22, memory_order_acquire) & 1) == 0)
          {
            uint64_t v30 = v22;
            uint64_t v37 = v14;
            uint64_t v38 = v15;
            unint64_t v35 = v18;
            uint64_t v36 = v12;
            uint64_t v39 = v13;
            unint64_t v40 = v17;
            unint64_t v41 = v19;
            uint64_t v42 = v20;
            int v43 = v23;
            unint64_t v44 = v24;
            int v31 = __cxa_guard_acquire(v22);
            unint64_t v24 = v44;
            LODWORD(v23) = v43;
            unint64_t v21 = &unk_1EB1F3000;
            unint64_t v19 = v41;
            uint64_t v20 = v42;
            uint64_t v13 = v39;
            unint64_t v17 = v40;
            unint64_t v18 = v35;
            uint64_t v12 = v36;
            uint64_t v14 = v37;
            uint64_t v15 = v38;
            unint64_t v22 = v30;
            if (v31)
            {
              unint64_t v32 = __swift::__runtime::llvm::hashing::detail::fixed_seed_override;
              if (!__swift::__runtime::llvm::hashing::detail::fixed_seed_override) {
                unint64_t v32 = 0xFF51AFD7ED558CCDLL;
              }
              __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed = v32;
              __cxa_guard_release(v30);
              unint64_t v24 = v44;
              LODWORD(v23) = v43;
              unint64_t v21 = (void *)&unk_1EB1F3000;
              unint64_t v19 = v41;
              uint64_t v20 = v42;
              uint64_t v13 = v39;
              unint64_t v17 = v40;
              unint64_t v18 = v35;
              uint64_t v12 = v36;
              uint64_t v14 = v37;
              uint64_t v15 = v38;
              unint64_t v22 = v30;
            }
          }
          unint64_t v25 = HIDWORD(v24);
          unint64_t v26 = 0x9DDFEA08EB382D69 * ((v21[38] + 8 * v24) ^ HIDWORD(v24));
          for (unint64_t i = 0x9DDFEA08EB382D69
                  * ((0x9DDFEA08EB382D69 * (v25 ^ (v26 >> 47) ^ v26)) ^ ((0x9DDFEA08EB382D69
                                                                          * (v25 ^ (v26 >> 47) ^ v26)) >> 47));
                ;
                unint64_t i = v29 + 1)
          {
            unint64_t v29 = i & v13;
            if ((i & v13) != 0)
            {
              switch((int)v18)
              {
                case 1:
                  LODWORD(v28) = *(unsigned __int8 *)(v19 + v29);
                  break;
                case 2:
                  LODWORD(v28) = *(unsigned __int16 *)(v19 + 2 * v29);
                  break;
                case 3:
                  LODWORD(v28) = *(_DWORD *)(v19 + 4 * v29);
                  break;
                default:
                  uint64_t v28 = (v11 >> (4 * v29)) & 0xF;
                  break;
              }
              if (!v28) {
                break;
              }
            }
          }
          if (v18 == 3)
          {
            *(_DWORD *)(v19 + 4 * v29) = v23;
          }
          else if (v18 == 2)
          {
            *(_WORD *)(v19 + 2 * v29) = v23;
          }
          else
          {
            *(unsigned char *)(v19 + v29) = v23;
          }
LABEL_20:
          if (!((unint64_t)++v20 >> v12)) {
            continue;
          }
          goto LABEL_48;
        default:
          JUMPOUT(0);
      }
    }
  }
  uint64_t v15 = a1 & 3;
  unint64_t v16 = a1 & 0xFFFFFFFFFFFFFFFCLL;
LABEL_48:
  atomic_store(v11, (unint64_t *)&qword_1EB1F8720);
  if (v15 && v16)
  {
    uint64_t v33 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
    *uint64_t v33 = qword_1EB1F8730;
    v33[1] = v16;
    qword_1EB1F8730 = (uint64_t)v33;
  }
  return v11;
}

char *swift_arrayInitWithCopy(char *__dst, char *__src, uint64_t a3, unint64_t *a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    unsigned int v7 = __dst;
    if (*(a4 - 1)) {
      uint64_t v8 = *(a4 - 1);
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(void *)(v8 + 72);
    if (*(unsigned char *)(v8 + 82))
    {
      uint64_t TypeContextDescriptor = swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a4);
      if (TypeContextDescriptor && (*(unsigned char *)(TypeContextDescriptor + 2) & 0x10) != 0)
      {
        return (char *)swift::swift_generic_arrayInitWithCopy(v7, __src, v5, v9, (uint64_t)a4);
      }
      else
      {
        swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a4);
        if (*(void *)(v8 + 16)) {
          uint64_t v12 = *(uint64_t (**)(char *, char *, unint64_t *))(v8 + 16);
        }
        else {
          uint64_t v12 = 0;
        }
        uint64_t v13 = 0;
        do
        {
          __dst = (char *)v12(&v7[v13], &__src[v13], a4);
          v13 += v9;
          --v5;
        }
        while (v5);
      }
    }
    else
    {
      size_t v10 = v9 * a3;
      return (char *)memcpy(__dst, __src, v10);
    }
  }
  return __dst;
}

char *swift_arrayInitWithTakeNoAlias(char *__dst, char *__src, uint64_t a3, unint64_t *a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    unsigned int v7 = __dst;
    if (*(a4 - 1)) {
      uint64_t v8 = *(a4 - 1);
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(void *)(v8 + 72);
    if ((*(unsigned char *)(v8 + 82) & 0x10) != 0)
    {
      swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a4);
      swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a4);
      if (*(void *)(v8 + 32)) {
        unint64_t v11 = *(uint64_t (**)(char *, char *, unint64_t *))(v8 + 32);
      }
      else {
        unint64_t v11 = 0;
      }
      uint64_t v12 = 0;
      do
      {
        __dst = (char *)v11(&v7[v12], &__src[v12], a4);
        v12 += v9;
        --v5;
      }
      while (v5);
    }
    else
    {
      size_t v10 = v9 * a3;
      return (char *)memcpy(__dst, __src, v10);
    }
  }
  return __dst;
}

char *swift_arrayInitWithTakeFrontToBack(char *__dst, char *__src, uint64_t a3, unint64_t *a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    unsigned int v7 = __dst;
    if (*(a4 - 1)) {
      uint64_t v8 = *(a4 - 1);
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(void *)(v8 + 72);
    if ((*(unsigned char *)(v8 + 82) & 0x10) != 0)
    {
      swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a4);
      swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a4);
      if (*(void *)(v8 + 32)) {
        unint64_t v11 = *(uint64_t (**)(char *, char *, unint64_t *))(v8 + 32);
      }
      else {
        unint64_t v11 = 0;
      }
      uint64_t v12 = 0;
      do
      {
        __dst = (char *)v11(&v7[v12], &__src[v12], a4);
        v12 += v9;
        --v5;
      }
      while (v5);
    }
    else
    {
      size_t v10 = v9 * a3;
      return (char *)memmove(__dst, __src, v10);
    }
  }
  return __dst;
}

char *swift_arrayInitWithTakeBackToFront(char *__dst, char *__src, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    unsigned int v7 = __dst;
    if (*(void *)(a4 - 8)) {
      uint64_t v8 = *(void *)(a4 - 8);
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(void *)(v8 + 72);
    if ((*(unsigned char *)(v8 + 82) & 0x10) != 0)
    {
      if (*(void *)(v8 + 32)) {
        unint64_t v11 = *(uint64_t (**)(char *, char *, uint64_t))(v8 + 32);
      }
      else {
        unint64_t v11 = 0;
      }
      uint64_t v12 = v9 * (a3 - 1);
      do
      {
        --v5;
        __dst = (char *)v11(&v7[v12], &__src[v12], a4);
        v12 -= v9;
      }
      while (v5);
    }
    else
    {
      size_t v10 = v9 * a3;
      return (char *)memmove(__dst, __src, v10);
    }
  }
  return __dst;
}

char *swift_arrayAssignWithCopyNoAlias(char *__dst, char *__src, uint64_t a3, unint64_t *a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    unsigned int v7 = __dst;
    if (*(a4 - 1)) {
      uint64_t v8 = *(a4 - 1);
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(void *)(v8 + 72);
    if (*(unsigned char *)(v8 + 82))
    {
      swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a4);
      uint64_t TypeContextDescriptor = swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a4);
      if (TypeContextDescriptor && (*(unsigned char *)(TypeContextDescriptor + 2) & 0x10) != 0)
      {
        return (char *)swift_generic_arrayAssignWithCopy(v7, __src, v5, v9, (uint64_t)a4);
      }
      else
      {
        if (*(void *)(v8 + 24)) {
          uint64_t v12 = *(uint64_t (**)(char *, char *, unint64_t *))(v8 + 24);
        }
        else {
          uint64_t v12 = 0;
        }
        uint64_t v13 = 0;
        do
        {
          __dst = (char *)v12(&v7[v13], &__src[v13], a4);
          v13 += v9;
          --v5;
        }
        while (v5);
      }
    }
    else
    {
      size_t v10 = v9 * a3;
      return (char *)memcpy(__dst, __src, v10);
    }
  }
  return __dst;
}

char *swift_arrayAssignWithCopyFrontToBack(char *__dst, char *__src, uint64_t a3, unint64_t *a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    unsigned int v7 = __dst;
    if (*(a4 - 1)) {
      uint64_t v8 = *(a4 - 1);
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(void *)(v8 + 72);
    if (*(unsigned char *)(v8 + 82))
    {
      swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a4);
      uint64_t TypeContextDescriptor = swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a4);
      if (TypeContextDescriptor && (*(unsigned char *)(TypeContextDescriptor + 2) & 0x10) != 0)
      {
        return (char *)swift_generic_arrayAssignWithCopy(v7, __src, v5, v9, (uint64_t)a4);
      }
      else
      {
        if (*(void *)(v8 + 24)) {
          uint64_t v12 = *(uint64_t (**)(char *, char *, unint64_t *))(v8 + 24);
        }
        else {
          uint64_t v12 = 0;
        }
        uint64_t v13 = 0;
        do
        {
          __dst = (char *)v12(&v7[v13], &__src[v13], a4);
          v13 += v9;
          --v5;
        }
        while (v5);
      }
    }
    else
    {
      size_t v10 = v9 * a3;
      return (char *)memmove(__dst, __src, v10);
    }
  }
  return __dst;
}

char *swift_arrayAssignWithCopyBackToFront(char *__dst, char *__src, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    unsigned int v7 = __dst;
    if (*(void *)(a4 - 8)) {
      uint64_t v8 = *(void *)(a4 - 8);
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(void *)(v8 + 72);
    if (*(unsigned char *)(v8 + 82))
    {
      if (*(void *)(v8 + 24)) {
        unint64_t v11 = *(uint64_t (**)(char *, char *, uint64_t))(v8 + 24);
      }
      else {
        unint64_t v11 = 0;
      }
      uint64_t v12 = v9 * (a3 - 1);
      do
      {
        --v5;
        __dst = (char *)v11(&v7[v12], &__src[v12], a4);
        v12 -= v9;
      }
      while (v5);
    }
    else
    {
      size_t v10 = v9 * a3;
      return (char *)memmove(__dst, __src, v10);
    }
  }
  return __dst;
}

char *swift_arrayAssignWithTake(char *__dst, char *__src, uint64_t a3, unint64_t *a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    unsigned int v7 = __dst;
    if (*(a4 - 1)) {
      uint64_t v8 = *(a4 - 1);
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(void *)(v8 + 72);
    if ((*(unsigned char *)(v8 + 82) & 0x11) != 0)
    {
      swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a4);
      swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a4);
      if (*(void *)(v8 + 40)) {
        size_t v10 = *(uint64_t (**)(char *, char *, unint64_t *))(v8 + 40);
      }
      else {
        size_t v10 = 0;
      }
      uint64_t v12 = 0;
      do
      {
        __dst = (char *)v10(&v7[v12], &__src[v12], a4);
        v12 += v9;
        --v5;
      }
      while (v5);
    }
    else
    {
      size_t v11 = v9 * a3;
      return (char *)memcpy(__dst, __src, v11);
    }
  }
  return __dst;
}

void swift_arrayDestroy(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  if (a2)
  {
    uint64_t v4 = a2;
    uint64_t v6 = *(a3 - 1);
    if (v6)
    {
      uint64_t v7 = *(a3 - 1);
      if ((*(unsigned char *)(v6 + 82) & 1) == 0) {
        return;
      }
    }
    else
    {
      uint64_t v7 = 0;
      if ((MEMORY[0x52] & 1) == 0) {
        return;
      }
    }
    uint64_t v8 = *(void *)(v7 + 72);
    uint64_t TypeContextDescriptor = swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a3);
    if (TypeContextDescriptor && (*(unsigned char *)(TypeContextDescriptor + 2) & 0x10) != 0)
    {
      swift::swift_generic_arrayDestroy(a1, v4, v8, (uint64_t)a3);
    }
    else
    {
      size_t v10 = (void (**)(uint64_t, unint64_t *))(v7 + 8);
      do
      {
        (*v10)(a1, a3);
        a1 += v8;
        --v4;
      }
      while (v4);
    }
  }
}

uint64_t swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(unint64_t *a1)
{
  unint64_t v1 = *a1;
  if (*a1 > 0x7FF) {
    LODWORD(v1) = 0;
  }
  if ((int)v1 > 514)
  {
    if (v1 == 515 || v1 == 516)
    {
      uint64_t v2 = a1[1];
      if (v2) {
        return v2;
      }
      return 0;
    }
    return 0;
  }
  if ((v1 - 512) < 3)
  {
    uint64_t v2 = a1[1];
    if (v2) {
      return v2;
    }
    return 0;
  }
  if (v1) {
    return 0;
  }
  if ((a1[4] & 2) != 0)
  {
    uint64_t v2 = a1[8];
    if (v2) {
      return v2;
    }
  }
  return 0;
}

uint64_t swift::AutoDiffLinearMapContext::allocateSubcontext(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift::__runtime::llvm::BumpPtrAllocatorImpl<__swift::__runtime::llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate((uint64_t *)(a1 + 16), *(void *)(*(void *)(a2 - 8) + 64), __clz(*(unsigned __int8 *)(*(void *)(a2 - 8) + 80) + 1) ^ 0x3Fu);
  uint64_t v6 = (unint64_t *)(a1 + 112);
  unint64_t v5 = *(void *)(a1 + 112);
  uint64_t v14 = a2;
  uint64_t v15 = v4;
  uint64_t v7 = *(unsigned int *)(a1 + 120);
  uint64_t v8 = (char *)&v14;
  if (v7 >= *(_DWORD *)(a1 + 124))
  {
    unint64_t v11 = v7 + 1;
    BOOL v12 = v5 + 16 * v7 > (unint64_t)&v14;
    if (v5 <= (unint64_t)&v14 && v12)
    {
      uint64_t v13 = (char *)&v14 - v5;
      __swift::__runtime::llvm::SmallVectorTemplateBase<swift::AutoDiffLinearMapContext::AllocatedContextObjectRecord,false>::grow(a1 + 112, v11);
      unint64_t v5 = *v6;
      uint64_t v8 = &v13[*v6];
    }
    else
    {
      __swift::__runtime::llvm::SmallVectorTemplateBase<swift::AutoDiffLinearMapContext::AllocatedContextObjectRecord,false>::grow(a1 + 112, v11);
      unint64_t v5 = *v6;
      uint64_t v8 = (char *)&v14;
    }
  }
  *(_OWORD *)(v5 + 16 * *(unsigned int *)(a1 + 120)) = *(_OWORD *)v8;
  *(void *)uint64_t v8 = 0;
  *((void *)v8 + 1) = 0;
  ++*(_DWORD *)(a1 + 120);
  if (v14 && v15)
  {
    if (*(void *)(v14 - 8)) {
      uint64_t v9 = *(void *)(v14 - 8);
    }
    else {
      uint64_t v9 = 0;
    }
    (*(void (**)(void))(v9 + 8))();
  }
  return v4;
}

double swift_autoDiffCreateLinearMapContext(uint64_t a1)
{
  unint64_t v1 = malloc_type_malloc(a1 + 192, 0xE44BEC52uLL);
  *unint64_t v1 = &unk_1EC07DAE8;
  v1[1] = 3;
  v1[2] = 0;
  v1[3] = 0;
  v1[4] = v1 + 6;
  *(void *)&double result = 0x400000000;
  v1[5] = 0x400000000;
  v1[12] = 0;
  v1[10] = v1 + 12;
  v1[11] = 0;
  v1[13] = 1;
  v1[14] = v1 + 16;
  v1[15] = 0x400000000;
  return result;
}

uint64_t swift_autoDiffProjectTopLevelSubcontext(uint64_t a1)
{
  return a1 + 192;
}

uint64_t swift_autoDiffAllocateSubcontext(uint64_t a1, uint64_t a2)
{
  return __swift::__runtime::llvm::BumpPtrAllocatorImpl<__swift::__runtime::llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate((uint64_t *)(a1 + 16), a2, 3);
}

double swift_autoDiffCreateLinearMapContextWithType(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(*(void *)(*(void *)(a1 - 8) + 64) + 192, 0xAADA4E37uLL);
  *uint64_t v2 = &unk_1EC07DAE8;
  v2[1] = 3;
  void v2[2] = 0;
  void v2[3] = 0;
  void v2[4] = v2 + 6;
  v2[5] = 0x400000000;
  v2[12] = 0;
  v2[10] = v2 + 12;
  v2[11] = 0;
  v2[16] = a1;
  v2[13] = 1;
  v2[14] = v2 + 16;
  v2[17] = v2 + 24;
  *(void *)&double result = 0x400000001;
  v2[15] = 0x400000001;
  return result;
}

void destroyLinearMapContext()
{
  unint64_t v1 = *(char **)(v0 + 112);
  uint64_t v2 = *(unsigned int *)(v0 + 120);
  if (v2)
  {
    uint64_t v3 = 16 * v2;
    do
    {
      uint64_t v5 = *(void *)&v1[v3 - 16];
      if (v5 && *(void *)&v1[v3 - 8])
      {
        if (*(void *)(v5 - 8)) {
          uint64_t v4 = *(void *)(v5 - 8);
        }
        else {
          uint64_t v4 = 0;
        }
        (*(void (**)(void))(v4 + 8))();
      }
      v3 -= 16;
    }
    while (v3);
    unint64_t v1 = *(char **)(v0 + 112);
  }
  if (v1 != (char *)(v0 + 128)) {
    free(v1);
  }
  __swift::__runtime::llvm::BumpPtrAllocatorImpl<__swift::__runtime::llvm::MallocAllocator,4096ul,4096ul,128ul>::~BumpPtrAllocatorImpl(v0 + 16);

  free((void *)v0);
}

uint64_t __swift::__runtime::llvm::BumpPtrAllocatorImpl<__swift::__runtime::llvm::MallocAllocator,4096ul,4096ul,128ul>::~BumpPtrAllocatorImpl(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 24)) {
    __swift::__runtime::llvm::deallocate_buffer(**(__swift::__runtime::llvm ***)(a1 + 16), (void *)0x1000);
  }
  uint64_t v2 = *(void *)(a1 + 64);
  if (*(_DWORD *)(a1 + 72)) {
    __swift::__runtime::llvm::deallocate_buffer(*(__swift::__runtime::llvm **)v2, *(void **)(v2 + 8));
  }
  if (v2 != a1 + 80) {
    free(*(void **)(a1 + 64));
  }
  uint64_t v3 = *(void **)(a1 + 16);
  if (v3 != (void *)(a1 + 32)) {
    free(v3);
  }
  return a1;
}

void __swift::__runtime::llvm::SmallVectorTemplateBase<swift::AutoDiffLinearMapContext::AllocatedContextObjectRecord,false>::grow(uint64_t a1, unint64_t a2)
{
  unint64_t v14 = 0;
  uint64_t v3 = __swift::__runtime::llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, a2, 16, &v14);
  uint64_t v4 = v3;
  uint64_t v5 = *(void **)a1;
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  if (v6)
  {
    uint64_t v7 = 16 * v6;
    uint64_t v8 = v3;
    do
    {
      *v8++ = *(_OWORD *)v5;
      *uint64_t v5 = 0;
      v5[1] = 0;
      v5 += 2;
      v7 -= 16;
    }
    while (v7);
    uint64_t v5 = *(void **)a1;
    uint64_t v9 = *(unsigned int *)(a1 + 8);
    if (v9)
    {
      uint64_t v10 = 2 * v9;
      do
      {
        uint64_t v12 = v5[v10 - 2];
        if (v12 && v5[v10 - 1])
        {
          if (*(void *)(v12 - 8)) {
            uint64_t v11 = *(void *)(v12 - 8);
          }
          else {
            uint64_t v11 = 0;
          }
          (*(void (**)(void))(v11 + 8))();
        }
        v10 -= 2;
      }
      while (v10 * 8);
      uint64_t v5 = *(void **)a1;
    }
  }
  int v13 = v14;
  if (v5 != (void *)(a1 + 16)) {
    free(v5);
  }
  *(void *)a1 = v4;
  *(_DWORD *)(a1 + 12) = v13;
}

uint64_t __swift::__runtime::llvm::BumpPtrAllocatorImpl<__swift::__runtime::llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate(uint64_t *__sz, uint64_t a2, char a3)
{
  uint64_t v5 = (uint64_t)(__sz + 10);
  __sz[10] += a2;
  uint64_t v6 = (1 << a3) - 1;
  uint64_t v7 = *__sz;
  uint64_t v8 = -(1 << a3);
  uint64_t v9 = ((v6 + *__sz) & v8) - *__sz;
  if (v9 + a2 <= (unint64_t)(__sz[1] - *__sz))
  {
    uint64_t result = v7 + v9;
    *__sz = v7 + v9 + a2;
  }
  else
  {
    uint64_t v10 = a2 + (1 << a3);
    uint64_t v11 = v10 - 1;
    if ((unint64_t)(v10 - 1) <= 0x1000)
    {
      unsigned int v16 = *((_DWORD *)__sz + 6) >> 7;
      if (v16 >= 0x1E) {
        LOBYTE(v16) = 30;
      }
      uint64_t v17 = 4096 << v16;
      buffer = (char *)__swift::__runtime::llvm::allocate_buffer(4096 << v16, (std::align_val_t)8uLL);
      uint64_t v19 = *((unsigned int *)__sz + 6);
      if (v19 >= *((_DWORD *)__sz + 7))
      {
        __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(__sz + 2), (uint64_t)(__sz + 4), v19 + 1, 8);
        LODWORD(v19) = *((_DWORD *)__sz + 6);
      }
      *(void *)(__sz[2] + 8 * v19) = buffer;
      ++*((_DWORD *)__sz + 6);
      uint64_t result = (unint64_t)&buffer[v6] & v8;
      *__sz = result + a2;
      __sz[1] = (uint64_t)&buffer[v17];
    }
    else
    {
      uint64_t v12 = __swift::__runtime::llvm::allocate_buffer(v10 - 1, (std::align_val_t)8uLL);
      uint64_t v13 = *((unsigned int *)__sz + 18);
      if (v13 >= *((_DWORD *)__sz + 19))
      {
        __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(__sz + 8), v5, v13 + 1, 16);
        LODWORD(v13) = *((_DWORD *)__sz + 18);
      }
      unint64_t v14 = (void *)(__sz[8] + 16 * v13);
      void *v14 = v12;
      v14[1] = v11;
      ++*((_DWORD *)__sz + 18);
      return ((unint64_t)v12 + v6) & v8;
    }
  }
  return result;
}

uint64_t _swift_stdlib_isExecutableLinkedOnOrAfter(unsigned int a1)
{
  if (_swift_stdlib_isExecutableLinkedOnOrAfter::getenvToken != -1) {
    dispatch_once_f(&_swift_stdlib_isExecutableLinkedOnOrAfter::getenvToken, 0, (dispatch_function_t)swift::runtime::bincompat::checkBinCompatEnvironmentVariable);
  }
  if (swift::runtime::bincompat::binCompatVersionOverride) {
    return swift::runtime::bincompat::binCompatVersionOverride >= a1;
  }
  if (a1 != 329216 && a1 != 329472) {
    return 0;
  }

  return dyld_program_sdk_at_least();
}

void swift::runtime::bincompat::checkBinCompatEnvironmentVariable(swift::runtime::bincompat *this, void *a2, const char *a3, char *a4)
{
  if (swift::runtime::environment::initializeToken != -1) {
    dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
  }
  if (swift::runtime::environment::SWIFT_BINARY_COMPATIBILITY_VERSION_variable) {
    BOOL v4 = swift::runtime::environment::SWIFT_BINARY_COMPATIBILITY_VERSION_variable == 329216;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4 || swift::runtime::environment::SWIFT_BINARY_COMPATIBILITY_VERSION_variable == 329472) {
    swift::runtime::bincompat::binCompatVersionOverride = swift::runtime::environment::SWIFT_BINARY_COMPATIBILITY_VERSION_variable;
  }
  else {
    swift::warning(0, "Warning: ignoring unknown SWIFT_BINARY_COMPATIBILITY_VERSION %x.\n", a3, a4, swift::runtime::environment::SWIFT_BINARY_COMPATIBILITY_VERSION_variable);
  }
}

uint64_t swift::runtime::bincompat::useLegacyProtocolConformanceReverseIteration(swift::runtime::bincompat *this)
{
  return dyld_program_sdk_at_least() ^ 1;
}

uint64_t swift::runtime::bincompat::useLegacyObjCBoxingInCasting(swift::runtime::bincompat *this)
{
  return dyld_program_sdk_at_least() ^ 1;
}

uint64_t swift::runtime::bincompat::useLegacySwiftObjCHashing(swift::runtime::bincompat *this)
{
  return dyld_program_sdk_at_least() ^ 1;
}

uint64_t swift_bincompat_useLegacyNonCrashingExecutorChecks()
{
  return dyld_program_sdk_at_least() ^ 1;
}

void swift_generic_destroy(uint64_t a1, uint64_t a2)
{
  __asm { BRAA            X9, X17 }
}

uint64_t sub_181533A88()
{
  uint64_t v4 = *(void *)(v0 + v3);
  if ((v4 & 0x8000000000000000) == 0) {
    swift_errorRelease((id)(v4 & 0xFFFFFFFFFFFFFF8));
  }
  return (*(uint64_t (**)(void))(v1 + 8 * HIBYTE(*v2)))();
}

uint64_t sub_181533AB8()
{
  uint64_t v4 = swift_release(*(void *)(v0 + v3) & 0xFFFFFFFFFFFFFF8);
  return (*(uint64_t (**)(uint64_t))(v1 + 8 * HIBYTE(*v2)))(v4);
}

uint64_t sub_181533AE4()
{
  swift_unownedRelease((atomic_ullong *)(*(void *)(v0 + v3) & 0xFFFFFFFFFFFFFF8));
  return (*(uint64_t (**)(void))(v1 + 8 * HIBYTE(*v2)))();
}

uint64_t sub_181533B10()
{
  swift_weakDestroy((uint64_t *)(v0 + v3));
  return (*(uint64_t (**)(void))(v1 + 8 * HIBYTE(*v2)))();
}

uint64_t sub_181533B38()
{
  swift_unknownObjectRelease(*(id *)(v0 + v3));
  return (*(uint64_t (**)(void))(v1 + 8 * HIBYTE(*v2)))();
}

uint64_t sub_181533B60()
{
  swift_unknownObjectUnownedDestroy((atomic_ullong **)(v0 + v3));
  return (*(uint64_t (**)(void))(v1 + 8 * HIBYTE(*v2)))();
}

uint64_t sub_181533B88()
{
  swift_unknownObjectWeakDestroy((id *)(v0 + v3));
  return (*(uint64_t (**)(void))(v1 + 8 * HIBYTE(*v2)))();
}

uint64_t sub_181533BB0()
{
  swift_bridgeObjectRelease(*(void *)(v0 + v3));
  return (*(uint64_t (**)(void))(v1 + 8 * HIBYTE(*v2)))();
}

uint64_t sub_181533BD8()
{
  _Block_release((const void *)(v0 + v3));
  return (*(uint64_t (**)(void))(v1 + 8 * HIBYTE(*v2)))();
}

uint64_t sub_181533C00()
{
  uint64_t v4 = *(void *)(v0 + v3);
  if ((v4 & 0x8000000000000000) == 0) {

  }
  return (*(uint64_t (**)(void))(v1 + 8 * HIBYTE(*v2)))();
}

uint64_t sub_181533C30()
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)(*v2 - 8) + 8))(v0 + v3);
  return (*(uint64_t (**)(uint64_t))(v1 + 8 * HIBYTE(v2[1])))(v4);
}

uint64_t sub_181533C8C()
{
  uint64_t v4 = *(void *)(v0 + v3 + 24);
  uint64_t v5 = *(void *)(v4 - 8);
  if (v5)
  {
    uint64_t v6 = *(void *)(v4 - 8);
    if ((*(unsigned char *)(v5 + 82) & 2) == 0)
    {
LABEL_3:
      uint64_t v7 = (*(uint64_t (**)(void))(v6 + 8))();
      return (*(uint64_t (**)(uint64_t))(v1 + 8 * HIBYTE(*v2)))(v7);
    }
  }
  else
  {
    uint64_t v6 = 0;
    if ((MEMORY[0x52] & 2) == 0) {
      goto LABEL_3;
    }
  }
  uint64_t v9 = swift_release(*(void *)(v0 + v3));
  return (*(uint64_t (**)(uint64_t))(v1 + 8 * HIBYTE(*v2)))(v9);
}

uint64_t sub_181533D30()
{
  uint64_t v5 = (uint64_t (*)(unint64_t *))((char *)v3 + *v3);
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(v0);
  uint64_t v7 = v5(GenericArgs);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v7 - 8) + 8))(v1 + v4, v7);
  return (*(uint64_t (**)(uint64_t))(v2 + 8 * HIBYTE(*((void *)v3 + 1))))(v8);
}

uint64_t sub_181533DA8@<X0>(uint64_t a1@<X8>, void *a2, uint64_t a3)
{
  a2 = v6;
  a3 = v7;
  uint64_t v8 = ((uint64_t (*)(uint64_t, void **, uint64_t *, uint64_t))destroyTable[a1])(v3, &a2, &a3, v4);
  return (*(uint64_t (**)(uint64_t))(v5 + 8 * HIBYTE(*a2)))(v8);
}

void swift::swift_generic_arrayDestroy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!*(void *)(a4 - 16))
  {
    uint64_t v4 = 0;
    if (!a2) {
      return;
    }
LABEL_5:
    __asm { BRAA            X9, X17 }
  }
  uint64_t v4 = *(void *)(a4 - 16);
  if (a2) {
    goto LABEL_5;
  }
}

void swift_generic_initWithCopy(void *__dst, void *__src, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a3 - 16) + 16);
  if ((v3 & 0xFFFFFFFFFFFFFFLL) != 0)
  {
    memcpy(__dst, __src, v3 & 0xFFFFFFFFFFFFFFLL);
    __asm { BRAA            X9, X17 }
  }
  __asm { BRAA            X9, X17 }
}

uint64_t sub_1815342E8(id a1)
{
  uint64_t v6 = *(void *)(v2 + v3);
  if ((v6 & 0x8000000000000000) == 0)
  {
    *(void *)(v1 + v3) = v6;
    v3 += 8;
    a1 = swift_errorRetain((id)(v6 & 0xFFFFFFFFFFFFFF8));
  }
  unint64_t v7 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3), (const void *)(v2 + v3), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(id))(v4 + 8 * HIBYTE(v7)))(a1);
}

uint64_t sub_181534330()
{
  uint64_t v5 = *(void *)(v1 + v2);
  *(void *)(v0 + v2) = v5;
  uint64_t v6 = swift_retain((atomic_ullong *)(v5 & 0xFFFFFFFFFFFFFF8));
  unint64_t v7 = *v4;
  if ((*v4 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v6 = memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v4 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v3 + 8 * HIBYTE(v7)))(v6);
}

uint64_t sub_181534374(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v9 = *(void *)(v5 + v6);
  *(void *)(v4 + v6) = v9;
  uint64_t v10 = swift_unownedRetain(v9 & 0xFFFFFFFFFFFFFF8, a2, a3, a4);
  unint64_t v11 = *v8;
  if ((*v8 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v10 = (uint64_t)memcpy((void *)(v4 + v6 + 8), (const void *)(v5 + v6 + 8), *v8 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(uint64_t))(v7 + 8 * HIBYTE(v11)))(v10);
}

uint64_t sub_1815343B8()
{
  uint64_t v5 = swift_weakCopyInit((swift *)(v0 + v2), (void *)(v1 + v2));
  unint64_t v6 = *v4;
  if ((*v4 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v5 = memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v4 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v3 + 8 * HIBYTE(v6)))(v5);
}

uint64_t sub_1815343F8()
{
  uint64_t v5 = *(void **)(v1 + v2);
  *(void *)(v0 + v2) = v5;
  id v6 = swift_unknownObjectRetain(v5);
  unint64_t v7 = *v4;
  if ((*v4 & 0xFFFFFFFFFFFFFFLL) != 0) {
    id v6 = memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v4 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(id))(v3 + 8 * HIBYTE(v7)))(v6);
}

uint64_t sub_181534438(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v9 = swift_unknownObjectUnownedCopyInit((void *)(v4 + v6), (uint64_t *)(v5 + v6), a3, a4);
  unint64_t v10 = *v8;
  if ((*v8 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v9 = memcpy((void *)(v4 + v6 + 8), (const void *)(v5 + v6 + 8), *v8 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v7 + 8 * HIBYTE(v10)))(v9);
}

uint64_t sub_181534478()
{
  uint64_t v5 = swift_unknownObjectWeakCopyInit((id *)(v0 + v2), (id *)(v1 + v2));
  unint64_t v6 = *v4;
  if ((*v4 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v5 = memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v4 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v3 + 8 * HIBYTE(v6)))(v5);
}

uint64_t sub_1815344B8()
{
  unint64_t v5 = *(void *)(v1 + v2);
  *(void *)(v0 + v2) = v5;
  unint64_t v6 = swift_bridgeObjectRetain(v5);
  unint64_t v7 = *v4;
  if ((*v4 & 0xFFFFFFFFFFFFFFLL) != 0) {
    unint64_t v6 = (unint64_t)memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v4 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(unint64_t))(v3 + 8 * HIBYTE(v7)))(v6);
}

uint64_t sub_1815344F8()
{
  unint64_t v5 = _Block_copy(*(const void **)(v1 + v2));
  *(void *)(v0 + v2) = v5;
  unint64_t v6 = *v4;
  if ((*v4 & 0xFFFFFFFFFFFFFFLL) != 0) {
    unint64_t v5 = memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v4 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v3 + 8 * HIBYTE(v6)))(v5);
}

uint64_t sub_181534538(id a1)
{
  uint64_t v6 = *(void *)(v2 + v3);
  *(void *)(v1 + v3) = v6;
  if ((v6 & 0x8000000000000000) == 0) {
    a1 = (id)(v6 & 0xFFFFFFFFFFFFFF8);
  }
  unint64_t v7 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(id))(v4 + 8 * HIBYTE(v7)))(a1);
}

uint64_t sub_181534580()
{
  uint64_t v5 = *(void *)(*v4 - 8);
  uint64_t v6 = *(void *)(v5 + 64) + v2;
  unint64_t v7 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v5 + 16))(v0 + v2, v1 + v2);
  unint64_t v8 = v4[1];
  if ((v8 & 0xFFFFFFFFFFFFFFLL) != 0) {
    unint64_t v7 = memcpy((void *)(v0 + v6), (const void *)(v1 + v6), v8 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v3 + 8 * HIBYTE(v8)))(v7);
}

uint64_t sub_1815345F4()
{
  uint64_t v5 = 0;
  if (*(void *)(*(void *)(v1 + v2 + 24) - 8)) {
    uint64_t v5 = *(uint64_t (***)(uint64_t))(*(void *)(v1 + v2 + 24) - 8);
  }
  uint64_t v6 = (void *)(*v5)(v0 + v2);
  unint64_t v7 = *v4;
  if ((*v4 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v6 = memcpy((void *)(v0 + v2 + 24), (const void *)(v1 + v2 + 24), *v4 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v3 + 8 * HIBYTE(v7)))(v6);
}

uint64_t sub_181534678()
{
  uint64_t v6 = (uint64_t (*)(unint64_t *))((char *)v5 + *v5);
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(v0);
  uint64_t v8 = *(void *)(v6(GenericArgs) - 8);
  uint64_t v9 = *(void *)(v8 + 64) + v3;
  unint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v8 + 16))(v1 + v3, v2 + v3);
  unint64_t v11 = *((void *)v5 + 1);
  if ((v11 & 0xFFFFFFFFFFFFFFLL) != 0) {
    unint64_t v10 = memcpy((void *)(v1 + v9), (const void *)(v2 + v9), v11 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v11)))(v10);
}

uint64_t sub_181534708@<X0>(uint64_t a1@<X8>, unint64_t *a2, uint64_t a3)
{
  a2 = v8;
  a3 = v6;
  uint64_t v9 = (void *)((uint64_t (*)(uint64_t, unint64_t **, uint64_t *, uint64_t, uint64_t))initWithCopyTable[a1])(v3, &a2, &a3, v4, v5);
  unint64_t v10 = *a2;
  if ((*a2 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v9 = memcpy((void *)(v4 + a3), (const void *)(v5 + a3), *a2 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v7 + 8 * HIBYTE(v10)))(v9);
}

uint64_t sub_181534764()
{
  return v0;
}

void *swift::swift_generic_arrayInitWithCopy(void *result, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!*(void *)(a5 - 16))
  {
    uint64_t v6 = 0;
    if (!a3) {
      return result;
    }
LABEL_5:
    uint64_t v5 = *(void *)(v6 + 16);
    if ((v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
      memcpy(result, a2, v5 & 0xFFFFFFFFFFFFFFLL);
    }
    __asm { BRAA            X9, X17 }
  }
  uint64_t v6 = *(void *)(a5 - 16);
  if (a3) {
    goto LABEL_5;
  }
  return result;
}

void *swift_generic_initWithTake(void *__dst, void *__src, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 - 8);
  if ((*(unsigned char *)(v4 + 82) & 0x10) != 0)
  {
    unint64_t v6 = *(void *)(*(void *)(a3 - 16) + 16);
    if ((v6 & 0xFFFFFFFFFFFFFFLL) != 0) {
      memcpy(__dst, __src, v6 & 0xFFFFFFFFFFFFFFLL);
    }
    switch(HIBYTE(v6))
    {
      case 0u:
        return __dst;
    }
  }
  else
  {
    memcpy(__dst, __src, *(void *)(v4 + 64));
  }
  return __dst;
}

uint64_t sub_181534E1C(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181534E60(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181534EA4(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181534EE8(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181534F2C(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181534F70(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181534FB4()
{
  uint64_t v5 = swift_unknownObjectWeakTakeInit((id *)(v0 + v2), (id *)(v1 + v2));
  unint64_t v6 = *v4;
  if ((*v4 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v5 = memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v4 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v3 + 8 * HIBYTE(v6)))(v5);
}

uint64_t sub_181535000(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181535044(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_181535088(void *a1)
{
  *(void *)(v1 + v3) = *(void *)(v2 + v3);
  unint64_t v6 = *v5;
  if ((*v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v5 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(a1);
}

uint64_t sub_1815350CC()
{
  uint64_t v5 = *(void *)(*v4 - 8);
  uint64_t v6 = *(void *)(v5 + 64) + v2;
  uint64_t v7 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v5 + 32))(v0 + v2, v1 + v2);
  unint64_t v8 = v4[1];
  if ((v8 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v7 = memcpy((void *)(v0 + v6), (const void *)(v1 + v6), v8 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v3 + 8 * HIBYTE(v8)))(v7);
}

uint64_t sub_181535148(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  unsigned int v16 = existentialInitWithTake(a1, a2, &a11, v12, v13);
  unint64_t v17 = *v15;
  a12 = v15 + 1;
  uint64_t v18 = a11;
  size_t v19 = v17 & 0xFFFFFFFFFFFFFFLL;
  if ((v17 & 0xFFFFFFFFFFFFFFLL) != 0) {
    unsigned int v16 = memcpy((void *)(v12 + a11), (const void *)(v13 + a11), v19);
  }
  a11 = v18 + v19;
  return (*(uint64_t (**)(void *))(v14 + 8 * HIBYTE(v17)))(v16);
}

uint64_t sub_181535194(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int *a12)
{
  uint64_t v16 = resilientInitWithTake(v14, &a12, &a11, v12, v13);
  uint64_t v17 = a11;
  unint64_t v18 = *(void *)a12;
  a12 += 2;
  if ((v18 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v16 = (uint64_t)memcpy((void *)(v12 + a11), (const void *)(v13 + a11), v18 & 0xFFFFFFFFFFFFFFLL);
  }
  a11 = v17 + (v18 & 0xFFFFFFFFFFFFFFLL);
  return (*(uint64_t (**)(uint64_t))(v15 + 8 * HIBYTE(v18)))(v16);
}

uint64_t sub_1815351E8@<X0>(uint64_t a1@<X8>, unint64_t *a2, uint64_t a3, uint64_t a4, void *a5)
{
  a2 = v10;
  a3 = v8;
  unint64_t v11 = (void *)((uint64_t (*)(uint64_t, unint64_t **, uint64_t *, uint64_t, uint64_t))initWithTakeTable[a1])(v7, &a2, &a3, v5, v6);
  uint64_t v12 = a3;
  unint64_t v13 = *a2;
  a5 = a2 + 1;
  if ((v13 & 0xFFFFFFFFFFFFFFLL) != 0) {
    unint64_t v11 = memcpy((void *)(v5 + a3), (const void *)(v6 + a3), v13 & 0xFFFFFFFFFFFFFFLL);
  }
  a4 = (v13 & 0xFFFFFFFFFFFFFFLL) + v12;
  return (*(uint64_t (**)(void *))(v9 + 8 * HIBYTE(v13)))(v11);
}

void swift_generic_assignWithCopy(void *__dst, void *__src, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a3 - 16) + 16);
  if ((v3 & 0xFFFFFFFFFFFFFFLL) != 0) {
    memcpy(__dst, __src, v3 & 0xFFFFFFFFFFFFFFLL);
  }
  __asm { BRAA            X9, X17 }
}

uint64_t sub_1815352F4(id a1)
{
  uint64_t v6 = *(void *)(v1 + v3);
  uint64_t v7 = *(void *)(v2 + v3);
  *(void *)(v1 + v3) = v7;
  if ((v6 & 0x8000000000000000) == 0) {
    swift_errorRelease((id)(v6 & 0xFFFFFFFFFFFFFF8));
  }
  if ((v7 & 0x8000000000000000) == 0) {
    a1 = swift_errorRetain((id)(v7 & 0xFFFFFFFFFFFFFF8));
  }
  unint64_t v8 = *v4;
  if ((*v4 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v4 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(id))(v5 + 8 * HIBYTE(v8)))(a1);
}

uint64_t sub_181535354()
{
  uint64_t v5 = *(void *)(v0 + v2);
  uint64_t v6 = *(void *)(v1 + v2);
  *(void *)(v0 + v2) = v6;
  uint64_t v7 = (atomic_ullong *)(v6 & 0xFFFFFFFFFFFFFF8);
  swift_release(v5 & 0xFFFFFFFFFFFFFF8);
  unint64_t v8 = swift_retain(v7);
  unint64_t v9 = *v3;
  if ((*v3 & 0xFFFFFFFFFFFFFFLL) != 0) {
    unint64_t v8 = memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v3 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v9)))(v8);
}

uint64_t sub_1815353B0()
{
  uint64_t v5 = *(void *)(v0 + v2);
  uint64_t v6 = *(void *)(v1 + v2);
  *(void *)(v0 + v2) = v6;
  uint64_t v7 = v6 & 0xFFFFFFFFFFFFFF8;
  swift_unownedRelease((atomic_ullong *)(v5 & 0xFFFFFFFFFFFFFF8));
  uint64_t v11 = swift_unownedRetain(v7, v8, v9, v10);
  unint64_t v12 = *v3;
  if ((*v3 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v11 = (uint64_t)memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v3 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(uint64_t))(v4 + 8 * HIBYTE(v12)))(v11);
}

uint64_t sub_18153540C()
{
  uint64_t v5 = swift_weakCopyAssign((uint64_t *)(v0 + v2), (uint64_t *)(v1 + v2));
  unint64_t v6 = *v3;
  if ((*v3 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v5 = memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v3 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(v5);
}

uint64_t sub_181535454()
{
  uint64_t v5 = *(void **)(v0 + v2);
  unint64_t v6 = *(void **)(v1 + v2);
  *(void *)(v0 + v2) = v6;
  swift_unknownObjectRelease(v5);
  id v7 = swift_unknownObjectRetain(v6);
  unint64_t v8 = *v3;
  if ((*v3 & 0xFFFFFFFFFFFFFFLL) != 0) {
    id v7 = memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v3 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(id))(v4 + 8 * HIBYTE(v8)))(v7);
}

uint64_t sub_1815354A8(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  unint64_t v9 = swift_unknownObjectUnownedCopyAssign((atomic_ullong **)(v4 + v6), (uint64_t *)(v5 + v6), a3, a4);
  unint64_t v10 = *v7;
  if ((*v7 & 0xFFFFFFFFFFFFFFLL) != 0) {
    unint64_t v9 = memcpy((void *)(v4 + v6 + 8), (const void *)(v5 + v6 + 8), *v7 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v8 + 8 * HIBYTE(v10)))(v9);
}

uint64_t sub_1815354F0()
{
  uint64_t v5 = swift_unknownObjectWeakCopyAssign((id *)(v0 + v2), (id *)(v1 + v2));
  unint64_t v6 = *v3;
  if ((*v3 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v5 = memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v3 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(v5);
}

uint64_t sub_181535538()
{
  uint64_t v5 = *(void *)(v0 + v2);
  unint64_t v6 = *(void *)(v1 + v2);
  *(void *)(v0 + v2) = v6;
  swift_bridgeObjectRelease(v5);
  unint64_t v7 = swift_bridgeObjectRetain(v6);
  unint64_t v8 = *v3;
  if ((*v3 & 0xFFFFFFFFFFFFFFLL) != 0) {
    unint64_t v7 = (unint64_t)memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v3 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(unint64_t))(v4 + 8 * HIBYTE(v8)))(v7);
}

uint64_t sub_18153558C()
{
  _Block_release(*(const void **)(v0 + v2));
  uint64_t v5 = _Block_copy(*(const void **)(v1 + v2));
  *(void *)(v0 + v2) = v5;
  unint64_t v6 = *v3;
  if ((*v3 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v5 = memcpy((void *)(v0 + v2 + 8), (const void *)(v1 + v2 + 8), *v3 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v6)))(v5);
}

uint64_t sub_1815355DC(id a1)
{
  uint64_t v6 = *(void *)(v1 + v3);
  uint64_t v7 = *(void *)(v2 + v3);
  *(void *)(v1 + v3) = v7;
  if ((v6 & 0x8000000000000000) == 0) {

  }
  if ((v7 & 0x8000000000000000) == 0) {
    a1 = (id)(v7 & 0xFFFFFFFFFFFFFF8);
  }
  unint64_t v8 = *v4;
  if ((*v4 & 0xFFFFFFFFFFFFFFLL) != 0) {
    a1 = memcpy((void *)(v1 + v3 + 8), (const void *)(v2 + v3 + 8), *v4 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(id))(v5 + 8 * HIBYTE(v8)))(a1);
}

uint64_t sub_18153563C()
{
  uint64_t v5 = *(void *)(*v3 - 8);
  uint64_t v6 = *(void *)(v5 + 64) + v2;
  uint64_t v7 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v5 + 24))(v0 + v2, v1 + v2);
  unint64_t v8 = v3[1];
  if ((v8 & 0xFFFFFFFFFFFFFFLL) != 0) {
    uint64_t v7 = memcpy((void *)(v0 + v6), (const void *)(v1 + v6), v8 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v4 + 8 * HIBYTE(v8)))(v7);
}

uint64_t sub_1815356B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, size_t a12)
{
  uint64_t v16 = existentialAssignWithCopy(a1, a2, &a12, v12, v13);
  unint64_t v17 = *v14;
  size_t v18 = a12;
  size_t v19 = *v14 & 0xFFFFFFFFFFFFFFLL;
  if (v19) {
    uint64_t v16 = memcpy((void *)(v12 + a12), (const void *)(v13 + a12), v19);
  }
  a12 = v18 + v19;
  return (*(uint64_t (**)(void *))(v15 + 8 * HIBYTE(v17)))(v16);
}

uint64_t sub_1815356FC()
{
  uint64_t v6 = (uint64_t (*)(unint64_t *))((char *)v4 + *v4);
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(v0);
  uint64_t v8 = *(void *)(v6(GenericArgs) - 8);
  uint64_t v9 = *(void *)(v8 + 64) + v3;
  unint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(v8 + 24))(v1 + v3, v2 + v3);
  unint64_t v11 = *((void *)v4 + 1);
  if ((v11 & 0xFFFFFFFFFFFFFFLL) != 0) {
    unint64_t v10 = memcpy((void *)(v1 + v9), (const void *)(v2 + v9), v11 & 0xFFFFFFFFFFFFFFLL);
  }
  return (*(uint64_t (**)(void *))(v5 + 8 * HIBYTE(v11)))(v10);
}

uint64_t sub_181535790@<X0>(uint64_t a1@<X8>, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  a3 = v9;
  a4 = v8;
  unint64_t v11 = (void *)((uint64_t (*)(uint64_t, unint64_t **, uint64_t *, uint64_t, uint64_t))assignWithCopyTable[a1])(v5, &a3, &a4, v6, v7);
  uint64_t v12 = a4;
  unint64_t v13 = *a3;
  uint64_t v14 = *a3 & 0xFFFFFFFFFFFFFFLL;
  if (v14) {
    unint64_t v11 = memcpy((void *)(v6 + a4), (const void *)(v7 + a4), *a3 & 0xFFFFFFFFFFFFFFLL);
  }
  a5 = v14 + v12;
  return (*(uint64_t (**)(void *))(v10 + 8 * HIBYTE(v13)))(v11);
}

uint64_t sub_1815357F0()
{
  return v0;
}

void *swift_generic_arrayAssignWithCopy(void *result, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!*(void *)(a5 - 16))
  {
    uint64_t v6 = 0;
    if (!a3) {
      return result;
    }
LABEL_5:
    uint64_t v5 = *(void *)(v6 + 16);
    if ((v5 & 0xFFFFFFFFFFFFFFLL) != 0) {
      memcpy(result, a2, v5 & 0xFFFFFFFFFFFFFFLL);
    }
    __asm { BRAA            X9, X17 }
  }
  uint64_t v6 = *(void *)(a5 - 16);
  if (a3) {
    goto LABEL_5;
  }
  return result;
}

void *swift_generic_assignWithTake(void *a1, void *a2, uint64_t a3)
{
  swift_generic_destroy((uint64_t)a1, a3);

  return swift_generic_initWithTake(a1, a2, a3);
}

uint64_t swift_singletonEnum_getEnumTag()
{
  return 0;
}

uint64_t swift_enumSimple_getEnumTag(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a2 - 16);
  v16[0] = &unk_1ECA03F90;
  v16[1] = a1;
  v16[3] = v16;
  v15[0] = &unk_1ECA03FD8;
  v15[1] = a1;
  v15[3] = v15;
  unint64_t v3 = v2[3];
  unint64_t v4 = v2[4];
  uint64_t v5 = v2[5];
  unint64_t v6 = v2[6];
  if (!(v3 >> 62)) {
    goto LABEL_13;
  }
  int v7 = (1 << ((v3 >> 62) - 1));
  if (v7 == 4)
  {
    int v8 = *(_DWORD *)&a1[v4];
    if (v8) {
      goto LABEL_8;
    }
LABEL_13:
    uint64_t v11 = (v3 >> 59) & 7;
    if (!v11) {
      return 0;
    }
    switch((1 << (v11 - 1)))
    {
      case 1u:
        uint64_t v12 = a1[v3];
        goto LABEL_19;
      case 2u:
        uint64_t v12 = *(unsigned __int16 *)&a1[v3];
        goto LABEL_19;
      case 4u:
        uint64_t v12 = *(unsigned int *)&a1[v3];
        goto LABEL_19;
      case 8u:
        uint64_t v12 = *(void *)&a1[v3];
LABEL_19:
        unint64_t v13 = v12 - v5;
        if (v13 >= v6) {
          return 0;
        }
        uint64_t result = (v13 + 1);
        break;
      default:
        goto LABEL_27;
    }
    return result;
  }
  if (v7 == 2)
  {
    int v8 = *(unsigned __int16 *)&a1[v4];
    if (*(_WORD *)&a1[v4]) {
      goto LABEL_8;
    }
    goto LABEL_13;
  }
  if (v7 != 1) {
LABEL_27:
  }
    abort();
  int v8 = a1[v4];
  if (!a1[v4]) {
    goto LABEL_13;
  }
LABEL_8:
  unint64_t v9 = (unint64_t)(v8 - 1) << (8 * v4);
  if (v4 > 3) {
    LODWORD(v9) = 0;
  }
  int v10 = 0;
  switch(v4)
  {
    case 0uLL:
      return v6 + (v10 | v9) + 1;
    case 1uLL:
      int v10 = *a1;
      break;
    case 2uLL:
      int v10 = *(unsigned __int16 *)a1;
      break;
    case 3uLL:
      int v10 = *(unsigned __int16 *)a1 | (a1[2] << 16);
      break;
    default:
      int v10 = *(_DWORD *)a1;
      break;
  }
  return v6 + (v10 | v9) + 1;
}

uint64_t swift_enumSimple_destructiveInjectEnumTag(unsigned char *a1, unsigned int a2, uint64_t a3)
{
  unint64_t v4 = *(void **)(a3 - 16);
  v26[0] = &unk_1ECA04020;
  v26[1] = a1;
  v26[2] = a2;
  unint64_t v27 = v26;
  unint64_t v22 = (void (**)(void **))&unk_1ECA04068;
  uint64_t v23 = a1;
  uint64_t v24 = a2;
  unint64_t v25 = (void **)&v22;
  unint64_t v5 = v4[3];
  unsigned int v6 = (v5 >> 62) - 1;
  int v7 = 1 << ((v5 >> 62) - 1);
  unint64_t v8 = v4[4];
  unint64_t v9 = v4[6];
  if (v5 >> 62) {
    BOOL v10 = v9 >= a2;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    uint64_t v11 = (v5 >> 59) & 7;
    if (v11 && v9 >= a2)
    {
      uint64_t v12 = v4[5];
      if (v6 <= 7)
      {
        unint64_t v13 = &a1[v8];
        switch((1 << ((v5 >> 62) - 1)))
        {
          case 1u:
            *unint64_t v13 = 0;
            break;
          case 2u:
            *(_WORD *)unint64_t v13 = 0;
            break;
          case 3u:
            v13[2] = 0;
            *(_WORD *)unint64_t v13 = 0;
            break;
          case 4u:
            *(_DWORD *)unint64_t v13 = 0;
            break;
          default:
            *(_DWORD *)unint64_t v13 = 0;
            bzero(v13 + 4, (1 << ((v5 >> 62) - 1)) - 4);
            break;
        }
        a2 = v24;
      }
      if (a2)
      {
        size_t v19 = &v23[v5];
        int v20 = v12 + a2 - 1;
        switch(1 << (v11 - 1))
        {
          case 1:
            *size_t v19 = v20;
            break;
          case 2:
            *(_WORD *)size_t v19 = v20;
            break;
          case 3:
            *(_WORD *)size_t v19 = v20;
            v19[2] = BYTE2(v20);
            break;
          case 4:
            *(_DWORD *)size_t v19 = v20;
            break;
          default:
            *(_DWORD *)size_t v19 = v20;
            unint64_t v17 = v19 + 4;
            size_t v18 = (1 << (v11 - 1)) - 4;
LABEL_44:
            bzero(v17, v18);
            break;
        }
      }
    }
  }
  else
  {
    unsigned int v14 = ~v9 + a2;
    if (v8 > 3)
    {
      int v15 = 1;
      goto LABEL_15;
    }
    int v15 = (v14 >> (8 * v8)) + 1;
    if (v8)
    {
      v14 &= ~(-1 << (8 * v8));
LABEL_15:
      switch(v8)
      {
        case 1uLL:
          *a1 = v14;
          if (v6 <= 7) {
            goto LABEL_24;
          }
          break;
        case 2uLL:
          *(_WORD *)a1 = v14;
          if (v6 <= 7) {
            goto LABEL_24;
          }
          break;
        case 3uLL:
          *(_WORD *)a1 = v14;
          a1[2] = BYTE2(v14);
          goto LABEL_23;
        case 4uLL:
          *(_DWORD *)a1 = v14;
          if (v6 <= 7) {
            goto LABEL_24;
          }
          break;
        default:
          *(_DWORD *)a1 = v14;
          bzero(a1 + 4, v8 - 4);
          if (v6 <= 7) {
            goto LABEL_24;
          }
          break;
      }
      goto LABEL_45;
    }
LABEL_23:
    if (v6 <= 7)
    {
LABEL_24:
      uint64_t v16 = &a1[v8];
      switch((char)v7)
      {
        case 1:
          unsigned char *v16 = v15;
          break;
        case 2:
          *(_WORD *)uint64_t v16 = v15;
          break;
        case 3:
          *(_WORD *)uint64_t v16 = v15;
          v16[2] = BYTE2(v15);
          break;
        case 4:
          *(_DWORD *)uint64_t v16 = v15;
          break;
        default:
          *(_DWORD *)uint64_t v16 = v15;
          unint64_t v17 = v16 + 4;
          size_t v18 = v7 - 4;
          goto LABEL_44;
      }
    }
  }
LABEL_45:
  if (v25 == (void **)&v22)
  {
    v22[4]((void **)&v22);
  }
  else if (v25)
  {
    (*((void (**)(void))*v25 + 5))();
  }
  uint64_t result = (uint64_t)v27;
  if (v27 == v26) {
    return (*(uint64_t (**)(void *))(v26[0] + 32))(v26);
  }
  if (v27) {
    return (*(uint64_t (**)(void))(*v27 + 40))();
  }
  return result;
}

uint64_t swift_enumFn_getEnumTag(uint64_t a1, uint64_t a2)
{
  return ((uint64_t (*)(void))(*(void *)(a2 - 16) + 24 + *(int *)(*(void *)(a2 - 16) + 24)))();
}

unint64_t swift_multiPayloadEnumGeneric_getEnumTag(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a2 - 16);
  unint64_t v3 = v2[4];
  unint64_t v5 = v2[6] - v2[3];
  switch(v2[3])
  {
    case 1u:
      unint64_t result = a1[v5];
      if (v3 > a1[v5]) {
        return result;
      }
      goto LABEL_9;
    case 2u:
      unint64_t result = *(unsigned __int16 *)&a1[v5];
      if (v3 <= *(unsigned __int16 *)&a1[v5]) {
        goto LABEL_9;
      }
      return result;
    case 4u:
      unint64_t result = *(unsigned int *)&a1[v5];
      if (v3 <= result) {
        goto LABEL_9;
      }
      return result;
    case 8u:
      unint64_t result = *(void *)&a1[v5];
      if (v3 > result) {
        return result;
      }
LABEL_9:
      unint64_t v7 = v5;
      switch(v5)
      {
        case 0uLL:
          goto LABEL_13;
        case 1uLL:
          unint64_t v7 = *a1;
          goto LABEL_13;
        case 2uLL:
          unint64_t v7 = *(unsigned __int16 *)a1;
          goto LABEL_13;
        case 3uLL:
          unint64_t v7 = *(unsigned __int16 *)a1 | ((unint64_t)a1[2] << 16);
LABEL_13:
          unint64_t result = (v7 | ((result - v3) << (8 * v5))) + v3;
          break;
        default:
          unint64_t result = v3 + *(unsigned int *)a1;
          break;
      }
      return result;
    default:
      abort();
  }
}

void swift_multiPayloadEnumGeneric_destructiveInjectEnumTag(unsigned char *a1, size_t a2, uint64_t a3)
{
  unint64_t v4 = *(void **)(a3 - 16);
  uint64_t v5 = v4[3];
  unint64_t v6 = v4[4];
  size_t v7 = v4[6];
  unint64_t v8 = v7 - v5;
  if (v6 <= a2)
  {
    if (v8 <= 3) {
      int v10 = ((a2 - v6) >> (8 * v8)) + v6;
    }
    else {
      int v10 = v6;
    }
    if (v8 <= 3) {
      int v11 = (a2 - v6) & ~(-1 << (8 * v8));
    }
    else {
      int v11 = a2 - v6;
    }
    uint64_t v12 = &a1[v8];
    switch(v5)
    {
      case 0:
        goto LABEL_22;
      case 1:
        unsigned char *v12 = v10;
        a2 = v8 - 4;
        if (v8 > 4) {
          goto LABEL_25;
        }
        goto LABEL_22;
      case 2:
        *(_WORD *)uint64_t v12 = v10;
        a2 = v8 - 4;
        if (v8 > 4) {
          goto LABEL_25;
        }
        goto LABEL_22;
      case 3:
        *(_WORD *)uint64_t v12 = v10;
        _OWORD v12[2] = BYTE2(v10);
        goto LABEL_22;
      case 4:
        *(_DWORD *)uint64_t v12 = v10;
        a2 = v8 - 4;
        if (v8 > 4) {
          goto LABEL_25;
        }
        goto LABEL_22;
      default:
        *(_DWORD *)uint64_t v12 = v10;
        bzero(v12 + 4, a2);
        a2 = v8 - 4;
        if (v8 <= 4)
        {
LABEL_22:
          switch(v8)
          {
            case 0uLL:
              return;
            case 1uLL:
              *a1 = v11;
              break;
            case 2uLL:
              *(_WORD *)a1 = v11;
              break;
            case 3uLL:
              *(_WORD *)a1 = v11;
              a1[2] = BYTE2(v11);
              break;
            case 4uLL:
              *(_DWORD *)a1 = v11;
              break;
            default:
              goto LABEL_25;
          }
        }
        else
        {
LABEL_25:
          *(_DWORD *)a1 = v11;
          unint64_t v13 = a1 + 4;
LABEL_26:
          bzero(v13, a2);
        }
        break;
    }
  }
  else
  {
    unint64_t v9 = &a1[v8];
    switch(v5)
    {
      case 0:
        return;
      case 1:
        *unint64_t v9 = a2;
        break;
      case 2:
        *(_WORD *)unint64_t v9 = a2;
        break;
      case 3:
        *(_WORD *)unint64_t v9 = a2;
        v9[2] = BYTE2(a2);
        break;
      case 4:
        *(_DWORD *)unint64_t v9 = a2;
        break;
      default:
        *(_DWORD *)unint64_t v9 = a2;
        unint64_t v13 = v9 + 4;
        a2 = v7;
        goto LABEL_26;
    }
  }
}

uint64_t swift_singlePayloadEnumGeneric_getEnumTag(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 - 16)) {
    uint64_t v3 = *(void *)(a2 - 16);
  }
  else {
    uint64_t v3 = 0;
  }
  v13[0] = &unk_1ECA040B0;
  v13[1] = a1;
  unsigned int v14 = v13;
  unint64_t v4 = v11;
  v11[0] = &unk_1ECA040F8;
  v11[1] = a1;
  uint64_t v12 = v11;
  unint64_t v5 = *(void *)(v3 + 24);
  unint64_t v6 = *(void *)(v3 + 32);
  uint64_t v7 = *(void *)(v3 + 40);
  if (v5 >> 62)
  {
    uint64_t v19 = *(void *)(v3 + 40);
    unint64_t v16 = v6;
    LOBYTE(v18) = 1 << ((v5 >> 62) - 1);
    uint64_t v8 = std::__function::__func<swift_singlePayloadEnumGeneric_getEnumTag::$_0,std::allocator<swift_singlePayloadEnumGeneric_getEnumTag::$_0>,std::optional<unsigned int> ()(swift::TargetMetadata<swift::InProcess> const*,unsigned long,unsigned char)>::operator()((uint64_t)v13, &v19, &v16, &v18);
    if ((v8 & 0xFF00000000) != 0) {
      goto LABEL_9;
    }
    unint64_t v4 = v12;
  }
  int v9 = *(_DWORD *)(v3 + 48);
  uint64_t v19 = v7;
  int v17 = v9;
  int v18 = v5;
  unint64_t v16 = v6;
  char v15 = 1 << ((v5 >> 62) - 1);
  if (!v4)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    return swift_singlePayloadEnumGeneric_destructiveInjectEnumTag();
  }
  uint64_t v8 = (*(uint64_t (**)(void *, uint64_t *, int *, int *, unint64_t *, char *))(*v4 + 48))(v4, &v19, &v18, &v17, &v16, &v15);
LABEL_9:
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  if (v14 == v13)
  {
    (*(void (**)(void *))(v13[0] + 32))(v13);
  }
  else if (v14)
  {
    (*(void (**)(void))(*v14 + 40))();
  }
  return v8;
}

uint64_t swift_singlePayloadEnumGeneric_destructiveInjectEnumTag(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (*(void *)(a3 - 16)) {
    uint64_t v4 = *(void *)(a3 - 16);
  }
  else {
    uint64_t v4 = 0;
  }
  v14[0] = &unk_1ECA04140;
  v14[1] = a2;
  v14[2] = a1;
  char v15 = v14;
  unint64_t v5 = v12;
  v12[0] = &unk_1ECA04188;
  v12[1] = a2;
  _OWORD v12[2] = a1;
  unint64_t v13 = v12;
  unint64_t v6 = *(void *)(v4 + 24);
  unint64_t v7 = *(void *)(v4 + 32);
  uint64_t v8 = *(void *)(v4 + 40);
  if (v6 >> 62)
  {
    uint64_t v20 = *(void *)(v4 + 40);
    unint64_t v17 = v7;
    LOBYTE(v19) = 1 << ((v6 >> 62) - 1);
    if ((unsigned __int16)std::__function::__func<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_0,std::allocator<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_0>,std::optional<BOOL> ()(swift::TargetMetadata<swift::InProcess> const*,unsigned long,unsigned char)>::operator()((uint64_t)v14, &v20, &v17, (unsigned __int8 *)&v19) > 0xFFu)goto LABEL_9; {
    unint64_t v5 = v13;
    }
  }
  int v9 = *(_DWORD *)(v4 + 48);
  uint64_t v20 = v8;
  int v18 = v9;
  int v19 = v6;
  unint64_t v17 = v7;
  char v16 = 1 << ((v6 >> 62) - 1);
  if (!v5)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    return swift_generic_initializeBufferWithCopyOfBuffer(v11);
  }
  (*(void (**)(void *, uint64_t *, int *, int *, unint64_t *, char *))(*v5 + 48))(v5, &v20, &v19, &v18, &v17, &v16);
LABEL_9:
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
  }
  else if (v13)
  {
    (*(void (**)(void))(*v13 + 40))();
  }
  uint64_t result = (uint64_t)v15;
  if (v15 == v14) {
    return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
  }
  if (v15) {
    return (*(uint64_t (**)(void))(*v15 + 40))();
  }
  return result;
}

atomic_ullong **swift_generic_initializeBufferWithCopyOfBuffer(atomic_ullong **__dst, atomic_ullong **a2, uint64_t a3)
{
  uint64_t v3 = __dst;
  if ((*(unsigned char *)(*(void *)(a3 - 8) + 82) & 2) != 0)
  {
    *__dst = *a2;
    swift_retain(*a2);
    return (atomic_ullong **)(*v3 + 2);
  }
  else
  {
    swift_generic_initWithCopy(__dst, a2, a3);
  }
  return v3;
}

uint64_t swift::swift_resolve_resilientAccessors(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v7 = result;
  uint64_t v8 = 0;
  while (1)
  {
    uint64_t v11 = v8;
    unint64_t v12 = *(void *)(a3 + v8);
    v8 += 8;
    uint64_t v13 = v12 & 0xFFFFFFFFFFFFFFLL;
    switch(HIBYTE(v12))
    {
      case 0u:
        return result;
      case 0xCu:
        uint64_t v8 = v11 + 16;
        continue;
      case 0xFu:
        uint64_t v14 = v8 + a3;
        uint64_t v15 = *(int *)(v8 + a3);
        uint64_t v8 = v11 + 16;
        char v16 = (uint64_t (*)(unint64_t *))(v14 + v15);
        GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a4);
        uint64_t result = v16(GenericArgs);
        int v18 = (uint64_t *)(v7 + v11 + a2);
        *int v18 = v13 | 0xC00000000000000;
        v18[1] = result;
        continue;
      case 0x10u:
        uint64_t v8 = v11 + 56;
        continue;
      case 0x11u:
        uint64_t v9 = v8 + a3 + *(int *)(v8 + a3);
        int v10 = (uint64_t *)(v7 + v11 + a2);
        *int v10 = v13 | 0x1200000000000000;
        v10[1] = v9;
        goto LABEL_3;
      case 0x12u:
LABEL_3:
        uint64_t v8 = v11 + 32;
        break;
      case 0x13u:
        uint64_t v8 = v11 + *(void *)(v11 + a3 + 44) + 60;
        break;
      case 0x14u:
        uint64_t v19 = v8 + a3 + *(int *)(v8 + a3);
        uint64_t v20 = (uint64_t *)(v7 + v11 + a2);
        uint64_t *v20 = v13 | 0x1500000000000000;
        v20[1] = v19;
        uint64_t v22 = *(void *)(v11 + a3 + 16);
        uint64_t v21 = *(void *)(v11 + a3 + 24);
        uint64_t v23 = v11 + 40;
        if (v22)
        {
          uint64_t v24 = v23 + a2 + 8 * v22;
          uint64_t v25 = a3 + v23 + 8 * v22;
          do
          {
            uint64_t v26 = *(void *)(a3 + v23);
            v23 += 8;
            uint64_t result = swift::swift_resolve_resilientAccessors(v7, v24 + v26, v25 + v26, a4);
            --v22;
          }
          while (v22);
        }
        uint64_t v8 = v23 + v21;
        break;
      case 0x15u:
      case 0x16u:
        uint64_t v8 = v11 + 8 * *(void *)(v11 + a3 + 16) + *(void *)(v11 + a3 + 24) + 40;
        break;
      default:
        continue;
    }
  }
}

uint64_t swift_generic_instantiateLayoutString(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if ((unint64_t)*a2 > 0x7FF) {
    LODWORD(v2) = 0;
  }
  if (!v2 || v2 == 773 || v2 == 515)
  {
    uint64_t v3 = a2 - 3;
    if (result)
    {
LABEL_7:
      *uint64_t v3 = result;
      return result;
    }
  }
  else
  {
    uint64_t v3 = a2 - 2;
    if (result) {
      goto LABEL_7;
    }
  }
  *uint64_t v3 = 0;
  return result;
}

void errorDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + *a3);
  if ((v4 & 0x8000000000000000) == 0)
  {
    *a3 += 8;
    swift_errorRelease((id)(v4 & 0xFFFFFFFFFFFFFF8));
  }
}

uint64_t nativeStrongDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + *a3) & 0xFFFFFFFFFFFFFF8;
  *a3 += 8;
  return swift_release(v4);
}

void unownedDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = (atomic_ullong *)(*(void *)(a4 + *a3) & 0xFFFFFFFFFFFFFF8);
  *a3 += 8;
  swift_unownedRelease(v4);
}

void weakDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = (uint64_t *)(a4 + *a3);
  *a3 += 8;
  swift_weakDestroy(v4);
}

void unknownDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(void **)(a4 + *a3);
  *a3 += 8;
  swift_unknownObjectRelease(v4);
}

void unknownUnownedDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = (atomic_ullong **)(a4 + *a3);
  *a3 += 8;
  swift_unknownObjectUnownedDestroy(v4);
}

void unknownWeakDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = (id *)(a4 + *a3);
  *a3 += 8;
  swift_unknownObjectWeakDestroy(v4);
}

void bridgeDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + *a3);
  *a3 += 8;
  swift_bridgeObjectRelease(v4);
}

void blockDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = (const void *)(a4 + *a3);
  *a3 += 8;
  _Block_release(v4);
}

void objcStrongDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + *a3);
  *a3 += 8;
  if ((v4 & 0x8000000000000000) == 0) {
}
  }

uint64_t metatypeDestroy(uint64_t a1, void **a2, void *a3, uint64_t a4)
{
  uint64_t v4 = *(*a2)++;
  uint64_t v5 = a4 + *a3;
  uint64_t v6 = *(void *)(v4 - 8);
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 8);
  *a3 += *(void *)(v6 + 64);
  return v7(v5, v4);
}

uint64_t existentialDestroy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v4 = (uint64_t *)(a4 + *a3);
  uint64_t v5 = v4[3];
  *a3 += 24;
  uint64_t v6 = *(void *)(v5 - 8);
  if (v6)
  {
    if ((*(unsigned char *)(v6 + 82) & 2) == 0) {
      return (*(uint64_t (**)(void))(v6 + 8))();
    }
  }
  else if ((MEMORY[0x52] & 2) == 0)
  {
    return MEMORY[8]();
  }
  return swift_release(*v4);
}

uint64_t resilientDestroy(unint64_t *a1, int **a2, void *a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t)*a2;
  uint64_t v7 = **a2;
  *a2 += 2;
  uint64_t v8 = (uint64_t (*)(unint64_t *))(v7 + v6);
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a1);
  uint64_t v10 = v8(GenericArgs);
  uint64_t v11 = a4 + *a3;
  uint64_t v12 = *(void *)(v10 - 8);
  uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 8);
  *a3 += *(void *)(v12 + 64);

  return v13(v11, v10);
}

void singlePayloadEnumSimple(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  unint64_t v4 = *(void *)*a2;
  uint64_t v5 = *a2 + 48;
  uint64_t v6 = (v4 >> 59) & 7;
  if (v4 >> 62)
  {
    uint64_t v12 = *(void *)(*a2 + 8);
    uint64_t v7 = *a3;
    uint64_t v13 = a4 + *a3;
    int v14 = (1 << ((v4 >> 62) - 1));
    switch(v14)
    {
      case 4:
        uint64_t v15 = *(unsigned int *)(v13 + v12);
        break;
      case 2:
        uint64_t v15 = *(unsigned __int16 *)(v13 + v12);
        break;
      case 1:
        uint64_t v15 = *(unsigned __int8 *)(v13 + v12);
        break;
      default:
LABEL_23:
        abort();
    }
    if (v6) {
      BOOL v16 = v15 == 0;
    }
    else {
      BOOL v16 = 0;
    }
    if (v16)
    {
LABEL_3:
      int v8 = (1 << (v6 - 1)) - 1;
      uint64_t v9 = *(void *)*a2;
      uint64_t v10 = a4 + v7;
      switch(v8)
      {
        case 0:
          uint64_t v11 = *(unsigned __int8 *)(v10 + v9);
          goto LABEL_8;
        case 1:
          uint64_t v11 = *(unsigned __int16 *)(v10 + v9);
          goto LABEL_8;
        case 3:
          uint64_t v11 = *(unsigned int *)(v10 + v9);
          goto LABEL_8;
        case 7:
          uint64_t v11 = *(void *)(v10 + v9);
LABEL_8:
          if ((unint64_t)(v11 - *(void *)(*a2 + 16)) < *(void *)(*a2 + 24)) {
            break;
          }
          goto LABEL_10;
        default:
          goto LABEL_23;
      }
    }
  }
  else
  {
    uint64_t v7 = *a3;
    if (v6) {
      goto LABEL_3;
    }
  }
  v5 += *(void *)(*a2 + 32);
  *a3 = v7 + *(void *)(*a2 + 40);
LABEL_10:
  *a2 = v5;
}

uint64_t singlePayloadEnumFN(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4)
{
  uint64_t v6 = *a2;
  uint64_t result = ((uint64_t (*)(uint64_t))(*(int *)*a2 + *a2))(a4 + *a3);
  if (result)
  {
    uint64_t v8 = v6 + *(void *)(v6 + 8) + 24;
    *a3 += *(void *)(v6 + 16);
  }
  else
  {
    uint64_t v8 = v6 + 24;
  }
  *a2 = v8;
  return result;
}

uint64_t singlePayloadEnumFNResolved(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(*(void *)a2 + 8);
  uint64_t v7 = *(void *)(*(void *)a2 + 16);
  uint64_t v8 = *(void *)a2 + 24;
  uint64_t result = (**(uint64_t (***)(uint64_t))a2)(a4 + *a3);
  if (result)
  {
    v8 += v6;
    *a3 += v7;
  }
  *(void *)a2 = v8;
  return result;
}

void singlePayloadEnumGeneric(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  unint64_t v6 = *(void *)*a2;
  uint64_t v7 = *(void *)(*a2 + 16);
  uint64_t v8 = *(void *)(*a2 + 28);
  uint64_t v9 = *(void *)(*a2 + 36);
  uint64_t v10 = *a2 + 44;
  if (v6 >> 62)
  {
    uint64_t v12 = *(void *)(*a2 + 8);
    uint64_t v11 = *a3;
    uint64_t v13 = a4 + *a3;
    int v14 = (1 << ((v6 >> 62) - 1));
    switch(v14)
    {
      case 4:
        uint64_t v15 = *(unsigned int *)(v13 + v12);
        break;
      case 2:
        uint64_t v15 = *(unsigned __int16 *)(v13 + v12);
        break;
      case 1:
        uint64_t v15 = *(unsigned __int8 *)(v13 + v12);
        break;
      default:
        abort();
    }
    if (v15) {
      goto LABEL_5;
    }
    if (!v7) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v11 = *a3;
    if (!v7)
    {
LABEL_5:
      v10 += v8;
      *a3 = v11 + v9;
      goto LABEL_6;
    }
  }
  if ((*(unsigned int (**)(uint64_t, void))(*(void *)(v7 - 8) + 48))(a4 + v11 + *(void *)*a2, *(unsigned int *)(*(void *)(v7 - 8) + 84)))
  {
    uint64_t v11 = *a3;
    goto LABEL_5;
  }
LABEL_6:
  *a2 = v10;
}

uint64_t multiPayloadEnumFN<&(handleRefCountsDestroy(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *))>(uint64_t a1, int **a2, uint64_t *a3, uint64_t a4)
{
  unint64_t v8 = *((void *)*a2 + 1);
  uint64_t v9 = *((void *)*a2 + 2);
  uint64_t v10 = *((void *)*a2 + 3);
  uint64_t v11 = (uint64_t)(*a2 + 8);
  uint64_t v12 = *a3;
  uint64_t result = ((uint64_t (*)(uint64_t))((char *)*a2 + **a2))(a4 + *a3);
  *a2 = (int *)(v11 + v9 + 8 * v8);
  *a3 += v10;
  if (v8 > result)
  {
    int v14 = (unint64_t *)(v11 + 8 * v8 + *(void *)(v11 + 8 * result));
    unint64_t v15 = *v14;
    unint64_t v17 = v14 + 1;
    for (uint64_t i = v12 + (v15 & 0xFFFFFFFFFFFFFFLL); HIBYTE(v15); i += v15 & 0xFFFFFFFFFFFFFFLL)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t **, uint64_t *, uint64_t))((char *)destroyTable
                                                                                           + ((v15 >> 53) & 0x7F8)))(a1, &v17, &i, a4);
      unint64_t v15 = *v17++;
    }
  }
  return result;
}

uint64_t multiPayloadEnumFNResolved<&(handleRefCountsDestroy(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *))>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  unint64_t v8 = *(void *)(*(void *)a2 + 8);
  uint64_t v9 = *(void *)(*(void *)a2 + 16);
  uint64_t v10 = *(void *)(*(void *)a2 + 24);
  uint64_t v11 = *(void *)a2 + 32;
  uint64_t v12 = *a3;
  uint64_t result = (**(uint64_t (***)(uint64_t))a2)(a4 + *a3);
  *(void *)a2 = v11 + v9 + 8 * v8;
  *a3 += v10;
  if (v8 > result)
  {
    int v14 = (unint64_t *)(v11 + 8 * v8 + *(void *)(v11 + 8 * result));
    unint64_t v15 = *v14;
    unint64_t v17 = v14 + 1;
    for (uint64_t i = v12 + (v15 & 0xFFFFFFFFFFFFFFLL); HIBYTE(v15); i += v15 & 0xFFFFFFFFFFFFFFLL)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t **, uint64_t *, uint64_t))((char *)destroyTable
                                                                                           + ((v15 >> 53) & 0x7F8)))(a1, &v17, &i, a4);
      unint64_t v15 = *v17++;
    }
  }
  return result;
}

uint64_t multiPayloadEnumGeneric<&(handleRefCountsDestroy(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *))>(uint64_t result, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v5 = result;
  unint64_t v6 = *(void *)(*(void *)a2 + 8);
  uint64_t v7 = *(void *)(*(void *)a2 + 24);
  uint64_t v8 = *a3;
  uint64_t v9 = v7 - **(void **)a2;
  uint64_t v10 = a4 + *a3;
  switch(**(void **)a2)
  {
    case 1u:
      unint64_t v11 = *(unsigned __int8 *)(v10 + v9);
      break;
    case 2u:
      unint64_t v11 = *(unsigned __int16 *)(v10 + v9);
      break;
    case 4u:
      unint64_t v11 = *(unsigned int *)(v10 + v9);
      break;
    case 8u:
      unint64_t v11 = *(void *)(v10 + v9);
      break;
    default:
      abort();
  }
  uint64_t v12 = *(void *)a2 + 32;
  *(void *)a2 = v12 + *(void *)(*(void *)a2 + 16) + 8 * v6;
  *a3 = v8 + v7;
  if (v11 < v6)
  {
    uint64_t v13 = (unint64_t *)(v12 + 8 * v6 + *(void *)(v12 + 8 * v11));
    unint64_t v14 = *v13;
    unint64_t v15 = v13 + 1;
    for (uint64_t i = (v14 & 0xFFFFFFFFFFFFFFLL) + v8; HIBYTE(v14); i += v14 & 0xFFFFFFFFFFFFFFLL)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t **, uint64_t *, uint64_t))((char *)destroyTable
                                                                                           + ((v14 >> 53) & 0x7F8)))(v5, &v15, &i, a4);
      unint64_t v14 = *v15++;
    }
  }
  return result;
}

unint64_t *swift::TargetMetadata<swift::InProcess>::getGenericArgs(unint64_t *a1)
{
  uint64_t result = (unint64_t *)swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a1);
  if (result)
  {
    uint64_t v3 = result;
    uint64_t result = (unint64_t *)swift::TargetContextDescriptor<swift::InProcess>::getGenericContext(result);
    if (result)
    {
      int v4 = *(_DWORD *)v3;
      int v5 = *(_DWORD *)v3 & 0x1F;
      if ((v5 - 17) >= 2)
      {
        if (v5 != 16) {
          abort();
        }
        if ((v4 & 0x20000000) != 0)
        {
          int ResilientImmediateMembersOffset = swift::getResilientImmediateMembersOffset((uint64_t)v3);
        }
        else
        {
          if ((v4 & 0x10000000) != 0)
          {
            int v7 = 0;
            uint64_t v8 = 3;
          }
          else
          {
            int v7 = *((_DWORD *)v3 + 7);
            uint64_t v8 = 4;
          }
          int ResilientImmediateMembersOffset = v7 - LODWORD(v3[v8]);
        }
      }
      else
      {
        int ResilientImmediateMembersOffset = 2;
      }
      return &a1[ResilientImmediateMembersOffset];
    }
  }
  return result;
}

uint64_t swift::TargetContextDescriptor<swift::InProcess>::getGenericContext(_DWORD *a1)
{
  int v1 = *a1;
  if ((*a1 & 0x80) == 0) {
    return 0;
  }
  uint64_t result = 0;
  switch(v1 & 0x1F)
  {
    case 1:
      if (a1) {
        int v4 = a1;
      }
      else {
        int v4 = 0;
      }
      if ((*v4 & 0x80) == 0) {
        return 0;
      }
      if (!v4) {
        int v4 = 0;
      }
      if (v4 == (unsigned char *)-12) {
        goto LABEL_49;
      }
      uint64_t v10 = v4 + 12;
      return (uint64_t)(v10 - 4);
    case 2:
      if (a1) {
        int v5 = a1;
      }
      else {
        int v5 = 0;
      }
      if ((*v5 & 0x80) == 0) {
        return 0;
      }
      if (!v5) {
        int v5 = 0;
      }
      if (v5 == (unsigned char *)-8) {
        goto LABEL_49;
      }
      uint64_t v10 = v5 + 8;
      return (uint64_t)(v10 - 4);
    case 4:
      if (a1) {
        unint64_t v6 = a1;
      }
      else {
        unint64_t v6 = 0;
      }
      if ((*v6 & 0x80) == 0) {
        return 0;
      }
      if (!v6) {
        unint64_t v6 = 0;
      }
      if (v6 == (unsigned char *)-8) {
LABEL_49:
      }
        uint64_t v10 = 0;
      else {
        uint64_t v10 = v6 + 8;
      }
      return (uint64_t)(v10 - 4);
    case 0x10:
      if (a1) {
        int v7 = a1;
      }
      else {
        int v7 = 0;
      }
      if ((*v7 & 0x80) == 0) {
        return 0;
      }
      if (!v7) {
        int v7 = 0;
      }
      if (v7 == (unsigned char *)-44) {
        goto LABEL_60;
      }
      uint64_t result = (uint64_t)(v7 + 48);
      break;
    case 0x11:
      if (a1) {
        uint64_t v8 = a1;
      }
      else {
        uint64_t v8 = 0;
      }
      if ((*v8 & 0x80) == 0) {
        return 0;
      }
      if (!v8) {
        uint64_t v8 = 0;
      }
      if (v8 == (unsigned char *)-28) {
        goto LABEL_60;
      }
      uint64_t result = (uint64_t)(v8 + 32);
      break;
    case 0x12:
      if (a1) {
        uint64_t v9 = a1;
      }
      else {
        uint64_t v9 = 0;
      }
      if ((*v9 & 0x80) == 0) {
        return 0;
      }
      if (!v9) {
        uint64_t v9 = 0;
      }
      if (v9 == (unsigned char *)-28) {
LABEL_60:
      }
        uint64_t result = 4;
      else {
        uint64_t result = (uint64_t)(v9 + 32);
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t handleRefCountsDestroy(uint64_t result, void **a2, void *a3, uint64_t a4)
{
  unint64_t v4 = *(*a2)++;
  *a3 += v4 & 0xFFFFFFFFFFFFFFLL;
  if (HIBYTE(v4))
  {
    uint64_t v8 = result;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void **, void *, uint64_t))((char *)destroyTable
                                                                                + ((v4 >> 53) & 0x7F8)))(v8, a2, a3, a4);
      unint64_t v4 = *(*a2)++;
      *a3 += v4 & 0xFFFFFFFFFFFFFFLL;
    }
    while (HIBYTE(v4));
  }
  return result;
}

id errorRetain(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a5 + *a3);
  if ((v6 & 0x8000000000000000) == 0)
  {
    *(void *)(a4 + v5) = v6;
    *a3 = v5 + 8;
    return swift_errorRetain((id)(v6 & 0xFFFFFFFFFFFFFF8));
  }
  return result;
}

atomic_ullong *nativeStrongRetain(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a5 + *a3);
  *(void *)(a4 + v5) = v6;
  *a3 = v5 + 8;
  return swift_retain((atomic_ullong *)(v6 & 0xFFFFFFFFFFFFFF8));
}

uint64_t unownedRetain(uint64_t a1, uint64_t a2, char *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = *(void *)a3;
  uint64_t v6 = *(void *)(a5 + *(void *)a3);
  *(void *)&a4[v5] = v6;
  *(void *)a3 = v5 + 8;
  return swift_unownedRetain(v6 & 0xFFFFFFFFFFFFFF8, a2, a3, a4);
}

swift *weakCopyInit(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = (swift *)(a4 + *a3);
  uint64_t v6 = (void *)(a5 + *a3);
  *a3 += 8;
  return swift_weakCopyInit(v5, v6);
}

id unknownRetain(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void **)(a5 + *a3);
  *(void *)(a4 + v5) = v6;
  *a3 = v5 + 8;
  return swift_unknownObjectRetain(v6);
}

void *unknownUnownedCopyInit(uint64_t a1, uint64_t a2, const char *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = &a4[*(void *)a3];
  uint64_t v6 = (uint64_t *)(a5 + *(void *)a3);
  *(void *)a3 += 8;
  return swift_unknownObjectUnownedCopyInit(v5, v6, a3, a4);
}

id *unknownWeakCopyInit(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = (id *)(a4 + *a3);
  uint64_t v6 = (id *)(a5 + *a3);
  *a3 += 8;
  return swift_unknownObjectWeakCopyInit(v5, v6);
}

unint64_t bridgeRetain(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  unint64_t v6 = *(void *)(a5 + *a3);
  *(void *)(a4 + v5) = v6;
  *a3 = v5 + 8;
  return swift_bridgeObjectRetain(v6);
}

void *blockCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = *a3;
  id result = _Block_copy(*(const void **)(a5 + *a3));
  *(void *)(a4 + v7) = result;
  *a3 = v7 + 8;
  return result;
}

id objcStrongRetain(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a5 + *a3);
  *(void *)(a4 + v5) = v6;
  *a3 = v5 + 8;
  if ((v6 & 0x8000000000000000) == 0) {
    return (id)(v6 & 0xFFFFFFFFFFFFFF8);
  }
  return result;
}

uint64_t metatypeInitWithCopy(uint64_t a1, void **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(*a2)++;
  uint64_t v7 = a4 + v5;
  uint64_t v8 = *(void *)(v6 - 8);
  uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 16);
  *a3 = *(void *)(v8 + 64) + v5;
  return v9(v7, a5 + v5, v6);
}

uint64_t existentialInitWithCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *a3;
  uint64_t v7 = *(void *)(a5 + *a3 + 24);
  *a3 = v6 + 24;
  if (*(void *)(v7 - 8)) {
    uint64_t v8 = *(uint64_t (***)(uint64_t))(v7 - 8);
  }
  else {
    uint64_t v8 = 0;
  }
  return (*v8)(a4 + v6);
}

uint64_t resilientInitWithCopy(unint64_t *a1, int **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = (uint64_t)*a2;
  uint64_t v9 = **a2;
  *a2 += 2;
  uint64_t v10 = *a3;
  unint64_t v11 = (uint64_t (*)(unint64_t *))(v9 + v8);
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a1);
  uint64_t v13 = v11(GenericArgs);
  uint64_t v14 = *(void *)(v13 - 8);
  unint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v14 + 16);
  *a3 = *(void *)(v14 + 64) + v10;

  return v15(a4 + v10, a5 + v10, v13);
}

void *singlePayloadEnumSimple(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  unint64_t v7 = *(void *)*a2;
  uint64_t v9 = *(void *)(*a2 + 32);
  size_t v8 = *(void *)(*a2 + 40);
  uint64_t v10 = *a2 + 48;
  uint64_t v11 = (v7 >> 59) & 7;
  if (v7 >> 62)
  {
    uint64_t v18 = *(void *)(*a2 + 8);
    uint64_t v12 = *a3;
    uint64_t v19 = a5 + *a3;
    int v20 = (1 << ((v7 >> 62) - 1));
    switch(v20)
    {
      case 4:
        uint64_t v21 = *(unsigned int *)(v19 + v18);
        break;
      case 2:
        uint64_t v21 = *(unsigned __int16 *)(v19 + v18);
        break;
      case 1:
        uint64_t v21 = *(unsigned __int8 *)(v19 + v18);
        break;
      default:
LABEL_23:
        abort();
    }
    if (v11) {
      BOOL v22 = v21 == 0;
    }
    else {
      BOOL v22 = 0;
    }
    if (v22)
    {
LABEL_3:
      int v13 = (1 << (v11 - 1)) - 1;
      uint64_t v14 = *(void *)*a2;
      uint64_t v15 = a5 + v12;
      switch(v13)
      {
        case 0:
          uint64_t v16 = *(unsigned __int8 *)(v15 + v14);
          goto LABEL_8;
        case 1:
          uint64_t v16 = *(unsigned __int16 *)(v15 + v14);
          goto LABEL_8;
        case 3:
          uint64_t v16 = *(unsigned int *)(v15 + v14);
          goto LABEL_8;
        case 7:
          uint64_t v16 = *(void *)(v15 + v14);
LABEL_8:
          if ((unint64_t)(v16 - *(void *)(*a2 + 16)) < *(void *)(*a2 + 24)) {
            break;
          }
          goto LABEL_10;
        default:
          goto LABEL_23;
      }
    }
  }
  else
  {
    uint64_t v12 = *a3;
    if (v11) {
      goto LABEL_3;
    }
  }
  id result = memcpy((void *)(a4 + v12), (const void *)(a5 + v12), v8);
  v10 += v9;
  *a3 += v8;
LABEL_10:
  *a2 = v10;
  return result;
}

void *singlePayloadEnumFN(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *a2;
  id result = (void *)((uint64_t (*)(uint64_t))(*(int *)*a2 + *a2))(a5 + *a3);
  if (result)
  {
    size_t v12 = *(void *)(v9 + 16);
    uint64_t v11 = v9 + *(void *)(v9 + 8) + 24;
    id result = memcpy((void *)(a4 + *a3), (const void *)(a5 + *a3), v12);
    *a3 += v12;
  }
  else
  {
    uint64_t v11 = v9 + 24;
  }
  *a2 = v11;
  return result;
}

void *singlePayloadEnumFNResolved(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(*(void *)a2 + 8);
  size_t v10 = *(void *)(*(void *)a2 + 16);
  uint64_t v11 = *(void *)a2 + 24;
  id result = (void *)(**(uint64_t (***)(uint64_t))a2)(a5 + *a3);
  if (result)
  {
    v11 += v9;
    id result = memcpy((void *)(a4 + *a3), (const void *)(a5 + *a3), v10);
    *a3 += v10;
  }
  *(void *)a2 = v11;
  return result;
}

void singlePayloadEnumGeneric(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9 = *(void *)*a2;
  uint64_t v10 = *(void *)(*a2 + 16);
  uint64_t v11 = *(void *)(*a2 + 28);
  size_t v12 = *(void *)(*a2 + 36);
  uint64_t v13 = *a2 + 44;
  if (v9 >> 62)
  {
    uint64_t v15 = *(void *)(*a2 + 8);
    uint64_t v14 = *a3;
    uint64_t v16 = a5 + *a3;
    int v17 = (1 << ((v9 >> 62) - 1));
    switch(v17)
    {
      case 4:
        uint64_t v18 = *(unsigned int *)(v16 + v15);
        break;
      case 2:
        uint64_t v18 = *(unsigned __int16 *)(v16 + v15);
        break;
      case 1:
        uint64_t v18 = *(unsigned __int8 *)(v16 + v15);
        break;
      default:
        abort();
    }
    if (v18) {
      goto LABEL_5;
    }
    if (!v10) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v14 = *a3;
    if (!v10)
    {
LABEL_5:
      v13 += v11;
      memcpy((void *)(a4 + v14), (const void *)(a5 + v14), v12);
      *a3 += v12;
      goto LABEL_6;
    }
  }
  if ((*(unsigned int (**)(uint64_t, void))(*(void *)(v10 - 8) + 48))(a5 + v14 + *(void *)*a2, *(unsigned int *)(*(void *)(v10 - 8) + 84)))
  {
    uint64_t v14 = *a3;
    goto LABEL_5;
  }
LABEL_6:
  *a2 = v13;
}

void *multiPayloadEnumFN<&(handleRefCountsInitWithCopy(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *,unsigned char *))>(uint64_t a1, int **a2, size_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = (uint64_t (*)(size_t))((char *)*a2 + **a2);
  unint64_t v11 = *((void *)*a2 + 1);
  uint64_t v12 = *((void *)*a2 + 2);
  size_t v13 = *((void *)*a2 + 3);
  uint64_t v14 = (uint64_t)(*a2 + 8);
  size_t v15 = *a3;
  size_t v22 = v15;
  id result = (void *)v10(a5 + v15);
  *a2 = (int *)(v14 + v12 + 8 * v11);
  size_t v17 = *a3;
  if (v11 <= result)
  {
    id result = memcpy((void *)(a4 + v17), (const void *)(a5 + v17), v13);
    *a3 += v13;
  }
  else
  {
    *a3 = v17 + v13;
    uint64_t v18 = (void *)(v14 + 8 * v11 + *(void *)(v14 + 8 * result));
    for (i = v18; ; uint64_t v18 = i)
    {
      unint64_t v19 = *v18;
      uint64_t i = v18 + 1;
      size_t v20 = v19 & 0xFFFFFFFFFFFFFFLL;
      if ((v19 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v15), (const void *)(a5 + v15), v20);
      }
      size_t v21 = v20 + v15;
      size_t v22 = v20 + v15;
      if (!HIBYTE(v19)) {
        break;
      }
      id result = (void *)(*(uint64_t (**)(uint64_t, void **, size_t *, uint64_t, uint64_t))((char *)initWithCopyTable
                                                                                                 + ((v19 >> 53) & 0x7F8)))(a1, &i, &v22, a4, a5);
      size_t v15 = v22;
    }
    if (*a3 != v21) {
      return memcpy((void *)(a4 + v21), (const void *)(a5 + v21), *a3 - v21);
    }
  }
  return result;
}

void *multiPayloadEnumFNResolved<&(handleRefCountsInitWithCopy(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *,unsigned char *))>(uint64_t a1, uint64_t (***a2)(size_t), size_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = **a2;
  unint64_t v11 = (unint64_t)(*a2)[1];
  size_t v13 = (*a2)[2];
  size_t v12 = (size_t)(*a2)[3];
  uint64_t v14 = (uint64_t)(*a2 + 4);
  size_t v15 = *a3;
  size_t v22 = v15;
  id result = (void *)v10(a5 + v15);
  *a2 = (uint64_t (**)(size_t))((char *)v13 + 8 * v11 + v14);
  size_t v17 = *a3;
  if (v11 <= result)
  {
    id result = memcpy((void *)(a4 + v17), (const void *)(a5 + v17), v12);
    *a3 += v12;
  }
  else
  {
    *a3 = v17 + v12;
    uint64_t v18 = (void *)(v14 + 8 * v11 + *(void *)(v14 + 8 * result));
    for (i = v18; ; uint64_t v18 = i)
    {
      unint64_t v19 = *v18;
      uint64_t i = v18 + 1;
      size_t v20 = v19 & 0xFFFFFFFFFFFFFFLL;
      if ((v19 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v15), (const void *)(a5 + v15), v20);
      }
      size_t v21 = v20 + v15;
      size_t v22 = v20 + v15;
      if (!HIBYTE(v19)) {
        break;
      }
      id result = (void *)(*(uint64_t (**)(uint64_t, void **, size_t *, uint64_t, uint64_t))((char *)initWithCopyTable
                                                                                                 + ((v19 >> 53) & 0x7F8)))(a1, &i, &v22, a4, a5);
      size_t v15 = v22;
    }
    if (*a3 != v21) {
      return memcpy((void *)(a4 + v21), (const void *)(a5 + v21), *a3 - v21);
    }
  }
  return result;
}

void *multiPayloadEnumGeneric<&(handleRefCountsInitWithCopy(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *,unsigned char *))>(void *result, uint64_t **a2, size_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a2;
  uint64_t v6 = **a2;
  unint64_t v7 = (*a2)[1];
  uint64_t v8 = (*a2)[2];
  size_t v9 = (*a2)[3];
  size_t v10 = *a3;
  size_t v25 = v10;
  int v11 = v6 - 1;
  size_t v15 = result;
  size_t v16 = v9 - v6;
  uint64_t v17 = a5 + v10;
  switch(v11)
  {
    case 0:
      unint64_t v18 = *(unsigned __int8 *)(v17 + v16);
      break;
    case 1:
      unint64_t v18 = *(unsigned __int16 *)(v17 + v16);
      break;
    case 3:
      unint64_t v18 = *(unsigned int *)(v17 + v16);
      break;
    case 7:
      unint64_t v18 = *(void *)(v17 + v16);
      break;
    default:
      abort();
  }
  unint64_t v19 = v5 + 4;
  *a2 = (void *)((char *)&v19[v7] + v8);
  if (v18 >= v7)
  {
    id result = memcpy((void *)(a4 + v10), (const void *)(a5 + v10), v9);
    *a3 += v9;
  }
  else
  {
    *a3 = v10 + v9;
    size_t v20 = (void *)((char *)&v19[v7] + v19[v18]);
    uint64_t v24 = v20;
    while (1)
    {
      unint64_t v21 = *v20;
      uint64_t v24 = v20 + 1;
      size_t v22 = v21 & 0xFFFFFFFFFFFFFFLL;
      if ((v21 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v10), (const void *)(a5 + v10), v22);
      }
      size_t v23 = v22 + v10;
      size_t v25 = v22 + v10;
      if (!HIBYTE(v21)) {
        break;
      }
      id result = (void *)(*(uint64_t (**)(void *, void **, size_t *, uint64_t, uint64_t))((char *)initWithCopyTable
                                                                                                + ((v21 >> 53) & 0x7F8)))(v15, &v24, &v25, a4, a5);
      size_t v20 = v24;
      size_t v10 = v25;
    }
    if (*a3 != v23) {
      return memcpy((void *)(a4 + v23), (const void *)(a5 + v23), *a3 - v23);
    }
  }
  return result;
}

void *handleRefCountsInitWithCopy(void *result, void **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  for (uint64_t i = result;
        ;
        id result = (void *)(*(uint64_t (**)(void *, void **, uint64_t *, uint64_t, uint64_t))((char *)initWithCopyTable + ((v11 >> 53) & 0x7F8)))(i, a2, a3, a4, a5))
  {
    uint64_t v10 = *a3;
    unint64_t v11 = *(*a2)++;
    if ((v11 & 0xFFFFFFFFFFFFFFLL) != 0) {
      id result = memcpy((void *)(a4 + v10), (const void *)(a5 + v10), v11 & 0xFFFFFFFFFFFFFFLL);
    }
    *a3 = (v11 & 0xFFFFFFFFFFFFFFLL) + v10;
    if (!HIBYTE(v11)) {
      break;
    }
  }
  return result;
}

void copyingInitWithTake(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  *(void *)(a4 + *a3) = *(void *)(a5 + *a3);
  *a3 += 8;
}

id *unknownWeakInitWithTake(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = (id *)(a4 + *a3);
  uint64_t v6 = (id *)(a5 + *a3);
  *a3 += 8;
  return swift_unknownObjectWeakTakeInit(v5, v6);
}

uint64_t metatypeInitWithTake(uint64_t a1, void **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(*a2)++;
  uint64_t v7 = a4 + v5;
  uint64_t v8 = *(void *)(v6 - 8);
  size_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 32);
  *a3 = *(void *)(v8 + 64) + v5;
  return v9(v7, a5 + v5, v6);
}

void *existentialInitWithTake(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *a3;
  uint64_t v7 = (void *)(a5 + *a3);
  uint64_t v8 = v7[3];
  id result = (void *)(a4 + v6);
  *a3 = v6 + 24;
  uint64_t v10 = *(void *)(v8 - 8);
  if (v10)
  {
    if ((*(unsigned char *)(v10 + 82) & 2) == 0) {
      return (void *)(*(uint64_t (**)(void *))(v10 + 32))(result);
    }
  }
  else if ((MEMORY[0x52] & 2) == 0)
  {
    return (void *)MEMORY[0x20](result);
  }
  *id result = *v7;
  return result;
}

uint64_t resilientInitWithTake(unint64_t *a1, int **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = (uint64_t)*a2;
  uint64_t v9 = **a2;
  *a2 += 2;
  uint64_t v10 = *a3;
  unint64_t v11 = (uint64_t (*)(unint64_t *))(v9 + v8);
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a1);
  uint64_t v13 = v11(GenericArgs);
  uint64_t v14 = *(void *)(v13 - 8);
  size_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v14 + 32);
  *a3 = *(void *)(v14 + 64) + v10;

  return v15(a4 + v10, a5 + v10, v13);
}

void *multiPayloadEnumFN<&(handleRefCountsInitWithTake(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *,unsigned char *))>(uint64_t a1, int **a2, size_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = (uint64_t (*)(size_t))((char *)*a2 + **a2);
  unint64_t v11 = *((void *)*a2 + 1);
  uint64_t v12 = *((void *)*a2 + 2);
  size_t v13 = *((void *)*a2 + 3);
  uint64_t v14 = (uint64_t)(*a2 + 8);
  size_t v15 = *a3;
  size_t v22 = v15;
  id result = (void *)v10(a5 + v15);
  *a2 = (int *)(v14 + v12 + 8 * v11);
  size_t v17 = *a3;
  if (v11 <= result)
  {
    id result = memcpy((void *)(a4 + v17), (const void *)(a5 + v17), v13);
    *a3 += v13;
  }
  else
  {
    *a3 = v17 + v13;
    unint64_t v18 = (void *)(v14 + 8 * v11 + *(void *)(v14 + 8 * result));
    for (i = v18; ; unint64_t v18 = i)
    {
      unint64_t v19 = *v18;
      uint64_t i = v18 + 1;
      size_t v20 = v19 & 0xFFFFFFFFFFFFFFLL;
      if ((v19 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v15), (const void *)(a5 + v15), v20);
      }
      size_t v21 = v20 + v15;
      size_t v22 = v20 + v15;
      if (!HIBYTE(v19)) {
        break;
      }
      id result = (void *)(*(uint64_t (**)(uint64_t, void **, size_t *, uint64_t, uint64_t))((char *)initWithTakeTable
                                                                                                 + ((v19 >> 53) & 0x7F8)))(a1, &i, &v22, a4, a5);
      size_t v15 = v22;
    }
    if (*a3 != v21) {
      return memcpy((void *)(a4 + v21), (const void *)(a5 + v21), *a3 - v21);
    }
  }
  return result;
}

void *multiPayloadEnumFNResolved<&(handleRefCountsInitWithTake(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *,unsigned char *))>(uint64_t a1, uint64_t (***a2)(size_t), size_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = **a2;
  unint64_t v11 = (unint64_t)(*a2)[1];
  size_t v13 = (*a2)[2];
  size_t v12 = (size_t)(*a2)[3];
  uint64_t v14 = (uint64_t)(*a2 + 4);
  size_t v15 = *a3;
  size_t v22 = v15;
  id result = (void *)v10(a5 + v15);
  *a2 = (uint64_t (**)(size_t))((char *)v13 + 8 * v11 + v14);
  size_t v17 = *a3;
  if (v11 <= result)
  {
    id result = memcpy((void *)(a4 + v17), (const void *)(a5 + v17), v12);
    *a3 += v12;
  }
  else
  {
    *a3 = v17 + v12;
    unint64_t v18 = (void *)(v14 + 8 * v11 + *(void *)(v14 + 8 * result));
    for (i = v18; ; unint64_t v18 = i)
    {
      unint64_t v19 = *v18;
      uint64_t i = v18 + 1;
      size_t v20 = v19 & 0xFFFFFFFFFFFFFFLL;
      if ((v19 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v15), (const void *)(a5 + v15), v20);
      }
      size_t v21 = v20 + v15;
      size_t v22 = v20 + v15;
      if (!HIBYTE(v19)) {
        break;
      }
      id result = (void *)(*(uint64_t (**)(uint64_t, void **, size_t *, uint64_t, uint64_t))((char *)initWithTakeTable
                                                                                                 + ((v19 >> 53) & 0x7F8)))(a1, &i, &v22, a4, a5);
      size_t v15 = v22;
    }
    if (*a3 != v21) {
      return memcpy((void *)(a4 + v21), (const void *)(a5 + v21), *a3 - v21);
    }
  }
  return result;
}

void *multiPayloadEnumGeneric<&(handleRefCountsInitWithTake(swift::TargetMetadata<swift::InProcess> const*,swift::LayoutStringReader1 &,unsigned long &,unsigned char *,unsigned char *))>(void *result, uint64_t **a2, size_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a2;
  uint64_t v6 = **a2;
  unint64_t v7 = (*a2)[1];
  uint64_t v8 = (*a2)[2];
  size_t v9 = (*a2)[3];
  size_t v10 = *a3;
  size_t v25 = v10;
  int v11 = v6 - 1;
  size_t v15 = result;
  size_t v16 = v9 - v6;
  uint64_t v17 = a5 + v10;
  switch(v11)
  {
    case 0:
      unint64_t v18 = *(unsigned __int8 *)(v17 + v16);
      break;
    case 1:
      unint64_t v18 = *(unsigned __int16 *)(v17 + v16);
      break;
    case 3:
      unint64_t v18 = *(unsigned int *)(v17 + v16);
      break;
    case 7:
      unint64_t v18 = *(void *)(v17 + v16);
      break;
    default:
      abort();
  }
  unint64_t v19 = v5 + 4;
  *a2 = (void *)((char *)&v19[v7] + v8);
  if (v18 >= v7)
  {
    id result = memcpy((void *)(a4 + v10), (const void *)(a5 + v10), v9);
    *a3 += v9;
  }
  else
  {
    *a3 = v10 + v9;
    size_t v20 = (void *)((char *)&v19[v7] + v19[v18]);
    uint64_t v24 = v20;
    while (1)
    {
      unint64_t v21 = *v20;
      uint64_t v24 = v20 + 1;
      size_t v22 = v21 & 0xFFFFFFFFFFFFFFLL;
      if ((v21 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v10), (const void *)(a5 + v10), v22);
      }
      size_t v23 = v22 + v10;
      size_t v25 = v22 + v10;
      if (!HIBYTE(v21)) {
        break;
      }
      id result = (void *)(*(uint64_t (**)(void *, void **, size_t *, uint64_t, uint64_t))((char *)initWithTakeTable
                                                                                                + ((v21 >> 53) & 0x7F8)))(v15, &v24, &v25, a4, a5);
      size_t v20 = v24;
      size_t v10 = v25;
    }
    if (*a3 != v23) {
      return memcpy((void *)(a4 + v23), (const void *)(a5 + v23), *a3 - v23);
    }
  }
  return result;
}

void errorAssignWithCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a4 + *a3);
  uint64_t v7 = *(void *)(a5 + *a3);
  *(void *)(a4 + v5) = v7;
  *a3 = v5 + 8;
  if ((v6 & 0x8000000000000000) == 0) {
    swift_errorRelease((id)(v6 & 0xFFFFFFFFFFFFFF8));
  }
  if ((v7 & 0x8000000000000000) == 0)
  {
    swift_errorRetain((id)(v7 & 0xFFFFFFFFFFFFFF8));
  }
}

atomic_ullong *nativeStrongAssignWithCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a4 + *a3);
  uint64_t v7 = *(void *)(a5 + *a3);
  *(void *)(a4 + v5) = v7;
  uint64_t v8 = (atomic_ullong *)(v7 & 0xFFFFFFFFFFFFFF8);
  *a3 = v5 + 8;
  swift_release(v6 & 0xFFFFFFFFFFFFFF8);

  return swift_retain(v8);
}

uint64_t unownedAssignWithCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a4 + *a3);
  uint64_t v7 = *(void *)(a5 + *a3);
  *(void *)(a4 + v5) = v7;
  uint64_t v8 = v7 & 0xFFFFFFFFFFFFFF8;
  *a3 = v5 + 8;
  swift_unownedRelease((atomic_ullong *)(v6 & 0xFFFFFFFFFFFFFF8));

  return swift_unownedRetain(v8, v9, v10, v11);
}

uint64_t *weakAssignWithCopy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = (uint64_t *)(a4 + *a3);
  uint64_t v6 = (uint64_t *)(a5 + *a3);
  *a3 += 8;
  return swift_weakCopyAssign(v5, v6);
}

id unknownAssignWithCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void **)(a4 + *a3);
  uint64_t v7 = *(void **)(a5 + *a3);
  *(void *)(a4 + v5) = v7;
  *a3 = v5 + 8;
  swift_unknownObjectRelease(v6);

  return swift_unknownObjectRetain(v7);
}

atomic_ullong **unknownUnownedAssignWithCopy(uint64_t a1, uint64_t a2, const char *a3, char *a4, uint64_t a5)
{
  uint64_t v5 = (atomic_ullong **)&a4[*(void *)a3];
  uint64_t v6 = (uint64_t *)(a5 + *(void *)a3);
  *(void *)a3 += 8;
  return swift_unknownObjectUnownedCopyAssign(v5, v6, a3, a4);
}

id *unknownWeakAssignWithCopy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = (id *)(a4 + *a3);
  uint64_t v6 = (id *)(a5 + *a3);
  *a3 += 8;
  return swift_unknownObjectWeakCopyAssign(v5, v6);
}

unint64_t bridgeAssignWithCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a4 + *a3);
  unint64_t v7 = *(void *)(a5 + *a3);
  *(void *)(a4 + v5) = v7;
  *a3 = v5 + 8;
  swift_bridgeObjectRelease(v6);

  return swift_bridgeObjectRetain(v7);
}

void *blockAssignWithCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *a3;
  _Block_release(*(const void **)(a4 + *a3));
  id result = _Block_copy(*(const void **)(a5 + v8));
  *(void *)(a4 + v8) = result;
  *a3 = v8 + 8;
  return result;
}

void objcStrongAssignWithCopy(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a4 + *a3);
  uint64_t v7 = *(void *)(a5 + *a3);
  *(void *)(a4 + v5) = v7;
  *a3 = v5 + 8;
  if ((v6 & 0x8000000000000000) == 0) {

  }
  if ((v7 & 0x8000000000000000) == 0)
  {
    id v8 = (id)(v7 & 0xFFFFFFFFFFFFFF8);
  }
}

uint64_t metatypeAssignWithCopy(uint64_t a1, void **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t v6 = *(*a2)++;
  uint64_t v7 = a4 + v5;
  uint64_t v8 = *(void *)(v6 - 8);
  uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 24);
  *a3 = *(void *)(v8 + 64) + v5;
  return v9(v7, a5 + v5, v6);
}

atomic_ullong *existentialAssignWithCopy(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = (uint64_t *)(a5 + *a3);
  uint64_t v6 = v5[3];
  uint64_t v7 = (uint64_t *)(a4 + *a3);
  uint64_t v8 = v7[3];
  *a3 += 24;
  if (v6 == v8)
  {
    uint64_t v11 = *(void *)(v6 - 8);
    if (v11)
    {
      uint64_t v12 = *(void *)(v6 - 8);
      if ((*(unsigned char *)(v11 + 82) & 2) != 0) {
        goto LABEL_25;
      }
    }
    else
    {
      if ((MEMORY[0x52] & 2) != 0)
      {
LABEL_25:
        swift_release(*v7);
        goto LABEL_26;
      }
      uint64_t v12 = 0;
    }
    size_t v15 = *(uint64_t (**)(uint64_t *, uint64_t *, uint64_t))(v12 + 24);
    size_t v16 = v7;
    uint64_t v17 = v5;
    uint64_t v18 = v6;
    return (atomic_ullong *)v15(v16, v17, v18);
  }
  uint64_t v9 = *(void *)(v8 - 8);
  if (v9)
  {
    uint64_t v10 = *(void *)(v8 - 8);
    if ((*(unsigned char *)(v9 + 82) & 2) != 0) {
      goto LABEL_11;
    }
  }
  else
  {
    if ((MEMORY[0x52] & 2) != 0)
    {
LABEL_11:
      swift_release(*v7);
      goto LABEL_12;
    }
    uint64_t v10 = 0;
  }
  (*(void (**)(uint64_t *))(v10 + 8))(v7);
LABEL_12:
  uint64_t v13 = *(void *)(v6 - 8);
  if (v13)
  {
    uint64_t v14 = *(void *)(v6 - 8);
    if ((*(unsigned char *)(v13 + 82) & 2) != 0) {
      goto LABEL_26;
    }
    goto LABEL_17;
  }
  if ((MEMORY[0x52] & 2) == 0)
  {
    uint64_t v14 = 0;
LABEL_17:
    size_t v15 = *(uint64_t (**)(uint64_t *, uint64_t *, uint64_t))(v14 + 16);
    size_t v16 = v7;
    uint64_t v17 = v5;
    uint64_t v18 = v6;
    return (atomic_ullong *)v15(v16, v17, v18);
  }
LABEL_26:
  uint64_t *v7 = *v5;
  size_t v20 = (atomic_ullong *)*v5;

  return swift_retain(v20);
}

uint64_t resilientAssignWithCopy(unint64_t *a1, int **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = (uint64_t)*a2;
  uint64_t v9 = **a2;
  *a2 += 2;
  uint64_t v10 = *a3;
  uint64_t v11 = (uint64_t (*)(unint64_t *))(v9 + v8);
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a1);
  uint64_t v13 = v11(GenericArgs);
  uint64_t v14 = *(void *)(v13 - 8);
  size_t v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v14 + 24);
  *a3 = *(void *)(v14 + 64) + v10;

  return v15(a4 + v10, a5 + v10, v13);
}

void *singlePayloadEnumSimpleAssignWithCopy(void *result, unint64_t **a2, size_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = result;
  size_t v10 = *a3;
  size_t v40 = *a3;
  unint64_t v12 = **a2;
  unint64_t v11 = (*a2)[1];
  unint64_t v14 = (*a2)[2];
  unint64_t v13 = (*a2)[3];
  uint64_t v15 = (*a2)[4];
  size_t v16 = (*a2)[5];
  uint64_t v17 = *a2 + 6;
  unint64_t v41 = v17;
  uint64_t v18 = (v12 >> 59) & 7;
  uint64_t v19 = v12;
  unint64_t v20 = v12 >> 62;
  if (v20)
  {
    int v26 = 1 << (v20 - 1);
    uint64_t v27 = a5 + v10;
    switch(v26)
    {
      case 1u:
        unint64_t v25 = *(unsigned __int8 *)(v27 + v11);
        unint64_t v21 = *(unsigned __int8 *)(a4 + v10 + v11);
        if (!v18) {
          goto LABEL_28;
        }
        break;
      case 2u:
        unint64_t v25 = *(unsigned __int16 *)(v27 + v11);
        unint64_t v21 = *(unsigned __int16 *)(a4 + v10 + v11);
        if (!v18) {
          goto LABEL_28;
        }
        break;
      case 4u:
        unint64_t v25 = *(unsigned int *)(v27 + v11);
        unint64_t v21 = *(unsigned int *)(a4 + v10 + v11);
        if (!v18) {
          goto LABEL_28;
        }
        break;
      default:
LABEL_49:
        abort();
    }
    int v22 = 1 << (v18 - 1);
    if (!v25) {
      goto LABEL_4;
    }
    unint64_t v25 = 0;
    if (!v21)
    {
LABEL_22:
      uint64_t v28 = a4 + v10;
      switch((char)v22)
      {
        case 1:
          uint64_t v29 = *(unsigned __int8 *)(v28 + v19);
          goto LABEL_27;
        case 2:
          uint64_t v29 = *(unsigned __int16 *)(v28 + v19);
          goto LABEL_27;
        case 4:
          uint64_t v29 = *(unsigned int *)(v28 + v19);
          goto LABEL_27;
        case 8:
          uint64_t v29 = *(void *)(v28 + v19);
LABEL_27:
          unint64_t v21 = v29 - v14;
          goto LABEL_28;
        default:
          goto LABEL_49;
      }
    }
LABEL_10:
    unint64_t v21 = 0;
  }
  else
  {
    unint64_t v21 = 0;
    if (v18)
    {
      int v22 = 1 << (v18 - 1);
LABEL_4:
      uint64_t v23 = a5 + v10;
      switch((char)v22)
      {
        case 1:
          uint64_t v24 = *(unsigned __int8 *)(v23 + v19);
          goto LABEL_9;
        case 2:
          uint64_t v24 = *(unsigned __int16 *)(v23 + v19);
          goto LABEL_9;
        case 4:
          uint64_t v24 = *(unsigned int *)(v23 + v19);
          goto LABEL_9;
        case 8:
          uint64_t v24 = *(void *)(v23 + v19);
LABEL_9:
          unint64_t v25 = v24 - v14;
          if (v21) {
            goto LABEL_10;
          }
          goto LABEL_22;
        default:
          goto LABEL_49;
      }
    }
    unint64_t v25 = 0;
  }
LABEL_28:
  if (v25 < v13 || v21 < v13)
  {
    int v31 = (unint64_t *)((char *)v17 + v15);
    if (v25 < v13)
    {
      if (v21 >= v13)
      {
        size_t v42 = v10;
        if (v15 >= 1)
        {
          do
          {
            unint64_t v37 = *v17++;
            unint64_t v36 = v37;
            unint64_t v41 = v17;
            v42 += v37 & 0xFFFFFFFFFFFFFFLL;
            if (HIBYTE(v37))
            {
              (*(void (**)(void *, unint64_t **, size_t *, uint64_t))((char *)destroyTable
                                                                                     + ((v36 >> 53) & 0x7F8)))(v9, &v41, &v42, a4);
              uint64_t v17 = v41;
            }
          }
          while (v17 < v31);
        }
        int v31 = v17;
      }
      id result = memcpy((void *)(a4 + v10), (const void *)(a5 + v10), v16);
      v10 += v16;
      uint64_t v17 = v31;
    }
    else if (v15 >= 1)
    {
      do
      {
        unint64_t v33 = *v17++;
        unint64_t v32 = v33;
        unint64_t v41 = v17;
        size_t v34 = v40;
        size_t v35 = v33 & 0xFFFFFFFFFFFFFFLL;
        if ((v33 & 0xFFFFFFFFFFFFFFLL) != 0)
        {
          size_t v38 = v40;
          uint64_t v39 = v17;
          id result = memcpy((void *)(a4 + v40), (const void *)(a5 + v40), v35);
          size_t v34 = v38;
          uint64_t v17 = v39;
        }
        size_t v40 = v34 + v35;
        if (HIBYTE(v32))
        {
          id result = (void *)(*(uint64_t (**)(void *, unint64_t **, size_t *, uint64_t, uint64_t))((char *)initWithCopyTable + ((v32 >> 53) & 0x7F8)))(v9, &v41, &v40, a4, a5);
          uint64_t v17 = v41;
        }
      }
      while (v17 < v31);
      size_t v10 = v40;
    }
  }
  *a2 = v17;
  *a3 = v10;
  return result;
}

void *singlePayloadEnumFNAssignWithCopy(uint64_t a1, unint64_t **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = (uint64_t (*)(uint64_t))((char *)*a2 + *(int *)*a2);
  uint64_t v11 = (*a2)[1];
  size_t v10 = (*a2)[2];
  unint64_t v12 = *a2 + 3;
  uint64_t v24 = v12;
  unint64_t v13 = v9;
  int v14 = v9(a5 + *a3);
  id result = (void *)v13(a4 + *a3);
  if (v14 | result)
  {
    size_t v16 = (unint64_t *)((char *)v12 + v11);
    if (v14)
    {
      if (!result)
      {
        uint64_t v25 = *a3;
        if (v11 >= 1)
        {
          do
          {
            unint64_t v18 = *v12++;
            unint64_t v17 = v18;
            uint64_t v24 = v12;
            v25 += v18 & 0xFFFFFFFFFFFFFFLL;
            if (HIBYTE(v18))
            {
              (*(void (**)(uint64_t, unint64_t **, uint64_t *, uint64_t))((char *)destroyTable
                                                                                       + ((v17 >> 53) & 0x7F8)))(a1, &v24, &v25, a4);
              unint64_t v12 = v24;
            }
          }
          while (v12 < v16);
        }
        size_t v16 = v12;
      }
      id result = memcpy((void *)(a4 + *a3), (const void *)(a5 + *a3), v10);
      *a3 += v10;
      unint64_t v12 = v16;
    }
    else if (v11 >= 1)
    {
      do
      {
        unint64_t v20 = *v12++;
        unint64_t v19 = v20;
        uint64_t v24 = v12;
        uint64_t v21 = *a3;
        size_t v22 = v20 & 0xFFFFFFFFFFFFFFLL;
        if ((v20 & 0xFFFFFFFFFFFFFFLL) != 0) {
          id result = memcpy((void *)(a4 + v21), (const void *)(a5 + v21), v22);
        }
        *a3 = v21 + v22;
        if (HIBYTE(v19))
        {
          id result = (void *)(*(uint64_t (**)(uint64_t, unint64_t **, uint64_t *, uint64_t, uint64_t))((char *)initWithCopyTable + ((v19 >> 53) & 0x7F8)))(a1, &v24, a3, a4, a5);
          unint64_t v12 = v24;
        }
      }
      while (v12 < v16);
    }
  }
  *a2 = v12;
  return result;
}

void *singlePayloadEnumFNResolvedAssignWithCopy(uint64_t a1, unint64_t **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = (uint64_t (*)(uint64_t))**a2;
  uint64_t v10 = (*a2)[1];
  size_t v11 = (*a2)[2];
  unint64_t v12 = *a2 + 3;
  uint64_t v23 = v12;
  int v13 = v9(a5 + *a3);
  id result = (void *)v9(a4 + *a3);
  if (v13 | result)
  {
    uint64_t v15 = (unint64_t *)((char *)v12 + v10);
    if (v13)
    {
      if (!result)
      {
        uint64_t v24 = *a3;
        if (v10 >= 1)
        {
          do
          {
            unint64_t v17 = *v12++;
            unint64_t v16 = v17;
            uint64_t v23 = v12;
            v24 += v17 & 0xFFFFFFFFFFFFFFLL;
            if (HIBYTE(v17))
            {
              (*(void (**)(uint64_t, unint64_t **, uint64_t *, uint64_t))((char *)destroyTable
                                                                                       + ((v16 >> 53) & 0x7F8)))(a1, &v23, &v24, a4);
              unint64_t v12 = v23;
            }
          }
          while (v12 < v15);
        }
        uint64_t v15 = v12;
      }
      id result = memcpy((void *)(a4 + *a3), (const void *)(a5 + *a3), v11);
      *a3 += v11;
      unint64_t v12 = v15;
    }
    else if (v10 >= 1)
    {
      do
      {
        unint64_t v19 = *v12++;
        unint64_t v18 = v19;
        uint64_t v23 = v12;
        uint64_t v20 = *a3;
        size_t v21 = v19 & 0xFFFFFFFFFFFFFFLL;
        if ((v19 & 0xFFFFFFFFFFFFFFLL) != 0) {
          id result = memcpy((void *)(a4 + v20), (const void *)(a5 + v20), v21);
        }
        *a3 = v20 + v21;
        if (HIBYTE(v18))
        {
          id result = (void *)(*(uint64_t (**)(uint64_t, unint64_t **, uint64_t *, uint64_t, uint64_t))((char *)initWithCopyTable + ((v18 >> 53) & 0x7F8)))(a1, &v23, a3, a4, a5);
          unint64_t v12 = v23;
        }
      }
      while (v12 < v15);
    }
  }
  *a2 = v12;
  return result;
}

void *singlePayloadEnumGenericAssignWithCopy(void *result, char **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = result;
  unint64_t v10 = *(void *)*a2;
  uint64_t v9 = *((void *)*a2 + 1);
  uint64_t v11 = *((void *)*a2 + 2);
  uint64_t v12 = *(void *)(*a2 + 28);
  size_t v13 = *(void *)(*a2 + 36);
  int v14 = *a2 + 44;
  int v31 = v14;
  uint64_t v15 = v10;
  size_t __n = v13;
  if (!(v10 >> 62))
  {
    uint64_t v16 = 0;
    if (!v11)
    {
      uint64_t v18 = 0;
      goto LABEL_9;
    }
    uint64_t v17 = *a3;
LABEL_4:
    id result = (void *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)(v11 - 8) + 48))(a5 + v17 + v15, *(unsigned int *)(*(void *)(v11 - 8) + 84), v11);
    uint64_t v18 = result;
    goto LABEL_5;
  }
  int v27 = 1 << ((v10 >> 62) - 1);
  uint64_t v17 = *a3;
  uint64_t v28 = a5 + *a3;
  switch(v27)
  {
    case 1u:
      uint64_t v18 = *(unsigned __int8 *)(v28 + v9);
      uint64_t v16 = *(unsigned __int8 *)(a4 + v17 + v9);
      if (!v11) {
        goto LABEL_9;
      }
      break;
    case 2u:
      uint64_t v18 = *(unsigned __int16 *)(v28 + v9);
      uint64_t v16 = *(unsigned __int16 *)(a4 + v17 + v9);
      if (!v11) {
        goto LABEL_9;
      }
      break;
    case 4u:
      uint64_t v18 = *(unsigned int *)(v28 + v9);
      uint64_t v16 = *(unsigned int *)(a4 + v17 + v9);
      if (!v11) {
        goto LABEL_9;
      }
      break;
    default:
      abort();
  }
  if (!v18) {
    goto LABEL_4;
  }
LABEL_5:
  if (v16)
  {
    if (!v18) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }
  id result = (void *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)(v11 - 8) + 48))(a4 + *a3 + v15, *(unsigned int *)(*(void *)(v11 - 8) + 84), v11);
  uint64_t v16 = result;
LABEL_9:
  if (!(v18 | v16)) {
    goto LABEL_14;
  }
  if (v18)
  {
    if (!v16)
    {
      uint64_t v32 = *a3;
      if (v12 >= 1)
      {
        uint64_t v24 = &v14[v12];
        do
        {
          unint64_t v26 = *(void *)v14;
          v14 += 8;
          unint64_t v25 = v26;
          int v31 = v14;
          v32 += v26 & 0xFFFFFFFFFFFFFFLL;
          if (HIBYTE(v26))
          {
            (*(void (**)(void *, char **, uint64_t *, uint64_t))((char *)destroyTable + ((v25 >> 53) & 0x7F8)))(v8, &v31, &v32, a4);
            int v14 = v31;
          }
        }
        while (v14 < v24);
      }
      goto LABEL_13;
    }
LABEL_12:
    v14 += v12;
LABEL_13:
    id result = memcpy((void *)(a4 + *a3), (const void *)(a5 + *a3), __n);
    *a3 += __n;
    goto LABEL_14;
  }
LABEL_15:
  if (v12 >= 1)
  {
    unint64_t v19 = &v14[v12];
    do
    {
      unint64_t v21 = *(void *)v14;
      v14 += 8;
      unint64_t v20 = v21;
      int v31 = v14;
      uint64_t v22 = *a3;
      size_t v23 = v21 & 0xFFFFFFFFFFFFFFLL;
      if ((v21 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v22), (const void *)(a5 + v22), v23);
      }
      *a3 = v22 + v23;
      if (HIBYTE(v20))
      {
        id result = (void *)(*(uint64_t (**)(void *, char **, uint64_t *, uint64_t, uint64_t))((char *)initWithCopyTable
                                                                                                 + ((v20 >> 53) & 0x7F8)))(v8, &v31, a3, a4, a5);
        int v14 = v31;
      }
    }
    while (v14 < v19);
  }
LABEL_14:
  *a2 = v14;
  return result;
}

void *multiPayloadEnumFNAssignWithCopy(unint64_t *a1, int **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10 = (uint64_t (*)(void))((char *)*a2 + **a2);
  unint64_t v11 = *((void *)*a2 + 1);
  uint64_t v100 = *((void *)*a2 + 2);
  size_t __n = *((void *)*a2 + 3);
  uint64_t v12 = (uint64_t)(*a2 + 8);
  uint64_t v13 = *a3;
  uint64_t v107 = v13;
  int v14 = v10;
  __src = (void *)(a5 + v13);
  unsigned int v15 = v10();
  id result = (void *)((uint64_t (*)(uint64_t))v14)(a4 + *a3);
  uint64_t v20 = 8 * v11;
  *a2 = (int *)(v12 + v100 + 8 * v11);
  if (v11 > v15 && v11 > result)
  {
    *a3 += __n;
    uint64_t v22 = *(void *)(v12 + 8 * v15);
    v99 = a3;
    if (v15 == result)
    {
      v108 = (unint64_t *)(v12 + v22 + v20);
      uint64_t v24 = (uint64_t *)(v108 + 1);
      unint64_t v23 = *v108;
      uint64_t v25 = *v108 & 0xFFFFFFFFFFFFFFLL;
      if (v25) {
        id result = memcpy((void *)(a4 + v13), __src, v23 & 0xFFFFFFFFFFFFFFLL);
      }
      uint64_t v26 = v25 + v13;
      uint64_t v106 = v25 + v13;
      switch(HIBYTE(v23))
      {
        case 0u:
          break;
        case 1u:
          uint64_t v36 = *(void *)(a4 + v26);
          uint64_t v37 = *(void *)(a5 + v26);
          *(void *)(a4 + v26) = v37;
          uint64_t v38 = v26 + 8;
          uint64_t v106 = v26 + 8;
          if ((v36 & 0x8000000000000000) == 0) {
            swift_errorRelease((id)(v36 & 0xFFFFFFFFFFFFFF8));
          }
          if ((v37 & 0x8000000000000000) == 0) {
            swift_errorRetain((id)(v37 & 0xFFFFFFFFFFFFFF8));
          }
          uint64_t v39 = *v24;
          size_t v40 = *v24 & 0xFFFFFFFFFFFFFFLL;
          if (v40) {
            memcpy((void *)(a4 + v38), (const void *)(a5 + v38), v40);
          }
          uint64_t v106 = v40 + v38;
          __asm { BRAA            X9, X17 }
          return result;
        case 2u:
          uint64_t v41 = *(void *)(a4 + v26);
          uint64_t v42 = *(void *)(a5 + v26);
          *(void *)(a4 + v26) = v42;
          int v43 = (atomic_ullong *)(v42 & 0xFFFFFFFFFFFFFF8);
          uint64_t v44 = v26 + 8;
          uint64_t v106 = v26 + 8;
          swift_release(v41 & 0xFFFFFFFFFFFFFF8);
          swift_retain(v43);
          uint64_t v45 = *v24;
          size_t v46 = *v24 & 0xFFFFFFFFFFFFFFLL;
          if (v46) {
            memcpy((void *)(a4 + v44), (const void *)(a5 + v44), v46);
          }
          uint64_t v106 = v46 + v44;
          __asm { BRAA            X9, X17 }
          return result;
        case 3u:
          uint64_t v47 = *(void *)(a4 + v26);
          uint64_t v48 = *(void *)(a5 + v26);
          *(void *)(a4 + v26) = v48;
          uint64_t v49 = v48 & 0xFFFFFFFFFFFFFF8;
          uint64_t v50 = v26 + 8;
          uint64_t v106 = v26 + 8;
          swift_unownedRelease((atomic_ullong *)(v47 & 0xFFFFFFFFFFFFFF8));
          swift_unownedRetain(v49, v51, v52, v53);
          uint64_t v54 = *v24;
          size_t v55 = *v24 & 0xFFFFFFFFFFFFFFLL;
          if (v55) {
            memcpy((void *)(a4 + v50), (const void *)(a5 + v50), v55);
          }
          uint64_t v106 = v55 + v50;
          __asm { BRAA            X9, X17 }
          return result;
        case 4u:
          uint64_t v56 = v26 + 8;
          uint64_t v106 = v26 + 8;
          swift_weakCopyAssign((uint64_t *)(a4 + v26), (uint64_t *)(a5 + v26));
          uint64_t v57 = *v24;
          size_t v58 = *v24 & 0xFFFFFFFFFFFFFFLL;
          if (v58) {
            memcpy((void *)(a4 + v56), (const void *)(a5 + v56), v58);
          }
          uint64_t v106 = v58 + v56;
          __asm { BRAA            X9, X17 }
          return result;
        case 5u:
          v59 = *(void **)(a4 + v26);
          v60 = *(void **)(a5 + v26);
          *(void *)(a4 + v26) = v60;
          uint64_t v61 = v26 + 8;
          uint64_t v106 = v26 + 8;
          swift_unknownObjectRelease(v59);
          swift_unknownObjectRetain(v60);
          uint64_t v62 = *v24;
          size_t v63 = *v24 & 0xFFFFFFFFFFFFFFLL;
          if (v63) {
            memcpy((void *)(a4 + v61), (const void *)(a5 + v61), v63);
          }
          uint64_t v106 = v63 + v61;
          __asm { BRAA            X9, X17 }
          return result;
        case 6u:
          uint64_t v64 = v26 + 8;
          uint64_t v106 = v26 + 8;
          swift_unknownObjectUnownedCopyAssign((atomic_ullong **)(a4 + v26), (uint64_t *)(a5 + v26), v18, v19);
          uint64_t v65 = *v24;
          size_t v66 = *v24 & 0xFFFFFFFFFFFFFFLL;
          if (v66) {
            memcpy((void *)(a4 + v64), (const void *)(a5 + v64), v66);
          }
          uint64_t v106 = v66 + v64;
          __asm { BRAA            X9, X17 }
          return result;
        case 7u:
          uint64_t v67 = v26 + 8;
          uint64_t v106 = v26 + 8;
          swift_unknownObjectWeakCopyAssign((id *)(a4 + v26), (id *)(a5 + v26));
          uint64_t v68 = *v24;
          size_t v69 = *v24 & 0xFFFFFFFFFFFFFFLL;
          if (v69) {
            memcpy((void *)(a4 + v67), (const void *)(a5 + v67), v69);
          }
          uint64_t v106 = v69 + v67;
          __asm { BRAA            X9, X17 }
          return result;
        case 8u:
          uint64_t v70 = *(void *)(a4 + v26);
          unint64_t v71 = *(void *)(a5 + v26);
          *(void *)(a4 + v26) = v71;
          uint64_t v72 = v26 + 8;
          uint64_t v106 = v26 + 8;
          swift_bridgeObjectRelease(v70);
          swift_bridgeObjectRetain(v71);
          uint64_t v73 = *v24;
          size_t v74 = *v24 & 0xFFFFFFFFFFFFFFLL;
          if (v74) {
            memcpy((void *)(a4 + v72), (const void *)(a5 + v72), v74);
          }
          uint64_t v106 = v74 + v72;
          __asm { BRAA            X9, X17 }
          return result;
        case 9u:
          _Block_release(*(const void **)(a4 + v26));
          *(void *)(a4 + v26) = _Block_copy(*(const void **)(a5 + v26));
          uint64_t v75 = v26 + 8;
          uint64_t v106 = v26 + 8;
          uint64_t v76 = *v24;
          size_t v77 = *v24 & 0xFFFFFFFFFFFFFFLL;
          if (v77) {
            memcpy((void *)(a4 + v75), (const void *)(a5 + v75), v77);
          }
          uint64_t v106 = v77 + v75;
          __asm { BRAA            X9, X17 }
          return result;
        case 0xAu:
          uint64_t v78 = *(void *)(a4 + v26);
          uint64_t v79 = *(void *)(a5 + v26);
          *(void *)(a4 + v26) = v79;
          uint64_t v80 = v26 + 8;
          uint64_t v106 = v26 + 8;
          if ((v78 & 0x8000000000000000) == 0) {

          }
          if ((v79 & 0x8000000000000000) == 0) {
            id v81 = (id)(v79 & 0xFFFFFFFFFFFFFF8);
          }
          uint64_t v82 = *v24;
          size_t v83 = *v24 & 0xFFFFFFFFFFFFFFLL;
          if (v83) {
            memcpy((void *)(a4 + v80), (const void *)(a5 + v80), v83);
          }
          uint64_t v106 = v83 + v80;
          __asm { BRAA            X9, X17 }
          return result;
        case 0xBu:
        case 0xDu:
          abort();
        case 0xCu:
          uint64_t v84 = *(void *)(*v24 - 8);
          uint64_t v85 = *(void *)(v84 + 64) + v26;
          (*(void (**)(uint64_t, uint64_t))(v84 + 24))(a4 + v26, a5 + v26);
          unint64_t v86 = v108[2];
          if ((v86 & 0xFFFFFFFFFFFFFFLL) != 0) {
            memcpy((void *)(a4 + v85), (const void *)(a5 + v85), v86 & 0xFFFFFFFFFFFFFFLL);
          }
          uint64_t v106 = (v86 & 0xFFFFFFFFFFFFFFLL) + v85;
          __asm { BRAA            X9, X17 }
          return result;
        case 0xEu:
          existentialAssignWithCopy((uint64_t)result, v17, &v106, a4, a5);
          uint64_t v87 = *v24;
          uint64_t v88 = v106;
          size_t v89 = *v24 & 0xFFFFFFFFFFFFFFLL;
          if (v89) {
            memcpy((void *)(a4 + v106), (const void *)(a5 + v106), v89);
          }
          uint64_t v106 = v88 + v89;
          __asm { BRAA            X9, X17 }
          return result;
        case 0xFu:
          v90 = (uint64_t (*)(unint64_t *))((char *)v24 + *(int *)v24);
          GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a1);
          uint64_t v92 = *(void *)(v90(GenericArgs) - 8);
          uint64_t v93 = *(void *)(v92 + 64) + v26;
          (*(void (**)(uint64_t, uint64_t))(v92 + 24))(a4 + v26, a5 + v26);
          unint64_t v94 = v108[2];
          if ((v94 & 0xFFFFFFFFFFFFFFLL) != 0) {
            memcpy((void *)(a4 + v93), (const void *)(a5 + v93), v94 & 0xFFFFFFFFFFFFFFLL);
          }
          uint64_t v106 = (v94 & 0xFFFFFFFFFFFFFFLL) + v93;
          __asm { BRAA            X9, X17 }
          return result;
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
        case 0x14u:
        case 0x15u:
        case 0x16u:
          v104 = (uint64_t *)(v108 + 1);
          uint64_t v105 = v25 + v13;
          ((void (*)(unint64_t *, uint64_t **, uint64_t *, uint64_t, uint64_t))assignWithCopyTable[HIBYTE(v23)])(a1, &v104, &v105, a4, a5);
          uint64_t v95 = v105;
          uint64_t v96 = *v104;
          uint64_t v97 = *v104 & 0xFFFFFFFFFFFFFFLL;
          if (v97) {
            memcpy((void *)(a4 + v105), (const void *)(a5 + v105), *v104 & 0xFFFFFFFFFFFFFFLL);
          }
          uint64_t v106 = v97 + v95;
          __asm { BRAA            X9, X17 }
          return result;
      }
    }
    else
    {
      uint64_t v27 = *(void *)(v12 + 8 * result);
      v108 = (unint64_t *)(v12 + v22 + v20);
      uint64_t v28 = (unint64_t *)(v12 + v20 + v27);
      unint64_t v29 = *v28;
      v103 = v28 + 1;
      for (uint64_t i = (v29 & 0xFFFFFFFFFFFFFFLL) + v13; HIBYTE(v29); i += v29 & 0xFFFFFFFFFFFFFFLL)
      {
        id result = (void *)(*(uint64_t (**)(unint64_t *, unint64_t **, uint64_t *, uint64_t))((char *)destroyTable + ((v29 >> 53) & 0x7F8)))(a1, &v103, &i, a4);
        unint64_t v29 = *v103++;
      }
      while (1)
      {
        uint64_t v30 = v107;
        unint64_t v31 = *v108++;
        uint64_t v32 = v31 & 0xFFFFFFFFFFFFFFLL;
        if ((v31 & 0xFFFFFFFFFFFFFFLL) != 0) {
          id result = memcpy((void *)(a4 + v107), (const void *)(a5 + v107), v31 & 0xFFFFFFFFFFFFFFLL);
        }
        uint64_t v26 = v32 + v30;
        uint64_t v107 = v32 + v30;
        if (!HIBYTE(v31)) {
          break;
        }
        id result = (void *)(*(uint64_t (**)(unint64_t *, unint64_t **, uint64_t *, uint64_t, uint64_t))((char *)initWithCopyTable + ((v31 >> 53) & 0x7F8)))(a1, &v108, &v107, a4, a5);
      }
    }
    size_t v33 = *v99 - v26;
    if (*v99 != v26)
    {
      size_t v34 = (void *)(a4 + v26);
      size_t v35 = (const void *)(a5 + v26);
      return memcpy(v34, v35, v33);
    }
  }
  else
  {
    if (v11 > v15)
    {
      *a3 += __n;
      v108 = (unint64_t *)(v12 + v20 + *(void *)(v12 + 8 * v15));
      id result = handleRefCountsInitWithCopy(a1, &v108, &v107, a4, a5);
      size_t v33 = *a3 - v107;
      if (*a3 == v107) {
        return result;
      }
      size_t v34 = (void *)(a4 + v107);
      size_t v35 = (const void *)(a5 + v107);
      return memcpy(v34, v35, v33);
    }
    if (v11 > result)
    {
      v108 = (unint64_t *)(v12 + v20 + *(void *)(v12 + 8 * result));
      handleRefCountsDestroy((uint64_t)a1, &v108, &v107, a4);
    }
    id result = memcpy((void *)(a4 + *a3), (const void *)(a5 + *a3), __n);
    *a3 += __n;
  }
  return result;
}

void *multiPayloadEnumFNResolvedAssignWithCopy(void *a1, uint64_t (***a2)(uint64_t), uint64_t *a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10 = **a2;
  unint64_t v11 = (unint64_t)(*a2)[1];
  size_t __n = (size_t)(*a2)[3];
  uint64_t v28 = (*a2)[2];
  uint64_t v12 = (uint64_t)(*a2 + 4);
  uint64_t v13 = *a3;
  uint64_t v31 = v13;
  unsigned int v14 = v10(a5 + v13);
  id result = (void *)v10(a4 + *a3);
  uint64_t v16 = 8 * v11;
  *a2 = (uint64_t (**)(uint64_t))((char *)v28 + 8 * v11 + v12);
  if (v11 > v14 && v11 > result)
  {
    *a3 += __n;
    uint64_t v18 = *(void *)(v12 + 8 * result);
    uint64_t v19 = v12 + v16;
    uint64_t v32 = (unint64_t *)(v19 + *(void *)(v12 + 8 * v14));
    uint64_t v20 = (unint64_t *)(v19 + v18);
    unint64_t v21 = *v20;
    uint64_t v30 = v20 + 1;
    for (uint64_t i = (v21 & 0xFFFFFFFFFFFFFFLL) + v13; HIBYTE(v21); i += v21 & 0xFFFFFFFFFFFFFFLL)
    {
      id result = (void *)(*(uint64_t (**)(void *, unint64_t **, uint64_t *, uint64_t))((char *)destroyTable
                                                                                                  + ((v21 >> 53) & 0x7F8)))(a1, &v30, &i, a4);
      unint64_t v21 = *v30++;
    }
    while (1)
    {
      uint64_t v22 = v31;
      unint64_t v23 = *v32++;
      uint64_t v24 = v23 & 0xFFFFFFFFFFFFFFLL;
      if ((v23 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v31), (const void *)(a5 + v31), v23 & 0xFFFFFFFFFFFFFFLL);
      }
      uint64_t v25 = v24 + v22;
      uint64_t v31 = v24 + v22;
      if (!HIBYTE(v23)) {
        break;
      }
      id result = (void *)(*(uint64_t (**)(void *, unint64_t **, uint64_t *, uint64_t, uint64_t))((char *)initWithCopyTable + ((v23 >> 53) & 0x7F8)))(a1, &v32, &v31, a4, a5);
    }
    size_t v26 = *a3 - v25;
    if (*a3 != v25) {
      return memcpy((void *)(a4 + v25), (const void *)(a5 + v25), v26);
    }
  }
  else
  {
    if (v11 > v14)
    {
      *a3 += __n;
      uint64_t v32 = (unint64_t *)(v12 + v16 + *(void *)(v12 + 8 * v14));
      id result = handleRefCountsInitWithCopy(a1, &v32, &v31, a4, a5);
      uint64_t v25 = v31;
      size_t v26 = *a3 - v31;
      if (*a3 == v31) {
        return result;
      }
      return memcpy((void *)(a4 + v25), (const void *)(a5 + v25), v26);
    }
    if (v11 > result)
    {
      uint64_t v32 = (unint64_t *)(v12 + v16 + *(void *)(v12 + 8 * result));
      handleRefCountsDestroy((uint64_t)a1, &v32, &v31, a4);
    }
    id result = memcpy((void *)(a4 + *a3), (const void *)(a5 + *a3), __n);
    *a3 += __n;
  }
  return result;
}

void *multiPayloadEnumGenericAssignWithCopy(void *result, uint64_t **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a2;
  uint64_t v7 = **a2;
  unint64_t v6 = (*a2)[1];
  uint64_t v8 = (*a2)[2];
  size_t v9 = (*a2)[3];
  uint64_t v10 = *a3;
  uint64_t v36 = v10;
  int v11 = v7 - 1;
  unsigned int v15 = result;
  size_t v16 = v9 - v7;
  uint64_t v17 = a5 + v10;
  switch(v11)
  {
    case 0:
      unint64_t v18 = *(unsigned __int8 *)(v17 + v16);
      unint64_t v19 = *(unsigned __int8 *)(a4 + v10 + v16);
      break;
    case 1:
      unint64_t v18 = *(unsigned __int16 *)(v17 + v16);
      unint64_t v19 = *(unsigned __int16 *)(a4 + v10 + v16);
      break;
    case 3:
      unint64_t v18 = *(unsigned int *)(v17 + v16);
      unint64_t v19 = *(unsigned int *)(a4 + v10 + v16);
      break;
    case 7:
      unint64_t v18 = *(void *)(v17 + v16);
      unint64_t v19 = *(void *)(a4 + v10 + v16);
      break;
    default:
      abort();
  }
  uint64_t v20 = v5 + 4;
  uint64_t v21 = v6;
  *a2 = (void *)((char *)&v20[v6] + v8);
  if (v18 >= v6 || v19 >= v6)
  {
    if (v18 >= v6)
    {
      if (v19 < v6)
      {
        size_t v35 = (void *)((char *)&v20[v21] + v20[v19]);
        handleRefCountsDestroy((uint64_t)result, &v35, &v36, a4);
        uint64_t v10 = *a3;
      }
      id result = memcpy((void *)(a4 + v10), (const void *)(a5 + v10), v9);
      *a3 += v9;
    }
    else
    {
      *a3 = v10 + v9;
      size_t v35 = (void *)((char *)&v20[v21] + v20[v18]);
      id result = handleRefCountsInitWithCopy(result, &v35, &v36, a4, a5);
      uint64_t v31 = v36;
      size_t v32 = *a3 - v36;
      if (*a3 != v36) {
        return memcpy((void *)(a4 + v31), (const void *)(a5 + v31), v32);
      }
    }
  }
  else
  {
    *a3 = v10 + v9;
    uint64_t v23 = v20[v18];
    uint64_t v24 = v20[v19];
    uint64_t v25 = &v20[v21];
    size_t v35 = (void *)((char *)v25 + v23);
    size_t v26 = (void *)((char *)v25 + v24);
    unint64_t v27 = *v26;
    size_t v34 = v26 + 1;
    for (uint64_t i = (v27 & 0xFFFFFFFFFFFFFFLL) + v10; HIBYTE(v27); i += v27 & 0xFFFFFFFFFFFFFFLL)
    {
      id result = (void *)(*(uint64_t (**)(void *, unint64_t **, uint64_t *, uint64_t))((char *)destroyTable
                                                                                                  + ((v27 >> 53) & 0x7F8)))(v15, &v34, &i, a4);
      unint64_t v27 = *v34++;
    }
    while (1)
    {
      uint64_t v28 = v36;
      unint64_t v29 = *v35++;
      uint64_t v30 = v29 & 0xFFFFFFFFFFFFFFLL;
      if ((v29 & 0xFFFFFFFFFFFFFFLL) != 0) {
        id result = memcpy((void *)(a4 + v36), (const void *)(a5 + v36), v29 & 0xFFFFFFFFFFFFFFLL);
      }
      uint64_t v31 = v30 + v28;
      uint64_t v36 = v30 + v28;
      if (!HIBYTE(v29)) {
        break;
      }
      id result = (void *)(*(uint64_t (**)(void *, unint64_t **, uint64_t *, uint64_t, uint64_t))((char *)initWithCopyTable + ((v29 >> 53) & 0x7F8)))(v15, &v35, &v36, a4, a5);
    }
    size_t v32 = *a3 - v31;
    if (*a3 != v31) {
      return memcpy((void *)(a4 + v31), (const void *)(a5 + v31), v32);
    }
  }
  return result;
}

void std::__throw_bad_function_call[abi:nn180100]()
{
}

void std::__function::__func<swift_enumSimple_getEnumTag::$_0,std::allocator<swift_enumSimple_getEnumTag::$_0>,std::optional<unsigned int> ()(unsigned long,unsigned long,unsigned char)>::~__func()
{
}

void *std::__function::__func<swift_enumSimple_getEnumTag::$_0,std::allocator<swift_enumSimple_getEnumTag::$_0>,std::optional<unsigned int> ()(unsigned long,unsigned long,unsigned char)>::__clone(uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *id result = &unk_1ECA03F90;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<swift_enumSimple_getEnumTag::$_0,std::allocator<swift_enumSimple_getEnumTag::$_0>,std::optional<unsigned int> ()(unsigned long,unsigned long,unsigned char)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ECA03F90;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<swift_enumSimple_getEnumTag::$_0,std::allocator<swift_enumSimple_getEnumTag::$_0>,std::optional<unsigned int> ()(unsigned long,unsigned long,unsigned char)>::operator()(uint64_t a1, void *a2, unint64_t *a3, unsigned char *a4)
{
  unint64_t v4 = *a3;
  uint64_t v5 = *(unsigned __int8 **)(a1 + 8);
  switch(*a4)
  {
    case 1:
      LODWORD(v6) = v5[v4];
      if (!v5[v4]) {
        return 0;
      }
      goto LABEL_7;
    case 2:
      LODWORD(v6) = *(unsigned __int16 *)&v5[v4];
      if (!*(_WORD *)&v5[v4]) {
        return 0;
      }
      goto LABEL_7;
    case 4:
      LODWORD(v6) = *(_DWORD *)&v5[v4];
      if (!v6) {
        return 0;
      }
      goto LABEL_7;
    case 8:
      uint64_t v6 = *(void *)&v5[v4];
      if (!v6) {
        return 0;
      }
LABEL_7:
      unint64_t v7 = (unint64_t)(v6 - 1) << (8 * v4);
      if (v4 > 3) {
        LODWORD(v7) = 0;
      }
      int v8 = 0;
      switch(v4)
      {
        case 0uLL:
          return (*a2 + (v8 | v7) + 1) | 0x100000000;
        case 1uLL:
          int v8 = *v5;
          break;
        case 2uLL:
          int v8 = *(unsigned __int16 *)v5;
          break;
        case 3uLL:
          int v8 = *(unsigned __int16 *)v5 | (v5[2] << 16);
          break;
        default:
          int v8 = *(_DWORD *)v5;
          break;
      }
      return (*a2 + (v8 | v7) + 1) | 0x100000000;
    default:
      abort();
  }
}

void std::__function::__func<swift_enumSimple_getEnumTag::$_1,std::allocator<swift_enumSimple_getEnumTag::$_1>,unsigned int ()(unsigned long,unsigned long long,unsigned char,unsigned int,unsigned long,unsigned char)>::~__func()
{
}

void *std::__function::__func<swift_enumSimple_getEnumTag::$_1,std::allocator<swift_enumSimple_getEnumTag::$_1>,unsigned int ()(unsigned long,unsigned long long,unsigned char,unsigned int,unsigned long,unsigned char)>::__clone(uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *id result = &unk_1ECA03FD8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<swift_enumSimple_getEnumTag::$_1,std::allocator<swift_enumSimple_getEnumTag::$_1>,unsigned int ()(unsigned long,unsigned long long,unsigned char,unsigned int,unsigned long,unsigned char)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ECA03FD8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<swift_enumSimple_getEnumTag::$_1,std::allocator<swift_enumSimple_getEnumTag::$_1>,unsigned int ()(unsigned long,unsigned long long,unsigned char,unsigned int,unsigned long,unsigned char)>::operator()(uint64_t a1, unint64_t *a2, void *a3, unsigned char *a4, unsigned int *a5)
{
  if (!*a4) {
    return 0;
  }
  uint64_t v5 = *a5;
  uint64_t v6 = *(void *)(a1 + 8);
  switch((1 << (*a4 - 1)))
  {
    case 1u:
      uint64_t v7 = *(unsigned __int8 *)(v6 + v5);
      break;
    case 2u:
      uint64_t v7 = *(unsigned __int16 *)(v6 + v5);
      break;
    case 4u:
      uint64_t v7 = *(unsigned int *)(v6 + v5);
      break;
    case 8u:
      uint64_t v7 = *(void *)(v6 + v5);
      break;
    default:
      abort();
  }
  unint64_t v8 = v7 - *a3;
  if (v8 < *a2) {
    return (v8 + 1);
  }
  else {
    return 0;
  }
}

void std::__function::__func<swift_enumSimple_destructiveInjectEnumTag::$_0,std::allocator<swift_enumSimple_destructiveInjectEnumTag::$_0>,std::optional<BOOL> ()(unsigned long,unsigned long,unsigned char)>::~__func()
{
}

__n128 std::__function::__func<swift_enumSimple_destructiveInjectEnumTag::$_0,std::allocator<swift_enumSimple_destructiveInjectEnumTag::$_0>,std::optional<BOOL> ()(unsigned long,unsigned long,unsigned char)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ECA04020;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<swift_enumSimple_destructiveInjectEnumTag::$_0,std::allocator<swift_enumSimple_destructiveInjectEnumTag::$_0>,std::optional<BOOL> ()(unsigned long,unsigned long,unsigned char)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECA04020;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<swift_enumSimple_destructiveInjectEnumTag::$_0,std::allocator<swift_enumSimple_destructiveInjectEnumTag::$_0>,std::optional<BOOL> ()(unsigned long,unsigned long,unsigned char)>::operator()(uint64_t a1, unint64_t *a2, uint64_t *a3, unsigned __int8 *a4)
{
  unint64_t v4 = *(unsigned int *)(a1 + 16);
  if (*a2 < v4)
  {
    uint64_t v6 = *a3;
    uint64_t v7 = *a4;
    unsigned int v8 = v4 + ~*a2;
    if ((unint64_t)*a3 <= 3)
    {
      int v9 = (v8 >> (8 * v6)) + 1;
      if (!v6)
      {
LABEL_15:
        if (v7)
        {
LABEL_16:
          uint64_t v12 = (unsigned char *)(*(void *)(a1 + 8) + v6);
          switch((int)v7)
          {
            case 1:
              unsigned char *v12 = v9;
              break;
            case 2:
              *(_WORD *)uint64_t v12 = v9;
              break;
            case 3:
              *(_WORD *)uint64_t v12 = v9;
              _OWORD v12[2] = BYTE2(v9);
              break;
            case 4:
              *(_DWORD *)uint64_t v12 = v9;
              break;
            default:
              *(_DWORD *)uint64_t v12 = v9;
              bzero(v12 + 4, v7 - 4);
              break;
          }
        }
        goto LABEL_24;
      }
      v8 &= ~(-1 << (8 * v6));
    }
    else
    {
      int v9 = 1;
    }
    int v11 = *(unsigned char **)(a1 + 8);
    switch(v6)
    {
      case 1:
        unsigned char *v11 = v8;
        if (v7) {
          goto LABEL_16;
        }
        break;
      case 2:
        *(_WORD *)int v11 = v8;
        if (v7) {
          goto LABEL_16;
        }
        break;
      case 3:
        *(_WORD *)int v11 = v8;
        v11[2] = BYTE2(v8);
        goto LABEL_15;
      case 4:
        *(_DWORD *)int v11 = v8;
        if (v7) {
          goto LABEL_16;
        }
        break;
      default:
        *(_DWORD *)int v11 = v8;
        bzero(v11 + 4, v6 - 4);
        if (v7) {
          goto LABEL_16;
        }
        break;
    }
LABEL_24:
    int v10 = 1;
    return v10 | (v10 << 8);
  }
  int v10 = 0;
  return v10 | (v10 << 8);
}

void std::__function::__func<swift_enumSimple_destructiveInjectEnumTag::$_1,std::allocator<swift_enumSimple_destructiveInjectEnumTag::$_1>,BOOL ()(unsigned long,unsigned long long,unsigned char,unsigned int,unsigned long,unsigned char)>::~__func()
{
}

__n128 std::__function::__func<swift_enumSimple_destructiveInjectEnumTag::$_1,std::allocator<swift_enumSimple_destructiveInjectEnumTag::$_1>,BOOL ()(unsigned long,unsigned long long,unsigned char,unsigned int,unsigned long,unsigned char)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ECA04068;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<swift_enumSimple_destructiveInjectEnumTag::$_1,std::allocator<swift_enumSimple_destructiveInjectEnumTag::$_1>,BOOL ()(unsigned long,unsigned long long,unsigned char,unsigned int,unsigned long,unsigned char)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECA04068;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<swift_enumSimple_destructiveInjectEnumTag::$_1,std::allocator<swift_enumSimple_destructiveInjectEnumTag::$_1>,BOOL ()(unsigned long,unsigned long long,unsigned char,unsigned int,unsigned long,unsigned char)>::operator()(uint64_t a1, unint64_t *a2, uint64_t *a3, char *a4, unsigned int *a5, void *a6, unsigned char *a7)
{
  char v7 = *a4;
  if (*a4)
  {
    unint64_t v9 = *(unsigned int *)(a1 + 16);
    if (*a2 >= v9)
    {
      uint64_t v10 = *a3;
      uint64_t v11 = *a5;
      uint64_t v12 = *a7;
      if (*a7)
      {
        uint64_t v13 = (unsigned char *)(*(void *)(a1 + 8) + *a6);
        switch(*a7)
        {
          case 1:
            *uint64_t v13 = 0;
            break;
          case 2:
            *(_WORD *)uint64_t v13 = 0;
            break;
          case 3:
            v13[2] = 0;
            *(_WORD *)uint64_t v13 = 0;
            break;
          case 4:
            *(_DWORD *)uint64_t v13 = 0;
            break;
          default:
            *(_DWORD *)uint64_t v13 = 0;
            bzero(v13 + 4, v12 - 4);
            break;
        }
        LODWORD(v9) = *(_DWORD *)(a1 + 16);
      }
      if (v9)
      {
        unsigned int v14 = (unsigned char *)(*(void *)(a1 + 8) + v11);
        int v15 = v10 + v9 - 1;
        switch(1 << (v7 - 1))
        {
          case 0:
            return 1;
          case 1:
            unsigned char *v14 = v15;
            break;
          case 2:
            *(_WORD *)unsigned int v14 = v15;
            break;
          case 3:
            *(_WORD *)unsigned int v14 = v15;
            v14[2] = BYTE2(v15);
            break;
          case 4:
            *(_DWORD *)unsigned int v14 = v15;
            break;
          default:
            *(_DWORD *)unsigned int v14 = v15;
            bzero(v14 + 4, (size_t)a2);
            break;
        }
      }
    }
  }
  return 1;
}

void std::__function::__func<swift_singlePayloadEnumGeneric_getEnumTag::$_0,std::allocator<swift_singlePayloadEnumGeneric_getEnumTag::$_0>,std::optional<unsigned int> ()(swift::TargetMetadata<swift::InProcess> const*,unsigned long,unsigned char)>::~__func()
{
}

void *std::__function::__func<swift_singlePayloadEnumGeneric_getEnumTag::$_0,std::allocator<swift_singlePayloadEnumGeneric_getEnumTag::$_0>,std::optional<unsigned int> ()(swift::TargetMetadata<swift::InProcess> const*,unsigned long,unsigned char)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1ECA040B0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<swift_singlePayloadEnumGeneric_getEnumTag::$_0,std::allocator<swift_singlePayloadEnumGeneric_getEnumTag::$_0>,std::optional<unsigned int> ()(swift::TargetMetadata<swift::InProcess> const*,unsigned long,unsigned char)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ECA040B0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<swift_singlePayloadEnumGeneric_getEnumTag::$_0,std::allocator<swift_singlePayloadEnumGeneric_getEnumTag::$_0>,std::optional<unsigned int> ()(swift::TargetMetadata<swift::InProcess> const*,unsigned long,unsigned char)>::operator()(uint64_t a1, uint64_t *a2, unint64_t *a3, unsigned char *a4)
{
  uint64_t v4 = *a2;
  unint64_t v5 = *a3;
  uint64_t v6 = *(unsigned __int8 **)(a1 + 8);
  switch(*a4)
  {
    case 1:
      LODWORD(v7) = v6[v5];
      if (!v6[v5]) {
        return 0;
      }
      goto LABEL_7;
    case 2:
      LODWORD(v7) = *(unsigned __int16 *)&v6[v5];
      if (!*(_WORD *)&v6[v5]) {
        return 0;
      }
      goto LABEL_7;
    case 4:
      LODWORD(v7) = *(_DWORD *)&v6[v5];
      if (!v7) {
        return 0;
      }
      goto LABEL_7;
    case 8:
      uint64_t v7 = *(void *)&v6[v5];
      if (!v7) {
        return 0;
      }
LABEL_7:
      if (v4) {
        int v8 = *(_DWORD *)(*(void *)(v4 - 8) + 84) + 1;
      }
      else {
        int v8 = 1;
      }
      unint64_t v10 = (unint64_t)(v7 - 1) << (8 * v5);
      if (v5 > 3) {
        LODWORD(v1swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
      }
      int v11 = 0;
      switch(v5)
      {
        case 0uLL:
          return ((v11 | v10) + v8) | 0x100000000;
        case 1uLL:
          int v11 = *v6;
          break;
        case 2uLL:
          int v11 = *(unsigned __int16 *)v6;
          break;
        case 3uLL:
          int v11 = *(unsigned __int16 *)v6 | (v6[2] << 16);
          break;
        default:
          int v11 = *(_DWORD *)v6;
          break;
      }
      return ((v11 | v10) + v8) | 0x100000000;
    default:
      abort();
  }
}

void std::__function::__func<swift_singlePayloadEnumGeneric_getEnumTag::$_1,std::allocator<swift_singlePayloadEnumGeneric_getEnumTag::$_1>,unsigned int ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int,unsigned int,unsigned long,unsigned char)>::~__func()
{
}

void *std::__function::__func<swift_singlePayloadEnumGeneric_getEnumTag::$_1,std::allocator<swift_singlePayloadEnumGeneric_getEnumTag::$_1>,unsigned int ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int,unsigned int,unsigned long,unsigned char)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1ECA040F8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<swift_singlePayloadEnumGeneric_getEnumTag::$_1,std::allocator<swift_singlePayloadEnumGeneric_getEnumTag::$_1>,unsigned int ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int,unsigned int,unsigned long,unsigned char)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ECA040F8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<swift_singlePayloadEnumGeneric_getEnumTag::$_1,std::allocator<swift_singlePayloadEnumGeneric_getEnumTag::$_1>,unsigned int ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int,unsigned int,unsigned long,unsigned char)>::operator()(uint64_t a1, void *a2, unsigned int *a3)
{
  if (*a2) {
    return (*(uint64_t (**)(void, void))(*(void *)(*a2 - 8) + 48))(*(void *)(a1 + 8) + *a3, *(unsigned int *)(*(void *)(*a2 - 8) + 84));
  }
  else {
    return 0;
  }
}

void std::__function::__func<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_0,std::allocator<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_0>,std::optional<BOOL> ()(swift::TargetMetadata<swift::InProcess> const*,unsigned long,unsigned char)>::~__func()
{
}

__n128 std::__function::__func<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_0,std::allocator<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_0>,std::optional<BOOL> ()(swift::TargetMetadata<swift::InProcess> const*,unsigned long,unsigned char)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ECA04140;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_0,std::allocator<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_0>,std::optional<BOOL> ()(swift::TargetMetadata<swift::InProcess> const*,unsigned long,unsigned char)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECA04140;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_0,std::allocator<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_0>,std::optional<BOOL> ()(swift::TargetMetadata<swift::InProcess> const*,unsigned long,unsigned char)>::operator()(uint64_t a1, uint64_t *a2, unint64_t *a3, unsigned __int8 *a4)
{
  uint64_t v5 = *a2;
  unint64_t v6 = *a3;
  uint64_t v7 = *a4;
  if (*a2) {
    LODWORD(v5) = *(_DWORD *)(*(void *)(v5 - 8) + 84);
  }
  unsigned int v8 = *(_DWORD *)(a1 + 8);
  if (v8 > v5)
  {
    unsigned int v9 = v8 + ~v5;
    if (v6 <= 3)
    {
      int v10 = (v9 >> (8 * v6)) + 1;
      if (!v6)
      {
LABEL_17:
        if (v7)
        {
LABEL_18:
          uint64_t v13 = (unsigned char *)(*(void *)(a1 + 16) + v6);
          switch((int)v7)
          {
            case 1:
              *uint64_t v13 = v10;
              break;
            case 2:
              *(_WORD *)uint64_t v13 = v10;
              break;
            case 3:
              *(_WORD *)uint64_t v13 = v10;
              v13[2] = BYTE2(v10);
              break;
            case 4:
              *(_DWORD *)uint64_t v13 = v10;
              break;
            default:
              *(_DWORD *)uint64_t v13 = v10;
              bzero(v13 + 4, v7 - 4);
              break;
          }
        }
        goto LABEL_26;
      }
      v9 &= ~(-1 << (8 * v6));
    }
    else
    {
      int v10 = 1;
    }
    uint64_t v12 = *(unsigned char **)(a1 + 16);
    switch(v6)
    {
      case 1uLL:
        unsigned char *v12 = v9;
        if (v7) {
          goto LABEL_18;
        }
        break;
      case 2uLL:
        *(_WORD *)uint64_t v12 = v9;
        if (v7) {
          goto LABEL_18;
        }
        break;
      case 3uLL:
        *(_WORD *)uint64_t v12 = v9;
        _OWORD v12[2] = BYTE2(v9);
        goto LABEL_17;
      case 4uLL:
        *(_DWORD *)uint64_t v12 = v9;
        if (v7) {
          goto LABEL_18;
        }
        break;
      default:
        *(_DWORD *)uint64_t v12 = v9;
        bzero(v12 + 4, v6 - 4);
        if (v7) {
          goto LABEL_18;
        }
        break;
    }
LABEL_26:
    int v11 = 1;
    return v11 | (v11 << 8);
  }
  int v11 = 0;
  return v11 | (v11 << 8);
}

void std::__function::__func<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_1,std::allocator<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_1>,BOOL ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int,unsigned int,unsigned long,unsigned char)>::~__func()
{
}

__n128 std::__function::__func<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_1,std::allocator<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_1>,BOOL ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int,unsigned int,unsigned long,unsigned char)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ECA04188;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_1,std::allocator<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_1>,BOOL ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int,unsigned int,unsigned long,unsigned char)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECA04188;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_1,std::allocator<swift_singlePayloadEnumGeneric_destructiveInjectEnumTag::$_1>,BOOL ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int,unsigned int,unsigned long,unsigned char)>::operator()(uint64_t a1, uint64_t *a2, unsigned int *a3, uint64_t a4, void *a5, unsigned char *a6)
{
  uint64_t v7 = *a2;
  uint64_t v8 = *a3;
  uint64_t v9 = *a6;
  if (*a2) {
    unsigned int v10 = *(_DWORD *)(*(void *)(v7 - 8) + 84);
  }
  else {
    unsigned int v10 = 0;
  }
  unsigned int v11 = *(_DWORD *)(a1 + 8);
  if (v11 <= v10)
  {
    if (*a6)
    {
      uint64_t v12 = (unsigned char *)(*(void *)(a1 + 16) + *a5);
      switch(*a6)
      {
        case 1:
          unsigned char *v12 = 0;
          break;
        case 2:
          *(_WORD *)uint64_t v12 = 0;
          break;
        case 3:
          _OWORD v12[2] = 0;
          *(_WORD *)uint64_t v12 = 0;
          break;
        case 4:
          *(_DWORD *)uint64_t v12 = 0;
          break;
        default:
          *(_DWORD *)uint64_t v12 = 0;
          bzero(v12 + 4, v9 - 4);
          break;
      }
      unsigned int v11 = *(_DWORD *)(a1 + 8);
    }
    if (v11)
    {
      if (*(void *)(v7 - 8)) {
        uint64_t v13 = *(void *)(v7 - 8);
      }
      else {
        uint64_t v13 = 0;
      }
      (*(void (**)(uint64_t))(v13 + 56))(*(void *)(a1 + 16) + v8);
    }
  }
  return 1;
}

std::string *swift::nameForMetadata@<X0>(std::string *__return_ptr a1@<X8>, Class *cls@<X0>, char a3@<W1>)
{
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  Class v4 = *cls;
  if ((unint64_t)*cls > 0x7FF) {
    LODWORD(v4) = 0;
  }
  if (v4 == 773)
  {
    class_getName(cls[1]);
    JUMPOUT(0x1852FEF20);
  }
  if (v4)
  {
LABEL_18:
    v24[1] = 0;
    void v24[2] = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 2400;
    uint64_t v27 = 0;
    char v28 = 0;
    size_t v63 = 0;
    v24[0] = &unk_1ECA07790;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    char v32 = 0;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    int v61 = 0;
    unsigned int v10 = (uint64_t *)_swift_buildDemanglingForMetadata((uint64_t)cls, (swift::Demangle::__runtime::NodeFactory *)v24);
    if (v10)
    {
      v14[0] = 0;
      uint64_t v15 = 0x101010101010101;
      uint64_t v16 = 0x101010100000000;
      char v17 = 1;
      __int16 v18 = 256;
      char v19 = 1;
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      v22[0] = &unk_1ECA041D0;
      v22[1] = swift::Demangle::__runtime::genericParameterName;
      uint64_t v23 = v22;
      v14[1] = a3;
      if ((a3 & 1) == 0) {
        BYTE4(v16) = 0;
      }
      swift::Demangle::__runtime::nodeToString((uint64_t *)&v12, v10, (swift::Demangle::__runtime::Node *)v14, v11);
      if (SHIBYTE(a1->__r_.__value_.__r.__words[2]) < 0) {
        operator delete(a1->__r_.__value_.__l.__data_);
      }
      *(_OWORD *)&a1->__r_.__value_.__l.__data_ = v12;
      a1->__r_.__value_.__r.__words[2] = v13;
      if (v23 == v22)
      {
        (*(void (**)(void *))(v22[0] + 32))(v22);
      }
      else if (v23)
      {
        (*(void (**)(void))(*v23 + 40))();
      }
    }
    else
    {
      MEMORY[0x1852FEF20](a1, "<<< invalid type >>>");
    }
    v24[0] = &unk_1ECA07790;
    if (v63 == v62)
    {
      (*(void (**)(void *))(v62[0] + 32))(v62);
    }
    else if (v63)
    {
      (*(void (**)(void))(*v63 + 40))();
    }
    v24[0] = &unk_1ECA07768;
    __n128 result = (std::string *)swift::Demangle::__runtime::NodeFactory::freeSlabs(v25);
    if (v27) {
      *(unsigned char *)(v27 + 48) = 0;
    }
    return result;
  }
  if (((_BYTE)cls[4] & 2) != 0)
  {
    unint64_t v6 = cls;
    while (!v6[8])
    {
      Class v7 = v6[1];
      if (v7)
      {
        unint64_t v6 = (Class *)v6[1];
        if ((*((unsigned char *)v7 + 32) & 2) == 0) {
          goto LABEL_15;
        }
      }
      else
      {
        unint64_t v6 = 0;
        if ((MEMORY[0x20] & 2) == 0) {
          goto LABEL_15;
        }
      }
    }
    goto LABEL_18;
  }
  unint64_t v6 = cls;
LABEL_15:
  Name = class_getName((Class)v6);

  return std::string::append(a1, Name);
}

std::string *swift::MetadataOrPack::nameForMetadata@<X0>(std::string **this@<X0>, uint64_t a2@<X8>)
{
  __n128 result = *this;
  if (result)
  {
    if (result)
    {
      *(unsigned char *)(a2 + 23) = 5;
      strcpy((char *)a2, "Pack{");
      Class v4 = (Class *)((unint64_t)result & 0xFFFFFFFFFFFFFFFELL);
      uint64_t v5 = *(void *)(((unint64_t)result & 0xFFFFFFFFFFFFFFFELL) - 8);
      if (v5)
      {
        swift::nameForMetadata((uint64_t *)&__p, *v4);
        if ((v14 & 0x80u) == 0) {
          p_p = (const std::string::value_type *)&__p;
        }
        else {
          p_p = (const std::string::value_type *)__p;
        }
        if ((v14 & 0x80u) == 0) {
          std::string::size_type v7 = v14;
        }
        else {
          std::string::size_type v7 = v13;
        }
        std::string::append((std::string *)a2, p_p, v7);
        if ((char)v14 < 0) {
          operator delete(__p);
        }
        uint64_t v8 = v5 - 1;
        if (v8)
        {
          uint64_t v9 = v4 + 1;
          do
          {
            std::string::append((std::string *)a2, ", ");
            swift::nameForMetadata((uint64_t *)&__p, *v9);
            if ((v14 & 0x80u) == 0) {
              unsigned int v10 = (const std::string::value_type *)&__p;
            }
            else {
              unsigned int v10 = (const std::string::value_type *)__p;
            }
            if ((v14 & 0x80u) == 0) {
              std::string::size_type v11 = v14;
            }
            else {
              std::string::size_type v11 = v13;
            }
            std::string::append((std::string *)a2, v10, v11);
            if ((char)v14 < 0) {
              operator delete(__p);
            }
            ++v9;
            --v8;
          }
          while (v8);
        }
      }
      return std::string::append((std::string *)a2, "}");
    }
    else
    {
      return (std::string *)swift::nameForMetadata((uint64_t *)a2, (Class)result);
    }
  }
  else
  {
    *(unsigned char *)(a2 + 23) = 11;
    strcpy((char *)a2, "<<nullptr>>");
  }
  return result;
}

unsigned char *swift_getTypeName(Class *a1, char a2)
{
  uint64_t v4 = 2;
  if ((a2 & 1) == 0) {
    uint64_t v4 = 0;
  }
  unint64_t v5 = v4 | (unint64_t)a1 & 0xFFFFFFFFFFFFFFF9;
  if (qword_1EB1F8750 != -1) {
    dispatch_once_f(&qword_1EB1F8750, &TypeNameCache, (dispatch_function_t)swift::Lazy<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>>::defaultInitCallback);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&TypeNameCacheLock);
  if (dword_1EB1F8748)
  {
    unsigned int v6 = (dword_1EB1F8748 - 1) & (v5 ^ ((unint64_t)a1 >> 9));
    std::string::size_type v7 = (uint64_t *)(TypeNameCache + 24 * v6);
    uint64_t v8 = *v7;
    if (v5 == *v7) {
      goto LABEL_12;
    }
    int v9 = 1;
    while (v8 != -2)
    {
      unsigned int v10 = v6 + v9++;
      unsigned int v6 = v10 & (dword_1EB1F8748 - 1);
      std::string::size_type v7 = (uint64_t *)(TypeNameCache + 24 * v6);
      uint64_t v8 = *v7;
      if (v5 == *v7) {
        goto LABEL_12;
      }
    }
  }
  std::string::size_type v7 = (uint64_t *)(TypeNameCache + 24 * dword_1EB1F8748);
LABEL_12:
  if (v7 != (uint64_t *)(TypeNameCache + 24 * dword_1EB1F8748))
  {
LABEL_21:
    uint64_t v15 = (unsigned char *)v7[1];
    goto LABEL_22;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&TypeNameCacheLock);
  os_unfair_lock_lock((os_unfair_lock_t)&TypeNameCacheLock);
  if (dword_1EB1F8748)
  {
    unsigned int v11 = (dword_1EB1F8748 - 1) & (v5 ^ ((unint64_t)a1 >> 9));
    std::string::size_type v7 = (uint64_t *)(TypeNameCache + 24 * v11);
    uint64_t v12 = *v7;
    if (v5 == *v7) {
      goto LABEL_20;
    }
    int v13 = 1;
    while (v12 != -2)
    {
      unsigned int v14 = v11 + v13++;
      unsigned int v11 = v14 & (dword_1EB1F8748 - 1);
      std::string::size_type v7 = (uint64_t *)(TypeNameCache + 24 * v11);
      uint64_t v12 = *v7;
      if (v5 == *v7) {
        goto LABEL_20;
      }
    }
  }
  std::string::size_type v7 = (uint64_t *)(TypeNameCache + 24 * dword_1EB1F8748);
LABEL_20:
  if (v7 != (uint64_t *)(TypeNameCache + 24 * dword_1EB1F8748)) {
    goto LABEL_21;
  }
  swift::nameForMetadata(&__p, a1, a2 & 1);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  __int16 v18 = malloc_type_malloc(size + 1, 0x5FBDE9BDuLL);
  uint64_t v15 = v18;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  memcpy(v18, p_p, size);
  v15[size] = 0;
  unint64_t v28 = v5;
  *(void *)&long long v29 = v15;
  *((void *)&v29 + 1) = size;
  if (dword_1EB1F8748)
  {
    unsigned int v20 = (dword_1EB1F8748 - 1) & (v5 ^ ((unint64_t)a1 >> 9));
    uint64_t v21 = (void *)(TypeNameCache + 24 * v20);
    uint64_t v22 = *v21;
    if (v5 == *v21) {
      goto LABEL_42;
    }
    uint64_t v23 = 0;
    int v24 = 1;
    while (v22 != -2)
    {
      if (v23) {
        BOOL v25 = 0;
      }
      else {
        BOOL v25 = v22 == -16;
      }
      if (v25) {
        uint64_t v23 = v21;
      }
      unsigned int v26 = v20 + v24++;
      unsigned int v20 = v26 & (dword_1EB1F8748 - 1);
      uint64_t v21 = (void *)(TypeNameCache + 24 * v20);
      uint64_t v22 = *v21;
      if (v5 == *v21) {
        goto LABEL_42;
      }
    }
    if (v23) {
      uint64_t v27 = (uint64_t)v23;
    }
    else {
      uint64_t v27 = (uint64_t)v21;
    }
  }
  else
  {
    uint64_t v27 = 0;
  }
  __swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>,__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>::InsertIntoBucket<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>((uint64_t)&TypeNameCache, v27, (uint64_t *)&v28, &v29);
LABEL_42:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
LABEL_22:
  os_unfair_lock_unlock((os_unfair_lock_t)&TypeNameCacheLock);
  return v15;
}

uint64_t swift::Lazy<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>>::defaultInitCallback(uint64_t result)
{
  *(void *)__n128 result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

unsigned char *swift_getMangledTypeName(unint64_t a1)
{
  unint64_t v2 = a1 & 0xFFFFFFFFFFFFFFF9 | 4;
  if (qword_1EB1F8750 != -1) {
    dispatch_once_f(&qword_1EB1F8750, &TypeNameCache, (dispatch_function_t)swift::Lazy<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>>::defaultInitCallback);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&TypeNameCacheLock);
  if (dword_1EB1F8748)
  {
    unsigned int v3 = (dword_1EB1F8748 - 1) & (v2 ^ (a1 >> 9));
    uint64_t v4 = (uint64_t *)(TypeNameCache + 24 * v3);
    uint64_t v5 = *v4;
    if (v2 == *v4) {
      goto LABEL_10;
    }
    int v6 = 1;
    while (v5 != -2)
    {
      unsigned int v7 = v3 + v6++;
      unsigned int v3 = v7 & (dword_1EB1F8748 - 1);
      uint64_t v4 = (uint64_t *)(TypeNameCache + 24 * v3);
      uint64_t v5 = *v4;
      if (v2 == *v4) {
        goto LABEL_10;
      }
    }
  }
  uint64_t v4 = (uint64_t *)(TypeNameCache + 24 * dword_1EB1F8748);
LABEL_10:
  if (v4 != (uint64_t *)(TypeNameCache + 24 * dword_1EB1F8748))
  {
LABEL_19:
    uint64_t v12 = (unsigned char *)v4[1];
    goto LABEL_20;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&TypeNameCacheLock);
  os_unfair_lock_lock((os_unfair_lock_t)&TypeNameCacheLock);
  if (dword_1EB1F8748)
  {
    unsigned int v8 = (dword_1EB1F8748 - 1) & (v2 ^ (a1 >> 9));
    uint64_t v4 = (uint64_t *)(TypeNameCache + 24 * v8);
    uint64_t v9 = *v4;
    if (v2 == *v4) {
      goto LABEL_18;
    }
    int v10 = 1;
    while (v9 != -2)
    {
      unsigned int v11 = v8 + v10++;
      unsigned int v8 = v11 & (dword_1EB1F8748 - 1);
      uint64_t v4 = (uint64_t *)(TypeNameCache + 24 * v8);
      uint64_t v9 = *v4;
      if (v2 == *v4) {
        goto LABEL_18;
      }
    }
  }
  uint64_t v4 = (uint64_t *)(TypeNameCache + 24 * dword_1EB1F8748);
LABEL_18:
  if (v4 != (uint64_t *)(TypeNameCache + 24 * dword_1EB1F8748)) {
    goto LABEL_19;
  }
  v32[1] = 0;
  v32[2] = 0;
  long long v33 = 0;
  uint64_t v34 = 2400;
  uint64_t v35 = 0;
  char v36 = 0;
  unint64_t v71 = 0;
  v32[0] = &unk_1ECA07790;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  char v40 = 0;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  int v69 = 0;
  unsigned int v14 = _swift_buildDemanglingForMetadata(a1, (swift::Demangle::__runtime::NodeFactory *)v32);
  if (v14)
  {
    swift::Demangle::__runtime::mangleNode(v14, v15);
    if (v30)
    {
      uint64_t v12 = 0;
LABEL_49:
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      goto LABEL_51;
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v29, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string v29 = __p;
    }
    if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v29.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v29.__r_.__value_.__l.__size_;
    }
    char v17 = malloc_type_malloc(size + 1, 0x8DD282DAuLL);
    uint64_t v12 = v17;
    if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      __int16 v18 = &v29;
    }
    else {
      __int16 v18 = (std::string *)v29.__r_.__value_.__r.__words[0];
    }
    memcpy(v17, v18, size);
    v12[size] = 0;
    unint64_t v27 = v2;
    *(void *)&long long v28 = v12;
    *((void *)&v28 + 1) = size;
    if (dword_1EB1F8748)
    {
      unsigned int v19 = (dword_1EB1F8748 - 1) & (v2 ^ (a1 >> 9));
      unsigned int v20 = (void *)(TypeNameCache + 24 * v19);
      uint64_t v21 = *v20;
      if (v2 == *v20) {
        goto LABEL_47;
      }
      uint64_t v22 = 0;
      int v23 = 1;
      while (v21 != -2)
      {
        if (v22) {
          BOOL v24 = 0;
        }
        else {
          BOOL v24 = v21 == -16;
        }
        if (v24) {
          uint64_t v22 = v20;
        }
        unsigned int v25 = v19 + v23++;
        unsigned int v19 = v25 & (dword_1EB1F8748 - 1);
        unsigned int v20 = (void *)(TypeNameCache + 24 * v19);
        uint64_t v21 = *v20;
        if (v2 == *v20) {
          goto LABEL_47;
        }
      }
      if (v22) {
        uint64_t v26 = (uint64_t)v22;
      }
      else {
        uint64_t v26 = (uint64_t)v20;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    __swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>,__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>::InsertIntoBucket<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>((uint64_t)&TypeNameCache, v26, (uint64_t *)&v27, &v28);
LABEL_47:
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v29.__r_.__value_.__l.__data_);
    }
    goto LABEL_49;
  }
  uint64_t v12 = 0;
LABEL_51:
  v32[0] = &unk_1ECA07790;
  if (v71 == v70)
  {
    (*(void (**)(void *))(v70[0] + 32))(v70);
  }
  else if (v71)
  {
    (*(void (**)(void))(*v71 + 40))();
  }
  v32[0] = &unk_1ECA07768;
  swift::Demangle::__runtime::NodeFactory::freeSlabs(v33);
  if (v35) {
    *(unsigned char *)(v35 + 48) = 0;
  }
LABEL_20:
  os_unfair_lock_unlock((os_unfair_lock_t)&TypeNameCacheLock);
  return v12;
}

unsigned char *swift_getFunctionFullNameFromMangledName(void *a1, size_t a2)
{
  if (qword_1E8ECF940 != -1) {
    dispatch_once_f(&qword_1E8ECF940, &MangledToPrettyFunctionNameCache, (dispatch_function_t)swift::Lazy<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>>::defaultInitCallback);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&MangledToPrettyFunctionNameCacheLock);
  int v4 = dword_1E8ECF938;
  if (!dword_1E8ECF938) {
    goto LABEL_18;
  }
  uint64_t v5 = MangledToPrettyFunctionNameCache;
  int v6 = dword_1E8ECF938 - 1;
  unsigned int v7 = (v4 - 1) & __swift::__runtime::llvm::hash_value(a1, a2);
  for (int i = 1; ; ++i)
  {
    uint64_t v9 = v5 + 32 * v7;
    int v10 = *(const void **)v9;
    if (*(void *)v9 != -2) {
      break;
    }
    if (a1 == (void *)-2) {
      goto LABEL_16;
    }
LABEL_14:
    if (v10 == (const void *)-1) {
      goto LABEL_18;
    }
    unsigned int v11 = v7 + i;
    unsigned int v7 = v11 & v6;
  }
  if (v10 == (const void *)-1)
  {
    if (a1 == (void *)-1) {
      goto LABEL_16;
    }
    goto LABEL_14;
  }
  if (*(void *)(v9 + 8) != a2 || a2 && memcmp(a1, *(const void **)v9, a2)) {
    goto LABEL_14;
  }
LABEL_16:
  if (v9 != MangledToPrettyFunctionNameCache + 32 * dword_1E8ECF938)
  {
    uint64_t v12 = *(unsigned char **)(v9 + 16);
    os_unfair_lock_unlock((os_unfair_lock_t)&MangledToPrettyFunctionNameCacheLock);
    return v12;
  }
LABEL_18:
  os_unfair_lock_unlock((os_unfair_lock_t)&MangledToPrettyFunctionNameCacheLock);
  if (!a2)
  {
LABEL_22:
    uint64_t v15 = malloc_type_malloc(a2, 0x7A675426uLL);
    memcpy(v15, a1, a2);
    memset(&v115, 0, sizeof(v115));
    long long v76 = xmmword_181636930;
    uint64_t v77 = 0;
    char v78 = 0;
    v113 = 0;
    uint64_t v80 = 0;
    uint64_t v81 = 0;
    uint64_t v79 = 0;
    char v82 = 0;
    long long v94 = 0u;
    long long v95 = 0u;
    long long v96 = 0u;
    long long v97 = 0u;
    long long v98 = 0u;
    long long v99 = 0u;
    long long v100 = 0u;
    long long v101 = 0u;
    long long v102 = 0u;
    long long v103 = 0u;
    long long v104 = 0u;
    long long v105 = 0u;
    long long v106 = 0u;
    long long v107 = 0u;
    long long v108 = 0u;
    long long v109 = 0u;
    long long v110 = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v87 = 0u;
    long long v88 = 0u;
    long long v89 = 0u;
    long long v90 = 0u;
    long long v91 = 0u;
    long long v92 = 0u;
    long long v93 = 0u;
    int v111 = 0;
    v75[0] = &unk_1ECA04218;
    v75[1] = &v114;
    v75[2] = &v115;
    size_t v74 = 0;
    unint64_t v16 = swift::Demangle::__runtime::Demangler::demangleSymbol((uint64_t)v75, v15, a2, v73);
    if (v74 == v73)
    {
      (*(void (**)(void *))(v73[0] + 32))(v73);
      if (!v16) {
        goto LABEL_38;
      }
    }
    else
    {
      if (v74) {
        (*(void (**)(void))(*v74 + 40))();
      }
      if (!v16) {
        goto LABEL_38;
      }
    }
    uint64_t v17 = swift::Demangle::__runtime::Node::findByKind(v16, 76, 3);
    uint64_t v18 = v17;
    if (v17)
    {
      if (*(unsigned char *)(v17 + 18) != 5 || *(_DWORD *)(v17 + 8) < 3u) {
        goto LABEL_68;
      }
      uint64_t v19 = swift::Demangle::__runtime::Node::findByKind(v17, 24, 1);
      if (v19)
      {
        uint64_t v20 = v19;
        uint64_t v21 = swift::Demangle::__runtime::Node::findByKind(v19, 153, 1);
        if (v21)
        {
          std::string::append(&v115, *(const std::string::value_type **)v21, *(void *)(v21 + 8));
          std::string::append(&v115, ".");
        }
        uint64_t v22 = swift::Demangle::__runtime::Node::findByKind(v20, 101, 1);
        if (v22)
        {
          std::string::append(&v115, *(const std::string::value_type **)v22, *(void *)(v22 + 8));
          std::string::append(&v115, ".");
        }
      }
      uint64_t v23 = 0;
      unint64_t v24 = 0;
      int v25 = *(unsigned __int8 *)(v18 + 18);
      unsigned int v26 = v25 - 1;
      while (1)
      {
        unint64_t v27 = *(unsigned __int8 *)(v18 + 18);
        if (v25 == 1) {
          goto LABEL_46;
        }
        if (v25 != 5)
        {
          if (v25 == 2) {
            unint64_t v27 = 2;
          }
          else {
            unint64_t v27 = 0;
          }
LABEL_46:
          if (v24 >= v27) {
            break;
          }
          goto LABEL_49;
        }
        if (v24 >= *(unsigned int *)(v18 + 8)) {
          break;
        }
LABEL_49:
        uint64_t v28 = v18;
        if (v26 >= 2) {
          uint64_t v28 = *(void *)v18;
        }
        if (*(_WORD *)(*(void *)(v28 + 8 * v24) + 16) == 101)
        {
          unint64_t v29 = *(unsigned __int8 *)(v18 + 18);
          switch(v25)
          {
            case 1:
              goto LABEL_56;
            case 5:
              if (*(unsigned int *)(v18 + 8) > v24)
              {
LABEL_57:
                uint64_t v30 = v18;
                if (v26 >= 2) {
                  uint64_t v30 = *(void *)v18;
                }
                uint64_t v23 = *(void *)(v30 + 8 * v24);
                goto LABEL_40;
              }
LABEL_60:
              uint64_t v23 = 0;
              ++v24;
              break;
            case 2:
              unint64_t v29 = 2;
LABEL_56:
              if (v29 > v24) {
                goto LABEL_57;
              }
              goto LABEL_60;
            default:
              uint64_t v23 = 0;
              ++v24;
              break;
          }
        }
        else
        {
LABEL_40:
          ++v24;
        }
      }
      if (!v23)
      {
LABEL_68:
        uint64_t v12 = 0;
        goto LABEL_69;
      }
      std::string::append(&v115, *(const std::string::value_type **)v23, *(void *)(v23 + 8));
      std::string::append(&v115, "(");
      uint64_t v31 = swift::Demangle::__runtime::Node::findByKind(v18, 290, 1);
      if (!v31) {
        goto LABEL_117;
      }
      uint64_t v32 = v31;
      unsigned int v33 = *(unsigned __int8 *)(v31 + 18);
      if (v33 - 1 < 2 || v33 == 5 && *(_DWORD *)(v31 + 8))
      {
        for (unint64_t j = 0; ; ++j)
        {
          unint64_t v37 = v33;
          if (v33 == 1) {
            goto LABEL_86;
          }
          if (v33 != 5) {
            break;
          }
          if (j >= *(unsigned int *)(v32 + 8)) {
            goto LABEL_117;
          }
LABEL_87:
          if (v33 == 1)
          {
            if (j) {
              goto LABEL_80;
            }
          }
          else if (v33 == 5)
          {
            if (*(unsigned int *)(v32 + 8) <= j) {
              goto LABEL_80;
            }
          }
          else if (v33 != 2 || j >= 2)
          {
            goto LABEL_80;
          }
          uint64_t v38 = v32;
          if (v33 - 1 >= 2) {
            uint64_t v38 = *(void *)v32;
          }
          uint64_t v39 = *(void *)(v38 + 8 * j);
          if (v39)
          {
            int v40 = *(unsigned __int16 *)(v39 + 16);
            if (v40 == 275)
            {
              char v36 = "_:";
LABEL_79:
              std::string::append(&v115, v36);
              goto LABEL_80;
            }
            if (v40 == 101)
            {
              std::string::append(&v115, *(const std::string::value_type **)v39, *(void *)(v39 + 8));
              char v36 = ":";
              goto LABEL_79;
            }
          }
LABEL_80:
          unsigned int v33 = *(unsigned __int8 *)(v32 + 18);
        }
        if (v33 == 2) {
          unint64_t v37 = 2;
        }
        else {
          unint64_t v37 = 0;
        }
LABEL_86:
        if (j >= v37) {
          goto LABEL_117;
        }
        goto LABEL_87;
      }
      uint64_t v41 = swift::Demangle::__runtime::Node::findByKind(v18, 3, 5);
      if (!v41) {
        goto LABEL_117;
      }
      int v42 = *(unsigned __int8 *)(v41 + 18);
      if ((v42 - 1) >= 2)
      {
        if (v42 != 5 || !*(_DWORD *)(v41 + 8))
        {
          uint64_t v43 = 0;
          goto LABEL_110;
        }
        uint64_t v41 = *(void *)v41;
      }
      uint64_t v43 = *(void *)v41;
LABEL_110:
      int v44 = *(unsigned __int8 *)(v43 + 18);
      long long v45 = (uint64_t *)v43;
      if ((v44 - 1) < 2) {
        goto LABEL_114;
      }
      if (v44 == 5 && *(_DWORD *)(v43 + 8))
      {
        long long v45 = *(uint64_t **)v43;
LABEL_114:
        uint64_t v46 = *v45;
        if (v46)
        {
          if (*(_WORD *)(v46 + 16) == 223)
          {
            while (1)
            {
              LODWORD(v65) = *(unsigned __int8 *)(v43 + 18);
              unsigned int v66 = v65 - 1;
              long long v67 = (uint64_t *)v43;
              if ((v65 - 1) >= 2)
              {
                if (v65 != 5 || !*(_DWORD *)(v43 + 8)) {
                  break;
                }
                long long v67 = *(uint64_t **)v43;
              }
              if (!*v67) {
                break;
              }
              long long v68 = (uint64_t *)v43;
              if (v66 >= 2) {
                long long v68 = *(uint64_t **)v43;
              }
              if (*(_WORD *)(*v68 + 16) == 224) {
                break;
              }
              if (v66 >= 2)
              {
                if (v65 != 5 || !*(_DWORD *)(v43 + 8)) {
                  goto LABEL_117;
                }
                uint64_t v43 = *(void *)v43;
              }
              uint64_t v43 = *(void *)v43;
              if (!v43) {
                goto LABEL_117;
              }
            }
            unint64_t v69 = 0;
            if (v65 == 1) {
              goto LABEL_166;
            }
LABEL_159:
            if (v65 == 5)
            {
              unint64_t v65 = *(unsigned int *)(v43 + 8);
            }
            else if (v65 == 2)
            {
              unint64_t v65 = 2;
            }
            else
            {
              unint64_t v65 = 0;
            }
            while (v69 < v65)
            {
              std::string::append(&v115, "_:");
              ++v69;
              LODWORD(v65) = *(unsigned __int8 *)(v43 + 18);
              if (v65 != 1) {
                goto LABEL_159;
              }
LABEL_166:
              unint64_t v65 = v65;
            }
          }
          else
          {
            std::string::append(&v115, "_:");
          }
        }
      }
LABEL_117:
      std::string::append(&v115, ")");
      if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v115.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v115.__r_.__value_.__l.__size_;
      }
      long long v48 = malloc_type_malloc(size + 1, 0x1C678E53uLL);
      uint64_t v12 = v48;
      if ((v115.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v49 = &v115;
      }
      else {
        long long v49 = (std::string *)v115.__r_.__value_.__r.__words[0];
      }
      memcpy(v48, v49, size);
      v12[size] = 0;
      os_unfair_lock_lock((os_unfair_lock_t)&MangledToPrettyFunctionNameCacheLock);
      *(void *)&long long v71 = v15;
      *((void *)&v71 + 1) = a2;
      *(void *)&long long v72 = v12;
      *((void *)&v72 + 1) = size;
      int v50 = dword_1E8ECF938;
      if (dword_1E8ECF938)
      {
        uint64_t v51 = MangledToPrettyFunctionNameCache;
        int v52 = __swift::__runtime::llvm::hash_value(v15, a2);
        long long v53 = 0;
        int v54 = v50 - 1;
        unsigned int v55 = (v50 - 1) & v52;
        for (int k = 1; ; ++k)
        {
          uint64_t v57 = v51 + 32 * v55;
          long long v58 = *(const void **)v57;
          if (*(void *)v57 == -2)
          {
            if (v15 == (void *)-2) {
              goto LABEL_143;
            }
          }
          else if (v58 == (const void *)-1)
          {
            if (v15 == (void *)-1) {
              goto LABEL_143;
            }
          }
          else if (*(void *)(v57 + 8) == a2)
          {
            if (!a2) {
              goto LABEL_143;
            }
            uint64_t v70 = v51;
            long long v59 = v53;
            int v60 = memcmp(v15, *(const void **)v57, a2);
            long long v53 = v59;
            uint64_t v51 = v70;
            if (!v60) {
              goto LABEL_143;
            }
          }
          if (v58 == (const void *)-1) {
            break;
          }
          if (v53) {
            BOOL v61 = 0;
          }
          else {
            BOOL v61 = v58 == (const void *)-2;
          }
          if (v61) {
            long long v53 = (void *)v57;
          }
          unsigned int v62 = v55 + k;
          unsigned int v55 = v62 & v54;
        }
        if (v53) {
          long long v63 = v53;
        }
        else {
          long long v63 = (void *)v57;
        }
      }
      else
      {
        long long v63 = 0;
      }
      long long v64 = __swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>,__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>::InsertIntoBucketImpl<__swift::__runtime::llvm::StringRef>((uint64_t)&MangledToPrettyFunctionNameCache, (uint64_t)&v71, (uint64_t)&v71, v63);
      *long long v64 = v71;
      v64[1] = v72;
LABEL_143:
      os_unfair_lock_unlock((os_unfair_lock_t)&MangledToPrettyFunctionNameCacheLock);
      goto LABEL_69;
    }
LABEL_38:
    uint64_t v12 = 0;
LABEL_69:
    v75[0] = &unk_1ECA07790;
    if (v113 == v112)
    {
      (*(void (**)(void *))(v112[0] + 32))(v112);
    }
    else if (v113)
    {
      (*(void (**)(void))(*v113 + 40))();
    }
    v75[0] = &unk_1ECA07768;
    swift::Demangle::__runtime::NodeFactory::freeSlabs((void *)v76);
    if (v77) {
      *(unsigned char *)(v77 + 48) = 0;
    }
    if (SHIBYTE(v115.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v115.__r_.__value_.__l.__data_);
    }
    return v12;
  }
  size_t v13 = a2;
  unsigned int v14 = (unsigned __int8 *)a1;
  while (*v14 - 32 < 0xFFFFFFE1)
  {
    ++v14;
    if (!--v13) {
      goto LABEL_22;
    }
  }
  return 0;
}

uint64_t swift::Lazy<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>>::defaultInitCallback(uint64_t result)
{
  *(void *)__n128 result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t swift::Demangle::__runtime::StackAllocatedDemangler<1024ul>::~StackAllocatedDemangler(uint64_t a1)
{
  *(void *)a1 = &unk_1ECA07790;
  uint64_t v2 = a1 + 544;
  uint64_t v3 = *(void *)(a1 + 568);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  *(void *)a1 = &unk_1ECA07768;
  swift::Demangle::__runtime::NodeFactory::freeSlabs(*(void **)(a1 + 24));
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4) {
    *(unsigned char *)(v4 + 48) = 0;
  }
  return a1;
}

void swift::swift_dynamicCastFailure(swift *this, const void *a2, const char *a3, char *a4, const char *a5, const char *a6)
{
  int v6 = ": ";
  if (!a5) {
    int v6 = ".";
  }
  unsigned int v7 = "";
  if (a5) {
    unsigned int v7 = a5;
  }
  swift::fatalError(0, "Could not cast value of type '%s' (%p) to '%s' (%p)%s%s\n", a3, a4, a2, this, a4, a3, v6, v7);
}

void swift::swift_dynamicCastFailure(Class *a1, Class *a2, const char *a3)
{
  swift::nameForMetadata(&v10, a1, 1);
  swift::nameForMetadata(&v9, a2, 1);
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unsigned int v7 = &v10;
  }
  else {
    unsigned int v7 = (std::string *)v10.__r_.__value_.__r.__words[0];
  }
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unsigned int v8 = &v9;
  }
  else {
    unsigned int v8 = (std::string *)v9.__r_.__value_.__r.__words[0];
  }
  swift::swift_dynamicCastFailure((swift *)a1, v7, (const char *)a2, (char *)v8, a3, v6);
}

uint64_t swift::_conformsToProtocol(swift::runtime::bincompat **a1, uint64_t a2, const char *a3, uint64_t *a4)
{
  if ((a3 & 1) == 0)
  {
    uint64_t v5 = swift_conformsToProtocolCommon(a2, (unint64_t)a3 & 0xFFFFFFFFFFFFFFFELL);
    uint64_t result = v5 != 0;
    if (a4)
    {
      if (v5)
      {
        *a4 = v5;
        return 1;
      }
    }
    return result;
  }
  uint64_t result = 0;
  uint64_t v8 = *(void *)a2;
  if (*(void *)a2 > 0x7FFuLL) {
    LODWORD(v8) = 0;
  }
  if ((int)v8 <= 770)
  {
    if ((v8 - 515) < 2)
    {
      if (!a1) {
        return 0;
      }
LABEL_17:
      unint64_t v17 = (unint64_t)a3 & 0xFFFFFFFFFFFFFFFELL;
      return swift_dynamicCastObjCProtocolConditional(*a1, 1, &v17) != 0;
    }
    if (v8) {
      return result;
    }
    if (a1) {
      goto LABEL_17;
    }
    std::string v9 = (void *)a2;
    goto LABEL_22;
  }
  if (v8 != 771)
  {
    if (v8 != 773) {
      return result;
    }
    if (a1) {
      goto LABEL_17;
    }
    std::string v9 = *(void **)(a2 + 8);
LABEL_22:
    return swift::objectConformsToObjCProtocol(v9, a3);
  }
  unint64_t v10 = *(unsigned int *)(a2 + 8);
  if ((v10 & 0x80FFFFFF) != 0) {
    return 0;
  }
  uint64_t v11 = *(unsigned int *)(a2 + 12);
  if (!v11) {
    return 0;
  }
  uint64_t v12 = (uint64_t *)(a2 + ((v10 >> 27) & 0x18) + 16);
  size_t v13 = (Protocol *)((unint64_t)a3 & 0xFFFFFFFFFFFFFFFELL);
  uint64_t v14 = 8 * v11 - 8;
  do
  {
    uint64_t v15 = *v12++;
    uint64_t result = protocol_conformsToProtocol((Protocol *)(v15 & 0xFFFFFFFFFFFFFFFELL), v13);
    if (result) {
      break;
    }
    uint64_t v16 = v14;
    v14 -= 8;
  }
  while (v16);
  return result;
}

unint64_t swift_getDynamicType(swift::SwiftError **a1, uint64_t *a2, int a3)
{
  uint64_t v3 = (uint64_t)a2;
  uint64_t v4 = a1;
  uint64_t v5 = *a2;
  if ((unint64_t)*a2 > 0x7FF) {
    LODWORD(v5) = 0;
  }
  switch((int)v5)
  {
    case 771:
      swift::TargetExistentialTypeMetadata<swift::InProcess>::mayTakeValue((uint64_t)a2, a1);
      if (!a3) {
        return v3;
      }
      int Representation = swift::TargetExistentialTypeMetadata<swift::InProcess>::getRepresentation(v3);
      if (Representation != 2)
      {
        if (Representation == 1) {
          goto LABEL_25;
        }
        if (Representation) {
          goto LABEL_4;
        }
      }
      while (1)
      {
        DynamicType = (uint64_t *)swift::TargetExistentialTypeMetadata<swift::InProcess>::getDynamicType(v3, v4);
        uint64_t v4 = swift::TargetExistentialTypeMetadata<swift::InProcess>::projectValue(v3, v4);
        uint64_t v3 = (uint64_t)DynamicType;
        uint64_t v5 = *DynamicType;
        if ((unint64_t)*DynamicType > 0x7FF) {
          LODWORD(v5) = 0;
        }
        if (v5 != 771) {
          break;
        }
        swift::TargetExistentialTypeMetadata<swift::InProcess>::mayTakeValue((uint64_t)DynamicType, v4);
        int v11 = swift::TargetExistentialTypeMetadata<swift::InProcess>::getRepresentation((uint64_t)DynamicType);
        if (v11 && v11 != 2)
        {
          if (v11 == 1) {
            goto LABEL_25;
          }
          goto LABEL_4;
        }
      }
      if ((int)v5 <= 771) {
        goto LABEL_23;
      }
      if (v5 == 772 || v5 == 774) {
        goto LABEL_4;
      }
      if (v5 == 773) {
        goto LABEL_25;
      }
      return v3;
    case 772:
    case 774:
LABEL_4:
      int v6 = *v4;
      return swift_getMetatypeMetadata((unint64_t)v6);
    case 773:
      goto LABEL_25;
    default:
LABEL_23:
      if (v5 && v5 != 515) {
        return v3;
      }
LABEL_25:
      uint64_t v12 = *v4;
      return swift_getObjectType((unint64_t)v12);
  }
}

uint64_t *swift_dynamicCastMetatypeToObjectConditional(uint64_t *result)
{
  uint64_t v1 = *result;
  if ((unint64_t)*result > 0x7FF) {
    LODWORD(v1) = 0;
  }
  if (v1)
  {
    if (v1 == 773) {
      return (uint64_t *)result[1];
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t swift_dynamicCastMetatypeToObjectUnconditional(uint64_t result)
{
  Class v1 = *(Class *)result;
  if (*(void *)result > 0x7FFuLL) {
    LODWORD(v1) = 0;
  }
  if (v1)
  {
    if (v1 != 773)
    {
      uint64_t v2 = (swift *)result;
      swift::nameForMetadata(&v5, (Class *)result, 1);
      if ((v5.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v4 = &v5;
      }
      else {
        uint64_t v4 = (std::string *)v5.__r_.__value_.__r.__words[0];
      }
      swift::swift_dynamicCastFailure(v2, v4, 0, "AnyObject", "only class metatypes can be converted to AnyObject", v3);
    }
    return *(void *)(result + 8);
  }
  return result;
}

atomic_ullong *_bridgeAnythingNonVerbatimToObjectiveC<A>(_:)(id *a1, uint64_t *a2)
{
  return bridgeAnythingNonVerbatimToObjectiveC(a1, a2, 1u);
}

atomic_ullong *bridgeAnythingNonVerbatimToObjectiveC(id *a1, uint64_t *a2, unsigned int a3)
{
  uint64_t v5 = *a2;
  if ((unint64_t)*a2 <= 0x7FF) {
    int v6 = *a2;
  }
  else {
    int v6 = 0;
  }
  if (!v6 || v6 == 773 || v6 == 515)
  {
    unsigned int v7 = *a1;
    if ((a3 & 1) == 0) {
      swift_unknownObjectRetain(*a1);
    }
    return v7;
  }
  if (v5 != 774 && v5 != 772)
  {
    if (v5 == 771)
    {
      int Representation = swift::TargetExistentialTypeMetadata<swift::InProcess>::getRepresentation((uint64_t)a2);
      if (Representation)
      {
        if (Representation == 2)
        {
          uint64_t v23 = (swift::SwiftError *)*a1;
          unint64_t Type = swift::SwiftError::getType((swift::SwiftError *)*a1, v11);
          BOOL v14 = 0;
          if (swift::SwiftError::isPureNSError(v23, v24))
          {
            BOOL v13 = 1;
            unint64_t v15 = (unint64_t)a1;
          }
          else
          {
            unint64_t v15 = ((unint64_t)v23 + *(unsigned __int8 *)(*(void *)(*((void *)v23 + 5) - 8) + 80) + 72) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*((void *)v23 + 5) - 8) + 80);
            BOOL v13 = 1;
          }
        }
        else if (Representation == 1)
        {
          unint64_t Type = swift_getObjectType((unint64_t)*a1);
          BOOL v13 = 0;
          BOOL v14 = 1;
          unint64_t v15 = (unint64_t)a1;
        }
        else
        {
          BOOL v13 = 0;
          BOOL v14 = 0;
          unint64_t Type = 0;
          unint64_t v15 = 0;
        }
      }
      else
      {
        unint64_t Type = (unint64_t)a1[3];
        unint64_t v15 = (unint64_t)swift::TargetExistentialTypeMetadata<swift::InProcess>::projectValue((uint64_t)a2, (swift::SwiftError **)a1);
        BOOL v14 = v15 == (void)a1;
        BOOL v13 = v15 != (void)a1;
      }
      if (v14) {
        uint64_t v25 = a3;
      }
      else {
        uint64_t v25 = 0;
      }
      unsigned int v7 = (void *)bridgeAnythingNonVerbatimToObjectiveC(v15, Type, v25);
      if (!a3) {
        return v7;
      }
      if (v14)
      {
        if (v13) {
          swift::fatalError(0, "Attempting to move out of a copy-on-write existential", v26, v27);
        }
        return v7;
      }
      goto LABEL_59;
    }
    BridgeWitness = findBridgeWitness((uint64_t)a2);
    if (BridgeWitness)
    {
      unsigned int v7 = (void *)((uint64_t (*)(uint64_t *, _UNKNOWN **))BridgeWitness[2])(a2, BridgeWitness);
      if (!a3) {
        return v7;
      }
LABEL_59:
      if (*(a2 - 1)) {
        uint64_t v28 = *(a2 - 1);
      }
      else {
        uint64_t v28 = 0;
      }
      (*(void (**)(id *, uint64_t *))(v28 + 8))(a1, a2);
      return v7;
    }
    uint64_t ErrorWitness = swift::findErrorWitness((uint64_t)a2);
    if (ErrorWitness)
    {
      if (a3) {
        char v22 = 2;
      }
      else {
        char v22 = 0;
      }
      return swift::dynamicCastValueToNSError((uint64_t)a1, (uint64_t)a2, ErrorWitness, v22);
    }
    goto LABEL_43;
  }
  unsigned int v7 = *a1;
  unint64_t v16 = *(void *)*a1;
  if (v16 > 0x7FF || (v16 != 773 ? (BOOL v17 = *(void *)*a1 == 0) : (BOOL v17 = 1), v17))
  {
    if (v16 > 0x7FF) {
      LODWORD(v16) = 0;
    }
    if (v16)
    {
      if (v16 == 773) {
        return (atomic_ullong *)v7[1];
      }
      else {
        return 0;
      }
    }
    return v7;
  }
  if (v16 != 771 || (unint64_t v18 = *((unsigned int *)v7 + 2), (v18 & 0x80FFFFFF) != 0) || *((_DWORD *)v7 + 3) != 1)
  {
LABEL_43:
    return swift::bridgeAnythingToSwiftValueObject((uint64_t)a1, (uint64_t)a2, a3);
  }
  uint64_t v19 = *(void *)((char *)v7 + ((v18 >> 27) & 0x18) + 16);

  return (atomic_ullong *)(id)(v19 & 0xFFFFFFFFFFFFFFFELL);
}

int **_getBridgedNonVerbatimObjectiveCType<A>(_:)(uint64_t a1, uint64_t a2)
{
  uint64_t result = (int **)findBridgeWitness(a2);
  if (result) {
  return result;
  }
}

_UNKNOWN **findBridgeWitness(uint64_t a1)
{
  if (*(void *)a1 == 512
    && (!*(void *)(a1 + 8) ? (uint64_t v2 = 0) : (uint64_t v2 = *(StructDescriptor **)(a1 + 8)),
        v2 == &nominal type descriptor for String))
  {
    uint64_t v4 = &unk_1EB1F8000;
    {
      uint64_t v4 = (void *)&unk_1EB1F8000;
      if (v7)
      {
        findBridgeWitness(swift::TargetMetadata<swift::InProcess> const*)::Swift_String_ObjectiveCBridgeable = swift_conformsToProtocolCommon(a1, (uint64_t)&protocol descriptor for _ObjectiveCBridgeable);
        uint64_t v4 = (void *)&unk_1EB1F8000;
      }
    }
    return (_UNKNOWN **)v4[245];
  }
  else
  {
    uint64_t result = (_UNKNOWN **)swift_conformsToProtocolCommon(a1, (uint64_t)&protocol descriptor for _ObjectiveCBridgeable);
    if (result) {
      return result;
    }
    uint64_t v5 = *(void *)a1;
    if (*(void *)a1 > 0x7FFuLL) {
      LODWORD(v5) = 0;
    }
    if (v5 == 774)
    {
      if ((*(_DWORD *)(a1 + 16) & 0x80FFFFFF) == 0) {
        return &protocol witness table for _BridgeableMetatype;
      }
      return 0;
    }
    if (v5 != 772) {
      return 0;
    }
    unint64_t v6 = **(void **)(a1 + 8);
    if (v6 > 0x7FF) {
      LODWORD(v6) = 0;
    }
    uint64_t result = &protocol witness table for _BridgeableMetatype;
    if (v6)
    {
      if (v6 != 515 && v6 != 773) {
        return 0;
      }
    }
  }
  return result;
}

const char *anonymous namespace'::_getBridgedObjectiveCType(uint64_t a1, uint64_t a2, int **a3)
{
  uint64_t v5 = *a3;
  uint64_t v6 = **a3;
  if (v6)
  {
    int v7 = (char **)((char *)v5 + (v6 & 0xFFFFFFFFFFFFFFFELL));
    if (v6)
    {
      if (*v7)
      {
        uint64_t v8 = *v7;
        goto LABEL_8;
      }
    }
    else if (v7)
    {
      uint64_t v8 = (char *)v5 + (v6 & 0xFFFFFFFFFFFFFFFELL);
      goto LABEL_8;
    }
  }
  uint64_t v8 = 0;
LABEL_8:
  std::string v9 = v8;
  if (v8) {
    std::string v9 = v8;
  }
  if (v9 == (char *)-24)
  {
    unint64_t v10 = 0;
    unsigned int v11 = MEMORY[0xFFFFFFFFFFFFFFF4];
    if (v8) {
      goto LABEL_12;
    }
  }
  else
  {
    unint64_t v10 = v9 + 24;
    unsigned int v11 = *((_DWORD *)v9 + 3);
    if (v8)
    {
LABEL_12:
      uint64_t v12 = v8;
      goto LABEL_15;
    }
  }
  uint64_t v12 = 0;
LABEL_15:
  BOOL v13 = v12;
  if (v12 == (char *)-24) {
    BOOL v14 = 0;
  }
  else {
    BOOL v14 = v12 + 24;
  }
  return swift_getAssociatedTypeWitness(a1, a3, a2, (uint64_t)&v14[12 * *((unsigned int *)v13 + 3) - 8], &v10[12 * v11]);
}

uint64_t _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)(swift *a1, uint64_t a2, void *a3)
{
  uint64_t result = tryBridgeNonVerbatimFromObjectiveCUniversal(a1, a2, a3);
  if ((result & 1) == 0)
  {
    BridgeWitness = (int **)findBridgeWitness(a2);
    if (!BridgeWitness) {
      _bridgeNonVerbatimFromObjectiveC<A>(_:_:_:)();
    }
    uint64_t v8 = BridgeWitness;
    swift_once(&swift_dynamicCastUnknownClass::Predicate, (dispatch_function_t)swift_dynamicCastUnknownClass::$_0::__invoke, 0);
    if (swift_dynamicCastUnknownClass::Override)
    {
      unint64_t v10 = (atomic_ullong *)swift_dynamicCastUnknownClass::Override(a1, BridgedObjectiveCType, swift_dynamicCastUnknownClassImpl);
      if (v10) {
        return ((uint64_t (*)(atomic_ullong *, void *, uint64_t, int **))v8[3])(v10, a3, a2, v8);
      }
    }
    else
    {
      unint64_t v10 = swift_dynamicCastUnknownClassImpl((uint64_t)a1, (uint64_t)BridgedObjectiveCType);
      if (v10) {
        return ((uint64_t (*)(atomic_ullong *, void *, uint64_t, int **))v8[3])(v10, a3, a2, v8);
      }
    }
    Class = (Class *)swift::_swift_getClass((unint64_t)a1, v11);
    swift::swift_dynamicCastFailure(Class, BridgedObjectiveCType, 0);
  }
  return result;
}

uint64_t tryBridgeNonVerbatimFromObjectiveCUniversal(swift *this, uint64_t a2, void *a3)
{
  if (*(void *)a2 == 771 && !*(_DWORD *)(a2 + 12) && (*(_DWORD *)(a2 + 8) & 0x80000000) != 0)
  {
    _bridgeNonVerbatimFromObjectiveCToAny(this, a3);
    return 1;
  }
  AsSwiftValue = swift::getAsSwiftValue(this, (objc_object *)a2);
  if (AsSwiftValue && swift::getValueFromSwiftValue(AsSwiftValue, v7) == a2)
  {
    _bridgeNonVerbatimBoxedValue(v8, (uint64_t)a3, a2, v9);
    return 1;
  }

  return swift::tryDynamicCastNSErrorObjectToValue((uint64_t)this, a3, (void *)a2, 0);
}

atomic_ullong *swift_dynamicCastUnknownClass(uint64_t a1, uint64_t a2)
{
  swift_once(&swift_dynamicCastUnknownClass::Predicate, (dispatch_function_t)swift_dynamicCastUnknownClass::$_0::__invoke, 0);
  uint64_t v4 = (uint64_t (*)(uint64_t, uint64_t, atomic_ullong *(*)(uint64_t, uint64_t)))swift_dynamicCastUnknownClass::Override;
  if (swift_dynamicCastUnknownClass::Override)
  {
    return (atomic_ullong *)v4(a1, a2, swift_dynamicCastUnknownClassImpl);
  }
  else
  {
    return swift_dynamicCastUnknownClassImpl(a1, a2);
  }
}

uint64_t _bridgeNonVerbatimFromObjectiveCConditional<A>(_:_:_:)(swift *a1, uint64_t a2, void *a3)
{
  if (tryBridgeNonVerbatimFromObjectiveCUniversal(a1, a2, a3)) {
    return 1;
  }
  uint64_t result = (uint64_t)findBridgeWitness(a2);
  if (result)
  {
    uint64_t v7 = result;
    swift_once(&swift_dynamicCastUnknownClass::Predicate, (dispatch_function_t)swift_dynamicCastUnknownClass::$_0::__invoke, 0);
    if (swift_dynamicCastUnknownClass::Override)
    {
      uint64_t result = swift_dynamicCastUnknownClass::Override(a1, BridgedObjectiveCType, swift_dynamicCastUnknownClassImpl);
      if (!result) {
        return result;
      }
    }
    else
    {
      uint64_t result = (uint64_t)swift_dynamicCastUnknownClassImpl((uint64_t)a1, (uint64_t)BridgedObjectiveCType);
      if (!result) {
        return result;
      }
    }
    return (*(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t))(v7 + 32))(result, a3, a2, v7) & 1;
  }
  return result;
}

BOOL _isBridgedNonVerbatimToObjectiveC<A>(_:)(uint64_t a1, uint64_t a2)
{
  return findBridgeWitness(a2) != 0;
}

BOOL _swift_isClassOrObjCExistentialType(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = *a2;
  if ((unint64_t)*a2 > 0x7FF) {
    LODWORD(v2) = 0;
  }
  BOOL result = 1;
  if ((int)v2 <= 769)
  {
    if (v2 && v2 != 515) {
      return 0;
    }
  }
  else
  {
    if (v2 == 770) {
      return (unint64_t)*((unsigned __int8 *)a2 + 10) << 16 == 0x10000;
    }
    if (v2 != 773)
    {
      if (v2 == 771) {
        return (a2[1] & 0x80FFFFFF) == 0;
      }
      return 0;
    }
  }
  return result;
}

uint64_t _swift_setClassMetadata(uint64_t result, void *a2)
{
  if (result) {
    *a2 = result;
  }
  else {
    *a2 = 0;
  }
  return result;
}

unint64_t _swift_class_getSuperclass(swift *a1)
{
  uint64_t v2 = *(void *)a1;
  if (*(void *)a1 <= 0x7FFuLL) {
    int v3 = *(void *)a1;
  }
  else {
    int v3 = 0;
  }
  uint64_t v4 = a1;
  if (!v3 || v3 == 773 && (uint64_t v4 = (swift *)*((void *)a1 + 1)) != 0)
  {
    uint64_t v7 = *((void *)v4 + 1);
    uint64_t v6 = (unint64_t *)((char *)v4 + 8);
    uint64_t v5 = v7;
    if (v7)
    {
      if (swift::getRootSuperclass(a1) != v5)
      {
        if (*v6) {
          unint64_t v8 = *v6;
        }
        else {
          unint64_t v8 = 0;
        }
        return swift_getObjCClassMetadata(v8);
      }
      uint64_t v2 = *(void *)a1;
    }
  }
  if (v2 != 515) {
    return 0;
  }
  unint64_t result = *((void *)a1 + 2);
  if (!result) {
    return 0;
  }
  return result;
}

BOOL swift_isClassType(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if ((unint64_t)*a1 > 0x7FF) {
    LODWORD(v1) = 0;
  }
  BOOL result = 1;
  if (v1) {
    return v1 == 515 || v1 == 773;
  }
  return result;
}

BOOL swift_isOptionalType(void *a1)
{
  return *a1 == 514;
}

uint64_t swift_dynamicCastClass(uint64_t a1, uint64_t a2)
{
  swift_once(&swift_dynamicCastClass::Predicate, (dispatch_function_t)swift_dynamicCastClass::$_0::__invoke, 0);
  uint64_t v4 = (uint64_t (*)(uint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))swift_dynamicCastClass::Override;
  if (swift_dynamicCastClass::Override)
  {
    return v4(a1, a2, swift_dynamicCastClassImpl);
  }
  else if (a1 < 1)
  {
    return 0;
  }
  else
  {
    for (uint64_t i = *(void *)a1 & 0x7FFFFFFFFFFFF8; i != a2; uint64_t i = *(void *)(i + 8))
    {
      if (!*(void *)(i + 8))
      {
        a2 = 0;
        break;
      }
    }
    if (a2) {
      return a1;
    }
    else {
      return 0;
    }
  }
}

uint64_t swift_dynamicCastClassImpl(uint64_t result, uint64_t a2)
{
  if (result < 1) {
    return 0;
  }
  for (uint64_t i = *(void *)result & 0x7FFFFFFFFFFFF8; i != a2; uint64_t i = *(void *)(i + 8))
  {
    if (!*(void *)(i + 8))
    {
      a2 = 0;
      break;
    }
  }
  if (!a2) {
    return 0;
  }
  return result;
}

uint64_t swift_dynamicCastClassUnconditional(int64_t a1, Class *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  swift_once(&swift_dynamicCastClassUnconditional::Predicate, (dispatch_function_t)swift_dynamicCastClassUnconditional::$_0::__invoke, 0);
  unint64_t v10 = (uint64_t (*)(int64_t, Class *, uint64_t, uint64_t, uint64_t, uint64_t (*)(int64_t, Class *)))swift_dynamicCastClassUnconditional::Override;
  if (!swift_dynamicCastClassUnconditional::Override)
  {
    swift_once(&swift_dynamicCastClass::Predicate, (dispatch_function_t)swift_dynamicCastClass::$_0::__invoke, 0);
    if (swift_dynamicCastClass::Override)
    {
      uint64_t result = swift_dynamicCastClass::Override(a1, a2, swift_dynamicCastClassImpl);
    }
    else
    {
      if (a1 < 1) {
        goto LABEL_14;
      }
      for (uint64_t i = *(void *)a1 & 0x7FFFFFFFFFFFF8; (Class *)i != a2; uint64_t i = *(void *)(i + 8))
      {
        if (!*(void *)(i + 8)) {
          goto LABEL_14;
        }
      }
      uint64_t result = a1;
      if (!a2) {
        goto LABEL_14;
      }
    }
    if (result) {
      return result;
    }
LABEL_14:
    Class = (Class *)swift::_swift_getClass(a1, v12);
    swift::swift_dynamicCastFailure(Class, a2, 0);
  }

  return v10(a1, a2, a3, a4, a5, swift_dynamicCastClassUnconditionalImpl);
}

uint64_t swift_dynamicCastClassUnconditionalImpl(int64_t a1, Class *a2)
{
  swift_once(&swift_dynamicCastClass::Predicate, (dispatch_function_t)swift_dynamicCastClass::$_0::__invoke, 0);
  if (swift_dynamicCastClass::Override)
  {
    uint64_t result = swift_dynamicCastClass::Override(a1, a2, swift_dynamicCastClassImpl);
  }
  else
  {
    if (a1 < 1) {
      goto LABEL_10;
    }
    for (uint64_t i = *(void *)a1 & 0x7FFFFFFFFFFFF8; (Class *)i != a2; uint64_t i = *(void *)(i + 8))
    {
      if (!*(void *)(i + 8)) {
        goto LABEL_10;
      }
    }
    uint64_t result = a1;
    if (!a2)
    {
LABEL_10:
      Class = (Class *)swift::_swift_getClass(a1, v4);
      swift::swift_dynamicCastFailure(Class, a2, 0);
    }
  }
  if (!result) {
    goto LABEL_10;
  }
  return result;
}

atomic_ullong *swift_dynamicCastUnknownClassImpl(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  uint64_t v5 = *(void *)a2;
  if (*(void *)a2 > 0x7FFuLL) {
    LODWORD(v5) = 0;
  }
  if ((int)v5 <= 770)
  {
    if (v5)
    {
      if (v5 == 515)
      {
        return (atomic_ullong *)swift_dynamicCastForeignClass(a1, a2);
      }
      return result;
    }
    swift_once(&swift_dynamicCastClass::Predicate, (dispatch_function_t)swift_dynamicCastClass::$_0::__invoke, 0);
    uint64_t v7 = (uint64_t (*)(uint64_t, uint64_t, uint64_t (*)(uint64_t, uint64_t)))swift_dynamicCastClass::Override;
    if (swift_dynamicCastClass::Override)
    {
      return (atomic_ullong *)v7(a1, a2, swift_dynamicCastClassImpl);
    }
    if (a1 >= 1)
    {
      for (uint64_t i = *(void *)a1 & 0x7FFFFFFFFFFFF8; i != a2; uint64_t i = *(void *)(i + 8))
      {
        if (!*(void *)(i + 8)) {
          return 0;
        }
      }
      return (atomic_ullong *)a1;
    }
    return 0;
  }
  if (v5 == 771)
  {
    uint64_t v8 = *(unsigned int *)(a2 + 12);
    if (!v8) {
      return (atomic_ullong *)a1;
    }
    uint64_t v9 = (const char **)(a2 + 8 * (((unint64_t)*(unsigned int *)(a2 + 8) >> 30) & 1) + 16);
    uint64_t v10 = 8 * v8;
    while ((*v9 & 1) != 0 && (swift::objectConformsToObjCProtocol((void *)a1, *v9) & 1) != 0)
    {
      ++v9;
      v10 -= 8;
      if (!v10) {
        return (atomic_ullong *)a1;
      }
    }
    return 0;
  }
  if (v5 == 773)
  {
    uint64_t v6 = *(void *)(a2 + 8);
    return swift_dynamicCastObjCClass((void *)a1, v6);
  }
  return result;
}

atomic_ullong *swift_dynamicCastUnknownClassUnconditional(swift *a1, Class *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  swift_once(&swift_dynamicCastUnknownClassUnconditional::Predicate, (dispatch_function_t)swift_dynamicCastUnknownClassUnconditional::$_0::__invoke, 0);
  uint64_t v10 = (uint64_t (*)(swift *, Class *, uint64_t, uint64_t, uint64_t, atomic_ullong *(*)(swift *, Class *, uint64_t, uint64_t, uint64_t)))swift_dynamicCastUnknownClassUnconditional::Override;
  if (swift_dynamicCastUnknownClassUnconditional::Override)
  {
    return (atomic_ullong *)v10(a1, a2, a3, a4, a5, swift_dynamicCastUnknownClassUnconditionalImpl);
  }
  else
  {
    return swift_dynamicCastUnknownClassUnconditionalImpl(a1, a2, a3, a4, a5);
  }
}

atomic_ullong *swift_dynamicCastUnknownClassUnconditionalImpl(swift *this, Class *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a2;
  uint64_t v6 = this;
  Class v7 = *a2;
  if ((unint64_t)*a2 > 0x7FF) {
    LODWORD(v7) = 0;
  }
  if ((int)v7 > 515)
  {
    if (v7 == 516) {
      return 0;
    }
    if (v7 != 771)
    {
      if (v7 == 773)
      {
        uint64_t v8 = (Class *)a2[1];
        return swift_dynamicCastObjCClassUnconditional(this, v8, a3, a4, a5);
      }
LABEL_26:
      Class = (Class *)swift::_swift_getClass((unint64_t)v6, a2);
      swift::swift_dynamicCastFailure(Class, v5, 0);
    }
    uint64_t v10 = *((unsigned int *)a2 + 3);
    if (v10)
    {
      unsigned int v11 = (Class **)&a2[(((unint64_t)*((unsigned int *)a2 + 2) >> 30) & 1) + 2];
      uint64_t v12 = 8 * v10;
      do
      {
        a2 = *v11;
        if ((*v11 & 1) == 0 || (swift::objectConformsToObjCProtocol(v6, (const char *)a2) & 1) == 0) {
          goto LABEL_26;
        }
        ++v11;
        v12 -= 8;
      }
      while (v12);
    }
    if (!v6) {
      goto LABEL_26;
    }
    return (atomic_ullong *)v6;
  }
  if (v7)
  {
    if (v7 != 515) {
      goto LABEL_26;
    }
    return (atomic_ullong *)swift_dynamicCastForeignClassUnconditional((uint64_t)this, (uint64_t)a2, a3, a4, a5);
  }
  else
  {
    return (atomic_ullong *)swift_dynamicCastClassUnconditional((int64_t)this, a2, a3, a4, a5);
  }
}

uint64_t *swift_dynamicCastMetatype(uint64_t *a1, uint64_t *a2)
{
  swift_once(&swift_dynamicCastMetatype::Predicate, (dispatch_function_t)swift_dynamicCastMetatype::$_0::__invoke, 0);
  uint64_t v4 = (uint64_t (*)(uint64_t *, uint64_t *, uint64_t *(*)(uint64_t *, uint64_t *)))swift_dynamicCastMetatype::Override;
  if (swift_dynamicCastMetatype::Override)
  {
    return (uint64_t *)v4(a1, a2, swift_dynamicCastMetatypeImpl);
  }
  else
  {
    return swift_dynamicCastMetatypeImpl(a1, a2);
  }
}

uint64_t *swift_dynamicCastMetatypeImpl(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = a1;
  if (a1 == a2) {
    return v2;
  }
  uint64_t v3 = *a2;
  if ((unint64_t)*a2 > 0x7FF) {
    LODWORD(v3) = 0;
  }
  if (v3)
  {
    if (v3 == 515)
    {
      uint64_t v6 = *a1;
      if ((unint64_t)*a1 > 0x7FF) {
        LODWORD(v6) = 0;
      }
      if (v6 && v6 != 515)
      {
        if (v6 != 773) {
          return 0;
        }
        a1 = (uint64_t *)a1[1];
      }
      goto LABEL_22;
    }
    if (v3 != 773) {
      return 0;
    }
    a2 = (uint64_t *)a2[1];
  }
  uint64_t v4 = *a1;
  if ((unint64_t)*a1 > 0x7FF) {
    LODWORD(v4) = 0;
  }
  if (!v4) {
    goto LABEL_14;
  }
  if (v4 != 515)
  {
    if (v4 == 773)
    {
      a1 = (uint64_t *)a1[1];
LABEL_14:
      uint64_t v5 = swift_dynamicCastObjCClassMetatype(a1, (uint64_t)a2);
      goto LABEL_23;
    }
    return 0;
  }
LABEL_22:
  uint64_t v5 = swift_dynamicCastForeignClassMetatype((uint64_t)a1, (uint64_t)a2);
LABEL_23:
  if (!v5) {
    return 0;
  }
  return v2;
}

uint64_t *swift_dynamicCastMetatypeUnconditional(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  swift_once(&swift_dynamicCastMetatypeUnconditional::Predicate, (dispatch_function_t)swift_dynamicCastMetatypeUnconditional::$_0::__invoke, 0);
  uint64_t v10 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *(*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t)))swift_dynamicCastMetatypeUnconditional::Override;
  if (swift_dynamicCastMetatypeUnconditional::Override)
  {
    return (uint64_t *)v10(a1, a2, a3, a4, a5, swift_dynamicCastMetatypeUnconditionalImpl);
  }
  else
  {
    return swift_dynamicCastMetatypeUnconditionalImpl(a1, a2, a3, a4, a5);
  }
}

uint64_t *swift_dynamicCastMetatypeUnconditionalImpl(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = (uint64_t *)a1;
  if (a1 != a2)
  {
    uint64_t v6 = a2;
    uint64_t v7 = *(void *)a2;
    if (*(void *)a2 > 0x7FFuLL) {
      LODWORD(v7) = 0;
    }
    if ((int)v7 <= 515)
    {
      if (v7)
      {
        if (v7 != 515) {
          goto LABEL_42;
        }
        Class v8 = *(Class *)a1;
        if (*(void *)a1 > 0x7FFuLL) {
          LODWORD(v8) = 0;
        }
        if (v8 && v8 != 515)
        {
          if (v8 != 773) {
            goto LABEL_42;
          }
          a1 = *(void *)(a1 + 8);
        }
        goto LABEL_27;
      }
    }
    else
    {
      if (v7 == 771)
      {
        unsigned int v10 = *(_DWORD *)(a2 + 8);
        if ((v10 & 0x40000000) != 0)
        {
          unsigned int v11 = *(uint64_t **)(a2 + 16);
          if (v11)
          {
            swift_once(&swift_dynamicCastMetatype::Predicate, (dispatch_function_t)swift_dynamicCastMetatype::$_0::__invoke, 0);
            if (swift_dynamicCastMetatype::Override) {
              uint64_t v12 = (uint64_t *)swift_dynamicCastMetatype::Override(v5, v11, swift_dynamicCastMetatypeImpl);
            }
            else {
              uint64_t v12 = swift_dynamicCastMetatypeImpl(v5, v11);
            }
            if (!v12) {
              goto LABEL_42;
            }
            unsigned int v10 = *(_DWORD *)(v6 + 8);
          }
        }
        if ((v10 & 0x80000000) != 0) {
          goto LABEL_37;
        }
        uint64_t v13 = *v5;
        if ((unint64_t)*v5 > 0x7FF) {
          LODWORD(v13) = 0;
        }
        if (!v13 || v13 == 773 || v13 == 515)
        {
LABEL_37:
          uint64_t v14 = *(unsigned int *)(v6 + 12);
          if (!v14) {
            return v5;
          }
          unint64_t v15 = (const char **)(v6 + 8 * ((v10 >> 30) & 1) + 16);
          uint64_t v16 = 8 * v14;
          while ((swift::_conformsToProtocol(0, (uint64_t)v5, *v15, 0) & 1) != 0)
          {
            ++v15;
            v16 -= 8;
            if (!v16) {
              return v5;
            }
          }
        }
LABEL_42:
        swift::swift_dynamicCastFailure((Class *)v5, (Class *)v6, 0);
      }
      if (v7 != 773) {
        goto LABEL_42;
      }
      uint64_t v6 = *(void *)(a2 + 8);
    }
    Class v9 = *(Class *)a1;
    if (*(void *)a1 > 0x7FFuLL) {
      LODWORD(v9) = 0;
    }
    if (!v9) {
      goto LABEL_22;
    }
    if (v9 != 515)
    {
      if (v9 == 773)
      {
        a1 = *(void *)(a1 + 8);
LABEL_22:
        swift_dynamicCastObjCClassMetatypeUnconditional((Class *)a1, (Class *)v6, a3, a4, a5);
        return v5;
      }
      goto LABEL_42;
    }
LABEL_27:
    swift_dynamicCastForeignClassMetatypeUnconditional(a1, v6, a3, a4, a5);
  }
  return v5;
}

void std::__function::__func<std::string (*)(unsigned long long,unsigned long long),std::allocator<std::string (*)(unsigned long long,unsigned long long)>,std::string ()(unsigned long long,unsigned long long)>::~__func()
{
}

void *std::__function::__func<std::string (*)(unsigned long long,unsigned long long),std::allocator<std::string (*)(unsigned long long,unsigned long long)>,std::string ()(unsigned long long,unsigned long long)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ECA041D0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::string (*)(unsigned long long,unsigned long long),std::allocator<std::string (*)(unsigned long long,unsigned long long)>,std::string ()(unsigned long long,unsigned long long)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ECA041D0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::string (*)(unsigned long long,unsigned long long),std::allocator<std::string (*)(unsigned long long,unsigned long long)>,std::string ()(unsigned long long,unsigned long long)>::operator()(uint64_t a1, void *a2, void *a3)
{
  return (*(uint64_t (**)(void, void))(a1 + 8))(*a2, *a3);
}

void *swift_dynamicCastClass::$_0::__invoke(swift_dynamicCastClass::$_0 *this, void *a2)
{
  uint64_t result = (void *)swift::getOverride_dynamicCastClass(this);
  swift_dynamicCastClass::Override = result;
  return result;
}

void *swift_dynamicCastClassUnconditional::$_0::__invoke(swift_dynamicCastClassUnconditional::$_0 *this, void *a2)
{
  uint64_t result = (void *)swift::getOverride_dynamicCastClassUnconditional(this);
  swift_dynamicCastClassUnconditional::Override = result;
  return result;
}

void *swift_dynamicCastUnknownClass::$_0::__invoke(swift_dynamicCastUnknownClass::$_0 *this, void *a2)
{
  uint64_t result = (void *)swift::getOverride_dynamicCastUnknownClass(this);
  swift_dynamicCastUnknownClass::Override = result;
  return result;
}

void *swift_dynamicCastUnknownClassUnconditional::$_0::__invoke(swift_dynamicCastUnknownClassUnconditional::$_0 *this, void *a2)
{
  uint64_t result = (void *)swift::getOverride_dynamicCastUnknownClassUnconditional(this);
  swift_dynamicCastUnknownClassUnconditional::Override = result;
  return result;
}

void *swift_dynamicCastMetatype::$_0::__invoke(swift_dynamicCastMetatype::$_0 *this, void *a2)
{
  uint64_t result = (void *)swift::getOverride_dynamicCastMetatype(this);
  swift_dynamicCastMetatype::Override = result;
  return result;
}

void *swift_dynamicCastMetatypeUnconditional::$_0::__invoke(swift_dynamicCastMetatypeUnconditional::$_0 *this, void *a2)
{
  uint64_t result = (void *)swift::getOverride_dynamicCastMetatypeUnconditional(this);
  swift_dynamicCastMetatypeUnconditional::Override = result;
  return result;
}

uint64_t __swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>,__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>::InsertIntoBucket<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>(uint64_t a1, uint64_t a2, uint64_t *a3, _OWORD *a4)
{
  int v8 = *(_DWORD *)(a1 + 8);
  unsigned int v9 = *(_DWORD *)(a1 + 16);
  if (4 * v8 + 4 >= 3 * v9)
  {
    v9 *= 2;
  }
  else if (v9 + ~v8 - *(_DWORD *)(a1 + 12) > v9 >> 3)
  {
LABEL_3:
    uint64_t v10 = *(void *)a2;
    goto LABEL_4;
  }
  __swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>::grow(a1, v9);
  uint64_t v10 = *a3;
  int v12 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v13 = v12 & (((unint64_t)*a3 >> 9) ^ *a3);
  a2 = *(void *)a1 + 24 * v13;
  uint64_t v14 = *(void *)a2;
  if (*a3 != *(void *)a2)
  {
    uint64_t v15 = 0;
    int v16 = 1;
    while (v14 != -2)
    {
      if (v15) {
        BOOL v17 = 0;
      }
      else {
        BOOL v17 = v14 == -16;
      }
      if (v17) {
        uint64_t v15 = a2;
      }
      unsigned int v18 = v13 + v16++;
      unsigned int v13 = v18 & v12;
      a2 = *(void *)a1 + 24 * (v18 & v12);
      uint64_t v14 = *(void *)a2;
      if (v10 == *(void *)a2) {
        goto LABEL_4;
      }
    }
    if (v15) {
      a2 = v15;
    }
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v10 != -2) {
    --*(_DWORD *)(a1 + 12);
  }
  *(void *)a2 = *a3;
  *(_OWORD *)(a2 + 8) = *a4;
  return a2;
}

void *__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::PointerIntPair<swift::TargetMetadata<swift::InProcess> const*,2u,TypeNameKind,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>,__swift::__runtime::llvm::PointerIntPairInfo<swift::TargetMetadata<swift::InProcess> const*,2u,__swift::__runtime::llvm::PointerLikeTypeTraits<swift::TargetMetadata<swift::InProcess> const*>>>,std::pair<char const*,unsigned long>>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(__swift::__runtime::llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = __swift::__runtime::llvm::allocate_buffer(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    unsigned int v10 = *(_DWORD *)(a1 + 16);
    if (!v10) {
      goto LABEL_16;
    }
    unint64_t v11 = 24 * v10 - 24;
    if (v11 >= 0x18)
    {
      unint64_t v16 = v11 / 0x18 + 1;
      int v12 = &result[3 * (v16 & 0x1FFFFFFFFFFFFFFELL)];
      uint64_t v17 = v16 & 0x1FFFFFFFFFFFFFFELL;
      unsigned int v18 = result;
      do
      {
        *unsigned int v18 = -2;
        v18[3] = -2;
        v18 += 6;
        v17 -= 2;
      }
      while (v17);
      if (v16 == (v16 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_16:
        if (v3)
        {
          uint64_t v20 = v4;
          do
          {
            unint64_t v22 = *(void *)v20;
            if (*(void *)v20 != -16 && v22 != -2)
            {
              int v24 = *(_DWORD *)(a1 + 16);
              if (v24)
              {
                int v25 = v24 - 1;
                unsigned int v26 = (v24 - 1) & ((v22 >> 9) ^ v22);
                uint64_t v21 = *(void *)a1 + 24 * v26;
                uint64_t v27 = *(void *)v21;
                if (v22 != *(void *)v21)
                {
                  uint64_t v28 = 0;
                  int v29 = 1;
                  while (v27 != -2)
                  {
                    if (v28) {
                      BOOL v30 = 0;
                    }
                    else {
                      BOOL v30 = v27 == -16;
                    }
                    if (v30) {
                      uint64_t v28 = v21;
                    }
                    unsigned int v31 = v26 + v29++;
                    unsigned int v26 = v31 & v25;
                    uint64_t v21 = *(void *)a1 + 24 * (v31 & v25);
                    uint64_t v27 = *(void *)v21;
                    if (v22 == *(void *)v21) {
                      goto LABEL_19;
                    }
                  }
                  if (v28) {
                    uint64_t v21 = v28;
                  }
                }
              }
              else
              {
                uint64_t v21 = 0;
              }
LABEL_19:
              *(void *)uint64_t v21 = v22;
              *(_OWORD *)(v21 + 8) = *(_OWORD *)((char *)v20 + 8);
              ++*(_DWORD *)(a1 + 8);
            }
            uint64_t v20 = (__swift::__runtime::llvm *)((char *)v20 + 24);
          }
          while (v20 != (__swift::__runtime::llvm *)((char *)v4 + 24 * v3));
        }
        __swift::__runtime::llvm::deallocate_buffer(v4, (void *)(24 * v3));
      }
    }
    else
    {
      int v12 = result;
    }
    uint64_t v19 = &result[3 * v10];
    do
    {
      void *v12 = -2;
      v12 += 3;
    }
    while (v12 != v19);
    goto LABEL_16;
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v13 = *(_DWORD *)(a1 + 16);
  if (v13)
  {
    unint64_t v14 = 24 * v13 - 24;
    if (v14 < 0x18)
    {
      uint64_t v15 = result;
LABEL_45:
      uint64_t v35 = &result[3 * v13];
      do
      {
        void *v15 = -2;
        v15 += 3;
      }
      while (v15 != v35);
      return result;
    }
    unint64_t v32 = v14 / 0x18 + 1;
    uint64_t v15 = &result[3 * (v32 & 0x1FFFFFFFFFFFFFFELL)];
    uint64_t v33 = v32 & 0x1FFFFFFFFFFFFFFELL;
    uint64_t v34 = result;
    do
    {
      void *v34 = -2;
      v34[3] = -2;
      v34 += 6;
      v33 -= 2;
    }
    while (v33);
    if (v32 != (v32 & 0x1FFFFFFFFFFFFFFELL)) {
      goto LABEL_45;
    }
  }
  return result;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  unint64_t v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    unsigned int v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    unint64_t v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

uint64_t __swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>,__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>::LookupBucketFor<__swift::__runtime::llvm::StringRef>(uint64_t *a1, uint64_t a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    uint64_t v7 = 0;
    int v8 = v4 - 1;
    unsigned int v9 = (v4 - 1) & __swift::__runtime::llvm::hash_value(*(void **)a2, *(void *)(a2 + 8));
    unsigned int v10 = *(const void **)a2;
    size_t v11 = *(void *)(a2 + 8);
    for (int i = 1; ; ++i)
    {
      uint64_t v13 = v6 + 32 * v9;
      unint64_t v14 = *(const void **)v13;
      if (*(void *)v13 == -2)
      {
        if (v10 == (const void *)-2) {
          goto LABEL_19;
        }
      }
      else if (v14 == (const void *)-1)
      {
        if (v10 == (const void *)-1) {
          goto LABEL_19;
        }
      }
      else if (v11 == *(void *)(v13 + 8) && (!v11 || !memcmp(v10, *(const void **)v13, v11)))
      {
LABEL_19:
        uint64_t result = 1;
        goto LABEL_21;
      }
      if (v14 == (const void *)-1) {
        break;
      }
      if (v7) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v14 == (const void *)-2;
      }
      if (v15) {
        uint64_t v7 = v6 + 32 * v9;
      }
      unsigned int v16 = v9 + i;
      unsigned int v9 = v16 & v8;
    }
    uint64_t result = 0;
    if (v7) {
      uint64_t v13 = v7;
    }
  }
  else
  {
    uint64_t v13 = 0;
    uint64_t result = 0;
  }
LABEL_21:
  *a3 = v13;
  return result;
}

void swift::Demangle::__runtime::StackAllocatedDemangler<1024ul>::~StackAllocatedDemangler(uint64_t a1)
{
  *(void *)a1 = &unk_1ECA07790;
  uint64_t v2 = a1 + 544;
  uint64_t v3 = *(void *)(a1 + 568);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  *(void *)a1 = &unk_1ECA07768;
  swift::Demangle::__runtime::NodeFactory::freeSlabs(*(void **)(a1 + 24));
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4) {
    *(unsigned char *)(v4 + 48) = 0;
  }

  JUMPOUT(0x1852FF000);
}

void *__swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>,__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>::InsertIntoBucketImpl<__swift::__runtime::llvm::StringRef>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  __swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>::grow(a1, v7);
  unsigned int v9 = 0;
  __swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>,__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>::LookupBucketFor<__swift::__runtime::llvm::StringRef>((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

_OWORD *__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(__swift::__runtime::llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = __swift::__runtime::llvm::allocate_buffer(32 * v8, (std::align_val_t)8uLL);
  unsigned int v10 = result;
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v11 = *(unsigned int *)(a1 + 16);
    if (v11)
    {
      if (((v11 - 1) & 0x7FFFFFFFFFFFFFFLL) == 0) {
        goto LABEL_10;
      }
      uint64_t v12 = ((v11 - 1) & 0x7FFFFFFFFFFFFFFLL) + 1;
      unsigned int v10 = &result[2 * (v12 & 0xFFFFFFFFFFFFFFELL)];
      uint64_t v13 = result + 2;
      uint64_t v14 = v12 & 0xFFFFFFFFFFFFFFELL;
      do
      {
        *(v13 - 2) = xmmword_181636940;
        *uint64_t v13 = xmmword_181636940;
        v13 += 4;
        v14 -= 2;
      }
      while (v14);
      if (v12 != (v12 & 0xFFFFFFFFFFFFFFELL))
      {
LABEL_10:
        BOOL v15 = &result[2 * v11];
        do
        {
          *unsigned int v10 = xmmword_181636940;
          v10 += 2;
        }
        while (v10 != v15);
      }
    }
    unsigned int v16 = (void *)(32 * v3);
    if (v3)
    {
      uint64_t v17 = 32 * v3;
      unsigned int v18 = v4;
      do
      {
        if (*(void *)v18 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          int v25 = 0;
          __swift::__runtime::llvm::DenseMapBase<__swift::__runtime::llvm::DenseMap<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>,__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>,__swift::__runtime::llvm::DenseMapInfo<__swift::__runtime::llvm::StringRef>,__swift::__runtime::llvm::detail::DenseMapPair<__swift::__runtime::llvm::StringRef,std::pair<char const*,unsigned long>>>::LookupBucketFor<__swift::__runtime::llvm::StringRef>((uint64_t *)a1, (uint64_t)v18, &v25);
          uint64_t v19 = v25;
          *int v25 = *(_OWORD *)v18;
          v19[1] = *((_OWORD *)v18 + 1);
          ++*(_DWORD *)(a1 + 8);
        }
        unsigned int v18 = (__swift::__runtime::llvm *)((char *)v18 + 32);
        v17 -= 32;
      }
      while (v17);
    }
    __swift::__runtime::llvm::deallocate_buffer(v4, v16);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v20 = *(unsigned int *)(a1 + 16);
  if (v20)
  {
    if (((v20 - 1) & 0x7FFFFFFFFFFFFFFLL) == 0) {
      goto LABEL_23;
    }
    uint64_t v21 = ((v20 - 1) & 0x7FFFFFFFFFFFFFFLL) + 1;
    unsigned int v10 = &result[2 * (v21 & 0xFFFFFFFFFFFFFFELL)];
    unint64_t v22 = result + 2;
    uint64_t v23 = v21 & 0xFFFFFFFFFFFFFFELL;
    do
    {
      *(v22 - 2) = xmmword_181636940;
      _OWORD *v22 = xmmword_181636940;
      v22 += 4;
      v23 -= 2;
    }
    while (v23);
    if (v21 != (v21 & 0xFFFFFFFFFFFFFFELL))
    {
LABEL_23:
      int v24 = &result[2 * v20];
      do
      {
        *unsigned int v10 = xmmword_181636940;
        v10 += 2;
      }
      while (v10 != v24);
    }
  }
  return result;
}

swift::Demangle::__runtime::Node *swift::_buildDemanglingForContext(uint64_t a1, const char *a2, uint64_t a3, swift::Demangle::__runtime::NodeFactory *a4)
{
  long long v110 = v112;
  uint64_t v111 = 0x800000000;
  if (a1)
  {
    uint64_t v6 = a1;
    unsigned int v7 = 0;
    while (1)
    {
      if (v7 >= HIDWORD(v111))
      {
        __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v110, (uint64_t)v112, v7 + 1, 8);
        unsigned int v7 = v111;
      }
      *(void *)&v110[8 * v7] = v6;
      unsigned int v7 = v111 + 1;
      LODWORD(v111) = v111 + 1;
      uint64_t v9 = v6 + 4;
      uint64_t v8 = *(int *)(v6 + 4);
      if (!v8) {
        break;
      }
      unsigned int v10 = (uint64_t *)((v8 & 0xFFFFFFFFFFFFFFFELL) + v9);
      if (v8)
      {
        if (!*v10) {
          break;
        }
        uint64_t v6 = *v10;
      }
      else
      {
        if (!v10) {
          break;
        }
        uint64_t v6 = (v8 & 0xFFFFFFFFFFFFFFFELL) + v9;
      }
    }
    if (v7)
    {
      long long v93 = a2;
      uint64_t v11 = 0;
      unint64_t v95 = 0;
      uint64_t v12 = v110;
      uint64_t v13 = &v110[8 * v7];
      uint64_t v14 = a3;
      long long v97 = v110;
      while (1)
      {
        uint64_t v21 = (_DWORD *)*((void *)v13 - 1);
        v13 -= 8;
        uint64_t v20 = v21;
        unint64_t v22 = v21;
        int v23 = *v21;
        int v24 = *v21 & 0x1F;
        if (v24 == 3)
        {
          if (v20) {
            BOOL v15 = v20;
          }
          else {
            BOOL v15 = 0;
          }
          unsigned int v16 = (char *)v15 + v15[2] + 8;
          Node = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 180);
          swift::Demangle::__runtime::Node::addChild(Node, v11, a4);
          unsigned int v18 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 101, v16);
          uint64_t v19 = Node;
        }
        else
        {
          int v25 = v22;
          if (v24 == 1)
          {
            if (v20) {
              uint64_t v27 = v20;
            }
            else {
              uint64_t v27 = 0;
            }
            uint64_t v31 = (int)v27[2];
            if (v31) {
              unint64_t v32 = (char *)v27 + v31 + 8;
            }
            else {
              unint64_t v32 = 0;
            }
            SymbolicMangledNameStringRef = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef(v32, a2);
            v108[0] = &unk_1ECA04240;
            v108[1] = a4;
            long long v109 = v108;
            unint64_t v35 = swift::Demangle::__runtime::Demangler::demangleType((uint64_t)a4, (uint64_t)SymbolicMangledNameStringRef, v34, v108);
            if (v109 == v108)
            {
              (*(void (**)(void *))(v108[0] + 32))(v108);
            }
            else if (v109)
            {
              (*(void (**)(void))(*v109 + 40))();
            }
            if (*(_WORD *)(v35 + 16) == 232)
            {
              int v36 = *(unsigned __int8 *)(v35 + 18);
              if ((v36 - 1) < 2) {
                goto LABEL_55;
              }
              if (v36 == 5)
              {
                if (*(_DWORD *)(v35 + 8))
                {
                  unint64_t v35 = *(void *)v35;
LABEL_55:
                  unint64_t v35 = *(void *)v35;
                  if (!v14)
                  {
LABEL_127:
                    long long v48 = 0;
                    goto LABEL_128;
                  }
                }
                else
                {
                  unint64_t v35 = 0;
                  if (!v14) {
                    goto LABEL_127;
                  }
                }
LABEL_71:
                if ((*v25 & 0x1F) == 2) {
                  goto LABEL_127;
                }
                uint64_t GenericContext = swift::TargetContextDescriptor<swift::InProcess>::getGenericContext(v20);
                if (!GenericContext) {
                  goto LABEL_127;
                }
                uint64_t v47 = GenericContext;
                if (v95 >= *(unsigned __int16 *)(GenericContext + 4)) {
                  goto LABEL_127;
                }
                long long v48 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 235);
                unint64_t v49 = *(unsigned __int16 *)(v47 + 4);
                if (v95 < v49)
                {
                  int v50 = (swift::Demangle::__runtime::Node **)&v93[8 * v95];
                  unint64_t v51 = v49 - v95;
                  do
                  {
                    int v52 = *v50++;
                    swift::Demangle::__runtime::Node::addChild(v48, v52, a4);
                    --v51;
                  }
                  while (v51);
                  unint64_t v95 = v49;
                  uint64_t v14 = a3;
                }
LABEL_128:
                unsigned int v82 = *(unsigned __int16 *)(v35 + 16);
                if (v82 > 0x11 || ((1 << v82) & 0x2E000) == 0) {
                  goto LABEL_152;
                }
                if (v48)
                {
                  long long v84 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, v82);
                  long long v85 = v84;
                  int v86 = *(unsigned __int8 *)(v35 + 18);
                  if ((v86 - 1) < 2) {
                    goto LABEL_137;
                  }
                  if (v86 == 5 && *(_DWORD *)(v35 + 8))
                  {
                    unint64_t v35 = *(void *)v35;
LABEL_137:
                    long long v87 = *(swift::Demangle::__runtime::Node **)v35;
                  }
                  else
                  {
                    long long v87 = 0;
                  }
                  swift::Demangle::__runtime::Node::addChild(v84, v87, a4);
                  swift::Demangle::__runtime::Node::addChild(v85, v48, a4);
                  unint64_t v35 = (unint64_t)v85;
                  goto LABEL_152;
                }
                int v88 = *(unsigned __int8 *)(v35 + 18);
                if ((v88 - 1) < 2)
                {
LABEL_142:
                  unint64_t v89 = *(void *)v35;
                }
                else
                {
                  if (v88 == 5 && *(_DWORD *)(v35 + 8))
                  {
                    unint64_t v35 = *(void *)v35;
                    goto LABEL_142;
                  }
                  unint64_t v89 = 0;
                }
                int v90 = *(unsigned __int8 *)(v89 + 18);
                if ((v90 - 1) >= 2)
                {
                  if (v90 != 5 || !*(_DWORD *)(v89 + 8))
                  {
                    unint64_t v35 = 0;
                    goto LABEL_152;
                  }
                  unint64_t v89 = *(void *)v89;
                }
                unint64_t v35 = *(void *)v89;
LABEL_152:
                Node = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 71);
                swift::Demangle::__runtime::Node::addChild(Node, v11, a4);
                swift::Demangle::__runtime::Node::addChild(Node, (swift::Demangle::__runtime::Node *)v35, a4);
                uint64_t v12 = v97;
                goto LABEL_17;
              }
              unint64_t v35 = 0;
            }
            if (!v14) {
              goto LABEL_127;
            }
            goto LABEL_71;
          }
          if (!v24)
          {
            if (v20) {
              unsigned int v26 = (char *)v20;
            }
            else {
              unsigned int v26 = 0;
            }
            Node = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 153, &v26[*((int *)v26 + 2) + 8]);
            goto LABEL_17;
          }
          if (v20 && (v23 & 0x10) != 0)
          {
            swift::ParsedTypeIdentity::parse((uint64_t)v20, (uint64_t)__str);
            if (v24 == 16)
            {
              __int16 v29 = 24;
              __int16 v28 = 13;
              if (!v107) {
                goto LABEL_84;
              }
            }
            else
            {
              if (v24 == 17)
              {
                __int16 v53 = 219;
                __int16 v28 = 15;
                if (v107 && v104 == 1)
                {
                  if (*v103 == 116) {
                    __int16 v53 = 234;
                  }
                  else {
                    __int16 v53 = 219;
                  }
                }
                goto LABEL_87;
              }
              if (v24 == 18) {
                __int16 v28 = 14;
              }
              else {
                __int16 v28 = 17;
              }
              if (v24 == 18) {
                __int16 v29 = 61;
              }
              else {
                __int16 v29 = 167;
              }
              if (!v107)
              {
LABEL_84:
                if (swift::_isCImportedTagType(v20, (uint64_t)__str)) {
                  __int16 v53 = 219;
                }
                else {
                  __int16 v53 = v29;
                }
                goto LABEL_87;
              }
            }
            if (v104 != 1) {
              goto LABEL_84;
            }
            __int16 v53 = *v103 == 116 ? 234 : 219;
            if (*v103 != 116) {
              goto LABEL_84;
            }
LABEL_87:
            __int16 v94 = v28;
            Node = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, v53);
            swift::Demangle::__runtime::Node::addChild(Node, v11, a4);
            if (v107) {
              BOOL v54 = v102 == 0;
            }
            else {
              BOOL v54 = 1;
            }
            if (v54) {
              size_t v55 = v100;
            }
            else {
              size_t v55 = v102;
            }
            long long v56 = (char *)&v101;
            if (v54) {
              long long v56 = __str;
            }
            if (v55)
            {
              uint64_t v57 = *(const void **)v56;
              long long v58 = (char *)*((void *)a4 + 1);
              if (!v58 || (long long v59 = &v58[v55], (unint64_t)&v58[v55] > *((void *)a4 + 2)))
              {
                unint64_t v60 = 2 * *((void *)a4 + 4);
                if (v60 <= v55 + 1) {
                  unint64_t v60 = v55 + 1;
                }
                *((void *)a4 + 4) = v60;
                unint64_t v61 = v60 + 8;
                unsigned int v62 = malloc_type_malloc(v60 + 8, 0xD0263BC5uLL);
                *unsigned int v62 = *((void *)a4 + 3);
                long long v58 = (char *)(v62 + 1);
                *((void *)a4 + 2) = (char *)v62 + v61;
                *((void *)a4 + 3) = v62;
                long long v59 = (char *)v62 + v55 + 8;
              }
              *((void *)a4 + 1) = v59;
              memmove(v58, v57, v55);
            }
            else
            {
              long long v58 = 0;
            }
            NodeWithAllocatedText = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText(a4, 101, (uint64_t)v58, v55);
            if (v107)
            {
              size_t v64 = __len;
              if (__len)
              {
                unint64_t v65 = __src;
                unsigned int v66 = (char *)*((void *)a4 + 1);
                if (!v66 || (long long v67 = &v66[__len], (unint64_t)&v66[__len] > *((void *)a4 + 2)))
                {
                  size_t v68 = 2 * *((void *)a4 + 4);
                  if (v68 <= __len + 1) {
                    size_t v68 = __len + 1;
                  }
                  *((void *)a4 + 4) = v68;
                  size_t v69 = v68 + 8;
                  uint64_t v70 = malloc_type_malloc(v68 + 8, 0xD0263BC5uLL);
                  *uint64_t v70 = *((void *)a4 + 3);
                  unsigned int v66 = (char *)(v70 + 1);
                  long long v71 = (char *)v70 + v69;
                  uint64_t v12 = v97;
                  *((void *)a4 + 2) = v71;
                  *((void *)a4 + 3) = v70;
                  long long v67 = (char *)v70 + v64 + 8;
                }
                *((void *)a4 + 1) = v67;
                memmove(v66, v65, v64);
                long long v72 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText(a4, 101, (uint64_t)v66, v64);
                uint64_t v73 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 205);
                swift::Demangle::__runtime::Node::addChild(v73, v72, a4);
                swift::Demangle::__runtime::Node::addChild(v73, NodeWithAllocatedText, a4);
                NodeWithAllocatedText = v73;
              }
            }
            swift::Demangle::__runtime::Node::addChild(Node, NodeWithAllocatedText, a4);
            uint64_t v14 = a3;
            if (!a3) {
              goto LABEL_17;
            }
            if ((*v25 & 0x1F) == 2) {
              goto LABEL_17;
            }
            uint64_t v74 = swift::TargetContextDescriptor<swift::InProcess>::getGenericContext(v20);
            if (!v74) {
              goto LABEL_17;
            }
            uint64_t v75 = v74;
            if (v95 >= *(unsigned __int16 *)(v74 + 4)) {
              goto LABEL_17;
            }
            long long v76 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 235);
            unint64_t v77 = *(unsigned __int16 *)(v75 + 4);
            if (v95 < v77)
            {
              char v78 = (swift::Demangle::__runtime::Node **)&v93[8 * v95];
              unint64_t v79 = v77 - v95;
              do
              {
                uint64_t v80 = *v78++;
                swift::Demangle::__runtime::Node::addChild(v76, v80, a4);
                --v79;
              }
              while (v79);
              unint64_t v95 = v77;
              uint64_t v14 = a3;
            }
            if (!v76) {
              goto LABEL_17;
            }
            uint64_t v81 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 232);
            swift::Demangle::__runtime::Node::addChild(v81, Node, a4);
            Node = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, v94);
            swift::Demangle::__runtime::Node::addChild(Node, v81, a4);
            uint64_t v19 = Node;
            unsigned int v18 = v76;
            goto LABEL_16;
          }
          if (v20) {
            BOOL v30 = v22;
          }
          else {
            BOOL v30 = 0;
          }
          snprintf(__str, 0x12uLL, "$%lx", v30);
          Node = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 1);
          v98[0] = 0;
          v98[1] = 0;
          size_t v37 = strlen(__str);
          swift::Demangle::__runtime::CharVector::append(v98, __str, v37, a4);
          uint64_t v38 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 101, (uint64_t *)v98);
          swift::Demangle::__runtime::Node::addChild(Node, v38, a4);
          swift::Demangle::__runtime::Node::addChild(Node, v11, a4);
          if (!v14) {
            goto LABEL_67;
          }
          if ((*v25 & 0x1F) == 2) {
            goto LABEL_67;
          }
          uint64_t v39 = swift::TargetContextDescriptor<swift::InProcess>::getGenericContext(v20);
          if (!v39) {
            goto LABEL_67;
          }
          uint64_t v40 = v39;
          if (v95 >= *(unsigned __int16 *)(v39 + 4)) {
            goto LABEL_67;
          }
          uint64_t v41 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 235);
          unint64_t v42 = *(unsigned __int16 *)(v40 + 4);
          if (v95 < v42)
          {
            uint64_t v43 = (swift::Demangle::__runtime::Node **)&v93[8 * v95];
            unint64_t v44 = v42 - v95;
            do
            {
              long long v45 = *v43++;
              swift::Demangle::__runtime::Node::addChild(v41, v45, a4);
              --v44;
            }
            while (v44);
            unint64_t v95 = v42;
            uint64_t v14 = a3;
          }
          if (!v41) {
LABEL_67:
          }
            uint64_t v41 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 235);
          uint64_t v19 = Node;
          unsigned int v18 = v41;
        }
LABEL_16:
        swift::Demangle::__runtime::Node::addChild(v19, v18, a4);
LABEL_17:
        uint64_t v11 = Node;
        if (v13 == v12) {
          goto LABEL_154;
        }
      }
    }
  }
  Node = 0;
LABEL_154:
  long long v91 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 232);
  swift::Demangle::__runtime::Node::addChild(v91, Node, a4);
  if (v110 != v112) {
    free(v110);
  }
  return v91;
}

swift::Demangle::__runtime::Node *_swift_buildDemanglingForMetadata(uint64_t a1, swift::Demangle::__runtime::NodeFactory *a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1 > 0x7FFuLL) {
    LODWORD(v4) = 0;
  }
  if ((int)v4 <= 768)
  {
    switch((int)v4)
    {
      case 512:
      case 513:
      case 514:
        uint64_t v9 = *(char **)(a1 + 8);
        if (!v9) {
          goto LABEL_30;
        }
        goto LABEL_29;
      case 515:
      case 516:
        uint64_t v9 = *(char **)(a1 + 8);
        if (v9)
        {
LABEL_29:
          int v25 = v9;
          goto LABEL_207;
        }
LABEL_30:
        unsigned int v26 = 0;
        goto LABEL_208;
      default:
        if (v4)
        {
LABEL_37:
          if ((_UNKNOWN *)a1 == &unk_1ECA05E30)
          {
            __int16 v29 = "Builtin.Int1";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05E40)
          {
            __int16 v29 = "Builtin.Int7";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05E50)
          {
            __int16 v29 = "Builtin.Int8";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05E60)
          {
            __int16 v29 = "Builtin.Int16";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05E70)
          {
            __int16 v29 = "Builtin.Int32";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05E80)
          {
            __int16 v29 = "Builtin.Int63";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05E90)
          {
            __int16 v29 = "Builtin.Int64";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05EA0)
          {
            __int16 v29 = "Builtin.Int128";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05EB0)
          {
            __int16 v29 = "Builtin.Int256";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05EC0)
          {
            __int16 v29 = "Builtin.Int512";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05ED0)
          {
            __int16 v29 = "Builtin.Word";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05EE0)
          {
            __int16 v29 = "Builtin.FPIEEE16";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05EF0)
          {
            __int16 v29 = "Builtin.FPIEEE32";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05F00)
          {
            __int16 v29 = "Builtin.FPIEEE64";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05F10)
          {
            __int16 v29 = "Builtin.FPIEEE80";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05F20)
          {
            __int16 v29 = "Builtin.FPIEEE128";
          }
          else if ((uint64_t *)a1 == &qword_1ECA05F30)
          {
            __int16 v29 = "Builtin.NativeObject";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05F40)
          {
            __int16 v29 = "Builtin.BridgeObject";
          }
          else if ((char *)a1 == &byte_1ECA05F50)
          {
            __int16 v29 = "Builtin.RawPointer";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05F60)
          {
            __int16 v29 = "Builtin.UnsafeValueBuffer";
          }
          else if ((uint64_t *)a1 == &qword_1ECA05F70)
          {
            __int16 v29 = "Builtin.UnknownObject";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05F80)
          {
            __int16 v29 = "Builtin.RawUnsafeContinuation";
          }
          else if ((char *)a1 == &byte_1ECA05F90)
          {
            __int16 v29 = "Builtin.DefaultActorStorage";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05FA0)
          {
            __int16 v29 = "Builtin.NonDefaultDistributedActorStorage";
          }
          else if ((uint64_t *)a1 == &qword_1ECA05FB0)
          {
            __int16 v29 = "Builtin.Executor";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05FC0)
          {
            __int16 v29 = "Builtin.Job";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05FD0)
          {
            __int16 v29 = "Builtin.Vec2xInt8";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05FE0)
          {
            __int16 v29 = "Builtin.Vec3xInt8";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA05FF0)
          {
            __int16 v29 = "Builtin.Vec4xInt8";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06000)
          {
            __int16 v29 = "Builtin.Vec8xInt8";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06010)
          {
            __int16 v29 = "Builtin.Vec16xInt8";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06020)
          {
            __int16 v29 = "Builtin.Vec32xInt8";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06030)
          {
            __int16 v29 = "Builtin.Vec64xInt8";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06040)
          {
            __int16 v29 = "Builtin.Vec2xInt16";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06050)
          {
            __int16 v29 = "Builtin.Vec3xInt16";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06060)
          {
            __int16 v29 = "Builtin.Vec4xInt16";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06070)
          {
            __int16 v29 = "Builtin.Vec8xInt16";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06080)
          {
            __int16 v29 = "Builtin.Vec16xInt16";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06090)
          {
            __int16 v29 = "Builtin.Vec32xInt16";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA060A0)
          {
            __int16 v29 = "Builtin.Vec64xInt16";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA060B0)
          {
            __int16 v29 = "Builtin.Vec2xInt32";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA060C0)
          {
            __int16 v29 = "Builtin.Vec3xInt32";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA060D0)
          {
            __int16 v29 = "Builtin.Vec4xInt32";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA060E0)
          {
            __int16 v29 = "Builtin.Vec8xInt32";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA060F0)
          {
            __int16 v29 = "Builtin.Vec16xInt32";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06100)
          {
            __int16 v29 = "Builtin.Vec32xInt32";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06110)
          {
            __int16 v29 = "Builtin.Vec64xInt32";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06120)
          {
            __int16 v29 = "Builtin.Vec2xInt64";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06130)
          {
            __int16 v29 = "Builtin.Vec3xInt64";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06140)
          {
            __int16 v29 = "Builtin.Vec4xInt64";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06150)
          {
            __int16 v29 = "Builtin.Vec8xInt64";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06160)
          {
            __int16 v29 = "Builtin.Vec16xInt64";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06170)
          {
            __int16 v29 = "Builtin.Vec32xInt64";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06180)
          {
            __int16 v29 = "Builtin.Vec64xInt64";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06190)
          {
            __int16 v29 = "Builtin.Vec2xFPIEEE32";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA061A0)
          {
            __int16 v29 = "Builtin.Vec3xFPIEEE32";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA061B0)
          {
            __int16 v29 = "Builtin.Vec4xFPIEEE32";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA061C0)
          {
            __int16 v29 = "Builtin.Vec8xFPIEEE32";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA061D0)
          {
            __int16 v29 = "Builtin.Vec16xFPIEEE32";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA061E0)
          {
            __int16 v29 = "Builtin.Vec32xFPIEEE32";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA061F0)
          {
            __int16 v29 = "Builtin.Vec64xFPIEEE32";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06200)
          {
            __int16 v29 = "Builtin.Vec2xFPIEEE64";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06210)
          {
            __int16 v29 = "Builtin.Vec3xFPIEEE64";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06220)
          {
            __int16 v29 = "Builtin.Vec4xFPIEEE64";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06230)
          {
            __int16 v29 = "Builtin.Vec8xFPIEEE64";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06240)
          {
            __int16 v29 = "Builtin.Vec16xFPIEEE64";
          }
          else if ((_UNKNOWN *)a1 == &unk_1ECA06250)
          {
            __int16 v29 = "Builtin.Vec32xFPIEEE64";
          }
          else
          {
            if ((_UNKNOWN *)a1 != &unk_1ECA06260) {
              return 0;
            }
            __int16 v29 = "Builtin.Vec64xFPIEEE64";
          }
          Node = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 20, v29);
          if (Node) {
            return Node;
          }
          return 0;
        }
        if ((*(unsigned char *)(a1 + 32) & 2) == 0) {
          return 0;
        }
        uint64_t v27 = a1;
        while (!*(void *)(v27 + 64))
        {
          uint64_t v28 = v27;
          uint64_t v27 = 0;
          if (*(void *)(v28 + 8)) {
            uint64_t v27 = *(void *)(v28 + 8);
          }
        }
        int v25 = *(char **)(v27 + 64);
LABEL_207:
        unsigned int v26 = v25;
LABEL_208:
        v162 = v164;
        *(void *)v163 = 0x800000000;
        if ((*(_DWORD *)v26 & 0x80) != 0)
        {
          int v102 = *(_DWORD *)v26 & 0x1F;
          if ((v102 - 17) >= 2)
          {
            if (v102 != 16) {
              abort();
            }
            if (v26) {
              long long v106 = v26;
            }
            else {
              long long v106 = 0;
            }
            if ((*(_DWORD *)v106 & 0x20000000) != 0)
            {
              int ResilientImmediateMembersOffset = swift::getResilientImmediateMembersOffset((uint64_t)v106);
            }
            else
            {
              if ((*(_DWORD *)v106 & 0x10000000) != 0)
              {
                int v107 = 0;
                uint64_t v108 = 24;
              }
              else
              {
                int v107 = *((_DWORD *)v106 + 7);
                uint64_t v108 = 32;
              }
              int ResilientImmediateMembersOffset = v107 - *(_DWORD *)&v106[v108];
            }
          }
          else
          {
            int ResilientImmediateMembersOffset = 2;
          }
          if (!_buildDemanglingForGenericArgs(v26, v3 + 8 * ResilientImmediateMembersOffset, (uint64_t)&v162, a2))
          {
            Node = 0;
            goto LABEL_219;
          }
          uint64_t v101 = (const char *)v162;
          uint64_t v100 = v163[0];
        }
        else
        {
          uint64_t v100 = 0;
          uint64_t v101 = v164;
        }
        if (v26) {
          uint64_t v104 = (uint64_t)v26;
        }
        else {
          uint64_t v104 = 0;
        }
        Node = swift::_buildDemanglingForContext(v104, v101, v100, a2);
LABEL_219:
        long long v105 = v162;
        if (v162 == v164) {
          return Node;
        }
        goto LABEL_220;
    }
  }
  Node = 0;
  switch((int)v4)
  {
    case 769:
      uint64_t v6 = *(char **)(a1 + 16);
      Node = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 223);
      uint64_t v7 = *(unsigned int *)(v3 + 8);
      if (!*(_DWORD *)(v3 + 8)) {
        return Node;
      }
      for (int i = (void *)(v3 + 24); ; i += 2)
      {
        uint64_t v13 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 224);
        if (v6)
        {
          uint64_t v14 = strchr(v6, 32);
          if (v14)
          {
            BOOL v15 = v14;
            if (v6 != v14)
            {
              int64_t v16 = v14 - v6;
              uint64_t v17 = (char *)*((void *)a2 + 1);
              if (!v17 || (unsigned int v18 = &v17[v16], (unint64_t)&v17[v16] > *((void *)a2 + 2)))
              {
                unint64_t v19 = 2 * *((void *)a2 + 4);
                if (v19 <= v16 + 1) {
                  unint64_t v19 = v16 + 1;
                }
                *((void *)a2 + 4) = v19;
                unint64_t v20 = v19 + 8;
                uint64_t v21 = malloc_type_malloc(v19 + 8, 0xD0263BC5uLL);
                *uint64_t v21 = *((void *)a2 + 3);
                uint64_t v17 = (char *)(v21 + 1);
                *((void *)a2 + 2) = (char *)v21 + v20;
                *((void *)a2 + 3) = v21;
                unsigned int v18 = (char *)v21 + v16 + 8;
              }
              *((void *)a2 + 1) = v18;
              memmove(v17, v6, v15 - v6);
              NodeWithAllocatedText = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText(a2, 225, (uint64_t)v17, v15 - v6);
              swift::Demangle::__runtime::Node::addChild(v13, NodeWithAllocatedText, a2);
            }
            uint64_t v6 = v15 + 1;
          }
        }
        uint64_t v23 = _swift_buildDemanglingForMetadata(*i, a2);
        if (!v23) {
          break;
        }
        int v24 = (swift::Demangle::__runtime::Node *)v23;
        if (*(_WORD *)(v23 + 16) == 232)
        {
          uint64_t v11 = v13;
          uint64_t v12 = v24;
        }
        else
        {
          unsigned int v10 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 232);
          swift::Demangle::__runtime::Node::addChild(v10, v24, a2);
          uint64_t v11 = v13;
          uint64_t v12 = v10;
        }
        swift::Demangle::__runtime::Node::addChild(v11, v12, a2);
        swift::Demangle::__runtime::Node::addChild(Node, v13, a2);
        if (!--v7) {
          return Node;
        }
      }
      return 0;
    case 770:
      uint64_t v35 = *(void *)(a1 + 8);
      switch(BYTE2(v35))
      {
        case 0:
          if ((v35 & 0x4000000) != 0) {
            __int16 v36 = 82;
          }
          else {
            __int16 v36 = 65;
          }
          break;
        case 1:
          __int16 v36 = 165;
          break;
        case 2:
          __int16 v36 = 222;
          break;
        case 3:
          __int16 v36 = 22;
          break;
        default:
          __int16 v36 = 0;
          break;
      }
      v162 = v164;
      *(void *)v163 = 0x800000000;
      uint64_t v109 = (unsigned __int16)v35;
      if (!(_WORD)v35) {
        goto LABEL_266;
      }
      __int16 v161 = v36;
      uint64_t v110 = 0;
      uint64_t v111 = a1 + 24;
      do
      {
        uint64_t v112 = v3;
        uint64_t v113 = *(void *)(v3 + 8);
        if ((v113 & 0x2000000) != 0) {
          unsigned int v114 = *(_DWORD *)(v111 + 8 * (unsigned __int16)v113 + 4 * v110);
        }
        else {
          unsigned int v114 = 0;
        }
        uint64_t v115 = _swift_buildDemanglingForMetadata(*(void *)(v111 + 8 * v110), a2);
        if (!v115) {
          goto LABEL_285;
        }
        v116 = (swift::Demangle::__runtime::Node *)v115;
        if ((v114 & 0x200) != 0)
        {
          v117 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 326);
          swift::Demangle::__runtime::Node::addChild(v117, v116, a2);
          v116 = v117;
        }
        unsigned int v118 = (v114 & 0x7F) - 1;
        if (v118 > 2)
        {
          if ((v114 & 0x400) == 0)
          {
LABEL_254:
            if ((v114 & 0x800) == 0) {
              goto LABEL_256;
            }
LABEL_255:
            v121 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 128);
            swift::Demangle::__runtime::Node::addChild(v121, v116, a2);
            v116 = v121;
            goto LABEL_256;
          }
        }
        else
        {
          v119 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 0xD100D0007BuLL >> (16 * v118));
          swift::Demangle::__runtime::Node::addChild(v119, v116, a2);
          v116 = v119;
          if ((v114 & 0x400) == 0) {
            goto LABEL_254;
          }
        }
        v120 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 127);
        swift::Demangle::__runtime::Node::addChild(v120, v116, a2);
        v116 = v120;
        if ((v114 & 0x800) != 0) {
          goto LABEL_255;
        }
LABEL_256:
        uint64_t v122 = v163[0];
        if (v163[0] >= (unint64_t)v163[1])
        {
          __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v162, (uint64_t)v164, v163[0] + 1, 16);
          uint64_t v122 = v163[0];
        }
        v123 = (swift::Demangle::__runtime::Node **)((char *)v162 + 16 * v122);
        *v123 = v116;
        v123[1] = (swift::Demangle::__runtime::Node *)((v114 >> 7) & 1);
        int v124 = v163[0]++;
        ++v110;
        uint64_t v3 = v112;
      }
      while (v109 != v110);
      __int16 v36 = v161;
      if (v124 || (*((unsigned char *)v162 + 8) & 1) != 0) {
        goto LABEL_266;
      }
      v125 = *(unsigned __int8 **)v162;
      int v126 = *(unsigned __int16 *)(*(void *)v162 + 16);
      if (v126 == 232)
      {
        v127 = *(unsigned __int8 **)v162;
        if (v125[18] - 1 >= 2) {
          v127 = *(unsigned __int8 **)v125;
        }
        int v126 = *(unsigned __int16 *)(*(void *)v127 + 16);
      }
      if (v126 == 223)
      {
LABEL_266:
        v125 = (unsigned __int8 *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 223);
        if (v163[0])
        {
          v128 = (swift::Demangle::__runtime::Node **)v162;
          v129 = (swift::Demangle::__runtime::Node **)((char *)v162 + 16 * v163[0]);
          do
          {
            v133 = *v128;
            int v134 = *((unsigned __int8 *)v128 + 8);
            v135 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 224);
            if (v134)
            {
              v136 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 276);
              swift::Demangle::__runtime::Node::addChild(v135, v136, a2);
            }
            if (*((_WORD *)v133 + 8) == 232)
            {
              v131 = v135;
              v132 = v133;
            }
            else
            {
              v130 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 232);
              swift::Demangle::__runtime::Node::addChild(v130, v133, a2);
              v131 = v135;
              v132 = v130;
            }
            swift::Demangle::__runtime::Node::addChild(v131, v132, a2);
            swift::Demangle::__runtime::Node::addChild((swift::Demangle::__runtime::Node *)v125, v135, a2);
            v128 += 2;
          }
          while (v128 != v129);
        }
      }
      v137 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 3);
      v138 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 232);
      swift::Demangle::__runtime::Node::addChild(v138, (swift::Demangle::__runtime::Node *)v125, a2);
      swift::Demangle::__runtime::Node::addChild(v137, v138, a2);
      uint64_t v139 = _swift_buildDemanglingForMetadata(*(void *)(v3 + 16), a2);
      if (!v139) {
        goto LABEL_285;
      }
      v140 = (swift::Demangle::__runtime::Node *)v139;
      v141 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 207);
      swift::Demangle::__runtime::Node::addChild(v141, v140, a2);
      Node = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, v36);
      unint64_t v142 = *(void *)(v3 + 8);
      if ((v142 & 0x10000000) != 0)
      {
        uint64_t v143 = _swift_buildDemanglingForMetadata(*(void *)(((v3+ 8 * (unsigned __int16)v142+ 4* ((unsigned __int16)*(void *)(v3 + 8) & (unint64_t)((uint64_t)(*(void *)(v3 + 8) << 38) >> 63))+ 31) & 0xFFFFFFFFFFFFFFF8)+ 8 * ((v142 >> 27) & 1)), a2);
        if (v143)
        {
          v144 = (swift::Demangle::__runtime::Node *)v143;
          v145 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 67);
          swift::Demangle::__runtime::Node::addChild(v145, v144, a2);
          swift::Demangle::__runtime::Node::addChild(Node, v145, a2);
          unint64_t v142 = *(void *)(v3 + 8);
          goto LABEL_278;
        }
LABEL_285:
        Node = 0;
        goto LABEL_297;
      }
LABEL_278:
      if ((v142 & 0x8000000) != 0)
      {
        unint64_t v146 = *(void *)((v3
                          + 8 * (unsigned __int16)v142
                          + 4 * ((unsigned __int16)v142 & (unint64_t)((uint64_t)(v142 << 38) >> 63))
                          + 31) & 0xFFFFFFFFFFFFFFF8)
             - 1;
        if (v146 <= 3)
        {
          v147 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 68, qword_181636960[v146]);
          swift::Demangle::__runtime::Node::addChild(Node, v147, a2);
        }
      }
      if (*(unsigned char *)(v3 + 11))
      {
        uint64_t ThrownError = swift::TargetFunctionTypeMetadata<swift::InProcess>::getThrownError(v3);
        if (ThrownError)
        {
          uint64_t v149 = _swift_buildDemanglingForMetadata(ThrownError, a2);
          if (!v149) {
            goto LABEL_285;
          }
          v150 = (swift::Demangle::__runtime::Node *)v149;
          v151 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 273);
          swift::Demangle::__runtime::Node::addChild(v151, v150, a2);
        }
        else
        {
          v151 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 272);
        }
        swift::Demangle::__runtime::Node::addChild(Node, v151, a2);
      }
      uint64_t v152 = *(void *)(v3 + 8);
      if ((v152 & 0x40000000) != 0)
      {
        v153 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 66);
        swift::Demangle::__runtime::Node::addChild(Node, v153, a2);
        uint64_t v152 = *(void *)(v3 + 8);
      }
      if ((v152 & 0x20000000) != 0)
      {
        v154 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 271);
        swift::Demangle::__runtime::Node::addChild(Node, v154, a2);
      }
      if ((swift::TargetFunctionTypeMetadata<swift::InProcess>::getExtendedFlags(v3) & 0x10) != 0)
      {
        v155 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 130);
        swift::Demangle::__runtime::Node::addChild(Node, v155, a2);
      }
      swift::Demangle::__runtime::Node::addChild(Node, v137, a2);
      swift::Demangle::__runtime::Node::addChild(Node, v141, a2);
LABEL_297:
      long long v105 = v162;
      if (v162 != v164) {
LABEL_220:
      }
        free(v105);
      return Node;
    case 771:
      uint64_t v37 = *(unsigned int *)(a1 + 12);
      v157 = (uint64_t *)(a1 + 16);
      uint64_t v38 = (void *)(a1 + 16 + 8 * (((unint64_t)*(unsigned int *)(a1 + 8) >> 30) & 1));
      uint64_t v39 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 235);
      Node = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 190);
      swift::Demangle::__runtime::Node::addChild(Node, v39, a2);
      if (!v37) {
        goto LABEL_190;
      }
      uint64_t v40 = 8 * v37;
      uint64_t v41 = v38;
      v160 = v39;
      uint64_t v158 = v37;
      break;
    case 772:
      uint64_t v30 = _swift_buildDemanglingForMetadata(*(void *)(a1 + 8), a2);
      if (!v30) {
        return 0;
      }
      uint64_t v31 = (swift::Demangle::__runtime::Node *)v30;
      unint64_t v32 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 232);
      swift::Demangle::__runtime::Node::addChild(v32, v31, a2);
      uint64_t v33 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 145);
      Node = v33;
      uint64_t v34 = v32;
      goto LABEL_228;
    case 773:
      Name = class_getName(*(Class *)(a1 + 8));
      uint64_t v43 = *((void *)a2 + 1);
      if (!v43 || (unint64_t v44 = (char *)(v43 + 3), (unint64_t)(v43 + 3) > *((void *)a2 + 2)))
      {
        unint64_t v45 = 2 * *((void *)a2 + 4);
        if (v45 <= 4) {
          unint64_t v45 = 4;
        }
        *((void *)a2 + 4) = v45;
        unint64_t v46 = v45 + 8;
        uint64_t v47 = malloc_type_malloc(v45 + 8, 0xD0263BC5uLL);
        *uint64_t v47 = *((void *)a2 + 3);
        unint64_t v44 = (char *)v47 + 11;
        uint64_t v43 = (uint64_t)(v47 + 1);
        *((void *)a2 + 2) = (char *)v47 + v46;
        *((void *)a2 + 3) = v47;
      }
      *((void *)a2 + 1) = v44;
      *(unsigned char *)(v43 + 2) = 67;
      *(_WORD *)uint64_t v43 = 24415;
      long long v48 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText(a2, 153, v43, 3);
      Node = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 24);
      swift::Demangle::__runtime::Node::addChild(Node, v48, a2);
      if (Name)
      {
        size_t v49 = strlen(Name);
        size_t v50 = v49;
        if (v49)
        {
          unint64_t v51 = (char *)*((void *)a2 + 1);
          if (!v51 || (int v52 = &v51[v49], (unint64_t)&v51[v49] > *((void *)a2 + 2)))
          {
            unint64_t v53 = 2 * *((void *)a2 + 4);
            if (v53 <= v49 + 1) {
              unint64_t v53 = v49 + 1;
            }
            *((void *)a2 + 4) = v53;
            unint64_t v54 = v53 + 8;
            size_t v55 = malloc_type_malloc(v53 + 8, 0xD0263BC5uLL);
            *size_t v55 = *((void *)a2 + 3);
            unint64_t v51 = (char *)(v55 + 1);
            *((void *)a2 + 2) = (char *)v55 + v54;
            *((void *)a2 + 3) = v55;
            int v52 = (char *)v55 + v50 + 8;
          }
          *((void *)a2 + 1) = v52;
          memmove(v51, Name, v50);
LABEL_227:
          uint64_t v34 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText(a2, 101, (uint64_t)v51, v50);
          uint64_t v33 = Node;
LABEL_228:
          swift::Demangle::__runtime::Node::addChild(v33, v34, a2);
          return Node;
        }
      }
      else
      {
        size_t v50 = 0;
      }
      unint64_t v51 = 0;
      goto LABEL_227;
    case 774:
      uint64_t v56 = _swift_buildDemanglingForMetadata(*(void *)(a1 + 8), a2);
      if (!v56) {
        return 0;
      }
      uint64_t v57 = (swift::Demangle::__runtime::Node *)v56;
      uint64_t v33 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 69);
      Node = v33;
      uint64_t v34 = v57;
      goto LABEL_228;
    case 775:
      return Node;
    default:
      if ((v4 - 1280) >= 2 && v4 != 1024) {
        goto LABEL_37;
      }
      return 0;
  }
  while (1)
  {
    unint64_t v61 = *v41 & 0xFFFFFFFFFFFFFFFELL;
    if ((*v41 & 1) == 0)
    {
      if (v61) {
        unint64_t v62 = *v41 & 0xFFFFFFFFFFFFFFFELL;
      }
      else {
        unint64_t v62 = 0;
      }
      unint64_t v65 = swift::_buildDemanglingForContext(v62, 0, 0, a2);
      if (!v65) {
        return 0;
      }
      long long v59 = v65;
      goto LABEL_132;
    }
    long long v63 = *(_WORD **)(v61 + 8);
    if (v63) {
      size_t v64 = strlen(*(const char **)(v61 + 8));
    }
    else {
      size_t v64 = 0;
    }
    v166 = 0;
    unint64_t v66 = swift::Demangle::__runtime::Demangler::demangleSymbol((uint64_t)a2, v63, v64, v165);
    if (v166 == v165)
    {
      (*(void (**)(void *))(v165[0] + 32))(v165);
      if (!v66) {
        goto LABEL_153;
      }
    }
    else
    {
      if (v166) {
        (*(void (**)(void *))(*v166 + 40))(v166);
      }
      if (!v66)
      {
LABEL_153:
        uint64_t v68 = *((void *)a2 + 1);
        if (!v68 || (size_t v69 = (char *)(v68 + 3), (unint64_t)(v68 + 3) > *((void *)a2 + 2)))
        {
          unint64_t v70 = 2 * *((void *)a2 + 4);
          if (v70 <= 4) {
            unint64_t v70 = 4;
          }
          *((void *)a2 + 4) = v70;
          unint64_t v71 = v70 + 8;
          long long v72 = malloc_type_malloc(v70 + 8, 0xD0263BC5uLL);
          *long long v72 = *((void *)a2 + 3);
          size_t v69 = (char *)v72 + 11;
          uint64_t v68 = (uint64_t)(v72 + 1);
          *((void *)a2 + 2) = (char *)v72 + v71;
          *((void *)a2 + 3) = v72;
        }
        *((void *)a2 + 1) = v69;
        *(unsigned char *)(v68 + 2) = 67;
        *(_WORD *)uint64_t v68 = 24415;
        uint64_t v73 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText(a2, 153, v68, 3);
        uint64_t v74 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 180);
        swift::Demangle::__runtime::Node::addChild(v74, v73, a2);
        if (v64)
        {
          uint64_t v75 = (char *)*((void *)a2 + 1);
          if (!v75 || (long long v76 = &v75[v64], (unint64_t)&v75[v64] > *((void *)a2 + 2)))
          {
            unint64_t v77 = 2 * *((void *)a2 + 4);
            if (v77 <= v64 + 1) {
              unint64_t v77 = v64 + 1;
            }
            *((void *)a2 + 4) = v77;
            unint64_t v78 = v77 + 8;
            unint64_t v79 = malloc_type_malloc(v77 + 8, 0xD0263BC5uLL);
            *unint64_t v79 = *((void *)a2 + 3);
            uint64_t v75 = (char *)(v79 + 1);
            uint64_t v80 = (char *)v79 + v78;
            uint64_t v37 = v158;
            *((void *)a2 + 2) = v80;
            *((void *)a2 + 3) = v79;
            long long v76 = (char *)v79 + v64 + 8;
          }
          *((void *)a2 + 1) = v76;
          memmove(v75, v63, v64);
        }
        else
        {
          uint64_t v75 = 0;
        }
        long long v83 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNodeWithAllocatedText(a2, 101, (uint64_t)v75, v64);
        swift::Demangle::__runtime::Node::addChild(v74, v83, a2);
        long long v84 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 232);
        swift::Demangle::__runtime::Node::addChild(v84, v74, a2);
        uint64_t v39 = v160;
        unint64_t v60 = v160;
        long long v59 = v84;
        goto LABEL_133;
      }
    }
    int v67 = *(unsigned __int8 *)(v66 + 18);
    if ((v67 - 1) < 2) {
      goto LABEL_151;
    }
    if (v67 == 5 && *(_DWORD *)(v66 + 8)) {
      break;
    }
    long long v59 = 0;
LABEL_166:
    if (*((_WORD *)v59 + 8) != 236) {
      goto LABEL_132;
    }
    int v81 = *((unsigned __int8 *)v59 + 18);
    if ((v81 - 1) < 2) {
      goto LABEL_171;
    }
    if (v81 == 5 && *((_DWORD *)v59 + 2))
    {
      long long v59 = *(swift::Demangle::__runtime::Node **)v59;
LABEL_171:
      unsigned int v82 = *(swift::Demangle::__runtime::Node **)v59;
      goto LABEL_175;
    }
    unsigned int v82 = 0;
LABEL_175:
    int v85 = *((unsigned __int8 *)v82 + 18);
    if ((v85 - 1) < 2) {
      goto LABEL_179;
    }
    if (v85 == 5 && *((_DWORD *)v82 + 2))
    {
      unsigned int v82 = *(swift::Demangle::__runtime::Node **)v82;
LABEL_179:
      int v86 = *(swift::Demangle::__runtime::Node **)v82;
      goto LABEL_181;
    }
    int v86 = 0;
LABEL_181:
    int v87 = *((unsigned __int8 *)v86 + 18);
    if ((v87 - 1) >= 2)
    {
      if (v87 != 5 || !*((_DWORD *)v86 + 2))
      {
        long long v58 = 0;
        goto LABEL_187;
      }
      int v86 = *(swift::Demangle::__runtime::Node **)v86;
    }
    long long v58 = *(swift::Demangle::__runtime::Node **)v86;
LABEL_187:
    int v88 = *((unsigned __int8 *)v58 + 18);
    if ((v88 - 1) >= 2)
    {
      if (v88 != 5 || !*((_DWORD *)v58 + 2))
      {
        long long v59 = 0;
        goto LABEL_132;
      }
      long long v58 = *(swift::Demangle::__runtime::Node **)v58;
    }
    long long v59 = *(swift::Demangle::__runtime::Node **)v58;
LABEL_132:
    unint64_t v60 = v39;
LABEL_133:
    swift::Demangle::__runtime::Node::addChild(v60, v59, a2);
    ++v41;
    v40 -= 8;
    if (!v40)
    {
LABEL_190:
      int v89 = *(_DWORD *)(a1 + 8);
      if ((v89 & 0x40000000) == 0 || (uint64_t v90 = *v157) == 0)
      {
        if (v89 < 0) {
          return Node;
        }
        if (v37)
        {
          char v96 = 0;
          long long v97 = &v38[v37];
          do
          {
            while (1)
            {
              uint64_t v98 = *v38;
              if ((*v38 & 1) == 0) {
                break;
              }
              ++v38;
              char v96 = 1;
              if (v38 == v97) {
                return Node;
              }
            }
            if ((v98 & 0xFFFFFFFFFFFFFFFELL) != 0) {
              long long v99 = (_DWORD *)(v98 & 0xFFFFFFFFFFFFFFFELL);
            }
            else {
              long long v99 = 0;
            }
            v96 |= (*v99 & 0x10000) == 0;
            ++v38;
          }
          while (v38 != v97);
          if (v96) {
            return Node;
          }
        }
        __int16 v94 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 192);
        long long v91 = v94;
        unint64_t v95 = Node;
LABEL_205:
        swift::Demangle::__runtime::Node::addChild(v94, v95, a2);
        return v91;
      }
      long long v91 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a2, 191);
      uint64_t v92 = _swift_buildDemanglingForMetadata(v90, a2);
      if (v92)
      {
        long long v93 = (swift::Demangle::__runtime::Node *)v92;
        swift::Demangle::__runtime::Node::addChild(v91, Node, a2);
        __int16 v94 = v91;
        unint64_t v95 = v93;
        goto LABEL_205;
      }
      return 0;
    }
  }
  unint64_t v66 = *(void *)v66;
LABEL_151:
  long long v59 = *(swift::Demangle::__runtime::Node **)v66;
  goto LABEL_166;
}

uint64_t swift::TargetFunctionTypeMetadata<swift::InProcess>::getThrownError(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 8);
  if ((v1 & 0x80000000) == 0) {
    return 0;
  }
  uint64_t v3 = (unsigned char *)(((a1
                 + 8 * (unsigned __int16)v1
                 + 4 * ((unsigned __int16)v1 & (unint64_t)((uint64_t)(v1 << 38) >> 63))
                 + 31) & 0xFFFFFFFFFFFFFFF8)
               + 8 * ((v1 >> 27) & 1)
               + 8 * ((v1 >> 28) & 1));
  if (*v3) {
    return *(void *)((unint64_t)&v3[4 * ((v1 >> 31) & 1) + 7] & 0xFFFFFFFFFFFFFFF8);
  }
  else {
    return 0;
  }
}

uint64_t swift::TargetFunctionTypeMetadata<swift::InProcess>::getExtendedFlags(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 8);
  if ((v1 & 0x80000000) != 0) {
    return *(unsigned int *)(((a1
  }
                             + 8 * (unsigned __int16)*(void *)(a1 + 8)
                             + 4
                             * ((unsigned __int16)*(void *)(a1 + 8) & (unint64_t)((uint64_t)(*(void *)(a1 + 8) << 38) >> 63))
                             + 31) & 0xFFFFFFFFFFFFFFF8)
                           + 8 * ((v1 >> 27) & 1)
                           + 8 * ((v1 >> 28) & 1));
  else {
    return 0;
  }
}

swift::Demangle::__runtime::Node *swift::_buildDemanglingForGenericType(char *a1, uint64_t a2, swift::Demangle::__runtime::NodeFactory *a3)
{
  if ((*(_DWORD *)a1 & 0x1Fu) - 16 > 2) {
    return 0;
  }
  uint64_t v9 = v11;
  *(void *)unsigned int v10 = 0x800000000;
  if (_buildDemanglingForGenericArgs(a1, a2, (uint64_t)&v9, a3))
  {
    if (a1) {
      uint64_t v6 = (uint64_t)a1;
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = swift::_buildDemanglingForContext(v6, (const char *)v9, v10[0], a3);
  }
  else
  {
    uint64_t v7 = 0;
  }
  if (v9 != v11) {
    free(v9);
  }
  return v7;
}

uint64_t _buildDemanglingForGenericArgs(char *a1, uint64_t a2, uint64_t a3, swift::Demangle::__runtime::NodeFactory *a4)
{
  uint64_t GenericContext = (unsigned __int16 *)swift::TargetContextDescriptor<swift::InProcess>::getGenericContext(a1);
  if (!GenericContext) {
    return 1;
  }
  uint64_t v9 = GenericContext;
  unsigned __int16 v10 = GenericContext[5];
  uint64_t v11 = v10 & 1;
  if (v10)
  {
    unint64_t v12 = GenericContext[2];
    uint64_t v13 = (_DWORD *)((((unint64_t)GenericContext + v12 + 15) & 0xFFFFFFFFFFFFFFFCLL) + 12 * GenericContext[3]);
    unsigned int v14 = HIWORD(*v13);
    BOOL v15 = &v13[v11];
    if ((unsigned __int16)*v13) {
      int64_t v16 = v15;
    }
    else {
      int64_t v16 = 0;
    }
  }
  else
  {
    unsigned int v14 = 0;
    int64_t v16 = 0;
    unint64_t v12 = GenericContext[2];
  }
  v66[0] = v67;
  v66[1] = (void *)0x600000000;
  unsigned int v18 = GenericContext + 6;
  if (v12)
  {
    if (v12 < 8)
    {
      unsigned int v19 = 0;
      unint64_t v20 = (unsigned __int8 *)(GenericContext + 6);
      goto LABEL_23;
    }
    if (v12 >= 0x20)
    {
      int32x4_t v23 = 0uLL;
      uint64_t v22 = (unsigned __int16)v12 & 0xFFE0;
      int32x4_t v24 = 0uLL;
      int v25 = (uint8x16_t *)(GenericContext + 14);
      uint64_t v26 = v22;
      int32x4_t v27 = 0uLL;
      int32x4_t v28 = 0uLL;
      int32x4_t v29 = 0uLL;
      int32x4_t v30 = 0uLL;
      int32x4_t v31 = 0uLL;
      int32x4_t v32 = 0uLL;
      do
      {
        uint8x16_t v33 = vshrq_n_u8(v25[-1], 7uLL);
        uint8x16_t v34 = vshrq_n_u8(*v25, 7uLL);
        uint16x8_t v35 = vmovl_u8(*(uint8x8_t *)v33.i8);
        uint16x8_t v36 = vmovl_high_u8(v33);
        uint16x8_t v37 = vmovl_u8(*(uint8x8_t *)v34.i8);
        uint16x8_t v38 = vmovl_high_u8(v34);
        int32x4_t v28 = (int32x4_t)vaddw_high_u16((uint32x4_t)v28, v36);
        int32x4_t v27 = (int32x4_t)vaddw_u16((uint32x4_t)v27, *(uint16x4_t *)v36.i8);
        int32x4_t v24 = (int32x4_t)vaddw_high_u16((uint32x4_t)v24, v35);
        int32x4_t v23 = (int32x4_t)vaddw_u16((uint32x4_t)v23, *(uint16x4_t *)v35.i8);
        int32x4_t v32 = (int32x4_t)vaddw_high_u16((uint32x4_t)v32, v38);
        int32x4_t v31 = (int32x4_t)vaddw_u16((uint32x4_t)v31, *(uint16x4_t *)v38.i8);
        int32x4_t v30 = (int32x4_t)vaddw_high_u16((uint32x4_t)v30, v37);
        int32x4_t v29 = (int32x4_t)vaddw_u16((uint32x4_t)v29, *(uint16x4_t *)v37.i8);
        v25 += 2;
        v26 -= 32;
      }
      while (v26);
      unsigned int v19 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v29, v23), vaddq_s32(v31, v27)), vaddq_s32(vaddq_s32(v30, v24), vaddq_s32(v32, v28))));
      if (v12 == v22) {
        goto LABEL_25;
      }
      if ((v12 & 0x18) == 0)
      {
        unint64_t v20 = &v18[v22];
LABEL_23:
        unint64_t v45 = &v18[v12];
        do
        {
          unsigned int v46 = *v20++;
          v19 += v46 >> 7;
        }
        while (v20 != v45);
LABEL_25:
        uint64_t v21 = v19;
        goto LABEL_26;
      }
    }
    else
    {
      unsigned int v19 = 0;
      uint64_t v22 = 0;
    }
    unint64_t v20 = &v18[v12 & 0xFFF8];
    int32x4_t v39 = 0uLL;
    int32x4_t v40 = (int32x4_t)v19;
    uint64_t v41 = (uint8x8_t *)((char *)GenericContext + v22 + 12);
    uint64_t v42 = v22 - ((unsigned __int16)v12 & 0xFFF8);
    do
    {
      uint8x8_t v43 = *v41++;
      uint16x8_t v44 = vmovl_u8(vshr_n_u8(v43, 7uLL));
      int32x4_t v39 = (int32x4_t)vaddw_high_u16((uint32x4_t)v39, v44);
      int32x4_t v40 = (int32x4_t)vaddw_u16((uint32x4_t)v40, *(uint16x4_t *)v44.i8);
      v42 += 8;
    }
    while (v42);
    unsigned int v19 = vaddvq_s32(vaddq_s32(v40, v39));
    if (v12 == (v12 & 0xFFF8)) {
      goto LABEL_25;
    }
    goto LABEL_23;
  }
  uint64_t v21 = 0;
LABEL_26:
  if (swift::_gatherWrittenGenericParameters(a1, a2 + 8 * v14, v21, (uint64_t)v66, (uint64_t)a4))
  {
    if (v9[2])
    {
      uint64_t v65 = a2;
      uint64_t v49 = 0;
      int v50 = 0;
      unint64_t v51 = &v18[v9[2]];
      uint64_t v64 = a3 + 16;
      do
      {
        uint64_t v52 = *((void *)v66[0] + v49);
        if ((*v18 & 0x3F) == 1)
        {
          if ((v52 & 1) == 0) {
            swift::fatalError(0, "Expected a metadata pack but got metadata\n", v47, v48);
          }
          uint64_t v57 = v16;
          unint64_t v58 = *(void *)(v65 + 8 * LOWORD(v16[2 * v50 + 1]));
          Node = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(a4, 226);
          if (v58)
          {
            unint64_t v60 = (void *)(v52 & 0xFFFFFFFFFFFFFFFELL);
            if (v58 <= 1) {
              unint64_t v58 = 1;
            }
            while (1)
            {
              unint64_t v61 = (swift::Demangle::__runtime::Node *)_swift_buildDemanglingForMetadata(*v60, a4);
              if (!v61) {
                break;
              }
              swift::Demangle::__runtime::Node::addChild(Node, v61, a4);
              ++v60;
              if (!--v58) {
                goto LABEL_47;
              }
            }
LABEL_52:
            uint64_t v17 = 0;
            goto LABEL_54;
          }
LABEL_47:
          if (!Node) {
            goto LABEL_52;
          }
          unint64_t v62 = *(unsigned int *)(a3 + 8);
          if (v62 >= *(unsigned int *)(a3 + 12))
          {
            __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod(a3, v64, v62 + 1, 8);
            unint64_t v62 = *(unsigned int *)(a3 + 8);
          }
          int64_t v16 = v57;
          *(void *)(*(void *)a3 + 8 * v62) = Node;
          ++*(_DWORD *)(a3 + 8);
          ++v50;
        }
        else
        {
          if ((*v18 & 0x3F) != 0) {
            goto LABEL_52;
          }
          if (v52) {
            BOOL v53 = (*((void *)v66[0] + v49) & 1) == 0;
          }
          else {
            BOOL v53 = 0;
          }
          if (!v53) {
            swift::fatalError(0, "Expected metadata but got a metadata pack\n", v47, v48);
          }
          uint64_t v54 = _swift_buildDemanglingForMetadata(*((void *)v66[0] + v49), a4);
          if (!v54) {
            goto LABEL_52;
          }
          uint64_t v55 = v54;
          unint64_t v56 = *(unsigned int *)(a3 + 8);
          if (v56 >= *(unsigned int *)(a3 + 12))
          {
            __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod(a3, v64, v56 + 1, 8);
            unint64_t v56 = *(unsigned int *)(a3 + 8);
          }
          *(void *)(*(void *)a3 + 8 * v56) = v55;
          ++*(_DWORD *)(a3 + 8);
        }
        ++v49;
        ++v18;
      }
      while (v18 != v51);
      uint64_t v17 = 1;
    }
    else
    {
      uint64_t v17 = 1;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
LABEL_54:
  if (v66[0] != v67) {
    free(v66[0]);
  }
  return v17;
}

uint64_t swift_demangle(swift::Demangle::__runtime *this, const char *a2, const char *a3, char *a4, int a5)
{
  if (a5) {
    swift::fatalError(0, "Only 'flags' value of '0' is currently supported.", a3, a4);
  }
  if (a3 && !a4) {
    swift::fatalError(0, "'outputBuffer' is passed but the size is 'nullptr'.", a3, 0);
  }
  if (swift::Demangle::__runtime::isSwiftSymbol(this, a2))
  {
    char v9 = 0;
    uint64_t v10 = 0x101010101010101;
    char v11 = 1;
    uint64_t v12 = 0x100010100000000;
    char v13 = 1;
    __int16 v14 = 256;
    char v15 = 1;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    v18[0] = &unk_1ECA041D0;
    v18[1] = swift::Demangle::__runtime::genericParameterName;
    v18[3] = v18;
    swift::Demangle::__runtime::demangleSymbolAsString(this, a2, (unint64_t)&v9, v7);
  }
  return 0;
}

void std::__function::__func<swift::ResolveToDemanglingForContext,std::allocator<swift::ResolveToDemanglingForContext>,swift::Demangle::__runtime::Node * ()(swift::Demangle::__runtime::SymbolicReferenceKind,swift::Demangle::__runtime::Directness,int,void const*)>::~__func()
{
}

void *std::__function::__func<swift::ResolveToDemanglingForContext,std::allocator<swift::ResolveToDemanglingForContext>,swift::Demangle::__runtime::Node * ()(swift::Demangle::__runtime::SymbolicReferenceKind,swift::Demangle::__runtime::Directness,int,void const*)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ECA04240;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<swift::ResolveToDemanglingForContext,std::allocator<swift::ResolveToDemanglingForContext>,swift::Demangle::__runtime::Node * ()(swift::Demangle::__runtime::SymbolicReferenceKind,swift::Demangle::__runtime::Directness,int,void const*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ECA04240;
  a2[1] = v2;
  return result;
}

swift::Demangle::__runtime::Node *std::__function::__func<swift::ResolveToDemanglingForContext,std::allocator<swift::ResolveToDemanglingForContext>,swift::Demangle::__runtime::Node * ()(swift::Demangle::__runtime::SymbolicReferenceKind,swift::Demangle::__runtime::Directness,int,void const*)>::operator()(uint64_t a1, unsigned __int8 *a2, int *a3, int *a4, uint64_t *a5)
{
  return swift::ResolveToDemanglingForContext::operator()((swift::Demangle::__runtime::NodeFactory **)(a1 + 8), *a2, *a3, *a4, *a5);
}

uint64_t swift_dynamicCast(char *a1, unint64_t *a2, Class *a3, const char *a4, unint64_t a5)
{
  swift_once(&swift_dynamicCast::Predicate, (dispatch_function_t)swift_dynamicCast::$_0::__invoke, 0);
  uint64_t v10 = (uint64_t (*)(char *, unint64_t *, Class *, const char *, unint64_t, uint64_t (*)(char *, unint64_t *, Class *, const char *, unint64_t)))swift_dynamicCast::Override;
  if (swift_dynamicCast::Override)
  {
    return v10(a1, a2, a3, a4, a5, swift_dynamicCastImpl);
  }
  char v13 = a3;
  __int16 v14 = (Class *)a4;
  uint64_t result = tryCast(a1, (uint64_t)a4, a2, (uint64_t)a3, (const char **)&v14, &v13, (a5 >> 1) & 1, a5 & 1);
  if (result == 1)
  {
    uint64_t v12 = 1;
    if ((a5 & 2) == 0) {
      return result;
    }
    goto LABEL_11;
  }
  if (result) {
    return 1;
  }
  if (a5) {
    swift::swift_dynamicCastFailure(v13, v14, 0);
  }
  uint64_t v12 = 0;
  uint64_t result = 0;
  if ((a5 & 4) != 0)
  {
LABEL_11:
    (*((void (**)(unint64_t *, Class *))*(a3 - 1) + 1))(a2, a3);
    return v12;
  }
  return result;
}

uint64_t swift_dynamicCastImpl(char *a1, unint64_t *a2, Class *a3, const char *a4, unint64_t a5)
{
  char v5 = a5;
  uint64_t v10 = a3;
  char v11 = (Class *)a4;
  uint64_t result = tryCast(a1, (uint64_t)a4, a2, (uint64_t)a3, (const char **)&v11, &v10, (a5 >> 1) & 1, a5 & 1);
  if (result == 1)
  {
    uint64_t v9 = 1;
    if ((v5 & 2) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  if (result) {
    return 1;
  }
  if (v5) {
    swift::swift_dynamicCastFailure(v10, v11, 0);
  }
  uint64_t v9 = 0;
  uint64_t result = 0;
  if ((v5 & 4) != 0)
  {
LABEL_7:
    (*((void (**)(unint64_t *, Class *))*(a3 - 1) + 1))(a2, a3);
    return v9;
  }
  return result;
}

void *swift_dynamicCast::$_0::__invoke(swift_dynamicCast::$_0 *this, void *a2)
{
  uint64_t result = (void *)swift::getOverride_dynamicCast(this);
  swift_dynamicCast::Override = result;
  return result;
}

uint64_t tryCast(char *a1, uint64_t a2, unint64_t *a3, uint64_t a4, const char **a5, void *a6, uint64_t a7, uint64_t a8)
{
  *a5 = (const char *)a2;
  *a6 = a4;
  if (a4 == a2)
  {
    uint64_t v19 = *(void *)(a4 - 8);
    if (a7)
    {
      if (v19) {
        uint64_t v20 = *(void *)(a4 - 8);
      }
      else {
        uint64_t v20 = 0;
      }
      (*(void (**)(char *, unint64_t *, uint64_t))(v20 + 32))(a1, a3, a4);
      return 2;
    }
    else
    {
      if (v19) {
        uint64_t v23 = *(void *)(a4 - 8);
      }
      else {
        uint64_t v23 = 0;
      }
      (*(void (**)(char *, unint64_t *, uint64_t))(v23 + 16))(a1, a3, a4);
      return 1;
    }
  }
  if (*(void *)a2 <= 0x7FFuLL) {
    int v16 = *(void *)a2;
  }
  else {
    int v16 = 0;
  }
  uint64_t v17 = *(void *)a4;
  if (*(void *)a4 > 0x7FFuLL) {
    LODWORD(v17) = 0;
  }
  int v74 = v17;
  if (v16 <= 767)
  {
    uint64_t v21 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToSwiftClass;
    switch(v16)
    {
      case 512:
        if (*(void *)(a2 + 8)) {
          uint64_t v22 = *(StructDescriptor **)(a2 + 8);
        }
        else {
          uint64_t v22 = 0;
        }
        unsigned int v18 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToString;
        if (v22 == &nominal type descriptor for String) {
          goto LABEL_47;
        }
        unsigned int v18 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToAnyHashable;
        if (v22 == &nominal type descriptor for AnyHashable) {
          goto LABEL_47;
        }
        unsigned int v18 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToArray;
        if (v22 == &nominal type descriptor for Array) {
          goto LABEL_47;
        }
        unsigned int v18 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToDictionary;
        if (v22 == &nominal type descriptor for Dictionary) {
          goto LABEL_47;
        }
        BOOL v26 = v22 == &nominal type descriptor for Set;
        int32x4_t v27 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToStruct;
        int32x4_t v28 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToSet;
        break;
      case 513:
        unsigned int v18 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToEnum;
        goto LABEL_47;
      case 514:
        unsigned int v18 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToOptional;
        goto LABEL_47;
      case 515:
        unsigned int v18 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToForeignClass;
        goto LABEL_47;
      default:
        if (v16) {
          goto LABEL_157;
        }
        goto LABEL_48;
    }
  }
  else
  {
    switch(v16)
    {
      case 768:
        unsigned int v18 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToOpaque;
        goto LABEL_47;
      case 769:
        unsigned int v18 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToTuple;
        goto LABEL_47;
      case 770:
        unsigned int v18 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToFunction;
        goto LABEL_47;
      case 771:
        int Representation = swift::TargetExistentialTypeMetadata<swift::InProcess>::getRepresentation(a2);
        if (Representation == 2)
        {
          unsigned int v18 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToErrorExistential;
LABEL_47:
          uint64_t v21 = v18;
          goto LABEL_48;
        }
        uint64_t v21 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToClassExistential;
        if (Representation == 1) {
          goto LABEL_48;
        }
        if (Representation) {
LABEL_157:
        }
          abort();
        BOOL v26 = *(_DWORD *)(a2 + 12) == 0;
        int32x4_t v27 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToConstrainedOpaqueExistential;
        int32x4_t v28 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToUnconstrainedOpaqueExistential;
        break;
      case 772:
        unsigned int v18 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToMetatype;
        goto LABEL_47;
      case 773:
        unsigned int v18 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToObjectiveCClass;
        goto LABEL_47;
      case 774:
        unsigned int v18 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToExistentialMetatype;
        goto LABEL_47;
      case 775:
        unsigned int v18 = (uint64_t (*)(char *, uint64_t, unint64_t *, uint64_t, const char **, void *, uint64_t, uint64_t))tryCastToExtendedExistential;
        goto LABEL_47;
      default:
        goto LABEL_157;
    }
  }
  if (v26) {
    uint64_t v21 = v28;
  }
  else {
    uint64_t v21 = v27;
  }
LABEL_48:
  uint64_t v73 = a1;
  uint64_t v24 = v21(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v24)
  {
    if (v74 > 770)
    {
      switch(v74)
      {
        case 771:
          goto LABEL_65;
        case 773:
          goto LABEL_56;
        case 774:
          unint64_t MetatypeMetadata = swift_getMetatypeMetadata(*a3);
          *a6 = MetatypeMetadata;
          int32x4_t v32 = v73;
          uint64_t v33 = a2;
          uint8x16_t v34 = a3;
          uint16x8_t v35 = a5;
          uint16x8_t v36 = a6;
          uint64_t v37 = a7;
          goto LABEL_93;
        case 775:
          switch(**(unsigned char **)(a4 + 8))
          {
            case 0:
              unint64_t v49 = a3[3];
              uint8x16_t v34 = swift::TargetOpaqueExistentialContainer<swift::InProcess>::projectValue(a3);
              goto LABEL_88;
            case 1:
              Objectunint64_t Type = swift_getObjectType(*a3);
              goto LABEL_87;
            case 2:
              Objectunint64_t Type = swift_getMetatypeMetadata(*a3);
LABEL_87:
              unint64_t v49 = ObjectType;
              uint8x16_t v34 = a3;
              goto LABEL_88;
            case 3:
              goto LABEL_157;
            default:
              uint8x16_t v34 = 0;
              unint64_t v49 = 0;
LABEL_88:
              *a6 = v49;
              if (v34 == a3) {
                uint64_t v37 = a7;
              }
              else {
                uint64_t v37 = 0;
              }
              int32x4_t v32 = v73;
              uint64_t v33 = a2;
              unint64_t MetatypeMetadata = v49;
              break;
          }
          goto LABEL_92;
        default:
          goto LABEL_94;
      }
    }
    if (v74)
    {
      if (v74 == 512)
      {
        if (*(StructDescriptor **)(a4 + 8) == &nominal type descriptor for AnyHashable
          && (_swift_anyHashableDownCastConditionalIndirect((uint64_t)a3, v73, a2, v29) & 1) != 0)
        {
          return 1;
        }
        goto LABEL_94;
      }
      if (v74 != 515) {
        goto LABEL_94;
      }
    }
LABEL_56:
    unint64_t NonNullSrcObject = getNonNullSrcObject((uint64_t *)a3, (Class)a4, (Class *)a2);
    if (NonNullSrcObject)
    {
      unint64_t v40 = swift_getObjectType(NonNullSrcObject);
      if (v40 != a4)
      {
        *a6 = v40;
        uint64_t v24 = v21(v73, a2, a3, v40, a5, a6, a7, a8);
        if (v24) {
          return v24;
        }
      }
    }
    if (v74 == 771)
    {
LABEL_65:
      int v45 = swift::TargetExistentialTypeMetadata<swift::InProcess>::getRepresentation(a4);
      if (v45)
      {
        if (v45 == 2)
        {
          int v50 = (swift::SwiftError *)*a3;
          unint64_t v48 = (unint64_t)a3;
          if (!swift::SwiftError::isPureNSError((swift::SwiftError *)*a3, v46)) {
            unint64_t v48 = ((unint64_t)v50 + *(unsigned __int8 *)(*(void *)(*((void *)v50 + 5) - 8) + 80) + 72) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*((void *)v50 + 5) - 8) + 80);
          }
          unint64_t Type = swift::SwiftError::getType(v50, v51);
        }
        else if (v45 == 1)
        {
          unint64_t Type = swift_getObjectType(*a3);
          unint64_t v48 = (unint64_t)a3;
        }
        else
        {
          unint64_t v48 = 0;
          unint64_t Type = 0;
        }
      }
      else
      {
        unint64_t Type = a3[3];
        unint64_t v48 = (unint64_t)swift::TargetExistentialTypeMetadata<swift::InProcess>::projectValue(a4, (swift::SwiftError **)a3);
      }
      *a6 = Type;
      if ((unint64_t *)v48 == a3) {
        uint64_t v37 = a7;
      }
      else {
        uint64_t v37 = 0;
      }
      int32x4_t v32 = v73;
      uint64_t v33 = a2;
      uint8x16_t v34 = (unint64_t *)v48;
      unint64_t MetatypeMetadata = Type;
LABEL_92:
      uint16x8_t v35 = a5;
      uint16x8_t v36 = a6;
LABEL_93:
      uint64_t v24 = tryCast(v32, v33, v34, MetatypeMetadata, v35, v36, v37, a8);
      if (v24) {
        return v24;
      }
    }
    else if (v74 == 773)
    {
      AsSwiftValue = swift::getAsSwiftValue((swift *)*a3, v39);
      if (AsSwiftValue)
      {
        uint64_t ValueFromSwiftValue = swift::getValueFromSwiftValue(AsSwiftValue, v42);
        uint64_t v24 = tryCast(v73, a2, v44, ValueFromSwiftValue, a5, a6, 0, a8);
        if (v24) {
          return v24;
        }
      }
      if (swift::tryDynamicCastNSErrorToValue(v73, (uint64_t *)a3, (uint64_t *)a4, (void *)a2, 0)) {
        return 1;
      }
    }
LABEL_94:
    if (v16 == 514)
    {
      if (v74 == 514)
      {
        GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs((unint64_t *)a4);
        unint64_t v54 = *GenericArgs;
        if (*(void *)(*GenericArgs - 8)) {
          uint64_t v55 = *(void *)(*GenericArgs - 8);
        }
        else {
          uint64_t v55 = 0;
        }
        unint64_t v56 = (swift::runtime::bincompat *)(*(uint64_t (**)(unint64_t *, uint64_t, unint64_t))(v55 + 48))(a3, 1, v54);
        if (v56)
        {
          if (swift::runtime::bincompat::useLegacyProtocolConformanceReverseIteration(v56))
          {
            uint64_t v57 = *(void *)(*swift::TargetMetadata<swift::InProcess>::getGenericArgs((unint64_t *)a2) - 8);
            if (v57) {
              uint64_t v58 = v57;
            }
            else {
              uint64_t v58 = 0;
            }
            uint64_t v24 = 1;
            (*(void (**)(char *, uint64_t, uint64_t))(v58 + 56))(v73, 1, 1);
          }
          else
          {
            size_t v69 = (unint64_t *)*swift::TargetMetadata<swift::InProcess>::getGenericArgs((unint64_t *)a4);
            for (int i = 1;
                  *v69 == 514;
                  size_t v69 = (unint64_t *)*swift::TargetMetadata<swift::InProcess>::getGenericArgs(v69))
            {
              ++i;
            }
            unint64_t v71 = (unint64_t *)*swift::TargetMetadata<swift::InProcess>::getGenericArgs((unint64_t *)a2);
            for (int j = 1;
                  *v71 == 514;
                  unint64_t v71 = (unint64_t *)*swift::TargetMetadata<swift::InProcess>::getGenericArgs(v71))
            {
              ++j;
            }
            initializeToNilAtDepth((uint64_t)v73, (unint64_t *)a2, (j - i) & ~((j - i) >> 31));
            return 1;
          }
          return v24;
        }
        unint64_t v59 = *swift::TargetMetadata<swift::InProcess>::getGenericArgs((unint64_t *)a2);
        uint64_t v60 = tryCast(v73, v59, a3, v54, a5, a6, a7, a8);
        if (v60) {
          goto LABEL_105;
        }
      }
      unint64_t v59 = *swift::TargetMetadata<swift::InProcess>::getGenericArgs((unint64_t *)a2);
      uint64_t v60 = tryCast(v73, v59, a3, a4, a5, a6, a7, a8);
      if (v60)
      {
LABEL_105:
        uint64_t v24 = v60;
        if (*(void *)(v59 - 8)) {
          uint64_t v61 = *(void *)(v59 - 8);
        }
        else {
          uint64_t v61 = 0;
        }
        (*(void (**)(char *, void, uint64_t, unint64_t))(v61 + 56))(v73, 0, 1, v59);
        return v24;
      }
    }
    if (v74 == 514)
    {
      unint64_t v62 = swift::TargetMetadata<swift::InProcess>::getGenericArgs((unint64_t *)a4);
      unint64_t v63 = *v62;
      uint64_t v64 = *(void *)(*v62 - 8) ? *(void *)(*v62 - 8) : 0;
      if (!(*(unsigned int (**)(unint64_t *, uint64_t, unint64_t))(v64 + 48))(a3, 1, v63))
      {
        uint64_t v24 = tryCast(v73, a2, a3, v63, a5, a6, a7, a8);
        if (v24) {
          return v24;
        }
      }
    }
    if (v16 > 514)
    {
      if (v16 != 515)
      {
        if (v16 == 771)
        {
          if (swift::TargetExistentialTypeMetadata<swift::InProcess>::getRepresentation(a2) == 1)
          {
            if (tryCastFromObjCBridgeableToClass((atomic_ullong **)v73, a2, (uint64_t)a3, a4)) {
              return 1;
            }
            uint64_t v24 = tryCastToClassExistentialViaSwiftValue(v73, a2, (unint64_t **)a3, (uint64_t *)a4, a7);
            if (v24) {
              return v24;
            }
          }
          return 0;
        }
        if (v16 != 773) {
          return 0;
        }
      }
    }
    else
    {
      if ((v16 - 512) < 2) {
        return (!v74 || v74 == 773 || v74 == 515)
      }
            && tryCastFromClassToObjCBridgeable((uint64_t)v73, (Class *)a2, (uint64_t *)a3, (objc_class *)a4, a5, a8);
      if (v16)
      {
        if (v16 != 514
          || *(void *)a4 != 771
          || swift::TargetExistentialTypeMetadata<swift::InProcess>::getRepresentation(a4) != 1
          || *(_DWORD *)(a4 + 12))
        {
          return 0;
        }
        int v65 = *(_DWORD *)(a4 + 8);
        if ((v65 & 0x40000000) != 0)
        {
          if (v65 < 0 || *(void *)(a4 + 16)) {
            return 0;
          }
        }
        else if (v65 < 0)
        {
          return 0;
        }
        return tryCastFromClassToObjCBridgeable((uint64_t)v73, (Class *)a2, (uint64_t *)a3, (objc_class *)a4, a5, 0) != 0;
      }
    }
    if ((v74 & 0xFFFFFFFE) == 0x200
      && tryCastFromObjCBridgeableToClass((atomic_ullong **)v73, a2, (uint64_t)a3, a4))
    {
      return 1;
    }
    if (v16 == 773)
    {
      uint64_t ErrorWitness = (swift *)swift::findErrorWitness(a4);
      if (ErrorWitness)
      {
        uint64_t v67 = (uint64_t)ErrorWitness;
        NSErrorMetadata = (swift *)swift::getNSErrorMetadata(ErrorWitness);
        if (NSErrorMetadata == (swift *)a2 || swift::getNSObjectMetadata(NSErrorMetadata) == a2)
        {
          *(void *)uint64_t v73 = swift::dynamicCastValueToNSError((uint64_t)a3, a4, v67, 0);
          return 1;
        }
      }
    }
    return 0;
  }
  return v24;
}

uint64_t getNonNullSrcObject(uint64_t *a1, Class cls, Class *a3)
{
  uint64_t v3 = *a1;
  if (!*a1)
  {
    swift::nameForMetadata(&v14, (Class *)cls, 1);
    uint64_t v7 = swift::nameForMetadata(&__p, a3, 1);
    uint64_t v8 = (swift *)swift::runtime::bincompat::useLegacyProtocolConformanceReverseIteration((swift::runtime::bincompat *)v7);
    if ((v14.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      char v11 = &v14;
    }
    else {
      char v11 = (std::string *)v14.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if (!v8) {
      swift::fatalError(v8, "Found a null pointer in a value of type '%s' (%p). Non-Optional values are not allowed to hold null pointers. (Detected while casting to '%s' (%p))%s\n", v9, v10, v11, cls, p_p, a3, "");
    }
    swift::warning(0, "Found a null pointer in a value of type '%s' (%p). Non-Optional values are not allowed to hold null pointers. (Detected while casting to '%s' (%p))%s\n", v9, v10, v11, cls, p_p, a3, ": Continuing with null object, but expect problems later.");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v14.__r_.__value_.__l.__data_);
    }
  }
  return v3;
}

uint64_t tryCastFromClassToObjCBridgeable(uint64_t a1, Class *a2, uint64_t *a3, objc_class *a4, const char **a5, int a6)
{
  uint64_t v12 = (int **)swift_conformsToProtocolCommon((uint64_t)a2, (uint64_t)&protocol descriptor for _ObjectiveCBridgeable);
  if (!v12) {
    return 0;
  }
  uint64_t v13 = (uint64_t)v12;
  uint64_t NonNullSrcObject = getNonNullSrcObject(a3, a4, a2);
  if (!NonNullSrcObject
    || (uint64_t v16 = NonNullSrcObject, !swift_dynamicCastUnknownClass(NonNullSrcObject, (uint64_t)BridgedObjectiveCType)))
  {
    *a5 = BridgedObjectiveCType;
    return 0;
  }

  return _tryCastFromClassToObjCBridgeable(a1, (uint64_t)a2, v16, a6, v13);
}

uint64_t tryCastFromObjCBridgeableToClass(atomic_ullong **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = swift_conformsToProtocolCommon(a4, (uint64_t)&protocol descriptor for _ObjectiveCBridgeable);
  if (result)
  {
    uint64_t v8 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(result + 16))(a4, result);
    uint64_t v9 = swift_dynamicCastUnknownClass((uint64_t)v8, a2);
    if (v9)
    {
      *a1 = v9;
      return 1;
    }
    else
    {
      swift_unknownObjectRelease(v8);
      return 0;
    }
  }
  return result;
}

uint64_t tryCastToClassExistentialViaSwiftValue(void *a1, uint64_t a2, unint64_t **a3, uint64_t *a4, int a5)
{
  uint64_t result = 0;
  uint64_t v11 = *a4;
  if ((unint64_t)*a4 > 0x7FF) {
    LODWORD(v11) = 0;
  }
  if ((int)v11 <= 771)
  {
    if (!v11 || v11 == 515) {
      return result;
    }
    goto LABEL_14;
  }
  if (v11 != 773)
  {
    if (v11 != 772) {
      goto LABEL_14;
    }
    uint64_t result = 0;
    unint64_t v12 = **a3;
    if (v12 > 0x7FF) {
      LODWORD(v12) = 0;
    }
    if (v12 && v12 != 515 && v12 != 773)
    {
LABEL_14:
      if (!*(_DWORD *)(a2 + 12)
        || (uint64_t result = swift::runtime::bincompat::useLegacyObjCBoxingInCasting(0), result)
        && (uint64_t result = swift::findSwiftValueConformances(a2), result))
      {
        *a1 = swift::bridgeAnythingToSwiftValueObject((uint64_t)a3, (uint64_t)a4, a5);
        if (a5) {
          return 2;
        }
        else {
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t tryCastToSwiftClass(void *a1, Class *a2, uint64_t *a3, Class cls, Class **a5, void *a6, char a7)
{
  uint64_t v7 = *(void *)cls;
  if (*(void *)cls > 0x7FFuLL) {
    LODWORD(v7) = 0;
  }
  if (v7 != 773 && v7 != 0) {
    return 0;
  }
  uint64_t result = getNonNullSrcObject(a3, cls, a2);
  if (result)
  {
    uint64_t result = swift_dynamicCastClass(result, (uint64_t)a2);
    if (result)
    {
      *a1 = result;
      if (a7)
      {
        return 2;
      }
      else
      {
        swift_unknownObjectRetain((id)result);
        return 1;
      }
    }
    else
    {
      *a6 = cls;
      *a5 = a2;
    }
  }
  return result;
}

void *tryCastToString(uint64_t a1, Class *a2, uint64_t *a3, objc_class *a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned __int8 a8)
{
  uint64_t v8 = *(void *)a4;
  if (*(void *)a4 > 0x7FFuLL) {
    LODWORD(v8) = 0;
  }
  if (v8 == 773 || v8 == 515) {
    return ObjCBridgeMemo::tryBridge(tryCastToString(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::memo, a1, a2, a3, a4, a5, a6, a7, a8);
  }
  else {
    return 0;
  }
}

uint64_t tryCastToAnyHashable(swift *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v7 = *a4;
  if ((unint64_t)*a4 > 0x7FF) {
    LODWORD(v7) = 0;
  }
  if (v7 != 514)
  {
    if (v7 == 773 || v7 == 515)
    {
      uint64_t NSStringMetadata = swift::getNSStringMetadata(a1);
      Superclass = (swift *)a4;
      while (Superclass != (swift *)NSStringMetadata)
      {
        Superclass = (swift *)_swift_class_getSuperclass(Superclass);
        if (!Superclass) {
          goto LABEL_16;
        }
      }
      uint64_t NSStringHashableConformance = swift::hashable_support::getNSStringHashableConformance(Superclass);
      if (NSStringHashableConformance)
      {
LABEL_17:
        _swift_convertToAnyHashableIndirect(a3, (uint64_t)a1, a4, NSStringHashableConformance);
        return 1;
      }
    }
LABEL_16:
    uint64_t result = swift_conformsToProtocolCommon((uint64_t)a4, (uint64_t)&protocol descriptor for Hashable);
    uint64_t NSStringHashableConformance = result;
    if (!result) {
      return result;
    }
    goto LABEL_17;
  }
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs((unint64_t *)a4);
  if (*(void *)(*GenericArgs - 8)) {
    uint64_t v11 = *(void *)(*GenericArgs - 8);
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v11 + 48))(a3, 1);
  if (result) {
    goto LABEL_16;
  }
  return result;
}

uint64_t tryCastToArray(__objc2_class ***a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  if (*a4 != 512) {
    return 0;
  }
  unint64_t v12 = a4[1] ? (StructDescriptor *)a4[1] : 0;
  if (v12 != &nominal type descriptor for Array) {
    return 0;
  }
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a4);
  char v15 = (uint64_t *)swift::TargetMetadata<swift::InProcess>::getGenericArgs(a2);
  uint64_t v16 = (uint64_t *)*GenericArgs;
  if (a8)
  {
    _swift_arrayDownCastIndirect(a3, a1, v16);
  }
  else if (!_swift_arrayDownCastConditionalIndirect(a3, a1, v16, *v15))
  {
    return 0;
  }
  return 1;
}

uint64_t tryCastToDictionary(uint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  if (*a4 != 512) {
    return 0;
  }
  unint64_t v12 = a4[1] ? (StructDescriptor *)a4[1] : 0;
  if (v12 != &nominal type descriptor for Dictionary) {
    return 0;
  }
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a4);
  char v15 = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a2);
  uint64_t v16 = (uint64_t *)*GenericArgs;
  uint64_t v17 = (uint64_t *)GenericArgs[1];
  unsigned int v18 = (ValueMetadata *)*v15;
  uint64_t v19 = (uint64_t *)v15[1];
  uint64_t v20 = GenericArgs[2];
  uint64_t v21 = v15[2];
  if (a8)
  {
    _swift_dictionaryDownCastIndirect(a3, a1, v16, v17, v18, v19, v20, v21);
  }
  else if (!_swift_dictionaryDownCastConditionalIndirect(a3, (__objc2_class ***)a1, v16, v17, (uint64_t)v18, (uint64_t)v19, v20, v21))
  {
    return 0;
  }
  return 1;
}

uint64_t tryCastToSet(uint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  if (*a4 != 512) {
    return 0;
  }
  unint64_t v12 = a4[1] ? (StructDescriptor *)a4[1] : 0;
  if (v12 != &nominal type descriptor for Set) {
    return 0;
  }
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a4);
  char v15 = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a2);
  uint64_t v16 = (uint64_t *)*GenericArgs;
  uint64_t v17 = (void *)GenericArgs[1];
  unsigned int v18 = (ValueMetadata *)*v15;
  uint64_t v19 = v15[1];
  if (a8)
  {
    _swift_setDownCastIndirect(a3, a1, v16, v18, v17, v19);
  }
  else if (!_swift_setDownCastConditionalIndirect(a3, a1, v16, v18, (uint64_t)v17, v19))
  {
    return 0;
  }
  return 1;
}

uint64_t tryCastToStruct()
{
  return 0;
}

uint64_t tryCastToEnum()
{
  return 0;
}

uint64_t tryCastToOptional()
{
  return 0;
}

uint64_t tryCastToForeignClass(void *a1, Class *a2, uint64_t *a3, Class cls, uint64_t a5, uint64_t a6, char a7, int a8)
{
  uint64_t v12 = *(void *)cls;
  if (*(void *)cls > 0x7FFuLL) {
    LODWORD(v12) = 0;
  }
  if (!v12 || v12 == 773 || (uint64_t result = 0, v12 == 515))
  {
    uint64_t NonNullSrcObject = getNonNullSrcObject(a3, cls, a2);
    if (NonNullSrcObject)
    {
      uint64_t result = swift_dynamicCastForeignClass(NonNullSrcObject, (uint64_t)a2);
      if (!result) {
        return result;
      }
      *a1 = result;
      if (a7) {
        return 2;
      }
      id v15 = (id)result;
      return 1;
    }
    if (a8)
    {
      *a1 = 0;
      return 1;
    }
    return 0;
  }
  return result;
}

uint64_t tryCastToOpaque()
{
  return 0;
}

uint64_t tryCastToTuple(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, int a7, uint64_t a8)
{
  *a6 = a4;
  *a5 = a2;
  if (*a4 != 769) {
    return 0;
  }
  uint64_t v10 = a4[1];
  if (v10 != *(void *)(a2 + 8)) {
    return 0;
  }
  std::string v14 = (char *)a4[2];
  id v15 = *(char **)(a2 + 16);
  if (v14) {
    BOOL v16 = v15 == 0;
  }
  else {
    BOOL v16 = 1;
  }
  if (!v16 && v14 != v15)
  {
    do
    {
      uint64_t v22 = strchr(v14, 32);
      uint64_t v23 = strchr(v15, 32);
      if (!v22) {
        break;
      }
      uint64_t v24 = v23;
      if (!v23) {
        break;
      }
      if (v22 != v14
        && v23 != v15
        && (v22 - v14 != v23 - v15
         || strncmp(v14, v15, (v22 - v14))))
      {
        return 0;
      }
      std::string v14 = v22 + 1;
      id v15 = v24 + 1;
    }
    while (v22 != v24);
  }
  if (!v10)
  {
LABEL_15:
    uint64_t v20 = *(a4 - 1);
    if (a7)
    {
      if (v20) {
        uint64_t v21 = *(a4 - 1);
      }
      else {
        uint64_t v21 = 0;
      }
      (*(void (**)(uint64_t, uint64_t, void *))(v21 + 32))(a1, a3, a4);
      return 2;
    }
    if (v20) {
      uint64_t v25 = *(a4 - 1);
    }
    else {
      uint64_t v25 = 0;
    }
    (*(void (**)(uint64_t, uint64_t, void *))(v25 + 16))(a1, a3, a4);
    return 1;
  }
  uint64_t v18 = 0;
  unsigned int v19 = 1;
  while (a4[2 * v18 + 3] == *(void *)(a2 + 24 + 16 * v18))
  {
    uint64_t v18 = v19++;
    if (v10 == v18) {
      goto LABEL_15;
    }
  }
  uint64_t v26 = v10;
  if (!v10) {
    return 1;
  }
  uint64_t v27 = 0;
  int32x4_t v28 = a4 + 4;
  for (int i = (void *)(a2 + 32); tryCast(a1 + *i, *(i - 1), a3 + *v28, *(v28 - 1), a5, a6, 0, a8); i += 2)
  {
    ++v27;
    v28 += 2;
    uint64_t result = 1;
    if (v26 == v27) {
      return result;
    }
  }
  if (!v27) {
    return 0;
  }
  int32x4_t v31 = (void *)(a2 + 32);
  do
  {
    if (*(void *)(*(v31 - 1) - 8)) {
      uint64_t v32 = *(void *)(*(v31 - 1) - 8);
    }
    else {
      uint64_t v32 = 0;
    }
    (*(void (**)(uint64_t))(v32 + 8))(a1 + *v31);
    uint64_t result = 0;
    v31 += 2;
    --v27;
  }
  while (v27);
  return result;
}

uint64_t tryCastToFunction(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, int a7)
{
  if (*a4 != 770) {
    return 0;
  }
  unint64_t v7 = a4[1];
  unint64_t v8 = *(void *)(a2 + 8);
  if (((v8 ^ v7) & 0xFFFFFFFFFEFFFFFFLL) != 0 || (v7 & 0x1000000) != 0 && (v8 & 0x1000000) == 0) {
    return 0;
  }
  if (a4[2] != *(void *)(a2 + 16)
    || (unsigned __int16)a4[1] != (unint64_t)(unsigned __int16)v8
    || ((v7 >> 25) & 1) != ((v8 >> 25) & 1))
  {
    return 0;
  }
  if ((unsigned __int16)a4[1])
  {
    uint64_t v10 = 0;
    uint64_t v11 = a4 + 3;
    uint64_t v12 = a2 + 24;
    uint64_t v13 = 8 * (unsigned __int16)a4[1];
    do
    {
      if (v11[v10] != *(void *)(v12 + v10 * 8)) {
        return 0;
      }
      if ((v7 & 0x2000000) != 0)
      {
        int v14 = *(_DWORD *)((char *)v11 + v13);
        if ((v8 & 0x2000000) == 0)
        {
LABEL_16:
          int v15 = 0;
          goto LABEL_17;
        }
      }
      else
      {
        int v14 = 0;
        if ((v8 & 0x2000000) == 0) {
          goto LABEL_16;
        }
      }
      int v15 = *(_DWORD *)(v12 + v13);
LABEL_17:
      if (v14 != v15) {
        return 0;
      }
      ++v10;
      v13 += 4;
    }
    while ((unsigned __int16)a4[1] != v10);
  }
  uint64_t v16 = *(a4 - 1);
  if (a7)
  {
    if (v16) {
      uint64_t v17 = *(a4 - 1);
    }
    else {
      uint64_t v17 = 0;
    }
    (*(void (**)(uint64_t, uint64_t, void *))(v17 + 32))(a1, a3, a4);
    return 2;
  }
  else
  {
    if (v16) {
      uint64_t v18 = *(a4 - 1);
    }
    else {
      uint64_t v18 = 0;
    }
    (*(void (**)(uint64_t, uint64_t, void *))(v18 + 16))(a1, a3, a4);
    return 1;
  }
}

uint64_t tryCastToUnconstrainedOpaqueExistential(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  a1[3] = a4;
  BoxForExistentialIn = swift::TargetMetadata<swift::InProcess>::allocateBoxForExistentialIn(a4, a1);
  uint64_t v11 = *(void *)(a4 - 8);
  if (a7)
  {
    if (v11) {
      uint64_t v12 = *(void *)(a4 - 8);
    }
    else {
      uint64_t v12 = 0;
    }
    (*(void (**)(void *, uint64_t, unint64_t))(v12 + 32))(BoxForExistentialIn, a3, a4);
    return 2;
  }
  else
  {
    if (v11) {
      uint64_t v13 = *(void *)(a4 - 8);
    }
    else {
      uint64_t v13 = 0;
    }
    (*(void (**)(void *, uint64_t, unint64_t))(v13 + 16))(BoxForExistentialIn, a3, a4);
    return 1;
  }
}

uint64_t tryCastToConstrainedOpaqueExistential(void *a1, uint64_t a2, swift::runtime::bincompat **a3, uint64_t *a4, uint64_t a5, uint64_t a6, int a7)
{
  unsigned int v12 = *(_DWORD *)(a2 + 8);
  if ((v12 & 0x40000000) != 0)
  {
    uint64_t v13 = *(uint64_t **)(a2 + 16);
    if (v13)
    {
      uint64_t result = (uint64_t)swift_dynamicCastMetatype(a4, v13);
      if (!result) {
        return result;
      }
      unsigned int v12 = *(_DWORD *)(a2 + 8);
    }
  }
  if ((v12 & 0x80000000) != 0) {
    goto LABEL_11;
  }
  uint64_t v15 = *a4;
  if ((unint64_t)*a4 > 0x7FF) {
    LODWORD(v15) = 0;
  }
  if (!v15 || v15 == 773 || (uint64_t result = 0, v15 == 515))
  {
LABEL_11:
    uint64_t v16 = *(unsigned int *)(a2 + 12);
    if (v16)
    {
      uint64_t v17 = a1 + 4;
      uint64_t v18 = (const char **)(a2 + 8 * ((v12 >> 30) & 1) + 16);
      uint64_t v19 = 8 * v16;
      while (1)
      {
        uint64_t v20 = *v18;
        uint64_t result = swift::_conformsToProtocol(a3, (uint64_t)a4, *v18, v17);
        if (!result) {
          break;
        }
        if (v17) {
          v17 += (v20 & 1) == 0;
        }
        else {
          uint64_t v17 = 0;
        }
        ++v18;
        v19 -= 8;
        if (!v19) {
          goto LABEL_18;
        }
      }
    }
    else
    {
LABEL_18:
      a1[3] = a4;
      BoxForExistentialIn = swift::TargetMetadata<swift::InProcess>::allocateBoxForExistentialIn((unint64_t)a4, a1);
      uint64_t v22 = *(a4 - 1);
      if (a7)
      {
        if (v22) {
          uint64_t v23 = *(a4 - 1);
        }
        else {
          uint64_t v23 = 0;
        }
        (*(void (**)(void *, swift::runtime::bincompat **, uint64_t *))(v23 + 32))(BoxForExistentialIn, a3, a4);
        return 2;
      }
      else
      {
        if (v22) {
          uint64_t v24 = *(a4 - 1);
        }
        else {
          uint64_t v24 = 0;
        }
        (*(void (**)(void *, swift::runtime::bincompat **, uint64_t *))(v24 + 16))(BoxForExistentialIn, a3, a4);
        return 1;
      }
    }
  }
  return result;
}

uint64_t tryCastToClassExistential(swift::runtime::bincompat **a1, uint64_t a2, uint64_t **a3, Class cls, uint64_t a5, uint64_t a6, char a7, int a8)
{
  uint64_t result = 0;
  uint64_t v15 = *(void *)cls;
  if (*(void *)cls > 0x7FFuLL) {
    LODWORD(v15) = 0;
  }
  if ((int)v15 > 771)
  {
    if (v15 != 773)
    {
      if (v15 != 772) {
        return result;
      }
      uint64_t v16 = swift_dynamicCastMetatypeToObjectConditional(*a3);
      int32x4_t v39 = (swift::runtime::bincompat *)v16;
      if (!v16) {
        return 0;
      }
      uint64_t v17 = (swift::runtime::bincompat *)v16;
      unsigned int v18 = *(_DWORD *)(a2 + 8);
      if ((v18 & 0x40000000) != 0)
      {
        uint64_t v19 = *(uint64_t **)(a2 + 16);
        if (v19)
        {
          if (!swift_dynamicCastMetatype(v16, v19)) {
            return 0;
          }
          unsigned int v18 = *(_DWORD *)(a2 + 8);
        }
      }
      if ((v18 & 0x80000000) != 0) {
        goto LABEL_20;
      }
      uint64_t v20 = *(void *)v17;
      if (*(void *)v17 > 0x7FFuLL) {
        LODWORD(v2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
      }
      if (!v20 || v20 == 773 || v20 == 515)
      {
LABEL_20:
        uint64_t v21 = *(unsigned int *)(a2 + 12);
        if (!v21)
        {
LABEL_28:
          *a1 = v17;
          if (a7) {
            return 2;
          }
          uint64_t v26 = v17;
LABEL_56:
          swift_unknownObjectRetain(v26);
          return 1;
        }
        uint64_t v22 = (uint64_t *)(a1 + 1);
        uint64_t v23 = (const char **)(a2 + 8 * ((v18 >> 30) & 1) + 16);
        uint64_t v24 = 8 * v21;
        while (1)
        {
          uint64_t v25 = *v23;
          if (!swift::_conformsToProtocol(&v39, (uint64_t)v17, *v23, v22)) {
            break;
          }
          if (v22) {
            v22 += (v25 & 1) == 0;
          }
          else {
            uint64_t v22 = 0;
          }
          ++v23;
          v24 -= 8;
          if (!v24)
          {
            uint64_t v17 = v39;
            goto LABEL_28;
          }
        }
      }
      return 0;
    }
    uint64_t v27 = *a3;
    if ((swift::runtime::bincompat::useLegacyObjCBoxingInCasting(0) & 1) == 0
      && swift::getAsSwiftValue((swift *)v27, v28))
    {
      return 0;
    }
  }
  else if (v15 && v15 != 515)
  {
    return result;
  }
  uint64_t NonNullSrcObject = getNonNullSrcObject((uint64_t *)a3, cls, (Class *)a2);
  if (!NonNullSrcObject)
  {
    if (a8)
    {
      *a1 = 0;
      return 1;
    }
    return 0;
  }
  int32x4_t v30 = (swift::runtime::bincompat *)NonNullSrcObject;
  unsigned int v31 = *(_DWORD *)(a2 + 8);
  if ((v31 & 0x40000000) != 0)
  {
    uint64_t v32 = *(uint64_t **)(a2 + 16);
    if (v32)
    {
      uint64_t result = (uint64_t)swift_dynamicCastMetatype((uint64_t *)cls, v32);
      if (!result) {
        return result;
      }
      unsigned int v31 = *(_DWORD *)(a2 + 8);
    }
  }
  if ((v31 & 0x80000000) != 0) {
    goto LABEL_43;
  }
  uint64_t v33 = *(void *)cls;
  if (*(void *)cls > 0x7FFuLL) {
    LODWORD(v33) = 0;
  }
  if (!v33 || v33 == 773 || (uint64_t result = 0, v33 == 515))
  {
LABEL_43:
    uint64_t v34 = *(unsigned int *)(a2 + 12);
    if (v34)
    {
      uint16x8_t v35 = (uint64_t *)(a1 + 1);
      uint16x8_t v36 = (const char **)(a2 + 8 * ((v31 >> 30) & 1) + 16);
      uint64_t v37 = 8 * v34;
      do
      {
        uint16x8_t v38 = *v36;
        uint64_t result = swift::_conformsToProtocol((swift::runtime::bincompat **)a3, (uint64_t)cls, *v36, v35);
        if (!result) {
          return result;
        }
        if (v35) {
          v35 += (v38 & 1) == 0;
        }
        else {
          uint16x8_t v35 = 0;
        }
        ++v36;
        v37 -= 8;
      }
      while (v37);
    }
    *a1 = v30;
    if (a7) {
      return 2;
    }
    uint64_t v26 = v30;
    goto LABEL_56;
  }
  return result;
}

uint64_t tryCastToErrorExistential(void *a1, uint64_t a2, swift::runtime::bincompat **a3, uint64_t *a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v12 = *a4;
  if ((unint64_t)*a4 > 0x7FF) {
    LODWORD(v12) = 0;
  }
  if (((v12 - 512) > 3 || v12 == 514) && v12 != 773 && v12 != 0) {
    return 0;
  }
  uint64_t v26 = 0;
  unsigned int v15 = *(_DWORD *)(a2 + 8);
  if ((v15 & 0x40000000) != 0)
  {
    uint64_t v16 = *(uint64_t **)(a2 + 16);
    if (v16)
    {
      uint64_t result = (uint64_t)swift_dynamicCastMetatype(a4, v16);
      if (!result) {
        return result;
      }
      unsigned int v15 = *(_DWORD *)(a2 + 8);
    }
  }
  if ((v15 & 0x80000000) != 0) {
    goto LABEL_23;
  }
  uint64_t v17 = *a4;
  if ((unint64_t)*a4 > 0x7FF) {
    LODWORD(v17) = 0;
  }
  if (!v17 || v17 == 773 || (uint64_t result = 0, v17 == 515))
  {
LABEL_23:
    uint64_t v18 = *(unsigned int *)(a2 + 12);
    if (v18)
    {
      uint64_t v19 = (const char **)(a2 + 8 * ((v15 >> 30) & 1) + 16);
      uint64_t v20 = 8 * v18;
      uint64_t v21 = &v26;
      while (1)
      {
        uint64_t v22 = *v19;
        uint64_t result = swift::_conformsToProtocol(a3, (uint64_t)a4, *v19, v21);
        if (!result) {
          break;
        }
        if (v21) {
          v21 += (v22 & 1) == 0;
        }
        else {
          uint64_t v21 = 0;
        }
        ++v19;
        v20 -= 8;
        if (!v20)
        {
          uint64_t v23 = v26;
          goto LABEL_32;
        }
      }
    }
    else
    {
      uint64_t v23 = 0;
LABEL_32:
      uint64_t v24 = _getErrorEmbeddedNSErrorIndirect<A>(_:)((uint64_t)a3, (uint64_t)a4, v23);
      if (v24)
      {
        *a1 = v24;
        return 1;
      }
      else
      {
        *a1 = swift_allocError((uint64_t)a4, v26, (uint64_t)a3, a7);
        if (a7) {
          return 2;
        }
        else {
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t tryCastToExtendedExistential(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t v12 = *(int **)(a2 + 8);
  if (v12)
  {
    uint64_t v13 = *(unsigned int **)(a2 + 8);
    int v14 = *v12;
    if ((*v12 & 0x100) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    unint64_t v15 = *((unsigned __int16 *)v13 + 10);
    uint64_t v16 = (void *)a4;
    if ((v14 & 0x200) == 0) {
      goto LABEL_63;
    }
    goto LABEL_7;
  }
  uint64_t v13 = 0;
  LOWORD(v14) = MEMORY[0];
  if ((MEMORY[0] & 0x100) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  unint64_t v15 = 0;
  uint64_t v16 = (void *)a4;
  if ((v14 & 0x200) == 0) {
    goto LABEL_63;
  }
LABEL_7:
  unint64_t v77 = 0;
  unint64_t v78 = 0;
  unint64_t v79 = 0;
  uint64_t v80 = 2400;
  uint64_t v81 = 0;
  char v82 = 0;
  v117 = 0;
  long long v76 = &unk_1ECA07790;
  uint64_t v83 = 0;
  uint64_t v84 = 0;
  uint64_t v85 = 0;
  char v86 = 0;
  long long v98 = 0u;
  long long v99 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  long long v102 = 0u;
  long long v103 = 0u;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v110 = 0u;
  long long v111 = 0u;
  long long v112 = 0u;
  long long v113 = 0u;
  long long v114 = 0u;
  long long v87 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v90 = 0u;
  long long v91 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  int v115 = 0;
  unint64_t v17 = *v13;
  if ((v17 & 0x200) != 0) {
    uint64_t v18 = (const char *)(((unint64_t)&v13[2 * ((v17 >> 8) & 1) + 4] + 3) & 0xFFFFFFFFFFFFFFFCLL);
  }
  else {
    uint64_t v18 = 0;
  }
  uint64_t v19 = *(int *)v18;
  uint64_t v20 = (uint64_t)&v18[v19];
  if (&v18[v19]) {
    size_t v21 = strlen(&v18[v19]);
  }
  else {
    size_t v21 = 0;
  }
  uint64_t v75 = 0;
  unint64_t v22 = swift::Demangle::__runtime::Demangler::demangleType((uint64_t)&v76, v20, v21, v74);
  if (v75 != v74)
  {
    if (v75) {
      (*(void (**)(void))(*v75 + 40))();
    }
    if (v22) {
      goto LABEL_17;
    }
LABEL_48:
    uint64_t v16 = (void *)a4;
    goto LABEL_56;
  }
  (*(void (**)(void *))(v74[0] + 32))(v74);
  if (!v22) {
    goto LABEL_48;
  }
LABEL_17:
  if (*(_WORD *)(v22 + 16) != 232)
  {
    LODWORD(v22) = 0;
    uint64_t v16 = (void *)a4;
    goto LABEL_56;
  }
  uint64_t v16 = (void *)a4;
  while (1)
  {
    int v24 = *(unsigned __int8 *)(v22 + 18);
    unsigned int v25 = v24 - 1;
    uint64_t v26 = (uint64_t *)v22;
    if ((v24 - 1) >= 2)
    {
      if (v24 != 5) {
        goto LABEL_55;
      }
      if (!*(_DWORD *)(v22 + 8)) {
        goto LABEL_52;
      }
      uint64_t v26 = *(uint64_t **)v22;
    }
    if (*(_WORD *)(*v26 + 16) != 145) {
      break;
    }
    uint64_t v27 = (uint64_t *)v22;
    if (v25 >= 2)
    {
      if (v24 != 5 || !*(_DWORD *)(v22 + 8))
      {
        uint64_t v28 = 0;
        goto LABEL_34;
      }
      uint64_t v27 = *(uint64_t **)v22;
    }
    uint64_t v28 = *v27;
LABEL_34:
    int v29 = *(unsigned __int8 *)(v28 + 18);
    if ((v29 - 1) >= 2 && (v29 != 5 || !*(_DWORD *)(v28 + 8))) {
      break;
    }
    if (*v16 != 772) {
      goto LABEL_55;
    }
    if (v25 < 2) {
      goto LABEL_42;
    }
    if (v24 == 5 && *(_DWORD *)(v22 + 8))
    {
      unint64_t v22 = *(void *)v22;
LABEL_42:
      unint64_t v23 = *(void *)v22;
      goto LABEL_44;
    }
    unint64_t v23 = 0;
LABEL_44:
    int v30 = *(unsigned __int8 *)(v23 + 18);
    if ((v30 - 1) >= 2)
    {
      if (v30 != 5 || !*(_DWORD *)(v23 + 8))
      {
        unint64_t v22 = 0;
        goto LABEL_22;
      }
      unint64_t v23 = *(void *)v23;
    }
    unint64_t v22 = *(void *)v23;
LABEL_22:
    uint64_t v16 = (void *)v16[1];
    if (*(_WORD *)(v22 + 16) != 232) {
      goto LABEL_55;
    }
  }
  if (v25 < 2)
  {
LABEL_54:
    LODWORD(v22) = *(unsigned __int16 *)(*(void *)v22 + 16) == 38;
    goto LABEL_56;
  }
  if (v24 == 5)
  {
LABEL_52:
    if (*(_DWORD *)(v22 + 8))
    {
      unint64_t v22 = *(void *)v22;
      goto LABEL_54;
    }
  }
LABEL_55:
  LODWORD(v22) = 0;
LABEL_56:
  long long v76 = &unk_1ECA07790;
  if (v117 == v116)
  {
    (*(void (**)(void *))(v116[0] + 32))(v116);
  }
  else if (v117)
  {
    (*(void (**)(void))(*v117 + 40))();
  }
  long long v76 = &unk_1ECA07768;
  swift::Demangle::__runtime::NodeFactory::freeSlabs(v79);
  if (v81) {
    *(unsigned char *)(v81 + 48) = 0;
  }
  if (!v22) {
    return 0;
  }
LABEL_63:
  unint64_t v71 = v73;
  uint64_t v72 = 0x400000000;
  uint64_t v68 = v70;
  uint64_t v69 = 0x400000000;
  if (v15 >= 5)
  {
    __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, (uint64_t)v73, v15, 8);
    unsigned int v31 = v72;
    goto LABEL_66;
  }
  unsigned int v31 = 0;
  int v32 = 0;
  if (v15)
  {
LABEL_66:
    memcpy((char *)v71 + 8 * v31, (const void *)(a2 + 16), 8 * v15);
    int v32 = v72;
  }
  uint64_t v33 = (v32 + v15);
  LODWORD(v72) = v33;
  if (v33 >= HIDWORD(v72))
  {
    __swift::__runtime::llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, (uint64_t)v73, v33 + 1, 8);
    LODWORD(v33) = v72;
  }
  *((void *)v71 + v33) = v16;
  LODWORD(v72) = v72 + 1;
  LODWORD(v76) = 2;
  unint64_t v77 = v13;
  unint64_t v78 = v71;
  unint64_t v79 = &v81;
  uint64_t v80 = 0x800000000;
  *(void *)&long long v100 = 0;
  unint64_t v34 = *v13;
  if ((v34 & 0x800) != 0)
  {
    uint64_t v36 = 0;
    uint16x8_t v35 = &swift::ImplicitGenericParamDescriptors;
  }
  else
  {
    uint16x8_t v35 = (void *)((((unint64_t)&v13[2 * ((v34 >> 8) & 1) + 4] + 3) & 0xFFFFFFFFFFFFFFFCLL)
                 + 4 * ((v34 >> 9) & 1)
                 + 4 * ((v34 >> 10) & 1));
    uint64_t v36 = *((unsigned __int16 *)v13 + 4);
  }
  uint64_t v37 = (unsigned __int16 *)(v13 + 4);
  if ((*v13 & 0x1100) == 0x100) {
    uint64_t v38 = *v37;
  }
  else {
    uint64_t v38 = 0;
  }
  uint64_t v39 = (unsigned __int16)*((void *)v13 + 1);
  uint64_t v40 = WORD1(*((void *)v13 + 1));
  v64[0] = &unk_1ECA04288;
  v64[1] = &v76;
  int v65 = v64;
  v62[0] = &unk_1ECA042D0;
  v62[1] = &v76;
  unint64_t v63 = v62;
  v60[0] = &unk_1ECA04318;
  uint64_t v61 = v60;
  ((void (*)(void *__return_ptr, void *, uint64_t, unint64_t, uint64_t, void **, void *, void *, void *))swift::_checkGenericRequirements)(v66, v35, v39, ((((unint64_t)&v37[4 * ((v34 >> 8) & 1) + 1] + 1) & 0xFFFFFFFFFFFFFFFCLL)+ 4 * ((v34 >> 9) & 1)+ 4 * ((v34 >> 10) & 1)+ v38+ v36+ 3) & 0xFFFFFFFFFFFFFFFCLL, v40, &v68, v64, v62, v60);
  if (v61 == v60)
  {
    (*(void (**)(void *))(v60[0] + 32))(v60);
  }
  else if (v61)
  {
    (*(void (**)(void))(*v61 + 40))();
  }
  if (v63 == v62)
  {
    (*(void (**)(void *))(v62[0] + 32))(v62);
  }
  else if (v63)
  {
    (*(void (**)(void))(*v63 + 40))();
  }
  if (v65 == v64)
  {
    (*(void (**)(void *))(v64[0] + 32))(v64);
    int v41 = v67;
    if (v67) {
      goto LABEL_87;
    }
  }
  else
  {
    if (v65) {
      (*(void (**)(void))(*v65 + 40))();
    }
    int v41 = v67;
    if (v67) {
LABEL_87:
    }
      ((void (*)(void, uint64_t, void))v66[1])(v66[0], 3, 0);
  }
  if (v79 != &v81) {
    free(v79);
  }
  if (v41)
  {
    uint64_t v42 = 0;
  }
  else
  {
    switch(*(unsigned char *)v13)
    {
      case 0:
        a1[3] = a4;
        BoxForExistentialIn = swift::TargetMetadata<swift::InProcess>::allocateBoxForExistentialIn(a4, a1);
        uint8x8_t v43 = a1 + 4;
        a1 = BoxForExistentialIn;
        uint64_t v44 = v69;
        if (v69) {
          goto LABEL_101;
        }
        goto LABEL_108;
      case 1:
      case 2:
        uint8x8_t v43 = a1 + 1;
        uint64_t v44 = v69;
        if (!v69) {
          goto LABEL_108;
        }
        goto LABEL_101;
      case 3:
        abort();
      default:
        a1 = 0;
        uint8x8_t v43 = 0;
        uint64_t v44 = v69;
        if (!v69) {
          goto LABEL_108;
        }
LABEL_101:
        uint64_t v46 = 0;
        uint64_t v47 = (char *)v68;
        if (v44 < 4) {
          goto LABEL_106;
        }
        if ((unint64_t)((char *)v43 - (unsigned char *)v68) < 0x20) {
          goto LABEL_106;
        }
        uint64_t v46 = v44 & 0xFFFFFFFC;
        unint64_t v48 = (long long *)((char *)v68 + 16);
        unint64_t v49 = v43 + 2;
        uint64_t v50 = v46;
        do
        {
          long long v51 = *v48;
          *(v49 - 1) = *(v48 - 1);
          *unint64_t v49 = v51;
          v48 += 2;
          v49 += 2;
          v50 -= 4;
        }
        while (v50);
        if (v46 != v44)
        {
LABEL_106:
          uint64_t v52 = &v43[v46];
          BOOL v53 = &v47[8 * v46];
          uint64_t v54 = v44 - v46;
          do
          {
            uint64_t v55 = *(void *)v53;
            v53 += 8;
            *v52++ = v55;
            --v54;
          }
          while (v54);
        }
LABEL_108:
        uint64_t v56 = *(void *)(a4 - 8);
        if (a7)
        {
          if (v56) {
            uint64_t v57 = *(void *)(a4 - 8);
          }
          else {
            uint64_t v57 = 0;
          }
          (*(void (**)(void *, uint64_t, unint64_t))(v57 + 32))(a1, a3, a4);
          uint64_t v42 = 2;
        }
        else
        {
          if (v56) {
            uint64_t v58 = *(void *)(a4 - 8);
          }
          else {
            uint64_t v58 = 0;
          }
          (*(void (**)(void *, uint64_t, unint64_t))(v58 + 16))(a1, a3, a4);
          uint64_t v42 = 1;
        }
        break;
    }
  }
  if (v68 != v70) {
    free(v68);
  }
  if (v71 != v73) {
    free(v71);
  }
  return v42;
}

void *tryCastToMetatype(uint64_t **a1, uint64_t a2, uint64_t *a3, Class cls, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = *(void *)cls;
  if (*(void *)cls > 0x7FFuLL) {
    LODWORD(v14) = 0;
  }
  if (!v14 || v14 == 773)
  {
    uint64_t result = (void *)getNonNullSrcObject(a3, cls, (Class *)a2);
    if (result)
    {
      unint64_t v17 = (unint64_t)result;
      Class = object_getClass(result);
      if (class_isMetaClass(Class)
        && (ObjCClassMetadata = swift_getObjCClassMetadata(v17), (unint64_t v21 = ObjCClassMetadata) != 0))
      {
        unint64_t MetatypeMetadata = swift_getMetatypeMetadata(ObjCClassMetadata);
        return (void *)tryCast(a1, a2, &v21, MetatypeMetadata, a5, a6, a7, a8);
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    uint64_t result = 0;
    if (v14 == 772)
    {
      uint64_t v16 = swift_dynamicCastMetatype((uint64_t *)*a3, *(uint64_t **)(a2 + 8));
      if (v16) {
        *a1 = v16;
      }
      return (void *)(v16 != 0);
    }
  }
  return result;
}

uint64_t tryCastToObjectiveCClass(void *a1, uint64_t a2, uint64_t *a3, Class cls, uint64_t a5, uint64_t a6, char a7, int a8)
{
  uint64_t v12 = *(void *)cls;
  if (*(void *)cls > 0x7FFuLL) {
    LODWORD(v12) = 0;
  }
  if (!v12 || v12 == 773 || (uint64_t result = 0, v12 == 515))
  {
    uint64_t NonNullSrcObject = (void *)getNonNullSrcObject(a3, cls, (Class *)a2);
    if (NonNullSrcObject)
    {
      uint64_t result = (uint64_t)swift_dynamicCastObjCClass(NonNullSrcObject, *(void *)(a2 + 8));
      if (!result) {
        return result;
      }
      *a1 = result;
      if (a7) {
        return 2;
      }
      id v15 = (id)result;
      return 1;
    }
    if (a8)
    {
      *a1 = 0;
      return 1;
    }
    return 0;
  }
  return result;
}

uint64_t tryCastToExistentialMetatype(uint64_t **a1, Class *a2, uint64_t *a3, Class cls)
{
  uint64_t v6 = *(void *)cls;
  if (*(void *)cls > 0x7FFuLL) {
    LODWORD(v6) = 0;
  }
  if (v6 == 773)
  {
    uint64_t NonNullSrcObject = (void *)getNonNullSrcObject(a3, cls, a2);
    if (NonNullSrcObject)
    {
      unint64_t v10 = (unint64_t)NonNullSrcObject;
      Class = object_getClass(NonNullSrcObject);
      if (class_isMetaClass(Class))
      {
        unint64_t ObjCClassMetadata = swift_getObjCClassMetadata(v10);
        if (ObjCClassMetadata)
        {
          unint64_t v7 = (uint64_t *)ObjCClassMetadata;
          goto LABEL_6;
        }
      }
    }
    return 0;
  }
  if (v6 != 772) {
    return 0;
  }
  unint64_t v7 = (uint64_t *)*a3;
LABEL_6:

  return _dynamicCastMetatypeToExistentialMetatype(a1, (uint64_t)a2, v7);
}

void *ObjCBridgeMemo::tryBridge(uint64_t *a1, uint64_t a2, Class *a3, uint64_t *a4, objc_class *a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9)
{
  v16[0] = a3;
  v16[1] = a1;
  swift_once(a1 + 3, (dispatch_function_t)ObjCBridgeMemo::tryBridge(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::{lambda(void *)#1}::__invoke, v16);
  if (!a1[2]) {
    return 0;
  }
  uint64_t result = (void *)getNonNullSrcObject(a4, a5, a3);
  if (result)
  {
    uint64_t v15 = (uint64_t)result;
    uint64_t result = object_getClass(result);
    while (result != (void *)a1[2])
    {
      uint64_t result = class_getSuperclass((Class)result);
      if (!result) {
        return result;
      }
    }
    return (void *)_tryCastFromClassToObjCBridgeable(a2, (uint64_t)a3, v15, a9, *a1);
  }
  return result;
}

uint64_t _tryCastFromClassToObjCBridgeable(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v11 = (uint64_t *)(a2 - 8);
  uint64_t v10 = *(void *)(a2 - 8);
  if (*(void *)(v10 + 72) >= 0x19uLL)
  {
    uint64_t v13 = (uint64_t *)swift_slowAlloc(*(void *)(v10 + 64) + 1, *(unsigned __int8 *)(*(void *)(a2 - 8) + 80));
    uint64_t v10 = *v11;
    uint64_t v12 = v13;
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v13 = &v17;
  }
  (*(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(v10 + 56))(v13, 1, 1, a2);
  if (a4)
  {
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a5 + 24))(a3, v13, a2, a5);
  }
  else if (((*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a5 + 32))(a3, v13, a2, a5) & 1) == 0)
  {
    uint64_t v15 = 0;
    if (!v12) {
      return v15;
    }
    goto LABEL_11;
  }
  if (*v11) {
    uint64_t v14 = *v11;
  }
  else {
    uint64_t v14 = 0;
  }
  (*(void (**)(uint64_t, uint64_t *, uint64_t))(v14 + 32))(a1, v13, a2);
  uint64_t v15 = 1;
  if (v12) {
LABEL_11:
  }
    swift_slowDealloc(v12);
  return v15;
}

uint64_t ObjCBridgeMemo::tryBridge(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::{lambda(void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v2 = (uint64_t *)a1[1];
  uint64_t result = swift_conformsToProtocolCommon(*a1, (uint64_t)&protocol descriptor for _ObjectiveCBridgeable);
  *uint64_t v2 = result;
  if (result)
  {
    v2[1] = result;
    uint64_t v4 = *(int **)result;
    if (*(void *)result > 0x7FFuLL) {
      LODWORD(v4) = 0;
    }
    if (v4)
    {
      if (v4 == 773) {
        uint64_t result = *(void *)(result + 8);
      }
      else {
        uint64_t result = 0;
      }
    }
    void v2[2] = result;
  }
  else
  {
    v2[1] = 0;
    void v2[2] = 0;
  }
  return result;
}

void std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_0,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_0>,void const* ()(unsigned int,unsigned int)>::~__func()
{
}

void *std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_0,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_0>,void const* ()(unsigned int,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ECA04288;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_0,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_0>,void const* ()(unsigned int,unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ECA04288;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_0,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_0>,void const* ()(unsigned int,unsigned int)>::operator()(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  return swift::SubstGenericParametersFromMetadata::getMetadata(*(swift::SubstGenericParametersFromMetadata **)(a1 + 8), *a2, *a3);
}

void std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_1,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_1>,void const* ()(unsigned int,unsigned int)>::~__func()
{
}

void *std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_1,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_1>,void const* ()(unsigned int,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ECA042D0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_1,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_1>,void const* ()(unsigned int,unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ECA042D0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_1,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_1>,void const* ()(unsigned int,unsigned int)>::operator()(uint64_t a1, uint64_t a2, int *a3)
{
  return swift::SubstGenericParametersFromMetadata::getMetadataKeyArgOrdinal(*(swift::SubstGenericParametersFromMetadata **)(a1 + 8), *a3);
}

void std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_2,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_2>,swift::TargetWitnessTable<swift::InProcess> const* ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int)>::~__func()
{
}

void *std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_2,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_2>,swift::TargetWitnessTable<swift::InProcess> const* ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1ECA04318;
  return result;
}

void std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_2,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_2>,swift::TargetWitnessTable<swift::InProcess> const* ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1ECA04318;
}

void std::__function::__func<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_2,std::allocator<tryCastToExtendedExistential(swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::OpaqueValue *,swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*&,swift::TargetMetadata<swift::InProcess> const*&,BOOL,BOOL)::$_2>,swift::TargetWitnessTable<swift::InProcess> const* ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int)>::operator()()
{
}

uint64_t _dynamicCastMetatypeToExistentialMetatype(uint64_t **a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = a1;
  uint64_t v5 = *(void *)(a2 + 8);
  if (*(void *)v5 != 771)
  {
    if (*a3 != 772) {
      return 0;
    }
    if (a1) {
      *a1 = a3;
    }
    while (1)
    {
      uint64_t v3 = (uint64_t *)v3[1];
      uint64_t v5 = *(void *)(v5 + 8);
      if (*(void *)v5 == 771) {
        break;
      }
      if (*v3 != 772) {
        return 0;
      }
    }
    uint64_t v4 = 0;
  }
  if (v4) {
    unint64_t v7 = (uint64_t *)(v4 + 1);
  }
  else {
    unint64_t v7 = 0;
  }
  unsigned int v8 = *(_DWORD *)(v5 + 8);
  if ((v8 & 0x40000000) != 0)
  {
    uint64_t v9 = *(uint64_t **)(v5 + 16);
    if (v9)
    {
      uint64_t result = (uint64_t)swift_dynamicCastMetatype(v3, v9);
      if (!result) {
        return result;
      }
      unsigned int v8 = *(_DWORD *)(v5 + 8);
    }
  }
  if ((v8 & 0x80000000) != 0) {
    goto LABEL_22;
  }
  uint64_t v10 = *v3;
  if ((unint64_t)*v3 > 0x7FF) {
    LODWORD(v1swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
  }
  if (!v10 || v10 == 773 || (uint64_t result = 0, v10 == 515))
  {
LABEL_22:
    uint64_t v11 = *(unsigned int *)(v5 + 12);
    if (v11)
    {
      uint64_t v12 = (const char **)(v5 + 8 * ((v8 >> 30) & 1) + 16);
      uint64_t v13 = 8 * v11;
      while (1)
      {
        uint64_t v14 = *v12;
        uint64_t result = swift::_conformsToProtocol(0, (uint64_t)v3, *v12, v7);
        if (!result) {
          break;
        }
        if (v7) {
          v7 += (v14 & 1) == 0;
        }
        else {
          unint64_t v7 = 0;
        }
        ++v12;
        v13 -= 8;
        if (!v13) {
          goto LABEL_29;
        }
      }
    }
    else
    {
LABEL_29:
      if (v4) {
        int *v4 = v3;
      }
      return 1;
    }
  }
  return result;
}

uint64_t initializeToNilAtDepth(uint64_t a1, unint64_t *a2, int a3)
{
  unint64_t v5 = *swift::TargetMetadata<swift::InProcess>::getGenericArgs(a2);
  if (a3 < 1)
  {
    uint64_t v6 = 1;
  }
  else
  {
    initializeToNilAtDepth(a1, v5, (a3 - 1));
    uint64_t v6 = 0;
  }
  unint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t))(*(void *)(v5 - 8) + 56);

  return v7(a1, v6, 1, v5);
}

__n128 swift_initEnumMetadataSingleCase(uint64_t a1, __int16 a2, __n128 *a3)
{
  uint64_t v4 = (uint64_t *)(a1 - 8);
  if (*(void *)(a1 - 8))
  {
    uint64_t v5 = *(void *)(a1 - 8);
    if ((a2 & 0x100) != 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  uint64_t v5 = 0;
  if ((a2 & 0x100) == 0)
  {
LABEL_5:
    Metadata = swift::allocateMetadata(0x70uLL, 8);
    uint64_t v7 = swift::TargetEnumValueWitnessTable<swift::InProcess>::TargetEnumValueWitnessTable((uint64_t)Metadata, v5);
    uint64_t *v4 = v7;
    uint64_t v5 = v7;
  }
LABEL_6:
  unsigned __int32 v8 = a3[1].n128_u32[1];
  int v9 = a3[1].n128_u32[0] | 0x200000;
  __n128 result = *a3;
  *(__n128 *)(v5 + 64) = *a3;
  *(_DWORD *)(v5 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v9;
  *(_DWORD *)(v5 + 84) = v8;
  return result;
}

double swift_initEnumMetadataSingleCaseWithLayoutString(uint64_t *a1, __int16 a2, unint64_t *a3)
{
  if (*(a3 - 1)) {
    uint64_t v5 = *(a3 - 1);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = a1 - 1;
  if (!*(a1 - 1))
  {
    uint64_t v7 = 0;
    if ((a2 & 0x100) != 0) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v7 = *(a1 - 1);
  if ((a2 & 0x100) == 0)
  {
LABEL_8:
    Metadata = swift::allocateMetadata(0x70uLL, 8);
    uint64_t v9 = swift::TargetEnumValueWitnessTable<swift::InProcess>::TargetEnumValueWitnessTable((uint64_t)Metadata, v7);
    *uint64_t v6 = v9;
    uint64_t v7 = v9;
  }
LABEL_9:
  long long v21 = *(_OWORD *)(v5 + 64);
  int v10 = *(_DWORD *)(v5 + 84);
  LODWORD(v22) = *(_DWORD *)(v5 + 80) | 0x200000;
  HIDWORD(v22) = v10;
  uint64_t v11 = _swift_refCountBytesForMetatype(a3);
  LOWORD(v19) = 26;
  uint64_t v12 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v19, (v11 + 31) & 0xFFFFFFFFFFFFFFF8, 1);
  *((void *)v12 + 1) = v11;
  uint64_t v19 = (uint64_t *)v12;
  uint64_t v20 = 16;
  uint64_t v17 = 0;
  unint64_t v18 = 0;
  uint64_t v16 = 0;
  _swift_addRefCountStringForMetatype((uint64_t)&v19, &v16, a3, &v18, (unint64_t *)&v17);
  v19[(unint64_t)v20 / 8] = v17;
  uint64_t v20 = 0;
  *uint64_t v19 = v16 & 0x7FFFFFFFFFFFFFFFLL;
  v20 += 8;
  *(void *)(v7 + 8) = swift_generic_destroy;
  *(void *)(v7 + 16) = swift_generic_initWithCopy;
  *(void *)(v7 + 32) = swift_generic_initWithTake;
  *(void *)(v7 + 24) = swift_generic_assignWithCopy;
  *(void *)(v7 + 4swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = swift_generic_assignWithTake;
  swift::installCommonValueWitnesses((uint64_t)&v21, (void **)v7);
  uint64_t v13 = *a1;
  if ((unint64_t)*a1 > 0x7FF) {
    LODWORD(v13) = 0;
  }
  if (!v13 || v13 == 773 || v13 == 515) {
    uint64_t v14 = a1 - 3;
  }
  else {
    uint64_t v14 = a1 - 2;
  }
  uint64_t *v14 = (uint64_t)v12;
  *(_OWORD *)(v7 + 64) = v21;
  double result = v22;
  *(double *)(v7 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v22;
  return result;
}

double swift_initEnumMetadataSinglePayload(uint64_t a1, __int16 a2, uint64_t a3, unsigned int a4)
{
  unint64_t v5 = *(void *)a3;
  unsigned int v6 = *(_DWORD *)(a3 + 20);
  unsigned int v7 = v6 - a4;
  if (v6 < a4)
  {
    if (v5 <= 3)
    {
      unsigned int v9 = ((a4 - v6 + ~(-1 << (8 * v5))) >> (8 * v5)) + 1;
      if (v9 >= 2)
      {
        uint64_t v10 = 4;
        if (v9 < 0x10000) {
          uint64_t v10 = 2;
        }
        if (v9 >= 0x100) {
          uint64_t v8 = v10;
        }
        else {
          uint64_t v8 = 1;
        }
      }
      else
      {
        uint64_t v8 = 0;
      }
    }
    else
    {
      uint64_t v8 = 1;
    }
    unsigned int v7 = 0;
    v5 += v8;
  }
  uint64_t v11 = (uint64_t *)(a1 - 8);
  if (!*(void *)(a1 - 8))
  {
    uint64_t v12 = 0;
    if ((a2 & 0x100) != 0) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  uint64_t v12 = *(void *)(a1 - 8);
  if ((a2 & 0x100) == 0)
  {
LABEL_16:
    Metadata = swift::allocateMetadata(0x70uLL, 8);
    uint64_t v14 = swift::TargetEnumValueWitnessTable<swift::InProcess>::TargetEnumValueWitnessTable((uint64_t)Metadata, v12);
    uint64_t *v11 = v14;
    uint64_t v12 = v14;
  }
LABEL_17:
  int v15 = *(_DWORD *)(a3 + 16);
  unint64_t v16 = v15 + 1;
  BOOL v18 = (v15 & 0x100000) != 0 || v5 >= 0x19 || v15 >= 8u;
  unsigned int v19 = v15 & 0xFFFDFFFF;
  if (v18) {
    int v20 = 0x20000;
  }
  else {
    int v20 = 0;
  }
  LODWORD(v24) = v19 | v20 | 0x200000;
  HIDWORD(v24) = v7;
  unint64_t v21 = (v5 + v16 - 1) / v16 * v16;
  if (v21 <= 1) {
    unint64_t v21 = 1;
  }
  *(void *)&long long v23 = v5;
  *((void *)&v23 + 1) = v21;
  swift::installCommonValueWitnesses((uint64_t)&v23, (void **)v12);
  *(_OWORD *)(v12 + 64) = v23;
  double result = v24;
  *(double *)(v12 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v24;
  return result;
}

double swift_initEnumMetadataSinglePayloadWithLayoutString(uint64_t *a1, __int16 a2, unint64_t *a3, unsigned int a4)
{
  unsigned int v7 = a3 - 1;
  unint64_t v6 = *(a3 - 1);
  unint64_t v8 = v6;
  unint64_t v9 = *(void *)(v6 + 64);
  unsigned int v10 = *(_DWORD *)(v6 + 84);
  unsigned int v11 = v10 - a4;
  if (v10 >= a4)
  {
    LODWORD(v12) = 0;
    unint64_t v13 = *(void *)(v6 + 64);
  }
  else
  {
    if (v9 <= 3)
    {
      unsigned int v14 = ((a4 - v10 + ~(-1 << (8 * v9))) >> (8 * v9)) + 1;
      if (v14 >= 2)
      {
        uint64_t v15 = 4;
        if (v14 < 0x10000) {
          uint64_t v15 = 2;
        }
        if (v14 >= 0x100) {
          uint64_t v12 = v15;
        }
        else {
          uint64_t v12 = 1;
        }
      }
      else
      {
        uint64_t v12 = 0;
      }
    }
    else
    {
      uint64_t v12 = 1;
    }
    unsigned int v11 = 0;
    unint64_t v13 = v12 + v9;
  }
  unint64_t v16 = a1 - 1;
  if (!*(a1 - 1))
  {
    uint64_t v17 = 0;
    if ((a2 & 0x100) != 0) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  uint64_t v17 = *(a1 - 1);
  if ((a2 & 0x100) == 0)
  {
LABEL_17:
    Metadata = swift::allocateMetadata(0x70uLL, 8);
    uint64_t v19 = swift::TargetEnumValueWitnessTable<swift::InProcess>::TargetEnumValueWitnessTable((uint64_t)Metadata, v17);
    uint64_t *v16 = v19;
    unint64_t v6 = *v7;
    uint64_t v17 = v19;
  }
LABEL_18:
  int v20 = *(_DWORD *)(v8 + 80);
  unint64_t v21 = v20 + 1;
  BOOL v23 = (v20 & 0x100000) != 0 || v13 >= 0x19 || v20 >= 8u;
  unsigned int v24 = v20 & 0xFFFDFFFF;
  if (v23) {
    int v25 = 0x20000;
  }
  else {
    int v25 = 0;
  }
  LODWORD(v5swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v24 | v25 | 0x200000;
  HIDWORD(v5swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v11;
  unint64_t v26 = (v13 + v21 - 1) / v21 * v21;
  if (v26 <= 1) {
    unint64_t v26 = 1;
  }
  *(void *)&long long v49 = v13;
  *((void *)&v49 + 1) = v26;
  if (*(_DWORD *)(v6 + 84))
  {
    if (*a3 == 769)
    {
      uint64_t v27 = (uint64_t *)(a3 + 3);
      unint64_t v28 = a3[1];
      if (v28 < 2)
      {
        unsigned int v31 = (unint64_t **)(a3 + 3);
      }
      else
      {
        uint64_t v29 = *v27;
        uint64_t v30 = 1;
        unsigned int v31 = (unint64_t **)(a3 + 3);
        do
        {
          int v32 = &v27[2 * v30];
          if (*(_DWORD *)(*(void *)(v29 - 8) + 84) < *(_DWORD *)(*(void *)(*v32 - 8) + 84))
          {
            uint64_t v29 = *v32;
            unsigned int v31 = (unint64_t **)&v27[2 * v30];
          }
          ++v30;
        }
        while (v28 != v30);
      }
      uint64_t v33 = *v31;
      unint64_t v34 = v31[1];
    }
    else
    {
      unint64_t v34 = 0;
      uint64_t v33 = a3;
    }
  }
  else
  {
    uint64_t v33 = 0;
    unint64_t v34 = 0;
  }
  uint64_t v35 = _swift_refCountBytesForMetatype(a3);
  LOWORD(v47) = 26;
  uint64_t v36 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v47, (v35 + 83) & 0xFFFFFFFFFFFFFFF8, 1);
  uint64_t v37 = v36;
  *((void *)v36 + 1) = v35 + 52;
  *((void *)v36 + 2) = 0x1300000000000000;
  if (v12 >= 3) {
    uint64_t v38 = 3;
  }
  else {
    uint64_t v38 = v12;
  }
  *((void *)v36 + 3) = (unint64_t)v34 | (v38 << 62);
  *((void *)v36 + 4) = v9;
  *((void *)v36 + 5) = v33;
  *((_DWORD *)v36 + 12) = a4;
  *(void *)(v36 + 26) = v35;
  uint64_t v47 = (uint64_t *)v36;
  uint64_t v48 = 68;
  unint64_t v45 = 0;
  unint64_t v46 = 0;
  uint64_t v44 = 0;
  _swift_addRefCountStringForMetatype((uint64_t)&v47, &v44, a3, &v46, &v45);
  *(uint64_t *)((char *)v47 + v48) = v45 + v12;
  uint64_t v39 = v47;
  *(uint64_t *)((char *)v47 + 6swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v9 - v45;
  uint64_t v48 = 0;
  *uint64_t v39 = v44 & 0x7FFFFFFFFFFFFFFFLL;
  v48 += 8;
  uint64_t v40 = *a1;
  if ((unint64_t)*a1 > 0x7FF) {
    LODWORD(v4swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
  }
  if (!v40 || v40 == 773 || v40 == 515) {
    int v41 = a1 - 3;
  }
  else {
    int v41 = a1 - 2;
  }
  *int v41 = (uint64_t)v37;
  *(void *)(v17 + 8) = swift_generic_destroy;
  *(void *)(v17 + 16) = swift_generic_initWithCopy;
  *(void *)(v17 + 32) = swift_generic_initWithTake;
  *(void *)(v17 + 24) = swift_generic_assignWithCopy;
  *(void *)(v17 + 4swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = swift_generic_assignWithTake;
  swift::installCommonValueWitnesses((uint64_t)&v49, (void **)v17);
  *(_OWORD *)(v17 + 64) = v49;
  double result = v50;
  *(double *)(v17 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v50;
  return result;
}

uint64_t swift_getEnumTagSinglePayloadGeneric(unsigned __int8 *a1, unsigned int a2, uint64_t a3, uint64_t (*a4)(void))
{
  unint64_t v5 = *(void *)(*(void *)(a3 - 8) + 64);
  unsigned int v6 = *(_DWORD *)(*(void *)(a3 - 8) + 84);
  BOOL v7 = a2 >= v6;
  unsigned int v8 = a2 - v6;
  if (v8 == 0 || !v7) {
    goto LABEL_12;
  }
  if (v5 > 3) {
    goto LABEL_6;
  }
  unsigned int v9 = ((v8 + ~(-1 << (8 * v5))) >> (8 * v5)) + 1;
  if (v9 < 2) {
    goto LABEL_12;
  }
  if (v9 >= 0x100)
  {
    if (v9 >= 0x10000) {
      int v10 = *(_DWORD *)&a1[v5];
    }
    else {
      int v10 = *(unsigned __int16 *)&a1[v5];
    }
  }
  else
  {
LABEL_6:
    int v10 = a1[v5];
  }
  if (!v10)
  {
LABEL_12:
    if (v6) {
      return a4();
    }
    else {
      return 0;
    }
  }
  int v11 = (v10 - 1) << (8 * v5);
  if (v5 > 3) {
    int v11 = 0;
  }
  int v12 = 0;
  switch(v5)
  {
    case 0uLL:
      return v6 + (v12 | v11) + 1;
    case 1uLL:
      int v12 = *a1;
      break;
    case 2uLL:
      int v12 = *(unsigned __int16 *)a1;
      break;
    case 3uLL:
      int v12 = *(unsigned __int16 *)a1 | (a1[2] << 16);
      break;
    default:
      int v12 = *(_DWORD *)a1;
      break;
  }
  return v6 + (v12 | v11) + 1;
}

void swift_storeEnumTagSinglePayloadGeneric(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4, void (*a5)(void, void, void, void))
{
}

void swift::storeEnumTagSinglePayloadImpl(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4, unint64_t a5, uint64_t a6, void (*a7)(void, void, void, void))
{
  int v11 = &a1[a5];
  if (a3 <= a6)
  {
    if (a2 > a6)
    {
      unsigned int v12 = 0;
      goto LABEL_17;
    }
  }
  else
  {
    if (a5 > 3)
    {
      unsigned int v12 = 1;
      if (a2 <= a6) {
        goto LABEL_23;
      }
      goto LABEL_17;
    }
    unsigned int v13 = ((a3 - a6 + ~(-1 << (8 * a5))) >> (8 * a5)) + 1;
    if (v13 >= 2)
    {
      if (v13 >= 0x10000) {
        int v15 = 4;
      }
      else {
        int v15 = 2;
      }
      if (v13 >= 0x100) {
        unsigned int v12 = v15;
      }
      else {
        unsigned int v12 = 1;
      }
      if (a2 <= a6)
      {
LABEL_23:
        switch(v12)
        {
          case 1u:
            unsigned char *v11 = 0;
            if (a2) {
              goto LABEL_44;
            }
            break;
          case 2u:
            *(_WORD *)int v11 = 0;
            if (a2) {
              goto LABEL_44;
            }
            break;
          case 3u:
            v11[2] = 0;
            *(_WORD *)int v11 = 0;
            goto LABEL_43;
          case 4u:
            *(_DWORD *)int v11 = 0;
            if (a2) {
              goto LABEL_44;
            }
            break;
          default:
            *(_DWORD *)int v11 = 0;
            uint64_t v17 = a7;
            bzero(v11 + 4, v12 - 4);
            a7 = v17;
            if (a2) {
              goto LABEL_44;
            }
            break;
        }
        return;
      }
LABEL_17:
      unsigned int v14 = ~a6 + a2;
      if (a5 > 3)
      {
        int v16 = 1;
        goto LABEL_21;
      }
LABEL_19:
      int v16 = (v14 >> (8 * a5)) + 1;
      if (!a5)
      {
LABEL_30:
        switch(v12)
        {
          case 0u:
            return;
          case 1u:
            unsigned char *v11 = v16;
            break;
          case 2u:
            *(_WORD *)int v11 = v16;
            break;
          case 3u:
            *(_WORD *)int v11 = v16;
            v11[2] = BYTE2(v16);
            break;
          case 4u:
            *(_DWORD *)int v11 = v16;
            break;
          default:
            *(_DWORD *)int v11 = v16;
            bzero(v11 + 4, v12 - 4);
            break;
        }
        return;
      }
      v14 &= ~(-1 << (8 * a5));
LABEL_21:
      switch(a5)
      {
        case 1uLL:
          *a1 = v14;
          break;
        case 2uLL:
          *(_WORD *)a1 = v14;
          break;
        case 3uLL:
          *(_WORD *)a1 = v14;
          a1[2] = BYTE2(v14);
          break;
        case 4uLL:
          *(_DWORD *)a1 = v14;
          break;
        default:
          *(_DWORD *)a1 = v14;
          bzero(a1 + 4, a5 - 4);
          break;
      }
      goto LABEL_30;
    }
    if (a2 > a6)
    {
      unsigned int v12 = 0;
      unsigned int v14 = ~a6 + a2;
      goto LABEL_19;
    }
  }
LABEL_43:
  if (a2)
  {
LABEL_44:
    a7(a1, a2, a6, a4);
  }
}

double swift_initEnumMetadataMultiPayload(uint64_t a1, __int16 a2, int a3, uint64_t a4)
{
  unsigned int v4 = a3;
  if (a3)
  {
    if (a3 == 1)
    {
      uint64_t v6 = 0;
      unint64_t v7 = 0;
      unint64_t v8 = 0;
      LOBYTE(v9) = 1;
      LOBYTE(v1swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 1;
    }
    else
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      unint64_t v14 = 0;
      unint64_t v15 = 0;
      uint64_t v6 = a3 & 0xFFFFFFFE;
      int v16 = (unint64_t **)(a4 + 8);
      LOBYTE(v17) = 1;
      uint64_t v18 = v6;
      LOBYTE(v19) = 1;
      LOBYTE(v2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 1;
      LOBYTE(a3) = 1;
      do
      {
        uint64_t v21 = (uint64_t)*(v16 - 1);
        if (v14 <= *(void *)v21) {
          unint64_t v14 = *(void *)v21;
        }
        if (v15 <= **v16) {
          unint64_t v15 = **v16;
        }
        int v22 = *(_DWORD *)(v21 + 16);
        int v23 = *((_DWORD *)*v16 + 4);
        v12 |= v22;
        v13 |= v23;
        int v17 = v17 & ((v22 & 0x10000) == 0);
        int v19 = v19 & ((v23 & 0x10000) == 0);
        int v20 = v20 & ((v22 & 0x100000) == 0);
        a3 = a3 & ((v23 & 0x100000) == 0);
        v16 += 2;
        v18 -= 2;
      }
      while (v18);
      if (v14 <= v15) {
        unint64_t v8 = v15;
      }
      else {
        unint64_t v8 = v14;
      }
      int v10 = a3 & v20;
      int v9 = v19 & v17;
      unint64_t v7 = v13 | v12;
      if (v6 == v4) {
        goto LABEL_19;
      }
    }
    unsigned int v24 = (unint64_t **)(a4 + 8 * v6);
    uint64_t v25 = v4 - v6;
    do
    {
      uint64_t v27 = *v24++;
      unint64_t v26 = v27;
      unint64_t v28 = *v27;
      if (v8 <= *v27) {
        unint64_t v8 = v28;
      }
      int v29 = *((_DWORD *)v26 + 4);
      v7 |= v29;
      int v9 = v9 & ((v29 & 0x10000) == 0);
      int v10 = v10 & ((v29 & 0x100000) == 0);
      --v25;
    }
    while (v25);
LABEL_19:
    if (v9) {
      int v11 = 0;
    }
    else {
      int v11 = 0x10000;
    }
    goto LABEL_22;
  }
  unint64_t v8 = 0;
  int v11 = 0;
  unint64_t v7 = 0;
  int v10 = 1;
LABEL_22:
  uint64_t v30 = *(void *)(a1 + 8);
  if (v30) {
    uint64_t v31 = *(void *)(a1 + 8);
  }
  else {
    uint64_t v31 = 0;
  }
  unint64_t v32 = (unint64_t)*(unsigned int *)(v31 + 20) >> 24;
  if (*(void *)(a1 + 8 * v32) != v8) {
    *(void *)(a1 + 8 * v32) = v8;
  }
  if (v30) {
    uint64_t v33 = v30;
  }
  else {
    uint64_t v33 = 0;
  }
  int v34 = *(_DWORD *)(v33 + 24);
  if (!v34)
  {
LABEL_33:
    if (v4 < 2) {
      goto LABEL_34;
    }
    goto LABEL_37;
  }
  if (v8 >= 4)
  {
    ++v4;
    goto LABEL_33;
  }
  v4 += (v34 + ~(-1 << (8 * v8))) >> (8 * v8);
  if (v4 < 2)
  {
LABEL_34:
    int v35 = 0;
    uint64_t v38 = *(void *)(a1 - 8);
    uint64_t v37 = (uint64_t *)(a1 - 8);
    uint64_t v36 = v38;
    if (!v38) {
      goto LABEL_45;
    }
    goto LABEL_39;
  }
LABEL_37:
  if (v4 >= 0x100)
  {
    if (v4 >= 0x10000) {
      int v35 = 4;
    }
    else {
      int v35 = 2;
    }
    uint64_t v41 = *(void *)(a1 - 8);
    uint64_t v37 = (uint64_t *)(a1 - 8);
    uint64_t v36 = v41;
    if (!v41)
    {
LABEL_45:
      uint64_t v40 = 0;
      if ((a2 & 0x100) != 0) {
        goto LABEL_47;
      }
      goto LABEL_46;
    }
  }
  else
  {
    int v35 = 1;
    uint64_t v39 = *(void *)(a1 - 8);
    uint64_t v37 = (uint64_t *)(a1 - 8);
    uint64_t v36 = v39;
    if (!v39) {
      goto LABEL_45;
    }
  }
LABEL_39:
  uint64_t v40 = v36;
  if ((a2 & 0x100) == 0)
  {
LABEL_46:
    Metadata = swift::allocateMetadata(0x70uLL, 8);
    uint64_t v43 = swift::TargetEnumValueWitnessTable<swift::InProcess>::TargetEnumValueWitnessTable((uint64_t)Metadata, v40);
    *uint64_t v37 = v43;
    uint64_t v40 = v43;
  }
LABEL_47:
  unsigned int v44 = (1 << (8 * v35)) - v4;
  if (v44 >= 0x7FFFFFFF) {
    unsigned int v44 = 0x7FFFFFFF;
  }
  if (v35 == 4) {
    unsigned int v44 = 0x7FFFFFFF;
  }
  uint64_t v45 = (v35 + v8);
  unint64_t v46 = (v45 + v7) & ~v7;
  if (v46 <= 1) {
    unint64_t v46 = 1;
  }
  BOOL v48 = v7 < 8 && v45 < 0x19;
  if ((v10 & v48) != 0) {
    int v49 = 0;
  }
  else {
    int v49 = 0x20000;
  }
  if (v10) {
    int v50 = 0x200000;
  }
  else {
    int v50 = 3145728;
  }
  *(void *)&long long v52 = (v35 + v8);
  *((void *)&v52 + 1) = v46;
  LODWORD(v53) = v50 | v11 | v7 & 0xFFCCFFFF | v49;
  HIDWORD(v53) = v44;
  swift::installCommonValueWitnesses((uint64_t)&v52, (void **)v40);
  *(void *)(v40 + 48) = swift_getMultiPayloadEnumTagSinglePayload;
  *(void *)(v40 + 56) = swift_storeMultiPayloadEnumTagSinglePayload;
  *(_OWORD *)(v40 + 64) = v52;
  double result = v53;
  *(double *)(v40 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v53;
  return result;
}

uint64_t swift_getMultiPayloadEnumTagSinglePayload(unsigned __int8 *a1, unsigned int a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(*(void *)(a3 - 8) + 64);
  unsigned int v4 = *(_DWORD *)(*(void *)(a3 - 8) + 84);
  if (a2 > v4)
  {
    if (v3 > 3) {
      goto LABEL_5;
    }
    unsigned int v5 = ((a2 - v4 + ~(-1 << (8 * v3))) >> (8 * v3)) + 1;
    if (v5 < 2) {
      goto LABEL_11;
    }
    if (v5 >= 0x100)
    {
      if (v5 >= 0x10000) {
        int v6 = *(_DWORD *)&a1[v3];
      }
      else {
        int v6 = *(unsigned __int16 *)&a1[v3];
      }
    }
    else
    {
LABEL_5:
      int v6 = a1[v3];
    }
    if (v6)
    {
      int v7 = (v6 - 1) << (8 * v3);
      if (v3 > 3) {
        int v7 = 0;
      }
      int v8 = 0;
      switch(v3)
      {
        case 0uLL:
          return v4 + (v8 | v7) + 1;
        case 1uLL:
          int v8 = *a1;
          break;
        case 2uLL:
          int v8 = *(unsigned __int16 *)a1;
          break;
        case 3uLL:
          int v8 = *(unsigned __int16 *)a1 | (a1[2] << 16);
          break;
        default:
          int v8 = *(_DWORD *)a1;
          break;
      }
      return v4 + (v8 | v7) + 1;
    }
  }
LABEL_11:
  if (!v4) {
    return 0;
  }
  if (*(void *)(a3 + 8)) {
    uint64_t v9 = *(void *)(a3 + 8);
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v11 = *(void *)(a3 + (((unint64_t)*(unsigned int *)(v9 + 20) >> 21) & 0x7F8));
  uint64_t v12 = v3 - v11;
  int v13 = 0;
  switch(v12)
  {
    case 0:
      break;
    case 1:
      int v13 = a1[v11];
      break;
    case 2:
      int v13 = *(unsigned __int16 *)&a1[v11];
      break;
    case 3:
      int v13 = *(unsigned __int16 *)&a1[v11] | (a1[v11 + 2] << 16);
      break;
    default:
      int v13 = *(_DWORD *)&a1[v11];
      break;
  }
  if (v12 == 4) {
    int v14 = 0;
  }
  else {
    int v14 = -1 << (8 * v12);
  }
  int v15 = v13 | v14;
  if (__CFADD__(v15, v4)) {
    return -v15;
  }
  else {
    return 0;
  }
}

void swift_storeMultiPayloadEnumTagSinglePayload(unsigned char *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
}

double swift_initEnumMetadataMultiPayloadWithLayoutString(uint64_t *a1, __int16 a2, unsigned int a3, unint64_t **a4)
{
  unsigned int v4 = a4;
  if (a3)
  {
    __int16 v54 = a2;
    unint64_t v7 = 0;
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    LOBYTE(v1swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 1;
    uint64_t v11 = a4;
    LOBYTE(v12) = 1;
    uint64_t v13 = a3;
    do
    {
      int v15 = *v11++;
      int v14 = v15;
      uint64_t v16 = *(v15 - 1);
      if (v9 <= *(void *)(v16 + 64)) {
        unint64_t v9 = *(void *)(v16 + 64);
      }
      int v17 = *(_DWORD *)(v16 + 80);
      v7 |= v17;
      int v10 = v10 & ((v17 & 0x10000) == 0);
      int v12 = v12 & ((v17 & 0x100000) == 0);
      v8 += _swift_refCountBytesForMetatype(v14) + 8;
      --v13;
    }
    while (v13);
    if (v10) {
      int v18 = 0;
    }
    else {
      int v18 = 0x10000;
    }
    a2 = v54;
  }
  else
  {
    unint64_t v9 = 0;
    uint64_t v8 = 0;
    int v18 = 0;
    unint64_t v7 = 0;
    int v12 = 1;
  }
  uint64_t v19 = a1[1];
  int v53 = v18;
  if (v19) {
    uint64_t v20 = a1[1];
  }
  else {
    uint64_t v20 = 0;
  }
  unint64_t v21 = (unint64_t)*(unsigned int *)(v20 + 20) >> 24;
  if (a1[v21] != v9) {
    a1[v21] = v9;
  }
  if (v19) {
    uint64_t v22 = v19;
  }
  else {
    uint64_t v22 = 0;
  }
  int v23 = *(_DWORD *)(v22 + 24);
  unsigned int v24 = a3;
  if (v23)
  {
    if (v9 < 4)
    {
      unsigned int v24 = ((v23 + ~(-1 << (8 * v9))) >> (8 * v9)) + a3;
      if (v24 < 2) {
        goto LABEL_23;
      }
      goto LABEL_25;
    }
    unsigned int v24 = a3 + 1;
  }
  if (v24 < 2)
  {
LABEL_23:
    uint64_t v25 = 0;
    goto LABEL_29;
  }
LABEL_25:
  if (v24 >= 0x100)
  {
    uint64_t v25 = 4;
    if (v24 < 0x10000) {
      uint64_t v25 = 2;
    }
  }
  else
  {
    uint64_t v25 = 1;
  }
LABEL_29:
  if (*(a1 - 1)) {
    uint64_t v26 = *(a1 - 1);
  }
  else {
    uint64_t v26 = 0;
  }
  uint64_t v55 = v25;
  long long v51 = a1;
  unsigned int v52 = v25 + v9;
  unsigned int v50 = v24;
  if ((a2 & 0x100) == 0)
  {
    Metadata = swift::allocateMetadata(0x70uLL, 8);
    uint64_t v28 = swift::TargetEnumValueWitnessTable<swift::InProcess>::TargetEnumValueWitnessTable((uint64_t)Metadata, v26);
    *(a1 - 1) = v28;
    uint64_t v26 = v28;
  }
  uint64_t v29 = a3;
  uint64_t v30 = 8 * a3 + 56;
  LOWORD(v56) = 26;
  uint64_t v31 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v56, (v30 + v8 + 15) & 0xFFFFFFFFFFFFFFF8, 1);
  unint64_t v32 = v31;
  v31[1] = v30 + v8 - 16;
  v31[2] = 0x1600000000000000;
  int v33 = v55;
  v31[3] = v55;
  v31[4] = a3;
  unint64_t v34 = v52;
  v31[5] = v8;
  v31[6] = v52;
  uint64_t v60 = 0;
  *(void *)&long long v56 = v31;
  *((void *)&v56 + 1) = v30;
  if (a3)
  {
    uint64_t v35 = 0;
    uint64_t v36 = v31 + 7;
    do
    {
      uint64_t v37 = v30;
      uint64_t v38 = *v4++;
      *v36++ = v35;
      unint64_t v58 = 0;
      unint64_t v59 = 0;
      _swift_addRefCountStringForMetatype((uint64_t)&v56, &v60, v38, &v58, &v59);
      *(void *)(v56 + *((void *)&v56 + 1)) = 0;
      uint64_t v30 = *((void *)&v56 + 1) + 8;
      *((void *)&v56 + 1) = v30;
      uint64_t v35 = v35 - v37 + v30;
      --v29;
    }
    while (v29);
    int v33 = v55;
    uint64_t v39 = (void *)v56;
    uint64_t v40 = v51;
    unint64_t v34 = v52;
  }
  else
  {
    uint64_t v39 = v31;
    uint64_t v40 = v51;
  }
  *(void *)((char *)v39 + v3swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
  *((void *)&v56 + 1) = 0;
  *(void *)long long v56 = v60 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v41 = *v40;
  if ((unint64_t)*v40 > 0x7FF) {
    LODWORD(v41) = 0;
  }
  if (!v41 || v41 == 773 || v41 == 515) {
    uint64_t v42 = v40 - 3;
  }
  else {
    uint64_t v42 = v40 - 2;
  }
  *uint64_t v42 = (uint64_t)v32;
  unsigned int v43 = (1 << (8 * v33)) - v50;
  if (v43 >= 0x7FFFFFFF) {
    unsigned int v43 = 0x7FFFFFFF;
  }
  if (v33 == 4) {
    unsigned int v43 = 0x7FFFFFFF;
  }
  *(void *)(v26 + 8) = swift_generic_destroy;
  *(void *)(v26 + 16) = swift_generic_initWithCopy;
  *(void *)(v26 + 32) = swift_generic_initWithTake;
  *(void *)(v26 + 24) = swift_generic_assignWithCopy;
  *(void *)(v26 + 4swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = swift_generic_assignWithTake;
  unint64_t v44 = (v34 + v7) & ~v7;
  if (v44 <= 1) {
    unint64_t v44 = 1;
  }
  BOOL v46 = v7 < 8 && v34 < 0x19;
  if ((v12 & v46) != 0) {
    int v47 = 0;
  }
  else {
    int v47 = 0x20000;
  }
  if (v12) {
    int v48 = 0x200000;
  }
  else {
    int v48 = 3145728;
  }
  *(void *)&long long v56 = v34;
  *((void *)&v56 + 1) = v44;
  LODWORD(v57) = v48 | v53 | v7 & 0xFFCCFFFF | v47;
  HIDWORD(v57) = v43;
  swift::installCommonValueWitnesses((uint64_t)&v56, (void **)v26);
  *(void *)(v26 + 48) = swift_getMultiPayloadEnumTagSinglePayload;
  *(void *)(v26 + 56) = swift_storeMultiPayloadEnumTagSinglePayload;
  *(_OWORD *)(v26 + 64) = v56;
  double result = v57;
  *(double *)(v26 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v57;
  return result;
}

void storeMultiPayloadExtraInhabitantTag(uint64_t a1, size_t a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)(a4 + 8)) {
    uint64_t v4 = *(void *)(a4 + 8);
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t v5 = *(void *)(a4 + (((unint64_t)*(unsigned int *)(v4 + 20) >> 21) & 0x7F8));
  int v6 = -(int)a2;
  unint64_t v7 = (unsigned char *)(a1 + v5);
  switch(*(void *)(*(void *)(a4 - 8) + 64) - v5)
  {
    case 0:
      return;
    case 1:
      unsigned char *v7 = v6;
      break;
    case 2:
      *(_WORD *)unint64_t v7 = v6;
      break;
    case 3:
      *(_WORD *)unint64_t v7 = v6;
      void v7[2] = BYTE2(v6);
      break;
    case 4:
      *(_DWORD *)unint64_t v7 = v6;
      break;
    default:
      *(_DWORD *)unint64_t v7 = v6;
      bzero(v7 + 4, a2);
      break;
  }
}

void swift_storeEnumTagMultiPayload(unsigned char *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    uint64_t v5 = *(void *)(a2 + 8);
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = *(void *)(a2 + (((unint64_t)*(unsigned int *)(v5 + 20) >> 21) & 0x7F8));
  uint64_t v8 = *(void *)(a2 - 8);
  size_t v7 = a2 - 8;
  unint64_t v9 = *(void *)(v8 + 64) - v6;
  if (v4) {
    uint64_t v10 = v4;
  }
  else {
    uint64_t v10 = 0;
  }
  unsigned int v11 = *(_DWORD *)(v10 + 20) & 0xFFFFFF;
  unsigned int v12 = a3 - v11;
  if (a3 >= v11)
  {
    if (v6 <= 3) {
      int v14 = v12 & ~(-1 << (8 * v6));
    }
    else {
      int v14 = a3 - v11;
    }
    if (v6 <= 3) {
      v11 += v12 >> (8 * v6);
    }
    int v15 = &a1[v6];
    switch(v9)
    {
      case 0uLL:
        goto LABEL_27;
      case 1uLL:
        unsigned char *v15 = v11;
        size_t v7 = v6 - 4;
        if (v6 > 4) {
          goto LABEL_30;
        }
        goto LABEL_27;
      case 2uLL:
        *(_WORD *)int v15 = v11;
        size_t v7 = v6 - 4;
        if (v6 > 4) {
          goto LABEL_30;
        }
        goto LABEL_27;
      case 3uLL:
        *(_WORD *)int v15 = v11;
        v15[2] = BYTE2(v11);
        goto LABEL_27;
      case 4uLL:
        *(_DWORD *)int v15 = v11;
        size_t v7 = v6 - 4;
        if (v6 > 4) {
          goto LABEL_30;
        }
        goto LABEL_27;
      default:
        *(_DWORD *)int v15 = v11;
        bzero(v15 + 4, v7);
        size_t v7 = v6 - 4;
        if (v6 <= 4)
        {
LABEL_27:
          switch(v6)
          {
            case 0uLL:
              return;
            case 1uLL:
              *a1 = v14;
              break;
            case 2uLL:
              *(_WORD *)a1 = v14;
              break;
            case 3uLL:
              *(_WORD *)a1 = v14;
              a1[2] = BYTE2(v14);
              break;
            case 4uLL:
              *(_DWORD *)a1 = v14;
              break;
            default:
              goto LABEL_30;
          }
        }
        else
        {
LABEL_30:
          *(_DWORD *)a1 = v14;
          uint64_t v16 = a1 + 4;
LABEL_31:
          bzero(v16, v7);
        }
        break;
    }
  }
  else
  {
    uint64_t v13 = &a1[v6];
    switch(v9)
    {
      case 0uLL:
        return;
      case 1uLL:
        *uint64_t v13 = a3;
        break;
      case 2uLL:
        *(_WORD *)uint64_t v13 = a3;
        break;
      case 3uLL:
        *(_WORD *)uint64_t v13 = a3;
        v13[2] = BYTE2(a3);
        break;
      case 4uLL:
        *(_DWORD *)uint64_t v13 = a3;
        break;
      default:
        *(_DWORD *)uint64_t v13 = a3;
        uint64_t v16 = v13 + 4;
        goto LABEL_31;
    }
  }
}

uint64_t swift_getEnumCaseMultiPayload(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2) {
    uint64_t v3 = *(void *)(a2 + 8);
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(void *)(a2 + (((unint64_t)*(unsigned int *)(v3 + 20) >> 21) & 0x7F8));
  if (v2) {
    uint64_t v5 = *(void *)(a2 + 8);
  }
  else {
    uint64_t v5 = 0;
  }
  unsigned int v6 = *(_DWORD *)(v5 + 20) & 0xFFFFFF;
  uint64_t v7 = 0;
  switch(*(void *)(*(void *)(a2 - 8) + 64) - v4)
  {
    case 0:
      goto LABEL_13;
    case 1:
      uint64_t v7 = a1[v4];
      int v8 = v7 - v6;
      if (v7 < v6) {
        return v7;
      }
      goto LABEL_14;
    case 2:
      uint64_t v7 = *(unsigned __int16 *)&a1[v4];
LABEL_13:
      int v8 = v7 - v6;
      if (v7 >= v6) {
        goto LABEL_14;
      }
      return v7;
    case 3:
      uint64_t v7 = *(unsigned __int16 *)&a1[v4] | (a1[v4 + 2] << 16);
      int v8 = v7 - v6;
      if (v7 < v6) {
        return v7;
      }
      goto LABEL_14;
    default:
      uint64_t v7 = *(unsigned int *)&a1[v4];
      int v8 = v7 - v6;
      if (v7 < v6) {
        return v7;
      }
LABEL_14:
      int v9 = 0;
      switch(v4)
      {
        case 0:
          goto LABEL_21;
        case 1:
          int v9 = *a1;
          goto LABEL_21;
        case 2:
          int v9 = *(unsigned __int16 *)a1;
          goto LABEL_21;
        case 3:
          int v9 = *(unsigned __int16 *)a1 | (a1[2] << 16);
LABEL_21:
          int v11 = v9 | (v8 << (8 * v4));
          break;
        default:
          int v11 = *(_DWORD *)a1;
          break;
      }
      return v11 + v6;
  }
}

uint64_t swift::TargetEnumValueWitnessTable<swift::InProcess>::TargetEnumValueWitnessTable(uint64_t result, uint64_t a2)
{
  *(void *)double result = *(void *)a2;
  *(void *)(result + 8) = *(void *)(a2 + 8);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 4swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = *(void *)(a2 + 56);
  long long v2 = *(_OWORD *)(a2 + 64);
  *(void *)(result + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = *(void *)(a2 + 80);
  *(_OWORD *)(result + 64) = v2;
  *(void *)(result + 88) = *(void *)(a2 + 88);
  *(void *)(result + 96) = *(void *)(a2 + 96);
  *(void *)(result + 104) = *(void *)(a2 + 104);
  return result;
}

void swift::runtime::environment::initialize(swift::runtime::environment *this, void *a2)
{
  long long v2 = (char **)*MEMORY[0x1E4F147F0];
  uint64_t v3 = *(char **)*MEMORY[0x1E4F147F0];
  if (!v3) {
    return;
  }
  unsigned __int8 v115 = 0;
  do
  {
    if (strncmp(v3, "SWIFT_", 6uLL)) {
      goto LABEL_6;
    }
    int v10 = strncmp(v3, "SWIFT_DEBUG_HELP=", 0x11uLL);
    BOOL v12 = v10 == 0;
    if (!v10)
    {
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_ENABLE_METADATA_ALLOCATION_ITERATION=", 0x31uLL))
    {
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_ENABLE_METADATA_ALLOCATION_ITERATION_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_ENABLE_METADATA_BACKTRACE_LOGGING=", 0x2EuLL))
    {
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_ENABLE_METADATA_BACKTRACE_LOGGING_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_IMPLICIT_OBJC_ENTRYPOINT=", 0x25uLL))
    {
      int v15 = v3 + 37;
      __endptr = 0;
      unint64_t v16 = strtol(v15, &__endptr, 0);
      if (*__endptr)
      {
        char v19 = 2;
        swift::warning(0, "Warning: cannot parse value %s=%s, defaulting to %u.\n", v17, v18, "SWIFT_DEBUG_IMPLICIT_OBJC_ENTRYPOINT", v15, 2);
      }
      else if ((v16 & 0x8000000000000000) != 0)
      {
        swift::warning(0, "Warning: %s=%s out of bounds, clamping to 0.\n", v17, v18, "SWIFT_DEBUG_IMPLICIT_OBJC_ENTRYPOINT", v15);
        char v19 = 0;
      }
      else if (v16 < 0x100)
      {
        char v19 = v16;
      }
      else
      {
        char v19 = -1;
        swift::warning(0, "Warning: %s=%s out of bounds, clamping to %d.\n", v17, v18, "SWIFT_DEBUG_IMPLICIT_OBJC_ENTRYPOINT", v15, 255);
      }
      swift::runtime::environment::SWIFT_DEBUG_IMPLICIT_OBJC_ENTRYPOINT_variable = v19;
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_IMPLICIT_OBJC_ENTRYPOINT_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DETERMINISTIC_HASHING=", 0x1CuLL))
    {
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DETERMINISTIC_HASHING_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_ENABLE_MANGLED_NAME_VERIFICATION=", 0x27uLL))
    {
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_ENABLE_MANGLED_NAME_VERIFICATION_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_ENABLE_MALLOC_SCRIBBLE=", 0x23uLL))
    {
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_ENABLE_MALLOC_SCRIBBLE_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_ENABLE_COW_CHECKS=", 0x1EuLL))
    {
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_ENABLE_COW_CHECKS_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_ENABLE_ASYNC_JOB_DISPATCH_INTEGRATION=", 0x2CuLL))
    {
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_ENABLE_ASYNC_JOB_DISPATCH_INTEGRATION_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_VALIDATE_UNCHECKED_CONTINUATIONS=", 0x2DuLL))
    {
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_VALIDATE_UNCHECKED_CONTINUATIONS_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_VALIDATE_SHARED_CACHE_PROTOCOL_CONFORMANCES=", 0x38uLL))
    {
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_VALIDATE_SHARED_CACHE_PROTOCOL_CONFORMANCES_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_ENABLE_SHARED_CACHE_PROTOCOL_CONFORMANCES=", 0x36uLL))
    {
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_ENABLE_SHARED_CACHE_PROTOCOL_CONFORMANCES_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_CONCURRENCY_ENABLE_COOPERATIVE_QUEUES=", 0x32uLL))
    {
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_CONCURRENCY_ENABLE_COOPERATIVE_QUEUES_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_BINARY_COMPATIBILITY_VERSION=", 0x23uLL))
    {
      uint64_t v29 = v3 + 35;
      __endptr = 0;
      unint64_t v30 = strtoll(v29, &__endptr, 0);
      if (*__endptr)
      {
        swift::warning(0, "Warning: cannot parse value %s=%s, defaulting to %u.\n", v31, v32, "SWIFT_BINARY_COMPATIBILITY_VERSION", v29, 0);
      }
      else
      {
        if ((v30 & 0x8000000000000000) == 0)
        {
          if (HIDWORD(v30))
          {
            int v33 = -1;
            swift::warning(0, "Warning: %s=%s out of bounds, clamping to %u.\n", v31, v32, "SWIFT_BINARY_COMPATIBILITY_VERSION", v29, 0xFFFFFFFFLL);
          }
          else
          {
            int v33 = v30;
          }
          goto LABEL_40;
        }
        swift::warning(0, "Warning: %s=%s out of bounds, clamping to 0.\n", v31, v32, "SWIFT_BINARY_COMPATIBILITY_VERSION", v29, v114);
      }
      int v33 = 0;
LABEL_40:
      swift::runtime::environment::SWIFT_BINARY_COMPATIBILITY_VERSION_variable = v33;
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_BINARY_COMPATIBILITY_VERSION_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_FAILED_TYPE_LOOKUP=", 0x1FuLL))
    {
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_FAILED_TYPE_LOOKUP_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_VALIDATE_EXTERNAL_GENERIC_METADATA_BUILDER=", 0x37uLL))
    {
      uint64_t v35 = v3 + 55;
      __endptr = 0;
      unint64_t v36 = strtol(v35, &__endptr, 0);
      if (*__endptr)
      {
        uint64_t v114 = 0;
        swift::warning(0, "Warning: cannot parse value %s=%s, defaulting to %u.\n", v37, v38, "SWIFT_DEBUG_VALIDATE_EXTERNAL_GENERIC_METADATA_BUILDER", v35);
      }
      else
      {
        if ((v36 & 0x8000000000000000) == 0)
        {
          if (v36 < 0x100)
          {
            char v39 = v36;
          }
          else
          {
            char v39 = -1;
            swift::warning(0, "Warning: %s=%s out of bounds, clamping to %d.\n", v37, v38, "SWIFT_DEBUG_VALIDATE_EXTERNAL_GENERIC_METADATA_BUILDER", v35, 255);
          }
          goto LABEL_47;
        }
        swift::warning(0, "Warning: %s=%s out of bounds, clamping to 0.\n", v37, v38, "SWIFT_DEBUG_VALIDATE_EXTERNAL_GENERIC_METADATA_BUILDER", v35);
      }
      char v39 = 0;
LABEL_47:
      swift::runtime::environment::SWIFT_DEBUG_VALIDATE_EXTERNAL_GENERIC_METADATA_BUILDER_variable = v39;
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_VALIDATE_EXTERNAL_GENERIC_METADATA_BUILDER_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_ENABLE_LIB_PRESPECIALIZED_METADATA=", 0x2FuLL))
    {
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_ENABLE_LIB_PRESPECIALIZED_METADATA_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_ENABLE_LIB_PRESPECIALIZED_DESCRIPTOR_LOOKUP=", 0x38uLL))
    {
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_ENABLE_LIB_PRESPECIALIZED_DESCRIPTOR_LOOKUP_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_VALIDATE_LIB_PRESPECIALIZED_DESCRIPTOR_LOOKUP=", 0x3AuLL))
    {
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_VALIDATE_LIB_PRESPECIALIZED_DESCRIPTOR_LOOKUP_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_LIB_PRESPECIALIZED_PATH=", 0x24uLL))
    {
      int v44 = v3[36];
      unsigned int v43 = v3 + 36;
      if (v44) {
        uint64_t v45 = v43;
      }
      else {
        uint64_t v45 = "";
      }
      swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_PATH_variable = strdup(v45);
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_PATH_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_LIB_PRESPECIALIZED_DISABLED_PROCESSES=", 0x32uLL))
    {
      int v47 = v3[50];
      BOOL v46 = v3 + 50;
      if (v47) {
        int v48 = v46;
      }
      else {
        int v48 = "";
      }
      swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_DISABLED_PROCESSES_variable = strdup(v48);
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_DISABLED_PROCESSES_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_LIB_PRESPECIALIZED_ENABLED_PROCESSES=", 0x31uLL))
    {
      int v50 = v3[49];
      int v49 = v3 + 49;
      if (v50) {
        long long v51 = v49;
      }
      else {
        long long v51 = "";
      }
      swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_ENABLED_PROCESSES_variable = strdup(v51);
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_ENABLED_PROCESSES_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_DEBUG_ENABLE_LIB_PRESPECIALIZED_LOGGING=", 0x2EuLL))
    {
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_DEBUG_ENABLE_LIB_PRESPECIALIZED_LOGGING_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_ROOT=", 0xBuLL))
    {
      int v54 = v3[11];
      int v53 = v3 + 11;
      if (v54) {
        uint64_t v55 = v53;
      }
      else {
        uint64_t v55 = "";
      }
      swift::runtime::environment::SWIFT_ROOT_variable = strdup(v55);
      BOOL v12 = 1;
      swift::runtime::environment::SWIFT_ROOT_isSet_variable = 1;
      uint64_t v3 = *v2;
    }
    if (!strncmp(v3, "SWIFT_BACKTRACE=", 0x10uLL))
    {
      int v60 = v3[16];
      unint64_t v59 = v3 + 16;
      if (v60) {
        uint64_t v61 = v59;
      }
      else {
        uint64_t v61 = "";
      }
      swift::runtime::environment::SWIFT_BACKTRACE_variable = strdup(v61);
      swift::runtime::environment::SWIFT_BACKTRACE_isSet_variable = 1;
      uint64_t v3 = *v2;
      if (!strncmp(*v2, "SWIFT_IS_CURRENT_EXECUTOR_LEGACY_MODE_OVERRIDE=", 0x2FuLL))
      {
LABEL_3:
        int v5 = v3[47];
        uint64_t v4 = v3 + 47;
        if (v5) {
          unsigned int v6 = v4;
        }
        else {
          unsigned int v6 = "";
        }
        swift::runtime::environment::SWIFT_IS_CURRENT_EXECUTOR_LEGACY_MODE_OVERRIDE_variable = (uint64_t)strdup(v6);
        swift::runtime::environment::SWIFT_IS_CURRENT_EXECUTOR_LEGACY_MODE_OVERRIDE_isSet_variable = 1;
      }
    }
    else
    {
      if (!strncmp(v3, "SWIFT_IS_CURRENT_EXECUTOR_LEGACY_MODE_OVERRIDE=", 0x2FuLL)) {
        goto LABEL_3;
      }
      if (!v12 && !strncmp(v3, "SWIFT_DEBUG_", 0xCuLL))
      {
        long long v56 = strchr(v3, 61);
        if (!v56) {
          long long v56 = &v3[strlen(v3)];
        }
        swift::warning(0, "Warning: unknown environment variable %.*s\n", v57, v58, v56 - v3, v3);
      }
    }
LABEL_6:
    int v9 = v2[1];
    ++v2;
    uint64_t v3 = v9;
  }
  while (v9);
  if (v115)
  {
    swift::warning(0, "Swift runtime debugging:\n", v7, v8);
    swift::warning(0, "%7s %s [default: %s] - %s\n", v62, v63, "BOOL", "SWIFT_DEBUG_ENABLE_METADATA_ALLOCATION_ITERATION", "false", "Enable additional metadata allocation tracking for swift-inspect to use.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v64, v65, "BOOL", "SWIFT_DEBUG_ENABLE_METADATA_BACKTRACE_LOGGING", "false", "Enable logging of backtraces for each metadata allocation. Requires SWIFT_DEBUG_ENABLE_METADATA_ALLOCATION_ITERATION to be enabled.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v66, v67, "uint8_t", "SWIFT_DEBUG_IMPLICIT_OBJC_ENTRYPOINT", "2", "Print warnings when using implicit @objc entrypoints. Set to desired reporting level, 0-3.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v68, v69, "BOOL", "SWIFT_DETERMINISTIC_HASHING", "false", "Disable randomized hash seeding.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v70, v71, "BOOL", "SWIFT_ENABLE_MANGLED_NAME_VERIFICATION", "false", "Enable verification that metadata can roundtrip through a mangled name each time metadata is instantiated.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v72, v73, "BOOL", "SWIFT_DEBUG_ENABLE_MALLOC_SCRIBBLE", "false", "Scribble on runtime allocations such as metadata allocations.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v74, v75, "BOOL", "SWIFT_DEBUG_ENABLE_COW_CHECKS", "false", "Enable internal checks for copy-on-write operations.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v76, v77, "BOOL", "SWIFT_ENABLE_ASYNC_JOB_DISPATCH_INTEGRATION", "true", "Enable use of dispatch_async_swift_job when available.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v78, v79, "BOOL", "SWIFT_DEBUG_VALIDATE_UNCHECKED_CONTINUATIONS", "false", "Check for and error on double-calls of unchecked continuations.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v80, v81, "BOOL", "SWIFT_DEBUG_VALIDATE_SHARED_CACHE_PROTOCOL_CONFORMANCES", "false", "Validate shared cache protocol conformance results against the lists of conformances in the shared cache images.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v82, v83, "BOOL", "SWIFT_DEBUG_ENABLE_SHARED_CACHE_PROTOCOL_CONFORMANCES", "true", "Enable querying precomputed protocol conformances in the shared cache.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v84, v85, "BOOL", "SWIFT_DEBUG_CONCURRENCY_ENABLE_COOPERATIVE_QUEUES", "true", "Enable dispatch cooperative queues in the global executor.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v86, v87, "uint32_t", "SWIFT_BINARY_COMPATIBILITY_VERSION", "0", "Set the binary compatibility level of the Swift Standard Library");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v88, v89, "BOOL", "SWIFT_DEBUG_FAILED_TYPE_LOOKUP", "false", "Enable warnings when we fail to look up a type by name.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v90, v91, "uint8_t", "SWIFT_DEBUG_VALIDATE_EXTERNAL_GENERIC_METADATA_BUILDER", "0", "Validate the external metadata builder by running it in parallel with the runtime's builder, and checking that they produce the same output. Level 0 does no validation. Level 1 does silent validation unless a validation failure occurs. Level 2 enables full debug logging in the builder.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v92, v93, "BOOL", "SWIFT_DEBUG_ENABLE_LIB_PRESPECIALIZED_METADATA", "true", "Enable use of metadata in prespecializations library.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v94, v95, "BOOL", "SWIFT_DEBUG_ENABLE_LIB_PRESPECIALIZED_DESCRIPTOR_LOOKUP", "true", "Enable use of descriptor map in prespecializations library.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v96, v97, "BOOL", "SWIFT_DEBUG_VALIDATE_LIB_PRESPECIALIZED_DESCRIPTOR_LOOKUP", "false", "Validate results from the prespecializations map descriptor map by comparing to a full scan.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v98, v99, "string", "SWIFT_DEBUG_LIB_PRESPECIALIZED_PATH", "\"\"", "A path to a prespecializations library to use at runtime. In order to be used, this library must be loaded into the process by other means (such as DYLD_INSERT_LIBRARIES) before Swift tries to use it.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v100, v101, "string", "SWIFT_DEBUG_LIB_PRESPECIALIZED_DISABLED_PROCESSES", "\"\"", "A colon-separated list of process names where the prespecializations library will be forcibly disabled.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v102, v103, "string", "SWIFT_DEBUG_LIB_PRESPECIALIZED_ENABLED_PROCESSES", "\"\"", "A colon-separated list of process names where the prespecializations library will be forcibly enabled. This overrides the disabled processes list in the prespecializations library, as well as the list in SWIFT_DEBUG_LIB_PRESPECIALIZED_DISABLED_PROCESSES.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v104, v105, "BOOL", "SWIFT_DEBUG_ENABLE_LIB_PRESPECIALIZED_LOGGING", "false", "Enable debug logging of prespecializations library use.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v106, v107, "string", "SWIFT_ROOT", "\"\"", "Overrides the root directory of the Swift installation. This is used to locate auxiliary files relative to the runtime itself.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v108, v109, "string", "SWIFT_BACKTRACE", "\"\"", "A comma-separated list of key=value pairs that controls the crash catching and backtracing support in the runtime. See docs/Backtracing.rst in the Swift repository for details.");
    swift::warning(0, "%7s %s [default: %s] - %s\n", v110, v111, "string", "SWIFT_IS_CURRENT_EXECUTOR_LEGACY_MODE_OVERRIDE", "\"\"", "Allows for suppressing 'is current executor' equality check crashes. As since Swift 6.0 checking for current executor equality, may crash and will never return 'false' because we are calling into library implemented SerialExecutor.checkIsolation which should crash if the isolation is not the expected one. Some old code may rely on the non-crashing behavior. This flag enables temporarily restoring the legacy 'nocrash' behavior until adopting code has been adjusted. Legal values are:  'legacy' (Legacy behavior),  'swift6' (Swift 6.0+ behavior)");
    swift::warning(0, "SWIFT_DEBUG_HELP=YES - Print this help.", v112, v113);
  }
}

const char *anonymous namespace'::parse_BOOL(_anonymous_namespace_ *this, const char *a2, const char *a3, char *a4)
{
  if (!a2) {
    return a3;
  }
  uint64_t v5 = 1;
  switch(*a2)
  {
    case '0':
    case 'F':
    case 'N':
    case 'f':
    case 'n':
      uint64_t v5 = 0;
      break;
    case '1':
    case 'T':
    case 'Y':
    case 't':
    case 'y':
      return (const char *)v5;
    default:
      unsigned int v6 = "false";
      if (a3) {
        unsigned int v6 = "true";
      }
      swift::warning(0, "Warning: cannot parse value %s=%s, defaulting to %s.\n", a3, a4, this, a2, v6);
      return a3;
  }
  return (const char *)v5;
}

uint64_t swift_COWChecksEnabled()
{
  if (swift::runtime::environment::initializeToken != -1) {
    dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
  }
  return swift::runtime::environment::SWIFT_DEBUG_ENABLE_COW_CHECKS_variable;
}

uint64_t concurrencyEnableCooperativeQueues()
{
  if (swift::runtime::environment::initializeToken != -1) {
    dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
  }
  return swift::runtime::environment::SWIFT_DEBUG_CONCURRENCY_ENABLE_COOPERATIVE_QUEUES_variable;
}

uint64_t concurrencyEnableJobDispatchIntegration()
{
  if (swift::runtime::environment::initializeToken != -1) {
    dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
  }
  return swift::runtime::environment::SWIFT_ENABLE_ASYNC_JOB_DISPATCH_INTEGRATION_variable;
}

uint64_t concurrencyValidateUncheckedContinuations()
{
  if (swift::runtime::environment::initializeToken != -1) {
    dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
  }
  return swift::runtime::environment::SWIFT_DEBUG_VALIDATE_UNCHECKED_CONTINUATIONS_variable;
}

uint64_t concurrencyIsCurrentExecutorLegacyModeOverride()
{
  if (swift::runtime::environment::initializeToken != -1) {
    dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
  }
  return swift::runtime::environment::SWIFT_IS_CURRENT_EXECUTOR_LEGACY_MODE_OVERRIDE_variable;
}

unint64_t _swift_setWillThrowHandler(unint64_t result)
{
  return result;
}

uint64_t swift_willThrow()
{
  unint64_t explicit = (uint64_t (*)(uint64_t))atomic_load_explicit((atomic_ullong *volatile)&_swift_willThrow, memory_order_acquire);
  if (explicit) {
    return explicit(v0);
  }
  return result;
}

void swift_willThrowTypedImpl(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t explicit = (void (*)(void))atomic_load_explicit(&_swift_willThrowTypedImpl, memory_order_acquire);
  if (explicit)
  {
    explicit();
  }
  else
  {
    uint64_t v4 = (void (*)(void))atomic_load_explicit((atomic_ullong *volatile)&_swift_willThrow, memory_order_acquire);
    if (v4)
    {
      uint64_t v5 = swift_allocError(a2, a3, a1, 0);
      v4();
      swift_errorRelease(v5);
    }
  }
}

void swift::dumpStackTraceEntry(swift *this, swift::SymbolInfo *a2, void *a3)
{
  int v3 = (int)a3;
  int v5 = (int)this;
  swift::SymbolInfo::lookup(a2, (uint64_t)v20);
  if (v21)
  {
    Filename = (const char *)swift::SymbolInfo::getFilename((swift::SymbolInfo *)v20);
    uint64_t v7 = Filename;
    if (Filename) {
      Filename = (const char *)strlen(Filename);
    }
    int v8 = Filename;
    do
    {
      if (!v8) {
        break;
      }
      int v9 = (v8--)[(void)(v7 - 1)];
    }
    while (v9 != 47);
    memset(&__p, 0, sizeof(__p));
    if (v21)
    {
      if (_ContiguousArrayBuffer.mutableCount.getter((uint64_t)v20))
      {
        swift::SymbolInfo::getSymbolAddress((swift::SymbolInfo *)v20);
        int status = 0;
        int v10 = (const char *)_ContiguousArrayBuffer.mutableCount.getter((uint64_t)v20);
        int v11 = __cxa_demangle(v10, 0, 0, &status);
        if (status)
        {
          BOOL v12 = (swift::Demangle::__runtime *)_ContiguousArrayBuffer.mutableCount.getter((uint64_t)v20);
          uint64_t v13 = (const char *)_ContiguousArrayBuffer.mutableCount.getter((uint64_t)v20);
          int v14 = (const char *)strlen(v13);
          v22[9] = 1;
          char v24 = 1;
          __int16 v25 = 0;
          char v26 = 1;
          uint64_t v27 = 0;
          uint64_t v28 = 0;
          v29[0] = &unk_1ECA041D0;
          v29[1] = swift::Demangle::__runtime::genericParameterName;
          v29[3] = v29;
          *(_WORD *)uint64_t v22 = 257;
          memset(&v22[2], 0, 7);
          uint64_t v23 = 0x101000001010101;
          swift::Demangle::__runtime::demangleSymbolAsString(v12, v14, (unint64_t)v22, v15);
        }
        unint64_t v16 = v11;
        std::string::append(&__p, v11);
        free(v16);
      }
      else
      {
        swift::SymbolInfo::getBaseAddress((swift::SymbolInfo *)v20);
        MEMORY[0x1852FEF20](&__p, "<unavailable>");
      }
      int v17 = (FILE *)*MEMORY[0x1E4F143C8];
      if (v3) {
      else
      }
        fprintf(v17, "%-4u %-34s 0x%0.16lx %s + %td\n");
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      std::__throw_bad_optional_access[abi:nn180100]();
      swift::withCurrentBacktrace(v18);
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "%-4u %-34s 0x%0.16tx\n", v5, "<unknown>", (ptrdiff_t)a2);
  }
}

uint64_t swift::withCurrentBacktrace(void *a1)
{
  unint64_t v1 = (void *)a1[3];
  if (v1)
  {
    if (v1 == a1)
    {
      unsigned int v6 = v5;
      (*(void (**)(void *, void *))(*a1 + 24))(a1, v5);
    }
    else
    {
      unsigned int v6 = (void *)(*(uint64_t (**)(void))(*v1 + 16))(a1[3]);
    }
  }
  else
  {
    unsigned int v6 = 0;
  }
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  *(_OWORD *)uint64_t v7 = 0u;
  long long v8 = 0u;
  int v2 = backtrace(v7, 128);
  uint64_t v40 = v7;
  int v39 = v2;
  if (v6)
  {
    (*(void (**)(void *, void ***, int *))(*v6 + 48))(v6, &v40, &v39);
    if (v6 == v5)
    {
      (*(void (**)(void *))(v5[0] + 32))(v5);
    }
    else if (v6)
    {
      (*(void (**)(void))(*v6 + 40))();
    }
    return 1;
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    return (uint64_t)swift::printCurrentBacktrace(v4);
  }
}

void *swift::printCurrentBacktrace(swift *this)
{
  int v5 = (int)this;
  v3[0] = &unk_1ECA04360;
  v3[1] = &v5;
  uint64_t v4 = v3;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  *(_OWORD *)unsigned int v6 = 0u;
  long long v7 = 0u;
  int v1 = backtrace(v6, 128);
  int v39 = v6;
  int v38 = v1;
  if (v4)
  {
    (*(void (**)(void *, void ***, int *))(*v4 + 48))(v4, &v39, &v38);
    uint64_t result = v4;
    if (v4 == v3)
    {
      return (void *)(*(uint64_t (**)(void *))(v3[0] + 32))(v3);
    }
    else if (v4)
    {
      return (void *)(*(uint64_t (**)(void))(*v4 + 40))();
    }
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    return (void *)_swift_runtime_on_report();
  }
  return result;
}

uint64_t _swift_shouldReportFatalErrorsToDebugger()
{
  return _swift_reportFatalErrorsToDebugger;
}

void swift_reportError(int a1, char *a2)
{
  int v3 = (FILE **)MEMORY[0x1E4F143C8];
  fputs(a2, (FILE *)*MEMORY[0x1E4F143C8]);
  fflush(*v3);
  asl_log(0, 0, 3, "%s", a2);
  long long v8 = 0;
  uint64_t v5 = qword_1E8EBFEB0[0];
  while (1)
  {
    if (v5)
    {
      swift_asprintf(&v8, v4, v5, a2);
      unsigned int v6 = v8;
    }
    else
    {
      unsigned int v6 = strdup(a2);
      long long v8 = v6;
    }
    uint64_t v7 = v5;
    atomic_compare_exchange_strong_explicit(qword_1E8EBFEB0, (unint64_t *)&v7, (unint64_t)v6, memory_order_release, memory_order_relaxed);
    if (v7 == v5) {
      break;
    }
    uint64_t v5 = v7;
    if (v8)
    {
      free(v8);
      long long v8 = 0;
    }
  }
}

void swift::fatalErrorv(swift *this, char *__format, va_list a3, char *a4)
{
  LODWORD(v5) = vsnprintf(0, 0, __format, a3);
  unsigned int v6 = 0;
  if ((v5 & 0x80000000) == 0)
  {
    size_t v7 = (v5 + 1);
    uint64_t v5 = (char *)malloc_type_malloc(v7, 0x887381A9uLL);
    unsigned int v6 = v5;
    if (v5)
    {
      LODWORD(v5) = vsnprintf(v5, v7, __format, a3);
      if ((v5 & 0x80000000) != 0)
      {
        free(v6);
        unsigned int v6 = 0;
      }
    }
  }
  swift_reportError((int)v5, (char *)v6);
  abort();
}

void swift::fatalError(swift *this, char *a2, const char *a3, char *a4, ...)
{
  va_start(va, a4);
  swift::fatalErrorv(this, a2, va, a4);
}

void swift::warningv(swift *this, char *__format, va_list a3, char *a4)
{
  char v5 = (char)this;
  int v6 = vsnprintf(0, 0, __format, a3);
  if (v6 < 0) {
    goto LABEL_5;
  }
  size_t v7 = (v6 + 1);
  long long v8 = (char *)malloc_type_malloc(v7, 0x887381A9uLL);
  long long v9 = v8;
  if (v8 && vsnprintf(v8, v7, __format, a3) < 0)
  {
    free(v9);
LABEL_5:
    long long v9 = 0;
  }
  long long v10 = (FILE **)MEMORY[0x1E4F143C8];
  fputs(v9, (FILE *)*MEMORY[0x1E4F143C8]);
  fflush(*v10);
  asl_log(0, 0, 3, "%s", v9);
  if (v5)
  {
    fputs("Current stack trace:\n", *v10);
    swift::printCurrentBacktrace((swift *)1);
  }
  free(v9);
}

void swift::warning(swift *this, char *a2, const char *a3, char *a4, ...)
{
  va_start(va, a4);
  swift::warningv(this, a2, va, a4);
}

void swift_reportWarning(swift *a1, uint64_t a2, const char *a3, char *a4)
{
}

void swift_deletedMethodError(swift *a1, uint64_t a2, const char *a3, char *a4)
{
}

void swift::swift_abortRetainOverflow(swift *this, uint64_t a2, const char *a3, char *a4)
{
}

void swift::swift_abortUnownedRetainOverflow(swift *this, uint64_t a2, const char *a3, char *a4)
{
}

void swift::swift_abortWeakRetainOverflow(swift *this, uint64_t a2, const char *a3, char *a4)
{
}

void swift::swift_abortRetainUnowned(swift *this, const void *a2, const char *a3, char *a4)
{
  if (!this) {
    swift::fatalError(0, "Fatal error: Attempted to read an unowned reference but the object was already deallocated", a3, a4);
  }
  swift::fatalError(this, "Fatal error: Attempted to read an unowned reference but object %p was already deallocated", a3, a4, this);
}

void swift::swift_abortDynamicReplacementDisabling(swift *this, uint64_t a2, const char *a3, char *a4)
{
}

void std::__throw_bad_optional_access[abi:nn180100]()
{
  std::__libcpp_verbose_abort("bad_optional_access was thrown in -fno-exceptions mode");
  swift_asprintf(v0, v1);
}

void swift_asprintf(char **a1, const char *a2, ...)
{
  va_start(va, a2);
  int v3 = vsnprintf(0, 0, "%s%s", va);
  *a1 = 0;
  if ((v3 & 0x80000000) == 0)
  {
    size_t v4 = (v3 + 1);
    char v5 = (char *)malloc_type_malloc(v4, 0x887381A9uLL);
    if (v5)
    {
      int v6 = v5;
      if (vsnprintf(v5, v4, "%s%s", va) < 0) {
        free(v6);
      }
      else {
        *a1 = v6;
      }
    }
  }
}

{
  int v3;
  size_t v4;
  char *v5;
  char *v6;
  va_list va;

  va_start(va, a2);
  int v3 = vsnprintf(0, 0, ".%ld", va);
  *a1 = 0;
  if ((v3 & 0x80000000) == 0)
  {
    size_t v4 = (v3 + 1);
    char v5 = (char *)malloc_type_malloc(v4, 0x887381A9uLL);
    if (v5)
    {
      int v6 = v5;
      if (vsnprintf(v5, v4, ".%ld", va) < 0) {
        free(v6);
      }
      else {
        *a1 = v6;
      }
    }
  }
}

{
  int v3;
  size_t v4;
  char *v5;
  char *v6;
  va_list va;

  va_start(va, a2);
  int v3 = vsnprintf(0, 0, "<%s %p depth = %u>", va);
  *a1 = 0;
  if ((v3 & 0x80000000) == 0)
  {
    size_t v4 = (v3 + 1);
    char v5 = (char *)malloc_type_malloc(v4, 0x887381A9uLL);
    if (v5)
    {
      int v6 = v5;
      if (vsnprintf(v5, v4, "<%s %p depth = %u>", va) < 0) {
        free(v6);
      }
      else {
        *a1 = v6;
      }
    }
  }
}

void std::__function::__func<swift::printCurrentBacktrace(unsigned int)::$_0,std::allocator<swift::printCurrentBacktrace(unsigned int)::$_0>,void ()(void **,int)>::~__func()
{
}

void *std::__function::__func<swift::printCurrentBacktrace(unsigned int)::$_0,std::allocator<swift::printCurrentBacktrace(unsigned int)::$_0>,void ()(void **,int)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1ECA04360;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<swift::printCurrentBacktrace(unsigned int)::$_0,std::allocator<swift::printCurrentBacktrace(unsigned int)::$_0>,void ()(void **,int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ECA04360;
  a2[1] = v2;
  return result;
}

void std::__function::__func<swift::printCurrentBacktrace(unsigned int)::$_0,std::allocator<swift::printCurrentBacktrace(unsigned int)::$_0>,void ()(void **,int)>::operator()(uint64_t a1, void *a2, int *a3)
{
  int v3 = *a3;
  int v4 = **(_DWORD **)(a1 + 8);
  if (v4 < *a3)
  {
    int v6 = (swift::SymbolInfo **)(*a2 + 8 * v4);
    do
    {
      size_t v7 = *v6++;
      swift::dumpStackTraceEntry((swift *)(v4 - **(_DWORD **)(a1 + 8)), v7, 0);
      ++v4;
    }
    while (v3 != v4);
  }
}

uint64_t _swift_stdlib_getDefaultErrorCode(uint64_t a1, void *a2)
{
  if (*a2 != 513) {
    return 1;
  }
  if (*(a2 - 1)) {
    uint64_t v2 = *(a2 - 1);
  }
  else {
    uint64_t v2 = 0;
  }
  return (*(unsigned int (**)(void))(v2 + 88))();
}

void _swift_exceptionPersonality(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
}

uint64_t swift::runtime::AccessSet::insert(unint64_t *a1, void *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v5 = *a1;
  if (*a1)
  {
    int v6 = "modification";
    size_t v7 = (void *)*a1;
    do
    {
      uint64_t v8 = v7[2];
      if (*v7 == a4)
      {
        if (a5)
        {
          uint64_t v15 = a5 & 1;
          uint64_t v16 = a4;
          if ((v8 & 1) == 0) {
            int v6 = "read";
          }
LABEL_13:
          long long v26 = (swift::SymbolInfo *)v7[1];
          long long v10 = v26;
          snprintf(__str, 0x64uLL, "Simultaneous accesses to 0x%lx, but modification requires exclusive access", v16);
          long long v11 = (FILE **)MEMORY[0x1E4F143C8];
          fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s.\n", __str);
          snprintf(v24, 0x32uLL, "Previous access (a %s) started at", v6);
          fprintf(*v11, "%s ", v24);
          if (v10)
          {
            swift::dumpStackTraceEntry(0, v10, (void *)1);
            fprintf(*v11, " (0x%lx).\n", v10);
          }
          else
          {
            fwrite("<unknown>.\n", 0xBuLL, 1uLL, *v11);
          }
          long long v12 = "modification";
          if (!v15) {
            long long v12 = "read";
          }
          snprintf(v23, 0x32uLL, "Current access (a %s) started at", v12);
          fprintf(*v11, "%s:\n", v23);
          swift::printCurrentBacktrace((swift *)1);
          long long v20 = v24;
          long long v21 = xmmword_18162ACB0;
          long long v22 = &v26;
          v17[0] = 2;
          v17[1] = "exclusivity-violation";
          v17[2] = v23;
          v17[3] = 1;
          v17[4] = v16;
          v17[5] = 1;
          v17[6] = &v20;
          long long v18 = 0u;
          long long v19 = 0u;
          _swift_reportToDebugger(1, __str, v17);
          swift::fatalError(0, "Fatal access conflict detected.\n", v13, v14);
        }
        if (v8)
        {
          uint64_t v15 = a5 & 1;
          uint64_t v16 = a4;
          goto LABEL_13;
        }
      }
      size_t v7 = (void *)(v8 & 0xFFFFFFFFFFFFFFFELL);
    }
    while ((v8 & 0xFFFFFFFFFFFFFFFELL) != 0);
  }
  if ((a5 & 0x20) != 0)
  {
    *a2 = a4;
    a2[1] = a3;
    a2[2] = a5 & 1 | v5;
    *a1 = (unint64_t)a2;
  }
  return (a5 >> 5) & 1;
}

uint64_t swift_beginAccess(uint64_t result, void *a2, unint64_t a3, uint64_t a4)
{
  if (_swift_disableExclusivityChecking) {
    goto LABEL_5;
  }
  uint64_t v6 = a4;
  uint64_t v8 = result;
  if (!a4) {
    uint64_t v6 = v4;
  }
  long long v9 = swift::runtime::SwiftTLSContext::get((swift::runtime::SwiftTLSContext *)result);
  uint64_t result = swift::runtime::AccessSet::insert(v9, a2, v6, v8, a3);
  if ((result & 1) == 0) {
LABEL_5:
  }
    *a2 = 0;
  return result;
}

swift::runtime::SwiftTLSContext *swift_endAccess(swift::runtime::SwiftTLSContext *result)
{
  if (*(void *)result)
  {
    int v1 = result;
    uint64_t result = (swift::runtime::SwiftTLSContext *)swift::runtime::SwiftTLSContext::get(result);
    unint64_t v2 = *(void *)result;
    if (*(swift::runtime::SwiftTLSContext **)result == v1)
    {
      *(void *)uint64_t result = *((void *)v1 + 2) & 0xFFFFFFFFFFFFFFFELL;
    }
    else
    {
      do
      {
        unint64_t v3 = v2;
        uint64_t v4 = *(void *)(v2 + 16);
        unint64_t v2 = v4 & 0xFFFFFFFFFFFFFFFELL;
        if ((v4 & 0xFFFFFFFFFFFFFFFELL) == 0) {
          abort();
        }
      }
      while ((swift::runtime::SwiftTLSContext *)v2 != v1);
      *(void *)(v3 + 16) = *((void *)v1 + 2) & 0xFFFFFFFFFFFFFFFELL | v4 & 1;
    }
  }
  return result;
}

uint64_t *swift_task_enterThreadLocalContext(swift::runtime::SwiftTLSContext *a1)
{
  uint64_t result = swift::runtime::SwiftTLSContext::get(a1);
  uint64_t v3 = *(void *)a1;
  uint64_t v4 = *result;
  if (*(void *)a1)
  {
    if (v4)
    {
      uint64_t v5 = *((void *)a1 + 1);
      *uint64_t result = v3;
      *(void *)(v5 + 16) = *(void *)(v5 + 16) & 1 | v4;
      *(void *)a1 = v4;
    }
    else
    {
      *uint64_t result = v3;
      *(void *)a1 = 0;
    }
    *((void *)a1 + 1) = 0;
  }
  else if (v4)
  {
    *(void *)a1 = v4;
  }
  return result;
}

unint64_t *swift_task_exitThreadLocalContext(swift::runtime::SwiftTLSContext *a1)
{
  uint64_t result = swift::runtime::SwiftTLSContext::get(a1);
  unint64_t v3 = *(void *)a1;
  unint64_t v4 = *result;
  if (*(void *)a1)
  {
    if (v4 == v3)
    {
      *(void *)a1 = 0;
      *((void *)a1 + 1) = 0;
    }
    else
    {
      unint64_t v5 = *result;
      while (1)
      {
        unint64_t v6 = v5;
        unint64_t v5 = *(void *)(v5 + 16) & 0xFFFFFFFFFFFFFFFELL;
        if (!v5) {
          break;
        }
        if (v5 == v3) {
          goto LABEL_13;
        }
      }
      unint64_t v6 = 0;
LABEL_13:
      *uint64_t result = v3;
      *(void *)(v6 + 16) &= 1uLL;
      *(void *)a1 = v4;
      *((void *)a1 + 1) = v6;
    }
  }
  else if (v4)
  {
    unint64_t v7 = *result;
    do
    {
      unint64_t v8 = v7;
      unint64_t v7 = *(void *)(v7 + 16) & 0xFFFFFFFFFFFFFFFELL;
    }
    while (v7);
    *uint64_t result = 0;
    *(void *)a1 = v4;
    *((void *)a1 + 1) = v8;
  }
  return result;
}

BOOL swift::TargetOpaqueExistentialContainer<swift::InProcess>::isValueInline(uint64_t a1)
{
  return (*(unsigned char *)(*(void *)(*(void *)(a1 + 24) - 8) + 82) & 2) == 0;
}

void *swift::TargetOpaqueExistentialContainer<swift::InProcess>::projectValue(void *result)
{
  int v1 = *(_DWORD *)(*(void *)(result[3] - 8) + 80);
  if ((v1 & 0x20000) != 0) {
    return (void *)(*result + ((v1 + 16) & ~(unint64_t)v1));
  }
  return result;
}

BOOL _swift_isObjCTypeNameSerializable(void *a1)
{
  int v1 = a1;
  uint64_t v2 = *a1;
  if (*a1 > 0x7FFuLL) {
    LODWORD(v2) = 0;
  }
  BOOL result = 1;
  if ((v2 - 515) < 2 || v2 == 773) {
    return result;
  }
  if (v2) {
    return 0;
  }
  if ((v1[4] & 2) == 0) {
    return result;
  }
  if (v1[8]) {
    goto LABEL_10;
  }
  if (v1[1])
  {
    int v1 = (void *)v1[1];
LABEL_10:
    if ((v1[5] & 4) != 0) {
      return result;
    }
    goto LABEL_11;
  }
  int v1 = 0;
  if ((MEMORY[0x28] & 4) != 0) {
    return result;
  }
LABEL_11:
  if (v1[8])
  {
    unint64_t v4 = (_DWORD *)v1[8];
LABEL_16:
    if (v4)
    {
      while (1)
      {
        BOOL result = (*v4 & 0x1F) != 2;
        if ((*v4 & 0x1F) == 2) {
          break;
        }
        uint64_t v7 = (int)v4[1];
        unint64_t v6 = v4 + 1;
        uint64_t v5 = v7;
        if (!v7) {
          break;
        }
        unint64_t v8 = (_DWORD **)((char *)v6 + (v5 & 0xFFFFFFFFFFFFFFFELL));
        if (v5)
        {
          unint64_t v4 = *v8;
          if (!*v8) {
            return result;
          }
          goto LABEL_16;
        }
        if (!v8) {
          return result;
        }
        unint64_t v4 = (_DWORD *)((char *)v6 + (v5 & 0xFFFFFFFFFFFFFFFELL));
      }
    }
  }
  return result;
}

uint64_t swift_getFunctionReplacement(swift::runtime::SwiftTLSContext *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (*(void *)a1 == a2) {
    return 0;
  }
  unint64_t v3 = swift::runtime::SwiftTLSContext::get(a1);
  if (*((unsigned char *)v3 + 8))
  {
    uint64_t v2 = 0;
    *((unsigned char *)v3 + 8) = 0;
  }
  return v2;
}

uint64_t swift_getOrigOfReplaceable(swift::runtime::SwiftTLSContext *a1)
{
  uint64_t v1 = *(void *)a1;
  *((unsigned char *)swift::runtime::SwiftTLSContext::get(a1) + 8) = 1;
  return v1;
}

uint64_t swift::compareGenericMetadata(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  unint64_t v4 = *(void *)a1;
  if (*(void *)a1 > 0x7FFuLL) {
    LODWORD(v4) = 0;
  }
  unint64_t v5 = *(void *)a2;
  if (*(void *)a2 > 0x7FFuLL) {
    LODWORD(v5) = 0;
  }
  if (v4 != v5)
  {
    validationLog(1, "Kinds do not match");
    goto LABEL_10;
  }
  uint64_t TypeContextDescriptor = (_DWORD *)swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor((unint64_t *)a1);
  if (TypeContextDescriptor != (_DWORD *)swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor((unint64_t *)a2))
  {
    validationLog(1, "Descriptors do not match");
    goto LABEL_10;
  }
  if ((*(unsigned char *)TypeContextDescriptor & 0x80) != 0)
  {
    if (*(void *)(a1 - 8)) {
      long long v12 = *(uint64_t **)(a1 - 8);
    }
    else {
      long long v12 = 0;
    }
    v51[0] = v12;
    if (*(void *)(a2 - 8)) {
      uint64_t v13 = *(void *)(a2 - 8);
    }
    else {
      uint64_t v13 = 0;
    }
    v54[0] = (void (*)(const char *, ...))v13;
    if (v12) {
      long long v14 = v12;
    }
    else {
      long long v14 = 0;
    }
    if (*v14) {
      uint64_t v15 = *v14;
    }
    else {
      uint64_t v15 = 0;
    }
    if (v15 != *(void *)v13) {
      goto LABEL_83;
    }
    uint64_t v16 = v14[1] ? v14[1] : 0;
    if (v16 != *(void *)(v13 + 8)) {
      goto LABEL_83;
    }
    uint64_t v17 = v14[2] ? v14[2] : 0;
    if (v17 != *(void *)(v13 + 16)) {
      goto LABEL_83;
    }
    uint64_t v18 = v14[3] ? v14[3] : 0;
    if (v18 == *(void *)(v13 + 24)
      && (!v14[4] ? (uint64_t v19 = 0) : (uint64_t v19 = v14[4]),
          v19 == *(void *)(v13 + 32)
       && (!v14[5] ? (uint64_t v20 = 0) : (uint64_t v20 = v14[5]),
           v20 == *(void *)(v13 + 40)
        && (!v14[6] ? (uint64_t v21 = 0) : (uint64_t v21 = v14[6]),
            v21 == *(void *)(v13 + 48)
         && (!v14[7] ? (uint64_t v22 = 0) : (uint64_t v22 = v14[7]),
             v22 == *(void *)(v13 + 56)
          && v14[8] == *(void *)(v13 + 64)
          && v14[9] == *(void *)(v13 + 72)
          && v14[10] == *(void *)(v13 + 80)
          && ((v14[10] & 0x200000) == 0
           || (!v14[11] ? (uint64_t v24 = 0) : (uint64_t v24 = v14[11]),
               v24 == *(void *)(v13 + 88)
            && (!v14[12] ? (uint64_t v25 = 0) : (uint64_t v25 = v14[12]),
                v25 == *(void *)(v13 + 96)
             && (!v14[13] ? (uint64_t v26 = 0) : (uint64_t v26 = v14[13]), v26 == *(void *)(v13 + 104))))))))))
    {
      char v23 = 1;
    }
    else
    {
LABEL_83:
      validationLog(1, "VWTs do not match");
      char v23 = 0;
    }
    FullGenericContextHeader = swift::TargetTypeContextDescriptor<swift::InProcess>::getFullGenericContextHeader(TypeContextDescriptor);
    if ((*TypeContextDescriptor & 0x1Fu) - 17 >= 2)
    {
      if ((*TypeContextDescriptor & 0x1F) != 0x10) {
LABEL_141:
      }
        abort();
      if (TypeContextDescriptor) {
        long long v29 = TypeContextDescriptor;
      }
      else {
        long long v29 = 0;
      }
      if ((*v29 & 0x20000000) != 0)
      {
        int ResilientImmediateMembersOffset = swift::getResilientImmediateMembersOffset((uint64_t)v29);
      }
      else
      {
        if ((*v29 & 0x10000000) != 0)
        {
          int v30 = 0;
          uint64_t v31 = 6;
        }
        else
        {
          int v30 = v29[7];
          uint64_t v31 = 8;
        }
        int ResilientImmediateMembersOffset = v30 - v29[v31];
      }
    }
    else
    {
      int ResilientImmediateMembersOffset = 2;
    }
    uint64_t v32 = *((unsigned __int16 *)FullGenericContextHeader + 6);
    unint64_t v33 = 8 * (v32 + ResilientImmediateMembersOffset);
    unint64_t v34 = *(void *)a1;
    if (*(void *)a1 > 0x7FFuLL) {
      LODWORD(v34) = 0;
    }
    if (v34 == 513)
    {
      uint64_t v35 = swift::compareGenericMetadata(swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*)::$_1::operator()(a1, v33);
      uint64_t v36 = swift::compareGenericMetadata(swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*)::$_1::operator()(a2, v33);
    }
    else if (v34 == 512)
    {
      uint64_t v35 = swift::compareGenericMetadata(swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*)::$_0::operator()(a1, v33);
      uint64_t v36 = swift::compareGenericMetadata(swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*)::$_0::operator()(a2, v33);
    }
    else
    {
      if (v34)
      {
        uint64_t v36 = 8 * (v32 + ResilientImmediateMembersOffset);
        goto LABEL_107;
      }
      uint64_t v35 = (*(_DWORD *)(a1 + 56) - *(_DWORD *)(a1 + 60)) >> 3;
      uint64_t v36 = (*(_DWORD *)(a2 + 56) - *(_DWORD *)(a2 + 60)) >> 3;
    }
    if (v35 != v36)
    {
      validationLog(1, "Sizes do not match");
      char v23 = 0;
      LODWORD(v32) = *((unsigned __int16 *)FullGenericContextHeader + 6);
      uint64_t v36 = v35;
    }
LABEL_107:
    unint64_t v50 = v36;
    if (v32)
    {
      unint64_t v37 = 0;
      do
      {
        int v38 = *TypeContextDescriptor;
        int v39 = *TypeContextDescriptor & 0x1F;
        if ((v39 - 17) >= 2)
        {
          if (v39 != 16) {
            goto LABEL_141;
          }
          if (TypeContextDescriptor) {
            uint64_t v41 = TypeContextDescriptor;
          }
          else {
            uint64_t v41 = 0;
          }
          if ((*v41 & 0x20000000) != 0)
          {
            int v40 = swift::getResilientImmediateMembersOffset((uint64_t)v41);
            int v38 = *TypeContextDescriptor;
          }
          else
          {
            if ((*v41 & 0x10000000) != 0)
            {
              int v42 = 0;
              uint64_t v43 = 6;
            }
            else
            {
              int v42 = v41[7];
              uint64_t v43 = 8;
            }
            int v40 = v42 - v41[v43];
          }
        }
        else
        {
          int v40 = 2;
        }
        uint64_t v44 = *(void *)(a1 + 8 * v40 + 8 * v37);
        int v45 = v38 & 0x1F;
        if ((v45 - 17) >= 2)
        {
          if (v45 != 16) {
            goto LABEL_141;
          }
          if (TypeContextDescriptor) {
            int v47 = TypeContextDescriptor;
          }
          else {
            int v47 = 0;
          }
          if ((*v47 & 0x20000000) != 0)
          {
            int v46 = swift::getResilientImmediateMembersOffset((uint64_t)v47);
          }
          else
          {
            if ((*v47 & 0x10000000) != 0)
            {
              int v48 = 0;
              uint64_t v49 = 6;
            }
            else
            {
              int v48 = v47[7];
              uint64_t v49 = 8;
            }
            int v46 = v48 - v47[v49];
          }
        }
        else
        {
          int v46 = 2;
        }
        if ((swift::compareGenericMetadata(v44, *(void *)(a2 + 8 * v46 + 8 * v37)) & 1) == 0)
        {
          validationLog(1, "Generic argument %u does not match", v37);
          char v23 = 0;
        }
        ++v37;
      }
      while (v37 < *((unsigned __int16 *)FullGenericContextHeader + 6));
    }
    if (v50 > v33 && memcmp((const void *)(a1 + v33), (const void *)(a2 + v33), v50 - v33)) {
      validationLog(1, "Metadatas do not match in the part after generic arguments");
    }
    if ((v23 & 1) == 0) {
      goto LABEL_10;
    }
    return 1;
  }
  validationLog(1, "Descriptor is not generic and pointers are not identical");
LABEL_10:
  validationLog(1, "Error: original and new metadata do not match!");
  validationLog(1, "Original metadata:");
  v54[0] = (void (*)(const char *, ...))printToStderr;
  swift::GenericMetadataBuilder<InProcessReaderWriter>::Dumper<void (*)(char const*,...)>::dumpMetadata(v54, (void *)a1, (uint64_t)v51);
  int v7 = v53;
  if (v53 != -1)
  {
    ((void (*)(void (**)(const char *, ...), void *))off_1ECA043D8[v53])(v54, v51);
    if (v7 == 1)
    {
      if (v52 >= 0) {
        unint64_t v8 = (const char *)v51;
      }
      else {
        unint64_t v8 = (const char *)v51[0];
      }
      validationLog(1, "error dumping original metadata: %s", v8);
    }
  }
  validationLog(1, "New metadata builder:");
  v54[0] = (void (*)(const char *, ...))printToStderr;
  swift::GenericMetadataBuilder<InProcessReaderWriter>::Dumper<void (*)(char const*,...)>::dumpMetadata(v54, (void *)a2, (uint64_t)v51);
  int v9 = v53;
  if (v53 != -1)
  {
    ((void (*)(void (**)(const char *, ...), void *))off_1ECA043D8[v53])(v54, v51);
    if (v9 == 1)
    {
      if (v52 >= 0) {
        long long v10 = (const char *)v51;
      }
      else {
        long long v10 = (const char *)v51[0];
      }
      validationLog(1, "error dumping new metadata: %s", v10);
    }
  }
  return 0;
}

void validationLog(char a1, const char *a2, ...)
{
  va_start(va, a2);
  if (a1) {
    goto LABEL_5;
  }
  if (swift::runtime::environment::initializeToken != -1) {
    dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
  }
  if (swift::runtime::environment::SWIFT_DEBUG_VALIDATE_EXTERNAL_GENERIC_METADATA_BUILDER_variable >= 2u)
  {
LABEL_5:
    unint64_t v3 = (FILE *)*MEMORY[0x1E4F143C8];
    fputs("GenericMetadataBuilder validation: ", (FILE *)*MEMORY[0x1E4F143C8]);
    vfprintf(v3, a2, va);
    fputs("\n", v3);
  }
}

uint64_t swift::compareGenericMetadata(swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*)::$_0::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v3 = *(void *)(a1 + 8);
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = v3;
  if (!v3) {
    uint64_t v3 = 0;
  }
  if (v3 == -28) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v3 + 28;
  }
  uint64_t v6 = *(int *)(v5 + 4);
  if (v6) {
    uint64_t v7 = v6 + v5 + 4;
  }
  else {
    uint64_t v7 = 0;
  }
  if ((*(unsigned char *)(v7 + 8) & 2) != 0)
  {
    uint64_t v10 = a1 + 8 * (*(unsigned int *)(v4 + 24) + ((4 * (unint64_t)*(unsigned int *)(v4 + 20) + 7) >> 3)) + 8;
    return v10 - a1;
  }
  if (v2)
  {
    unsigned int v8 = *(_DWORD *)(v2 + 24);
    if (v8)
    {
      uint64_t v9 = *(void *)(a1 + 8);
LABEL_19:
      uint64_t v10 = a1 + 8 * v8 + 4 * *(unsigned int *)(v9 + 20);
      return v10 - a1;
    }
  }
  else
  {
    unsigned int v8 = MEMORY[0x18];
    if (MEMORY[0x18])
    {
      uint64_t v9 = 0;
      goto LABEL_19;
    }
  }
  return a2;
}

uint64_t swift::compareGenericMetadata(swift::TargetMetadata<swift::InProcess> const*,swift::TargetMetadata<swift::InProcess> const*)::$_1::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v3 = *(void *)(a1 + 8);
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = v3;
  uint64_t v5 = v3;
  if (!v3) {
    uint64_t v3 = 0;
  }
  if (v3 == -28) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v3 + 28;
  }
  uint64_t v7 = 0;
  uint64_t v8 = *(int *)(v6 + 4);
  if (v8) {
    uint64_t v9 = v8 + v6 + 4;
  }
  else {
    uint64_t v9 = 0;
  }
  if ((*(unsigned char *)(v9 + 8) & 2) != 0)
  {
    if (v5) {
      uint64_t v10 = v4;
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t v11 = *(unsigned __int16 *)(v10 + 40) + 2;
    if (v2) {
      uint64_t v12 = *(void *)(a1 + 8);
    }
    else {
      uint64_t v12 = 0;
    }
    if (*(unsigned char *)(v12 + 23)) {
      uint64_t v13 = v11 + 1;
    }
    else {
      uint64_t v13 = v11;
    }
    uint64_t v7 = a1 + 8 * v13;
  }
  if (v7) {
    return v7 - a1 + 8;
  }
  else {
    return a2;
  }
}

void swift::validateExternalGenericMetadataBuilder(Class *a1, int *a2, uint64_t a3)
{
  if (a2 && (*a2 & 0x1Fu) - 19 >= 0xFFFFFFFE && (*a2 & 0x80) != 0)
  {
    FullGenericContextHeader = swift::TargetTypeContextDescriptor<swift::InProcess>::getFullGenericContextHeader(a2);
    uint64_t v8 = (int)FullGenericContextHeader[1];
    uint64_t v9 = (char *)FullGenericContextHeader + v8 + 4;
    swift::GenericMetadataBuilder<InProcessReaderWriter>::GenericMetadataBuilder(v33, (InProcessReaderWriter *)&v29);
    if (v8) {
      uint64_t v10 = (uint64_t)v9;
    }
    else {
      uint64_t v10 = 0;
    }
    swift::GenericMetadataBuilder<InProcessReaderWriter>::extraDataSize(v33, a2, v10, (uint64_t)v26);
    swift::GenericMetadataBuilder<InProcessReaderWriter>::~GenericMetadataBuilder((unsigned int *)v33);
    if (v28 == 1)
    {
      if (v27 >= 0) {
        uint64_t v11 = (const char *)v26;
      }
      else {
        uint64_t v11 = (const char *)v26[0];
      }
      validationLog(0, "error getting extra data size: %s", v11);
LABEL_40:
      if (v28 != -1) {
        ((void (*)(InProcessReaderWriter **, void *))off_1ECA044A8[v28])(v33, v26);
      }
      return;
    }
    unint64_t v12 = *(unsigned __int16 *)(swift::TargetContextDescriptor<swift::InProcess>::getGenericContext(a2) + 8);
    uint64_t v13 = v26[0];
    swift::GenericMetadataBuilder<InProcessReaderWriter>::GenericMetadataBuilder(v33, (InProcessReaderWriter *)&v34);
    swift::GenericMetadataBuilder<InProcessReaderWriter>::buildGenericValueMetadata(v33, a2, a3, v12, v10, v13, (uint64_t)&v29);
    int v14 = v32;
    if (v32)
    {
      if (v32 == 1) {
        uint64_t v15 = (std::string *)&v29;
      }
      else {
        uint64_t v15 = 0;
      }
      uint64_t v16 = (uint64_t)&v31 + 7;
      if (v32 != 1) {
        uint64_t v16 = 23;
      }
      if (*(char *)v16 < 0)
      {
        uint64_t v17 = 8;
        if (v32 == 1) {
          uint64_t v17 = (uint64_t)&v30;
        }
        std::string::__init_copy_ctor_external(&v24, v15->__r_.__value_.__l.__data_, *(void *)v17);
        int v14 = v32;
      }
      else
      {
        std::string v24 = *v15;
      }
      int v25 = 1;
      if (v14 == -1) {
        goto LABEL_26;
      }
    }
    else
    {
      v24.__r_.__value_.__r.__words[0] = (std::string::size_type)&v29[v31];
      int v25 = 0;
    }
    ((void (*)(char *, const char **))off_1ECA043F8[v14])(&v35, &v29);
LABEL_26:
    swift::GenericMetadataBuilder<InProcessReaderWriter>::~GenericMetadataBuilder((unsigned int *)v33);
    if (v25 == 1)
    {
      validationLog(0, "error allocating metadata: %s");
    }
    else
    {
      uint64_t v18 = v24.__r_.__value_.__r.__words[0];
      swift::GenericMetadataBuilder<InProcessReaderWriter>::GenericMetadataBuilder(v33, (InProcessReaderWriter *)&v34);
      swift::GenericMetadataBuilder<InProcessReaderWriter>::initializeGenericMetadata(v33, v18 - 16, (uint64_t)&v29);
      int v19 = v32;
      int v20 = v32;
      if (v32 == 1)
      {
        if (v31 >= 0) {
          uint64_t v21 = (const char *)&v29;
        }
        else {
          uint64_t v21 = v29;
        }
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "swift_initializeGenericValueMetadata failed: %s", v21);
        int v20 = v32;
      }
      if (v20 != -1) {
        ((void (*)(char *, const char **))off_1ECA043D8[v20])(&v35, &v29);
      }
      swift::GenericMetadataBuilder<InProcessReaderWriter>::~GenericMetadataBuilder((unsigned int *)v33);
      if (v19 != 1)
      {
        if ((swift::compareGenericMetadata((uint64_t)a1, v18) & 1) == 0) {
          swift::fatalError(0, "Fatal error: mismatched metadata.\n", v22, v23);
        }
        swift_getTypeName(a1, 0);
        validationLog(0, "Validated generic metadata builder on %.*s");
      }
    }
    if (v25 != -1) {
      ((void (*)(InProcessReaderWriter **, std::string *))off_1ECA04498[v25])(v33, &v24);
    }
    goto LABEL_40;
  }
}

_DWORD *swift::TargetTypeContextDescriptor<swift::InProcess>::getFullGenericContextHeader(_DWORD *a1)
{
  int v1 = *a1 & 0x1F;
  switch(v1)
  {
    case 18:
      if (a1) {
        uint64_t v3 = a1;
      }
      else {
        uint64_t v3 = 0;
      }
      if (!v3) {
        uint64_t v3 = 0;
      }
      if (v3 != (_DWORD *)-28) {
        return v3 + 7;
      }
      break;
    case 17:
      if (a1) {
        uint64_t v4 = a1;
      }
      else {
        uint64_t v4 = 0;
      }
      if (!v4) {
        uint64_t v4 = 0;
      }
      if (v4 != (_DWORD *)-28) {
        return v4 + 7;
      }
      break;
    case 16:
      if (a1) {
        uint64_t v2 = a1;
      }
      else {
        uint64_t v2 = 0;
      }
      if (!v2) {
        uint64_t v2 = 0;
      }
      if (v2 != (_DWORD *)-44) {
        return v2 + 11;
      }
      break;
    default:
      abort();
  }
  return 0;
}

uint64_t printToStderr(const char *a1, ...)
{
  va_start(va, a1);
  return vfprintf((FILE *)*MEMORY[0x1E4F143C8], a1, va);
}

void swift::GenericMetadataBuilder<InProcessReaderWriter>::Dumper<void (*)(char const*,...)>::dumpMetadata(void (**a1)(const char *, ...)@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  swift::GenericMetadataBuilder<InProcessReaderWriter>::Dumper<void (*)(char const*,...)>::printPointer<swift::TargetMetadata<swift::InProcess> const>(a1, "Metadata ", a2, "\n");
  if (*(a2 - 1)) {
    uint64_t v6 = (void *)*(a2 - 1);
  }
  else {
    uint64_t v6 = 0;
  }
  char v34 = v6;
  int v35 = 0;
  swift::GenericMetadataBuilder<InProcessReaderWriter>::Dumper<void (*)(char const*,...)>::printPointer<swift::TargetMetadata<swift::InProcess> const>(a1, "  value witnesses: ", v6, "\n");
  swift::GenericMetadataBuilder<InProcessReaderWriter>::Dumper<void (*)(char const*,...)>::dumpVWT(a1, (uint64_t)v6, (uint64_t)v30);
  if (v33)
  {
    if (v33 == 1) {
      uint64_t v8 = v30;
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = (uint64_t)&v32;
    if (v33 != 1) {
      uint64_t v9 = 23;
    }
    if (*(char *)v9 < 0)
    {
      uint64_t v17 = 8;
      if (v33 == 1) {
        uint64_t v17 = (uint64_t)&v31;
      }
      std::string::__init_copy_ctor_external((std::string *)a3, *(const std::string::value_type **)v8, *(void *)v17);
    }
    else
    {
      *(_OWORD *)a3 = *(_OWORD *)v8;
      *(void *)(a3 + 16) = *((void *)v8 + 2);
    }
    *(_DWORD *)(a3 + 24) = 1;
    goto LABEL_24;
  }
  if (*a2 <= 0x7FFuLL) {
    uint64_t v10 = (swift *)*a2;
  }
  else {
    uint64_t v10 = 0;
  }
  StringForMetadataKind = swift::getStringForMetadataKind(v10, v7);
  uint64_t v13 = *a1;
  if (!StringForMetadataKind)
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    goto LABEL_36;
  }
  std::string::size_type v14 = v12;
  if (v12 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  uint64_t v15 = StringForMetadataKind;
  if (v12 >= 0x17)
  {
    uint64_t v19 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17) {
      uint64_t v19 = v12 | 7;
    }
    uint64_t v20 = v19 + 1;
    uint64_t v16 = (std::string *)operator new(v19 + 1);
    __dst.__r_.__value_.__l.__size_ = v14;
    __dst.__r_.__value_.__r.__words[2] = v20 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v16;
    goto LABEL_33;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v12;
  uint64_t v16 = &__dst;
  if (v12) {
LABEL_33:
  }
    memmove(v16, v15, v14);
  v16->__r_.__value_.__s.__data_[v14] = 0;
  p_dst = &__dst;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
LABEL_36:
  v13("  kind: %#x (%s)\n", v10, (const char *)p_dst);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (*a2 <= 0x7FFuLL && *a2)
  {
    if (*a2 - 515 >= 0xFFFFFFFD)
    {
      swift::GenericMetadataBuilder<InProcessReaderWriter>::Dumper<void (*)(char const*,...)>::dumpValueMetadata(a1, a2, (uint64_t)a2, (uint64_t)&__dst);
      int v21 = v29;
      if (v29)
      {
        if (v29 == 1) {
          uint64_t v22 = &__dst;
        }
        else {
          uint64_t v22 = 0;
        }
        uint64_t v23 = (uint64_t)&__dst.__r_.__value_.__r.__words[2] + 7;
        if (v29 != 1) {
          uint64_t v23 = 23;
        }
        if (*(char *)v23 < 0)
        {
          std::string v24 = (const std::string::value_type *)v22->__r_.__value_.__r.__words[0];
LABEL_63:
          BOOL v26 = v21 == 1;
          p_std::string::size_type size = (std::string::size_type *)8;
          if (v26) {
            p_std::string::size_type size = &__dst.__r_.__value_.__l.__size_;
          }
          std::string::__init_copy_ctor_external((std::string *)a3, v24, *p_size);
          int v21 = v29;
          goto LABEL_66;
        }
        goto LABEL_60;
      }
    }
LABEL_61:
    *(_DWORD *)(a3 + 24) = 0;
    goto LABEL_24;
  }
  swift::BuilderError::BuilderError((swift::BuilderError *)&v36, "Class dumping is not yet implemented");
  if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(&__dst, v36.__r_.__value_.__l.__data_, v36.__r_.__value_.__l.__size_);
    int v29 = 1;
    if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v36.__r_.__value_.__l.__data_);
      int v21 = v29;
      if (!v29) {
        goto LABEL_61;
      }
    }
    else
    {
      int v21 = 1;
    }
  }
  else
  {
    std::string __dst = v36;
    int v29 = 1;
    int v21 = 1;
  }
  if (v21 == 1) {
    uint64_t v22 = &__dst;
  }
  else {
    uint64_t v22 = 0;
  }
  uint64_t v25 = (uint64_t)&__dst.__r_.__value_.__r.__words[2] + 7;
  if (v21 != 1) {
    uint64_t v25 = 23;
  }
  if (*(char *)v25 < 0)
  {
    std::string v24 = (const std::string::value_type *)v22->__r_.__value_.__r.__words[0];
    goto LABEL_63;
  }
LABEL_60:
  *(_OWORD *)a3 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  *(void *)(a3 + 16) = *((void *)&v22->__r_.__value_.__l + 2);
LABEL_66:
  *(_DWORD *)(a3 + 24) = 1;
  if (v21 != -1) {
    ((void (*)(std::string *, std::string *))off_1ECA043D8[v21])(&v36, &__dst);
  }
LABEL_24:
  if (v33 != -1) {
    ((void (*)(std::string *, unsigned char *))off_1ECA043D8[v33])(&__dst, v30);
  }
  if (v35 != -1) {
    ((void (*)(unsigned char *, void **))off_1ECA043C8[v35])(v30, &v34);
  }
}

uint64_t swift::GenericMetadataBuilder<InProcessReaderWriter>::Dumper<void (*)(char const*,...)>::printPointer<swift::TargetMetadata<swift::InProcess> const>(void (**a1)(const char *, ...), const char *a2, void *a3, const char *a4)
{
  (*a1)("%s", a2);
  InProcessReaderWriter::getSymbolInfo<swift::TargetMetadata<swift::InProcess> const>(a3, (uint64_t)v10);
  if (v11 >= 0) {
    MetadataKind v7 = v10;
  }
  else {
    MetadataKind v7 = (void **)v10[0];
  }
  p_p = (const char *)&__p;
  if (v13 < 0) {
    p_p = (const char *)__p;
  }
  (*a1)("%#llx - %s (%s + %llu)", a3, (const char *)v7, p_p, v14);
  if (v13 < 0)
  {
    operator delete(__p);
    if ((v11 & 0x80000000) == 0) {
      return ((uint64_t (*)(const char *, ...))*a1)("%s", a4);
    }
LABEL_10:
    operator delete(v10[0]);
    return ((uint64_t (*)(const char *, ...))*a1)("%s", a4);
  }
  if (v11 < 0) {
    goto LABEL_10;
  }
  return ((uint64_t (*)(const char *, ...))*a1)("%s", a4);
}

void swift::GenericMetadataBuilder<InProcessReaderWriter>::Dumper<void (*)(char const*,...)>::dumpVWT(void (**a1)(const char *, ...)@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj55882EEKPFPNS_11OpaqueValueEPNS_17TargetValueBufferINS_9InProcessEEESF_PKNS_14TargetMetadataISD_EEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_(a1, "initializeBufferWithCopyOfBuffer", (void **)a2, (uint64_t)v11);
  int v6 = v14;
  if (v14) {
    goto LABEL_9;
  }
  _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj1272EEKPFvPNS_11OpaqueValueEPKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_(a1, "destroy", (void **)(a2 + 8), (uint64_t)v11);
  int v6 = v14;
  if (v14) {
    goto LABEL_9;
  }
  _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj58298EEKPFPNS_11OpaqueValueESB_SB_PKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_(a1, "initializeWithCopy", (void **)(a2 + 16), (uint64_t)v11);
  int v6 = v14;
  if (v14) {
    goto LABEL_9;
  }
  _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj34641EEKPFPNS_11OpaqueValueESB_SB_PKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_(a1, "assignWithCopy", (void **)(a2 + 24), (uint64_t)v11);
  int v6 = v14;
  if (v14) {
    goto LABEL_9;
  }
  _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj18648EEKPFPNS_11OpaqueValueESB_SB_PKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_(a1, "initializeWithTake", (void **)(a2 + 32), (uint64_t)v11);
  int v6 = v14;
  if (v14) {
    goto LABEL_9;
  }
  _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj61402EEKPFPNS_11OpaqueValueESB_SB_PKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_(a1, "assignWithTake", (void **)(a2 + 40), (uint64_t)v11);
  int v6 = v14;
  if (v14) {
    goto LABEL_9;
  }
  _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj24816EEKPFjPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISE_EEEES5_PT_(a1, "getEnumTagSinglePayload", (void **)(a2 + 48), (uint64_t)v11);
  int v6 = v14;
  if (v14) {
    goto LABEL_9;
  }
  _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj41169EEKPFvPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_(a1, "storeEnumTagSinglePayload", (void **)(a2 + 56), (uint64_t)v11);
  int v6 = v14;
  if (v14) {
    goto LABEL_9;
  }
  (*a1)("    %s: %#llx (%llu)\n", "size", *(void *)(a2 + 64), *(void *)(a2 + 64));
  (*a1)("    %s: %#llx (%llu)\n", "stride", *(void *)(a2 + 72), *(void *)(a2 + 72));
  (*a1)("    %s: %#llx (%llu)\n", "flags", *(unsigned int *)(a2 + 80), *(unsigned int *)(a2 + 80));
  (*a1)("    %s: %#llx (%llu)\n", "extraInhabitantCount", *(unsigned int *)(a2 + 84), *(unsigned int *)(a2 + 84));
  if (!a2) {
    goto LABEL_27;
  }
  if ((*(_DWORD *)(a2 + 80) & 0x200000) != 0
    && ((_ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj41909EEKPFjPKNS_11OpaqueValueEPKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISE_EEEES5_PT_(a1, "getEnumTag", (void **)(a2 + 88), (uint64_t)v11), (int v6 = v14) != 0)|| (_ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj1053EEKPFvPNS_11OpaqueValueEPKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_(a1, "destructiveProjectEnumData", (void **)(a2 + 96), (uint64_t)v11), (int v6 = v14) != 0)|| (_ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj45796EEKPFvPNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_(a1, "destructiveInjectEnumTag", (void **)(a2 + 104), (uint64_t)v11), (int v6 = v14) != 0)))
  {
LABEL_9:
    if (v6 == 1) {
      MetadataKind v7 = v11;
    }
    else {
      MetadataKind v7 = 0;
    }
    uint64_t v8 = (uint64_t)&v13;
    if (v6 != 1) {
      uint64_t v8 = 23;
    }
    if (*(char *)v8 < 0)
    {
      BOOL v9 = v6 == 1;
      uint64_t v10 = 8;
      if (v9) {
        uint64_t v10 = (uint64_t)&v12;
      }
      std::string::__init_copy_ctor_external((std::string *)a3, *(const std::string::value_type **)v7, *(void *)v10);
      int v6 = v14;
    }
    else
    {
      *(_OWORD *)a3 = *(_OWORD *)v7;
      *(void *)(a3 + 16) = *((void *)v7 + 2);
    }
    *(_DWORD *)(a3 + 24) = 1;
    if (v6 != -1) {
      ((void (*)(char *, unsigned char *))off_1ECA043D8[v6])(&v15, v11);
    }
  }
  else
  {
LABEL_27:
    *(_DWORD *)(a3 + 24) = 0;
  }
}

unint64_t swift::GenericMetadataBuilder<InProcessReaderWriter>::Dumper<void (*)(char const*,...)>::dumpValueMetadata@<X0>(void (**a1)(const char *, ...)@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  if (*(void *)(a3 + 8)) {
    uint64_t v8 = *(unsigned char **)(a3 + 8);
  }
  else {
    uint64_t v8 = 0;
  }
  swift::GenericMetadataBuilder<InProcessReaderWriter>::Dumper<void (*)(char const*,...)>::printPointer<swift::TargetValueTypeDescriptor<swift::InProcess> const>(a1, "  description: ", v8, "\n");
  if ((v8[2] & 0x10) != 0)
  {
    if (*(void *)(a3 - 16)) {
      BOOL v9 = *(void **)(a3 - 16);
    }
    else {
      BOOL v9 = 0;
    }
    swift::GenericMetadataBuilder<InProcessReaderWriter>::Dumper<void (*)(char const*,...)>::printPointer<swift::TargetMetadata<swift::InProcess> const>(a1, "  layout string: ", v9, "\n");
  }
  uint64_t v10 = &v8[*((int *)v8 + 2) + 8];
  swift::GenericMetadataBuilder<InProcessReaderWriter>::Dumper<void (*)(char const*,...)>::printPointer<swift::TargetMetadata<swift::InProcess> const>(a1, "  name: ", v10, "\n");
  unint64_t result = ((uint64_t (*)(const char *, ...))*a1)("        \"%s\"\n", v10);
  unint64_t v12 = *a2;
  uint64_t v31 = a4;
  if (*a2 == 512)
  {
    unint64_t v13 = a2[1];
    if (v13)
    {
      v34[0] = (void *)a2[1];
      LODWORD(__p) = 0;
      unint64_t v14 = v13;
    }
    else
    {
      unint64_t v14 = 0;
      v34[0] = 0;
      LODWORD(__p) = 0;
    }
    uint64_t v17 = *(unsigned int *)(v14 + 24);
    if (!v17)
    {
LABEL_29:
      unint64_t result = ((uint64_t (*)(void **, void **))off_1ECA043B8[v17])(v32, v34);
      if ((*v8 & 0x80) == 0) {
        goto LABEL_46;
      }
      goto LABEL_30;
    }
    unint64_t v18 = v14;
    if (*(_DWORD *)(v14 + 20))
    {
      unint64_t v19 = 0;
      uint64_t v20 = &a2[v17];
      do
      {
        (*a1)("  fieldOffset[%u]: %u\n", v19, *((_DWORD *)v20 + v19));
        ++v19;
      }
      while (v19 < *(unsigned int *)(v18 + 20));
      goto LABEL_25;
    }
LABEL_28:
    LODWORD(v17) = 0;
    goto LABEL_29;
  }
  if (v12 <= 0x7FF && (v12 - 515) >= 0xFFFFFFFE)
  {
    unint64_t v15 = a2[1];
    if (v15)
    {
      v34[0] = (void *)a2[1];
      LODWORD(__p) = 0;
      unint64_t v16 = v15;
    }
    else
    {
      unint64_t v16 = 0;
      v34[0] = 0;
      LODWORD(__p) = 0;
    }
    if (HIBYTE(*(_DWORD *)(v16 + 20)))
    {
      unint64_t v21 = (unint64_t)*(unsigned int *)(v16 + 20) >> 24;
      (*a1)("  offset: %u\n", HIBYTE(*(_DWORD *)(v16 + 20)));
      (*a1)("  payload size: %llu\n", a2[v21]);
LABEL_25:
      LODWORD(v17) = __p;
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  if ((*v8 & 0x80) == 0) {
    goto LABEL_46;
  }
LABEL_30:
  uint64_t v22 = *((unsigned __int16 *)swift::TargetTypeContextDescriptor<swift::InProcess>::getFullGenericContextHeader(v8) + 4);
  if ((*(_DWORD *)v8 & 0x1Fu) - 17 >= 2)
  {
    if ((*(_DWORD *)v8 & 0x1F) != 0x10) {
      abort();
    }
    if (v8) {
      int v28 = v8;
    }
    else {
      int v28 = 0;
    }
    if ((*v28 & 0x20000000) != 0)
    {
      unint64_t result = swift::getResilientImmediateMembersOffset((uint64_t)v28);
    }
    else
    {
      if ((*v28 & 0x10000000) != 0)
      {
        int v29 = 0;
        uint64_t v30 = 6;
      }
      else
      {
        int v29 = v28[7];
        uint64_t v30 = 8;
      }
      unint64_t result = (v29 - v28[v30]);
    }
  }
  else
  {
    unint64_t result = 2;
  }
  if (v22)
  {
    uint64_t v23 = 0;
    uint64_t v24 = a3 + 8 * (int)result;
    do
    {
      v32[0] = *(void **)(v24 + 8 * v23);
      int v33 = 0;
      (*a1)("  genericArg[%u]: ", v23);
      uint64_t v25 = v32[0];
      InProcessReaderWriter::getSymbolInfo<swift::TargetMetadata<swift::InProcess> const>(v32[0], (uint64_t)v34);
      BOOL v26 = v34;
      if (v35 < 0) {
        BOOL v26 = (void **)v34[0];
      }
      if (v37 >= 0) {
        p_p = (const char *)&__p;
      }
      else {
        p_p = (const char *)__p;
      }
      (*a1)("%#llx - %s (%s + %llu)", v25, (const char *)v26, p_p, v38);
      if (v37 < 0)
      {
        operator delete(__p);
        if (v35 < 0) {
LABEL_45:
        }
          operator delete(v34[0]);
      }
      else if (v35 < 0)
      {
        goto LABEL_45;
      }
      unint64_t result = ((uint64_t (*)(const char *))*a1)("\n");
      if (v33 != -1) {
        unint64_t result = ((uint64_t (*)(void **, void **))off_1ECA043A8[v33])(v34, v32);
      }
      ++v23;
    }
    while (v22 != v23);
  }
LABEL_46:
  *(_DWORD *)(v31 + 24) = 0;
  return result;
}

unint64_t InProcessReaderWriter::getSymbolInfo<swift::TargetMetadata<swift::InProcess> const>@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  unint64_t result = dladdr(a1, &__s);
  if (!result)
  {
    strcpy((char *)(a2 + 23), "\t<unknown>");
    strcpy((char *)a2, "<unknown>");
    *(unsigned char *)(a2 + 47) = 9;
    *(void *)(a2 + 48) = 0;
    return result;
  }
  dli_fname = (char *)__s.dli_fname;
  if (__s.dli_fname)
  {
    dli_sname = __s.dli_sname;
    if (__s.dli_sname) {
      goto LABEL_4;
    }
  }
  else
  {
    dli_fname = "<unknown>";
    __s.dli_fname = "<unknown>";
    dli_sname = __s.dli_sname;
    if (__s.dli_sname) {
      goto LABEL_4;
    }
  }
  dli_sname = "<unknown>";
  __s.dli_sname = "<unknown>";
LABEL_4:
  MetadataKind v7 = strrchr(dli_fname, 47);
  if (v7) {
    dli_fname = v7 + 1;
  }
  size_t v8 = strlen(dli_sname);
  if (v8 > 0x7FFFFFFFFFFFFFF7) {
LABEL_26:
  }
    abort();
  size_t v9 = v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = operator new(v11 + 1);
    *(void *)(a2 + 8) = v9;
    *(void *)(a2 + 16) = v12 | 0x8000000000000000;
    *(void *)a2 = v10;
    goto LABEL_14;
  }
  *(unsigned char *)(a2 + 23) = v8;
  uint64_t v10 = (void *)a2;
  if (v8) {
LABEL_14:
  }
    memmove(v10, dli_sname, v9);
  *((unsigned char *)v10 + v9) = 0;
  unint64_t result = strlen(dli_fname);
  if (result > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_26;
  }
  size_t v13 = result;
  if (result >= 0x17)
  {
    uint64_t v15 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17) {
      uint64_t v15 = result | 7;
    }
    uint64_t v16 = v15 + 1;
    unint64_t v14 = operator new(v15 + 1);
    *(void *)(a2 + 32) = v13;
    *(void *)(a2 + 4swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16 | 0x8000000000000000;
    *(void *)(a2 + 24) = v14;
  }
  else
  {
    unint64_t v14 = (void *)(a2 + 24);
    *(unsigned char *)(a2 + 47) = result;
    if (!result) {
      goto LABEL_23;
    }
  }
  unint64_t result = (unint64_t)memmove(v14, dli_fname, v13);
LABEL_23:
  *((unsigned char *)v14 + v13) = 0;
  *(void *)(a2 + 48) = (unsigned char *)a1 - (char *)__s.dli_fbase;
  return result;
}

uint64_t _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj55882EEKPFPNS_11OpaqueValueEPNS_17TargetValueBufferINS_9InProcessEEESF_PKNS_14TargetMetadataISD_EEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_@<X0>(void (**a1)(const char *, ...)@<X0>, const char *a2@<X2>, void **a3@<X3>, uint64_t a4@<X8>)
{
  if (*a3) {
    int v6 = *a3;
  }
  else {
    int v6 = 0;
  }
  (*a1)("    %s: ", a2);
  InProcessReaderWriter::getSymbolInfo<swift::TargetMetadata<swift::InProcess> const>(v6, (uint64_t)v10);
  if (v11 >= 0) {
    MetadataKind v7 = v10;
  }
  else {
    MetadataKind v7 = (void **)v10[0];
  }
  p_p = (const char *)&__p;
  if (v13 < 0) {
    p_p = (const char *)__p;
  }
  (*a1)("%#llx - %s (%s + %llu)", v6, (const char *)v7, p_p, v14);
  if (v13 < 0)
  {
    operator delete(__p);
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_11;
    }
LABEL_13:
    operator delete(v10[0]);
    goto LABEL_11;
  }
  if (v11 < 0) {
    goto LABEL_13;
  }
LABEL_11:
  uint64_t result = ((uint64_t (*)(const char *))*a1)("\n");
  *(_DWORD *)(a4 + 24) = 0;
  return result;
}

uint64_t _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj1272EEKPFvPNS_11OpaqueValueEPKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_@<X0>(void (**a1)(const char *, ...)@<X0>, const char *a2@<X2>, void **a3@<X3>, uint64_t a4@<X8>)
{
  if (*a3) {
    int v6 = *a3;
  }
  else {
    int v6 = 0;
  }
  (*a1)("    %s: ", a2);
  InProcessReaderWriter::getSymbolInfo<swift::TargetMetadata<swift::InProcess> const>(v6, (uint64_t)v10);
  if (v11 >= 0) {
    MetadataKind v7 = v10;
  }
  else {
    MetadataKind v7 = (void **)v10[0];
  }
  p_p = (const char *)&__p;
  if (v13 < 0) {
    p_p = (const char *)__p;
  }
  (*a1)("%#llx - %s (%s + %llu)", v6, (const char *)v7, p_p, v14);
  if (v13 < 0)
  {
    operator delete(__p);
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_11;
    }
LABEL_13:
    operator delete(v10[0]);
    goto LABEL_11;
  }
  if (v11 < 0) {
    goto LABEL_13;
  }
LABEL_11:
  uint64_t result = ((uint64_t (*)(const char *))*a1)("\n");
  *(_DWORD *)(a4 + 24) = 0;
  return result;
}

uint64_t _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj58298EEKPFPNS_11OpaqueValueESB_SB_PKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_@<X0>(void (**a1)(const char *, ...)@<X0>, const char *a2@<X2>, void **a3@<X3>, uint64_t a4@<X8>)
{
  if (*a3) {
    int v6 = *a3;
  }
  else {
    int v6 = 0;
  }
  (*a1)("    %s: ", a2);
  InProcessReaderWriter::getSymbolInfo<swift::TargetMetadata<swift::InProcess> const>(v6, (uint64_t)v10);
  if (v11 >= 0) {
    MetadataKind v7 = v10;
  }
  else {
    MetadataKind v7 = (void **)v10[0];
  }
  p_p = (const char *)&__p;
  if (v13 < 0) {
    p_p = (const char *)__p;
  }
  (*a1)("%#llx - %s (%s + %llu)", v6, (const char *)v7, p_p, v14);
  if (v13 < 0)
  {
    operator delete(__p);
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_11;
    }
LABEL_13:
    operator delete(v10[0]);
    goto LABEL_11;
  }
  if (v11 < 0) {
    goto LABEL_13;
  }
LABEL_11:
  uint64_t result = ((uint64_t (*)(const char *))*a1)("\n");
  *(_DWORD *)(a4 + 24) = 0;
  return result;
}

uint64_t _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj34641EEKPFPNS_11OpaqueValueESB_SB_PKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_@<X0>(void (**a1)(const char *, ...)@<X0>, const char *a2@<X2>, void **a3@<X3>, uint64_t a4@<X8>)
{
  if (*a3) {
    int v6 = *a3;
  }
  else {
    int v6 = 0;
  }
  (*a1)("    %s: ", a2);
  InProcessReaderWriter::getSymbolInfo<swift::TargetMetadata<swift::InProcess> const>(v6, (uint64_t)v10);
  if (v11 >= 0) {
    MetadataKind v7 = v10;
  }
  else {
    MetadataKind v7 = (void **)v10[0];
  }
  p_p = (const char *)&__p;
  if (v13 < 0) {
    p_p = (const char *)__p;
  }
  (*a1)("%#llx - %s (%s + %llu)", v6, (const char *)v7, p_p, v14);
  if (v13 < 0)
  {
    operator delete(__p);
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_11;
    }
LABEL_13:
    operator delete(v10[0]);
    goto LABEL_11;
  }
  if (v11 < 0) {
    goto LABEL_13;
  }
LABEL_11:
  uint64_t result = ((uint64_t (*)(const char *))*a1)("\n");
  *(_DWORD *)(a4 + 24) = 0;
  return result;
}

uint64_t _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj18648EEKPFPNS_11OpaqueValueESB_SB_PKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_@<X0>(void (**a1)(const char *, ...)@<X0>, const char *a2@<X2>, void **a3@<X3>, uint64_t a4@<X8>)
{
  if (*a3) {
    int v6 = *a3;
  }
  else {
    int v6 = 0;
  }
  (*a1)("    %s: ", a2);
  InProcessReaderWriter::getSymbolInfo<swift::TargetMetadata<swift::InProcess> const>(v6, (uint64_t)v10);
  if (v11 >= 0) {
    MetadataKind v7 = v10;
  }
  else {
    MetadataKind v7 = (void **)v10[0];
  }
  p_p = (const char *)&__p;
  if (v13 < 0) {
    p_p = (const char *)__p;
  }
  (*a1)("%#llx - %s (%s + %llu)", v6, (const char *)v7, p_p, v14);
  if (v13 < 0)
  {
    operator delete(__p);
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_11;
    }
LABEL_13:
    operator delete(v10[0]);
    goto LABEL_11;
  }
  if (v11 < 0) {
    goto LABEL_13;
  }
LABEL_11:
  uint64_t result = ((uint64_t (*)(const char *))*a1)("\n");
  *(_DWORD *)(a4 + 24) = 0;
  return result;
}

uint64_t _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj61402EEKPFPNS_11OpaqueValueESB_SB_PKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_@<X0>(void (**a1)(const char *, ...)@<X0>, const char *a2@<X2>, void **a3@<X3>, uint64_t a4@<X8>)
{
  if (*a3) {
    int v6 = *a3;
  }
  else {
    int v6 = 0;
  }
  (*a1)("    %s: ", a2);
  InProcessReaderWriter::getSymbolInfo<swift::TargetMetadata<swift::InProcess> const>(v6, (uint64_t)v10);
  if (v11 >= 0) {
    MetadataKind v7 = v10;
  }
  else {
    MetadataKind v7 = (void **)v10[0];
  }
  p_p = (const char *)&__p;
  if (v13 < 0) {
    p_p = (const char *)__p;
  }
  (*a1)("%#llx - %s (%s + %llu)", v6, (const char *)v7, p_p, v14);
  if (v13 < 0)
  {
    operator delete(__p);
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_11;
    }
LABEL_13:
    operator delete(v10[0]);
    goto LABEL_11;
  }
  if (v11 < 0) {
    goto LABEL_13;
  }
LABEL_11:
  uint64_t result = ((uint64_t (*)(const char *))*a1)("\n");
  *(_DWORD *)(a4 + 24) = 0;
  return result;
}

uint64_t _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj24816EEKPFjPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISE_EEEES5_PT_@<X0>(void (**a1)(const char *, ...)@<X0>, const char *a2@<X2>, void **a3@<X3>, uint64_t a4@<X8>)
{
  if (*a3) {
    int v6 = *a3;
  }
  else {
    int v6 = 0;
  }
  (*a1)("    %s: ", a2);
  InProcessReaderWriter::getSymbolInfo<swift::TargetMetadata<swift::InProcess> const>(v6, (uint64_t)v10);
  if (v11 >= 0) {
    MetadataKind v7 = v10;
  }
  else {
    MetadataKind v7 = (void **)v10[0];
  }
  p_p = (const char *)&__p;
  if (v13 < 0) {
    p_p = (const char *)__p;
  }
  (*a1)("%#llx - %s (%s + %llu)", v6, (const char *)v7, p_p, v14);
  if (v13 < 0)
  {
    operator delete(__p);
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_11;
    }
LABEL_13:
    operator delete(v10[0]);
    goto LABEL_11;
  }
  if (v11 < 0) {
    goto LABEL_13;
  }
LABEL_11:
  uint64_t result = ((uint64_t (*)(const char *))*a1)("\n");
  *(_DWORD *)(a4 + 24) = 0;
  return result;
}

uint64_t _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj41169EEKPFvPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_@<X0>(void (**a1)(const char *, ...)@<X0>, const char *a2@<X2>, void **a3@<X3>, uint64_t a4@<X8>)
{
  if (*a3) {
    int v6 = *a3;
  }
  else {
    int v6 = 0;
  }
  (*a1)("    %s: ", a2);
  InProcessReaderWriter::getSymbolInfo<swift::TargetMetadata<swift::InProcess> const>(v6, (uint64_t)v10);
  if (v11 >= 0) {
    MetadataKind v7 = v10;
  }
  else {
    MetadataKind v7 = (void **)v10[0];
  }
  p_p = (const char *)&__p;
  if (v13 < 0) {
    p_p = (const char *)__p;
  }
  (*a1)("%#llx - %s (%s + %llu)", v6, (const char *)v7, p_p, v14);
  if (v13 < 0)
  {
    operator delete(__p);
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_11;
    }
LABEL_13:
    operator delete(v10[0]);
    goto LABEL_11;
  }
  if (v11 < 0) {
    goto LABEL_13;
  }
LABEL_11:
  uint64_t result = ((uint64_t (*)(const char *))*a1)("\n");
  *(_DWORD *)(a4 + 24) = 0;
  return result;
}

uint64_t _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj41909EEKPFjPKNS_11OpaqueValueEPKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISE_EEEES5_PT_@<X0>(void (**a1)(const char *, ...)@<X0>, const char *a2@<X2>, void **a3@<X3>, uint64_t a4@<X8>)
{
  if (*a3) {
    int v6 = *a3;
  }
  else {
    int v6 = 0;
  }
  (*a1)("    %s: ", a2);
  InProcessReaderWriter::getSymbolInfo<swift::TargetMetadata<swift::InProcess> const>(v6, (uint64_t)v10);
  if (v11 >= 0) {
    MetadataKind v7 = v10;
  }
  else {
    MetadataKind v7 = (void **)v10[0];
  }
  p_p = (const char *)&__p;
  if (v13 < 0) {
    p_p = (const char *)__p;
  }
  (*a1)("%#llx - %s (%s + %llu)", v6, (const char *)v7, p_p, v14);
  if (v13 < 0)
  {
    operator delete(__p);
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_11;
    }
LABEL_13:
    operator delete(v10[0]);
    goto LABEL_11;
  }
  if (v11 < 0) {
    goto LABEL_13;
  }
LABEL_11:
  uint64_t result = ((uint64_t (*)(const char *))*a1)("\n");
  *(_DWORD *)(a4 + 24) = 0;
  return result;
}

uint64_t _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj1053EEKPFvPNS_11OpaqueValueEPKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_@<X0>(void (**a1)(const char *, ...)@<X0>, const char *a2@<X2>, void **a3@<X3>, uint64_t a4@<X8>)
{
  if (*a3) {
    int v6 = *a3;
  }
  else {
    int v6 = 0;
  }
  (*a1)("    %s: ", a2);
  InProcessReaderWriter::getSymbolInfo<swift::TargetMetadata<swift::InProcess> const>(v6, (uint64_t)v10);
  if (v11 >= 0) {
    MetadataKind v7 = v10;
  }
  else {
    MetadataKind v7 = (void **)v10[0];
  }
  p_p = (const char *)&__p;
  if (v13 < 0) {
    p_p = (const char *)__p;
  }
  (*a1)("%#llx - %s (%s + %llu)", v6, (const char *)v7, p_p, v14);
  if (v13 < 0)
  {
    operator delete(__p);
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_11;
    }
LABEL_13:
    operator delete(v10[0]);
    goto LABEL_11;
  }
  if (v11 < 0) {
    goto LABEL_13;
  }
LABEL_11:
  uint64_t result = ((uint64_t (*)(const char *))*a1)("\n");
  *(_DWORD *)(a4 + 24) = 0;
  return result;
}

uint64_t _ZN5swift22GenericMetadataBuilderI21InProcessReaderWriterE6DumperIPFvPKczEE20dumpVWTFunctionFieldIU9__ptrauthILj0ELb1ELj45796EEKPFvPNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEEEEENS_14BuilderErrorOrINSt3__19monostateEEENS1_6BufferIKNS_23TargetValueWitnessTableISD_EEEES5_PT_@<X0>(void (**a1)(const char *, ...)@<X0>, const char *a2@<X2>, void **a3@<X3>, uint64_t a4@<X8>)
{
  if (*a3) {
    int v6 = *a3;
  }
  else {
    int v6 = 0;
  }
  (*a1)("    %s: ", a2);
  InProcessReaderWriter::getSymbolInfo<swift::TargetMetadata<swift::InProcess> const>(v6, (uint64_t)v10);
  if (v11 >= 0) {
    MetadataKind v7 = v10;
  }
  else {
    MetadataKind v7 = (void **)v10[0];
  }
  p_p = (const char *)&__p;
  if (v13 < 0) {
    p_p = (const char *)__p;
  }
  (*a1)("%#llx - %s (%s + %llu)", v6, (const char *)v7, p_p, v14);
  if (v13 < 0)
  {
    operator delete(__p);
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_11;
    }
LABEL_13:
    operator delete(v10[0]);
    goto LABEL_11;
  }
  if (v11 < 0) {
    goto LABEL_13;
  }
LABEL_11:
  uint64_t result = ((uint64_t (*)(const char *))*a1)("\n");
  *(_DWORD *)(a4 + 24) = 0;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN21InProcessReaderWriter6BufferIKcEEN5swift12BuilderErrorEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSF_1EJSB_SD_EEEEEEDcSH_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

swift::BuilderError *swift::BuilderError::BuilderError(swift::BuilderError *this, const char *__format, ...)
{
  va_start(va, __format);
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  int v4 = vsnprintf(0, 0, __format, va);
  if (v4 < 0) {
    goto LABEL_6;
  }
  size_t v5 = (v4 + 1);
  int v6 = (char *)malloc_type_malloc(v5, 0x887381A9uLL);
  if (!v6) {
    goto LABEL_6;
  }
  MetadataKind v7 = v6;
  if (vsnprintf(v6, v5, __format, va) < 0)
  {
    free(v7);
LABEL_6:
    size_t v8 = 0;
    MetadataKind v7 = "<could not create error string>";
    goto LABEL_7;
  }
  size_t v8 = v7;
LABEL_7:
  MEMORY[0x1852FEF20](this, v7);
  free(v8);
  return this;
}

uint64_t swift::GenericMetadataBuilder<InProcessReaderWriter>::Dumper<void (*)(char const*,...)>::printPointer<swift::TargetValueTypeDescriptor<swift::InProcess> const>(void (**a1)(const char *, ...), const char *a2, const void *a3, const char *a4)
{
  (*a1)("%s", a2);
  InProcessReaderWriter::getSymbolInfo<swift::TargetValueTypeDescriptor<swift::InProcess> const>(a3, (uint64_t)v11);
  if (a3) {
    MetadataKind v7 = a3;
  }
  else {
    MetadataKind v7 = 0;
  }
  if (v12 >= 0) {
    size_t v8 = v11;
  }
  else {
    size_t v8 = (void **)v11[0];
  }
  p_p = (const char *)&__p;
  if (v14 < 0) {
    p_p = (const char *)__p;
  }
  (*a1)("%#llx - %s (%s + %llu)", v7, (const char *)v8, p_p, v15);
  if (v14 < 0)
  {
    operator delete(__p);
    if ((v12 & 0x80000000) == 0) {
      return ((uint64_t (*)(const char *, ...))*a1)("%s", a4);
    }
LABEL_13:
    operator delete(v11[0]);
    return ((uint64_t (*)(const char *, ...))*a1)("%s", a4);
  }
  if (v12 < 0) {
    goto LABEL_13;
  }
  return ((uint64_t (*)(const char *, ...))*a1)("%s", a4);
}

size_t InProcessReaderWriter::getSymbolInfo<swift::TargetValueTypeDescriptor<swift::InProcess> const>@<X0>(const void *a1@<X1>, uint64_t a2@<X8>)
{
  if (a1) {
    int v4 = a1;
  }
  else {
    int v4 = 0;
  }
  size_t result = dladdr(v4, &__s);
  if (!result)
  {
    strcpy((char *)(a2 + 23), "\t<unknown>");
    strcpy((char *)a2, "<unknown>");
    *(unsigned char *)(a2 + 47) = 9;
    *(void *)(a2 + 48) = 0;
    return result;
  }
  dli_fname = (char *)__s.dli_fname;
  if (__s.dli_fname)
  {
    dli_sname = __s.dli_sname;
    if (__s.dli_sname) {
      goto LABEL_7;
    }
  }
  else
  {
    dli_fname = "<unknown>";
    __s.dli_fname = "<unknown>";
    dli_sname = __s.dli_sname;
    if (__s.dli_sname) {
      goto LABEL_7;
    }
  }
  dli_sname = "<unknown>";
  __s.dli_sname = "<unknown>";
LABEL_7:
  size_t v8 = strrchr(dli_fname, 47);
  if (v8) {
    dli_fname = v8 + 1;
  }
  size_t v9 = strlen(dli_sname);
  if (v9 > 0x7FFFFFFFFFFFFFF7) {
LABEL_31:
  }
    abort();
  size_t v10 = v9;
  if (v9 >= 0x17)
  {
    uint64_t v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17) {
      uint64_t v12 = v9 | 7;
    }
    uint64_t v13 = v12 + 1;
    char v11 = operator new(v12 + 1);
    *(void *)(a2 + 8) = v10;
    *(void *)(a2 + 16) = v13 | 0x8000000000000000;
    *(void *)a2 = v11;
    goto LABEL_17;
  }
  *(unsigned char *)(a2 + 23) = v9;
  char v11 = (void *)a2;
  if (v9) {
LABEL_17:
  }
    memmove(v11, dli_sname, v10);
  *((unsigned char *)v11 + v1swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
  size_t result = strlen(dli_fname);
  if (result > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_31;
  }
  size_t v14 = result;
  if (result >= 0x17)
  {
    uint64_t v17 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17) {
      uint64_t v17 = result | 7;
    }
    uint64_t v18 = v17 + 1;
    uint64_t v15 = operator new(v17 + 1);
    *(void *)(a2 + 32) = v14;
    *(void *)(a2 + 4swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v18 | 0x8000000000000000;
    *(void *)(a2 + 24) = v15;
LABEL_26:
    size_t result = (size_t)memmove(v15, dli_fname, v14);
    v15[v14] = 0;
    if (a1) {
      goto LABEL_22;
    }
LABEL_27:
    uint64_t v16 = 0;
    goto LABEL_28;
  }
  uint64_t v15 = (unsigned char *)(a2 + 24);
  *(unsigned char *)(a2 + 47) = result;
  if (result) {
    goto LABEL_26;
  }
  unsigned char *v15 = 0;
  if (!a1) {
    goto LABEL_27;
  }
LABEL_22:
  uint64_t v16 = a1;
LABEL_28:
  *(void *)(a2 + 48) = v16 - (char *)__s.dli_fbase;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN21InProcessReaderWriter6BufferIKN5swift14TargetMetadataINSA_9InProcessEEEEENSA_12BuilderErrorEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSI_1EJSF_SG_EEEEEEDcSK_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN21InProcessReaderWriter6BufferIKN5swift25TargetValueTypeDescriptorINSA_9InProcessEEEEENSA_12BuilderErrorEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSI_1EJSF_SG_EEEEEEDcSK_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN21InProcessReaderWriter6BufferIKN5swift23TargetValueWitnessTableINSA_9InProcessEEEEENSA_12BuilderErrorEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSI_1EJSF_SG_EEEEEEDcSK_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEN5swift12BuilderErrorEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSC_1EJS8_SA_EEEEEEDcSE_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

void swift::GenericMetadataBuilder<InProcessReaderWriter>::extraDataSize(InProcessReaderWriter **a1@<X0>, int *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  if (a2) {
    size_t v8 = a2;
  }
  else {
    size_t v8 = 0;
  }
  size_t v9 = (char *)v8 + v8[2] + 8;
  if (!v9) {
    size_t v9 = "<unknown>";
  }
  InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 835, "extraDataSize", "Getting extra data size for %s", v9);
  int v10 = *a2;
  if (a2 && (*a2 & 0x1Fu) - 19 >= 0xFFFFFFFE)
  {
    if (*(unsigned char *)(a3 + 8))
    {
      unint64_t v12 = 8 * (*(unsigned __int16 *)(a3 + 22) + (unint64_t)*(unsigned __int16 *)(a3 + 20));
      InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 853, "extraDataSize", "Value type descriptor has extra data pattern, extra data size: %zu");
      goto LABEL_14;
    }
    if ((*a2 & 0x1F) == 0x12)
    {
      if (HIBYTE(a2[5]))
      {
        unint64_t v12 = (((unint64_t)a2[5] >> 21) & 0x7F8) - 16;
        InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 890, "extraDataSize", "Enum descriptor has payload size offset, computed extra data size: %zu");
        goto LABEL_14;
      }
      if ((v10 & 0x80) != 0)
      {
        unint64_t v12 = 8 * *((unsigned __int16 *)a2 + 20);
        InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 899, "extraDataSize", "Enum descriptor has no payload size offset, computed extra data size from generic arguments, extra data size: %zu");
        goto LABEL_14;
      }
    }
    else if ((*a2 & 0x1F) == 0x11)
    {
      uint64_t v11 = a2[6];
      if (v11)
      {
        unint64_t v12 = (8 * v11 + 4 * a2[5] - 9) & 0xFFFFFFFFFFFFFFF8;
        InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 869, "extraDataSize", "Struct descriptor has field offset vector, computed extra data size: %zu");
LABEL_14:
        *(void *)a4 = v12;
        *(_DWORD *)(a4 + 24) = 0;
        return;
      }
      if ((v10 & 0x80) != 0)
      {
        unint64_t v12 = 8 * *((unsigned __int16 *)a2 + 20);
        InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 878, "extraDataSize", "Struct descriptor has no field offset vector, computed extra data size from generic arguments, extra data size: %zu");
        goto LABEL_14;
      }
    }
  }
  swift::BuilderError::BuilderError((swift::BuilderError *)__p, "Unable to compute extra data size of descriptor with kind %u", *a2 & 0x1F);
  if (SHIBYTE(v15) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)a4, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
    int v13 = SHIBYTE(v15);
    *(_DWORD *)(a4 + 24) = 1;
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(_OWORD *)a4 = *(_OWORD *)__p;
    *(void *)(a4 + 16) = v15;
    *(_DWORD *)(a4 + 24) = 1;
  }
}

InProcessReaderWriter **swift::GenericMetadataBuilder<InProcessReaderWriter>::GenericMetadataBuilder(InProcessReaderWriter **a1, InProcessReaderWriter *a2)
{
  *a1 = a2;
  uint64_t v4 = (uint64_t)(a1 + 29);
  InProcessReaderWriter::getSymbolPointer<char>(a2, "_swift_pod_copy", (uint64_t)(a1 + 1));
  InProcessReaderWriter::getSymbolPointer<char>(a2, "_swift_pod_destroy", (uint64_t)(a1 + 5));
  InProcessReaderWriter::getSymbolPointer<char>(a2, "_swift_pod_direct_initializeBufferWithCopyOfBuffer", (uint64_t)(a1 + 9));
  InProcessReaderWriter::getSymbolPointer<char>(a2, "_swift_pod_indirect_initializeBufferWithCopyOfBuffer", (uint64_t)(a1 + 13));
  InProcessReaderWriter::getSymbolPointer<char>(a2, "$sBi8_WV", (uint64_t)(a1 + 17));
  InProcessReaderWriter::getSymbolPointer<char>(a2, "$sBi16_WV", (uint64_t)(a1 + 21));
  InProcessReaderWriter::getSymbolPointer<char>(a2, "$sBi32_WV", (uint64_t)(a1 + 25));
  InProcessReaderWriter::getSymbolPointer<char>(a2, "$sBi64_WV", v4);
  InProcessReaderWriter::getSymbolPointer<char>(a2, "$sBi128_WV", (uint64_t)(a1 + 33));
  InProcessReaderWriter::getSymbolPointer<char>(a2, "$sBi256_WV", (uint64_t)(a1 + 37));
  InProcessReaderWriter::getSymbolPointer<char>(a2, "$sBi512_WV", (uint64_t)(a1 + 41));
  return a1;
}

void InProcessReaderWriter::getSymbolPointer<char>(InProcessReaderWriter *a1@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = dlsym((void *)0xFFFFFFFFFFFFFFFDLL, a2);
  InProcessReaderWriter::log(a1, "GenericMetadataBuilder.cpp", 233, "getSymbolPointer", "getSymbolPointer(\"%s\") -> %p", a2, v6);
  if (v6)
  {
    *(void *)a3 = v6;
    *(_DWORD *)(a3 + 24) = 0;
  }
  else
  {
    swift::BuilderError::BuilderError((swift::BuilderError *)__p, "dlsym could not find symbol '%s'", a2);
    if (SHIBYTE(v9) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)a3, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
      int v7 = SHIBYTE(v9);
      *(_DWORD *)(a3 + 24) = 1;
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      *(_OWORD *)a3 = *(_OWORD *)__p;
      *(void *)(a3 + 16) = v9;
      *(_DWORD *)(a3 + 24) = 1;
    }
  }
}

void InProcessReaderWriter::log(InProcessReaderWriter *this, const char *a2, int a3, const char *a4, const char *a5, ...)
{
  va_start(va, a5);
  if (swift::runtime::environment::initializeToken != -1) {
    dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
  }
  if (swift::runtime::environment::SWIFT_DEBUG_VALIDATE_EXTERNAL_GENERIC_METADATA_BUILDER_variable >= 2u)
  {
    uint64_t v9 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s:%u:%s: ", a2, a3, a4);
    vfprintf(*v9, a5, va);
    fputs("\n", *v9);
  }
}

unsigned int *swift::GenericMetadataBuilder<InProcessReaderWriter>::~GenericMetadataBuilder(unsigned int *a1)
{
  uint64_t v2 = a1[88];
  if (v2 != -1) {
    ((void (*)(char *, unsigned int *))off_1ECA043C8[v2])(&v14, a1 + 82);
  }
  a1[88] = -1;
  uint64_t v3 = a1[80];
  if (v3 != -1) {
    ((void (*)(char *, unsigned int *))off_1ECA043C8[v3])(&v15, a1 + 74);
  }
  a1[80] = -1;
  uint64_t v4 = a1[72];
  if (v4 != -1) {
    ((void (*)(char *, unsigned int *))off_1ECA043C8[v4])(&v16, a1 + 66);
  }
  a1[72] = -1;
  uint64_t v5 = a1[64];
  if (v5 != -1) {
    ((void (*)(char *, unsigned int *))off_1ECA043C8[v5])(&v17, a1 + 58);
  }
  a1[64] = -1;
  uint64_t v6 = a1[56];
  if (v6 != -1) {
    ((void (*)(char *, unsigned int *))off_1ECA043C8[v6])(&v18, a1 + 50);
  }
  a1[56] = -1;
  uint64_t v7 = a1[48];
  if (v7 != -1) {
    ((void (*)(char *, unsigned int *))off_1ECA043C8[v7])(&v19, a1 + 42);
  }
  a1[48] = -1;
  uint64_t v8 = a1[40];
  if (v8 != -1) {
    ((void (*)(char *, unsigned int *))off_1ECA043C8[v8])(&v20, a1 + 34);
  }
  a1[40] = -1;
  uint64_t v9 = a1[32];
  if (v9 != -1) {
    ((void (*)(char *, unsigned int *))off_1ECA04398[v9])(&v21, a1 + 26);
  }
  a1[32] = -1;
  uint64_t v10 = a1[24];
  if (v10 != -1) {
    ((void (*)(char *, unsigned int *))off_1ECA04398[v10])(&v22, a1 + 18);
  }
  a1[24] = -1;
  uint64_t v11 = a1[16];
  if (v11 != -1) {
    ((void (*)(char *, unsigned int *))off_1ECA04398[v11])(&v23, a1 + 10);
  }
  a1[16] = -1;
  uint64_t v12 = a1[8];
  if (v12 != -1) {
    ((void (*)(char *, unsigned int *))off_1ECA04398[v12])(&v24, a1 + 2);
  }
  a1[8] = -1;
  return a1;
}

void swift::GenericMetadataBuilder<InProcessReaderWriter>::buildGenericValueMetadata(InProcessReaderWriter **a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  size_t v13 = a6 + 32;
  InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 424, "buildGenericValueMetadata", "Extra data size is %zu, allocating %zu bytes total", a6, a6 + 32);
  __int16 v26 = 18;
  char v14 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v26, v13, 8);
  swift::GenericMetadataBuilder<InProcessReaderWriter>::initializeValueMetadataFromPattern(a1, (uint64_t)v14, 16, (unint64_t)a2, a5, (uint64_t)&v26);
  if (v29)
  {
    if (v29 == 1) {
      char v15 = &v26;
    }
    else {
      char v15 = 0;
    }
    uint64_t v16 = (uint64_t)&v28;
    if (v29 != 1) {
      uint64_t v16 = 23;
    }
    if (*(char *)v16 < 0)
    {
      uint64_t v20 = 8;
      if (v29 == 1) {
        uint64_t v20 = (uint64_t)&v27;
      }
      std::string::__init_copy_ctor_external((std::string *)a7, *(const std::string::value_type **)v15, *(void *)v20);
    }
    else
    {
      *(_OWORD *)a7 = *(_OWORD *)v15;
      *(void *)(a7 + 16) = *((void *)v15 + 2);
    }
    *(_DWORD *)(a7 + 24) = 1;
    goto LABEL_27;
  }
  swift::GenericMetadataBuilder<InProcessReaderWriter>::installGenericArguments(a1, (uint64_t)v14, 16, a2, a3, a4, (uint64_t)v22);
  int v17 = v25;
  if (!v25)
  {
    *(void *)a7 = v14;
    *(void *)(a7 + 8) = v13;
    *(void *)(a7 + 16) = 16;
    *(_DWORD *)(a7 + 24) = 0;
LABEL_26:
    ((void (*)(char *, unsigned char *))off_1ECA043D8[v17])(&v30, v22);
    goto LABEL_27;
  }
  if (v25 == 1) {
    char v18 = v22;
  }
  else {
    char v18 = 0;
  }
  uint64_t v19 = (uint64_t)&v24;
  if (v25 != 1) {
    uint64_t v19 = 23;
  }
  if (*(char *)v19 < 0)
  {
    uint64_t v21 = 8;
    if (v25 == 1) {
      uint64_t v21 = (uint64_t)&v23;
    }
    std::string::__init_copy_ctor_external((std::string *)a7, *(const std::string::value_type **)v18, *(void *)v21);
    int v17 = v25;
  }
  else
  {
    *(_OWORD *)a7 = *(_OWORD *)v18;
    *(void *)(a7 + 16) = *((void *)v18 + 2);
  }
  *(_DWORD *)(a7 + 24) = 1;
  if (v17 != -1) {
    goto LABEL_26;
  }
LABEL_27:
  if (v29 != -1) {
    ((void (*)(unsigned char *, __int16 *))off_1ECA043D8[v29])(v22, &v26);
  }
}

void swift::GenericMetadataBuilder<InProcessReaderWriter>::initializeValueMetadataFromPattern(InProcessReaderWriter **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  uint64_t v10 = (unint64_t *)(a2 + a3);
  if ((*(unsigned char *)(a5 + 8) & 1) == 0) {
    goto LABEL_11;
  }
  bzero(v10 + 2, 8 * *(unsigned __int16 *)(a5 + 20));
  InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 289, "initializeValueMetadataFromPattern", "Writing %hu words of extra data from offset %hu", *(unsigned __int16 *)(a5 + 22), *(unsigned __int16 *)(a5 + 20));
  uint64_t v13 = *(int *)(a5 + 16);
  uint64_t v14 = *(unsigned __int16 *)(a5 + 22);
  uint64_t v15 = v13 ? v13 + a5 + 16 : 0;
  if (!*(_WORD *)(a5 + 22)) {
    goto LABEL_11;
  }
  uint64_t v16 = *(unsigned __int16 *)(a5 + 20);
  if (v14 >= 0xA && (unint64_t)(a2 + a3 + 8 * v16 - v15 + 16) >= 0x20)
  {
    uint64_t v17 = (unsigned __int16)v14 & 0xFFFC;
    __int16 v26 = (long long *)(v15 + 16);
    uint64_t v27 = (_OWORD *)(a3 + 8 * v16 + a2 + 32);
    uint64_t v28 = v17;
    do
    {
      long long v29 = *v26;
      *(v27 - 1) = *(v26 - 1);
      *uint64_t v27 = v29;
      v26 += 2;
      v27 += 2;
      v28 -= 4;
    }
    while (v28);
    if (v17 == v14) {
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  char v18 = (void *)(a3 + 8 * (v17 + v16) + a2 + 16);
  uint64_t v19 = (uint64_t *)(v15 + 8 * v17);
  uint64_t v20 = v14 - v17;
  do
  {
    uint64_t v21 = *v19++;
    *v18++ = v21;
    --v20;
  }
  while (v20);
LABEL_11:
  uint64_t v22 = *(int *)(a5 + 12);
  if (!v22) {
    goto LABEL_17;
  }
  uint64_t v23 = (void *)((v22 & 0xFFFFFFFFFFFFFFFELL) + a5 + 12);
  if ((v22 & 1) == 0) {
    goto LABEL_15;
  }
  if (!*v23)
  {
LABEL_17:
    InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 314, "initializeValueMetadataFromPattern", "Setting initial value witnesses");
    goto LABEL_18;
  }
  uint64_t v23 = (void *)*v23;
LABEL_15:
  InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 314, "initializeValueMetadataFromPattern", "Setting initial value witnesses");
  if (v23)
  {
    char v24 = v23;
    goto LABEL_19;
  }
LABEL_18:
  char v24 = 0;
LABEL_19:
  *(v10 - 1) = (unint64_t)v24;
  InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 322, "initializeValueMetadataFromPattern", "Setting metadata kind %#x", *(_DWORD *)(a5 + 8) >> 21);
  *uint64_t v10 = (unint64_t)*(unsigned int *)(a5 + 8) >> 21;
  InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 326, "initializeValueMetadataFromPattern", "Setting descriptor");
  if (a4) {
    unint64_t v25 = a4;
  }
  else {
    unint64_t v25 = 0;
  }
  v10[1] = v25;
  *(_DWORD *)(a6 + 24) = 0;
}

void swift::GenericMetadataBuilder<InProcessReaderWriter>::installGenericArguments(InProcessReaderWriter **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, _DWORD *a4@<X4>, uint64_t a5@<X5>, unint64_t a6@<X6>, uint64_t a7@<X8>)
{
  uint64_t v14 = (char *)a4 + a4[2] + 8;
  if (!v14) {
    uint64_t v14 = "<unknown>";
  }
  InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 343, "installGenericArguments", "Building %s", v14);
  uint64_t GenericContext = swift::TargetContextDescriptor<swift::InProcess>::getGenericContext(a4);
  uint64_t v16 = GenericContext;
  if (a4) {
    uint64_t v17 = a4;
  }
  else {
    uint64_t v17 = 0;
  }
  int v18 = *v17 & 0x1F;
  if ((!v17 || v18 != 18) && (!v17 || v18 != 17)) {
    goto LABEL_34;
  }
  unint64_t v19 = *(unsigned __int16 *)(GenericContext + 8);
  if (a6 >= v19)
  {
    if (a4) {
      uint64_t v20 = a4;
    }
    else {
      uint64_t v20 = 0;
    }
    int v22 = *v20 & 0x1F;
    if (v20 && v22 == 18 || v20 && v22 == 17)
    {
      InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 362, "installGenericArguments", "Installing %hu generic arguments at offset %d", v19, 2);
      uint64_t v23 = *(unsigned __int16 *)(v16 + 8);
      if (*(_WORD *)(v16 + 8))
      {
        if (v23 >= 8 && (unint64_t)(a2 + a3 - a5 + 16) >= 0x20)
        {
          uint64_t v24 = (unsigned __int16)v23 & 0xFFFC;
          long long v29 = (_OWORD *)(a3 + a2 + 32);
          char v30 = (long long *)(a5 + 16);
          uint64_t v31 = v24;
          do
          {
            long long v32 = *v30;
            *(v29 - 1) = *(v30 - 1);
            *long long v29 = v32;
            v29 += 2;
            v30 += 2;
            v31 -= 4;
          }
          while (v31);
          if (v24 == v23) {
            goto LABEL_28;
          }
        }
        else
        {
          uint64_t v24 = 0;
        }
        unint64_t v25 = (void *)(a3 + a2 + 8 * v24 + 16);
        __int16 v26 = (uint64_t *)(a5 + 8 * v24);
        uint64_t v27 = v23 - v24;
        do
        {
          uint64_t v28 = *v26++;
          *v25++ = v28;
          --v27;
        }
        while (v27);
      }
LABEL_28:
      *(_DWORD *)(a7 + 24) = 0;
      return;
    }
LABEL_34:
    abort();
  }
  swift::BuilderError::BuilderError((swift::BuilderError *)__p, "Not enough generic arguments, %zu provided, %d required", a6, v19);
  if (SHIBYTE(v34) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)a7, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
    int v21 = SHIBYTE(v34);
    *(_DWORD *)(a7 + 24) = 1;
    if (v21 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(_OWORD *)a7 = *(_OWORD *)__p;
    *(void *)(a7 + 16) = v34;
    *(_DWORD *)(a7 + 24) = 1;
  }
}

uint64_t swift::BuilderErrorOr<std::monostate>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 24);
  uint64_t v4 = *(unsigned int *)(a2 + 24);
  if (v3 == -1)
  {
    if (v4 == -1) {
      return a1;
    }
LABEL_5:
    uint64_t v6 = a1;
    ((void (*)(uint64_t *, uint64_t, uint64_t))off_1ECA043E8[v4])(&v6, a1, a2);
    return a1;
  }
  if (v4 != -1) {
    goto LABEL_5;
  }
  ((void (*)(char *, uint64_t, uint64_t))off_1ECA043D8[v3])(&v7, a1, a2);
  *(_DWORD *)(a1 + 24) = -1;
  return a1;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEN5swift12BuilderErrorEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISB_LNS0_6_TraitE1EEEEEvOT_EUlRSH_OT0_E_JRNS0_6__baseILSF_1EJS8_SA_EEEOSP_EEEDcSH_DpT0_(uint64_t result)
{
  uint64_t v1 = *(void *)result;
  uint64_t v2 = *(unsigned int *)(*(void *)result + 24);
  if (v2 != -1)
  {
    if (!v2) {
      return result;
    }
    size_t result = ((uint64_t (*)(char *, uint64_t))off_1ECA043D8[v2])(&v3, v1);
  }
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEN5swift12BuilderErrorEEEEE16__generic_assignB8nn180100INS0_17__move_assignmentISB_LNS0_6_TraitE1EEEEEvOT_EUlRSH_OT0_E_JRNS0_6__baseILSF_1EJS8_SA_EEEOSP_EEEDcSH_DpT0_(__n128 **a1, uint64_t a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = (*a1)[1].n128_u32[2];
  if (v5 == -1) {
    goto LABEL_7;
  }
  if (v5 != 1)
  {
    ((void (*)(char *, __n128 *))off_1ECA043D8[v5])(&v8, v4);
LABEL_7:
    v4[1].n128_u32[2] = -1;
    __n128 result = *a3;
    v4[1].n128_u64[0] = a3[1].n128_u64[0];
    __n128 *v4 = result;
    a3->n128_u64[1] = 0;
    a3[1].n128_u64[0] = 0;
    a3->n128_u64[0] = 0;
    v4[1].n128_u32[2] = 1;
    return result;
  }
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  __n128 result = *a3;
  *(void *)(a2 + 16) = a3[1].n128_u64[0];
  *(__n128 *)a2 = result;
  a3[1].n128_u8[7] = 0;
  a3->n128_u8[0] = 0;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN5swift22GenericMetadataBuilderI21InProcessReaderWriterE19ConstructedMetadataENS8_12BuilderErrorEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSF_1EJSC_SD_EEEEEEDcSH_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

void swift::GenericMetadataBuilder<InProcessReaderWriter>::initializeGenericMetadata(InProcessReaderWriter **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = (uint64_t *)(a2 + 16);
  if (a2) {
    uint64_t v5 = a2 + 16;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2)
  {
    if (*(void *)v5 <= 0x7FFuLL && *(void *)v5 - 515 > 0xFFFFFFFC)
    {
      FullGenericContextHeader = swift::TargetTypeContextDescriptor<swift::InProcess>::getFullGenericContextHeader(*(_DWORD **)(v5 + 8));
      uint64_t v10 = (int)FullGenericContextHeader[1];
      if (v10) {
        uint64_t v11 = (char *)FullGenericContextHeader + v10 + 4;
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t v12 = *((int *)v11 + 1);
      uint64_t v13 = &v11[v12 + 4];
      if (v12) {
        BOOL v14 = v13 == 0;
      }
      else {
        BOOL v14 = 1;
      }
      if (v14)
      {
        __p[0] = 0;
        int v31 = 0;
      }
      else
      {
        __p[0] = v13;
        int v31 = 0;
        if (v13)
        {
          unint64_t v16 = *(void *)v5;
          if (*(void *)v5 == 512)
          {
            swift::GenericMetadataBuilder<InProcessReaderWriter>::initializeStructMetadata(a1, a2, v5, &v27);
            int v17 = v28;
            if (v28)
            {
              if (v28 == 1) {
                int v18 = &v27;
              }
              else {
                int v18 = 0;
              }
              uint64_t v19 = (uint64_t)&v27.__r_.__value_.__r.__words[2] + 7;
              if (v28 != 1) {
                uint64_t v19 = 23;
              }
              if (*(char *)v19 < 0)
              {
                uint64_t v20 = (const std::string::value_type *)v18->__r_.__value_.__r.__words[0];
LABEL_59:
                BOOL v14 = v17 == 1;
                p_std::string::size_type size = (std::string::size_type *)8;
                if (v14) {
                  p_std::string::size_type size = &v27.__r_.__value_.__l.__size_;
                }
                std::string::__init_copy_ctor_external((std::string *)a3, v20, *p_size);
                int v17 = v28;
                goto LABEL_62;
              }
              goto LABEL_56;
            }
            goto LABEL_57;
          }
          if (v16 > 0x7FF || (v16 - 515) < 0xFFFFFFFE)
          {
            uint64_t v23 = *v4;
            if ((unint64_t)*v4 > 0x7FF) {
              LODWORD(v23) = 0;
            }
            swift::BuilderError::BuilderError((swift::BuilderError *)&v27, "Don't know how to initialize metadata kind %#x", v23);
            if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
            {
              std::string::__init_copy_ctor_external((std::string *)a3, v27.__r_.__value_.__l.__data_, v27.__r_.__value_.__l.__size_);
              int v24 = SHIBYTE(v27.__r_.__value_.__r.__words[2]);
              *(_DWORD *)(a3 + 24) = 1;
              if (v24 < 0) {
                operator delete(v27.__r_.__value_.__l.__data_);
              }
            }
            else
            {
              *(std::string *)a3 = v27;
              *(_DWORD *)(a3 + 24) = 1;
            }
            goto LABEL_64;
          }
          InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 825, "initializeEnumMetadata", "Initializing enum");
          swift::BuilderError::BuilderError((swift::BuilderError *)&v32, "Don't know how to initialize enum metadata yet");
          if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
          {
            std::string::__init_copy_ctor_external(&v27, v32.__r_.__value_.__l.__data_, v32.__r_.__value_.__l.__size_);
            int v28 = 1;
            if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v32.__r_.__value_.__l.__data_);
              int v17 = v28;
              if (!v28)
              {
LABEL_57:
                int v21 = 0;
                *(_DWORD *)(a3 + 24) = 0;
                goto LABEL_65;
              }
            }
            else
            {
              int v17 = 1;
            }
          }
          else
          {
            std::string v27 = v32;
            int v28 = 1;
            int v17 = 1;
          }
          if (v17 == 1) {
            int v18 = &v27;
          }
          else {
            int v18 = 0;
          }
          uint64_t v25 = (uint64_t)&v27.__r_.__value_.__r.__words[2] + 7;
          if (v17 != 1) {
            uint64_t v25 = 23;
          }
          if (*(char *)v25 < 0)
          {
            uint64_t v20 = (const std::string::value_type *)v18->__r_.__value_.__r.__words[0];
            goto LABEL_59;
          }
LABEL_56:
          *(_OWORD *)a3 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
          *(void *)(a3 + 16) = *((void *)&v18->__r_.__value_.__l + 2);
LABEL_62:
          *(_DWORD *)(a3 + 24) = 1;
          if (v17 != -1) {
            ((void (*)(std::string *, std::string *))off_1ECA043D8[v17])(&v32, &v27);
          }
LABEL_64:
          int v21 = 0;
          goto LABEL_65;
        }
      }
      InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 471, "initializeGenericMetadata", "Type has no completion function, skipping initialization");
      *(_DWORD *)(a3 + 24) = 0;
      int v21 = v31;
      if (v31 == -1) {
        return;
      }
LABEL_65:
      ((void (*)(std::string *, void **))off_1ECA04398[v21])(&v27, __p);
      return;
    }
  }
  uint64_t v15 = *v4;
  if ((unint64_t)*v4 > 0x7FF) {
    LODWORD(v15) = 0;
  }
  swift::BuilderError::BuilderError((swift::BuilderError *)__p, "Don't know how to initialize metadata kind %#x", v15);
  if (SHIBYTE(v30) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)a3, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
    int v22 = SHIBYTE(v30);
    *(_DWORD *)(a3 + 24) = 1;
    if (v22 < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(_OWORD *)a3 = *(_OWORD *)__p;
    *(void *)(a3 + 16) = v30;
    *(_DWORD *)(a3 + 24) = 1;
  }
}

void swift::GenericMetadataBuilder<InProcessReaderWriter>::initializeStructMetadata(InProcessReaderWriter **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, std::string *a4@<X8>)
{
  uint64_t v5 = a1;
  InProcessReaderWriter::log(*a1, "GenericMetadataBuilder.h", 675, "initializeStructMetadata", "Initializing struct");
  uint64_t v7 = *(void *)(a3 + 8);
  if (v7)
  {
    v93[0] = *(void *)(a3 + 8);
    int v94 = 0;
    uint64_t v8 = v7;
  }
  else
  {
    uint64_t v8 = 0;
    v93[0] = 0;
    int v94 = 0;
  }
  uint64_t v10 = v8 + 16;
  uint64_t v9 = *(int *)(v8 + 16);
  if (v9) {
    uint64_t v11 = v8 + 16 + v9;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v12 = *(unsigned int *)(v11 + 12);
  InProcessReaderWriter::log(*v5, "GenericMetadataBuilder.h", 690, "initializeStructMetadata", "%zu fields", v12);
  *(void *)&long long v91 = 0;
  if (!v12)
  {
    int v39 = 0;
    unint64_t v37 = 0;
    unsigned int v42 = 0;
    unint64_t v38 = 0;
    int v40 = 0;
LABEL_49:
    int v43 = 0;
    int v44 = 0;
LABEL_53:
    LODWORD(v92) = v39 | v43 | v40 | v44;
    HIDWORD(v92) = v42;
    unint64_t v45 = (v38 + v37) & ~v38;
    if (v45 <= 1) {
      unint64_t v45 = 1;
    }
    *((void *)&v91 + 1) = v45;
    if (*(void *)(a3 - 8)) {
      int v46 = *(uint64_t **)(a3 - 8);
    }
    else {
      int v46 = 0;
    }
    InProcessReaderWriter::getSymbolInfo<swift::TargetMetadata<swift::InProcess> const>(v46, (uint64_t)&__p);
    if (v81 >= 0) {
      p_p = (const char *)&__p;
    }
    else {
      p_p = (const char *)__p;
    }
    int v48 = (const char *)&v82;
    if (v83 < 0) {
      int v48 = (const char *)v82;
    }
    InProcessReaderWriter::log(*v5, "GenericMetadataBuilder.h", 776, "initializeStructMetadata", "Initializing new VWT from old VWT %#llx - %s (%s + %llu)", v46, p_p, v48, v84);
    if (v83 < 0)
    {
      operator delete(v82);
      if ((v81 & 0x80000000) == 0)
      {
LABEL_66:
        LOWORD(__p) = 18;
        uint64_t v49 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&__p, 0x58uLL, 8);
        *(void *)uint64_t v49 = *v46;
        unint64_t v50 = v46 + 1;
        *((void *)v49 + 1) = v46[1];
        long long v51 = v46 + 2;
        *((void *)v49 + 2) = v46[2];
        char v52 = v46 + 3;
        *((void *)v49 + 3) = v46[3];
        int v53 = v46 + 4;
        *((void *)v49 + 4) = v46[4];
        int v54 = v46 + 5;
        *((void *)v49 + 5) = v46[5];
        uint64_t v55 = v46 + 6;
        *((void *)v49 + 6) = v46[6];
        long long v56 = v46 + 7;
        *((void *)v49 + 7) = v46[7];
        long long v57 = *((_OWORD *)v46 + 4);
        *((void *)v49 + 1swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v46[10];
        *((_OWORD *)v49 + 4) = v57;
        if (*v46) {
          uint64_t v58 = *v46;
        }
        else {
          uint64_t v58 = 0;
        }
        *(void *)uint64_t v49 = v58;
        if (*v50) {
          uint64_t v59 = *v50;
        }
        else {
          uint64_t v59 = 0;
        }
        *((void *)v49 + 1) = v59;
        if (*v51) {
          uint64_t v60 = *v51;
        }
        else {
          uint64_t v60 = 0;
        }
        *((void *)v49 + 2) = v60;
        if (*v52) {
          uint64_t v61 = *v52;
        }
        else {
          uint64_t v61 = 0;
        }
        *((void *)v49 + 3) = v61;
        if (*v53) {
          uint64_t v62 = *v53;
        }
        else {
          uint64_t v62 = 0;
        }
        *((void *)v49 + 4) = v62;
        if (*v54) {
          uint64_t v63 = *v54;
        }
        else {
          uint64_t v63 = 0;
        }
        *((void *)v49 + 5) = v63;
        if (*v55) {
          uint64_t v64 = *v55;
        }
        else {
          uint64_t v64 = 0;
        }
        *((void *)v49 + 6) = v64;
        if (*v56) {
          uint64_t v65 = *v56;
        }
        else {
          uint64_t v65 = 0;
        }
        *((void *)v49 + 7) = v65;
        swift::GenericMetadataBuilder<InProcessReaderWriter>::installCommonValueWitnesses((uint64_t)v5, (uint64_t)&v91, v49, (uint64_t)&__p);
        int v66 = (int)v82;
        if (v82)
        {
          if (v82 == 1) {
            unsigned __int8 v67 = &__p;
          }
          else {
            unsigned __int8 v67 = 0;
          }
          uint64_t v68 = (uint64_t)&v81;
          if (v82 != 1) {
            uint64_t v68 = 23;
          }
          if (*(char *)v68 < 0)
          {
            uint64_t v69 = 8;
            if (v82 == 1) {
              uint64_t v69 = (uint64_t)&v80;
            }
            std::string::__init_copy_ctor_external(a4, (const std::string::value_type *)*v67, *(void *)v69);
            int v66 = (int)v82;
          }
          else
          {
            *(_OWORD *)&a4->__r_.__value_.__l.__data_ = *(_OWORD *)v67;
            a4->__r_.__value_.__r.__words[2] = (std::string::size_type)v67[2];
          }
          LODWORD(a4[1].__r_.__value_.__l.__data_) = 1;
          if (v66 == -1) {
            goto LABEL_106;
          }
        }
        else
        {
          *((_OWORD *)v49 + 4) = v91;
          *((void *)v49 + 1swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v92;
          int v66 = 0;
          *(void *)(a2 + 8) = v49;
          LODWORD(a4[1].__r_.__value_.__l.__data_) = 0;
        }
        ((void (*)(void *, void **))off_1ECA043D8[v66])(v89, &__p);
        goto LABEL_106;
      }
    }
    else if ((v81 & 0x80000000) == 0)
    {
      goto LABEL_66;
    }
    operator delete(__p);
    goto LABEL_66;
  }
  unint64_t v76 = 0;
  unint64_t v77 = v5;
  uint64_t v14 = 0;
  unint64_t v75 = 0;
  uint64_t v71 = a3 + 8 * *(unsigned int *)(v10 + 8);
  uint64_t v70 = a3;
  uint64_t v15 = v11 + 20;
  unint64_t v16 = (int *)(v11 + 24);
  unsigned int v72 = 0;
  char v73 = 1;
  char v74 = 1;
  int v17 = v5;
  while (1)
  {
    int v18 = a4;
    uint64_t v19 = *v16;
    uint64_t v20 = v19 ? (void *)(v15 + v19 + 4) : 0;
    std::string __p = v20;
    LODWORD(v82) = 0;
    uint64_t v21 = *(v16 - 1);
    int v22 = v21 ? (unsigned char *)(v15 + v21) : 0;
    v89[0] = v22;
    int v90 = 0;
    SymbolicMangledNameStringRef = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef(v22, v13);
    unint64_t v25 = v24;
    InProcessReaderWriter::log(*v17, "GenericMetadataBuilder.h", 720, "initializeStructMetadata", "Examining field %u '%s' type '%.*s' (mangled name is %zu bytes)", v14, (const char *)__p, v24, SymbolicMangledNameStringRef, v24);
    InProcessReaderWriter::getTypeByMangledName((uint64_t)*v17, a2, (unsigned __int8 *)SymbolicMangledNameStringRef, v25, (uint64_t)&v85);
    int v26 = v88;
    if (v88)
    {
      std::string v27 = (const void **)&v85;
      if (v88 != 1) {
        std::string v27 = 0;
      }
      uint64_t v28 = (uint64_t)&v87;
      if (v88 != 1) {
        uint64_t v28 = 23;
      }
      if (*(char *)v28 < 0)
      {
        char v35 = (const std::string::value_type *)*v27;
        uint64_t v36 = (uint64_t)&v86;
        if (v88 != 1) {
          uint64_t v36 = 8;
        }
        a4 = v18;
        std::string::__init_copy_ctor_external(v18, v35, *(void *)v36);
      }
      else
      {
        a4 = v18;
        *(_OWORD *)&v18->__r_.__value_.__l.__data_ = *(_OWORD *)v27;
        v18->__r_.__value_.__r.__words[2] = (std::string::size_type)v27[2];
      }
      LODWORD(a4[1].__r_.__value_.__l.__data_) = 1;
    }
    else
    {
      long long v29 = v85;
      InProcessReaderWriter::log(*v17, "GenericMetadataBuilder.h", 727, "initializeStructMetadata", "Looked up field type metadata %p", v85);
      uint64_t v30 = *(v29 - 1);
      a4 = v18;
      unint64_t v31 = v75;
      unint64_t v32 = (v76 + *(unsigned __int8 *)(v30 + 80)) & ~(unint64_t)*(unsigned __int8 *)(v30 + 80);
      *(_DWORD *)(v71 + 4 * v14) = v32;
      unint64_t v76 = v32 + *(void *)(v30 + 64);
      int v33 = *(_DWORD *)(v30 + 80);
      if (v75 <= v33) {
        unint64_t v31 = *(_DWORD *)(v30 + 80);
      }
      unint64_t v75 = v31;
      v73 &= (v33 & 0x10000) == 0;
      v74 &= (v33 & 0x100000) == 0;
      unsigned int v34 = v72;
      if (*(_DWORD *)(v30 + 84) > v72) {
        unsigned int v34 = *(_DWORD *)(v30 + 84);
      }
      unsigned int v72 = v34;
    }
    if (v88 != -1) {
      ((void (*)(char *, void **))off_1ECA043A8[v88])(v95, &v85);
    }
    if (v90 != -1) {
      ((void (*)(void **, void *))off_1ECA04398[v90])(&v85, v89);
    }
    if (v82 != -1) {
      ((void (*)(void *, void **))off_1ECA04398[v82])(v89, &__p);
    }
    if (v26) {
      break;
    }
    v16 += 3;
    ++v14;
    v15 += 12;
    if (v12 == v14)
    {
      unint64_t v38 = v75;
      unint64_t v37 = v76;
      *(void *)&long long v91 = v76;
      int v39 = v75 & 0xFFECFFFF;
      if (v73) {
        int v40 = 0;
      }
      else {
        int v40 = 0x10000;
      }
      if (v74)
      {
        if (v76 < 0x19 && v75 < 8)
        {
          uint64_t v5 = v77;
          a3 = v70;
          unsigned int v42 = v72;
          goto LABEL_49;
        }
        int v43 = 0;
        int v44 = 0x20000;
      }
      else
      {
        int v44 = 0x20000;
        int v43 = 0x100000;
      }
      uint64_t v5 = v77;
      a3 = v70;
      unsigned int v42 = v72;
      goto LABEL_53;
    }
  }
LABEL_106:
  if (v94 != -1) {
    ((void (*)(void **, uint64_t *))off_1ECA043B8[v94])(&__p, v93);
  }
}

void InProcessReaderWriter::getTypeByMangledName(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned __int8 *a3@<X4>, unint64_t a4@<X5>, uint64_t a5@<X8>)
{
  uint64_t v10 = (unint64_t *)(a2 + 16);
  if (a2) {
    uint64_t v11 = (unint64_t *)(a2 + 16);
  }
  else {
    uint64_t v11 = 0;
  }
  int v21 = 0;
  uint64_t TypeContextDescriptor = swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(v11);
  if (TypeContextDescriptor)
  {
    uint64_t v22 = TypeContextDescriptor;
    if (a2)
    {
LABEL_6:
      GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(v10);
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v22 = 0;
    if (a2) {
      goto LABEL_6;
    }
  }
  GenericArgs = 0;
LABEL_9:
  uint64_t v23 = GenericArgs;
  unint64_t v24 = v26;
  uint64_t v25 = 0x800000000;
  v26[32] = 0;
  v17[0] = &unk_1ECA04418;
  v17[1] = &v21;
  v17[2] = a1;
  int v18 = v17;
  v15[0] = &unk_1ECA04460;
  v15[1] = &v21;
  v15[2] = a1;
  unint64_t v16 = v15;
  swift_getTypeByMangledName(63, a3, a4, (uint64_t)GenericArgs, v17, v15, (uint64_t)v19);
  if (v16 == v15)
  {
    (*(void (**)(void *))(v15[0] + 32))(v15);
  }
  else if (v16)
  {
    (*(void (**)(void))(*v16 + 40))();
  }
  if (v18 == v17)
  {
    (*(void (**)(void *))(v17[0] + 32))(v17);
  }
  else if (v18)
  {
    (*(void (**)(void))(*v18 + 40))();
  }
  if (v20 == 1)
  {
    swift::BuilderErrorOr<InProcessReaderWriter::Buffer<swift::TargetMetadata<swift::InProcess> const>>::BuilderErrorOr(a5, v19);
    if (v20 == 1) {
      ((void (*)(void, uint64_t, void))v19[1])(v19[0], 3, 0);
    }
  }
  else
  {
    if (v20) {
      uint64_t v14 = 0;
    }
    else {
      uint64_t v14 = v19[0];
    }
    *(void *)a5 = v14;
    *(_DWORD *)(a5 + 24) = 0;
  }
  if (v24 != v26) {
    free(v24);
  }
}

void swift::GenericMetadataBuilder<InProcessReaderWriter>::installCommonValueWitnesses(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  int v7 = *(_DWORD *)(a2 + 16);
  if ((v7 & 0x10000) != 0)
  {
    if ((v7 & 0x100000) != 0) {
      goto LABEL_64;
    }
    InProcessReaderWriter::log(*(InProcessReaderWriter **)a1, "GenericMetadataBuilder.h", 658, "installCommonValueWitnesses", "Is bitwise takable, setting pod_copy as initializeWithTake");
    uint64_t v15 = (void *)(a1 + 8);
    int v14 = *(_DWORD *)(a1 + 32);
    if (!v14)
    {
      a3[4] = *v15;
      goto LABEL_64;
    }
    goto LABEL_31;
  }
  int v9 = *(_DWORD *)(a2 + 20);
  uint64_t v10 = v9 != 0;
  uint64_t v11 = *(InProcessReaderWriter **)a1;
  if (v9) {
    uint64_t v12 = "true";
  }
  else {
    uint64_t v12 = "false";
  }
  InProcessReaderWriter::log(v11, "GenericMetadataBuilder.h", 534, "installCommonValueWitnesses", "type isPOD, hasExtraInhabitants=%s layout.size=%zu flags.getAlignmentMask=%zu", v12, *(void *)a2, *(_DWORD *)(a2 + 16));
  uint64_t v13 = (v10 << 48) | (*(void *)a2 << 16) | v7;
  if (v13 <= 524294)
  {
    switch(v13)
    {
      case 65536:
        InProcessReaderWriter::log(*(InProcessReaderWriter **)a1, "GenericMetadataBuilder.h", 589, "installCommonValueWitnesses", "case sizeWithAlignmentMask(1, 0, 0)");
        int v14 = *(_DWORD *)(a1 + 160);
        if (!v14)
        {
          uint64_t v19 = *(uint64_t **)(a1 + 136);
          goto LABEL_56;
        }
        uint64_t v15 = (void *)(a1 + 136);
        break;
      case 131073:
        int v14 = *(_DWORD *)(a1 + 192);
        if (!v14)
        {
          InProcessReaderWriter::log(*(InProcessReaderWriter **)a1, "GenericMetadataBuilder.h", 600, "installCommonValueWitnesses", "case sizeWithAlignmentMask(2, 1, 0)");
          uint64_t v19 = *(uint64_t **)(a1 + 168);
          goto LABEL_56;
        }
        uint64_t v15 = (void *)(a1 + 168);
        break;
      case 262147:
        int v14 = *(_DWORD *)(a1 + 224);
        if (!v14)
        {
          InProcessReaderWriter::log(*(InProcessReaderWriter **)a1, "GenericMetadataBuilder.h", 609, "installCommonValueWitnesses", "case sizeWithAlignmentMask(4, 3, 0)");
          uint64_t v19 = *(uint64_t **)(a1 + 200);
          goto LABEL_56;
        }
        uint64_t v15 = (void *)(a1 + 200);
        break;
      default:
        goto LABEL_38;
    }
    goto LABEL_31;
  }
  if (v13 > 2097182)
  {
    if (v13 == 2097183)
    {
      int v14 = *(_DWORD *)(a1 + 320);
      if (!v14)
      {
        InProcessReaderWriter::log(*(InProcessReaderWriter **)a1, "GenericMetadataBuilder.h", 636, "installCommonValueWitnesses", "case sizeWithAlignmentMask(32, 31, 0)");
        uint64_t v19 = *(uint64_t **)(a1 + 296);
        goto LABEL_56;
      }
      uint64_t v15 = (void *)(a1 + 296);
    }
    else
    {
      if (v13 != 4194367) {
        goto LABEL_38;
      }
      int v14 = *(_DWORD *)(a1 + 352);
      if (!v14)
      {
        InProcessReaderWriter::log(*(InProcessReaderWriter **)a1, "GenericMetadataBuilder.h", 645, "installCommonValueWitnesses", "case sizeWithAlignmentMask(64, 63, 0)");
        uint64_t v19 = *(uint64_t **)(a1 + 328);
        goto LABEL_56;
      }
      uint64_t v15 = (void *)(a1 + 328);
    }
LABEL_31:
    if (v14 == 1) {
      unint64_t v16 = v15;
    }
    else {
      unint64_t v16 = 0;
    }
    goto LABEL_34;
  }
  if (v13 == 524295)
  {
    int v14 = *(_DWORD *)(a1 + 256);
    if (!v14)
    {
      InProcessReaderWriter::log(*(InProcessReaderWriter **)a1, "GenericMetadataBuilder.h", 618, "installCommonValueWitnesses", "case sizeWithAlignmentMask(8, 7, 0)");
      uint64_t v19 = *(uint64_t **)(a1 + 232);
      goto LABEL_56;
    }
    uint64_t v15 = (void *)(a1 + 232);
    goto LABEL_31;
  }
  if (v13 == 1048591)
  {
    int v14 = *(_DWORD *)(a1 + 288);
    if (v14)
    {
      uint64_t v15 = (void *)(a1 + 264);
      goto LABEL_31;
    }
    InProcessReaderWriter::log(*(InProcessReaderWriter **)a1, "GenericMetadataBuilder.h", 627, "installCommonValueWitnesses", "case sizeWithAlignmentMask(16, 15, 0)");
    uint64_t v19 = *(uint64_t **)(a1 + 264);
LABEL_56:
    swift::GenericMetadataBuilder<InProcessReaderWriter>::copyVWT(a3, v19, (uint64_t)v32);
    int v20 = v35;
    if (v35)
    {
      if (v35 == 1) {
        int v21 = v32;
      }
      else {
        int v21 = 0;
      }
      uint64_t v22 = (uint64_t)&v34;
      if (v35 != 1) {
        uint64_t v22 = 23;
      }
      if (*(char *)v22 < 0)
      {
        uint64_t v23 = 8;
        if (v35 == 1) {
          uint64_t v23 = (uint64_t)v33;
        }
        std::string::__init_copy_ctor_external((std::string *)a4, *(const std::string::value_type **)v21, *(void *)v23);
        int v20 = v35;
      }
      else
      {
        *(_OWORD *)a4 = *(_OWORD *)v21;
        *(void *)(a4 + 16) = *((void *)v21 + 2);
      }
      *(_DWORD *)(a4 + 24) = 1;
      if (v20 != -1) {
        goto LABEL_70;
      }
      return;
    }
LABEL_64:
    *(_DWORD *)(a4 + 24) = 0;
    return;
  }
LABEL_38:
  if ((v7 & 0x20000) != 0) {
    int v17 = "false";
  }
  else {
    int v17 = "true";
  }
  InProcessReaderWriter::log(*(InProcessReaderWriter **)a1, "GenericMetadataBuilder.h", 541, "installCommonValueWitnesses", "Uncommon layout case, flags.isInlineStorage=%s", v17);
  if ((v7 & 0x20000) != 0)
  {
    unint64_t v16 = (void *)(a1 + 104);
    int v18 = *(_DWORD *)(a1 + 128);
    if (v18) {
      goto LABEL_46;
    }
  }
  else
  {
    unint64_t v16 = (void *)(a1 + 72);
    int v18 = *(_DWORD *)(a1 + 96);
    if (v18) {
      goto LABEL_46;
    }
  }
  *a3 = *v16;
  unint64_t v16 = (void *)(a1 + 40);
  int v18 = *(_DWORD *)(a1 + 64);
  if (v18)
  {
LABEL_46:
    if (v18 != 1) {
      unint64_t v16 = 0;
    }
    goto LABEL_34;
  }
  unint64_t v24 = (void *)(a1 + 8);
  int v25 = *(_DWORD *)(a1 + 32);
  if (v25)
  {
    if (v25 == 1) {
      unint64_t v16 = (void *)(a1 + 8);
    }
    else {
      unint64_t v16 = 0;
    }
LABEL_34:
    if (*((char *)v16 + 23) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)a4, (const std::string::value_type *)*v16, v16[1]);
    }
    else
    {
      *(_OWORD *)a4 = *(_OWORD *)v16;
      *(void *)(a4 + 16) = v16[2];
    }
    *(_DWORD *)(a4 + 24) = 1;
    return;
  }
  a3[1] = *v16;
  int v35 = 0;
  a3[2] = *v24;
  int v31 = 0;
  swift::BuilderErrorOr<std::monostate>::operator=((uint64_t)v32, (uint64_t)v30);
  if (v31 != -1) {
    ((void (*)(char *, unsigned char *))off_1ECA043D8[v31])(&v36, v30);
  }
  int v20 = v35;
  if (!v35)
  {
    a3[4] = *v24;
    int v31 = 0;
    swift::BuilderErrorOr<std::monostate>::operator=((uint64_t)v32, (uint64_t)v30);
    if (v31 != -1) {
      ((void (*)(char *, unsigned char *))off_1ECA043D8[v31])(&v36, v30);
    }
    int v20 = v35;
    if (!v35)
    {
      a3[3] = *v24;
      int v31 = 0;
      swift::BuilderErrorOr<std::monostate>::operator=((uint64_t)v32, (uint64_t)v30);
      if (v31 != -1) {
        ((void (*)(char *, unsigned char *))off_1ECA043D8[v31])(&v36, v30);
      }
      int v20 = v35;
      if (!v35)
      {
        a3[5] = *v24;
        int v31 = 0;
        swift::BuilderErrorOr<std::monostate>::operator=((uint64_t)v32, (uint64_t)v30);
        if (v31 != -1) {
          ((void (*)(char *, unsigned char *))off_1ECA043D8[v31])(&v36, v30);
        }
        int v20 = v35;
        if (!v35)
        {
          *(_DWORD *)(a4 + 24) = 0;
LABEL_70:
          ((void (*)(unsigned char *, unsigned char *))off_1ECA043D8[v20])(v30, v32);
          return;
        }
      }
    }
  }
  if (v20 == 1) {
    int v26 = v32;
  }
  else {
    int v26 = 0;
  }
  uint64_t v27 = (uint64_t)&v34;
  if (v20 != 1) {
    uint64_t v27 = 23;
  }
  if (*(char *)v27 < 0)
  {
    BOOL v28 = v20 == 1;
    uint64_t v29 = 8;
    if (v28) {
      uint64_t v29 = (uint64_t)v33;
    }
    std::string::__init_copy_ctor_external((std::string *)a4, *(const std::string::value_type **)v26, *(void *)v29);
  }
  else
  {
    *(_OWORD *)a4 = *(_OWORD *)v26;
    *(void *)(a4 + 16) = *((void *)v26 + 2);
  }
  *(_DWORD *)(a4 + 24) = 1;
  int v20 = v35;
  if (v35 != -1) {
    goto LABEL_70;
  }
}

void std::__function::__func<InProcessReaderWriter::getTypeByMangledName(InProcessReaderWriter::WritableData<swift::FullMetadata<swift::TargetMetadata<swift::InProcess>>>,swift::Demangle::__runtime::Node *,__swift::__runtime::llvm::StringRef)::{lambda(unsigned int,unsigned int)#1},std::allocator<InProcessReaderWriter::getTypeByMangledName(InProcessReaderWriter::WritableData<swift::FullMetadata<swift::TargetMetadata<swift::InProcess>>>,swift::Demangle::__runtime::Node *,__swift::__runtime::llvm::StringRef)::{lambda(unsigned int,unsigned int)#1}>,void const* ()(unsigned int,unsigned int)>::~__func()
{
}

__n128 std::__function::__func<InProcessReaderWriter::getTypeByMangledName(InProcessReaderWriter::WritableData<swift::FullMetadata<swift::TargetMetadata<swift::InProcess>>>,swift::Demangle::__runtime::Node *,__swift::__runtime::llvm::StringRef)::{lambda(unsigned int,unsigned int)#1},std::allocator<InProcessReaderWriter::getTypeByMangledName(InProcessReaderWriter::WritableData<swift::FullMetadata<swift::TargetMetadata<swift::InProcess>>>,swift::Demangle::__runtime::Node *,__swift::__runtime::llvm::StringRef)::{lambda(unsigned int,unsigned int)#1}>,void const* ()(unsigned int,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ECA04418;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<InProcessReaderWriter::getTypeByMangledName(InProcessReaderWriter::WritableData<swift::FullMetadata<swift::TargetMetadata<swift::InProcess>>>,swift::Demangle::__runtime::Node *,__swift::__runtime::llvm::StringRef)::{lambda(unsigned int,unsigned int)#1},std::allocator<InProcessReaderWriter::getTypeByMangledName(InProcessReaderWriter::WritableData<swift::FullMetadata<swift::TargetMetadata<swift::InProcess>>>,swift::Demangle::__runtime::Node *,__swift::__runtime::llvm::StringRef)::{lambda(unsigned int,unsigned int)#1}>,void const* ()(unsigned int,unsigned int)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECA04418;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

const void *std::__function::__func<InProcessReaderWriter::getTypeByMangledName(InProcessReaderWriter::WritableData<swift::FullMetadata<swift::TargetMetadata<swift::InProcess>>>,swift::Demangle::__runtime::Node *,__swift::__runtime::llvm::StringRef)::{lambda(unsigned int,unsigned int)#1},std::allocator<InProcessReaderWriter::getTypeByMangledName(InProcessReaderWriter::WritableData<swift::FullMetadata<swift::TargetMetadata<swift::InProcess>>>,swift::Demangle::__runtime::Node *,__swift::__runtime::llvm::StringRef)::{lambda(unsigned int,unsigned int)#1}>,void const* ()(unsigned int,unsigned int)>::operator()(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *a3;
  uint64_t v5 = *(InProcessReaderWriter **)(a1 + 16);
  Metadata = (const void *)swift::SubstGenericParametersFromMetadata::getMetadata(*(swift::SubstGenericParametersFromMetadata **)(a1 + 8), *a2, *a3);
  InProcessReaderWriter::log(v5, "GenericMetadataBuilder.cpp", 256, "operator()", "substitutions.getMetadata(%u, %u).Ptr = %p", v3, v4, Metadata);
  return Metadata;
}

void std::__function::__func<InProcessReaderWriter::getTypeByMangledName(InProcessReaderWriter::WritableData<swift::FullMetadata<swift::TargetMetadata<swift::InProcess>>>,swift::Demangle::__runtime::Node *,__swift::__runtime::llvm::StringRef)::{lambda(swift::TargetMetadata<swift::InProcess> const*,unsigned int)#1},std::allocator<InProcessReaderWriter::getTypeByMangledName(InProcessReaderWriter::WritableData<swift::FullMetadata<swift::TargetMetadata<swift::InProcess>>>,swift::Demangle::__runtime::Node *,__swift::__runtime::llvm::StringRef)::{lambda(swift::TargetMetadata<swift::InProcess> const*,unsigned int)#1}>,swift::TargetWitnessTable<swift::InProcess> const* ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int)>::~__func()
{
}

__n128 std::__function::__func<InProcessReaderWriter::getTypeByMangledName(InProcessReaderWriter::WritableData<swift::FullMetadata<swift::TargetMetadata<swift::InProcess>>>,swift::Demangle::__runtime::Node *,__swift::__runtime::llvm::StringRef)::{lambda(swift::TargetMetadata<swift::InProcess> const*,unsigned int)#1},std::allocator<InProcessReaderWriter::getTypeByMangledName(InProcessReaderWriter::WritableData<swift::FullMetadata<swift::TargetMetadata<swift::InProcess>>>,swift::Demangle::__runtime::Node *,__swift::__runtime::llvm::StringRef)::{lambda(swift::TargetMetadata<swift::InProcess> const*,unsigned int)#1}>,swift::TargetWitnessTable<swift::InProcess> const* ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ECA04460;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<InProcessReaderWriter::getTypeByMangledName(InProcessReaderWriter::WritableData<swift::FullMetadata<swift::TargetMetadata<swift::InProcess>>>,swift::Demangle::__runtime::Node *,__swift::__runtime::llvm::StringRef)::{lambda(swift::TargetMetadata<swift::InProcess> const*,unsigned int)#1},std::allocator<InProcessReaderWriter::getTypeByMangledName(InProcessReaderWriter::WritableData<swift::FullMetadata<swift::TargetMetadata<swift::InProcess>>>,swift::Demangle::__runtime::Node *,__swift::__runtime::llvm::StringRef)::{lambda(swift::TargetMetadata<swift::InProcess> const*,unsigned int)#1}>,swift::TargetWitnessTable<swift::InProcess> const* ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECA04460;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

const void *std::__function::__func<InProcessReaderWriter::getTypeByMangledName(InProcessReaderWriter::WritableData<swift::FullMetadata<swift::TargetMetadata<swift::InProcess>>>,swift::Demangle::__runtime::Node *,__swift::__runtime::llvm::StringRef)::{lambda(swift::TargetMetadata<swift::InProcess> const*,unsigned int)#1},std::allocator<InProcessReaderWriter::getTypeByMangledName(InProcessReaderWriter::WritableData<swift::FullMetadata<swift::TargetMetadata<swift::InProcess>>>,swift::Demangle::__runtime::Node *,__swift::__runtime::llvm::StringRef)::{lambda(swift::TargetMetadata<swift::InProcess> const*,unsigned int)#1}>,swift::TargetWitnessTable<swift::InProcess> const* ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int)>::operator()(uint64_t a1, uint64_t *a2, int *a3)
{
  unsigned int v3 = (const void *)*a2;
  int v4 = *a3;
  uint64_t v5 = *(InProcessReaderWriter **)(a1 + 16);
  uint64_t WitnessTable = (const void *)swift::SubstGenericParametersFromMetadata::getWitnessTable(*(void *)(a1 + 8), *a2, *a3);
  InProcessReaderWriter::log(v5, "GenericMetadataBuilder.cpp", 262, "operator()", "substitutions.getWitnessTable(%p, %u) = %p", v3, v4, WitnessTable);
  return WitnessTable;
}

uint64_t swift::BuilderErrorOr<InProcessReaderWriter::Buffer<swift::TargetMetadata<swift::InProcess> const>>::BuilderErrorOr(uint64_t a1, void *a2)
{
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  int v4 = (const char *)((uint64_t (*)(void, void, void))a2[1])(*a2, 0, 0);
  size_t v5 = strlen(v4);
  if (v5 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v6 = v5;
  if (v5 >= 0x17)
  {
    uint64_t v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v8 = v5 | 7;
    }
    uint64_t v9 = v8 + 1;
    int v7 = (long long *)operator new(v8 + 1);
    *((void *)&v12 + 1) = v6;
    unint64_t v13 = v9 | 0x8000000000000000;
    *(void *)&long long v12 = v7;
    goto LABEL_8;
  }
  HIBYTE(v13) = v5;
  int v7 = &v12;
  if (v5) {
LABEL_8:
  }
    memmove(v7, v4, v6);
  *((unsigned char *)v7 + v6) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 24);
  if (v10 == -1)
  {
LABEL_15:
    *(_OWORD *)a1 = v12;
    *(void *)(a1 + 16) = v13;
    *(_DWORD *)(a1 + 24) = 1;
    goto LABEL_16;
  }
  if (v10 != 1)
  {
    ((void (*)(char *, uint64_t))off_1ECA043A8[v10])(&v14, a1);
    goto LABEL_15;
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(_OWORD *)a1 = v12;
  *(void *)(a1 + 16) = v13;
LABEL_16:
  ((void (*)(void, uint64_t, const char *))a2[1])(*a2, 1, v4);
  return a1;
}

void swift::GenericMetadataBuilder<InProcessReaderWriter>::copyVWT(void *a1@<X1>, uint64_t *a2@<X3>, uint64_t a3@<X8>)
{
  if (*a2) {
    uint64_t v3 = *a2;
  }
  else {
    uint64_t v3 = 0;
  }
  *a1 = v3;
  if (a2[1])
  {
    int v4 = a1 + 1;
    uint64_t v5 = a2[1];
  }
  else
  {
    uint64_t v5 = 0;
    int v4 = a1 + 1;
  }
  void *v4 = v5;
  if (a2[2])
  {
    size_t v6 = a1 + 2;
    uint64_t v7 = a2[2];
  }
  else
  {
    uint64_t v7 = 0;
    size_t v6 = a1 + 2;
  }
  *size_t v6 = v7;
  if (a2[3])
  {
    uint64_t v8 = a1 + 3;
    uint64_t v9 = a2[3];
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v8 = a1 + 3;
  }
  *uint64_t v8 = v9;
  if (a2[4])
  {
    uint64_t v10 = a1 + 4;
    uint64_t v11 = a2[4];
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v10 = a1 + 4;
  }
  *uint64_t v10 = v11;
  if (a2[5])
  {
    long long v12 = a1 + 5;
    uint64_t v13 = a2[5];
  }
  else
  {
    uint64_t v13 = 0;
    long long v12 = a1 + 5;
  }
  void *v12 = v13;
  if (a2[6])
  {
    char v14 = a1 + 6;
    uint64_t v15 = a2[6];
  }
  else
  {
    uint64_t v15 = 0;
    char v14 = a1 + 6;
  }
  void *v14 = v15;
  if (a2[7])
  {
    unint64_t v16 = a1 + 7;
    uint64_t v17 = a2[7];
  }
  else
  {
    uint64_t v17 = 0;
    unint64_t v16 = a1 + 7;
  }
  void *v16 = v17;
  *(_DWORD *)(a3 + 24) = 0;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJPN5swift19TargetValueMetadataINS8_9InProcessEEENS8_12BuilderErrorEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSF_1EJSC_SD_EEEEEEDcSH_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJmN5swift12BuilderErrorEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSB_1EJmS9_EEEEEEDcSD_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

void *swift_slowAlloc(size_t size, unint64_t a2)
{
  if (a2 > 0xF)
  {
    if (a2 == -1) {
      size_t v3 = 16;
    }
    else {
      size_t v3 = a2 + 1;
    }
    memptr = 0;
    malloc_type_posix_memalign(&memptr, v3, size, 0x15DE84FFuLL);
    __n128 result = memptr;
  }
  else
  {
    __n128 result = malloc_type_malloc(size, 0x69E04FF3uLL);
  }
  if (!result) {
    swift::hashable_support::findHashableBaseTypeOfHashableType();
  }
  return result;
}

void *swift::swift_slowAllocTyped(size_t size, unint64_t a2, malloc_type_id_t type_id)
{
  memptr = 0;
  if (a2 > 0xF)
  {
    if (a2 == -1) {
      size_t v4 = 16;
    }
    else {
      size_t v4 = a2 + 1;
    }
    if (malloc_type_posix_memalign(&memptr, v4, size, type_id))
    {
      memptr = 0;
LABEL_11:
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    __n128 result = memptr;
  }
  else
  {
    __n128 result = malloc_type_malloc(size, type_id);
    memptr = result;
  }
  if (!result) {
    goto LABEL_11;
  }
  return result;
}

void *_swift_allocObject_(unint64_t *a1, size_t a2, unint64_t a3)
{
  unsigned int v61 = HIDWORD(a1) ^ a1;
  atomic_fetch_add_explicit(&MallocTypes, 1u, memory_order_acquire);
  do
  {
    unint64_t explicit = atomic_load_explicit(&qword_1EB1F87F0, memory_order_acquire);
    unint64_t v7 = atomic_load_explicit(&qword_1EB1F87F8, memory_order_acquire);
    unint64_t v8 = atomic_load_explicit(&dword_1EB1F87EC, memory_order_acquire);
  }
  while (explicit != atomic_load_explicit(&qword_1EB1F87F0, memory_order_acquire));
  if (explicit) {
    BOOL v9 = v7 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9 && v8 != 0)
  {
    uint64_t v11 = (malloc_type_id_t *)swift::ConcurrentReadableHashMap<MallocTypeCacheEntry,swift::LazyMutex>::find<unsigned int>(&v61, v7, v8, explicit + 8);
    if (v11)
    {
      malloc_type_id_t v12 = *v11;
      atomic_fetch_add_explicit(&MallocTypes, 0xFFFFFFFF, memory_order_release);
      goto LABEL_76;
    }
  }
  atomic_fetch_add_explicit(&MallocTypes, 0xFFFFFFFF, memory_order_release);
  unint64_t v13 = *a1;
  if (*a1 > 0x7FF) {
    LODWORD(v13) = 0;
  }
  char v14 = a1;
  if (v13)
  {
    if (v13 == 773) {
      char v14 = (unint64_t *)a1[1];
    }
    else {
      char v14 = 0;
    }
  }
  uint64_t v15 = v61;
  uint64_t TypeContextDescriptor = swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a1);
  unsigned int v17 = 0;
  int v18 = 2048;
  if (v14 && TypeContextDescriptor)
  {
    if ((v14[4] & 2) != 0)
    {
      unsigned int v17 = (8 * *((unsigned __int16 *)v14 + 20)) & 0x10;
      uint64_t v19 = *(int *)(TypeContextDescriptor + 16);
      if (v19)
      {
        uint64_t v20 = TypeContextDescriptor + 16 + v19;
        if (v20)
        {
          uint64_t v21 = *(unsigned int *)(v20 + 12);
          if (!v21) {
            goto LABEL_32;
          }
          uint64_t v22 = (int *)(v20 + 16);
          uint64_t v23 = 12 * v21;
          char v24 = 1;
          do
          {
            int v26 = *v22;
            v22 += 3;
            char v25 = v26;
            int v27 = v17 | 4;
            if ((v26 & 2) != 0) {
              int v27 = v17 | 1;
            }
            if (v25)
            {
              char v24 = 0;
              unsigned int v17 = v27;
            }
            v23 -= 12;
          }
          while (v23);
          if ((v24 & 1) == 0) {
            int v28 = 0;
          }
          else {
LABEL_32:
          }
            int v28 = 256;
          unsigned int v17 = v17 & 0xFFFFFEFF | v28;
          int v18 = 2048;
        }
      }
    }
    else
    {
      unsigned int v17 = 0;
      int v18 = 1024;
    }
  }
  unsigned int v62 = v61;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB1F8800);
  uint64_t v29 = qword_1EB1F87F8;
  uint64_t v30 = (unsigned __int8 *)(qword_1EB1F87F8 & 0xFFFFFFFFFFFFFFFCLL);
  BOOL v31 = (qword_1EB1F87F8 & 3) == 0 || v30 == 0;
  size_t v60 = a2;
  uint64_t v59 = v15;
  if (v31) {
    unsigned int v32 = 4;
  }
  else {
    unsigned int v32 = *v30;
  }
  uint64_t v33 = v18 | (v17 << 16);
  unint64_t v34 = dword_1EB1F87EC;
  int v35 = (_DWORD *)qword_1EB1F87F0;
  if (qword_1EB1F87F0) {
    uint64_t v36 = qword_1EB1F87F0 + 8;
  }
  else {
    uint64_t v36 = 0;
  }
  if (!swift::ConcurrentReadableHashMap<MallocTypeCacheEntry,swift::LazyMutex>::find<unsigned int>(&v62, qword_1EB1F87F8, dword_1EB1F87EC, v36))
  {
    uint64_t v58 = (v34 + 1);
    if ((1 << v32) / (unint64_t)((1 << v32) - v58) < 4)
    {
      unsigned int v43 = v37;
      if (!v35) {
        goto LABEL_54;
      }
    }
    else
    {
      uint64_t v29 = swift::ConcurrentReadableHashMap<MallocTypeCacheEntry,swift::LazyMutex>::resize((uint64_t)&MallocTypes, v29, v32, v36);
      swift::ConcurrentReadableHashMap<MallocTypeCacheEntry,swift::LazyMutex>::find<unsigned int>(&v62, v29, v34, v36);
      unsigned int v43 = v42;
      if (!v35) {
        goto LABEL_54;
      }
    }
    unint64_t v44 = (unint64_t)v35;
    if (v34 < *v35)
    {
LABEL_60:
      unint64_t v49 = v44 + 8 * v34;
      uint64_t v38 = v59;
      *(void *)(v49 + 8) = v59 | (v33 << 32);
      atomic_store(v58, (unsigned int *)&dword_1EB1F87EC);
      uint64_t v50 = v43;
      uint64_t v39 = v33;
      a2 = v60;
      switch(v29 & 3)
      {
        case 1:
          unint64_t v51 = v29 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v29 & 3) == 0) {
            unint64_t v51 = 0;
          }
          atomic_store(v58, (unsigned __int8 *)(v51 + v50));
          break;
        case 2:
          unint64_t v52 = v29 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v29 & 3) == 0) {
            unint64_t v52 = 0;
          }
          atomic_store(v58, (unsigned __int16 *)(v52 + 2 * v50));
          break;
        case 3:
          unint64_t v53 = v29 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v29 & 3) == 0) {
            unint64_t v53 = 0;
          }
          atomic_store(v58, (unsigned int *)(v53 + 4 * v50));
          break;
        default:
          atomic_store((v58 << (4 * v50)) | v29, (unint64_t *)&qword_1EB1F87F8);
          break;
      }
      __dmb(0xBu);
      if (MallocTypes) {
        goto LABEL_75;
      }
      int v54 = (void **)qword_1EB1F8808;
      if (qword_1EB1F8808)
      {
        do
        {
          uint64_t v55 = (void **)*v54;
          free(v54[1]);
          free(v54);
          int v54 = v55;
        }
        while (v55);
      }
      goto LABEL_74;
    }
LABEL_54:
    unint64_t v45 = v34 + (v34 >> 2);
    if (v45 <= v34 + 1) {
      unint64_t v45 = v34 + 1;
    }
    size_t v46 = malloc_good_size(8 * v45 + 8);
    int v47 = malloc_type_malloc(v46, 0x1000D770uLL);
    if (!v47) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    unint64_t v44 = (unint64_t)v47;
    *int v47 = (v46 + 0x7FFFFFFF8) >> 3;
    if (v35)
    {
      memcpy(v47 + 2, v35 + 2, 8 * v34);
      int v48 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
      *int v48 = qword_1EB1F8808;
      v48[1] = v35;
      qword_1EB1F8808 = (uint64_t)v48;
    }
    atomic_store(v44, (unint64_t *)&qword_1EB1F87F0);
    goto LABEL_60;
  }
  __dmb(0xBu);
  uint64_t v38 = v59;
  uint64_t v39 = v33;
  if (!MallocTypes)
  {
    int v40 = (void **)qword_1EB1F8808;
    if (qword_1EB1F8808)
    {
      do
      {
        uint64_t v41 = (void **)*v40;
        free(v40[1]);
        free(v40);
        int v40 = v41;
      }
      while (v41);
    }
LABEL_74:
    qword_1EB1F8808 = 0;
  }
LABEL_75:
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB1F8800);
  malloc_type_id_t v12 = v38 | (v39 << 32);
LABEL_76:
  __n128 result = swift::swift_slowAllocTyped(a2, a3, v12);
  if (a1) {
    long long v57 = a1;
  }
  else {
    long long v57 = 0;
  }
  *__n128 result = v57;
  result[1] = 3;
  return result;
}

atomic_ullong *_swift_retain_(atomic_ullong *result)
{
  if ((uint64_t)result >= 1)
  {
    uint64_t v1 = result[1];
    unint64_t v2 = v1 + 0x200000000;
    if (v1 + 0x200000000 < 0)
    {
      uint64_t v3 = result[1];
      if (v1 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(result + 1, v3, 1);
      }
    }
    else
    {
      uint64_t v3 = result[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(result + 1, (unint64_t *)&v3, v2, memory_order_relaxed, memory_order_relaxed);
        if (v3 == v1) {
          break;
        }
        uint64_t v1 = v3;
        unint64_t v2 = v3 + 0x200000000;
        if (v3 + 0x200000000 < 0)
        {
          if (v3 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(result + 1, v3, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

uint64_t _swift_retain_n_(uint64_t a1, uint64_t a2)
{
  if (a1 >= 1)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    if (a2 == 1 || (v4 & 0x80000000FFFFFFFFLL) != 0x80000000FFFFFFFFLL)
    {
      size_t v6 = (atomic_ullong *)(a1 + 8);
      uint64_t v7 = a2 << 33;
      int64_t v8 = v4 + (a2 << 33);
      if (v8 < 0)
      {
        uint64_t v9 = *(void *)(a1 + 8);
        if (v4 != -1) {
LABEL_10:
        }
          swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v6, v9, a2);
      }
      else
      {
        uint64_t v9 = *(void *)(a1 + 8);
        while (1)
        {
          atomic_compare_exchange_strong_explicit(v6, (unint64_t *)&v9, v8, memory_order_relaxed, memory_order_relaxed);
          if (v9 == v4) {
            break;
          }
          uint64_t v4 = v9;
          int64_t v8 = v9 + v7;
          if (v9 + v7 < 0)
          {
            if (v9 == -1) {
              return a1;
            }
            goto LABEL_10;
          }
        }
      }
    }
  }
  return a1;
}

uint64_t _swift_release_(uint64_t result)
{
  if (result >= 1)
  {
    uint64_t v1 = result;
    result += 8;
    uint64_t v2 = *(void *)(v1 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v1 + 8);
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>((atomic_ullong *)result, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = *(void *)(v1 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)result, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>((atomic_ullong *)result, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

uint64_t _swift_release_n_(uint64_t result, uint64_t a2)
{
  if (result >= 1)
  {
    uint64_t v3 = *(void *)(result + 8);
    if (a2 == 1 || (v3 & 0x80000000FFFFFFFFLL) != 0x80000000FFFFFFFFLL)
    {
      result += 8;
      if (a2 < 2 || (v3 & 0x8000000000000000) == 0)
      {
        uint64_t v4 = a2 << 33;
        while (v3 - v4 >= 0)
        {
          uint64_t v5 = v3;
          atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)result, (unint64_t *)&v5, v3 - v4, memory_order_release, memory_order_relaxed);
          if (v5 == v3) {
            return result;
          }
          uint64_t v3 = v5;
          if (a2 >= 2 && v5 < 0) {
            break;
          }
        }
      }
      if (v3 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>((atomic_ullong *)result, v3, a2);
      }
    }
  }
  return result;
}

uint64_t _swift_tryRetain_(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  if (a1 < 1) {
    return 0;
  }
  uint64_t v4 = a1;
  uint64_t v5 = (atomic_ullong *)(a1 + 8);
  uint64_t v6 = *(void *)(v4 + 8);
  if (v6 < 0) {
    goto LABEL_5;
  }
LABEL_3:
  if ((v6 & 0x100000000) != 0) {
    return 0;
  }
  while (v6 + 0x200000000 >= 0)
  {
    uint64_t v7 = v6;
    atomic_compare_exchange_strong_explicit(v5, (unint64_t *)&v7, v6 + 0x200000000, memory_order_relaxed, memory_order_relaxed);
    if (v7 == v6) {
      return v4;
    }
    uint64_t v6 = v7;
    if ((v7 & 0x8000000000000000) == 0) {
      goto LABEL_3;
    }
LABEL_5:
    if ((~v6 & 0x1FFFFFFFFLL) == 0) {
      return 0;
    }
  }
  if (v6 != -1
    && !swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::tryIncrementSlow((swift *)v5, v6, a3, a4))
  {
    return 0;
  }
  return v4;
}

void *swift_allocObject(unint64_t *a1, size_t a2, unint64_t a3)
{
  if ((void *(*)(unint64_t *, size_t, unint64_t))_swift_allocObject[0] == _swift_allocObject_) {
    return _swift_allocObject_(a1, a2, a3);
  }
  if ((_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly & 1) == 0) {
    _swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly = 1;
  }
  return ((void *(*)(unint64_t *, size_t, unint64_t))_swift_allocObject[0])(a1, a2, a3);
}

void *swift_initStackObject(uint64_t a1, void *a2)
{
  if (a1) {
    uint64_t v2 = a1;
  }
  else {
    uint64_t v2 = 0;
  }
  *a2 = v2;
  a2[1] = 5;
  return a2;
}

uint64_t swift_initStaticObject(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 - 8);
  v5[0] = a2;
  v5[1] = a1;
  if (v3 != -1) {
    dispatch_once_f((dispatch_once_t *)(a2 - 8), v5, (dispatch_function_t)swift_initStaticObject::$_0::__invoke);
  }
  return a2;
}

void swift_verifyEndOfLifetime(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  if ((*(void *)(a1 + 8) & 0x8000000000000000) != 0 && *(void *)(a1 + 8) != 0xFFFFFFFFLL)
  {
    _X0 = 0;
    _X1 = 0;
    __asm { CASP            X0, X1, X0, X1, [X8] }
  }
  swift::fatalError(0, "Fatal error: Stack object escaped\n", a3, a4);
}

void *swift_bufferAllocate(unint64_t *a1, size_t a2, unint64_t a3)
{
  if (_swift_allocObject == _swift_allocObject_) {
    return _swift_allocObject_(a1, a2, a3);
  }
  if ((_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly & 1) == 0) {
    _swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly = 1;
  }
  return _swift_allocObject(a1, a2, a3);
}

void *swift_makeBoxUnique(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  if (swift_isUniquelyReferenced_nonNull_native(*a1)) {
    return (void *)v6;
  }
  uint64_t v7 = swift_allocBox(a2);
  if (*(void *)(a2 - 8)) {
    uint64_t v9 = *(void *)(a2 - 8);
  }
  else {
    uint64_t v9 = 0;
  }
  (*(void (**)(uint64_t, uint64_t, unint64_t))(v9 + 16))(v8, v6 + ((a3 + 16) & ~a3), a2);
  *a1 = (uint64_t)v7;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v6);
  }
  else if (v6 >= 1)
  {
    uint64_t v10 = (atomic_ullong *)(v6 + 8);
    uint64_t v11 = *(void *)(v6 + 8);
    unint64_t v12 = v11 - 0x200000000;
    if (v11 - 0x200000000 < 0)
    {
      uint64_t v13 = *(void *)(v6 + 8);
      if (v11 != -1) {
LABEL_13:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v10, v13, 1);
    }
    else
    {
      uint64_t v13 = *(void *)(v6 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v10, (unint64_t *)&v13, v12, memory_order_release, memory_order_relaxed);
        if (v13 == v11) {
          break;
        }
        uint64_t v11 = v13;
        unint64_t v12 = v13 - 0x200000000;
        if (v13 - 0x200000000 < 0)
        {
          if (v13 == -1) {
            return v7;
          }
          goto LABEL_13;
        }
      }
    }
  }
  return v7;
}

void *swift_allocBox(unint64_t a1)
{
  unint64_t v73 = a1;
  unint64_t explicit = atomic_load_explicit(&qword_1EB1F8838, memory_order_acquire);
  if (explicit && *(void *)(explicit + 40) == v73) {
    goto LABEL_109;
  }
  atomic_fetch_add_explicit(&Boxes, 1u, memory_order_acquire);
  do
  {
    unint64_t v2 = atomic_load_explicit(&qword_1EB1F8818, memory_order_acquire);
    unint64_t v3 = atomic_load_explicit(&qword_1EB1F8820, memory_order_acquire);
    unint64_t v4 = atomic_load_explicit(&dword_1EB1F8814, memory_order_acquire);
  }
  while (v2 != atomic_load_explicit(&qword_1EB1F8818, memory_order_acquire));
  if (v2) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5 && v4 != 0)
  {
    if (v7)
    {
      qword_1EB1F8838 = *v7;
      unint64_t explicit = *v7;
      atomic_fetch_add_explicit(&Boxes, 0xFFFFFFFF, memory_order_release);
      goto LABEL_109;
    }
  }
  atomic_fetch_add_explicit(&Boxes, 0xFFFFFFFF, memory_order_release);
  unint64_t v74 = v73;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB1F8828);
  unint64_t v8 = qword_1EB1F8820;
  uint64_t v9 = qword_1EB1F8820 & 3;
  BOOL v10 = v9 == 0;
  if ((qword_1EB1F8820 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
    BOOL v10 = 1;
  }
  BOOL v72 = v10;
  if (v10) {
    int v11 = 4;
  }
  else {
    int v11 = *(unsigned __int8 *)(qword_1EB1F8820 & 0xFFFFFFFFFFFFFFFCLL);
  }
  unint64_t v12 = dword_1EB1F8814;
  uint64_t v13 = (_DWORD *)qword_1EB1F8818;
  if (qword_1EB1F8818) {
    uint64_t v14 = qword_1EB1F8818 + 8;
  }
  else {
    uint64_t v14 = 0;
  }
  if (!v15)
  {
    uint64_t v71 = v14;
    __src = v13 + 2;
    uint64_t v19 = (v12 + 1);
    if ((1 << v11) / (unint64_t)((1 << v11) - v19) < 4)
    {
      unsigned int v26 = v16;
      unint64_t v27 = v8;
      if (!v13) {
        goto LABEL_81;
      }
    }
    else
    {
      uint64_t v69 = v13;
      unsigned int v20 = (v11 + 1);
      if (v20 >= 0x11) {
        unsigned int v21 = 4;
      }
      else {
        unsigned int v21 = 2;
      }
      if (v20 < 9) {
        size_t v22 = 1;
      }
      else {
        size_t v22 = v21;
      }
      unint64_t v23 = (unint64_t)malloc_type_calloc(2 << v11, v22, 0x4269077AuLL);
      if (!v23) {
        swift::hashable_support::findHashableBaseTypeOfHashableType();
      }
      uint64_t v24 = v14;
      char v25 = v11;
      unint64_t v67 = v12;
      uint64_t v68 = (v12 + 1);
      if (v22 != 1)
      {
        if (v22 == 4) {
          size_t v22 = 3;
        }
        else {
          size_t v22 = 2;
        }
      }
      unint64_t v27 = v22 | v23;
      *(unsigned char *)unint64_t v23 = v11 + 1;
      if (v11)
      {
        if (v9) {
          unint64_t v28 = v8 & 0xFFFFFFFFFFFFFFFCLL;
        }
        else {
          unint64_t v28 = 0;
        }
        unint64_t v29 = v27 & 3;
        if ((v27 & 3) != 0) {
          unint64_t v30 = v23 & 0xFFFFFFFFFFFFFFFCLL;
        }
        else {
          unint64_t v30 = 0;
        }
        uint64_t v31 = 1;
        unsigned int v32 = (void *)&unk_1EB1F3000;
        while (2)
        {
          switch(v8 & 3)
          {
            case 0uLL:
              uint64_t v33 = (v8 >> (4 * v31)) & 0xF;
              if (!v33) {
                goto LABEL_50;
              }
              goto LABEL_59;
            case 1uLL:
              LODWORD(v33) = *(unsigned __int8 *)(v28 + v31);
              if (*(unsigned char *)(v28 + v31)) {
                goto LABEL_59;
              }
              goto LABEL_50;
            case 2uLL:
              LODWORD(v33) = *(unsigned __int16 *)(v28 + 2 * v31);
              if (!*(_WORD *)(v28 + 2 * v31)) {
                goto LABEL_50;
              }
              goto LABEL_59;
            case 3uLL:
              LODWORD(v33) = *(_DWORD *)(v28 + 4 * v31);
              if (!v33) {
                goto LABEL_50;
              }
LABEL_59:
              unint64_t v34 = *(void *)(*(void *)(v24 + 8 * (v33 - 1)) + 40);
              {
                unint64_t v65 = v28;
                unint64_t v66 = v29;
                unsigned int v32 = &unk_1EB1F3000;
                unint64_t v28 = v65;
                unint64_t v29 = v66;
                char v25 = v11;
                uint64_t v24 = v71;
                if (v40)
                {
                  unint64_t v41 = __swift::__runtime::llvm::hashing::detail::fixed_seed_override;
                  if (!__swift::__runtime::llvm::hashing::detail::fixed_seed_override) {
                    unint64_t v41 = 0xFF51AFD7ED558CCDLL;
                  }
                  __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed = v41;
                  unsigned int v32 = (void *)&unk_1EB1F3000;
                  unint64_t v28 = v65;
                  unint64_t v29 = v66;
                  char v25 = v11;
                  uint64_t v24 = v71;
                }
              }
              unint64_t v35 = 0x9DDFEA08EB382D69 * ((v32[38] + 8 * v34) ^ HIDWORD(v34));
              unint64_t v36 = 0x9DDFEA08EB382D69 * (HIDWORD(v34) ^ (v35 >> 47) ^ v35);
              for (unint64_t i = 0x9DDFEA08EB382D69 * (v36 ^ (v36 >> 47)); ; unint64_t i = v39 + 1)
              {
                uint64_t v39 = i & ~(-2 << v11);
                if (v39)
                {
                  switch((int)v29)
                  {
                    case 1:
                      LODWORD(v38) = *(unsigned __int8 *)(v30 + v39);
                      break;
                    case 2:
                      LODWORD(v38) = *(unsigned __int16 *)(v30 + 2 * v39);
                      break;
                    case 3:
                      LODWORD(v38) = *(_DWORD *)(v30 + 4 * v39);
                      break;
                    default:
                      uint64_t v38 = (v27 >> (4 * v39)) & 0xF;
                      break;
                  }
                  if (!v38) {
                    break;
                  }
                }
              }
              if (v29 == 3)
              {
                *(_DWORD *)(v30 + 4 * v39) = v33;
              }
              else if (v29 == 2)
              {
                *(_WORD *)(v30 + 2 * v39) = v33;
              }
              else
              {
                *(unsigned char *)(v30 + v39) = v33;
              }
LABEL_50:
              if (!((unint64_t)++v31 >> v25)) {
                continue;
              }
              goto LABEL_77;
            default:
              JUMPOUT(0);
          }
        }
      }
LABEL_77:
      atomic_store(v27, (unint64_t *)&qword_1EB1F8820);
      if (!v72)
      {
        unsigned int v42 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
        uint64_t v24 = v71;
        *unsigned int v42 = qword_1EB1F8830;
        v42[1] = v8 & 0xFFFFFFFFFFFFFFFCLL;
        qword_1EB1F8830 = (uint64_t)v42;
      }
      unint64_t v12 = v67;
      unsigned int v26 = v43;
      uint64_t v19 = v68;
      uint64_t v13 = v69;
      if (!v69) {
        goto LABEL_81;
      }
    }
    unint64_t v44 = (unint64_t)v13;
    if (v12 < *v13)
    {
LABEL_87:
      v75[0] = 1;
      uint64_t v50 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)v75, 0x30uLL, 8);
      unint64_t explicit = (unint64_t)v50;
      unint64_t v51 = v73;
      else {
        unint64_t v52 = 0;
      }
      int v53 = *(unsigned __int8 *)(*(void *)(v73 - 8) + 80);
      *(void *)uint64_t v50 = 0;
      if (v52) {
        int v54 = v52;
      }
      else {
        int v54 = 0;
      }
      *((void *)v50 + 1) = v54;
      *((void *)v50 + 2) = 0;
      *((void *)v50 + 3) = 1280;
      *((_DWORD *)v50 + 8) = (v53 + 16) & ~v53;
      *((void *)v50 + 5) = v51;
      *(void *)(v44 + 8 + 8 * v12) = v50;
      atomic_store(v19, (unsigned int *)&dword_1EB1F8814);
      switch(v26)
      {
        case 1u:
          unint64_t v55 = v27 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v27 & 3) == 0) {
            unint64_t v55 = 0;
          }
          atomic_store(v19, (unsigned __int8 *)(v55 + v26));
          break;
        case 2u:
          unint64_t v56 = v27 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v27 & 3) == 0) {
            unint64_t v56 = 0;
          }
          atomic_store(v19, (unsigned __int16 *)(v56 + 2 * v26));
          break;
        case 3u:
          unint64_t v57 = v27 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v27 & 3) == 0) {
            unint64_t v57 = 0;
          }
          atomic_store(v19, (unsigned int *)(v57 + 4 * v26));
          break;
        default:
          atomic_store((v19 << (4 * v26)) | v27, (unint64_t *)&qword_1EB1F8820);
          break;
      }
      __dmb(0xBu);
      if (Boxes) {
        goto LABEL_108;
      }
      uint64_t v58 = (void **)qword_1EB1F8830;
      if (qword_1EB1F8830)
      {
        do
        {
          uint64_t v59 = (void **)*v58;
          free(v58[1]);
          free(v58);
          uint64_t v58 = v59;
        }
        while (v59);
      }
      goto LABEL_107;
    }
LABEL_81:
    unint64_t v45 = v13;
    unint64_t v46 = v12 + (v12 >> 2);
    if (v46 <= v12 + 1) {
      unint64_t v46 = v12 + 1;
    }
    size_t v47 = malloc_good_size(8 * v46 + 8);
    int v48 = malloc_type_malloc(v47, 0x1000D770uLL);
    if (!v48) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    unint64_t v44 = (unint64_t)v48;
    *int v48 = (v47 + 0x7FFFFFFF8) >> 3;
    if (v45)
    {
      memcpy(v48 + 2, __src, 8 * v12);
      unint64_t v49 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
      *unint64_t v49 = qword_1EB1F8830;
      v49[1] = v45;
      qword_1EB1F8830 = (uint64_t)v49;
    }
    atomic_store(v44, (unint64_t *)&qword_1EB1F8818);
    goto LABEL_87;
  }
  unint64_t explicit = *v15;
  __dmb(0xBu);
  if (!Boxes)
  {
    unsigned int v17 = (void **)qword_1EB1F8830;
    if (qword_1EB1F8830)
    {
      do
      {
        int v18 = (void **)*v17;
        free(v17[1]);
        free(v17);
        unsigned int v17 = v18;
      }
      while (v18);
    }
LABEL_107:
    qword_1EB1F8830 = 0;
  }
LABEL_108:
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB1F8828);
  qword_1EB1F8838 = explicit;
LABEL_109:
  if (explicit) {
    size_t v60 = (unint64_t *)(explicit + 24);
  }
  else {
    size_t v60 = 0;
  }
  uint64_t v61 = *(void *)(*(void *)(explicit + 40) - 8);
  size_t v62 = (*(_DWORD *)(explicit + 32) + *(_DWORD *)(v61 + 64));
  unint64_t v63 = *(_DWORD *)(v61 + 80) & 0xF8 | 7;
  if (_swift_allocObject == _swift_allocObject_) {
    return _swift_allocObject_(v60, v62, v63);
  }
  if ((_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly & 1) == 0) {
    _swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly = 1;
  }
  return _swift_allocObject(v60, v62, v63);
}

uint64_t swift_release(uint64_t result)
{
  uint64_t v1 = result;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_release(result);
  }
  if (result >= 1)
  {
    result += 8;
    uint64_t v2 = *(void *)(v1 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v1 + 8);
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>((atomic_ullong *)result, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = *(void *)(v1 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)result, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>((atomic_ullong *)result, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

void swift_deallocBox(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if ((v1 & 0x80000000FFFFFFFFLL) != 0x80000000FFFFFFFFLL)
  {
    if ((v1 & 0x8000000000000000) == 0 || *(void *)(a1 + 8) == 0xFFFFFFFFLL)
    {
      *(void *)(a1 + 8) = v1 & 0x80000000FFFFFFFFLL | 0x100000000;
    }
    else
    {
      _X4 = 0;
      _X5 = 0;
      __asm { CASP            X4, X5, X4, X5, [X9] }
      LODWORD(_X3) = 0;
      unint64_t v10 = 0;
      _X6 = _X4 - 0x200000000;
      if (_X4 - 0x200000000 < 0)
      {
        _X2 = _X4;
        unint64_t v14 = 0;
        if (_X4 != -1)
        {
LABEL_8:
          for (unint64_t i = v14; ; unint64_t i = HIDWORD(v18))
          {
            uint64_t v16 = _X2;
            _X6 = _X2 - 0x200000000;
            if (_X2 - 0x200000000 < 0)
            {
              if (_X2 == -1) {
                break;
              }
              _X6 = _X2 & 0x80000000FFFFFFFFLL | 0x100000000;
            }
            unint64_t v18 = _X3 | (i << 32);
            _X3 = v18;
            __asm { CASPL           X2, X3, X6, X7, [X10] }
            if (_X2 == v16) {
              break;
            }
          }
        }
      }
      else
      {
        while (1)
        {
          unint64_t v12 = _X3 | (v10 << 32);
          _X3 = v12;
          __asm { CASPL           X2, X3, X6, X7, [X10] }
          if (_X2 == _X4) {
            break;
          }
          unint64_t v14 = HIDWORD(v12);
          unint64_t v10 = HIDWORD(v12);
          _X4 = _X2;
          _X6 = _X2 - 0x200000000;
          if (_X2 - 0x200000000 < 0)
          {
            if (_X2 == -1) {
              break;
            }
            goto LABEL_8;
          }
        }
      }
    }
  }
  swift_deallocObject(a1);
}

void swift_deallocObject(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 < 0)
  {
    if ((~v2 & 0x1FFFFFFFFLL) != 0) {
      goto LABEL_6;
    }
  }
  else if ((v2 & 0x100000000) == 0)
  {
    goto LABEL_6;
  }
  if ((v2 & 0x7FFFFFFEFFFFFFFELL) == 2) {
    goto LABEL_15;
  }
LABEL_6:
  if (a1 < 1) {
    return;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  if ((~v3 & 0x80000000FFFFFFFFLL) == 0) {
    return;
  }
  if ((v3 & 0x8000000000000000) == 0) {
    goto LABEL_11;
  }
  uint64_t v4 = *(void *)(a1 + 8);
LABEL_10:
  if (v4 != 0xFFFFFFFFLL)
  {
    if ((swift::HeapObjectSideTableEntry::decrementUnownedShouldFree((swift::HeapObjectSideTableEntry *)(8 * v3), 1) & 1) == 0) {
      return;
    }
    goto LABEL_15;
  }
LABEL_11:
  while (1)
  {
    uint64_t v5 = v3;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 8), (unint64_t *)&v5, (2 * ((v3 >> 1) - 1)) | v3 & 0xFFFFFFFF00000001, memory_order_relaxed, memory_order_relaxed);
    if (v5 == v3) {
      break;
    }
    uint64_t v3 = v5;
    if (v5 < 0)
    {
      uint64_t v4 = v5;
      goto LABEL_10;
    }
  }
  if ((((v3 >> 1) - 1) & 0x7FFFFFFF) == 0)
  {
LABEL_15:
    swift_slowDealloc((void *)a1);
  }
}

uint64_t swift_projectBox(uint64_t result)
{
  if (result) {
    result += *(unsigned int *)(*(void *)result + 8);
  }
  return result;
}

_UNKNOWN **swift_allocEmptyBox()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
  }
  {
    uint64_t v0 = qword_1EC07DB28;
    unint64_t v1 = qword_1EC07DB28 + 0x200000000;
    if (qword_1EC07DB28 + 0x200000000 < 0)
    {
      uint64_t v2 = qword_1EC07DB28;
      if (qword_1EC07DB28 != -1) {
LABEL_8:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(&qword_1EC07DB28, v2, 1);
    }
    else
    {
      uint64_t v2 = qword_1EC07DB28;
      while (1)
      {
        atomic_compare_exchange_strong_explicit(&qword_1EC07DB28, (unint64_t *)&v2, v1, memory_order_relaxed, memory_order_relaxed);
        if (v2 == v0) {
          break;
        }
        uint64_t v0 = v2;
        unint64_t v1 = v2 + 0x200000000;
        if (v2 + 0x200000000 < 0)
        {
          if (v2 == -1) {
          goto LABEL_8;
          }
        }
      }
    }
  }
}

atomic_ullong *swift_retain(atomic_ullong *result)
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(result);
  }
  if ((uint64_t)result >= 1)
  {
    uint64_t v1 = result[1];
    unint64_t v2 = v1 + 0x200000000;
    if (v1 + 0x200000000 < 0)
    {
      uint64_t v3 = result[1];
      if (v1 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(result + 1, v3, 1);
      }
    }
    else
    {
      uint64_t v3 = result[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(result + 1, (unint64_t *)&v3, v2, memory_order_relaxed, memory_order_relaxed);
        if (v3 == v1) {
          break;
        }
        uint64_t v1 = v3;
        unint64_t v2 = v3 + 0x200000000;
        if (v3 + 0x200000000 < 0)
        {
          if (v3 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(result + 1, v3, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x1(uint64_t a1, atomic_ullong *a2)
{
  __n128 result = a2;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(a2);
  }
  if ((uint64_t)a2 >= 1)
  {
    uint64_t v3 = a2 + 1;
    uint64_t v4 = a2[1];
    unint64_t v5 = v4 + 0x200000000;
    if (v4 + 0x200000000 < 0)
    {
      uint64_t v6 = a2[1];
      if (v4 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(result + 1, v6, 1);
      }
    }
    else
    {
      uint64_t v6 = a2[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v3, (unint64_t *)&v6, v5, memory_order_relaxed, memory_order_relaxed);
        if (v6 == v4) {
          break;
        }
        uint64_t v4 = v6;
        unint64_t v5 = v6 + 0x200000000;
        if (v6 + 0x200000000 < 0)
        {
          if (v6 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(result + 1, v6, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x2(uint64_t a1, uint64_t a2, atomic_ullong *a3)
{
  __n128 result = a3;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(a3);
  }
  if ((uint64_t)a3 >= 1)
  {
    uint64_t v4 = a3[1];
    unint64_t v5 = v4 + 0x200000000;
    if (v4 + 0x200000000 < 0)
    {
      uint64_t v6 = a3[1];
      if (v4 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(a3 + 1, v6, 1);
      }
    }
    else
    {
      uint64_t v6 = a3[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(a3 + 1, (unint64_t *)&v6, v5, memory_order_relaxed, memory_order_relaxed);
        if (v6 == v4) {
          break;
        }
        uint64_t v4 = v6;
        unint64_t v5 = v6 + 0x200000000;
        if (v6 + 0x200000000 < 0)
        {
          if (v6 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(a3 + 1, v6, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x3(uint64_t a1, uint64_t a2, uint64_t a3, atomic_ullong *a4)
{
  __n128 result = a4;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(a4);
  }
  if ((uint64_t)a4 >= 1)
  {
    uint64_t v5 = a4[1];
    unint64_t v6 = v5 + 0x200000000;
    if (v5 + 0x200000000 < 0)
    {
      uint64_t v7 = a4[1];
      if (v5 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(a4 + 1, v7, 1);
      }
    }
    else
    {
      uint64_t v7 = a4[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(a4 + 1, (unint64_t *)&v7, v6, memory_order_relaxed, memory_order_relaxed);
        if (v7 == v5) {
          break;
        }
        uint64_t v5 = v7;
        unint64_t v6 = v7 + 0x200000000;
        if (v7 + 0x200000000 < 0)
        {
          if (v7 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(a4 + 1, v7, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, atomic_ullong *a5)
{
  __n128 result = a5;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(a5);
  }
  if ((uint64_t)a5 >= 1)
  {
    uint64_t v6 = a5[1];
    unint64_t v7 = v6 + 0x200000000;
    if (v6 + 0x200000000 < 0)
    {
      uint64_t v8 = a5[1];
      if (v6 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(a5 + 1, v8, 1);
      }
    }
    else
    {
      uint64_t v8 = a5[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(a5 + 1, (unint64_t *)&v8, v7, memory_order_relaxed, memory_order_relaxed);
        if (v8 == v6) {
          break;
        }
        uint64_t v6 = v8;
        unint64_t v7 = v8 + 0x200000000;
        if (v8 + 0x200000000 < 0)
        {
          if (v8 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(a5 + 1, v8, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x5(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, atomic_ullong *a6)
{
  __n128 result = a6;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(a6);
  }
  if ((uint64_t)a6 >= 1)
  {
    uint64_t v7 = a6[1];
    unint64_t v8 = v7 + 0x200000000;
    if (v7 + 0x200000000 < 0)
    {
      uint64_t v9 = a6[1];
      if (v7 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(a6 + 1, v9, 1);
      }
    }
    else
    {
      uint64_t v9 = a6[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(a6 + 1, (unint64_t *)&v9, v8, memory_order_relaxed, memory_order_relaxed);
        if (v9 == v7) {
          break;
        }
        uint64_t v7 = v9;
        unint64_t v8 = v9 + 0x200000000;
        if (v9 + 0x200000000 < 0)
        {
          if (v9 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(a6 + 1, v9, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x6(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, atomic_ullong *a7)
{
  __n128 result = a7;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(a7);
  }
  if ((uint64_t)a7 >= 1)
  {
    uint64_t v8 = a7[1];
    unint64_t v9 = v8 + 0x200000000;
    if (v8 + 0x200000000 < 0)
    {
      uint64_t v10 = a7[1];
      if (v8 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(a7 + 1, v10, 1);
      }
    }
    else
    {
      uint64_t v10 = a7[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(a7 + 1, (unint64_t *)&v10, v9, memory_order_relaxed, memory_order_relaxed);
        if (v10 == v8) {
          break;
        }
        uint64_t v8 = v10;
        unint64_t v9 = v10 + 0x200000000;
        if (v10 + 0x200000000 < 0)
        {
          if (v10 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(a7 + 1, v10, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x7(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, atomic_ullong *a8)
{
  __n128 result = a8;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(a8);
  }
  if ((uint64_t)a8 >= 1)
  {
    uint64_t v9 = a8[1];
    unint64_t v10 = v9 + 0x200000000;
    if (v9 + 0x200000000 < 0)
    {
      uint64_t v11 = a8[1];
      if (v9 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(a8 + 1, v11, 1);
      }
    }
    else
    {
      uint64_t v11 = a8[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(a8 + 1, (unint64_t *)&v11, v10, memory_order_relaxed, memory_order_relaxed);
        if (v11 == v9) {
          break;
        }
        uint64_t v9 = v11;
        unint64_t v10 = v11 + 0x200000000;
        if (v11 + 0x200000000 < 0)
        {
          if (v11 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(a8 + 1, v11, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x8@<X0>(atomic_ullong *a1@<X8>)
{
  __n128 result = a1;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(a1);
  }
  if ((uint64_t)a1 >= 1)
  {
    unint64_t v2 = a1 + 1;
    uint64_t v3 = result[1];
    unint64_t v4 = v3 + 0x200000000;
    if (v3 + 0x200000000 < 0)
    {
      uint64_t v5 = result[1];
      if (v3 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(result + 1, v5, 1);
      }
    }
    else
    {
      uint64_t v5 = result[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v2, (unint64_t *)&v5, v4, memory_order_relaxed, memory_order_relaxed);
        if (v5 == v3) {
          break;
        }
        uint64_t v3 = v5;
        unint64_t v4 = v5 + 0x200000000;
        if (v5 + 0x200000000 < 0)
        {
          if (v5 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(result + 1, v5, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x9()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0[1];
    unint64_t v3 = v2 + 0x200000000;
    if (v2 + 0x200000000 < 0)
    {
      uint64_t v4 = v0[1];
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = v0[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v0 + 1, (unint64_t *)&v4, v3, memory_order_relaxed, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 + 0x200000000;
        if (v4 + 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x10()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0 + 1;
    uint64_t v3 = v0[1];
    unint64_t v4 = v3 + 0x200000000;
    if (v3 + 0x200000000 < 0)
    {
      uint64_t v5 = result[1];
      if (v3 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(result + 1, v5, 1);
      }
    }
    else
    {
      uint64_t v5 = result[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v2, (unint64_t *)&v5, v4, memory_order_relaxed, memory_order_relaxed);
        if (v5 == v3) {
          break;
        }
        uint64_t v3 = v5;
        unint64_t v4 = v5 + 0x200000000;
        if (v5 + 0x200000000 < 0)
        {
          if (v5 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(result + 1, v5, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x11()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0 + 1;
    uint64_t v3 = v0[1];
    unint64_t v4 = v3 + 0x200000000;
    if (v3 + 0x200000000 < 0)
    {
      uint64_t v5 = result[1];
      if (v3 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(result + 1, v5, 1);
      }
    }
    else
    {
      uint64_t v5 = result[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v2, (unint64_t *)&v5, v4, memory_order_relaxed, memory_order_relaxed);
        if (v5 == v3) {
          break;
        }
        uint64_t v3 = v5;
        unint64_t v4 = v5 + 0x200000000;
        if (v5 + 0x200000000 < 0)
        {
          if (v5 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(result + 1, v5, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x12()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0[1];
    unint64_t v3 = v2 + 0x200000000;
    if (v2 + 0x200000000 < 0)
    {
      uint64_t v4 = v0[1];
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = v0[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v0 + 1, (unint64_t *)&v4, v3, memory_order_relaxed, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 + 0x200000000;
        if (v4 + 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x13()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0[1];
    unint64_t v3 = v2 + 0x200000000;
    if (v2 + 0x200000000 < 0)
    {
      uint64_t v4 = v0[1];
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = v0[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v0 + 1, (unint64_t *)&v4, v3, memory_order_relaxed, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 + 0x200000000;
        if (v4 + 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x14()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0[1];
    unint64_t v3 = v2 + 0x200000000;
    if (v2 + 0x200000000 < 0)
    {
      uint64_t v4 = v0[1];
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = v0[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v0 + 1, (unint64_t *)&v4, v3, memory_order_relaxed, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 + 0x200000000;
        if (v4 + 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x15()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0[1];
    unint64_t v3 = v2 + 0x200000000;
    if (v2 + 0x200000000 < 0)
    {
      uint64_t v4 = v0[1];
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = v0[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v0 + 1, (unint64_t *)&v4, v3, memory_order_relaxed, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 + 0x200000000;
        if (v4 + 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x19()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0[1];
    unint64_t v3 = v2 + 0x200000000;
    if (v2 + 0x200000000 < 0)
    {
      uint64_t v4 = v0[1];
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = v0[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v0 + 1, (unint64_t *)&v4, v3, memory_order_relaxed, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 + 0x200000000;
        if (v4 + 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x20()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0[1];
    unint64_t v3 = v2 + 0x200000000;
    if (v2 + 0x200000000 < 0)
    {
      uint64_t v4 = v0[1];
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = v0[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v0 + 1, (unint64_t *)&v4, v3, memory_order_relaxed, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 + 0x200000000;
        if (v4 + 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x21()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0[1];
    unint64_t v3 = v2 + 0x200000000;
    if (v2 + 0x200000000 < 0)
    {
      uint64_t v4 = v0[1];
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = v0[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v0 + 1, (unint64_t *)&v4, v3, memory_order_relaxed, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 + 0x200000000;
        if (v4 + 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x22()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0[1];
    unint64_t v3 = v2 + 0x200000000;
    if (v2 + 0x200000000 < 0)
    {
      uint64_t v4 = v0[1];
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = v0[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v0 + 1, (unint64_t *)&v4, v3, memory_order_relaxed, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 + 0x200000000;
        if (v4 + 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x23()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0[1];
    unint64_t v3 = v2 + 0x200000000;
    if (v2 + 0x200000000 < 0)
    {
      uint64_t v4 = v0[1];
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = v0[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v0 + 1, (unint64_t *)&v4, v3, memory_order_relaxed, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 + 0x200000000;
        if (v4 + 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x24()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0[1];
    unint64_t v3 = v2 + 0x200000000;
    if (v2 + 0x200000000 < 0)
    {
      uint64_t v4 = v0[1];
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = v0[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v0 + 1, (unint64_t *)&v4, v3, memory_order_relaxed, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 + 0x200000000;
        if (v4 + 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x25()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0[1];
    unint64_t v3 = v2 + 0x200000000;
    if (v2 + 0x200000000 < 0)
    {
      uint64_t v4 = v0[1];
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = v0[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v0 + 1, (unint64_t *)&v4, v3, memory_order_relaxed, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 + 0x200000000;
        if (v4 + 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x26()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0[1];
    unint64_t v3 = v2 + 0x200000000;
    if (v2 + 0x200000000 < 0)
    {
      uint64_t v4 = v0[1];
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = v0[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v0 + 1, (unint64_t *)&v4, v3, memory_order_relaxed, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 + 0x200000000;
        if (v4 + 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x27()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0[1];
    unint64_t v3 = v2 + 0x200000000;
    if (v2 + 0x200000000 < 0)
    {
      uint64_t v4 = v0[1];
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = v0[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v0 + 1, (unint64_t *)&v4, v3, memory_order_relaxed, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 + 0x200000000;
        if (v4 + 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

atomic_ullong *swift_retain_x28()
{
  __n128 result = v0;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_retain(v0);
  }
  if ((uint64_t)v0 >= 1)
  {
    uint64_t v2 = v0[1];
    unint64_t v3 = v2 + 0x200000000;
    if (v2 + 0x200000000 < 0)
    {
      uint64_t v4 = v0[1];
      if (v2 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
      }
    }
    else
    {
      uint64_t v4 = v0[1];
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v0 + 1, (unint64_t *)&v4, v3, memory_order_relaxed, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 + 0x200000000;
        if (v4 + 0x200000000 < 0)
        {
          if (v4 != -1) {
            return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v0 + 1, v4, 1);
          }
          return result;
        }
      }
    }
  }
  return result;
}

uint64_t swift_nonatomic_retain(uint64_t result)
{
  if (result >= 1)
  {
    uint64_t v1 = *(void *)(result + 8);
    if (v1 + 0x200000000 < 0)
    {
      if (v1 != -1)
      {
        uint64_t v2 = result;
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementNonAtomicSlow((swift *)(result + 8), v1, 1);
        return v2;
      }
    }
    else
    {
      *(void *)(result + 8) = v1 + 0x200000000;
    }
  }
  return result;
}

uint64_t swift_retain_n(uint64_t a1, uint64_t a2)
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    unint64_t v10 = (uint64_t (*)(uint64_t, uint64_t))_swift_retain_n[0];
    return v10(a1, a2);
  }
  else
  {
    if (a1 >= 1)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (a2 == 1 || (v4 & 0x80000000FFFFFFFFLL) != 0x80000000FFFFFFFFLL)
      {
        uint64_t v6 = (atomic_ullong *)(a1 + 8);
        uint64_t v7 = a2 << 33;
        int64_t v8 = v4 + (a2 << 33);
        if (v8 < 0)
        {
          uint64_t v9 = *(void *)(a1 + 8);
          if (v4 != -1) {
LABEL_11:
          }
            swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementSlow(v6, v9, a2);
        }
        else
        {
          uint64_t v9 = *(void *)(a1 + 8);
          while (1)
          {
            atomic_compare_exchange_strong_explicit(v6, (unint64_t *)&v9, v8, memory_order_relaxed, memory_order_relaxed);
            if (v9 == v4) {
              break;
            }
            uint64_t v4 = v9;
            int64_t v8 = v9 + v7;
            if (v9 + v7 < 0)
            {
              if (v9 == -1) {
                return a1;
              }
              goto LABEL_11;
            }
          }
        }
      }
    }
    return a1;
  }
}

uint64_t swift_nonatomic_retain_n(uint64_t result, uint64_t a2)
{
  if (result >= 1)
  {
    uint64_t v3 = *(void *)(result + 8);
    if (a2 == 1 || (v3 & 0x80000000FFFFFFFFLL) != 0x80000000FFFFFFFFLL)
    {
      if (v3 + (a2 << 33) < 0)
      {
        if (v3 != -1)
        {
          uint64_t v4 = result;
          swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementNonAtomicSlow((swift *)(result + 8), v3, a2);
          return v4;
        }
      }
      else
      {
        *(void *)(result + 8) = v3 + (a2 << 33);
      }
    }
  }
  return result;
}

void swift_release_x1(uint64_t a1, uint64_t a2)
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(a2);
  }
  else if (a2 >= 1)
  {
    uint64_t v2 = (atomic_ullong *)(a2 + 8);
    uint64_t v3 = *(void *)(a2 + 8);
    unint64_t v4 = v3 - 0x200000000;
    if (v3 - 0x200000000 < 0)
    {
      uint64_t v5 = *(void *)(a2 + 8);
      if (v3 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v2, v5, 1);
    }
    else
    {
      uint64_t v5 = *(void *)(a2 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v2, (unint64_t *)&v5, v4, memory_order_release, memory_order_relaxed);
        if (v5 == v3) {
          break;
        }
        uint64_t v3 = v5;
        unint64_t v4 = v5 - 0x200000000;
        if (v5 - 0x200000000 < 0)
        {
          if (v5 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(a3);
  }
  else if (a3 >= 1)
  {
    uint64_t v3 = (atomic_ullong *)(a3 + 8);
    uint64_t v4 = *(void *)(a3 + 8);
    unint64_t v5 = v4 - 0x200000000;
    if (v4 - 0x200000000 < 0)
    {
      uint64_t v6 = *(void *)(a3 + 8);
      if (v4 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v3, v6, 1);
    }
    else
    {
      uint64_t v6 = *(void *)(a3 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v3, (unint64_t *)&v6, v5, memory_order_release, memory_order_relaxed);
        if (v6 == v4) {
          break;
        }
        uint64_t v4 = v6;
        unint64_t v5 = v6 - 0x200000000;
        if (v6 - 0x200000000 < 0)
        {
          if (v6 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(a4);
  }
  else if (a4 >= 1)
  {
    uint64_t v4 = (atomic_ullong *)(a4 + 8);
    uint64_t v5 = *(void *)(a4 + 8);
    unint64_t v6 = v5 - 0x200000000;
    if (v5 - 0x200000000 < 0)
    {
      uint64_t v7 = *(void *)(a4 + 8);
      if (v5 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v4, v7, 1);
    }
    else
    {
      uint64_t v7 = *(void *)(a4 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v4, (unint64_t *)&v7, v6, memory_order_release, memory_order_relaxed);
        if (v7 == v5) {
          break;
        }
        uint64_t v5 = v7;
        unint64_t v6 = v7 - 0x200000000;
        if (v7 - 0x200000000 < 0)
        {
          if (v7 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(a5);
  }
  else if (a5 >= 1)
  {
    uint64_t v5 = (atomic_ullong *)(a5 + 8);
    uint64_t v6 = *(void *)(a5 + 8);
    unint64_t v7 = v6 - 0x200000000;
    if (v6 - 0x200000000 < 0)
    {
      uint64_t v8 = *(void *)(a5 + 8);
      if (v6 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v5, v8, 1);
    }
    else
    {
      uint64_t v8 = *(void *)(a5 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v5, (unint64_t *)&v8, v7, memory_order_release, memory_order_relaxed);
        if (v8 == v6) {
          break;
        }
        uint64_t v6 = v8;
        unint64_t v7 = v8 - 0x200000000;
        if (v8 - 0x200000000 < 0)
        {
          if (v8 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x5(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(a6);
  }
  else if (a6 >= 1)
  {
    uint64_t v6 = (atomic_ullong *)(a6 + 8);
    uint64_t v7 = *(void *)(a6 + 8);
    unint64_t v8 = v7 - 0x200000000;
    if (v7 - 0x200000000 < 0)
    {
      uint64_t v9 = *(void *)(a6 + 8);
      if (v7 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v6, v9, 1);
    }
    else
    {
      uint64_t v9 = *(void *)(a6 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v6, (unint64_t *)&v9, v8, memory_order_release, memory_order_relaxed);
        if (v9 == v7) {
          break;
        }
        uint64_t v7 = v9;
        unint64_t v8 = v9 - 0x200000000;
        if (v9 - 0x200000000 < 0)
        {
          if (v9 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x6(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(a7);
  }
  else if (a7 >= 1)
  {
    uint64_t v7 = (atomic_ullong *)(a7 + 8);
    uint64_t v8 = *(void *)(a7 + 8);
    unint64_t v9 = v8 - 0x200000000;
    if (v8 - 0x200000000 < 0)
    {
      uint64_t v10 = *(void *)(a7 + 8);
      if (v8 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v7, v10, 1);
    }
    else
    {
      uint64_t v10 = *(void *)(a7 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v7, (unint64_t *)&v10, v9, memory_order_release, memory_order_relaxed);
        if (v10 == v8) {
          break;
        }
        uint64_t v8 = v10;
        unint64_t v9 = v10 - 0x200000000;
        if (v10 - 0x200000000 < 0)
        {
          if (v10 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x7(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(a8);
  }
  else if (a8 >= 1)
  {
    uint64_t v8 = (atomic_ullong *)(a8 + 8);
    uint64_t v9 = *(void *)(a8 + 8);
    unint64_t v10 = v9 - 0x200000000;
    if (v9 - 0x200000000 < 0)
    {
      uint64_t v11 = *(void *)(a8 + 8);
      if (v9 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v8, v11, 1);
    }
    else
    {
      uint64_t v11 = *(void *)(a8 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v8, (unint64_t *)&v11, v10, memory_order_release, memory_order_relaxed);
        if (v11 == v9) {
          break;
        }
        uint64_t v9 = v11;
        unint64_t v10 = v11 - 0x200000000;
        if (v11 - 0x200000000 < 0)
        {
          if (v11 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x8(uint64_t a1@<X8>)
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(a1);
  }
  else if (a1 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(a1 + 8);
    uint64_t v2 = *(void *)(a1 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = *(void *)(a1 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x9()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = v2;
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = v2;
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x10()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = v2;
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = v2;
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x11()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v0 + 8);
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = *(void *)(v0 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x12()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v0 + 8);
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = *(void *)(v0 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x13()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v0 + 8);
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = *(void *)(v0 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x14()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v0 + 8);
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = *(void *)(v0 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x15()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v0 + 8);
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = *(void *)(v0 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x19()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v0 + 8);
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = *(void *)(v0 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x20()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v0 + 8);
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = *(void *)(v0 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x21()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v0 + 8);
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = *(void *)(v0 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x22()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v0 + 8);
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = *(void *)(v0 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x23()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v0 + 8);
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = *(void *)(v0 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x24()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v0 + 8);
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = *(void *)(v0 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x25()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v0 + 8);
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = *(void *)(v0 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x26()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v0 + 8);
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = *(void *)(v0 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x27()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v0 + 8);
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = *(void *)(v0 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

void swift_release_x28()
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    _swift_release(v0);
  }
  else if (v0 >= 1)
  {
    uint64_t v1 = (atomic_ullong *)(v0 + 8);
    uint64_t v2 = *(void *)(v0 + 8);
    unint64_t v3 = v2 - 0x200000000;
    if (v2 - 0x200000000 < 0)
    {
      uint64_t v4 = *(void *)(v0 + 8);
      if (v2 != -1) {
LABEL_11:
      }
        swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(v1, v4, 1);
    }
    else
    {
      uint64_t v4 = *(void *)(v0 + 8);
      while (1)
      {
        atomic_compare_exchange_strong_explicit(v1, (unint64_t *)&v4, v3, memory_order_release, memory_order_relaxed);
        if (v4 == v2) {
          break;
        }
        uint64_t v2 = v4;
        unint64_t v3 = v4 - 0x200000000;
        if (v4 - 0x200000000 < 0)
        {
          if (v4 != -1) {
            goto LABEL_11;
          }
          return;
        }
      }
    }
  }
}

uint64_t swift_nonatomic_release(uint64_t result)
{
  if (result < 1) {
    return result;
  }
  uint64_t v1 = *(void *)(result + 8);
  if ((v1 & 0x80000000FFFFFFFELL) == 2)
  {
    if (v1 > 0x1FFFFFFFFLL)
    {
      *(void *)(result + 8) = v1 - 0x200000000;
      return result;
    }
    if (v1 == -1) {
      return result;
    }
LABEL_11:
    *(void *)(result + 8) = v1 & 0x80000000FFFFFFFFLL | 0x100000000;
    return _swift_release_dealloc((void *)result);
  }
  if (v1 - 0x200000000 >= 0)
  {
    *(void *)(result + 8) = v1 - 0x200000000;
    return result;
  }
  if (v1 != -1)
  {
    if (v1 < 0) {
      return swift::HeapObjectSideTableEntry::decrementNonAtomicStrong<(swift::PerformDeinit)1>((void **)(8 * v1), 1);
    }
    goto LABEL_11;
  }
  return result;
}

uint64_t swift_release_n(uint64_t result, uint64_t a2)
{
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly) {
    return _swift_release_n(result, a2);
  }
  if (result >= 1)
  {
    uint64_t v3 = *(void *)(result + 8);
    if (a2 == 1 || (v3 & 0x80000000FFFFFFFFLL) != 0x80000000FFFFFFFFLL)
    {
      result += 8;
      if (a2 < 2 || (v3 & 0x8000000000000000) == 0)
      {
        uint64_t v4 = a2 << 33;
        while (v3 - v4 >= 0)
        {
          uint64_t v5 = v3;
          atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)result, (unint64_t *)&v5, v3 - v4, memory_order_release, memory_order_relaxed);
          if (v5 == v3) {
            return result;
          }
          uint64_t v3 = v5;
          if (a2 >= 2 && v5 < 0) {
            break;
          }
        }
      }
      if (v3 != -1) {
        return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>((atomic_ullong *)result, v3, a2);
      }
    }
  }
  return result;
}

uint64_t swift_nonatomic_release_n(uint64_t result, uint64_t a2)
{
  if (result >= 1)
  {
    uint64_t v2 = *(void *)(result + 8);
    if ((v2 & 0x80000000FFFFFFFELL) == 2)
    {
      uint64_t v3 = v2 - (a2 << 33);
      if (v3 < 0)
      {
        if (v2 == -1) {
          return result;
        }
LABEL_14:
        *(void *)(result + 8) = v2 & 0x80000000FFFFFFFFLL | 0x100000000;
        return _swift_release_dealloc((void *)result);
      }
LABEL_8:
      *(void *)(result + 8) = v3;
      return result;
    }
    if (a2 == 1) {
      goto LABEL_7;
    }
    if ((~v2 & 0x80000000FFFFFFFFLL) == 0) {
      return result;
    }
    if (a2 < 2 || (v2 & 0x8000000000000000) == 0)
    {
LABEL_7:
      uint64_t v3 = v2 - (a2 << 33);
      if (v3 >= 0) {
        goto LABEL_8;
      }
    }
    if (v2 != -1)
    {
      if (v2 < 0) {
        return swift::HeapObjectSideTableEntry::decrementNonAtomicStrong<(swift::PerformDeinit)1>((void **)(8 * v2), a2);
      }
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t swift_retainCount(uint64_t a1)
{
  if (a1 < 1) {
    return 0;
  }
  _X0 = *(void *)(a1 + 8);
  if ((_X0 & 0x8000000000000000) != 0 && _X0 != 0xFFFFFFFFLL)
  {
    _X0 = 0;
    _X1 = 0;
    __asm { CASP            X0, X1, X0, X1, [X8] }
  }
  return ((_X0 >> 33) & 0x3FFFFFFF) + 1;
}

uint64_t swift_unownedRetainCount(uint64_t a1)
{
  _X0 = *(void *)(a1 + 8);
  if (_X0 < 0 && _X0 != 0xFFFFFFFFLL)
  {
    _X0 = 0;
    _X1 = 0;
    __asm { CASP            X0, X1, X0, X1, [X8] }
  }
  return _X0 >> 1;
}

BOOL swift_weakRetainCount(uint64_t a1)
{
  if ((*(void *)(a1 + 8) & 0x8000000000000000) == 0 || *(void *)(a1 + 8) == 0xFFFFFFFFLL) {
    return (*(void *)(a1 + 8) & 0xFFFFFFFELL) != 0;
  }
  _X0 = 0;
  _X1 = 0;
  __asm { CASP            X0, X1, X0, X1, [X8] }
  return 0;
}

uint64_t swift_unownedRetain(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  if (a1 >= 1) {
    swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementUnowned((atomic_ullong *)(a1 + 8), 1, a3, a4);
  }
  return a1;
}

atomic_ullong *swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementUnowned(atomic_ullong *result, uint64_t a2, const char *a3, char *a4)
{
  atomic_ullong v4 = *result;
  if ((~*result & 0x80000000FFFFFFFFLL) != 0)
  {
    if ((v4 & 0x8000000000000000) == 0) {
      goto LABEL_5;
    }
    atomic_ullong v5 = *result;
LABEL_4:
    if (v5 == 0xFFFFFFFFLL)
    {
LABEL_5:
      while (1)
      {
        unsigned int v6 = 2 * (a2 + (v4 >> 1));
        if (v6 == -2 || v6 >> 1 != a2 + (v4 >> 1)) {
          return (atomic_ullong *)swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementUnownedSlow(result, a2, a3, a4);
        }
        unint64_t v8 = v4 & 0xFFFFFFFF00000001 | (2 * (v6 >> 1));
        atomic_ullong v5 = v4;
        atomic_compare_exchange_strong_explicit(result, (unint64_t *)&v5, v8, memory_order_relaxed, memory_order_relaxed);
        if (v5 == v4) {
          return result;
        }
        atomic_ullong v4 = v5;
        if (v5 < 0)
        {
          atomic_ullong v5 = v5;
          goto LABEL_4;
        }
      }
    }
    else
    {
      _X2 = 0;
      __n128 result = (atomic_ullong *)(8 * v4 + 16);
      _X3 = 0;
      __asm { CASP            X2, X3, X2, X3, [X0] }
      if (((unint64_t)_X2 & 0x8000000000000000) == 0 || _X2 != 0xFFFFFFFFLL)
      {
        unsigned int v15 = 2 * (a2 + (_X2 >> 1));
        if (v15 == -2 || v15 >> 1 != a2 + (_X2 >> 1)) {
LABEL_27:
        }
          swift::RefCounts<swift::SideTableRefCountBits>::incrementUnownedSlow((swift *)result, a2, _X2, (char *)_X3);
        unint64_t v17 = 0;
        LODWORD(_X5) = 0;
        while (1)
        {
          _X6 = (unint64_t)_X2 & 0xFFFFFFFF00000001 | (2 * (v15 >> 1));
          _X3 = _X5 | (v17 << 32);
          _X5 = (char *)_X3;
          __asm { CASP            X4, X5, X6, X7, [X0] }
          if (_X4 == _X2) {
            break;
          }
          unint64_t v17 = HIDWORD(_X3);
          unsigned int v15 = 2 * (a2 + (_X4 >> 1));
          BOOL v21 = v15 != -2 && v15 >> 1 == a2 + (_X4 >> 1);
          _X2 = _X4;
          if (!v21) {
            goto LABEL_27;
          }
        }
      }
    }
  }
  return result;
}

void swift_unownedRelease(atomic_ullong *a1)
{
  if ((uint64_t)a1 < 1) {
    return;
  }
  atomic_ullong v2 = a1[1];
  if ((~v2 & 0x80000000FFFFFFFFLL) == 0) {
    return;
  }
  if ((v2 & 0x8000000000000000) == 0) {
    goto LABEL_6;
  }
  uint64_t v3 = a1[1];
LABEL_5:
  if (v3 != 0xFFFFFFFFLL)
  {
    if ((swift::HeapObjectSideTableEntry::decrementUnownedShouldFree((swift::HeapObjectSideTableEntry *)(8 * v2), 1) & 1) == 0) {
      return;
    }
    goto LABEL_10;
  }
LABEL_6:
  while (1)
  {
    atomic_ullong v4 = v2;
    atomic_compare_exchange_strong_explicit(a1 + 1, (unint64_t *)&v4, (2 * ((v2 >> 1) - 1)) | v2 & 0xFFFFFFFF00000001, memory_order_relaxed, memory_order_relaxed);
    if (v4 == v2) {
      break;
    }
    atomic_ullong v2 = v4;
    if (v4 < 0)
    {
      uint64_t v3 = v4;
      goto LABEL_5;
    }
  }
  if ((((v2 >> 1) - 1) & 0x7FFFFFFF) == 0)
  {
LABEL_10:
    swift_slowDealloc(a1);
  }
}

uint64_t swift_nonatomic_unownedRetain(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  if (a1 >= 1) {
    swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementUnownedNonAtomic((atomic_ullong *)(a1 + 8), 1, a3, a4);
  }
  return a1;
}

atomic_ullong *swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementUnownedNonAtomic(atomic_ullong *result, uint64_t a2, const char *a3, char *a4)
{
  atomic_ullong v4 = *result;
  if ((~*result & 0x80000000FFFFFFFFLL) != 0)
  {
    if ((v4 & 0x8000000000000000) == 0 || *result == 0xFFFFFFFFLL)
    {
      unsigned int v11 = 2 * (a2 + (v4 >> 1));
      _ZF = v11 != -2 && v11 >> 1 == a2 + (v4 >> 1);
      if (_ZF) {
        *__n128 result = v4 & 0xFFFFFFFF00000001 | (2 * (v11 >> 1));
      }
      else {
        return (atomic_ullong *)swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementUnownedSlow(result, a2, a3, a4);
      }
    }
    else
    {
      _X2 = 0;
      __n128 result = (atomic_ullong *)(8 * v4 + 16);
      _X3 = 0;
      __asm { CASP            X2, X3, X2, X3, [X0] }
      if (((unint64_t)_X2 & 0x8000000000000000) == 0 || _X2 != 0xFFFFFFFFLL)
      {
        unsigned int v13 = 2 * (a2 + (_X2 >> 1));
        if (v13 == -2 || v13 >> 1 != a2 + (_X2 >> 1)) {
          swift::RefCounts<swift::SideTableRefCountBits>::incrementUnownedSlow((swift *)result, a2, _X2, 0);
        }
        _X2 = (unint64_t)_X2 & 0xFFFFFFFF00000001 | (2 * (v13 >> 1));
        atomic_ullong v16 = *result;
        do
        {
          _X7 = result[1];
          __asm { CASP            X6, X7, X2, X3, [X0] }
          _ZF = _X6 == v16;
          atomic_ullong v16 = _X6;
        }
        while (!_ZF);
      }
    }
  }
  return result;
}

void swift_nonatomic_unownedRelease(unint64_t *a1)
{
  if ((uint64_t)a1 >= 1
    && swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::decrementUnownedShouldFreeNonAtomic(a1 + 1, 1))
  {
    swift_slowDealloc(a1);
  }
}

uint64_t swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::decrementUnownedShouldFreeNonAtomic(unint64_t *a1, int a2)
{
  unint64_t v2 = *a1;
  if ((~*a1 & 0x80000000FFFFFFFFLL) == 0) {
    return 0;
  }
  if ((v2 & 0x8000000000000000) == 0 || *a1 == 0xFFFFFFFFLL)
  {
    int v24 = (v2 >> 1) - a2;
    unint64_t v25 = (2 * v24) | v2 & 0xFFFFFFFF00000001;
    BOOL v3 = (v24 & 0x7FFFFFFF) == 0;
    *a1 = v25;
    return v3;
  }
  _X4 = 0;
  uint64_t v5 = 8 * v2;
  _X5 = 0;
  __asm { CASP            X4, X5, X4, X5, [X8] }
  if (_X4 < 0 && _X4 == 0xFFFFFFFFLL) {
    return 0;
  }
  int v12 = (_X4 >> 1) - a2;
  _X2 = (2 * v12) | _X4 & 0xFFFFFFFF00000001;
  uint64_t v14 = v12 & 0x7FFFFFFF;
  uint64_t v15 = *(void *)(v5 + 16);
  do
  {
    _X7 = *(void *)(v5 + 24);
    __asm { CASP            X6, X7, X2, X3, [X9] }
    _ZF = _X6 == v15;
    uint64_t v15 = _X6;
  }
  while (!_ZF);
  if (v14) {
    return 0;
  }
  _X2 = 0;
  _X3 = 0;
  __asm { CASP            X2, X3, X2, X3, [X8] }
  uint64_t v21 = *(void *)(v5 + 16);
  do
  {
    _X7 = *(void *)(v5 + 24);
    __asm { CASP            X6, X7, X2, X3, [X8] }
    _ZF = _X6 == v21;
    uint64_t v21 = _X6;
  }
  while (!_ZF);
  return 1;
}

uint64_t swift_unownedRetain_n(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  if (a1 >= 1) {
    swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementUnowned((atomic_ullong *)(a1 + 8), a2, a3, a4);
  }
  return a1;
}

void swift_unownedRelease_n(atomic_ullong *a1, int a2)
{
  if ((uint64_t)a1 < 1) {
    return;
  }
  atomic_ullong v3 = a1[1];
  if ((~v3 & 0x80000000FFFFFFFFLL) == 0) {
    return;
  }
  if ((v3 & 0x8000000000000000) == 0) {
    goto LABEL_6;
  }
  uint64_t v4 = a1[1];
LABEL_5:
  if (v4 != 0xFFFFFFFFLL)
  {
    if ((swift::HeapObjectSideTableEntry::decrementUnownedShouldFree((swift::HeapObjectSideTableEntry *)(8 * v3), a2) & 1) == 0) {
      return;
    }
    goto LABEL_10;
  }
LABEL_6:
  while (1)
  {
    atomic_ullong v5 = v3;
    atomic_compare_exchange_strong_explicit(a1 + 1, (unint64_t *)&v5, (2 * ((v3 >> 1) - a2)) | v3 & 0xFFFFFFFF00000001, memory_order_relaxed, memory_order_relaxed);
    if (v5 == v3) {
      break;
    }
    atomic_ullong v3 = v5;
    if (v5 < 0)
    {
      uint64_t v4 = v5;
      goto LABEL_5;
    }
  }
  if ((((v3 >> 1) - a2) & 0x7FFFFFFF) == 0)
  {
LABEL_10:
    swift_slowDealloc(a1);
  }
}

uint64_t swift_nonatomic_unownedRetain_n(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  if (a1 >= 1) {
    swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::incrementUnownedNonAtomic((atomic_ullong *)(a1 + 8), a2, a3, a4);
  }
  return a1;
}

void swift_nonatomic_unownedRelease_n(unint64_t *a1, int a2)
{
  if ((uint64_t)a1 >= 1
    && swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::decrementUnownedShouldFreeNonAtomic(a1 + 1, a2))
  {
    swift_slowDealloc(a1);
  }
}

uint64_t swift_tryRetain(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
  uint64_t v4 = a1;
  if (_swift_enableSwizzlingOfAllocationAndRefCountingFunctions_forInstrumentsOnly)
  {
    uint64_t v9 = (uint64_t (*)(uint64_t, uint64_t, const char *, char *))_swift_tryRetain;
    return v9(a1, (uint64_t)&_swift_tryRetain, (const char *)v9, a4);
  }
  else
  {
    if (a1 < 1) {
      return 0;
    }
    atomic_ullong v5 = (atomic_ullong *)(a1 + 8);
    uint64_t v6 = *(void *)(v4 + 8);
    if (v6 < 0) {
      goto LABEL_6;
    }
LABEL_4:
    if ((v6 & 0x100000000) != 0) {
      return 0;
    }
    while (v6 + 0x200000000 >= 0)
    {
      uint64_t v7 = v6;
      atomic_compare_exchange_strong_explicit(v5, (unint64_t *)&v7, v6 + 0x200000000, memory_order_relaxed, memory_order_relaxed);
      if (v7 == v6) {
        return v4;
      }
      uint64_t v6 = v7;
      if ((v7 & 0x8000000000000000) == 0) {
        goto LABEL_4;
      }
LABEL_6:
      if ((~v6 & 0x1FFFFFFFFLL) == 0) {
        return 0;
      }
    }
    if (v6 != -1
      && !swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::tryIncrementSlow((swift *)v5, v6, a3, a4))
    {
      return 0;
    }
    return v4;
  }
}

uint64_t swift_isDeallocating(uint64_t a1)
{
  if (a1 < 1) {
    return 0;
  }
  unint64_t v1 = *(void *)(a1 + 8);
  if ((v1 & 0x8000000000000000) == 0 || *(void *)(a1 + 8) == 0xFFFFFFFFLL) {
    return HIDWORD(v1) & 1;
  }
  _X0 = 0;
  _X1 = 0;
  __asm { CASP            X0, X1, X0, X1, [X8] }
  return HIDWORD(_X0) & 1;
}

uint64_t swift_setDeallocating(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  if ((v1 & 0x80000000FFFFFFFFLL) != 0x80000000FFFFFFFFLL)
  {
    if ((v1 & 0x8000000000000000) == 0 || *(void *)(result + 8) == 0xFFFFFFFFLL)
    {
      *(void *)(result + 8) = v1 & 0x80000000FFFFFFFFLL | 0x100000000;
    }
    else
    {
      _X2 = 0;
      _X3 = 0;
      __asm { CASP            X2, X3, X2, X3, [X9] }
      LODWORD(_X1) = 0;
      unint64_t v10 = 0;
      _X4 = _X2 - 0x200000000;
      if (_X2 - 0x200000000 < 0)
      {
        __n128 result = _X2;
        unint64_t v13 = 0;
        if (_X2 != -1)
        {
LABEL_8:
          for (unint64_t i = v13; ; unint64_t i = HIDWORD(v17))
          {
            uint64_t v15 = result;
            _X4 = result - 0x200000000;
            if (result - 0x200000000 < 0)
            {
              if (result == -1) {
                return result;
              }
              _X4 = result & 0x80000000FFFFFFFFLL | 0x100000000;
            }
            unint64_t v17 = _X1 | (i << 32);
            _X1 = v17;
            __asm { CASPL           X0, X1, X4, X5, [X10] }
            if (result == v15) {
              break;
            }
          }
        }
      }
      else
      {
        while (1)
        {
          unint64_t v12 = _X1 | (v10 << 32);
          _X1 = v12;
          __asm { CASPL           X0, X1, X4, X5, [X10] }
          if (result == _X2) {
            break;
          }
          unint64_t v13 = HIDWORD(v12);
          unint64_t v10 = HIDWORD(v12);
          _X2 = result;
          _X4 = result - 0x200000000;
          if (result - 0x200000000 < 0)
          {
            if (result == -1) {
              return result;
            }
            goto LABEL_8;
          }
        }
      }
    }
  }
  return result;
}

uint64_t swift_unownedRetainStrong(uint64_t this, uint64_t a2, const char *a3, char *a4)
{
  if (this >= 1)
  {
    atomic_ullong v5 = (atomic_ullong *)(this + 8);
    uint64_t v6 = *(void *)(this + 8);
    if (v6 < 0) {
      goto LABEL_5;
    }
LABEL_3:
    if ((v6 & 0x100000000) != 0) {
      goto LABEL_13;
    }
    while (v6 + 0x200000000 >= 0)
    {
      uint64_t v7 = v6;
      atomic_compare_exchange_strong_explicit(v5, (unint64_t *)&v7, v6 + 0x200000000, memory_order_relaxed, memory_order_relaxed);
      if (v7 == v6) {
        return this;
      }
      uint64_t v6 = v7;
      if ((v7 & 0x8000000000000000) == 0) {
        goto LABEL_3;
      }
LABEL_5:
      if ((~v6 & 0x1FFFFFFFFLL) == 0) {
        goto LABEL_13;
      }
    }
    if (v6 != -1
      && (swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::tryIncrementSlow((swift *)v5, v6, a3, a4) & 1) == 0)
    {
LABEL_13:
      swift::swift_abortRetainUnowned((swift *)this, (const void *)v6, a3, a4);
    }
  }
  return this;
}

uint64_t swift_nonatomic_unownedRetainStrong(uint64_t result, uint64_t a2, const char *a3, char *a4)
{
  if (result >= 1)
  {
    uint64_t v4 = *(void *)(result + 8);
    if (v4 < 0)
    {
      if ((~v4 & 0x1FFFFFFFFLL) == 0) {
        goto LABEL_11;
      }
    }
    else if ((v4 & 0x100000000) != 0)
    {
      goto LABEL_11;
    }
    if (v4 + 0x200000000 < 0)
    {
      if (v4 != -1)
      {
        uint64_t v6 = (swift *)result;
        char v5 = swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::tryIncrementNonAtomicSlow((swift *)(result + 8), v4, a3, a4);
        __n128 result = (uint64_t)v6;
        if ((v5 & 1) == 0) {
LABEL_11:
        }
          swift::swift_abortRetainUnowned((swift *)result, (const void *)v4, a3, a4);
      }
    }
    else
    {
      *(void *)(result + 8) = v4 + 0x200000000;
    }
  }
  return result;
}

uint64_t swift_unownedRetainStrongAndRelease(uint64_t this, uint64_t a2, const char *a3, char *a4)
{
  if (this >= 1)
  {
    uint64_t v4 = (swift *)this;
    char v5 = (atomic_ullong *)(this + 8);
    uint64_t v6 = *(void *)(this + 8);
    if (v6 < 0) {
      goto LABEL_5;
    }
LABEL_3:
    if ((v6 & 0x100000000) != 0) {
      goto LABEL_16;
    }
    while (v6 + 0x200000000 >= 0)
    {
      uint64_t v7 = v6;
      atomic_compare_exchange_strong_explicit(v5, (unint64_t *)&v7, v6 + 0x200000000, memory_order_relaxed, memory_order_relaxed);
      if (v7 == v6) {
        goto LABEL_12;
      }
      uint64_t v6 = v7;
      if ((v7 & 0x8000000000000000) == 0) {
        goto LABEL_3;
      }
LABEL_5:
      if ((~v6 & 0x1FFFFFFFFLL) == 0) {
        goto LABEL_16;
      }
    }
    if (v6 != -1)
    {
      this = swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::tryIncrementSlow((swift *)(this + 8), v6, a3, a4);
      if ((this & 1) == 0) {
LABEL_16:
      }
        swift::swift_abortRetainUnowned(v4, (const void *)v6, a3, a4);
    }
LABEL_12:
    atomic_ullong v8 = *v5;
    if ((~*v5 & 0x80000000FFFFFFFFLL) != 0)
    {
      if ((v8 & 0x8000000000000000) == 0) {
        goto LABEL_18;
      }
      atomic_ullong v9 = *v5;
LABEL_17:
      if (v9 == 0xFFFFFFFFLL)
      {
LABEL_18:
        while (1)
        {
          atomic_ullong v9 = v8;
          atomic_compare_exchange_strong_explicit(v5, (unint64_t *)&v9, ((v8 & 0xFFFFFFFE) - 2) | v8 & 0xFFFFFFFF00000001, memory_order_relaxed, memory_order_relaxed);
          if (v9 == v8) {
            break;
          }
          atomic_ullong v8 = v9;
          if (v9 < 0)
          {
            atomic_ullong v9 = v9;
            goto LABEL_17;
          }
        }
      }
      else
      {
        return swift::HeapObjectSideTableEntry::decrementUnownedShouldFree((swift::HeapObjectSideTableEntry *)(8 * v8), 1);
      }
    }
  }
  return this;
}

uint64_t swift_nonatomic_unownedRetainStrongAndRelease(uint64_t result, uint64_t a2, const char *a3, char *a4)
{
  if (result >= 1)
  {
    uint64_t v4 = *(void *)(result + 8);
    if (v4 < 0)
    {
      if ((~v4 & 0x1FFFFFFFFLL) == 0) {
        goto LABEL_14;
      }
    }
    else if ((v4 & 0x100000000) != 0)
    {
      goto LABEL_14;
    }
    char v5 = (unint64_t *)(result + 8);
    if (v4 + 0x200000000 < 0)
    {
      if (v4 != -1)
      {
        uint64_t v7 = (unint64_t *)(result + 8);
        uint64_t v8 = result;
        char v6 = swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::tryIncrementNonAtomicSlow((swift *)(result + 8), v4, a3, a4);
        char v5 = v7;
        __n128 result = v8;
        if ((v6 & 1) == 0) {
LABEL_14:
        }
          swift::swift_abortRetainUnowned((swift *)result, (const void *)v4, a3, a4);
      }
    }
    else
    {
      *char v5 = v4 + 0x200000000;
    }
    return swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::decrementUnownedShouldFreeNonAtomic(v5, 1);
  }
  return result;
}

uint64_t swift_unownedCheck(uint64_t result, const void *a2, const char *_X2, char *_X3)
{
  if (result >= 1)
  {
    uint64_t v4 = *(void *)(result + 8);
    if ((v4 & 0x8000000000000000) == 0 || *(void *)(result + 8) == 0xFFFFFFFFLL)
    {
      if ((v4 & 0x100000000) != 0) {
LABEL_5:
      }
        swift::swift_abortRetainUnowned((swift *)result, a2, _X2, _X3);
    }
    else
    {
      _X2 = 0;
      _X3 = 0;
      __asm { CASP            X2, X3, X2, X3, [X8] }
      if (((unint64_t)_X2 & 0x100000000) != 0) {
        goto LABEL_5;
      }
    }
  }
  return result;
}

uint64_t _swift_release_dealloc(void *a1)
{
  return (*(uint64_t (**)(void))(*a1 - 16))();
}

void swift_rootObjCDealloc(uint64_t a1)
{
}

void swift_deallocClassInstance(uint64_t a1)
{
  if (a1 >= 1)
  {
    _X0 = *(void *)(a1 + 8);
    if ((_X0 & 0x8000000000000000) != 0 && _X0 != 0xFFFFFFFFLL)
    {
      _X0 = 0;
      _X1 = 0;
      __asm { CASP            X0, X1, X0, X1, [X8] }
    }
    uint64_t v9 = (_X0 >> 33) & 0x3FFFFFFF;
    if (v9)
    {
      if (*(void *)a1) {
        unint64_t v10 = *(unint64_t **)a1;
      }
      else {
        unint64_t v10 = 0;
      }
      uint64_t TypeContextDescriptor = swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(v10);
      if (TypeContextDescriptor) {
        uint64_t v14 = (const char *)(TypeContextDescriptor + 8 + *(int *)(TypeContextDescriptor + 8));
      }
      else {
        uint64_t v14 = "<unknown>";
      }
      swift::fatalError(0, "Object %p of class %s deallocated with non-zero retain count %zd. This object's deinit, or something called from it, may have created a strong reference to self which outlived deinit, resulting in a dangling reference.\n", v12, v13, a1, v14, v9 + 1);
    }
  }
  if ((*(void *)(a1 + 8) & 0x8000000000000001) != 1) {
    objc_destructInstance((id)a1);
  }

  swift_deallocObject(a1);
}

void swift_deallocPartialClassInstance(void *a1, uint64_t a2)
{
  if (!a1) {
    return;
  }
  uint64_t v2 = a2;
  unint64_t v3 = *(void *)(*a1 & 0x7FFFFFFFFFFFF8);
  uint64_t v4 = *a1 & 0x7FFFFFFFFFFFF8;
  if (v3 <= 0x7FF && v3 != 0) {
    uint64_t v4 = *(void *)((*a1 & 0x7FFFFFFFFFFFF8) + 8);
  }
  if ((*(unsigned char *)(v4 + 32) & 2) == 0) {
    goto LABEL_47;
  }
  uint64_t v15 = a1;
  if (v4 != a2)
  {
    while ((*(unsigned char *)(v4 + 32) & 2) != 0)
    {
      unsigned int v11 = *(void (**)(void))(v4 + 72);
      if (v11)
      {
        v11();
        a1 = v15;
      }
      if (*(void *)(v4 + 8)) {
        uint64_t v4 = *(void *)(v4 + 8);
      }
      else {
        uint64_t v4 = 0;
      }
      uint64_t v12 = *(void *)v4;
      if (*(void *)v4 > 0x7FFuLL) {
        LODWORD(v12) = 0;
      }
      if (v12)
      {
        if (v12 == 773) {
          uint64_t v4 = *(void *)(v4 + 8);
        }
        else {
          uint64_t v4 = 0;
        }
      }
      if (v4 == v2) {
        goto LABEL_9;
      }
    }
    unint64_t v13 = (objc_class *)v4;
    goto LABEL_46;
  }
LABEL_9:
  if ((swift::usesNativeSwiftReferenceCounting(v2) & 1) == 0)
  {
    a1 = v15;
    while ((*(unsigned char *)(v2 + 32) & 2) != 0)
    {
      if (*(void *)(v2 + 8)) {
        uint64_t v2 = *(void *)(v2 + 8);
      }
      else {
        uint64_t v2 = 0;
      }
      uint64_t v14 = *(void *)v2;
      if (*(void *)v2 > 0x7FFuLL) {
        LODWORD(v14) = 0;
      }
      if (v14)
      {
        if (v14 == 773) {
          uint64_t v2 = *(void *)(v2 + 8);
        }
        else {
          uint64_t v2 = 0;
        }
      }
    }
    unint64_t v13 = (objc_class *)v2;
LABEL_46:
    object_setClass(a1, v13);
    a1 = v15;
LABEL_47:

    return;
  }
  uint64_t v6 = (uint64_t)v15;
  uint64_t v7 = v15 + 1;
  uint64_t v8 = v15[1];
  unint64_t v9 = v8 - 0x200000000;
  if (v8 - 0x200000000 < 0)
  {
    uint64_t v10 = v15[1];
    if (v8 != -1)
    {
LABEL_15:
      swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)0>(v7, v10, 1);
      uint64_t v6 = (uint64_t)v15;
    }
  }
  else
  {
    uint64_t v10 = v15[1];
    while (1)
    {
      atomic_compare_exchange_strong_explicit(v7, (unint64_t *)&v10, v9, memory_order_release, memory_order_relaxed);
      if (v10 == v8) {
        break;
      }
      uint64_t v8 = v10;
      unint64_t v9 = v10 - 0x200000000;
      if (v10 - 0x200000000 < 0)
      {
        if (v10 == -1) {
          break;
        }
        goto LABEL_15;
      }
    }
  }

  swift_deallocClassInstance(v6);
}

void swift_deallocUninitializedObject(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if ((v2 & 0x80000000FFFFFFFFLL) != 0x80000000FFFFFFFFLL)
  {
    if ((v2 & 0x8000000000000000) == 0 || *(void *)(a1 + 8) == 0xFFFFFFFFLL)
    {
      *(void *)(a1 + 8) = v2 & 0x80000000FFFFFFFFLL | 0x100000000;
    }
    else
    {
      _X6 = 0;
      _X7 = 0;
      __asm { CASP            X6, X7, X6, X7, [X9] }
      LODWORD(_X5) = 0;
      unint64_t v11 = 0;
      _X12 = _X6 - 0x200000000;
      if (_X6 - 0x200000000 < 0)
      {
        _X4 = _X6;
        unint64_t v15 = 0;
        if (_X6 != -1)
        {
LABEL_8:
          for (unint64_t i = v15; ; unint64_t i = HIDWORD(v19))
          {
            uint64_t v17 = _X4;
            _X12 = _X4 - 0x200000000;
            if (_X4 - 0x200000000 < 0)
            {
              if (_X4 == -1) {
                break;
              }
              _X12 = _X4 & 0x80000000FFFFFFFFLL | 0x100000000;
            }
            unint64_t v19 = _X5 | (i << 32);
            _X5 = v19;
            __asm { CASPL           X4, X5, X12, X13, [X10] }
            if (_X4 == v17) {
              break;
            }
          }
        }
      }
      else
      {
        while (1)
        {
          unint64_t v13 = _X5 | (v11 << 32);
          _X5 = v13;
          __asm { CASPL           X4, X5, X12, X13, [X10] }
          if (_X4 == _X6) {
            break;
          }
          unint64_t v15 = HIDWORD(v13);
          unint64_t v11 = HIDWORD(v13);
          _X6 = _X4;
          _X12 = _X4 - 0x200000000;
          if (_X4 - 0x200000000 < 0)
          {
            if (_X4 == -1) {
              break;
            }
            goto LABEL_8;
          }
        }
      }
    }
  }
  uint64_t v20 = *(void *)(a1 + 8);
  if (v20 < 0)
  {
    if ((~v20 & 0x1FFFFFFFFLL) != 0) {
      goto LABEL_20;
    }
  }
  else if ((v20 & 0x100000000) == 0)
  {
    goto LABEL_20;
  }
  if ((v20 & 0x7FFFFFFEFFFFFFFELL) == 2) {
    goto LABEL_31;
  }
LABEL_20:
  if (a1 < 1) {
    return;
  }
  uint64_t v21 = *(void *)(a1 + 8);
  if ((~v21 & 0x80000000FFFFFFFFLL) == 0) {
    return;
  }
  if ((v21 & 0x8000000000000000) == 0) {
    goto LABEL_27;
  }
  uint64_t v22 = *(void *)(a1 + 8);
LABEL_26:
  if (v22 != 0xFFFFFFFFLL)
  {
    if ((swift::HeapObjectSideTableEntry::decrementUnownedShouldFree((swift::HeapObjectSideTableEntry *)(8 * v21), 1) & 1) == 0) {
      return;
    }
    goto LABEL_31;
  }
LABEL_27:
  while (1)
  {
    uint64_t v23 = v21;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 8), (unint64_t *)&v23, (2 * ((v21 >> 1) - 1)) | v21 & 0xFFFFFFFF00000001, memory_order_relaxed, memory_order_relaxed);
    if (v23 == v21) {
      break;
    }
    uint64_t v21 = v23;
    if (v23 < 0)
    {
      uint64_t v22 = v23;
      goto LABEL_26;
    }
  }
  if ((((v21 >> 1) - 1) & 0x7FFFFFFF) == 0)
  {
LABEL_31:
    swift_slowDealloc((void *)a1);
  }
}

uint64_t *swift_weakInit(uint64_t *a1, uint64_t a2)
{
  if (a2) {
    unint64_t v3 = swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::formWeakReference((atomic_ullong *)(a2 + 8));
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = v3 | 1;
  if (!v3) {
    uint64_t v4 = 0;
  }
  *a1 = v4;
  return a1;
}

uint64_t *swift_weakAssign(uint64_t *a1, uint64_t a2)
{
  if (a2) {
    unint64_t v3 = swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::formWeakReference((atomic_ullong *)(a2 + 8));
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = v3 | 1;
  if (!v3) {
    uint64_t v4 = 0;
  }
  uint64_t v5 = *a1;
  *a1 = v4;
  if ((v5 & 0x7FFFFFFFFFFFFFFELL) != 0)
  {
    _X6 = 0;
    _X7 = 0;
    __asm { CASP            X6, X7, X6, X7, [X8] }
    _X2 = _X6;
    _X5 = 0;
    __asm { CASP            X4, X5, X2, X3, [X8] }
    if (_X4 != _X6)
    {
      do
      {
        _X2 = _X4;
        _X7 = 0;
        __asm { CASP            X6, X7, X2, X3, [X8] }
        uint64_t v19 = _X6 ^ _X4;
        _X4 = _X6;
      }
      while (v19);
    }
  }
  return a1;
}

uint64_t swift_weakLoadStrong(void *a1)
{
  uint64_t v1 = *a1 & 0x7FFFFFFFFFFFFFFELL;
  if (!v1) {
    return 0;
  }
  _X4 = 0;
  _X5 = 0;
  uint64_t v4 = 0;
  __asm { CASP            X4, X5, X4, X5, [X0] }
  if ((_X4 & 0x100000000) == 0)
  {
    unint64_t v10 = 0;
    _X3 = 0;
    while (1)
    {
      _X6 = _X4 + 0x200000000;
      if (_X4 + 0x200000000 < 0) {
        break;
      }
      unint64_t v13 = _X3 | (v10 << 32);
      _X3 = (char *)v13;
      __asm { CASP            X2, X3, X6, X7, [X0] }
      if (_X2 == _X4) {
        return *(void *)v1;
      }
      unint64_t v10 = HIDWORD(v13);
      _X4 = _X2;
      if ((_X2 & 0x100000000) != 0) {
        return 0;
      }
    }
    if (_X4 == -1
      || swift::RefCounts<swift::SideTableRefCountBits>::tryIncrementSlow((swift *)(v1 + 16), _X4, (const char *)(_X3 | (v10 << 32)), _X3))
    {
      return *(void *)v1;
    }
    return 0;
  }
  return v4;
}

uint64_t swift_weakTakeStrong(uint64_t *a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v4 = *a1;
  *a1 = 0;
  return swift::WeakReference::nativeTakeStrongFromBits((uint64_t)a1, v4, a3, a4);
}

void swift_weakDestroy(uint64_t *a1)
{
  uint64_t v1 = *a1;
  *a1 = 0;
  if ((v1 & 0x7FFFFFFFFFFFFFFELL) != 0)
  {
    _X6 = 0;
    _X7 = 0;
    __asm { CASP            X6, X7, X6, X7, [X8] }
    _X2 = _X6;
    _X5 = 0;
    __asm { CASP            X4, X5, X2, X3, [X8] }
    if (_X4 != _X6)
    {
      do
      {
        _X2 = _X4;
        _X7 = 0;
        __asm { CASP            X6, X7, X2, X3, [X8] }
        uint64_t v15 = _X6 ^ _X4;
        _X4 = _X6;
      }
      while (v15);
    }
  }
}

swift *swift_weakCopyInit(swift *result, void *a2)
{
  if ((*a2 & 0x7FFFFFFFFFFFFFFELL) != 0)
  {
    _X2 = 0;
    _X3 = 0;
    uint64_t v4 = 0;
    __asm { CASP            X2, X3, X2, X3, [X10] }
    if ((_X2 & 0x100000000) == 0)
    {
      _X2 = 0;
      _X3 = 0;
      __asm { CASP            X2, X3, X2, X3, [X10] }
      unint64_t v13 = 0;
      _X4 = _X2;
      while (1)
      {
        unint64_t v15 = _X3 | (v13 << 32);
        _X3 = (char *)v15;
        __asm { CASP            X2, X3, X4, X5, [X9] }
        if (_X2 == _X4) {
          break;
        }
        unint64_t v13 = HIDWORD(v15);
        _X4 = _X2;
        if (v15 == -1) {
          swift::swift_abortWeakRetainOverflow(result, (uint64_t)a2, _X2, (char *)v15);
        }
      }
      uint64_t v4 = *a2 & 0x7FFFFFFFFFFFFFFELL;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  uint64_t v17 = v4 | 1;
  if (!v4) {
    uint64_t v17 = 0;
  }
  *(void *)__n128 result = v17;
  return result;
}

void *swift_weakTakeInit(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *__n128 result = v2;
  return result;
}

uint64_t *swift_weakCopyAssign(uint64_t *a1, uint64_t *a2)
{
  return a1;
}

void swift::WeakReference::nativeCopyAssign(uint64_t *a1, uint64_t *a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *a1;
    *a1 = 0;
    if ((v4 & 0x7FFFFFFFFFFFFFFELL) != 0)
    {
      _X6 = 0;
      _X7 = 0;
      __asm { CASP            X6, X7, X6, X7, [X8] }
      _X2 = _X6;
      _X5 = 0;
      __asm { CASP            X4, X5, X2, X3, [X8] }
      if (_X4 != _X6)
      {
        do
        {
          _X2 = _X4;
          _X7 = 0;
          __asm { CASP            X6, X7, X2, X3, [X8] }
          uint64_t v18 = _X6 ^ _X4;
          _X4 = _X6;
        }
        while (v18);
      }
    }
    if ((*a2 & 0x7FFFFFFFFFFFFFFELL) != 0)
    {
      _X0 = 0;
      _X1 = 0;
      uint64_t v21 = 0;
      __asm { CASP            X0, X1, X0, X1, [X10] }
      if ((_X0 & 0x100000000) == 0)
      {
        _X0 = 0;
        _X1 = 0;
        __asm { CASP            X0, X1, X0, X1, [X10] }
        unint64_t v26 = 0;
        _X2 = _X0;
        while (1)
        {
          unint64_t v28 = (char *)(_X1 + 1);
          unint64_t v29 = _X1 | (v26 << 32);
          _X1 = v29;
          __asm { CASP            X0, X1, X2, X3, [X9]; this }
          if (_X0 == _X2) {
            break;
          }
          unint64_t v26 = HIDWORD(v29);
          _X2 = _X0;
          if (v29 == -1) {
            swift::swift_abortWeakRetainOverflow(_X0, v29, (const char *)_X0, v28);
          }
        }
        uint64_t v21 = *a2 & 0x7FFFFFFFFFFFFFFELL;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    uint64_t v31 = v21 | 1;
    if (!v21) {
      uint64_t v31 = 0;
    }
    *a1 = v31;
  }
}

uint64_t *swift_weakTakeAssign(uint64_t *result, uint64_t *a2)
{
  if (result != a2)
  {
    uint64_t v2 = *result;
    *__n128 result = 0;
    if ((v2 & 0x7FFFFFFFFFFFFFFELL) != 0)
    {
      _X6 = 0;
      _X7 = 0;
      __asm { CASP            X6, X7, X6, X7, [X8] }
      _X2 = _X6;
      _X5 = 0;
      __asm { CASP            X4, X5, X2, X3, [X8] }
      if (_X4 != _X6)
      {
        do
        {
          _X2 = _X4;
          _X7 = 0;
          __asm { CASP            X6, X7, X2, X3, [X8] }
          uint64_t v16 = _X6 ^ _X4;
          _X4 = _X6;
        }
        while (v16);
      }
    }
    uint64_t v17 = *a2;
    *a2 = 0;
    *__n128 result = v17;
  }
  return result;
}

uint64_t swift::ConcurrentReadableHashMap<MallocTypeCacheEntry,swift::LazyMutex>::find<unsigned int>(_DWORD *a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = *a1;
  uint64_t v5 = &unk_1EB1F3000;
  {
    uint64_t v21 = a1;
    uint64_t v19 = a4;
    unint64_t v17 = a3;
    unint64_t v20 = a2;
    uint64_t v18 = v4;
    uint64_t v5 = &unk_1EB1F3000;
    a3 = v17;
    uint64_t v4 = v18;
    a4 = v19;
    int v15 = v14;
    a2 = v20;
    a1 = v21;
    if (v15)
    {
      unint64_t v16 = __swift::__runtime::llvm::hashing::detail::fixed_seed_override;
      if (!__swift::__runtime::llvm::hashing::detail::fixed_seed_override) {
        unint64_t v16 = 0xFF51AFD7ED558CCDLL;
      }
      __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed = v16;
      uint64_t v5 = (void *)&unk_1EB1F3000;
      a3 = v17;
      uint64_t v4 = v18;
      a2 = v20;
      a1 = v21;
      a4 = v19;
    }
  }
  unint64_t v6 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v5[38] + 8 * v4)) ^ ((0x9DDFEA08EB382D69 * (v5[38] + 8 * v4)) >> 47));
  uint64_t v7 = 0x1DDFEA08EB382D69 * (v6 ^ (v6 >> 47));
  uint64_t v8 = (char *)(a2 & 0xFFFFFFFFFFFFFFFCLL);
  char v9 = 4;
  if ((a2 & 3) != 0 && v8) {
    char v9 = *v8;
  }
  if ((a2 & 3) == 0) {
    uint64_t v8 = 0;
  }
  while (2)
  {
    unint64_t v10 = v7 & ~(-1 << v9);
    if (v10 <= 1) {
      unint64_t v10 = 1;
    }
    switch(a2 & 3)
    {
      case 1uLL:
        LODWORD(v11) = v8 + v10;
        LOBYTE(v11) = atomic_load_explicit(&v8[v10], memory_order_acquire);
        if (v11) {
          goto LABEL_19;
        }
        return 0;
      case 2uLL:
        LODWORD(v11) = v8 + 2 * v10;
        LOWORD(v11) = atomic_load_explicit((atomic_ushort *volatile)&v8[2 * v10], memory_order_acquire);
        if (!v11) {
          return 0;
        }
        goto LABEL_19;
      case 3uLL:
        LODWORD(v11) = atomic_load_explicit((atomic_uint *volatile)&v8[4 * v10], memory_order_acquire);
        if (v11) {
          goto LABEL_19;
        }
        return 0;
      default:
        uint64_t v11 = (a2 >> (4 * v10)) & 0xF;
        if (v11)
        {
LABEL_19:
          unint64_t v12 = (v11 - 1);
          if (v12 < a3 && *(_DWORD *)(a4 + 8 * v12) == *a1) {
            return a4 + 8 * v12;
          }
          uint64_t v7 = v10 + 1;
          continue;
        }
        return 0;
    }
  }
}

unint64_t swift::ConcurrentReadableHashMap<MallocTypeCacheEntry,swift::LazyMutex>::resize(uint64_t a1, unint64_t a2, unsigned int a3, uint64_t a4)
{
  char v8 = a3 + 1;
  unsigned int v9 = (a3 + 1);
  if (v9 >= 0x11) {
    unsigned int v10 = 4;
  }
  else {
    unsigned int v10 = 2;
  }
  if (v9 < 9) {
    size_t v11 = 1;
  }
  else {
    size_t v11 = v10;
  }
  unint64_t v12 = (unint64_t)malloc_type_calloc(2 << a3, v11, 0x4269077AuLL);
  if (!v12) {
    swift::hashable_support::findHashableBaseTypeOfHashableType();
  }
  if (v11 != 1)
  {
    if (v11 == 4) {
      size_t v11 = 3;
    }
    else {
      size_t v11 = 2;
    }
  }
  unint64_t v13 = v11 | v12;
  *(unsigned char *)unint64_t v12 = v8;
  if (a3)
  {
    uint64_t v14 = a3;
    uint64_t v15 = ~(-2 << a3);
    uint64_t v16 = a2 & 3;
    uint64_t v17 = v16;
    unint64_t v18 = a2 & 0xFFFFFFFFFFFFFFFCLL;
    if ((a2 & 3) != 0) {
      unint64_t v19 = a2 & 0xFFFFFFFFFFFFFFFCLL;
    }
    else {
      unint64_t v19 = 0;
    }
    unint64_t v20 = v13 & 3;
    unint64_t v21 = v12 & 0xFFFFFFFFFFFFFFFCLL;
    if ((v13 & 3) == 0) {
      unint64_t v21 = 0;
    }
    uint64_t v22 = 1;
    uint64_t v23 = (void *)&unk_1EB1F3000;
    while (2)
    {
      switch(v16)
      {
        case 0:
          uint64_t v25 = (a2 >> (4 * v22)) & 0xF;
          if (!v25) {
            goto LABEL_20;
          }
          goto LABEL_29;
        case 1:
          LODWORD(v25) = *(unsigned __int8 *)(v19 + v22);
          if (*(unsigned char *)(v19 + v22)) {
            goto LABEL_29;
          }
          goto LABEL_20;
        case 2:
          LODWORD(v25) = *(unsigned __int16 *)(v19 + 2 * v22);
          if (!*(_WORD *)(v19 + 2 * v22)) {
            goto LABEL_20;
          }
          goto LABEL_29;
        case 3:
          LODWORD(v25) = *(_DWORD *)(v19 + 4 * v22);
          if (!v25) {
            goto LABEL_20;
          }
LABEL_29:
          uint64_t v26 = *(unsigned int *)(a4 + 8 * (v25 - 1));
          if ((atomic_load_explicit((atomic_uchar *volatile)v24, memory_order_acquire) & 1) == 0)
          {
            uint64_t v31 = v24;
            uint64_t v38 = v16;
            uint64_t v39 = v17;
            unint64_t v36 = v20;
            uint64_t v37 = v14;
            uint64_t v40 = v15;
            unint64_t v41 = v19;
            unint64_t v42 = v21;
            uint64_t v43 = v22;
            int v44 = v25;
            uint64_t v45 = v26;
            int v32 = __cxa_guard_acquire(v24);
            uint64_t v26 = v45;
            LODWORD(v25) = v44;
            uint64_t v23 = &unk_1EB1F3000;
            unint64_t v21 = v42;
            uint64_t v22 = v43;
            uint64_t v15 = v40;
            unint64_t v19 = v41;
            unint64_t v20 = v36;
            uint64_t v14 = v37;
            uint64_t v16 = v38;
            uint64_t v17 = v39;
            int v24 = v31;
            if (v32)
            {
              unint64_t v33 = __swift::__runtime::llvm::hashing::detail::fixed_seed_override;
              if (!__swift::__runtime::llvm::hashing::detail::fixed_seed_override) {
                unint64_t v33 = 0xFF51AFD7ED558CCDLL;
              }
              __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed = v33;
              __cxa_guard_release(v31);
              uint64_t v26 = v45;
              LODWORD(v25) = v44;
              uint64_t v23 = (void *)&unk_1EB1F3000;
              unint64_t v21 = v42;
              uint64_t v22 = v43;
              uint64_t v15 = v40;
              unint64_t v19 = v41;
              unint64_t v20 = v36;
              uint64_t v14 = v37;
              uint64_t v16 = v38;
              uint64_t v17 = v39;
              int v24 = v31;
            }
          }
          unint64_t v27 = 0x9DDFEA08EB382D69
              * ((0x9DDFEA08EB382D69 * (v23[38] + 8 * v26)) ^ ((0x9DDFEA08EB382D69 * (v23[38] + 8 * v26)) >> 47));
          for (unint64_t i = 0x9DDFEA08EB382D69 * (v27 ^ (v27 >> 47)); ; unint64_t i = v30 + 1)
          {
            unint64_t v30 = i & v15;
            if ((i & v15) != 0)
            {
              switch((int)v20)
              {
                case 1:
                  LODWORD(v29) = *(unsigned __int8 *)(v21 + v30);
                  break;
                case 2:
                  LODWORD(v29) = *(unsigned __int16 *)(v21 + 2 * v30);
                  break;
                case 3:
                  LODWORD(v29) = *(_DWORD *)(v21 + 4 * v30);
                  break;
                default:
                  uint64_t v29 = (v13 >> (4 * v30)) & 0xF;
                  break;
              }
              if (!v29) {
                break;
              }
            }
          }
          if (v20 == 3)
          {
            *(_DWORD *)(v21 + 4 * v3swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v25;
          }
          else if (v20 == 2)
          {
            *(_WORD *)(v21 + 2 * v3swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v25;
          }
          else
          {
            *(unsigned char *)(v21 + v3swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v25;
          }
LABEL_20:
          if (!((unint64_t)++v22 >> v14)) {
            continue;
          }
          goto LABEL_48;
        default:
          JUMPOUT(0);
      }
    }
  }
  uint64_t v17 = a2 & 3;
  unint64_t v18 = a2 & 0xFFFFFFFFFFFFFFFCLL;
LABEL_48:
  atomic_store(v13, (unint64_t *)(a1 + 16));
  if (v17 && v18)
  {
    unint64_t v34 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
    void *v34 = *(void *)(a1 + 32);
    v34[1] = v18;
    *(void *)(a1 + 32) = v34;
  }
  return v13;
}

uint64_t swift_initStaticObject::$_0::__invoke(uint64_t this, void *a2)
{
  uint64_t v2 = *(void **)this;
  *uint64_t v2 = *(void *)(this + 8);
  v2[1] = 0x80000004FFFFFFFFLL;
  return this;
}

uint64_t swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)1>(atomic_ullong *a1, uint64_t _X1, uint64_t a3)
{
  if (a3 != 1 && (_X1 & 0x80000000FFFFFFFFLL) == 0x80000000FFFFFFFFLL) {
    return 0;
  }
  BOOL v4 = a3 > 1;
  uint64_t v5 = a3 << 33;
  while (1)
  {
    BOOL v7 = _X1 >= 0 || a3 < 2;
    if (v7 && ((_X1 - v5) & 0x8000000000000000) == 0)
    {
      uint64_t v6 = _X1;
      atomic_compare_exchange_strong_explicit(a1, (unint64_t *)&v6, _X1 - v5, memory_order_release, memory_order_relaxed);
      if (v6 == _X1) {
        return 0;
      }
      goto LABEL_6;
    }
    if (_X1 == -1) {
      return 0;
    }
    if (_X1 < 0) {
      break;
    }
    uint64_t v6 = _X1;
    atomic_compare_exchange_strong_explicit(a1, (unint64_t *)&v6, _X1 & 0x80000000FFFFFFFFLL | 0x100000000, memory_order_release, memory_order_relaxed);
    if (v6 == _X1)
    {
      __dmb(9u);
      char v8 = a1 - 1;
LABEL_16:
      _swift_release_dealloc(v8);
      return 1;
    }
LABEL_6:
    _X1 = v6;
  }
  _X4 = 0;
  _X5 = 0;
  size_t v11 = (atomic_ullong **)(8 * _X1);
  __asm { CASP            X4, X5, X4, X5, [X11] }
  LODWORD(_X1) = 0;
  unint64_t v16 = 0;
  if (a3 == 1)
  {
    BOOL v4 = 0;
    goto LABEL_22;
  }
  uint64_t v17 = _X4;
  if ((_X4 & 0x8000000000000000) == 0 || _X4 != 0xFFFFFFFFLL)
  {
    if (a3 >= 2 && _X4 < 0)
    {
      unint64_t v24 = 0;
    }
    else
    {
LABEL_22:
      while (1)
      {
        _X6 = _X4 - v5;
        if (_X4 - v5 < 0) {
          break;
        }
        unint64_t v19 = _X1 | (v16 << 32);
        _X1 = v19;
        __asm { CASPL           X0, X1, X6, X7, [X11] }
        if (_X0 == _X4) {
          return 0;
        }
        unint64_t v21 = HIDWORD(v19);
        BOOL v22 = _X0 < 0 && v4;
        _X4 = _X0;
        unint64_t v16 = HIDWORD(v19);
        uint64_t v23 = _X0;
        if (v22) {
          goto LABEL_33;
        }
      }
      unint64_t v21 = v16;
      uint64_t v23 = _X4;
LABEL_33:
      uint64_t v17 = v23;
      unint64_t v24 = v21;
      _X4 = v23;
    }
    if (v17 != 0xFFFFFFFFLL && (a3 == 1 || (_X4 & 0x80000000FFFFFFFFLL) != 0x80000000FFFFFFFFLL))
    {
      while (1)
      {
        _X6 = _X4 - v5;
        BOOL v29 = a3 >= 2 && _X4 < 0 || _X6 < 0;
        char v30 = !v29;
        if (v29)
        {
          if (_X4 == -1) {
            return 0;
          }
          _X6 = _X4 & 0x80000000FFFFFFFFLL | 0x100000000;
        }
        unint64_t v25 = _X1 | (v24 << 32);
        _X1 = v25;
        __asm { CASPL           X0, X1, X6, X7, [X10] }
        if (_X0 == _X4) {
          break;
        }
        unint64_t v24 = HIDWORD(v25);
        _X4 = _X0;
      }
      if ((v30 & 1) == 0)
      {
        __dmb(9u);
        char v8 = *v11;
        goto LABEL_16;
      }
    }
  }
  return 0;
}

uint64_t swift::WeakReference::nativeTakeStrongFromBits(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  BOOL v4 = (uint64_t *)(a2 & 0x7FFFFFFFFFFFFFFELL);
  if ((a2 & 0x7FFFFFFFFFFFFFFELL) == 0) {
    return 0;
  }
  _X4 = 0;
  _X5 = 0;
  uint64_t v7 = 0;
  __asm { CASP            X4, X5, X4, X5, [X20] }
  if ((_X4 & 0x100000000) == 0)
  {
    unint64_t v13 = 0;
    LODWORD(_X1) = 0;
    while (1)
    {
      _X2 = _X4 + 0x200000000;
      if (_X4 + 0x200000000 < 0) {
        break;
      }
      a4 = (char *)_X1;
      unint64_t v16 = _X1 | (v13 << 32);
      _X1 = v16;
      __asm { CASP            X0, X1, X2, X3, [X20] }
      if (_X0 == _X4) {
        goto LABEL_11;
      }
      unint64_t v13 = HIDWORD(v16);
      _X4 = _X0;
      if ((_X0 & 0x100000000) != 0) {
        goto LABEL_7;
      }
    }
    if (_X4 != -1
      && !swift::RefCounts<swift::SideTableRefCountBits>::tryIncrementSlow((swift *)(v4 + 2), _X4, (const char *)(_X1 | (v13 << 32)), a4))
    {
LABEL_7:
      uint64_t v7 = 0;
      goto LABEL_12;
    }
LABEL_11:
    uint64_t v7 = *v4;
  }
LABEL_12:
  _X4 = 0;
  _X5 = 0;
  __asm { CASP            X4, X5, X4, X5, [X20] }
  _X0 = _X4;
  _X3 = 0;
  __asm { CASP            X2, X3, X0, X1, [X20] }
  if (_X2 != _X4)
  {
    do
    {
      _X0 = _X2;
      _X5 = 0;
      __asm { CASP            X4, X5, X0, X1, [X20] }
      uint64_t v27 = _X4 ^ _X2;
      _X2 = _X4;
    }
    while (v27);
  }
  return v7;
}

uint64_t swift::ConcurrentReadableHashMap<swift::HashMapElementWrapper<anonymous namespace'::BoxCacheEntry>,swift::LazyMutex>::find<swift::TargetMetadata<swift::InProcess> const*>(unint64_t *a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v4 = *a1;
  uint64_t v5 = &unk_1EB1F3000;
  {
    BOOL v22 = a1;
    uint64_t v20 = a4;
    unint64_t v18 = a3;
    unint64_t v21 = a2;
    unint64_t v19 = v4;
    uint64_t v5 = &unk_1EB1F3000;
    a3 = v18;
    unint64_t v4 = v19;
    a4 = v20;
    int v16 = v15;
    a2 = v21;
    a1 = v22;
    if (v16)
    {
      unint64_t v17 = __swift::__runtime::llvm::hashing::detail::fixed_seed_override;
      if (!__swift::__runtime::llvm::hashing::detail::fixed_seed_override) {
        unint64_t v17 = 0xFF51AFD7ED558CCDLL;
      }
      __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed = v17;
      uint64_t v5 = (void *)&unk_1EB1F3000;
      a3 = v18;
      unint64_t v4 = v19;
      a2 = v21;
      a1 = v22;
      a4 = v20;
    }
  }
  uint64_t v6 = (v5[38] + 8 * v4) ^ HIDWORD(v4);
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(v4) ^ ((0x9DDFEA08EB382D69 * v6) >> 47) ^ (0x9DDFEA08EB382D69 * v6));
  uint64_t v8 = 0x1DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unsigned int v9 = (char *)(a2 & 0xFFFFFFFFFFFFFFFCLL);
  char v10 = 4;
  if ((a2 & 3) != 0 && v9) {
    char v10 = *v9;
  }
  if ((a2 & 3) == 0) {
    unsigned int v9 = 0;
  }
  while (2)
  {
    unint64_t v11 = v8 & ~(-1 << v10);
    if (v11 <= 1) {
      unint64_t v11 = 1;
    }
    switch(a2 & 3)
    {
      case 1uLL:
        LODWORD(v12) = v9 + v11;
        LOBYTE(v12) = atomic_load_explicit(&v9[v11], memory_order_acquire);
        if (v12) {
          goto LABEL_19;
        }
        return 0;
      case 2uLL:
        LODWORD(v12) = v9 + 2 * v11;
        LOWORD(v12) = atomic_load_explicit((atomic_ushort *volatile)&v9[2 * v11], memory_order_acquire);
        if (!v12) {
          return 0;
        }
        goto LABEL_19;
      case 3uLL:
        LODWORD(v12) = atomic_load_explicit((atomic_uint *volatile)&v9[4 * v11], memory_order_acquire);
        if (v12) {
          goto LABEL_19;
        }
        return 0;
      default:
        uint64_t v12 = (a2 >> (4 * v11)) & 0xF;
        if (v12)
        {
LABEL_19:
          unint64_t v13 = (v12 - 1);
          if (v13 < a3 && *(void *)(*(void *)(a4 + 8 * v13) + 40) == *a1) {
            return a4 + 8 * v13;
          }
          uint64_t v8 = v11 + 1;
          continue;
        }
        return 0;
    }
  }
}

void anonymous namespace'::destroyGenericBox()
{
  if (*(void *)v0) {
    uint64_t v1 = *(void *)v0;
  }
  else {
    uint64_t v1 = 0;
  }
  if (*(void *)(*(void *)(v1 + 16) - 8)) {
    uint64_t v2 = *(void *)(*(void *)(v1 + 16) - 8);
  }
  else {
    uint64_t v2 = 0;
  }
  (*(void (**)(char *))(v2 + 8))(&v0[*(unsigned int *)(v1 + 8)]);

  swift_deallocObject((uint64_t)v0);
}

uint64_t swift::HeapObjectSideTableEntry::decrementNonAtomicStrong<(swift::PerformDeinit)1>(void **a1, uint64_t a2)
{
  _X4 = 0;
  _X5 = 0;
  __asm { CASP            X4, X5, X4, X5, [X8] }
  LODWORD(_X3) = 0;
  unint64_t v9 = 0;
  if (a2 == 1)
  {
    BOOL v12 = 0;
LABEL_6:
    uint64_t v13 = a2 << 33;
    while (1)
    {
      _X6 = _X4 - v13;
      if (_X4 - v13 < 0) {
        break;
      }
      unint64_t v15 = _X3 | (v9 << 32);
      _X3 = v15;
      __asm { CASPL           X2, X3, X6, X7, [X8] }
      if (_X2 == _X4) {
        return 0;
      }
      unint64_t v17 = HIDWORD(v15);
      BOOL v18 = _X2 < 0 && v12;
      _X4 = _X2;
      unint64_t v9 = HIDWORD(v15);
      uint64_t v19 = _X2;
      if (v18) {
        goto LABEL_18;
      }
    }
    unint64_t v17 = v9;
    uint64_t v19 = _X4;
LABEL_18:
    uint64_t v10 = v19;
    unint64_t v9 = v17;
    _X4 = v19;
    goto LABEL_19;
  }
  uint64_t v10 = _X4;
  if (_X4 < 0 && _X4 == 0xFFFFFFFFLL) {
    return 0;
  }
  BOOL v12 = a2 > 1;
  if (a2 < 2 || (_X4 & 0x8000000000000000) == 0) {
    goto LABEL_6;
  }
LABEL_19:
  if (v10 == 0xFFFFFFFFLL || a2 != 1 && (_X4 & 0x80000000FFFFFFFFLL) == 0x80000000FFFFFFFFLL) {
    return 0;
  }
  while (1)
  {
    _X6 = _X4 - (a2 << 33);
    BOOL v22 = a2 >= 2 && _X4 < 0 || _X6 < 0;
    char v23 = !v22;
    if (v22)
    {
      if (_X4 == -1) {
        return 0;
      }
      _X6 = _X4 & 0x80000000FFFFFFFFLL | 0x100000000;
    }
    unint64_t v24 = _X3 | (v9 << 32);
    _X3 = v24;
    __asm { CASPL           X2, X3, X6, X7, [X8] }
    if (_X2 == _X4) {
      break;
    }
    unint64_t v9 = HIDWORD(v24);
    _X4 = _X2;
  }
  if (v23) {
    return 0;
  }
  __dmb(9u);
  _swift_release_dealloc(*a1);
  return 1;
}

uint64_t swift::HeapObjectSideTableEntry::decrementUnownedShouldFree(swift::HeapObjectSideTableEntry *this, int a2)
{
  _X2 = 0;
  _X3 = 0;
  __asm { CASP            X2, X3, X2, X3, [X9] }
  if (_X2 < 0 && _X2 == 0xFFFFFFFFLL) {
    return 0;
  }
  int v9 = (_X2 >> 1) - a2;
  _X6 = (2 * v9) | _X2 & 0xFFFFFFFF00000001;
  _X5 = 0;
  __asm { CASP            X4, X5, X6, X7, [X9] }
  if (_X4 != _X2)
  {
    do
    {
      int v9 = (_X4 >> 1) - a2;
      _X2 = (2 * v9) | _X4 & 0xFFFFFFFF00000001;
      _X7 = 0;
      __asm { CASP            X6, X7, X2, X3, [X9] }
      uint64_t v16 = _X6 ^ _X4;
      _X4 = _X6;
    }
    while (v16);
  }
  if ((v9 & 0x7FFFFFFF) != 0) {
    return 0;
  }
  _X6 = 0;
  _X7 = 0;
  __asm { CASP            X6, X7, X6, X7, [X8] }
  _X2 = _X6;
  _X5 = 0;
  __asm { CASP            X4, X5, X2, X3, [X8] }
  if (_X4 != _X6)
  {
    do
    {
      _X2 = _X4;
      _X7 = 0;
      __asm { CASP            X6, X7, X2, X3, [X8] }
      uint64_t v28 = _X6 ^ _X4;
      _X4 = _X6;
    }
    while (v28);
  }
  return 1;
}

BOOL swift::RefCounts<swift::RefCountBitsT<(swift::RefCountInlinedness)1>>::doDecrementSlow<(swift::PerformDeinit)0>(atomic_ullong *a1, uint64_t a2, uint64_t a3)
{
  if (a3 != 1 && (a2 & 0x80000000FFFFFFFFLL) == 0x80000000FFFFFFFFLL) {
    return 0;
  }
  BOOL v4 = a3 > 1;
  uint64_t v5 = a3 << 33;
  while (1)
  {
    BOOL v6 = a2 >= 0 || a3 < 2;
    unint64_t v7 = a2 - v5;
    if (a2 - v5 < 0) {
      BOOL v6 = 0;
    }
    if (!v6) {
      break;
    }
LABEL_14:
    uint64_t v8 = a2;
    atomic_compare_exchange_strong_explicit(a1, (unint64_t *)&v8, v7, memory_order_release, memory_order_relaxed);
    if (v8 == a2) {
      return !v6;
    }
    a2 = v8;
  }
  if (a2 == -1) {
    return 0;
  }
  if ((a2 & 0x8000000000000000) == 0)
  {
    unint64_t v7 = a2 & 0x80000000FFFFFFFFLL | 0x100000000;
    goto LABEL_14;
  }
  _X4 = 0;
  _X5 = 0;
  __asm { CASP            X4, X5, X4, X5, [X11] }
  LODWORD(_X1) = 0;
  unint64_t v16 = 0;
  if (a3 == 1)
  {
    BOOL v4 = 0;
    goto LABEL_23;
  }
  uint64_t v17 = _X4;
  if ((_X4 & 0x8000000000000000) == 0 || _X4 != 0xFFFFFFFFLL)
  {
    if (a3 >= 2 && _X4 < 0)
    {
      unint64_t v18 = 0;
    }
    else
    {
LABEL_23:
      while (1)
      {
        _X6 = _X4 - v5;
        if (_X4 - v5 < 0) {
          break;
        }
        unint64_t v20 = _X1 | (v16 << 32);
        _X1 = v20;
        __asm { CASPL           X0, X1, X6, X7, [X11] }
        if (_X0 == _X4) {
          return 0;
        }
        unint64_t v22 = HIDWORD(v20);
        BOOL v23 = _X0 < 0 && v4;
        _X4 = _X0;
        unint64_t v16 = HIDWORD(v20);
        uint64_t v24 = _X0;
        if (v23) {
          goto LABEL_31;
        }
      }
      unint64_t v22 = v16;
      uint64_t v24 = _X4;
LABEL_31:
      uint64_t v17 = v24;
      unint64_t v18 = v22;
      _X4 = v24;
    }
    if (v17 != 0xFFFFFFFFLL && (a3 == 1 || (_X4 & 0x80000000FFFFFFFFLL) != 0x80000000FFFFFFFFLL))
    {
      while (1)
      {
        _X6 = _X4 - v5;
        BOOL v27 = a3 >= 2 && _X4 < 0 || _X6 < 0;
        BOOL v6 = !v27;
        if (v27)
        {
          if (_X4 == -1) {
            return 0;
          }
          _X6 = _X4 & 0x80000000FFFFFFFFLL | 0x100000000;
        }
        unint64_t v28 = _X1 | (v18 << 32);
        _X1 = v28;
        __asm { CASPL           X0, X1, X6, X7, [X10] }
        if (_X0 == _X4) {
          break;
        }
        unint64_t v18 = HIDWORD(v28);
        _X4 = _X0;
      }
      return !v6;
    }
  }
  return 0;
}

uint64_t swift::initializeProtocolLookup(swift *this)
{
}

void anonymous namespace'::addImageCallback<&anonymous namespace'::TextSegment,&anonymous namespace'::ProtocolsSection,0,&(swift::addImageProtocolsBlockCallbackUnsafe(void const*,void const*,unsigned long))>(swift *a1)
{
  unint64_t v2 = _dyld_lookup_section_info();
  if (v2)
  {
    swift::addImageProtocolsBlockCallbackUnsafe(a1, v2, v3);
  }
}

uint64_t swift::initializeProtocolConformanceLookup(swift *this)
{
}

void anonymous namespace'::addImageCallback<&anonymous namespace'::TextSegment,&anonymous namespace'::ProtocolConformancesSection,1,&(swift::addImageProtocolConformanceBlockCallbackUnsafe(void const*,void const*,unsigned long))>(swift *a1)
{
  unint64_t v2 = _dyld_lookup_section_info();
  if (v2)
  {
    swift::addImageProtocolConformanceBlockCallbackUnsafe(a1, v2, v3);
  }
}

uint64_t swift::initializeTypeMetadataRecordLookup(swift *this)
{
}

void anonymous namespace'::addImageCallback<&anonymous namespace'::TextSegment,&anonymous namespace'::TypeMetadataRecordSection,2,&(swift::addImageTypeMetadataRecordBlockCallbackUnsafe(void const*,void const*,unsigned long))>(swift *a1)
{
  unint64_t v2 = _dyld_lookup_section_info();
  if (v2)
  {
    swift::addImageTypeMetadataRecordBlockCallbackUnsafe(a1, v2, v3);
  }
}

uint64_t swift::initializeDynamicReplacementLookup(swift *this)
{
}

void anonymous namespace'::addImageCallback2Sections<&anonymous namespace'::TextSegment,&anonymous namespace'::DynamicReplacementSection,&anonymous namespace'::TextSegment,&anonymous namespace'::DynamicReplacementSomeSection,3,4,&(swift::addImageDynamicReplacementBlockCallback(void const*,void const*,unsigned long,void const*,unsigned long))>(swift *a1)
{
  uint64_t v2 = _dyld_lookup_section_info();
  if (v2)
  {
    BOOL v4 = (unsigned int *)v2;
    uint64_t v5 = v3;
    unint64_t v7 = _dyld_lookup_section_info();
    swift::addImageDynamicReplacementBlockCallback(a1, v4, v5, v7, v6);
  }
}

uint64_t swift::initializeAccessibleFunctionsLookup(swift *this)
{
}

void anonymous namespace'::addImageCallback<&anonymous namespace'::TextSegment,&anonymous namespace'::AccessibleFunctionsSection,5,&(swift::addImageAccessibleFunctionsBlockCallbackUnsafe(void const*,void const*,unsigned long))>(swift *a1)
{
  unint64_t v2 = _dyld_lookup_section_info();
  if (v2)
  {
    swift::addImageAccessibleFunctionsBlockCallbackUnsafe(a1, v2, v3);
  }
}

uint64_t swift::SymbolInfo::getFilename(swift::SymbolInfo *this)
{
  return *(void *)this;
}

uint64_t swift::SymbolInfo::getBaseAddress(swift::SymbolInfo *this)
{
  return *((void *)this + 1);
}

uint64_t swift::SymbolInfo::getSymbolAddress(swift::SymbolInfo *this)
{
  return *((void *)this + 3);
}

uint64_t swift::SymbolInfo::lookup@<X0>(swift::SymbolInfo *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = dladdr(this, &v7);
  if (result)
  {
    long long v5 = *(_OWORD *)&v7.dli_sname;
    *(_OWORD *)a2 = *(_OWORD *)&v7.dli_fname;
    *(_OWORD *)(a2 + 16) = v5;
    char v6 = 1;
  }
  else
  {
    char v6 = 0;
    *(unsigned char *)a2 = 0;
  }
  *(unsigned char *)(a2 + 32) = v6;
  return result;
}

void *swift_copyKeyPathTrivialIndices(void *__src, void *__dst, size_t a3)
{
  return memcpy(__dst, __src, a3);
}

uint64_t equateGenericArguments(const void *a1, const void *a2)
{
  return 1;
}

uint64_t hashGenericArguments(const void *a1)
{
  return 0;
}

void (*swift_readAtKeyPath(uint64_t *a1, uint64_t a2, unint64_t **a3))(uint64_t *a1)
{
  if (*a3) {
    long long v5 = *a3;
  }
  else {
    long long v5 = 0;
  }
  uint64_t v6 = swift::TargetMetadata<swift::InProcess>::getGenericArgs(v5)[1];
  *a1 = v6;
  BufferIn = swift::TargetMetadata<swift::InProcess>::allocateBufferIn(v6, a1 + 1);
  swift_getAtKeyPath(a2, v8, v9, (uint64_t)BufferIn);
  return _destroy_temporary_continuation;
}

void _destroy_temporary_continuation(uint64_t *a1)
{
  unint64_t v2 = (void **)(a1 + 1);
  uint64_t v3 = *a1;
  uint64_t v4 = swift::TargetMetadata<swift::InProcess>::projectBufferFrom(*a1, (uint64_t)(a1 + 1));
  if (*(void *)(v3 - 8)) {
    uint64_t v5 = *(void *)(v3 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  (*(void (**)(uint64_t, uint64_t))(v5 + 8))(v4, v3);
  uint64_t v6 = *a1;

  swift::TargetMetadata<swift::InProcess>::deallocateBufferIn(v6, v2);
}

void (*swift_modifyAtWritableKeyPath(void *a1, void **a2, uint64_t a3))(id *a1)
{
  _swift_modifyAtWritableKeyPath_impl(a2, a3);
  *a1 = v4;
  return _release_owner_continuation;
}

void _release_owner_continuation(id *a1)
{
}

void (*swift_modifyAtReferenceWritableKeyPath(void *a1, uint64_t a2))(id *a1)
{
  _swift_modifyAtReferenceWritableKeyPath_impl(a2);
  *a1 = v3;
  return _release_owner_continuation;
}

void *swift_copyPOD(void *a1, const void *a2, uint64_t a3)
{
  return memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
}

unsigned char *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned char,1ul,1ul,1ul>>,true,1ul,1ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(unsigned char *result, unsigned char *a2)
{
  *uint64_t result = *a2;
  return result;
}

unsigned char *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned char,1ul,1ul,1ul>>::initializeWithCopy(unsigned char *result, unsigned char *a2)
{
  *uint64_t result = *a2;
  return result;
}

unsigned char *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned char,1ul,1ul,1ul>>::assignWithCopy(unsigned char *result, unsigned char *a2)
{
  *uint64_t result = *a2;
  return result;
}

unsigned char *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned char,1ul,1ul,1ul>>::initializeWithTake(unsigned char *result, unsigned char *a2)
{
  *uint64_t result = *a2;
  return result;
}

unsigned char *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned char,1ul,1ul,1ul>>::assignWithTake(unsigned char *result, unsigned char *a2)
{
  *uint64_t result = *a2;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned char,1ul,1ul,1ul>>,true,1ul,1ul,false>::getEnumTagSinglePayload(unsigned __int8 *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  unsigned int v2 = a2 + 255;
  if ((a2 + 255) < 0x100) {
    return 0;
  }
  if (v2 >> 8 < 0xFF)
  {
    int v3 = a1[1];
    if (!a1[1]) {
      return 0;
    }
    return (*a1 | (v3 << 8)) - 255;
  }
  if (v2 >= 0xFFFF00)
  {
    int v3 = *(_DWORD *)(a1 + 1);
    if (v3) {
      return (*a1 | (v3 << 8)) - 255;
    }
  }
  else
  {
    int v3 = *(unsigned __int16 *)(a1 + 1);
    if (*(_WORD *)(a1 + 1)) {
      return (*a1 | (v3 << 8)) - 255;
    }
  }
  return 0;
}

void swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned char,1ul,1ul,1ul>>,true,1ul,1ul,false>::storeEnumTagSinglePayload(unsigned char *a1, int a2, int a3)
{
  if (a3 && (unsigned int v3 = a3 + 255, (a3 + 255) >= 0x100))
  {
    if (v3 >= 0xFFFF00) {
      unsigned int v4 = 4;
    }
    else {
      unsigned int v4 = 2;
    }
    if (v3 >> 8 < 0xFF) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    if (a2)
    {
      unsigned int v6 = ((a2 - 1) >> 8) + 1;
      *a1 = a2 - 1;
      switch((int)v5)
      {
        case 1:
          a1[1] = v6;
          break;
        case 2:
          *(_WORD *)(a1 + 1) = v6;
          break;
        case 3:
          *(_WORD *)(a1 + 1) = v6;
          a1[3] = BYTE2(v6);
          break;
        case 4:
          *(_DWORD *)(a1 + 1) = v6;
          break;
        default:
          *(_DWORD *)(a1 + 1) = v6;
          goto LABEL_22;
      }
    }
    else
    {
      switch(v5)
      {
        case 1:
          a1[1] = 0;
          break;
        case 2:
          *(_WORD *)(a1 + 1) = 0;
          break;
        case 3:
          a1[3] = 0;
          *(_WORD *)(a1 + 1) = 0;
          break;
        case 4:
          *(_DWORD *)(a1 + 1) = 0;
          break;
        default:
          *(_DWORD *)(a1 + 1) = 0;
LABEL_22:
          bzero(a1 + 5, v5 - 4);
          break;
      }
    }
  }
  else if (a2)
  {
    *a1 = a2 - 1;
  }
}

_WORD *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned short,2ul,2ul,2ul>>,true,2ul,2ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(_WORD *result, _WORD *a2)
{
  *uint64_t result = *a2;
  return result;
}

_WORD *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned short,2ul,2ul,2ul>>::initializeWithCopy(_WORD *result, _WORD *a2)
{
  *uint64_t result = *a2;
  return result;
}

_WORD *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned short,2ul,2ul,2ul>>::assignWithCopy(_WORD *result, _WORD *a2)
{
  *uint64_t result = *a2;
  return result;
}

_WORD *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned short,2ul,2ul,2ul>>::initializeWithTake(_WORD *result, _WORD *a2)
{
  *uint64_t result = *a2;
  return result;
}

_WORD *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned short,2ul,2ul,2ul>>::assignWithTake(_WORD *result, _WORD *a2)
{
  *uint64_t result = *a2;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned short,2ul,2ul,2ul>>,true,2ul,2ul,false>::getEnumTagSinglePayload(unsigned __int16 *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  unsigned int v2 = a2 + 0xFFFF;
  if ((a2 + 0xFFFF) < 0x10000) {
    return 0;
  }
  if (v2 < 0xFF0000)
  {
    int v3 = *((unsigned __int8 *)a1 + 2);
    if (!*((unsigned char *)a1 + 2)) {
      return 0;
    }
    return (*a1 | (v3 << 16)) - 0xFFFF;
  }
  if (v2 <= 0xFFFEFFFF)
  {
    int v3 = a1[1];
    if (a1[1]) {
      return (*a1 | (v3 << 16)) - 0xFFFF;
    }
  }
  else
  {
    int v3 = *(_DWORD *)(a1 + 1);
    if (v3) {
      return (*a1 | (v3 << 16)) - 0xFFFF;
    }
  }
  return 0;
}

void swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned short,2ul,2ul,2ul>>,true,2ul,2ul,false>::storeEnumTagSinglePayload(uint64_t a1, int a2, int a3)
{
  if (a3 && (unsigned int v3 = a3 + 0xFFFF, (a3 + 0xFFFF) >= 0x10000))
  {
    if (v3 <= 0xFFFEFFFF) {
      unsigned int v4 = 2;
    }
    else {
      unsigned int v4 = 4;
    }
    if (v3 < 0xFF0000) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    if (a2)
    {
      unsigned int v6 = ((a2 - 1) >> 16) + 1;
      *(_WORD *)a1 = a2 - 1;
      switch((int)v5)
      {
        case 1:
          *(unsigned char *)(a1 + 2) = v6;
          break;
        case 2:
          *(_WORD *)(a1 + 2) = v6;
          break;
        case 3:
          *(_WORD *)(a1 + 2) = v6;
          *(unsigned char *)(a1 + 4) = BYTE2(v6);
          break;
        case 4:
          *(_DWORD *)(a1 + 2) = v6;
          break;
        default:
          *(_DWORD *)(a1 + 2) = v6;
          goto LABEL_22;
      }
    }
    else
    {
      switch(v5)
      {
        case 1:
          *(unsigned char *)(a1 + 2) = 0;
          break;
        case 2:
          *(_WORD *)(a1 + 2) = 0;
          break;
        case 3:
          *(unsigned char *)(a1 + 4) = 0;
          *(_WORD *)(a1 + 2) = 0;
          break;
        case 4:
          *(_DWORD *)(a1 + 2) = 0;
          break;
        default:
          *(_DWORD *)(a1 + 2) = 0;
LABEL_22:
          bzero((void *)(a1 + 6), v5 - 4);
          break;
      }
    }
  }
  else if (a2)
  {
    *(_WORD *)a1 = a2 - 1;
  }
}

_DWORD *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned int,4ul,4ul,4ul>>,true,4ul,4ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(_DWORD *result, _DWORD *a2)
{
  *uint64_t result = *a2;
  return result;
}

_DWORD *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned int,4ul,4ul,4ul>>::initializeWithCopy(_DWORD *result, _DWORD *a2)
{
  *uint64_t result = *a2;
  return result;
}

_DWORD *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned int,4ul,4ul,4ul>>::assignWithCopy(_DWORD *result, _DWORD *a2)
{
  *uint64_t result = *a2;
  return result;
}

_DWORD *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned int,4ul,4ul,4ul>>::initializeWithTake(_DWORD *result, _DWORD *a2)
{
  *uint64_t result = *a2;
  return result;
}

_DWORD *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned int,4ul,4ul,4ul>>::assignWithTake(_DWORD *result, _DWORD *a2)
{
  *uint64_t result = *a2;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned int,4ul,4ul,4ul>>,true,4ul,4ul,false>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 4)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned int,4ul,4ul,4ul>>,true,4ul,4ul,false>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)uint64_t result = a2 - 1;
      *(unsigned char *)(result + 4) = 1;
    }
    else
    {
      *(unsigned char *)(result + 4) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)uint64_t result = a2 - 1;
  }
  return result;
}

void *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned long long,8ul,8ul,8ul>>,true,8ul,8ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(void *result, void *a2)
{
  *uint64_t result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned long long,8ul,8ul,8ul>>::initializeWithCopy(void *result, void *a2)
{
  *uint64_t result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned long long,8ul,8ul,8ul>>::assignWithCopy(void *result, void *a2)
{
  *uint64_t result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned long long,8ul,8ul,8ul>>::initializeWithTake(void *result, void *a2)
{
  *uint64_t result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned long long,8ul,8ul,8ul>>::assignWithTake(void *result, void *a2)
{
  *uint64_t result = *a2;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned long long,8ul,8ul,8ul>>,true,8ul,8ul,false>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<unsigned long long,8ul,8ul,8ul>>,true,8ul,8ul,false>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)uint64_t result = a2 - 1;
      *(_DWORD *)(result + 4) = 0;
      *(unsigned char *)(result + 8) = 1;
    }
    else
    {
      *(unsigned char *)(result + 8) = 0;
    }
  }
  else if (a2)
  {
    *(void *)uint64_t result = (a2 - 1);
  }
  return result;
}

char *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int128_like,16ul,16ul,16ul>>,true,16ul,16ul,(swift::metadataimpl::FixedPacking)0>::initializeBufferWithCopyOfBuffer(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  unsigned int v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int128_like,16ul,16ul,16ul>>::initializeWithCopy(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int128_like,16ul,16ul,16ul>>::assignWithCopy(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int128_like,16ul,16ul,16ul>>::initializeWithTake(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int128_like,16ul,16ul,16ul>>::assignWithTake(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int128_like,16ul,16ul,16ul>>,true,16ul,16ul,false>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int128_like,16ul,16ul,16ul>>,true,16ul,16ul,false>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(_DWORD *)(result + 12) = 0;
      *(unsigned char *)(result + 16) = 1;
    }
    else
    {
      *(unsigned char *)(result + 16) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(_DWORD *)(result + 12) = 0;
  }
  return result;
}

char *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int256_like,16ul,32ul,32ul>>,true,32ul,16ul,(swift::metadataimpl::FixedPacking)0>::initializeBufferWithCopyOfBuffer(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  unsigned int v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int256_like,16ul,32ul,32ul>>::initializeWithCopy(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int256_like,16ul,32ul,32ul>>::assignWithCopy(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int256_like,16ul,32ul,32ul>>::initializeWithTake(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int256_like,16ul,32ul,32ul>>::assignWithTake(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int256_like,16ul,32ul,32ul>>,true,32ul,16ul,false>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int256_like,16ul,32ul,32ul>>,true,32ul,16ul,false>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(void *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
      *(void *)(result + 12) = 0;
      *(_DWORD *)(result + 28) = 0;
      *(unsigned char *)(result + 32) = 1;
    }
    else
    {
      *(unsigned char *)(result + 32) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(void *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
    *(void *)(result + 12) = 0;
    *(_DWORD *)(result + 28) = 0;
  }
  return result;
}

char *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int512_like,16ul,64ul,64ul>>,true,64ul,16ul,(swift::metadataimpl::FixedPacking)0>::initializeBufferWithCopyOfBuffer(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  unsigned int v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int512_like,16ul,64ul,64ul>>::initializeWithCopy(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int512_like,16ul,64ul,64ul>>::assignWithCopy(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int512_like,16ul,64ul,64ul>>::initializeWithTake(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int512_like,16ul,64ul,64ul>>::assignWithTake(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v4;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int512_like,16ul,64ul,64ul>>,true,64ul,16ul,false>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 64)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::int512_like,16ul,64ul,64ul>>,true,64ul,16ul,false>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 48) = 0u;
      *(unsigned char *)(result + 64) = 1;
    }
    else
    {
      *(unsigned char *)(result + 64) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 48) = 0u;
  }
  return result;
}

void *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<long,8ul,8ul,8ul>>,true,8ul,8ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<long,8ul,8ul,8ul>>::initializeWithCopy(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<long,8ul,8ul,8ul>>::assignWithCopy(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<long,8ul,8ul,8ul>>::initializeWithTake(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<long,8ul,8ul,8ul>>::assignWithTake(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<long,8ul,8ul,8ul>>,true,8ul,8ul,false>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<long,8ul,8ul,8ul>>,true,8ul,8ul,false>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_DWORD *)(result + 4) = 0;
      *(unsigned char *)(result + 8) = 1;
    }
    else
    {
      *(unsigned char *)(result + 8) = 0;
    }
  }
  else if (a2)
  {
    *(void *)__n128 result = (a2 - 1);
  }
  return result;
}

float swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<float,4ul,4ul,4ul>>,true,4ul,4ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(_DWORD *a1, float *a2)
{
  float result = *a2;
  *a1 = *(_DWORD *)a2;
  return result;
}

float swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<float,4ul,4ul,4ul>>::initializeWithCopy(_DWORD *a1, float *a2)
{
  float result = *a2;
  *a1 = *(_DWORD *)a2;
  return result;
}

float swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<float,4ul,4ul,4ul>>::assignWithCopy(_DWORD *a1, float *a2)
{
  float result = *a2;
  *a1 = *(_DWORD *)a2;
  return result;
}

float swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<float,4ul,4ul,4ul>>::initializeWithTake(_DWORD *a1, float *a2)
{
  float result = *a2;
  *a1 = *(_DWORD *)a2;
  return result;
}

float swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<float,4ul,4ul,4ul>>::assignWithTake(_DWORD *a1, float *a2)
{
  float result = *a2;
  *a1 = *(_DWORD *)a2;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<float,4ul,4ul,4ul>>,true,4ul,4ul,false>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 4)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<float,4ul,4ul,4ul>>,true,4ul,4ul,false>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)float result = a2 - 1;
      *(unsigned char *)(result + 4) = 1;
    }
    else
    {
      *(unsigned char *)(result + 4) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)float result = a2 - 1;
  }
  return result;
}

double swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<double,8ul,8ul,8ul>>,true,8ul,8ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<double,8ul,8ul,8ul>>::initializeWithCopy(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<double,8ul,8ul,8ul>>::assignWithCopy(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<double,8ul,8ul,8ul>>::initializeWithTake(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<double,8ul,8ul,8ul>>::assignWithTake(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<double,8ul,8ul,8ul>>,true,8ul,8ul,false>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<double,8ul,8ul,8ul>>,true,8ul,8ul,false>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)double result = a2 - 1;
      *(_DWORD *)(result + 4) = 0;
      *(unsigned char *)(result + 8) = 1;
    }
    else
    {
      *(unsigned char *)(result + 8) = 0;
    }
  }
  else if (a2)
  {
    *(void *)double result = (a2 - 1);
  }
  return result;
}

char *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::float80_like,16ul,16ul,16ul>>,true,16ul,16ul,(swift::metadataimpl::FixedPacking)0>::initializeBufferWithCopyOfBuffer(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::float80_like,16ul,16ul,16ul>>::initializeWithCopy(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::float80_like,16ul,16ul,16ul>>::assignWithCopy(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::float80_like,16ul,16ul,16ul>>::initializeWithTake(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::float80_like,16ul,16ul,16ul>>::assignWithTake(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::float80_like,16ul,16ul,16ul>>,true,16ul,16ul,false>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<anonymous namespace'::float80_like,16ul,16ul,16ul>>,true,16ul,16ul,false>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(_DWORD *)(result + 12) = 0;
      *(unsigned char *)(result + 16) = 1;
    }
    else
    {
      *(unsigned char *)(result + 16) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(_DWORD *)(result + 12) = 0;
  }
  return result;
}

atomic_ullong **swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::SwiftRetainableBox>,true,8ul,8ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(atomic_ullong **a1, atomic_ullong **a2)
{
  uint64_t v3 = *a2;
  swift_retain(*a2);
  *a1 = v3;
  return a1;
}

uint64_t swift::metadataimpl::ValueWitnesses<swift::metadataimpl::SwiftRetainableBox>::destroy(uint64_t *a1)
{
  return swift_release(*a1);
}

atomic_ullong **swift::metadataimpl::ValueWitnesses<swift::metadataimpl::SwiftRetainableBox>::initializeWithCopy(atomic_ullong **a1, atomic_ullong **a2)
{
  uint64_t v3 = *a2;
  swift_retain(*a2);
  *a1 = v3;
  return a1;
}

uint64_t *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::SwiftRetainableBox>::assignWithCopy(uint64_t *a1, atomic_ullong **a2)
{
  uint64_t v3 = *a1;
  long long v4 = *a2;
  swift_retain(*a2);
  *a1 = (uint64_t)v4;
  swift_release(v3);
  return a1;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::SwiftRetainableBox>::initializeWithTake(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

uint64_t *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::SwiftRetainableBox>::assignWithTake(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a1;
  *a1 = *a2;
  swift_release(v3);
  return a1;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::SwiftRetainableBox>,true,8ul,8ul,true>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 < 0 && *(unsigned char *)(a1 + 8)) {
    return *(_DWORD *)a1 ^ 0x80000000;
  }
  if (HIDWORD(*(void *)a1)) {
    return 0;
  }
  return *(void *)a1 + 1;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::SwiftRetainableBox>,true,8ul,8ul,true>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if ((a3 & 0x80000000) == 0)
  {
    if (a2 < 0)
    {
      *(void *)__n128 result = a2 ^ 0x80000000;
      return result;
    }
    if (!a2) {
      return result;
    }
LABEL_7:
    *(void *)__n128 result = (a2 - 1);
    return result;
  }
  if (a2 < 0)
  {
    *(_DWORD *)__n128 result = a2 ^ 0x80000000;
    *(_DWORD *)(result + 4) = 0;
    *(unsigned char *)(result + 8) = 1;
    return result;
  }
  *(unsigned char *)(result + 8) = 0;
  if (a2) {
    goto LABEL_7;
  }
  return result;
}

unint64_t *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::BridgeObjectBox>,true,8ul,8ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(unint64_t *a1, unint64_t *a2)
{
  *a1 = swift_bridgeObjectRetain(*a2);
  return a1;
}

void swift::metadataimpl::ValueWitnesses<swift::metadataimpl::BridgeObjectBox>::destroy(uint64_t *a1)
{
}

unint64_t *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::BridgeObjectBox>::initializeWithCopy(unint64_t *a1, unint64_t *a2)
{
  *a1 = swift_bridgeObjectRetain(*a2);
  return a1;
}

uint64_t *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::BridgeObjectBox>::assignWithCopy(uint64_t *a1, unint64_t *a2)
{
  uint64_t v3 = *a1;
  *a1 = swift_bridgeObjectRetain(*a2);
  swift_bridgeObjectRelease(v3);
  return a1;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::BridgeObjectBox>::initializeWithTake(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

uint64_t *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::BridgeObjectBox>::assignWithTake(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a1;
  *a1 = *a2;
  swift_bridgeObjectRelease(v3);
  return a1;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::BridgeObjectBox>,true,8ul,8ul,true>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 < 0 && *(unsigned char *)(a1 + 8)) {
    return *(_DWORD *)a1 ^ 0x80000000;
  }
  if (HIDWORD(*(void *)a1)) {
    return 0;
  }
  return *(void *)a1 + 1;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::BridgeObjectBox>,true,8ul,8ul,true>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if ((a3 & 0x80000000) == 0)
  {
    if (a2 < 0)
    {
      *(void *)__n128 result = a2 ^ 0x80000000;
      return result;
    }
    if (!a2) {
      return result;
    }
LABEL_7:
    *(void *)__n128 result = (a2 - 1);
    return result;
  }
  if (a2 < 0)
  {
    *(_DWORD *)__n128 result = a2 ^ 0x80000000;
    *(_DWORD *)(result + 4) = 0;
    *(unsigned char *)(result + 8) = 1;
    return result;
  }
  *(unsigned char *)(result + 8) = 0;
  if (a2) {
    goto LABEL_7;
  }
  return result;
}

void *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::RawPointerBox>,true,8ul,8ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::RawPointerBox>::initializeWithCopy(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::RawPointerBox>::assignWithCopy(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::RawPointerBox>::initializeWithTake(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::RawPointerBox>::assignWithTake(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::RawPointerBox>,true,8ul,8ul,true>::getEnumTagSinglePayload(uint64_t a1, unsigned int a2)
{
  if (a2 >= 2 && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 2);
  }
  else {
    return *(void *)a1 == 0;
  }
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::RawPointerBox>,true,8ul,8ul,true>::storeEnumTagSinglePayload(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a3 < 2)
  {
    if (a2 >= 2)
    {
      *(_DWORD *)__n128 result = a2 - 2;
      *(_DWORD *)(result + 4) = 0;
      return result;
    }
  }
  else
  {
    if (a2 > 1)
    {
      *(_DWORD *)__n128 result = a2 - 2;
      *(_DWORD *)(result + 4) = 0;
      *(unsigned char *)(result + 8) = 1;
      return result;
    }
    *(unsigned char *)(result + 8) = 0;
  }
  if (a2) {
    *(void *)__n128 result = 0;
  }
  return result;
}

__n128 swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<swift::TargetValueBuffer<swift::InProcess>,8ul,24ul,24ul>>,true,24ul,8ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  *a1 = result;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<swift::TargetValueBuffer<swift::InProcess>,8ul,24ul,24ul>>::initializeWithCopy(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  *a1 = result;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<swift::TargetValueBuffer<swift::InProcess>,8ul,24ul,24ul>>::assignWithCopy(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  *a1 = result;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<swift::TargetValueBuffer<swift::InProcess>,8ul,24ul,24ul>>::initializeWithTake(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  *a1 = result;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<swift::TargetValueBuffer<swift::InProcess>,8ul,24ul,24ul>>::assignWithTake(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  *a1 = result;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<swift::TargetValueBuffer<swift::InProcess>,8ul,24ul,24ul>>,true,24ul,8ul,false>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 24)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<swift::TargetValueBuffer<swift::InProcess>,8ul,24ul,24ul>>,true,24ul,8ul,false>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 12) = 0;
      *(void *)(result + 4) = 0;
      *(_DWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
      *(unsigned char *)(result + 24) = 1;
    }
    else
    {
      *(unsigned char *)(result + 24) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 12) = 0;
    *(void *)(result + 4) = 0;
    *(_DWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
  }
  return result;
}

void *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::ObjCRetainableBox>,true,8ul,8ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(void *a1, id *a2)
{
  *a1 = *a2;
  return a1;
}

void swift::metadataimpl::ValueWitnesses<swift::metadataimpl::ObjCRetainableBox>::destroy(id *a1)
{
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::ObjCRetainableBox>::initializeWithCopy(void *a1, id *a2)
{
  *a1 = *a2;
  return a1;
}

void **swift::metadataimpl::ValueWitnesses<swift::metadataimpl::ObjCRetainableBox>::assignWithCopy(void **a1, id *a2)
{
  uint64_t v3 = *a1;
  *a1 = *a2;

  return a1;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::ObjCRetainableBox>::initializeWithTake(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

void **swift::metadataimpl::ValueWitnesses<swift::metadataimpl::ObjCRetainableBox>::assignWithTake(void **a1, void **a2)
{
  uint64_t v3 = *a1;
  *a1 = *a2;

  return a1;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::ObjCRetainableBox>,true,8ul,8ul,true>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 < 0 && *(unsigned char *)(a1 + 8)) {
    return *(_DWORD *)a1 ^ 0x80000000;
  }
  if (HIDWORD(*(void *)a1)) {
    return 0;
  }
  return *(void *)a1 + 1;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::ObjCRetainableBox>,true,8ul,8ul,true>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if ((a3 & 0x80000000) == 0)
  {
    if (a2 < 0)
    {
      *(void *)__n128 result = a2 ^ 0x80000000;
      return result;
    }
    if (!a2) {
      return result;
    }
LABEL_7:
    *(void *)__n128 result = (a2 - 1);
    return result;
  }
  if (a2 < 0)
  {
    *(_DWORD *)__n128 result = a2 ^ 0x80000000;
    *(_DWORD *)(result + 4) = 0;
    *(unsigned char *)(result + 8) = 1;
    return result;
  }
  *(unsigned char *)(result + 8) = 0;
  if (a2) {
    goto LABEL_7;
  }
  return result;
}

char *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::BD,16ul,96ul,96ul>>,true,96ul,16ul,(swift::metadataimpl::FixedPacking)0>::initializeBufferWithCopyOfBuffer(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::BD,16ul,96ul,96ul>>::initializeWithCopy(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v2;
  __n128 result = *(__n128 *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  long long v5 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v5;
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v4;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::BD,16ul,96ul,96ul>>::assignWithCopy(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v2;
  __n128 result = *(__n128 *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  long long v5 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v5;
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v4;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::BD,16ul,96ul,96ul>>::initializeWithTake(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v2;
  __n128 result = *(__n128 *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  long long v5 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v5;
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v4;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::BD,16ul,96ul,96ul>>::assignWithTake(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v2;
  __n128 result = *(__n128 *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  long long v5 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v5;
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v4;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::BD,16ul,96ul,96ul>>,true,96ul,16ul,false>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 96)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::BD,16ul,96ul,96ul>>,true,96ul,16ul,false>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 52) = 0u;
      *(_OWORD *)(result + 68) = 0u;
      *(_OWORD *)(result + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(unsigned char *)(result + 96) = 1;
    }
    else
    {
      *(unsigned char *)(result + 96) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 52) = 0u;
    *(_OWORD *)(result + 68) = 0u;
    *(_OWORD *)(result + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
  }
  return result;
}

char *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::Bd,16ul,96ul,96ul>>,true,96ul,16ul,(swift::metadataimpl::FixedPacking)0>::initializeBufferWithCopyOfBuffer(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::Bd,16ul,96ul,96ul>>::initializeWithCopy(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v2;
  __n128 result = *(__n128 *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  long long v5 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v5;
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v4;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::Bd,16ul,96ul,96ul>>::assignWithCopy(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v2;
  __n128 result = *(__n128 *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  long long v5 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v5;
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v4;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::Bd,16ul,96ul,96ul>>::initializeWithTake(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v2;
  __n128 result = *(__n128 *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  long long v5 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v5;
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v4;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::Bd,16ul,96ul,96ul>>::assignWithTake(uint64_t a1, uint64_t a2)
{
  long long v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v2;
  __n128 result = *(__n128 *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  long long v5 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v5;
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v4;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::Bd,16ul,96ul,96ul>>,true,96ul,16ul,false>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 96)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::Bd,16ul,96ul,96ul>>,true,96ul,16ul,false>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 52) = 0u;
      *(_OWORD *)(result + 68) = 0u;
      *(_OWORD *)(result + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(unsigned char *)(result + 96) = 1;
    }
    else
    {
      *(unsigned char *)(result + 96) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 52) = 0u;
    *(_OWORD *)(result + 68) = 0u;
    *(_OWORD *)(result + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
  }
  return result;
}

__n128 swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::Be,8ul,16ul,16ul>>,true,16ul,8ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::Be,8ul,16ul,16ul>>::initializeWithCopy(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::Be,8ul,16ul,16ul>>::assignWithCopy(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::Be,8ul,16ul,16ul>>::initializeWithTake(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::Be,8ul,16ul,16ul>>::assignWithTake(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::Be,8ul,16ul,16ul>>,true,16ul,8ul,false>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::NativeBox<ctypes::anonymous namespace'::Be,8ul,16ul,16ul>>,true,16ul,8ul,false>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(_DWORD *)(result + 12) = 0;
      *(unsigned char *)(result + 16) = 1;
    }
    else
    {
      *(unsigned char *)(result + 16) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(_DWORD *)(result + 12) = 0;
  }
  return result;
}

_WORD *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_hLm2ELm2ELm2EEEEELb1ELm2ELm2ELNS0_12FixedPackingE1EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(_WORD *result, _WORD *a2)
{
  *__n128 result = *a2;
  return result;
}

_WORD *_ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_hLm2ELm2ELm2EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_WORD *result, _WORD *a2)
{
  *__n128 result = *a2;
  return result;
}

_WORD *_ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_hLm2ELm2ELm2EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_WORD *result, _WORD *a2)
{
  *__n128 result = *a2;
  return result;
}

_WORD *_ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_hLm2ELm2ELm2EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_WORD *result, _WORD *a2)
{
  *__n128 result = *a2;
  return result;
}

_WORD *_ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_hLm2ELm2ELm2EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_WORD *result, _WORD *a2)
{
  *__n128 result = *a2;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_hLm2ELm2ELm2EEEEELb1ELm2ELm2ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(unsigned __int16 *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  unsigned int v2 = a2 + 0xFFFF;
  if ((a2 + 0xFFFF) < 0x10000) {
    return 0;
  }
  if (v2 < 0xFF0000)
  {
    int v3 = *((unsigned __int8 *)a1 + 2);
    if (!*((unsigned char *)a1 + 2)) {
      return 0;
    }
    return (*a1 | (v3 << 16)) - 0xFFFF;
  }
  if (v2 <= 0xFFFEFFFF)
  {
    int v3 = a1[1];
    if (a1[1]) {
      return (*a1 | (v3 << 16)) - 0xFFFF;
    }
  }
  else
  {
    int v3 = *(_DWORD *)(a1 + 1);
    if (v3) {
      return (*a1 | (v3 << 16)) - 0xFFFF;
    }
  }
  return 0;
}

void _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_hLm2ELm2ELm2EEEEELb1ELm2ELm2ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2, int a3)
{
  if (a3 && (unsigned int v3 = a3 + 0xFFFF, (a3 + 0xFFFF) >= 0x10000))
  {
    if (v3 <= 0xFFFEFFFF) {
      unsigned int v4 = 2;
    }
    else {
      unsigned int v4 = 4;
    }
    if (v3 < 0xFF0000) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    if (a2)
    {
      unsigned int v6 = ((a2 - 1) >> 16) + 1;
      *(_WORD *)a1 = a2 - 1;
      switch((int)v5)
      {
        case 1:
          *(unsigned char *)(a1 + 2) = v6;
          break;
        case 2:
          *(_WORD *)(a1 + 2) = v6;
          break;
        case 3:
          *(_WORD *)(a1 + 2) = v6;
          *(unsigned char *)(a1 + 4) = BYTE2(v6);
          break;
        case 4:
          *(_DWORD *)(a1 + 2) = v6;
          break;
        default:
          *(_DWORD *)(a1 + 2) = v6;
          goto LABEL_22;
      }
    }
    else
    {
      switch(v5)
      {
        case 1:
          *(unsigned char *)(a1 + 2) = 0;
          break;
        case 2:
          *(_WORD *)(a1 + 2) = 0;
          break;
        case 3:
          *(unsigned char *)(a1 + 4) = 0;
          *(_WORD *)(a1 + 2) = 0;
          break;
        case 4:
          *(_DWORD *)(a1 + 2) = 0;
          break;
        default:
          *(_DWORD *)(a1 + 2) = 0;
LABEL_22:
          bzero((void *)(a1 + 6), v5 - 4);
          break;
      }
    }
  }
  else if (a2)
  {
    *(_WORD *)a1 = a2 - 1;
  }
}

_DWORD *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv3_hLm4ELm4ELm4EEEEELb1ELm4ELm4ELNS0_12FixedPackingE1EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

_DWORD *_ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv3_hLm4ELm4ELm4EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

_DWORD *_ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv3_hLm4ELm4ELm4EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

_DWORD *_ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv3_hLm4ELm4ELm4EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

_DWORD *_ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv3_hLm4ELm4ELm4EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv3_hLm4ELm4ELm4EEEEELb1ELm4ELm4ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 4)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv3_hLm4ELm4ELm4EEEEELb1ELm4ELm4ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(unsigned char *)(result + 4) = 1;
    }
    else
    {
      *(unsigned char *)(result + 4) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
  }
  return result;
}

_DWORD *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_hLm4ELm4ELm4EEEEELb1ELm4ELm4ELNS0_12FixedPackingE1EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

_DWORD *_ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_hLm4ELm4ELm4EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

_DWORD *_ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_hLm4ELm4ELm4EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

_DWORD *_ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_hLm4ELm4ELm4EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

_DWORD *_ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_hLm4ELm4ELm4EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_hLm4ELm4ELm4EEEEELb1ELm4ELm4ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 4)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_hLm4ELm4ELm4EEEEELb1ELm4ELm4ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(unsigned char *)(result + 4) = 1;
    }
    else
    {
      *(unsigned char *)(result + 4) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
  }
  return result;
}

double _ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_hLm8ELm8ELm8EEEEELb1ELm8ELm8ELNS0_12FixedPackingE1EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_hLm8ELm8ELm8EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_hLm8ELm8ELm8EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_hLm8ELm8ELm8EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_hLm8ELm8ELm8EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_hLm8ELm8ELm8EEEEELb1ELm8ELm8ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_hLm8ELm8ELm8EEEEELb1ELm8ELm8ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)double result = a2 - 1;
      *(_DWORD *)(result + 4) = 0;
      *(unsigned char *)(result + 8) = 1;
    }
    else
    {
      *(unsigned char *)(result + 8) = 0;
    }
  }
  else if (a2)
  {
    *(void *)double result = (a2 - 1);
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_hLm16ELm16ELm16EEEEELb1ELm16ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  unsigned int v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_hLm16ELm16ELm16EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_hLm16ELm16ELm16EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_hLm16ELm16ELm16EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_hLm16ELm16ELm16EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_hLm16ELm16ELm16EEEEELb1ELm16ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_hLm16ELm16ELm16EEEEELb1ELm16ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(_DWORD *)(result + 12) = 0;
      *(unsigned char *)(result + 16) = 1;
    }
    else
    {
      *(unsigned char *)(result + 16) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(_DWORD *)(result + 12) = 0;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_hLm16ELm32ELm32EEEEELb1ELm32ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  unsigned int v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_hLm16ELm32ELm32EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_hLm16ELm32ELm32EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_hLm16ELm32ELm32EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_hLm16ELm32ELm32EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_hLm16ELm32ELm32EEEEELb1ELm32ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_hLm16ELm32ELm32EEEEELb1ELm32ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(void *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
      *(void *)(result + 12) = 0;
      *(_DWORD *)(result + 28) = 0;
      *(unsigned char *)(result + 32) = 1;
    }
    else
    {
      *(unsigned char *)(result + 32) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(void *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
    *(void *)(result + 12) = 0;
    *(_DWORD *)(result + 28) = 0;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_hLm16ELm64ELm64EEEEELb1ELm64ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  unsigned int v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_hLm16ELm64ELm64EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_hLm16ELm64ELm64EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_hLm16ELm64ELm64EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_hLm16ELm64ELm64EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_hLm16ELm64ELm64EEEEELb1ELm64ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 64)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_hLm16ELm64ELm64EEEEELb1ELm64ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 48) = 0u;
      *(unsigned char *)(result + 64) = 1;
    }
    else
    {
      *(unsigned char *)(result + 64) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 48) = 0u;
  }
  return result;
}

_DWORD *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_tLm4ELm4ELm4EEEEELb1ELm4ELm4ELNS0_12FixedPackingE1EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

_DWORD *_ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_tLm4ELm4ELm4EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

_DWORD *_ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_tLm4ELm4ELm4EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

_DWORD *_ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_tLm4ELm4ELm4EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

_DWORD *_ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_tLm4ELm4ELm4EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_DWORD *result, _DWORD *a2)
{
  *__n128 result = *a2;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_tLm4ELm4ELm4EEEEELb1ELm4ELm4ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 4)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_tLm4ELm4ELm4EEEEELb1ELm4ELm4ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(unsigned char *)(result + 4) = 1;
    }
    else
    {
      *(unsigned char *)(result + 4) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
  }
  return result;
}

double _ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv3_tLm8ELm8ELm8EEEEELb1ELm8ELm8ELNS0_12FixedPackingE1EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv3_tLm8ELm8ELm8EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv3_tLm8ELm8ELm8EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv3_tLm8ELm8ELm8EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv3_tLm8ELm8ELm8EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv3_tLm8ELm8ELm8EEEEELb1ELm8ELm8ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv3_tLm8ELm8ELm8EEEEELb1ELm8ELm8ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)double result = a2 - 1;
      *(_DWORD *)(result + 4) = 0;
      *(unsigned char *)(result + 8) = 1;
    }
    else
    {
      *(unsigned char *)(result + 8) = 0;
    }
  }
  else if (a2)
  {
    *(void *)double result = (a2 - 1);
  }
  return result;
}

double _ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_tLm8ELm8ELm8EEEEELb1ELm8ELm8ELNS0_12FixedPackingE1EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_tLm8ELm8ELm8EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_tLm8ELm8ELm8EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_tLm8ELm8ELm8EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_tLm8ELm8ELm8EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_tLm8ELm8ELm8EEEEELb1ELm8ELm8ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_tLm8ELm8ELm8EEEEELb1ELm8ELm8ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)double result = a2 - 1;
      *(_DWORD *)(result + 4) = 0;
      *(unsigned char *)(result + 8) = 1;
    }
    else
    {
      *(unsigned char *)(result + 8) = 0;
    }
  }
  else if (a2)
  {
    *(void *)double result = (a2 - 1);
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_tLm16ELm16ELm16EEEEELb1ELm16ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_tLm16ELm16ELm16EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_tLm16ELm16ELm16EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_tLm16ELm16ELm16EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_tLm16ELm16ELm16EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_tLm16ELm16ELm16EEEEELb1ELm16ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_tLm16ELm16ELm16EEEEELb1ELm16ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(_DWORD *)(result + 12) = 0;
      *(unsigned char *)(result + 16) = 1;
    }
    else
    {
      *(unsigned char *)(result + 16) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(_DWORD *)(result + 12) = 0;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_tLm16ELm32ELm32EEEEELb1ELm32ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_tLm16ELm32ELm32EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_tLm16ELm32ELm32EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_tLm16ELm32ELm32EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_tLm16ELm32ELm32EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_tLm16ELm32ELm32EEEEELb1ELm32ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_tLm16ELm32ELm32EEEEELb1ELm32ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(void *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
      *(void *)(result + 12) = 0;
      *(_DWORD *)(result + 28) = 0;
      *(unsigned char *)(result + 32) = 1;
    }
    else
    {
      *(unsigned char *)(result + 32) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(void *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
    *(void *)(result + 12) = 0;
    *(_DWORD *)(result + 28) = 0;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_tLm16ELm64ELm64EEEEELb1ELm64ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_tLm16ELm64ELm64EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_tLm16ELm64ELm64EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_tLm16ELm64ELm64EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_tLm16ELm64ELm64EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_tLm16ELm64ELm64EEEEELb1ELm64ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 64)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_tLm16ELm64ELm64EEEEELb1ELm64ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 48) = 0u;
      *(unsigned char *)(result + 64) = 1;
    }
    else
    {
      *(unsigned char *)(result + 64) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 48) = 0u;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_tLm16ELm128ELm128EEEEELb1ELm128ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_tLm16ELm128ELm128EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_tLm16ELm128ELm128EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_tLm16ELm128ELm128EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_tLm16ELm128ELm128EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_tLm16ELm128ELm128EEEEELb1ELm128ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 128)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_tLm16ELm128ELm128EEEEELb1ELm128ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 52) = 0u;
      *(_OWORD *)(result + 68) = 0u;
      *(_OWORD *)(result + 84) = 0u;
      *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 112) = 0u;
      *(unsigned char *)(result + 128) = 1;
    }
    else
    {
      *(unsigned char *)(result + 128) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 52) = 0u;
    *(_OWORD *)(result + 68) = 0u;
    *(_OWORD *)(result + 84) = 0u;
    *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 112) = 0u;
  }
  return result;
}

double _ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_jLm8ELm8ELm8EEEEELb1ELm8ELm8ELNS0_12FixedPackingE1EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_jLm8ELm8ELm8EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_jLm8ELm8ELm8EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_jLm8ELm8ELm8EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_jLm8ELm8ELm8EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_jLm8ELm8ELm8EEEEELb1ELm8ELm8ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_jLm8ELm8ELm8EEEEELb1ELm8ELm8ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)double result = a2 - 1;
      *(_DWORD *)(result + 4) = 0;
      *(unsigned char *)(result + 8) = 1;
    }
    else
    {
      *(unsigned char *)(result + 8) = 0;
    }
  }
  else if (a2)
  {
    *(void *)double result = (a2 - 1);
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv3_jLm16ELm16ELm16EEEEELb1ELm16ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv3_jLm16ELm16ELm16EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv3_jLm16ELm16ELm16EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv3_jLm16ELm16ELm16EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv3_jLm16ELm16ELm16EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv3_jLm16ELm16ELm16EEEEELb1ELm16ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv3_jLm16ELm16ELm16EEEEELb1ELm16ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(_DWORD *)(result + 12) = 0;
      *(unsigned char *)(result + 16) = 1;
    }
    else
    {
      *(unsigned char *)(result + 16) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(_DWORD *)(result + 12) = 0;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_jLm16ELm16ELm16EEEEELb1ELm16ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_jLm16ELm16ELm16EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_jLm16ELm16ELm16EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_jLm16ELm16ELm16EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_jLm16ELm16ELm16EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_jLm16ELm16ELm16EEEEELb1ELm16ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_jLm16ELm16ELm16EEEEELb1ELm16ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(_DWORD *)(result + 12) = 0;
      *(unsigned char *)(result + 16) = 1;
    }
    else
    {
      *(unsigned char *)(result + 16) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(_DWORD *)(result + 12) = 0;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_jLm16ELm32ELm32EEEEELb1ELm32ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_jLm16ELm32ELm32EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_jLm16ELm32ELm32EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_jLm16ELm32ELm32EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_jLm16ELm32ELm32EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_jLm16ELm32ELm32EEEEELb1ELm32ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_jLm16ELm32ELm32EEEEELb1ELm32ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(void *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
      *(void *)(result + 12) = 0;
      *(_DWORD *)(result + 28) = 0;
      *(unsigned char *)(result + 32) = 1;
    }
    else
    {
      *(unsigned char *)(result + 32) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(void *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
    *(void *)(result + 12) = 0;
    *(_DWORD *)(result + 28) = 0;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_jLm16ELm64ELm64EEEEELb1ELm64ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_jLm16ELm64ELm64EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_jLm16ELm64ELm64EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_jLm16ELm64ELm64EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_jLm16ELm64ELm64EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_jLm16ELm64ELm64EEEEELb1ELm64ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 64)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_jLm16ELm64ELm64EEEEELb1ELm64ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 48) = 0u;
      *(unsigned char *)(result + 64) = 1;
    }
    else
    {
      *(unsigned char *)(result + 64) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 48) = 0u;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_jLm16ELm128ELm128EEEEELb1ELm128ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_jLm16ELm128ELm128EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_jLm16ELm128ELm128EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_jLm16ELm128ELm128EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_jLm16ELm128ELm128EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_jLm16ELm128ELm128EEEEELb1ELm128ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 128)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_jLm16ELm128ELm128EEEEELb1ELm128ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 52) = 0u;
      *(_OWORD *)(result + 68) = 0u;
      *(_OWORD *)(result + 84) = 0u;
      *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 112) = 0u;
      *(unsigned char *)(result + 128) = 1;
    }
    else
    {
      *(unsigned char *)(result + 128) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 52) = 0u;
    *(_OWORD *)(result + 68) = 0u;
    *(_OWORD *)(result + 84) = 0u;
    *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 112) = 0u;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_jLm16ELm256ELm256EEEEELb1ELm256ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_jLm16ELm256ELm256EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v9 = a2[6];
  long long v8 = a2[7];
  long long v11 = a2[8];
  long long v10 = a2[9];
  long long v13 = a2[10];
  long long v12 = a2[11];
  long long v15 = a2[12];
  long long v14 = a2[13];
  long long v16 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16;
  *(_OWORD *)(a1 + 192) = v15;
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v13;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_jLm16ELm256ELm256EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v9 = a2[6];
  long long v8 = a2[7];
  long long v11 = a2[8];
  long long v10 = a2[9];
  long long v13 = a2[10];
  long long v12 = a2[11];
  long long v15 = a2[12];
  long long v14 = a2[13];
  long long v16 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16;
  *(_OWORD *)(a1 + 192) = v15;
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v13;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_jLm16ELm256ELm256EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v9 = a2[6];
  long long v8 = a2[7];
  long long v11 = a2[8];
  long long v10 = a2[9];
  long long v13 = a2[10];
  long long v12 = a2[11];
  long long v15 = a2[12];
  long long v14 = a2[13];
  long long v16 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16;
  *(_OWORD *)(a1 + 192) = v15;
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v13;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_jLm16ELm256ELm256EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v9 = a2[6];
  long long v8 = a2[7];
  long long v11 = a2[8];
  long long v10 = a2[9];
  long long v13 = a2[10];
  long long v12 = a2[11];
  long long v15 = a2[12];
  long long v14 = a2[13];
  long long v16 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16;
  *(_OWORD *)(a1 + 192) = v15;
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v13;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_jLm16ELm256ELm256EEEEELb1ELm256ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 256)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_jLm16ELm256ELm256EEEEELb1ELm256ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 52) = 0u;
      *(_OWORD *)(result + 68) = 0u;
      *(_OWORD *)(result + 84) = 0u;
      *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 116) = 0u;
      *(_OWORD *)(result + 132) = 0u;
      *(_OWORD *)(result + 148) = 0u;
      *(_OWORD *)(result + 164) = 0u;
      *(_OWORD *)(result + 18swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 196) = 0u;
      *(_OWORD *)(result + 212) = 0u;
      *(_OWORD *)(result + 228) = 0u;
      *(_OWORD *)(result + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(unsigned char *)(result + 256) = 1;
    }
    else
    {
      *(unsigned char *)(result + 256) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 52) = 0u;
    *(_OWORD *)(result + 68) = 0u;
    *(_OWORD *)(result + 84) = 0u;
    *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 116) = 0u;
    *(_OWORD *)(result + 132) = 0u;
    *(_OWORD *)(result + 148) = 0u;
    *(_OWORD *)(result + 164) = 0u;
    *(_OWORD *)(result + 18swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 196) = 0u;
    *(_OWORD *)(result + 212) = 0u;
    *(_OWORD *)(result + 228) = 0u;
    *(_OWORD *)(result + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_yLm16ELm16ELm16EEEEELb1ELm16ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_yLm16ELm16ELm16EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_yLm16ELm16ELm16EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_yLm16ELm16ELm16EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_yLm16ELm16ELm16EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_yLm16ELm16ELm16EEEEELb1ELm16ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_yLm16ELm16ELm16EEEEELb1ELm16ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(_DWORD *)(result + 12) = 0;
      *(unsigned char *)(result + 16) = 1;
    }
    else
    {
      *(unsigned char *)(result + 16) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(_DWORD *)(result + 12) = 0;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv3_yLm16ELm32ELm32EEEEELb1ELm32ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv3_yLm16ELm32ELm32EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv3_yLm16ELm32ELm32EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv3_yLm16ELm32ELm32EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv3_yLm16ELm32ELm32EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv3_yLm16ELm32ELm32EEEEELb1ELm32ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv3_yLm16ELm32ELm32EEEEELb1ELm32ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(void *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
      *(void *)(result + 12) = 0;
      *(_DWORD *)(result + 28) = 0;
      *(unsigned char *)(result + 32) = 1;
    }
    else
    {
      *(unsigned char *)(result + 32) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(void *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
    *(void *)(result + 12) = 0;
    *(_DWORD *)(result + 28) = 0;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_yLm16ELm32ELm32EEEEELb1ELm32ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_yLm16ELm32ELm32EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_yLm16ELm32ELm32EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_yLm16ELm32ELm32EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_yLm16ELm32ELm32EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_yLm16ELm32ELm32EEEEELb1ELm32ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_yLm16ELm32ELm32EEEEELb1ELm32ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(void *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
      *(void *)(result + 12) = 0;
      *(_DWORD *)(result + 28) = 0;
      *(unsigned char *)(result + 32) = 1;
    }
    else
    {
      *(unsigned char *)(result + 32) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(void *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
    *(void *)(result + 12) = 0;
    *(_DWORD *)(result + 28) = 0;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_yLm16ELm64ELm64EEEEELb1ELm64ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_yLm16ELm64ELm64EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_yLm16ELm64ELm64EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_yLm16ELm64ELm64EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_yLm16ELm64ELm64EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_yLm16ELm64ELm64EEEEELb1ELm64ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 64)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_yLm16ELm64ELm64EEEEELb1ELm64ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 48) = 0u;
      *(unsigned char *)(result + 64) = 1;
    }
    else
    {
      *(unsigned char *)(result + 64) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 48) = 0u;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_yLm16ELm128ELm128EEEEELb1ELm128ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_yLm16ELm128ELm128EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_yLm16ELm128ELm128EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_yLm16ELm128ELm128EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_yLm16ELm128ELm128EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_yLm16ELm128ELm128EEEEELb1ELm128ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 128)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_yLm16ELm128ELm128EEEEELb1ELm128ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 52) = 0u;
      *(_OWORD *)(result + 68) = 0u;
      *(_OWORD *)(result + 84) = 0u;
      *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 112) = 0u;
      *(unsigned char *)(result + 128) = 1;
    }
    else
    {
      *(unsigned char *)(result + 128) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 52) = 0u;
    *(_OWORD *)(result + 68) = 0u;
    *(_OWORD *)(result + 84) = 0u;
    *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 112) = 0u;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_yLm16ELm256ELm256EEEEELb1ELm256ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_yLm16ELm256ELm256EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v9 = a2[6];
  long long v8 = a2[7];
  long long v11 = a2[8];
  long long v10 = a2[9];
  long long v13 = a2[10];
  long long v12 = a2[11];
  long long v15 = a2[12];
  long long v14 = a2[13];
  long long v16 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16;
  *(_OWORD *)(a1 + 192) = v15;
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v13;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_yLm16ELm256ELm256EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v9 = a2[6];
  long long v8 = a2[7];
  long long v11 = a2[8];
  long long v10 = a2[9];
  long long v13 = a2[10];
  long long v12 = a2[11];
  long long v15 = a2[12];
  long long v14 = a2[13];
  long long v16 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16;
  *(_OWORD *)(a1 + 192) = v15;
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v13;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_yLm16ELm256ELm256EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v9 = a2[6];
  long long v8 = a2[7];
  long long v11 = a2[8];
  long long v10 = a2[9];
  long long v13 = a2[10];
  long long v12 = a2[11];
  long long v15 = a2[12];
  long long v14 = a2[13];
  long long v16 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16;
  *(_OWORD *)(a1 + 192) = v15;
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v13;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_yLm16ELm256ELm256EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v9 = a2[6];
  long long v8 = a2[7];
  long long v11 = a2[8];
  long long v10 = a2[9];
  long long v13 = a2[10];
  long long v12 = a2[11];
  long long v15 = a2[12];
  long long v14 = a2[13];
  long long v16 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16;
  *(_OWORD *)(a1 + 192) = v15;
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v13;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_yLm16ELm256ELm256EEEEELb1ELm256ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 256)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_yLm16ELm256ELm256EEEEELb1ELm256ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 52) = 0u;
      *(_OWORD *)(result + 68) = 0u;
      *(_OWORD *)(result + 84) = 0u;
      *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 116) = 0u;
      *(_OWORD *)(result + 132) = 0u;
      *(_OWORD *)(result + 148) = 0u;
      *(_OWORD *)(result + 164) = 0u;
      *(_OWORD *)(result + 18swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 196) = 0u;
      *(_OWORD *)(result + 212) = 0u;
      *(_OWORD *)(result + 228) = 0u;
      *(_OWORD *)(result + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(unsigned char *)(result + 256) = 1;
    }
    else
    {
      *(unsigned char *)(result + 256) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 52) = 0u;
    *(_OWORD *)(result + 68) = 0u;
    *(_OWORD *)(result + 84) = 0u;
    *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 116) = 0u;
    *(_OWORD *)(result + 132) = 0u;
    *(_OWORD *)(result + 148) = 0u;
    *(_OWORD *)(result + 164) = 0u;
    *(_OWORD *)(result + 18swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 196) = 0u;
    *(_OWORD *)(result + 212) = 0u;
    *(_OWORD *)(result + 228) = 0u;
    *(_OWORD *)(result + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_yLm16ELm512ELm512EEEEELb1ELm512ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_yLm16ELm512ELm512EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 32);
  long long v5 = *(_OWORD *)(a2 + 48);
  long long v6 = *(_OWORD *)(a2 + 64);
  long long v7 = *(_OWORD *)(a2 + 80);
  long long v8 = *(_OWORD *)(a2 + 96);
  long long v9 = *(_OWORD *)(a2 + 112);
  long long v10 = *(_OWORD *)(a2 + 128);
  long long v11 = *(_OWORD *)(a2 + 144);
  long long v12 = *(_OWORD *)(a2 + 160);
  long long v13 = *(_OWORD *)(a2 + 176);
  long long v14 = *(_OWORD *)(a2 + 192);
  long long v15 = *(_OWORD *)(a2 + 208);
  long long v16 = *(_OWORD *)(a2 + 224);
  long long v17 = *(_OWORD *)(a2 + 240);
  long long v18 = *(_OWORD *)(a2 + 256);
  long long v19 = *(_OWORD *)(a2 + 272);
  long long v20 = *(_OWORD *)(a2 + 288);
  long long v21 = *(_OWORD *)(a2 + 304);
  long long v22 = *(_OWORD *)(a2 + 320);
  long long v23 = *(_OWORD *)(a2 + 336);
  long long v24 = *(_OWORD *)(a2 + 352);
  long long v25 = *(_OWORD *)(a2 + 368);
  long long v26 = *(_OWORD *)(a2 + 384);
  long long v27 = *(_OWORD *)(a2 + 400);
  long long v28 = *(_OWORD *)(a2 + 416);
  long long v29 = *(_OWORD *)(a2 + 432);
  long long v30 = *(_OWORD *)(a2 + 448);
  long long v31 = *(_OWORD *)(a2 + 464);
  long long v32 = *(_OWORD *)(a2 + 496);
  *(_OWORD *)(a1 + 48swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = *(_OWORD *)(a2 + 480);
  *(_OWORD *)(a1 + 496) = v32;
  *(_OWORD *)(a1 + 448) = v30;
  *(_OWORD *)(a1 + 464) = v31;
  *(_OWORD *)(a1 + 416) = v28;
  *(_OWORD *)(a1 + 432) = v29;
  *(_OWORD *)(a1 + 384) = v26;
  *(_OWORD *)(a1 + 40swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v27;
  *(_OWORD *)(a1 + 352) = v24;
  *(_OWORD *)(a1 + 368) = v25;
  *(_OWORD *)(a1 + 32swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v22;
  *(_OWORD *)(a1 + 336) = v23;
  *(_OWORD *)(a1 + 288) = v20;
  *(_OWORD *)(a1 + 304) = v21;
  *(_OWORD *)(a1 + 256) = v18;
  *(_OWORD *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v17;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_yLm16ELm512ELm512EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 32);
  long long v5 = *(_OWORD *)(a2 + 48);
  long long v6 = *(_OWORD *)(a2 + 64);
  long long v7 = *(_OWORD *)(a2 + 80);
  long long v8 = *(_OWORD *)(a2 + 96);
  long long v9 = *(_OWORD *)(a2 + 112);
  long long v10 = *(_OWORD *)(a2 + 128);
  long long v11 = *(_OWORD *)(a2 + 144);
  long long v12 = *(_OWORD *)(a2 + 160);
  long long v13 = *(_OWORD *)(a2 + 176);
  long long v14 = *(_OWORD *)(a2 + 192);
  long long v15 = *(_OWORD *)(a2 + 208);
  long long v16 = *(_OWORD *)(a2 + 224);
  long long v17 = *(_OWORD *)(a2 + 240);
  long long v18 = *(_OWORD *)(a2 + 256);
  long long v19 = *(_OWORD *)(a2 + 272);
  long long v20 = *(_OWORD *)(a2 + 288);
  long long v21 = *(_OWORD *)(a2 + 304);
  long long v22 = *(_OWORD *)(a2 + 320);
  long long v23 = *(_OWORD *)(a2 + 336);
  long long v24 = *(_OWORD *)(a2 + 352);
  long long v25 = *(_OWORD *)(a2 + 368);
  long long v26 = *(_OWORD *)(a2 + 384);
  long long v27 = *(_OWORD *)(a2 + 400);
  long long v28 = *(_OWORD *)(a2 + 416);
  long long v29 = *(_OWORD *)(a2 + 432);
  long long v30 = *(_OWORD *)(a2 + 448);
  long long v31 = *(_OWORD *)(a2 + 464);
  long long v32 = *(_OWORD *)(a2 + 496);
  *(_OWORD *)(a1 + 48swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = *(_OWORD *)(a2 + 480);
  *(_OWORD *)(a1 + 496) = v32;
  *(_OWORD *)(a1 + 448) = v30;
  *(_OWORD *)(a1 + 464) = v31;
  *(_OWORD *)(a1 + 416) = v28;
  *(_OWORD *)(a1 + 432) = v29;
  *(_OWORD *)(a1 + 384) = v26;
  *(_OWORD *)(a1 + 40swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v27;
  *(_OWORD *)(a1 + 352) = v24;
  *(_OWORD *)(a1 + 368) = v25;
  *(_OWORD *)(a1 + 32swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v22;
  *(_OWORD *)(a1 + 336) = v23;
  *(_OWORD *)(a1 + 288) = v20;
  *(_OWORD *)(a1 + 304) = v21;
  *(_OWORD *)(a1 + 256) = v18;
  *(_OWORD *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v17;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_yLm16ELm512ELm512EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 32);
  long long v5 = *(_OWORD *)(a2 + 48);
  long long v6 = *(_OWORD *)(a2 + 64);
  long long v7 = *(_OWORD *)(a2 + 80);
  long long v8 = *(_OWORD *)(a2 + 96);
  long long v9 = *(_OWORD *)(a2 + 112);
  long long v10 = *(_OWORD *)(a2 + 128);
  long long v11 = *(_OWORD *)(a2 + 144);
  long long v12 = *(_OWORD *)(a2 + 160);
  long long v13 = *(_OWORD *)(a2 + 176);
  long long v14 = *(_OWORD *)(a2 + 192);
  long long v15 = *(_OWORD *)(a2 + 208);
  long long v16 = *(_OWORD *)(a2 + 224);
  long long v17 = *(_OWORD *)(a2 + 240);
  long long v18 = *(_OWORD *)(a2 + 256);
  long long v19 = *(_OWORD *)(a2 + 272);
  long long v20 = *(_OWORD *)(a2 + 288);
  long long v21 = *(_OWORD *)(a2 + 304);
  long long v22 = *(_OWORD *)(a2 + 320);
  long long v23 = *(_OWORD *)(a2 + 336);
  long long v24 = *(_OWORD *)(a2 + 352);
  long long v25 = *(_OWORD *)(a2 + 368);
  long long v26 = *(_OWORD *)(a2 + 384);
  long long v27 = *(_OWORD *)(a2 + 400);
  long long v28 = *(_OWORD *)(a2 + 416);
  long long v29 = *(_OWORD *)(a2 + 432);
  long long v30 = *(_OWORD *)(a2 + 448);
  long long v31 = *(_OWORD *)(a2 + 464);
  long long v32 = *(_OWORD *)(a2 + 496);
  *(_OWORD *)(a1 + 48swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = *(_OWORD *)(a2 + 480);
  *(_OWORD *)(a1 + 496) = v32;
  *(_OWORD *)(a1 + 448) = v30;
  *(_OWORD *)(a1 + 464) = v31;
  *(_OWORD *)(a1 + 416) = v28;
  *(_OWORD *)(a1 + 432) = v29;
  *(_OWORD *)(a1 + 384) = v26;
  *(_OWORD *)(a1 + 40swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v27;
  *(_OWORD *)(a1 + 352) = v24;
  *(_OWORD *)(a1 + 368) = v25;
  *(_OWORD *)(a1 + 32swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v22;
  *(_OWORD *)(a1 + 336) = v23;
  *(_OWORD *)(a1 + 288) = v20;
  *(_OWORD *)(a1 + 304) = v21;
  *(_OWORD *)(a1 + 256) = v18;
  *(_OWORD *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v17;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_yLm16ELm512ELm512EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 32);
  long long v5 = *(_OWORD *)(a2 + 48);
  long long v6 = *(_OWORD *)(a2 + 64);
  long long v7 = *(_OWORD *)(a2 + 80);
  long long v8 = *(_OWORD *)(a2 + 96);
  long long v9 = *(_OWORD *)(a2 + 112);
  long long v10 = *(_OWORD *)(a2 + 128);
  long long v11 = *(_OWORD *)(a2 + 144);
  long long v12 = *(_OWORD *)(a2 + 160);
  long long v13 = *(_OWORD *)(a2 + 176);
  long long v14 = *(_OWORD *)(a2 + 192);
  long long v15 = *(_OWORD *)(a2 + 208);
  long long v16 = *(_OWORD *)(a2 + 224);
  long long v17 = *(_OWORD *)(a2 + 240);
  long long v18 = *(_OWORD *)(a2 + 256);
  long long v19 = *(_OWORD *)(a2 + 272);
  long long v20 = *(_OWORD *)(a2 + 288);
  long long v21 = *(_OWORD *)(a2 + 304);
  long long v22 = *(_OWORD *)(a2 + 320);
  long long v23 = *(_OWORD *)(a2 + 336);
  long long v24 = *(_OWORD *)(a2 + 352);
  long long v25 = *(_OWORD *)(a2 + 368);
  long long v26 = *(_OWORD *)(a2 + 384);
  long long v27 = *(_OWORD *)(a2 + 400);
  long long v28 = *(_OWORD *)(a2 + 416);
  long long v29 = *(_OWORD *)(a2 + 432);
  long long v30 = *(_OWORD *)(a2 + 448);
  long long v31 = *(_OWORD *)(a2 + 464);
  long long v32 = *(_OWORD *)(a2 + 496);
  *(_OWORD *)(a1 + 48swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = *(_OWORD *)(a2 + 480);
  *(_OWORD *)(a1 + 496) = v32;
  *(_OWORD *)(a1 + 448) = v30;
  *(_OWORD *)(a1 + 464) = v31;
  *(_OWORD *)(a1 + 416) = v28;
  *(_OWORD *)(a1 + 432) = v29;
  *(_OWORD *)(a1 + 384) = v26;
  *(_OWORD *)(a1 + 40swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v27;
  *(_OWORD *)(a1 + 352) = v24;
  *(_OWORD *)(a1 + 368) = v25;
  *(_OWORD *)(a1 + 32swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v22;
  *(_OWORD *)(a1 + 336) = v23;
  *(_OWORD *)(a1 + 288) = v20;
  *(_OWORD *)(a1 + 304) = v21;
  *(_OWORD *)(a1 + 256) = v18;
  *(_OWORD *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v17;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_yLm16ELm512ELm512EEEEELb1ELm512ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 512)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_yLm16ELm512ELm512EEEEELb1ELm512ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 52) = 0u;
      *(_OWORD *)(result + 68) = 0u;
      *(_OWORD *)(result + 84) = 0u;
      *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 116) = 0u;
      *(_OWORD *)(result + 132) = 0u;
      *(_OWORD *)(result + 148) = 0u;
      *(_OWORD *)(result + 164) = 0u;
      *(_OWORD *)(result + 18swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 196) = 0u;
      *(_OWORD *)(result + 212) = 0u;
      *(_OWORD *)(result + 228) = 0u;
      *(_OWORD *)(result + 244) = 0u;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 496) = 0u;
      *(_OWORD *)(result + 26swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 276) = 0u;
      *(_OWORD *)(result + 292) = 0u;
      *(_OWORD *)(result + 308) = 0u;
      *(_OWORD *)(result + 324) = 0u;
      *(_OWORD *)(result + 34swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 356) = 0u;
      *(_OWORD *)(result + 372) = 0u;
      *(_OWORD *)(result + 388) = 0u;
      *(_OWORD *)(result + 404) = 0u;
      *(_OWORD *)(result + 42swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 436) = 0u;
      *(_OWORD *)(result + 452) = 0u;
      *(_OWORD *)(result + 468) = 0u;
      *(_OWORD *)(result + 484) = 0u;
      *(unsigned char *)(result + 512) = 1;
    }
    else
    {
      *(unsigned char *)(result + 512) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 52) = 0u;
    *(_OWORD *)(result + 68) = 0u;
    *(_OWORD *)(result + 84) = 0u;
    *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 116) = 0u;
    *(_OWORD *)(result + 132) = 0u;
    *(_OWORD *)(result + 148) = 0u;
    *(_OWORD *)(result + 164) = 0u;
    *(_OWORD *)(result + 18swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 196) = 0u;
    *(_OWORD *)(result + 212) = 0u;
    *(_OWORD *)(result + 228) = 0u;
    *(_OWORD *)(result + 244) = 0u;
    *(_OWORD *)(result + 496) = 0u;
    *(_OWORD *)(result + 4) = 0u;
    result += 4;
    *(_OWORD *)(result + 256) = 0u;
    *(_OWORD *)(result + 272) = 0u;
    *(_OWORD *)(result + 288) = 0u;
    *(_OWORD *)(result + 304) = 0u;
    *(_OWORD *)(result + 32swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 336) = 0u;
    *(_OWORD *)(result + 352) = 0u;
    *(_OWORD *)(result + 368) = 0u;
    *(_OWORD *)(result + 384) = 0u;
    *(_OWORD *)(result + 40swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 416) = 0u;
    *(_OWORD *)(result + 432) = 0u;
    *(_OWORD *)(result + 448) = 0u;
    *(_OWORD *)(result + 464) = 0u;
    *(_OWORD *)(result + 48swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
  }
  return result;
}

double _ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_fLm8ELm8ELm8EEEEELb1ELm8ELm8ELNS0_12FixedPackingE1EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_fLm8ELm8ELm8EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_fLm8ELm8ELm8EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_fLm8ELm8ELm8EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

double _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_fLm8ELm8ELm8EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(void *a1, double *a2)
{
  double result = *a2;
  *a1 = *(void *)a2;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_fLm8ELm8ELm8EEEEELb1ELm8ELm8ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_fLm8ELm8ELm8EEEEELb1ELm8ELm8ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)double result = a2 - 1;
      *(_DWORD *)(result + 4) = 0;
      *(unsigned char *)(result + 8) = 1;
    }
    else
    {
      *(unsigned char *)(result + 8) = 0;
    }
  }
  else if (a2)
  {
    *(void *)double result = (a2 - 1);
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_fLm16ELm16ELm16EEEEELb1ELm16ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_fLm16ELm16ELm16EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_fLm16ELm16ELm16EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_fLm16ELm16ELm16EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_fLm16ELm16ELm16EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_fLm16ELm16ELm16EEEEELb1ELm16ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_fLm16ELm16ELm16EEEEELb1ELm16ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(_DWORD *)(result + 12) = 0;
      *(unsigned char *)(result + 16) = 1;
    }
    else
    {
      *(unsigned char *)(result + 16) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(_DWORD *)(result + 12) = 0;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_fLm16ELm32ELm32EEEEELb1ELm32ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_fLm16ELm32ELm32EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_fLm16ELm32ELm32EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_fLm16ELm32ELm32EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_fLm16ELm32ELm32EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_fLm16ELm32ELm32EEEEELb1ELm32ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_fLm16ELm32ELm32EEEEELb1ELm32ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(void *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
      *(void *)(result + 12) = 0;
      *(_DWORD *)(result + 28) = 0;
      *(unsigned char *)(result + 32) = 1;
    }
    else
    {
      *(unsigned char *)(result + 32) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(void *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
    *(void *)(result + 12) = 0;
    *(_DWORD *)(result + 28) = 0;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_fLm16ELm64ELm64EEEEELb1ELm64ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_fLm16ELm64ELm64EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_fLm16ELm64ELm64EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_fLm16ELm64ELm64EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_fLm16ELm64ELm64EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_fLm16ELm64ELm64EEEEELb1ELm64ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 64)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_fLm16ELm64ELm64EEEEELb1ELm64ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 48) = 0u;
      *(unsigned char *)(result + 64) = 1;
    }
    else
    {
      *(unsigned char *)(result + 64) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 48) = 0u;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_fLm16ELm128ELm128EEEEELb1ELm128ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_fLm16ELm128ELm128EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_fLm16ELm128ELm128EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_fLm16ELm128ELm128EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_fLm16ELm128ELm128EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_fLm16ELm128ELm128EEEEELb1ELm128ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 128)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_fLm16ELm128ELm128EEEEELb1ELm128ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 52) = 0u;
      *(_OWORD *)(result + 68) = 0u;
      *(_OWORD *)(result + 84) = 0u;
      *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 112) = 0u;
      *(unsigned char *)(result + 128) = 1;
    }
    else
    {
      *(unsigned char *)(result + 128) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 52) = 0u;
    *(_OWORD *)(result + 68) = 0u;
    *(_OWORD *)(result + 84) = 0u;
    *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 112) = 0u;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_fLm16ELm256ELm256EEEEELb1ELm256ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_fLm16ELm256ELm256EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v9 = a2[6];
  long long v8 = a2[7];
  long long v11 = a2[8];
  long long v10 = a2[9];
  long long v13 = a2[10];
  long long v12 = a2[11];
  long long v15 = a2[12];
  long long v14 = a2[13];
  long long v16 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16;
  *(_OWORD *)(a1 + 192) = v15;
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v13;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_fLm16ELm256ELm256EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v9 = a2[6];
  long long v8 = a2[7];
  long long v11 = a2[8];
  long long v10 = a2[9];
  long long v13 = a2[10];
  long long v12 = a2[11];
  long long v15 = a2[12];
  long long v14 = a2[13];
  long long v16 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16;
  *(_OWORD *)(a1 + 192) = v15;
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v13;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_fLm16ELm256ELm256EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v9 = a2[6];
  long long v8 = a2[7];
  long long v11 = a2[8];
  long long v10 = a2[9];
  long long v13 = a2[10];
  long long v12 = a2[11];
  long long v15 = a2[12];
  long long v14 = a2[13];
  long long v16 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16;
  *(_OWORD *)(a1 + 192) = v15;
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v13;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_fLm16ELm256ELm256EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v9 = a2[6];
  long long v8 = a2[7];
  long long v11 = a2[8];
  long long v10 = a2[9];
  long long v13 = a2[10];
  long long v12 = a2[11];
  long long v15 = a2[12];
  long long v14 = a2[13];
  long long v16 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16;
  *(_OWORD *)(a1 + 192) = v15;
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v13;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_fLm16ELm256ELm256EEEEELb1ELm256ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 256)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_fLm16ELm256ELm256EEEEELb1ELm256ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 52) = 0u;
      *(_OWORD *)(result + 68) = 0u;
      *(_OWORD *)(result + 84) = 0u;
      *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 116) = 0u;
      *(_OWORD *)(result + 132) = 0u;
      *(_OWORD *)(result + 148) = 0u;
      *(_OWORD *)(result + 164) = 0u;
      *(_OWORD *)(result + 18swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 196) = 0u;
      *(_OWORD *)(result + 212) = 0u;
      *(_OWORD *)(result + 228) = 0u;
      *(_OWORD *)(result + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(unsigned char *)(result + 256) = 1;
    }
    else
    {
      *(unsigned char *)(result + 256) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 52) = 0u;
    *(_OWORD *)(result + 68) = 0u;
    *(_OWORD *)(result + 84) = 0u;
    *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 116) = 0u;
    *(_OWORD *)(result + 132) = 0u;
    *(_OWORD *)(result + 148) = 0u;
    *(_OWORD *)(result + 164) = 0u;
    *(_OWORD *)(result + 18swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 196) = 0u;
    *(_OWORD *)(result + 212) = 0u;
    *(_OWORD *)(result + 228) = 0u;
    *(_OWORD *)(result + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_dLm16ELm16ELm16EEEEELb1ELm16ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_dLm16ELm16ELm16EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_dLm16ELm16ELm16EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_dLm16ELm16ELm16EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv2_dLm16ELm16ELm16EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_dLm16ELm16ELm16EEEEELb1ELm16ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 16)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv2_dLm16ELm16ELm16EEEEELb1ELm16ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(_DWORD *)(result + 12) = 0;
      *(unsigned char *)(result + 16) = 1;
    }
    else
    {
      *(unsigned char *)(result + 16) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(_DWORD *)(result + 12) = 0;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_dLm16ELm32ELm32EEEEELb1ELm32ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_dLm16ELm32ELm32EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_dLm16ELm32ELm32EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_dLm16ELm32ELm32EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv4_dLm16ELm32ELm32EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(_OWORD *a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_dLm16ELm32ELm32EEEEELb1ELm32ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 32)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv4_dLm16ELm32ELm32EEEEELb1ELm32ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(void *)(result + 4) = 0;
      *(void *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
      *(void *)(result + 12) = 0;
      *(_DWORD *)(result + 28) = 0;
      *(unsigned char *)(result + 32) = 1;
    }
    else
    {
      *(unsigned char *)(result + 32) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(void *)(result + 4) = 0;
    *(void *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0;
    *(void *)(result + 12) = 0;
    *(_DWORD *)(result + 28) = 0;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_dLm16ELm64ELm64EEEEELb1ELm64ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_dLm16ELm64ELm64EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_dLm16ELm64ELm64EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_dLm16ELm64ELm64EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv8_dLm16ELm64ELm64EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v4 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_dLm16ELm64ELm64EEEEELb1ELm64ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 64)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv8_dLm16ELm64ELm64EEEEELb1ELm64ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 48) = 0u;
      *(unsigned char *)(result + 64) = 1;
    }
    else
    {
      *(unsigned char *)(result + 64) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 48) = 0u;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_dLm16ELm128ELm128EEEEELb1ELm128ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_dLm16ELm128ELm128EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_dLm16ELm128ELm128EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_dLm16ELm128ELm128EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv16_dLm16ELm128ELm128EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v8 = a2[7];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_dLm16ELm128ELm128EEEEELb1ELm128ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 128)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv16_dLm16ELm128ELm128EEEEELb1ELm128ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 52) = 0u;
      *(_OWORD *)(result + 68) = 0u;
      *(_OWORD *)(result + 84) = 0u;
      *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 112) = 0u;
      *(unsigned char *)(result + 128) = 1;
    }
    else
    {
      *(unsigned char *)(result + 128) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 52) = 0u;
    *(_OWORD *)(result + 68) = 0u;
    *(_OWORD *)(result + 84) = 0u;
    *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 112) = 0u;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_dLm16ELm256ELm256EEEEELb1ELm256ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_dLm16ELm256ELm256EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v9 = a2[6];
  long long v8 = a2[7];
  long long v11 = a2[8];
  long long v10 = a2[9];
  long long v13 = a2[10];
  long long v12 = a2[11];
  long long v15 = a2[12];
  long long v14 = a2[13];
  long long v16 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16;
  *(_OWORD *)(a1 + 192) = v15;
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v13;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_dLm16ELm256ELm256EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v9 = a2[6];
  long long v8 = a2[7];
  long long v11 = a2[8];
  long long v10 = a2[9];
  long long v13 = a2[10];
  long long v12 = a2[11];
  long long v15 = a2[12];
  long long v14 = a2[13];
  long long v16 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16;
  *(_OWORD *)(a1 + 192) = v15;
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v13;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_dLm16ELm256ELm256EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v9 = a2[6];
  long long v8 = a2[7];
  long long v11 = a2[8];
  long long v10 = a2[9];
  long long v13 = a2[10];
  long long v12 = a2[11];
  long long v15 = a2[12];
  long long v14 = a2[13];
  long long v16 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16;
  *(_OWORD *)(a1 + 192) = v15;
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v13;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv32_dLm16ELm256ELm256EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  __n128 result = (__n128)a2[1];
  long long v5 = a2[2];
  long long v4 = a2[3];
  long long v7 = a2[4];
  long long v6 = a2[5];
  long long v9 = a2[6];
  long long v8 = a2[7];
  long long v11 = a2[8];
  long long v10 = a2[9];
  long long v13 = a2[10];
  long long v12 = a2[11];
  long long v15 = a2[12];
  long long v14 = a2[13];
  long long v16 = a2[15];
  *(_OWORD *)(a1 + 224) = a2[14];
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v16;
  *(_OWORD *)(a1 + 192) = v15;
  *(_OWORD *)(a1 + 208) = v14;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v13;
  *(_OWORD *)(a1 + 176) = v12;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v8;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)a1 = v3;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_dLm16ELm256ELm256EEEEELb1ELm256ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 256)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv32_dLm16ELm256ELm256EEEEELb1ELm256ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 52) = 0u;
      *(_OWORD *)(result + 68) = 0u;
      *(_OWORD *)(result + 84) = 0u;
      *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 116) = 0u;
      *(_OWORD *)(result + 132) = 0u;
      *(_OWORD *)(result + 148) = 0u;
      *(_OWORD *)(result + 164) = 0u;
      *(_OWORD *)(result + 18swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 196) = 0u;
      *(_OWORD *)(result + 212) = 0u;
      *(_OWORD *)(result + 228) = 0u;
      *(_OWORD *)(result + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(unsigned char *)(result + 256) = 1;
    }
    else
    {
      *(unsigned char *)(result + 256) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 4) = 0u;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 52) = 0u;
    *(_OWORD *)(result + 68) = 0u;
    *(_OWORD *)(result + 84) = 0u;
    *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 116) = 0u;
    *(_OWORD *)(result + 132) = 0u;
    *(_OWORD *)(result + 148) = 0u;
    *(_OWORD *)(result + 164) = 0u;
    *(_OWORD *)(result + 18swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 196) = 0u;
    *(_OWORD *)(result + 212) = 0u;
    *(_OWORD *)(result + 228) = 0u;
    *(_OWORD *)(result + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
  }
  return result;
}

char *_ZN5swift12metadataimpl20BufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_dLm16ELm512ELm512EEEEELb1ELm512ELm16ELNS0_12FixedPackingE0EE32initializeBufferWithCopyOfBufferEPNS_17TargetValueBufferINS_9InProcessEEESC_PKNS_14TargetMetadataISA_EE(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_dLm16ELm512ELm512EEEE18initializeWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 32);
  long long v5 = *(_OWORD *)(a2 + 48);
  long long v6 = *(_OWORD *)(a2 + 64);
  long long v7 = *(_OWORD *)(a2 + 80);
  long long v8 = *(_OWORD *)(a2 + 96);
  long long v9 = *(_OWORD *)(a2 + 112);
  long long v10 = *(_OWORD *)(a2 + 128);
  long long v11 = *(_OWORD *)(a2 + 144);
  long long v12 = *(_OWORD *)(a2 + 160);
  long long v13 = *(_OWORD *)(a2 + 176);
  long long v14 = *(_OWORD *)(a2 + 192);
  long long v15 = *(_OWORD *)(a2 + 208);
  long long v16 = *(_OWORD *)(a2 + 224);
  long long v17 = *(_OWORD *)(a2 + 240);
  long long v18 = *(_OWORD *)(a2 + 256);
  long long v19 = *(_OWORD *)(a2 + 272);
  long long v20 = *(_OWORD *)(a2 + 288);
  long long v21 = *(_OWORD *)(a2 + 304);
  long long v22 = *(_OWORD *)(a2 + 320);
  long long v23 = *(_OWORD *)(a2 + 336);
  long long v24 = *(_OWORD *)(a2 + 352);
  long long v25 = *(_OWORD *)(a2 + 368);
  long long v26 = *(_OWORD *)(a2 + 384);
  long long v27 = *(_OWORD *)(a2 + 400);
  long long v28 = *(_OWORD *)(a2 + 416);
  long long v29 = *(_OWORD *)(a2 + 432);
  long long v30 = *(_OWORD *)(a2 + 448);
  long long v31 = *(_OWORD *)(a2 + 464);
  long long v32 = *(_OWORD *)(a2 + 496);
  *(_OWORD *)(a1 + 48swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = *(_OWORD *)(a2 + 480);
  *(_OWORD *)(a1 + 496) = v32;
  *(_OWORD *)(a1 + 448) = v30;
  *(_OWORD *)(a1 + 464) = v31;
  *(_OWORD *)(a1 + 416) = v28;
  *(_OWORD *)(a1 + 432) = v29;
  *(_OWORD *)(a1 + 384) = v26;
  *(_OWORD *)(a1 + 40swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v27;
  *(_OWORD *)(a1 + 352) = v24;
  *(_OWORD *)(a1 + 368) = v25;
  *(_OWORD *)(a1 + 32swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v22;
  *(_OWORD *)(a1 + 336) = v23;
  *(_OWORD *)(a1 + 288) = v20;
  *(_OWORD *)(a1 + 304) = v21;
  *(_OWORD *)(a1 + 256) = v18;
  *(_OWORD *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v17;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_dLm16ELm512ELm512EEEE14assignWithCopyEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 32);
  long long v5 = *(_OWORD *)(a2 + 48);
  long long v6 = *(_OWORD *)(a2 + 64);
  long long v7 = *(_OWORD *)(a2 + 80);
  long long v8 = *(_OWORD *)(a2 + 96);
  long long v9 = *(_OWORD *)(a2 + 112);
  long long v10 = *(_OWORD *)(a2 + 128);
  long long v11 = *(_OWORD *)(a2 + 144);
  long long v12 = *(_OWORD *)(a2 + 160);
  long long v13 = *(_OWORD *)(a2 + 176);
  long long v14 = *(_OWORD *)(a2 + 192);
  long long v15 = *(_OWORD *)(a2 + 208);
  long long v16 = *(_OWORD *)(a2 + 224);
  long long v17 = *(_OWORD *)(a2 + 240);
  long long v18 = *(_OWORD *)(a2 + 256);
  long long v19 = *(_OWORD *)(a2 + 272);
  long long v20 = *(_OWORD *)(a2 + 288);
  long long v21 = *(_OWORD *)(a2 + 304);
  long long v22 = *(_OWORD *)(a2 + 320);
  long long v23 = *(_OWORD *)(a2 + 336);
  long long v24 = *(_OWORD *)(a2 + 352);
  long long v25 = *(_OWORD *)(a2 + 368);
  long long v26 = *(_OWORD *)(a2 + 384);
  long long v27 = *(_OWORD *)(a2 + 400);
  long long v28 = *(_OWORD *)(a2 + 416);
  long long v29 = *(_OWORD *)(a2 + 432);
  long long v30 = *(_OWORD *)(a2 + 448);
  long long v31 = *(_OWORD *)(a2 + 464);
  long long v32 = *(_OWORD *)(a2 + 496);
  *(_OWORD *)(a1 + 48swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = *(_OWORD *)(a2 + 480);
  *(_OWORD *)(a1 + 496) = v32;
  *(_OWORD *)(a1 + 448) = v30;
  *(_OWORD *)(a1 + 464) = v31;
  *(_OWORD *)(a1 + 416) = v28;
  *(_OWORD *)(a1 + 432) = v29;
  *(_OWORD *)(a1 + 384) = v26;
  *(_OWORD *)(a1 + 40swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v27;
  *(_OWORD *)(a1 + 352) = v24;
  *(_OWORD *)(a1 + 368) = v25;
  *(_OWORD *)(a1 + 32swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v22;
  *(_OWORD *)(a1 + 336) = v23;
  *(_OWORD *)(a1 + 288) = v20;
  *(_OWORD *)(a1 + 304) = v21;
  *(_OWORD *)(a1 + 256) = v18;
  *(_OWORD *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v17;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_dLm16ELm512ELm512EEEE18initializeWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 32);
  long long v5 = *(_OWORD *)(a2 + 48);
  long long v6 = *(_OWORD *)(a2 + 64);
  long long v7 = *(_OWORD *)(a2 + 80);
  long long v8 = *(_OWORD *)(a2 + 96);
  long long v9 = *(_OWORD *)(a2 + 112);
  long long v10 = *(_OWORD *)(a2 + 128);
  long long v11 = *(_OWORD *)(a2 + 144);
  long long v12 = *(_OWORD *)(a2 + 160);
  long long v13 = *(_OWORD *)(a2 + 176);
  long long v14 = *(_OWORD *)(a2 + 192);
  long long v15 = *(_OWORD *)(a2 + 208);
  long long v16 = *(_OWORD *)(a2 + 224);
  long long v17 = *(_OWORD *)(a2 + 240);
  long long v18 = *(_OWORD *)(a2 + 256);
  long long v19 = *(_OWORD *)(a2 + 272);
  long long v20 = *(_OWORD *)(a2 + 288);
  long long v21 = *(_OWORD *)(a2 + 304);
  long long v22 = *(_OWORD *)(a2 + 320);
  long long v23 = *(_OWORD *)(a2 + 336);
  long long v24 = *(_OWORD *)(a2 + 352);
  long long v25 = *(_OWORD *)(a2 + 368);
  long long v26 = *(_OWORD *)(a2 + 384);
  long long v27 = *(_OWORD *)(a2 + 400);
  long long v28 = *(_OWORD *)(a2 + 416);
  long long v29 = *(_OWORD *)(a2 + 432);
  long long v30 = *(_OWORD *)(a2 + 448);
  long long v31 = *(_OWORD *)(a2 + 464);
  long long v32 = *(_OWORD *)(a2 + 496);
  *(_OWORD *)(a1 + 48swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = *(_OWORD *)(a2 + 480);
  *(_OWORD *)(a1 + 496) = v32;
  *(_OWORD *)(a1 + 448) = v30;
  *(_OWORD *)(a1 + 464) = v31;
  *(_OWORD *)(a1 + 416) = v28;
  *(_OWORD *)(a1 + 432) = v29;
  *(_OWORD *)(a1 + 384) = v26;
  *(_OWORD *)(a1 + 40swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v27;
  *(_OWORD *)(a1 + 352) = v24;
  *(_OWORD *)(a1 + 368) = v25;
  *(_OWORD *)(a1 + 32swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v22;
  *(_OWORD *)(a1 + 336) = v23;
  *(_OWORD *)(a1 + 288) = v20;
  *(_OWORD *)(a1 + 304) = v21;
  *(_OWORD *)(a1 + 256) = v18;
  *(_OWORD *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v17;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 _ZN5swift12metadataimpl14ValueWitnessesINS0_9NativeBoxIDv64_dLm16ELm512ELm512EEEE14assignWithTakeEPNS_11OpaqueValueES7_PKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 32);
  long long v5 = *(_OWORD *)(a2 + 48);
  long long v6 = *(_OWORD *)(a2 + 64);
  long long v7 = *(_OWORD *)(a2 + 80);
  long long v8 = *(_OWORD *)(a2 + 96);
  long long v9 = *(_OWORD *)(a2 + 112);
  long long v10 = *(_OWORD *)(a2 + 128);
  long long v11 = *(_OWORD *)(a2 + 144);
  long long v12 = *(_OWORD *)(a2 + 160);
  long long v13 = *(_OWORD *)(a2 + 176);
  long long v14 = *(_OWORD *)(a2 + 192);
  long long v15 = *(_OWORD *)(a2 + 208);
  long long v16 = *(_OWORD *)(a2 + 224);
  long long v17 = *(_OWORD *)(a2 + 240);
  long long v18 = *(_OWORD *)(a2 + 256);
  long long v19 = *(_OWORD *)(a2 + 272);
  long long v20 = *(_OWORD *)(a2 + 288);
  long long v21 = *(_OWORD *)(a2 + 304);
  long long v22 = *(_OWORD *)(a2 + 320);
  long long v23 = *(_OWORD *)(a2 + 336);
  long long v24 = *(_OWORD *)(a2 + 352);
  long long v25 = *(_OWORD *)(a2 + 368);
  long long v26 = *(_OWORD *)(a2 + 384);
  long long v27 = *(_OWORD *)(a2 + 400);
  long long v28 = *(_OWORD *)(a2 + 416);
  long long v29 = *(_OWORD *)(a2 + 432);
  long long v30 = *(_OWORD *)(a2 + 448);
  long long v31 = *(_OWORD *)(a2 + 464);
  long long v32 = *(_OWORD *)(a2 + 496);
  *(_OWORD *)(a1 + 48swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = *(_OWORD *)(a2 + 480);
  *(_OWORD *)(a1 + 496) = v32;
  *(_OWORD *)(a1 + 448) = v30;
  *(_OWORD *)(a1 + 464) = v31;
  *(_OWORD *)(a1 + 416) = v28;
  *(_OWORD *)(a1 + 432) = v29;
  *(_OWORD *)(a1 + 384) = v26;
  *(_OWORD *)(a1 + 40swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v27;
  *(_OWORD *)(a1 + 352) = v24;
  *(_OWORD *)(a1 + 368) = v25;
  *(_OWORD *)(a1 + 32swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v22;
  *(_OWORD *)(a1 + 336) = v23;
  *(_OWORD *)(a1 + 288) = v20;
  *(_OWORD *)(a1 + 304) = v21;
  *(_OWORD *)(a1 + 256) = v18;
  *(_OWORD *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 24swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v17;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 16swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v12;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 128) = v10;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 8swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v7;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_dLm16ELm512ELm512EEEEELb1ELm512ELm16ELb0EE23getEnumTagSinglePayloadEPKNS_11OpaqueValueEjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 512)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t _ZN5swift12metadataimpl29FixedSizeBufferValueWitnessesINS0_14ValueWitnessesINS0_9NativeBoxIDv64_dLm16ELm512ELm512EEEEELb1ELm512ELm16ELb0EE25storeEnumTagSinglePayloadEPNS_11OpaqueValueEjjPKNS_14TargetMetadataINS_9InProcessEEE(uint64_t result, int a2, int a3)
{
  if (a3)
  {
    if (a2)
    {
      *(_DWORD *)__n128 result = a2 - 1;
      *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 36) = 0u;
      *(_OWORD *)(result + 52) = 0u;
      *(_OWORD *)(result + 68) = 0u;
      *(_OWORD *)(result + 84) = 0u;
      *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 116) = 0u;
      *(_OWORD *)(result + 132) = 0u;
      *(_OWORD *)(result + 148) = 0u;
      *(_OWORD *)(result + 164) = 0u;
      *(_OWORD *)(result + 18swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 196) = 0u;
      *(_OWORD *)(result + 212) = 0u;
      *(_OWORD *)(result + 228) = 0u;
      *(_OWORD *)(result + 244) = 0u;
      *(_OWORD *)(result + 4) = 0u;
      *(_OWORD *)(result + 496) = 0u;
      *(_OWORD *)(result + 26swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 276) = 0u;
      *(_OWORD *)(result + 292) = 0u;
      *(_OWORD *)(result + 308) = 0u;
      *(_OWORD *)(result + 324) = 0u;
      *(_OWORD *)(result + 34swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 356) = 0u;
      *(_OWORD *)(result + 372) = 0u;
      *(_OWORD *)(result + 388) = 0u;
      *(_OWORD *)(result + 404) = 0u;
      *(_OWORD *)(result + 42swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(result + 436) = 0u;
      *(_OWORD *)(result + 452) = 0u;
      *(_OWORD *)(result + 468) = 0u;
      *(_OWORD *)(result + 484) = 0u;
      *(unsigned char *)(result + 512) = 1;
    }
    else
    {
      *(unsigned char *)(result + 512) = 0;
    }
  }
  else if (a2)
  {
    *(_DWORD *)__n128 result = a2 - 1;
    *(_OWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 36) = 0u;
    *(_OWORD *)(result + 52) = 0u;
    *(_OWORD *)(result + 68) = 0u;
    *(_OWORD *)(result + 84) = 0u;
    *(_OWORD *)(result + 10swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 116) = 0u;
    *(_OWORD *)(result + 132) = 0u;
    *(_OWORD *)(result + 148) = 0u;
    *(_OWORD *)(result + 164) = 0u;
    *(_OWORD *)(result + 18swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 196) = 0u;
    *(_OWORD *)(result + 212) = 0u;
    *(_OWORD *)(result + 228) = 0u;
    *(_OWORD *)(result + 244) = 0u;
    *(_OWORD *)(result + 496) = 0u;
    *(_OWORD *)(result + 4) = 0u;
    result += 4;
    *(_OWORD *)(result + 256) = 0u;
    *(_OWORD *)(result + 272) = 0u;
    *(_OWORD *)(result + 288) = 0u;
    *(_OWORD *)(result + 304) = 0u;
    *(_OWORD *)(result + 32swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 336) = 0u;
    *(_OWORD *)(result + 352) = 0u;
    *(_OWORD *)(result + 368) = 0u;
    *(_OWORD *)(result + 384) = 0u;
    *(_OWORD *)(result + 40swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(result + 416) = 0u;
    *(_OWORD *)(result + 432) = 0u;
    *(_OWORD *)(result + 448) = 0u;
    *(_OWORD *)(result + 464) = 0u;
    *(_OWORD *)(result + 48swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
  }
  return result;
}

void *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::PointerPointerBox>,true,8ul,8ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::PointerPointerBox>::initializeWithCopy(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::PointerPointerBox>::assignWithCopy(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::PointerPointerBox>::initializeWithTake(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::PointerPointerBox>::assignWithTake(void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::PointerPointerBox>,true,8ul,8ul,true>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 < 0 && *(unsigned char *)(a1 + 8)) {
    return *(_DWORD *)a1 ^ 0x80000000;
  }
  if (HIDWORD(*(void *)a1)) {
    return 0;
  }
  return *(void *)a1 + 1;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::PointerPointerBox>,true,8ul,8ul,true>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if ((a3 & 0x80000000) == 0)
  {
    if (a2 < 0)
    {
      *(void *)__n128 result = a2 ^ 0x80000000;
      return result;
    }
    if (!a2) {
      return result;
    }
LABEL_7:
    *(void *)__n128 result = (a2 - 1);
    return result;
  }
  if (a2 < 0)
  {
    *(_DWORD *)__n128 result = a2 ^ 0x80000000;
    *(_DWORD *)(result + 4) = 0;
    *(unsigned char *)(result + 8) = 1;
    return result;
  }
  *(unsigned char *)(result + 8) = 0;
  if (a2) {
    goto LABEL_7;
  }
  return result;
}

void *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<anonymous namespace'::ThickFunctionBox>,true,16ul,8ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(void *a1, void *a2)
{
  *a1 = *a2;
  long long v3 = (atomic_ullong *)a2[1];
  swift_retain(v3);
  a1[1] = v3;
  return a1;
}

uint64_t swift::metadataimpl::ValueWitnesses<anonymous namespace'::ThickFunctionBox>::destroy(uint64_t a1)
{
  return swift_release(*(void *)(a1 + 8));
}

void *swift::metadataimpl::ValueWitnesses<anonymous namespace'::ThickFunctionBox>::initializeWithCopy(void *a1, void *a2)
{
  *a1 = *a2;
  long long v3 = (atomic_ullong *)a2[1];
  swift_retain(v3);
  a1[1] = v3;
  return a1;
}

void *swift::metadataimpl::ValueWitnesses<anonymous namespace'::ThickFunctionBox>::assignWithCopy(void *a1, void *a2)
{
  *a1 = *a2;
  uint64_t v3 = a1[1];
  long long v4 = (atomic_ullong *)a2[1];
  swift_retain(v4);
  a1[1] = v4;
  swift_release(v3);
  return a1;
}

void *swift::metadataimpl::ValueWitnesses<anonymous namespace'::ThickFunctionBox>::initializeWithTake(void *result, void *a2)
{
  *__n128 result = *a2;
  result[1] = a2[1];
  return result;
}

void *swift::metadataimpl::ValueWitnesses<anonymous namespace'::ThickFunctionBox>::assignWithTake(void *a1, void *a2)
{
  *a1 = *a2;
  uint64_t v3 = a1[1];
  a1[1] = a2[1];
  swift_release(v3);
  return a1;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<anonymous namespace'::ThickFunctionBox>,true,16ul,8ul,true>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 < 0 && *(unsigned char *)(a1 + 16)) {
    return *(_DWORD *)a1 ^ 0x80000000;
  }
  if (HIDWORD(*(void *)a1)) {
    return 0;
  }
  return *(void *)a1 + 1;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<anonymous namespace'::ThickFunctionBox>,true,16ul,8ul,true>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if ((a3 & 0x80000000) == 0)
  {
    if (a2 < 0)
    {
      *(_DWORD *)__n128 result = a2 ^ 0x80000000;
      *(void *)(result + 4) = 0;
      *(_DWORD *)(result + 12) = 0;
      return result;
    }
    if (!a2) {
      return result;
    }
LABEL_7:
    *(void *)__n128 result = (a2 - 1);
    return result;
  }
  if (a2 < 0)
  {
    *(_DWORD *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + 4) = 0;
    *(_DWORD *)(result + 12) = 0;
    *(unsigned char *)(result + 16) = 1;
    return result;
  }
  *(unsigned char *)(result + 16) = 0;
  if (a2) {
    goto LABEL_7;
  }
  return result;
}

char *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<anonymous namespace'::DiffFunctionBox>,true,48ul,8ul,(swift::metadataimpl::FixedPacking)0>::initializeBufferWithCopyOfBuffer(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  long long v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

uint64_t swift::metadataimpl::ValueWitnesses<anonymous namespace'::DiffFunctionBox>::destroy(uint64_t *a1)
{
  swift_release(a1[1]);
  swift_release(a1[3]);
  uint64_t v2 = a1[5];

  return swift_release(v2);
}

void *swift::metadataimpl::ValueWitnesses<anonymous namespace'::DiffFunctionBox>::initializeWithCopy(void *a1, void *a2)
{
  *a1 = *a2;
  long long v4 = (atomic_ullong *)a2[1];
  swift_retain(v4);
  a1[1] = v4;
  a1[2] = a2[2];
  long long v5 = (atomic_ullong *)a2[3];
  swift_retain(v5);
  a1[3] = v5;
  a1[4] = a2[4];
  long long v6 = (atomic_ullong *)a2[5];
  swift_retain(v6);
  a1[5] = v6;
  return a1;
}

void *swift::metadataimpl::ValueWitnesses<anonymous namespace'::DiffFunctionBox>::assignWithCopy(void *a1, void *a2)
{
  *a1 = *a2;
  uint64_t v4 = a1[1];
  long long v5 = (atomic_ullong *)a2[1];
  swift_retain(v5);
  a1[1] = v5;
  swift_release(v4);
  a1[2] = a2[2];
  uint64_t v6 = a1[3];
  long long v7 = (atomic_ullong *)a2[3];
  swift_retain(v7);
  a1[3] = v7;
  swift_release(v6);
  a1[4] = a2[4];
  uint64_t v8 = a1[5];
  long long v9 = (atomic_ullong *)a2[5];
  swift_retain(v9);
  a1[5] = v9;
  swift_release(v8);
  return a1;
}

void *swift::metadataimpl::ValueWitnesses<anonymous namespace'::DiffFunctionBox>::initializeWithTake(void *result, void *a2)
{
  *__n128 result = *a2;
  result[1] = a2[1];
  result[2] = a2[2];
  result[3] = a2[3];
  result[4] = a2[4];
  result[5] = a2[5];
  return result;
}

void *swift::metadataimpl::ValueWitnesses<anonymous namespace'::DiffFunctionBox>::assignWithTake(void *a1, void *a2)
{
  *a1 = *a2;
  uint64_t v4 = a1[1];
  a1[1] = a2[1];
  swift_release(v4);
  a1[2] = a2[2];
  uint64_t v5 = a1[3];
  a1[3] = a2[3];
  swift_release(v5);
  a1[4] = a2[4];
  uint64_t v6 = a1[5];
  a1[5] = a2[5];
  swift_release(v6);
  return a1;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<anonymous namespace'::DiffFunctionBox>,true,48ul,8ul,true>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 < 0 && *(unsigned char *)(a1 + 48)) {
    return *(_DWORD *)a1 ^ 0x80000000;
  }
  if (HIDWORD(*(void *)a1)) {
    return 0;
  }
  return *(void *)a1 + 1;
}

double swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<anonymous namespace'::DiffFunctionBox>,true,48ul,8ul,true>::storeEnumTagSinglePayload(uint64_t a1, int a2, int a3)
{
  if ((a3 & 0x80000000) == 0)
  {
    if (a2 < 0)
    {
      *(_DWORD *)a1 = a2 ^ 0x80000000;
      double result = 0.0;
      *(_OWORD *)(a1 + 4) = 0u;
      *(_OWORD *)(a1 + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
      *(_OWORD *)(a1 + 32) = 0u;
      return result;
    }
    if (!a2) {
      return result;
    }
LABEL_7:
    *(void *)a1 = (a2 - 1);
    return result;
  }
  if (a2 < 0)
  {
    *(_DWORD *)a1 = a2 ^ 0x80000000;
    double result = 0.0;
    *(_OWORD *)(a1 + 4) = 0u;
    *(_OWORD *)(a1 + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(unsigned char *)(a1 + 48) = 1;
    return result;
  }
  *(unsigned char *)(a1 + 48) = 0;
  if (a2) {
    goto LABEL_7;
  }
  return result;
}

void *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<anonymous namespace'::TrivialThickFunctionBox>,true,16ul,8ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(void *result, void *a2)
{
  *double result = *a2;
  result[1] = a2[1];
  return result;
}

void *swift::metadataimpl::ValueWitnesses<anonymous namespace'::TrivialThickFunctionBox>::initializeWithCopy(void *result, void *a2)
{
  *double result = *a2;
  result[1] = a2[1];
  return result;
}

void *swift::metadataimpl::ValueWitnesses<anonymous namespace'::TrivialThickFunctionBox>::assignWithCopy(void *result, void *a2)
{
  *double result = *a2;
  result[1] = a2[1];
  return result;
}

void *swift::metadataimpl::ValueWitnesses<anonymous namespace'::TrivialThickFunctionBox>::initializeWithTake(void *result, void *a2)
{
  *double result = *a2;
  result[1] = a2[1];
  return result;
}

void *swift::metadataimpl::ValueWitnesses<anonymous namespace'::TrivialThickFunctionBox>::assignWithTake(void *result, void *a2)
{
  *double result = *a2;
  result[1] = a2[1];
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<anonymous namespace'::TrivialThickFunctionBox>,true,16ul,8ul,true>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 < 0 && *(unsigned char *)(a1 + 16)) {
    return *(_DWORD *)a1 ^ 0x80000000;
  }
  if (HIDWORD(*(void *)a1)) {
    return 0;
  }
  return *(void *)a1 + 1;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<anonymous namespace'::TrivialThickFunctionBox>,true,16ul,8ul,true>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if ((a3 & 0x80000000) == 0)
  {
    if (a2 < 0)
    {
      *(_DWORD *)double result = a2 ^ 0x80000000;
      *(void *)(result + 4) = 0;
      *(_DWORD *)(result + 12) = 0;
      return result;
    }
    if (!a2) {
      return result;
    }
LABEL_7:
    *(void *)double result = (a2 - 1);
    return result;
  }
  if (a2 < 0)
  {
    *(_DWORD *)double result = a2 ^ 0x80000000;
    *(void *)(result + 4) = 0;
    *(_DWORD *)(result + 12) = 0;
    *(unsigned char *)(result + 16) = 1;
    return result;
  }
  *(unsigned char *)(result + 16) = 0;
  if (a2) {
    goto LABEL_7;
  }
  return result;
}

void *swift::metadataimpl::BufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::FunctionPointerBox>,true,8ul,8ul,(swift::metadataimpl::FixedPacking)1>::initializeBufferWithCopyOfBuffer(void *result, void *a2)
{
  *double result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::FunctionPointerBox>::initializeWithCopy(void *result, void *a2)
{
  *double result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::FunctionPointerBox>::assignWithCopy(void *result, void *a2)
{
  *double result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::FunctionPointerBox>::initializeWithTake(void *result, void *a2)
{
  *double result = *a2;
  return result;
}

void *swift::metadataimpl::ValueWitnesses<swift::metadataimpl::FunctionPointerBox>::assignWithTake(void *result, void *a2)
{
  *double result = *a2;
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::FunctionPointerBox>,true,8ul,8ul,true>::getEnumTagSinglePayload(uint64_t a1, int a2)
{
  if (a2 < 0 && *(unsigned char *)(a1 + 8)) {
    return *(_DWORD *)a1 ^ 0x80000000;
  }
  if (HIDWORD(*(void *)a1)) {
    return 0;
  }
  return *(void *)a1 + 1;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::FunctionPointerBox>,true,8ul,8ul,true>::storeEnumTagSinglePayload(uint64_t result, int a2, int a3)
{
  if ((a3 & 0x80000000) == 0)
  {
    if (a2 < 0)
    {
      *(void *)double result = a2 ^ 0x80000000;
      return result;
    }
    if (!a2) {
      return result;
    }
LABEL_7:
    *(void *)double result = (a2 - 1);
    return result;
  }
  if (a2 < 0)
  {
    *(_DWORD *)double result = a2 ^ 0x80000000;
    *(_DWORD *)(result + 4) = 0;
    *(unsigned char *)(result + 8) = 1;
    return result;
  }
  *(unsigned char *)(result + 8) = 0;
  if (a2) {
    goto LABEL_7;
  }
  return result;
}

uint64_t swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::AggregateBox<>>,true,0ul,1ul,false>::getEnumTagSinglePayload(unsigned int *a1, int a2)
{
  if (a2)
  {
    unsigned int v2 = a2 + 1;
    if ((a2 + 1) >= 2)
    {
      if (v2 >= 0x100)
      {
        if (v2 >= 0x10000)
        {
          uint64_t result = *a1;
          if (result) {
            return result;
          }
        }
        else
        {
          uint64_t result = *(unsigned __int16 *)a1;
          if (result) {
            return result;
          }
        }
      }
      else
      {
        uint64_t result = *(unsigned __int8 *)a1;
        if (result) {
          return result;
        }
      }
    }
  }
  return 0;
}

void swift::metadataimpl::FixedSizeBufferValueWitnesses<swift::metadataimpl::ValueWitnesses<swift::metadataimpl::AggregateBox<>>,true,0ul,1ul,false>::storeEnumTagSinglePayload(unsigned char *a1, int a2, int a3)
{
  if (a3)
  {
    unsigned int v3 = a3 + 1;
    if ((a3 + 1) >= 2)
    {
      if (v3 >= 0x10000) {
        unsigned int v4 = 4;
      }
      else {
        unsigned int v4 = 2;
      }
      if (v3 < 0x100) {
        uint64_t v5 = 1;
      }
      else {
        uint64_t v5 = v4;
      }
      if (a2)
      {
        switch((int)v5)
        {
          case 1:
            *a1 = a2;
            break;
          case 2:
            *(_WORD *)a1 = a2;
            break;
          case 3:
            *(_WORD *)a1 = a2;
            a1[2] = BYTE2(a2);
            break;
          case 4:
            *(_DWORD *)a1 = a2;
            break;
          default:
            *(_DWORD *)a1 = a2;
            bzero(a1 + 4, v5 - 4);
            break;
        }
      }
      else
      {
        switch(v5)
        {
          case 1:
            *a1 = 0;
            break;
          case 2:
            *(_WORD *)a1 = 0;
            break;
          case 3:
            a1[2] = 0;
            *(_WORD *)a1 = 0;
            break;
          case 4:
            *(_DWORD *)a1 = 0;
            break;
          default:
            *(_DWORD *)a1 = 0;
            bzero(a1 + 4, v5 - 4);
            break;
        }
      }
    }
  }
}

void swift::libPrespecializedImageLoaded(swift *this)
{
  if (dyld_shared_cache_some_image_overridden())
  {
    if (qword_1EB1F8878 != -1) {
      dispatch_once_f(&qword_1EB1F8878, &LibPrespecialized, (dispatch_function_t)swift::Lazy<LibPrespecializedState>::defaultInitCallback);
    }
    atomic_store(4u, (unsigned int *)&unk_1EB1F8848);
  }
}

const void *swift::getLibPrespecializedMetadata(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  unsigned int v4 = (_DWORD *)v1;
  if (qword_1EB1F8878 != -1) {
    dispatch_once_f(&qword_1EB1F8878, &LibPrespecialized, (dispatch_function_t)swift::Lazy<LibPrespecializedState>::defaultInitCallback);
  }
  unsigned int v5 = atomic_load((unsigned int *)&unk_1EB1F8848);
  if (v5 == 3)
  {
    uint64_t GenericContext = swift::TargetContextDescriptor<swift::InProcess>::getGenericContext(v4);
    if (GenericContext)
    {
      long long v11 = *(void **)(LibPrespecialized + 24);
      if (!*v11)
      {
LABEL_28:
        if (prespecializedLoggingEnabled) {
          fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Looking up description %p in debug table, no entry found.\n");
        }
        return 0;
      }
      uint64_t v12 = 0;
      while (1)
      {
        long long v13 = (void *)v11[2 * v12 + 1];
        if (*v13 == *(unsigned __int16 *)(GenericContext + 8) + 1)
        {
          long long v14 = v4 ? v4 : 0;
          if (v14 == (_DWORD *)v13[1]) {
            break;
          }
        }
LABEL_16:
        if (++v12 == *v11) {
          goto LABEL_28;
        }
      }
      long long v15 = v13 + 2;
      uint64_t v16 = *(unsigned __int16 *)(GenericContext + 8);
      long long v17 = (uint64_t *)v3;
      while (v16)
      {
        uint64_t v19 = *v15++;
        uint64_t v18 = v19;
        uint64_t v20 = *v17++;
        --v16;
        if (v18 != v20) {
          goto LABEL_16;
        }
      }
      if (prespecializedLoggingEnabled)
      {
        uint64_t v39 = v4;
        uint64_t v38 = v12;
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Looking up description %p in debug table, found %p.\n", v39, (const void *)v11[2 * v12 + 2]);
        uint64_t v12 = v38;
      }
      return (const void *)v11[2 * v12 + 2];
    }
    return 0;
  }
  if (v5 == 2)
  {
    if (swift::TargetContextDescriptor<swift::InProcess>::getGenericContext(v4))
    {
      pointer_hash_table_entry = (const void *)_dyld_find_pointer_hash_table_entry();
      if (prespecializedLoggingEnabled) {
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Looking up description %p in dyld table, found %p.\n", v4, pointer_hash_table_entry);
      }
      return pointer_hash_table_entry;
    }
    return 0;
  }
  if (v5 != 1) {
    return 0;
  }
  uint64_t v6 = swift::TargetContextDescriptor<swift::InProcess>::getGenericContext(v4);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = *(unsigned __int16 *)(v6 + 4);
  if (*(_WORD *)(v6 + 4))
  {
    uint64_t v8 = (unsigned char *)(v6 + 12);
    while ((*v8 & 0x3F) == 0)
    {
      ++v8;
      if (!--v7) {
        goto LABEL_11;
      }
    }
    return 0;
  }
LABEL_11:
  if (v4) {
    unint64_t v9 = (unint64_t)v4;
  }
  else {
    unint64_t v9 = 0;
  }
  BOOL v23 = qword_1EB1F8850 <= (unint64_t)LibPrespecialized && unk_1EB1F8858 > (unint64_t)LibPrespecialized;
  if (v23)
  {
    BOOL v24 = qword_1EB1F8850 <= v9 && unk_1EB1F8858 > v9;
    if (!v24 || qword_1EB1F8860 <= v9 && qword_1EB1F8868 > v9)
    {
      if (prespecializedLoggingEnabled) {
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Rejecting descriptor %p, not in the shared cache\n");
      }
      return 0;
    }
  }
  if (*(_WORD *)(v6 + 8))
  {
    uint64_t v25 = 0;
    while (1)
    {
      if (v23)
      {
        unint64_t v26 = *(void *)(v3 + 8 * v25);
        if (qword_1EB1F8850 > v26 || unk_1EB1F8858 <= v26) {
          break;
        }
        if (qword_1EB1F8860 <= v26 && qword_1EB1F8868 > v26) {
          break;
        }
      }
      if (*(unsigned __int16 *)(v6 + 8) == ++v25) {
        goto LABEL_70;
      }
    }
    if (prespecializedLoggingEnabled) {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Rejecting argument %u %p to descriptor %p, not in the shared cache\n");
    }
    return 0;
  }
LABEL_70:
  long long v44 = xmmword_181636930;
  uint64_t v45 = 0;
  char v46 = 0;
  char v81 = 0;
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  uint64_t v47 = 0;
  char v50 = 0;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  int v79 = 0;
  v43[0] = &unk_1ECA06298;
  v43[1] = &v82;
  v43[2] = v83;
  long long v30 = swift::_buildDemanglingForGenericType((char *)v4, v3, (swift::Demangle::__runtime::NodeFactory *)v43);
  if (v30)
  {
    long long v31 = v30;
    if (*((_WORD *)v30 + 8) != 99)
    {
      Node = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(v43, 99);
      swift::Demangle::__runtime::Node::addChild(Node, v31, (swift::Demangle::__runtime::NodeFactory *)v43);
      long long v31 = Node;
    }
    swift::Demangle::__runtime::mangleNode((uint64_t)v31);
    if (v40)
    {
      swift::warning(0, "Mangling for prespecialized metadata failed with code %d", v33, v34, v40);
      pointer_hash_table_entry = 0;
    }
    else
    {
      unint64_t v35 = *(unint64_t **)(LibPrespecialized + 8);
      uint64_t v84 = v42;
      uint64_t v85 = v41;
      v83[0] = v35;
      v83[1] = &v85;
      v83[2] = &v84;
      unint64_t v36 = swift::PrebuiltStringMapBase::findIndex<swift::PrebuiltStringMap<char const*,swift::TargetMetadata<swift::InProcess> *,&swift::LibPrespecializedData<swift::InProcess>::stringIsNull>::find(char const*,unsigned long)::{lambda(unsigned long)#1}>(v35, v41, v42, v83);
      if (v37 && v35[2 * v36 + 1]) {
        pointer_hash_table_entry = (const void *)v35[2 * v36 + 2];
      }
      else {
        pointer_hash_table_entry = 0;
      }
      if (prespecializedLoggingEnabled) {
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: found %p for key '%.*s'.\n", pointer_hash_table_entry, v42, (const char *)v41);
      }
    }
  }
  else
  {
    if (prespecializedLoggingEnabled) {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: failed to build demangling with descriptor %p.\n", v4);
    }
    pointer_hash_table_entry = 0;
  }
  v43[0] = &unk_1ECA07790;
  if (v81 == v80)
  {
    (*(void (**)(void *))(v80[0] + 32))(v80);
  }
  else if (v81)
  {
    (*(void (**)(void))(*v81 + 40))();
  }
  v43[0] = &unk_1ECA07768;
  swift::Demangle::__runtime::NodeFactory::freeSlabs((void *)v44);
  if (v45) {
    *(unsigned char *)(v45 + 48) = 0;
  }
  return pointer_hash_table_entry;
}

uint64_t swift::getLibPrespecializedTypeDescriptor(swift *this, swift::Demangle::__runtime::Node *a2)
{
  uint64_t v2 = (const char *)MEMORY[0x1F4188790](this);
  if (qword_1EB1F8878 != -1) {
    dispatch_once_f(&qword_1EB1F8878, &LibPrespecialized, (dispatch_function_t)swift::Lazy<LibPrespecializedState>::defaultInitCallback);
  }
  uint64_t v3 = LibPrespecialized;
  if (LibPrespecialized) {
    BOOL v4 = byte_1EB1F8870 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return 2;
  }
  if (*(_DWORD *)(LibPrespecialized + 4) < 4u) {
    return 2;
  }
  unsigned int v5 = *(unint64_t **)(LibPrespecialized + 40);
  if (!v5) {
    return 2;
  }
  long long v55 = xmmword_181636930;
  uint64_t v56 = 0;
  char v57 = 0;
  uint64_t v92 = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  uint64_t v58 = 0;
  char v61 = 0;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v82 = 0u;
  long long v83 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v86 = 0u;
  long long v87 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  int v90 = 0;
  v54[0] = &unk_1ECA06298;
  v54[1] = &v93;
  v54[2] = &v94;
  if (prespecializedLoggingEnabled)
  {
    swift::Demangle::__runtime::mangleNode((uint64_t)v2);
    if (v51)
    {
      if (prespecializedLoggingEnabled) {
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Failed to build demangling for node %p.\n");
      }
      goto LABEL_95;
    }
    if (prespecializedLoggingEnabled) {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Looking up descriptor named '%.*s'.\n", v53, v52);
    }
  }
  if (!v2)
  {
LABEL_93:
    if (prespecializedLoggingEnabled) {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Failed to build simplified mangling for node %p.\n");
    }
    goto LABEL_95;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = (uint64_t)v2;
  while (1)
  {
    unsigned int v11 = *(unsigned __int16 *)(v8 + 16);
    if (v11 > 0xA6)
    {
      if (*(unsigned __int16 *)(v8 + 16) > 0xE9u)
      {
        if (v11 != 234 && v11 != 300) {
          goto LABEL_66;
        }
      }
      else if (v11 != 167 && v11 != 219)
      {
        if (v11 == 180)
        {
          if (v7)
          {
            if (*(_WORD *)(v6 + 16) != 71)
            {
              int v31 = *(unsigned __int8 *)(v6 + 18);
              long long v32 = (swift::Demangle::__runtime::Node **)v6;
              if ((v31 - 1) >= 2)
              {
                if (v31 != 5 || !*(_DWORD *)(v6 + 8))
                {
LABEL_142:
                  uint64_t v48 = 0;
                  goto LABEL_143;
                }
                goto LABEL_140;
              }
              goto LABEL_141;
            }
            goto LABEL_86;
          }
          goto LABEL_87;
        }
        goto LABEL_66;
      }
LABEL_29:
      Node = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(v54, 167);
      long long v13 = Node;
      int v14 = *(unsigned __int8 *)(v8 + 18);
      uint64_t v15 = v8;
      if (v14 != 2)
      {
        if (v14 != 5 || *(_DWORD *)(v8 + 8) < 2u) {
          goto LABEL_93;
        }
        uint64_t v15 = *(void *)v8;
      }
      uint64_t v16 = *(swift::Demangle::__runtime::Node **)(v15 + 8);
      if (!v16 || *((_WORD *)v16 + 8) != 101) {
        goto LABEL_93;
      }
      swift::Demangle::__runtime::Node::addChild(Node, v16, (swift::Demangle::__runtime::NodeFactory *)v54);
      uint64_t v17 = (uint64_t)v13;
      if (!v7)
      {
LABEL_56:
        int v25 = *(unsigned __int8 *)(v8 + 18);
        if ((v25 - 1) >= 2)
        {
          if (v25 != 5 || !*(_DWORD *)(v8 + 8)) {
            goto LABEL_89;
          }
          uint64_t v8 = *(void *)v8;
        }
        goto LABEL_16;
      }
      if (*(_WORD *)(v6 + 16) == 71)
      {
        swift::Demangle::__runtime::Node::addChild((swift::Demangle::__runtime::Node *)v6, v13, (swift::Demangle::__runtime::NodeFactory *)v54);
LABEL_55:
        uint64_t v17 = v7;
        goto LABEL_56;
      }
      int v18 = *(unsigned __int8 *)(v6 + 18);
      uint64_t v19 = (swift::Demangle::__runtime::Node **)v6;
      if ((v18 - 1) >= 2)
      {
        if (v18 != 5 || !*(_DWORD *)(v6 + 8))
        {
          uint64_t v20 = 0;
          goto LABEL_54;
        }
        uint64_t v19 = *(swift::Demangle::__runtime::Node ***)v6;
      }
      uint64_t v20 = *v19;
LABEL_54:
      swift::Demangle::__runtime::Node::addChild((swift::Demangle::__runtime::Node *)v6, v20, (swift::Demangle::__runtime::NodeFactory *)v54);
      swift::Demangle::__runtime::Node::replaceChild(v6, 0, (uint64_t)v13);
      goto LABEL_55;
    }
    if (*(unsigned __int16 *)(v8 + 16) <= 0x46u)
    {
      if (v11 != 24 && v11 != 61) {
        goto LABEL_66;
      }
      goto LABEL_29;
    }
    if (v11 != 71) {
      break;
    }
    long long v21 = (swift::Demangle::__runtime::Node *)swift::Demangle::__runtime::NodeFactory::createNode(v54, 71);
    long long v13 = v21;
    int v22 = *(unsigned __int8 *)(v8 + 18);
    BOOL v23 = (swift::Demangle::__runtime::Node **)v8;
    if ((v22 - 1) >= 2)
    {
      if (v22 != 5 || !*(_DWORD *)(v8 + 8)) {
        goto LABEL_93;
      }
      BOOL v23 = *(swift::Demangle::__runtime::Node ***)v8;
    }
    BOOL v24 = *v23;
    if (!*v23 || *((_WORD *)v24 + 8) != 153) {
      goto LABEL_93;
    }
    swift::Demangle::__runtime::Node::addChild(v21, v24, (swift::Demangle::__runtime::NodeFactory *)v54);
    uint64_t v17 = (uint64_t)v13;
    if (!v7) {
      goto LABEL_74;
    }
    if (*(_WORD *)(v6 + 16) != 71)
    {
      int v26 = *(unsigned __int8 *)(v6 + 18);
      long long v27 = (swift::Demangle::__runtime::Node **)v6;
      if ((v26 - 1) < 2) {
        goto LABEL_64;
      }
      if (v26 == 5 && *(_DWORD *)(v6 + 8))
      {
        long long v27 = *(swift::Demangle::__runtime::Node ***)v6;
LABEL_64:
        long long v28 = *v27;
      }
      else
      {
        long long v28 = 0;
      }
      swift::Demangle::__runtime::Node::addChild((swift::Demangle::__runtime::Node *)v6, v28, (swift::Demangle::__runtime::NodeFactory *)v54);
      swift::Demangle::__runtime::Node::replaceChild(v6, 0, (uint64_t)v13);
      goto LABEL_73;
    }
    swift::Demangle::__runtime::Node::addChild((swift::Demangle::__runtime::Node *)v6, v13, (swift::Demangle::__runtime::NodeFactory *)v54);
LABEL_73:
    uint64_t v17 = v7;
LABEL_74:
    int v30 = *(unsigned __int8 *)(v8 + 18);
    if (v30 != 2)
    {
      if (v30 != 5 || *(_DWORD *)(v8 + 8) < 2u) {
        goto LABEL_89;
      }
      uint64_t v8 = *(void *)v8;
    }
    v8 += 8;
LABEL_16:
    uint64_t v8 = *(void *)v8;
    uint64_t v6 = (uint64_t)v13;
    uint64_t v7 = v17;
    if (!v8) {
      goto LABEL_89;
    }
  }
  if (v11 == 153)
  {
    if (v7)
    {
      if (*(_WORD *)(v6 + 16) != 71)
      {
        int v47 = *(unsigned __int8 *)(v6 + 18);
        long long v32 = (swift::Demangle::__runtime::Node **)v6;
        if ((v47 - 1) >= 2)
        {
          if (v47 != 5 || !*(_DWORD *)(v6 + 8)) {
            goto LABEL_142;
          }
LABEL_140:
          long long v32 = *(swift::Demangle::__runtime::Node ***)v6;
        }
LABEL_141:
        uint64_t v48 = *v32;
LABEL_143:
        swift::Demangle::__runtime::Node::addChild((swift::Demangle::__runtime::Node *)v6, v48, (swift::Demangle::__runtime::NodeFactory *)v54);
        swift::Demangle::__runtime::Node::replaceChild(v6, 0, v8);
        goto LABEL_90;
      }
LABEL_86:
      swift::Demangle::__runtime::Node::addChild((swift::Demangle::__runtime::Node *)v6, (swift::Demangle::__runtime::Node *)v8, (swift::Demangle::__runtime::NodeFactory *)v54);
      goto LABEL_90;
    }
LABEL_87:
    uint64_t v7 = v8;
    goto LABEL_90;
  }
LABEL_66:
  int v29 = *(unsigned __int8 *)(v8 + 18);
  if ((v29 - 1) < 2)
  {
LABEL_70:
    uint64_t v17 = v7;
    long long v13 = (swift::Demangle::__runtime::Node *)v6;
    goto LABEL_16;
  }
  if (v29 == 5 && *(_DWORD *)(v8 + 8))
  {
    uint64_t v8 = *(void *)v8;
    goto LABEL_70;
  }
  uint64_t v17 = v7;
LABEL_89:
  uint64_t v7 = v17;
  if (!v17) {
    goto LABEL_93;
  }
LABEL_90:
  swift::Demangle::__runtime::mangleNode(v7);
  if (v51)
  {
    if (prespecializedLoggingEnabled) {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Failed to build demangling for simplified node %p.\n\n");
    }
    goto LABEL_95;
  }
  unint64_t v33 = 0xC6A4A7935BD1E995 * v53;
  unint64_t v34 = v53 & 0xFFFFFFFFFFFFFFF8;
  if ((v53 & 0xFFFFFFFFFFFFFFF8) != 0)
  {
    unint64_t v35 = (unsigned __int8 *)&v52[v34];
    char v36 = v53;
    char v37 = v52;
    do
    {
      uint64_t v38 = *(void *)v37;
      v37 += 8;
      v36 -= 8;
      unint64_t v33 = 0xC6A4A7935BD1E995
          * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v38) ^ ((0xC6A4A7935BD1E995 * v38) >> 47))) ^ v33);
      v34 -= 8;
    }
    while (v34);
  }
  else
  {
    unint64_t v35 = (unsigned __int8 *)v52;
    char v36 = v53;
  }
  switch(v36 & 7)
  {
    case 1:
      goto LABEL_114;
    case 2:
      goto LABEL_113;
    case 3:
      goto LABEL_112;
    case 4:
      goto LABEL_111;
    case 5:
      goto LABEL_110;
    case 6:
      goto LABEL_109;
    case 7:
      v33 ^= (unint64_t)v35[6] << 48;
LABEL_109:
      v33 ^= (unint64_t)v35[5] << 40;
LABEL_110:
      v33 ^= (unint64_t)v35[4] << 32;
LABEL_111:
      v33 ^= (unint64_t)v35[3] << 24;
LABEL_112:
      v33 ^= (unint64_t)v35[2] << 16;
LABEL_113:
      v33 ^= (unint64_t)v35[1] << 8;
LABEL_114:
      v33 ^= *v35;
      break;
    default:
      break;
  }
  int v39 = 0;
  unint64_t v40 = 0;
  unint64_t v41 = 0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v33) ^ ((0xC6A4A7935BD1E995 * v33) >> 47));
  uint64_t v42 = v5 + 1;
  unint64_t v43 = (v41 ^ (v41 >> 47)) % *v5;
  do
  {
    long long v44 = (char *)v42[v43];
    if (!v44
      || (++v40, _dyld_is_preoptimized_objc_image_loaded())
      && (++v39, (swift::_contextDescriptorMatchesMangling(v44, v2) & 1) != 0))
    {
      uint64_t v45 = (const void **)&v42[v43];
      goto LABEL_126;
    }
    if (v43 + 1 < *v5) {
      ++v43;
    }
    else {
      unint64_t v43 = 0;
    }
  }
  while (v40 <= *v5);
  uint64_t v45 = 0;
LABEL_126:
  if (prespecializedLoggingEnabled)
  {
    uint64_t v49 = (const void *)swift::PrebuiltAuxDataImplicitStringMap<void const*,unsigned short>::find<swift::getLibPrespecializedTypeDescriptor(swift::Demangle::__runtime::Node *)::$_2,swift::getLibPrespecializedTypeDescriptor(swift::Demangle::__runtime::Node *)::$_3>(v5, (unsigned __int8 *)v52, v53);
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Hash table lookup checked %u loaded entries, %u total entries, starting data pointer %p, starting auxiliary pointer %p.\n", v39, v40, v49, v50);
    if (!v45) {
      goto LABEL_150;
    }
LABEL_128:
    char v46 = *v45;
    if (v46)
    {
      if (prespecializedLoggingEnabled) {
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Found descriptor %p for key '%.*s'.\n", v46, v53, v52);
      }
      uint64_t v9 = 0;
    }
    else
    {
      if (prespecializedLoggingEnabled) {
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Did not find descriptor for key '%.*s'.\n", v53, v52);
      }
      if (*(_DWORD *)(v3 + 4) >= 3u && (*(unsigned char *)(v3 + 32) & 4) != 0) {
        goto LABEL_95;
      }
      uint64_t v9 = 1;
    }
  }
  else
  {
    if (v45) {
      goto LABEL_128;
    }
LABEL_150:
    if (prespecializedLoggingEnabled) {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Descriptor table lookup of '%.*s' returned NULL pointer to descriptor pointer.\n");
    }
LABEL_95:
    uint64_t v9 = 2;
  }
  v54[0] = &unk_1ECA07790;
  if (v92 == v91)
  {
    (*(void (**)(void *))(v91[0] + 32))(v91);
  }
  else if (v92)
  {
    (*(void (**)(void))(*v92 + 40))();
  }
  v54[0] = &unk_1ECA07768;
  swift::Demangle::__runtime::NodeFactory::freeSlabs((void *)v55);
  if (v56) {
    *(unsigned char *)(v56 + 48) = 0;
  }
  return v9;
}

uint64_t swift::PrebuiltAuxDataImplicitStringMap<void const*,unsigned short>::find<swift::getLibPrespecializedTypeDescriptor(swift::Demangle::__runtime::Node *)::$_2,swift::getLibPrespecializedTypeDescriptor(swift::Demangle::__runtime::Node *)::$_3>(void *a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v3 = 0xC6A4A7935BD1E995 * a3;
  unint64_t v4 = a3 & 0xFFFFFFFFFFFFFFF8;
  if ((a3 & 0xFFFFFFFFFFFFFFF8) != 0)
  {
    unsigned int v5 = &a2[v4];
    do
    {
      uint64_t v6 = *(void *)a2;
      a2 += 8;
      LOBYTE(a3) = a3 - 8;
      unint64_t v3 = 0xC6A4A7935BD1E995
         * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))) ^ v3);
      v4 -= 8;
    }
    while (v4);
    a2 = v5;
  }
  switch(a3 & 7)
  {
    case 1:
      goto LABEL_12;
    case 2:
      goto LABEL_11;
    case 3:
      goto LABEL_10;
    case 4:
      goto LABEL_9;
    case 5:
      goto LABEL_8;
    case 6:
      goto LABEL_7;
    case 7:
      v3 ^= (unint64_t)a2[6] << 48;
LABEL_7:
      v3 ^= (unint64_t)a2[5] << 40;
LABEL_8:
      v3 ^= (unint64_t)a2[4] << 32;
LABEL_9:
      v3 ^= (unint64_t)a2[3] << 24;
LABEL_10:
      v3 ^= (unint64_t)a2[2] << 16;
LABEL_11:
      v3 ^= (unint64_t)a2[1] << 8;
LABEL_12:
      v3 ^= *a2;
      break;
    default:
      break;
  }
  unint64_t v7 = 0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v3) ^ ((0xC6A4A7935BD1E995 * v3) >> 47));
  return (uint64_t)&a1[(v7 ^ (v7 >> 47)) % *a1 + 1];
}

uint64_t swift::Demangle::__runtime::StackAllocatedDemangler<4096ul>::~StackAllocatedDemangler(uint64_t a1)
{
  *(void *)a1 = &unk_1ECA07790;
  uint64_t v2 = a1 + 544;
  uint64_t v3 = *(void *)(a1 + 568);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  *(void *)a1 = &unk_1ECA07768;
  swift::Demangle::__runtime::NodeFactory::freeSlabs(*(void **)(a1 + 24));
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4) {
    *(unsigned char *)(v4 + 48) = 0;
  }
  return a1;
}

void _swift_validatePrespecializedMetadata(_DWORD *a1, _DWORD *a2)
{
  if (a1) {
    *a1 = 0;
  }
  if (a2) {
    *a2 = 0;
  }
  if (qword_1EB1F8878 != -1) {
    dispatch_once_f(&qword_1EB1F8878, &LibPrespecialized, (dispatch_function_t)swift::Lazy<LibPrespecializedState>::defaultInitCallback);
  }
  uint64_t v4 = LibPrespecialized;
  if (LibPrespecialized)
  {
    atomic_store(4u, (unsigned int *)&unk_1EB1F8848);
    unsigned int v5 = *(uint64_t **)(v4 + 8);
    uint64_t v6 = *v5;
    if (*v5)
    {
      unint64_t v7 = v5 + 2;
      uint64_t v8 = (FILE **)MEMORY[0x1E4F143C8];
      do
      {
        uint64_t v9 = (char *)*(v7 - 1);
        if (v9 && *v7)
        {
          if (a1) {
            ++*a1;
          }
          if (*v9 == 36) {
            long long v10 = v9 + 1;
          }
          else {
            long long v10 = v9;
          }
          size_t v11 = strlen(v10);
          int v18 = 0;
          uint64_t v16 = 0;
          swift_getTypeByMangledName(0, (unsigned __int8 *)v10, v11, 0, v17, v15, (uint64_t)v19);
          if (v16 == v15)
          {
            (*(void (**)(void *))(v15[0] + 32))(v15);
          }
          else if (v16)
          {
            (*(void (**)(void))(*v16 + 40))();
          }
          if (v18 == v17)
          {
            (*(void (**)(void *))(v17[0] + 32))(v17);
          }
          else if (v18)
          {
            (*(void (**)(void))(*v18 + 40))();
          }
          int v12 = v20;
          if (v20 == 1)
          {
            fprintf(*v8, "Prespecializations library validation: unable to build metadata for mangled name '%s'\n", v10);
            if (a2) {
              ++*a2;
            }
            int v12 = v20;
          }
          if (v12) {
            uint64_t v13 = 0;
          }
          else {
            uint64_t v13 = v19[0];
          }
          char v14 = swift::compareGenericMetadata(v13, *v7);
          if (a2 && (v14 & 1) == 0) {
            ++*a2;
          }
          if (v20 == 1) {
            ((void (*)(void, uint64_t, void))v19[1])(v19[0], 3, 0);
          }
        }
        v7 += 2;
        --v6;
      }
      while (v6);
    }
  }
}

void __swift::__runtime::llvm::function_ref<swift::Demangle::__runtime::Node * ()(swift::Demangle::__runtime::SymbolicReferenceKind,void const*)>::callback_fn<getMetadataFromNameKeyedMap(LibPrespecializedState const&,swift::TargetTypeContextDescriptor<swift::InProcess> const*,void const* const*)::$_0>(uint64_t a1, uint64_t a2, const char *a3, char *a4)
{
}

unint64_t swift::PrebuiltStringMapBase::findIndex<swift::PrebuiltStringMap<char const*,swift::TargetMetadata<swift::InProcess> *,&swift::LibPrespecializedData<swift::InProcess>::stringIsNull>::find(char const*,unsigned long)::{lambda(unsigned long)#1}>(unint64_t *a1, unsigned __int8 *a2, uint64_t a3, void *a4)
{
  unint64_t v4 = 0xC6A4A7935BD1E995 * a3;
  unint64_t v5 = a3 & 0xFFFFFFFFFFFFFFF8;
  if ((a3 & 0xFFFFFFFFFFFFFFF8) != 0)
  {
    uint64_t v6 = &a2[v5];
    do
    {
      uint64_t v7 = *(void *)a2;
      a2 += 8;
      LOBYTE(a3) = a3 - 8;
      unint64_t v4 = 0xC6A4A7935BD1E995
         * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v7) ^ ((0xC6A4A7935BD1E995 * v7) >> 47))) ^ v4);
      v5 -= 8;
    }
    while (v5);
    a2 = v6;
  }
  switch(a3 & 7)
  {
    case 1:
      goto LABEL_12;
    case 2:
      goto LABEL_11;
    case 3:
      goto LABEL_10;
    case 4:
      goto LABEL_9;
    case 5:
      goto LABEL_8;
    case 6:
      goto LABEL_7;
    case 7:
      v4 ^= (unint64_t)a2[6] << 48;
LABEL_7:
      v4 ^= (unint64_t)a2[5] << 40;
LABEL_8:
      v4 ^= (unint64_t)a2[4] << 32;
LABEL_9:
      v4 ^= (unint64_t)a2[3] << 24;
LABEL_10:
      v4 ^= (unint64_t)a2[2] << 16;
LABEL_11:
      v4 ^= (unint64_t)a2[1] << 8;
LABEL_12:
      v4 ^= *a2;
      break;
    default:
      break;
  }
  uint64_t v8 = 0;
  unint64_t v9 = 0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v4) ^ ((0xC6A4A7935BD1E995 * v4) >> 47));
  unint64_t v10 = *a1;
  unint64_t v11 = (v9 ^ (v9 >> 47)) % *a1;
  int v12 = (const char **)a4[1];
  uint64_t v13 = *a4 + 8;
  char v14 = (size_t *)a4[2];
  while (1)
  {
    uint64_t v15 = *(void *)(v13 + 16 * v11);
    if (!v15) {
      break;
    }
    size_t v16 = *v14;
    if (!strncmp(*(const char **)(v13 + 16 * v11), *v12, *v14) && !*(unsigned char *)(v15 + v16)) {
      break;
    }
    if (v11 + 1 < v10) {
      ++v11;
    }
    else {
      unint64_t v11 = 0;
    }
    if (++v8 > v10) {
      return 0;
    }
  }
  return v11;
}

void LibPrespecializedState::LibPrespecializedState(LibPrespecializedState *this)
{
  *((_DWORD *)this + 2) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  if (swift::runtime::environment::initializeToken != -1) {
    dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
  }
  prespecializedLoggingEnabled = swift::runtime::environment::SWIFT_DEBUG_ENABLE_LIB_PRESPECIALIZED_LOGGING_variable;
  *(void *)this = LibPrespecializedState::findLibPrespecialized(this);
  shared_cache_range = (swift::MetadataAllocator *)_dyld_get_shared_cache_range();
  *((void *)this + 2) = shared_cache_range;
  *((void *)this + 3) = shared_cache_range;
  uint64_t v3 = (char *)swift::MetadataAllocator::InitialPoolLocation(shared_cache_range);
  *((void *)this + 4) = v3;
  *((void *)this + 5) = &v3[v4];
  if (!*((_DWORD *)this + 2)) {
    *((_DWORD *)this + 2) = LibPrespecializedState::computeMapConfiguration((uint64_t)this, *(void *)this);
  }
  uint64_t v5 = *(void *)this;
  if (*(void *)this)
  {
    unint64_t v6 = *(_DWORD *)(v5 + 4) >= 3u ? *(void *)(v5 + 32) & 2 : 0;
    *((unsigned char *)this + 48) = v6 >> 1;
    if (prespecializedLoggingEnabled)
    {
      if (v6) {
        uint64_t v7 = "true";
      }
      else {
        uint64_t v7 = "false";
      }
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Setting descriptorMapEnabled=%s from the option flags.\n", v7);
    }
  }
  if (swift::runtime::environment::initializeToken != -1) {
    dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
  }
  if (swift::runtime::environment::SWIFT_DEBUG_ENABLE_LIB_PRESPECIALIZED_DESCRIPTOR_LOOKUP_isSet_variable)
  {
    *((unsigned char *)this + 48) = swift::runtime::environment::SWIFT_DEBUG_ENABLE_LIB_PRESPECIALIZED_DESCRIPTOR_LOOKUP_variable;
    if (prespecializedLoggingEnabled) {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Setting descriptorMapEnabled=%s from SWIFT_DEBUG_ENABLE_LIB_PRESPECIALIZED_DESCRIPTOR_LOOKUP.\n");
    }
  }
  else if (_os_feature_enabled_simple_impl())
  {
    *((unsigned char *)this + 48) ^= 1u;
    if (prespecializedLoggingEnabled) {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Toggling descriptorMapEnabled to %s togglePrespecializationDescriptorMap is set.\n");
    }
  }
}

_DWORD *LibPrespecializedState::findLibPrespecialized(LibPrespecializedState *this)
{
  if (swift::runtime::environment::initializeToken != -1) {
    dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
  }
  if (swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_PATH_variable
    && *swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_PATH_variable)
  {
    uint64_t v2 = dlopen(swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_PATH_variable, 17);
    if (!v2)
    {
      uint64_t v5 = dlerror();
      swift::warning(0, "Failed to load prespecializations library: %s\n", v6, v7, v5);
      return 0;
    }
    swift_prespecialized_data = dlsym(v2, "_swift_prespecializationsData");
    if (!prespecializedLoggingEnabled) {
      goto LABEL_15;
    }
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Loaded custom library from %s, found dataPtr %p\n");
    goto LABEL_14;
  }
  swift_prespecialized_data = (_DWORD *)_dyld_get_swift_prespecialized_data();
  if (prespecializedLoggingEnabled)
  {
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Got dataPtr %p from _dyld_get_swift_prespecialized_data\n", swift_prespecialized_data);
    if (!dyld_shared_cache_some_image_overridden()) {
      goto LABEL_14;
    }
  }
  else if (!dyld_shared_cache_some_image_overridden())
  {
    goto LABEL_14;
  }
  atomic_store(4u, (unsigned int *)this + 2);
  if (!prespecializedLoggingEnabled) {
    goto LABEL_15;
  }
  uint64_t v4 = (FILE *)*MEMORY[0x1E4F143C8];
  dyld_shared_cache_some_image_overridden();
  fprintf(v4, "Prespecializations library: Disabling prespecialized metadata, dyld_shared_cache_some_image_overridden = %d\n");
LABEL_14:
  if (prespecializedLoggingEnabled)
  {
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Returning data pointer %p\n", swift_prespecialized_data);
    if (!swift_prespecialized_data) {
      return swift_prespecialized_data;
    }
    goto LABEL_16;
  }
LABEL_15:
  if (!swift_prespecialized_data) {
    return swift_prespecialized_data;
  }
LABEL_16:
  if (*swift_prespecialized_data != 1)
  {
    if (prespecializedLoggingEnabled)
    {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Unknown major version %u, disabling\n");
      return 0;
    }
    return 0;
  }
  uint64_t v8 = (const char **)MEMORY[0x1E4F143B0];
  if (*MEMORY[0x1E4F143B0])
  {
    if (swift::runtime::environment::initializeToken != -1) {
      dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
    }
    unint64_t v9 = (const char *)swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_ENABLED_PROCESSES_variable;
    if (swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_ENABLED_PROCESSES_variable
      && *swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_ENABLED_PROCESSES_variable)
    {
      unint64_t v10 = *v8;
      size_t v11 = strlen(*v8);
      int v12 = strchr(swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_ENABLED_PROCESSES_variable, 58);
      if (v12)
      {
        uint64_t v13 = v12;
        while (v13 - v9 != v11 || strncmp(v9, v10, v11))
        {
          unint64_t v9 = v13 + 1;
          uint64_t v13 = strchr(v13 + 1, 58);
          if (!v13) {
            goto LABEL_30;
          }
        }
        goto LABEL_48;
      }
LABEL_30:
      if (!strcmp(v10, v9))
      {
LABEL_48:
        if (!prespecializedLoggingEnabled) {
          return swift_prespecialized_data;
        }
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Found %s in SWIFT_DEBUG_LIB_PRESPECIALIZED_ENABLED_PROCESSES, enabling\n", v10);
        goto LABEL_46;
      }
    }
    char v14 = (const char *)swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_DISABLED_PROCESSES_variable;
    if (swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_DISABLED_PROCESSES_variable
      && *swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_DISABLED_PROCESSES_variable)
    {
      uint64_t v15 = *v8;
      size_t v16 = strlen(*v8);
      uint64_t v17 = strchr(swift::runtime::environment::SWIFT_DEBUG_LIB_PRESPECIALIZED_DISABLED_PROCESSES_variable, 58);
      if (v17)
      {
        int v18 = v17;
        while (v18 - v14 != v16 || strncmp(v14, v15, v16))
        {
          char v14 = v18 + 1;
          int v18 = strchr(v18 + 1, 58);
          if (!v18) {
            goto LABEL_39;
          }
        }
LABEL_50:
        if (prespecializedLoggingEnabled)
        {
          fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Found %s in SWIFT_DEBUG_LIB_PRESPECIALIZED_DISABLED_PROCESSES, disabling\n");
          return 0;
        }
        return 0;
      }
LABEL_39:
      if (!strcmp(v15, v14)) {
        goto LABEL_50;
      }
    }
    if (swift_prespecialized_data[1] >= 2u)
    {
      uint64_t v19 = (const char **)*((void *)swift_prespecialized_data + 2);
      if (v19)
      {
        unsigned __int16 v20 = *v19;
        if (*v19)
        {
          long long v21 = *v8;
          int v22 = v19 + 1;
          while (strcmp(v20, v21))
          {
            BOOL v23 = *v22++;
            unsigned __int16 v20 = v23;
            if (!v23) {
              goto LABEL_46;
            }
          }
          if (prespecializedLoggingEnabled)
          {
            fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Found %s in disabled processes list, disabling\n");
            return 0;
          }
          return 0;
        }
      }
    }
  }
LABEL_46:
  if (prespecializedLoggingEnabled)
  {
    int v25 = (FILE **)MEMORY[0x1E4F143C8];
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Returning data %p, major version %u minor %u\n", swift_prespecialized_data, *swift_prespecialized_data, swift_prespecialized_data[1]);
    if (prespecializedLoggingEnabled)
    {
      uint64_t v26 = swift_prespecialized_data[1] >= 3u ? *((void *)swift_prespecialized_data + 4) : 0;
      fprintf(*v25, "Prespecializations library:   optionFlags=%#zx\n", v26);
      if (prespecializedLoggingEnabled)
      {
        fprintf(*v25, "Prespecializations library:   metadataMap=%p\n", *((const void **)swift_prespecialized_data + 1));
        if (prespecializedLoggingEnabled)
        {
          long long v27 = swift_prespecialized_data[1] >= 2u ? (const void *)*((void *)swift_prespecialized_data + 2) : 0;
          fprintf(*v25, "Prespecializations library:   disabledProcessTable=%p\n", v27);
          if (prespecializedLoggingEnabled)
          {
            long long v28 = swift_prespecialized_data[1] >= 3u ? (const void *)*((void *)swift_prespecialized_data + 3) : 0;
            fprintf(*v25, "Prespecializations library:   pointerKeyedMetadataMap=%p\n", v28);
            if (prespecializedLoggingEnabled)
            {
              if (swift_prespecialized_data[1] >= 4u) {
                int v29 = (const void *)*((void *)swift_prespecialized_data + 5);
              }
              else {
                int v29 = 0;
              }
              fprintf(*v25, "Prespecializations library:   descriptorMap=%p\n", v29);
            }
          }
        }
      }
    }
  }
  return swift_prespecialized_data;
}

uint64_t LibPrespecializedState::computeMapConfiguration(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 4;
  }
  if (swift::runtime::environment::initializeToken != -1) {
    dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
  }
  if (!swift::runtime::environment::SWIFT_DEBUG_ENABLE_LIB_PRESPECIALIZED_METADATA_variable)
  {
    if (prespecializedLoggingEnabled)
    {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: %s\n");
      return 4;
    }
    return 4;
  }
  uint64_t v4 = *(void *)(a2 + 8);
  unsigned int v5 = *(_DWORD *)(a2 + 4);
  if (v5 >= 3)
  {
    unint64_t v6 = *(void *)(a2 + 24);
    if (!(v4 | v6))
    {
LABEL_7:
      if (prespecializedLoggingEnabled)
      {
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: No prespecializations map available from data at %p, disabling.\n");
        return 4;
      }
      return 4;
    }
  }
  else
  {
    unint64_t v6 = 0;
    if (!v4) {
      goto LABEL_7;
    }
  }
  if (!v6)
  {
    if (prespecializedLoggingEnabled) {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Data at %p only contains name-keyed map.\n", (const void *)a2);
    }
    return 1;
  }
  if (v4)
  {
    if (v5 >= 3) {
      uint64_t v8 = *(void *)(a2 + 32) & 1;
    }
    else {
      uint64_t v8 = 0;
    }
    if (_os_feature_enabled_simple_impl()) {
      BOOL v9 = v8 == 0;
    }
    else {
      BOOL v9 = v8 != 0;
    }
    if (prespecializedLoggingEnabled)
    {
      unint64_t v10 = "name";
      if (v9) {
        unint64_t v10 = "pointer";
      }
      int v12 = (const void *)a2;
      BOOL v11 = v9;
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Data at %p contains both maps. Using %s keyed map.\n", v12, v10);
      if (v11) {
        goto LABEL_28;
      }
    }
    else if (v9)
    {
LABEL_28:
      if (*(void *)(a1 + 16) > v6) {
        return 3;
      }
      if (*(void *)(a1 + 24) > v6) {
        return 2;
      }
      return 3;
    }
    return 1;
  }
  if (prespecializedLoggingEnabled) {
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "Prespecializations library: Data at %p only contains pointer-keyed map.\n", (const void *)a2);
  }
  return 2;
}

void swift::Demangle::__runtime::StackAllocatedDemangler<4096ul>::~StackAllocatedDemangler(uint64_t a1)
{
  *(void *)a1 = &unk_1ECA07790;
  uint64_t v2 = a1 + 544;
  uint64_t v3 = *(void *)(a1 + 568);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  *(void *)a1 = &unk_1ECA07768;
  swift::Demangle::__runtime::NodeFactory::freeSlabs(*(void **)(a1 + 24));
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4) {
    *(unsigned char *)(v4 + 48) = 0;
  }

  JUMPOUT(0x1852FF000);
}

_WORD *swift::TargetSingletonMetadataInitialization<swift::InProcess>::allocate(uint64_t a1, _DWORD *a2)
{
  if (a2 && (*a2 & 0x1F) == 0x10 && (*a2 & 0x20000000) != 0)
  {
    uint64_t v4 = *(int *)(a1 + 4);
    if (v4) {
      unsigned int v5 = (int *)(v4 + a1 + 4);
    }
    else {
      unsigned int v5 = 0;
    }
    uint64_t v6 = *v5;
    uint64_t v7 = (uint64_t (*)(_DWORD *))((char *)v5 + v6);
    if (v6) {
      BOOL v8 = v7 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (v8 || !v7) {
      return _swift_relocateClassMetadata((uint64_t)a2, v5);
    }
    else {
      return (_WORD *)v7(a2);
    }
  }
  else
  {
    uint64_t v10 = *(int *)(a1 + 4);
    uint64_t result = (_WORD *)(v10 + a1 + 4);
    if (v10) {
      BOOL v11 = result;
    }
    else {
      BOOL v11 = 0;
    }
    if (*(void *)v11 > 0x7FFuLL || *(void *)v11 == 0)
    {
      if ((*((void *)v11 + 4) & 3) == 1) {
        *((void *)v11 + 4) ^= 3uLL;
      }
      if ((v11[20] & 2) != 0) {
        uint64_t v13 = value witness table for Builtin.NativeObject;
      }
      else {
        uint64_t v13 = (uint64_t (**)())&value witness table for Builtin.UnknownObject;
      }
      *((void *)v11 - 1) = v13;
    }
  }
  return result;
}

_WORD *_swift_relocateClassMetadata(uint64_t a1, int *a2)
{
  if ((*(_DWORD *)a1 & 0x20000000) != 0)
  {
    uint64_t v7 = *(int *)(a1 + 24);
    if (v7) {
      BOOL v8 = (atomic_ullong *)(v7 + a1 + 24);
    }
    else {
      BOOL v8 = 0;
    }
    uint64_t explicit = atomic_load_explicit(v8, memory_order_acquire);
    if (explicit)
    {
      unint64_t v10 = v8[1];
    }
    else
    {
      unint64_t v10 = computeMetadataBoundsFromSuperclass((unsigned char *)a1, (uint64_t)v8);
      uint64_t explicit = v11;
    }
  }
  else
  {
    if ((*(_DWORD *)a1 & 0x10000000) != 0)
    {
      int v5 = 0;
      uint64_t v6 = 24;
    }
    else
    {
      int v5 = *(_DWORD *)(a1 + 28);
      uint64_t v6 = 32;
    }
    uint64_t explicit = 8 * (v5 - *(_DWORD *)(a1 + v6));
    unint64_t v10 = *(void *)(a1 + 24);
  }
  size_t v12 = 8 * (v10 + HIDWORD(v10));
  int v13 = 8 * v10;
  char v14 = &swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&getResilientMetadataAllocator(void)::allocator, v12, 8)[4 * v10];
  bzero((char *)v14 + explicit, 8 * *(unsigned int *)(a1 + 32));
  uint64_t v15 = 0;
  uint64_t v16 = a2[1];
  if (v16 && (int *)((char *)a2 + v16 + 4)) {
    uint64_t v15 = (char *)a2 + v16 + 4;
  }
  *((void *)v14 - 2) = v15;
  int v17 = a2[3];
  if ((v17 & 2) != 0) {
    int v18 = value witness table for Builtin.NativeObject;
  }
  else {
    int v18 = (uint64_t (**)())&value witness table for Builtin.UnknownObject;
  }
  uint64_t v19 = a2[4];
  *((void *)v14 - 1) = v18;
  uint64_t v20 = a2[5];
  if (v20) {
    long long v21 = (char *)a2 + v20 + 20;
  }
  else {
    long long v21 = 0;
  }
  *(void *)char v14 = v21;
  *((void *)v14 + 1) = 0;
  *((void *)v14 + 2) = MEMORY[0x1E4FBA8C0];
  *((void *)v14 + 3) = 0;
  if (v19) {
    uint64_t v22 = ((unint64_t)a2 + v19 + 16) | 2;
  }
  else {
    uint64_t v22 = 2;
  }
  *((void *)v14 + 4) = v22;
  *((_DWORD *)v14 + 1swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v17;
  *(void *)(v14 + 22) = 0;
  *((_DWORD *)v14 + 13) = 0;
  *((_DWORD *)v14 + 14) = v12;
  *((_DWORD *)v14 + 15) = v13;
  if (a1) {
    uint64_t v23 = a1;
  }
  else {
    uint64_t v23 = 0;
  }
  BOOL v24 = 0;
  *((void *)v14 + 8) = v23;
  uint64_t v27 = a2[2];
  uint64_t v26 = a2 + 2;
  uint64_t v25 = v27;
  if (v27)
  {
    long long v28 = (char *)v26 + v25;
    if (v28) {
      BOOL v24 = v28;
    }
  }
  *((void *)v14 + 9) = v24;
  return v14;
}

uint64_t swift_allocateMetadataPack(uint64_t result, unint64_t a2)
{
  if ((result & 1) == 0)
  {
    uint64_t v82 = result;
    unint64_t v83 = a2;
    uint64_t explicit = (void *)atomic_load_explicit(&qword_1EB2089A8, memory_order_acquire);
    if (explicit && v83 == *explicit)
    {
      if (!v83) {
        return (unint64_t)(explicit + 1) | 1;
      }
      uint64_t v3 = 0;
      unsigned int v4 = 1;
      while (*(void *)(v82 + 8 * v3) == explicit[v3 + 1])
      {
        uint64_t v3 = v4++;
        if (v83 == v3) {
          return (unint64_t)(explicit + 1) | 1;
        }
      }
    }
    atomic_fetch_add_explicit(&MetadataPacks, 1u, memory_order_acquire);
    do
    {
      unint64_t v5 = atomic_load_explicit(&qword_1EB208988, memory_order_acquire);
      unint64_t v6 = atomic_load_explicit(&qword_1EB208990, memory_order_acquire);
      unint64_t v7 = atomic_load_explicit(&dword_1EB208984, memory_order_acquire);
    }
    while (v5 != atomic_load_explicit(&qword_1EB208988, memory_order_acquire));
    if (v5) {
      BOOL v8 = v6 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8 && v7 != 0)
    {
      if (v10)
      {
        qword_1EB2089A8 = *v10;
        uint64_t explicit = (void *)*v10;
        atomic_fetch_add_explicit(&MetadataPacks, 0xFFFFFFFF, memory_order_release);
        return (unint64_t)(explicit + 1) | 1;
      }
    }
    atomic_fetch_add_explicit(&MetadataPacks, 0xFFFFFFFF, memory_order_release);
    uint64_t v11 = v82;
    unint64_t v12 = v83;
    v84[0] = v82;
    v84[1] = v83;
    os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB208998);
    uint64_t v13 = qword_1EB208990;
    uint64_t v14 = qword_1EB208990 & 3;
    BOOL v15 = v14 == 0;
    if ((qword_1EB208990 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
      BOOL v15 = 1;
    }
    BOOL v75 = v15;
    unint64_t v76 = qword_1EB208990 & 0xFFFFFFFFFFFFFFFCLL;
    if (v15) {
      int v16 = 4;
    }
    else {
      int v16 = *(unsigned __int8 *)(qword_1EB208990 & 0xFFFFFFFFFFFFFFFCLL);
    }
    unint64_t v17 = dword_1EB208984;
    int v18 = (_DWORD *)qword_1EB208988;
    if (qword_1EB208988) {
      uint64_t v19 = qword_1EB208988 + 8;
    }
    else {
      uint64_t v19 = 0;
    }
    if (v20)
    {
      uint64_t explicit = *v20;
      __dmb(0xBu);
      if (MetadataPacks)
      {
LABEL_114:
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB208998);
        qword_1EB2089A8 = (uint64_t)explicit;
        return (unint64_t)(explicit + 1) | 1;
      }
      uint64_t v22 = (void **)qword_1EB2089A0;
      if (qword_1EB2089A0)
      {
        do
        {
          uint64_t v23 = (void **)*v22;
          free(v22[1]);
          free(v22);
          uint64_t v22 = v23;
        }
        while (v23);
      }
LABEL_113:
      qword_1EB2089A0 = 0;
      goto LABEL_114;
    }
    uint64_t v79 = v19;
    unint64_t v80 = v13;
    __src = v18 + 2;
    uint64_t v24 = (v17 + 1);
    if ((1 << v16) / (unint64_t)((1 << v16) - v24) < 4)
    {
      unint64_t v29 = v80;
      unsigned int v30 = v21;
      if (v18) {
        goto LABEL_84;
      }
    }
    else
    {
      long long v73 = v18;
      unsigned int v25 = (v16 + 1);
      char v78 = v16;
      if (v25 >= 0x11) {
        unsigned int v26 = 4;
      }
      else {
        unsigned int v26 = 2;
      }
      if (v25 < 9) {
        size_t v27 = 1;
      }
      else {
        size_t v27 = v26;
      }
      unint64_t v28 = (unint64_t)malloc_type_calloc(2 << v16, v27, 0x4269077AuLL);
      if (!v28) {
        swift::hashable_support::findHashableBaseTypeOfHashableType();
      }
      unint64_t v71 = v12;
      uint64_t v72 = v11;
      unint64_t v69 = v17;
      uint64_t v70 = (v17 + 1);
      if (v27 != 1)
      {
        if (v27 == 4) {
          size_t v27 = 3;
        }
        else {
          size_t v27 = 2;
        }
      }
      unint64_t v29 = v27 | v28;
      *(unsigned char *)unint64_t v28 = v16 + 1;
      unint64_t v31 = v80;
      char v32 = v16;
      if (v16)
      {
        uint64_t v33 = ~(-2 << v16);
        unint64_t v34 = v80 & 3;
        unint64_t v35 = v76;
        if (!v14) {
          unint64_t v35 = 0;
        }
        unint64_t v81 = v35;
        int v36 = v29 & 3;
        if ((v29 & 3) != 0) {
          unint64_t v37 = v28 & 0xFFFFFFFFFFFFFFFCLL;
        }
        else {
          unint64_t v37 = 0;
        }
        uint64_t v38 = 1;
        unint64_t v77 = v29;
        while (2)
        {
          switch(v34)
          {
            case 0uLL:
              uint64_t v39 = (v31 >> (4 * v38)) & 0xF;
              if (!v39) {
                goto LABEL_55;
              }
              goto LABEL_64;
            case 1uLL:
              LODWORD(v39) = *(unsigned __int8 *)(v81 + v38);
              if (*(unsigned char *)(v81 + v38)) {
                goto LABEL_64;
              }
              goto LABEL_55;
            case 2uLL:
              LODWORD(v39) = *(unsigned __int16 *)(v81 + 2 * v38);
              if (!*(_WORD *)(v81 + 2 * v38)) {
                goto LABEL_55;
              }
              goto LABEL_64;
            case 3uLL:
              LODWORD(v39) = *(_DWORD *)(v81 + 4 * v38);
              if (!v39) {
                goto LABEL_55;
              }
LABEL_64:
              unint64_t v40 = *(void **)(v19 + 8 * (v39 - 1));
              unint64_t v85 = 0;
              if (*v40)
              {
                unint64_t v41 = v34;
                uint64_t v42 = 0;
                unint64_t v43 = v40 + 1;
                do
                {
                  unint64_t v44 = __swift::__runtime::llvm::hash_combine<__swift::__runtime::llvm::hash_code,swift::TargetMetadata<swift::InProcess> const*>(&v85, v43);
                  unint64_t v85 = v44;
                  ++v42;
                  ++v43;
                }
                while (v42 != *v40);
                uint64_t v19 = v79;
                unint64_t v31 = v80;
                unint64_t v34 = v41;
                unint64_t v29 = v77;
                char v32 = v78;
              }
              else
              {
                unint64_t v44 = 0;
              }
              while (1)
              {
                unint64_t v46 = v44 & v33;
                if ((v44 & v33) != 0)
                {
                  switch(v36)
                  {
                    case 1:
                      LODWORD(v45) = *(unsigned __int8 *)(v37 + v46);
                      break;
                    case 2:
                      LODWORD(v45) = *(unsigned __int16 *)(v37 + 2 * v46);
                      break;
                    case 3:
                      LODWORD(v45) = *(_DWORD *)(v37 + 4 * v46);
                      break;
                    default:
                      uint64_t v45 = (v29 >> (4 * v46)) & 0xF;
                      break;
                  }
                  if (!v45) {
                    break;
                  }
                }
                unint64_t v44 = v46 + 1;
              }
              if (v36 == 3)
              {
                *(_DWORD *)(v37 + 4 * v46) = v39;
              }
              else if (v36 == 2)
              {
                *(_WORD *)(v37 + 2 * v46) = v39;
              }
              else
              {
                *(unsigned char *)(v37 + v46) = v39;
              }
LABEL_55:
              if (!((unint64_t)++v38 >> v32)) {
                continue;
              }
              goto LABEL_81;
            default:
              JUMPOUT(0);
          }
        }
      }
LABEL_81:
      atomic_store(v29, (unint64_t *)&qword_1EB208990);
      if (!v75)
      {
        int v47 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
        *int v47 = qword_1EB2089A0;
        v47[1] = v76;
        qword_1EB2089A0 = (uint64_t)v47;
      }
      unint64_t v17 = v69;
      unint64_t v12 = v71;
      uint64_t v11 = v72;
      uint64_t v24 = v70;
      int v18 = v73;
      unsigned int v30 = v48;
      if (v73)
      {
LABEL_84:
        unint64_t v49 = (unint64_t)v18;
        if (v17 < *v18) {
          goto LABEL_91;
        }
      }
    }
    char v50 = v18;
    unint64_t v51 = v17 + (v17 >> 2);
    if (v51 <= v17 + 1) {
      unint64_t v51 = v17 + 1;
    }
    size_t v52 = malloc_good_size(8 * v51 + 8);
    uint64_t v53 = malloc_type_malloc(v52, 0x1000D770uLL);
    if (!v53) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    unint64_t v49 = (unint64_t)v53;
    _DWORD *v53 = (v52 + 0x7FFFFFFF8) >> 3;
    if (v50)
    {
      memcpy(v53 + 2, __src, 8 * v17);
      long long v54 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
      *long long v54 = qword_1EB2089A0;
      v54[1] = v50;
      qword_1EB2089A0 = (uint64_t)v54;
    }
    atomic_store(v49, (unint64_t *)&qword_1EB208988);
LABEL_91:
    unint64_t v55 = v49 + 8;
    LOWORD(v85) = 24;
    uint64_t v56 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v85, 8 * v12 + 8, 8);
    uint64_t explicit = v56;
    *(void *)uint64_t v56 = v12;
    if (!v12)
    {
LABEL_99:
      *(void *)(v55 + 8 * v17) = v56;
      atomic_store(v24, (unsigned int *)&dword_1EB208984);
      switch(v29 & 3)
      {
        case 1uLL:
          unint64_t v60 = v29 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v29 & 3) == 0) {
            unint64_t v60 = 0;
          }
          atomic_store(v24, (unsigned __int8 *)(v60 + v30));
          break;
        case 2uLL:
          unint64_t v61 = v29 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v29 & 3) == 0) {
            unint64_t v61 = 0;
          }
          atomic_store(v24, (unsigned __int16 *)(v61 + 2 * v30));
          break;
        case 3uLL:
          unint64_t v62 = v29 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v29 & 3) == 0) {
            unint64_t v62 = 0;
          }
          atomic_store(v24, (unsigned int *)(v62 + 4 * v30));
          break;
        default:
          atomic_store((v24 << (4 * v30)) | v29, (unint64_t *)&qword_1EB208990);
          break;
      }
      __dmb(0xBu);
      if (MetadataPacks) {
        goto LABEL_114;
      }
      long long v63 = (void **)qword_1EB2089A0;
      if (qword_1EB2089A0)
      {
        do
        {
          long long v64 = (void **)*v63;
          free(v63[1]);
          free(v63);
          long long v63 = v64;
        }
        while (v64);
      }
      goto LABEL_113;
    }
    if (v12 >= 0xE)
    {
      int v57 = 0;
      unint64_t v58 = 0;
      if (!v12 || (v12 - 1) >> 32) {
        goto LABEL_97;
      }
      if ((unint64_t)v56 - v11 + 8 >= 0x20)
      {
        unint64_t v58 = v12 & 0xFFFFFFFFFFFFFFFCLL;
        int v57 = v12 & 0xFFFFFFFC;
        long long v65 = (long long *)(v11 + 16);
        long long v66 = v56 + 12;
        unint64_t v67 = v12 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          long long v68 = *v65;
          *(v66 - 1) = *(v65 - 1);
          *long long v66 = v68;
          v65 += 2;
          v66 += 2;
          v67 -= 4;
        }
        while (v67);
        if (v12 == v58) {
          goto LABEL_99;
        }
        goto LABEL_97;
      }
    }
    unint64_t v58 = 0;
    int v57 = 0;
LABEL_97:
    unsigned int v59 = v57 + 1;
    do
    {
      *(void *)&v56[4 * v58 + 4] = *(void *)(v11 + 8 * v58);
      unint64_t v58 = v59++;
    }
    while (v12 > v58);
    goto LABEL_99;
  }
  return result;
}

uint64_t swift_allocateWitnessTablePack(uint64_t result, unint64_t a2)
{
  if ((result & 1) == 0)
  {
    uint64_t v82 = result;
    unint64_t v83 = a2;
    uint64_t explicit = (void *)atomic_load_explicit(&qword_1EB2089D8, memory_order_acquire);
    if (explicit && v83 == *explicit)
    {
      if (!v83) {
        return (unint64_t)(explicit + 1) | 1;
      }
      uint64_t v3 = 0;
      unsigned int v4 = 1;
      while (*(void *)(v82 + 8 * v3) == explicit[v3 + 1])
      {
        uint64_t v3 = v4++;
        if (v83 == v3) {
          return (unint64_t)(explicit + 1) | 1;
        }
      }
    }
    atomic_fetch_add_explicit(&WitnessTablePacks, 1u, memory_order_acquire);
    do
    {
      unint64_t v5 = atomic_load_explicit(&qword_1EB2089B8, memory_order_acquire);
      unint64_t v6 = atomic_load_explicit(&qword_1EB2089C0, memory_order_acquire);
      unint64_t v7 = atomic_load_explicit(&dword_1EB2089B4, memory_order_acquire);
    }
    while (v5 != atomic_load_explicit(&qword_1EB2089B8, memory_order_acquire));
    if (v5) {
      BOOL v8 = v6 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8 && v7 != 0)
    {
      if (v10)
      {
        qword_1EB2089D8 = *v10;
        uint64_t explicit = (void *)*v10;
        atomic_fetch_add_explicit(&WitnessTablePacks, 0xFFFFFFFF, memory_order_release);
        return (unint64_t)(explicit + 1) | 1;
      }
    }
    atomic_fetch_add_explicit(&WitnessTablePacks, 0xFFFFFFFF, memory_order_release);
    uint64_t v11 = v82;
    unint64_t v12 = v83;
    v84[0] = v82;
    v84[1] = v83;
    os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB2089C8);
    uint64_t v13 = qword_1EB2089C0;
    uint64_t v14 = qword_1EB2089C0 & 3;
    BOOL v15 = v14 == 0;
    if ((qword_1EB2089C0 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
      BOOL v15 = 1;
    }
    BOOL v75 = v15;
    unint64_t v76 = qword_1EB2089C0 & 0xFFFFFFFFFFFFFFFCLL;
    if (v15) {
      int v16 = 4;
    }
    else {
      int v16 = *(unsigned __int8 *)(qword_1EB2089C0 & 0xFFFFFFFFFFFFFFFCLL);
    }
    unint64_t v17 = dword_1EB2089B4;
    int v18 = (_DWORD *)qword_1EB2089B8;
    if (qword_1EB2089B8) {
      uint64_t v19 = qword_1EB2089B8 + 8;
    }
    else {
      uint64_t v19 = 0;
    }
    if (v20)
    {
      uint64_t explicit = *v20;
      __dmb(0xBu);
      if (WitnessTablePacks)
      {
LABEL_114:
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB2089C8);
        qword_1EB2089D8 = (uint64_t)explicit;
        return (unint64_t)(explicit + 1) | 1;
      }
      uint64_t v22 = (void **)qword_1EB2089D0;
      if (qword_1EB2089D0)
      {
        do
        {
          uint64_t v23 = (void **)*v22;
          free(v22[1]);
          free(v22);
          uint64_t v22 = v23;
        }
        while (v23);
      }
LABEL_113:
      qword_1EB2089D0 = 0;
      goto LABEL_114;
    }
    uint64_t v79 = v19;
    unint64_t v80 = v13;
    __src = v18 + 2;
    uint64_t v24 = (v17 + 1);
    if ((1 << v16) / (unint64_t)((1 << v16) - v24) < 4)
    {
      unint64_t v29 = v80;
      unsigned int v30 = v21;
      if (v18) {
        goto LABEL_84;
      }
    }
    else
    {
      long long v73 = v18;
      unsigned int v25 = (v16 + 1);
      char v78 = v16;
      if (v25 >= 0x11) {
        unsigned int v26 = 4;
      }
      else {
        unsigned int v26 = 2;
      }
      if (v25 < 9) {
        size_t v27 = 1;
      }
      else {
        size_t v27 = v26;
      }
      unint64_t v28 = (unint64_t)malloc_type_calloc(2 << v16, v27, 0x4269077AuLL);
      if (!v28) {
        swift::hashable_support::findHashableBaseTypeOfHashableType();
      }
      unint64_t v71 = v12;
      uint64_t v72 = v11;
      unint64_t v69 = v17;
      uint64_t v70 = (v17 + 1);
      if (v27 != 1)
      {
        if (v27 == 4) {
          size_t v27 = 3;
        }
        else {
          size_t v27 = 2;
        }
      }
      unint64_t v29 = v27 | v28;
      *(unsigned char *)unint64_t v28 = v16 + 1;
      unint64_t v31 = v80;
      char v32 = v16;
      if (v16)
      {
        uint64_t v33 = ~(-2 << v16);
        unint64_t v34 = v80 & 3;
        unint64_t v35 = v76;
        if (!v14) {
          unint64_t v35 = 0;
        }
        unint64_t v81 = v35;
        int v36 = v29 & 3;
        if ((v29 & 3) != 0) {
          unint64_t v37 = v28 & 0xFFFFFFFFFFFFFFFCLL;
        }
        else {
          unint64_t v37 = 0;
        }
        uint64_t v38 = 1;
        unint64_t v77 = v29;
        while (2)
        {
          switch(v34)
          {
            case 0uLL:
              uint64_t v39 = (v31 >> (4 * v38)) & 0xF;
              if (!v39) {
                goto LABEL_55;
              }
              goto LABEL_64;
            case 1uLL:
              LODWORD(v39) = *(unsigned __int8 *)(v81 + v38);
              if (*(unsigned char *)(v81 + v38)) {
                goto LABEL_64;
              }
              goto LABEL_55;
            case 2uLL:
              LODWORD(v39) = *(unsigned __int16 *)(v81 + 2 * v38);
              if (!*(_WORD *)(v81 + 2 * v38)) {
                goto LABEL_55;
              }
              goto LABEL_64;
            case 3uLL:
              LODWORD(v39) = *(_DWORD *)(v81 + 4 * v38);
              if (!v39) {
                goto LABEL_55;
              }
LABEL_64:
              unint64_t v40 = *(void **)(v19 + 8 * (v39 - 1));
              unint64_t v85 = 0;
              if (*v40)
              {
                unint64_t v41 = v34;
                uint64_t v42 = 0;
                unint64_t v43 = v40 + 1;
                do
                {
                  unint64_t v44 = __swift::__runtime::llvm::hash_combine<__swift::__runtime::llvm::hash_code,swift::TargetMetadata<swift::InProcess> const*>(&v85, v43);
                  unint64_t v85 = v44;
                  ++v42;
                  ++v43;
                }
                while (v42 != *v40);
                uint64_t v19 = v79;
                unint64_t v31 = v80;
                unint64_t v34 = v41;
                unint64_t v29 = v77;
                char v32 = v78;
              }
              else
              {
                unint64_t v44 = 0;
              }
              while (1)
              {
                unint64_t v46 = v44 & v33;
                if ((v44 & v33) != 0)
                {
                  switch(v36)
                  {
                    case 1:
                      LODWORD(v45) = *(unsigned __int8 *)(v37 + v46);
                      break;
                    case 2:
                      LODWORD(v45) = *(unsigned __int16 *)(v37 + 2 * v46);
                      break;
                    case 3:
                      LODWORD(v45) = *(_DWORD *)(v37 + 4 * v46);
                      break;
                    default:
                      uint64_t v45 = (v29 >> (4 * v46)) & 0xF;
                      break;
                  }
                  if (!v45) {
                    break;
                  }
                }
                unint64_t v44 = v46 + 1;
              }
              if (v36 == 3)
              {
                *(_DWORD *)(v37 + 4 * v46) = v39;
              }
              else if (v36 == 2)
              {
                *(_WORD *)(v37 + 2 * v46) = v39;
              }
              else
              {
                *(unsigned char *)(v37 + v46) = v39;
              }
LABEL_55:
              if (!((unint64_t)++v38 >> v32)) {
                continue;
              }
              goto LABEL_81;
            default:
              JUMPOUT(0);
          }
        }
      }
LABEL_81:
      atomic_store(v29, (unint64_t *)&qword_1EB2089C0);
      if (!v75)
      {
        int v47 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
        *int v47 = qword_1EB2089D0;
        v47[1] = v76;
        qword_1EB2089D0 = (uint64_t)v47;
      }
      unint64_t v17 = v69;
      unint64_t v12 = v71;
      uint64_t v11 = v72;
      uint64_t v24 = v70;
      int v18 = v73;
      unsigned int v30 = v48;
      if (v73)
      {
LABEL_84:
        unint64_t v49 = (unint64_t)v18;
        if (v17 < *v18) {
          goto LABEL_91;
        }
      }
    }
    char v50 = v18;
    unint64_t v51 = v17 + (v17 >> 2);
    if (v51 <= v17 + 1) {
      unint64_t v51 = v17 + 1;
    }
    size_t v52 = malloc_good_size(8 * v51 + 8);
    uint64_t v53 = malloc_type_malloc(v52, 0x1000D770uLL);
    if (!v53) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    unint64_t v49 = (unint64_t)v53;
    _DWORD *v53 = (v52 + 0x7FFFFFFF8) >> 3;
    if (v50)
    {
      memcpy(v53 + 2, __src, 8 * v17);
      long long v54 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
      *long long v54 = qword_1EB2089D0;
      v54[1] = v50;
      qword_1EB2089D0 = (uint64_t)v54;
    }
    atomic_store(v49, (unint64_t *)&qword_1EB2089B8);
LABEL_91:
    unint64_t v55 = v49 + 8;
    LOWORD(v85) = 25;
    uint64_t v56 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v85, 8 * v12 + 8, 8);
    uint64_t explicit = v56;
    *(void *)uint64_t v56 = v12;
    if (!v12)
    {
LABEL_99:
      *(void *)(v55 + 8 * v17) = v56;
      atomic_store(v24, (unsigned int *)&dword_1EB2089B4);
      switch(v29 & 3)
      {
        case 1uLL:
          unint64_t v60 = v29 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v29 & 3) == 0) {
            unint64_t v60 = 0;
          }
          atomic_store(v24, (unsigned __int8 *)(v60 + v30));
          break;
        case 2uLL:
          unint64_t v61 = v29 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v29 & 3) == 0) {
            unint64_t v61 = 0;
          }
          atomic_store(v24, (unsigned __int16 *)(v61 + 2 * v30));
          break;
        case 3uLL:
          unint64_t v62 = v29 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v29 & 3) == 0) {
            unint64_t v62 = 0;
          }
          atomic_store(v24, (unsigned int *)(v62 + 4 * v30));
          break;
        default:
          atomic_store((v24 << (4 * v30)) | v29, (unint64_t *)&qword_1EB2089C0);
          break;
      }
      __dmb(0xBu);
      if (WitnessTablePacks) {
        goto LABEL_114;
      }
      long long v63 = (void **)qword_1EB2089D0;
      if (qword_1EB2089D0)
      {
        do
        {
          long long v64 = (void **)*v63;
          free(v63[1]);
          free(v63);
          long long v63 = v64;
        }
        while (v64);
      }
      goto LABEL_113;
    }
    if (v12 >= 0xE)
    {
      int v57 = 0;
      unint64_t v58 = 0;
      if (!v12 || (v12 - 1) >> 32) {
        goto LABEL_97;
      }
      if ((unint64_t)v56 - v11 + 8 >= 0x20)
      {
        unint64_t v58 = v12 & 0xFFFFFFFFFFFFFFFCLL;
        int v57 = v12 & 0xFFFFFFFC;
        long long v65 = (long long *)(v11 + 16);
        long long v66 = v56 + 12;
        unint64_t v67 = v12 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          long long v68 = *v65;
          *(v66 - 1) = *(v65 - 1);
          *long long v66 = v68;
          v65 += 2;
          v66 += 2;
          v67 -= 4;
        }
        while (v67);
        if (v12 == v58) {
          goto LABEL_99;
        }
        goto LABEL_97;
      }
    }
    unint64_t v58 = 0;
    int v57 = 0;
LABEL_97:
    unsigned int v59 = v57 + 1;
    do
    {
      *(void *)&v56[4 * v58 + 4] = *(void *)(v11 + 8 * v58);
      unint64_t v58 = v59++;
    }
    while (v12 > v58);
    goto LABEL_99;
  }
  return result;
}

uint64_t swift::getResilientMetadataBounds(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 24);
  if (v1) {
    uint64_t v2 = (atomic_ullong *)(a1 + 24 + v1);
  }
  else {
    uint64_t v2 = 0;
  }
  if (atomic_load_explicit(v2, memory_order_acquire)) {
    return v2[1];
  }
  else {
    return computeMetadataBoundsFromSuperclass((unsigned char *)a1, (uint64_t)v2);
  }
}

uint64_t computeMetadataBoundsFromSuperclass(unsigned char *a1, uint64_t a2)
{
  uint64_t v3 = a1;
  if (!a1) {
    a1 = 0;
  }
  TrailingObjectsImpl = (int *)swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(a1);
  uint64_t v7 = *TrailingObjectsImpl;
  BOOL v8 = (char *)TrailingObjectsImpl + v7;
  if (v7) {
    BOOL v9 = v8 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    LODWORD(v1swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 3;
    LODWORD(v11) = 10;
  }
  else
  {
    switch((*v3 >> 25) & 7)
    {
      case 0:
        unint64_t v12 = (int *)(v8 + 24);
        if ((v8[3] & 0x20) == 0)
        {
          unint64_t v10 = *(void *)v12;
          goto LABEL_37;
        }
        uint64_t v24 = *v12;
        unsigned int v25 = (atomic_ullong *)((char *)v12 + v24);
        if (v24) {
          unsigned int v26 = v25;
        }
        else {
          unsigned int v26 = 0;
        }
        if (!atomic_load_explicit(v26, memory_order_acquire)) {
          goto LABEL_36;
        }
        goto LABEL_34;
      case 1:
        if (!*(void *)v8) {
          swift::fatalError(0, "instantiating class metadata for class with missing weak-linked ancestor", v5, v6);
        }
        uint64_t v14 = *(const char **)v8;
        BOOL v15 = (int *)(*(void *)v8 + 24);
        if ((*(unsigned char *)(*(void *)v8 + 3) & 0x20) != 0)
        {
          uint64_t v27 = *v15;
          unint64_t v28 = (atomic_ullong *)((char *)v15 + v27);
          if (v27) {
            unsigned int v26 = v28;
          }
          else {
            unsigned int v26 = 0;
          }
          if (atomic_load_explicit(v26, memory_order_acquire))
          {
LABEL_34:
            unint64_t v10 = v26[1];
          }
          else
          {
            BOOL v8 = v14;
LABEL_36:
            unint64_t v10 = computeMetadataBoundsFromSuperclass(v8);
          }
        }
        else
        {
          unint64_t v10 = *(void *)v15;
        }
LABEL_37:
        unint64_t v11 = HIDWORD(v10);
        break;
      case 2:
        Class v13 = objc_lookUpClass(v8);
        goto LABEL_17;
      case 3:
        Class v13 = *(Class *)v8;
LABEL_17:
        uint64_t InitializedObjCClass = swift_getInitializedObjCClass((uint64_t)v13);
        if ((*(unsigned char *)(InitializedObjCClass + 32) & 2) != 0)
        {
          unint64_t v17 = *(unsigned int *)(InitializedObjCClass + 60);
          unint64_t v18 = *(unsigned int *)(InitializedObjCClass + 56) - v17;
          uint64_t v19 = v17 >> 3;
          unint64_t v20 = (v18 << 29) & 0xFFFFFFFF00000000;
          unint64_t v21 = v18 >> 3;
          if (v19 < 3) {
            uint64_t v19 = 3;
          }
          BOOL v22 = v21 >= 0xA;
          uint64_t v23 = 0xA00000000;
          if (v22) {
            uint64_t v23 = v20;
          }
          unint64_t v10 = v23 | v19;
        }
        else
        {
          unint64_t v10 = 0xA00000003;
        }
        goto LABEL_37;
      default:
        abort();
    }
  }
  int v29 = v3[8];
  uint64_t v30 = 8 * v11;
  if ((*v3 & 0x10000000) != 0) {
    int v31 = 0;
  }
  else {
    int v31 = v3[8];
  }
  uint64_t v32 = (v31 + v11);
  if ((*v3 & 0x10000000) != 0) {
    uint64_t v33 = (v29 + v10);
  }
  else {
    uint64_t v33 = v10;
  }
  if ((*v3 & 0x10000000) != 0) {
    unint64_t v34 = -8 * (v29 + v10);
  }
  else {
    unint64_t v34 = v30;
  }
  uint64_t result = v33 | (v32 << 32);
  *(_DWORD *)(a2 + 8) = v33;
  *(_DWORD *)(a2 + 12) = v32;
  atomic_store(v34, (unint64_t *)a2);
  return result;
}

unint64_t swift::getResilientImmediateMembersOffset(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 24);
  if (v1) {
    uint64_t v2 = (unint64_t *)(a1 + 24 + v1);
  }
  else {
    uint64_t v2 = 0;
  }
  unint64_t v3 = *v2;
  if (!*v2)
  {
    computeMetadataBoundsFromSuperclass((unsigned char *)a1, (uint64_t)v2);
    unint64_t v3 = v4;
  }
  return v3 >> 3;
}

uint64_t swift::TargetMetadata<swift::InProcess>::isCanonicalStaticallySpecializedGenericMetadata(uint64_t a1)
{
  unint64_t v1 = *(void *)a1;
  if (*(void *)a1 != 512)
  {
    if (v1 <= 0x7FF && (v1 - 513) <= 1) {
      return swift::TargetEnumMetadata<swift::InProcess>::isCanonicalStaticallySpecializedGenericMetadata(a1);
    }
    BOOL v5 = v1 > 0x7FF || *(void *)a1 == 0;
    if (v5 && (**(unsigned char **)(a1 + 64) & 0x80) != 0) {
      return (*(unsigned __int8 *)(a1 + 40) >> 4) & 1;
    }
    return 0;
  }
  uint64_t v2 = *(unsigned char **)(a1 + 8);
  if (v2)
  {
    if ((*v2 & 0x80) != 0)
    {
      uint64_t v3 = *(void *)(a1 + 8);
      goto LABEL_18;
    }
    return 0;
  }
  uint64_t v3 = 0;
  if ((MEMORY[0] & 0x80) == 0) {
    return 0;
  }
LABEL_18:
  if (v3) {
    uint64_t v7 = v3;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v7 == -28) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = v7 + 28;
  }
  uint64_t v9 = *(int *)(v8 + 4);
  if (v9) {
    uint64_t v10 = v9 + v8 + 4;
  }
  else {
    uint64_t v10 = 0;
  }
  if ((*(unsigned char *)(v10 + 8) & 2) == 0) {
    return 0;
  }
  return (*(void *)(a1
                    + 8 * (*(unsigned int *)(v3 + 24) + ((4 * (unint64_t)*(unsigned int *)(v3 + 20) + 7) >> 3))) >> 1) & 1;
}

uint64_t swift::TargetEnumMetadata<swift::InProcess>::isCanonicalStaticallySpecializedGenericMetadata(uint64_t a1)
{
  unint64_t v1 = *(unsigned char **)(a1 + 8);
  if (v1)
  {
    if ((*v1 & 0x80) != 0)
    {
      uint64_t v2 = *(void *)(a1 + 8);
      goto LABEL_5;
    }
    return 0;
  }
  uint64_t v2 = 0;
  if ((MEMORY[0] & 0x80) == 0) {
    return 0;
  }
LABEL_5:
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 0;
  }
  if (v3 == -28) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = v3 + 28;
  }
  uint64_t v5 = *(int *)(v4 + 4);
  if (v5) {
    uint64_t v6 = v5 + v4 + 4;
  }
  else {
    uint64_t v6 = 0;
  }
  if ((*(unsigned char *)(v6 + 8) & 2) == 0) {
    return 0;
  }
  if (v2) {
    uint64_t v8 = v2;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(unsigned __int16 *)(v8 + 40) + 2;
  if (v1) {
    uint64_t v10 = *(void *)(a1 + 8);
  }
  else {
    uint64_t v10 = 0;
  }
  if (*(unsigned char *)(v10 + 23)) {
    uint64_t v11 = v9 + 1;
  }
  else {
    uint64_t v11 = v9;
  }
  return (*(void *)(a1 + 8 * v11) >> 1) & 1;
}

_WORD *swift_allocateGenericClassMetadata(uint64_t a1, const void *a2, uint64_t a3)
{
  if (a1) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = 0;
  }
  if ((*(_DWORD *)v5 & 0x20000000) != 0)
  {
    uint64_t v8 = *(int *)(v5 + 24);
    if (v8) {
      uint64_t v9 = (atomic_ullong *)(v8 + v5 + 24);
    }
    else {
      uint64_t v9 = 0;
    }
    uint64_t explicit = atomic_load_explicit(v9, memory_order_acquire);
    if (explicit)
    {
      unint64_t v11 = v9[1];
    }
    else
    {
      unint64_t v11 = computeMetadataBoundsFromSuperclass((unsigned char *)v5, (uint64_t)v9);
      uint64_t explicit = v12;
    }
  }
  else
  {
    if ((*(_DWORD *)v5 & 0x10000000) != 0)
    {
      int v6 = 0;
      uint64_t v7 = 24;
    }
    else
    {
      int v6 = *(_DWORD *)(v5 + 28);
      uint64_t v7 = 32;
    }
    uint64_t explicit = 8 * (v6 - *(_DWORD *)(v5 + v7));
    unint64_t v11 = *(void *)(v5 + 24);
  }
  unint64_t v13 = v11;
  if (*(unsigned char *)(a3 + 8)) {
    unint64_t v13 = v11
  }
        + ((unint64_t)(*(unsigned __int16 *)(a3 + 38) + *(unsigned __int16 *)(a3 + 36)) << 32);
  __int16 v45 = 17;
  uint64_t v14 = &swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v45, 8 * (HIDWORD(v13) + v13), 8)[4 * v13];
  BOOL v15 = &v14[4 * HIDWORD(v11)];
  if (*(unsigned char *)(a3 + 8))
  {
    bzero(&v14[4 * HIDWORD(v11)], 8 * *(unsigned __int16 *)(a3 + 36));
    int v16 = (int *)(a3 + 32);
    uint64_t v17 = *(int *)(a3 + 32);
    if (v17) {
      unint64_t v18 = (const void *)(v17 + a3 + 32);
    }
    else {
      unint64_t v18 = 0;
    }
    memcpy(&v15[4 * *(unsigned __int16 *)(a3 + 36)], v18, 8 * *(unsigned __int16 *)(a3 + 38));
  }
  else
  {
    int v16 = 0;
  }
  uint64_t v19 = (char *)v14 + explicit;
  bzero(v19, 8 * *(unsigned int *)(v5 + 32));
  int v20 = *(_DWORD *)(a3 + 8);
  if (v20 < 0)
  {
    uint64_t v21 = a3 + 8 * (v20 & 1);
    uint64_t v23 = *(int *)(v21 + 32);
    uint64_t v22 = v21 + 32;
    uint64_t v24 = (const void *)(v23 + v22);
    if (v23) {
      unsigned int v25 = v24;
    }
    else {
      unsigned int v25 = 0;
    }
    memcpy(&v19[8 * *(unsigned __int16 *)(v22 + 4)], v25, 8 * *(unsigned __int16 *)(v22 + 6));
  }
  uint64_t v26 = 0;
  uint64_t v27 = *(int *)(a3 + 12);
  if (v27 && v27 + a3 + 12) {
    uint64_t v26 = v27 + a3 + 12;
  }
  *((void *)v14 - 2) = v26;
  int v28 = *(_DWORD *)(a3 + 20);
  if ((v28 & 2) != 0) {
    int v29 = value witness table for Builtin.NativeObject;
  }
  else {
    int v29 = (uint64_t (**)())&value witness table for Builtin.UnknownObject;
  }
  *((void *)v14 - 1) = v29;
  uint64_t v30 = &v15[4 * *(unsigned __int16 *)(a3 + 26)];
  uint64_t v31 = 4 * *(unsigned __int16 *)(a3 + 28);
  *((void *)v30 + 4) = &v15[v31];
  uint64_t v32 = *v16;
  if (v32) {
    uint64_t v33 = (char *)v16 + v32;
  }
  else {
    uint64_t v33 = 0;
  }
  unint64_t v34 = v30;
  *(void *)&v15[v31 + 16] = *(void *)&v33[v31 * 2 + 32];
  uint64_t v35 = MEMORY[0x1E4FBA8C0];
  *(void *)uint64_t v14 = v34;
  *((void *)v14 + 1) = 0;
  *((void *)v14 + 2) = v35;
  *((void *)v14 + 3) = 0;
  uint64_t v36 = 4 * *(unsigned __int16 *)(a3 + 24);
  *((void *)v14 + 4) = (unint64_t)&v15[v36] | 2;
  *(void *)&v15[v36 + 16] = *(void *)&v33[v36 * 2 + 32];
  *((_DWORD *)v14 + 1swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v28;
  *(void *)(v14 + 22) = 0;
  *((_DWORD *)v14 + 13) = 0;
  *((_DWORD *)v14 + 14) = 8 * (HIDWORD(v11) + v11);
  *((_DWORD *)v14 + 15) = 8 * v11;
  if (v5) {
    uint64_t v37 = v5;
  }
  else {
    uint64_t v37 = 0;
  }
  uint64_t v38 = 0;
  *((void *)v14 + 8) = v37;
  uint64_t v41 = *(int *)(a3 + 16);
  uint64_t v40 = a3 + 16;
  uint64_t v39 = v41;
  if (v41)
  {
    uint64_t v42 = v39 + v40;
    if (v42) {
      uint64_t v38 = v42;
    }
  }
  *((void *)v14 + 9) = v38;
  if (v5) {
    unint64_t v43 = (_DWORD *)v5;
  }
  else {
    unint64_t v43 = 0;
  }
  installGenericArguments((uint64_t)v14, v43, a2);
  return v14;
}

_WORD *swift::MetadataAllocator::Allocate(swift::MetadataAllocator *this, size_t size, uint64_t a3)
{
  if (swift::MetadataAllocator::Allocate(unsigned long,unsigned long)::getenvToken != -1) {
    dispatch_once_f(&swift::MetadataAllocator::Allocate(unsigned long,unsigned long)::getenvToken, 0, (dispatch_function_t)checkAllocatorDebugEnvironmentVariables);
  }
  if (size > 0x2000)
  {
    uint64_t v3 = swift_slowAlloc(size, a3 - 1);
    if (swift::runtime::environment::initializeToken != -1) {
      dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
    }
    if (swift::runtime::environment::SWIFT_DEBUG_ENABLE_MALLOC_SCRIBBLE_variable) {
      memset(v3, 170, size);
    }
    return v3;
  }
  uint64_t v34 = a3;
  uint64_t v35 = (unsigned __int16 *)this;
  _X22 = 0;
  _X23 = 0;
  if (_swift_debug_metadataAllocationIterationEnabled) {
    size_t v9 = size + 8;
  }
  else {
    size_t v9 = size;
  }
  __asm { CASP            X22, X23, X22, X23, [X8] }
  while (1)
  {
    if (_X23 >= v9)
    {
      _X0 = (swift::runtime::environment *)((char *)_X22 + v9);
      if (!_X22)
      {
        _X2 = 0;
        _X3 = 0;
        __asm { CASP            X2, X3, X2, X3, [X8]; char * }
        swift::fatalError(0, "Metadata allocator corruption: allocation is NULL. curState: {%p, %zu} - curStateReRead: {%p, %zu} - newState: {%p, %zu} - allocatedNewPage: %s - requested size: %zu - sizeWithHeader: %zu - alignment: %zu - Tag: %d\n", _X2, 0, 0, _X23, _X2, 0, _X0, _X23 - v9, "false", size, v9, v34, *v35);
      }
      int v16 = _X22;
    }
    else
    {
      if (_swift_debug_metadataAllocationIterationEnabled) {
        uint64_t v15 = 8184;
      }
      else {
        uint64_t v15 = 0x2000;
      }
      int v16 = swift_slowAlloc(0x4000uLL, 0);
      if (swift::runtime::environment::initializeToken != -1) {
        dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
      }
      if (swift::runtime::environment::SWIFT_DEBUG_ENABLE_MALLOC_SCRIBBLE_variable) {
        memset(v16, 170, 0x4000uLL);
      }
      if (_swift_debug_metadataAllocationIterationEnabled)
      {
        uint64_t v22 = &v16[v15];
        void *v22 = (char *)_X22 + _X23;
        v22[1] = v15 * 2;
      }
      _X0 = (swift::runtime::environment *)((char *)v16 + v9);
    }
    _X21 = _X23;
    __asm { CASP            X20, X21, X0, X1, [X8] }
    BOOL v20 = _X20 == _X22;
    if (_X20 != _X22)
    {
      if (_X23 < v9) {
        swift_slowDealloc(v16);
      }
      goto LABEL_12;
    }
    if (_swift_debug_metadataAllocationIterationEnabled) {
      break;
    }
    if (swift::runtime::environment::initializeToken == -1)
    {
      if (!size) {
        return v16;
      }
    }
    else
    {
      dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
      if (!size) {
        return v16;
      }
    }
    if (!swift::runtime::environment::SWIFT_DEBUG_ENABLE_MALLOC_SCRIBBLE_variable) {
      return v16;
    }
    uint64_t v21 = 0;
    do
    {
      if (*((unsigned __int8 *)v16 + v21) != 170)
      {
        uint64_t v27 = (unsigned __int8 *)v16 + v21;
        unint64_t v28 = size - v21;
        if (v28 >= 0x10) {
          uint64_t v29 = 16;
        }
        else {
          uint64_t v29 = v28;
        }
        if (v28 <= 0x10) {
          uint64_t v30 = "";
        }
        else {
          uint64_t v30 = "...";
        }
        __swift::__runtime::llvm::toHex(v27, v29, 0, &v36);
        if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v33 = &v36;
        }
        else {
          uint64_t v33 = (std::string *)v36.__r_.__value_.__r.__words[0];
        }
        swift::fatalError(0, "corrupt metadata allocation arena detected at %p: %s%s", v31, v32, v27, v33, v30);
      }
      ++v21;
    }
    while (size != v21);
    _X21 = _X23;
    _X20 = _X22;
    uint64_t v3 = v16;
LABEL_12:
    _X22 = _X20;
    _X23 = _X21;
    if (v20) {
      return v3;
    }
  }
  _WORD *v16 = size;
  v16[1] = *v35;
  uint64_t v3 = v16 + 4;
  if (swift::runtime::environment::SWIFT_DEBUG_ENABLE_METADATA_BACKTRACE_LOGGING(_X0)) {
    recordBacktrace(v16 + 4);
  }
  checkScribble((char *)v16 + 8, size);
  return v3;
}

void *installGenericArguments(uint64_t a1, _DWORD *a2, const void *a3)
{
  uint64_t GenericContext = (unsigned __int16 *)swift::TargetContextDescriptor<swift::InProcess>::getGenericContext(a2);
  if ((*a2 & 0x1Fu) - 17 >= 2)
  {
    if ((*a2 & 0x1F) != 0x10) {
      abort();
    }
    if (a2) {
      uint64_t v19 = a2;
    }
    else {
      uint64_t v19 = 0;
    }
    if ((*v19 & 0x20000000) != 0)
    {
      uint64_t v22 = (int)v19[6];
      if (v22) {
        uint64_t v23 = (unint64_t *)((char *)v19 + v22 + 24);
      }
      else {
        uint64_t v23 = 0;
      }
      unint64_t v24 = *v23;
      if (!*v23)
      {
        computeMetadataBoundsFromSuperclass(v19, (uint64_t)v23);
        unint64_t v24 = v25;
      }
      unint64_t v7 = v24 >> 3;
    }
    else
    {
      if ((*v19 & 0x10000000) != 0)
      {
        int v20 = 0;
        uint64_t v21 = 6;
      }
      else
      {
        int v20 = v19[7];
        uint64_t v21 = 8;
      }
      LODWORD(v7) = v20 - v19[v21];
    }
  }
  else
  {
    LODWORD(v7) = 2;
  }
  uint64_t v8 = (char *)(a1 + 8 * (int)v7);
  if (GenericContext[5])
  {
    size_t v9 = (_WORD *)((((unint64_t)GenericContext + GenericContext[2] + 15) & 0xFFFFFFFFFFFFFFFCLL)
                 + 12 * GenericContext[3]);
    uint64_t v10 = (unsigned __int16)*v9;
    uint64_t v11 = GenericContext[4];
    if (*v9) {
      uint64_t v12 = &v9[2 * (GenericContext[5] & 1)];
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t result = memcpy(v8, a3, 8 * v11);
    if (v10)
    {
      uint64_t v14 = v12 + 2;
      do
      {
        uint64_t v16 = *(v14 - 1);
        unint64_t v17 = *(void *)&v8[8 * *v14];
        if (*(v14 - 2) == 1)
        {
          uint64_t v15 = 8 * v16;
          uint64_t result = (void *)swift_allocateWitnessTablePack(*(void *)&v8[8 * v16], v17);
        }
        else
        {
          if (*(v14 - 2)) {
            goto LABEL_11;
          }
          uint64_t v15 = 8 * v16;
          uint64_t result = (void *)swift_allocateMetadataPack(*(void *)&v8[8 * v16], v17);
        }
        *(void *)&v8[v15] = result;
LABEL_11:
        v14 += 4;
        --v10;
      }
      while (v10);
    }
  }
  else
  {
    size_t v18 = 8 * GenericContext[4];
    return memcpy(v8, a3, v18);
  }
  return result;
}

void *swift_allocateGenericValueMetadata(_DWORD *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  if (a1) {
    int v6 = a1;
  }
  else {
    int v6 = 0;
  }
  __int16 v18 = 18;
  unint64_t v7 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v18, a4 + 32, 8);
  uint64_t v8 = v7;
  if (*(unsigned char *)(a3 + 8))
  {
    bzero(v7 + 16, 8 * *(unsigned __int16 *)(a3 + 20));
    uint64_t v9 = *(int *)(a3 + 16);
    if (v9) {
      uint64_t v10 = (const void *)(v9 + a3 + 16);
    }
    else {
      uint64_t v10 = 0;
    }
    memcpy(&v8[*(unsigned __int16 *)(a3 + 20) + 4], v10, 8 * *(unsigned __int16 *)(a3 + 22));
  }
  uint64_t v11 = *(int *)(a3 + 12);
  if (!v11) {
    goto LABEL_15;
  }
  uint64_t v12 = (void *)((v11 & 0xFFFFFFFFFFFFFFFELL) + a3 + 12);
  if (v11)
  {
    if (!*v12) {
      goto LABEL_15;
    }
    uint64_t v12 = (void *)*v12;
  }
  if (v12)
  {
    unint64_t v13 = v12;
    goto LABEL_16;
  }
LABEL_15:
  unint64_t v13 = 0;
LABEL_16:
  unint64_t v14 = (unint64_t)*(unsigned int *)(a3 + 8) >> 21;
  v8[1] = v13;
  void v8[2] = v14;
  if (v6)
  {
    uint64_t v15 = v6;
    uint64_t v16 = v6;
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v16 = 0;
  }
  void v8[3] = v15;
  installGenericArguments((uint64_t)(v8 + 2), v16, a2);
  return v8 + 2;
}

unint64_t swift_getCanonicalSpecializedMetadata(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  uint64_t v19 = a2;
  uint64_t v20 = a1;
  unint64_t v5 = *a2;
  if (*a2 == 512)
  {
    int v6 = (_DWORD *)a2[1];
    if (v6) {
      goto LABEL_17;
    }
  }
  else if (v5 > 0x7FF || (v5 - 513) > 1)
  {
    if (v5 > 0x7FF || *a2 == 0)
    {
      int v6 = (_DWORD *)a2[8];
      if (v6) {
        goto LABEL_17;
      }
    }
  }
  else
  {
    int v6 = (_DWORD *)a2[1];
    if (v6)
    {
LABEL_17:
      uint64_t v9 = v6;
      goto LABEL_19;
    }
  }
  uint64_t v9 = 0;
LABEL_19:
  unint64_t result = *a3;
  if (!*a3)
  {
    CanonicalMetadataPrespecializationCachingOnceToken = swift::TargetTypeContextDescriptor<swift::InProcess>::getCanonicalMetadataPrespecializationCachingOnceToken((uint64_t)v9);
    if (CanonicalMetadataPrespecializationCachingOnceToken)
    {
      if (v9) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = 0;
      }
      if (*(void *)CanonicalMetadataPrespecializationCachingOnceToken != -1) {
        dispatch_once_f((dispatch_once_t *)CanonicalMetadataPrespecializationCachingOnceToken, v12, (dispatch_function_t)cacheCanonicalSpecializedMetadata(swift::TargetTypeContextDescriptor<swift::InProcess> const*,long *)::$_0::__invoke);
      }
    }
    GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a2);
    Cache = getCache(v9);
    swift::MetadataCacheKey::MetadataCacheKey((uint64_t)v18, Cache + 28, (uint64_t)GenericArgs);
    v15[0] = v18[0];
    v15[1] = v18[1];
    unint64_t result = v17;
    atomic_store(v17, a3);
  }
  return result;
}

char *swift::TargetTypeContextDescriptor<swift::InProcess>::getCanonicalMetadataPrespecializationCachingOnceToken(uint64_t a1)
{
  int v1 = *(_DWORD *)a1 & 0x1F;
  if (v1 == 16)
  {
    if ((*(unsigned char *)(a1 + 2) & 8) != 0)
    {
      if (!a1) {
        a1 = 0;
      }
      TrailingObjectsImpl = (int *)swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl((unsigned int *)a1);
      return (char *)TrailingObjectsImpl + *TrailingObjectsImpl;
    }
    return 0;
  }
  if (v1 != 17)
  {
    if (v1 != 18) {
      abort();
    }
    if ((*(unsigned char *)(a1 + 2) & 8) != 0)
    {
      if (a1) {
        uint64_t v2 = (unsigned char *)a1;
      }
      else {
        uint64_t v2 = 0;
      }
      unint64_t v5 = swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetEnumDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetEnumDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v2);
      unint64_t v6 = *(unsigned int *)v2;
      if ((v6 & 0x80000) != 0)
      {
        if (!v2) {
          uint64_t v2 = 0;
        }
        unint64_t v9 = swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetEnumDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetEnumDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v2);
        uint64_t v10 = v2;
LABEL_29:
        uint64_t v8 = *(unsigned int *)(v9 + 4 * ((*v10 & 0x30000) == 0x20000) + 12 * ((*v10 & 0x30000) == 0x10000));
        goto LABEL_30;
      }
      goto LABEL_22;
    }
    return 0;
  }
  if ((*(unsigned char *)(a1 + 2) & 8) == 0) {
    return 0;
  }
  if (a1) {
    uint64_t v4 = (unsigned char *)a1;
  }
  else {
    uint64_t v4 = 0;
  }
  unint64_t v5 = swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetStructDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetStructDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v4);
  unint64_t v6 = *(unsigned int *)v4;
  if ((v6 & 0x80000) != 0)
  {
    if (!v4) {
      uint64_t v4 = 0;
    }
    unint64_t v9 = swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetStructDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetStructDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v4);
    uint64_t v10 = v4;
    goto LABEL_29;
  }
LABEL_22:
  uint64_t v8 = 0;
LABEL_30:
  TrailingObjectsImpl = (int *)(v5
                              + 4 * ((v6 & 0x30000) == 0x20000)
                              + 12 * ((v6 & 0x30000) == 0x10000)
                              + 4 * ((v6 >> 19) & 1)
                              + 4 * v8);
  return (char *)TrailingObjectsImpl + *TrailingObjectsImpl;
}

_WORD *getCache(_DWORD *a1)
{
  int v1 = *a1 & 0x1F;
  switch(v1)
  {
    case 18:
      if (a1) {
        uint64_t v3 = a1;
      }
      else {
        uint64_t v3 = 0;
      }
      uint64_t v8 = v3 + 7;
      if (v3 != (_DWORD *)-28)
      {
        unint64_t v6 = v3 + 7;
        uint64_t v7 = *v8;
        if (!v7) {
          goto LABEL_26;
        }
        goto LABEL_23;
      }
      break;
    case 17:
      if (a1) {
        uint64_t v4 = a1;
      }
      else {
        uint64_t v4 = 0;
      }
      unint64_t v9 = v4 + 7;
      if (v4 != (_DWORD *)-28)
      {
        unint64_t v6 = v4 + 7;
        uint64_t v7 = *v9;
        if (!v7) {
          goto LABEL_26;
        }
        goto LABEL_23;
      }
      break;
    case 16:
      if (a1) {
        uint64_t v2 = a1;
      }
      else {
        uint64_t v2 = 0;
      }
      unint64_t v5 = v2 + 11;
      if (v2 != (_DWORD *)-44)
      {
        unint64_t v6 = v2 + 11;
        uint64_t v7 = *v5;
        if (!v7) {
          goto LABEL_26;
        }
        goto LABEL_23;
      }
      break;
    default:
      abort();
  }
  unint64_t v6 = 0;
  uint64_t v7 = MEMORY[0];
  if (!MEMORY[0])
  {
LABEL_26:
    unint64_t v83 = a1;
    uint64_t explicit = (_WORD *)atomic_load_explicit(&qword_1E8ECF990, memory_order_acquire);
    if (explicit && *(_DWORD **)explicit == v83) {
      return explicit + 4;
    }
    do
    {
      unint64_t v12 = atomic_load_explicit(&qword_1E8ECF970, memory_order_acquire);
      unint64_t v13 = atomic_load_explicit(&qword_1E8ECF978, memory_order_acquire);
      unint64_t v14 = atomic_load_explicit(&dword_1E8ECF96C, memory_order_acquire);
    }
    while (v12 != atomic_load_explicit(&qword_1E8ECF970, memory_order_acquire));
    if (v12) {
      BOOL v15 = v13 == 0;
    }
    else {
      BOOL v15 = 1;
    }
    if (!v15 && v14 != 0)
    {
      if (v17)
      {
        qword_1E8ECF990 = *v17;
        uint64_t explicit = (_WORD *)*v17;
        return explicit + 4;
      }
    }
    context[0] = (unint64_t)v83;
    os_unfair_lock_lock((os_unfair_lock_t)&unk_1E8ECF980);
    unint64_t v18 = qword_1E8ECF978;
    uint64_t v19 = qword_1E8ECF978 & 3;
    BOOL v20 = v19 == 0;
    if ((qword_1E8ECF978 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
      BOOL v20 = 1;
    }
    BOOL v82 = v20;
    if (v20) {
      int v21 = 4;
    }
    else {
      int v21 = *(unsigned __int8 *)(qword_1E8ECF978 & 0xFFFFFFFFFFFFFFFCLL);
    }
    unint64_t v22 = dword_1E8ECF96C;
    uint64_t v23 = (_DWORD *)qword_1E8ECF970;
    if (qword_1E8ECF970) {
      uint64_t v24 = qword_1E8ECF970 + 8;
    }
    else {
      uint64_t v24 = 0;
    }
    if (v25)
    {
      uint64_t explicit = *v25;
      __dmb(0xBu);
      {
LABEL_142:
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_1E8ECF980);
        qword_1E8ECF990 = (uint64_t)explicit;
        return explicit + 4;
      }
      uint64_t v27 = (void **)qword_1E8ECF988;
      if (qword_1E8ECF988)
      {
        do
        {
          unint64_t v28 = (void **)*v27;
          free(v27[1]);
          free(v27);
          uint64_t v27 = v28;
        }
        while (v28);
      }
LABEL_141:
      qword_1E8ECF988 = 0;
      goto LABEL_142;
    }
    uint64_t v81 = v24;
    uint64_t v29 = (v22 + 1);
    if ((1 << v21) / (unint64_t)((1 << v21) - v29) < 4)
    {
      unsigned int v35 = v26;
      unint64_t v36 = v18;
      if (v23) {
        goto LABEL_105;
      }
    }
    else
    {
      unsigned int v30 = (v21 + 1);
      if (v30 >= 0x11) {
        unsigned int v31 = 4;
      }
      else {
        unsigned int v31 = 2;
      }
      if (v30 < 9) {
        size_t v32 = 1;
      }
      else {
        size_t v32 = v31;
      }
      unint64_t v33 = (unint64_t)malloc_type_calloc(2 << v21, v32, 0x4269077AuLL);
      if (!v33) {
        swift::hashable_support::findHashableBaseTypeOfHashableType();
      }
      uint64_t v34 = v81;
      unint64_t v79 = v22;
      uint64_t v80 = (v22 + 1);
      if (v32 != 1)
      {
        if (v32 == 4) {
          size_t v32 = 3;
        }
        else {
          size_t v32 = 2;
        }
      }
      unint64_t v36 = v32 | v33;
      *(unsigned char *)unint64_t v33 = v21 + 1;
      if (v21)
      {
        if (v19) {
          unint64_t v37 = v18 & 0xFFFFFFFFFFFFFFFCLL;
        }
        else {
          unint64_t v37 = 0;
        }
        unint64_t v38 = v36 & 3;
        if ((v36 & 3) != 0) {
          unint64_t v39 = v33 & 0xFFFFFFFFFFFFFFFCLL;
        }
        else {
          unint64_t v39 = 0;
        }
        uint64_t v40 = 1;
        uint64_t v41 = (void *)&unk_1EB1F3000;
        while (2)
        {
          switch(v18 & 3)
          {
            case 0uLL:
              uint64_t v42 = (v18 >> (4 * v40)) & 0xF;
              if (!v42) {
                goto LABEL_75;
              }
              goto LABEL_84;
            case 1uLL:
              LODWORD(v42) = *(unsigned __int8 *)(v37 + v40);
              if (!*(unsigned char *)(v37 + v40)) {
                goto LABEL_75;
              }
              goto LABEL_84;
            case 2uLL:
              LODWORD(v42) = *(unsigned __int16 *)(v37 + 2 * v40);
              if (!*(_WORD *)(v37 + 2 * v40)) {
                goto LABEL_75;
              }
              goto LABEL_84;
            case 3uLL:
              LODWORD(v42) = *(_DWORD *)(v37 + 4 * v40);
              if (v42)
              {
LABEL_84:
                unint64_t v43 = **(void **)(v34 + 8 * (v42 - 1));
                {
                  unint64_t v77 = v43;
                  unint64_t v78 = v38;
                  unint64_t v76 = v37;
                  uint64_t v41 = &unk_1EB1F3000;
                  unint64_t v37 = v76;
                  unint64_t v43 = v77;
                  uint64_t v34 = v81;
                  unint64_t v38 = v78;
                  if (v49)
                  {
                    unint64_t v50 = __swift::__runtime::llvm::hashing::detail::fixed_seed_override;
                    if (!__swift::__runtime::llvm::hashing::detail::fixed_seed_override) {
                      unint64_t v50 = 0xFF51AFD7ED558CCDLL;
                    }
                    __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed = v50;
                    uint64_t v41 = (void *)&unk_1EB1F3000;
                    unint64_t v37 = v76;
                    unint64_t v43 = v77;
                    uint64_t v34 = v81;
                    unint64_t v38 = v78;
                  }
                }
                unint64_t v44 = 0x9DDFEA08EB382D69 * ((v41[38] + 8 * v43) ^ HIDWORD(v43));
                unint64_t v45 = 0x9DDFEA08EB382D69 * (HIDWORD(v43) ^ (v44 >> 47) ^ v44);
                for (unint64_t i = 0x9DDFEA08EB382D69 * (v45 ^ (v45 >> 47)); ; unint64_t i = v48 + 1)
                {
                  uint64_t v48 = i & ~(-2 << v21);
                  if (v48)
                  {
                    switch((int)v38)
                    {
                      case 1:
                        LODWORD(v47) = *(unsigned __int8 *)(v39 + v48);
                        break;
                      case 2:
                        LODWORD(v47) = *(unsigned __int16 *)(v39 + 2 * v48);
                        break;
                      case 3:
                        LODWORD(v47) = *(_DWORD *)(v39 + 4 * v48);
                        break;
                      default:
                        uint64_t v47 = (v36 >> (4 * v48)) & 0xF;
                        break;
                    }
                    if (!v47) {
                      break;
                    }
                  }
                }
                if (v38 == 3)
                {
                  *(_DWORD *)(v39 + 4 * v48) = v42;
                }
                else if (v38 == 2)
                {
                  *(_WORD *)(v39 + 2 * v48) = v42;
                }
                else
                {
                  *(unsigned char *)(v39 + v48) = v42;
                }
              }
LABEL_75:
              if (!((unint64_t)++v40 >> v21)) {
                continue;
              }
              goto LABEL_102;
            default:
              JUMPOUT(0);
          }
        }
      }
LABEL_102:
      atomic_store(v36, (unint64_t *)&qword_1E8ECF978);
      if (!v82)
      {
        unint64_t v51 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
        uint64_t v34 = v81;
        *unint64_t v51 = qword_1E8ECF988;
        v51[1] = v18 & 0xFFFFFFFFFFFFFFFCLL;
        qword_1E8ECF988 = (uint64_t)v51;
      }
      unint64_t v22 = v79;
      unsigned int v35 = v52;
      uint64_t v29 = v80;
      if (v23)
      {
LABEL_105:
        unint64_t v53 = (unint64_t)v23;
        if (v22 < *v23) {
          goto LABEL_112;
        }
      }
    }
    unint64_t v54 = v22 + (v22 >> 2);
    if (v54 <= v22 + 1) {
      unint64_t v54 = v22 + 1;
    }
    size_t v55 = malloc_good_size(8 * v54 + 8);
    uint64_t v56 = malloc_type_malloc(v55, 0x1000D770uLL);
    if (!v56) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    unint64_t v53 = (unint64_t)v56;
    *uint64_t v56 = (v55 + 0x7FFFFFFF8) >> 3;
    if (v23)
    {
      memcpy(v56 + 2, v23 + 2, 8 * v22);
      int v57 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
      *int v57 = qword_1E8ECF988;
      v57[1] = v23;
      qword_1E8ECF988 = (uint64_t)v57;
    }
    atomic_store(v53, (unint64_t *)&qword_1E8ECF970);
LABEL_112:
    __int16 v84 = 20;
    uint64_t explicit = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v84, 0x50uLL, 8);
    unint64_t v58 = v83;
    *(void *)uint64_t explicit = v83;
    uint64_t GenericContext = (unsigned __int16 *)swift::TargetContextDescriptor<swift::InProcess>::getGenericContext(v58);
    *((void *)explicit + 2) = 0;
    *((void *)explicit + 3) = 0;
    *((void *)explicit + 1) = 0;
    *((_DWORD *)explicit + 8) = 0;
    *((void *)explicit + 5) = 0;
    *((void *)explicit + 6) = 0;
    *((_DWORD *)explicit + 14) = 0;
    unint64_t v60 = (char *)(GenericContext + 6);
    unint64_t v61 = (_DWORD *)(((unint64_t)GenericContext + GenericContext[2] + 15) & 0xFFFFFFFFFFFFFFFCLL);
    if (GenericContext[5])
    {
      unint64_t v62 = &v61[3 * GenericContext[3]];
      int v63 = *v62;
      if ((unsigned __int16)*v62)
      {
        long long v64 = &v62[GenericContext[5] & 1];
LABEL_117:
        uint64_t v65 = *(void *)(GenericContext + 2);
        *((_DWORD *)explicit + 16) = 0;
        *((_DWORD *)explicit + 17) = v63;
        *((void *)explicit + 9) = v64;
        uint64_t v66 = (unsigned __int16)v65;
        if ((_WORD)v65)
        {
          int v67 = 0;
          do
          {
            if (*v60 < 0) {
              explicit[32] = ++v67;
            }
            ++v60;
            --v66;
          }
          while (v66);
        }
        if ((v65 & 0xFFFF0000) != 0)
        {
          int v68 = 0;
          uint64_t v69 = 12 * WORD1(v65);
          do
          {
            if ((*v61 & 0x9F) == 0x80) {
              explicit[33] = ++v68;
            }
            v61 += 3;
            v69 -= 12;
          }
          while (v69);
        }
        *(void *)(v53 + 8 + 8 * v22) = explicit;
        atomic_store(v29, (unsigned int *)&dword_1E8ECF96C);
        switch(v35)
        {
          case 1u:
            unint64_t v70 = v36 & 0xFFFFFFFFFFFFFFFCLL;
            if ((v36 & 3) == 0) {
              unint64_t v70 = 0;
            }
            atomic_store(v29, (unsigned __int8 *)(v70 + v35));
            break;
          case 2u:
            unint64_t v71 = v36 & 0xFFFFFFFFFFFFFFFCLL;
            if ((v36 & 3) == 0) {
              unint64_t v71 = 0;
            }
            atomic_store(v29, (unsigned __int16 *)(v71 + 2 * v35));
            break;
          case 3u:
            unint64_t v72 = v36 & 0xFFFFFFFFFFFFFFFCLL;
            if ((v36 & 3) == 0) {
              unint64_t v72 = 0;
            }
            atomic_store(v29, (unsigned int *)(v72 + 4 * v35));
            break;
          default:
            atomic_store((v29 << (4 * v35)) | v36, (unint64_t *)&qword_1E8ECF978);
            break;
        }
        __dmb(0xBu);
          goto LABEL_142;
        long long v73 = (void **)qword_1E8ECF988;
        if (qword_1E8ECF988)
        {
          do
          {
            long long v74 = (void **)*v73;
            free(v73[1]);
            free(v73);
            long long v73 = v74;
          }
          while (v74);
        }
        goto LABEL_141;
      }
    }
    else
    {
      int v63 = 0;
    }
    long long v64 = 0;
    goto LABEL_117;
  }
LABEL_23:
  uint64_t v10 = (uint64_t)v6 + v7;
  if (!(_DWORD *)((char *)v6 + v7)) {
    goto LABEL_26;
  }
  context[0] = (unint64_t)v6 + v7;
  context[1] = swift::TargetContextDescriptor<swift::InProcess>::getGenericContext(a1);
  if (*(void *)(v10 + 72) != -1) {
  return (_WORD *)v10;
  }
}

uint64_t swift::MetadataCacheKey::MetadataCacheKey(uint64_t result, _OWORD *a2, uint64_t a3)
{
  *(void *)unint64_t result = a3;
  *(_OWORD *)(result + 8) = *a2;
  uint64_t v3 = *(unsigned __int16 *)(result + 8);
  uint64_t v4 = (1455063249 * v3);
  if (*(_WORD *)(result + 8))
  {
    unint64_t v5 = 0;
    uint64_t v6 = *(void *)(result + 16);
    uint64_t v7 = *(unsigned __int16 *)(result + 14);
    uint64_t v8 = v7 + v3;
    do
    {
      if (v5 >= *(unsigned __int16 *)(result + 12)
        || *(_WORD *)(v6 + 8 * v5)
        || (uint64_t v9 = v6 + 8 * v5, v7 != *(unsigned __int16 *)(v9 + 2)))
      {
        uint64_t v4 = __ROR8__(v4, 10) ^ (*(void *)(a3 + 8 * v7) >> 19) ^ *(void *)(a3 + 8 * v7);
      }
      else
      {
        unint64_t v10 = *(void *)(a3 + 8 * *(unsigned __int16 *)(v9 + 4));
        ++v5;
        if (v10)
        {
          uint64_t v11 = 0;
          do
          {
            uint64_t v4 = __ROR8__(v4, 10) ^ (*(void *)((*(void *)(a3 + 8 * v7) & 0xFFFFFFFFFFFFFFFELL) + 8 * v11) >> 19) ^ *(void *)((*(void *)(a3 + 8 * v7) & 0xFFFFFFFFFFFFFFFELL) + 8 * v11);
            ++v11;
          }
          while (v10 > v11);
        }
      }
      ++v7;
    }
    while (v7 != v8);
  }
  *(_DWORD *)(result + 24) = (unint64_t)(668265261 * v4) >> 10;
  return result;
}

void swift::LockingConcurrentMap<anonymous namespace'::GenericCacheEntry,swift::LockingConcurrentMapStorage<anonymous namespace'::GenericCacheEntry,(unsigned short)14>>::getOrInsert<swift::MetadataCacheKey,swift::MetadataRequest &,swift::TargetMetadata<swift::InProcess> const*&>(uint64_t a1@<X0>, _OWORD *a2@<X1>, void *a3@<X2>, uint64_t *a4@<X3>, atomic_ullong **a5@<X8>)
{
  uint64_t v7 = (os_unfair_lock_s *)(a1 + 48);
  uint64_t v18 = a1 + 48;
  uint64_t v19 = 0;
  __int16 v20 = 0;
  long long v8 = a2[1];
  v17[0] = *a2;
  v17[1] = v8;
  unint64_t v10 = v9;
  if ((v11 & 1) == 0)
  {
LABEL_8:
    *a5 = v10;
    a5[1] = (atomic_ullong *)v12;
    goto LABEL_10;
  }
  if (v19) {
    LOBYTE(v2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 1;
  }
  if (HIBYTE(v20) != 4)
  {
    if (!HIBYTE(v20)) {
      abort();
    }
    goto LABEL_8;
  }
  unint64_t v13 = 0;
  atomic_ullong v14 = v9[4];
  *a5 = v9;
  a5[1] = (atomic_ullong *)v14;
LABEL_10:
  a5[2] = v13;
  BOOL v15 = v19;
  if (v19)
  {
    os_unfair_lock_unlock(v19 + 2);
    uint64_t v16 = *(void *)&v15[4]._os_unfair_lock_opaque;
    *(void *)&v15[4]._os_unfair_lock_opaque = 0;
    if (v16) {
      MEMORY[0x1852FF000](v16, 0x80C4018A671A6);
    }
    swift_slowDealloc(v15);
  }
}

Class *swift_getGenericMetadata(__int16 a1, uint64_t a2, int *a3)
{
  return _swift_getGenericMetadata(a1, a2, a3);
}

Class *_swift_getGenericMetadata(__int16 a1, uint64_t a2, int *a3)
{
  Cache = getCache(a3);
  uint64_t v7 = (uint64_t)Cache;
  uint64_t v8 = (unsigned __int16)Cache[28];
  __int16 v9 = Cache[29];
  unint64_t v10 = (unsigned __int16)Cache[30];
  uint64_t v11 = (unsigned __int16)Cache[31];
  uint64_t v12 = *((void *)Cache + 8);
  unint64_t v13 = (1455063249 * v8);
  if (Cache[28])
  {
    unint64_t v14 = 0;
    uint64_t v15 = (unsigned __int16)Cache[31];
    do
    {
      if (v14 >= v10 || *(_WORD *)(v12 + 8 * v14) || (uint64_t v16 = v12 + 8 * v14, v15 != *(unsigned __int16 *)(v16 + 2)))
      {
        unint64_t v13 = __ROR8__(v13, 10) ^ (*(void *)(a2 + 8 * v15) >> 19) ^ *(void *)(a2 + 8 * v15);
      }
      else
      {
        unint64_t v17 = *(void *)(a2 + 8 * *(unsigned __int16 *)(v16 + 4));
        ++v14;
        if (v17)
        {
          uint64_t v18 = 0;
          do
          {
            unint64_t v19 = *(void *)((*(void *)(a2 + 8 * v15) & 0xFFFFFFFFFFFFFFFELL) + 8 * v18);
            unint64_t v13 = __ROR8__(v13, 10) ^ (v19 >> 19) ^ v19;
            ++v18;
          }
          while (v17 > v18);
        }
      }
      ++v15;
    }
    while (v15 != v11 + v8);
  }
  __int16 v20 = (os_unfair_lock_s *)(v7 + 48);
  os_unfair_lock_t v121 = (os_unfair_lock_t)(v7 + 48);
  uint64_t v122 = 0;
  __int16 v123 = 0;
  *(void *)&long long v124 = a2;
  WORD4(v124) = v8;
  WORD5(v124) = v9;
  WORD6(v124) = v10;
  HIWORD(v124) = v11;
  *(void *)&long long v125 = v12;
  DWORD2(v125) = (668265261 * v13) >> 10;
  uint64_t explicit = (_WORD *)atomic_load_explicit((atomic_ullong *volatile)(v7 + 40), memory_order_acquire);
  if (explicit)
  {
    int v22 = *((_DWORD *)explicit + 6);
    v128 = explicit + 20;
    long long v129 = *(_OWORD *)(explicit + 4);
    LODWORD(v13swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v22;
    if (swift::MetadataCacheKey::operator==((uint64_t)&v124, (uint64_t)&v128)) {
      goto LABEL_21;
    }
  }
  atomic_fetch_add_explicit((atomic_uint *volatile)v7, 1u, memory_order_acquire);
  do
  {
    unint64_t v23 = atomic_load_explicit((atomic_ullong *volatile)(v7 + 8), memory_order_acquire);
    unint64_t v24 = atomic_load_explicit((atomic_ullong *volatile)(v7 + 16), memory_order_acquire);
    uint64_t v25 = atomic_load_explicit((atomic_uint *volatile)(v7 + 4), memory_order_acquire);
  }
  while (v23 != atomic_load_explicit((atomic_ullong *volatile)(v7 + 8), memory_order_acquire));
  if (v23) {
    unint64_t v26 = v23 + 8;
  }
  else {
    unint64_t v26 = 0;
  }
  v128 = (_WORD *)v7;
  *(void *)&long long v129 = v24;
  *((void *)&v129 + 1) = v26;
  uint64_t v130 = v25;
  if (v27)
  {
    *(void *)(v7 + 4swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = *v27;
    uint64_t explicit = (_WORD *)*v27;
    atomic_fetch_add_explicit((atomic_uint *volatile)v7, 0xFFFFFFFF, memory_order_release);
    goto LABEL_21;
  }
  atomic_fetch_add_explicit((atomic_uint *volatile)v7, 0xFFFFFFFF, memory_order_release);
  long long v126 = v124;
  long long v127 = v125;
  LODWORD(v32) = v7 + 24;
  os_unfair_lock_lock((os_unfair_lock_t)(v7 + 24));
  unint64_t v33 = *(void *)(v7 + 16);
  uint64_t v34 = (unsigned __int8 *)(v33 & 0xFFFFFFFFFFFFFFFCLL);
  __int16 v117 = a1;
  unint64_t v118 = v33;
  unint64_t v35 = v33 & 3;
  unsigned __int8 v115 = a3;
  locint k = (os_unfair_lock_s *)(v7 + 24);
  if (v35 && v34)
  {
    int v36 = *v34;
    unsigned int v37 = *(_DWORD *)(v7 + 4);
    unint64_t v38 = *(_DWORD **)(v7 + 8);
    BOOL v39 = v38 == 0;
    BOOL v110 = v38 == 0;
    long long v112 = v38;
    uint64_t v40 = v38 + 2;
    __src = v40;
    if (v39) {
      uint64_t v40 = 0;
    }
    uint64_t v119 = (uint64_t)v40;
  }
  else
  {
    unsigned int v37 = *(_DWORD *)(v7 + 4);
    uint64_t v41 = *(_DWORD **)(v7 + 8);
    BOOL v39 = v41 == 0;
    BOOL v110 = v41 == 0;
    long long v112 = v41;
    uint64_t v42 = v41 + 2;
    __src = v42;
    if (v39) {
      uint64_t v42 = 0;
    }
    uint64_t v119 = (uint64_t)v42;
    int v36 = 4;
  }
  int v108 = v36;
  unint64_t v43 = v37;
  uint64_t v44 = DWORD2(v127);
  uint64_t v45 = ~(-1 << v36);
  if (v35) {
    unint64_t v46 = v34;
  }
  else {
    unint64_t v46 = 0;
  }
  while (2)
  {
    if ((v44 & (unint64_t)v45) <= 1) {
      uint64_t v47 = 1;
    }
    else {
      uint64_t v47 = v44 & v45;
    }
    switch(v118 & 3)
    {
      case 1uLL:
        LOBYTE(v32) = atomic_load_explicit((atomic_uchar *volatile)&v46[v47], memory_order_acquire);
        if (v32) {
          goto LABEL_50;
        }
        goto LABEL_54;
      case 2uLL:
        LOWORD(v32) = atomic_load_explicit((atomic_ushort *volatile)&v46[2 * v47], memory_order_acquire);
        if (!v32) {
          goto LABEL_54;
        }
        goto LABEL_50;
      case 3uLL:
        LODWORD(v32) = atomic_load_explicit((atomic_uint *volatile)&v46[4 * v47], memory_order_acquire);
        if (v32) {
          goto LABEL_50;
        }
        goto LABEL_54;
      default:
        uint64_t v32 = (v118 >> (4 * v47)) & 0xF;
        if (!v32)
        {
LABEL_54:
          uint64_t v107 = (v43 + 1);
          if ((1 << v108) / (unint64_t)((1 << v108) - v107) > 3)
          {
            uint64_t v52 = DWORD2(v127);
            unint64_t v53 = (char *)(v51 & 0xFFFFFFFFFFFFFFFCLL);
            char v54 = 4;
            unint64_t v118 = v51;
            if ((v51 & 3) != 0 && v53) {
              char v54 = *v53;
            }
            uint64_t v55 = ~(-1 << v54);
            unint64_t v56 = v51 & 3;
            if ((v51 & 3) != 0) {
              unint64_t v57 = v51 & 0xFFFFFFFFFFFFFFFCLL;
            }
            else {
              unint64_t v57 = 0;
            }
            while (1)
            {
              unint64_t v58 = v52 & v55;
              uint64_t v47 = v58 <= 1 ? 1 : v58;
              switch(v56)
              {
                case 1uLL:
                  LODWORD(v59) = v57 + v47;
                  LOBYTE(v59) = atomic_load_explicit((atomic_uchar *volatile)(v57 + v47), memory_order_acquire);
                  break;
                case 2uLL:
                  LODWORD(v59) = v57 + 2 * v47;
                  LOWORD(v59) = atomic_load_explicit((atomic_ushort *volatile)(v57 + 2 * v47), memory_order_acquire);
                  break;
                case 3uLL:
                  LODWORD(v59) = atomic_load_explicit((atomic_uint *volatile)(v57 + 4 * v47), memory_order_acquire);
                  break;
                default:
                  uint64_t v59 = (v118 >> (4 * v47)) & 0xF;
                  break;
              }
              if (!v59) {
                break;
              }
              unsigned int v60 = v59 - 1;
              if (v60 < v43)
              {
                uint64_t v61 = *(void *)(v119 + 8 * v60);
                int v62 = *(_DWORD *)(v61 + 24);
                v128 = (_WORD *)(v61 + 40);
                long long v129 = *(_OWORD *)(v61 + 8);
                LODWORD(v13swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v62;
                if (swift::MetadataCacheKey::operator==((uint64_t)&v126, (uint64_t)&v128))
                {
                  uint64_t v63 = 0;
                  goto LABEL_75;
                }
              }
              uint64_t v52 = v47 + 1;
            }
          }
          uint64_t v63 = v47;
LABEL_75:
          uint64_t v120 = v63;
          if (v110 || v43 >= *v112)
          {
            unint64_t v65 = v43 + (v43 >> 2);
            if (v65 <= v43 + 1) {
              unint64_t v65 = v43 + 1;
            }
            size_t v66 = malloc_good_size(8 * v65 + 8);
            int v67 = malloc_type_malloc(v66, 0x1000D770uLL);
            if (!v67) {
              swift::hashable_support::findHashableBaseTypeOfHashableType();
            }
            unint64_t v64 = (unint64_t)v67;
            *int v67 = (v66 + 0x7FFFFFFF8) >> 3;
            if (!v110)
            {
              memcpy(v67 + 2, __src, 8 * v43);
              int v68 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
              *int v68 = *(void *)(v7 + 32);
              v68[1] = v112;
              *(void *)(v7 + 32) = v68;
            }
            atomic_store(v64, (unint64_t *)(v7 + 8));
          }
          else
          {
            unint64_t v64 = (unint64_t)v112;
          }
          LOWORD(v128) = 14;
          uint64_t explicit = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v128, 8 * (WORD4(v124) + (unint64_t)HIWORD(v124) + WORD5(v124)) + 40, 8);
          uint64_t v69 = (const void *)v124;
          __int16 v70 = WORD4(v124);
          __int16 v71 = WORD5(v124);
          uint64_t v72 = WORD6(v124);
          __int16 v73 = HIWORD(v124);
          uint64_t v74 = v125;
          int v75 = DWORD2(v125);
          HIBYTE(v123) = 0;
          unint64_t v76 = (unint64_t)v122;
          if (!v122)
          {
            uint64_t v111 = v125;
            long long v113 = (const void *)v124;
            __int16 v109 = WORD4(v124);
            int __srca = DWORD2(v125);
            unint64_t v76 = (unint64_t)swift_slowAlloc(0x30uLL, 0xFuLL);
            *(_OWORD *)unint64_t v76 = 0u;
            *(_OWORD *)(v76 + 16) = 0u;
            *(_OWORD *)(v76 + 32) = 0u;
            *(void *)unint64_t v76 = 1;
            *(void *)(v76 + 16) = 0;
            *(void *)(v76 + 24) = 0;
            os_unfair_lock_lock((os_unfair_lock_t)(v76 + 8));
            int v75 = __srca;
            __int16 v70 = v109;
            uint64_t v74 = v111;
            uint64_t v69 = v113;
            uint64_t v122 = (os_unfair_lock_s *)v76;
          }
          unint64_t v114 = v64 + 8;
          *(void *)uint64_t explicit = v76 | 8;
          explicit[4] = v70;
          explicit[5] = v71;
          explicit[6] = v72;
          explicit[7] = v73;
          *((void *)explicit + 2) = v74;
          *((_DWORD *)explicit + 6) = v75;
          *((void *)explicit + 4) = 0;
          unint64_t v77 = explicit + 20;
          size_t v78 = 8 * (unsigned __int16)(v71 + v70 + v73);
          uint64_t v79 = v74;
          memcpy(explicit + 20, v69, v78);
          uint64_t v80 = v115;
          if (v72)
          {
            uint64_t v81 = (unsigned __int16 *)(v79 + 4);
            do
            {
              uint64_t v84 = *(v81 - 1);
              unint64_t v85 = *(void *)&v77[4 * *v81];
              if (*(v81 - 2) == 1)
              {
                uint64_t v82 = 4 * v84;
                WitnessTablePacint k = swift_allocateWitnessTablePack(*(void *)&v77[4 * v84], v85);
              }
              else
              {
                if (*(v81 - 2)) {
                  goto LABEL_90;
                }
                uint64_t v82 = 4 * v84;
                WitnessTablePacint k = swift_allocateMetadataPack(*(void *)&v77[4 * v84], v85);
              }
              *(void *)&v77[v82] = WitnessTablePack;
LABEL_90:
              v81 += 4;
              --v72;
            }
            while (v72);
          }
          *(void *)(v114 + 8 * v43) = explicit;
          atomic_store(v107, (unsigned int *)(v7 + 4));
          a1 = v117;
          switch(v118 & 3)
          {
            case 1uLL:
              unint64_t v86 = v118 & 0xFFFFFFFFFFFFFFFCLL;
              if ((v118 & 3) == 0) {
                unint64_t v86 = 0;
              }
              atomic_store(v43 + 1, (unsigned __int8 *)(v86 + v120));
              break;
            case 2uLL:
              unint64_t v87 = v118 & 0xFFFFFFFFFFFFFFFCLL;
              if ((v118 & 3) == 0) {
                unint64_t v87 = 0;
              }
              atomic_store(v43 + 1, (unsigned __int16 *)(v87 + 2 * v120));
              break;
            case 3uLL:
              unint64_t v88 = v118 & 0xFFFFFFFFFFFFFFFCLL;
              if ((v118 & 3) == 0) {
                unint64_t v88 = 0;
              }
              atomic_store(v107, (unsigned int *)(v88 + 4 * v120));
              break;
            default:
              atomic_store((v107 << (4 * v120)) | v118, (unint64_t *)(v7 + 16));
              break;
          }
          __dmb(0xBu);
          if (*(_DWORD *)v7)
          {
            os_unfair_lock_unlock(lock);
            *(void *)(v7 + 4swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = explicit;
          }
          else
          {
            long long v89 = *(void ***)(v7 + 32);
            if (v89)
            {
              do
              {
                int v90 = (void **)*v89;
                free(v89[1]);
                free(v89);
                long long v89 = v90;
              }
              while (v90);
            }
LABEL_113:
            *(void *)(v7 + 32) = 0;
            os_unfair_lock_unlock(lock);
            *(void *)(v7 + 4swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = explicit;
            __int16 v20 = (os_unfair_lock_s *)(v7 + 48);
            if (v32) {
              goto LABEL_21;
            }
          }
          if (v122) {
            LOBYTE(v123) = 1;
          }
          if (HIBYTE(v123))
          {
            if (HIBYTE(v123) == 4)
            {
              LibPrespecializedMetadata = (Class *)*((void *)explicit + 4);
              goto LABEL_22;
            }
            goto LABEL_145;
          }
          LibPrespecializedMetadata = (Class *)swift::getLibPrespecializedMetadata((uint64_t)v80);
          if (LibPrespecializedMetadata)
          {
LABEL_120:
            HIBYTE(v123) = 4;
            *((void *)explicit + 4) = LibPrespecializedMetadata;
            uint64_t v93 = v121;
            os_unfair_lock_lock(v121);
            atomic_store(4uLL, (unint64_t *)explicit);
            uint64_t v94 = v122;
            os_unfair_lock_unlock(v122 + 2);
            if (*(void *)&v122->_os_unfair_lock_opaque == 1)
            {
              uint64_t v95 = *(void *)&v122[4]._os_unfair_lock_opaque;
              *(void *)&v122[4]._os_unfair_lock_opaque = 0;
              if (v95) {
                MEMORY[0x1852FF000](v95, 0x80C4018A671A6);
              }
              swift_slowDealloc(v94);
            }
            else
            {
              --*(void *)&v122->_os_unfair_lock_opaque;
            }
            os_unfair_lock_unlock(v93);
            uint64_t v122 = 0;
            if (swift::runtime::environment::initializeToken != -1) {
              dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
            }
            if (swift::runtime::environment::SWIFT_DEBUG_VALIDATE_EXTERNAL_GENERIC_METADATA_BUILDER_variable) {
              swift::validateExternalGenericMetadataBuilder(LibPrespecializedMetadata, v80, a2);
            }
            goto LABEL_22;
          }
          __int16 v96 = a1;
          FullGenericContextHeader = swift::TargetTypeContextDescriptor<swift::InProcess>::getFullGenericContextHeader(v80);
          uint64_t v98 = (int)FullGenericContextHeader[1];
          if (v98) {
            long long v99 = (_DWORD *)((char *)FullGenericContextHeader + v98 + 4);
          }
          else {
            long long v99 = 0;
          }
          uint64_t v100 = *v99;
          if (v100) {
            long long v101 = (uint64_t *)((uint64_t (*)(int *, uint64_t, int *))((char *)v99 + v100))(v80, a2, v99);
          }
          else {
            long long v101 = (uint64_t *)MEMORY[0](v80, a2, v99);
          }
          LibPrespecializedMetadata = (Class *)v101;
          if (v99[1])
          {
            if ((*(unsigned char *)(*(v101 - 1) + 82) & 0x40) != 0) {
              char v103 = 1;
            }
            else {
              char v103 = 2;
            }
            a1 = v96;
          }
          else
          {
            if (areAllTransitiveMetadataComplete_cheap(v101)) {
              goto LABEL_120;
            }
            a1 = v96;
            char v103 = 3;
          }
          HIBYTE(v123) = v103;
          *((void *)explicit + 4) = LibPrespecializedMetadata;
LABEL_145:
          long long v104 = (Class *)*((void *)explicit + 4);
          if (swift::runtime::environment::initializeToken != -1) {
            dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
          }
          if (swift::runtime::environment::SWIFT_DEBUG_VALIDATE_EXTERNAL_GENERIC_METADATA_BUILDER_variable) {
            swift::validateExternalGenericMetadataBuilder(v104, v80, a2);
          }
          goto LABEL_22;
        }
LABEL_50:
        uint64_t v48 = (v32 - 1);
        if (v48 >= v43 {
          || (uint64_t v49 = *(void *)(v119 + 8 * v48),
        }
              int v50 = *(_DWORD *)(v49 + 24),
              v128 = (_WORD *)(v49 + 40),
              long long v129 = *(_OWORD *)(v49 + 8),
              LODWORD(v13swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v50,
              (swift::MetadataCacheKey::operator==((uint64_t)&v126, (uint64_t)&v128) & 1) == 0))
        {
          uint64_t v44 = v47 + 1;
          continue;
        }
        uint64_t explicit = *(_WORD **)(v119 + 8 * v48);
        __dmb(0xBu);
        if (*(_DWORD *)v7)
        {
          os_unfair_lock_unlock(lock);
          *(void *)(v7 + 4swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = explicit;
          a1 = v117;
          __int16 v20 = (os_unfair_lock_s *)(v7 + 48);
          goto LABEL_21;
        }
        long long v91 = *(void ***)(v7 + 32);
        a1 = v117;
        if (v91)
        {
          do
          {
            uint64_t v92 = (void **)*v91;
            free(v91[1]);
            free(v91);
            long long v91 = v92;
          }
          while (v92);
          uint64_t v80 = v115;
          goto LABEL_113;
        }
        *(void *)(v7 + 32) = 0;
        os_unfair_lock_unlock(lock);
        *(void *)(v7 + 4swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = explicit;
        __int16 v20 = (os_unfair_lock_s *)(v7 + 48);
LABEL_21:
LABEL_22:
        uint64_t v29 = v122;
        if (v122)
        {
          os_unfair_lock_unlock(v122 + 2);
          uint64_t v30 = *(void *)&v29[4]._os_unfair_lock_opaque;
          *(void *)&v29[4]._os_unfair_lock_opaque = 0;
          if (v30) {
            MEMORY[0x1852FF000](v30, 0x80C4018A671A6);
          }
          swift_slowDealloc(v29);
        }
        return LibPrespecializedMetadata;
    }
  }
}

Class *swift_getCanonicalPrespecializedGenericMetadata(__int16 a1, uint64_t a2, int *a3, dispatch_once_t *predicate)
{
  if (a3)
  {
    uint64_t v6 = a3;
    uint64_t v7 = a3;
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
  }
  if (*predicate != -1) {
    dispatch_once_f(predicate, v7, (dispatch_function_t)cacheCanonicalSpecializedMetadata(swift::TargetTypeContextDescriptor<swift::InProcess> const*,long *)::$_0::__invoke);
  }

  return _swift_getGenericMetadata(a1, a2, v6);
}

uint64_t swift_getSingletonMetadata(__int16 a1, _DWORD *a2)
{
  if (a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = 0;
  }
  if (qword_1EB1F8890 != -1) {
  uint64_t v41 = &SingletonMetadata;
  }
  unint64_t v42 = 0;
  __int16 v43 = 0;
  int v4 = *v3 & 0x1F;
  if (v4 == 16)
  {
    if (v3) {
      uint64_t v6 = v3;
    }
    else {
      uint64_t v6 = 0;
    }
    if (v6) {
      __int16 v9 = v6;
    }
    else {
      __int16 v9 = 0;
    }
    unint64_t TrailingObjectsImpl = swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v9);
    unint64_t v14 = *(unsigned int *)v9;
    unint64_t v11 = TrailingObjectsImpl + 4 * ((v14 >> 29) & 1);
  }
  else
  {
    if (v4 == 17)
    {
      if (v3) {
        uint64_t v7 = v3;
      }
      else {
        uint64_t v7 = 0;
      }
      if (v7) {
        unint64_t v10 = v7;
      }
      else {
        unint64_t v10 = 0;
      }
      unint64_t v11 = swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetStructDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetStructDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v10);
      uint64_t v12 = v10;
    }
    else
    {
      if (v4 != 18) {
        goto LABEL_79;
      }
      if (v3) {
        unint64_t v5 = v3;
      }
      else {
        unint64_t v5 = 0;
      }
      if (v5) {
        uint64_t v8 = v5;
      }
      else {
        uint64_t v8 = 0;
      }
      unint64_t v11 = swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetEnumDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetEnumDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v8);
      uint64_t v12 = v8;
    }
    LODWORD(v14) = *v12;
  }
  uint64_t v15 = (int *)(v11 + 4 * ((v14 & 0x30000) == 0x20000));
  uint64_t v16 = *v15;
  unint64_t v17 = (atomic_ullong *)((char *)v15 + v16);
  if (v16) {
    uint64_t v18 = v17;
  }
  else {
    uint64_t v18 = 0;
  }
  uint64_t explicit = (atomic_ullong *)atomic_load_explicit(v18 + 1, memory_order_acquire);
  if (explicit)
  {
LABEL_46:
    goto LABEL_47;
  }
  __int16 v20 = swift_slowAlloc(0x10uLL, 7uLL);
  HIBYTE(v43) = 0;
  unint64_t v21 = (unint64_t)swift_slowAlloc(0x30uLL, 0xFuLL);
  *(_OWORD *)unint64_t v21 = 0u;
  *(_OWORD *)(v21 + 16) = 0u;
  *(_OWORD *)(v21 + 32) = 0u;
  *(void *)unint64_t v21 = 1;
  *(void *)(v21 + 16) = 0;
  *(void *)(v21 + 24) = 0;
  os_unfair_lock_lock((os_unfair_lock_t)(v21 + 8));
  unint64_t v42 = v21;
  uint64_t explicit = 0;
  void *v20 = v21 | 8;
  v20[1] = 0;
  atomic_compare_exchange_strong(v18 + 1, (unint64_t *)&explicit, (unint64_t)v20);
  if (explicit)
  {
    swift_slowDealloc(v20);
    goto LABEL_46;
  }
  if (v42) {
    LOBYTE(v43) = 1;
  }
  if (HIBYTE(v43) != 4)
  {
    if (HIBYTE(v43))
    {
LABEL_78:
LABEL_47:
      uint64_t v25 = v24;
      unint64_t v26 = v42;
      if (!v42) {
        return v25;
      }
      goto LABEL_48;
    }
    int v22 = *v3 & 0x1F;
    switch(v22)
    {
      case 16:
        if (v3) {
          uint64_t v29 = v3;
        }
        else {
          uint64_t v29 = 0;
        }
        if (v29) {
          uint64_t v32 = v29;
        }
        else {
          uint64_t v32 = 0;
        }
        unint64_t v36 = swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v32);
        unint64_t v37 = *(unsigned int *)v32;
        unint64_t v34 = v36 + 4 * ((v37 >> 29) & 1);
        goto LABEL_74;
      case 17:
        if (v3) {
          uint64_t v30 = v3;
        }
        else {
          uint64_t v30 = 0;
        }
        if (v30) {
          unint64_t v33 = v30;
        }
        else {
          unint64_t v33 = 0;
        }
        unint64_t v34 = swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetStructDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetStructDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v33);
        unint64_t v35 = v33;
        goto LABEL_73;
      case 18:
        if (v3) {
          unint64_t v23 = v3;
        }
        else {
          unint64_t v23 = 0;
        }
        if (v23) {
          unsigned int v31 = v23;
        }
        else {
          unsigned int v31 = 0;
        }
        unint64_t v34 = swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetEnumDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetEnumDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v31);
        unint64_t v35 = v31;
LABEL_73:
        LODWORD(v37) = *v35;
LABEL_74:
        unint64_t v38 = swift::TargetSingletonMetadataInitialization<swift::InProcess>::allocate(v34 + 4 * ((v37 & 0x30000) == 0x20000), v3);
        if ((*(_DWORD *)(*((void *)v38 - 1) + 80) & 0x400000) != 0) {
          char v40 = 1;
        }
        else {
          char v40 = 2;
        }
        HIBYTE(v43) = v40;
        v20[1] = v38;
        goto LABEL_78;
    }
LABEL_79:
    abort();
  }
  uint64_t v25 = v20[1];
  unint64_t v26 = v42;
  if (!v42) {
    return v25;
  }
LABEL_48:
  os_unfair_lock_unlock((os_unfair_lock_t)(v26 + 8));
  uint64_t v27 = *(void *)(v26 + 16);
  *(void *)(v26 + 16) = 0;
  if (v27) {
    MEMORY[0x1852FF000](v27, 0x80C4018A671A6);
  }
  swift_slowDealloc((void *)v26);
  return v25;
}

_DWORD *swift::Lazy<anonymous namespace'::SingletonTypeMetadataCache>::defaultInitCallback(_DWORD *result)
{
  *unint64_t result = 0;
  return result;
}

unint64_t swift_getObjCClassMetadata(unint64_t result)
{
  if (result && (*(unsigned char *)(result + 32) & 2) == 0)
  {
    unint64_t v64 = result;
    unint64_t explicit = atomic_load_explicit(&qword_1EB208978, memory_order_acquire);
    if (explicit && *(void *)(explicit + 24) == v64) {
      goto LABEL_107;
    }
    atomic_fetch_add_explicit(&ObjCClassWrappers, 1u, memory_order_acquire);
    do
    {
      unint64_t v2 = atomic_load_explicit(&qword_1EB208958, memory_order_acquire);
      unint64_t v3 = atomic_load_explicit(&qword_1EB208960, memory_order_acquire);
      unint64_t v4 = atomic_load_explicit(&dword_1EB208954, memory_order_acquire);
    }
    while (v2 != atomic_load_explicit(&qword_1EB208958, memory_order_acquire));
    if (v2) {
      BOOL v5 = v3 == 0;
    }
    else {
      BOOL v5 = 1;
    }
    if (!v5 && v4 != 0)
    {
      if (v7)
      {
        qword_1EB208978 = *v7;
        unint64_t explicit = *v7;
        atomic_fetch_add_explicit(&ObjCClassWrappers, 0xFFFFFFFF, memory_order_release);
        goto LABEL_107;
      }
    }
    atomic_fetch_add_explicit(&ObjCClassWrappers, 0xFFFFFFFF, memory_order_release);
    unint64_t v65 = v64;
    os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB208968);
    unint64_t v8 = qword_1EB208960;
    uint64_t v9 = qword_1EB208960 & 3;
    BOOL v10 = v9 == 0;
    if ((qword_1EB208960 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
      BOOL v10 = 1;
    }
    BOOL v63 = v10;
    if (v10) {
      int v11 = 4;
    }
    else {
      int v11 = *(unsigned __int8 *)(qword_1EB208960 & 0xFFFFFFFFFFFFFFFCLL);
    }
    unint64_t v12 = dword_1EB208954;
    unint64_t v13 = (_DWORD *)qword_1EB208958;
    if (qword_1EB208958) {
      uint64_t v14 = qword_1EB208958 + 8;
    }
    else {
      uint64_t v14 = 0;
    }
    if (v15)
    {
      unint64_t explicit = *v15;
      __dmb(0xBu);
      if (ObjCClassWrappers)
      {
LABEL_106:
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB208968);
        qword_1EB208978 = explicit;
LABEL_107:
        if (explicit) {
          return explicit + 16;
        }
        else {
          return 0;
        }
      }
      unint64_t v17 = (void **)qword_1EB208970;
      if (qword_1EB208970)
      {
        do
        {
          uint64_t v18 = (void **)*v17;
          free(v17[1]);
          free(v17);
          unint64_t v17 = v18;
        }
        while (v18);
      }
LABEL_105:
      qword_1EB208970 = 0;
      goto LABEL_106;
    }
    uint64_t v62 = v14;
    uint64_t v19 = (v12 + 1);
    if ((1 << v11) / (unint64_t)((1 << v11) - v19) < 4)
    {
      unsigned int v25 = v16;
      unint64_t v26 = v8;
      if (!v13) {
        goto LABEL_83;
      }
    }
    else
    {
      unsigned int v20 = (v11 + 1);
      if (v20 >= 0x11) {
        unsigned int v21 = 4;
      }
      else {
        unsigned int v21 = 2;
      }
      if (v20 < 9) {
        size_t v22 = 1;
      }
      else {
        size_t v22 = v21;
      }
      unint64_t v23 = (unint64_t)malloc_type_calloc(2 << v11, v22, 0x4269077AuLL);
      if (!v23) {
        swift::hashable_support::findHashableBaseTypeOfHashableType();
      }
      uint64_t v24 = v62;
      unint64_t v60 = v12;
      uint64_t v61 = (v12 + 1);
      if (v22 != 1)
      {
        if (v22 == 4) {
          size_t v22 = 3;
        }
        else {
          size_t v22 = 2;
        }
      }
      unint64_t v26 = v22 | v23;
      *(unsigned char *)unint64_t v23 = v11 + 1;
      if (v11)
      {
        unint64_t v27 = v8 & 3;
        if (v9) {
          unint64_t v28 = v8 & 0xFFFFFFFFFFFFFFFCLL;
        }
        else {
          unint64_t v28 = 0;
        }
        unint64_t v29 = v26 & 3;
        if ((v26 & 3) != 0) {
          unint64_t v30 = v23 & 0xFFFFFFFFFFFFFFFCLL;
        }
        else {
          unint64_t v30 = 0;
        }
        uint64_t v31 = 1;
        uint64_t v32 = (void *)&unk_1EB1F3000;
        while (2)
        {
          switch(v27)
          {
            case 0uLL:
              uint64_t v33 = (v8 >> (4 * v31)) & 0xF;
              if (!v33) {
                goto LABEL_52;
              }
              goto LABEL_61;
            case 1uLL:
              LODWORD(v33) = *(unsigned __int8 *)(v28 + v31);
              if (*(unsigned char *)(v28 + v31)) {
                goto LABEL_61;
              }
              goto LABEL_52;
            case 2uLL:
              LODWORD(v33) = *(unsigned __int16 *)(v28 + 2 * v31);
              if (!*(_WORD *)(v28 + 2 * v31)) {
                goto LABEL_52;
              }
              goto LABEL_61;
            case 3uLL:
              LODWORD(v33) = *(_DWORD *)(v28 + 4 * v31);
              if (!v33) {
                goto LABEL_52;
              }
LABEL_61:
              unint64_t v34 = *(void *)(*(void *)(v24 + 8 * (v33 - 1)) + 24);
              {
                unint64_t v58 = v29;
                unint64_t v59 = v27;
                unint64_t v57 = v28;
                uint64_t v32 = &unk_1EB1F3000;
                unint64_t v28 = v57;
                unint64_t v29 = v58;
                uint64_t v24 = v62;
                unint64_t v27 = v59;
                if (v40)
                {
                  unint64_t v41 = __swift::__runtime::llvm::hashing::detail::fixed_seed_override;
                  if (!__swift::__runtime::llvm::hashing::detail::fixed_seed_override) {
                    unint64_t v41 = 0xFF51AFD7ED558CCDLL;
                  }
                  __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed = v41;
                  uint64_t v32 = (void *)&unk_1EB1F3000;
                  unint64_t v28 = v57;
                  unint64_t v29 = v58;
                  uint64_t v24 = v62;
                  unint64_t v27 = v59;
                }
              }
              unint64_t v35 = 0x9DDFEA08EB382D69 * ((v32[38] + 8 * v34) ^ HIDWORD(v34));
              unint64_t v36 = 0x9DDFEA08EB382D69 * (HIDWORD(v34) ^ (v35 >> 47) ^ v35);
              for (unint64_t i = 0x9DDFEA08EB382D69 * (v36 ^ (v36 >> 47)); ; unint64_t i = v39 + 1)
              {
                uint64_t v39 = i & ~(-2 << v11);
                if (v39)
                {
                  switch((int)v29)
                  {
                    case 1:
                      LODWORD(v38) = *(unsigned __int8 *)(v30 + v39);
                      break;
                    case 2:
                      LODWORD(v38) = *(unsigned __int16 *)(v30 + 2 * v39);
                      break;
                    case 3:
                      LODWORD(v38) = *(_DWORD *)(v30 + 4 * v39);
                      break;
                    default:
                      uint64_t v38 = (v26 >> (4 * v39)) & 0xF;
                      break;
                  }
                  if (!v38) {
                    break;
                  }
                }
              }
              if (v29 == 3)
              {
                *(_DWORD *)(v30 + 4 * v39) = v33;
              }
              else if (v29 == 2)
              {
                *(_WORD *)(v30 + 2 * v39) = v33;
              }
              else
              {
                *(unsigned char *)(v30 + v39) = v33;
              }
LABEL_52:
              if (!((unint64_t)++v31 >> v11)) {
                continue;
              }
              goto LABEL_79;
            default:
              JUMPOUT(0);
          }
        }
      }
LABEL_79:
      atomic_store(v26, (unint64_t *)&qword_1EB208960);
      if (!v63)
      {
        unint64_t v42 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
        uint64_t v24 = v62;
        *unint64_t v42 = qword_1EB208970;
        v42[1] = v8 & 0xFFFFFFFFFFFFFFFCLL;
        qword_1EB208970 = (uint64_t)v42;
      }
      unint64_t v12 = v60;
      unsigned int v25 = v43;
      uint64_t v19 = v61;
      if (!v13) {
        goto LABEL_83;
      }
    }
    unint64_t v44 = (unint64_t)v13;
    if (v12 < *v13)
    {
LABEL_89:
      __int16 v66 = 2;
      uint64_t v49 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v66, 0x20uLL, 8);
      unint64_t explicit = (unint64_t)v49;
      unint64_t v50 = v64;
      int v51 = 773;
      v49[2] = 773;
      if (&value witness table for Builtin.UnknownObject) {
        int v51 = v49 + 8;
      }
      v49[1] = &value witness table for Builtin.UnknownObject;
      v49[3] = v50;
      *(void *)(v44 + 8 + 8 * v12) = v49;
      atomic_store(v19, (unsigned int *)&dword_1EB208954);
      switch(v51)
      {
        case 1:
          unint64_t v52 = v26 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v26 & 3) == 0) {
            unint64_t v52 = 0;
          }
          atomic_store(v19, (unsigned __int8 *)(v52 + v25));
          break;
        case 2:
          unint64_t v53 = v26 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v26 & 3) == 0) {
            unint64_t v53 = 0;
          }
          atomic_store(v19, (unsigned __int16 *)(v53 + 2 * v25));
          break;
        case 3:
          unint64_t v54 = v26 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v26 & 3) == 0) {
            unint64_t v54 = 0;
          }
          atomic_store(v19, (unsigned int *)(v54 + 4 * v25));
          break;
        default:
          atomic_store((v19 << (4 * v25)) | v26, (unint64_t *)&qword_1EB208960);
          break;
      }
      __dmb(0xBu);
      if (ObjCClassWrappers) {
        goto LABEL_106;
      }
      uint64_t v55 = (void **)qword_1EB208970;
      if (qword_1EB208970)
      {
        do
        {
          unint64_t v56 = (void **)*v55;
          free(v55[1]);
          free(v55);
          uint64_t v55 = v56;
        }
        while (v56);
      }
      goto LABEL_105;
    }
LABEL_83:
    unint64_t v45 = v12 + (v12 >> 2);
    if (v45 <= v12 + 1) {
      unint64_t v45 = v12 + 1;
    }
    size_t v46 = malloc_good_size(8 * v45 + 8);
    uint64_t v47 = malloc_type_malloc(v46, 0x1000D770uLL);
    if (!v47) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    unint64_t v44 = (unint64_t)v47;
    *uint64_t v47 = (v46 + 0x7FFFFFFF8) >> 3;
    if (v13)
    {
      memcpy(v47 + 2, v13 + 2, 8 * v12);
      uint64_t v48 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
      *uint64_t v48 = qword_1EB208970;
      v48[1] = v13;
      qword_1EB208970 = (uint64_t)v48;
    }
    atomic_store(v44, (unint64_t *)&qword_1EB208958);
    goto LABEL_89;
  }
  return result;
}

void *swift_getObjCClassFromMetadata(void *result)
{
  if (result)
  {
    if (*result == 773) {
      return (void *)result[1];
    }
  }
  return result;
}

void *swift::swift_getObjCClassFromMetadataConditional(void *result)
{
  if (result)
  {
    if (*result <= 0x7FFuLL && *result != 0)
    {
      if (*result == 773) {
        return (void *)result[1];
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

uint64_t swift_getFunctionTypeMetadata0(uint64_t a1, uint64_t a2)
{
  v4[0] = a1;
  memset(&v4[1], 0, 24);
  v4[4] = a2;
  v4[5] = 0;
  int v5 = 0;
  uint64_t v6 = 0;
  if (v2) {
    return v2 + 16;
  }
  else {
    return 0;
  }
}

uint64_t swift_getFunctionTypeMetadata(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v6[0] = a1;
  v6[1] = 0;
  void v6[2] = a2;
  void v6[3] = a3;
  v6[4] = a4;
  v6[5] = 0;
  int v7 = 0;
  uint64_t v8 = 0;
  if (v4) {
    return v4 + 16;
  }
  else {
    return 0;
  }
}

uint64_t swift_getFunctionTypeMetadata1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a2;
  v6[0] = a1;
  v6[1] = 0;
  void v6[2] = (uint64_t)&v5;
  void v6[3] = 0;
  v6[4] = a3;
  v6[5] = 0;
  int v7 = 0;
  uint64_t v8 = 0;
  if (v3) {
    return v3 + 16;
  }
  else {
    return 0;
  }
}

uint64_t swift_getFunctionTypeMetadata2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v6[0] = a2;
  v6[1] = a3;
  v7[0] = a1;
  v7[1] = 0;
  void v7[2] = (uint64_t)v6;
  void v7[3] = 0;
  v7[4] = a4;
  v7[5] = 0;
  int v8 = 0;
  uint64_t v9 = 0;
  if (v4) {
    return v4 + 16;
  }
  else {
    return 0;
  }
}

uint64_t swift_getFunctionTypeMetadata3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v7[0] = a2;
  v7[1] = a3;
  void v7[2] = a4;
  v8[0] = a1;
  v8[1] = 0;
  void v8[2] = (uint64_t)v7;
  void v8[3] = 0;
  v8[4] = a5;
  v8[5] = 0;
  int v9 = 0;
  uint64_t v10 = 0;
  if (v5) {
    return v5 + 16;
  }
  else {
    return 0;
  }
}

uint64_t swift::StableAddressConcurrentReadableHashMap<anonymous namespace'::FunctionCacheEntry,swift::TaggedMetadataAllocator<(unsigned short)3>,swift::LazyMutex>::getOrInsert<anonymous namespace'::FunctionCacheEntry::Key>(uint64_t *a1)
{
  uint64_t explicit = atomic_load_explicit(&qword_1EB208A08, memory_order_acquire);
  {
    long long v99 = (unint64_t *)a1;
    atomic_fetch_add_explicit(&FunctionTypes, 1u, memory_order_acquire);
    do
    {
      unint64_t v3 = atomic_load_explicit(&qword_1EB2089E8, memory_order_acquire);
      unint64_t v4 = atomic_load_explicit(&qword_1EB2089F0, memory_order_acquire);
      unsigned int v5 = atomic_load_explicit(&dword_1EB2089E4, memory_order_acquire);
    }
    while (v3 != atomic_load_explicit(&qword_1EB2089E8, memory_order_acquire));
    if (v3) {
      unint64_t v6 = v3 + 8;
    }
    else {
      unint64_t v6 = 0;
    }
    if (v3) {
      BOOL v7 = v4 == 0;
    }
    else {
      BOOL v7 = 1;
    }
    if (!v7 && v5 != 0)
    {
      unint64_t v17 = (char *)(v4 & 0xFFFFFFFFFFFFFFFCLL);
      if ((v4 & 3) == 0 || v17 == 0) {
        char v35 = 4;
      }
      else {
        char v35 = *v17;
      }
      uint64_t v36 = ~(-1 << v35);
      if ((v4 & 3) != 0) {
        unint64_t v37 = v4 & 0xFFFFFFFFFFFFFFFCLL;
      }
      else {
        unint64_t v37 = 0;
      }
      while (1)
      {
        if ((v16 & v36) <= 1) {
          uint64_t v38 = 1;
        }
        else {
          uint64_t v38 = v16 & v36;
        }
        switch(v4 & 3)
        {
          case 1uLL:
            LODWORD(v39) = v37 + v38;
            LOBYTE(v39) = atomic_load_explicit((atomic_uchar *volatile)(v37 + v38), memory_order_acquire);
            if (!v39) {
              goto LABEL_16;
            }
            goto LABEL_83;
          case 2uLL:
            LODWORD(v39) = v37 + 2 * v38;
            LOWORD(v39) = atomic_load_explicit((atomic_ushort *volatile)(v37 + 2 * v38), memory_order_acquire);
            if (!v39) {
              goto LABEL_16;
            }
            goto LABEL_83;
          case 3uLL:
            LODWORD(v39) = atomic_load_explicit((atomic_uint *volatile)(v37 + 4 * v38), memory_order_acquire);
            if (v39) {
              goto LABEL_83;
            }
            goto LABEL_16;
          default:
            uint64_t v39 = (v4 >> (4 * v38)) & 0xF;
            if (!v39) {
              goto LABEL_16;
            }
LABEL_83:
            uint64_t v40 = (v39 - 1);
            if (v5 > v40
            {
              qword_1EB208A08 = *(void *)(v6 + 8 * v40);
              uint64_t explicit = *(void *)(v6 + 8 * v40);
              atomic_fetch_add_explicit(&FunctionTypes, 0xFFFFFFFF, memory_order_release);
              return explicit;
            }
            unint64_t v16 = v38 + 1;
            break;
        }
      }
    }
LABEL_16:
    atomic_fetch_add_explicit(&FunctionTypes, 0xFFFFFFFF, memory_order_release);
    int v9 = (unint64_t *)a1;
    long long v10 = *((_OWORD *)a1 + 1);
    v101[0] = *(_OWORD *)a1;
    v101[1] = v10;
    long long v11 = *((_OWORD *)a1 + 3);
    v101[2] = *((_OWORD *)a1 + 2);
    v101[3] = v11;
    os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB2089F8);
    uint64_t v12 = qword_1EB2089F0 & 3;
    unint64_t v100 = qword_1EB2089F0;
    unint64_t v13 = (char *)(qword_1EB2089F0 & 0xFFFFFFFFFFFFFFFCLL);
    BOOL v14 = (qword_1EB2089F0 & 0xFFFFFFFFFFFFFFFCLL) == 0 || (qword_1EB2089F0 & 3) == 0;
    if (v14) {
      int v15 = 4;
    }
    else {
      int v15 = *v13;
    }
    unint64_t v19 = dword_1EB2089E4;
    long long v97 = (_DWORD *)qword_1EB2089E8;
    __src = (void *)(qword_1EB2089E8 + 8);
    if (qword_1EB2089E8) {
      uint64_t v20 = qword_1EB2089E8 + 8;
    }
    else {
      uint64_t v20 = 0;
    }
    if (v14) {
      char v22 = 4;
    }
    else {
      char v22 = *v13;
    }
    uint64_t v23 = ~(-1 << v22);
    uint64_t v94 = v13;
    if (v12) {
      uint64_t v24 = v13;
    }
    else {
      uint64_t v24 = 0;
    }
    while (1)
    {
      if ((v21 & v23) <= 1) {
        uint64_t v25 = 1;
      }
      else {
        uint64_t v25 = v21 & v23;
      }
      switch(v100 & 3)
      {
        case 1uLL:
          LODWORD(v26) = v24 + v25;
          LOBYTE(v26) = atomic_load_explicit(&v24[v25], memory_order_acquire);
          if (!v26) {
            goto LABEL_55;
          }
          goto LABEL_49;
        case 2uLL:
          LODWORD(v26) = v24 + 2 * v25;
          LOWORD(v26) = atomic_load_explicit((atomic_ushort *volatile)&v24[2 * v25], memory_order_acquire);
          if (!v26) {
            goto LABEL_55;
          }
          goto LABEL_49;
        case 3uLL:
          LODWORD(v26) = atomic_load_explicit((atomic_uint *volatile)&v24[4 * v25], memory_order_acquire);
          if (v26) {
            goto LABEL_49;
          }
          goto LABEL_55;
        default:
          uint64_t v26 = (v100 >> (4 * v25)) & 0xF;
          if (!v26)
          {
LABEL_55:
            uint64_t v96 = (v19 + 1);
            if ((1 << v15) / (unint64_t)((1 << v15) - v96) <= 3)
            {
              uint64_t v25 = v25;
              unint64_t v34 = v97;
              if (v97) {
                goto LABEL_150;
              }
              goto LABEL_151;
            }
            unsigned int v30 = (v15 + 1);
            char v98 = v15;
            if (v30 >= 0x11) {
              unsigned int v31 = 4;
            }
            else {
              unsigned int v31 = 2;
            }
            if (v30 < 9) {
              size_t v32 = 1;
            }
            else {
              size_t v32 = v31;
            }
            unint64_t v33 = (unint64_t)malloc_type_calloc(2 << v15, v32, 0x4269077AuLL);
            if (!v33) {
              swift::hashable_support::findHashableBaseTypeOfHashableType();
            }
            unint64_t v92 = v19;
            if (v32 != 1)
            {
              if (v32 == 4) {
                size_t v32 = 3;
              }
              else {
                size_t v32 = 2;
              }
            }
            unint64_t v41 = v32 | v33;
            unint64_t v93 = v33;
            *(unsigned char *)unint64_t v33 = v15 + 1;
            if (v15)
            {
              uint64_t v42 = ~(-2 << v15);
              LODWORD(v32) = v41 & 3;
              if ((v41 & 3) != 0) {
                unint64_t v43 = v33 & 0xFFFFFFFFFFFFFFFCLL;
              }
              else {
                unint64_t v43 = 0;
              }
              uint64_t v44 = 1;
              while (2)
              {
                switch(v100 & 3)
                {
                  case 0uLL:
                    uint64_t v45 = (v100 >> (4 * v44)) & 0xF;
                    if (!v45) {
                      goto LABEL_93;
                    }
                    goto LABEL_102;
                  case 1uLL:
                    LODWORD(v45) = v24[v44];
                    if (!v24[v44]) {
                      goto LABEL_93;
                    }
                    goto LABEL_102;
                  case 2uLL:
                    LODWORD(v45) = *(unsigned __int16 *)&v24[2 * v44];
                    if (!*(_WORD *)&v24[2 * v44]) {
                      goto LABEL_93;
                    }
                    goto LABEL_102;
                  case 3uLL:
                    LODWORD(v45) = *(_DWORD *)&v24[4 * v44];
                    if (!v45) {
                      goto LABEL_93;
                    }
LABEL_102:
                    uint64_t v46 = *(void *)(v20 + 8 * (v45 - 1));
                    unint64_t v47 = *(void *)(v46 + 24);
                    v102[0] = v47;
                    if ((v47 & 0x8000000) != 0)
                    {
                      uint64_t v49 = (unsigned __int16)v47;
                      uint64_t v48 = *(void *)((v46
                                       + 8 * (unsigned __int16)v47
                                       + 4 * ((unsigned __int16)v47 & (unint64_t)((uint64_t)(v47 << 38) >> 63))
                                       + 47) & 0xFFFFFFFFFFFFFFF8);
                    }
                    else
                    {
                      uint64_t v48 = 0;
                      uint64_t v49 = (unsigned __int16)v47;
                    }
                    v102[1] = v48;
                    v102[2] = v46 + 40;
                    uint64_t v50 = v46 + 40 + 8 * v49;
                    uint64_t v51 = *(void *)(v46 + 32);
                    v102[3] = v50;
                    v102[4] = v51;
                    if ((v47 & 0x10000000) != 0)
                    {
                      uint64_t v103 = *(void *)(((v50 + 4 * (v49 & ((uint64_t)(v47 << 38) >> 63)) + 7) & 0xFFFFFFFFFFFFFFF8)
                                       + 8 * ((v47 >> 27) & 1));
                      if ((v47 & 0x80000000) == 0)
                      {
LABEL_110:
                        uint64_t v53 = 0;
                        int v104 = 0;
                        goto LABEL_112;
                      }
                    }
                    else
                    {
                      uint64_t v103 = 0;
                      if ((v47 & 0x80000000) == 0) {
                        goto LABEL_110;
                      }
                    }
                    unint64_t v52 = (int *)(((v50 + 4 * (v49 & ((uint64_t)(v47 << 38) >> 63)) + 7) & 0xFFFFFFFFFFFFFFF8)
                                + 8 * ((v47 >> 27) & 1)
                                + 8 * ((v47 >> 28) & 1));
                    int v104 = *v52;
                    if (v104) {
                      uint64_t v53 = *(void *)(((unint64_t)&v52[((v47 >> 31) & 1) + 1] + 3) & 0xFFFFFFFFFFFFFFF8);
                    }
                    else {
                      uint64_t v53 = 0;
                    }
LABEL_112:
                    uint64_t v105 = v53;
                    {
                      unint64_t v56 = i & v42;
                      if ((i & v42) != 0)
                      {
                        switch(v41 & 3)
                        {
                          case 1uLL:
                            LODWORD(v55) = *(unsigned __int8 *)(v43 + v56);
                            break;
                          case 2uLL:
                            LODWORD(v55) = *(unsigned __int16 *)(v43 + 2 * v56);
                            break;
                          case 3uLL:
                            LODWORD(v55) = *(_DWORD *)(v43 + 4 * v56);
                            break;
                          default:
                            uint64_t v55 = (v41 >> (4 * v56)) & 0xF;
                            break;
                        }
                        if (!v55) {
                          break;
                        }
                      }
                    }
                    if (v32 == 3)
                    {
                      *(_DWORD *)(v43 + 4 * v56) = v45;
                    }
                    else if (v32 == 2)
                    {
                      *(_WORD *)(v43 + 2 * v56) = v45;
                    }
                    else
                    {
                      *(unsigned char *)(v43 + v56) = v45;
                    }
LABEL_93:
                    if (!((unint64_t)++v44 >> v98)) {
                      continue;
                    }
                    goto LABEL_125;
                  default:
                    JUMPOUT(0);
                }
              }
            }
LABEL_125:
            atomic_store(v41, (unint64_t *)&qword_1EB2089F0);
            if (!v14)
            {
              unint64_t v57 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
              *unint64_t v57 = qword_1EB208A00;
              v57[1] = v94;
              qword_1EB208A00 = (uint64_t)v57;
            }
            char v59 = 4;
            unint64_t v19 = v92;
            if ((v93 & 0xFFFFFFFFFFFFFFFCLL) != 0 && (v41 & 3) != 0) {
              char v59 = *(unsigned char *)(v93 & 0xFFFFFFFFFFFFFFFCLL);
            }
            uint64_t v60 = ~(-1 << v59);
            if ((v41 & 3) != 0) {
              unint64_t v61 = v93 & 0xFFFFFFFFFFFFFFFCLL;
            }
            else {
              unint64_t v61 = 0;
            }
            while (1)
            {
              if ((v58 & v60) <= 1) {
                uint64_t v62 = 1;
              }
              else {
                uint64_t v62 = v58 & v60;
              }
              switch((int)v32)
              {
                case 1:
                  LODWORD(v63) = v61 + v62;
                  LOBYTE(v63) = atomic_load_explicit((atomic_uchar *volatile)(v61 + v62), memory_order_acquire);
                  if (v63) {
                    goto LABEL_145;
                  }
                  goto LABEL_148;
                case 2:
                  LODWORD(v63) = v61 + 2 * v62;
                  LOWORD(v63) = atomic_load_explicit((atomic_ushort *volatile)(v61 + 2 * v62), memory_order_acquire);
                  if (!v63) {
                    goto LABEL_148;
                  }
                  goto LABEL_145;
                case 3:
                  LODWORD(v63) = atomic_load_explicit((atomic_uint *volatile)(v61 + 4 * v62), memory_order_acquire);
                  if (v63) {
                    goto LABEL_145;
                  }
                  goto LABEL_148;
                default:
                  uint64_t v63 = (v41 >> (4 * v62)) & 0xF;
                  if (!v63)
                  {
LABEL_148:
                    uint64_t v25 = v62;
LABEL_149:
                    unint64_t v100 = v41;
                    int v9 = v99;
                    unint64_t v34 = v97;
                    if (v97)
                    {
LABEL_150:
                      unint64_t v65 = (unint64_t)v34;
                      if (v19 >= *v34) {
                        goto LABEL_151;
                      }
LABEL_157:
                      uint64_t v70 = (unsigned __int16)*v9;
                      uint64_t v71 = 4 * v70 + 7;
                      uint64_t v72 = ((*v9 >> 27) & 1) + v70;
                      if ((*v9 & 0x2000000) == 0) {
                        uint64_t v71 = 7;
                      }
                      size_t v73 = 8 * (v9[6] & 1)
                          + ((((*v9 >> 29) & 4 | (*v9 >> 25) & 8) + ((v71 + 8 * v72) | 4)) & 0xFFFFFFFFFFFFFFF8)
                          + 40;
                      LOWORD(v102[0]) = 3;
                      uint64_t v74 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)v102, v73, 8);
                      uint64_t explicit = (uint64_t)v74;
                      v74[2] = 0;
                      void v74[3] = 0;
                      unint64_t v75 = *v9;
                      int v76 = BYTE2(*v9);
                      if ((v76 - 2) < 2)
                      {
                        unint64_t v77 = value witness table for @convention(thin) ();
                        size_t v78 = (uint64_t (***)())(v74 + 1);
                        if (value witness table for @convention(thin) ()) {
                          unint64_t v77 = value witness table for @convention(thin) ();
                        }
                      }
                      else
                      {
                        if (v76 != 1)
                        {
                          if (!BYTE2(*v9))
                          {
                            if ((v75 & 0x4000000) != 0)
                            {
                              unint64_t v91 = v9[1];
                              if (v91)
                              {
                                if (v91 != 2) {
                                  abort();
                                }
                                unint64_t v77 = value witness table for @differentiable(reverse) ();
                                size_t v78 = (uint64_t (***)())(v74 + 1);
                                if (value witness table for @differentiable(reverse) ()) {
                                  unint64_t v77 = value witness table for @differentiable(reverse) ();
                                }
                              }
                              else
                              {
                                unint64_t v77 = value witness table for ();
                                size_t v78 = (uint64_t (***)())(v74 + 1);
                                if (value witness table for ()) {
                                  unint64_t v77 = value witness table for ();
                                }
                              }
                            }
                            else
                            {
                              unint64_t v77 = value witness table for ();
                              size_t v78 = (uint64_t (***)())(v74 + 1);
                              if (value witness table for ()) {
                                unint64_t v77 = value witness table for ();
                              }
                            }
                            goto LABEL_169;
                          }
LABEL_170:
                          v74[2] = 770;
                          void v74[3] = v75;
                          v74[4] = v9[4];
                          if ((v75 & 0x10000000) != 0)
                          {
                            *(void *)((((unint64_t)&v74[(unsigned __int16)v75 + 5]
                                        + 4 * ((unsigned __int16)v75 & (unint64_t)((uint64_t)(v75 << 38) >> 63))
                                        + 7) & 0xFFFFFFFFFFFFFFF8)
                                      + 8 * ((v75 >> 27) & 1)) = v9[5];
                            if ((v75 & 0x8000000) != 0) {
                              goto LABEL_175;
                            }
LABEL_172:
                            if ((v75 & 0x80000000) == 0) {
                              goto LABEL_173;
                            }
LABEL_176:
                            int v80 = *((_DWORD *)v9 + 12);
                            uint64_t v79 = (unsigned __int16)v75;
                            uint64_t v81 = (_DWORD *)((((unint64_t)&v74[(unsigned __int16)v75 + 5]
                                             + 4
                                             * ((unsigned __int16)v75 & (unint64_t)((uint64_t)(v75 << 38) >> 63))
                                             + 7) & 0xFFFFFFFFFFFFFFF8)
                                           + 8 * ((v75 >> 27) & 1)
                                           + 8 * ((v75 >> 28) & 1));
                            *uint64_t v81 = v80;
                            if (v80) {
                              *(void *)(((unint64_t)&v81[((v75 >> 31) & 1) + 1] + 3) & 0xFFFFFFFFFFFFFFF8) = v9[7];
                            }
                          }
                          else
                          {
                            if ((v75 & 0x8000000) == 0) {
                              goto LABEL_172;
                            }
LABEL_175:
                            *(void *)(((unint64_t)&v74[(unsigned __int16)v75 + 5]
                                       + 4 * ((unsigned __int16)v75 & (unint64_t)((uint64_t)(v75 << 38) >> 63))
                                       + 7) & 0xFFFFFFFFFFFFFFF8) = v9[1];
                            if ((v75 & 0x80000000) != 0) {
                              goto LABEL_176;
                            }
LABEL_173:
                            uint64_t v79 = (unsigned __int16)v75;
                          }
                          if (v79)
                          {
                            uint64_t v82 = 0;
                            unint64_t v83 = *v9;
                            do
                            {
                              v74[v82 + 5] = *(void *)(v9[2] + 8 * v82);
                              if ((v75 & 0x2000000) != 0)
                              {
                                if ((v83 & 0x2000000) != 0) {
                                  int v84 = *(_DWORD *)(v9[3] + 4 * v82);
                                }
                                else {
                                  int v84 = 0;
                                }
                                *((_DWORD *)&v74[v79 + 5] + v82) = v84;
                              }
                              ++v82;
                            }
                            while (v79 != v82);
                          }
                          *(void *)(v65 + 8 + 8 * v19) = v74;
                          atomic_store(v96, (unsigned int *)&dword_1EB2089E4);
                          switch((int)v25)
                          {
                            case 1:
                              unint64_t v85 = v100 & 0xFFFFFFFFFFFFFFFCLL;
                              if ((v100 & 3) == 0) {
                                unint64_t v85 = 0;
                              }
                              atomic_store(v96, (unsigned __int8 *)(v85 + v25));
                              break;
                            case 2:
                              unint64_t v86 = v100 & 0xFFFFFFFFFFFFFFFCLL;
                              if ((v100 & 3) == 0) {
                                unint64_t v86 = 0;
                              }
                              atomic_store(v96, (unsigned __int16 *)(v86 + 2 * v25));
                              break;
                            case 3:
                              unint64_t v87 = v100 & 0xFFFFFFFFFFFFFFFCLL;
                              if ((v100 & 3) == 0) {
                                unint64_t v87 = 0;
                              }
                              atomic_store(v96, (unsigned int *)(v87 + 4 * v25));
                              break;
                            default:
                              atomic_store((v96 << (4 * v25)) | v100, (unint64_t *)&qword_1EB2089F0);
                              break;
                          }
                          __dmb(0xBu);
                          if (!FunctionTypes)
                          {
                            unint64_t v88 = (void **)qword_1EB208A00;
                            if (qword_1EB208A00)
                            {
                              do
                              {
                                long long v89 = (void **)*v88;
                                free(v88[1]);
                                free(v88);
                                unint64_t v88 = v89;
                              }
                              while (v89);
                            }
                            goto LABEL_200;
                          }
                          goto LABEL_201;
                        }
                        unint64_t v77 = (uint64_t (**)())&value witness table for Builtin.UnknownObject;
                        size_t v78 = (uint64_t (***)())(v74 + 1);
                        if (&value witness table for Builtin.UnknownObject) {
                          unint64_t v77 = (uint64_t (**)())&value witness table for Builtin.UnknownObject;
                        }
                      }
LABEL_169:
                      *size_t v78 = v77;
                      goto LABEL_170;
                    }
LABEL_151:
                    unint64_t v66 = v19 + (v19 >> 2);
                    if (v66 <= v19 + 1) {
                      unint64_t v66 = v19 + 1;
                    }
                    size_t v67 = malloc_good_size(8 * v66 + 8);
                    int v68 = malloc_type_malloc(v67, 0x1000D770uLL);
                    if (!v68) {
                      swift::hashable_support::findHashableBaseTypeOfHashableType();
                    }
                    unint64_t v65 = (unint64_t)v68;
                    *int v68 = (v67 + 0x7FFFFFFF8) >> 3;
                    if (v34)
                    {
                      memcpy(v68 + 2, __src, 8 * v19);
                      uint64_t v69 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
                      *uint64_t v69 = qword_1EB208A00;
                      v69[1] = v34;
                      qword_1EB208A00 = (uint64_t)v69;
                    }
                    atomic_store(v65, (unint64_t *)&qword_1EB2089E8);
                    goto LABEL_157;
                  }
LABEL_145:
                  unsigned int v64 = v63 - 1;
                  if (v64 < v92
                  {
                    uint64_t v25 = 0;
                    goto LABEL_149;
                  }
                  unint64_t v58 = v62 + 1;
                  break;
              }
            }
          }
LABEL_49:
          uint64_t v27 = (v26 - 1);
          if (v27 < v19
          {
            uint64_t explicit = *(void *)(v20 + 8 * v27);
            __dmb(0xBu);
            if (!FunctionTypes)
            {
              unint64_t v28 = (void **)qword_1EB208A00;
              if (qword_1EB208A00)
              {
                do
                {
                  unint64_t v29 = (void **)*v28;
                  free(v28[1]);
                  free(v28);
                  unint64_t v28 = v29;
                }
                while (v29);
              }
LABEL_200:
              qword_1EB208A00 = 0;
            }
LABEL_201:
            os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB2089F8);
            qword_1EB208A08 = explicit;
            return explicit;
          }
          unint64_t v21 = v25 + 1;
          break;
      }
    }
  }
  return explicit;
}

uint64_t swift_getFunctionTypeMetadataDifferentiable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v7[0] = a1;
  v7[1] = a2;
  void v7[2] = a3;
  void v7[3] = a4;
  v7[4] = a5;
  v7[5] = 0;
  int v8 = 0;
  uint64_t v9 = 0;
  if (v5) {
    return v5 + 16;
  }
  else {
    return 0;
  }
}

uint64_t swift_getFunctionTypeMetadataGlobalActor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v8[0] = a1;
  v8[1] = a2;
  void v8[2] = a3;
  void v8[3] = a4;
  v8[4] = a5;
  v8[5] = a6;
  int v9 = 0;
  uint64_t v10 = 0;
  if (v6) {
    return v6 + 16;
  }
  else {
    return 0;
  }
}

uint64_t swift_getExtendedFunctionTypeMetadata(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8)
{
  if (!a8) {
    goto LABEL_15;
  }
  if (*(void *)a8 <= 0x7FFuLL && *(void *)a8 - 515 >= 0xFFFFFFFE)
  {
    if (*(EnumDescriptor **)(a8 + 8) != &nominal type descriptor for Never) {
      goto LABEL_15;
    }
    a1 &= ~0x1000000uLL;
  }
  else
  {
    if (*(void *)a8 != 771) {
      goto LABEL_15;
    }
    if (*(_DWORD *)(a8 + 12) != 1) {
      goto LABEL_15;
    }
    unint64_t v9 = *(unsigned int *)(a8 + 8);
    uint64_t v10 = *(void *)(a8 + 8 * ((v9 >> 30) & 1) + 16);
    if (v10) {
      goto LABEL_15;
    }
    long long v11 = (v10 & 0xFFFFFFFFFFFFFFFELL) != 0 ? (void *)(v10 & 0xFFFFFFFFFFFFFFFELL) : 0;
    if (v11 != &protocol descriptor for Error || (v9 & 0x80000000) == 0) {
      goto LABEL_15;
    }
  }
  a8 = 0;
  a7 &= ~1u;
  if (!a7) {
    a1 &= ~0x80000000uLL;
  }
LABEL_15:
  v14[0] = a1;
  v14[1] = a2;
  unsigned char v14[2] = a3;
  void v14[3] = a4;
  v14[4] = a5;
  v14[5] = a6;
  int v15 = a7;
  uint64_t v16 = a8;
  if (v12) {
    return v12 + 16;
  }
  else {
    return 0;
  }
}

uint64_t swift_getTupleTypeLayout2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unsigned int v3 = *(_DWORD *)(a2 + 20);
  uint64_t v4 = *(_DWORD *)(a3 + 16);
  uint64_t v5 = (*(void *)a2 + v4) & ~v4;
  if (v3 <= *(_DWORD *)(a3 + 20)) {
    unsigned int v3 = *(_DWORD *)(a3 + 20);
  }
  unint64_t v6 = v5 + *(void *)a3;
  if (*(_DWORD *)(a2 + 16) <= v4) {
    uint64_t v7 = *(_DWORD *)(a3 + 16);
  }
  else {
    uint64_t v7 = *(_DWORD *)(a2 + 16);
  }
  int v8 = *(_DWORD *)(a3 + 16) | *(_DWORD *)(a2 + 16);
  int v9 = v8 & 0x10000;
  int v10 = v8 & 0x100000;
  if (v6 < 0x19 && v7 < 8 && v10 == 0) {
    int v13 = 0;
  }
  else {
    int v13 = 0x20000;
  }
  unsigned int v14 = v9 | v10 | v7 | v13;
  *(void *)(a1 + 16) = v14;
  unint64_t v15 = (v6 + v7) & ~v7;
  if (v15 <= 1) {
    unint64_t v15 = 1;
  }
  *(void *)a1 = v6;
  *(void *)(a1 + 8) = v15;
  if (v3)
  {
    *(_DWORD *)(a1 + 16) = v14;
    *(_DWORD *)(a1 + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v3;
  }
  return v5;
}

uint64_t swift_getTupleTypeLayout(uint64_t result, uint64_t a2, unsigned __int16 a3, uint64_t a4)
{
  *(void *)unint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  int v4 = a3;
  if (a3)
  {
    uint64_t v5 = 0;
    unsigned int v6 = 0;
    unint64_t v7 = 0;
    unint64_t v8 = 0;
    LOBYTE(v9) = 1;
    LOBYTE(v1swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = 1;
    do
    {
      uint64_t v11 = *(void *)(a4 + 8 * v5);
      int v12 = *(_DWORD *)(v11 + 16);
      unint64_t v13 = v12;
      unint64_t v14 = (v7 + v13) & ~v13;
      if (a2)
      {
        *(_DWORD *)(a2 + 4 * v5) = v14;
        int v12 = *(_DWORD *)(v11 + 16);
        unint64_t v13 = v12;
      }
      if (v6 <= *(_DWORD *)(v11 + 20)) {
        unsigned int v6 = *(_DWORD *)(v11 + 20);
      }
      unint64_t v7 = *(void *)v11 + v14;
      if (v8 <= v13) {
        unint64_t v8 = v13;
      }
      int v9 = ((v12 & 0x10000) == 0) & v9;
      int v10 = ((v12 & 0x100000) == 0) & v10;
      ++v5;
    }
    while (a3 != (unint64_t)v5);
    if (v9) {
      int v4 = 0;
    }
    else {
      int v4 = 0x10000;
    }
    if (v8 >= 8 || v7 >= 0x19) {
      int v16 = 0;
    }
    else {
      int v16 = v10;
    }
    *(void *)unint64_t result = v7;
    int v17 = v8 & 0xFFECFFFF;
    if (!v10)
    {
      int v18 = 0x100000;
      goto LABEL_23;
    }
  }
  else
  {
    int v17 = 0;
    unint64_t v7 = 0;
    unint64_t v8 = 0;
    unsigned int v6 = 0;
    int v16 = 1;
  }
  int v18 = 0;
LABEL_23:
  if (v16) {
    int v19 = 0;
  }
  else {
    int v19 = 0x20000;
  }
  unsigned int v20 = v18 | v17 | v4 | v19;
  *(void *)(result + 16) = v20;
  unint64_t v21 = (v7 + v8) & ~v8;
  if (v21 <= 1) {
    unint64_t v21 = 1;
  }
  *(void *)(result + 8) = v21;
  if (v6)
  {
    *(void *)unint64_t result = v7;
    *(_DWORD *)(result + 16) = v20;
    *(_DWORD *)(result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v6;
  }
  return result;
}

uint64_t swift_getTupleTypeLayout3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unsigned int v4 = *(_DWORD *)(a2 + 20);
  unsigned int v5 = *(_DWORD *)(a2 + 16);
  uint64_t v6 = *(_DWORD *)(a3 + 16);
  uint64_t v7 = (*(void *)a2 + v6) & ~v6;
  if (v4 <= *(_DWORD *)(a3 + 20)) {
    unsigned int v4 = *(_DWORD *)(a3 + 20);
  }
  if (v5 <= v6) {
    unsigned int v5 = *(_DWORD *)(a3 + 16);
  }
  int v8 = *(_DWORD *)(a3 + 16) | *(_DWORD *)(a2 + 16);
  int v9 = *(_DWORD *)(a4 + 16);
  if (v4 <= *(_DWORD *)(a4 + 20)) {
    unsigned int v4 = *(_DWORD *)(a4 + 20);
  }
  unint64_t v10 = ((v7 + *(void *)a3 + v9) & ~(unint64_t)v9) + *(void *)a4;
  if (v5 <= v9) {
    uint64_t v11 = v9;
  }
  else {
    uint64_t v11 = v5;
  }
  int v12 = v9 | v8;
  int v13 = (v9 | v8) & 0x10000;
  int v14 = v12 & 0x100000;
  if (v10 < 0x19 && v11 < 8 && v14 == 0) {
    int v17 = 0;
  }
  else {
    int v17 = 0x20000;
  }
  unsigned int v18 = v13 | v14 | v11 | v17;
  *(void *)(a1 + 16) = v18;
  unint64_t v19 = (v10 + v11) & ~v11;
  if (v19 <= 1) {
    unint64_t v19 = 1;
  }
  *(void *)a1 = v10;
  *(void *)(a1 + 8) = v19;
  if (v4)
  {
    *(_DWORD *)(a1 + 16) = v18;
    *(_DWORD *)(a1 + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v4;
  }
  return v7;
}

uint64_t *swift_getTupleTypeMetadata(uint64_t a1, int a2, uint64_t a3, const char *a4, uint64_t a5)
{
  uint64_t v31 = a5;
  uint64_t v32 = a1;
  uint64_t v5 = (unsigned __int16)a2;
  if (!(_WORD)a2) {
    return (uint64_t *)&unk_1ECA06270;
  }
  if (qword_1EB1F88D0 == -1)
  {
    if ((a2 & 0x10000) == 0)
    {
LABEL_4:
      *(void *)&long long v29 = v5;
      *((void *)&v29 + 1) = a3;
      unsigned int v30 = a4;
      return (uint64_t *)v34;
    }
  }
  else
  {
    if ((a2 & 0x10000) == 0) {
      goto LABEL_4;
    }
  }
  uint64_t v33 = v5;
  uint64_t v34 = a3;
  char v35 = a4;
  atomic_fetch_add_explicit(&TupleTypes, 1u, memory_order_acquire);
  do
  {
    unint64_t explicit = atomic_load_explicit(&qword_1EB1F88A0, memory_order_acquire);
    unint64_t v11 = atomic_load_explicit(&qword_1EB1F88A8, memory_order_acquire);
    unint64_t v12 = atomic_load_explicit(&dword_1EB1F889C, memory_order_acquire);
  }
  while (explicit != atomic_load_explicit(&qword_1EB1F88A0, memory_order_acquire));
  if (explicit) {
    _ZF = v11 == 0;
  }
  else {
    _ZF = 1;
  }
  BOOL v14 = _ZF || v12 == 0;
  if (v14
  {
    atomic_fetch_add_explicit(&TupleTypes, 0xFFFFFFFF, memory_order_release);
  }
  else
  {
    int v16 = *v15;
    atomic_fetch_add_explicit(&TupleTypes, 0xFFFFFFFF, memory_order_release);
    if (v16) {
  }
    }
  size_t v17 = (strlen(a4) + 9) & 0xFFFFFFFFFFFFFFF8;
  LOWORD(v33) = 13;
  _X22 = (char *)swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v33, v17, 1);
  _swift_strlcpy(_X22, a4, v17);
  *(void *)&long long v27 = v5;
  *((void *)&v27 + 1) = a3;
  unint64_t v28 = _X22;
  uint64_t v9 = v34;
  if (*(char **)(v34 + 16) != _X22)
  {
    if (v17 <= 0x2000)
    {
      _X24 = 0;
      _X25 = 0;
      __asm { CASP            X24, X25, X24, X25, [X26] }
      if (&_X22[v17] == _X24)
      {
        if (swift::runtime::environment::initializeToken != -1) {
          dispatch_once_f(&swift::runtime::environment::initializeToken, 0, (dispatch_function_t)swift::runtime::environment::initialize);
        }
        if (swift::runtime::environment::SWIFT_DEBUG_ENABLE_MALLOC_SCRIBBLE_variable) {
          memset(_X22, 170, v17);
        }
        __asm { CASP            X24, X25, X22, X23, [X26] }
      }
    }
    else
    {
      swift_slowDealloc(_X22);
    }
  }
  return (uint64_t *)v9;
}

double swift::Lazy<anonymous namespace'::TupleCache>::defaultInitCallback(uint64_t a1)
{
  *(void *)(a1 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

void swift::LockingConcurrentMap<anonymous namespace'::TupleCacheEntry,anonymous namespace'::TupleCacheStorage>::getOrInsert<anonymous namespace'::TupleCacheEntry::Key,swift::MetadataRequest &,swift::TargetValueWitnessTable<swift::InProcess> const*&>(long long *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  v151 = &unk_1EB1F88C8;
  uint64_t v152 = 0;
  __int16 v153 = 0;
  long long v154 = *a1;
  v155 = (const char *)*((void *)a1 + 2);
  unint64_t explicit = (_WORD *)atomic_load_explicit(&qword_1EB1F88C0, memory_order_acquire);
  if (explicit && (void)v154 == *((void *)explicit + 15))
  {
    if ((void)v154)
    {
      uint64_t v8 = 0;
      while (*(void *)(*((void *)&v154 + 1) + 8 * v8) == *(void *)&explicit[8 * v8 + 68])
      {
        if ((void)v154 == ++v8) {
          goto LABEL_7;
        }
      }
    }
    else
    {
LABEL_7:
      uint64_t v9 = (const char *)*((void *)explicit + 16);
      if (v155 == v9 || v155 && v9 && !strcmp(v155, v9)) {
        goto LABEL_187;
      }
    }
  }
  atomic_fetch_add_explicit(&TupleTypes, 1u, memory_order_acquire);
  do
  {
    unint64_t v10 = atomic_load_explicit(&qword_1EB1F88A0, memory_order_acquire);
    unint64_t v11 = atomic_load_explicit(&qword_1EB1F88A8, memory_order_acquire);
    unint64_t v12 = atomic_load_explicit(&dword_1EB1F889C, memory_order_acquire);
  }
  while (v10 != atomic_load_explicit(&qword_1EB1F88A0, memory_order_acquire));
  if (v10) {
    BOOL v13 = v11 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13 && v12 != 0)
  {
    if (v15)
    {
      qword_1EB1F88C0 = *v15;
      unint64_t explicit = (_WORD *)*v15;
      atomic_fetch_add_explicit(&TupleTypes, 0xFFFFFFFF, memory_order_release);
LABEL_187:
LABEL_188:
      *a4 = explicit;
      a4[1] = v133;
      goto LABEL_189;
    }
  }
  atomic_fetch_add_explicit(&TupleTypes, 0xFFFFFFFF, memory_order_release);
  long long v156 = v154;
  v157 = v155;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB1F88B0);
  unint64_t v16 = qword_1EB1F88A8;
  uint64_t v150 = qword_1EB1F88A8 & 3;
  BOOL v17 = v150 == 0;
  if ((qword_1EB1F88A8 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
    BOOL v17 = 1;
  }
  BOOL v142 = v17;
  unint64_t v144 = qword_1EB1F88A8 & 0xFFFFFFFFFFFFFFFCLL;
  v145 = a3;
  if (v17) {
    int v18 = 4;
  }
  else {
    int v18 = *(unsigned __int8 *)(qword_1EB1F88A8 & 0xFFFFFFFFFFFFFFFCLL);
  }
  unint64_t v19 = dword_1EB1F889C;
  unsigned int v20 = (_DWORD *)qword_1EB1F88A0;
  if (qword_1EB1F88A0) {
    uint64_t v21 = qword_1EB1F88A0 + 8;
  }
  else {
    uint64_t v21 = 0;
  }
  uint64_t v24 = v22;
  if (v22)
  {
    unint64_t explicit = *v22;
    __dmb(0xBu);
    if (TupleTypes)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB1F88B0);
      qword_1EB1F88C0 = (uint64_t)explicit;
      goto LABEL_187;
    }
    long long v29 = (void **)qword_1EB1F88B8;
    if (qword_1EB1F88B8)
    {
      do
      {
        unsigned int v30 = (void **)*v29;
        free(v29[1]);
        free(v29);
        long long v29 = v30;
      }
      while (v30);
    }
    goto LABEL_186;
  }
  v140 = a4;
  v141 = v20;
  unint64_t v143 = v19;
  uint64_t v139 = a2;
  __src = v20 + 2;
  uint64_t v138 = (v19 + 1);
  if ((1 << v18) / (unint64_t)((1 << v18) - v138) < 4)
  {
    unint64_t v147 = v16;
  }
  else
  {
    unsigned int v25 = (v18 + 1);
    if (v25 >= 0x11) {
      unsigned int v26 = 4;
    }
    else {
      unsigned int v26 = 2;
    }
    if (v25 < 9) {
      size_t v27 = 1;
    }
    else {
      size_t v27 = v26;
    }
    unint64_t v28 = (unint64_t)malloc_type_calloc(2 << v18, v27, 0x4269077AuLL);
    if (!v28) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    if (v27 != 1)
    {
      if (v27 == 4) {
        size_t v27 = 3;
      }
      else {
        size_t v27 = 2;
      }
    }
    unint64_t v31 = v27 | v28;
    *(unsigned char *)unint64_t v28 = v18 + 1;
    unint64_t v147 = v27 | v28;
    if (v18)
    {
      uint64_t v32 = ~(-2 << v18);
      unint64_t v33 = v144;
      if (!v150) {
        unint64_t v33 = 0;
      }
      unint64_t v146 = v33;
      int v34 = v31 & 3;
      if ((v31 & 3) != 0) {
        unint64_t v35 = v28 & 0xFFFFFFFFFFFFFFFCLL;
      }
      else {
        unint64_t v35 = 0;
      }
      uint64_t v36 = 1;
      while (1)
      {
        switch(v16 & 3)
        {
          case 0uLL:
            uint64_t v37 = (v16 >> (4 * v36)) & 0xF;
            if (!v37) {
              goto LABEL_57;
            }
            goto LABEL_66;
          case 1uLL:
            LODWORD(v37) = *(unsigned __int8 *)(v146 + v36);
            if (!*(unsigned char *)(v146 + v36)) {
              goto LABEL_57;
            }
            goto LABEL_66;
          case 2uLL:
            LODWORD(v37) = *(unsigned __int16 *)(v146 + 2 * v36);
            if (!*(_WORD *)(v146 + 2 * v36)) {
              goto LABEL_57;
            }
            goto LABEL_66;
          case 3uLL:
            LODWORD(v37) = *(_DWORD *)(v146 + 4 * v36);
            if (!v37) {
              goto LABEL_57;
            }
LABEL_66:
            int v149 = v37;
            uint64_t v38 = *(void **)(v21 + 8 * (v37 - 1));
            uint64_t v39 = v38[15];
            Dl_info __s = (char *)v38[16];
            unint64_t v158 = 0;
            {
              unint64_t v114 = __swift::__runtime::llvm::hashing::detail::fixed_seed_override;
              if (!__swift::__runtime::llvm::hashing::detail::fixed_seed_override) {
                unint64_t v114 = 0xFF51AFD7ED558CCDLL;
              }
              __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed = v114;
            }
            uint64_t v40 = v38 + 17;
            uint64_t v41 = (uint64_t)&v38[2 * v39 + 17];
            if (v39)
            {
              *(void *)&long long v159 = v38[17];
              if (v38 + 19 == (void *)v41)
              {
                unint64_t v42 = 8;
              }
              else
              {
                *((void *)&v159 + 1) = v38[19];
                if (v38 + 21 == (void *)v41)
                {
                  unint64_t v42 = 16;
                }
                else
                {
                  *(void *)&long long v160 = v38[21];
                  if (v38 + 23 == (void *)v41)
                  {
                    unint64_t v42 = 24;
                  }
                  else
                  {
                    *((void *)&v160 + 1) = v38[23];
                    if (v38 + 25 == (void *)v41)
                    {
                      unint64_t v42 = 32;
                    }
                    else
                    {
                      *(void *)&long long v161 = v38[25];
                      if (v38 + 27 == (void *)v41)
                      {
                        unint64_t v42 = 40;
                      }
                      else
                      {
                        *((void *)&v161 + 1) = v38[27];
                        if (v38 + 29 == (void *)v41)
                        {
                          unint64_t v42 = 48;
                        }
                        else
                        {
                          *(void *)&long long v162 = v38[29];
                          if (v38 + 31 == (void *)v41)
                          {
                            unint64_t v42 = 56;
                          }
                          else
                          {
                            *((void *)&v162 + 1) = v38[31];
                            uint64_t v40 = v38 + 33;
                            unint64_t v42 = 64;
                            if (v38 + 33 != (void *)v41) {
                              goto LABEL_78;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              goto LABEL_126;
            }
            unint64_t v42 = 0;
            if (v40 != (void *)v41)
            {
LABEL_78:
              unint64_t v43 = 0x9DDFEA08EB382D69
                  * ((0x9DDFEA08EB382D69
                    * (__swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed ^ 0xB492B66FBE98F273)) ^ ((0x9DDFEA08EB382D69 * (__swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed ^ 0xB492B66FBE98F273)) >> 47) ^ 0xB492B66FBE98F273);
              uint64_t v44 = __ROR8__(__swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed ^ 0xB492B66FBE98F273, 49);
              unint64_t v45 = __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed ^ ((unint64_t)__swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed >> 47);
              unint64_t v46 = __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed ^ (((0x9DDFEA08EB382D69
                                                                                                 * (v45 ^ (0xB492B66FBE98F273 * __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed))) ^ __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed) >> 47) ^ (0x9DDFEA08EB382D69 * (v45 ^ (0xB492B66FBE98F273 * __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed)));
              uint64_t v47 = v44
                  + __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed
                  + *((void *)&v159 + 1);
              unint64_t v48 = *((void *)&v161 + 1)
                  + v44
                  - 0x4B6D499041670D8DLL
                  * __ROR8__(v162+ __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed- 0x4B6D499041670D8DLL * __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed, 42);
              unint64_t v49 = v45 - 0x622015F714C7D297 * (v43 ^ (v43 >> 47));
              uint64_t v50 = v159
                  - 0x6D8ED9027DD26057 * __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed;
              uint64_t v51 = v50 + *((void *)&v159 + 1) + v160;
              unint64_t v52 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v46) ^ ((0x9DDFEA08EB382D69 * v46) >> 47));
              unint64_t v53 = (0xB492B66FBE98F273 * __ROR8__(v47, 37)) ^ v52;
              uint64_t v54 = __ROR8__(v49, 33);
              uint64_t v55 = __ROR8__(v51, 44) + v50 + __ROR8__(v53 + v45 + v50 + *((void *)&v160 + 1), 21);
              unint64_t v56 = 0xB492B66FBE98F273 * v54;
              uint64_t v57 = v51 + *((void *)&v160 + 1);
              uint64_t v58 = v52 + v161 - 0x4B6D499041670D8DLL * v54;
              uint64_t v59 = *((void *)&v161 + 1) + v162 + v58;
              uint64_t v60 = __ROR8__(v59, 44) + v58 + __ROR8__(v48 + v160 + *((void *)&v162 + 1) + v58, 21);
              uint64_t v61 = v59 + *((void *)&v162 + 1);
              unint64_t v62 = 64;
              while (1)
              {
                *(void *)&long long v159 = *v40;
                BOOL v70 = v40 + 2 == (void *)v41;
                if (v40 + 2 == (void *)v41)
                {
                  uint64_t v73 = 0;
                  uint64_t v72 = 8;
                  v40 += 2;
                  uint64_t v74 = (char *)&v159 + 8;
                }
                else
                {
                  *((void *)&v159 + 1) = v40[2];
                  BOOL v70 = v40 + 4 == (void *)v41;
                  if (v40 + 4 == (void *)v41)
                  {
                    uint64_t v73 = 8;
                    uint64_t v72 = 16;
                    v40 += 4;
                    uint64_t v74 = (char *)&v160;
                  }
                  else
                  {
                    *(void *)&long long v160 = v40[4];
                    BOOL v70 = v40 + 6 == (void *)v41;
                    if (v40 + 6 == (void *)v41)
                    {
                      uint64_t v73 = 16;
                      uint64_t v72 = 24;
                      v40 += 6;
                      uint64_t v74 = (char *)&v160 + 8;
                    }
                    else
                    {
                      *((void *)&v160 + 1) = v40[6];
                      BOOL v70 = v40 + 8 == (void *)v41;
                      if (v40 + 8 == (void *)v41)
                      {
                        uint64_t v73 = 24;
                        uint64_t v72 = 32;
                        v40 += 8;
                        uint64_t v74 = (char *)&v161;
                      }
                      else
                      {
                        *(void *)&long long v161 = v40[8];
                        BOOL v70 = v40 + 10 == (void *)v41;
                        if (v40 + 10 == (void *)v41)
                        {
                          uint64_t v73 = 32;
                          uint64_t v72 = 40;
                          v40 += 10;
                          uint64_t v74 = (char *)&v161 + 8;
                        }
                        else
                        {
                          *((void *)&v161 + 1) = v40[10];
                          BOOL v70 = v40 + 12 == (void *)v41;
                          if (v40 + 12 == (void *)v41)
                          {
                            uint64_t v73 = 40;
                            uint64_t v72 = 48;
                            v40 += 12;
                            uint64_t v74 = (char *)&v162;
                          }
                          else
                          {
                            *(void *)&long long v162 = v40[12];
                            BOOL v70 = v40 + 14 == (void *)v41;
                            if (v40 + 14 != (void *)v41)
                            {
                              uint64_t v71 = v40[14];
                              v40 += 16;
                              *((void *)&v162 + 1) = v71;
                              BOOL v70 = v40 == (void *)v41;
                              uint64_t v72 = 64;
                              goto LABEL_79;
                            }
                            uint64_t v73 = 48;
                            uint64_t v72 = 56;
                            v40 += 14;
                            uint64_t v74 = (char *)&v162 + 8;
                          }
                        }
                      }
                    }
                  }
                }
                uint64_t v75 = 56 - v73;
                uint64_t v76 = v72;
                if (v72 != 56 - v73)
                {
                  do
                  {
                    uint64_t v82 = v76;
                    uint64_t v76 = v75;
                    uint64_t v75 = v82 % v75;
                  }
                  while (v75);
                  if (v76)
                  {
                    unint64_t v83 = (long long *)((char *)&v159 + v76);
                    do
                    {
                      char v85 = *((unsigned char *)v83 - 1);
                      unint64_t v83 = (long long *)((char *)v83 - 1);
                      char v84 = v85;
                      unint64_t v86 = (long long *)((char *)v83 + v72);
                      unint64_t v87 = v83;
                      do
                      {
                        unint64_t v88 = v87;
                        unint64_t v87 = v86;
                        *(unsigned char *)unint64_t v88 = *(unsigned char *)v86;
                        long long v89 = (char *)((char *)&v163 - (char *)v86);
                        BOOL v90 = __OFSUB__(v72, v89);
                        uint64_t v92 = v72 - (void)v89;
                        char v91 = (v92 < 0) ^ v90;
                        unint64_t v86 = (long long *)((char *)&v159 + v92);
                        if (v91) {
                          unint64_t v86 = (long long *)((char *)v87 + v72);
                        }
                      }
                      while (v86 != v83);
                      *(unsigned char *)unint64_t v87 = v84;
                    }
                    while (v83 != &v159);
                  }
                  goto LABEL_79;
                }
                unint64_t v77 = 55 - v73;
                if (55 - v73 >= (v73 | 7uLL)) {
                  unint64_t v77 = v73 | 7;
                }
                size_t v78 = (char *)&v159;
                if (&v159 < (long long *)((char *)&v159 + v73 + v77 + 9))
                {
                  uint64_t v79 = v72;
                  if (v74 < (char *)&v159 + v77 + 1) {
                    goto LABEL_100;
                  }
                }
                if (v77 >= 0x1F)
                {
                  unint64_t v94 = v77 + 1;
                  uint64_t v93 = (v77 + 1) & 0x60;
                  uint64_t v95 = (long long *)((char *)&v159 + v72);
                  long long v96 = v159;
                  long long v97 = v160;
                  long long v98 = *(long long *)((char *)&v159 + v72 + 16);
                  long long v159 = *(long long *)((char *)&v159 + v72);
                  long long v160 = v98;
                  *uint64_t v95 = v96;
                  v95[1] = v97;
                  if (v93 != 32)
                  {
                    long long v99 = (long long *)((char *)&v161 + v72);
                    long long v100 = v161;
                    long long v101 = v162;
                    long long v102 = *(long long *)((char *)&v161 + v72 + 16);
                    long long v161 = *(long long *)((char *)&v161 + v72);
                    long long v162 = v102;
                    _OWORD *v99 = v100;
                    v99[1] = v101;
                  }
                  if (v94 == v93) {
                    goto LABEL_79;
                  }
                  if ((v94 & 0x18) == 0)
                  {
                    size_t v78 = (char *)&v159 + v93;
                    uint64_t v79 = v72 + v93;
LABEL_100:
                    int v80 = v78 + 1;
                    do
                    {
                      char v81 = *(v80 - 1);
                      *(v80 - 1) = *((unsigned char *)&v159 + v79);
                      *((unsigned char *)&v159 + v79) = v81;
                      if (v80 == v74) {
                        break;
                      }
                      ++v80;
                      BOOL v13 = v79++ == 63;
                    }
                    while (!v13);
                    goto LABEL_79;
                  }
                }
                else
                {
                  uint64_t v93 = 0;
                }
                uint64_t v103 = (uint64_t *)((char *)&v159 + v93);
                uint64_t v104 = v77 - v93 + 1;
                do
                {
                  uint64_t v105 = *v103;
                  uint64_t *v103 = v103[(unint64_t)v72 / 8];
                  v103[(unint64_t)v72 / 8] = v105;
                  ++v103;
                  v104 -= 8;
                }
                while (v104);
LABEL_79:
                unint64_t v63 = v48 + v56 + v57 + *((void *)&v159 + 1);
                unint64_t v48 = *((void *)&v161 + 1) + v57 - 0x4B6D499041670D8DLL * __ROR8__(v55 + v48 + v162, 42);
                uint64_t v64 = v159 - 0x4B6D499041670D8DLL * v55;
                uint64_t v65 = v64 + *((void *)&v159 + 1) + v160;
                uint64_t v66 = __ROR8__(v61 + v53, 33);
                unint64_t v67 = (0xB492B66FBE98F273 * __ROR8__(v63, 37)) ^ v60;
                uint64_t v55 = __ROR8__(v65, 44) + v64 + __ROR8__(v67 + v61 + v64 + *((void *)&v160 + 1), 21);
                unint64_t v56 = 0xB492B66FBE98F273 * v66;
                unint64_t v68 = 0xB492B66FBE98F273 * v66 + v60 + v161;
                unint64_t v69 = *((void *)&v161 + 1) + v162 + v68;
                uint64_t v57 = v65 + *((void *)&v160 + 1);
                uint64_t v60 = __ROR8__(v69, 44) + v68 + __ROR8__(v48 + v160 + v68 + *((void *)&v162 + 1), 21);
                uint64_t v61 = v69 + *((void *)&v162 + 1);
                v62 += v72;
                unint64_t v53 = v67;
                if (v70)
                {
                  unint64_t v106 = 0x9DDFEA08EB382D69
                       * (v61 ^ ((0x9DDFEA08EB382D69 * (v61 ^ v57)) >> 47) ^ (0x9DDFEA08EB382D69 * (v61 ^ v57)));
                  unint64_t v107 = 0xB492B66FBE98F273 * ((v62 ^ (v62 >> 47)) + v66)
                       - 0x622015F714C7D297
                       * ((0x9DDFEA08EB382D69
                         * (v60 ^ ((0x9DDFEA08EB382D69 * (v60 ^ v55)) >> 47) ^ (0x9DDFEA08EB382D69 * (v60 ^ v55)))) ^ ((0x9DDFEA08EB382D69 * (v60 ^ ((0x9DDFEA08EB382D69 * (v60 ^ v55)) >> 47) ^ (0x9DDFEA08EB382D69 * (v60 ^ v55)))) >> 47));
                  unint64_t v108 = 0x9DDFEA08EB382D69
                       * (v107 ^ (v67
                                - 0x4B6D499041670D8DLL * (v48 ^ (v48 >> 47))
                                - 0x622015F714C7D297 * (v106 ^ (v106 >> 47))));
                  unint64_t v109 = 0x9DDFEA08EB382D69
                       * ((0x9DDFEA08EB382D69 * (v107 ^ (v108 >> 47) ^ v108)) ^ ((0x9DDFEA08EB382D69
                                                                                  * (v107 ^ (v108 >> 47) ^ v108)) >> 47));
                  goto LABEL_127;
                }
              }
            }
LABEL_126:
            unint64_t v109 = __swift::__runtime::llvm::hashing::detail::hash_short((__swift::__runtime::llvm::hashing::detail *)&v159, v42, __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed);
LABEL_127:
            unint64_t v158 = v109;
            size_t v110 = (size_t)__s;
            *(void *)&long long v159 = __s;
            if (__s) {
              size_t v110 = strlen(__s);
            }
            *((void *)&v159 + 1) = v110;
            unint64_t v111 = __swift::__runtime::llvm::hash_combine<__swift::__runtime::llvm::hash_code,__swift::__runtime::llvm::StringRef>(&v158, (uint64_t)&v159);
            unint64_t v31 = v147;
            while (1)
            {
              unint64_t v113 = v111 & v32;
              if ((v111 & v32) != 0)
              {
                switch(v34)
                {
                  case 1:
                    LODWORD(v112) = *(unsigned __int8 *)(v35 + v113);
                    break;
                  case 2:
                    LODWORD(v112) = *(unsigned __int16 *)(v35 + 2 * v113);
                    break;
                  case 3:
                    LODWORD(v112) = *(_DWORD *)(v35 + 4 * v113);
                    break;
                  default:
                    uint64_t v112 = (v147 >> (4 * v113)) & 0xF;
                    break;
                }
                if (!v112) {
                  break;
                }
              }
              unint64_t v111 = v113 + 1;
            }
            if (v34 == 3)
            {
              *(_DWORD *)(v35 + 4 * v113) = v149;
            }
            else if (v34 == 2)
            {
              *(_WORD *)(v35 + 2 * v113) = v149;
            }
            else
            {
              *(unsigned char *)(v35 + v113) = v149;
            }
LABEL_57:
            if ((unint64_t)++v36 >> v18) {
              goto LABEL_152;
            }
            break;
          default:
            JUMPOUT(0);
        }
      }
    }
LABEL_152:
    atomic_store(v31, (unint64_t *)&qword_1EB1F88A8);
    if (!v142)
    {
      unsigned __int8 v115 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
      unint64_t v31 = v147;
      *unsigned __int8 v115 = qword_1EB1F88B8;
      v115[1] = v144;
      qword_1EB1F88B8 = (uint64_t)v115;
    }
    unint64_t v19 = v143;
    a3 = v145;
  }
  unsigned int v116 = v23;
  if (!v141 || (unint64_t v117 = (unint64_t)v141, v19 >= *v141))
  {
    unint64_t v118 = v19 + (v19 >> 2);
    if (v118 <= v19 + 1) {
      unint64_t v118 = v19 + 1;
    }
    size_t v119 = malloc_good_size(8 * v118 + 8);
    uint64_t v120 = malloc_type_malloc(v119, 0x1000D770uLL);
    if (!v120) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    unint64_t v117 = (unint64_t)v120;
    _DWORD *v120 = (v119 + 0x7FFFFFFF8) >> 3;
    if (v141)
    {
      memcpy(v120 + 2, __src, 8 * v143);
      os_unfair_lock_t v121 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
      void *v121 = qword_1EB1F88B8;
      v121[1] = v141;
      qword_1EB1F88B8 = (uint64_t)v121;
    }
    atomic_store(v117, (unint64_t *)&qword_1EB1F88A0);
  }
  uint64_t v122 = v154;
  LOWORD(v159) = 13;
  unint64_t explicit = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v159, 16 * v154 + 136, 8);
  uint64_t v123 = *a3;
  HIBYTE(v153) = 1;
  unint64_t v124 = (unint64_t)v152;
  if (!v152)
  {
    unint64_t v124 = (unint64_t)swift_slowAlloc(0x30uLL, 0xFuLL);
    *(_OWORD *)unint64_t v124 = 0u;
    *(_OWORD *)(v124 + 16) = 0u;
    *(_OWORD *)(v124 + 32) = 0u;
    *(void *)unint64_t v124 = 1;
    *(void *)(v124 + 16) = 0;
    *(void *)(v124 + 24) = 0;
    os_unfair_lock_lock((os_unfair_lock_t)(v124 + 8));
    uint64_t v152 = (os_unfair_lock_s *)v124;
  }
  *(void *)unint64_t explicit = v124 | 9;
  *((_DWORD *)explicit + 24) = 0;
  *((void *)explicit + 14) = 769;
  *((void *)explicit + 15) = v122;
  *((void *)explicit + 16) = v155;
  if (v123) {
    uint64_t v125 = v123;
  }
  else {
    uint64_t v125 = 0;
  }
  *((void *)explicit + 13) = v125;
  if (v122)
  {
    uint64_t v126 = 0;
    uint64_t v127 = *((void *)&v154 + 1);
    do
    {
      *(void *)&explicit[8 * v126 + 68] = *(void *)(v127 + 8 * v126);
      ++v126;
    }
    while (v122 != v126);
  }
  *(void *)(v117 + 8 + 8 * v143) = explicit;
  uint64_t v24 = 0;
  atomic_store(v138, (unsigned int *)&dword_1EB1F889C);
  a2 = v139;
  a4 = v140;
  switch((int)a3)
  {
    case 1:
      unint64_t v128 = v147 & 0xFFFFFFFFFFFFFFFCLL;
      if ((v147 & 3) == 0) {
        unint64_t v128 = 0;
      }
      atomic_store(v138, (unsigned __int8 *)(v128 + v116));
      break;
    case 2:
      unint64_t v129 = v147 & 0xFFFFFFFFFFFFFFFCLL;
      if ((v147 & 3) == 0) {
        unint64_t v129 = 0;
      }
      atomic_store(v138, (unsigned __int16 *)(v129 + 2 * v116));
      break;
    case 3:
      unint64_t v130 = v147 & 0xFFFFFFFFFFFFFFFCLL;
      if ((v147 & 3) == 0) {
        unint64_t v130 = 0;
      }
      atomic_store(v138, (unsigned int *)(v130 + 4 * v116));
      break;
    default:
      atomic_store((v138 << (4 * v116)) | v147, (unint64_t *)&qword_1EB1F88A8);
      break;
  }
  __dmb(0xBu);
  if (TupleTypes)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB1F88B0);
    qword_1EB1F88C0 = (uint64_t)explicit;
    goto LABEL_194;
  }
  v131 = (void **)qword_1EB1F88B8;
  if (qword_1EB1F88B8)
  {
    do
    {
      v132 = (void **)*v131;
      free(v131[1]);
      free(v131);
      v131 = v132;
    }
    while (v132);
  }
LABEL_186:
  qword_1EB1F88B8 = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB1F88B0);
  qword_1EB1F88C0 = (uint64_t)explicit;
  if (v24) {
    goto LABEL_187;
  }
LABEL_194:
  if (v152) {
    LOBYTE(v153) = 1;
  }
  if (HIBYTE(v153) != 4)
  {
    if (!HIBYTE(v153)) {
      abort();
    }
    goto LABEL_188;
  }
  uint64_t v134 = 0;
  *a4 = explicit;
  a4[1] = explicit + 56;
LABEL_189:
  a4[2] = v134;
  v135 = v152;
  if (v152)
  {
    os_unfair_lock_unlock(v152 + 2);
    uint64_t v136 = *(void *)&v135[4]._os_unfair_lock_opaque;
    *(void *)&v135[4]._os_unfair_lock_opaque = 0;
    if (v136) {
      MEMORY[0x1852FF000](v136, 0x80C4018A671A6);
    }
    swift_slowDealloc(v135);
  }
}

uint64_t *swift_getTupleTypeMetadata2(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5)
{
  v6[0] = a2;
  v6[1] = a3;
  return swift_getTupleTypeMetadata(a1, 2, (uint64_t)v6, a4, a5);
}

uint64_t *swift_getTupleTypeMetadata3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6)
{
  v7[0] = a2;
  v7[1] = a3;
  void v7[2] = a4;
  return swift_getTupleTypeMetadata(a1, 3, (uint64_t)v7, a5, a6);
}

uint64_t swift::equalContexts(const char *a1, const char *a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t v20 = v2;
  uint64_t v21 = v3;
  uint64_t result = 0;
  if (!a1 || !a2) {
    return result;
  }
  if ((*(_DWORD *)a1 & 0x40) != 0
    || (*(_DWORD *)a2 & 0x40) != 0
    || ((*(_DWORD *)a2 ^ *(_DWORD *)a1) & 0x1F) != 0)
  {
    return 0;
  }
  uint64_t v7 = *((int *)a1 + 1);
  if (v7)
  {
    uint64_t v8 = (unint64_t *)&a1[(v7 & 0xFFFFFFFFFFFFFFFELL) + 4];
    if (v7)
    {
      if (*v8)
      {
        unint64_t v9 = *v8;
        goto LABEL_17;
      }
    }
    else if (v8)
    {
      unint64_t v9 = (unint64_t)&a1[(v7 & 0xFFFFFFFFFFFFFFFELL) + 4];
      goto LABEL_17;
    }
  }
  unint64_t v9 = 0;
LABEL_17:
  uint64_t v10 = *((int *)a2 + 1);
  if (v10)
  {
    unint64_t v11 = (unint64_t *)&a2[(v10 & 0xFFFFFFFFFFFFFFFELL) + 4];
    if (v10)
    {
      if (*v11)
      {
        unint64_t v12 = *v11;
        goto LABEL_24;
      }
    }
    else if (v11)
    {
      unint64_t v12 = (unint64_t)&a2[(v10 & 0xFFFFFFFFFFFFFFFELL) + 4];
      goto LABEL_24;
    }
  }
  unint64_t v12 = 0;
LABEL_24:
  uint64_t result = swift::equalContexts(v9, v12);
  if (result)
  {
    if ((*a1 & 0x1Fu) - 1 >= 2)
    {
      if ((*a1 & 0x1F) == 0)
      {
        int v13 = strcmp(&a1[*((int *)a1 + 2) + 8], &a2[*((int *)a2 + 2) + 8]);
        return v13 == 0;
      }
      if ((*a1 & 0x10) != 0)
      {
        uint64_t v14 = (uint64_t)a2;
        swift::ParsedTypeIdentity::parse((uint64_t)a1, (uint64_t)v17);
        unint64_t v16 = __s2;
        size_t v15 = v19;
        swift::ParsedTypeIdentity::parse(v14, (uint64_t)v17);
        if (v15 == v19)
        {
          if (!v15) {
            return 1;
          }
          int v13 = memcmp(v16, __s2, v15);
          return v13 == 0;
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t swift_compareTypeContextDescriptors(_DWORD *a1, _DWORD *a2)
{
  if (a1)
  {
    uint64_t v2 = a1;
    if (!a2)
    {
LABEL_7:
      uint64_t v3 = 0;
      if (v2) {
        goto LABEL_8;
      }
      return 1;
    }
  }
  else
  {
    uint64_t v2 = 0;
    if (!a2) {
      goto LABEL_7;
    }
  }
  uint64_t v3 = a2;
  if (v2 == a2) {
    return 1;
  }
LABEL_8:
  uint64_t result = 0;
  if (v2 && v3)
  {
    if ((*v2 & 0x40) != 0 || (*v3 & 0x40) != 0 || ((*v3 ^ *v2) & 0x1F) != 0) {
      return 0;
    }
    uint64_t v5 = (int)v2[1];
    if (v5)
    {
      uint64_t v6 = (const char **)((char *)v2 + (v5 & 0xFFFFFFFFFFFFFFFELL) + 4);
      if (v5)
      {
        if (*v6)
        {
          uint64_t v7 = *v6;
          goto LABEL_21;
        }
      }
      else if (v6)
      {
        uint64_t v7 = (char *)v2 + (v5 & 0xFFFFFFFFFFFFFFFELL) + 4;
        goto LABEL_21;
      }
    }
    uint64_t v7 = 0;
LABEL_21:
    uint64_t v8 = (int)v3[1];
    if (v8)
    {
      unint64_t v9 = (const char **)((char *)v3 + (v8 & 0xFFFFFFFFFFFFFFFELL) + 4);
      if (v8)
      {
        if (*v9)
        {
          uint64_t v10 = *v9;
          goto LABEL_28;
        }
      }
      else if (v9)
      {
        uint64_t v10 = (char *)v3 + (v8 & 0xFFFFFFFFFFFFFFFELL) + 4;
        goto LABEL_28;
      }
    }
    uint64_t v10 = 0;
LABEL_28:
    uint64_t result = swift::equalContexts(v7, v10);
    if (!result) {
      return result;
    }
    swift::ParsedTypeIdentity::parse((uint64_t)v2, (uint64_t)v13);
    unint64_t v12 = __s2;
    size_t v11 = v15;
    swift::ParsedTypeIdentity::parse((uint64_t)v3, (uint64_t)v13);
    if (v11 != v15) {
      return 0;
    }
    if (v11) {
      return memcmp(v12, __s2, v11) == 0;
    }
    return 1;
  }
  return result;
}

char *_swift_pod_indirect_initializeBufferWithCopyOfBuffer(atomic_ullong **a1, atomic_ullong **a2, uint64_t a3)
{
  if (*(void *)(a3 - 8)) {
    uint64_t v3 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v3 = 0;
  }
  unsigned int v4 = *a2;
  *a1 = *a2;
  swift_retain(v4);
  return (char *)v4 + ((*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80));
}

void *_swift_pod_copy(void *a1, const void *a2, uint64_t a3)
{
  return memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
}

void *_swift_pod_direct_initializeBufferWithCopyOfBuffer(void *a1, const void *a2, uint64_t a3)
{
  return memcpy(a1, a2, *(void *)(*(void *)(a3 - 8) + 64));
}

uint64_t swift::installCommonValueWitnesses(uint64_t result, void **a2)
{
  int v2 = *(_DWORD *)(result + 16);
  if ((v2 & 0x10000) != 0)
  {
    if ((v2 & 0x100000) == 0) {
      a2[4] = _swift_pod_copy;
    }
  }
  else
  {
    int64_t v3 = *(_DWORD *)(result + 16) | (*(void *)result << 16) | ((unint64_t)(*(_DWORD *)(result + 20) != 0) << 48);
    if (v3 <= 524294)
    {
      switch(v3)
      {
        case 65536:
          unsigned int v4 = &value witness table for Builtin.Int8;
          goto LABEL_23;
        case 131073:
          unsigned int v4 = &value witness table for Builtin.Int16;
          goto LABEL_23;
        case 262147:
          unsigned int v4 = &value witness table for Builtin.Int32;
          goto LABEL_23;
      }
    }
    else if (v3 > 2097182)
    {
      if (v3 == 2097183)
      {
        unsigned int v4 = (ValueWitnessTable *)value witness table for Builtin.Int256;
        goto LABEL_23;
      }
      if (v3 == 4194367)
      {
        unsigned int v4 = (ValueWitnessTable *)value witness table for Builtin.Int512;
        goto LABEL_23;
      }
    }
    else
    {
      if (v3 == 524295)
      {
        unsigned int v4 = &value witness table for Builtin.Int64;
        goto LABEL_23;
      }
      if (v3 == 1048591)
      {
        unsigned int v4 = &value witness table for Builtin.Int128;
LABEL_23:
        *a2 = v4->initializeBufferWithCopyOfBuffer;
        a2[1] = v4->destroy;
        a2[2] = v4->initializeWithCopy;
        a2[3] = v4->assignWithCopy;
        a2[4] = v4->initializeWithTake;
        a2[5] = v4->assignWithTake;
        a2[6] = v4->getEnumTagSinglePayload;
        a2[7] = v4->storeEnumTagSinglePayload;
        return result;
      }
    }
    if ((v2 & 0x20000) != 0) {
      uint64_t v5 = _swift_pod_indirect_initializeBufferWithCopyOfBuffer;
    }
    else {
      uint64_t v5 = _swift_pod_direct_initializeBufferWithCopyOfBuffer;
    }
    *a2 = v5;
    a2[1] = _swift_pod_destroy;
    a2[2] = _swift_pod_copy;
    a2[4] = _swift_pod_copy;
    a2[3] = _swift_pod_copy;
    a2[5] = _swift_pod_copy;
  }
  return result;
}

uint64_t swift_initStructMetadata(uint64_t a1, __int16 a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  v34[0] = 0;
  if (a3)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    unint64_t v7 = 0;
    LOBYTE(v8) = 1;
    LOBYTE(v9) = 1;
    do
    {
      uint64_t v10 = *(void *)(a4 + 8 * v5);
      int v11 = *(_DWORD *)(v10 + 16);
      unint64_t v12 = v11;
      unint64_t v13 = (v6 + v12) & ~v12;
      if (*(_DWORD *)(a5 + 4 * v5) != v13)
      {
        *(_DWORD *)(a5 + 4 * v5) = v13;
        int v11 = *(_DWORD *)(v10 + 16);
        unint64_t v12 = v11;
      }
      unint64_t v6 = *(void *)v10 + v13;
      if (v7 <= v12) {
        unint64_t v7 = v12;
      }
      int v8 = ((v11 & 0x10000) == 0) & v8;
      int v9 = ((v11 & 0x100000) == 0) & v9;
      ++v5;
    }
    while (a3 != v5);
    if (v8) {
      int v14 = 0;
    }
    else {
      int v14 = 0x10000;
    }
    if (v7 >= 8 || v6 >= 0x19) {
      int v16 = 0;
    }
    else {
      int v16 = v9;
    }
    v34[0] = v6;
    int v17 = v7 & 0xFFECFFFF;
    if (!v9)
    {
      int v18 = 0x100000;
      goto LABEL_21;
    }
  }
  else
  {
    int v17 = 0;
    unint64_t v6 = 0;
    int v14 = 0;
    unint64_t v7 = 0;
    int v16 = 1;
  }
  int v18 = 0;
LABEL_21:
  if (v16) {
    int v19 = 0;
  }
  else {
    int v19 = 0x20000;
  }
  int v20 = v18 | v17 | v14 | v19;
  int v35 = v20;
  unint64_t v21 = (v6 + v7) & ~v7;
  if (v21 <= 1) {
    uint64_t v22 = 1;
  }
  else {
    uint64_t v22 = v21;
  }
  v34[1] = v22;
  if (!a3)
  {
    unsigned int v25 = 0;
    goto LABEL_49;
  }
  unint64_t v23 = a3 - 1;
  if (a3 == 1)
  {
    unint64_t v24 = 0;
    unsigned int v25 = 0;
    goto LABEL_45;
  }
  unsigned int v25 = 0;
  unint64_t v24 = 0;
  if (!a3)
  {
    LODWORD(v23) = 0;
LABEL_45:
    unsigned int v30 = v23 + 1;
    do
    {
      unsigned int v31 = *(_DWORD *)(*(void *)(a4 + 8 * v24) + 20);
      if (v31 > v25) {
        unsigned int v25 = v31;
      }
      unint64_t v24 = v30++;
    }
    while (v24 < a3);
    goto LABEL_49;
  }
  unint64_t v26 = HIDWORD(v23);
  LODWORD(v23) = 0;
  if (v26) {
    goto LABEL_45;
  }
  unsigned int v27 = 0;
  unint64_t v24 = a3 & 0xFFFFFFFFFFFFFFFELL;
  LODWORD(v23) = a3 & 0xFFFFFFFE;
  uint64_t v28 = a4 + 8;
  unint64_t v29 = a3 & 0xFFFFFFFFFFFFFFFELL;
  do
  {
    if (*(_DWORD *)(*(void *)(v28 - 8) + 20) > v26) {
      LODWORD(v26) = *(_DWORD *)(*(void *)(v28 - 8) + 20);
    }
    if (*(_DWORD *)(*(void *)v28 + 20) > v27) {
      unsigned int v27 = *(_DWORD *)(*(void *)v28 + 20);
    }
    v28 += 16;
    v29 -= 2;
  }
  while (v29);
  unsigned int v25 = v26 <= v27 ? v27 : v26;
  if (v24 != a3) {
    goto LABEL_45;
  }
LABEL_49:
  MutableVWTableForInit = (void **)getMutableVWTableForInit(a1, a2);
  unsigned int v36 = v25;
  uint64_t result = swift::installCommonValueWitnesses((uint64_t)v34, MutableVWTableForInit);
  MutableVWTableForInit[8] = (void *)v6;
  MutableVWTableForInit[9] = (void *)v22;
  *((_DWORD *)MutableVWTableForInit + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v20;
  *((_DWORD *)MutableVWTableForInit + 21) = v25;
  return result;
}

_WORD *getMutableVWTableForInit(uint64_t a1, __int16 a2)
{
  int v2 = (void *)(a1 - 8);
  if (*(void *)(a1 - 8))
  {
    uint64_t v3 = *(void *)(a1 - 8);
    if ((a2 & 0x100) == 0)
    {
LABEL_3:
      __int16 v6 = 12;
      uint64_t result = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v6, 0x58uLL, 8);
      *(void *)uint64_t result = *(void *)v3;
      *((void *)result + 1) = *(void *)(v3 + 8);
      *((void *)result + 2) = *(void *)(v3 + 16);
      *((void *)result + 3) = *(void *)(v3 + 24);
      *((void *)result + 4) = *(void *)(v3 + 32);
      *((void *)result + 5) = *(void *)(v3 + 40);
      *((void *)result + 6) = *(void *)(v3 + 48);
      *((void *)result + 7) = *(void *)(v3 + 56);
      long long v5 = *(_OWORD *)(v3 + 64);
      *((void *)result + 1swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = *(void *)(v3 + 80);
      *((_OWORD *)result + 4) = v5;
      *int v2 = result;
      return result;
    }
  }
  else
  {
    uint64_t v3 = 0;
    if ((a2 & 0x100) == 0) {
      goto LABEL_3;
    }
  }
  return (_WORD *)v3;
}

uint64_t swift_initStructMetadataWithLayoutString(uint64_t *a1, __int16 a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v59 = 0;
  unint64_t v60 = 0;
  unint64_t v61 = 0;
  if (a3)
  {
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    unsigned int v14 = 1;
    LOBYTE(v15) = 1;
    LOBYTE(v16) = 1;
    do
    {
      uint64_t v17 = *(void *)(a4 + 8 * v11);
      if (!*(unsigned char *)(a5 + v11)) {
        uint64_t v17 = *(void *)(v17 - 8) + 64;
      }
      int v18 = *(_DWORD *)(v17 + 16);
      unint64_t v19 = v18;
      unint64_t v20 = (v12 + v19) & ~v19;
      if (*(_DWORD *)(a6 + 4 * v11) != v20)
      {
        *(_DWORD *)(a6 + 4 * v11) = v20;
        int v18 = *(_DWORD *)(v17 + 16);
        unint64_t v19 = v18;
      }
      unint64_t v12 = *(void *)v17 + v20;
      if (v13 <= v19) {
        unint64_t v13 = v19;
      }
      int v15 = ((v18 & 0x10000) == 0) & v15;
      int v16 = ((v18 & 0x100000) == 0) & v16;
      uint64_t v11 = v14++;
    }
    while (v11 != a3);
    if (v15) {
      int v21 = 0;
    }
    else {
      int v21 = 0x10000;
    }
    if (v13 >= 8 || v12 >= 0x19) {
      int v23 = 0;
    }
    else {
      int v23 = v16;
    }
    unint64_t v59 = *(void *)v17 + v20;
    int v24 = v13 & 0xFFECFFFF;
    if (!v16)
    {
      int v25 = 0x100000;
      goto LABEL_23;
    }
  }
  else
  {
    int v24 = 0;
    unint64_t v12 = 0;
    int v21 = 0;
    unint64_t v13 = 0;
    int v23 = 1;
  }
  int v25 = 0;
LABEL_23:
  if (v23) {
    unsigned int v26 = 0;
  }
  else {
    unsigned int v26 = 0x20000;
  }
  int v27 = v25 | v24 | v21 | v26;
  unint64_t v61 = v25 | v24 | v21 | (unint64_t)v26;
  unint64_t v28 = (v12 + v13) & ~v13;
  if (v28 <= 1) {
    unint64_t v28 = 1;
  }
  unint64_t v53 = v28;
  unint64_t v60 = v28;
  if (a3)
  {
    unint64_t v29 = 0;
    unsigned int v30 = 0;
    uint64_t v31 = 0;
    unsigned int v32 = 1;
    do
    {
      if (*(unsigned char *)(a5 + v29))
      {
        if (*(unsigned __int8 *)(a5 + v29) < 5u) {
          v31 += 8;
        }
        unsigned int v34 = *(_DWORD *)(*(void *)(a4 + 8 * v29) + 20);
        if (v34 > v30) {
          unsigned int v30 = v34;
        }
      }
      else
      {
        unint64_t v33 = *(unint64_t **)(a4 + 8 * v29);
        if (*(_DWORD *)(*(v33 - 1) + 84) > v30) {
          unsigned int v30 = *(_DWORD *)(*(v33 - 1) + 84);
        }
        v31 += _swift_refCountBytesForMetatype(v33);
      }
      unint64_t v29 = v32++;
    }
    while (v29 < a3);
  }
  else
  {
    uint64_t v31 = 0;
    unsigned int v30 = 0;
  }
  LOWORD(v57) = 26;
  int v35 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v57, (v31 + 31) & 0xFFFFFFFFFFFFFFF8, 1);
  unsigned int v36 = v35;
  *((void *)v35 + 1) = v31;
  uint64_t v37 = 16;
  uint64_t v57 = (uint64_t *)v35;
  uint64_t v58 = 16;
  unint64_t v55 = 0;
  unint64_t v56 = 0;
  uint64_t v54 = 0;
  if (a3)
  {
    unint64_t v38 = 0;
    unsigned int v39 = 1;
    do
    {
      unsigned int v41 = *(unsigned __int8 *)(a5 + v38);
      uint64_t v42 = *(void *)(a4 + 8 * v38);
      if (*(unsigned char *)(a5 + v38))
      {
        unint64_t v43 = (v56 + *(unsigned __int8 *)(v42 + 16)) & ~(unint64_t)*(unsigned __int8 *)(v42 + 16);
        if (v41 <= 4)
        {
          if (v41 >= 3) {
            uint64_t v44 = 0x700000000000000;
          }
          else {
            uint64_t v44 = 0x600000000000000;
          }
          uint64_t v45 = v58;
          *(uint64_t *)((char *)v57 + v58) = (v43 - v56 + v55) | v44;
          uint64_t v58 = v45 + 8;
        }
        unint64_t v40 = *(void *)v42;
        unint64_t v56 = *(void *)v42 + v43;
        unint64_t v55 = v40 - 8;
      }
      else
      {
        _swift_addRefCountStringForMetatype((uint64_t)&v57, &v54, (unint64_t *)v42, &v56, &v55);
      }
      unint64_t v38 = v39++;
    }
    while (v38 < a3);
    unint64_t v46 = v55;
    uint64_t v47 = v57;
    uint64_t v37 = v58;
    uint64_t v48 = v54 & 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v48 = 0;
    unint64_t v46 = 0;
    uint64_t v47 = (uint64_t *)v35;
  }
  *(uint64_t *)((char *)v47 + v37) = v46;
  *uint64_t v47 = v48;
  uint64_t v49 = *a1;
  if ((unint64_t)*a1 > 0x7FF) {
    LODWORD(v49) = 0;
  }
  if (!v49 || v49 == 773 || v49 == 515) {
    uint64_t v50 = a1 - 3;
  }
  else {
    uint64_t v50 = a1 - 2;
  }
  *uint64_t v50 = (uint64_t)v36;
  MutableVWTableForInit = getMutableVWTableForInit((uint64_t)a1, a2);
  *((void *)MutableVWTableForInit + 1) = swift_generic_destroy;
  *((void *)MutableVWTableForInit + 2) = swift_generic_initWithCopy;
  *((void *)MutableVWTableForInit + 4) = swift_generic_initWithTake;
  *((void *)MutableVWTableForInit + 3) = swift_generic_assignWithCopy;
  *((void *)MutableVWTableForInit + 5) = swift_generic_assignWithTake;
  HIDWORD(v61) = v30;
  uint64_t result = swift::installCommonValueWitnesses((uint64_t)&v59, (void **)MutableVWTableForInit);
  *((void *)MutableVWTableForInit + 8) = v12;
  *((void *)MutableVWTableForInit + 9) = v53;
  *((_DWORD *)MutableVWTableForInit + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v27;
  *((_DWORD *)MutableVWTableForInit + 21) = v30;
  return result;
}

uint64_t _swift_refCountBytesForMetatype(unint64_t *a1)
{
  uint64_t v2 = *(a1 - 1);
  if (v2) {
    uint64_t v3 = (uint64_t (**)())*(a1 - 1);
  }
  else {
    uint64_t v3 = 0;
  }
  if (!*(void *)(v2 + 64) || (*((unsigned char *)v3 + 82) & 1) == 0) {
    return 0;
  }
  if (*a1 != 769)
  {
    if (v3 == value witness table for Builtin.BridgeObject
      || v3 == value witness table for Builtin.NativeObject
      || v3 == (uint64_t (**)())&value witness table for Builtin.UnknownObject)
    {
      return 8;
    }
    if (*a1 <= 0x7FF) {
      int v9 = *a1;
    }
    else {
      int v9 = 0;
    }
    if (v9)
    {
      if (v9 != 773 || (uint64_t v10 = (unint64_t *)a1[1]) == 0)
      {
        uint64_t TypeContextDescriptor = swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a1);
        if (TypeContextDescriptor && (*(unsigned char *)(TypeContextDescriptor + 2) & 0x10) != 0) {
          return *(void *)(*(a1 - 2) + 8);
        }
        unint64_t v12 = *a1;
        if (*a1 > 0x7FF) {
          LODWORD(v12) = 0;
        }
        BOOL v13 = v12 == 771 || v12 == 774;
        goto LABEL_37;
      }
    }
    else
    {
      uint64_t v10 = a1;
    }
    BOOL v13 = (v10[4] & 2) == 0;
LABEL_37:
    if (v13) {
      return 8;
    }
    else {
      return 16;
    }
  }
  if (!a1[1]) {
    return 0;
  }
  unint64_t v6 = 0;
  uint64_t v4 = 0;
  do
    v4 += _swift_refCountBytesForMetatype(a1[2 * v6++ + 3]);
  while (v6 < a1[1]);
  return v4;
}

uint64_t _swift_addRefCountStringForMetatype(uint64_t result, void *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  long long v5 = a3 - 1;
  unint64_t v6 = *a4;
  uint64_t v7 = *(a3 - 1);
  int v8 = *(_DWORD *)(v7 + 80);
  unint64_t v9 = (*a4 + v8) & ~(unint64_t)v8;
  *a4 = v9;
  uint64_t v11 = (void *)(v7 + 64);
  uint64_t v10 = *(void *)(v7 + 64);
  if (!v10) {
    return result;
  }
  unint64_t v14 = v9 - v6 + *a5;
  if ((v8 & 0x10000) == 0)
  {
    unint64_t v15 = v14 + v10;
LABEL_4:
    *a5 = v15;
LABEL_25:
    *a4 += *v11;
    return result;
  }
  int v18 = (uint64_t *)result;
  unint64_t v19 = *a3;
  if (*a3 != 769)
  {
    if ((uint64_t (**)())v7 == value witness table for Builtin.NativeObject)
    {
      uint64_t v22 = v14 | 0x200000000000000;
      goto LABEL_22;
    }
    if ((ValueWitnessTable *)v7 != &value witness table for Builtin.UnknownObject)
    {
      if ((uint64_t (**)())v7 == value witness table for Builtin.BridgeObject)
      {
        uint64_t v22 = v14 | 0x800000000000000;
        goto LABEL_22;
      }
      if (v19 > 0x7FF) {
        LODWORD(v19) = 0;
      }
      int v21 = a3;
      if (!v19 || v19 == 773 && (int v21 = (unint64_t *)a3[1]) != 0)
      {
        if ((v21[4] & 2) == 0) {
          goto LABEL_19;
        }
      }
      else
      {
        uint64_t result = swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a3);
        if (result && (*(unsigned char *)(result + 2) & 0x10) != 0)
        {
          unsigned int v34 = (uint64_t *)*(a3 - 2);
          size_t v35 = v34[1];
          if (!v35)
          {
            unint64_t v39 = *v5;
            *a5 += *(void *)(*v5 + 64);
            unint64_t v23 = v39;
            goto LABEL_24;
          }
          uint64_t v40 = *(a3 - 2);
          uint64_t v37 = *v34;
          unsigned int v36 = v34 + 2;
          *a2 |= v37;
          uint64_t result = (uint64_t)memcpy((void *)(*v18 + v18[1]), v36, v35);
          if (v37 < 0) {
            uint64_t result = swift::swift_resolve_resilientAccessors(*v18, v18[1], (uint64_t)v36, a3);
          }
          if (v14)
          {
            uint64_t v38 = v18[1];
            *(void *)(*v18 + v38) += v14;
            v18[1] = v38;
          }
          *a5 = *(void *)(v35 + v40 + 16);
          v18[1] += v35;
          goto LABEL_23;
        }
        if (*a3 <= 0x7FF) {
          int v24 = *a3;
        }
        else {
          int v24 = 0;
        }
        if (v24 == 774 || v24 == 771)
        {
          if (*a3 == 771) {
            int v25 = a3;
          }
          else {
            int v25 = 0;
          }
          uint64_t v26 = 0xE00000000000000;
          if (*((int *)v25 + 2) >= 0) {
            uint64_t v26 = 0x500000000000000;
          }
          *(void *)(*v18 + v18[1]) = v26 | v14;
          v18[1] += 8;
          uint64_t v27 = *(a3 - 1);
          uint64_t v29 = *(void *)(v27 + 64);
          uint64_t v11 = (void *)(v27 + 64);
          uint64_t v28 = v29;
          BOOL v30 = *((int *)v25 + 2) < 0;
          uint64_t v31 = -24;
          if (!v30) {
            uint64_t v31 = -8;
          }
          unint64_t v15 = v31 + v28;
          goto LABEL_4;
        }
      }
      *(void *)(*v18 + v18[1]) = v14 | 0xC00000000000000;
      uint64_t v32 = *v18;
      uint64_t v33 = v18[1] + 8;
      v18[1] = v33;
      *(void *)(v32 + v33) = a3;
      v18[1] += 8;
      *a5 = 0;
      unint64_t v23 = *(a3 - 1);
      goto LABEL_24;
    }
LABEL_19:
    uint64_t v22 = v14 | 0xA00000000000000;
LABEL_22:
    *(void *)(*(void *)result + *(void *)(result + 8)) = v22;
    *(void *)(result + 8) += 8;
    *a5 = 0;
LABEL_23:
    unint64_t v23 = *v5;
LABEL_24:
    uint64_t v11 = (void *)(v23 + 64);
    goto LABEL_25;
  }
  *a5 = v14;
  if (a3[1])
  {
    unint64_t v20 = 0;
    do
      uint64_t result = _swift_addRefCountStringForMetatype(v18, a2, a3[2 * v20++ + 3], a4, a5);
    while (v20 < a3[1]);
  }
  return result;
}

_WORD *swift_initRawStructMetadata(uint64_t a1, __int16 a2, uint64_t *a3, int a4)
{
  uint64_t result = getMutableVWTableForInit(a1, a2);
  uint64_t v7 = *a3;
  uint64_t v8 = a3[1];
  int v9 = *((unsigned __int8 *)a3 + 16);
  int v10 = *((_DWORD *)a3 + 5);
  if (a4 >= 0)
  {
    uint64_t v7 = v8 * a4;
    uint64_t v8 = v7;
  }
  *((void *)result + 8) = v7;
  *((void *)result + 9) = v8;
  *((_DWORD *)result + 2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v9 | 0x800000;
  *((_DWORD *)result + 21) = v10;
  return result;
}

_WORD *swift_relocateClassMetadata(uint64_t a1, int *a2)
{
  return _swift_relocateClassMetadata(a1, a2);
}

uint64_t supportsLazyObjcClassNames(void)
{
  if (qword_1EB208A18 != -1) {
    dispatch_once_f(&qword_1EB208A18, &supportsLazyObjcClassNames(void)::$_0::operator() const(void)::TheLazy, (dispatch_function_t)supportsLazyObjcClassNames(void)::$_0::operator() const(void)::{lambda(void *)#1}::__invoke);
  }
  return supportsLazyObjcClassNames(void)::$_0::operator() const(void)::TheLazy;
}

uint64_t getSuperclassMetadata(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2 + 64;
  uint64_t v4 = *(void *)(a2 + 64);
  uint64_t v6 = *(int *)(v4 + 20);
  uint64_t v7 = (unsigned char *)(v4 + 20 + v6);
  if (v6) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8) {
    return 0;
  }
  SymbolicMangledNameStringRef = swift::Demangle::__runtime::makeSymbolicMangledNameStringRef(v7, (const char *)a2);
  unint64_t v12 = v11;
  v36[0] = SymbolicMangledNameStringRef;
  v36[1] = v11;
  int v30 = 0;
  uint64_t TypeContextDescriptor = swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor((unint64_t *)a2);
  if (TypeContextDescriptor) {
    uint64_t v14 = TypeContextDescriptor;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v31 = v14;
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs((unint64_t *)a2);
  uint64_t v33 = v35;
  uint64_t v34 = 0x800000000;
  v35[32] = 0;
  v26[0] = &unk_1ECA066A0;
  v26[1] = &v30;
  uint64_t v27 = v26;
  v24[0] = &unk_1ECA066E8;
  v24[1] = &v30;
  int v25 = v24;
  swift_getTypeByMangledName(v28, a1, SymbolicMangledNameStringRef, v12, GenericArgs, v26, v24);
  if (v25 == v24)
  {
    (*(void (**)(void *))(v24[0] + 32))(v24);
  }
  else if (v25)
  {
    (*(void (**)(void))(*v25 + 40))();
  }
  if (v27 == v26)
  {
    (*(void (**)(void *))(v26[0] + 32))(v26);
    int v15 = v29;
    if (v29)
    {
LABEL_18:
      if (v15 == 1)
      {
        uint64_t v17 = *(void *)v5 + 8 + *(int *)(*(void *)v5 + 8);
        int v18 = v22;
        __swift::__runtime::llvm::StringRef::str(v36, (uint64_t)v22);
        if (v23 < 0) {
          int v18 = (void *)v22[0];
        }
        uint64_t v19 = ((uint64_t (*)(void, void, void))v28[1])(v28[0], 0, 0);
        swift::fatalError(0, "failed to demangle superclass of %s from mangled name '%s': %s\n", v20, v21, v17, v18, v19);
      }
      uint64_t v9 = 0;
      goto LABEL_22;
    }
  }
  else
  {
    if (v27) {
      (*(void (**)(void))(*v27 + 40))();
    }
    int v15 = v29;
    if (v29) {
      goto LABEL_18;
    }
  }
  uint64_t v9 = v28[0];
LABEL_22:
  if (v33 != v35) {
    free(v33);
  }
  return v9;
}

uint64_t swift::SubstGenericParametersFromMetadata::SubstGenericParametersFromMetadata(uint64_t a1, unint64_t *a2)
{
  *(_DWORD *)a1 = 0;
  uint64_t TypeContextDescriptor = swift::TargetMetadata<swift::InProcess>::getTypeContextDescriptor(a2);
  if (!TypeContextDescriptor)
  {
    *(void *)(a1 + 8) = 0;
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    GenericArgs = 0;
    goto LABEL_6;
  }
  *(void *)(a1 + 8) = TypeContextDescriptor;
  if (!a2) {
    goto LABEL_5;
  }
LABEL_3:
  GenericArgs = swift::TargetMetadata<swift::InProcess>::getGenericArgs(a2);
LABEL_6:
  *(void *)(a1 + 16) = GenericArgs;
  *(void *)(a1 + 24) = a1 + 40;
  *(void *)(a1 + 32) = 0x800000000;
  *(void *)(a1 + 296) = 0;
  return a1;
}

void *std::function<swift::TargetWitnessTable<swift::InProcess> const* ()(swift::TargetMetadata<swift::InProcess> const*,unsigned int)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void const* ()(unsigned int,unsigned int)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

const void **__swift::__runtime::llvm::StringRef::str@<X0>(const void **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (void *)a2;
  uint64_t v3 = *this;
  if (!*this)
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    return this;
  }
  size_t v4 = (size_t)this[1];
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v4 >= 0x17)
  {
    uint64_t v5 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v5 = v4 | 7;
    }
    uint64_t v6 = v5 + 1;
    uint64_t v7 = operator new(v5 + 1);
    v2[1] = v4;
    void v2[2] = v6 | 0x8000000000000000;
    *uint64_t v2 = v7;
    uint64_t v2 = v7;
  }
  else
  {
    *(unsigned char *)(a2 + 23) = v4;
    if (!v4) {
      goto LABEL_11;
    }
  }
  this = (const void **)memmove(v2, v3, v4);
LABEL_11:
  *((unsigned char *)v2 + v4) = 0;
  return this;
}

swift *swift_initClassMetadata(uint64_t a1, __int16 a2, size_t a3, uint64_t a4, uint64_t a5)
{
  return _swift_initClassMetadataImpl(a1, a2, a3, a4, a5, 0);
}

swift *_swift_initClassMetadataImpl(uint64_t a1, __int16 a2, size_t a3, uint64_t a4, uint64_t a5, char a6)
{
  if (a6) {
    unint64_t v8 = 1;
  }
  else {
    unint64_t v8 = 255;
  }
  if (a6) {
    uint64_t v9 = 257;
  }
  else {
    uint64_t v9 = 255;
  }
  uint64_t result = (swift *)getSuperclassMetadata(v9, a1);
  if (!result)
  {
    BOOL v13 = (swift **)(a1 + 8);
LABEL_14:
    *BOOL v13 = 0;
    uint64_t RootSuperclass = swift::getRootSuperclass(result);
    if (RootSuperclass) {
      unint64_t v12 = (swift *)RootSuperclass;
    }
    else {
      unint64_t v12 = 0;
    }
LABEL_18:
    *BOOL v13 = v12;
    if (_swift_initClassMetadataImpl(swift::TargetClassMetadata<swift::InProcess,swift::TargetAnyClassMetadataObjCInterop<swift::InProcess>> *,swift::ClassLayoutFlags,unsigned long,swift::TargetTypeLayout<swift::InProcess> const* const*,unsigned long *,BOOL)::onceToken != -1) {
      dispatch_once_f(&_swift_initClassMetadataImpl(swift::TargetClassMetadata<swift::InProcess,swift::TargetAnyClassMetadataObjCInterop<swift::InProcess>> *,swift::ClassLayoutFlags,unsigned long,swift::TargetTypeLayout<swift::InProcess> const* const*,unsigned long *,BOOL)::onceToken, 0, (dispatch_function_t)_swift_initClassMetadataImpl(swift::TargetClassMetadata<swift::InProcess,swift::TargetAnyClassMetadataObjCInterop<swift::InProcess>> *,swift::ClassLayoutFlags,unsigned long,swift::TargetTypeLayout<swift::InProcess> const* const*,unsigned long *,BOOL)::$_0::__invoke);
    }
    int v15 = *v13;
    __int16 v16 = a2;
    if (v15)
    {
      uint64_t v17 = v15;
      for (unint64_t i = v15; ; unint64_t i = (swift *)*((void *)i + 1))
      {
        if ((*((unsigned char *)i + 32) & 2) == 0)
        {
LABEL_83:
          if ((**(unsigned char **)(a1 + 64) & 0x80) != 0
            || (*((unsigned char *)v17 + 32) & 2) != 0 && (**((unsigned char **)v17 + 8) & 0x80) != 0)
          {
            Class Class = object_getClass((id)a1);
            Class v52 = object_getClass(v17);
            if (v52) {
              Class v53 = v52;
            }
            else {
              Class v53 = 0;
            }
            *((void *)Class + 1) = v53;
          }
          goto LABEL_90;
        }
        uint64_t v19 = *((void *)i + 8) ? (int *)*((void *)i + 8) : 0;
        int v20 = *v19;
        if ((*v19 & 0x80) != 0)
        {
          uint64_t v21 = v19 ? (uint64_t)v19 : 0;
          if (*(_WORD *)(v21 + 56)) {
            break;
          }
        }
LABEL_44:
        if ((v16 & 0x100) != 0 || (v20 & 0x80000000) == 0) {
          goto LABEL_72;
        }
        if (v19) {
          uint64_t v28 = v19;
        }
        else {
          uint64_t v28 = 0;
        }
        unsigned __int16 v29 = (unsigned int *)(swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v28)
                             + 4 * (((unint64_t)*(unsigned int *)v28 >> 29) & 1)
                             + 4 * ((*(_DWORD *)v28 & 0x30000) == 0x20000)
                             + 12 * ((*(_DWORD *)v28 & 0x30000) == 0x10000));
        if ((*v19 & 0x20000000) != 0)
        {
          uint64_t v32 = v19[6];
          if (v32) {
            uint64_t v33 = (atomic_ullong *)((char *)v19 + v32 + 24);
          }
          else {
            uint64_t v33 = 0;
          }
          unint64_t explicit = atomic_load_explicit(v33, memory_order_acquire);
          if (!explicit)
          {
            computeMetadataBoundsFromSuperclass(v19, (uint64_t)v33);
            unint64_t explicit = v35;
          }
          unsigned int v30 = *v29 + (explicit >> 3);
          if (*v19 < 0)
          {
LABEL_58:
            if (v19) {
              unsigned int v36 = v19;
            }
            else {
              unsigned int v36 = 0;
            }
            unint64_t v31 = swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v36)
                + 4 * (((unint64_t)*(unsigned int *)v36 >> 29) & 1)
                + 4 * ((*(_DWORD *)v36 & 0x30000) == 0x20000)
                + 12 * ((*(_DWORD *)v36 & 0x30000) == 0x10000)
                + (((unint64_t)*(unsigned int *)v36 >> 28) & 8);
            if (*v19 < 0)
            {
              if (v19) {
                uint64_t v37 = v19;
              }
              else {
                uint64_t v37 = 0;
              }
              swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v37);
            }
            goto LABEL_68;
          }
        }
        else
        {
          unsigned int v30 = *v29;
          if (*v19 < 0) {
            goto LABEL_58;
          }
        }
        unint64_t v31 = 0;
LABEL_68:
        uint64_t v39 = v29[1];
        __int16 v16 = a2;
        if (v39)
        {
          uint64_t v40 = 8 * v30;
          unsigned int v41 = (void *)(a1 + v40);
          uint64_t v42 = (void *)((char *)v17 + v40);
          uint64_t v43 = 8 * v30;
          uint64_t v44 = (uint64_t)v17 + v43;
          uint64_t v45 = a1 + v43;
          do
          {
            v31 += 8;
            *v41++ = *v42;
            v44 += 8;
            ++v42;
            v45 += 8;
            --v39;
          }
          while (v39);
        }
LABEL_72:
        unsigned int v46 = v19[10];
        if (v46)
        {
          if ((*((unsigned char *)v19 + 3) & 0x20) != 0)
          {
            uint64_t v47 = v19[6];
            if (v47) {
              uint64_t v48 = (atomic_ullong *)((char *)v19 + v47 + 24);
            }
            else {
              uint64_t v48 = 0;
            }
            unint64_t v49 = atomic_load_explicit(v48, memory_order_acquire);
            if (!v49)
            {
              computeMetadataBoundsFromSuperclass(v19, (uint64_t)v48);
              unint64_t v49 = v50;
            }
            unsigned int v46 = v19[10] + (v49 >> 3);
          }
          memcpy((void *)(a1 + 8 * v46), (char *)v17 + 8 * v46, 8 * v19[9]);
        }
        if (!*((void *)i + 1)) {
          goto LABEL_83;
        }
      }
      if ((v20 & 0x20000000) == 0)
      {
        if ((v20 & 0x10000000) != 0)
        {
          int v22 = 0;
          uint64_t v23 = 6;
        }
        else
        {
          int v22 = v19[7];
          uint64_t v23 = 8;
        }
        LODWORD(v26) = v22 - v19[v23];
        if (!v19) {
          goto LABEL_42;
        }
LABEL_39:
        uint64_t v27 = v19;
LABEL_43:
        memcpy((void *)(a1 + 8 * (int)v26), (char *)v17 + 8 * (int)v26, 8 * *((unsigned __int16 *)v27 + 28));
        int v20 = *v19;
        goto LABEL_44;
      }
      uint64_t v24 = v19[6];
      if (v24) {
        int v25 = (void *)((char *)v19 + v24 + 24);
      }
      else {
        int v25 = 0;
      }
      if (*v25)
      {
        uint64_t v26 = *v25 >> 3;
        if (v19) {
          goto LABEL_39;
        }
      }
      else
      {
        computeMetadataBoundsFromSuperclass(v19, (uint64_t)v25);
        uint64_t v26 = v38 >> 3;
        if (v19) {
          goto LABEL_39;
        }
      }
LABEL_42:
      uint64_t v27 = 0;
      goto LABEL_43;
    }
LABEL_90:
    unint64_t v144 = (objc_class *)a1;
    if ((v16 & 0x100) != 0) {
      goto LABEL_158;
    }
    if (*(void *)(a1 + 64)) {
      uint64_t v54 = *(void *)(a1 + 64);
    }
    else {
      uint64_t v54 = 0;
    }
    if ((*(_DWORD *)v54 & 0x80000000) == 0)
    {
LABEL_95:
      if ((*(unsigned char *)(v54 + 3) & 0x40) != 0)
      {
        unint64_t v55 = v54 ? (unsigned char *)v54 : 0;
        unint64_t TrailingObjectsImpl = swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v55);
        unint64_t v58 = *(unsigned int *)v55;
        if ((v58 & 0x80000000) != 0)
        {
          unint64_t v60 = v55 ? v55 : 0;
          uint64_t v59 = *(unsigned int *)(swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v60)
                                + 4 * (((unint64_t)*(unsigned int *)v60 >> 29) & 1)
                                + 4 * ((*(_DWORD *)v60 & 0x30000) == 0x20000)
                                + 12 * ((*(_DWORD *)v60 & 0x30000) == 0x10000)
                                + 4);
        }
        else
        {
          uint64_t v59 = 0;
        }
        unint64_t v69 = (unsigned int *)(TrailingObjectsImpl
                             + 4 * ((v58 >> 29) & 1)
                             + 4 * ((v58 & 0x30000) == 0x20000)
                             + 12 * ((v58 & 0x30000) == 0x10000)
                             + 8 * ((v58 >> 31) & 1)
                             + 8 * v59);
        uint64_t MethodOverrideDescriptors = swift::TargetClassDescriptor<swift::InProcess>::getMethodOverrideDescriptors((unsigned int *)v54);
        BOOL v142 = v69;
        uint64_t v73 = *v69;
        if (v73)
        {
          uint64_t v74 = MethodOverrideDescriptors;
          uint64_t v75 = (int *)(MethodOverrideDescriptors + 4);
          while (1)
          {
            uint64_t v76 = *(v75 - 1);
            if (!v76) {
              break;
            }
            unint64_t v77 = (unsigned int **)(v74 + (v76 & 0xFFFFFFFFFFFFFFFELL));
            if (v76)
            {
              size_t v78 = *v77;
              if (!*v77) {
                break;
              }
            }
            else
            {
              if (!v77) {
                break;
              }
              size_t v78 = (unsigned int *)(v74 + (v76 & 0xFFFFFFFFFFFFFFFELL));
            }
            uint64_t v79 = v78;
            uint64_t v80 = *v75;
            if (!v80) {
              goto LABEL_121;
            }
LABEL_130:
            char v81 = (void *)(v74 + (v80 & 0xFFFFFFFFFFFFFFFELL) + 4);
            if (v80)
            {
              if (!*v81) {
                goto LABEL_121;
              }
              char v81 = (void *)*v81;
            }
            if (v79 && v81)
            {
              if ((*v79 & 0x80000000) != 0)
              {
                unint64_t v82 = swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v79)
                    + 4 * (((unint64_t)*v79 >> 29) & 1)
                    + 4 * ((*v79 & 0x30000) == 0x20000)
                    + 12 * ((*v79 & 0x30000) == 0x10000)
                    + (((unint64_t)*v79 >> 28) & 8);
                if ((*v79 & 0x80000000) != 0) {
                  uint64_t v83 = *(unsigned int *)(swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v79)
                }
                                        + 4 * (((unint64_t)*v79 >> 29) & 1)
                                        + 4 * ((*v79 & 0x30000) == 0x20000)
                                        + 12 * ((*v79 & 0x30000) == 0x10000)
                                        + 4);
                else {
                  uint64_t v83 = 0;
                }
              }
              else
              {
                unint64_t v82 = 0;
                uint64_t v83 = 0;
              }
              unint64_t v84 = v82 + 8 * v83;
              unint64_t v85 = (unint64_t)v81 - v82;
              if ((unint64_t)v81 < v82 || (unint64_t)v81 >= v84) {
                swift::fatalError(0, "resilient vtable at %p contains out-of-bounds method descriptor %p\n", v71, v72, v142, v81);
              }
              a1 = (uint64_t)v144;
              if ((*v79 & 0x80000000) != 0)
              {
                unint64_t v87 = (unsigned int *)(swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v79)
                                     + 4 * (((unint64_t)*v79 >> 29) & 1)
                                     + 4 * ((*v79 & 0x30000) == 0x20000)
                                     + 12 * ((*v79 & 0x30000) == 0x10000));
                if ((*v79 & 0x20000000) != 0) {
                  goto LABEL_148;
                }
LABEL_146:
                unsigned int v88 = *v87;
              }
              else
              {
                unint64_t v87 = 0;
                if ((*v79 & 0x20000000) == 0) {
                  goto LABEL_146;
                }
LABEL_148:
                uint64_t v89 = (int)v79[6];
                if (v89) {
                  BOOL v90 = (atomic_ullong *)((char *)v79 + v89 + 24);
                }
                else {
                  BOOL v90 = 0;
                }
                unint64_t v91 = atomic_load_explicit(v90, memory_order_acquire);
                if (!v91)
                {
                  computeMetadataBoundsFromSuperclass(v79, (uint64_t)v90);
                  unint64_t v91 = v92;
                }
                unsigned int v88 = *v87 + (v91 >> 3);
              }
              uint64_t v93 = (uint64_t *)((char *)v144 + 8 * (v85 >> 3) + 8 * v88);
              uint64_t v94 = v75[1];
              if (v94) {
                uint64_t v95 = v74 + v94 + 8;
              }
              else {
                uint64_t v95 = 0;
              }
              *uint64_t v93 = v95;
            }
LABEL_121:
            v74 += 12;
            v75 += 3;
            if (!--v73) {
              goto LABEL_158;
            }
          }
          uint64_t v79 = 0;
          uint64_t v80 = *v75;
          if (!v80) {
            goto LABEL_121;
          }
          goto LABEL_130;
        }
      }
LABEL_158:
      initClassFieldOffsetVector((swift *)a1, a3, a4, a5);
      if (*(void *)(a1 + 64)) {
        long long v96 = *(unsigned char **)(a1 + 64);
      }
      else {
        long long v96 = 0;
      }
      int v97 = *(_DWORD *)v96;
      if ((*(_DWORD *)v96 & 0x80) != 0)
      {
        if (qword_1EB208A18 != -1) {
          dispatch_once_f(&qword_1EB208A18, &supportsLazyObjcClassNames(void)::$_0::operator() const(void)::TheLazy, (dispatch_function_t)supportsLazyObjcClassNames(void)::$_0::operator() const(void)::{lambda(void *)#1}::__invoke);
        }
        if (supportsLazyObjcClassNames(void)::$_0::operator() const(void)::TheLazy)
        {
          *(void *)((*(void *)(a1 + 32) & 0x7FFFFFFFF8) + 0x18) = 0;
          uint64_t v112 = *((void *)object_getClass((id)a1) + 4) & 0x7FFFFFFFF8;
          *(void *)(v112 + 16) = a1;
          *(void *)(v112 + 24) = 0;
          uint64_t v113 = *(void *)(a1 + 32);
        }
        else
        {
          Class v114 = object_getClass((id)a1);
          unsigned __int8 v115 = copyGenericClassObjCName(a1);
          uint64_t v113 = *(void *)(a1 + 32);
          *(void *)((v113 & 0x7FFFFFFFF8) + 0x18) = v115;
          *(void *)((*((void *)v114 + 4) & 0x7FFFFFFFF8) + 0x18) = v115;
        }
        memset(v148, 0, sizeof(v148));
        if (a3)
        {
          uint64_t v116 = v113 & 0x7FFFFFFFF8;
          unint64_t v117 = *(const void **)((v113 & 0x7FFFFFFFF8) + 0x30);
          unint64_t v118 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&getResilientMetadataAllocator(void)::allocator, (32 * a3) | 8, 4);
          memcpy(v118, v117, (32 * a3) | 8);
          uint64_t v119 = 0;
          int v120 = 0;
          os_unfair_lock_t v121 = 0;
          *(void *)(v116 + 48) = v118;
          uint64_t v122 = v118 + 4;
          uint64_t v124 = a4;
          uint64_t v123 = a5;
          do
          {
            uint64_t v125 = *(void *)(v124 + 8 * v119);
            uint64_t v126 = &v122[16 * v119];
            uint64_t v127 = *(void *)v126;
            if (*(void *)v126)
            {
              if (!v121)
              {
                if (a3 > 8)
                {
                  os_unfair_lock_t v121 = malloc_type_calloc(a3, 8uLL, 0x10040436913F5uLL);
                }
                else
                {
                  os_unfair_lock_t v121 = v148;
                  bzero(v148, 8 * a3);
                }
                uint64_t v124 = a4;
                uint64_t v123 = a5;
              }
              *((void *)v121 + v119) = v127;
            }
            *(void *)uint64_t v126 = v123 + 8 * v119;
            int v129 = *((_DWORD *)v126 + 7);
            unint64_t v128 = v126 + 14;
            if (*(void *)v125 != v129)
            {
              _DWORD *v128 = *(void *)v125;
              *(void *)&v122[16 * v119 + 8] = 0;
              int v130 = -1;
              do
                ++v130;
              while (*(unsigned __int8 *)(v125 + 16) + 1 != 1 << v130);
              *(_DWORD *)&v122[16 * v119 + 12] = v130;
            }
            uint64_t v119 = ++v120;
          }
          while (v120 != a3);
          swift_instantiateObjCClass(v144);
          if (v121)
          {
            uint64_t v131 = 0;
            do
            {
              v132 = (void *)*((void *)v121 + v131);
              if (v132)
              {
                uint64_t v133 = *(void *)(a5 + 8 * v131);
                if (*v132 != v133) {
                  void *v132 = v133;
                }
              }
              ++v131;
            }
            while (a3 != v131);
            if (v121 != v148) {
              free(v121);
            }
          }
          return 0;
        }
      }
      else
      {
        long long v98 = v96;
        uint64_t v100 = a4;
        uint64_t v99 = a5;
        if (a3)
        {
          uint64_t v101 = *(void *)(a1 + 32) & 0x7FFFFFFFF8;
          long long v102 = *(_WORD **)(v101 + 0x30);
          if (v102)
          {
            v145 = v96;
            uint64_t v103 = 0;
            int v104 = 0;
            char v105 = 0;
            do
            {
              unint64_t v106 = *(uint64_t **)(v100 + 8 * v103);
              uint64_t v107 = (uint64_t)&v102[16 * v103 + 4];
              unint64_t v108 = *(void **)v107;
              if (*(void *)v107)
              {
                uint64_t v109 = *(void *)(v99 + 8 * v103);
                if (*v108 != v109) {
                  void *v108 = v109;
                }
              }
              uint64_t v110 = *v106;
              if (*v106 != *(_DWORD *)(v107 + 28))
              {
                if ((v105 & 1) == 0)
                {
                  long long v102 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&getResilientMetadataAllocator(void)::allocator, (32 * a3) | 8, 4);
                  memcpy(v102, *(const void **)(v101 + 48), (32 * a3) | 8);
                  uint64_t v100 = a4;
                  uint64_t v99 = a5;
                  *(void *)(v101 + 48) = v102;
                  uint64_t v107 = (uint64_t)&v102[16 * v103 + 4];
                  uint64_t v110 = *v106;
                }
                *(_DWORD *)(v107 + 28) = v110;
                *(void *)(v107 + 16) = 0;
                int v111 = -1;
                do
                  ++v111;
                while (*((unsigned __int8 *)v106 + 16) + 1 != 1 << v111);
                *(_DWORD *)(v107 + 24) = v111;
                char v105 = 1;
              }
              uint64_t v103 = ++v104;
            }
            while (v104 != a3);
            int v97 = *(_DWORD *)v98;
            long long v96 = v145;
          }
        }
        if (v97 & 0x20000000) != 0 && (v98[28])
        {
          if (!v96) {
            long long v96 = 0;
          }
          uint64_t v134 = (int *)swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v96);
          uint64_t v135 = *v134;
          if (v135)
          {
            if ((int *)((char *)v134 + v135))
            {
              _objc_realizeClassFromSwift((Class)a1, (char *)v134 + v135);
              return 0;
            }
          }
        }
      }
      swift_instantiateObjCClass((objc_class *)a1);
      return 0;
    }
    if (v54) {
      unint64_t v56 = (unsigned char *)v54;
    }
    else {
      unint64_t v56 = 0;
    }
    unint64_t v61 = (unsigned int *)(swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v56)
                         + 4 * (((unint64_t)*(unsigned int *)v56 >> 29) & 1)
                         + 4 * ((*(_DWORD *)v56 & 0x30000) == 0x20000)
                         + 12 * ((*(_DWORD *)v56 & 0x30000) == 0x10000));
    if ((*(_DWORD *)v54 & 0x20000000) != 0)
    {
      uint64_t v64 = *(int *)(v54 + 24);
      if (v64) {
        uint64_t v65 = (atomic_ullong *)(v64 + v54 + 24);
      }
      else {
        uint64_t v65 = 0;
      }
      unint64_t v66 = atomic_load_explicit(v65, memory_order_acquire);
      if (!v66)
      {
        computeMetadataBoundsFromSuperclass((unsigned char *)v54, (uint64_t)v65);
        unint64_t v66 = v67;
      }
      unsigned int v62 = *v61 + (v66 >> 3);
      if ((*(_DWORD *)v54 & 0x80000000) == 0) {
        goto LABEL_108;
      }
    }
    else
    {
      unsigned int v62 = *v61;
      if ((*(_DWORD *)v54 & 0x80000000) == 0)
      {
LABEL_108:
        unint64_t v63 = 0;
LABEL_221:
        uint64_t v137 = v61[1];
        if (v137)
        {
          uint64_t v138 = (int *)(v63 + 4);
          unint64_t v139 = v63 + 4;
          do
          {
            uint64_t v140 = *v138;
            if (v140) {
              uint64_t v141 = v139 + v140;
            }
            else {
              uint64_t v141 = 0;
            }
            v138 += 2;
            *(void *)(a1 + 8 * v62) = v141;
            v139 += 8;
            ++v62;
            --v137;
          }
          while (v137);
        }
        goto LABEL_95;
      }
    }
    if (v54) {
      unint64_t v68 = (unsigned char *)v54;
    }
    else {
      unint64_t v68 = 0;
    }
    unint64_t v63 = swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v68)
        + 4 * (((unint64_t)*(unsigned int *)v68 >> 29) & 1)
        + 4 * ((*(_DWORD *)v68 & 0x30000) == 0x20000)
        + 12 * ((*(_DWORD *)v68 & 0x30000) == 0x10000)
        + (((unint64_t)*(unsigned int *)v68 >> 28) & 8);
    if ((*(_DWORD *)v54 & 0x80000000) != 0)
    {
      if (v54) {
        uint64_t v136 = (unsigned char *)v54;
      }
      else {
        uint64_t v136 = 0;
      }
      swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v136);
    }
    goto LABEL_221;
  }
  unint64_t v12 = result;
  if (*(void *)result == 773) {
    unint64_t v12 = (swift *)*((void *)result + 1);
  }
  if (v8 >= v11)
  {
    BOOL v13 = (swift **)(a1 + 8);
    if (v12) {
      goto LABEL_18;
    }
    goto LABEL_14;
  }
  return result;
}

swift *swift_initClassMetadata2(uint64_t a1, __int16 a2, size_t a3, uint64_t a4, uint64_t a5)
{
  return _swift_initClassMetadataImpl(a1, a2, a3, a4, a5, 1);
}

uint64_t swift_updateClassMetadata(objc_class *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return _swift_updateClassMetadataImpl(a1, a3, a4, a5, 0);
}

uint64_t _swift_updateClassMetadataImpl(objc_class *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  if (a5) {
    unint64_t v9 = 1;
  }
  else {
    unint64_t v9 = 255;
  }
  if (a5) {
    uint64_t v10 = 257;
  }
  else {
    uint64_t v10 = 255;
  }
  uint64_t result = getSuperclassMetadata(v10, (uint64_t)a1);
  if (result) {
    BOOL v13 = v9 >= v12;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13)
  {
    previously = a1;
    initClassFieldOffsetVector(a1, a2, a3, a4);
    if (a2)
    {
      uint64_t v14 = *((void *)a1 + 4) & 0x7FFFFFFFF8;
      int v15 = *(_WORD **)(v14 + 0x30);
      if (v15)
      {
        uint64_t v16 = 0;
        int v17 = 0;
        char v18 = 0;
        do
        {
          uint64_t v19 = *(uint64_t **)(a3 + 8 * v16);
          uint64_t v20 = (uint64_t)&v15[16 * v16 + 4];
          uint64_t v21 = *(void **)v20;
          if (*(void *)v20)
          {
            uint64_t v22 = *(void *)(a4 + 8 * v16);
            if (*v21 != v22) {
              *uint64_t v21 = v22;
            }
          }
          uint64_t v23 = *v19;
          if (*v19 != *(_DWORD *)(v20 + 28))
          {
            if ((v18 & 1) == 0)
            {
              int v15 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&getResilientMetadataAllocator(void)::allocator, (32 * a2) | 8, 4);
              memcpy(v15, *(const void **)(v14 + 48), (32 * a2) | 8);
              *(void *)(v14 + 48) = v15;
              uint64_t v20 = (uint64_t)&v15[16 * v16 + 4];
              uint64_t v23 = *v19;
            }
            *(_DWORD *)(v20 + 28) = v23;
            *(void *)(v20 + 16) = 0;
            int v24 = -1;
            do
              ++v24;
            while (*((unsigned __int8 *)v19 + 16) + 1 != 1 << v24);
            *(_DWORD *)(v20 + 24) = v24;
            char v18 = 1;
          }
          uint64_t v16 = ++v17;
        }
        while (v17 != a2);
      }
    }
    _objc_realizeClassFromSwift(previously, previously);
    return 0;
  }
  return result;
}

uint64_t swift_updateClassMetadata2(objc_class *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return _swift_updateClassMetadataImpl(a1, a3, a4, a5, 1);
}

uint64_t swift_lookUpClassMethod(uint64_t a1, uint64_t a2, int *a3)
{
  if (a3)
  {
    size_t v4 = a3;
    if (!a2)
    {
LABEL_3:
      uint64_t v5 = 0;
      goto LABEL_6;
    }
  }
  else
  {
    size_t v4 = 0;
    if (!a2) {
      goto LABEL_3;
    }
  }
  uint64_t v5 = a2;
LABEL_6:
  int v6 = *v4;
  if (*v4 < 0)
  {
    if (v4) {
      unint64_t v9 = v4;
    }
    else {
      unint64_t v9 = 0;
    }
    uint64_t v7 = (int *)(swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v9)
               + 4 * (((unint64_t)*(unsigned int *)v9 >> 29) & 1)
               + 4 * ((*(_DWORD *)v9 & 0x30000) == 0x20000)
               + 12 * ((*(_DWORD *)v9 & 0x30000) == 0x10000));
    int v6 = *v4;
    if (*v4 < 0)
    {
      if (v4) {
        uint64_t v10 = v4;
      }
      else {
        uint64_t v10 = 0;
      }
      unint64_t v8 = swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v10)
         + 4 * (((unint64_t)*(unsigned int *)v10 >> 29) & 1)
         + 4 * ((*(_DWORD *)v10 & 0x30000) == 0x20000)
         + 12 * ((*(_DWORD *)v10 & 0x30000) == 0x10000)
         + (((unint64_t)*(unsigned int *)v10 >> 28) & 8);
      int v6 = *v4;
      if (*v4 < 0)
      {
        if (v4) {
          unint64_t v11 = v4;
        }
        else {
          unint64_t v11 = 0;
        }
        swift::ABI::trailing_objects_internal::TrailingObjectsImpl<4,swift::TargetClassDescriptor<swift::InProcess>,swift::ABI::TrailingObjects<swift::TargetClassDescriptor<swift::InProcess>,swift::TargetTypeGenericContextDescriptorHeader<swift::InProcess>,swift::GenericParamDescriptor,swift::TargetGenericRequirementDescriptor<swift::InProcess>,swift::GenericPackShapeHeader,swift::GenericPackShapeDescriptor,swift::ConditionalInvertibleProtocolSet,swift::ConditionalInvertibleProtocolsRequirementCount,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>,swift::TargetConditionalInvertibleProtocolRequirement<swift::InProcess>,swift::TargetResilientSuperclass<swift::InProcess>,swift::TargetForeignMetadataInitialization<swift::InProcess>,swift::TargetSingletonMetadataInitialization<swift::InProcess>,swift::TargetVTableDescriptorHeader<swift::InProcess>,swift::TargetMethodDescriptor<swift::InProcess>,swift::TargetOverrideTableHeader<swift::InProcess>,swift::TargetMethodOverrideDescriptor<swift::InProcess>,swift::TargetObjCResilientClassStubInfo<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListCount<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadataAccessorsListEntry<swift::InProcess>,swift::TargetCanonicalSpecializedMetadatasCachingOnceToken<swift::InProcess>,swift::InvertibleProtocolSet>::getTrailingObjectsImpl(v11);
        int v6 = *v4;
      }
    }
    else
    {
      unint64_t v8 = 0;
    }
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0;
  }
  if ((v6 & 0x20000000) != 0)
  {
    uint64_t v13 = v4[6];
    if (v13) {
      uint64_t v14 = (atomic_ullong *)((char *)v4 + v13 + 24);
    }
    else {
      uint64_t v14 = 0;
    }
    unint64_t explicit = atomic_load_explicit(v14, memory_order_acquire);
    if (!explicit)
    {
      computeMetadataBoundsFromSuperclass(v4, (uint64_t)v14);
      unint64_t explicit = v16;
    }
    int v12 = *v7 + (explicit >> 3);
  }
  else
  {
    int v12 = *v7;
  }
  return *(void *)(a1 + 8 * (v12 + ((v5 - v8) >> 3)));
}

unint64_t swift_getMetatypeMetadata(unint64_t a1)
{
  unint64_t v65 = a1;
  unint64_t explicit = atomic_load_explicit(&qword_1EB208A58, memory_order_acquire);
  if (explicit && *(void *)(explicit + 24) == v65) {
    goto LABEL_105;
  }
  atomic_fetch_add_explicit(&MetatypeTypes, 1u, memory_order_acquire);
  do
  {
    unint64_t v2 = atomic_load_explicit(&qword_1EB208A38, memory_order_acquire);
    unint64_t v3 = atomic_load_explicit(&qword_1EB208A40, memory_order_acquire);
    unint64_t v4 = atomic_load_explicit(&dword_1EB208A34, memory_order_acquire);
  }
  while (v2 != atomic_load_explicit(&qword_1EB208A38, memory_order_acquire));
  if (v2) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5 && v4 != 0)
  {
    if (v7)
    {
      qword_1EB208A58 = *v7;
      unint64_t explicit = *v7;
      atomic_fetch_add_explicit(&MetatypeTypes, 0xFFFFFFFF, memory_order_release);
      goto LABEL_105;
    }
  }
  atomic_fetch_add_explicit(&MetatypeTypes, 0xFFFFFFFF, memory_order_release);
  unint64_t v66 = v65;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB208A48);
  unint64_t v8 = qword_1EB208A40;
  uint64_t v9 = qword_1EB208A40 & 3;
  BOOL v10 = v9 == 0;
  if ((qword_1EB208A40 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
    BOOL v10 = 1;
  }
  BOOL v64 = v10;
  if (v10) {
    int v11 = 4;
  }
  else {
    int v11 = *(unsigned __int8 *)(qword_1EB208A40 & 0xFFFFFFFFFFFFFFFCLL);
  }
  unint64_t v12 = dword_1EB208A34;
  uint64_t v13 = (_DWORD *)qword_1EB208A38;
  if (qword_1EB208A38) {
    uint64_t v14 = qword_1EB208A38 + 8;
  }
  else {
    uint64_t v14 = 0;
  }
  if (!v15)
  {
    uint64_t v63 = v14;
    uint64_t v19 = (v12 + 1);
    if ((1 << v11) / (unint64_t)((1 << v11) - v19) < 4)
    {
      unsigned int v25 = v16;
      unint64_t v26 = v8;
      if (!v13) {
        goto LABEL_81;
      }
    }
    else
    {
      unsigned int v20 = (v11 + 1);
      if (v20 >= 0x11) {
        unsigned int v21 = 4;
      }
      else {
        unsigned int v21 = 2;
      }
      if (v20 < 9) {
        size_t v22 = 1;
      }
      else {
        size_t v22 = v21;
      }
      unint64_t v23 = (unint64_t)malloc_type_calloc(2 << v11, v22, 0x4269077AuLL);
      if (!v23) {
        swift::hashable_support::findHashableBaseTypeOfHashableType();
      }
      uint64_t v24 = v63;
      unint64_t v61 = v12;
      uint64_t v62 = (v12 + 1);
      if (v22 != 1)
      {
        if (v22 == 4) {
          size_t v22 = 3;
        }
        else {
          size_t v22 = 2;
        }
      }
      unint64_t v26 = v22 | v23;
      *(unsigned char *)unint64_t v23 = v11 + 1;
      if (v11)
      {
        unint64_t v27 = v8 & 3;
        if (v9) {
          unint64_t v28 = v8 & 0xFFFFFFFFFFFFFFFCLL;
        }
        else {
          unint64_t v28 = 0;
        }
        unint64_t v29 = v26 & 3;
        if ((v26 & 3) != 0) {
          unint64_t v30 = v23 & 0xFFFFFFFFFFFFFFFCLL;
        }
        else {
          unint64_t v30 = 0;
        }
        uint64_t v31 = 1;
        uint64_t v32 = (void *)&unk_1EB1F3000;
        while (2)
        {
          switch(v27)
          {
            case 0uLL:
              uint64_t v33 = (v8 >> (4 * v31)) & 0xF;
              if (!v33) {
                goto LABEL_50;
              }
              goto LABEL_59;
            case 1uLL:
              LODWORD(v33) = *(unsigned __int8 *)(v28 + v31);
              if (*(unsigned char *)(v28 + v31)) {
                goto LABEL_59;
              }
              goto LABEL_50;
            case 2uLL:
              LODWORD(v33) = *(unsigned __int16 *)(v28 + 2 * v31);
              if (!*(_WORD *)(v28 + 2 * v31)) {
                goto LABEL_50;
              }
              goto LABEL_59;
            case 3uLL:
              LODWORD(v33) = *(_DWORD *)(v28 + 4 * v31);
              if (!v33) {
                goto LABEL_50;
              }
LABEL_59:
              unint64_t v34 = *(void *)(*(void *)(v24 + 8 * (v33 - 1)) + 24);
              {
                unint64_t v59 = v29;
                unint64_t v60 = v27;
                unint64_t v58 = v28;
                uint64_t v32 = &unk_1EB1F3000;
                unint64_t v28 = v58;
                unint64_t v29 = v59;
                uint64_t v24 = v63;
                unint64_t v27 = v60;
                if (v40)
                {
                  unint64_t v41 = __swift::__runtime::llvm::hashing::detail::fixed_seed_override;
                  if (!__swift::__runtime::llvm::hashing::detail::fixed_seed_override) {
                    unint64_t v41 = 0xFF51AFD7ED558CCDLL;
                  }
                  __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed = v41;
                  uint64_t v32 = (void *)&unk_1EB1F3000;
                  unint64_t v28 = v58;
                  unint64_t v29 = v59;
                  uint64_t v24 = v63;
                  unint64_t v27 = v60;
                }
              }
              unint64_t v35 = 0x9DDFEA08EB382D69 * ((v32[38] + 8 * v34) ^ HIDWORD(v34));
              unint64_t v36 = 0x9DDFEA08EB382D69 * (HIDWORD(v34) ^ (v35 >> 47) ^ v35);
              for (unint64_t i = 0x9DDFEA08EB382D69 * (v36 ^ (v36 >> 47)); ; unint64_t i = v39 + 1)
              {
                uint64_t v39 = i & ~(-2 << v11);
                if (v39)
                {
                  switch((int)v29)
                  {
                    case 1:
                      LODWORD(v38) = *(unsigned __int8 *)(v30 + v39);
                      break;
                    case 2:
                      LODWORD(v38) = *(unsigned __int16 *)(v30 + 2 * v39);
                      break;
                    case 3:
                      LODWORD(v38) = *(_DWORD *)(v30 + 4 * v39);
                      break;
                    default:
                      uint64_t v38 = (v26 >> (4 * v39)) & 0xF;
                      break;
                  }
                  if (!v38) {
                    break;
                  }
                }
              }
              if (v29 == 3)
              {
                *(_DWORD *)(v30 + 4 * v39) = v33;
              }
              else if (v29 == 2)
              {
                *(_WORD *)(v30 + 2 * v39) = v33;
              }
              else
              {
                *(unsigned char *)(v30 + v39) = v33;
              }
LABEL_50:
              if (!((unint64_t)++v31 >> v11)) {
                continue;
              }
              goto LABEL_77;
            default:
              JUMPOUT(0);
          }
        }
      }
LABEL_77:
      atomic_store(v26, (unint64_t *)&qword_1EB208A40);
      if (!v64)
      {
        uint64_t v42 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
        uint64_t v24 = v63;
        *uint64_t v42 = qword_1EB208A50;
        v42[1] = v8 & 0xFFFFFFFFFFFFFFFCLL;
        qword_1EB208A50 = (uint64_t)v42;
      }
      unint64_t v12 = v61;
      unsigned int v25 = v43;
      uint64_t v19 = v62;
      if (!v13) {
        goto LABEL_81;
      }
    }
    unint64_t v44 = (unint64_t)v13;
    if (v12 < *v13)
    {
LABEL_87:
      __int16 v67 = 4;
      unint64_t v49 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v67, 0x20uLL, 8);
      unint64_t explicit = (unint64_t)v49;
      unint64_t v50 = v65;
      int v51 = 772;
      v49[2] = 772;
      if (value witness table for Builtin.NativeObject.Type) {
        int v51 = v49 + 8;
      }
      v49[1] = value witness table for Builtin.NativeObject.Type;
      v49[3] = v50;
      *(void *)(v44 + 8 + 8 * v12) = v49;
      atomic_store(v19, (unsigned int *)&dword_1EB208A34);
      switch(v51)
      {
        case 1:
          unint64_t v52 = v26 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v26 & 3) == 0) {
            unint64_t v52 = 0;
          }
          atomic_store(v19, (unsigned __int8 *)(v52 + v25));
          break;
        case 2:
          unint64_t v53 = v26 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v26 & 3) == 0) {
            unint64_t v53 = 0;
          }
          atomic_store(v19, (unsigned __int16 *)(v53 + 2 * v25));
          break;
        case 3:
          unint64_t v54 = v26 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v26 & 3) == 0) {
            unint64_t v54 = 0;
          }
          atomic_store(v19, (unsigned int *)(v54 + 4 * v25));
          break;
        default:
          atomic_store((v19 << (4 * v25)) | v26, (unint64_t *)&qword_1EB208A40);
          break;
      }
      __dmb(0xBu);
      if (MetatypeTypes) {
        goto LABEL_104;
      }
      unint64_t v55 = (void **)qword_1EB208A50;
      if (qword_1EB208A50)
      {
        do
        {
          unint64_t v56 = (void **)*v55;
          free(v55[1]);
          free(v55);
          unint64_t v55 = v56;
        }
        while (v56);
      }
      goto LABEL_103;
    }
LABEL_81:
    unint64_t v45 = v12 + (v12 >> 2);
    if (v45 <= v12 + 1) {
      unint64_t v45 = v12 + 1;
    }
    size_t v46 = malloc_good_size(8 * v45 + 8);
    uint64_t v47 = malloc_type_malloc(v46, 0x1000D770uLL);
    if (!v47) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    unint64_t v44 = (unint64_t)v47;
    *uint64_t v47 = (v46 + 0x7FFFFFFF8) >> 3;
    if (v13)
    {
      memcpy(v47 + 2, v13 + 2, 8 * v12);
      uint64_t v48 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
      *uint64_t v48 = qword_1EB208A50;
      v48[1] = v13;
      qword_1EB208A50 = (uint64_t)v48;
    }
    atomic_store(v44, (unint64_t *)&qword_1EB208A38);
    goto LABEL_87;
  }
  unint64_t explicit = *v15;
  __dmb(0xBu);
  if (!MetatypeTypes)
  {
    int v17 = (void **)qword_1EB208A50;
    if (qword_1EB208A50)
    {
      do
      {
        char v18 = (void **)*v17;
        free(v17[1]);
        free(v17);
        int v17 = v18;
      }
      while (v18);
    }
LABEL_103:
    qword_1EB208A50 = 0;
  }
LABEL_104:
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB208A48);
  qword_1EB208A58 = explicit;
LABEL_105:
  if (explicit) {
    return explicit + 16;
  }
  else {
    return 0;
  }
}

unint64_t swift_getExistentialMetatypeMetadata(unint64_t a1)
{
  uint64_t v72 = (void *)a1;
  unint64_t explicit = atomic_load_explicit(&qword_1EB208A88, memory_order_acquire);
  if (explicit && *(void **)(explicit + 24) == v72) {
    goto LABEL_113;
  }
  atomic_fetch_add_explicit(&ExistentialMetatypes, 1u, memory_order_acquire);
  do
  {
    unint64_t v2 = atomic_load_explicit(&qword_1EB208A68, memory_order_acquire);
    unint64_t v3 = atomic_load_explicit(&qword_1EB208A70, memory_order_acquire);
    unint64_t v4 = atomic_load_explicit(&dword_1EB208A64, memory_order_acquire);
  }
  while (v2 != atomic_load_explicit(&qword_1EB208A68, memory_order_acquire));
  if (v2) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5 && v4 != 0)
  {
    if (v7)
    {
      qword_1EB208A88 = *v7;
      unint64_t explicit = *v7;
      atomic_fetch_add_explicit(&ExistentialMetatypes, 0xFFFFFFFF, memory_order_release);
      goto LABEL_113;
    }
  }
  atomic_fetch_add_explicit(&ExistentialMetatypes, 0xFFFFFFFF, memory_order_release);
  uint64_t v73 = v72;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB208A78);
  unint64_t v8 = qword_1EB208A70;
  uint64_t v9 = qword_1EB208A70 & 3;
  BOOL v10 = v9 == 0;
  if ((qword_1EB208A70 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
    BOOL v10 = 1;
  }
  BOOL v71 = v10;
  if (v10) {
    int v11 = 4;
  }
  else {
    int v11 = *(unsigned __int8 *)(qword_1EB208A70 & 0xFFFFFFFFFFFFFFFCLL);
  }
  unint64_t v12 = dword_1EB208A64;
  uint64_t v13 = (_DWORD *)qword_1EB208A68;
  if (qword_1EB208A68) {
    uint64_t v14 = qword_1EB208A68 + 8;
  }
  else {
    uint64_t v14 = 0;
  }
  if (!v15)
  {
    uint64_t v70 = v14;
    __src = v13 + 2;
    uint64_t v19 = (v12 + 1);
    if ((1 << v11) / (unint64_t)((1 << v11) - v19) < 4)
    {
      unsigned int v26 = v16;
      unint64_t v27 = v8;
      if (v13) {
        goto LABEL_80;
      }
    }
    else
    {
      unint64_t v68 = v13;
      unsigned int v20 = (v11 + 1);
      if (v20 >= 0x11) {
        unsigned int v21 = 4;
      }
      else {
        unsigned int v21 = 2;
      }
      if (v20 < 9) {
        size_t v22 = 1;
      }
      else {
        size_t v22 = v21;
      }
      unint64_t v23 = (unint64_t)malloc_type_calloc(2 << v11, v22, 0x4269077AuLL);
      if (!v23) {
        swift::hashable_support::findHashableBaseTypeOfHashableType();
      }
      uint64_t v24 = v14;
      char v25 = v11;
      unint64_t v66 = v12;
      uint64_t v67 = (v12 + 1);
      if (v22 != 1)
      {
        if (v22 == 4) {
          size_t v22 = 3;
        }
        else {
          size_t v22 = 2;
        }
      }
      unint64_t v27 = v22 | v23;
      *(unsigned char *)unint64_t v23 = v11 + 1;
      if (v11)
      {
        if (v9) {
          unint64_t v28 = v8 & 0xFFFFFFFFFFFFFFFCLL;
        }
        else {
          unint64_t v28 = 0;
        }
        unint64_t v29 = v27 & 3;
        if ((v27 & 3) != 0) {
          unint64_t v30 = v23 & 0xFFFFFFFFFFFFFFFCLL;
        }
        else {
          unint64_t v30 = 0;
        }
        uint64_t v31 = 1;
        uint64_t v32 = (void *)&unk_1EB1F3000;
        while (2)
        {
          switch(v8 & 3)
          {
            case 0uLL:
              uint64_t v33 = (v8 >> (4 * v31)) & 0xF;
              if (!v33) {
                goto LABEL_50;
              }
              goto LABEL_59;
            case 1uLL:
              LODWORD(v33) = *(unsigned __int8 *)(v28 + v31);
              if (*(unsigned char *)(v28 + v31)) {
                goto LABEL_59;
              }
              goto LABEL_50;
            case 2uLL:
              LODWORD(v33) = *(unsigned __int16 *)(v28 + 2 * v31);
              if (!*(_WORD *)(v28 + 2 * v31)) {
                goto LABEL_50;
              }
              goto LABEL_59;
            case 3uLL:
              LODWORD(v33) = *(_DWORD *)(v28 + 4 * v31);
              if (!v33) {
                goto LABEL_50;
              }
LABEL_59:
              unint64_t v34 = *(void *)(*(void *)(v24 + 8 * (v33 - 1)) + 24);
              {
                unint64_t v64 = v28;
                unint64_t v65 = v29;
                uint64_t v32 = &unk_1EB1F3000;
                unint64_t v28 = v64;
                unint64_t v29 = v65;
                char v25 = v11;
                uint64_t v24 = v70;
                if (v40)
                {
                  unint64_t v41 = __swift::__runtime::llvm::hashing::detail::fixed_seed_override;
                  if (!__swift::__runtime::llvm::hashing::detail::fixed_seed_override) {
                    unint64_t v41 = 0xFF51AFD7ED558CCDLL;
                  }
                  __swift::__runtime::llvm::hashing::detail::get_execution_seed(void)::seed = v41;
                  uint64_t v32 = (void *)&unk_1EB1F3000;
                  unint64_t v28 = v64;
                  unint64_t v29 = v65;
                  char v25 = v11;
                  uint64_t v24 = v70;
                }
              }
              unint64_t v35 = 0x9DDFEA08EB382D69 * ((v32[38] + 8 * v34) ^ HIDWORD(v34));
              unint64_t v36 = 0x9DDFEA08EB382D69 * (HIDWORD(v34) ^ (v35 >> 47) ^ v35);
              for (unint64_t i = 0x9DDFEA08EB382D69 * (v36 ^ (v36 >> 47)); ; unint64_t i = v39 + 1)
              {
                uint64_t v39 = i & ~(-2 << v11);
                if (v39)
                {
                  switch((int)v29)
                  {
                    case 1:
                      LODWORD(v38) = *(unsigned __int8 *)(v30 + v39);
                      break;
                    case 2:
                      LODWORD(v38) = *(unsigned __int16 *)(v30 + 2 * v39);
                      break;
                    case 3:
                      LODWORD(v38) = *(_DWORD *)(v30 + 4 * v39);
                      break;
                    default:
                      uint64_t v38 = (v27 >> (4 * v39)) & 0xF;
                      break;
                  }
                  if (!v38) {
                    break;
                  }
                }
              }
              if (v29 == 3)
              {
                *(_DWORD *)(v30 + 4 * v39) = v33;
              }
              else if (v29 == 2)
              {
                *(_WORD *)(v30 + 2 * v39) = v33;
              }
              else
              {
                *(unsigned char *)(v30 + v39) = v33;
              }
LABEL_50:
              if (!((unint64_t)++v31 >> v25)) {
                continue;
              }
              goto LABEL_77;
            default:
              JUMPOUT(0);
          }
        }
      }
LABEL_77:
      atomic_store(v27, (unint64_t *)&qword_1EB208A70);
      if (!v71)
      {
        uint64_t v42 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
        uint64_t v24 = v70;
        *uint64_t v42 = qword_1EB208A80;
        v42[1] = v8 & 0xFFFFFFFFFFFFFFFCLL;
        qword_1EB208A80 = (uint64_t)v42;
      }
      unint64_t v12 = v66;
      unsigned int v26 = v43;
      uint64_t v19 = v67;
      uint64_t v13 = v68;
      if (v68)
      {
LABEL_80:
        unint64_t v44 = (unint64_t)v13;
        if (v12 < *v13) {
          goto LABEL_87;
        }
      }
    }
    unint64_t v45 = v13;
    unint64_t v46 = v12 + (v12 >> 2);
    if (v46 <= v12 + 1) {
      unint64_t v46 = v12 + 1;
    }
    size_t v47 = malloc_good_size(8 * v46 + 8);
    uint64_t v48 = malloc_type_malloc(v47, 0x1000D770uLL);
    if (!v48) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    unint64_t v44 = (unint64_t)v48;
    *uint64_t v48 = (v47 + 0x7FFFFFFF8) >> 3;
    if (v45)
    {
      memcpy(v48 + 2, __src, 8 * v12);
      unint64_t v49 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
      *unint64_t v49 = qword_1EB208A80;
      v49[1] = v45;
      qword_1EB208A80 = (uint64_t)v49;
    }
    atomic_store(v44, (unint64_t *)&qword_1EB208A68);
LABEL_87:
    __int16 v74 = 6;
    unint64_t v50 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v74, 0x28uLL, 8);
    unint64_t explicit = (unint64_t)v50;
    int v51 = v72;
    *((void *)v50 + 2) = 0;
    *((_DWORD *)v50 + 8) = 0;
    uint64_t v52 = *v51;
    if (*v51 > 0x7FFuLL) {
      LODWORD(v52) = 0;
    }
    if (v52 == 774)
    {
      unint64_t v54 = (int *)(v51 + 2);
    }
    else
    {
      int v53 = 0;
      if (v52 != 771)
      {
LABEL_94:
        unint64_t v55 = v44 + 8;
        *((void *)v50 + 2) = 774;
        ExistentialMetatypeValueWitnesses = getExistentialMetatypeValueWitnesses(v53 & 0xFFFFFF);
        if (ExistentialMetatypeValueWitnesses) {
          uint64_t v57 = ExistentialMetatypeValueWitnesses;
        }
        else {
          uint64_t v57 = 0;
        }
        *(void *)(explicit + 8) = v57;
        *(void *)(explicit + 24) = v51;
        *(_DWORD *)(explicit + 32) = v53;
        *(void *)(v55 + 8 * v12) = explicit;
        atomic_store(v19, (unsigned int *)&dword_1EB208A64);
        switch(v26)
        {
          case 1u:
            unint64_t v58 = v27 & 0xFFFFFFFFFFFFFFFCLL;
            if ((v27 & 3) == 0) {
              unint64_t v58 = 0;
            }
            atomic_store(v19, (unsigned __int8 *)(v58 + v26));
            break;
          case 2u:
            unint64_t v59 = v27 & 0xFFFFFFFFFFFFFFFCLL;
            if ((v27 & 3) == 0) {
              unint64_t v59 = 0;
            }
            atomic_store(v19, (unsigned __int16 *)(v59 + 2 * v26));
            break;
          case 3u:
            unint64_t v60 = v27 & 0xFFFFFFFFFFFFFFFCLL;
            if ((v27 & 3) == 0) {
              unint64_t v60 = 0;
            }
            atomic_store(v19, (unsigned int *)(v60 + 4 * v26));
            break;
          default:
            atomic_store((v19 << (4 * v26)) | v27, (unint64_t *)&qword_1EB208A70);
            break;
        }
        __dmb(0xBu);
        if (ExistentialMetatypes) {
          goto LABEL_112;
        }
        unint64_t v61 = (void **)qword_1EB208A80;
        if (qword_1EB208A80)
        {
          do
          {
            uint64_t v62 = (void **)*v61;
            free(v61[1]);
            free(v61);
            unint64_t v61 = v62;
          }
          while (v62);
        }
        goto LABEL_111;
      }
      unint64_t v54 = (int *)(v51 + 1);
    }
    int v53 = *v54;
    goto LABEL_94;
  }
  unint64_t explicit = *v15;
  __dmb(0xBu);
  if (!ExistentialMetatypes)
  {
    int v17 = (void **)qword_1EB208A80;
    if (qword_1EB208A80)
    {
      do
      {
        char v18 = (void **)*v17;
        free(v17[1]);
        free(v17);
        int v17 = v18;
      }
      while (v18);
    }
LABEL_111:
    qword_1EB208A80 = 0;
  }
LABEL_112:
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB208A78);
  qword_1EB208A88 = explicit;
LABEL_113:
  if (explicit) {
    return explicit + 16;
  }
  else {
    return 0;
  }
}

uint64_t swift::TargetExistentialTypeMetadata<swift::InProcess>::getRepresentation(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 8);
  int v2 = v1 & 0x3F000000;
  BOOL v3 = v1 >= 0;
  if (v2 == 0x1000000) {
    return 2;
  }
  else {
    return v3;
  }
}

uint64_t swift::TargetExistentialTypeMetadata<swift::InProcess>::mayTakeValue(uint64_t a1, swift::SwiftError **a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  int v3 = v2 & 0x3F000000;
  int v4 = v2 >= 0;
  if (v3 == 0x1000000) {
    int v4 = 2;
  }
  if (v4 == 2)
  {
    int v6 = *a2;
    return swift::SwiftError::isPureNSError(v6, a2);
  }
  else if (v4 == 1)
  {
    return 1;
  }
  else
  {
    return swift::TargetOpaqueExistentialContainer<swift::InProcess>::isValueInline((uint64_t)a2);
  }
}

swift::SwiftError **swift::TargetExistentialTypeMetadata<swift::InProcess>::projectValue(uint64_t a1, swift::SwiftError **a2)
{
  int v2 = a2;
  int v3 = *(_DWORD *)(a1 + 8);
  int v4 = v3 & 0x3F000000;
  int v5 = v3 >= 0;
  if (v4 == 0x1000000) {
    int v5 = 2;
  }
  if (v5 == 2)
  {
    uint64_t v7 = *a2;
    if (!swift::SwiftError::isPureNSError(*a2, a2)) {
      return (swift::SwiftError **)(((unint64_t)v7
    }
                                   + *(unsigned __int8 *)(*(void *)(*((void *)v7 + 5) - 8) + 80)
                                   + 72) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(*((void *)v7 + 5) - 8)
                                                                                 + 80));
    return v2;
  }
  if (v5 == 1) {
    return v2;
  }

  return (swift::SwiftError **)swift::TargetOpaqueExistentialContainer<swift::InProcess>::projectValue(a2);
}

unint64_t swift::TargetExistentialTypeMetadata<swift::InProcess>::getDynamicType(uint64_t a1, swift::SwiftError **a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  int v3 = v2 & 0x3F000000;
  int v4 = v2 >= 0;
  if (v3 == 0x1000000) {
    int v4 = 2;
  }
  if (!v4) {
    return (unint64_t)a2[3];
  }
  if (v4 == 2)
  {
    uint64_t v7 = *a2;
    return swift::SwiftError::getType(v7, a2);
  }
  else
  {
    unint64_t v5 = (unint64_t)*a2;
    return swift_getObjectType(v5);
  }
}

uint64_t (***swift::_getSimpleProtocolTypeMetadata(_DWORD *a1))()
{
  if (a1) {
    uint64_t v3 = (uint64_t)a1;
  }
  else {
    uint64_t v3 = 0;
  }
  v5[1] = v1;
  void v5[2] = v2;
  v5[0] = v3;
  return swift_getExistentialTypeMetadata(HIWORD(*a1) & 1, 0, 1, v5);
}

uint64_t (***swift_getExistentialTypeMetadata(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t *a4))()
{
  if (a2 || a3)
  {
    *(void *)&long long v110 = a2;
    *((void *)&v110 + 1) = a1 | (unint64_t)(2 * a3);
    int v111 = a4;
    unint64_t explicit = (_WORD *)atomic_load_explicit(&qword_1EB208AB8, memory_order_acquire);
    if (explicit)
    {
      unint64_t v7 = *((unsigned int *)explicit + 4);
      if (((DWORD2(v110) ^ ((v7 & 0x80000000) != 0)) & 1) == 0)
      {
        if ((v7 & 0x40000000) != 0)
        {
          if ((void)v110 != *((void *)explicit + 3)) {
            goto LABEL_18;
          }
        }
        else if ((void)v110)
        {
          goto LABEL_18;
        }
        unint64_t v8 = (unint64_t)DWORD2(v110) >> 1;
        if (DWORD2(v110) >> 1 == *((_DWORD *)explicit + 5))
        {
          if (DWORD2(v110) < 2) {
            goto LABEL_150;
          }
          uint64_t v9 = v111;
          uint64_t v10 = 8 * ((v7 >> 30) & 1) + 24;
          while (1)
          {
            uint64_t v11 = *v9++;
            if (v11 != *(void *)((char *)explicit + v10)) {
              break;
            }
            v10 += 8;
            if (!--v8) {
              goto LABEL_150;
            }
          }
        }
      }
    }
LABEL_18:
    atomic_fetch_add_explicit(&ExistentialTypes, 1u, memory_order_acquire);
    do
    {
      unint64_t v12 = atomic_load_explicit(&qword_1EB208A98, memory_order_acquire);
      unint64_t v13 = atomic_load_explicit(&qword_1EB208AA0, memory_order_acquire);
      unint64_t v14 = atomic_load_explicit(&dword_1EB208A94, memory_order_acquire);
    }
    while (v12 != atomic_load_explicit(&qword_1EB208A98, memory_order_acquire));
    if (v12) {
      BOOL v15 = v13 == 0;
    }
    else {
      BOOL v15 = 1;
    }
    if (!v15 && v14 != 0)
    {
      if (v17)
      {
        qword_1EB208AB8 = *v17;
        unint64_t explicit = (_WORD *)*v17;
        atomic_fetch_add_explicit(&ExistentialTypes, 0xFFFFFFFF, memory_order_release);
        goto LABEL_150;
      }
    }
    atomic_fetch_add_explicit(&ExistentialTypes, 0xFFFFFFFF, memory_order_release);
    long long v112 = v110;
    uint64_t v113 = v111;
    os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB208AA8);
    unint64_t v18 = qword_1EB208AA0;
    uint64_t v19 = qword_1EB208AA0 & 3;
    BOOL v20 = v19 == 0;
    if ((qword_1EB208AA0 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
      BOOL v20 = 1;
    }
    BOOL v106 = v20;
    if (v20) {
      int v21 = 4;
    }
    else {
      int v21 = *(unsigned __int8 *)(qword_1EB208AA0 & 0xFFFFFFFFFFFFFFFCLL);
    }
    unint64_t v22 = dword_1EB208A94;
    unint64_t v23 = (_DWORD *)qword_1EB208A98;
    uint64_t v24 = (const void *)(qword_1EB208A98 + 8);
    if (qword_1EB208A98) {
      uint64_t v25 = qword_1EB208A98 + 8;
    }
    else {
      uint64_t v25 = 0;
    }
    if (v26)
    {
      unint64_t explicit = *v26;
      __dmb(0xBu);
      if (ExistentialTypes)
      {
LABEL_149:
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB208AA8);
        qword_1EB208AB8 = (uint64_t)explicit;
LABEL_150:
        if (explicit) {
          return (uint64_t (***)())(explicit + 4);
        }
        else {
          return 0;
        }
      }
      unint64_t v28 = (void **)qword_1EB208AB0;
      if (qword_1EB208AB0)
      {
        do
        {
          unint64_t v29 = (void **)*v28;
          free(v28[1]);
          free(v28);
          unint64_t v28 = v29;
        }
        while (v29);
      }
LABEL_148:
      qword_1EB208AB0 = 0;
      goto LABEL_149;
    }
    uint64_t v104 = (v22 + 1);
    unint64_t v105 = v22;
    if ((1 << v21) / (unint64_t)((1 << v21) - v104) < 4)
    {
      unsigned int v35 = v27;
      unint64_t v36 = v18;
      if (v23) {
        goto LABEL_95;
      }
    }
    else
    {
      unsigned int v30 = (v21 + 1);
      char v108 = v21;
      if (v30 >= 0x11) {
        unsigned int v31 = 4;
      }
      else {
        unsigned int v31 = 2;
      }
      if (v30 < 9) {
        size_t v32 = 1;
      }
      else {
        size_t v32 = v31;
      }
      unint64_t v33 = (unint64_t)malloc_type_calloc(2 << v21, v32, 0x4269077AuLL);
      if (!v33) {
        swift::hashable_support::findHashableBaseTypeOfHashableType();
      }
      uint64_t v34 = v25;
      long long v102 = v23 + 2;
      uint64_t v103 = v23;
      if (v32 != 1)
      {
        if (v32 == 4) {
          size_t v32 = 3;
        }
        else {
          size_t v32 = 2;
        }
      }
      unint64_t v36 = v32 | v33;
      *(unsigned char *)unint64_t v33 = v21 + 1;
      if (v21)
      {
        uint64_t v37 = ~(-2 << v21);
        unint64_t v38 = v18 & 0xFFFFFFFFFFFFFFFCLL;
        if (!v19) {
          unint64_t v38 = 0;
        }
        unint64_t v107 = v38;
        int v39 = v36 & 3;
        if ((v36 & 3) != 0) {
          unint64_t v40 = v33 & 0xFFFFFFFFFFFFFFFCLL;
        }
        else {
          unint64_t v40 = 0;
        }
        uint64_t v41 = 1;
        while (2)
        {
          switch(v18 & 3)
          {
            case 0uLL:
              uint64_t v42 = (v18 >> (4 * v41)) & 0xF;
              if (!v42) {
                goto LABEL_64;
              }
              goto LABEL_73;
            case 1uLL:
              LODWORD(v42) = *(unsigned __int8 *)(v107 + v41);
              if (*(unsigned char *)(v107 + v41)) {
                goto LABEL_73;
              }
              goto LABEL_64;
            case 2uLL:
              LODWORD(v42) = *(unsigned __int16 *)(v107 + 2 * v41);
              if (!*(_WORD *)(v107 + 2 * v41)) {
                goto LABEL_64;
              }
              goto LABEL_73;
            case 3uLL:
              LODWORD(v42) = *(_DWORD *)(v107 + 4 * v41);
              if (!v42) {
                goto LABEL_64;
              }
LABEL_73:
              uint64_t v43 = *(void *)(v34 + 8 * (v42 - 1));
              unint64_t v44 = *(unsigned int *)(v43 + 16);
              if ((v44 & 0x40000000) != 0) {
                uint64_t v45 = *(void *)(v43 + 24);
              }
              else {
                uint64_t v45 = 0;
              }
              uint64_t v114 = v45;
              uint64_t v115 = 0;
              unsigned int v46 = *(_DWORD *)(v43 + 20);
              uint64_t v115 = (__PAIR64__(v46, v44) >> 31);
              uint64_t v116 = v43 + 8 * ((v44 >> 30) & 1) + 24;
              BOOL v118 = (v44 & 0x80000000) != 0;
              LODWORD(v117) = v46 & 0x7FFFFFFF;
              unint64_t v47 = __swift::__runtime::llvm::hash_combine<swift::TargetMetadata<swift::InProcess> const*,swift::ProtocolClassConstraint,unsigned int>(&v114, (char *)&v118, (int *)&v117);
              unint64_t v119 = v47;
              if (v115 >= 2)
              {
                uint64_t v48 = 0;
                do
                {
                  uint64_t v117 = *(void *)(v116 + 8 * v48);
                  unint64_t v47 = __swift::__runtime::llvm::hash_combine<__swift::__runtime::llvm::hash_code,swift::TargetMetadata<swift::InProcess> const*>(&v119, &v117);
                  unint64_t v119 = v47;
                  ++v48;
                }
                while (v48 != (unint64_t)v115 >> 1);
                uint64_t v34 = v25;
              }
              while (1)
              {
                unint64_t v50 = v47 & v37;
                if ((v47 & v37) != 0)
                {
                  switch(v36 & 3)
                  {
                    case 1uLL:
                      LODWORD(v49) = *(unsigned __int8 *)(v40 + v50);
                      break;
                    case 2uLL:
                      LODWORD(v49) = *(unsigned __int16 *)(v40 + 2 * v50);
                      break;
                    case 3uLL:
                      LODWORD(v49) = *(_DWORD *)(v40 + 4 * v50);
                      break;
                    default:
                      uint64_t v49 = (v36 >> (4 * v50)) & 0xF;
                      break;
                  }
                  if (!v49) {
                    break;
                  }
                }
                unint64_t v47 = v50 + 1;
              }
              if (v39 == 3)
              {
                *(_DWORD *)(v40 + 4 * v5swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v42;
              }
              else if (v39 == 2)
              {
                *(_WORD *)(v40 + 2 * v5swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v42;
              }
              else
              {
                *(unsigned char *)(v40 + v5swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v42;
              }
LABEL_64:
              if (!((unint64_t)++v41 >> v108)) {
                continue;
              }
              goto LABEL_92;
            default:
              JUMPOUT(0);
          }
        }
      }
LABEL_92:
      atomic_store(v36, (unint64_t *)&qword_1EB208AA0);
      if (!v106)
      {
        int v51 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
        *int v51 = qword_1EB208AB0;
        v51[1] = v18 & 0xFFFFFFFFFFFFFFFCLL;
        qword_1EB208AB0 = (uint64_t)v51;
      }
      unint64_t v22 = v105;
      unsigned int v35 = v52;
      uint64_t v24 = v102;
      unint64_t v23 = v103;
      if (v103)
      {
LABEL_95:
        unint64_t v53 = (unint64_t)v23;
        if (v22 < *v23) {
          goto LABEL_102;
        }
      }
    }
    unint64_t v54 = v22 + (v22 >> 2);
    if (v54 <= v22 + 1) {
      unint64_t v54 = v22 + 1;
    }
    size_t v55 = malloc_good_size(8 * v54 + 8);
    unint64_t v56 = malloc_type_malloc(v55, 0x1000D770uLL);
    if (!v56) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    unint64_t v53 = (unint64_t)v56;
    *unint64_t v56 = (v55 + 0x7FFFFFFF8) >> 3;
    if (v23)
    {
      memcpy(v56 + 2, v24, 8 * v22);
      uint64_t v57 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
      *uint64_t v57 = qword_1EB208AB0;
      v57[1] = v23;
      qword_1EB208AB0 = (uint64_t)v57;
    }
    atomic_store(v53, (unint64_t *)&qword_1EB208A98);
LABEL_102:
    unint64_t v58 = (unint64_t)DWORD2(v110) >> 1;
    if ((void)v110) {
      ++v58;
    }
    LOWORD(v114) = 7;
    unint64_t explicit = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v114, 8 * v58 + 24, 8);
    unsigned int v59 = 0;
    uint64_t v60 = v110;
    unint64_t v61 = DWORD2(v110);
    uint64_t v62 = v111;
    *((void *)explicit + 1) = 771;
    *((void *)explicit + 2) = 0;
    unint64_t v63 = v61 >> 1;
    if (v61 >= 2)
    {
      unint64_t v64 = (v63 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v64 >= 7)
      {
        unint64_t v66 = v64 + 1;
        uint64_t v67 = (v64 + 1) & 0x3FFFFFFFFFFFFFF8;
        unint64_t v65 = (char *)&v62[v67];
        unint64_t v68 = (int8x16_t *)(v62 + 4);
        int32x4_t v69 = 0uLL;
        int8x16_t v70 = (int8x16_t)vdupq_n_s64(1uLL);
        uint64_t v71 = v67;
        int32x4_t v72 = 0uLL;
        do
        {
          int8x16_t v74 = v68[-2];
          int8x16_t v73 = v68[-1];
          int8x16_t v76 = *v68;
          int8x16_t v75 = v68[1];
          v68 += 4;
          int32x4_t v69 = vsubq_s32(v69, vuzp1q_s32((int32x4_t)vceqzq_s64((int64x2_t)vandq_s8(v74, v70)), (int32x4_t)vceqzq_s64((int64x2_t)vandq_s8(v73, v70))));
          int32x4_t v72 = vsubq_s32(v72, vuzp1q_s32((int32x4_t)vceqzq_s64((int64x2_t)vandq_s8(v76, v70)), (int32x4_t)vceqzq_s64((int64x2_t)vandq_s8(v75, v70))));
          v71 -= 8;
        }
        while (v71);
        unsigned int v59 = vaddvq_s32(vaddq_s32(v72, v69));
        if (v66 == v67) {
          goto LABEL_113;
        }
      }
      else
      {
        unsigned int v59 = 0;
        unint64_t v65 = (char *)v62;
      }
      do
      {
        char v77 = *v65;
        v65 += 8;
        if ((v77 & 1) == 0) {
          ++v59;
        }
      }
      while (v65 != (char *)&v62[v63]);
    }
LABEL_113:
    unsigned int v109 = v35;
    if (v61 & 0xFFFFFFFE) != 2 || (uint64_t v78 = *v62, (*v62))
    {
      int v80 = 0;
    }
    else
    {
      if ((v78 & 0xFFFFFFFFFFFFFFFELL) != 0) {
        uint64_t v79 = (_DWORD *)(v78 & 0xFFFFFFFFFFFFFFFELL);
      }
      else {
        uint64_t v79 = 0;
      }
      int v80 = (*v79 >> 18) & 0x3F;
    }
    ExistentialValueWitnesses = getExistentialValueWitnesses(v61 & 1, v59, v80);
    if (ExistentialValueWitnesses) {
      unint64_t v82 = ExistentialValueWitnesses;
    }
    else {
      unint64_t v82 = 0;
    }
    *(void *)unint64_t explicit = v82;
    unsigned int v83 = v59 & 0x40FFFFFF | (v61 << 31) | (v80 << 24);
    *((_DWORD *)explicit + 4) = v83;
    if (v60)
    {
      v83 |= 0x40000000u;
      *((_DWORD *)explicit + 4) = v83;
      *((void *)explicit + 3) = v60;
    }
    *((_DWORD *)explicit + 5) = v63;
    if (v61 < 2) {
      goto LABEL_134;
    }
    uint64_t v84 = (v83 >> 30) & 1;
    if (v63 <= 1) {
      unint64_t v85 = 1;
    }
    else {
      unint64_t v85 = v61 >> 1;
    }
    if (v85 >= 0xA && (unint64_t v86 = &explicit[4 * v84], (unint64_t)((char *)v86 - (char *)v62 + 24) >= 0x20))
    {
      unint64_t v87 = v85 & 0x7FFFFFFC;
      long long v98 = (long long *)(v62 + 2);
      uint64_t v99 = v86 + 20;
      unint64_t v100 = v87;
      do
      {
        long long v101 = *v98;
        *(v99 - 1) = *(v98 - 1);
        _OWORD *v99 = v101;
        v98 += 2;
        v99 += 2;
        v100 -= 4;
      }
      while (v100);
      if (v85 == v87) {
        goto LABEL_134;
      }
    }
    else
    {
      unint64_t v87 = 0;
    }
    unint64_t v88 = v85 - v87;
    uint64_t v89 = 8 * v87;
    BOOL v90 = &explicit[4 * v84 + 12 + (unint64_t)v89 / 2];
    unint64_t v91 = &v62[(unint64_t)v89 / 8];
    do
    {
      uint64_t v92 = *v91++;
      *v90++ = v92;
      --v88;
    }
    while (v88);
LABEL_134:
    *(void *)(v53 + 8 + 8 * v105) = explicit;
    atomic_store(v104, (unsigned int *)&dword_1EB208A94);
    switch(v80)
    {
      case 1:
        unint64_t v93 = v36 & 0xFFFFFFFFFFFFFFFCLL;
        if ((v36 & 3) == 0) {
          unint64_t v93 = 0;
        }
        atomic_store(v104, (unsigned __int8 *)(v93 + v109));
        break;
      case 2:
        unint64_t v94 = v36 & 0xFFFFFFFFFFFFFFFCLL;
        if ((v36 & 3) == 0) {
          unint64_t v94 = 0;
        }
        atomic_store(v104, (unsigned __int16 *)(v94 + 2 * v109));
        break;
      case 3:
        unint64_t v95 = v36 & 0xFFFFFFFFFFFFFFFCLL;
        if ((v36 & 3) == 0) {
          unint64_t v95 = 0;
        }
        atomic_store(v104, (unsigned int *)(v95 + 4 * v109));
        break;
      default:
        atomic_store((v104 << (4 * v109)) | v36, (unint64_t *)&qword_1EB208AA0);
        break;
    }
    __dmb(0xBu);
    if (ExistentialTypes) {
      goto LABEL_149;
    }
    long long v96 = (void **)qword_1EB208AB0;
    if (qword_1EB208AB0)
    {
      do
      {
        int v97 = (void **)*v96;
        free(v96[1]);
        free(v96);
        long long v96 = v97;
      }
      while (v97);
    }
    goto LABEL_148;
  }
  int v4 = (uint64_t (***)())&type metadata for Swift.AnyObject;
  if (a1) {
    int v4 = &type metadata for Any;
  }
  return v4 + 1;
}

unint64_t swift_getExtendedExistentialTypeShape(const char *a1)
{
  uint64_t v1 = *(int *)a1;
  if (v1) {
    uint64_t v2 = (atomic_ullong *)&a1[v1];
  }
  else {
    uint64_t v2 = 0;
  }
  unint64_t explicit = atomic_load_explicit(v2, memory_order_acquire);
  if (explicit) {
    return explicit;
  }
  *(void *)&long long v72 = a1;
  uint64_t v5 = *((int *)a1 + 2);
  int v6 = &a1[v5 + 8];
  if (v6) {
    size_t v7 = strlen(&a1[v5 + 8]);
  }
  else {
    size_t v7 = 0;
  }
  *((void *)&v72 + 1) = v6;
  size_t v73 = v7;
  unint64_t v8 = (_WORD *)atomic_load_explicit(&qword_1EB208AE8, memory_order_acquire);
  if (!v8) {
    goto LABEL_17;
  }
  if (*(void *)v8 != (void)v72)
  {
    uint64_t v9 = (const char *)(*(int *)(*(void *)v8 + 8) + *(void *)v8 + 8);
    if (v9)
    {
      if (strlen(v9) == v73 && (!v73 || !memcmp(v9, *((const void **)&v72 + 1), v73))) {
        goto LABEL_114;
      }
LABEL_17:
      atomic_fetch_add_explicit(&ExtendedExistentialTypeShapes, 1u, memory_order_acquire);
      do
      {
        unint64_t v10 = atomic_load_explicit(&qword_1EB208AC8, memory_order_acquire);
        unint64_t v11 = atomic_load_explicit(&qword_1EB208AD0, memory_order_acquire);
        unint64_t v12 = atomic_load_explicit(&dword_1EB208AC4, memory_order_acquire);
      }
      while (v10 != atomic_load_explicit(&qword_1EB208AC8, memory_order_acquire));
      if (v10) {
        BOOL v13 = v11 == 0;
      }
      else {
        BOOL v13 = 1;
      }
      if (!v13 && v12 != 0)
      {
        if (v15)
        {
          qword_1EB208AE8 = *v15;
          unint64_t v8 = (_WORD *)*v15;
          atomic_fetch_add_explicit(&ExtendedExistentialTypeShapes, 0xFFFFFFFF, memory_order_release);
          goto LABEL_114;
        }
      }
      atomic_fetch_add_explicit(&ExtendedExistentialTypeShapes, 0xFFFFFFFF, memory_order_release);
      long long v74 = v72;
      size_t v75 = v73;
      os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB208AD8);
      uint64_t v16 = qword_1EB208AD0;
      uint64_t v17 = qword_1EB208AD0 & 3;
      BOOL v18 = v17 == 0;
      if ((qword_1EB208AD0 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
        BOOL v18 = 1;
      }
      BOOL v67 = v18;
      if (v18) {
        int v19 = 4;
      }
      else {
        int v19 = *(unsigned __int8 *)(qword_1EB208AD0 & 0xFFFFFFFFFFFFFFFCLL);
      }
      unint64_t v20 = dword_1EB208AC4;
      int v21 = (_DWORD *)qword_1EB208AC8;
      if (qword_1EB208AC8) {
        uint64_t v22 = qword_1EB208AC8 + 8;
      }
      else {
        uint64_t v22 = 0;
      }
      if (v23)
      {
        unint64_t v8 = *v23;
        __dmb(0xBu);
        if (ExtendedExistentialTypeShapes)
        {
LABEL_113:
          os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB208AD8);
          qword_1EB208AE8 = (uint64_t)v8;
          goto LABEL_114;
        }
        uint64_t v25 = (void **)qword_1EB208AE0;
        if (qword_1EB208AE0)
        {
          do
          {
            unsigned int v26 = (void **)*v25;
            free(v25[1]);
            free(v25);
            uint64_t v25 = v26;
          }
          while (v26);
        }
LABEL_112:
        qword_1EB208AE0 = 0;
        goto LABEL_113;
      }
      unint64_t v68 = v16;
      unint64_t v65 = v16 & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v66 = v21;
      uint64_t v27 = (v20 + 1);
      __src = v21 + 2;
      if ((1 << v19) / (unint64_t)((1 << v19) - v27) < 4)
      {
        unsigned int v32 = v24;
        unint64_t v33 = v68;
        uint64_t v34 = v66;
        if (!v66) {
          goto LABEL_92;
        }
      }
      else
      {
        unsigned int v28 = (v19 + 1);
        char v71 = v19;
        if (v28 >= 0x11) {
          unsigned int v29 = 4;
        }
        else {
          unsigned int v29 = 2;
        }
        if (v28 < 9) {
          size_t v30 = 1;
        }
        else {
          size_t v30 = v29;
        }
        unint64_t v31 = (unint64_t)malloc_type_calloc(2 << v19, v30, 0x4269077AuLL);
        if (!v31) {
          swift::hashable_support::findHashableBaseTypeOfHashableType();
        }
        unint64_t v62 = v20;
        uint64_t v63 = (v20 + 1);
        if (v30 != 1)
        {
          if (v30 == 4) {
            size_t v30 = 3;
          }
          else {
            size_t v30 = 2;
          }
        }
        unint64_t v33 = v30 | v31;
        *(unsigned char *)unint64_t v31 = v19 + 1;
        if (v19)
        {
          uint64_t v35 = ~(-2 << v19);
          uint64_t v36 = v16 & 3;
          unint64_t v37 = v65;
          if (!v17) {
            unint64_t v37 = 0;
          }
          uint64_t v69 = v22;
          unint64_t v70 = v37;
          int v38 = v33 & 3;
          if ((v33 & 3) != 0) {
            unint64_t v39 = v31 & 0xFFFFFFFFFFFFFFFCLL;
          }
          else {
            unint64_t v39 = 0;
          }
          uint64_t v40 = 1;
          while (2)
          {
            switch(v36)
            {
              case 0:
                uint64_t v41 = (v68 >> (4 * v40)) & 0xF;
                if (!v41) {
                  goto LABEL_63;
                }
                goto LABEL_72;
              case 1:
                LODWORD(v41) = *(unsigned __int8 *)(v70 + v40);
                if (*(unsigned char *)(v70 + v40)) {
                  goto LABEL_72;
                }
                goto LABEL_63;
              case 2:
                LODWORD(v41) = *(unsigned __int16 *)(v70 + 2 * v40);
                if (!*(_WORD *)(v70 + 2 * v40)) {
                  goto LABEL_63;
                }
                goto LABEL_72;
              case 3:
                LODWORD(v41) = *(_DWORD *)(v70 + 4 * v40);
                if (!v41) {
                  goto LABEL_63;
                }
LABEL_72:
                uint64_t v42 = **(void **)(v22 + 8 * (v41 - 1));
                uint64_t v43 = (char *)(*(int *)(v42 + 8) + v42 + 8);
                if (v43) {
                  size_t v44 = strlen(v43);
                }
                else {
                  size_t v44 = 0;
                }
                unint64_t v45 = __swift::__runtime::llvm::hash_value(v43, v44);
                uint64_t v22 = v69;
                while (1)
                {
                  unint64_t v47 = v45 & v35;
                  if ((v45 & v35) != 0)
                  {
                    switch(v33 & 3)
                    {
                      case 1uLL:
                        LODWORD(v46) = *(unsigned __int8 *)(v39 + v47);
                        break;
                      case 2uLL:
                        LODWORD(v46) = *(unsigned __int16 *)(v39 + 2 * v47);
                        break;
                      case 3uLL:
                        LODWORD(v46) = *(_DWORD *)(v39 + 4 * v47);
                        break;
                      default:
                        uint64_t v46 = (v33 >> (4 * v47)) & 0xF;
                        break;
                    }
                    if (!v46) {
                      break;
                    }
                  }
                  unint64_t v45 = v47 + 1;
                }
                if (v38 == 3)
                {
                  *(_DWORD *)(v39 + 4 * v47) = v41;
                }
                else if (v38 == 2)
                {
                  *(_WORD *)(v39 + 2 * v47) = v41;
                }
                else
                {
                  *(unsigned char *)(v39 + v47) = v41;
                }
LABEL_63:
                if (!((unint64_t)++v40 >> v71)) {
                  continue;
                }
                goto LABEL_88;
              default:
                JUMPOUT(0);
            }
          }
        }
LABEL_88:
        atomic_store(v33, (unint64_t *)&qword_1EB208AD0);
        if (!v67)
        {
          uint64_t v48 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
          *uint64_t v48 = qword_1EB208AE0;
          v48[1] = v65;
          qword_1EB208AE0 = (uint64_t)v48;
        }
        unint64_t v20 = v62;
        unsigned int v32 = v49;
        uint64_t v27 = v63;
        uint64_t v34 = v66;
        if (!v66) {
          goto LABEL_92;
        }
      }
      unint64_t v50 = (unint64_t)v34;
      if (v20 < *v34)
      {
LABEL_98:
        __int16 v76 = 23;
        unint64_t v8 = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v76, 8uLL, 8);
        *(void *)unint64_t v8 = v72;
        *(void *)(v50 + 8 + 8 * v2swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v8;
        atomic_store(v27, (unsigned int *)&dword_1EB208AC4);
        switch((int)v27)
        {
          case 1:
            unint64_t v56 = v33 & 0xFFFFFFFFFFFFFFFCLL;
            if ((v33 & 3) == 0) {
              unint64_t v56 = 0;
            }
            atomic_store(v27, (unsigned __int8 *)(v56 + v32));
            break;
          case 2:
            unint64_t v57 = v33 & 0xFFFFFFFFFFFFFFFCLL;
            if ((v33 & 3) == 0) {
              unint64_t v57 = 0;
            }
            atomic_store(v27, (unsigned __int16 *)(v57 + 2 * v32));
            break;
          case 3:
            unint64_t v58 = v33 & 0xFFFFFFFFFFFFFFFCLL;
            if ((v33 & 3) == 0) {
              unint64_t v58 = 0;
            }
            atomic_store(v27, (unsigned int *)(v58 + 4 * v32));
            break;
          default:
            atomic_store((v27 << (4 * v32)) | v33, (unint64_t *)&qword_1EB208AD0);
            break;
        }
        __dmb(0xBu);
        if (ExtendedExistentialTypeShapes) {
          goto LABEL_113;
        }
        unsigned int v59 = (void **)qword_1EB208AE0;
        if (qword_1EB208AE0)
        {
          do
          {
            uint64_t v60 = (void **)*v59;
            free(v59[1]);
            free(v59);
            unsigned int v59 = v60;
          }
          while (v60);
        }
        goto LABEL_112;
      }
LABEL_92:
      unint64_t v51 = v20 + (v20 >> 2);
      unint64_t v52 = v20;
      if (v51 <= v20 + 1) {
        unint64_t v51 = v20 + 1;
      }
      size_t v53 = malloc_good_size(8 * v51 + 8);
      unint64_t v54 = malloc_type_malloc(v53, 0x1000D770uLL);
      if (!v54) {
        swift::hashable_support::findHashableBaseTypeOfHashableType();
      }
      unint64_t v50 = (unint64_t)v54;
      *unint64_t v54 = (v53 + 0x7FFFFFFF8) >> 3;
      unint64_t v20 = v52;
      if (v34)
      {
        memcpy(v54 + 2, __src, 8 * v52);
        size_t v55 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
        *size_t v55 = qword_1EB208AE0;
        v55[1] = v34;
        qword_1EB208AE0 = (uint64_t)v55;
      }
      atomic_store(v50, (unint64_t *)&qword_1EB208AC8);
      goto LABEL_98;
    }
    if (v73) {
      goto LABEL_17;
    }
  }
LABEL_114:
  uint64_t v61 = *(void *)v8;
  atomic_store(*(void *)v8 + 4, (unint64_t *)v2);
  return v61 + 4;
}

void *swift_getExtendedExistentialTypeMetadata_unique(unsigned int *a1, uint64_t a2)
{
  *(_OWORD *)__src = v91[0];
  long long v89 = v91[1];
  BOOL v90 = v92;
  unint64_t explicit = (void *)atomic_load_explicit(&qword_1EB208B18, memory_order_acquire);
  if (explicit)
  {
    long long v96 = v90;
    v95[0] = *(_OWORD *)__src;
    v95[1] = v89;
    uint64_t v3 = (unsigned int *)explicit[3];
    if (v3)
    {
      if (v96 != v3) {
        goto LABEL_9;
      }
    }
    else
    {
      if (v96) {
        goto LABEL_9;
      }
      uint64_t v3 = 0;
    }
    if (v100 == v96 && (swift::MetadataCacheKey::operator==(v4, (uint64_t)v95) & 1) != 0) {
      goto LABEL_131;
    }
  }
LABEL_9:
  atomic_fetch_add_explicit(&ExtendedExistentialTypes, 1u, memory_order_acquire);
  do
  {
    unint64_t v5 = atomic_load_explicit(&qword_1EB208AF8, memory_order_acquire);
    unint64_t v6 = atomic_load_explicit(&qword_1EB208B00, memory_order_acquire);
    unint64_t v7 = atomic_load_explicit(&dword_1EB208AF4, memory_order_acquire);
  }
  while (v5 != atomic_load_explicit(&qword_1EB208AF8, memory_order_acquire));
  if (v5) {
    BOOL v8 = v6 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8 && v7 != 0)
  {
    if (v10)
    {
      qword_1EB208B18 = *v10;
      unint64_t explicit = (void *)*v10;
      atomic_fetch_add_explicit(&ExtendedExistentialTypes, 0xFFFFFFFF, memory_order_release);
      goto LABEL_131;
    }
  }
  atomic_fetch_add_explicit(&ExtendedExistentialTypes, 0xFFFFFFFF, memory_order_release);
  v93[0] = *(_OWORD *)__src;
  v93[1] = v89;
  unint64_t v94 = v90;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB208B08);
  unint64_t v11 = qword_1EB208B00;
  uint64_t v12 = qword_1EB208B00 & 3;
  BOOL v13 = v12 == 0;
  if ((qword_1EB208B00 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
    BOOL v13 = 1;
  }
  BOOL v83 = v13;
  if (v13) {
    int v14 = 4;
  }
  else {
    int v14 = *(unsigned __int8 *)(qword_1EB208B00 & 0xFFFFFFFFFFFFFFFCLL);
  }
  unint64_t v15 = dword_1EB208AF4;
  uint64_t v16 = (_DWORD *)qword_1EB208AF8;
  uint64_t v17 = (const void *)(qword_1EB208AF8 + 8);
  if (qword_1EB208AF8) {
    uint64_t v18 = qword_1EB208AF8 + 8;
  }
  else {
    uint64_t v18 = 0;
  }
  if (!v19)
  {
    uint64_t v86 = v18;
    uint64_t v81 = (v15 + 1);
    unint64_t v82 = v15;
    if ((1 << v14) / (unint64_t)((1 << v14) - v81) < 4)
    {
      unsigned int v29 = v20;
      unint64_t v30 = v11;
      if (!v16) {
        goto LABEL_85;
      }
    }
    else
    {
      int v80 = v16 + 2;
      char v23 = v14;
      unsigned int v24 = (v14 + 1);
      if (v24 >= 0x11) {
        unsigned int v25 = 4;
      }
      else {
        unsigned int v25 = 2;
      }
      if (v24 < 9) {
        size_t v26 = 1;
      }
      else {
        size_t v26 = v25;
      }
      unint64_t v27 = (unint64_t)malloc_type_calloc(2 << v14, v26, 0x4269077AuLL);
      if (!v27) {
        swift::hashable_support::findHashableBaseTypeOfHashableType();
      }
      uint64_t v28 = v18;
      uint64_t v79 = v16;
      if (v26 != 1)
      {
        if (v26 == 4) {
          size_t v26 = 3;
        }
        else {
          size_t v26 = 2;
        }
      }
      unint64_t v30 = v26 | v27;
      *(unsigned char *)unint64_t v27 = v14 + 1;
      if (v14)
      {
        uint64_t v31 = ~(-2 << v14);
        if (v12) {
          unint64_t v32 = v11 & 0xFFFFFFFFFFFFFFFCLL;
        }
        else {
          unint64_t v32 = 0;
        }
        unint64_t v84 = v32;
        int v33 = v30 & 3;
        if ((v30 & 3) != 0) {
          unint64_t v34 = v27 & 0xFFFFFFFFFFFFFFFCLL;
        }
        else {
          unint64_t v34 = 0;
        }
        uint64_t v35 = 1;
        while (2)
        {
          switch(v11 & 3)
          {
            case 0uLL:
              uint64_t v36 = (v11 >> (4 * v35)) & 0xF;
              if (!v36) {
                goto LABEL_56;
              }
              goto LABEL_65;
            case 1uLL:
              LODWORD(v36) = *(unsigned __int8 *)(v84 + v35);
              if (!*(unsigned char *)(v84 + v35)) {
                goto LABEL_56;
              }
              goto LABEL_65;
            case 2uLL:
              LODWORD(v36) = *(unsigned __int16 *)(v84 + 2 * v35);
              if (!*(_WORD *)(v84 + 2 * v35)) {
                goto LABEL_56;
              }
              goto LABEL_65;
            case 3uLL:
              LODWORD(v36) = *(_DWORD *)(v84 + 4 * v35);
              if (v36)
              {
LABEL_65:
                if (*(void *)(*(void *)(v28 + 8 * (v36 - 1)) + 24)) {
                  unint64_t v37 = *(unsigned int **)(*(void *)(v28 + 8 * (v36 - 1)) + 24);
                }
                else {
                  unint64_t v37 = 0;
                }
                v101[0] = v99;
                for (unint64_t i = __swift::__runtime::llvm::hash_combine<__swift::__runtime::llvm::hash_code,unsigned int>(&v100, v101); ; unint64_t i = v40 + 1)
                {
                  unint64_t v40 = i & v31;
                  if ((i & v31) != 0)
                  {
                    switch(v30 & 3)
                    {
                      case 1uLL:
                        LODWORD(v39) = *(unsigned __int8 *)(v34 + v40);
                        break;
                      case 2uLL:
                        LODWORD(v39) = *(unsigned __int16 *)(v34 + 2 * v40);
                        break;
                      case 3uLL:
                        LODWORD(v39) = *(_DWORD *)(v34 + 4 * v40);
                        break;
                      default:
                        uint64_t v39 = (v30 >> (4 * v40)) & 0xF;
                        break;
                    }
                    if (!v39) {
                      break;
                    }
                  }
                }
                if (v33 == 3)
                {
                  *(_DWORD *)(v34 + 4 * v4swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v36;
                  uint64_t v28 = v86;
                }
                else
                {
                  uint64_t v28 = v86;
                  if (v33 == 2) {
                    *(_WORD *)(v34 + 2 * v4swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v36;
                  }
                  else {
                    *(unsigned char *)(v34 + v4swift_once(&getOverrideSectionPtr(void)::Predicate, (dispatch_function_t)getOverrideSectionPtr(void)::$_0::__invoke, 0) = v36;
                  }
                }
              }
LABEL_56:
              if (!((unint64_t)++v35 >> v23)) {
                continue;
              }
              goto LABEL_81;
            default:
              JUMPOUT(0);
          }
        }
      }
LABEL_81:
      atomic_store(v30, (unint64_t *)&qword_1EB208B00);
      if (!v83)
      {
        uint64_t v41 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
        uint64_t v28 = v86;
        *uint64_t v41 = qword_1EB208B10;
        v41[1] = v11 & 0xFFFFFFFFFFFFFFFCLL;
        qword_1EB208B10 = (uint64_t)v41;
      }
      unint64_t v15 = v82;
      unsigned int v29 = v42;
      uint64_t v16 = v79;
      uint64_t v17 = v80;
      if (!v79) {
        goto LABEL_85;
      }
    }
    unint64_t v43 = (unint64_t)v16;
    if (v15 < *v16)
    {
LABEL_91:
      if (*((unsigned char *)v90 + 1)) {
        size_t v48 = 8 * *((unsigned __int16 *)v90 + 10) + 32;
      }
      else {
        size_t v48 = 32;
      }
      __int16 v97 = 22;
      unint64_t explicit = swift::MetadataAllocator::Allocate((swift::MetadataAllocator *)&v97, v48, 8);
      unsigned int v49 = __src[0];
      __int16 v50 = (__int16)__src[1];
      __int16 v51 = WORD1(__src[1]);
      uint64_t v52 = WORD2(__src[1]);
      __int16 v53 = HIWORD(__src[1]);
      uint64_t v87 = v89;
      unint64_t v54 = v90;
      unint64_t v55 = *v90;
      if ((v55 & 0x400) == 0) {
        goto LABEL_140;
      }
      unint64_t v56 = (int *)((((unint64_t)&v90[2 * ((v55 >> 8) & 1) + 4] + 3) & 0xFFFFFFFFFFFFFFFCLL)
                  + 4 * ((v55 >> 9) & 1));
      uint64_t v57 = *v56;
      unint64_t v58 = (uint64_t (**)())((char *)v56 + (v57 & 0xFFFFFFFFFFFFFFFELL));
      if (v57) {
        unint64_t v58 = (uint64_t (**)())*v58;
      }
      if (!v58)
      {
LABEL_140:
        unsigned int v85 = v29;
        __int16 v59 = HIWORD(__src[1]);
        int v60 = *((unsigned __int16 *)v90 + 6);
        int v61 = *((unsigned __int16 *)v90 + 4);
        switch(*v90)
        {
          case 0u:
            char v62 = 1;
            goto LABEL_101;
          case 1u:
            char v62 = 0;
LABEL_101:
            ExistentialValueWitnesses = getExistentialValueWitnesses(v62, v60 - v61, 0);
            break;
          case 2u:
            ExistentialValueWitnesses = getExistentialMetatypeValueWitnesses(v60 - v61);
            break;
          default:
            abort();
        }
        unint64_t v58 = ExistentialValueWitnesses;
        __int16 v53 = v59;
        unsigned int v29 = v85;
        if (!ExistentialValueWitnesses) {
          goto LABEL_106;
        }
      }
      if (v58)
      {
        *unint64_t explicit = 0;
        unint64_t v64 = v58;
      }
      else
      {
LABEL_106:
        unint64_t v64 = 0;
        uint64_t v98 = 0;
        *unint64_t explicit = 0;
      }
      unint64_t v65 = v54;
      unint64_t v66 = v43 + 8;
      explicit[1] = v64;
      explicit[2] = 775;
      explicit[3] = v65;
      BOOL v67 = explicit + 4;
      memcpy(explicit + 4, v49, 8 * (unsigned __int16)(v51 + v50 + v53));
      if (!v52)
      {
LABEL_115:
        *(void *)(v66 + 8 * v82) = explicit;
        atomic_store(v81, (unsigned int *)&dword_1EB208AF4);
        switch((int)v52)
        {
          case 1:
            unint64_t v73 = v30 & 0xFFFFFFFFFFFFFFFCLL;
            if ((v30 & 3) == 0) {
              unint64_t v73 = 0;
            }
            atomic_store(v81, (unsigned __int8 *)(v73 + v29));
            break;
          case 2:
            unint64_t v74 = v30 & 0xFFFFFFFFFFFFFFFCLL;
            if ((v30 & 3) == 0) {
              unint64_t v74 = 0;
            }
            atomic_store(v81, (unsigned __int16 *)(v74 + 2 * v29));
            break;
          case 3:
            unint64_t v75 = v30 & 0xFFFFFFFFFFFFFFFCLL;
            if ((v30 & 3) == 0) {
              unint64_t v75 = 0;
            }
            atomic_store(v81, (unsigned int *)(v75 + 4 * v29));
            break;
          default:
            atomic_store((v81 << (4 * v29)) | v30, (unint64_t *)&qword_1EB208B00);
            break;
        }
        __dmb(0xBu);
        if (ExtendedExistentialTypes) {
          goto LABEL_130;
        }
        __int16 v76 = (void **)qword_1EB208B10;
        if (qword_1EB208B10)
        {
          do
          {
            char v77 = (void **)*v76;
            free(v76[1]);
            free(v76);
            __int16 v76 = v77;
          }
          while (v77);
        }
        goto LABEL_129;
      }
      unint64_t v68 = (unsigned __int16 *)(v87 + 4);
      while (1)
      {
        uint64_t v71 = *(v68 - 1);
        unint64_t v72 = v67[*v68];
        if (*(v68 - 2) == 1)
        {
          uint64_t v69 = v71;
          WitnessTablePacint k = swift_allocateWitnessTablePack(v67[v71], v72);
        }
        else
        {
          if (*(v68 - 2)) {
            goto LABEL_111;
          }
          uint64_t v69 = v71;
          WitnessTablePacint k = swift_allocateMetadataPack(v67[v71], v72);
        }
        v67[v69] = WitnessTablePack;
LABEL_111:
        v68 += 4;
        if (!--v52) {
          goto LABEL_115;
        }
      }
    }
LABEL_85:
    unint64_t v44 = v15 + (v15 >> 2);
    if (v44 <= v15 + 1) {
      unint64_t v44 = v15 + 1;
    }
    size_t v45 = malloc_good_size(8 * v44 + 8);
    uint64_t v46 = malloc_type_malloc(v45, 0x1000D770uLL);
    if (!v46) {
      swift::hashable_support::findHashableBaseTypeOfHashableType();
    }
    unint64_t v43 = (unint64_t)v46;
    *uint64_t v46 = (v45 + 0x7FFFFFFF8) >> 3;
    if (v16)
    {
      memcpy(v46 + 2, v17, 8 * v15);
      unint64_t v47 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
      *unint64_t v47 = qword_1EB208B10;
      v47[1] = v16;
      qword_1EB208B10 = (uint64_t)v47;
    }
    atomic_store(v43, (unint64_t *)&qword_1EB208AF8);
    goto LABEL_91;
  }
  unint64_t explicit = *v19;
  __dmb(0xBu);
  if (!ExtendedExistentialTypes)
  {
    int v21 = (void **)qword_1EB208B10;
    if (qword_1EB208B10)
    {
      do
      {
        uint64_t v22 = (void **)*v21;
        free(v21[1]);
        free(v21);
        int v21 = v22;
      }
      while (v22);
    }
LABEL_129:
    qword_1EB208B10 = 0;
  }
LABEL_130:
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB208B08);
  qword_1EB208B18 = (uint64_t)explicit;
LABEL_131:
  if (explicit) {
    return explicit + 2;
  }
  else {
    return 0;
  }
}