void sub_1A5F0C(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  char *v12;
  unint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  char *v17;
  unint64_t v18;
  void *v19;
  void *v20;
  uint64_t v21;
  char *v22;
  unint64_t v23;
  void *v24;
  void *v25;
  uint64_t v26;
  char *v27;
  unint64_t v28;
  void *v29;
  void *v30;
  uint64_t v31;
  char *v32;
  unint64_t v33;
  void *v34;
  void *v35;
  uint64_t v36;
  char *v37;
  unint64_t v38;
  void *v39;
  void *v40;
  uint64_t v41;
  uint64_t *v42;
  unint64_t v43;
  void *v44;
  void *v45;
  uint64_t v46;
  char *v47;
  unint64_t v48;
  void *v49;
  void *v50;
  uint64_t v51;
  char *v52;
  unint64_t v53;
  void *v54;
  void *v55;
  uint64_t v56;
  char *v57;
  unint64_t v58;
  void *v59;
  void *v60;
  uint64_t v61;
  char *v62;
  unint64_t v63;
  void *v64;
  void *v65;
  uint64_t v66;
  char *v67;
  unint64_t v68;
  void *v69;
  void *v70;
  uint64_t v71;
  char *v72;
  unint64_t v73;
  void *v74;
  void *v75;
  uint64_t v76;
  uint64_t *v77;
  unint64_t v78;
  void *v79;
  void *v80;
  uint64_t v81;
  char *v82;
  unint64_t v83;
  void *v84;
  void *v85;
  uint64_t v86;
  char *v87;
  unint64_t v88;
  void *v89;
  void *v90;
  uint64_t v91;
  char *v92;
  unint64_t v93;
  void *v94;
  void *v95;
  uint64_t v96;
  char *v97;
  unint64_t v98;
  void *v99;
  void *v100;
  uint64_t v101;
  char *v102;
  unint64_t v103;
  void *v104;
  void *v105;
  uint64_t v106;
  char *v107;
  unint64_t v108;
  void *v109;
  void *v110;
  uint64_t v111;
  char *v112;
  unint64_t v113;
  void *v114;
  void *v115;
  unint64_t v116;
  unint64_t *v117;
  unint64_t v118;
  void *v119;
  char *v120;
  uint64_t v121;
  unint64_t v122;
  unint64_t v123;
  unint64_t v124;
  char *v125;
  char *v126;
  uint64_t v127;
  unint64_t v128;
  unint64_t v129;
  unint64_t v130;
  char *v131;
  char *v132;
  uint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  char *v137;
  char *v138;
  uint64_t v139;
  unint64_t v140;
  unint64_t v141;
  unint64_t v142;
  char *v143;
  char *v144;
  uint64_t v145;
  unint64_t v146;
  unint64_t v147;
  unint64_t v148;
  char *v149;
  char *v150;
  uint64_t v151;
  unint64_t v152;
  unint64_t v153;
  unint64_t v154;
  char *v155;
  uint64_t *v156;
  uint64_t v157;
  unint64_t v158;
  unint64_t v159;
  unint64_t v160;
  char *v161;
  char *v162;
  uint64_t v163;
  unint64_t v164;
  unint64_t v165;
  unint64_t v166;
  char *v167;
  char *v168;
  uint64_t v169;
  unint64_t v170;
  unint64_t v171;
  unint64_t v172;
  char *v173;
  char *v174;
  uint64_t v175;
  unint64_t v176;
  unint64_t v177;
  unint64_t v178;
  char *v179;
  char *v180;
  uint64_t v181;
  unint64_t v182;
  unint64_t v183;
  unint64_t v184;
  char *v185;
  char *v186;
  uint64_t v187;
  unint64_t v188;
  unint64_t v189;
  unint64_t v190;
  char *v191;
  char *v192;
  uint64_t v193;
  unint64_t v194;
  unint64_t v195;
  unint64_t v196;
  char *v197;
  uint64_t *v198;
  uint64_t v199;
  unint64_t v200;
  unint64_t v201;
  unint64_t v202;
  char *v203;
  char *v204;
  uint64_t v205;
  unint64_t v206;
  unint64_t v207;
  unint64_t v208;
  char *v209;
  char *v210;
  uint64_t v211;
  unint64_t v212;
  unint64_t v213;
  unint64_t v214;
  char *v215;
  char *v216;
  uint64_t v217;
  unint64_t v218;
  unint64_t v219;
  unint64_t v220;
  char *v221;
  char *v222;
  uint64_t v223;
  unint64_t v224;
  unint64_t v225;
  unint64_t v226;
  char *v227;
  char *v228;
  uint64_t v229;
  unint64_t v230;
  unint64_t v231;
  unint64_t v232;
  char *v233;
  char *v234;
  uint64_t v235;
  unint64_t v236;
  unint64_t v237;
  unint64_t v238;
  char *v239;
  char *v240;
  uint64_t v241;
  unint64_t v242;
  unint64_t v243;
  unint64_t v244;
  char *v245;
  unint64_t *v246;
  uint64_t v247;
  unint64_t v248;
  unint64_t v249;
  unint64_t v250;
  char *v251;
  char *v252;
  uint64_t v253;
  char *v254;
  uint64_t v255;
  char *v256;
  uint64_t v257;
  char *v258;
  uint64_t v259;
  char *v260;
  uint64_t v261;
  char *v262;
  uint64_t v263;
  uint64_t *v264;
  uint64_t v265;
  char *v266;
  uint64_t v267;
  char *v268;
  uint64_t v269;
  char *v270;
  uint64_t v271;
  char *v272;
  uint64_t v273;
  char *v274;
  uint64_t v275;
  char *v276;
  uint64_t v277;
  uint64_t *v278;
  uint64_t v279;
  char *v280;
  uint64_t v281;
  char *v282;
  uint64_t v283;
  char *v284;
  uint64_t v285;
  char *v286;
  uint64_t v287;
  char *v288;
  uint64_t v289;
  char *v290;
  uint64_t v291;
  char *v292;
  uint64_t v293;
  unint64_t *v294;
  unint64_t v295;
  int *v296;
  int **v297;
  uint64_t v298;
  unint64_t v299;
  int v300;
  unint64_t v301;
  void *v302;

  v4 = *a1;
  if (*a2 == 1)
  {
    v297 = (int **)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    v296 = *v297;
    v298 = (char *)v297[1] - (char *)*v297;
    if (v298)
    {
      v299 = v298 >> 2;
      if (v299 <= 1) {
        v299 = 1;
      }
      do
      {
        v300 = *v296++;
        switch(v300)
        {
          case 133:
            v301 = *(_WORD *)(a1[3] + 58) & 0x3FFF;
            v302 = (void *)(*(void *)a1[2] + 3976);
            goto LABEL_410;
          case 134:
            v301 = *(_WORD *)(a1[3] + 40) & 0x3FFF;
            v302 = (void *)(*(void *)a1[2] + 4000);
            goto LABEL_410;
          case 135:
            v301 = *(_WORD *)(a1[3] + 60) & 0x3FFF;
            v302 = (void *)(*(void *)a1[2] + 4024);
            goto LABEL_410;
          case 136:
            v301 = *(_WORD *)(a1[3] + 42) & 0x3FFF;
            v302 = (void *)(*(void *)a1[2] + 4048);
            goto LABEL_410;
          case 137:
            v301 = *(_WORD *)(a1[3] + 62) & 0x3FFF;
            v302 = (void *)(*(void *)a1[2] + 4072);
            goto LABEL_410;
          case 138:
            v301 = *(_WORD *)(a1[3] + 44) & 0x3FFF;
            v302 = (void *)(*(void *)a1[2] + 4096);
            goto LABEL_410;
          case 139:
            v301 = *(_DWORD *)(a1[3] + 28) & 0x3FFFF;
            v302 = (void *)(*(void *)a1[2] + 4120);
            goto LABEL_410;
          case 140:
            v301 = *(_WORD *)(a1[3] + 52) & 0x3FFF;
            v302 = (void *)(*(void *)a1[2] + 4144);
            goto LABEL_410;
          case 141:
            v301 = *(_WORD *)(a1[3] + 34) & 0x3FFF;
            v302 = (void *)(*(void *)a1[2] + 4168);
            goto LABEL_410;
          case 142:
            v301 = *(_WORD *)(a1[3] + 54) & 0x3FFF;
            v302 = (void *)(*(void *)a1[2] + 4192);
            goto LABEL_410;
          case 143:
            v301 = *(_WORD *)(a1[3] + 36) & 0x3FFF;
            v302 = (void *)(*(void *)a1[2] + 4216);
            goto LABEL_410;
          case 144:
            v301 = *(_WORD *)(a1[3] + 56) & 0x3FFF;
            v302 = (void *)(*(void *)a1[2] + 4240);
            goto LABEL_410;
          case 145:
            v301 = *(_WORD *)(a1[3] + 38) & 0x3FFF;
            v302 = (void *)(*(void *)a1[2] + 4264);
            goto LABEL_410;
          case 146:
            v301 = *(_DWORD *)(a1[3] + 24) & 0x3FFFF;
            v302 = (void *)(*(void *)a1[2] + 4288);
            goto LABEL_410;
          case 147:
            v301 = *(_WORD *)(a1[3] + 68) & 0x7FF;
            v302 = (void *)(*(void *)a1[2] + 4312);
            goto LABEL_410;
          case 148:
            v301 = *(_WORD *)(a1[3] + 50) & 0x7FF;
            v302 = (void *)(*(void *)a1[2] + 4336);
            goto LABEL_410;
          case 149:
            v301 = *(_WORD *)(a1[3] + 32) & 0x1FFF;
            v302 = (void *)(*(void *)a1[2] + 4360);
            goto LABEL_410;
          case 150:
            v301 = *(_WORD *)(a1[3] + 64) & 0x1FF;
            v302 = (void *)(*(void *)a1[2] + 4384);
            goto LABEL_410;
          case 151:
            v301 = *(_WORD *)(a1[3] + 46) & 0x1FF;
            v302 = (void *)(*(void *)a1[2] + 4408);
            goto LABEL_410;
          case 152:
            v301 = *(_WORD *)(a1[3] + 66) & 0x1FF;
            v302 = (void *)(*(void *)a1[2] + 4432);
            goto LABEL_410;
          case 153:
            v301 = *(_WORD *)(a1[3] + 48) & 0x1FF;
            v302 = (void *)(*(void *)a1[2] + 4456);
            goto LABEL_410;
          case 154:
            v301 = (unint64_t)*(unsigned int *)(a1[3] + 28) >> 18;
            v302 = (void *)(*(void *)a1[2] + 4480);
LABEL_410:
            *(void *)(*v302 - 8) += v301;
            break;
          default:
            break;
        }
        --v299;
      }
      while (v299);
    }
  }
  else
  {
    if (*a2) {
      return;
    }
    v5 = (void *)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    v6 = v5[1] - *v5;
    if (v6)
    {
      v7 = 0;
      v8 = v6 >> 2;
      if (v8 <= 1) {
        v9 = 1;
      }
      else {
        v9 = v8;
      }
      do
      {
        switch(*(_DWORD *)(*v5 + 4 * v7))
        {
          case 0x85:
            v10 = *(void **)a1[2];
            v11 = *(_WORD *)(a1[3] + 58) & 0x3FFF;
            v12 = (char *)v10[497];
            v13 = v10[498];
            if ((unint64_t)v12 >= v13)
            {
              v120 = (char *)v10[496];
              v121 = (v12 - v120) >> 3;
              if ((unint64_t)(v121 + 1) >> 61) {
                goto LABEL_414;
              }
              v122 = v13 - (void)v120;
              v123 = (uint64_t)(v13 - (void)v120) >> 2;
              if (v123 <= v121 + 1) {
                v123 = v121 + 1;
              }
              if (v122 >= 0x7FFFFFFFFFFFFFF8) {
                v124 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v124 = v123;
              }
              if (v124)
              {
                v125 = (char *)sub_5714((uint64_t)(v10 + 498), v124);
                v12 = (char *)v10[497];
                v120 = (char *)v10[496];
              }
              else
              {
                v125 = 0;
              }
              v252 = &v125[8 * v121];
              *(void *)v252 = v11;
              v14 = v252 + 8;
              while (v12 != v120)
              {
                v253 = *((void *)v12 - 1);
                v12 -= 8;
                *((void *)v252 - 1) = v253;
                v252 -= 8;
              }
              v10[496] = v252;
              v10[497] = v14;
              v10[498] = &v125[8 * v124];
              if (v120) {
                operator delete(v120);
              }
            }
            else
            {
              *(void *)v12 = v11;
              v14 = v12 + 8;
            }
            v10[497] = v14;
            break;
          case 0x86:
            v15 = *(void **)a1[2];
            v16 = *(_WORD *)(a1[3] + 40) & 0x3FFF;
            v17 = (char *)v15[500];
            v18 = v15[501];
            if ((unint64_t)v17 >= v18)
            {
              v126 = (char *)v15[499];
              v127 = (v17 - v126) >> 3;
              if ((unint64_t)(v127 + 1) >> 61) {
                goto LABEL_414;
              }
              v128 = v18 - (void)v126;
              v129 = (uint64_t)(v18 - (void)v126) >> 2;
              if (v129 <= v127 + 1) {
                v129 = v127 + 1;
              }
              if (v128 >= 0x7FFFFFFFFFFFFFF8) {
                v130 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v130 = v129;
              }
              if (v130)
              {
                v131 = (char *)sub_5714((uint64_t)(v15 + 501), v130);
                v17 = (char *)v15[500];
                v126 = (char *)v15[499];
              }
              else
              {
                v131 = 0;
              }
              v254 = &v131[8 * v127];
              *(void *)v254 = v16;
              v19 = v254 + 8;
              while (v17 != v126)
              {
                v255 = *((void *)v17 - 1);
                v17 -= 8;
                *((void *)v254 - 1) = v255;
                v254 -= 8;
              }
              v15[499] = v254;
              v15[500] = v19;
              v15[501] = &v131[8 * v130];
              if (v126) {
                operator delete(v126);
              }
            }
            else
            {
              *(void *)v17 = v16;
              v19 = v17 + 8;
            }
            v15[500] = v19;
            break;
          case 0x87:
            v20 = *(void **)a1[2];
            v21 = *(_WORD *)(a1[3] + 60) & 0x3FFF;
            v22 = (char *)v20[503];
            v23 = v20[504];
            if ((unint64_t)v22 >= v23)
            {
              v132 = (char *)v20[502];
              v133 = (v22 - v132) >> 3;
              if ((unint64_t)(v133 + 1) >> 61) {
                goto LABEL_414;
              }
              v134 = v23 - (void)v132;
              v135 = (uint64_t)(v23 - (void)v132) >> 2;
              if (v135 <= v133 + 1) {
                v135 = v133 + 1;
              }
              if (v134 >= 0x7FFFFFFFFFFFFFF8) {
                v136 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v136 = v135;
              }
              if (v136)
              {
                v137 = (char *)sub_5714((uint64_t)(v20 + 504), v136);
                v22 = (char *)v20[503];
                v132 = (char *)v20[502];
              }
              else
              {
                v137 = 0;
              }
              v256 = &v137[8 * v133];
              *(void *)v256 = v21;
              v24 = v256 + 8;
              while (v22 != v132)
              {
                v257 = *((void *)v22 - 1);
                v22 -= 8;
                *((void *)v256 - 1) = v257;
                v256 -= 8;
              }
              v20[502] = v256;
              v20[503] = v24;
              v20[504] = &v137[8 * v136];
              if (v132) {
                operator delete(v132);
              }
            }
            else
            {
              *(void *)v22 = v21;
              v24 = v22 + 8;
            }
            v20[503] = v24;
            break;
          case 0x88:
            v25 = *(void **)a1[2];
            v26 = *(_WORD *)(a1[3] + 42) & 0x3FFF;
            v27 = (char *)v25[506];
            v28 = v25[507];
            if ((unint64_t)v27 >= v28)
            {
              v138 = (char *)v25[505];
              v139 = (v27 - v138) >> 3;
              if ((unint64_t)(v139 + 1) >> 61) {
                goto LABEL_414;
              }
              v140 = v28 - (void)v138;
              v141 = (uint64_t)(v28 - (void)v138) >> 2;
              if (v141 <= v139 + 1) {
                v141 = v139 + 1;
              }
              if (v140 >= 0x7FFFFFFFFFFFFFF8) {
                v142 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v142 = v141;
              }
              if (v142)
              {
                v143 = (char *)sub_5714((uint64_t)(v25 + 507), v142);
                v27 = (char *)v25[506];
                v138 = (char *)v25[505];
              }
              else
              {
                v143 = 0;
              }
              v258 = &v143[8 * v139];
              *(void *)v258 = v26;
              v29 = v258 + 8;
              while (v27 != v138)
              {
                v259 = *((void *)v27 - 1);
                v27 -= 8;
                *((void *)v258 - 1) = v259;
                v258 -= 8;
              }
              v25[505] = v258;
              v25[506] = v29;
              v25[507] = &v143[8 * v142];
              if (v138) {
                operator delete(v138);
              }
            }
            else
            {
              *(void *)v27 = v26;
              v29 = v27 + 8;
            }
            v25[506] = v29;
            break;
          case 0x89:
            v30 = *(void **)a1[2];
            v31 = *(_WORD *)(a1[3] + 62) & 0x3FFF;
            v32 = (char *)v30[509];
            v33 = v30[510];
            if ((unint64_t)v32 >= v33)
            {
              v144 = (char *)v30[508];
              v145 = (v32 - v144) >> 3;
              if ((unint64_t)(v145 + 1) >> 61) {
                goto LABEL_414;
              }
              v146 = v33 - (void)v144;
              v147 = (uint64_t)(v33 - (void)v144) >> 2;
              if (v147 <= v145 + 1) {
                v147 = v145 + 1;
              }
              if (v146 >= 0x7FFFFFFFFFFFFFF8) {
                v148 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v148 = v147;
              }
              if (v148)
              {
                v149 = (char *)sub_5714((uint64_t)(v30 + 510), v148);
                v32 = (char *)v30[509];
                v144 = (char *)v30[508];
              }
              else
              {
                v149 = 0;
              }
              v260 = &v149[8 * v145];
              *(void *)v260 = v31;
              v34 = v260 + 8;
              while (v32 != v144)
              {
                v261 = *((void *)v32 - 1);
                v32 -= 8;
                *((void *)v260 - 1) = v261;
                v260 -= 8;
              }
              v30[508] = v260;
              v30[509] = v34;
              v30[510] = &v149[8 * v148];
              if (v144) {
                operator delete(v144);
              }
            }
            else
            {
              *(void *)v32 = v31;
              v34 = v32 + 8;
            }
            v30[509] = v34;
            break;
          case 0x8A:
            v35 = *(void **)a1[2];
            v36 = *(_WORD *)(a1[3] + 44) & 0x3FFF;
            v37 = (char *)v35[512];
            v38 = v35[513];
            if ((unint64_t)v37 >= v38)
            {
              v150 = (char *)v35[511];
              v151 = (v37 - v150) >> 3;
              if ((unint64_t)(v151 + 1) >> 61) {
                goto LABEL_414;
              }
              v152 = v38 - (void)v150;
              v153 = (uint64_t)(v38 - (void)v150) >> 2;
              if (v153 <= v151 + 1) {
                v153 = v151 + 1;
              }
              if (v152 >= 0x7FFFFFFFFFFFFFF8) {
                v154 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v154 = v153;
              }
              if (v154)
              {
                v155 = (char *)sub_5714((uint64_t)(v35 + 513), v154);
                v37 = (char *)v35[512];
                v150 = (char *)v35[511];
              }
              else
              {
                v155 = 0;
              }
              v262 = &v155[8 * v151];
              *(void *)v262 = v36;
              v39 = v262 + 8;
              while (v37 != v150)
              {
                v263 = *((void *)v37 - 1);
                v37 -= 8;
                *((void *)v262 - 1) = v263;
                v262 -= 8;
              }
              v35[511] = v262;
              v35[512] = v39;
              v35[513] = &v155[8 * v154];
              if (v150) {
                operator delete(v150);
              }
            }
            else
            {
              *(void *)v37 = v36;
              v39 = v37 + 8;
            }
            v35[512] = v39;
            break;
          case 0x8B:
            v40 = *(void **)a1[2];
            v41 = *(_DWORD *)(a1[3] + 28) & 0x3FFFFLL;
            v42 = (uint64_t *)v40[515];
            v43 = v40[516];
            if ((unint64_t)v42 >= v43)
            {
              v156 = (uint64_t *)v40[514];
              v157 = v42 - v156;
              if ((unint64_t)(v157 + 1) >> 61) {
                goto LABEL_414;
              }
              v158 = v43 - (void)v156;
              v159 = (uint64_t)(v43 - (void)v156) >> 2;
              if (v159 <= v157 + 1) {
                v159 = v157 + 1;
              }
              if (v158 >= 0x7FFFFFFFFFFFFFF8) {
                v160 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v160 = v159;
              }
              if (v160)
              {
                v161 = (char *)sub_5714((uint64_t)(v40 + 516), v160);
                v42 = (uint64_t *)v40[515];
                v156 = (uint64_t *)v40[514];
              }
              else
              {
                v161 = 0;
              }
              v264 = (uint64_t *)&v161[8 * v157];
              *v264 = v41;
              v44 = v264 + 1;
              while (v42 != v156)
              {
                v265 = *--v42;
                *--v264 = v265;
              }
              v40[514] = v264;
              v40[515] = v44;
              v40[516] = &v161[8 * v160];
              if (v156) {
                operator delete(v156);
              }
            }
            else
            {
              *v42 = v41;
              v44 = v42 + 1;
            }
            v40[515] = v44;
            break;
          case 0x8C:
            v45 = *(void **)a1[2];
            v46 = *(_WORD *)(a1[3] + 52) & 0x3FFF;
            v47 = (char *)v45[518];
            v48 = v45[519];
            if ((unint64_t)v47 >= v48)
            {
              v162 = (char *)v45[517];
              v163 = (v47 - v162) >> 3;
              if ((unint64_t)(v163 + 1) >> 61) {
                goto LABEL_414;
              }
              v164 = v48 - (void)v162;
              v165 = (uint64_t)(v48 - (void)v162) >> 2;
              if (v165 <= v163 + 1) {
                v165 = v163 + 1;
              }
              if (v164 >= 0x7FFFFFFFFFFFFFF8) {
                v166 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v166 = v165;
              }
              if (v166)
              {
                v167 = (char *)sub_5714((uint64_t)(v45 + 519), v166);
                v47 = (char *)v45[518];
                v162 = (char *)v45[517];
              }
              else
              {
                v167 = 0;
              }
              v266 = &v167[8 * v163];
              *(void *)v266 = v46;
              v49 = v266 + 8;
              while (v47 != v162)
              {
                v267 = *((void *)v47 - 1);
                v47 -= 8;
                *((void *)v266 - 1) = v267;
                v266 -= 8;
              }
              v45[517] = v266;
              v45[518] = v49;
              v45[519] = &v167[8 * v166];
              if (v162) {
                operator delete(v162);
              }
            }
            else
            {
              *(void *)v47 = v46;
              v49 = v47 + 8;
            }
            v45[518] = v49;
            break;
          case 0x8D:
            v50 = *(void **)a1[2];
            v51 = *(_WORD *)(a1[3] + 34) & 0x3FFF;
            v52 = (char *)v50[521];
            v53 = v50[522];
            if ((unint64_t)v52 >= v53)
            {
              v168 = (char *)v50[520];
              v169 = (v52 - v168) >> 3;
              if ((unint64_t)(v169 + 1) >> 61) {
                goto LABEL_414;
              }
              v170 = v53 - (void)v168;
              v171 = (uint64_t)(v53 - (void)v168) >> 2;
              if (v171 <= v169 + 1) {
                v171 = v169 + 1;
              }
              if (v170 >= 0x7FFFFFFFFFFFFFF8) {
                v172 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v172 = v171;
              }
              if (v172)
              {
                v173 = (char *)sub_5714((uint64_t)(v50 + 522), v172);
                v52 = (char *)v50[521];
                v168 = (char *)v50[520];
              }
              else
              {
                v173 = 0;
              }
              v268 = &v173[8 * v169];
              *(void *)v268 = v51;
              v54 = v268 + 8;
              while (v52 != v168)
              {
                v269 = *((void *)v52 - 1);
                v52 -= 8;
                *((void *)v268 - 1) = v269;
                v268 -= 8;
              }
              v50[520] = v268;
              v50[521] = v54;
              v50[522] = &v173[8 * v172];
              if (v168) {
                operator delete(v168);
              }
            }
            else
            {
              *(void *)v52 = v51;
              v54 = v52 + 8;
            }
            v50[521] = v54;
            break;
          case 0x8E:
            v55 = *(void **)a1[2];
            v56 = *(_WORD *)(a1[3] + 54) & 0x3FFF;
            v57 = (char *)v55[524];
            v58 = v55[525];
            if ((unint64_t)v57 >= v58)
            {
              v174 = (char *)v55[523];
              v175 = (v57 - v174) >> 3;
              if ((unint64_t)(v175 + 1) >> 61) {
                goto LABEL_414;
              }
              v176 = v58 - (void)v174;
              v177 = (uint64_t)(v58 - (void)v174) >> 2;
              if (v177 <= v175 + 1) {
                v177 = v175 + 1;
              }
              if (v176 >= 0x7FFFFFFFFFFFFFF8) {
                v178 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v178 = v177;
              }
              if (v178)
              {
                v179 = (char *)sub_5714((uint64_t)(v55 + 525), v178);
                v57 = (char *)v55[524];
                v174 = (char *)v55[523];
              }
              else
              {
                v179 = 0;
              }
              v270 = &v179[8 * v175];
              *(void *)v270 = v56;
              v59 = v270 + 8;
              while (v57 != v174)
              {
                v271 = *((void *)v57 - 1);
                v57 -= 8;
                *((void *)v270 - 1) = v271;
                v270 -= 8;
              }
              v55[523] = v270;
              v55[524] = v59;
              v55[525] = &v179[8 * v178];
              if (v174) {
                operator delete(v174);
              }
            }
            else
            {
              *(void *)v57 = v56;
              v59 = v57 + 8;
            }
            v55[524] = v59;
            break;
          case 0x8F:
            v60 = *(void **)a1[2];
            v61 = *(_WORD *)(a1[3] + 36) & 0x3FFF;
            v62 = (char *)v60[527];
            v63 = v60[528];
            if ((unint64_t)v62 >= v63)
            {
              v180 = (char *)v60[526];
              v181 = (v62 - v180) >> 3;
              if ((unint64_t)(v181 + 1) >> 61) {
                goto LABEL_414;
              }
              v182 = v63 - (void)v180;
              v183 = (uint64_t)(v63 - (void)v180) >> 2;
              if (v183 <= v181 + 1) {
                v183 = v181 + 1;
              }
              if (v182 >= 0x7FFFFFFFFFFFFFF8) {
                v184 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v184 = v183;
              }
              if (v184)
              {
                v185 = (char *)sub_5714((uint64_t)(v60 + 528), v184);
                v62 = (char *)v60[527];
                v180 = (char *)v60[526];
              }
              else
              {
                v185 = 0;
              }
              v272 = &v185[8 * v181];
              *(void *)v272 = v61;
              v64 = v272 + 8;
              while (v62 != v180)
              {
                v273 = *((void *)v62 - 1);
                v62 -= 8;
                *((void *)v272 - 1) = v273;
                v272 -= 8;
              }
              v60[526] = v272;
              v60[527] = v64;
              v60[528] = &v185[8 * v184];
              if (v180) {
                operator delete(v180);
              }
            }
            else
            {
              *(void *)v62 = v61;
              v64 = v62 + 8;
            }
            v60[527] = v64;
            break;
          case 0x90:
            v65 = *(void **)a1[2];
            v66 = *(_WORD *)(a1[3] + 56) & 0x3FFF;
            v67 = (char *)v65[530];
            v68 = v65[531];
            if ((unint64_t)v67 >= v68)
            {
              v186 = (char *)v65[529];
              v187 = (v67 - v186) >> 3;
              if ((unint64_t)(v187 + 1) >> 61) {
                goto LABEL_414;
              }
              v188 = v68 - (void)v186;
              v189 = (uint64_t)(v68 - (void)v186) >> 2;
              if (v189 <= v187 + 1) {
                v189 = v187 + 1;
              }
              if (v188 >= 0x7FFFFFFFFFFFFFF8) {
                v190 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v190 = v189;
              }
              if (v190)
              {
                v191 = (char *)sub_5714((uint64_t)(v65 + 531), v190);
                v67 = (char *)v65[530];
                v186 = (char *)v65[529];
              }
              else
              {
                v191 = 0;
              }
              v274 = &v191[8 * v187];
              *(void *)v274 = v66;
              v69 = v274 + 8;
              while (v67 != v186)
              {
                v275 = *((void *)v67 - 1);
                v67 -= 8;
                *((void *)v274 - 1) = v275;
                v274 -= 8;
              }
              v65[529] = v274;
              v65[530] = v69;
              v65[531] = &v191[8 * v190];
              if (v186) {
                operator delete(v186);
              }
            }
            else
            {
              *(void *)v67 = v66;
              v69 = v67 + 8;
            }
            v65[530] = v69;
            break;
          case 0x91:
            v70 = *(void **)a1[2];
            v71 = *(_WORD *)(a1[3] + 38) & 0x3FFF;
            v72 = (char *)v70[533];
            v73 = v70[534];
            if ((unint64_t)v72 >= v73)
            {
              v192 = (char *)v70[532];
              v193 = (v72 - v192) >> 3;
              if ((unint64_t)(v193 + 1) >> 61) {
                goto LABEL_414;
              }
              v194 = v73 - (void)v192;
              v195 = (uint64_t)(v73 - (void)v192) >> 2;
              if (v195 <= v193 + 1) {
                v195 = v193 + 1;
              }
              if (v194 >= 0x7FFFFFFFFFFFFFF8) {
                v196 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v196 = v195;
              }
              if (v196)
              {
                v197 = (char *)sub_5714((uint64_t)(v70 + 534), v196);
                v72 = (char *)v70[533];
                v192 = (char *)v70[532];
              }
              else
              {
                v197 = 0;
              }
              v276 = &v197[8 * v193];
              *(void *)v276 = v71;
              v74 = v276 + 8;
              while (v72 != v192)
              {
                v277 = *((void *)v72 - 1);
                v72 -= 8;
                *((void *)v276 - 1) = v277;
                v276 -= 8;
              }
              v70[532] = v276;
              v70[533] = v74;
              v70[534] = &v197[8 * v196];
              if (v192) {
                operator delete(v192);
              }
            }
            else
            {
              *(void *)v72 = v71;
              v74 = v72 + 8;
            }
            v70[533] = v74;
            break;
          case 0x92:
            v75 = *(void **)a1[2];
            v76 = *(_DWORD *)(a1[3] + 24) & 0x3FFFFLL;
            v77 = (uint64_t *)v75[536];
            v78 = v75[537];
            if ((unint64_t)v77 >= v78)
            {
              v198 = (uint64_t *)v75[535];
              v199 = v77 - v198;
              if ((unint64_t)(v199 + 1) >> 61) {
                goto LABEL_414;
              }
              v200 = v78 - (void)v198;
              v201 = (uint64_t)(v78 - (void)v198) >> 2;
              if (v201 <= v199 + 1) {
                v201 = v199 + 1;
              }
              if (v200 >= 0x7FFFFFFFFFFFFFF8) {
                v202 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v202 = v201;
              }
              if (v202)
              {
                v203 = (char *)sub_5714((uint64_t)(v75 + 537), v202);
                v77 = (uint64_t *)v75[536];
                v198 = (uint64_t *)v75[535];
              }
              else
              {
                v203 = 0;
              }
              v278 = (uint64_t *)&v203[8 * v199];
              *v278 = v76;
              v79 = v278 + 1;
              while (v77 != v198)
              {
                v279 = *--v77;
                *--v278 = v279;
              }
              v75[535] = v278;
              v75[536] = v79;
              v75[537] = &v203[8 * v202];
              if (v198) {
                operator delete(v198);
              }
            }
            else
            {
              *v77 = v76;
              v79 = v77 + 1;
            }
            v75[536] = v79;
            break;
          case 0x93:
            v80 = *(void **)a1[2];
            v81 = *(_WORD *)(a1[3] + 68) & 0x7FF;
            v82 = (char *)v80[539];
            v83 = v80[540];
            if ((unint64_t)v82 >= v83)
            {
              v204 = (char *)v80[538];
              v205 = (v82 - v204) >> 3;
              if ((unint64_t)(v205 + 1) >> 61) {
                goto LABEL_414;
              }
              v206 = v83 - (void)v204;
              v207 = (uint64_t)(v83 - (void)v204) >> 2;
              if (v207 <= v205 + 1) {
                v207 = v205 + 1;
              }
              if (v206 >= 0x7FFFFFFFFFFFFFF8) {
                v208 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v208 = v207;
              }
              if (v208)
              {
                v209 = (char *)sub_5714((uint64_t)(v80 + 540), v208);
                v82 = (char *)v80[539];
                v204 = (char *)v80[538];
              }
              else
              {
                v209 = 0;
              }
              v280 = &v209[8 * v205];
              *(void *)v280 = v81;
              v84 = v280 + 8;
              while (v82 != v204)
              {
                v281 = *((void *)v82 - 1);
                v82 -= 8;
                *((void *)v280 - 1) = v281;
                v280 -= 8;
              }
              v80[538] = v280;
              v80[539] = v84;
              v80[540] = &v209[8 * v208];
              if (v204) {
                operator delete(v204);
              }
            }
            else
            {
              *(void *)v82 = v81;
              v84 = v82 + 8;
            }
            v80[539] = v84;
            break;
          case 0x94:
            v85 = *(void **)a1[2];
            v86 = *(_WORD *)(a1[3] + 50) & 0x7FF;
            v87 = (char *)v85[542];
            v88 = v85[543];
            if ((unint64_t)v87 >= v88)
            {
              v210 = (char *)v85[541];
              v211 = (v87 - v210) >> 3;
              if ((unint64_t)(v211 + 1) >> 61) {
                goto LABEL_414;
              }
              v212 = v88 - (void)v210;
              v213 = (uint64_t)(v88 - (void)v210) >> 2;
              if (v213 <= v211 + 1) {
                v213 = v211 + 1;
              }
              if (v212 >= 0x7FFFFFFFFFFFFFF8) {
                v214 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v214 = v213;
              }
              if (v214)
              {
                v215 = (char *)sub_5714((uint64_t)(v85 + 543), v214);
                v87 = (char *)v85[542];
                v210 = (char *)v85[541];
              }
              else
              {
                v215 = 0;
              }
              v282 = &v215[8 * v211];
              *(void *)v282 = v86;
              v89 = v282 + 8;
              while (v87 != v210)
              {
                v283 = *((void *)v87 - 1);
                v87 -= 8;
                *((void *)v282 - 1) = v283;
                v282 -= 8;
              }
              v85[541] = v282;
              v85[542] = v89;
              v85[543] = &v215[8 * v214];
              if (v210) {
                operator delete(v210);
              }
            }
            else
            {
              *(void *)v87 = v86;
              v89 = v87 + 8;
            }
            v85[542] = v89;
            break;
          case 0x95:
            v90 = *(void **)a1[2];
            v91 = *(_WORD *)(a1[3] + 32) & 0x1FFF;
            v92 = (char *)v90[545];
            v93 = v90[546];
            if ((unint64_t)v92 >= v93)
            {
              v216 = (char *)v90[544];
              v217 = (v92 - v216) >> 3;
              if ((unint64_t)(v217 + 1) >> 61) {
                goto LABEL_414;
              }
              v218 = v93 - (void)v216;
              v219 = (uint64_t)(v93 - (void)v216) >> 2;
              if (v219 <= v217 + 1) {
                v219 = v217 + 1;
              }
              if (v218 >= 0x7FFFFFFFFFFFFFF8) {
                v220 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v220 = v219;
              }
              if (v220)
              {
                v221 = (char *)sub_5714((uint64_t)(v90 + 546), v220);
                v92 = (char *)v90[545];
                v216 = (char *)v90[544];
              }
              else
              {
                v221 = 0;
              }
              v284 = &v221[8 * v217];
              *(void *)v284 = v91;
              v94 = v284 + 8;
              while (v92 != v216)
              {
                v285 = *((void *)v92 - 1);
                v92 -= 8;
                *((void *)v284 - 1) = v285;
                v284 -= 8;
              }
              v90[544] = v284;
              v90[545] = v94;
              v90[546] = &v221[8 * v220];
              if (v216) {
                operator delete(v216);
              }
            }
            else
            {
              *(void *)v92 = v91;
              v94 = v92 + 8;
            }
            v90[545] = v94;
            break;
          case 0x96:
            v95 = *(void **)a1[2];
            v96 = *(_WORD *)(a1[3] + 64) & 0x1FF;
            v97 = (char *)v95[548];
            v98 = v95[549];
            if ((unint64_t)v97 >= v98)
            {
              v222 = (char *)v95[547];
              v223 = (v97 - v222) >> 3;
              if ((unint64_t)(v223 + 1) >> 61) {
                goto LABEL_414;
              }
              v224 = v98 - (void)v222;
              v225 = (uint64_t)(v98 - (void)v222) >> 2;
              if (v225 <= v223 + 1) {
                v225 = v223 + 1;
              }
              if (v224 >= 0x7FFFFFFFFFFFFFF8) {
                v226 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v226 = v225;
              }
              if (v226)
              {
                v227 = (char *)sub_5714((uint64_t)(v95 + 549), v226);
                v97 = (char *)v95[548];
                v222 = (char *)v95[547];
              }
              else
              {
                v227 = 0;
              }
              v286 = &v227[8 * v223];
              *(void *)v286 = v96;
              v99 = v286 + 8;
              while (v97 != v222)
              {
                v287 = *((void *)v97 - 1);
                v97 -= 8;
                *((void *)v286 - 1) = v287;
                v286 -= 8;
              }
              v95[547] = v286;
              v95[548] = v99;
              v95[549] = &v227[8 * v226];
              if (v222) {
                operator delete(v222);
              }
            }
            else
            {
              *(void *)v97 = v96;
              v99 = v97 + 8;
            }
            v95[548] = v99;
            break;
          case 0x97:
            v100 = *(void **)a1[2];
            v101 = *(_WORD *)(a1[3] + 46) & 0x1FF;
            v102 = (char *)v100[551];
            v103 = v100[552];
            if ((unint64_t)v102 >= v103)
            {
              v228 = (char *)v100[550];
              v229 = (v102 - v228) >> 3;
              if ((unint64_t)(v229 + 1) >> 61) {
                goto LABEL_414;
              }
              v230 = v103 - (void)v228;
              v231 = (uint64_t)(v103 - (void)v228) >> 2;
              if (v231 <= v229 + 1) {
                v231 = v229 + 1;
              }
              if (v230 >= 0x7FFFFFFFFFFFFFF8) {
                v232 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v232 = v231;
              }
              if (v232)
              {
                v233 = (char *)sub_5714((uint64_t)(v100 + 552), v232);
                v102 = (char *)v100[551];
                v228 = (char *)v100[550];
              }
              else
              {
                v233 = 0;
              }
              v288 = &v233[8 * v229];
              *(void *)v288 = v101;
              v104 = v288 + 8;
              while (v102 != v228)
              {
                v289 = *((void *)v102 - 1);
                v102 -= 8;
                *((void *)v288 - 1) = v289;
                v288 -= 8;
              }
              v100[550] = v288;
              v100[551] = v104;
              v100[552] = &v233[8 * v232];
              if (v228) {
                operator delete(v228);
              }
            }
            else
            {
              *(void *)v102 = v101;
              v104 = v102 + 8;
            }
            v100[551] = v104;
            break;
          case 0x98:
            v105 = *(void **)a1[2];
            v106 = *(_WORD *)(a1[3] + 66) & 0x1FF;
            v107 = (char *)v105[554];
            v108 = v105[555];
            if ((unint64_t)v107 >= v108)
            {
              v234 = (char *)v105[553];
              v235 = (v107 - v234) >> 3;
              if ((unint64_t)(v235 + 1) >> 61) {
                goto LABEL_414;
              }
              v236 = v108 - (void)v234;
              v237 = (uint64_t)(v108 - (void)v234) >> 2;
              if (v237 <= v235 + 1) {
                v237 = v235 + 1;
              }
              if (v236 >= 0x7FFFFFFFFFFFFFF8) {
                v238 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v238 = v237;
              }
              if (v238)
              {
                v239 = (char *)sub_5714((uint64_t)(v105 + 555), v238);
                v107 = (char *)v105[554];
                v234 = (char *)v105[553];
              }
              else
              {
                v239 = 0;
              }
              v290 = &v239[8 * v235];
              *(void *)v290 = v106;
              v109 = v290 + 8;
              while (v107 != v234)
              {
                v291 = *((void *)v107 - 1);
                v107 -= 8;
                *((void *)v290 - 1) = v291;
                v290 -= 8;
              }
              v105[553] = v290;
              v105[554] = v109;
              v105[555] = &v239[8 * v238];
              if (v234) {
                operator delete(v234);
              }
            }
            else
            {
              *(void *)v107 = v106;
              v109 = v107 + 8;
            }
            v105[554] = v109;
            break;
          case 0x99:
            v110 = *(void **)a1[2];
            v111 = *(_WORD *)(a1[3] + 48) & 0x1FF;
            v112 = (char *)v110[557];
            v113 = v110[558];
            if ((unint64_t)v112 >= v113)
            {
              v240 = (char *)v110[556];
              v241 = (v112 - v240) >> 3;
              if ((unint64_t)(v241 + 1) >> 61) {
                goto LABEL_414;
              }
              v242 = v113 - (void)v240;
              v243 = (uint64_t)(v113 - (void)v240) >> 2;
              if (v243 <= v241 + 1) {
                v243 = v241 + 1;
              }
              if (v242 >= 0x7FFFFFFFFFFFFFF8) {
                v244 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v244 = v243;
              }
              if (v244)
              {
                v245 = (char *)sub_5714((uint64_t)(v110 + 558), v244);
                v112 = (char *)v110[557];
                v240 = (char *)v110[556];
              }
              else
              {
                v245 = 0;
              }
              v292 = &v245[8 * v241];
              *(void *)v292 = v111;
              v114 = v292 + 8;
              while (v112 != v240)
              {
                v293 = *((void *)v112 - 1);
                v112 -= 8;
                *((void *)v292 - 1) = v293;
                v292 -= 8;
              }
              v110[556] = v292;
              v110[557] = v114;
              v110[558] = &v245[8 * v244];
              if (v240) {
                operator delete(v240);
              }
            }
            else
            {
              *(void *)v112 = v111;
              v114 = v112 + 8;
            }
            v110[557] = v114;
            break;
          case 0x9A:
            v115 = *(void **)a1[2];
            v116 = (unint64_t)*(unsigned int *)(a1[3] + 28) >> 18;
            v117 = (unint64_t *)v115[560];
            v118 = v115[561];
            if ((unint64_t)v117 >= v118)
            {
              v246 = (unint64_t *)v115[559];
              v247 = v117 - v246;
              if ((unint64_t)(v247 + 1) >> 61) {
LABEL_414:
              }
                sub_566C();
              v248 = v118 - (void)v246;
              v249 = (uint64_t)(v118 - (void)v246) >> 2;
              if (v249 <= v247 + 1) {
                v249 = v247 + 1;
              }
              if (v248 >= 0x7FFFFFFFFFFFFFF8) {
                v250 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                v250 = v249;
              }
              if (v250)
              {
                v251 = (char *)sub_5714((uint64_t)(v115 + 561), v250);
                v117 = (unint64_t *)v115[560];
                v246 = (unint64_t *)v115[559];
              }
              else
              {
                v251 = 0;
              }
              v294 = (unint64_t *)&v251[8 * v247];
              *v294 = v116;
              v119 = v294 + 1;
              while (v117 != v246)
              {
                v295 = *--v117;
                *--v294 = v295;
              }
              v115[559] = v294;
              v115[560] = v119;
              v115[561] = &v251[8 * v250];
              if (v246) {
                operator delete(v246);
              }
            }
            else
            {
              *v117 = v116;
              v119 = v117 + 1;
            }
            v115[560] = v119;
            break;
          default:
            break;
        }
        ++v7;
      }
      while (v7 != v9);
    }
  }
  *a2 = 1;
}

void sub_1A7460(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  if (*a2 == 1)
  {
    v143 = (int **)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    v142 = *v143;
    uint64_t v144 = (char *)v143[1] - (char *)*v143;
    if (v144)
    {
      unint64_t v145 = v144 >> 2;
      if (v145 <= 1) {
        unint64_t v145 = 1;
      }
      do
      {
        int v146 = *v142++;
        switch(v146)
        {
          case 165:
            uint64_t v147 = *(_DWORD *)(a1[3] + 44) & 0xFFFFF;
            v148 = (void *)(*(void *)a1[2] + 4744);
            goto LABEL_194;
          case 166:
            uint64_t v147 = *(_DWORD *)(a1[3] + 48) & 0xFFFFF;
            v148 = (void *)(*(void *)a1[2] + 4768);
            goto LABEL_194;
          case 167:
            uint64_t v147 = *(_DWORD *)(a1[3] + 52) & 0xFFFFF;
            v148 = (void *)(*(void *)a1[2] + 4792);
            goto LABEL_194;
          case 168:
            uint64_t v147 = *(unsigned __int16 *)(a1[3] + 58);
            v148 = (void *)(*(void *)a1[2] + 4816);
            goto LABEL_194;
          case 169:
            uint64_t v147 = *(unsigned __int16 *)(a1[3] + 56);
            v148 = (void *)(*(void *)a1[2] + 4840);
            goto LABEL_194;
          case 170:
            uint64_t v147 = *(_DWORD *)(a1[3] + 32) & 0xFFFFF;
            v148 = (void *)(*(void *)a1[2] + 4864);
            goto LABEL_194;
          case 171:
            uint64_t v147 = *(_DWORD *)(a1[3] + 36) & 0xFFFFF;
            v148 = (void *)(*(void *)a1[2] + 4888);
            goto LABEL_194;
          case 172:
            uint64_t v147 = *(_DWORD *)(a1[3] + 40) & 0xFFFFF;
            v148 = (void *)(*(void *)a1[2] + 4912);
            goto LABEL_194;
          case 173:
            uint64_t v147 = *(_DWORD *)(a1[3] + 24) & 0xFFFFF;
            v148 = (void *)(*(void *)a1[2] + 4936);
            goto LABEL_194;
          case 174:
            uint64_t v147 = *(_DWORD *)(a1[3] + 28) & 0xFFFFF;
            v148 = (void *)(*(void *)a1[2] + 4960);
LABEL_194:
            *(void *)(*v148 - 8) += v147;
            break;
          default:
            break;
        }
        --v145;
      }
      while (v145);
    }
  }
  else
  {
    if (*a2) {
      return;
    }
    v5 = (void *)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v6 = v5[1] - *v5;
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = v6 >> 2;
      if (v8 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v8;
      }
      do
      {
        switch(*(_DWORD *)(*v5 + 4 * v7))
        {
          case 0xA5:
            v10 = *(void **)a1[2];
            uint64_t v11 = *(_DWORD *)(a1[3] + 44) & 0xFFFFFLL;
            v12 = (uint64_t *)v10[593];
            unint64_t v13 = v10[594];
            if ((unint64_t)v12 >= v13)
            {
              v62 = (uint64_t *)v10[592];
              uint64_t v63 = v12 - v62;
              if ((unint64_t)(v63 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v64 = v13 - (void)v62;
              unint64_t v65 = (uint64_t)(v13 - (void)v62) >> 2;
              if (v65 <= v63 + 1) {
                unint64_t v65 = v63 + 1;
              }
              if (v64 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v66 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v66 = v65;
              }
              if (v66)
              {
                v67 = (char *)sub_5714((uint64_t)(v10 + 594), v66);
                v12 = (uint64_t *)v10[593];
                v62 = (uint64_t *)v10[592];
              }
              else
              {
                v67 = 0;
              }
              v122 = (uint64_t *)&v67[8 * v63];
              uint64_t *v122 = v11;
              v14 = v122 + 1;
              while (v12 != v62)
              {
                uint64_t v123 = *--v12;
                *--v122 = v123;
              }
              v10[592] = v122;
              v10[593] = v14;
              v10[594] = &v67[8 * v66];
              if (v62) {
                operator delete(v62);
              }
            }
            else
            {
              uint64_t *v12 = v11;
              v14 = v12 + 1;
            }
            v10[593] = v14;
            break;
          case 0xA6:
            v15 = *(void **)a1[2];
            uint64_t v16 = *(_DWORD *)(a1[3] + 48) & 0xFFFFFLL;
            v17 = (uint64_t *)v15[596];
            unint64_t v18 = v15[597];
            if ((unint64_t)v17 >= v18)
            {
              v68 = (uint64_t *)v15[595];
              uint64_t v69 = v17 - v68;
              if ((unint64_t)(v69 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v70 = v18 - (void)v68;
              unint64_t v71 = (uint64_t)(v18 - (void)v68) >> 2;
              if (v71 <= v69 + 1) {
                unint64_t v71 = v69 + 1;
              }
              if (v70 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v72 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v72 = v71;
              }
              if (v72)
              {
                v73 = (char *)sub_5714((uint64_t)(v15 + 597), v72);
                v17 = (uint64_t *)v15[596];
                v68 = (uint64_t *)v15[595];
              }
              else
              {
                v73 = 0;
              }
              v124 = (uint64_t *)&v73[8 * v69];
              uint64_t *v124 = v16;
              v19 = v124 + 1;
              while (v17 != v68)
              {
                uint64_t v125 = *--v17;
                *--v124 = v125;
              }
              v15[595] = v124;
              v15[596] = v19;
              v15[597] = &v73[8 * v72];
              if (v68) {
                operator delete(v68);
              }
            }
            else
            {
              uint64_t *v17 = v16;
              v19 = v17 + 1;
            }
            v15[596] = v19;
            break;
          case 0xA7:
            v20 = *(void **)a1[2];
            uint64_t v21 = *(_DWORD *)(a1[3] + 52) & 0xFFFFFLL;
            v22 = (uint64_t *)v20[599];
            unint64_t v23 = v20[600];
            if ((unint64_t)v22 >= v23)
            {
              v74 = (uint64_t *)v20[598];
              uint64_t v75 = v22 - v74;
              if ((unint64_t)(v75 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v76 = v23 - (void)v74;
              unint64_t v77 = (uint64_t)(v23 - (void)v74) >> 2;
              if (v77 <= v75 + 1) {
                unint64_t v77 = v75 + 1;
              }
              if (v76 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v78 = v77;
              }
              if (v78)
              {
                v79 = (char *)sub_5714((uint64_t)(v20 + 600), v78);
                v22 = (uint64_t *)v20[599];
                v74 = (uint64_t *)v20[598];
              }
              else
              {
                v79 = 0;
              }
              v126 = (uint64_t *)&v79[8 * v75];
              uint64_t *v126 = v21;
              v24 = v126 + 1;
              while (v22 != v74)
              {
                uint64_t v127 = *--v22;
                *--v126 = v127;
              }
              v20[598] = v126;
              v20[599] = v24;
              v20[600] = &v79[8 * v78];
              if (v74) {
                operator delete(v74);
              }
            }
            else
            {
              uint64_t *v22 = v21;
              v24 = v22 + 1;
            }
            v20[599] = v24;
            break;
          case 0xA8:
            uint64_t v25 = a1[2];
            v26 = *(void **)v25;
            uint64_t v27 = *(unsigned __int16 *)(a1[3] + 58);
            v28 = *(char **)(*(void *)v25 + 4816);
            unint64_t v29 = *(void *)(*(void *)v25 + 4824);
            if ((unint64_t)v28 >= v29)
            {
              v80 = (char *)v26[601];
              uint64_t v81 = (v28 - v80) >> 3;
              if ((unint64_t)(v81 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v82 = v29 - (void)v80;
              unint64_t v83 = (uint64_t)(v29 - (void)v80) >> 2;
              if (v83 <= v81 + 1) {
                unint64_t v83 = v81 + 1;
              }
              if (v82 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v84 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v84 = v83;
              }
              if (v84)
              {
                v85 = (char *)sub_5714((uint64_t)(v26 + 603), v84);
                v28 = (char *)v26[602];
                v80 = (char *)v26[601];
              }
              else
              {
                v85 = 0;
              }
              v128 = &v85[8 * v81];
              *(void *)v128 = v27;
              v30 = v128 + 8;
              while (v28 != v80)
              {
                uint64_t v129 = *((void *)v28 - 1);
                v28 -= 8;
                *((void *)v128 - 1) = v129;
                v128 -= 8;
              }
              v26[601] = v128;
              v26[602] = v30;
              v26[603] = &v85[8 * v84];
              if (v80) {
                operator delete(v80);
              }
            }
            else
            {
              *(void *)v28 = v27;
              v30 = v28 + 8;
            }
            v26[602] = v30;
            break;
          case 0xA9:
            uint64_t v31 = a1[2];
            v32 = *(void **)v31;
            uint64_t v33 = *(unsigned __int16 *)(a1[3] + 56);
            v34 = *(char **)(*(void *)v31 + 4840);
            unint64_t v35 = *(void *)(*(void *)v31 + 4848);
            if ((unint64_t)v34 >= v35)
            {
              v86 = (char *)v32[604];
              uint64_t v87 = (v34 - v86) >> 3;
              if ((unint64_t)(v87 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v88 = v35 - (void)v86;
              unint64_t v89 = (uint64_t)(v35 - (void)v86) >> 2;
              if (v89 <= v87 + 1) {
                unint64_t v89 = v87 + 1;
              }
              if (v88 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v90 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v90 = v89;
              }
              if (v90)
              {
                v91 = (char *)sub_5714((uint64_t)(v32 + 606), v90);
                v34 = (char *)v32[605];
                v86 = (char *)v32[604];
              }
              else
              {
                v91 = 0;
              }
              v130 = &v91[8 * v87];
              *(void *)v130 = v33;
              v36 = v130 + 8;
              while (v34 != v86)
              {
                uint64_t v131 = *((void *)v34 - 1);
                v34 -= 8;
                *((void *)v130 - 1) = v131;
                v130 -= 8;
              }
              v32[604] = v130;
              v32[605] = v36;
              v32[606] = &v91[8 * v90];
              if (v86) {
                operator delete(v86);
              }
            }
            else
            {
              *(void *)v34 = v33;
              v36 = v34 + 8;
            }
            v32[605] = v36;
            break;
          case 0xAA:
            v37 = *(void **)a1[2];
            uint64_t v38 = *(_DWORD *)(a1[3] + 32) & 0xFFFFFLL;
            v39 = (uint64_t *)v37[608];
            unint64_t v40 = v37[609];
            if ((unint64_t)v39 >= v40)
            {
              v92 = (uint64_t *)v37[607];
              uint64_t v93 = v39 - v92;
              if ((unint64_t)(v93 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v94 = v40 - (void)v92;
              unint64_t v95 = (uint64_t)(v40 - (void)v92) >> 2;
              if (v95 <= v93 + 1) {
                unint64_t v95 = v93 + 1;
              }
              if (v94 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v96 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v96 = v95;
              }
              if (v96)
              {
                v97 = (char *)sub_5714((uint64_t)(v37 + 609), v96);
                v39 = (uint64_t *)v37[608];
                v92 = (uint64_t *)v37[607];
              }
              else
              {
                v97 = 0;
              }
              v132 = (uint64_t *)&v97[8 * v93];
              uint64_t *v132 = v38;
              v41 = v132 + 1;
              while (v39 != v92)
              {
                uint64_t v133 = *--v39;
                *--v132 = v133;
              }
              v37[607] = v132;
              v37[608] = v41;
              v37[609] = &v97[8 * v96];
              if (v92) {
                operator delete(v92);
              }
            }
            else
            {
              uint64_t *v39 = v38;
              v41 = v39 + 1;
            }
            v37[608] = v41;
            break;
          case 0xAB:
            v42 = *(void **)a1[2];
            uint64_t v43 = *(_DWORD *)(a1[3] + 36) & 0xFFFFFLL;
            v44 = (uint64_t *)v42[611];
            unint64_t v45 = v42[612];
            if ((unint64_t)v44 >= v45)
            {
              v98 = (uint64_t *)v42[610];
              uint64_t v99 = v44 - v98;
              if ((unint64_t)(v99 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v100 = v45 - (void)v98;
              unint64_t v101 = (uint64_t)(v45 - (void)v98) >> 2;
              if (v101 <= v99 + 1) {
                unint64_t v101 = v99 + 1;
              }
              if (v100 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v102 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v102 = v101;
              }
              if (v102)
              {
                v103 = (char *)sub_5714((uint64_t)(v42 + 612), v102);
                v44 = (uint64_t *)v42[611];
                v98 = (uint64_t *)v42[610];
              }
              else
              {
                v103 = 0;
              }
              v134 = (uint64_t *)&v103[8 * v99];
              uint64_t *v134 = v43;
              v46 = v134 + 1;
              while (v44 != v98)
              {
                uint64_t v135 = *--v44;
                *--v134 = v135;
              }
              v42[610] = v134;
              v42[611] = v46;
              v42[612] = &v103[8 * v102];
              if (v98) {
                operator delete(v98);
              }
            }
            else
            {
              uint64_t *v44 = v43;
              v46 = v44 + 1;
            }
            v42[611] = v46;
            break;
          case 0xAC:
            v47 = *(void **)a1[2];
            uint64_t v48 = *(_DWORD *)(a1[3] + 40) & 0xFFFFFLL;
            v49 = (uint64_t *)v47[614];
            unint64_t v50 = v47[615];
            if ((unint64_t)v49 >= v50)
            {
              v104 = (uint64_t *)v47[613];
              uint64_t v105 = v49 - v104;
              if ((unint64_t)(v105 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v106 = v50 - (void)v104;
              unint64_t v107 = (uint64_t)(v50 - (void)v104) >> 2;
              if (v107 <= v105 + 1) {
                unint64_t v107 = v105 + 1;
              }
              if (v106 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v108 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v108 = v107;
              }
              if (v108)
              {
                v109 = (char *)sub_5714((uint64_t)(v47 + 615), v108);
                v49 = (uint64_t *)v47[614];
                v104 = (uint64_t *)v47[613];
              }
              else
              {
                v109 = 0;
              }
              v136 = (uint64_t *)&v109[8 * v105];
              uint64_t *v136 = v48;
              v51 = v136 + 1;
              while (v49 != v104)
              {
                uint64_t v137 = *--v49;
                *--v136 = v137;
              }
              v47[613] = v136;
              v47[614] = v51;
              v47[615] = &v109[8 * v108];
              if (v104) {
                operator delete(v104);
              }
            }
            else
            {
              uint64_t *v49 = v48;
              v51 = v49 + 1;
            }
            v47[614] = v51;
            break;
          case 0xAD:
            v52 = *(void **)a1[2];
            uint64_t v53 = *(_DWORD *)(a1[3] + 24) & 0xFFFFFLL;
            v54 = (uint64_t *)v52[617];
            unint64_t v55 = v52[618];
            if ((unint64_t)v54 >= v55)
            {
              v110 = (uint64_t *)v52[616];
              uint64_t v111 = v54 - v110;
              if ((unint64_t)(v111 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v112 = v55 - (void)v110;
              unint64_t v113 = (uint64_t)(v55 - (void)v110) >> 2;
              if (v113 <= v111 + 1) {
                unint64_t v113 = v111 + 1;
              }
              if (v112 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v114 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v114 = v113;
              }
              if (v114)
              {
                v115 = (char *)sub_5714((uint64_t)(v52 + 618), v114);
                v54 = (uint64_t *)v52[617];
                v110 = (uint64_t *)v52[616];
              }
              else
              {
                v115 = 0;
              }
              v138 = (uint64_t *)&v115[8 * v111];
              uint64_t *v138 = v53;
              v56 = v138 + 1;
              while (v54 != v110)
              {
                uint64_t v139 = *--v54;
                *--v138 = v139;
              }
              v52[616] = v138;
              v52[617] = v56;
              v52[618] = &v115[8 * v114];
              if (v110) {
                operator delete(v110);
              }
            }
            else
            {
              uint64_t *v54 = v53;
              v56 = v54 + 1;
            }
            v52[617] = v56;
            break;
          case 0xAE:
            v57 = *(void **)a1[2];
            uint64_t v58 = *(_DWORD *)(a1[3] + 28) & 0xFFFFFLL;
            v59 = (uint64_t *)v57[620];
            unint64_t v60 = v57[621];
            if ((unint64_t)v59 >= v60)
            {
              v116 = (uint64_t *)v57[619];
              uint64_t v117 = v59 - v116;
              if ((unint64_t)(v117 + 1) >> 61) {
LABEL_198:
              }
                sub_566C();
              unint64_t v118 = v60 - (void)v116;
              unint64_t v119 = (uint64_t)(v60 - (void)v116) >> 2;
              if (v119 <= v117 + 1) {
                unint64_t v119 = v117 + 1;
              }
              if (v118 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v120 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v120 = v119;
              }
              if (v120)
              {
                v121 = (char *)sub_5714((uint64_t)(v57 + 621), v120);
                v59 = (uint64_t *)v57[620];
                v116 = (uint64_t *)v57[619];
              }
              else
              {
                v121 = 0;
              }
              v140 = (uint64_t *)&v121[8 * v117];
              uint64_t *v140 = v58;
              v61 = v140 + 1;
              while (v59 != v116)
              {
                uint64_t v141 = *--v59;
                *--v140 = v141;
              }
              v57[619] = v140;
              v57[620] = v61;
              v57[621] = &v121[8 * v120];
              if (v116) {
                operator delete(v116);
              }
            }
            else
            {
              uint64_t *v59 = v58;
              v61 = v59 + 1;
            }
            v57[620] = v61;
            break;
          default:
            break;
        }
        ++v7;
      }
      while (v7 != v9);
    }
  }
  *a2 = 1;
}

void sub_1A7ED8(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  if (*a2 == 1)
  {
    v427 = (int **)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    v426 = *v427;
    uint64_t v428 = (char *)v427[1] - (char *)*v427;
    if (v428)
    {
      unint64_t v429 = v428 >> 2;
      if (v429 <= 1) {
        unint64_t v429 = 1;
      }
      do
      {
        int v430 = *v426++;
        switch(v430)
        {
          case '!':
            v431 = (_WORD *)(a1[3] + 34);
            v432 = (void *)(*(void *)a1[2] + 1576);
            goto LABEL_590;
          case '""':
            v431 = (_WORD *)(a1[3] + 26);
            v432 = (void *)(*(void *)a1[2] + 1600);
            goto LABEL_590;
          case '#':
            v431 = (_WORD *)(a1[3] + 36);
            v432 = (void *)(*(void *)a1[2] + 1624);
            goto LABEL_590;
          case '$':
            v431 = (_WORD *)(a1[3] + 28);
            v432 = (void *)(*(void *)a1[2] + 1648);
            goto LABEL_590;
          case '%':
            v431 = (_WORD *)(a1[3] + 38);
            v432 = (void *)(*(void *)a1[2] + 1672);
            goto LABEL_590;
          case '&':
            v431 = (_WORD *)(a1[3] + 30);
            v432 = (void *)(*(void *)a1[2] + 1696);
            goto LABEL_590;
          case '\'':
            v431 = (_WORD *)(a1[3] + 40);
            v432 = (void *)(*(void *)a1[2] + 1720);
            goto LABEL_590;
          case '(':
            v431 = (_WORD *)(a1[3] + 32);
            v432 = (void *)(*(void *)a1[2] + 1744);
            goto LABEL_590;
          case ')':
            v431 = (_WORD *)(a1[3] + 50);
            v432 = (void *)(*(void *)a1[2] + 1768);
            goto LABEL_590;
          case '*':
            v431 = (_WORD *)(a1[3] + 42);
            v432 = (void *)(*(void *)a1[2] + 1792);
            goto LABEL_590;
          case '+':
            v431 = (_WORD *)(a1[3] + 52);
            v432 = (void *)(*(void *)a1[2] + 1816);
            goto LABEL_590;
          case ',':
            v431 = (_WORD *)(a1[3] + 44);
            v432 = (void *)(*(void *)a1[2] + 1840);
            goto LABEL_590;
          case '-':
            v431 = (_WORD *)(a1[3] + 54);
            v432 = (void *)(*(void *)a1[2] + 1864);
            goto LABEL_590;
          case '.':
            v431 = (_WORD *)(a1[3] + 46);
            v432 = (void *)(*(void *)a1[2] + 1888);
            goto LABEL_590;
          case '/':
            v431 = (_WORD *)(a1[3] + 56);
            v432 = (void *)(*(void *)a1[2] + 1912);
            goto LABEL_590;
          case '0':
            v431 = (_WORD *)(a1[3] + 48);
            v432 = (void *)(*(void *)a1[2] + 1936);
            goto LABEL_590;
          case '1':
            v431 = (_WORD *)(a1[3] + 66);
            v432 = (void *)(*(void *)a1[2] + 1960);
            goto LABEL_590;
          case '2':
            v431 = (_WORD *)(a1[3] + 58);
            v432 = (void *)(*(void *)a1[2] + 1984);
            goto LABEL_590;
          case '3':
            v431 = (_WORD *)(a1[3] + 68);
            v432 = (void *)(*(void *)a1[2] + 2008);
            goto LABEL_590;
          case '4':
            v431 = (_WORD *)(a1[3] + 60);
            v432 = (void *)(*(void *)a1[2] + 2032);
            goto LABEL_590;
          case '5':
            v431 = (_WORD *)(a1[3] + 70);
            v432 = (void *)(*(void *)a1[2] + 2056);
            goto LABEL_590;
          case '6':
            v431 = (_WORD *)(a1[3] + 62);
            v432 = (void *)(*(void *)a1[2] + 2080);
            goto LABEL_590;
          case '7':
            v431 = (_WORD *)(a1[3] + 72);
            v432 = (void *)(*(void *)a1[2] + 2104);
            goto LABEL_590;
          case '8':
            v431 = (_WORD *)(a1[3] + 64);
            v432 = (void *)(*(void *)a1[2] + 2128);
            goto LABEL_590;
          case '9':
            v431 = (_WORD *)(a1[3] + 82);
            v432 = (void *)(*(void *)a1[2] + 2152);
            goto LABEL_590;
          case ':':
            v431 = (_WORD *)(a1[3] + 74);
            v432 = (void *)(*(void *)a1[2] + 2176);
            goto LABEL_590;
          case ';':
            v431 = (_WORD *)(a1[3] + 84);
            v432 = (void *)(*(void *)a1[2] + 2200);
            goto LABEL_590;
          case '<':
            v431 = (_WORD *)(a1[3] + 76);
            v432 = (void *)(*(void *)a1[2] + 2224);
            goto LABEL_590;
          case '=':
            v431 = (_WORD *)(a1[3] + 86);
            v432 = (void *)(*(void *)a1[2] + 2248);
            goto LABEL_590;
          case '>':
            v431 = (_WORD *)(a1[3] + 78);
            v432 = (void *)(*(void *)a1[2] + 2272);
            goto LABEL_590;
          case '?':
            v431 = (_WORD *)(a1[3] + 88);
            v432 = (void *)(*(void *)a1[2] + 2296);
            goto LABEL_590;
          case '@':
            v431 = (_WORD *)(a1[3] + 80);
            v432 = (void *)(*(void *)a1[2] + 2320);
LABEL_590:
            *(void *)(*v432 - 8) += *v431 & 0x7FFF;
            break;
          default:
            break;
        }
        --v429;
      }
      while (v429);
    }
  }
  else
  {
    if (*a2) {
      return;
    }
    v5 = (void *)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v6 = v5[1] - *v5;
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = v6 >> 2;
      if (v8 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v8;
      }
      do
      {
        switch(*(_DWORD *)(*v5 + 4 * v7))
        {
          case '!':
            v10 = *(void **)a1[2];
            uint64_t v11 = *(_WORD *)(a1[3] + 34) & 0x7FFF;
            v12 = (char *)v10[197];
            unint64_t v13 = v10[198];
            if ((unint64_t)v12 >= v13)
            {
              v170 = (char *)v10[196];
              uint64_t v171 = (v12 - v170) >> 3;
              if ((unint64_t)(v171 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v172 = v13 - (void)v170;
              unint64_t v173 = (uint64_t)(v13 - (void)v170) >> 2;
              if (v173 <= v171 + 1) {
                unint64_t v173 = v171 + 1;
              }
              if (v172 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v174 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v174 = v173;
              }
              if (v174)
              {
                v175 = (char *)sub_5714((uint64_t)(v10 + 198), v174);
                v12 = (char *)v10[197];
                v170 = (char *)v10[196];
              }
              else
              {
                v175 = 0;
              }
              v362 = &v175[8 * v171];
              *(void *)v362 = v11;
              v14 = v362 + 8;
              while (v12 != v170)
              {
                uint64_t v363 = *((void *)v12 - 1);
                v12 -= 8;
                *((void *)v362 - 1) = v363;
                v362 -= 8;
              }
              v10[196] = v362;
              v10[197] = v14;
              v10[198] = &v175[8 * v174];
              if (v170) {
                operator delete(v170);
              }
            }
            else
            {
              *(void *)v12 = v11;
              v14 = v12 + 8;
            }
            v10[197] = v14;
            break;
          case '""':
            v15 = *(void **)a1[2];
            uint64_t v16 = *(_WORD *)(a1[3] + 26) & 0x7FFF;
            v17 = (char *)v15[200];
            unint64_t v18 = v15[201];
            if ((unint64_t)v17 >= v18)
            {
              v176 = (char *)v15[199];
              uint64_t v177 = (v17 - v176) >> 3;
              if ((unint64_t)(v177 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v178 = v18 - (void)v176;
              unint64_t v179 = (uint64_t)(v18 - (void)v176) >> 2;
              if (v179 <= v177 + 1) {
                unint64_t v179 = v177 + 1;
              }
              if (v178 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v180 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v180 = v179;
              }
              if (v180)
              {
                v181 = (char *)sub_5714((uint64_t)(v15 + 201), v180);
                v17 = (char *)v15[200];
                v176 = (char *)v15[199];
              }
              else
              {
                v181 = 0;
              }
              v364 = &v181[8 * v177];
              *(void *)v364 = v16;
              v19 = v364 + 8;
              while (v17 != v176)
              {
                uint64_t v365 = *((void *)v17 - 1);
                v17 -= 8;
                *((void *)v364 - 1) = v365;
                v364 -= 8;
              }
              v15[199] = v364;
              v15[200] = v19;
              v15[201] = &v181[8 * v180];
              if (v176) {
                operator delete(v176);
              }
            }
            else
            {
              *(void *)v17 = v16;
              v19 = v17 + 8;
            }
            v15[200] = v19;
            break;
          case '#':
            v20 = *(void **)a1[2];
            uint64_t v21 = *(_WORD *)(a1[3] + 36) & 0x7FFF;
            v22 = (char *)v20[203];
            unint64_t v23 = v20[204];
            if ((unint64_t)v22 >= v23)
            {
              v182 = (char *)v20[202];
              uint64_t v183 = (v22 - v182) >> 3;
              if ((unint64_t)(v183 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v184 = v23 - (void)v182;
              unint64_t v185 = (uint64_t)(v23 - (void)v182) >> 2;
              if (v185 <= v183 + 1) {
                unint64_t v185 = v183 + 1;
              }
              if (v184 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v186 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v186 = v185;
              }
              if (v186)
              {
                v187 = (char *)sub_5714((uint64_t)(v20 + 204), v186);
                v22 = (char *)v20[203];
                v182 = (char *)v20[202];
              }
              else
              {
                v187 = 0;
              }
              v366 = &v187[8 * v183];
              *(void *)v366 = v21;
              v24 = v366 + 8;
              while (v22 != v182)
              {
                uint64_t v367 = *((void *)v22 - 1);
                v22 -= 8;
                *((void *)v366 - 1) = v367;
                v366 -= 8;
              }
              v20[202] = v366;
              v20[203] = v24;
              v20[204] = &v187[8 * v186];
              if (v182) {
                operator delete(v182);
              }
            }
            else
            {
              *(void *)v22 = v21;
              v24 = v22 + 8;
            }
            v20[203] = v24;
            break;
          case '$':
            uint64_t v25 = *(void **)a1[2];
            uint64_t v26 = *(_WORD *)(a1[3] + 28) & 0x7FFF;
            uint64_t v27 = (char *)v25[206];
            unint64_t v28 = v25[207];
            if ((unint64_t)v27 >= v28)
            {
              v188 = (char *)v25[205];
              uint64_t v189 = (v27 - v188) >> 3;
              if ((unint64_t)(v189 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v190 = v28 - (void)v188;
              unint64_t v191 = (uint64_t)(v28 - (void)v188) >> 2;
              if (v191 <= v189 + 1) {
                unint64_t v191 = v189 + 1;
              }
              if (v190 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v192 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v192 = v191;
              }
              if (v192)
              {
                v193 = (char *)sub_5714((uint64_t)(v25 + 207), v192);
                uint64_t v27 = (char *)v25[206];
                v188 = (char *)v25[205];
              }
              else
              {
                v193 = 0;
              }
              v368 = &v193[8 * v189];
              *(void *)v368 = v26;
              unint64_t v29 = v368 + 8;
              while (v27 != v188)
              {
                uint64_t v369 = *((void *)v27 - 1);
                v27 -= 8;
                *((void *)v368 - 1) = v369;
                v368 -= 8;
              }
              v25[205] = v368;
              v25[206] = v29;
              v25[207] = &v193[8 * v192];
              if (v188) {
                operator delete(v188);
              }
            }
            else
            {
              *(void *)uint64_t v27 = v26;
              unint64_t v29 = v27 + 8;
            }
            v25[206] = v29;
            break;
          case '%':
            v30 = *(void **)a1[2];
            uint64_t v31 = *(_WORD *)(a1[3] + 38) & 0x7FFF;
            v32 = (char *)v30[209];
            unint64_t v33 = v30[210];
            if ((unint64_t)v32 >= v33)
            {
              v194 = (char *)v30[208];
              uint64_t v195 = (v32 - v194) >> 3;
              if ((unint64_t)(v195 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v196 = v33 - (void)v194;
              unint64_t v197 = (uint64_t)(v33 - (void)v194) >> 2;
              if (v197 <= v195 + 1) {
                unint64_t v197 = v195 + 1;
              }
              if (v196 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v198 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v198 = v197;
              }
              if (v198)
              {
                v199 = (char *)sub_5714((uint64_t)(v30 + 210), v198);
                v32 = (char *)v30[209];
                v194 = (char *)v30[208];
              }
              else
              {
                v199 = 0;
              }
              v370 = &v199[8 * v195];
              *(void *)v370 = v31;
              v34 = v370 + 8;
              while (v32 != v194)
              {
                uint64_t v371 = *((void *)v32 - 1);
                v32 -= 8;
                *((void *)v370 - 1) = v371;
                v370 -= 8;
              }
              v30[208] = v370;
              v30[209] = v34;
              v30[210] = &v199[8 * v198];
              if (v194) {
                operator delete(v194);
              }
            }
            else
            {
              *(void *)v32 = v31;
              v34 = v32 + 8;
            }
            v30[209] = v34;
            break;
          case '&':
            unint64_t v35 = *(void **)a1[2];
            uint64_t v36 = *(_WORD *)(a1[3] + 30) & 0x7FFF;
            v37 = (char *)v35[212];
            unint64_t v38 = v35[213];
            if ((unint64_t)v37 >= v38)
            {
              v200 = (char *)v35[211];
              uint64_t v201 = (v37 - v200) >> 3;
              if ((unint64_t)(v201 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v202 = v38 - (void)v200;
              unint64_t v203 = (uint64_t)(v38 - (void)v200) >> 2;
              if (v203 <= v201 + 1) {
                unint64_t v203 = v201 + 1;
              }
              if (v202 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v204 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v204 = v203;
              }
              if (v204)
              {
                v205 = (char *)sub_5714((uint64_t)(v35 + 213), v204);
                v37 = (char *)v35[212];
                v200 = (char *)v35[211];
              }
              else
              {
                v205 = 0;
              }
              v372 = &v205[8 * v201];
              *(void *)v372 = v36;
              v39 = v372 + 8;
              while (v37 != v200)
              {
                uint64_t v373 = *((void *)v37 - 1);
                v37 -= 8;
                *((void *)v372 - 1) = v373;
                v372 -= 8;
              }
              v35[211] = v372;
              v35[212] = v39;
              v35[213] = &v205[8 * v204];
              if (v200) {
                operator delete(v200);
              }
            }
            else
            {
              *(void *)v37 = v36;
              v39 = v37 + 8;
            }
            v35[212] = v39;
            break;
          case '\'':
            unint64_t v40 = *(void **)a1[2];
            uint64_t v41 = *(_WORD *)(a1[3] + 40) & 0x7FFF;
            v42 = (char *)v40[215];
            unint64_t v43 = v40[216];
            if ((unint64_t)v42 >= v43)
            {
              v206 = (char *)v40[214];
              uint64_t v207 = (v42 - v206) >> 3;
              if ((unint64_t)(v207 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v208 = v43 - (void)v206;
              unint64_t v209 = (uint64_t)(v43 - (void)v206) >> 2;
              if (v209 <= v207 + 1) {
                unint64_t v209 = v207 + 1;
              }
              if (v208 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v210 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v210 = v209;
              }
              if (v210)
              {
                v211 = (char *)sub_5714((uint64_t)(v40 + 216), v210);
                v42 = (char *)v40[215];
                v206 = (char *)v40[214];
              }
              else
              {
                v211 = 0;
              }
              v374 = &v211[8 * v207];
              *(void *)v374 = v41;
              v44 = v374 + 8;
              while (v42 != v206)
              {
                uint64_t v375 = *((void *)v42 - 1);
                v42 -= 8;
                *((void *)v374 - 1) = v375;
                v374 -= 8;
              }
              v40[214] = v374;
              v40[215] = v44;
              v40[216] = &v211[8 * v210];
              if (v206) {
                operator delete(v206);
              }
            }
            else
            {
              *(void *)v42 = v41;
              v44 = v42 + 8;
            }
            v40[215] = v44;
            break;
          case '(':
            unint64_t v45 = *(void **)a1[2];
            uint64_t v46 = *(_WORD *)(a1[3] + 32) & 0x7FFF;
            v47 = (char *)v45[218];
            unint64_t v48 = v45[219];
            if ((unint64_t)v47 >= v48)
            {
              v212 = (char *)v45[217];
              uint64_t v213 = (v47 - v212) >> 3;
              if ((unint64_t)(v213 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v214 = v48 - (void)v212;
              unint64_t v215 = (uint64_t)(v48 - (void)v212) >> 2;
              if (v215 <= v213 + 1) {
                unint64_t v215 = v213 + 1;
              }
              if (v214 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v216 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v216 = v215;
              }
              if (v216)
              {
                v217 = (char *)sub_5714((uint64_t)(v45 + 219), v216);
                v47 = (char *)v45[218];
                v212 = (char *)v45[217];
              }
              else
              {
                v217 = 0;
              }
              v376 = &v217[8 * v213];
              *(void *)v376 = v46;
              v49 = v376 + 8;
              while (v47 != v212)
              {
                uint64_t v377 = *((void *)v47 - 1);
                v47 -= 8;
                *((void *)v376 - 1) = v377;
                v376 -= 8;
              }
              v45[217] = v376;
              v45[218] = v49;
              v45[219] = &v217[8 * v216];
              if (v212) {
                operator delete(v212);
              }
            }
            else
            {
              *(void *)v47 = v46;
              v49 = v47 + 8;
            }
            v45[218] = v49;
            break;
          case ')':
            unint64_t v50 = *(void **)a1[2];
            uint64_t v51 = *(_WORD *)(a1[3] + 50) & 0x7FFF;
            v52 = (char *)v50[221];
            unint64_t v53 = v50[222];
            if ((unint64_t)v52 >= v53)
            {
              v218 = (char *)v50[220];
              uint64_t v219 = (v52 - v218) >> 3;
              if ((unint64_t)(v219 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v220 = v53 - (void)v218;
              unint64_t v221 = (uint64_t)(v53 - (void)v218) >> 2;
              if (v221 <= v219 + 1) {
                unint64_t v221 = v219 + 1;
              }
              if (v220 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v222 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v222 = v221;
              }
              if (v222)
              {
                v223 = (char *)sub_5714((uint64_t)(v50 + 222), v222);
                v52 = (char *)v50[221];
                v218 = (char *)v50[220];
              }
              else
              {
                v223 = 0;
              }
              v378 = &v223[8 * v219];
              *(void *)v378 = v51;
              v54 = v378 + 8;
              while (v52 != v218)
              {
                uint64_t v379 = *((void *)v52 - 1);
                v52 -= 8;
                *((void *)v378 - 1) = v379;
                v378 -= 8;
              }
              v50[220] = v378;
              v50[221] = v54;
              v50[222] = &v223[8 * v222];
              if (v218) {
                operator delete(v218);
              }
            }
            else
            {
              *(void *)v52 = v51;
              v54 = v52 + 8;
            }
            v50[221] = v54;
            break;
          case '*':
            unint64_t v55 = *(void **)a1[2];
            uint64_t v56 = *(_WORD *)(a1[3] + 42) & 0x7FFF;
            v57 = (char *)v55[224];
            unint64_t v58 = v55[225];
            if ((unint64_t)v57 >= v58)
            {
              v224 = (char *)v55[223];
              uint64_t v225 = (v57 - v224) >> 3;
              if ((unint64_t)(v225 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v226 = v58 - (void)v224;
              unint64_t v227 = (uint64_t)(v58 - (void)v224) >> 2;
              if (v227 <= v225 + 1) {
                unint64_t v227 = v225 + 1;
              }
              if (v226 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v228 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v228 = v227;
              }
              if (v228)
              {
                v229 = (char *)sub_5714((uint64_t)(v55 + 225), v228);
                v57 = (char *)v55[224];
                v224 = (char *)v55[223];
              }
              else
              {
                v229 = 0;
              }
              v380 = &v229[8 * v225];
              *(void *)v380 = v56;
              v59 = v380 + 8;
              while (v57 != v224)
              {
                uint64_t v381 = *((void *)v57 - 1);
                v57 -= 8;
                *((void *)v380 - 1) = v381;
                v380 -= 8;
              }
              v55[223] = v380;
              v55[224] = v59;
              v55[225] = &v229[8 * v228];
              if (v224) {
                operator delete(v224);
              }
            }
            else
            {
              *(void *)v57 = v56;
              v59 = v57 + 8;
            }
            v55[224] = v59;
            break;
          case '+':
            unint64_t v60 = *(void **)a1[2];
            uint64_t v61 = *(_WORD *)(a1[3] + 52) & 0x7FFF;
            v62 = (char *)v60[227];
            unint64_t v63 = v60[228];
            if ((unint64_t)v62 >= v63)
            {
              v230 = (char *)v60[226];
              uint64_t v231 = (v62 - v230) >> 3;
              if ((unint64_t)(v231 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v232 = v63 - (void)v230;
              unint64_t v233 = (uint64_t)(v63 - (void)v230) >> 2;
              if (v233 <= v231 + 1) {
                unint64_t v233 = v231 + 1;
              }
              if (v232 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v234 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v234 = v233;
              }
              if (v234)
              {
                v235 = (char *)sub_5714((uint64_t)(v60 + 228), v234);
                v62 = (char *)v60[227];
                v230 = (char *)v60[226];
              }
              else
              {
                v235 = 0;
              }
              v382 = &v235[8 * v231];
              *(void *)v382 = v61;
              unint64_t v64 = v382 + 8;
              while (v62 != v230)
              {
                uint64_t v383 = *((void *)v62 - 1);
                v62 -= 8;
                *((void *)v382 - 1) = v383;
                v382 -= 8;
              }
              v60[226] = v382;
              v60[227] = v64;
              v60[228] = &v235[8 * v234];
              if (v230) {
                operator delete(v230);
              }
            }
            else
            {
              *(void *)v62 = v61;
              unint64_t v64 = v62 + 8;
            }
            v60[227] = v64;
            break;
          case ',':
            unint64_t v65 = *(void **)a1[2];
            uint64_t v66 = *(_WORD *)(a1[3] + 44) & 0x7FFF;
            v67 = (char *)v65[230];
            unint64_t v68 = v65[231];
            if ((unint64_t)v67 >= v68)
            {
              v236 = (char *)v65[229];
              uint64_t v237 = (v67 - v236) >> 3;
              if ((unint64_t)(v237 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v238 = v68 - (void)v236;
              unint64_t v239 = (uint64_t)(v68 - (void)v236) >> 2;
              if (v239 <= v237 + 1) {
                unint64_t v239 = v237 + 1;
              }
              if (v238 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v240 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v240 = v239;
              }
              if (v240)
              {
                v241 = (char *)sub_5714((uint64_t)(v65 + 231), v240);
                v67 = (char *)v65[230];
                v236 = (char *)v65[229];
              }
              else
              {
                v241 = 0;
              }
              v384 = &v241[8 * v237];
              *(void *)v384 = v66;
              uint64_t v69 = v384 + 8;
              while (v67 != v236)
              {
                uint64_t v385 = *((void *)v67 - 1);
                v67 -= 8;
                *((void *)v384 - 1) = v385;
                v384 -= 8;
              }
              v65[229] = v384;
              v65[230] = v69;
              v65[231] = &v241[8 * v240];
              if (v236) {
                operator delete(v236);
              }
            }
            else
            {
              *(void *)v67 = v66;
              uint64_t v69 = v67 + 8;
            }
            v65[230] = v69;
            break;
          case '-':
            unint64_t v70 = *(void **)a1[2];
            uint64_t v71 = *(_WORD *)(a1[3] + 54) & 0x7FFF;
            unint64_t v72 = (char *)v70[233];
            unint64_t v73 = v70[234];
            if ((unint64_t)v72 >= v73)
            {
              v242 = (char *)v70[232];
              uint64_t v243 = (v72 - v242) >> 3;
              if ((unint64_t)(v243 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v244 = v73 - (void)v242;
              unint64_t v245 = (uint64_t)(v73 - (void)v242) >> 2;
              if (v245 <= v243 + 1) {
                unint64_t v245 = v243 + 1;
              }
              if (v244 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v246 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v246 = v245;
              }
              if (v246)
              {
                v247 = (char *)sub_5714((uint64_t)(v70 + 234), v246);
                unint64_t v72 = (char *)v70[233];
                v242 = (char *)v70[232];
              }
              else
              {
                v247 = 0;
              }
              v386 = &v247[8 * v243];
              *(void *)v386 = v71;
              v74 = v386 + 8;
              while (v72 != v242)
              {
                uint64_t v387 = *((void *)v72 - 1);
                v72 -= 8;
                *((void *)v386 - 1) = v387;
                v386 -= 8;
              }
              v70[232] = v386;
              v70[233] = v74;
              v70[234] = &v247[8 * v246];
              if (v242) {
                operator delete(v242);
              }
            }
            else
            {
              *(void *)unint64_t v72 = v71;
              v74 = v72 + 8;
            }
            v70[233] = v74;
            break;
          case '.':
            uint64_t v75 = *(void **)a1[2];
            uint64_t v76 = *(_WORD *)(a1[3] + 46) & 0x7FFF;
            unint64_t v77 = (char *)v75[236];
            unint64_t v78 = v75[237];
            if ((unint64_t)v77 >= v78)
            {
              v248 = (char *)v75[235];
              uint64_t v249 = (v77 - v248) >> 3;
              if ((unint64_t)(v249 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v250 = v78 - (void)v248;
              unint64_t v251 = (uint64_t)(v78 - (void)v248) >> 2;
              if (v251 <= v249 + 1) {
                unint64_t v251 = v249 + 1;
              }
              if (v250 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v252 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v252 = v251;
              }
              if (v252)
              {
                v253 = (char *)sub_5714((uint64_t)(v75 + 237), v252);
                unint64_t v77 = (char *)v75[236];
                v248 = (char *)v75[235];
              }
              else
              {
                v253 = 0;
              }
              v388 = &v253[8 * v249];
              *(void *)v388 = v76;
              v79 = v388 + 8;
              while (v77 != v248)
              {
                uint64_t v389 = *((void *)v77 - 1);
                v77 -= 8;
                *((void *)v388 - 1) = v389;
                v388 -= 8;
              }
              v75[235] = v388;
              v75[236] = v79;
              v75[237] = &v253[8 * v252];
              if (v248) {
                operator delete(v248);
              }
            }
            else
            {
              *(void *)unint64_t v77 = v76;
              v79 = v77 + 8;
            }
            v75[236] = v79;
            break;
          case '/':
            v80 = *(void **)a1[2];
            uint64_t v81 = *(_WORD *)(a1[3] + 56) & 0x7FFF;
            unint64_t v82 = (char *)v80[239];
            unint64_t v83 = v80[240];
            if ((unint64_t)v82 >= v83)
            {
              v254 = (char *)v80[238];
              uint64_t v255 = (v82 - v254) >> 3;
              if ((unint64_t)(v255 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v256 = v83 - (void)v254;
              unint64_t v257 = (uint64_t)(v83 - (void)v254) >> 2;
              if (v257 <= v255 + 1) {
                unint64_t v257 = v255 + 1;
              }
              if (v256 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v258 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v258 = v257;
              }
              if (v258)
              {
                v259 = (char *)sub_5714((uint64_t)(v80 + 240), v258);
                unint64_t v82 = (char *)v80[239];
                v254 = (char *)v80[238];
              }
              else
              {
                v259 = 0;
              }
              v390 = &v259[8 * v255];
              *(void *)v390 = v81;
              unint64_t v84 = v390 + 8;
              while (v82 != v254)
              {
                uint64_t v391 = *((void *)v82 - 1);
                v82 -= 8;
                *((void *)v390 - 1) = v391;
                v390 -= 8;
              }
              v80[238] = v390;
              v80[239] = v84;
              v80[240] = &v259[8 * v258];
              if (v254) {
                operator delete(v254);
              }
            }
            else
            {
              *(void *)unint64_t v82 = v81;
              unint64_t v84 = v82 + 8;
            }
            v80[239] = v84;
            break;
          case '0':
            v85 = *(void **)a1[2];
            uint64_t v86 = *(_WORD *)(a1[3] + 48) & 0x7FFF;
            uint64_t v87 = (char *)v85[242];
            unint64_t v88 = v85[243];
            if ((unint64_t)v87 >= v88)
            {
              v260 = (char *)v85[241];
              uint64_t v261 = (v87 - v260) >> 3;
              if ((unint64_t)(v261 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v262 = v88 - (void)v260;
              unint64_t v263 = (uint64_t)(v88 - (void)v260) >> 2;
              if (v263 <= v261 + 1) {
                unint64_t v263 = v261 + 1;
              }
              if (v262 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v264 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v264 = v263;
              }
              if (v264)
              {
                v265 = (char *)sub_5714((uint64_t)(v85 + 243), v264);
                uint64_t v87 = (char *)v85[242];
                v260 = (char *)v85[241];
              }
              else
              {
                v265 = 0;
              }
              v392 = &v265[8 * v261];
              *(void *)v392 = v86;
              unint64_t v89 = v392 + 8;
              while (v87 != v260)
              {
                uint64_t v393 = *((void *)v87 - 1);
                v87 -= 8;
                *((void *)v392 - 1) = v393;
                v392 -= 8;
              }
              v85[241] = v392;
              v85[242] = v89;
              v85[243] = &v265[8 * v264];
              if (v260) {
                operator delete(v260);
              }
            }
            else
            {
              *(void *)uint64_t v87 = v86;
              unint64_t v89 = v87 + 8;
            }
            v85[242] = v89;
            break;
          case '1':
            unint64_t v90 = *(void **)a1[2];
            uint64_t v91 = *(_WORD *)(a1[3] + 66) & 0x7FFF;
            v92 = (char *)v90[245];
            unint64_t v93 = v90[246];
            if ((unint64_t)v92 >= v93)
            {
              v266 = (char *)v90[244];
              uint64_t v267 = (v92 - v266) >> 3;
              if ((unint64_t)(v267 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v268 = v93 - (void)v266;
              unint64_t v269 = (uint64_t)(v93 - (void)v266) >> 2;
              if (v269 <= v267 + 1) {
                unint64_t v269 = v267 + 1;
              }
              if (v268 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v270 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v270 = v269;
              }
              if (v270)
              {
                v271 = (char *)sub_5714((uint64_t)(v90 + 246), v270);
                v92 = (char *)v90[245];
                v266 = (char *)v90[244];
              }
              else
              {
                v271 = 0;
              }
              v394 = &v271[8 * v267];
              *(void *)v394 = v91;
              unint64_t v94 = v394 + 8;
              while (v92 != v266)
              {
                uint64_t v395 = *((void *)v92 - 1);
                v92 -= 8;
                *((void *)v394 - 1) = v395;
                v394 -= 8;
              }
              v90[244] = v394;
              v90[245] = v94;
              v90[246] = &v271[8 * v270];
              if (v266) {
                operator delete(v266);
              }
            }
            else
            {
              *(void *)v92 = v91;
              unint64_t v94 = v92 + 8;
            }
            v90[245] = v94;
            break;
          case '2':
            unint64_t v95 = *(void **)a1[2];
            uint64_t v96 = *(_WORD *)(a1[3] + 58) & 0x7FFF;
            v97 = (char *)v95[248];
            unint64_t v98 = v95[249];
            if ((unint64_t)v97 >= v98)
            {
              v272 = (char *)v95[247];
              uint64_t v273 = (v97 - v272) >> 3;
              if ((unint64_t)(v273 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v274 = v98 - (void)v272;
              unint64_t v275 = (uint64_t)(v98 - (void)v272) >> 2;
              if (v275 <= v273 + 1) {
                unint64_t v275 = v273 + 1;
              }
              if (v274 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v276 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v276 = v275;
              }
              if (v276)
              {
                v277 = (char *)sub_5714((uint64_t)(v95 + 249), v276);
                v97 = (char *)v95[248];
                v272 = (char *)v95[247];
              }
              else
              {
                v277 = 0;
              }
              v396 = &v277[8 * v273];
              *(void *)v396 = v96;
              uint64_t v99 = v396 + 8;
              while (v97 != v272)
              {
                uint64_t v397 = *((void *)v97 - 1);
                v97 -= 8;
                *((void *)v396 - 1) = v397;
                v396 -= 8;
              }
              v95[247] = v396;
              v95[248] = v99;
              v95[249] = &v277[8 * v276];
              if (v272) {
                operator delete(v272);
              }
            }
            else
            {
              *(void *)v97 = v96;
              uint64_t v99 = v97 + 8;
            }
            v95[248] = v99;
            break;
          case '3':
            unint64_t v100 = *(void **)a1[2];
            uint64_t v101 = *(_WORD *)(a1[3] + 68) & 0x7FFF;
            unint64_t v102 = (char *)v100[251];
            unint64_t v103 = v100[252];
            if ((unint64_t)v102 >= v103)
            {
              v278 = (char *)v100[250];
              uint64_t v279 = (v102 - v278) >> 3;
              if ((unint64_t)(v279 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v280 = v103 - (void)v278;
              unint64_t v281 = (uint64_t)(v103 - (void)v278) >> 2;
              if (v281 <= v279 + 1) {
                unint64_t v281 = v279 + 1;
              }
              if (v280 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v282 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v282 = v281;
              }
              if (v282)
              {
                v283 = (char *)sub_5714((uint64_t)(v100 + 252), v282);
                unint64_t v102 = (char *)v100[251];
                v278 = (char *)v100[250];
              }
              else
              {
                v283 = 0;
              }
              v398 = &v283[8 * v279];
              *(void *)v398 = v101;
              v104 = v398 + 8;
              while (v102 != v278)
              {
                uint64_t v399 = *((void *)v102 - 1);
                v102 -= 8;
                *((void *)v398 - 1) = v399;
                v398 -= 8;
              }
              v100[250] = v398;
              v100[251] = v104;
              v100[252] = &v283[8 * v282];
              if (v278) {
                operator delete(v278);
              }
            }
            else
            {
              *(void *)unint64_t v102 = v101;
              v104 = v102 + 8;
            }
            v100[251] = v104;
            break;
          case '4':
            uint64_t v105 = *(void **)a1[2];
            uint64_t v106 = *(_WORD *)(a1[3] + 60) & 0x7FFF;
            unint64_t v107 = (char *)v105[254];
            unint64_t v108 = v105[255];
            if ((unint64_t)v107 >= v108)
            {
              v284 = (char *)v105[253];
              uint64_t v285 = (v107 - v284) >> 3;
              if ((unint64_t)(v285 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v286 = v108 - (void)v284;
              unint64_t v287 = (uint64_t)(v108 - (void)v284) >> 2;
              if (v287 <= v285 + 1) {
                unint64_t v287 = v285 + 1;
              }
              if (v286 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v288 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v288 = v287;
              }
              if (v288)
              {
                v289 = (char *)sub_5714((uint64_t)(v105 + 255), v288);
                unint64_t v107 = (char *)v105[254];
                v284 = (char *)v105[253];
              }
              else
              {
                v289 = 0;
              }
              v400 = &v289[8 * v285];
              *(void *)v400 = v106;
              v109 = v400 + 8;
              while (v107 != v284)
              {
                uint64_t v401 = *((void *)v107 - 1);
                v107 -= 8;
                *((void *)v400 - 1) = v401;
                v400 -= 8;
              }
              v105[253] = v400;
              v105[254] = v109;
              v105[255] = &v289[8 * v288];
              if (v284) {
                operator delete(v284);
              }
            }
            else
            {
              *(void *)unint64_t v107 = v106;
              v109 = v107 + 8;
            }
            v105[254] = v109;
            break;
          case '5':
            v110 = *(void **)a1[2];
            uint64_t v111 = *(_WORD *)(a1[3] + 70) & 0x7FFF;
            unint64_t v112 = (char *)v110[257];
            unint64_t v113 = v110[258];
            if ((unint64_t)v112 >= v113)
            {
              v290 = (char *)v110[256];
              uint64_t v291 = (v112 - v290) >> 3;
              if ((unint64_t)(v291 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v292 = v113 - (void)v290;
              unint64_t v293 = (uint64_t)(v113 - (void)v290) >> 2;
              if (v293 <= v291 + 1) {
                unint64_t v293 = v291 + 1;
              }
              if (v292 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v294 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v294 = v293;
              }
              if (v294)
              {
                v295 = (char *)sub_5714((uint64_t)(v110 + 258), v294);
                unint64_t v112 = (char *)v110[257];
                v290 = (char *)v110[256];
              }
              else
              {
                v295 = 0;
              }
              v402 = &v295[8 * v291];
              *(void *)v402 = v111;
              unint64_t v114 = v402 + 8;
              while (v112 != v290)
              {
                uint64_t v403 = *((void *)v112 - 1);
                v112 -= 8;
                *((void *)v402 - 1) = v403;
                v402 -= 8;
              }
              v110[256] = v402;
              v110[257] = v114;
              v110[258] = &v295[8 * v294];
              if (v290) {
                operator delete(v290);
              }
            }
            else
            {
              *(void *)unint64_t v112 = v111;
              unint64_t v114 = v112 + 8;
            }
            v110[257] = v114;
            break;
          case '6':
            v115 = *(void **)a1[2];
            uint64_t v116 = *(_WORD *)(a1[3] + 62) & 0x7FFF;
            uint64_t v117 = (char *)v115[260];
            unint64_t v118 = v115[261];
            if ((unint64_t)v117 >= v118)
            {
              v296 = (char *)v115[259];
              uint64_t v297 = (v117 - v296) >> 3;
              if ((unint64_t)(v297 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v298 = v118 - (void)v296;
              unint64_t v299 = (uint64_t)(v118 - (void)v296) >> 2;
              if (v299 <= v297 + 1) {
                unint64_t v299 = v297 + 1;
              }
              if (v298 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v300 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v300 = v299;
              }
              if (v300)
              {
                v301 = (char *)sub_5714((uint64_t)(v115 + 261), v300);
                uint64_t v117 = (char *)v115[260];
                v296 = (char *)v115[259];
              }
              else
              {
                v301 = 0;
              }
              v404 = &v301[8 * v297];
              *(void *)v404 = v116;
              unint64_t v119 = v404 + 8;
              while (v117 != v296)
              {
                uint64_t v405 = *((void *)v117 - 1);
                v117 -= 8;
                *((void *)v404 - 1) = v405;
                v404 -= 8;
              }
              v115[259] = v404;
              v115[260] = v119;
              v115[261] = &v301[8 * v300];
              if (v296) {
                operator delete(v296);
              }
            }
            else
            {
              *(void *)uint64_t v117 = v116;
              unint64_t v119 = v117 + 8;
            }
            v115[260] = v119;
            break;
          case '7':
            unint64_t v120 = *(void **)a1[2];
            uint64_t v121 = *(_WORD *)(a1[3] + 72) & 0x7FFF;
            v122 = (char *)v120[263];
            unint64_t v123 = v120[264];
            if ((unint64_t)v122 >= v123)
            {
              v302 = (char *)v120[262];
              uint64_t v303 = (v122 - v302) >> 3;
              if ((unint64_t)(v303 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v304 = v123 - (void)v302;
              unint64_t v305 = (uint64_t)(v123 - (void)v302) >> 2;
              if (v305 <= v303 + 1) {
                unint64_t v305 = v303 + 1;
              }
              if (v304 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v306 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v306 = v305;
              }
              if (v306)
              {
                v307 = (char *)sub_5714((uint64_t)(v120 + 264), v306);
                v122 = (char *)v120[263];
                v302 = (char *)v120[262];
              }
              else
              {
                v307 = 0;
              }
              v406 = &v307[8 * v303];
              *(void *)v406 = v121;
              v124 = v406 + 8;
              while (v122 != v302)
              {
                uint64_t v407 = *((void *)v122 - 1);
                v122 -= 8;
                *((void *)v406 - 1) = v407;
                v406 -= 8;
              }
              v120[262] = v406;
              v120[263] = v124;
              v120[264] = &v307[8 * v306];
              if (v302) {
                operator delete(v302);
              }
            }
            else
            {
              *(void *)v122 = v121;
              v124 = v122 + 8;
            }
            v120[263] = v124;
            break;
          case '8':
            uint64_t v125 = *(void **)a1[2];
            uint64_t v126 = *(_WORD *)(a1[3] + 64) & 0x7FFF;
            uint64_t v127 = (char *)v125[266];
            unint64_t v128 = v125[267];
            if ((unint64_t)v127 >= v128)
            {
              v308 = (char *)v125[265];
              uint64_t v309 = (v127 - v308) >> 3;
              if ((unint64_t)(v309 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v310 = v128 - (void)v308;
              unint64_t v311 = (uint64_t)(v128 - (void)v308) >> 2;
              if (v311 <= v309 + 1) {
                unint64_t v311 = v309 + 1;
              }
              if (v310 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v312 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v312 = v311;
              }
              if (v312)
              {
                v313 = (char *)sub_5714((uint64_t)(v125 + 267), v312);
                uint64_t v127 = (char *)v125[266];
                v308 = (char *)v125[265];
              }
              else
              {
                v313 = 0;
              }
              v408 = &v313[8 * v309];
              *(void *)v408 = v126;
              uint64_t v129 = v408 + 8;
              while (v127 != v308)
              {
                uint64_t v409 = *((void *)v127 - 1);
                v127 -= 8;
                *((void *)v408 - 1) = v409;
                v408 -= 8;
              }
              v125[265] = v408;
              v125[266] = v129;
              v125[267] = &v313[8 * v312];
              if (v308) {
                operator delete(v308);
              }
            }
            else
            {
              *(void *)uint64_t v127 = v126;
              uint64_t v129 = v127 + 8;
            }
            v125[266] = v129;
            break;
          case '9':
            v130 = *(void **)a1[2];
            uint64_t v131 = *(_WORD *)(a1[3] + 82) & 0x7FFF;
            v132 = (char *)v130[269];
            unint64_t v133 = v130[270];
            if ((unint64_t)v132 >= v133)
            {
              v314 = (char *)v130[268];
              uint64_t v315 = (v132 - v314) >> 3;
              if ((unint64_t)(v315 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v316 = v133 - (void)v314;
              unint64_t v317 = (uint64_t)(v133 - (void)v314) >> 2;
              if (v317 <= v315 + 1) {
                unint64_t v317 = v315 + 1;
              }
              if (v316 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v318 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v318 = v317;
              }
              if (v318)
              {
                v319 = (char *)sub_5714((uint64_t)(v130 + 270), v318);
                v132 = (char *)v130[269];
                v314 = (char *)v130[268];
              }
              else
              {
                v319 = 0;
              }
              v410 = &v319[8 * v315];
              *(void *)v410 = v131;
              v134 = v410 + 8;
              while (v132 != v314)
              {
                uint64_t v411 = *((void *)v132 - 1);
                v132 -= 8;
                *((void *)v410 - 1) = v411;
                v410 -= 8;
              }
              v130[268] = v410;
              v130[269] = v134;
              v130[270] = &v319[8 * v318];
              if (v314) {
                operator delete(v314);
              }
            }
            else
            {
              *(void *)v132 = v131;
              v134 = v132 + 8;
            }
            v130[269] = v134;
            break;
          case ':':
            uint64_t v135 = *(void **)a1[2];
            uint64_t v136 = *(_WORD *)(a1[3] + 74) & 0x7FFF;
            uint64_t v137 = (char *)v135[272];
            unint64_t v138 = v135[273];
            if ((unint64_t)v137 >= v138)
            {
              v320 = (char *)v135[271];
              uint64_t v321 = (v137 - v320) >> 3;
              if ((unint64_t)(v321 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v322 = v138 - (void)v320;
              unint64_t v323 = (uint64_t)(v138 - (void)v320) >> 2;
              if (v323 <= v321 + 1) {
                unint64_t v323 = v321 + 1;
              }
              if (v322 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v324 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v324 = v323;
              }
              if (v324)
              {
                v325 = (char *)sub_5714((uint64_t)(v135 + 273), v324);
                uint64_t v137 = (char *)v135[272];
                v320 = (char *)v135[271];
              }
              else
              {
                v325 = 0;
              }
              v412 = &v325[8 * v321];
              *(void *)v412 = v136;
              uint64_t v139 = v412 + 8;
              while (v137 != v320)
              {
                uint64_t v413 = *((void *)v137 - 1);
                v137 -= 8;
                *((void *)v412 - 1) = v413;
                v412 -= 8;
              }
              v135[271] = v412;
              v135[272] = v139;
              v135[273] = &v325[8 * v324];
              if (v320) {
                operator delete(v320);
              }
            }
            else
            {
              *(void *)uint64_t v137 = v136;
              uint64_t v139 = v137 + 8;
            }
            v135[272] = v139;
            break;
          case ';':
            v140 = *(void **)a1[2];
            uint64_t v141 = *(_WORD *)(a1[3] + 84) & 0x7FFF;
            v142 = (char *)v140[275];
            unint64_t v143 = v140[276];
            if ((unint64_t)v142 >= v143)
            {
              v326 = (char *)v140[274];
              uint64_t v327 = (v142 - v326) >> 3;
              if ((unint64_t)(v327 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v328 = v143 - (void)v326;
              unint64_t v329 = (uint64_t)(v143 - (void)v326) >> 2;
              if (v329 <= v327 + 1) {
                unint64_t v329 = v327 + 1;
              }
              if (v328 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v330 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v330 = v329;
              }
              if (v330)
              {
                v331 = (char *)sub_5714((uint64_t)(v140 + 276), v330);
                v142 = (char *)v140[275];
                v326 = (char *)v140[274];
              }
              else
              {
                v331 = 0;
              }
              v414 = &v331[8 * v327];
              *(void *)v414 = v141;
              uint64_t v144 = v414 + 8;
              while (v142 != v326)
              {
                uint64_t v415 = *((void *)v142 - 1);
                v142 -= 8;
                *((void *)v414 - 1) = v415;
                v414 -= 8;
              }
              v140[274] = v414;
              v140[275] = v144;
              v140[276] = &v331[8 * v330];
              if (v326) {
                operator delete(v326);
              }
            }
            else
            {
              *(void *)v142 = v141;
              uint64_t v144 = v142 + 8;
            }
            v140[275] = v144;
            break;
          case '<':
            unint64_t v145 = *(void **)a1[2];
            uint64_t v146 = *(_WORD *)(a1[3] + 76) & 0x7FFF;
            uint64_t v147 = (char *)v145[278];
            unint64_t v148 = v145[279];
            if ((unint64_t)v147 >= v148)
            {
              v332 = (char *)v145[277];
              uint64_t v333 = (v147 - v332) >> 3;
              if ((unint64_t)(v333 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v334 = v148 - (void)v332;
              unint64_t v335 = (uint64_t)(v148 - (void)v332) >> 2;
              if (v335 <= v333 + 1) {
                unint64_t v335 = v333 + 1;
              }
              if (v334 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v336 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v336 = v335;
              }
              if (v336)
              {
                v337 = (char *)sub_5714((uint64_t)(v145 + 279), v336);
                uint64_t v147 = (char *)v145[278];
                v332 = (char *)v145[277];
              }
              else
              {
                v337 = 0;
              }
              v416 = &v337[8 * v333];
              *(void *)v416 = v146;
              v149 = v416 + 8;
              while (v147 != v332)
              {
                uint64_t v417 = *((void *)v147 - 1);
                v147 -= 8;
                *((void *)v416 - 1) = v417;
                v416 -= 8;
              }
              v145[277] = v416;
              v145[278] = v149;
              v145[279] = &v337[8 * v336];
              if (v332) {
                operator delete(v332);
              }
            }
            else
            {
              *(void *)uint64_t v147 = v146;
              v149 = v147 + 8;
            }
            v145[278] = v149;
            break;
          case '=':
            v150 = *(void **)a1[2];
            uint64_t v151 = *(_WORD *)(a1[3] + 86) & 0x7FFF;
            v152 = (char *)v150[281];
            unint64_t v153 = v150[282];
            if ((unint64_t)v152 >= v153)
            {
              v338 = (char *)v150[280];
              uint64_t v339 = (v152 - v338) >> 3;
              if ((unint64_t)(v339 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v340 = v153 - (void)v338;
              unint64_t v341 = (uint64_t)(v153 - (void)v338) >> 2;
              if (v341 <= v339 + 1) {
                unint64_t v341 = v339 + 1;
              }
              if (v340 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v342 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v342 = v341;
              }
              if (v342)
              {
                v343 = (char *)sub_5714((uint64_t)(v150 + 282), v342);
                v152 = (char *)v150[281];
                v338 = (char *)v150[280];
              }
              else
              {
                v343 = 0;
              }
              v418 = &v343[8 * v339];
              *(void *)v418 = v151;
              v154 = v418 + 8;
              while (v152 != v338)
              {
                uint64_t v419 = *((void *)v152 - 1);
                v152 -= 8;
                *((void *)v418 - 1) = v419;
                v418 -= 8;
              }
              v150[280] = v418;
              v150[281] = v154;
              v150[282] = &v343[8 * v342];
              if (v338) {
                operator delete(v338);
              }
            }
            else
            {
              *(void *)v152 = v151;
              v154 = v152 + 8;
            }
            v150[281] = v154;
            break;
          case '>':
            v155 = *(void **)a1[2];
            uint64_t v156 = *(_WORD *)(a1[3] + 78) & 0x7FFF;
            v157 = (char *)v155[284];
            unint64_t v158 = v155[285];
            if ((unint64_t)v157 >= v158)
            {
              v344 = (char *)v155[283];
              uint64_t v345 = (v157 - v344) >> 3;
              if ((unint64_t)(v345 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v346 = v158 - (void)v344;
              unint64_t v347 = (uint64_t)(v158 - (void)v344) >> 2;
              if (v347 <= v345 + 1) {
                unint64_t v347 = v345 + 1;
              }
              if (v346 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v348 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v348 = v347;
              }
              if (v348)
              {
                v349 = (char *)sub_5714((uint64_t)(v155 + 285), v348);
                v157 = (char *)v155[284];
                v344 = (char *)v155[283];
              }
              else
              {
                v349 = 0;
              }
              v420 = &v349[8 * v345];
              *(void *)v420 = v156;
              v159 = v420 + 8;
              while (v157 != v344)
              {
                uint64_t v421 = *((void *)v157 - 1);
                v157 -= 8;
                *((void *)v420 - 1) = v421;
                v420 -= 8;
              }
              v155[283] = v420;
              v155[284] = v159;
              v155[285] = &v349[8 * v348];
              if (v344) {
                operator delete(v344);
              }
            }
            else
            {
              *(void *)v157 = v156;
              v159 = v157 + 8;
            }
            v155[284] = v159;
            break;
          case '?':
            v160 = *(void **)a1[2];
            uint64_t v161 = *(_WORD *)(a1[3] + 88) & 0x7FFF;
            v162 = (char *)v160[287];
            unint64_t v163 = v160[288];
            if ((unint64_t)v162 >= v163)
            {
              v350 = (char *)v160[286];
              uint64_t v351 = (v162 - v350) >> 3;
              if ((unint64_t)(v351 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v352 = v163 - (void)v350;
              unint64_t v353 = (uint64_t)(v163 - (void)v350) >> 2;
              if (v353 <= v351 + 1) {
                unint64_t v353 = v351 + 1;
              }
              if (v352 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v354 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v354 = v353;
              }
              if (v354)
              {
                v355 = (char *)sub_5714((uint64_t)(v160 + 288), v354);
                v162 = (char *)v160[287];
                v350 = (char *)v160[286];
              }
              else
              {
                v355 = 0;
              }
              v422 = &v355[8 * v351];
              *(void *)v422 = v161;
              v164 = v422 + 8;
              while (v162 != v350)
              {
                uint64_t v423 = *((void *)v162 - 1);
                v162 -= 8;
                *((void *)v422 - 1) = v423;
                v422 -= 8;
              }
              v160[286] = v422;
              v160[287] = v164;
              v160[288] = &v355[8 * v354];
              if (v350) {
                operator delete(v350);
              }
            }
            else
            {
              *(void *)v162 = v161;
              v164 = v162 + 8;
            }
            v160[287] = v164;
            break;
          case '@':
            v165 = *(void **)a1[2];
            uint64_t v166 = *(_WORD *)(a1[3] + 80) & 0x7FFF;
            v167 = (char *)v165[290];
            unint64_t v168 = v165[291];
            if ((unint64_t)v167 >= v168)
            {
              v356 = (char *)v165[289];
              uint64_t v357 = (v167 - v356) >> 3;
              if ((unint64_t)(v357 + 1) >> 61) {
LABEL_594:
              }
                sub_566C();
              unint64_t v358 = v168 - (void)v356;
              unint64_t v359 = (uint64_t)(v168 - (void)v356) >> 2;
              if (v359 <= v357 + 1) {
                unint64_t v359 = v357 + 1;
              }
              if (v358 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v360 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v360 = v359;
              }
              if (v360)
              {
                v361 = (char *)sub_5714((uint64_t)(v165 + 291), v360);
                v167 = (char *)v165[290];
                v356 = (char *)v165[289];
              }
              else
              {
                v361 = 0;
              }
              v424 = &v361[8 * v357];
              *(void *)v424 = v166;
              v169 = v424 + 8;
              while (v167 != v356)
              {
                uint64_t v425 = *((void *)v167 - 1);
                v167 -= 8;
                *((void *)v424 - 1) = v425;
                v424 -= 8;
              }
              v165[289] = v424;
              v165[290] = v169;
              v165[291] = &v361[8 * v360];
              if (v356) {
                operator delete(v356);
              }
            }
            else
            {
              *(void *)v167 = v166;
              v169 = v167 + 8;
            }
            v165[290] = v169;
            break;
          default:
            break;
        }
        ++v7;
      }
      while (v7 != v9);
    }
  }
  *a2 = 1;
}

void sub_1A9CA0(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  if (*a2 == 1)
  {
    unint64_t v190 = (int **)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v189 = *v190;
    uint64_t v191 = (char *)v190[1] - (char *)*v190;
    if (v191)
    {
      unint64_t v192 = v191 >> 2;
      if (v192 <= 1) {
        unint64_t v192 = 1;
      }
      do
      {
        int v193 = *v189++;
        switch(v193)
        {
          case 15:
            uint64_t v194 = *(_WORD *)(a1[3] + 48) & 0x7FFF;
            uint64_t v195 = (void *)(*(void *)a1[2] + 1144);
            goto LABEL_248;
          case 16:
            uint64_t v194 = *(_WORD *)(a1[3] + 36) & 0x7FFF;
            uint64_t v195 = (void *)(*(void *)a1[2] + 1168);
            goto LABEL_248;
          case 17:
            uint64_t v194 = *(unsigned __int16 *)(a1[3] + 44);
            uint64_t v195 = (void *)(*(void *)a1[2] + 1192);
            goto LABEL_248;
          case 18:
            uint64_t v194 = *(unsigned __int16 *)(a1[3] + 32);
            uint64_t v195 = (void *)(*(void *)a1[2] + 1216);
            goto LABEL_248;
          case 19:
            uint64_t v194 = *(unsigned __int16 *)(a1[3] + 38);
            uint64_t v195 = (void *)(*(void *)a1[2] + 1240);
            goto LABEL_248;
          case 20:
            uint64_t v194 = *(unsigned __int16 *)(a1[3] + 26);
            uint64_t v195 = (void *)(*(void *)a1[2] + 1264);
            goto LABEL_248;
          case 21:
            uint64_t v194 = *(unsigned __int16 *)(a1[3] + 40);
            uint64_t v195 = (void *)(*(void *)a1[2] + 1288);
            goto LABEL_248;
          case 22:
            uint64_t v194 = *(unsigned __int16 *)(a1[3] + 28);
            uint64_t v195 = (void *)(*(void *)a1[2] + 1312);
            goto LABEL_248;
          case 23:
            uint64_t v194 = *(unsigned __int16 *)(a1[3] + 46);
            uint64_t v195 = (void *)(*(void *)a1[2] + 1336);
            goto LABEL_248;
          case 24:
            uint64_t v194 = *(unsigned __int16 *)(a1[3] + 34);
            uint64_t v195 = (void *)(*(void *)a1[2] + 1360);
            goto LABEL_248;
          case 25:
            uint64_t v194 = *(unsigned __int16 *)(a1[3] + 42);
            uint64_t v195 = (void *)(*(void *)a1[2] + 1384);
            goto LABEL_248;
          case 26:
            uint64_t v194 = *(unsigned __int16 *)(a1[3] + 30);
            uint64_t v195 = (void *)(*(void *)a1[2] + 1408);
            goto LABEL_248;
          case 27:
            uint64_t v194 = *(_WORD *)(a1[3] + 50) & 0x7FFF;
            uint64_t v195 = (void *)(*(void *)a1[2] + 1432);
LABEL_248:
            *(void *)(*v195 - 8) += v194;
            break;
          default:
            break;
        }
        --v192;
      }
      while (v192);
    }
  }
  else
  {
    if (*a2) {
      return;
    }
    v5 = (void *)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v6 = v5[1] - *v5;
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = v6 >> 2;
      if (v8 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v8;
      }
      do
      {
        switch(*(_DWORD *)(*v5 + 4 * v7))
        {
          case 0xF:
            v10 = *(void **)a1[2];
            uint64_t v11 = *(_WORD *)(a1[3] + 48) & 0x7FFF;
            v12 = (char *)v10[143];
            unint64_t v13 = v10[144];
            if ((unint64_t)v12 >= v13)
            {
              v85 = (char *)v10[142];
              uint64_t v86 = (v12 - v85) >> 3;
              if ((unint64_t)(v86 + 1) >> 61) {
                goto LABEL_252;
              }
              unint64_t v87 = v13 - (void)v85;
              unint64_t v88 = (uint64_t)(v13 - (void)v85) >> 2;
              if (v88 <= v86 + 1) {
                unint64_t v88 = v86 + 1;
              }
              if (v87 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v89 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v89 = v88;
              }
              if (v89)
              {
                unint64_t v90 = (char *)sub_5714((uint64_t)(v10 + 144), v89);
                v12 = (char *)v10[143];
                v85 = (char *)v10[142];
              }
              else
              {
                unint64_t v90 = 0;
              }
              unint64_t v163 = &v90[8 * v86];
              *(void *)unint64_t v163 = v11;
              v14 = v163 + 8;
              while (v12 != v85)
              {
                uint64_t v164 = *((void *)v12 - 1);
                v12 -= 8;
                *((void *)v163 - 1) = v164;
                v163 -= 8;
              }
              v10[142] = v163;
              v10[143] = v14;
              v10[144] = &v90[8 * v89];
              if (v85) {
                operator delete(v85);
              }
            }
            else
            {
              *(void *)v12 = v11;
              v14 = v12 + 8;
            }
            v10[143] = v14;
            break;
          case 0x10:
            v15 = *(void **)a1[2];
            uint64_t v16 = *(_WORD *)(a1[3] + 36) & 0x7FFF;
            v17 = (char *)v15[146];
            unint64_t v18 = v15[147];
            if ((unint64_t)v17 >= v18)
            {
              uint64_t v91 = (char *)v15[145];
              uint64_t v92 = (v17 - v91) >> 3;
              if ((unint64_t)(v92 + 1) >> 61) {
                goto LABEL_252;
              }
              unint64_t v93 = v18 - (void)v91;
              unint64_t v94 = (uint64_t)(v18 - (void)v91) >> 2;
              if (v94 <= v92 + 1) {
                unint64_t v94 = v92 + 1;
              }
              if (v93 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v95 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v95 = v94;
              }
              if (v95)
              {
                uint64_t v96 = (char *)sub_5714((uint64_t)(v15 + 147), v95);
                v17 = (char *)v15[146];
                uint64_t v91 = (char *)v15[145];
              }
              else
              {
                uint64_t v96 = 0;
              }
              v165 = &v96[8 * v92];
              *(void *)v165 = v16;
              v19 = v165 + 8;
              while (v17 != v91)
              {
                uint64_t v166 = *((void *)v17 - 1);
                v17 -= 8;
                *((void *)v165 - 1) = v166;
                v165 -= 8;
              }
              v15[145] = v165;
              v15[146] = v19;
              v15[147] = &v96[8 * v95];
              if (v91) {
                operator delete(v91);
              }
            }
            else
            {
              *(void *)v17 = v16;
              v19 = v17 + 8;
            }
            v15[146] = v19;
            break;
          case 0x11:
            uint64_t v20 = a1[2];
            uint64_t v21 = *(void **)v20;
            uint64_t v22 = *(unsigned __int16 *)(a1[3] + 44);
            unint64_t v23 = *(char **)(*(void *)v20 + 1192);
            unint64_t v24 = *(void *)(*(void *)v20 + 1200);
            if ((unint64_t)v23 >= v24)
            {
              v97 = (char *)v21[148];
              uint64_t v98 = (v23 - v97) >> 3;
              if ((unint64_t)(v98 + 1) >> 61) {
                goto LABEL_252;
              }
              unint64_t v99 = v24 - (void)v97;
              unint64_t v100 = (uint64_t)(v24 - (void)v97) >> 2;
              if (v100 <= v98 + 1) {
                unint64_t v100 = v98 + 1;
              }
              if (v99 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v101 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v101 = v100;
              }
              if (v101)
              {
                unint64_t v102 = (char *)sub_5714((uint64_t)(v21 + 150), v101);
                unint64_t v23 = (char *)v21[149];
                v97 = (char *)v21[148];
              }
              else
              {
                unint64_t v102 = 0;
              }
              v167 = &v102[8 * v98];
              *(void *)v167 = v22;
              uint64_t v25 = v167 + 8;
              while (v23 != v97)
              {
                uint64_t v168 = *((void *)v23 - 1);
                v23 -= 8;
                *((void *)v167 - 1) = v168;
                v167 -= 8;
              }
              v21[148] = v167;
              v21[149] = v25;
              v21[150] = &v102[8 * v101];
              if (v97) {
                operator delete(v97);
              }
            }
            else
            {
              *(void *)unint64_t v23 = v22;
              uint64_t v25 = v23 + 8;
            }
            v21[149] = v25;
            break;
          case 0x12:
            uint64_t v26 = a1[2];
            uint64_t v27 = *(void **)v26;
            uint64_t v28 = *(unsigned __int16 *)(a1[3] + 32);
            unint64_t v29 = *(char **)(*(void *)v26 + 1216);
            unint64_t v30 = *(void *)(*(void *)v26 + 1224);
            if ((unint64_t)v29 >= v30)
            {
              unint64_t v103 = (char *)v27[151];
              uint64_t v104 = (v29 - v103) >> 3;
              if ((unint64_t)(v104 + 1) >> 61) {
                goto LABEL_252;
              }
              unint64_t v105 = v30 - (void)v103;
              unint64_t v106 = (uint64_t)(v30 - (void)v103) >> 2;
              if (v106 <= v104 + 1) {
                unint64_t v106 = v104 + 1;
              }
              if (v105 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v107 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v107 = v106;
              }
              if (v107)
              {
                unint64_t v108 = (char *)sub_5714((uint64_t)(v27 + 153), v107);
                unint64_t v29 = (char *)v27[152];
                unint64_t v103 = (char *)v27[151];
              }
              else
              {
                unint64_t v108 = 0;
              }
              v169 = &v108[8 * v104];
              *(void *)v169 = v28;
              uint64_t v31 = v169 + 8;
              while (v29 != v103)
              {
                uint64_t v170 = *((void *)v29 - 1);
                v29 -= 8;
                *((void *)v169 - 1) = v170;
                v169 -= 8;
              }
              v27[151] = v169;
              v27[152] = v31;
              v27[153] = &v108[8 * v107];
              if (v103) {
                operator delete(v103);
              }
            }
            else
            {
              *(void *)unint64_t v29 = v28;
              uint64_t v31 = v29 + 8;
            }
            v27[152] = v31;
            break;
          case 0x13:
            uint64_t v32 = a1[2];
            unint64_t v33 = *(void **)v32;
            uint64_t v34 = *(unsigned __int16 *)(a1[3] + 38);
            unint64_t v35 = *(char **)(*(void *)v32 + 1240);
            unint64_t v36 = *(void *)(*(void *)v32 + 1248);
            if ((unint64_t)v35 >= v36)
            {
              v109 = (char *)v33[154];
              uint64_t v110 = (v35 - v109) >> 3;
              if ((unint64_t)(v110 + 1) >> 61) {
                goto LABEL_252;
              }
              unint64_t v111 = v36 - (void)v109;
              unint64_t v112 = (uint64_t)(v36 - (void)v109) >> 2;
              if (v112 <= v110 + 1) {
                unint64_t v112 = v110 + 1;
              }
              if (v111 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v113 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v113 = v112;
              }
              if (v113)
              {
                unint64_t v114 = (char *)sub_5714((uint64_t)(v33 + 156), v113);
                unint64_t v35 = (char *)v33[155];
                v109 = (char *)v33[154];
              }
              else
              {
                unint64_t v114 = 0;
              }
              uint64_t v171 = &v114[8 * v110];
              *(void *)uint64_t v171 = v34;
              v37 = v171 + 8;
              while (v35 != v109)
              {
                uint64_t v172 = *((void *)v35 - 1);
                v35 -= 8;
                *((void *)v171 - 1) = v172;
                v171 -= 8;
              }
              v33[154] = v171;
              v33[155] = v37;
              v33[156] = &v114[8 * v113];
              if (v109) {
                operator delete(v109);
              }
            }
            else
            {
              *(void *)unint64_t v35 = v34;
              v37 = v35 + 8;
            }
            v33[155] = v37;
            break;
          case 0x14:
            uint64_t v38 = a1[2];
            v39 = *(void **)v38;
            uint64_t v40 = *(unsigned __int16 *)(a1[3] + 26);
            uint64_t v41 = *(char **)(*(void *)v38 + 1264);
            unint64_t v42 = *(void *)(*(void *)v38 + 1272);
            if ((unint64_t)v41 >= v42)
            {
              v115 = (char *)v39[157];
              uint64_t v116 = (v41 - v115) >> 3;
              if ((unint64_t)(v116 + 1) >> 61) {
                goto LABEL_252;
              }
              unint64_t v117 = v42 - (void)v115;
              unint64_t v118 = (uint64_t)(v42 - (void)v115) >> 2;
              if (v118 <= v116 + 1) {
                unint64_t v118 = v116 + 1;
              }
              if (v117 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v119 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v119 = v118;
              }
              if (v119)
              {
                unint64_t v120 = (char *)sub_5714((uint64_t)(v39 + 159), v119);
                uint64_t v41 = (char *)v39[158];
                v115 = (char *)v39[157];
              }
              else
              {
                unint64_t v120 = 0;
              }
              unint64_t v173 = &v120[8 * v116];
              *(void *)unint64_t v173 = v40;
              unint64_t v43 = v173 + 8;
              while (v41 != v115)
              {
                uint64_t v174 = *((void *)v41 - 1);
                v41 -= 8;
                *((void *)v173 - 1) = v174;
                v173 -= 8;
              }
              v39[157] = v173;
              v39[158] = v43;
              v39[159] = &v120[8 * v119];
              if (v115) {
                operator delete(v115);
              }
            }
            else
            {
              *(void *)uint64_t v41 = v40;
              unint64_t v43 = v41 + 8;
            }
            v39[158] = v43;
            break;
          case 0x15:
            uint64_t v44 = a1[2];
            unint64_t v45 = *(void **)v44;
            uint64_t v46 = *(unsigned __int16 *)(a1[3] + 40);
            v47 = *(char **)(*(void *)v44 + 1288);
            unint64_t v48 = *(void *)(*(void *)v44 + 1296);
            if ((unint64_t)v47 >= v48)
            {
              uint64_t v121 = (char *)v45[160];
              uint64_t v122 = (v47 - v121) >> 3;
              if ((unint64_t)(v122 + 1) >> 61) {
                goto LABEL_252;
              }
              unint64_t v123 = v48 - (void)v121;
              unint64_t v124 = (uint64_t)(v48 - (void)v121) >> 2;
              if (v124 <= v122 + 1) {
                unint64_t v124 = v122 + 1;
              }
              if (v123 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v125 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v125 = v124;
              }
              if (v125)
              {
                uint64_t v126 = (char *)sub_5714((uint64_t)(v45 + 162), v125);
                v47 = (char *)v45[161];
                uint64_t v121 = (char *)v45[160];
              }
              else
              {
                uint64_t v126 = 0;
              }
              v175 = &v126[8 * v122];
              *(void *)v175 = v46;
              v49 = v175 + 8;
              while (v47 != v121)
              {
                uint64_t v176 = *((void *)v47 - 1);
                v47 -= 8;
                *((void *)v175 - 1) = v176;
                v175 -= 8;
              }
              v45[160] = v175;
              v45[161] = v49;
              v45[162] = &v126[8 * v125];
              if (v121) {
                operator delete(v121);
              }
            }
            else
            {
              *(void *)v47 = v46;
              v49 = v47 + 8;
            }
            v45[161] = v49;
            break;
          case 0x16:
            uint64_t v50 = a1[2];
            uint64_t v51 = *(void **)v50;
            uint64_t v52 = *(unsigned __int16 *)(a1[3] + 28);
            unint64_t v53 = *(char **)(*(void *)v50 + 1312);
            unint64_t v54 = *(void *)(*(void *)v50 + 1320);
            if ((unint64_t)v53 >= v54)
            {
              uint64_t v127 = (char *)v51[163];
              uint64_t v128 = (v53 - v127) >> 3;
              if ((unint64_t)(v128 + 1) >> 61) {
                goto LABEL_252;
              }
              unint64_t v129 = v54 - (void)v127;
              unint64_t v130 = (uint64_t)(v54 - (void)v127) >> 2;
              if (v130 <= v128 + 1) {
                unint64_t v130 = v128 + 1;
              }
              if (v129 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v131 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v131 = v130;
              }
              if (v131)
              {
                v132 = (char *)sub_5714((uint64_t)(v51 + 165), v131);
                unint64_t v53 = (char *)v51[164];
                uint64_t v127 = (char *)v51[163];
              }
              else
              {
                v132 = 0;
              }
              uint64_t v177 = &v132[8 * v128];
              *(void *)uint64_t v177 = v52;
              unint64_t v55 = v177 + 8;
              while (v53 != v127)
              {
                uint64_t v178 = *((void *)v53 - 1);
                v53 -= 8;
                *((void *)v177 - 1) = v178;
                v177 -= 8;
              }
              v51[163] = v177;
              v51[164] = v55;
              v51[165] = &v132[8 * v131];
              if (v127) {
                operator delete(v127);
              }
            }
            else
            {
              *(void *)unint64_t v53 = v52;
              unint64_t v55 = v53 + 8;
            }
            v51[164] = v55;
            break;
          case 0x17:
            uint64_t v56 = a1[2];
            v57 = *(void **)v56;
            uint64_t v58 = *(unsigned __int16 *)(a1[3] + 46);
            v59 = *(char **)(*(void *)v56 + 1336);
            unint64_t v60 = *(void *)(*(void *)v56 + 1344);
            if ((unint64_t)v59 >= v60)
            {
              unint64_t v133 = (char *)v57[166];
              uint64_t v134 = (v59 - v133) >> 3;
              if ((unint64_t)(v134 + 1) >> 61) {
                goto LABEL_252;
              }
              unint64_t v135 = v60 - (void)v133;
              unint64_t v136 = (uint64_t)(v60 - (void)v133) >> 2;
              if (v136 <= v134 + 1) {
                unint64_t v136 = v134 + 1;
              }
              if (v135 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v137 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v137 = v136;
              }
              if (v137)
              {
                unint64_t v138 = (char *)sub_5714((uint64_t)(v57 + 168), v137);
                v59 = (char *)v57[167];
                unint64_t v133 = (char *)v57[166];
              }
              else
              {
                unint64_t v138 = 0;
              }
              unint64_t v179 = &v138[8 * v134];
              *(void *)unint64_t v179 = v58;
              uint64_t v61 = v179 + 8;
              while (v59 != v133)
              {
                uint64_t v180 = *((void *)v59 - 1);
                v59 -= 8;
                *((void *)v179 - 1) = v180;
                v179 -= 8;
              }
              v57[166] = v179;
              v57[167] = v61;
              v57[168] = &v138[8 * v137];
              if (v133) {
                operator delete(v133);
              }
            }
            else
            {
              *(void *)v59 = v58;
              uint64_t v61 = v59 + 8;
            }
            v57[167] = v61;
            break;
          case 0x18:
            uint64_t v62 = a1[2];
            unint64_t v63 = *(void **)v62;
            uint64_t v64 = *(unsigned __int16 *)(a1[3] + 34);
            unint64_t v65 = *(char **)(*(void *)v62 + 1360);
            unint64_t v66 = *(void *)(*(void *)v62 + 1368);
            if ((unint64_t)v65 >= v66)
            {
              uint64_t v139 = (char *)v63[169];
              uint64_t v140 = (v65 - v139) >> 3;
              if ((unint64_t)(v140 + 1) >> 61) {
                goto LABEL_252;
              }
              unint64_t v141 = v66 - (void)v139;
              unint64_t v142 = (uint64_t)(v66 - (void)v139) >> 2;
              if (v142 <= v140 + 1) {
                unint64_t v142 = v140 + 1;
              }
              if (v141 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v143 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v143 = v142;
              }
              if (v143)
              {
                uint64_t v144 = (char *)sub_5714((uint64_t)(v63 + 171), v143);
                unint64_t v65 = (char *)v63[170];
                uint64_t v139 = (char *)v63[169];
              }
              else
              {
                uint64_t v144 = 0;
              }
              v181 = &v144[8 * v140];
              *(void *)v181 = v64;
              v67 = v181 + 8;
              while (v65 != v139)
              {
                uint64_t v182 = *((void *)v65 - 1);
                v65 -= 8;
                *((void *)v181 - 1) = v182;
                v181 -= 8;
              }
              v63[169] = v181;
              v63[170] = v67;
              v63[171] = &v144[8 * v143];
              if (v139) {
                operator delete(v139);
              }
            }
            else
            {
              *(void *)unint64_t v65 = v64;
              v67 = v65 + 8;
            }
            v63[170] = v67;
            break;
          case 0x19:
            uint64_t v68 = a1[2];
            uint64_t v69 = *(void **)v68;
            uint64_t v70 = *(unsigned __int16 *)(a1[3] + 42);
            uint64_t v71 = *(char **)(*(void *)v68 + 1384);
            unint64_t v72 = *(void *)(*(void *)v68 + 1392);
            if ((unint64_t)v71 >= v72)
            {
              unint64_t v145 = (char *)v69[172];
              uint64_t v146 = (v71 - v145) >> 3;
              if ((unint64_t)(v146 + 1) >> 61) {
                goto LABEL_252;
              }
              unint64_t v147 = v72 - (void)v145;
              unint64_t v148 = (uint64_t)(v72 - (void)v145) >> 2;
              if (v148 <= v146 + 1) {
                unint64_t v148 = v146 + 1;
              }
              if (v147 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v149 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v149 = v148;
              }
              if (v149)
              {
                v150 = (char *)sub_5714((uint64_t)(v69 + 174), v149);
                uint64_t v71 = (char *)v69[173];
                unint64_t v145 = (char *)v69[172];
              }
              else
              {
                v150 = 0;
              }
              uint64_t v183 = &v150[8 * v146];
              *(void *)uint64_t v183 = v70;
              unint64_t v73 = v183 + 8;
              while (v71 != v145)
              {
                uint64_t v184 = *((void *)v71 - 1);
                v71 -= 8;
                *((void *)v183 - 1) = v184;
                v183 -= 8;
              }
              v69[172] = v183;
              v69[173] = v73;
              v69[174] = &v150[8 * v149];
              if (v145) {
                operator delete(v145);
              }
            }
            else
            {
              *(void *)uint64_t v71 = v70;
              unint64_t v73 = v71 + 8;
            }
            v69[173] = v73;
            break;
          case 0x1A:
            uint64_t v74 = a1[2];
            uint64_t v75 = *(void **)v74;
            uint64_t v76 = *(unsigned __int16 *)(a1[3] + 30);
            unint64_t v77 = *(char **)(*(void *)v74 + 1408);
            unint64_t v78 = *(void *)(*(void *)v74 + 1416);
            if ((unint64_t)v77 >= v78)
            {
              uint64_t v151 = (char *)v75[175];
              uint64_t v152 = (v77 - v151) >> 3;
              if ((unint64_t)(v152 + 1) >> 61) {
                goto LABEL_252;
              }
              unint64_t v153 = v78 - (void)v151;
              unint64_t v154 = (uint64_t)(v78 - (void)v151) >> 2;
              if (v154 <= v152 + 1) {
                unint64_t v154 = v152 + 1;
              }
              if (v153 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v155 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v155 = v154;
              }
              if (v155)
              {
                uint64_t v156 = (char *)sub_5714((uint64_t)(v75 + 177), v155);
                unint64_t v77 = (char *)v75[176];
                uint64_t v151 = (char *)v75[175];
              }
              else
              {
                uint64_t v156 = 0;
              }
              unint64_t v185 = &v156[8 * v152];
              *(void *)unint64_t v185 = v76;
              v79 = v185 + 8;
              while (v77 != v151)
              {
                uint64_t v186 = *((void *)v77 - 1);
                v77 -= 8;
                *((void *)v185 - 1) = v186;
                v185 -= 8;
              }
              v75[175] = v185;
              v75[176] = v79;
              v75[177] = &v156[8 * v155];
              if (v151) {
                operator delete(v151);
              }
            }
            else
            {
              *(void *)unint64_t v77 = v76;
              v79 = v77 + 8;
            }
            v75[176] = v79;
            break;
          case 0x1B:
            v80 = *(void **)a1[2];
            uint64_t v81 = *(_WORD *)(a1[3] + 50) & 0x7FFF;
            unint64_t v82 = (char *)v80[179];
            unint64_t v83 = v80[180];
            if ((unint64_t)v82 >= v83)
            {
              v157 = (char *)v80[178];
              uint64_t v158 = (v82 - v157) >> 3;
              if ((unint64_t)(v158 + 1) >> 61) {
LABEL_252:
              }
                sub_566C();
              unint64_t v159 = v83 - (void)v157;
              unint64_t v160 = (uint64_t)(v83 - (void)v157) >> 2;
              if (v160 <= v158 + 1) {
                unint64_t v160 = v158 + 1;
              }
              if (v159 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v161 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v161 = v160;
              }
              if (v161)
              {
                v162 = (char *)sub_5714((uint64_t)(v80 + 180), v161);
                unint64_t v82 = (char *)v80[179];
                v157 = (char *)v80[178];
              }
              else
              {
                v162 = 0;
              }
              v187 = &v162[8 * v158];
              *(void *)v187 = v81;
              unint64_t v84 = v187 + 8;
              while (v82 != v157)
              {
                uint64_t v188 = *((void *)v82 - 1);
                v82 -= 8;
                *((void *)v187 - 1) = v188;
                v187 -= 8;
              }
              v80[178] = v187;
              v80[179] = v84;
              v80[180] = &v162[8 * v161];
              if (v157) {
                operator delete(v157);
              }
            }
            else
            {
              *(void *)unint64_t v82 = v81;
              unint64_t v84 = v82 + 8;
            }
            v80[179] = v84;
            break;
          default:
            break;
        }
        ++v7;
      }
      while (v7 != v9);
    }
  }
  *a2 = 1;
}

void sub_1AA900(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  if (*a2 == 1)
  {
    unint64_t v208 = (int **)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v207 = *v208;
    uint64_t v209 = (char *)v208[1] - (char *)*v208;
    if (v209)
    {
      unint64_t v210 = v209 >> 2;
      if (v210 <= 1) {
        unint64_t v210 = 1;
      }
      do
      {
        int v211 = *v207++;
        switch(v211)
        {
          case 0:
            unint64_t v212 = *(_DWORD *)(a1[3] + 36) & 0x3FFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 784);
            goto LABEL_284;
          case 1:
            unint64_t v212 = *(_DWORD *)(a1[3] + 32) & 0x3FFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 808);
            goto LABEL_284;
          case 2:
            unint64_t v212 = *(_DWORD *)(a1[3] + 28) & 0x3FFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 832);
            goto LABEL_284;
          case 3:
            unint64_t v212 = ((unint64_t)*(unsigned int *)(a1[3] + 24) >> 1) & 0x3FFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 856);
            goto LABEL_284;
          case 4:
            unint64_t v212 = *(_DWORD *)(a1[3] + 44) & 0x3FFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 880);
            goto LABEL_284;
          case 5:
            unint64_t v212 = *(_DWORD *)(a1[3] + 40) & 0x3FFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 904);
            goto LABEL_284;
          case 6:
            unint64_t v212 = *(unsigned __int16 *)(a1[3] + 62);
            uint64_t v213 = (void *)(*(void *)a1[2] + 928);
            goto LABEL_284;
          case 7:
            unint64_t v212 = *(_DWORD *)(a1[3] + 44) & 0x3FFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 952);
            goto LABEL_284;
          case 8:
            unint64_t v212 = *(_DWORD *)(a1[3] + 40) & 0x3FFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 976);
            goto LABEL_284;
          case 9:
            unint64_t v212 = *(_DWORD *)(a1[3] + 36) & 0x3FFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 1000);
            goto LABEL_284;
          case 10:
            unint64_t v212 = *(_DWORD *)(a1[3] + 32) & 0x3FFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 1024);
            goto LABEL_284;
          case 11:
            unint64_t v212 = *(_DWORD *)(a1[3] + 48) & 0xFFFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 1048);
            goto LABEL_284;
          case 12:
            unint64_t v212 = *(_DWORD *)(a1[3] + 56) & 0xFFFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 1072);
            goto LABEL_284;
          case 13:
            unint64_t v212 = *(unsigned __int16 *)(a1[3] + 60);
            uint64_t v213 = (void *)(*(void *)a1[2] + 1096);
            goto LABEL_284;
          case 14:
            unint64_t v212 = *(_DWORD *)(a1[3] + 52) & 0xFFFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 1120);
LABEL_284:
            *(void *)(*v213 - 8) += v212;
            break;
          default:
            break;
        }
        --v210;
      }
      while (v210);
    }
  }
  else
  {
    if (*a2) {
      return;
    }
    v5 = (void *)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v6 = v5[1] - *v5;
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = v6 >> 2;
      if (v8 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v8;
      }
      do
      {
        switch(*(_DWORD *)(*v5 + 4 * v7))
        {
          case 0:
            v10 = *(void **)a1[2];
            uint64_t v11 = *(_DWORD *)(a1[3] + 36) & 0x3FFFFLL;
            v12 = (uint64_t *)v10[98];
            unint64_t v13 = v10[99];
            if ((unint64_t)v12 >= v13)
            {
              unint64_t v87 = (uint64_t *)v10[97];
              uint64_t v88 = v12 - v87;
              if ((unint64_t)(v88 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v89 = v13 - (void)v87;
              unint64_t v90 = (uint64_t)(v13 - (void)v87) >> 2;
              if (v90 <= v88 + 1) {
                unint64_t v90 = v88 + 1;
              }
              if (v89 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v91 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v91 = v90;
              }
              if (v91)
              {
                uint64_t v92 = (char *)sub_5714((uint64_t)(v10 + 99), v91);
                v12 = (uint64_t *)v10[98];
                unint64_t v87 = (uint64_t *)v10[97];
              }
              else
              {
                uint64_t v92 = 0;
              }
              uint64_t v177 = (uint64_t *)&v92[8 * v88];
              *uint64_t v177 = v11;
              v14 = v177 + 1;
              while (v12 != v87)
              {
                uint64_t v178 = *--v12;
                *--uint64_t v177 = v178;
              }
              v10[97] = v177;
              v10[98] = v14;
              v10[99] = &v92[8 * v91];
              if (v87) {
                operator delete(v87);
              }
            }
            else
            {
              uint64_t *v12 = v11;
              v14 = v12 + 1;
            }
            v10[98] = v14;
            break;
          case 1:
            v15 = *(void **)a1[2];
            uint64_t v16 = *(_DWORD *)(a1[3] + 32) & 0x3FFFFLL;
            v17 = (uint64_t *)v15[101];
            unint64_t v18 = v15[102];
            if ((unint64_t)v17 >= v18)
            {
              unint64_t v93 = (uint64_t *)v15[100];
              uint64_t v94 = v17 - v93;
              if ((unint64_t)(v94 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v95 = v18 - (void)v93;
              unint64_t v96 = (uint64_t)(v18 - (void)v93) >> 2;
              if (v96 <= v94 + 1) {
                unint64_t v96 = v94 + 1;
              }
              if (v95 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v97 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v97 = v96;
              }
              if (v97)
              {
                uint64_t v98 = (char *)sub_5714((uint64_t)(v15 + 102), v97);
                v17 = (uint64_t *)v15[101];
                unint64_t v93 = (uint64_t *)v15[100];
              }
              else
              {
                uint64_t v98 = 0;
              }
              unint64_t v179 = (uint64_t *)&v98[8 * v94];
              *unint64_t v179 = v16;
              v19 = v179 + 1;
              while (v17 != v93)
              {
                uint64_t v180 = *--v17;
                *--unint64_t v179 = v180;
              }
              v15[100] = v179;
              v15[101] = v19;
              v15[102] = &v98[8 * v97];
              if (v93) {
                operator delete(v93);
              }
            }
            else
            {
              uint64_t *v17 = v16;
              v19 = v17 + 1;
            }
            v15[101] = v19;
            break;
          case 2:
            uint64_t v20 = *(void **)a1[2];
            uint64_t v21 = *(_DWORD *)(a1[3] + 28) & 0x3FFFFLL;
            uint64_t v22 = (uint64_t *)v20[104];
            unint64_t v23 = v20[105];
            if ((unint64_t)v22 >= v23)
            {
              unint64_t v99 = (uint64_t *)v20[103];
              uint64_t v100 = v22 - v99;
              if ((unint64_t)(v100 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v101 = v23 - (void)v99;
              unint64_t v102 = (uint64_t)(v23 - (void)v99) >> 2;
              if (v102 <= v100 + 1) {
                unint64_t v102 = v100 + 1;
              }
              if (v101 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v103 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v103 = v102;
              }
              if (v103)
              {
                uint64_t v104 = (char *)sub_5714((uint64_t)(v20 + 105), v103);
                uint64_t v22 = (uint64_t *)v20[104];
                unint64_t v99 = (uint64_t *)v20[103];
              }
              else
              {
                uint64_t v104 = 0;
              }
              v181 = (uint64_t *)&v104[8 * v100];
              uint64_t *v181 = v21;
              unint64_t v24 = v181 + 1;
              while (v22 != v99)
              {
                uint64_t v182 = *--v22;
                *--v181 = v182;
              }
              v20[103] = v181;
              v20[104] = v24;
              v20[105] = &v104[8 * v103];
              if (v99) {
                operator delete(v99);
              }
            }
            else
            {
              uint64_t *v22 = v21;
              unint64_t v24 = v22 + 1;
            }
            v20[104] = v24;
            break;
          case 3:
            uint64_t v25 = *(void **)a1[2];
            unint64_t v26 = ((unint64_t)*(unsigned int *)(a1[3] + 24) >> 1) & 0x3FFFF;
            uint64_t v27 = (unint64_t *)v25[107];
            unint64_t v28 = v25[108];
            if ((unint64_t)v27 >= v28)
            {
              unint64_t v105 = (unint64_t *)v25[106];
              uint64_t v106 = v27 - v105;
              if ((unint64_t)(v106 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v107 = v28 - (void)v105;
              unint64_t v108 = (uint64_t)(v28 - (void)v105) >> 2;
              if (v108 <= v106 + 1) {
                unint64_t v108 = v106 + 1;
              }
              if (v107 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v109 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v109 = v108;
              }
              if (v109)
              {
                uint64_t v110 = (char *)sub_5714((uint64_t)(v25 + 108), v109);
                uint64_t v27 = (unint64_t *)v25[107];
                unint64_t v105 = (unint64_t *)v25[106];
              }
              else
              {
                uint64_t v110 = 0;
              }
              uint64_t v183 = (unint64_t *)&v110[8 * v106];
              *uint64_t v183 = v26;
              unint64_t v29 = v183 + 1;
              while (v27 != v105)
              {
                unint64_t v184 = *--v27;
                *--uint64_t v183 = v184;
              }
              v25[106] = v183;
              v25[107] = v29;
              v25[108] = &v110[8 * v109];
              if (v105) {
                operator delete(v105);
              }
            }
            else
            {
              *uint64_t v27 = v26;
              unint64_t v29 = v27 + 1;
            }
            v25[107] = v29;
            break;
          case 4:
            unint64_t v30 = *(void **)a1[2];
            uint64_t v31 = *(_DWORD *)(a1[3] + 44) & 0x3FFFFLL;
            uint64_t v32 = (uint64_t *)v30[110];
            unint64_t v33 = v30[111];
            if ((unint64_t)v32 >= v33)
            {
              unint64_t v111 = (uint64_t *)v30[109];
              uint64_t v112 = v32 - v111;
              if ((unint64_t)(v112 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v113 = v33 - (void)v111;
              unint64_t v114 = (uint64_t)(v33 - (void)v111) >> 2;
              if (v114 <= v112 + 1) {
                unint64_t v114 = v112 + 1;
              }
              if (v113 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v115 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v115 = v114;
              }
              if (v115)
              {
                uint64_t v116 = (char *)sub_5714((uint64_t)(v30 + 111), v115);
                uint64_t v32 = (uint64_t *)v30[110];
                unint64_t v111 = (uint64_t *)v30[109];
              }
              else
              {
                uint64_t v116 = 0;
              }
              unint64_t v185 = (uint64_t *)&v116[8 * v112];
              *unint64_t v185 = v31;
              uint64_t v34 = v185 + 1;
              while (v32 != v111)
              {
                uint64_t v186 = *--v32;
                *--unint64_t v185 = v186;
              }
              v30[109] = v185;
              v30[110] = v34;
              v30[111] = &v116[8 * v115];
              if (v111) {
                operator delete(v111);
              }
            }
            else
            {
              uint64_t *v32 = v31;
              uint64_t v34 = v32 + 1;
            }
            v30[110] = v34;
            break;
          case 5:
            unint64_t v35 = *(void **)a1[2];
            uint64_t v36 = *(_DWORD *)(a1[3] + 40) & 0x3FFFFLL;
            v37 = (uint64_t *)v35[113];
            unint64_t v38 = v35[114];
            if ((unint64_t)v37 >= v38)
            {
              unint64_t v117 = (uint64_t *)v35[112];
              uint64_t v118 = v37 - v117;
              if ((unint64_t)(v118 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v119 = v38 - (void)v117;
              unint64_t v120 = (uint64_t)(v38 - (void)v117) >> 2;
              if (v120 <= v118 + 1) {
                unint64_t v120 = v118 + 1;
              }
              if (v119 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v121 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v121 = v120;
              }
              if (v121)
              {
                uint64_t v122 = (char *)sub_5714((uint64_t)(v35 + 114), v121);
                v37 = (uint64_t *)v35[113];
                unint64_t v117 = (uint64_t *)v35[112];
              }
              else
              {
                uint64_t v122 = 0;
              }
              v187 = (uint64_t *)&v122[8 * v118];
              uint64_t *v187 = v36;
              v39 = v187 + 1;
              while (v37 != v117)
              {
                uint64_t v188 = *--v37;
                *--v187 = v188;
              }
              v35[112] = v187;
              v35[113] = v39;
              v35[114] = &v122[8 * v121];
              if (v117) {
                operator delete(v117);
              }
            }
            else
            {
              uint64_t *v37 = v36;
              v39 = v37 + 1;
            }
            v35[113] = v39;
            break;
          case 6:
            uint64_t v40 = a1[2];
            uint64_t v41 = *(void **)v40;
            uint64_t v42 = *(unsigned __int16 *)(a1[3] + 62);
            unint64_t v43 = *(char **)(*(void *)v40 + 928);
            unint64_t v44 = *(void *)(*(void *)v40 + 936);
            if ((unint64_t)v43 >= v44)
            {
              unint64_t v123 = (char *)v41[115];
              uint64_t v124 = (v43 - v123) >> 3;
              if ((unint64_t)(v124 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v125 = v44 - (void)v123;
              unint64_t v126 = (uint64_t)(v44 - (void)v123) >> 2;
              if (v126 <= v124 + 1) {
                unint64_t v126 = v124 + 1;
              }
              if (v125 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v127 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v127 = v126;
              }
              if (v127)
              {
                uint64_t v128 = (char *)sub_5714((uint64_t)(v41 + 117), v127);
                unint64_t v43 = (char *)v41[116];
                unint64_t v123 = (char *)v41[115];
              }
              else
              {
                uint64_t v128 = 0;
              }
              uint64_t v189 = &v128[8 * v124];
              *(void *)uint64_t v189 = v42;
              unint64_t v45 = v189 + 8;
              while (v43 != v123)
              {
                uint64_t v190 = *((void *)v43 - 1);
                v43 -= 8;
                *((void *)v189 - 1) = v190;
                v189 -= 8;
              }
              v41[115] = v189;
              v41[116] = v45;
              v41[117] = &v128[8 * v127];
              if (v123) {
                operator delete(v123);
              }
            }
            else
            {
              *(void *)unint64_t v43 = v42;
              unint64_t v45 = v43 + 8;
            }
            v41[116] = v45;
            break;
          case 7:
            uint64_t v46 = *(void **)a1[2];
            uint64_t v47 = *(_DWORD *)(a1[3] + 44) & 0x3FFFFLL;
            unint64_t v48 = (uint64_t *)v46[119];
            unint64_t v49 = v46[120];
            if ((unint64_t)v48 >= v49)
            {
              unint64_t v129 = (uint64_t *)v46[118];
              uint64_t v130 = v48 - v129;
              if ((unint64_t)(v130 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v131 = v49 - (void)v129;
              unint64_t v132 = (uint64_t)(v49 - (void)v129) >> 2;
              if (v132 <= v130 + 1) {
                unint64_t v132 = v130 + 1;
              }
              if (v131 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v133 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v133 = v132;
              }
              if (v133)
              {
                uint64_t v134 = (char *)sub_5714((uint64_t)(v46 + 120), v133);
                unint64_t v48 = (uint64_t *)v46[119];
                unint64_t v129 = (uint64_t *)v46[118];
              }
              else
              {
                uint64_t v134 = 0;
              }
              uint64_t v191 = (uint64_t *)&v134[8 * v130];
              *uint64_t v191 = v47;
              uint64_t v50 = v191 + 1;
              while (v48 != v129)
              {
                uint64_t v192 = *--v48;
                *--uint64_t v191 = v192;
              }
              v46[118] = v191;
              v46[119] = v50;
              v46[120] = &v134[8 * v133];
              if (v129) {
                operator delete(v129);
              }
            }
            else
            {
              *unint64_t v48 = v47;
              uint64_t v50 = v48 + 1;
            }
            v46[119] = v50;
            break;
          case 8:
            uint64_t v51 = *(void **)a1[2];
            uint64_t v52 = *(_DWORD *)(a1[3] + 40) & 0x3FFFFLL;
            unint64_t v53 = (uint64_t *)v51[122];
            unint64_t v54 = v51[123];
            if ((unint64_t)v53 >= v54)
            {
              unint64_t v135 = (uint64_t *)v51[121];
              uint64_t v136 = v53 - v135;
              if ((unint64_t)(v136 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v137 = v54 - (void)v135;
              unint64_t v138 = (uint64_t)(v54 - (void)v135) >> 2;
              if (v138 <= v136 + 1) {
                unint64_t v138 = v136 + 1;
              }
              if (v137 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v139 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v139 = v138;
              }
              if (v139)
              {
                uint64_t v140 = (char *)sub_5714((uint64_t)(v51 + 123), v139);
                unint64_t v53 = (uint64_t *)v51[122];
                unint64_t v135 = (uint64_t *)v51[121];
              }
              else
              {
                uint64_t v140 = 0;
              }
              int v193 = (uint64_t *)&v140[8 * v136];
              uint64_t *v193 = v52;
              unint64_t v55 = v193 + 1;
              while (v53 != v135)
              {
                uint64_t v194 = *--v53;
                *--int v193 = v194;
              }
              v51[121] = v193;
              v51[122] = v55;
              v51[123] = &v140[8 * v139];
              if (v135) {
                operator delete(v135);
              }
            }
            else
            {
              *unint64_t v53 = v52;
              unint64_t v55 = v53 + 1;
            }
            v51[122] = v55;
            break;
          case 9:
            uint64_t v56 = *(void **)a1[2];
            uint64_t v57 = *(_DWORD *)(a1[3] + 36) & 0x3FFFFLL;
            uint64_t v58 = (uint64_t *)v56[125];
            unint64_t v59 = v56[126];
            if ((unint64_t)v58 >= v59)
            {
              unint64_t v141 = (uint64_t *)v56[124];
              uint64_t v142 = v58 - v141;
              if ((unint64_t)(v142 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v143 = v59 - (void)v141;
              unint64_t v144 = (uint64_t)(v59 - (void)v141) >> 2;
              if (v144 <= v142 + 1) {
                unint64_t v144 = v142 + 1;
              }
              if (v143 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v145 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v145 = v144;
              }
              if (v145)
              {
                uint64_t v146 = (char *)sub_5714((uint64_t)(v56 + 126), v145);
                uint64_t v58 = (uint64_t *)v56[125];
                unint64_t v141 = (uint64_t *)v56[124];
              }
              else
              {
                uint64_t v146 = 0;
              }
              uint64_t v195 = (uint64_t *)&v146[8 * v142];
              *uint64_t v195 = v57;
              unint64_t v60 = v195 + 1;
              while (v58 != v141)
              {
                uint64_t v196 = *--v58;
                *--uint64_t v195 = v196;
              }
              v56[124] = v195;
              v56[125] = v60;
              v56[126] = &v146[8 * v145];
              if (v141) {
                operator delete(v141);
              }
            }
            else
            {
              *uint64_t v58 = v57;
              unint64_t v60 = v58 + 1;
            }
            v56[125] = v60;
            break;
          case 0xA:
            uint64_t v61 = *(void **)a1[2];
            uint64_t v62 = *(_DWORD *)(a1[3] + 32) & 0x3FFFFLL;
            unint64_t v63 = (uint64_t *)v61[128];
            unint64_t v64 = v61[129];
            if ((unint64_t)v63 >= v64)
            {
              unint64_t v147 = (uint64_t *)v61[127];
              uint64_t v148 = v63 - v147;
              if ((unint64_t)(v148 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v149 = v64 - (void)v147;
              unint64_t v150 = (uint64_t)(v64 - (void)v147) >> 2;
              if (v150 <= v148 + 1) {
                unint64_t v150 = v148 + 1;
              }
              if (v149 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v151 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v151 = v150;
              }
              if (v151)
              {
                uint64_t v152 = (char *)sub_5714((uint64_t)(v61 + 129), v151);
                unint64_t v63 = (uint64_t *)v61[128];
                unint64_t v147 = (uint64_t *)v61[127];
              }
              else
              {
                uint64_t v152 = 0;
              }
              unint64_t v197 = (uint64_t *)&v152[8 * v148];
              *unint64_t v197 = v62;
              unint64_t v65 = v197 + 1;
              while (v63 != v147)
              {
                uint64_t v198 = *--v63;
                *--unint64_t v197 = v198;
              }
              v61[127] = v197;
              v61[128] = v65;
              v61[129] = &v152[8 * v151];
              if (v147) {
                operator delete(v147);
              }
            }
            else
            {
              *unint64_t v63 = v62;
              unint64_t v65 = v63 + 1;
            }
            v61[128] = v65;
            break;
          case 0xB:
            unint64_t v66 = *(void **)a1[2];
            uint64_t v67 = *(_DWORD *)(a1[3] + 48) & 0xFFFFFLL;
            uint64_t v68 = (uint64_t *)v66[131];
            unint64_t v69 = v66[132];
            if ((unint64_t)v68 >= v69)
            {
              unint64_t v153 = (uint64_t *)v66[130];
              uint64_t v154 = v68 - v153;
              if ((unint64_t)(v154 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v155 = v69 - (void)v153;
              unint64_t v156 = (uint64_t)(v69 - (void)v153) >> 2;
              if (v156 <= v154 + 1) {
                unint64_t v156 = v154 + 1;
              }
              if (v155 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v157 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v157 = v156;
              }
              if (v157)
              {
                uint64_t v158 = (char *)sub_5714((uint64_t)(v66 + 132), v157);
                uint64_t v68 = (uint64_t *)v66[131];
                unint64_t v153 = (uint64_t *)v66[130];
              }
              else
              {
                uint64_t v158 = 0;
              }
              v199 = (uint64_t *)&v158[8 * v154];
              uint64_t *v199 = v67;
              uint64_t v70 = v199 + 1;
              while (v68 != v153)
              {
                uint64_t v200 = *--v68;
                *--v199 = v200;
              }
              v66[130] = v199;
              v66[131] = v70;
              v66[132] = &v158[8 * v157];
              if (v153) {
                operator delete(v153);
              }
            }
            else
            {
              uint64_t *v68 = v67;
              uint64_t v70 = v68 + 1;
            }
            v66[131] = v70;
            break;
          case 0xC:
            uint64_t v71 = *(void **)a1[2];
            uint64_t v72 = *(_DWORD *)(a1[3] + 56) & 0xFFFFFLL;
            unint64_t v73 = (uint64_t *)v71[134];
            unint64_t v74 = v71[135];
            if ((unint64_t)v73 >= v74)
            {
              unint64_t v159 = (uint64_t *)v71[133];
              uint64_t v160 = v73 - v159;
              if ((unint64_t)(v160 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v161 = v74 - (void)v159;
              unint64_t v162 = (uint64_t)(v74 - (void)v159) >> 2;
              if (v162 <= v160 + 1) {
                unint64_t v162 = v160 + 1;
              }
              if (v161 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v163 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v163 = v162;
              }
              if (v163)
              {
                uint64_t v164 = (char *)sub_5714((uint64_t)(v71 + 135), v163);
                unint64_t v73 = (uint64_t *)v71[134];
                unint64_t v159 = (uint64_t *)v71[133];
              }
              else
              {
                uint64_t v164 = 0;
              }
              uint64_t v201 = (uint64_t *)&v164[8 * v160];
              *uint64_t v201 = v72;
              uint64_t v75 = v201 + 1;
              while (v73 != v159)
              {
                uint64_t v202 = *--v73;
                *--uint64_t v201 = v202;
              }
              v71[133] = v201;
              v71[134] = v75;
              v71[135] = &v164[8 * v163];
              if (v159) {
                operator delete(v159);
              }
            }
            else
            {
              uint64_t *v73 = v72;
              uint64_t v75 = v73 + 1;
            }
            v71[134] = v75;
            break;
          case 0xD:
            uint64_t v76 = a1[2];
            unint64_t v77 = *(void **)v76;
            uint64_t v78 = *(unsigned __int16 *)(a1[3] + 60);
            v79 = *(char **)(*(void *)v76 + 1096);
            unint64_t v80 = *(void *)(*(void *)v76 + 1104);
            if ((unint64_t)v79 >= v80)
            {
              v165 = (char *)v77[136];
              uint64_t v166 = (v79 - v165) >> 3;
              if ((unint64_t)(v166 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v167 = v80 - (void)v165;
              unint64_t v168 = (uint64_t)(v80 - (void)v165) >> 2;
              if (v168 <= v166 + 1) {
                unint64_t v168 = v166 + 1;
              }
              if (v167 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v169 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v169 = v168;
              }
              if (v169)
              {
                uint64_t v170 = (char *)sub_5714((uint64_t)(v77 + 138), v169);
                v79 = (char *)v77[137];
                v165 = (char *)v77[136];
              }
              else
              {
                uint64_t v170 = 0;
              }
              unint64_t v203 = &v170[8 * v166];
              *(void *)unint64_t v203 = v78;
              uint64_t v81 = v203 + 8;
              while (v79 != v165)
              {
                uint64_t v204 = *((void *)v79 - 1);
                v79 -= 8;
                *((void *)v203 - 1) = v204;
                v203 -= 8;
              }
              v77[136] = v203;
              v77[137] = v81;
              v77[138] = &v170[8 * v169];
              if (v165) {
                operator delete(v165);
              }
            }
            else
            {
              *(void *)v79 = v78;
              uint64_t v81 = v79 + 8;
            }
            v77[137] = v81;
            break;
          case 0xE:
            unint64_t v82 = *(void **)a1[2];
            uint64_t v83 = *(_DWORD *)(a1[3] + 52) & 0xFFFFFLL;
            unint64_t v84 = (uint64_t *)v82[140];
            unint64_t v85 = v82[141];
            if ((unint64_t)v84 >= v85)
            {
              uint64_t v171 = (uint64_t *)v82[139];
              uint64_t v172 = v84 - v171;
              if ((unint64_t)(v172 + 1) >> 61) {
LABEL_288:
              }
                sub_566C();
              unint64_t v173 = v85 - (void)v171;
              unint64_t v174 = (uint64_t)(v85 - (void)v171) >> 2;
              if (v174 <= v172 + 1) {
                unint64_t v174 = v172 + 1;
              }
              if (v173 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v175 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v175 = v174;
              }
              if (v175)
              {
                uint64_t v176 = (char *)sub_5714((uint64_t)(v82 + 141), v175);
                unint64_t v84 = (uint64_t *)v82[140];
                uint64_t v171 = (uint64_t *)v82[139];
              }
              else
              {
                uint64_t v176 = 0;
              }
              v205 = (uint64_t *)&v176[8 * v172];
              uint64_t *v205 = v83;
              uint64_t v86 = v205 + 1;
              while (v84 != v171)
              {
                uint64_t v206 = *--v84;
                *--v205 = v206;
              }
              v82[139] = v205;
              v82[140] = v86;
              v82[141] = &v176[8 * v175];
              if (v171) {
                operator delete(v171);
              }
            }
            else
            {
              *unint64_t v84 = v83;
              uint64_t v86 = v84 + 1;
            }
            v82[140] = v86;
            break;
          default:
            break;
        }
        ++v7;
      }
      while (v7 != v9);
    }
  }
  *a2 = 1;
}

void sub_1AB758(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  if (*a2 == 1)
  {
    unint64_t v63 = (int **)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v62 = *v63;
    uint64_t v64 = (char *)v63[1] - (char *)*v63;
    if (v64)
    {
      unint64_t v65 = v64 >> 2;
      if (v65 <= 1) {
        unint64_t v65 = 1;
      }
      do
      {
        int v66 = *v62++;
        switch(v66)
        {
          case 214:
            unint64_t v67 = *(_DWORD *)(a1[3] + 36) & 0xFFFFF;
            uint64_t v68 = (void *)(*(void *)a1[2] + 5920);
            goto LABEL_86;
          case 215:
            unint64_t v67 = *(_DWORD *)(a1[3] + 28) & 0x1FFFF;
            uint64_t v68 = (void *)(*(void *)a1[2] + 5944);
            goto LABEL_86;
          case 216:
            unint64_t v67 = *(_DWORD *)(a1[3] + 32) & 0xFFFFF;
            uint64_t v68 = (void *)(*(void *)a1[2] + 5968);
            goto LABEL_86;
          case 217:
            unint64_t v67 = ((unint64_t)*(unsigned int *)(a1[3] + 24) >> 1) & 0x7FFFF;
            uint64_t v68 = (void *)(*(void *)a1[2] + 5992);
LABEL_86:
            *(void *)(*v68 - 8) += v67;
            break;
          default:
            break;
        }
        --v65;
      }
      while (v65);
    }
  }
  else
  {
    if (*a2) {
      return;
    }
    v5 = (void *)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v6 = v5[1] - *v5;
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = v6 >> 2;
      if (v8 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v8;
      }
      do
      {
        switch(*(_DWORD *)(*v5 + 4 * v7))
        {
          case 0xD6:
            v10 = *(void **)a1[2];
            uint64_t v11 = *(_DWORD *)(a1[3] + 36) & 0xFFFFFLL;
            v12 = (uint64_t *)v10[740];
            unint64_t v13 = v10[741];
            if ((unint64_t)v12 >= v13)
            {
              unint64_t v30 = (uint64_t *)v10[739];
              uint64_t v31 = v12 - v30;
              if ((unint64_t)(v31 + 1) >> 61) {
                goto LABEL_90;
              }
              unint64_t v32 = v13 - (void)v30;
              unint64_t v33 = (uint64_t)(v13 - (void)v30) >> 2;
              if (v33 <= v31 + 1) {
                unint64_t v33 = v31 + 1;
              }
              if (v32 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v34 = v33;
              }
              if (v34)
              {
                unint64_t v35 = (char *)sub_5714((uint64_t)(v10 + 741), v34);
                v12 = (uint64_t *)v10[740];
                unint64_t v30 = (uint64_t *)v10[739];
              }
              else
              {
                unint64_t v35 = 0;
              }
              unint64_t v54 = (uint64_t *)&v35[8 * v31];
              uint64_t *v54 = v11;
              v14 = v54 + 1;
              while (v12 != v30)
              {
                uint64_t v55 = *--v12;
                *--unint64_t v54 = v55;
              }
              v10[739] = v54;
              v10[740] = v14;
              v10[741] = &v35[8 * v34];
              if (v30) {
                operator delete(v30);
              }
            }
            else
            {
              uint64_t *v12 = v11;
              v14 = v12 + 1;
            }
            v10[740] = v14;
            break;
          case 0xD7:
            v15 = *(void **)a1[2];
            uint64_t v16 = *(_DWORD *)(a1[3] + 28) & 0x1FFFFLL;
            v17 = (uint64_t *)v15[743];
            unint64_t v18 = v15[744];
            if ((unint64_t)v17 >= v18)
            {
              uint64_t v36 = (uint64_t *)v15[742];
              uint64_t v37 = v17 - v36;
              if ((unint64_t)(v37 + 1) >> 61) {
                goto LABEL_90;
              }
              unint64_t v38 = v18 - (void)v36;
              unint64_t v39 = (uint64_t)(v18 - (void)v36) >> 2;
              if (v39 <= v37 + 1) {
                unint64_t v39 = v37 + 1;
              }
              if (v38 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v40 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v40 = v39;
              }
              if (v40)
              {
                uint64_t v41 = (char *)sub_5714((uint64_t)(v15 + 744), v40);
                v17 = (uint64_t *)v15[743];
                uint64_t v36 = (uint64_t *)v15[742];
              }
              else
              {
                uint64_t v41 = 0;
              }
              uint64_t v56 = (uint64_t *)&v41[8 * v37];
              uint64_t *v56 = v16;
              v19 = v56 + 1;
              while (v17 != v36)
              {
                uint64_t v57 = *--v17;
                *--uint64_t v56 = v57;
              }
              v15[742] = v56;
              v15[743] = v19;
              v15[744] = &v41[8 * v40];
              if (v36) {
                operator delete(v36);
              }
            }
            else
            {
              uint64_t *v17 = v16;
              v19 = v17 + 1;
            }
            v15[743] = v19;
            break;
          case 0xD8:
            uint64_t v20 = *(void **)a1[2];
            uint64_t v21 = *(_DWORD *)(a1[3] + 32) & 0xFFFFFLL;
            uint64_t v22 = (uint64_t *)v20[746];
            unint64_t v23 = v20[747];
            if ((unint64_t)v22 >= v23)
            {
              uint64_t v42 = (uint64_t *)v20[745];
              uint64_t v43 = v22 - v42;
              if ((unint64_t)(v43 + 1) >> 61) {
                goto LABEL_90;
              }
              unint64_t v44 = v23 - (void)v42;
              unint64_t v45 = (uint64_t)(v23 - (void)v42) >> 2;
              if (v45 <= v43 + 1) {
                unint64_t v45 = v43 + 1;
              }
              if (v44 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v46 = v45;
              }
              if (v46)
              {
                uint64_t v47 = (char *)sub_5714((uint64_t)(v20 + 747), v46);
                uint64_t v22 = (uint64_t *)v20[746];
                uint64_t v42 = (uint64_t *)v20[745];
              }
              else
              {
                uint64_t v47 = 0;
              }
              uint64_t v58 = (uint64_t *)&v47[8 * v43];
              *uint64_t v58 = v21;
              unint64_t v24 = v58 + 1;
              while (v22 != v42)
              {
                uint64_t v59 = *--v22;
                *--uint64_t v58 = v59;
              }
              v20[745] = v58;
              v20[746] = v24;
              v20[747] = &v47[8 * v46];
              if (v42) {
                operator delete(v42);
              }
            }
            else
            {
              uint64_t *v22 = v21;
              unint64_t v24 = v22 + 1;
            }
            v20[746] = v24;
            break;
          case 0xD9:
            uint64_t v25 = *(void **)a1[2];
            unint64_t v26 = ((unint64_t)*(unsigned int *)(a1[3] + 24) >> 1) & 0x7FFFF;
            uint64_t v27 = (unint64_t *)v25[749];
            unint64_t v28 = v25[750];
            if ((unint64_t)v27 >= v28)
            {
              unint64_t v48 = (unint64_t *)v25[748];
              uint64_t v49 = v27 - v48;
              if ((unint64_t)(v49 + 1) >> 61) {
LABEL_90:
              }
                sub_566C();
              unint64_t v50 = v28 - (void)v48;
              unint64_t v51 = (uint64_t)(v28 - (void)v48) >> 2;
              if (v51 <= v49 + 1) {
                unint64_t v51 = v49 + 1;
              }
              if (v50 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v52 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v52 = v51;
              }
              if (v52)
              {
                unint64_t v53 = (char *)sub_5714((uint64_t)(v25 + 750), v52);
                uint64_t v27 = (unint64_t *)v25[749];
                unint64_t v48 = (unint64_t *)v25[748];
              }
              else
              {
                unint64_t v53 = 0;
              }
              unint64_t v60 = (unint64_t *)&v53[8 * v49];
              *unint64_t v60 = v26;
              unint64_t v29 = v60 + 1;
              while (v27 != v48)
              {
                unint64_t v61 = *--v27;
                *--unint64_t v60 = v61;
              }
              v25[748] = v60;
              v25[749] = v29;
              v25[750] = &v53[8 * v52];
              if (v48) {
                operator delete(v48);
              }
            }
            else
            {
              *uint64_t v27 = v26;
              unint64_t v29 = v27 + 1;
            }
            v25[749] = v29;
            break;
          default:
            break;
        }
        ++v7;
      }
      while (v7 != v9);
    }
  }
  *a2 = 1;
}

void sub_1ABC58(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  if (*a2 == 1)
  {
    v271 = (int **)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    unint64_t v270 = *v271;
    uint64_t v272 = (char *)v271[1] - (char *)*v271;
    if (v272)
    {
      unint64_t v273 = v272 >> 2;
      if (v273 <= 1) {
        unint64_t v273 = 1;
      }
      do
      {
        int v274 = *v270++;
        switch(v274)
        {
          case 175:
            int v275 = *(_DWORD *)(a1[3] + 48);
            unint64_t v276 = (void *)(*(void *)a1[2] + 4984);
            goto LABEL_374;
          case 176:
            int v275 = *(_DWORD *)(a1[3] + 88);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5008);
            goto LABEL_374;
          case 177:
            int v275 = *(_DWORD *)(a1[3] + 24) >> 1;
            unint64_t v276 = (void *)(*(void *)a1[2] + 5032);
            goto LABEL_374;
          case 178:
            int v275 = *(_DWORD *)(a1[3] + 64);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5056);
            goto LABEL_374;
          case 179:
            int v275 = *(_DWORD *)(a1[3] + 32);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5080);
            goto LABEL_374;
          case 180:
            int v275 = *(_DWORD *)(a1[3] + 72);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5104);
            goto LABEL_374;
          case 181:
            int v275 = *(_DWORD *)(a1[3] + 44);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5128);
            goto LABEL_374;
          case 182:
            int v275 = *(_DWORD *)(a1[3] + 84);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5152);
            goto LABEL_374;
          case 183:
            int v275 = *(_DWORD *)(a1[3] + 40);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5176);
            goto LABEL_374;
          case 184:
            int v275 = *(_DWORD *)(a1[3] + 80);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5200);
            goto LABEL_374;
          case 185:
            int v275 = *(_DWORD *)(a1[3] + 56);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5224);
            goto LABEL_374;
          case 186:
            int v275 = *(_DWORD *)(a1[3] + 96);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5248);
            goto LABEL_374;
          case 187:
            int v275 = *(_DWORD *)(a1[3] + 60);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5272);
            goto LABEL_374;
          case 188:
            int v275 = *(_DWORD *)(a1[3] + 52);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5296);
            goto LABEL_374;
          case 189:
            int v275 = *(_DWORD *)(a1[3] + 92);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5320);
            goto LABEL_374;
          case 190:
            int v275 = *(_DWORD *)(a1[3] + 28);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5344);
            goto LABEL_374;
          case 191:
            int v275 = *(_DWORD *)(a1[3] + 68);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5368);
            goto LABEL_374;
          case 192:
            int v275 = *(_DWORD *)(a1[3] + 36);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5392);
            goto LABEL_374;
          case 193:
            int v275 = *(_DWORD *)(a1[3] + 76);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5416);
            goto LABEL_374;
          case 194:
            int v275 = *(_DWORD *)(a1[3] + 100);
            unint64_t v276 = (void *)(*(void *)a1[2] + 5440);
LABEL_374:
            *(void *)(*v276 - 8) += v275 & 0x7FFFF;
            break;
          default:
            break;
        }
        --v273;
      }
      while (v273);
    }
  }
  else
  {
    if (*a2) {
      return;
    }
    v5 = (void *)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v6 = v5[1] - *v5;
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = v6 >> 2;
      if (v8 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v8;
      }
      do
      {
        switch(*(_DWORD *)(*v5 + 4 * v7))
        {
          case 0xAF:
            v10 = *(void **)a1[2];
            uint64_t v11 = *(_DWORD *)(a1[3] + 48) & 0x7FFFFLL;
            v12 = (uint64_t *)v10[623];
            unint64_t v13 = v10[624];
            if ((unint64_t)v12 >= v13)
            {
              uint64_t v110 = (uint64_t *)v10[622];
              uint64_t v111 = v12 - v110;
              if ((unint64_t)(v111 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v112 = v13 - (void)v110;
              unint64_t v113 = (uint64_t)(v13 - (void)v110) >> 2;
              if (v113 <= v111 + 1) {
                unint64_t v113 = v111 + 1;
              }
              if (v112 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v114 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v114 = v113;
              }
              if (v114)
              {
                unint64_t v115 = (char *)sub_5714((uint64_t)(v10 + 624), v114);
                v12 = (uint64_t *)v10[623];
                uint64_t v110 = (uint64_t *)v10[622];
              }
              else
              {
                unint64_t v115 = 0;
              }
              v230 = (uint64_t *)&v115[8 * v111];
              uint64_t *v230 = v11;
              v14 = v230 + 1;
              while (v12 != v110)
              {
                uint64_t v231 = *--v12;
                *--v230 = v231;
              }
              v10[622] = v230;
              v10[623] = v14;
              v10[624] = &v115[8 * v114];
              if (v110) {
                operator delete(v110);
              }
            }
            else
            {
              uint64_t *v12 = v11;
              v14 = v12 + 1;
            }
            v10[623] = v14;
            break;
          case 0xB0:
            v15 = *(void **)a1[2];
            uint64_t v16 = *(_DWORD *)(a1[3] + 88) & 0x7FFFFLL;
            v17 = (uint64_t *)v15[626];
            unint64_t v18 = v15[627];
            if ((unint64_t)v17 >= v18)
            {
              uint64_t v116 = (uint64_t *)v15[625];
              uint64_t v117 = v17 - v116;
              if ((unint64_t)(v117 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v118 = v18 - (void)v116;
              unint64_t v119 = (uint64_t)(v18 - (void)v116) >> 2;
              if (v119 <= v117 + 1) {
                unint64_t v119 = v117 + 1;
              }
              if (v118 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v120 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v120 = v119;
              }
              if (v120)
              {
                unint64_t v121 = (char *)sub_5714((uint64_t)(v15 + 627), v120);
                v17 = (uint64_t *)v15[626];
                uint64_t v116 = (uint64_t *)v15[625];
              }
              else
              {
                unint64_t v121 = 0;
              }
              unint64_t v232 = (uint64_t *)&v121[8 * v117];
              *unint64_t v232 = v16;
              v19 = v232 + 1;
              while (v17 != v116)
              {
                uint64_t v233 = *--v17;
                *--unint64_t v232 = v233;
              }
              v15[625] = v232;
              v15[626] = v19;
              v15[627] = &v121[8 * v120];
              if (v116) {
                operator delete(v116);
              }
            }
            else
            {
              uint64_t *v17 = v16;
              v19 = v17 + 1;
            }
            v15[626] = v19;
            break;
          case 0xB1:
            uint64_t v20 = *(void **)a1[2];
            unint64_t v21 = ((unint64_t)*(unsigned int *)(a1[3] + 24) >> 1) & 0x7FFFF;
            uint64_t v22 = (unint64_t *)v20[629];
            unint64_t v23 = v20[630];
            if ((unint64_t)v22 >= v23)
            {
              uint64_t v122 = (unint64_t *)v20[628];
              uint64_t v123 = v22 - v122;
              if ((unint64_t)(v123 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v124 = v23 - (void)v122;
              unint64_t v125 = (uint64_t)(v23 - (void)v122) >> 2;
              if (v125 <= v123 + 1) {
                unint64_t v125 = v123 + 1;
              }
              if (v124 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v126 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v126 = v125;
              }
              if (v126)
              {
                unint64_t v127 = (char *)sub_5714((uint64_t)(v20 + 630), v126);
                uint64_t v22 = (unint64_t *)v20[629];
                uint64_t v122 = (unint64_t *)v20[628];
              }
              else
              {
                unint64_t v127 = 0;
              }
              unint64_t v234 = (unint64_t *)&v127[8 * v123];
              *unint64_t v234 = v21;
              unint64_t v24 = v234 + 1;
              while (v22 != v122)
              {
                unint64_t v235 = *--v22;
                *--unint64_t v234 = v235;
              }
              v20[628] = v234;
              v20[629] = v24;
              v20[630] = &v127[8 * v126];
              if (v122) {
                operator delete(v122);
              }
            }
            else
            {
              unint64_t *v22 = v21;
              unint64_t v24 = v22 + 1;
            }
            v20[629] = v24;
            break;
          case 0xB2:
            uint64_t v25 = *(void **)a1[2];
            uint64_t v26 = *(_DWORD *)(a1[3] + 64) & 0x7FFFFLL;
            uint64_t v27 = (uint64_t *)v25[632];
            unint64_t v28 = v25[633];
            if ((unint64_t)v27 >= v28)
            {
              uint64_t v128 = (uint64_t *)v25[631];
              uint64_t v129 = v27 - v128;
              if ((unint64_t)(v129 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v130 = v28 - (void)v128;
              unint64_t v131 = (uint64_t)(v28 - (void)v128) >> 2;
              if (v131 <= v129 + 1) {
                unint64_t v131 = v129 + 1;
              }
              if (v130 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v132 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v132 = v131;
              }
              if (v132)
              {
                unint64_t v133 = (char *)sub_5714((uint64_t)(v25 + 633), v132);
                uint64_t v27 = (uint64_t *)v25[632];
                uint64_t v128 = (uint64_t *)v25[631];
              }
              else
              {
                unint64_t v133 = 0;
              }
              v236 = (uint64_t *)&v133[8 * v129];
              uint64_t *v236 = v26;
              unint64_t v29 = v236 + 1;
              while (v27 != v128)
              {
                uint64_t v237 = *--v27;
                *--v236 = v237;
              }
              v25[631] = v236;
              v25[632] = v29;
              v25[633] = &v133[8 * v132];
              if (v128) {
                operator delete(v128);
              }
            }
            else
            {
              *uint64_t v27 = v26;
              unint64_t v29 = v27 + 1;
            }
            v25[632] = v29;
            break;
          case 0xB3:
            unint64_t v30 = *(void **)a1[2];
            uint64_t v31 = *(_DWORD *)(a1[3] + 32) & 0x7FFFFLL;
            unint64_t v32 = (uint64_t *)v30[635];
            unint64_t v33 = v30[636];
            if ((unint64_t)v32 >= v33)
            {
              uint64_t v134 = (uint64_t *)v30[634];
              uint64_t v135 = v32 - v134;
              if ((unint64_t)(v135 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v136 = v33 - (void)v134;
              unint64_t v137 = (uint64_t)(v33 - (void)v134) >> 2;
              if (v137 <= v135 + 1) {
                unint64_t v137 = v135 + 1;
              }
              if (v136 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v138 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v138 = v137;
              }
              if (v138)
              {
                unint64_t v139 = (char *)sub_5714((uint64_t)(v30 + 636), v138);
                unint64_t v32 = (uint64_t *)v30[635];
                uint64_t v134 = (uint64_t *)v30[634];
              }
              else
              {
                unint64_t v139 = 0;
              }
              unint64_t v238 = (uint64_t *)&v139[8 * v135];
              *unint64_t v238 = v31;
              unint64_t v34 = v238 + 1;
              while (v32 != v134)
              {
                uint64_t v239 = *--v32;
                *--unint64_t v238 = v239;
              }
              v30[634] = v238;
              v30[635] = v34;
              v30[636] = &v139[8 * v138];
              if (v134) {
                operator delete(v134);
              }
            }
            else
            {
              uint64_t *v32 = v31;
              unint64_t v34 = v32 + 1;
            }
            v30[635] = v34;
            break;
          case 0xB4:
            unint64_t v35 = *(void **)a1[2];
            uint64_t v36 = *(_DWORD *)(a1[3] + 72) & 0x7FFFFLL;
            uint64_t v37 = (uint64_t *)v35[638];
            unint64_t v38 = v35[639];
            if ((unint64_t)v37 >= v38)
            {
              uint64_t v140 = (uint64_t *)v35[637];
              uint64_t v141 = v37 - v140;
              if ((unint64_t)(v141 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v142 = v38 - (void)v140;
              unint64_t v143 = (uint64_t)(v38 - (void)v140) >> 2;
              if (v143 <= v141 + 1) {
                unint64_t v143 = v141 + 1;
              }
              if (v142 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v144 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v144 = v143;
              }
              if (v144)
              {
                unint64_t v145 = (char *)sub_5714((uint64_t)(v35 + 639), v144);
                uint64_t v37 = (uint64_t *)v35[638];
                uint64_t v140 = (uint64_t *)v35[637];
              }
              else
              {
                unint64_t v145 = 0;
              }
              unint64_t v240 = (uint64_t *)&v145[8 * v141];
              *unint64_t v240 = v36;
              unint64_t v39 = v240 + 1;
              while (v37 != v140)
              {
                uint64_t v241 = *--v37;
                *--unint64_t v240 = v241;
              }
              v35[637] = v240;
              v35[638] = v39;
              v35[639] = &v145[8 * v144];
              if (v140) {
                operator delete(v140);
              }
            }
            else
            {
              uint64_t *v37 = v36;
              unint64_t v39 = v37 + 1;
            }
            v35[638] = v39;
            break;
          case 0xB5:
            unint64_t v40 = *(void **)a1[2];
            uint64_t v41 = *(_DWORD *)(a1[3] + 44) & 0x7FFFFLL;
            uint64_t v42 = (uint64_t *)v40[641];
            unint64_t v43 = v40[642];
            if ((unint64_t)v42 >= v43)
            {
              uint64_t v146 = (uint64_t *)v40[640];
              uint64_t v147 = v42 - v146;
              if ((unint64_t)(v147 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v148 = v43 - (void)v146;
              unint64_t v149 = (uint64_t)(v43 - (void)v146) >> 2;
              if (v149 <= v147 + 1) {
                unint64_t v149 = v147 + 1;
              }
              if (v148 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v150 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v150 = v149;
              }
              if (v150)
              {
                unint64_t v151 = (char *)sub_5714((uint64_t)(v40 + 642), v150);
                uint64_t v42 = (uint64_t *)v40[641];
                uint64_t v146 = (uint64_t *)v40[640];
              }
              else
              {
                unint64_t v151 = 0;
              }
              v242 = (uint64_t *)&v151[8 * v147];
              uint64_t *v242 = v41;
              unint64_t v44 = v242 + 1;
              while (v42 != v146)
              {
                uint64_t v243 = *--v42;
                *--v242 = v243;
              }
              v40[640] = v242;
              v40[641] = v44;
              v40[642] = &v151[8 * v150];
              if (v146) {
                operator delete(v146);
              }
            }
            else
            {
              uint64_t *v42 = v41;
              unint64_t v44 = v42 + 1;
            }
            v40[641] = v44;
            break;
          case 0xB6:
            unint64_t v45 = *(void **)a1[2];
            uint64_t v46 = *(_DWORD *)(a1[3] + 84) & 0x7FFFFLL;
            uint64_t v47 = (uint64_t *)v45[644];
            unint64_t v48 = v45[645];
            if ((unint64_t)v47 >= v48)
            {
              uint64_t v152 = (uint64_t *)v45[643];
              uint64_t v153 = v47 - v152;
              if ((unint64_t)(v153 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v154 = v48 - (void)v152;
              unint64_t v155 = (uint64_t)(v48 - (void)v152) >> 2;
              if (v155 <= v153 + 1) {
                unint64_t v155 = v153 + 1;
              }
              if (v154 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v156 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v156 = v155;
              }
              if (v156)
              {
                unint64_t v157 = (char *)sub_5714((uint64_t)(v45 + 645), v156);
                uint64_t v47 = (uint64_t *)v45[644];
                uint64_t v152 = (uint64_t *)v45[643];
              }
              else
              {
                unint64_t v157 = 0;
              }
              unint64_t v244 = (uint64_t *)&v157[8 * v153];
              *unint64_t v244 = v46;
              uint64_t v49 = v244 + 1;
              while (v47 != v152)
              {
                uint64_t v245 = *--v47;
                *--unint64_t v244 = v245;
              }
              v45[643] = v244;
              v45[644] = v49;
              v45[645] = &v157[8 * v156];
              if (v152) {
                operator delete(v152);
              }
            }
            else
            {
              uint64_t *v47 = v46;
              uint64_t v49 = v47 + 1;
            }
            v45[644] = v49;
            break;
          case 0xB7:
            unint64_t v50 = *(void **)a1[2];
            uint64_t v51 = *(_DWORD *)(a1[3] + 40) & 0x7FFFFLL;
            unint64_t v52 = (uint64_t *)v50[647];
            unint64_t v53 = v50[648];
            if ((unint64_t)v52 >= v53)
            {
              uint64_t v158 = (uint64_t *)v50[646];
              uint64_t v159 = v52 - v158;
              if ((unint64_t)(v159 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v160 = v53 - (void)v158;
              unint64_t v161 = (uint64_t)(v53 - (void)v158) >> 2;
              if (v161 <= v159 + 1) {
                unint64_t v161 = v159 + 1;
              }
              if (v160 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v162 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v162 = v161;
              }
              if (v162)
              {
                unint64_t v163 = (char *)sub_5714((uint64_t)(v50 + 648), v162);
                unint64_t v52 = (uint64_t *)v50[647];
                uint64_t v158 = (uint64_t *)v50[646];
              }
              else
              {
                unint64_t v163 = 0;
              }
              unint64_t v246 = (uint64_t *)&v163[8 * v159];
              *unint64_t v246 = v51;
              unint64_t v54 = v246 + 1;
              while (v52 != v158)
              {
                uint64_t v247 = *--v52;
                *--unint64_t v246 = v247;
              }
              v50[646] = v246;
              v50[647] = v54;
              v50[648] = &v163[8 * v162];
              if (v158) {
                operator delete(v158);
              }
            }
            else
            {
              uint64_t *v52 = v51;
              unint64_t v54 = v52 + 1;
            }
            v50[647] = v54;
            break;
          case 0xB8:
            uint64_t v55 = *(void **)a1[2];
            uint64_t v56 = *(_DWORD *)(a1[3] + 80) & 0x7FFFFLL;
            uint64_t v57 = (uint64_t *)v55[650];
            unint64_t v58 = v55[651];
            if ((unint64_t)v57 >= v58)
            {
              uint64_t v164 = (uint64_t *)v55[649];
              uint64_t v165 = v57 - v164;
              if ((unint64_t)(v165 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v166 = v58 - (void)v164;
              unint64_t v167 = (uint64_t)(v58 - (void)v164) >> 2;
              if (v167 <= v165 + 1) {
                unint64_t v167 = v165 + 1;
              }
              if (v166 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v168 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v168 = v167;
              }
              if (v168)
              {
                unint64_t v169 = (char *)sub_5714((uint64_t)(v55 + 651), v168);
                uint64_t v57 = (uint64_t *)v55[650];
                uint64_t v164 = (uint64_t *)v55[649];
              }
              else
              {
                unint64_t v169 = 0;
              }
              v248 = (uint64_t *)&v169[8 * v165];
              uint64_t *v248 = v56;
              uint64_t v59 = v248 + 1;
              while (v57 != v164)
              {
                uint64_t v249 = *--v57;
                *--v248 = v249;
              }
              v55[649] = v248;
              v55[650] = v59;
              v55[651] = &v169[8 * v168];
              if (v164) {
                operator delete(v164);
              }
            }
            else
            {
              uint64_t *v57 = v56;
              uint64_t v59 = v57 + 1;
            }
            v55[650] = v59;
            break;
          case 0xB9:
            unint64_t v60 = *(void **)a1[2];
            uint64_t v61 = *(_DWORD *)(a1[3] + 56) & 0x7FFFFLL;
            uint64_t v62 = (uint64_t *)v60[653];
            unint64_t v63 = v60[654];
            if ((unint64_t)v62 >= v63)
            {
              uint64_t v170 = (uint64_t *)v60[652];
              uint64_t v171 = v62 - v170;
              if ((unint64_t)(v171 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v172 = v63 - (void)v170;
              unint64_t v173 = (uint64_t)(v63 - (void)v170) >> 2;
              if (v173 <= v171 + 1) {
                unint64_t v173 = v171 + 1;
              }
              if (v172 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v174 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v174 = v173;
              }
              if (v174)
              {
                unint64_t v175 = (char *)sub_5714((uint64_t)(v60 + 654), v174);
                uint64_t v62 = (uint64_t *)v60[653];
                uint64_t v170 = (uint64_t *)v60[652];
              }
              else
              {
                unint64_t v175 = 0;
              }
              unint64_t v250 = (uint64_t *)&v175[8 * v171];
              *unint64_t v250 = v61;
              uint64_t v64 = v250 + 1;
              while (v62 != v170)
              {
                uint64_t v251 = *--v62;
                *--unint64_t v250 = v251;
              }
              v60[652] = v250;
              v60[653] = v64;
              v60[654] = &v175[8 * v174];
              if (v170) {
                operator delete(v170);
              }
            }
            else
            {
              uint64_t *v62 = v61;
              uint64_t v64 = v62 + 1;
            }
            v60[653] = v64;
            break;
          case 0xBA:
            unint64_t v65 = *(void **)a1[2];
            uint64_t v66 = *(_DWORD *)(a1[3] + 96) & 0x7FFFFLL;
            unint64_t v67 = (uint64_t *)v65[656];
            unint64_t v68 = v65[657];
            if ((unint64_t)v67 >= v68)
            {
              uint64_t v176 = (uint64_t *)v65[655];
              uint64_t v177 = v67 - v176;
              if ((unint64_t)(v177 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v178 = v68 - (void)v176;
              unint64_t v179 = (uint64_t)(v68 - (void)v176) >> 2;
              if (v179 <= v177 + 1) {
                unint64_t v179 = v177 + 1;
              }
              if (v178 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v180 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v180 = v179;
              }
              if (v180)
              {
                v181 = (char *)sub_5714((uint64_t)(v65 + 657), v180);
                unint64_t v67 = (uint64_t *)v65[656];
                uint64_t v176 = (uint64_t *)v65[655];
              }
              else
              {
                v181 = 0;
              }
              unint64_t v252 = (uint64_t *)&v181[8 * v177];
              *unint64_t v252 = v66;
              unint64_t v69 = v252 + 1;
              while (v67 != v176)
              {
                uint64_t v253 = *--v67;
                *--unint64_t v252 = v253;
              }
              v65[655] = v252;
              v65[656] = v69;
              v65[657] = &v181[8 * v180];
              if (v176) {
                operator delete(v176);
              }
            }
            else
            {
              uint64_t *v67 = v66;
              unint64_t v69 = v67 + 1;
            }
            v65[656] = v69;
            break;
          case 0xBB:
            uint64_t v70 = *(void **)a1[2];
            uint64_t v71 = *(_DWORD *)(a1[3] + 60) & 0x7FFFFLL;
            uint64_t v72 = (uint64_t *)v70[659];
            unint64_t v73 = v70[660];
            if ((unint64_t)v72 >= v73)
            {
              uint64_t v182 = (uint64_t *)v70[658];
              uint64_t v183 = v72 - v182;
              if ((unint64_t)(v183 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v184 = v73 - (void)v182;
              unint64_t v185 = (uint64_t)(v73 - (void)v182) >> 2;
              if (v185 <= v183 + 1) {
                unint64_t v185 = v183 + 1;
              }
              if (v184 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v186 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v186 = v185;
              }
              if (v186)
              {
                v187 = (char *)sub_5714((uint64_t)(v70 + 660), v186);
                uint64_t v72 = (uint64_t *)v70[659];
                uint64_t v182 = (uint64_t *)v70[658];
              }
              else
              {
                v187 = 0;
              }
              v254 = (uint64_t *)&v187[8 * v183];
              uint64_t *v254 = v71;
              unint64_t v74 = v254 + 1;
              while (v72 != v182)
              {
                uint64_t v255 = *--v72;
                *--v254 = v255;
              }
              v70[658] = v254;
              v70[659] = v74;
              v70[660] = &v187[8 * v186];
              if (v182) {
                operator delete(v182);
              }
            }
            else
            {
              *uint64_t v72 = v71;
              unint64_t v74 = v72 + 1;
            }
            v70[659] = v74;
            break;
          case 0xBC:
            uint64_t v75 = *(void **)a1[2];
            uint64_t v76 = *(_DWORD *)(a1[3] + 52) & 0x7FFFFLL;
            unint64_t v77 = (uint64_t *)v75[662];
            unint64_t v78 = v75[663];
            if ((unint64_t)v77 >= v78)
            {
              uint64_t v188 = (uint64_t *)v75[661];
              uint64_t v189 = v77 - v188;
              if ((unint64_t)(v189 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v190 = v78 - (void)v188;
              unint64_t v191 = (uint64_t)(v78 - (void)v188) >> 2;
              if (v191 <= v189 + 1) {
                unint64_t v191 = v189 + 1;
              }
              if (v190 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v192 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v192 = v191;
              }
              if (v192)
              {
                int v193 = (char *)sub_5714((uint64_t)(v75 + 663), v192);
                unint64_t v77 = (uint64_t *)v75[662];
                uint64_t v188 = (uint64_t *)v75[661];
              }
              else
              {
                int v193 = 0;
              }
              unint64_t v256 = (uint64_t *)&v193[8 * v189];
              *unint64_t v256 = v76;
              v79 = v256 + 1;
              while (v77 != v188)
              {
                uint64_t v257 = *--v77;
                *--unint64_t v256 = v257;
              }
              v75[661] = v256;
              v75[662] = v79;
              v75[663] = &v193[8 * v192];
              if (v188) {
                operator delete(v188);
              }
            }
            else
            {
              *unint64_t v77 = v76;
              v79 = v77 + 1;
            }
            v75[662] = v79;
            break;
          case 0xBD:
            unint64_t v80 = *(void **)a1[2];
            uint64_t v81 = *(_DWORD *)(a1[3] + 92) & 0x7FFFFLL;
            unint64_t v82 = (uint64_t *)v80[665];
            unint64_t v83 = v80[666];
            if ((unint64_t)v82 >= v83)
            {
              uint64_t v194 = (uint64_t *)v80[664];
              uint64_t v195 = v82 - v194;
              if ((unint64_t)(v195 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v196 = v83 - (void)v194;
              unint64_t v197 = (uint64_t)(v83 - (void)v194) >> 2;
              if (v197 <= v195 + 1) {
                unint64_t v197 = v195 + 1;
              }
              if (v196 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v198 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v198 = v197;
              }
              if (v198)
              {
                v199 = (char *)sub_5714((uint64_t)(v80 + 666), v198);
                unint64_t v82 = (uint64_t *)v80[665];
                uint64_t v194 = (uint64_t *)v80[664];
              }
              else
              {
                v199 = 0;
              }
              unint64_t v258 = (uint64_t *)&v199[8 * v195];
              *unint64_t v258 = v81;
              unint64_t v84 = v258 + 1;
              while (v82 != v194)
              {
                uint64_t v259 = *--v82;
                *--unint64_t v258 = v259;
              }
              v80[664] = v258;
              v80[665] = v84;
              v80[666] = &v199[8 * v198];
              if (v194) {
                operator delete(v194);
              }
            }
            else
            {
              *unint64_t v82 = v81;
              unint64_t v84 = v82 + 1;
            }
            v80[665] = v84;
            break;
          case 0xBE:
            unint64_t v85 = *(void **)a1[2];
            uint64_t v86 = *(_DWORD *)(a1[3] + 28) & 0x7FFFFLL;
            unint64_t v87 = (uint64_t *)v85[668];
            unint64_t v88 = v85[669];
            if ((unint64_t)v87 >= v88)
            {
              uint64_t v200 = (uint64_t *)v85[667];
              uint64_t v201 = v87 - v200;
              if ((unint64_t)(v201 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v202 = v88 - (void)v200;
              unint64_t v203 = (uint64_t)(v88 - (void)v200) >> 2;
              if (v203 <= v201 + 1) {
                unint64_t v203 = v201 + 1;
              }
              if (v202 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v204 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v204 = v203;
              }
              if (v204)
              {
                v205 = (char *)sub_5714((uint64_t)(v85 + 669), v204);
                unint64_t v87 = (uint64_t *)v85[668];
                uint64_t v200 = (uint64_t *)v85[667];
              }
              else
              {
                v205 = 0;
              }
              v260 = (uint64_t *)&v205[8 * v201];
              uint64_t *v260 = v86;
              unint64_t v89 = v260 + 1;
              while (v87 != v200)
              {
                uint64_t v261 = *--v87;
                *--v260 = v261;
              }
              v85[667] = v260;
              v85[668] = v89;
              v85[669] = &v205[8 * v204];
              if (v200) {
                operator delete(v200);
              }
            }
            else
            {
              *unint64_t v87 = v86;
              unint64_t v89 = v87 + 1;
            }
            v85[668] = v89;
            break;
          case 0xBF:
            unint64_t v90 = *(void **)a1[2];
            uint64_t v91 = *(_DWORD *)(a1[3] + 68) & 0x7FFFFLL;
            uint64_t v92 = (uint64_t *)v90[671];
            unint64_t v93 = v90[672];
            if ((unint64_t)v92 >= v93)
            {
              uint64_t v206 = (uint64_t *)v90[670];
              uint64_t v207 = v92 - v206;
              if ((unint64_t)(v207 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v208 = v93 - (void)v206;
              unint64_t v209 = (uint64_t)(v93 - (void)v206) >> 2;
              if (v209 <= v207 + 1) {
                unint64_t v209 = v207 + 1;
              }
              if (v208 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v210 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v210 = v209;
              }
              if (v210)
              {
                int v211 = (char *)sub_5714((uint64_t)(v90 + 672), v210);
                uint64_t v92 = (uint64_t *)v90[671];
                uint64_t v206 = (uint64_t *)v90[670];
              }
              else
              {
                int v211 = 0;
              }
              unint64_t v262 = (uint64_t *)&v211[8 * v207];
              *unint64_t v262 = v91;
              uint64_t v94 = v262 + 1;
              while (v92 != v206)
              {
                uint64_t v263 = *--v92;
                *--unint64_t v262 = v263;
              }
              v90[670] = v262;
              v90[671] = v94;
              v90[672] = &v211[8 * v210];
              if (v206) {
                operator delete(v206);
              }
            }
            else
            {
              uint64_t *v92 = v91;
              uint64_t v94 = v92 + 1;
            }
            v90[671] = v94;
            break;
          case 0xC0:
            unint64_t v95 = *(void **)a1[2];
            uint64_t v96 = *(_DWORD *)(a1[3] + 36) & 0x7FFFFLL;
            unint64_t v97 = (uint64_t *)v95[674];
            unint64_t v98 = v95[675];
            if ((unint64_t)v97 >= v98)
            {
              unint64_t v212 = (uint64_t *)v95[673];
              uint64_t v213 = v97 - v212;
              if ((unint64_t)(v213 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v214 = v98 - (void)v212;
              unint64_t v215 = (uint64_t)(v98 - (void)v212) >> 2;
              if (v215 <= v213 + 1) {
                unint64_t v215 = v213 + 1;
              }
              if (v214 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v216 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v216 = v215;
              }
              if (v216)
              {
                v217 = (char *)sub_5714((uint64_t)(v95 + 675), v216);
                unint64_t v97 = (uint64_t *)v95[674];
                unint64_t v212 = (uint64_t *)v95[673];
              }
              else
              {
                v217 = 0;
              }
              unint64_t v264 = (uint64_t *)&v217[8 * v213];
              *unint64_t v264 = v96;
              unint64_t v99 = v264 + 1;
              while (v97 != v212)
              {
                uint64_t v265 = *--v97;
                *--unint64_t v264 = v265;
              }
              v95[673] = v264;
              v95[674] = v99;
              v95[675] = &v217[8 * v216];
              if (v212) {
                operator delete(v212);
              }
            }
            else
            {
              uint64_t *v97 = v96;
              unint64_t v99 = v97 + 1;
            }
            v95[674] = v99;
            break;
          case 0xC1:
            uint64_t v100 = *(void **)a1[2];
            uint64_t v101 = *(_DWORD *)(a1[3] + 76) & 0x7FFFFLL;
            unint64_t v102 = (uint64_t *)v100[677];
            unint64_t v103 = v100[678];
            if ((unint64_t)v102 >= v103)
            {
              v218 = (uint64_t *)v100[676];
              uint64_t v219 = v102 - v218;
              if ((unint64_t)(v219 + 1) >> 61) {
                goto LABEL_378;
              }
              unint64_t v220 = v103 - (void)v218;
              unint64_t v221 = (uint64_t)(v103 - (void)v218) >> 2;
              if (v221 <= v219 + 1) {
                unint64_t v221 = v219 + 1;
              }
              if (v220 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v222 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v222 = v221;
              }
              if (v222)
              {
                v223 = (char *)sub_5714((uint64_t)(v100 + 678), v222);
                unint64_t v102 = (uint64_t *)v100[677];
                v218 = (uint64_t *)v100[676];
              }
              else
              {
                v223 = 0;
              }
              v266 = (uint64_t *)&v223[8 * v219];
              uint64_t *v266 = v101;
              uint64_t v104 = v266 + 1;
              while (v102 != v218)
              {
                uint64_t v267 = *--v102;
                *--v266 = v267;
              }
              v100[676] = v266;
              v100[677] = v104;
              v100[678] = &v223[8 * v222];
              if (v218) {
                operator delete(v218);
              }
            }
            else
            {
              *unint64_t v102 = v101;
              uint64_t v104 = v102 + 1;
            }
            v100[677] = v104;
            break;
          case 0xC2:
            unint64_t v105 = *(void **)a1[2];
            uint64_t v106 = *(_DWORD *)(a1[3] + 100) & 0x7FFFFLL;
            unint64_t v107 = (uint64_t *)v105[680];
            unint64_t v108 = v105[681];
            if ((unint64_t)v107 >= v108)
            {
              v224 = (uint64_t *)v105[679];
              uint64_t v225 = v107 - v224;
              if ((unint64_t)(v225 + 1) >> 61) {
LABEL_378:
              }
                sub_566C();
              unint64_t v226 = v108 - (void)v224;
              unint64_t v227 = (uint64_t)(v108 - (void)v224) >> 2;
              if (v227 <= v225 + 1) {
                unint64_t v227 = v225 + 1;
              }
              if (v226 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v228 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v228 = v227;
              }
              if (v228)
              {
                v229 = (char *)sub_5714((uint64_t)(v105 + 681), v228);
                unint64_t v107 = (uint64_t *)v105[680];
                v224 = (uint64_t *)v105[679];
              }
              else
              {
                v229 = 0;
              }
              unint64_t v268 = (uint64_t *)&v229[8 * v225];
              *unint64_t v268 = v106;
              unint64_t v109 = v268 + 1;
              while (v107 != v224)
              {
                uint64_t v269 = *--v107;
                *--unint64_t v268 = v269;
              }
              v105[679] = v268;
              v105[680] = v109;
              v105[681] = &v229[8 * v228];
              if (v224) {
                operator delete(v224);
              }
            }
            else
            {
              *unint64_t v107 = v106;
              unint64_t v109 = v107 + 1;
            }
            v105[680] = v109;
            break;
          default:
            break;
        }
        ++v7;
      }
      while (v7 != v9);
    }
  }
  *a2 = 1;
}

void sub_1ACFD0(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  if (*a2 == 1)
  {
    unint64_t v258 = (int **)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v257 = *v258;
    uint64_t v259 = (char *)v258[1] - (char *)*v258;
    if (v259)
    {
      unint64_t v260 = v259 >> 2;
      if (v260 <= 1) {
        unint64_t v260 = 1;
      }
      do
      {
        int v261 = *v257++;
        switch(v261)
        {
          case 195:
            uint64_t v262 = *(_WORD *)(a1[3] + 36) & 0x7FFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5464);
            goto LABEL_356;
          case 196:
            uint64_t v262 = *(_DWORD *)(a1[3] + 68) & 0x7FFFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5488);
            goto LABEL_356;
          case 197:
            uint64_t v262 = *(_WORD *)(a1[3] + 42) & 0x7FFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5512);
            goto LABEL_356;
          case 198:
            uint64_t v262 = (unsigned __int16)*(_DWORD *)(a1[3] + 24) >> 1;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5536);
            goto LABEL_356;
          case 199:
            uint64_t v262 = *(_DWORD *)(a1[3] + 44) & 0x7FFFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5560);
            goto LABEL_356;
          case 200:
            uint64_t v262 = *(_WORD *)(a1[3] + 28) & 0x7FFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5584);
            goto LABEL_356;
          case 201:
            uint64_t v262 = *(_DWORD *)(a1[3] + 52) & 0x7FFFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5608);
            goto LABEL_356;
          case 202:
            uint64_t v262 = *(_WORD *)(a1[3] + 34) & 0x7FFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5632);
            goto LABEL_356;
          case 203:
            uint64_t v262 = *(_DWORD *)(a1[3] + 64) & 0x7FFFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5656);
            goto LABEL_356;
          case 204:
            uint64_t v262 = *(_WORD *)(a1[3] + 32) & 0x7FFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5680);
            goto LABEL_356;
          case 205:
            uint64_t v262 = *(_DWORD *)(a1[3] + 60) & 0x7FFFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5704);
            goto LABEL_356;
          case 206:
            uint64_t v262 = *(_WORD *)(a1[3] + 40) & 0x7FFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5728);
            goto LABEL_356;
          case 207:
            uint64_t v262 = *(_DWORD *)(a1[3] + 76) & 0x7FFFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5752);
            goto LABEL_356;
          case 208:
            uint64_t v262 = *(_WORD *)(a1[3] + 38) & 0x7FFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5776);
            goto LABEL_356;
          case 209:
            uint64_t v262 = *(_DWORD *)(a1[3] + 72) & 0x7FFFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5800);
            goto LABEL_356;
          case 210:
            uint64_t v262 = *(_WORD *)(a1[3] + 26) & 0x7FFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5824);
            goto LABEL_356;
          case 211:
            uint64_t v262 = *(_DWORD *)(a1[3] + 48) & 0x7FFFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5848);
            goto LABEL_356;
          case 212:
            uint64_t v262 = *(_WORD *)(a1[3] + 30) & 0x7FFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5872);
            goto LABEL_356;
          case 213:
            uint64_t v262 = *(_DWORD *)(a1[3] + 56) & 0x7FFFF;
            uint64_t v263 = (void *)(*(void *)a1[2] + 5896);
LABEL_356:
            *(void *)(*v263 - 8) += v262;
            break;
          default:
            break;
        }
        --v260;
      }
      while (v260);
    }
  }
  else
  {
    if (*a2) {
      return;
    }
    v5 = (void *)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v6 = v5[1] - *v5;
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = v6 >> 2;
      if (v8 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v8;
      }
      do
      {
        switch(*(_DWORD *)(*v5 + 4 * v7))
        {
          case 0xC3:
            v10 = *(void **)a1[2];
            uint64_t v11 = *(_WORD *)(a1[3] + 36) & 0x7FFF;
            v12 = (char *)v10[683];
            unint64_t v13 = v10[684];
            if ((unint64_t)v12 >= v13)
            {
              unint64_t v105 = (char *)v10[682];
              uint64_t v106 = (v12 - v105) >> 3;
              if ((unint64_t)(v106 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v107 = v13 - (void)v105;
              unint64_t v108 = (uint64_t)(v13 - (void)v105) >> 2;
              if (v108 <= v106 + 1) {
                unint64_t v108 = v106 + 1;
              }
              if (v107 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v109 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v109 = v108;
              }
              if (v109)
              {
                uint64_t v110 = (char *)sub_5714((uint64_t)(v10 + 684), v109);
                v12 = (char *)v10[683];
                unint64_t v105 = (char *)v10[682];
              }
              else
              {
                uint64_t v110 = 0;
              }
              uint64_t v219 = &v110[8 * v106];
              *(void *)uint64_t v219 = v11;
              v14 = v219 + 8;
              while (v12 != v105)
              {
                uint64_t v220 = *((void *)v12 - 1);
                v12 -= 8;
                *((void *)v219 - 1) = v220;
                v219 -= 8;
              }
              v10[682] = v219;
              v10[683] = v14;
              v10[684] = &v110[8 * v109];
              if (v105) {
                operator delete(v105);
              }
            }
            else
            {
              *(void *)v12 = v11;
              v14 = v12 + 8;
            }
            v10[683] = v14;
            break;
          case 0xC4:
            v15 = *(void **)a1[2];
            uint64_t v16 = *(_DWORD *)(a1[3] + 68) & 0x7FFFFLL;
            v17 = (uint64_t *)v15[686];
            unint64_t v18 = v15[687];
            if ((unint64_t)v17 >= v18)
            {
              uint64_t v111 = (uint64_t *)v15[685];
              uint64_t v112 = v17 - v111;
              if ((unint64_t)(v112 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v113 = v18 - (void)v111;
              unint64_t v114 = (uint64_t)(v18 - (void)v111) >> 2;
              if (v114 <= v112 + 1) {
                unint64_t v114 = v112 + 1;
              }
              if (v113 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v115 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v115 = v114;
              }
              if (v115)
              {
                uint64_t v116 = (char *)sub_5714((uint64_t)(v15 + 687), v115);
                v17 = (uint64_t *)v15[686];
                uint64_t v111 = (uint64_t *)v15[685];
              }
              else
              {
                uint64_t v116 = 0;
              }
              unint64_t v221 = (uint64_t *)&v116[8 * v112];
              *unint64_t v221 = v16;
              v19 = v221 + 1;
              while (v17 != v111)
              {
                uint64_t v222 = *--v17;
                *--unint64_t v221 = v222;
              }
              v15[685] = v221;
              v15[686] = v19;
              v15[687] = &v116[8 * v115];
              if (v111) {
                operator delete(v111);
              }
            }
            else
            {
              uint64_t *v17 = v16;
              v19 = v17 + 1;
            }
            v15[686] = v19;
            break;
          case 0xC5:
            uint64_t v20 = *(void **)a1[2];
            uint64_t v21 = *(_WORD *)(a1[3] + 42) & 0x7FFF;
            uint64_t v22 = (char *)v20[689];
            unint64_t v23 = v20[690];
            if ((unint64_t)v22 >= v23)
            {
              uint64_t v117 = (char *)v20[688];
              uint64_t v118 = (v22 - v117) >> 3;
              if ((unint64_t)(v118 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v119 = v23 - (void)v117;
              unint64_t v120 = (uint64_t)(v23 - (void)v117) >> 2;
              if (v120 <= v118 + 1) {
                unint64_t v120 = v118 + 1;
              }
              if (v119 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v121 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v121 = v120;
              }
              if (v121)
              {
                uint64_t v122 = (char *)sub_5714((uint64_t)(v20 + 690), v121);
                uint64_t v22 = (char *)v20[689];
                uint64_t v117 = (char *)v20[688];
              }
              else
              {
                uint64_t v122 = 0;
              }
              v223 = &v122[8 * v118];
              *(void *)v223 = v21;
              unint64_t v24 = v223 + 8;
              while (v22 != v117)
              {
                uint64_t v224 = *((void *)v22 - 1);
                v22 -= 8;
                *((void *)v223 - 1) = v224;
                v223 -= 8;
              }
              v20[688] = v223;
              v20[689] = v24;
              v20[690] = &v122[8 * v121];
              if (v117) {
                operator delete(v117);
              }
            }
            else
            {
              *(void *)uint64_t v22 = v21;
              unint64_t v24 = v22 + 8;
            }
            v20[689] = v24;
            break;
          case 0xC6:
            uint64_t v25 = *(void **)a1[2];
            uint64_t v26 = (unsigned __int16)*(_DWORD *)(a1[3] + 24) >> 1;
            uint64_t v27 = (char *)v25[692];
            unint64_t v28 = v25[693];
            if ((unint64_t)v27 >= v28)
            {
              uint64_t v123 = (char *)v25[691];
              uint64_t v124 = (v27 - v123) >> 3;
              if ((unint64_t)(v124 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v125 = v28 - (void)v123;
              unint64_t v126 = (uint64_t)(v28 - (void)v123) >> 2;
              if (v126 <= v124 + 1) {
                unint64_t v126 = v124 + 1;
              }
              if (v125 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v127 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v127 = v126;
              }
              if (v127)
              {
                uint64_t v128 = (char *)sub_5714((uint64_t)(v25 + 693), v127);
                uint64_t v27 = (char *)v25[692];
                uint64_t v123 = (char *)v25[691];
              }
              else
              {
                uint64_t v128 = 0;
              }
              uint64_t v225 = &v128[8 * v124];
              *(void *)uint64_t v225 = v26;
              unint64_t v29 = v225 + 8;
              while (v27 != v123)
              {
                uint64_t v226 = *((void *)v27 - 1);
                v27 -= 8;
                *((void *)v225 - 1) = v226;
                v225 -= 8;
              }
              v25[691] = v225;
              v25[692] = v29;
              v25[693] = &v128[8 * v127];
              if (v123) {
                operator delete(v123);
              }
            }
            else
            {
              *(void *)uint64_t v27 = v26;
              unint64_t v29 = v27 + 8;
            }
            v25[692] = v29;
            break;
          case 0xC7:
            unint64_t v30 = *(void **)a1[2];
            uint64_t v31 = *(_DWORD *)(a1[3] + 44) & 0x7FFFFLL;
            unint64_t v32 = (uint64_t *)v30[695];
            unint64_t v33 = v30[696];
            if ((unint64_t)v32 >= v33)
            {
              uint64_t v129 = (uint64_t *)v30[694];
              uint64_t v130 = v32 - v129;
              if ((unint64_t)(v130 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v131 = v33 - (void)v129;
              unint64_t v132 = (uint64_t)(v33 - (void)v129) >> 2;
              if (v132 <= v130 + 1) {
                unint64_t v132 = v130 + 1;
              }
              if (v131 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v133 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v133 = v132;
              }
              if (v133)
              {
                uint64_t v134 = (char *)sub_5714((uint64_t)(v30 + 696), v133);
                unint64_t v32 = (uint64_t *)v30[695];
                uint64_t v129 = (uint64_t *)v30[694];
              }
              else
              {
                uint64_t v134 = 0;
              }
              unint64_t v227 = (uint64_t *)&v134[8 * v130];
              *unint64_t v227 = v31;
              unint64_t v34 = v227 + 1;
              while (v32 != v129)
              {
                uint64_t v228 = *--v32;
                *--unint64_t v227 = v228;
              }
              v30[694] = v227;
              v30[695] = v34;
              v30[696] = &v134[8 * v133];
              if (v129) {
                operator delete(v129);
              }
            }
            else
            {
              uint64_t *v32 = v31;
              unint64_t v34 = v32 + 1;
            }
            v30[695] = v34;
            break;
          case 0xC8:
            unint64_t v35 = *(void **)a1[2];
            uint64_t v36 = *(_WORD *)(a1[3] + 28) & 0x7FFF;
            uint64_t v37 = (char *)v35[698];
            unint64_t v38 = v35[699];
            if ((unint64_t)v37 >= v38)
            {
              uint64_t v135 = (char *)v35[697];
              uint64_t v136 = (v37 - v135) >> 3;
              if ((unint64_t)(v136 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v137 = v38 - (void)v135;
              unint64_t v138 = (uint64_t)(v38 - (void)v135) >> 2;
              if (v138 <= v136 + 1) {
                unint64_t v138 = v136 + 1;
              }
              if (v137 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v139 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v139 = v138;
              }
              if (v139)
              {
                uint64_t v140 = (char *)sub_5714((uint64_t)(v35 + 699), v139);
                uint64_t v37 = (char *)v35[698];
                uint64_t v135 = (char *)v35[697];
              }
              else
              {
                uint64_t v140 = 0;
              }
              v229 = &v140[8 * v136];
              *(void *)v229 = v36;
              unint64_t v39 = v229 + 8;
              while (v37 != v135)
              {
                uint64_t v230 = *((void *)v37 - 1);
                v37 -= 8;
                *((void *)v229 - 1) = v230;
                v229 -= 8;
              }
              v35[697] = v229;
              v35[698] = v39;
              v35[699] = &v140[8 * v139];
              if (v135) {
                operator delete(v135);
              }
            }
            else
            {
              *(void *)uint64_t v37 = v36;
              unint64_t v39 = v37 + 8;
            }
            v35[698] = v39;
            break;
          case 0xC9:
            unint64_t v40 = *(void **)a1[2];
            uint64_t v41 = *(_DWORD *)(a1[3] + 52) & 0x7FFFFLL;
            uint64_t v42 = (uint64_t *)v40[701];
            unint64_t v43 = v40[702];
            if ((unint64_t)v42 >= v43)
            {
              uint64_t v141 = (uint64_t *)v40[700];
              uint64_t v142 = v42 - v141;
              if ((unint64_t)(v142 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v143 = v43 - (void)v141;
              unint64_t v144 = (uint64_t)(v43 - (void)v141) >> 2;
              if (v144 <= v142 + 1) {
                unint64_t v144 = v142 + 1;
              }
              if (v143 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v145 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v145 = v144;
              }
              if (v145)
              {
                uint64_t v146 = (char *)sub_5714((uint64_t)(v40 + 702), v145);
                uint64_t v42 = (uint64_t *)v40[701];
                uint64_t v141 = (uint64_t *)v40[700];
              }
              else
              {
                uint64_t v146 = 0;
              }
              uint64_t v231 = (uint64_t *)&v146[8 * v142];
              *uint64_t v231 = v41;
              unint64_t v44 = v231 + 1;
              while (v42 != v141)
              {
                uint64_t v232 = *--v42;
                *--uint64_t v231 = v232;
              }
              v40[700] = v231;
              v40[701] = v44;
              v40[702] = &v146[8 * v145];
              if (v141) {
                operator delete(v141);
              }
            }
            else
            {
              uint64_t *v42 = v41;
              unint64_t v44 = v42 + 1;
            }
            v40[701] = v44;
            break;
          case 0xCA:
            unint64_t v45 = *(void **)a1[2];
            uint64_t v46 = *(_WORD *)(a1[3] + 34) & 0x7FFF;
            uint64_t v47 = (char *)v45[704];
            unint64_t v48 = v45[705];
            if ((unint64_t)v47 >= v48)
            {
              uint64_t v147 = (char *)v45[703];
              uint64_t v148 = (v47 - v147) >> 3;
              if ((unint64_t)(v148 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v149 = v48 - (void)v147;
              unint64_t v150 = (uint64_t)(v48 - (void)v147) >> 2;
              if (v150 <= v148 + 1) {
                unint64_t v150 = v148 + 1;
              }
              if (v149 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v151 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v151 = v150;
              }
              if (v151)
              {
                uint64_t v152 = (char *)sub_5714((uint64_t)(v45 + 705), v151);
                uint64_t v47 = (char *)v45[704];
                uint64_t v147 = (char *)v45[703];
              }
              else
              {
                uint64_t v152 = 0;
              }
              uint64_t v233 = &v152[8 * v148];
              *(void *)uint64_t v233 = v46;
              uint64_t v49 = v233 + 8;
              while (v47 != v147)
              {
                uint64_t v234 = *((void *)v47 - 1);
                v47 -= 8;
                *((void *)v233 - 1) = v234;
                v233 -= 8;
              }
              v45[703] = v233;
              v45[704] = v49;
              v45[705] = &v152[8 * v151];
              if (v147) {
                operator delete(v147);
              }
            }
            else
            {
              *(void *)uint64_t v47 = v46;
              uint64_t v49 = v47 + 8;
            }
            v45[704] = v49;
            break;
          case 0xCB:
            unint64_t v50 = *(void **)a1[2];
            uint64_t v51 = *(_DWORD *)(a1[3] + 64) & 0x7FFFFLL;
            unint64_t v52 = (uint64_t *)v50[707];
            unint64_t v53 = v50[708];
            if ((unint64_t)v52 >= v53)
            {
              uint64_t v153 = (uint64_t *)v50[706];
              uint64_t v154 = v52 - v153;
              if ((unint64_t)(v154 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v155 = v53 - (void)v153;
              unint64_t v156 = (uint64_t)(v53 - (void)v153) >> 2;
              if (v156 <= v154 + 1) {
                unint64_t v156 = v154 + 1;
              }
              if (v155 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v157 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v157 = v156;
              }
              if (v157)
              {
                uint64_t v158 = (char *)sub_5714((uint64_t)(v50 + 708), v157);
                unint64_t v52 = (uint64_t *)v50[707];
                uint64_t v153 = (uint64_t *)v50[706];
              }
              else
              {
                uint64_t v158 = 0;
              }
              unint64_t v235 = (uint64_t *)&v158[8 * v154];
              uint64_t *v235 = v51;
              unint64_t v54 = v235 + 1;
              while (v52 != v153)
              {
                uint64_t v236 = *--v52;
                *--unint64_t v235 = v236;
              }
              v50[706] = v235;
              v50[707] = v54;
              v50[708] = &v158[8 * v157];
              if (v153) {
                operator delete(v153);
              }
            }
            else
            {
              uint64_t *v52 = v51;
              unint64_t v54 = v52 + 1;
            }
            v50[707] = v54;
            break;
          case 0xCC:
            uint64_t v55 = *(void **)a1[2];
            uint64_t v56 = *(_WORD *)(a1[3] + 32) & 0x7FFF;
            uint64_t v57 = (char *)v55[710];
            unint64_t v58 = v55[711];
            if ((unint64_t)v57 >= v58)
            {
              uint64_t v159 = (char *)v55[709];
              uint64_t v160 = (v57 - v159) >> 3;
              if ((unint64_t)(v160 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v161 = v58 - (void)v159;
              unint64_t v162 = (uint64_t)(v58 - (void)v159) >> 2;
              if (v162 <= v160 + 1) {
                unint64_t v162 = v160 + 1;
              }
              if (v161 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v163 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v163 = v162;
              }
              if (v163)
              {
                uint64_t v164 = (char *)sub_5714((uint64_t)(v55 + 711), v163);
                uint64_t v57 = (char *)v55[710];
                uint64_t v159 = (char *)v55[709];
              }
              else
              {
                uint64_t v164 = 0;
              }
              uint64_t v237 = &v164[8 * v160];
              *(void *)uint64_t v237 = v56;
              uint64_t v59 = v237 + 8;
              while (v57 != v159)
              {
                uint64_t v238 = *((void *)v57 - 1);
                v57 -= 8;
                *((void *)v237 - 1) = v238;
                v237 -= 8;
              }
              v55[709] = v237;
              v55[710] = v59;
              v55[711] = &v164[8 * v163];
              if (v159) {
                operator delete(v159);
              }
            }
            else
            {
              *(void *)uint64_t v57 = v56;
              uint64_t v59 = v57 + 8;
            }
            v55[710] = v59;
            break;
          case 0xCD:
            unint64_t v60 = *(void **)a1[2];
            uint64_t v61 = *(_DWORD *)(a1[3] + 60) & 0x7FFFFLL;
            uint64_t v62 = (uint64_t *)v60[713];
            unint64_t v63 = v60[714];
            if ((unint64_t)v62 >= v63)
            {
              uint64_t v165 = (uint64_t *)v60[712];
              uint64_t v166 = v62 - v165;
              if ((unint64_t)(v166 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v167 = v63 - (void)v165;
              unint64_t v168 = (uint64_t)(v63 - (void)v165) >> 2;
              if (v168 <= v166 + 1) {
                unint64_t v168 = v166 + 1;
              }
              if (v167 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v169 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v169 = v168;
              }
              if (v169)
              {
                uint64_t v170 = (char *)sub_5714((uint64_t)(v60 + 714), v169);
                uint64_t v62 = (uint64_t *)v60[713];
                uint64_t v165 = (uint64_t *)v60[712];
              }
              else
              {
                uint64_t v170 = 0;
              }
              uint64_t v239 = (uint64_t *)&v170[8 * v166];
              *uint64_t v239 = v61;
              uint64_t v64 = v239 + 1;
              while (v62 != v165)
              {
                uint64_t v240 = *--v62;
                *--uint64_t v239 = v240;
              }
              v60[712] = v239;
              v60[713] = v64;
              v60[714] = &v170[8 * v169];
              if (v165) {
                operator delete(v165);
              }
            }
            else
            {
              uint64_t *v62 = v61;
              uint64_t v64 = v62 + 1;
            }
            v60[713] = v64;
            break;
          case 0xCE:
            unint64_t v65 = *(void **)a1[2];
            uint64_t v66 = *(_WORD *)(a1[3] + 40) & 0x7FFF;
            unint64_t v67 = (char *)v65[716];
            unint64_t v68 = v65[717];
            if ((unint64_t)v67 >= v68)
            {
              uint64_t v171 = (char *)v65[715];
              uint64_t v172 = (v67 - v171) >> 3;
              if ((unint64_t)(v172 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v173 = v68 - (void)v171;
              unint64_t v174 = (uint64_t)(v68 - (void)v171) >> 2;
              if (v174 <= v172 + 1) {
                unint64_t v174 = v172 + 1;
              }
              if (v173 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v175 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v175 = v174;
              }
              if (v175)
              {
                uint64_t v176 = (char *)sub_5714((uint64_t)(v65 + 717), v175);
                unint64_t v67 = (char *)v65[716];
                uint64_t v171 = (char *)v65[715];
              }
              else
              {
                uint64_t v176 = 0;
              }
              uint64_t v241 = &v176[8 * v172];
              *(void *)uint64_t v241 = v66;
              unint64_t v69 = v241 + 8;
              while (v67 != v171)
              {
                uint64_t v242 = *((void *)v67 - 1);
                v67 -= 8;
                *((void *)v241 - 1) = v242;
                v241 -= 8;
              }
              v65[715] = v241;
              v65[716] = v69;
              v65[717] = &v176[8 * v175];
              if (v171) {
                operator delete(v171);
              }
            }
            else
            {
              *(void *)unint64_t v67 = v66;
              unint64_t v69 = v67 + 8;
            }
            v65[716] = v69;
            break;
          case 0xCF:
            uint64_t v70 = *(void **)a1[2];
            uint64_t v71 = *(_DWORD *)(a1[3] + 76) & 0x7FFFFLL;
            uint64_t v72 = (uint64_t *)v70[719];
            unint64_t v73 = v70[720];
            if ((unint64_t)v72 >= v73)
            {
              uint64_t v177 = (uint64_t *)v70[718];
              uint64_t v178 = v72 - v177;
              if ((unint64_t)(v178 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v179 = v73 - (void)v177;
              unint64_t v180 = (uint64_t)(v73 - (void)v177) >> 2;
              if (v180 <= v178 + 1) {
                unint64_t v180 = v178 + 1;
              }
              if (v179 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v181 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v181 = v180;
              }
              if (v181)
              {
                uint64_t v182 = (char *)sub_5714((uint64_t)(v70 + 720), v181);
                uint64_t v72 = (uint64_t *)v70[719];
                uint64_t v177 = (uint64_t *)v70[718];
              }
              else
              {
                uint64_t v182 = 0;
              }
              uint64_t v243 = (uint64_t *)&v182[8 * v178];
              *uint64_t v243 = v71;
              unint64_t v74 = v243 + 1;
              while (v72 != v177)
              {
                uint64_t v244 = *--v72;
                *--uint64_t v243 = v244;
              }
              v70[718] = v243;
              v70[719] = v74;
              v70[720] = &v182[8 * v181];
              if (v177) {
                operator delete(v177);
              }
            }
            else
            {
              *uint64_t v72 = v71;
              unint64_t v74 = v72 + 1;
            }
            v70[719] = v74;
            break;
          case 0xD0:
            uint64_t v75 = *(void **)a1[2];
            uint64_t v76 = *(_WORD *)(a1[3] + 38) & 0x7FFF;
            unint64_t v77 = (char *)v75[722];
            unint64_t v78 = v75[723];
            if ((unint64_t)v77 >= v78)
            {
              uint64_t v183 = (char *)v75[721];
              uint64_t v184 = (v77 - v183) >> 3;
              if ((unint64_t)(v184 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v185 = v78 - (void)v183;
              unint64_t v186 = (uint64_t)(v78 - (void)v183) >> 2;
              if (v186 <= v184 + 1) {
                unint64_t v186 = v184 + 1;
              }
              if (v185 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v187 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v187 = v186;
              }
              if (v187)
              {
                uint64_t v188 = (char *)sub_5714((uint64_t)(v75 + 723), v187);
                unint64_t v77 = (char *)v75[722];
                uint64_t v183 = (char *)v75[721];
              }
              else
              {
                uint64_t v188 = 0;
              }
              uint64_t v245 = &v188[8 * v184];
              *(void *)uint64_t v245 = v76;
              v79 = v245 + 8;
              while (v77 != v183)
              {
                uint64_t v246 = *((void *)v77 - 1);
                v77 -= 8;
                *((void *)v245 - 1) = v246;
                v245 -= 8;
              }
              v75[721] = v245;
              v75[722] = v79;
              v75[723] = &v188[8 * v187];
              if (v183) {
                operator delete(v183);
              }
            }
            else
            {
              *(void *)unint64_t v77 = v76;
              v79 = v77 + 8;
            }
            v75[722] = v79;
            break;
          case 0xD1:
            unint64_t v80 = *(void **)a1[2];
            uint64_t v81 = *(_DWORD *)(a1[3] + 72) & 0x7FFFFLL;
            unint64_t v82 = (uint64_t *)v80[725];
            unint64_t v83 = v80[726];
            if ((unint64_t)v82 >= v83)
            {
              uint64_t v189 = (uint64_t *)v80[724];
              uint64_t v190 = v82 - v189;
              if ((unint64_t)(v190 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v191 = v83 - (void)v189;
              unint64_t v192 = (uint64_t)(v83 - (void)v189) >> 2;
              if (v192 <= v190 + 1) {
                unint64_t v192 = v190 + 1;
              }
              if (v191 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v193 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v193 = v192;
              }
              if (v193)
              {
                uint64_t v194 = (char *)sub_5714((uint64_t)(v80 + 726), v193);
                unint64_t v82 = (uint64_t *)v80[725];
                uint64_t v189 = (uint64_t *)v80[724];
              }
              else
              {
                uint64_t v194 = 0;
              }
              uint64_t v247 = (uint64_t *)&v194[8 * v190];
              uint64_t *v247 = v81;
              unint64_t v84 = v247 + 1;
              while (v82 != v189)
              {
                uint64_t v248 = *--v82;
                *--uint64_t v247 = v248;
              }
              v80[724] = v247;
              v80[725] = v84;
              v80[726] = &v194[8 * v193];
              if (v189) {
                operator delete(v189);
              }
            }
            else
            {
              *unint64_t v82 = v81;
              unint64_t v84 = v82 + 1;
            }
            v80[725] = v84;
            break;
          case 0xD2:
            unint64_t v85 = *(void **)a1[2];
            uint64_t v86 = *(_WORD *)(a1[3] + 26) & 0x7FFF;
            unint64_t v87 = (char *)v85[728];
            unint64_t v88 = v85[729];
            if ((unint64_t)v87 >= v88)
            {
              uint64_t v195 = (char *)v85[727];
              uint64_t v196 = (v87 - v195) >> 3;
              if ((unint64_t)(v196 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v197 = v88 - (void)v195;
              unint64_t v198 = (uint64_t)(v88 - (void)v195) >> 2;
              if (v198 <= v196 + 1) {
                unint64_t v198 = v196 + 1;
              }
              if (v197 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v199 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v199 = v198;
              }
              if (v199)
              {
                uint64_t v200 = (char *)sub_5714((uint64_t)(v85 + 729), v199);
                unint64_t v87 = (char *)v85[728];
                uint64_t v195 = (char *)v85[727];
              }
              else
              {
                uint64_t v200 = 0;
              }
              uint64_t v249 = &v200[8 * v196];
              *(void *)uint64_t v249 = v86;
              unint64_t v89 = v249 + 8;
              while (v87 != v195)
              {
                uint64_t v250 = *((void *)v87 - 1);
                v87 -= 8;
                *((void *)v249 - 1) = v250;
                v249 -= 8;
              }
              v85[727] = v249;
              v85[728] = v89;
              v85[729] = &v200[8 * v199];
              if (v195) {
                operator delete(v195);
              }
            }
            else
            {
              *(void *)unint64_t v87 = v86;
              unint64_t v89 = v87 + 8;
            }
            v85[728] = v89;
            break;
          case 0xD3:
            unint64_t v90 = *(void **)a1[2];
            uint64_t v91 = *(_DWORD *)(a1[3] + 48) & 0x7FFFFLL;
            uint64_t v92 = (uint64_t *)v90[731];
            unint64_t v93 = v90[732];
            if ((unint64_t)v92 >= v93)
            {
              uint64_t v201 = (uint64_t *)v90[730];
              uint64_t v202 = v92 - v201;
              if ((unint64_t)(v202 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v203 = v93 - (void)v201;
              unint64_t v204 = (uint64_t)(v93 - (void)v201) >> 2;
              if (v204 <= v202 + 1) {
                unint64_t v204 = v202 + 1;
              }
              if (v203 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v205 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v205 = v204;
              }
              if (v205)
              {
                uint64_t v206 = (char *)sub_5714((uint64_t)(v90 + 732), v205);
                uint64_t v92 = (uint64_t *)v90[731];
                uint64_t v201 = (uint64_t *)v90[730];
              }
              else
              {
                uint64_t v206 = 0;
              }
              uint64_t v251 = (uint64_t *)&v206[8 * v202];
              *uint64_t v251 = v91;
              uint64_t v94 = v251 + 1;
              while (v92 != v201)
              {
                uint64_t v252 = *--v92;
                *--uint64_t v251 = v252;
              }
              v90[730] = v251;
              v90[731] = v94;
              v90[732] = &v206[8 * v205];
              if (v201) {
                operator delete(v201);
              }
            }
            else
            {
              uint64_t *v92 = v91;
              uint64_t v94 = v92 + 1;
            }
            v90[731] = v94;
            break;
          case 0xD4:
            unint64_t v95 = *(void **)a1[2];
            uint64_t v96 = *(_WORD *)(a1[3] + 30) & 0x7FFF;
            unint64_t v97 = (char *)v95[734];
            unint64_t v98 = v95[735];
            if ((unint64_t)v97 >= v98)
            {
              uint64_t v207 = (char *)v95[733];
              uint64_t v208 = (v97 - v207) >> 3;
              if ((unint64_t)(v208 + 1) >> 61) {
                goto LABEL_360;
              }
              unint64_t v209 = v98 - (void)v207;
              unint64_t v210 = (uint64_t)(v98 - (void)v207) >> 2;
              if (v210 <= v208 + 1) {
                unint64_t v210 = v208 + 1;
              }
              if (v209 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v211 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v211 = v210;
              }
              if (v211)
              {
                unint64_t v212 = (char *)sub_5714((uint64_t)(v95 + 735), v211);
                unint64_t v97 = (char *)v95[734];
                uint64_t v207 = (char *)v95[733];
              }
              else
              {
                unint64_t v212 = 0;
              }
              uint64_t v253 = &v212[8 * v208];
              *(void *)uint64_t v253 = v96;
              unint64_t v99 = v253 + 8;
              while (v97 != v207)
              {
                uint64_t v254 = *((void *)v97 - 1);
                v97 -= 8;
                *((void *)v253 - 1) = v254;
                v253 -= 8;
              }
              v95[733] = v253;
              v95[734] = v99;
              v95[735] = &v212[8 * v211];
              if (v207) {
                operator delete(v207);
              }
            }
            else
            {
              *(void *)unint64_t v97 = v96;
              unint64_t v99 = v97 + 8;
            }
            v95[734] = v99;
            break;
          case 0xD5:
            uint64_t v100 = *(void **)a1[2];
            uint64_t v101 = *(_DWORD *)(a1[3] + 56) & 0x7FFFFLL;
            unint64_t v102 = (uint64_t *)v100[737];
            unint64_t v103 = v100[738];
            if ((unint64_t)v102 >= v103)
            {
              uint64_t v213 = (uint64_t *)v100[736];
              uint64_t v214 = v102 - v213;
              if ((unint64_t)(v214 + 1) >> 61) {
LABEL_360:
              }
                sub_566C();
              unint64_t v215 = v103 - (void)v213;
              unint64_t v216 = (uint64_t)(v103 - (void)v213) >> 2;
              if (v216 <= v214 + 1) {
                unint64_t v216 = v214 + 1;
              }
              if (v215 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v217 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v217 = v216;
              }
              if (v217)
              {
                v218 = (char *)sub_5714((uint64_t)(v100 + 738), v217);
                unint64_t v102 = (uint64_t *)v100[737];
                uint64_t v213 = (uint64_t *)v100[736];
              }
              else
              {
                v218 = 0;
              }
              uint64_t v255 = (uint64_t *)&v218[8 * v214];
              *uint64_t v255 = v101;
              uint64_t v104 = v255 + 1;
              while (v102 != v213)
              {
                uint64_t v256 = *--v102;
                *--uint64_t v255 = v256;
              }
              v100[736] = v255;
              v100[737] = v104;
              v100[738] = &v218[8 * v217];
              if (v213) {
                operator delete(v213);
              }
            }
            else
            {
              *unint64_t v102 = v101;
              uint64_t v104 = v102 + 1;
            }
            v100[737] = v104;
            break;
          default:
            break;
        }
        ++v7;
      }
      while (v7 != v9);
    }
  }
  *a2 = 1;
}

void sub_1AE2A4(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  if (*a2 == 1)
  {
    unint64_t v78 = (int **)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    unint64_t v77 = *v78;
    uint64_t v79 = (char *)v78[1] - (char *)*v78;
    if (v79)
    {
      unint64_t v80 = v79 >> 2;
      if (v80 <= 1) {
        unint64_t v80 = 1;
      }
      do
      {
        int v81 = *v77++;
        switch(v81)
        {
          case 28:
            unint64_t v82 = (unint64_t)*(unsigned int *)(a1[3] + 32) >> 17;
            unint64_t v83 = (void *)(*(void *)a1[2] + 1456);
            goto LABEL_104;
          case 29:
            unint64_t v82 = *(_DWORD *)(a1[3] + 32) & 0x1FFFF;
            unint64_t v83 = (void *)(*(void *)a1[2] + 1480);
            goto LABEL_104;
          case 30:
            unint64_t v82 = *(_DWORD *)(a1[3] + 28) & 0x1FFFF;
            unint64_t v83 = (void *)(*(void *)a1[2] + 1504);
            goto LABEL_104;
          case 31:
            unint64_t v82 = *(unsigned __int16 *)(a1[3] + 26);
            unint64_t v83 = (void *)(*(void *)a1[2] + 1528);
            goto LABEL_104;
          case 32:
            unint64_t v82 = *(unsigned __int16 *)(a1[3] + 24);
            unint64_t v83 = (void *)(*(void *)a1[2] + 1552);
LABEL_104:
            *(void *)(*v83 - 8) += v82;
            break;
          default:
            break;
        }
        --v80;
      }
      while (v80);
    }
  }
  else
  {
    if (*a2) {
      return;
    }
    v5 = (void *)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v6 = v5[1] - *v5;
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = v6 >> 2;
      if (v8 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v8;
      }
      do
      {
        switch(*(_DWORD *)(*v5 + 4 * v7))
        {
          case 0x1C:
            v10 = *(void **)a1[2];
            unint64_t v11 = (unint64_t)*(unsigned int *)(a1[3] + 32) >> 17;
            v12 = (unint64_t *)v10[182];
            unint64_t v13 = v10[183];
            if ((unint64_t)v12 >= v13)
            {
              uint64_t v37 = (unint64_t *)v10[181];
              uint64_t v38 = v12 - v37;
              if ((unint64_t)(v38 + 1) >> 61) {
                goto LABEL_108;
              }
              unint64_t v39 = v13 - (void)v37;
              unint64_t v40 = (uint64_t)(v13 - (void)v37) >> 2;
              if (v40 <= v38 + 1) {
                unint64_t v40 = v38 + 1;
              }
              if (v39 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v41 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v41 = v40;
              }
              if (v41)
              {
                uint64_t v42 = (char *)sub_5714((uint64_t)(v10 + 183), v41);
                v12 = (unint64_t *)v10[182];
                uint64_t v37 = (unint64_t *)v10[181];
              }
              else
              {
                uint64_t v42 = 0;
              }
              unint64_t v67 = (unint64_t *)&v42[8 * v38];
              unint64_t *v67 = v11;
              v14 = v67 + 1;
              while (v12 != v37)
              {
                unint64_t v68 = *--v12;
                *--unint64_t v67 = v68;
              }
              v10[181] = v67;
              v10[182] = v14;
              v10[183] = &v42[8 * v41];
              if (v37) {
                operator delete(v37);
              }
            }
            else
            {
              unint64_t *v12 = v11;
              v14 = v12 + 1;
            }
            v10[182] = v14;
            break;
          case 0x1D:
            v15 = *(void **)a1[2];
            uint64_t v16 = *(_DWORD *)(a1[3] + 32) & 0x1FFFFLL;
            v17 = (uint64_t *)v15[185];
            unint64_t v18 = v15[186];
            if ((unint64_t)v17 >= v18)
            {
              unint64_t v43 = (uint64_t *)v15[184];
              uint64_t v44 = v17 - v43;
              if ((unint64_t)(v44 + 1) >> 61) {
                goto LABEL_108;
              }
              unint64_t v45 = v18 - (void)v43;
              unint64_t v46 = (uint64_t)(v18 - (void)v43) >> 2;
              if (v46 <= v44 + 1) {
                unint64_t v46 = v44 + 1;
              }
              if (v45 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v47 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v47 = v46;
              }
              if (v47)
              {
                unint64_t v48 = (char *)sub_5714((uint64_t)(v15 + 186), v47);
                v17 = (uint64_t *)v15[185];
                unint64_t v43 = (uint64_t *)v15[184];
              }
              else
              {
                unint64_t v48 = 0;
              }
              unint64_t v69 = (uint64_t *)&v48[8 * v44];
              *unint64_t v69 = v16;
              v19 = v69 + 1;
              while (v17 != v43)
              {
                uint64_t v70 = *--v17;
                *--unint64_t v69 = v70;
              }
              v15[184] = v69;
              v15[185] = v19;
              v15[186] = &v48[8 * v47];
              if (v43) {
                operator delete(v43);
              }
            }
            else
            {
              uint64_t *v17 = v16;
              v19 = v17 + 1;
            }
            v15[185] = v19;
            break;
          case 0x1E:
            uint64_t v20 = *(void **)a1[2];
            uint64_t v21 = *(_DWORD *)(a1[3] + 28) & 0x1FFFFLL;
            uint64_t v22 = (uint64_t *)v20[188];
            unint64_t v23 = v20[189];
            if ((unint64_t)v22 >= v23)
            {
              uint64_t v49 = (uint64_t *)v20[187];
              uint64_t v50 = v22 - v49;
              if ((unint64_t)(v50 + 1) >> 61) {
                goto LABEL_108;
              }
              unint64_t v51 = v23 - (void)v49;
              unint64_t v52 = (uint64_t)(v23 - (void)v49) >> 2;
              if (v52 <= v50 + 1) {
                unint64_t v52 = v50 + 1;
              }
              if (v51 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v53 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v53 = v52;
              }
              if (v53)
              {
                unint64_t v54 = (char *)sub_5714((uint64_t)(v20 + 189), v53);
                uint64_t v22 = (uint64_t *)v20[188];
                uint64_t v49 = (uint64_t *)v20[187];
              }
              else
              {
                unint64_t v54 = 0;
              }
              uint64_t v71 = (uint64_t *)&v54[8 * v50];
              *uint64_t v71 = v21;
              unint64_t v24 = v71 + 1;
              while (v22 != v49)
              {
                uint64_t v72 = *--v22;
                *--uint64_t v71 = v72;
              }
              v20[187] = v71;
              v20[188] = v24;
              v20[189] = &v54[8 * v53];
              if (v49) {
                operator delete(v49);
              }
            }
            else
            {
              uint64_t *v22 = v21;
              unint64_t v24 = v22 + 1;
            }
            v20[188] = v24;
            break;
          case 0x1F:
            uint64_t v25 = a1[2];
            uint64_t v26 = *(void **)v25;
            uint64_t v27 = *(unsigned __int16 *)(a1[3] + 26);
            unint64_t v28 = *(char **)(*(void *)v25 + 1528);
            unint64_t v29 = *(void *)(*(void *)v25 + 1536);
            if ((unint64_t)v28 >= v29)
            {
              uint64_t v55 = (char *)v26[190];
              uint64_t v56 = (v28 - v55) >> 3;
              if ((unint64_t)(v56 + 1) >> 61) {
                goto LABEL_108;
              }
              unint64_t v57 = v29 - (void)v55;
              unint64_t v58 = (uint64_t)(v29 - (void)v55) >> 2;
              if (v58 <= v56 + 1) {
                unint64_t v58 = v56 + 1;
              }
              if (v57 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v59 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v59 = v58;
              }
              if (v59)
              {
                unint64_t v60 = (char *)sub_5714((uint64_t)(v26 + 192), v59);
                unint64_t v28 = (char *)v26[191];
                uint64_t v55 = (char *)v26[190];
              }
              else
              {
                unint64_t v60 = 0;
              }
              unint64_t v73 = &v60[8 * v56];
              *(void *)unint64_t v73 = v27;
              unint64_t v30 = v73 + 8;
              while (v28 != v55)
              {
                uint64_t v74 = *((void *)v28 - 1);
                v28 -= 8;
                *((void *)v73 - 1) = v74;
                v73 -= 8;
              }
              v26[190] = v73;
              v26[191] = v30;
              v26[192] = &v60[8 * v59];
              if (v55) {
                operator delete(v55);
              }
            }
            else
            {
              *(void *)unint64_t v28 = v27;
              unint64_t v30 = v28 + 8;
            }
            v26[191] = v30;
            break;
          case 0x20:
            uint64_t v31 = a1[2];
            unint64_t v32 = *(void **)v31;
            uint64_t v33 = *(unsigned __int16 *)(a1[3] + 24);
            unint64_t v34 = *(char **)(*(void *)v31 + 1552);
            unint64_t v35 = *(void *)(*(void *)v31 + 1560);
            if ((unint64_t)v34 >= v35)
            {
              uint64_t v61 = (char *)v32[193];
              uint64_t v62 = (v34 - v61) >> 3;
              if ((unint64_t)(v62 + 1) >> 61) {
LABEL_108:
              }
                sub_566C();
              unint64_t v63 = v35 - (void)v61;
              unint64_t v64 = (uint64_t)(v35 - (void)v61) >> 2;
              if (v64 <= v62 + 1) {
                unint64_t v64 = v62 + 1;
              }
              if (v63 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v65 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v65 = v64;
              }
              if (v65)
              {
                uint64_t v66 = (char *)sub_5714((uint64_t)(v32 + 195), v65);
                unint64_t v34 = (char *)v32[194];
                uint64_t v61 = (char *)v32[193];
              }
              else
              {
                uint64_t v66 = 0;
              }
              uint64_t v75 = &v66[8 * v62];
              *(void *)uint64_t v75 = v33;
              uint64_t v36 = v75 + 8;
              while (v34 != v61)
              {
                uint64_t v76 = *((void *)v34 - 1);
                v34 -= 8;
                *((void *)v75 - 1) = v76;
                v75 -= 8;
              }
              v32[193] = v75;
              v32[194] = v36;
              v32[195] = &v66[8 * v65];
              if (v61) {
                operator delete(v61);
              }
            }
            else
            {
              *(void *)unint64_t v34 = v33;
              uint64_t v36 = v34 + 8;
            }
            v32[194] = v36;
            break;
          default:
            break;
        }
        ++v7;
      }
      while (v7 != v9);
    }
  }
  *a2 = 1;
}

void sub_1AE844(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  if (*a2 == 1)
  {
    v427 = (int **)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    v426 = *v427;
    uint64_t v428 = (char *)v427[1] - (char *)*v427;
    if (v428)
    {
      unint64_t v429 = v428 >> 2;
      if (v429 <= 1) {
        unint64_t v429 = 1;
      }
      do
      {
        int v430 = *v426++;
        switch(v430)
        {
          case 'J':
            LOWORD(v431) = *(_WORD *)(a1[3] + 82);
            v432 = (void *)(*(void *)a1[2] + 2560);
            goto LABEL_590;
          case 'K':
            LOWORD(v431) = *(_WORD *)(a1[3] + 66);
            v432 = (void *)(*(void *)a1[2] + 2584);
            goto LABEL_590;
          case 'L':
            LOWORD(v431) = *(_WORD *)(a1[3] + 50);
            v432 = (void *)(*(void *)a1[2] + 2608);
            goto LABEL_590;
          case 'M':
            LOWORD(v431) = *(_WORD *)(a1[3] + 34);
            v432 = (void *)(*(void *)a1[2] + 2632);
            goto LABEL_590;
          case 'N':
            LOWORD(v431) = *(_WORD *)(a1[3] + 84);
            v432 = (void *)(*(void *)a1[2] + 2656);
            goto LABEL_590;
          case 'O':
            LOWORD(v431) = *(_WORD *)(a1[3] + 68);
            v432 = (void *)(*(void *)a1[2] + 2680);
            goto LABEL_590;
          case 'P':
            LOWORD(v431) = *(_WORD *)(a1[3] + 52);
            v432 = (void *)(*(void *)a1[2] + 2704);
            goto LABEL_590;
          case 'Q':
            LOWORD(v431) = *(_WORD *)(a1[3] + 36);
            v432 = (void *)(*(void *)a1[2] + 2728);
            goto LABEL_590;
          case 'R':
            LOWORD(v431) = *(_WORD *)(a1[3] + 86);
            v432 = (void *)(*(void *)a1[2] + 2752);
            goto LABEL_590;
          case 'S':
            LOWORD(v431) = *(_WORD *)(a1[3] + 70);
            v432 = (void *)(*(void *)a1[2] + 2776);
            goto LABEL_590;
          case 'T':
            LOWORD(v431) = *(_WORD *)(a1[3] + 54);
            v432 = (void *)(*(void *)a1[2] + 2800);
            goto LABEL_590;
          case 'U':
            LOWORD(v431) = *(_WORD *)(a1[3] + 38);
            v432 = (void *)(*(void *)a1[2] + 2824);
            goto LABEL_590;
          case 'V':
            LOWORD(v431) = *(_WORD *)(a1[3] + 76);
            v432 = (void *)(*(void *)a1[2] + 2848);
            goto LABEL_590;
          case 'W':
            LOWORD(v431) = *(_WORD *)(a1[3] + 60);
            v432 = (void *)(*(void *)a1[2] + 2872);
            goto LABEL_590;
          case 'X':
            LOWORD(v431) = *(_WORD *)(a1[3] + 44);
            v432 = (void *)(*(void *)a1[2] + 2896);
            goto LABEL_590;
          case 'Y':
            LOWORD(v431) = *(_WORD *)(a1[3] + 28);
            v432 = (void *)(*(void *)a1[2] + 2920);
            goto LABEL_590;
          case 'Z':
            LOWORD(v431) = *(_WORD *)(a1[3] + 78);
            v432 = (void *)(*(void *)a1[2] + 2944);
            goto LABEL_590;
          case '[':
            LOWORD(v431) = *(_WORD *)(a1[3] + 62);
            v432 = (void *)(*(void *)a1[2] + 2968);
            goto LABEL_590;
          case '\\':
            LOWORD(v431) = *(_WORD *)(a1[3] + 46);
            v432 = (void *)(*(void *)a1[2] + 2992);
            goto LABEL_590;
          case ']':
            LOWORD(v431) = *(_WORD *)(a1[3] + 30);
            v432 = (void *)(*(void *)a1[2] + 3016);
            goto LABEL_590;
          case '^':
            LOWORD(v431) = *(_WORD *)(a1[3] + 80);
            v432 = (void *)(*(void *)a1[2] + 3040);
            goto LABEL_590;
          case '_':
            LOWORD(v431) = *(_WORD *)(a1[3] + 64);
            v432 = (void *)(*(void *)a1[2] + 3064);
            goto LABEL_590;
            LOWORD(v431) = *(_WORD *)(a1[3] + 48);
            v432 = (void *)(*(void *)a1[2] + 3088);
            goto LABEL_590;
          case 'a':
            LOWORD(v431) = *(_WORD *)(a1[3] + 32);
            v432 = (void *)(*(void *)a1[2] + 3112);
            goto LABEL_590;
          case 'b':
            LOWORD(v431) = *(_WORD *)(a1[3] + 72);
            v432 = (void *)(*(void *)a1[2] + 3136);
            goto LABEL_590;
          case 'c':
            LOWORD(v431) = *(_WORD *)(a1[3] + 56);
            v432 = (void *)(*(void *)a1[2] + 3160);
            goto LABEL_590;
          case 'd':
            LOWORD(v431) = *(_WORD *)(a1[3] + 40);
            v432 = (void *)(*(void *)a1[2] + 3184);
            goto LABEL_590;
          case 'e':
            int v431 = *(unsigned __int16 *)(a1[3] + 24) >> 1;
            v432 = (void *)(*(void *)a1[2] + 3208);
            goto LABEL_590;
          case 'f':
            LOWORD(v431) = *(_WORD *)(a1[3] + 74);
            v432 = (void *)(*(void *)a1[2] + 3232);
            goto LABEL_590;
          case 'g':
            LOWORD(v431) = *(_WORD *)(a1[3] + 58);
            v432 = (void *)(*(void *)a1[2] + 3256);
            goto LABEL_590;
          case 'h':
            LOWORD(v431) = *(_WORD *)(a1[3] + 42);
            v432 = (void *)(*(void *)a1[2] + 3280);
            goto LABEL_590;
          case 'i':
            LOWORD(v431) = *(_WORD *)(a1[3] + 26);
            v432 = (void *)(*(void *)a1[2] + 3304);
LABEL_590:
            *(void *)(*v432 - 8) += v431 & 0x1FFF;
            break;
          default:
            break;
        }
        --v429;
      }
      while (v429);
    }
  }
  else
  {
    if (*a2) {
      return;
    }
    v5 = (void *)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v6 = v5[1] - *v5;
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = v6 >> 2;
      if (v8 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v8;
      }
      do
      {
        switch(*(_DWORD *)(*v5 + 4 * v7))
        {
          case 'J':
            v10 = *(void **)a1[2];
            uint64_t v11 = *(_WORD *)(a1[3] + 82) & 0x1FFF;
            v12 = (char *)v10[320];
            unint64_t v13 = v10[321];
            if ((unint64_t)v12 >= v13)
            {
              uint64_t v170 = (char *)v10[319];
              uint64_t v171 = (v12 - v170) >> 3;
              if ((unint64_t)(v171 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v172 = v13 - (void)v170;
              unint64_t v173 = (uint64_t)(v13 - (void)v170) >> 2;
              if (v173 <= v171 + 1) {
                unint64_t v173 = v171 + 1;
              }
              if (v172 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v174 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v174 = v173;
              }
              if (v174)
              {
                unint64_t v175 = (char *)sub_5714((uint64_t)(v10 + 321), v174);
                v12 = (char *)v10[320];
                uint64_t v170 = (char *)v10[319];
              }
              else
              {
                unint64_t v175 = 0;
              }
              v362 = &v175[8 * v171];
              *(void *)v362 = v11;
              v14 = v362 + 8;
              while (v12 != v170)
              {
                uint64_t v363 = *((void *)v12 - 1);
                v12 -= 8;
                *((void *)v362 - 1) = v363;
                v362 -= 8;
              }
              v10[319] = v362;
              v10[320] = v14;
              v10[321] = &v175[8 * v174];
              if (v170) {
                operator delete(v170);
              }
            }
            else
            {
              *(void *)v12 = v11;
              v14 = v12 + 8;
            }
            v10[320] = v14;
            break;
          case 'K':
            v15 = *(void **)a1[2];
            uint64_t v16 = *(_WORD *)(a1[3] + 66) & 0x1FFF;
            v17 = (char *)v15[323];
            unint64_t v18 = v15[324];
            if ((unint64_t)v17 >= v18)
            {
              uint64_t v176 = (char *)v15[322];
              uint64_t v177 = (v17 - v176) >> 3;
              if ((unint64_t)(v177 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v178 = v18 - (void)v176;
              unint64_t v179 = (uint64_t)(v18 - (void)v176) >> 2;
              if (v179 <= v177 + 1) {
                unint64_t v179 = v177 + 1;
              }
              if (v178 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v180 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v180 = v179;
              }
              if (v180)
              {
                unint64_t v181 = (char *)sub_5714((uint64_t)(v15 + 324), v180);
                v17 = (char *)v15[323];
                uint64_t v176 = (char *)v15[322];
              }
              else
              {
                unint64_t v181 = 0;
              }
              v364 = &v181[8 * v177];
              *(void *)v364 = v16;
              v19 = v364 + 8;
              while (v17 != v176)
              {
                uint64_t v365 = *((void *)v17 - 1);
                v17 -= 8;
                *((void *)v364 - 1) = v365;
                v364 -= 8;
              }
              v15[322] = v364;
              v15[323] = v19;
              v15[324] = &v181[8 * v180];
              if (v176) {
                operator delete(v176);
              }
            }
            else
            {
              *(void *)v17 = v16;
              v19 = v17 + 8;
            }
            v15[323] = v19;
            break;
          case 'L':
            uint64_t v20 = *(void **)a1[2];
            uint64_t v21 = *(_WORD *)(a1[3] + 50) & 0x1FFF;
            uint64_t v22 = (char *)v20[326];
            unint64_t v23 = v20[327];
            if ((unint64_t)v22 >= v23)
            {
              uint64_t v182 = (char *)v20[325];
              uint64_t v183 = (v22 - v182) >> 3;
              if ((unint64_t)(v183 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v184 = v23 - (void)v182;
              unint64_t v185 = (uint64_t)(v23 - (void)v182) >> 2;
              if (v185 <= v183 + 1) {
                unint64_t v185 = v183 + 1;
              }
              if (v184 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v186 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v186 = v185;
              }
              if (v186)
              {
                unint64_t v187 = (char *)sub_5714((uint64_t)(v20 + 327), v186);
                uint64_t v22 = (char *)v20[326];
                uint64_t v182 = (char *)v20[325];
              }
              else
              {
                unint64_t v187 = 0;
              }
              v366 = &v187[8 * v183];
              *(void *)v366 = v21;
              unint64_t v24 = v366 + 8;
              while (v22 != v182)
              {
                uint64_t v367 = *((void *)v22 - 1);
                v22 -= 8;
                *((void *)v366 - 1) = v367;
                v366 -= 8;
              }
              v20[325] = v366;
              v20[326] = v24;
              v20[327] = &v187[8 * v186];
              if (v182) {
                operator delete(v182);
              }
            }
            else
            {
              *(void *)uint64_t v22 = v21;
              unint64_t v24 = v22 + 8;
            }
            v20[326] = v24;
            break;
          case 'M':
            uint64_t v25 = *(void **)a1[2];
            uint64_t v26 = *(_WORD *)(a1[3] + 34) & 0x1FFF;
            uint64_t v27 = (char *)v25[329];
            unint64_t v28 = v25[330];
            if ((unint64_t)v27 >= v28)
            {
              uint64_t v188 = (char *)v25[328];
              uint64_t v189 = (v27 - v188) >> 3;
              if ((unint64_t)(v189 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v190 = v28 - (void)v188;
              unint64_t v191 = (uint64_t)(v28 - (void)v188) >> 2;
              if (v191 <= v189 + 1) {
                unint64_t v191 = v189 + 1;
              }
              if (v190 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v192 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v192 = v191;
              }
              if (v192)
              {
                unint64_t v193 = (char *)sub_5714((uint64_t)(v25 + 330), v192);
                uint64_t v27 = (char *)v25[329];
                uint64_t v188 = (char *)v25[328];
              }
              else
              {
                unint64_t v193 = 0;
              }
              v368 = &v193[8 * v189];
              *(void *)v368 = v26;
              unint64_t v29 = v368 + 8;
              while (v27 != v188)
              {
                uint64_t v369 = *((void *)v27 - 1);
                v27 -= 8;
                *((void *)v368 - 1) = v369;
                v368 -= 8;
              }
              v25[328] = v368;
              v25[329] = v29;
              v25[330] = &v193[8 * v192];
              if (v188) {
                operator delete(v188);
              }
            }
            else
            {
              *(void *)uint64_t v27 = v26;
              unint64_t v29 = v27 + 8;
            }
            v25[329] = v29;
            break;
          case 'N':
            unint64_t v30 = *(void **)a1[2];
            uint64_t v31 = *(_WORD *)(a1[3] + 84) & 0x1FFF;
            unint64_t v32 = (char *)v30[332];
            unint64_t v33 = v30[333];
            if ((unint64_t)v32 >= v33)
            {
              uint64_t v194 = (char *)v30[331];
              uint64_t v195 = (v32 - v194) >> 3;
              if ((unint64_t)(v195 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v196 = v33 - (void)v194;
              unint64_t v197 = (uint64_t)(v33 - (void)v194) >> 2;
              if (v197 <= v195 + 1) {
                unint64_t v197 = v195 + 1;
              }
              if (v196 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v198 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v198 = v197;
              }
              if (v198)
              {
                unint64_t v199 = (char *)sub_5714((uint64_t)(v30 + 333), v198);
                unint64_t v32 = (char *)v30[332];
                uint64_t v194 = (char *)v30[331];
              }
              else
              {
                unint64_t v199 = 0;
              }
              v370 = &v199[8 * v195];
              *(void *)v370 = v31;
              unint64_t v34 = v370 + 8;
              while (v32 != v194)
              {
                uint64_t v371 = *((void *)v32 - 1);
                v32 -= 8;
                *((void *)v370 - 1) = v371;
                v370 -= 8;
              }
              v30[331] = v370;
              v30[332] = v34;
              v30[333] = &v199[8 * v198];
              if (v194) {
                operator delete(v194);
              }
            }
            else
            {
              *(void *)unint64_t v32 = v31;
              unint64_t v34 = v32 + 8;
            }
            v30[332] = v34;
            break;
          case 'O':
            unint64_t v35 = *(void **)a1[2];
            uint64_t v36 = *(_WORD *)(a1[3] + 68) & 0x1FFF;
            uint64_t v37 = (char *)v35[335];
            unint64_t v38 = v35[336];
            if ((unint64_t)v37 >= v38)
            {
              uint64_t v200 = (char *)v35[334];
              uint64_t v201 = (v37 - v200) >> 3;
              if ((unint64_t)(v201 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v202 = v38 - (void)v200;
              unint64_t v203 = (uint64_t)(v38 - (void)v200) >> 2;
              if (v203 <= v201 + 1) {
                unint64_t v203 = v201 + 1;
              }
              if (v202 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v204 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v204 = v203;
              }
              if (v204)
              {
                unint64_t v205 = (char *)sub_5714((uint64_t)(v35 + 336), v204);
                uint64_t v37 = (char *)v35[335];
                uint64_t v200 = (char *)v35[334];
              }
              else
              {
                unint64_t v205 = 0;
              }
              v372 = &v205[8 * v201];
              *(void *)v372 = v36;
              unint64_t v39 = v372 + 8;
              while (v37 != v200)
              {
                uint64_t v373 = *((void *)v37 - 1);
                v37 -= 8;
                *((void *)v372 - 1) = v373;
                v372 -= 8;
              }
              v35[334] = v372;
              v35[335] = v39;
              v35[336] = &v205[8 * v204];
              if (v200) {
                operator delete(v200);
              }
            }
            else
            {
              *(void *)uint64_t v37 = v36;
              unint64_t v39 = v37 + 8;
            }
            v35[335] = v39;
            break;
          case 'P':
            unint64_t v40 = *(void **)a1[2];
            uint64_t v41 = *(_WORD *)(a1[3] + 52) & 0x1FFF;
            uint64_t v42 = (char *)v40[338];
            unint64_t v43 = v40[339];
            if ((unint64_t)v42 >= v43)
            {
              uint64_t v206 = (char *)v40[337];
              uint64_t v207 = (v42 - v206) >> 3;
              if ((unint64_t)(v207 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v208 = v43 - (void)v206;
              unint64_t v209 = (uint64_t)(v43 - (void)v206) >> 2;
              if (v209 <= v207 + 1) {
                unint64_t v209 = v207 + 1;
              }
              if (v208 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v210 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v210 = v209;
              }
              if (v210)
              {
                unint64_t v211 = (char *)sub_5714((uint64_t)(v40 + 339), v210);
                uint64_t v42 = (char *)v40[338];
                uint64_t v206 = (char *)v40[337];
              }
              else
              {
                unint64_t v211 = 0;
              }
              v374 = &v211[8 * v207];
              *(void *)v374 = v41;
              uint64_t v44 = v374 + 8;
              while (v42 != v206)
              {
                uint64_t v375 = *((void *)v42 - 1);
                v42 -= 8;
                *((void *)v374 - 1) = v375;
                v374 -= 8;
              }
              v40[337] = v374;
              v40[338] = v44;
              v40[339] = &v211[8 * v210];
              if (v206) {
                operator delete(v206);
              }
            }
            else
            {
              *(void *)uint64_t v42 = v41;
              uint64_t v44 = v42 + 8;
            }
            v40[338] = v44;
            break;
          case 'Q':
            unint64_t v45 = *(void **)a1[2];
            uint64_t v46 = *(_WORD *)(a1[3] + 36) & 0x1FFF;
            unint64_t v47 = (char *)v45[341];
            unint64_t v48 = v45[342];
            if ((unint64_t)v47 >= v48)
            {
              unint64_t v212 = (char *)v45[340];
              uint64_t v213 = (v47 - v212) >> 3;
              if ((unint64_t)(v213 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v214 = v48 - (void)v212;
              unint64_t v215 = (uint64_t)(v48 - (void)v212) >> 2;
              if (v215 <= v213 + 1) {
                unint64_t v215 = v213 + 1;
              }
              if (v214 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v216 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v216 = v215;
              }
              if (v216)
              {
                unint64_t v217 = (char *)sub_5714((uint64_t)(v45 + 342), v216);
                unint64_t v47 = (char *)v45[341];
                unint64_t v212 = (char *)v45[340];
              }
              else
              {
                unint64_t v217 = 0;
              }
              v376 = &v217[8 * v213];
              *(void *)v376 = v46;
              uint64_t v49 = v376 + 8;
              while (v47 != v212)
              {
                uint64_t v377 = *((void *)v47 - 1);
                v47 -= 8;
                *((void *)v376 - 1) = v377;
                v376 -= 8;
              }
              v45[340] = v376;
              v45[341] = v49;
              v45[342] = &v217[8 * v216];
              if (v212) {
                operator delete(v212);
              }
            }
            else
            {
              *(void *)unint64_t v47 = v46;
              uint64_t v49 = v47 + 8;
            }
            v45[341] = v49;
            break;
          case 'R':
            uint64_t v50 = *(void **)a1[2];
            uint64_t v51 = *(_WORD *)(a1[3] + 86) & 0x1FFF;
            unint64_t v52 = (char *)v50[344];
            unint64_t v53 = v50[345];
            if ((unint64_t)v52 >= v53)
            {
              v218 = (char *)v50[343];
              uint64_t v219 = (v52 - v218) >> 3;
              if ((unint64_t)(v219 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v220 = v53 - (void)v218;
              unint64_t v221 = (uint64_t)(v53 - (void)v218) >> 2;
              if (v221 <= v219 + 1) {
                unint64_t v221 = v219 + 1;
              }
              if (v220 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v222 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v222 = v221;
              }
              if (v222)
              {
                v223 = (char *)sub_5714((uint64_t)(v50 + 345), v222);
                unint64_t v52 = (char *)v50[344];
                v218 = (char *)v50[343];
              }
              else
              {
                v223 = 0;
              }
              v378 = &v223[8 * v219];
              *(void *)v378 = v51;
              unint64_t v54 = v378 + 8;
              while (v52 != v218)
              {
                uint64_t v379 = *((void *)v52 - 1);
                v52 -= 8;
                *((void *)v378 - 1) = v379;
                v378 -= 8;
              }
              v50[343] = v378;
              v50[344] = v54;
              v50[345] = &v223[8 * v222];
              if (v218) {
                operator delete(v218);
              }
            }
            else
            {
              *(void *)unint64_t v52 = v51;
              unint64_t v54 = v52 + 8;
            }
            v50[344] = v54;
            break;
          case 'S':
            uint64_t v55 = *(void **)a1[2];
            uint64_t v56 = *(_WORD *)(a1[3] + 70) & 0x1FFF;
            unint64_t v57 = (char *)v55[347];
            unint64_t v58 = v55[348];
            if ((unint64_t)v57 >= v58)
            {
              uint64_t v224 = (char *)v55[346];
              uint64_t v225 = (v57 - v224) >> 3;
              if ((unint64_t)(v225 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v226 = v58 - (void)v224;
              unint64_t v227 = (uint64_t)(v58 - (void)v224) >> 2;
              if (v227 <= v225 + 1) {
                unint64_t v227 = v225 + 1;
              }
              if (v226 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v228 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v228 = v227;
              }
              if (v228)
              {
                v229 = (char *)sub_5714((uint64_t)(v55 + 348), v228);
                unint64_t v57 = (char *)v55[347];
                uint64_t v224 = (char *)v55[346];
              }
              else
              {
                v229 = 0;
              }
              v380 = &v229[8 * v225];
              *(void *)v380 = v56;
              unint64_t v59 = v380 + 8;
              while (v57 != v224)
              {
                uint64_t v381 = *((void *)v57 - 1);
                v57 -= 8;
                *((void *)v380 - 1) = v381;
                v380 -= 8;
              }
              v55[346] = v380;
              v55[347] = v59;
              v55[348] = &v229[8 * v228];
              if (v224) {
                operator delete(v224);
              }
            }
            else
            {
              *(void *)unint64_t v57 = v56;
              unint64_t v59 = v57 + 8;
            }
            v55[347] = v59;
            break;
          case 'T':
            unint64_t v60 = *(void **)a1[2];
            uint64_t v61 = *(_WORD *)(a1[3] + 54) & 0x1FFF;
            uint64_t v62 = (char *)v60[350];
            unint64_t v63 = v60[351];
            if ((unint64_t)v62 >= v63)
            {
              uint64_t v230 = (char *)v60[349];
              uint64_t v231 = (v62 - v230) >> 3;
              if ((unint64_t)(v231 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v232 = v63 - (void)v230;
              unint64_t v233 = (uint64_t)(v63 - (void)v230) >> 2;
              if (v233 <= v231 + 1) {
                unint64_t v233 = v231 + 1;
              }
              if (v232 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v234 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v234 = v233;
              }
              if (v234)
              {
                unint64_t v235 = (char *)sub_5714((uint64_t)(v60 + 351), v234);
                uint64_t v62 = (char *)v60[350];
                uint64_t v230 = (char *)v60[349];
              }
              else
              {
                unint64_t v235 = 0;
              }
              v382 = &v235[8 * v231];
              *(void *)v382 = v61;
              unint64_t v64 = v382 + 8;
              while (v62 != v230)
              {
                uint64_t v383 = *((void *)v62 - 1);
                v62 -= 8;
                *((void *)v382 - 1) = v383;
                v382 -= 8;
              }
              v60[349] = v382;
              v60[350] = v64;
              v60[351] = &v235[8 * v234];
              if (v230) {
                operator delete(v230);
              }
            }
            else
            {
              *(void *)uint64_t v62 = v61;
              unint64_t v64 = v62 + 8;
            }
            v60[350] = v64;
            break;
          case 'U':
            unint64_t v65 = *(void **)a1[2];
            uint64_t v66 = *(_WORD *)(a1[3] + 38) & 0x1FFF;
            unint64_t v67 = (char *)v65[353];
            unint64_t v68 = v65[354];
            if ((unint64_t)v67 >= v68)
            {
              uint64_t v236 = (char *)v65[352];
              uint64_t v237 = (v67 - v236) >> 3;
              if ((unint64_t)(v237 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v238 = v68 - (void)v236;
              unint64_t v239 = (uint64_t)(v68 - (void)v236) >> 2;
              if (v239 <= v237 + 1) {
                unint64_t v239 = v237 + 1;
              }
              if (v238 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v240 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v240 = v239;
              }
              if (v240)
              {
                uint64_t v241 = (char *)sub_5714((uint64_t)(v65 + 354), v240);
                unint64_t v67 = (char *)v65[353];
                uint64_t v236 = (char *)v65[352];
              }
              else
              {
                uint64_t v241 = 0;
              }
              v384 = &v241[8 * v237];
              *(void *)v384 = v66;
              unint64_t v69 = v384 + 8;
              while (v67 != v236)
              {
                uint64_t v385 = *((void *)v67 - 1);
                v67 -= 8;
                *((void *)v384 - 1) = v385;
                v384 -= 8;
              }
              v65[352] = v384;
              v65[353] = v69;
              v65[354] = &v241[8 * v240];
              if (v236) {
                operator delete(v236);
              }
            }
            else
            {
              *(void *)unint64_t v67 = v66;
              unint64_t v69 = v67 + 8;
            }
            v65[353] = v69;
            break;
          case 'V':
            uint64_t v70 = *(void **)a1[2];
            uint64_t v71 = *(_WORD *)(a1[3] + 76) & 0x1FFF;
            uint64_t v72 = (char *)v70[356];
            unint64_t v73 = v70[357];
            if ((unint64_t)v72 >= v73)
            {
              uint64_t v242 = (char *)v70[355];
              uint64_t v243 = (v72 - v242) >> 3;
              if ((unint64_t)(v243 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v244 = v73 - (void)v242;
              unint64_t v245 = (uint64_t)(v73 - (void)v242) >> 2;
              if (v245 <= v243 + 1) {
                unint64_t v245 = v243 + 1;
              }
              if (v244 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v246 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v246 = v245;
              }
              if (v246)
              {
                uint64_t v247 = (char *)sub_5714((uint64_t)(v70 + 357), v246);
                uint64_t v72 = (char *)v70[356];
                uint64_t v242 = (char *)v70[355];
              }
              else
              {
                uint64_t v247 = 0;
              }
              v386 = &v247[8 * v243];
              *(void *)v386 = v71;
              uint64_t v74 = v386 + 8;
              while (v72 != v242)
              {
                uint64_t v387 = *((void *)v72 - 1);
                v72 -= 8;
                *((void *)v386 - 1) = v387;
                v386 -= 8;
              }
              v70[355] = v386;
              v70[356] = v74;
              v70[357] = &v247[8 * v246];
              if (v242) {
                operator delete(v242);
              }
            }
            else
            {
              *(void *)uint64_t v72 = v71;
              uint64_t v74 = v72 + 8;
            }
            v70[356] = v74;
            break;
          case 'W':
            uint64_t v75 = *(void **)a1[2];
            uint64_t v76 = *(_WORD *)(a1[3] + 60) & 0x1FFF;
            unint64_t v77 = (char *)v75[359];
            unint64_t v78 = v75[360];
            if ((unint64_t)v77 >= v78)
            {
              uint64_t v248 = (char *)v75[358];
              uint64_t v249 = (v77 - v248) >> 3;
              if ((unint64_t)(v249 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v250 = v78 - (void)v248;
              unint64_t v251 = (uint64_t)(v78 - (void)v248) >> 2;
              if (v251 <= v249 + 1) {
                unint64_t v251 = v249 + 1;
              }
              if (v250 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v252 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v252 = v251;
              }
              if (v252)
              {
                uint64_t v253 = (char *)sub_5714((uint64_t)(v75 + 360), v252);
                unint64_t v77 = (char *)v75[359];
                uint64_t v248 = (char *)v75[358];
              }
              else
              {
                uint64_t v253 = 0;
              }
              v388 = &v253[8 * v249];
              *(void *)v388 = v76;
              uint64_t v79 = v388 + 8;
              while (v77 != v248)
              {
                uint64_t v389 = *((void *)v77 - 1);
                v77 -= 8;
                *((void *)v388 - 1) = v389;
                v388 -= 8;
              }
              v75[358] = v388;
              v75[359] = v79;
              v75[360] = &v253[8 * v252];
              if (v248) {
                operator delete(v248);
              }
            }
            else
            {
              *(void *)unint64_t v77 = v76;
              uint64_t v79 = v77 + 8;
            }
            v75[359] = v79;
            break;
          case 'X':
            unint64_t v80 = *(void **)a1[2];
            uint64_t v81 = *(_WORD *)(a1[3] + 44) & 0x1FFF;
            unint64_t v82 = (char *)v80[362];
            unint64_t v83 = v80[363];
            if ((unint64_t)v82 >= v83)
            {
              uint64_t v254 = (char *)v80[361];
              uint64_t v255 = (v82 - v254) >> 3;
              if ((unint64_t)(v255 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v256 = v83 - (void)v254;
              unint64_t v257 = (uint64_t)(v83 - (void)v254) >> 2;
              if (v257 <= v255 + 1) {
                unint64_t v257 = v255 + 1;
              }
              if (v256 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v258 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v258 = v257;
              }
              if (v258)
              {
                uint64_t v259 = (char *)sub_5714((uint64_t)(v80 + 363), v258);
                unint64_t v82 = (char *)v80[362];
                uint64_t v254 = (char *)v80[361];
              }
              else
              {
                uint64_t v259 = 0;
              }
              v390 = &v259[8 * v255];
              *(void *)v390 = v81;
              unint64_t v84 = v390 + 8;
              while (v82 != v254)
              {
                uint64_t v391 = *((void *)v82 - 1);
                v82 -= 8;
                *((void *)v390 - 1) = v391;
                v390 -= 8;
              }
              v80[361] = v390;
              v80[362] = v84;
              v80[363] = &v259[8 * v258];
              if (v254) {
                operator delete(v254);
              }
            }
            else
            {
              *(void *)unint64_t v82 = v81;
              unint64_t v84 = v82 + 8;
            }
            v80[362] = v84;
            break;
          case 'Y':
            unint64_t v85 = *(void **)a1[2];
            uint64_t v86 = *(_WORD *)(a1[3] + 28) & 0x1FFF;
            unint64_t v87 = (char *)v85[365];
            unint64_t v88 = v85[366];
            if ((unint64_t)v87 >= v88)
            {
              unint64_t v260 = (char *)v85[364];
              uint64_t v261 = (v87 - v260) >> 3;
              if ((unint64_t)(v261 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v262 = v88 - (void)v260;
              unint64_t v263 = (uint64_t)(v88 - (void)v260) >> 2;
              if (v263 <= v261 + 1) {
                unint64_t v263 = v261 + 1;
              }
              if (v262 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v264 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v264 = v263;
              }
              if (v264)
              {
                uint64_t v265 = (char *)sub_5714((uint64_t)(v85 + 366), v264);
                unint64_t v87 = (char *)v85[365];
                unint64_t v260 = (char *)v85[364];
              }
              else
              {
                uint64_t v265 = 0;
              }
              v392 = &v265[8 * v261];
              *(void *)v392 = v86;
              unint64_t v89 = v392 + 8;
              while (v87 != v260)
              {
                uint64_t v393 = *((void *)v87 - 1);
                v87 -= 8;
                *((void *)v392 - 1) = v393;
                v392 -= 8;
              }
              v85[364] = v392;
              v85[365] = v89;
              v85[366] = &v265[8 * v264];
              if (v260) {
                operator delete(v260);
              }
            }
            else
            {
              *(void *)unint64_t v87 = v86;
              unint64_t v89 = v87 + 8;
            }
            v85[365] = v89;
            break;
          case 'Z':
            unint64_t v90 = *(void **)a1[2];
            uint64_t v91 = *(_WORD *)(a1[3] + 78) & 0x1FFF;
            uint64_t v92 = (char *)v90[368];
            unint64_t v93 = v90[369];
            if ((unint64_t)v92 >= v93)
            {
              v266 = (char *)v90[367];
              uint64_t v267 = (v92 - v266) >> 3;
              if ((unint64_t)(v267 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v268 = v93 - (void)v266;
              unint64_t v269 = (uint64_t)(v93 - (void)v266) >> 2;
              if (v269 <= v267 + 1) {
                unint64_t v269 = v267 + 1;
              }
              if (v268 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v270 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v270 = v269;
              }
              if (v270)
              {
                v271 = (char *)sub_5714((uint64_t)(v90 + 369), v270);
                uint64_t v92 = (char *)v90[368];
                v266 = (char *)v90[367];
              }
              else
              {
                v271 = 0;
              }
              v394 = &v271[8 * v267];
              *(void *)v394 = v91;
              uint64_t v94 = v394 + 8;
              while (v92 != v266)
              {
                uint64_t v395 = *((void *)v92 - 1);
                v92 -= 8;
                *((void *)v394 - 1) = v395;
                v394 -= 8;
              }
              v90[367] = v394;
              v90[368] = v94;
              v90[369] = &v271[8 * v270];
              if (v266) {
                operator delete(v266);
              }
            }
            else
            {
              *(void *)uint64_t v92 = v91;
              uint64_t v94 = v92 + 8;
            }
            v90[368] = v94;
            break;
          case '[':
            unint64_t v95 = *(void **)a1[2];
            uint64_t v96 = *(_WORD *)(a1[3] + 62) & 0x1FFF;
            unint64_t v97 = (char *)v95[371];
            unint64_t v98 = v95[372];
            if ((unint64_t)v97 >= v98)
            {
              uint64_t v272 = (char *)v95[370];
              uint64_t v273 = (v97 - v272) >> 3;
              if ((unint64_t)(v273 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v274 = v98 - (void)v272;
              unint64_t v275 = (uint64_t)(v98 - (void)v272) >> 2;
              if (v275 <= v273 + 1) {
                unint64_t v275 = v273 + 1;
              }
              if (v274 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v276 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v276 = v275;
              }
              if (v276)
              {
                v277 = (char *)sub_5714((uint64_t)(v95 + 372), v276);
                unint64_t v97 = (char *)v95[371];
                uint64_t v272 = (char *)v95[370];
              }
              else
              {
                v277 = 0;
              }
              v396 = &v277[8 * v273];
              *(void *)v396 = v96;
              unint64_t v99 = v396 + 8;
              while (v97 != v272)
              {
                uint64_t v397 = *((void *)v97 - 1);
                v97 -= 8;
                *((void *)v396 - 1) = v397;
                v396 -= 8;
              }
              v95[370] = v396;
              v95[371] = v99;
              v95[372] = &v277[8 * v276];
              if (v272) {
                operator delete(v272);
              }
            }
            else
            {
              *(void *)unint64_t v97 = v96;
              unint64_t v99 = v97 + 8;
            }
            v95[371] = v99;
            break;
          case '\\':
            uint64_t v100 = *(void **)a1[2];
            uint64_t v101 = *(_WORD *)(a1[3] + 46) & 0x1FFF;
            unint64_t v102 = (char *)v100[374];
            unint64_t v103 = v100[375];
            if ((unint64_t)v102 >= v103)
            {
              v278 = (char *)v100[373];
              uint64_t v279 = (v102 - v278) >> 3;
              if ((unint64_t)(v279 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v280 = v103 - (void)v278;
              unint64_t v281 = (uint64_t)(v103 - (void)v278) >> 2;
              if (v281 <= v279 + 1) {
                unint64_t v281 = v279 + 1;
              }
              if (v280 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v282 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v282 = v281;
              }
              if (v282)
              {
                v283 = (char *)sub_5714((uint64_t)(v100 + 375), v282);
                unint64_t v102 = (char *)v100[374];
                v278 = (char *)v100[373];
              }
              else
              {
                v283 = 0;
              }
              v398 = &v283[8 * v279];
              *(void *)v398 = v101;
              uint64_t v104 = v398 + 8;
              while (v102 != v278)
              {
                uint64_t v399 = *((void *)v102 - 1);
                v102 -= 8;
                *((void *)v398 - 1) = v399;
                v398 -= 8;
              }
              v100[373] = v398;
              v100[374] = v104;
              v100[375] = &v283[8 * v282];
              if (v278) {
                operator delete(v278);
              }
            }
            else
            {
              *(void *)unint64_t v102 = v101;
              uint64_t v104 = v102 + 8;
            }
            v100[374] = v104;
            break;
          case ']':
            unint64_t v105 = *(void **)a1[2];
            uint64_t v106 = *(_WORD *)(a1[3] + 30) & 0x1FFF;
            unint64_t v107 = (char *)v105[377];
            unint64_t v108 = v105[378];
            if ((unint64_t)v107 >= v108)
            {
              v284 = (char *)v105[376];
              uint64_t v285 = (v107 - v284) >> 3;
              if ((unint64_t)(v285 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v286 = v108 - (void)v284;
              unint64_t v287 = (uint64_t)(v108 - (void)v284) >> 2;
              if (v287 <= v285 + 1) {
                unint64_t v287 = v285 + 1;
              }
              if (v286 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v288 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v288 = v287;
              }
              if (v288)
              {
                v289 = (char *)sub_5714((uint64_t)(v105 + 378), v288);
                unint64_t v107 = (char *)v105[377];
                v284 = (char *)v105[376];
              }
              else
              {
                v289 = 0;
              }
              v400 = &v289[8 * v285];
              *(void *)v400 = v106;
              unint64_t v109 = v400 + 8;
              while (v107 != v284)
              {
                uint64_t v401 = *((void *)v107 - 1);
                v107 -= 8;
                *((void *)v400 - 1) = v401;
                v400 -= 8;
              }
              v105[376] = v400;
              v105[377] = v109;
              v105[378] = &v289[8 * v288];
              if (v284) {
                operator delete(v284);
              }
            }
            else
            {
              *(void *)unint64_t v107 = v106;
              unint64_t v109 = v107 + 8;
            }
            v105[377] = v109;
            break;
          case '^':
            uint64_t v110 = *(void **)a1[2];
            uint64_t v111 = *(_WORD *)(a1[3] + 80) & 0x1FFF;
            uint64_t v112 = (char *)v110[380];
            unint64_t v113 = v110[381];
            if ((unint64_t)v112 >= v113)
            {
              v290 = (char *)v110[379];
              uint64_t v291 = (v112 - v290) >> 3;
              if ((unint64_t)(v291 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v292 = v113 - (void)v290;
              unint64_t v293 = (uint64_t)(v113 - (void)v290) >> 2;
              if (v293 <= v291 + 1) {
                unint64_t v293 = v291 + 1;
              }
              if (v292 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v294 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v294 = v293;
              }
              if (v294)
              {
                v295 = (char *)sub_5714((uint64_t)(v110 + 381), v294);
                uint64_t v112 = (char *)v110[380];
                v290 = (char *)v110[379];
              }
              else
              {
                v295 = 0;
              }
              v402 = &v295[8 * v291];
              *(void *)v402 = v111;
              unint64_t v114 = v402 + 8;
              while (v112 != v290)
              {
                uint64_t v403 = *((void *)v112 - 1);
                v112 -= 8;
                *((void *)v402 - 1) = v403;
                v402 -= 8;
              }
              v110[379] = v402;
              v110[380] = v114;
              v110[381] = &v295[8 * v294];
              if (v290) {
                operator delete(v290);
              }
            }
            else
            {
              *(void *)uint64_t v112 = v111;
              unint64_t v114 = v112 + 8;
            }
            v110[380] = v114;
            break;
          case '_':
            unint64_t v115 = *(void **)a1[2];
            uint64_t v116 = *(_WORD *)(a1[3] + 64) & 0x1FFF;
            uint64_t v117 = (char *)v115[383];
            unint64_t v118 = v115[384];
            if ((unint64_t)v117 >= v118)
            {
              v296 = (char *)v115[382];
              uint64_t v297 = (v117 - v296) >> 3;
              if ((unint64_t)(v297 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v298 = v118 - (void)v296;
              unint64_t v299 = (uint64_t)(v118 - (void)v296) >> 2;
              if (v299 <= v297 + 1) {
                unint64_t v299 = v297 + 1;
              }
              if (v298 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v300 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v300 = v299;
              }
              if (v300)
              {
                v301 = (char *)sub_5714((uint64_t)(v115 + 384), v300);
                uint64_t v117 = (char *)v115[383];
                v296 = (char *)v115[382];
              }
              else
              {
                v301 = 0;
              }
              v404 = &v301[8 * v297];
              *(void *)v404 = v116;
              unint64_t v119 = v404 + 8;
              while (v117 != v296)
              {
                uint64_t v405 = *((void *)v117 - 1);
                v117 -= 8;
                *((void *)v404 - 1) = v405;
                v404 -= 8;
              }
              v115[382] = v404;
              v115[383] = v119;
              v115[384] = &v301[8 * v300];
              if (v296) {
                operator delete(v296);
              }
            }
            else
            {
              *(void *)uint64_t v117 = v116;
              unint64_t v119 = v117 + 8;
            }
            v115[383] = v119;
            break;
            unint64_t v120 = *(void **)a1[2];
            uint64_t v121 = *(_WORD *)(a1[3] + 48) & 0x1FFF;
            uint64_t v122 = (char *)v120[386];
            unint64_t v123 = v120[387];
            if ((unint64_t)v122 >= v123)
            {
              v302 = (char *)v120[385];
              uint64_t v303 = (v122 - v302) >> 3;
              if ((unint64_t)(v303 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v304 = v123 - (void)v302;
              unint64_t v305 = (uint64_t)(v123 - (void)v302) >> 2;
              if (v305 <= v303 + 1) {
                unint64_t v305 = v303 + 1;
              }
              if (v304 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v306 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v306 = v305;
              }
              if (v306)
              {
                v307 = (char *)sub_5714((uint64_t)(v120 + 387), v306);
                uint64_t v122 = (char *)v120[386];
                v302 = (char *)v120[385];
              }
              else
              {
                v307 = 0;
              }
              v406 = &v307[8 * v303];
              *(void *)v406 = v121;
              uint64_t v124 = v406 + 8;
              while (v122 != v302)
              {
                uint64_t v407 = *((void *)v122 - 1);
                v122 -= 8;
                *((void *)v406 - 1) = v407;
                v406 -= 8;
              }
              v120[385] = v406;
              v120[386] = v124;
              v120[387] = &v307[8 * v306];
              if (v302) {
                operator delete(v302);
              }
            }
            else
            {
              *(void *)uint64_t v122 = v121;
              uint64_t v124 = v122 + 8;
            }
            v120[386] = v124;
            break;
          case 'a':
            unint64_t v125 = *(void **)a1[2];
            uint64_t v126 = *(_WORD *)(a1[3] + 32) & 0x1FFF;
            unint64_t v127 = (char *)v125[389];
            unint64_t v128 = v125[390];
            if ((unint64_t)v127 >= v128)
            {
              v308 = (char *)v125[388];
              uint64_t v309 = (v127 - v308) >> 3;
              if ((unint64_t)(v309 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v310 = v128 - (void)v308;
              unint64_t v311 = (uint64_t)(v128 - (void)v308) >> 2;
              if (v311 <= v309 + 1) {
                unint64_t v311 = v309 + 1;
              }
              if (v310 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v312 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v312 = v311;
              }
              if (v312)
              {
                v313 = (char *)sub_5714((uint64_t)(v125 + 390), v312);
                unint64_t v127 = (char *)v125[389];
                v308 = (char *)v125[388];
              }
              else
              {
                v313 = 0;
              }
              v408 = &v313[8 * v309];
              *(void *)v408 = v126;
              uint64_t v129 = v408 + 8;
              while (v127 != v308)
              {
                uint64_t v409 = *((void *)v127 - 1);
                v127 -= 8;
                *((void *)v408 - 1) = v409;
                v408 -= 8;
              }
              v125[388] = v408;
              v125[389] = v129;
              v125[390] = &v313[8 * v312];
              if (v308) {
                operator delete(v308);
              }
            }
            else
            {
              *(void *)unint64_t v127 = v126;
              uint64_t v129 = v127 + 8;
            }
            v125[389] = v129;
            break;
          case 'b':
            uint64_t v130 = *(void **)a1[2];
            uint64_t v131 = *(_WORD *)(a1[3] + 72) & 0x1FFF;
            unint64_t v132 = (char *)v130[392];
            unint64_t v133 = v130[393];
            if ((unint64_t)v132 >= v133)
            {
              v314 = (char *)v130[391];
              uint64_t v315 = (v132 - v314) >> 3;
              if ((unint64_t)(v315 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v316 = v133 - (void)v314;
              unint64_t v317 = (uint64_t)(v133 - (void)v314) >> 2;
              if (v317 <= v315 + 1) {
                unint64_t v317 = v315 + 1;
              }
              if (v316 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v318 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v318 = v317;
              }
              if (v318)
              {
                v319 = (char *)sub_5714((uint64_t)(v130 + 393), v318);
                unint64_t v132 = (char *)v130[392];
                v314 = (char *)v130[391];
              }
              else
              {
                v319 = 0;
              }
              v410 = &v319[8 * v315];
              *(void *)v410 = v131;
              uint64_t v134 = v410 + 8;
              while (v132 != v314)
              {
                uint64_t v411 = *((void *)v132 - 1);
                v132 -= 8;
                *((void *)v410 - 1) = v411;
                v410 -= 8;
              }
              v130[391] = v410;
              v130[392] = v134;
              v130[393] = &v319[8 * v318];
              if (v314) {
                operator delete(v314);
              }
            }
            else
            {
              *(void *)unint64_t v132 = v131;
              uint64_t v134 = v132 + 8;
            }
            v130[392] = v134;
            break;
          case 'c':
            uint64_t v135 = *(void **)a1[2];
            uint64_t v136 = *(_WORD *)(a1[3] + 56) & 0x1FFF;
            unint64_t v137 = (char *)v135[395];
            unint64_t v138 = v135[396];
            if ((unint64_t)v137 >= v138)
            {
              v320 = (char *)v135[394];
              uint64_t v321 = (v137 - v320) >> 3;
              if ((unint64_t)(v321 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v322 = v138 - (void)v320;
              unint64_t v323 = (uint64_t)(v138 - (void)v320) >> 2;
              if (v323 <= v321 + 1) {
                unint64_t v323 = v321 + 1;
              }
              if (v322 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v324 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v324 = v323;
              }
              if (v324)
              {
                v325 = (char *)sub_5714((uint64_t)(v135 + 396), v324);
                unint64_t v137 = (char *)v135[395];
                v320 = (char *)v135[394];
              }
              else
              {
                v325 = 0;
              }
              v412 = &v325[8 * v321];
              *(void *)v412 = v136;
              unint64_t v139 = v412 + 8;
              while (v137 != v320)
              {
                uint64_t v413 = *((void *)v137 - 1);
                v137 -= 8;
                *((void *)v412 - 1) = v413;
                v412 -= 8;
              }
              v135[394] = v412;
              v135[395] = v139;
              v135[396] = &v325[8 * v324];
              if (v320) {
                operator delete(v320);
              }
            }
            else
            {
              *(void *)unint64_t v137 = v136;
              unint64_t v139 = v137 + 8;
            }
            v135[395] = v139;
            break;
          case 'd':
            uint64_t v140 = *(void **)a1[2];
            uint64_t v141 = *(_WORD *)(a1[3] + 40) & 0x1FFF;
            uint64_t v142 = (char *)v140[398];
            unint64_t v143 = v140[399];
            if ((unint64_t)v142 >= v143)
            {
              v326 = (char *)v140[397];
              uint64_t v327 = (v142 - v326) >> 3;
              if ((unint64_t)(v327 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v328 = v143 - (void)v326;
              unint64_t v329 = (uint64_t)(v143 - (void)v326) >> 2;
              if (v329 <= v327 + 1) {
                unint64_t v329 = v327 + 1;
              }
              if (v328 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v330 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v330 = v329;
              }
              if (v330)
              {
                v331 = (char *)sub_5714((uint64_t)(v140 + 399), v330);
                uint64_t v142 = (char *)v140[398];
                v326 = (char *)v140[397];
              }
              else
              {
                v331 = 0;
              }
              v414 = &v331[8 * v327];
              *(void *)v414 = v141;
              unint64_t v144 = v414 + 8;
              while (v142 != v326)
              {
                uint64_t v415 = *((void *)v142 - 1);
                v142 -= 8;
                *((void *)v414 - 1) = v415;
                v414 -= 8;
              }
              v140[397] = v414;
              v140[398] = v144;
              v140[399] = &v331[8 * v330];
              if (v326) {
                operator delete(v326);
              }
            }
            else
            {
              *(void *)uint64_t v142 = v141;
              unint64_t v144 = v142 + 8;
            }
            v140[398] = v144;
            break;
          case 'e':
            unint64_t v145 = *(void **)a1[2];
            unint64_t v146 = ((unint64_t)*(unsigned __int16 *)(a1[3] + 24) >> 1) & 0x1FFF;
            uint64_t v147 = (unint64_t *)v145[401];
            unint64_t v148 = v145[402];
            if ((unint64_t)v147 >= v148)
            {
              v332 = (unint64_t *)v145[400];
              uint64_t v333 = v147 - v332;
              if ((unint64_t)(v333 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v334 = v148 - (void)v332;
              unint64_t v335 = (uint64_t)(v148 - (void)v332) >> 2;
              if (v335 <= v333 + 1) {
                unint64_t v335 = v333 + 1;
              }
              if (v334 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v336 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v336 = v335;
              }
              if (v336)
              {
                v337 = (char *)sub_5714((uint64_t)(v145 + 402), v336);
                uint64_t v147 = (unint64_t *)v145[401];
                v332 = (unint64_t *)v145[400];
              }
              else
              {
                v337 = 0;
              }
              v416 = (unint64_t *)&v337[8 * v333];
              unint64_t *v416 = v146;
              unint64_t v149 = v416 + 1;
              while (v147 != v332)
              {
                unint64_t v417 = *--v147;
                *--v416 = v417;
              }
              v145[400] = v416;
              v145[401] = v149;
              v145[402] = &v337[8 * v336];
              if (v332) {
                operator delete(v332);
              }
            }
            else
            {
              *uint64_t v147 = v146;
              unint64_t v149 = v147 + 1;
            }
            v145[401] = v149;
            break;
          case 'f':
            unint64_t v150 = *(void **)a1[2];
            uint64_t v151 = *(_WORD *)(a1[3] + 74) & 0x1FFF;
            uint64_t v152 = (char *)v150[404];
            unint64_t v153 = v150[405];
            if ((unint64_t)v152 >= v153)
            {
              v338 = (char *)v150[403];
              uint64_t v339 = (v152 - v338) >> 3;
              if ((unint64_t)(v339 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v340 = v153 - (void)v338;
              unint64_t v341 = (uint64_t)(v153 - (void)v338) >> 2;
              if (v341 <= v339 + 1) {
                unint64_t v341 = v339 + 1;
              }
              if (v340 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v342 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v342 = v341;
              }
              if (v342)
              {
                v343 = (char *)sub_5714((uint64_t)(v150 + 405), v342);
                uint64_t v152 = (char *)v150[404];
                v338 = (char *)v150[403];
              }
              else
              {
                v343 = 0;
              }
              v418 = &v343[8 * v339];
              *(void *)v418 = v151;
              uint64_t v154 = v418 + 8;
              while (v152 != v338)
              {
                uint64_t v419 = *((void *)v152 - 1);
                v152 -= 8;
                *((void *)v418 - 1) = v419;
                v418 -= 8;
              }
              v150[403] = v418;
              v150[404] = v154;
              v150[405] = &v343[8 * v342];
              if (v338) {
                operator delete(v338);
              }
            }
            else
            {
              *(void *)uint64_t v152 = v151;
              uint64_t v154 = v152 + 8;
            }
            v150[404] = v154;
            break;
          case 'g':
            unint64_t v155 = *(void **)a1[2];
            uint64_t v156 = *(_WORD *)(a1[3] + 58) & 0x1FFF;
            unint64_t v157 = (char *)v155[407];
            unint64_t v158 = v155[408];
            if ((unint64_t)v157 >= v158)
            {
              v344 = (char *)v155[406];
              uint64_t v345 = (v157 - v344) >> 3;
              if ((unint64_t)(v345 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v346 = v158 - (void)v344;
              unint64_t v347 = (uint64_t)(v158 - (void)v344) >> 2;
              if (v347 <= v345 + 1) {
                unint64_t v347 = v345 + 1;
              }
              if (v346 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v348 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v348 = v347;
              }
              if (v348)
              {
                v349 = (char *)sub_5714((uint64_t)(v155 + 408), v348);
                unint64_t v157 = (char *)v155[407];
                v344 = (char *)v155[406];
              }
              else
              {
                v349 = 0;
              }
              v420 = &v349[8 * v345];
              *(void *)v420 = v156;
              uint64_t v159 = v420 + 8;
              while (v157 != v344)
              {
                uint64_t v421 = *((void *)v157 - 1);
                v157 -= 8;
                *((void *)v420 - 1) = v421;
                v420 -= 8;
              }
              v155[406] = v420;
              v155[407] = v159;
              v155[408] = &v349[8 * v348];
              if (v344) {
                operator delete(v344);
              }
            }
            else
            {
              *(void *)unint64_t v157 = v156;
              uint64_t v159 = v157 + 8;
            }
            v155[407] = v159;
            break;
          case 'h':
            uint64_t v160 = *(void **)a1[2];
            uint64_t v161 = *(_WORD *)(a1[3] + 42) & 0x1FFF;
            unint64_t v162 = (char *)v160[410];
            unint64_t v163 = v160[411];
            if ((unint64_t)v162 >= v163)
            {
              v350 = (char *)v160[409];
              uint64_t v351 = (v162 - v350) >> 3;
              if ((unint64_t)(v351 + 1) >> 61) {
                goto LABEL_594;
              }
              unint64_t v352 = v163 - (void)v350;
              unint64_t v353 = (uint64_t)(v163 - (void)v350) >> 2;
              if (v353 <= v351 + 1) {
                unint64_t v353 = v351 + 1;
              }
              if (v352 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v354 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v354 = v353;
              }
              if (v354)
              {
                v355 = (char *)sub_5714((uint64_t)(v160 + 411), v354);
                unint64_t v162 = (char *)v160[410];
                v350 = (char *)v160[409];
              }
              else
              {
                v355 = 0;
              }
              v422 = &v355[8 * v351];
              *(void *)v422 = v161;
              uint64_t v164 = v422 + 8;
              while (v162 != v350)
              {
                uint64_t v423 = *((void *)v162 - 1);
                v162 -= 8;
                *((void *)v422 - 1) = v423;
                v422 -= 8;
              }
              v160[409] = v422;
              v160[410] = v164;
              v160[411] = &v355[8 * v354];
              if (v350) {
                operator delete(v350);
              }
            }
            else
            {
              *(void *)unint64_t v162 = v161;
              uint64_t v164 = v162 + 8;
            }
            v160[410] = v164;
            break;
          case 'i':
            uint64_t v165 = *(void **)a1[2];
            uint64_t v166 = *(_WORD *)(a1[3] + 26) & 0x1FFF;
            unint64_t v167 = (char *)v165[413];
            unint64_t v168 = v165[414];
            if ((unint64_t)v167 >= v168)
            {
              v356 = (char *)v165[412];
              uint64_t v357 = (v167 - v356) >> 3;
              if ((unint64_t)(v357 + 1) >> 61) {
LABEL_594:
              }
                sub_566C();
              unint64_t v358 = v168 - (void)v356;
              unint64_t v359 = (uint64_t)(v168 - (void)v356) >> 2;
              if (v359 <= v357 + 1) {
                unint64_t v359 = v357 + 1;
              }
              if (v358 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v360 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v360 = v359;
              }
              if (v360)
              {
                v361 = (char *)sub_5714((uint64_t)(v165 + 414), v360);
                unint64_t v167 = (char *)v165[413];
                v356 = (char *)v165[412];
              }
              else
              {
                v361 = 0;
              }
              v424 = &v361[8 * v357];
              *(void *)v424 = v166;
              unint64_t v169 = v424 + 8;
              while (v167 != v356)
              {
                uint64_t v425 = *((void *)v167 - 1);
                v167 -= 8;
                *((void *)v424 - 1) = v425;
                v424 -= 8;
              }
              v165[412] = v424;
              v165[413] = v169;
              v165[414] = &v361[8 * v360];
              if (v356) {
                operator delete(v356);
              }
            }
            else
            {
              *(void *)unint64_t v167 = v166;
              unint64_t v169 = v167 + 8;
            }
            v165[413] = v169;
            break;
          default:
            break;
        }
        ++v7;
      }
      while (v7 != v9);
    }
  }
  *a2 = 1;
}

void sub_1B060C(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  if (*a2 == 1)
  {
    unint64_t v103 = (int **)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    unint64_t v102 = *v103;
    uint64_t v104 = (char *)v103[1] - (char *)*v103;
    if (v104)
    {
      unint64_t v105 = v104 >> 2;
      if (v105 <= 1) {
        unint64_t v105 = 1;
      }
      do
      {
        int v106 = *v102++;
        switch(v106)
        {
          case 'C':
            uint64_t v107 = *(_WORD *)(a1[3] + 42) & 0x7FFF;
            unint64_t v108 = (void *)(*(void *)a1[2] + 2392);
            goto LABEL_140;
          case 'D':
            uint64_t v107 = *(_WORD *)(a1[3] + 40) & 0x7FFF;
            unint64_t v108 = (void *)(*(void *)a1[2] + 2416);
            goto LABEL_140;
          case 'E':
            uint64_t v107 = *(_WORD *)(a1[3] + 38) & 0x7FFF;
            unint64_t v108 = (void *)(*(void *)a1[2] + 2440);
            goto LABEL_140;
          case 'F':
            uint64_t v107 = (*(void *)(a1[3] + 32) >> 33) & 0x7FFFLL;
            unint64_t v108 = (void *)(*(void *)a1[2] + 2464);
            goto LABEL_140;
          case 'G':
            uint64_t v107 = *(void *)(a1[3] + 32) & 0x1FFFFFFFFLL;
            unint64_t v108 = (void *)(*(void *)a1[2] + 2488);
            goto LABEL_140;
          case 'H':
            uint64_t v107 = *(_WORD *)(a1[3] + 44) & 0x7FFF;
            unint64_t v108 = (void *)(*(void *)a1[2] + 2512);
            goto LABEL_140;
          case 'I':
            uint64_t v107 = *(unsigned int *)(a1[3] + 24);
            unint64_t v108 = (void *)(*(void *)a1[2] + 2536);
LABEL_140:
            *(void *)(*v108 - 8) += v107;
            break;
          default:
            break;
        }
        --v105;
      }
      while (v105);
    }
  }
  else
  {
    if (*a2) {
      return;
    }
    v5 = (void *)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v6 = v5[1] - *v5;
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = v6 >> 2;
      if (v8 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v8;
      }
      do
      {
        switch(*(_DWORD *)(*v5 + 4 * v7))
        {
          case 'C':
            v10 = *(void **)a1[2];
            uint64_t v11 = *(_WORD *)(a1[3] + 42) & 0x7FFF;
            v12 = (char *)v10[299];
            unint64_t v13 = v10[300];
            if ((unint64_t)v12 >= v13)
            {
              uint64_t v46 = (char *)v10[298];
              uint64_t v47 = (v12 - v46) >> 3;
              if ((unint64_t)(v47 + 1) >> 61) {
                goto LABEL_144;
              }
              unint64_t v48 = v13 - (void)v46;
              unint64_t v49 = (uint64_t)(v13 - (void)v46) >> 2;
              if (v49 <= v47 + 1) {
                unint64_t v49 = v47 + 1;
              }
              if (v48 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v50 = v49;
              }
              if (v50)
              {
                uint64_t v51 = (char *)sub_5714((uint64_t)(v10 + 300), v50);
                v12 = (char *)v10[299];
                uint64_t v46 = (char *)v10[298];
              }
              else
              {
                uint64_t v51 = 0;
              }
              unint64_t v88 = &v51[8 * v47];
              *(void *)unint64_t v88 = v11;
              v14 = v88 + 8;
              while (v12 != v46)
              {
                uint64_t v89 = *((void *)v12 - 1);
                v12 -= 8;
                *((void *)v88 - 1) = v89;
                v88 -= 8;
              }
              v10[298] = v88;
              v10[299] = v14;
              v10[300] = &v51[8 * v50];
              if (v46) {
                operator delete(v46);
              }
            }
            else
            {
              *(void *)v12 = v11;
              v14 = v12 + 8;
            }
            v10[299] = v14;
            break;
          case 'D':
            v15 = *(void **)a1[2];
            uint64_t v16 = *(_WORD *)(a1[3] + 40) & 0x7FFF;
            v17 = (char *)v15[302];
            unint64_t v18 = v15[303];
            if ((unint64_t)v17 >= v18)
            {
              unint64_t v52 = (char *)v15[301];
              uint64_t v53 = (v17 - v52) >> 3;
              if ((unint64_t)(v53 + 1) >> 61) {
                goto LABEL_144;
              }
              unint64_t v54 = v18 - (void)v52;
              unint64_t v55 = (uint64_t)(v18 - (void)v52) >> 2;
              if (v55 <= v53 + 1) {
                unint64_t v55 = v53 + 1;
              }
              if (v54 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v56 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v56 = v55;
              }
              if (v56)
              {
                unint64_t v57 = (char *)sub_5714((uint64_t)(v15 + 303), v56);
                v17 = (char *)v15[302];
                unint64_t v52 = (char *)v15[301];
              }
              else
              {
                unint64_t v57 = 0;
              }
              unint64_t v90 = &v57[8 * v53];
              *(void *)unint64_t v90 = v16;
              v19 = v90 + 8;
              while (v17 != v52)
              {
                uint64_t v91 = *((void *)v17 - 1);
                v17 -= 8;
                *((void *)v90 - 1) = v91;
                v90 -= 8;
              }
              v15[301] = v90;
              v15[302] = v19;
              v15[303] = &v57[8 * v56];
              if (v52) {
                operator delete(v52);
              }
            }
            else
            {
              *(void *)v17 = v16;
              v19 = v17 + 8;
            }
            v15[302] = v19;
            break;
          case 'E':
            uint64_t v20 = *(void **)a1[2];
            uint64_t v21 = *(_WORD *)(a1[3] + 38) & 0x7FFF;
            uint64_t v22 = (char *)v20[305];
            unint64_t v23 = v20[306];
            if ((unint64_t)v22 >= v23)
            {
              unint64_t v58 = (char *)v20[304];
              uint64_t v59 = (v22 - v58) >> 3;
              if ((unint64_t)(v59 + 1) >> 61) {
                goto LABEL_144;
              }
              unint64_t v60 = v23 - (void)v58;
              unint64_t v61 = (uint64_t)(v23 - (void)v58) >> 2;
              if (v61 <= v59 + 1) {
                unint64_t v61 = v59 + 1;
              }
              if (v60 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v62 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v62 = v61;
              }
              if (v62)
              {
                unint64_t v63 = (char *)sub_5714((uint64_t)(v20 + 306), v62);
                uint64_t v22 = (char *)v20[305];
                unint64_t v58 = (char *)v20[304];
              }
              else
              {
                unint64_t v63 = 0;
              }
              uint64_t v92 = &v63[8 * v59];
              *(void *)uint64_t v92 = v21;
              unint64_t v24 = v92 + 8;
              while (v22 != v58)
              {
                uint64_t v93 = *((void *)v22 - 1);
                v22 -= 8;
                *((void *)v92 - 1) = v93;
                v92 -= 8;
              }
              v20[304] = v92;
              v20[305] = v24;
              v20[306] = &v63[8 * v62];
              if (v58) {
                operator delete(v58);
              }
            }
            else
            {
              *(void *)uint64_t v22 = v21;
              unint64_t v24 = v22 + 8;
            }
            v20[305] = v24;
            break;
          case 'F':
            uint64_t v25 = *(void **)a1[2];
            uint64_t v26 = (*(void *)(a1[3] + 32) >> 33) & 0x7FFFLL;
            uint64_t v27 = (uint64_t *)v25[308];
            unint64_t v28 = v25[309];
            if ((unint64_t)v27 >= v28)
            {
              unint64_t v64 = (uint64_t *)v25[307];
              uint64_t v65 = v27 - v64;
              if ((unint64_t)(v65 + 1) >> 61) {
                goto LABEL_144;
              }
              unint64_t v66 = v28 - (void)v64;
              unint64_t v67 = (uint64_t)(v28 - (void)v64) >> 2;
              if (v67 <= v65 + 1) {
                unint64_t v67 = v65 + 1;
              }
              if (v66 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v68 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v68 = v67;
              }
              if (v68)
              {
                unint64_t v69 = (char *)sub_5714((uint64_t)(v25 + 309), v68);
                uint64_t v27 = (uint64_t *)v25[308];
                unint64_t v64 = (uint64_t *)v25[307];
              }
              else
              {
                unint64_t v69 = 0;
              }
              uint64_t v94 = (uint64_t *)&v69[8 * v65];
              *uint64_t v94 = v26;
              unint64_t v29 = v94 + 1;
              while (v27 != v64)
              {
                uint64_t v95 = *--v27;
                *--uint64_t v94 = v95;
              }
              v25[307] = v94;
              v25[308] = v29;
              v25[309] = &v69[8 * v68];
              if (v64) {
                operator delete(v64);
              }
            }
            else
            {
              *uint64_t v27 = v26;
              unint64_t v29 = v27 + 1;
            }
            v25[308] = v29;
            break;
          case 'G':
            unint64_t v30 = *(void **)a1[2];
            uint64_t v31 = *(void *)(a1[3] + 32) & 0x1FFFFFFFFLL;
            unint64_t v32 = (uint64_t *)v30[311];
            unint64_t v33 = v30[312];
            if ((unint64_t)v32 >= v33)
            {
              uint64_t v70 = (uint64_t *)v30[310];
              uint64_t v71 = v32 - v70;
              if ((unint64_t)(v71 + 1) >> 61) {
                goto LABEL_144;
              }
              unint64_t v72 = v33 - (void)v70;
              unint64_t v73 = (uint64_t)(v33 - (void)v70) >> 2;
              if (v73 <= v71 + 1) {
                unint64_t v73 = v71 + 1;
              }
              if (v72 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v74 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v74 = v73;
              }
              if (v74)
              {
                uint64_t v75 = (char *)sub_5714((uint64_t)(v30 + 312), v74);
                unint64_t v32 = (uint64_t *)v30[311];
                uint64_t v70 = (uint64_t *)v30[310];
              }
              else
              {
                uint64_t v75 = 0;
              }
              uint64_t v96 = (uint64_t *)&v75[8 * v71];
              *uint64_t v96 = v31;
              unint64_t v34 = v96 + 1;
              while (v32 != v70)
              {
                uint64_t v97 = *--v32;
                *--uint64_t v96 = v97;
              }
              v30[310] = v96;
              v30[311] = v34;
              v30[312] = &v75[8 * v74];
              if (v70) {
                operator delete(v70);
              }
            }
            else
            {
              uint64_t *v32 = v31;
              unint64_t v34 = v32 + 1;
            }
            v30[311] = v34;
            break;
          case 'H':
            unint64_t v35 = *(void **)a1[2];
            uint64_t v36 = *(_WORD *)(a1[3] + 44) & 0x7FFF;
            uint64_t v37 = (char *)v35[314];
            unint64_t v38 = v35[315];
            if ((unint64_t)v37 >= v38)
            {
              uint64_t v76 = (char *)v35[313];
              uint64_t v77 = (v37 - v76) >> 3;
              if ((unint64_t)(v77 + 1) >> 61) {
                goto LABEL_144;
              }
              unint64_t v78 = v38 - (void)v76;
              unint64_t v79 = (uint64_t)(v38 - (void)v76) >> 2;
              if (v79 <= v77 + 1) {
                unint64_t v79 = v77 + 1;
              }
              if (v78 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v80 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v80 = v79;
              }
              if (v80)
              {
                uint64_t v81 = (char *)sub_5714((uint64_t)(v35 + 315), v80);
                uint64_t v37 = (char *)v35[314];
                uint64_t v76 = (char *)v35[313];
              }
              else
              {
                uint64_t v81 = 0;
              }
              unint64_t v98 = &v81[8 * v77];
              *(void *)unint64_t v98 = v36;
              unint64_t v39 = v98 + 8;
              while (v37 != v76)
              {
                uint64_t v99 = *((void *)v37 - 1);
                v37 -= 8;
                *((void *)v98 - 1) = v99;
                v98 -= 8;
              }
              v35[313] = v98;
              v35[314] = v39;
              v35[315] = &v81[8 * v80];
              if (v76) {
                operator delete(v76);
              }
            }
            else
            {
              *(void *)uint64_t v37 = v36;
              unint64_t v39 = v37 + 8;
            }
            v35[314] = v39;
            break;
          case 'I':
            uint64_t v40 = a1[2];
            uint64_t v41 = *(void **)v40;
            uint64_t v42 = *(unsigned int *)(a1[3] + 24);
            unint64_t v43 = *(char **)(*(void *)v40 + 2536);
            unint64_t v44 = *(void *)(*(void *)v40 + 2544);
            if ((unint64_t)v43 >= v44)
            {
              unint64_t v82 = (char *)v41[316];
              uint64_t v83 = (v43 - v82) >> 3;
              if ((unint64_t)(v83 + 1) >> 61) {
LABEL_144:
              }
                sub_566C();
              unint64_t v84 = v44 - (void)v82;
              unint64_t v85 = (uint64_t)(v44 - (void)v82) >> 2;
              if (v85 <= v83 + 1) {
                unint64_t v85 = v83 + 1;
              }
              if (v84 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v86 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v86 = v85;
              }
              if (v86)
              {
                unint64_t v87 = (char *)sub_5714((uint64_t)(v41 + 318), v86);
                unint64_t v43 = (char *)v41[317];
                unint64_t v82 = (char *)v41[316];
              }
              else
              {
                unint64_t v87 = 0;
              }
              uint64_t v100 = &v87[8 * v83];
              *(void *)uint64_t v100 = v42;
              unint64_t v45 = v100 + 8;
              while (v43 != v82)
              {
                uint64_t v101 = *((void *)v43 - 1);
                v43 -= 8;
                *((void *)v100 - 1) = v101;
                v100 -= 8;
              }
              v41[316] = v100;
              v41[317] = v45;
              v41[318] = &v87[8 * v86];
              if (v82) {
                operator delete(v82);
              }
            }
            else
            {
              *(void *)unint64_t v43 = v42;
              unint64_t v45 = v43 + 8;
            }
            v41[317] = v45;
            break;
          default:
            break;
        }
        ++v7;
      }
      while (v7 != v9);
    }
  }
  *a2 = 1;
}

void sub_1B0D74(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  if (*a2 == 1)
  {
    unint64_t v118 = (int **)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v117 = *v118;
    uint64_t v119 = (char *)v118[1] - (char *)*v118;
    if (v119)
    {
      unint64_t v120 = v119 >> 2;
      if (v120 <= 1) {
        unint64_t v120 = 1;
      }
      do
      {
        int v121 = *v117++;
        switch(v121)
        {
          case 125:
            uint64_t v122 = *(_WORD *)(a1[3] + 24) & 0x7FFF;
            unint64_t v123 = (void *)(*(void *)a1[2] + 3784);
            goto LABEL_158;
          case 126:
            uint64_t v122 = *(_DWORD *)(a1[3] + 40) & 0x1FFFF;
            unint64_t v123 = (void *)(*(void *)a1[2] + 3808);
            goto LABEL_158;
          case 127:
            uint64_t v122 = *(_WORD *)(a1[3] + 26) & 0x7FFF;
            unint64_t v123 = (void *)(*(void *)a1[2] + 3832);
            goto LABEL_158;
          case 128:
            uint64_t v122 = *(_DWORD *)(a1[3] + 36) & 0x3FFFF;
            unint64_t v123 = (void *)(*(void *)a1[2] + 3856);
            goto LABEL_158;
          case 129:
            uint64_t v122 = *(_DWORD *)(a1[3] + 32) & 0x3FFFF;
            unint64_t v123 = (void *)(*(void *)a1[2] + 3880);
            goto LABEL_158;
          case 130:
            uint64_t v122 = *(unsigned __int16 *)(a1[3] + 46);
            unint64_t v123 = (void *)(*(void *)a1[2] + 3904);
            goto LABEL_158;
          case 131:
            uint64_t v122 = *(unsigned __int16 *)(a1[3] + 44);
            unint64_t v123 = (void *)(*(void *)a1[2] + 3928);
            goto LABEL_158;
          case 132:
            uint64_t v122 = *(unsigned __int16 *)(a1[3] + 28);
            unint64_t v123 = (void *)(*(void *)a1[2] + 3952);
LABEL_158:
            *(void *)(*v123 - 8) += v122;
            break;
          default:
            break;
        }
        --v120;
      }
      while (v120);
    }
  }
  else
  {
    if (*a2) {
      return;
    }
    v5 = (void *)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v6 = v5[1] - *v5;
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = v6 >> 2;
      if (v8 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v8;
      }
      do
      {
        switch(*(_DWORD *)(*v5 + 4 * v7))
        {
          case 0x7D:
            v10 = *(void **)a1[2];
            uint64_t v11 = *(_WORD *)(a1[3] + 24) & 0x7FFF;
            v12 = (char *)v10[473];
            unint64_t v13 = v10[474];
            if ((unint64_t)v12 >= v13)
            {
              uint64_t v53 = (char *)v10[472];
              uint64_t v54 = (v12 - v53) >> 3;
              if ((unint64_t)(v54 + 1) >> 61) {
                goto LABEL_162;
              }
              unint64_t v55 = v13 - (void)v53;
              unint64_t v56 = (uint64_t)(v13 - (void)v53) >> 2;
              if (v56 <= v54 + 1) {
                unint64_t v56 = v54 + 1;
              }
              if (v55 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v57 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v57 = v56;
              }
              if (v57)
              {
                unint64_t v58 = (char *)sub_5714((uint64_t)(v10 + 474), v57);
                v12 = (char *)v10[473];
                uint64_t v53 = (char *)v10[472];
              }
              else
              {
                unint64_t v58 = 0;
              }
              uint64_t v101 = &v58[8 * v54];
              *(void *)uint64_t v101 = v11;
              v14 = v101 + 8;
              while (v12 != v53)
              {
                uint64_t v102 = *((void *)v12 - 1);
                v12 -= 8;
                *((void *)v101 - 1) = v102;
                v101 -= 8;
              }
              v10[472] = v101;
              v10[473] = v14;
              v10[474] = &v58[8 * v57];
              if (v53) {
                operator delete(v53);
              }
            }
            else
            {
              *(void *)v12 = v11;
              v14 = v12 + 8;
            }
            v10[473] = v14;
            break;
          case 0x7E:
            v15 = *(void **)a1[2];
            uint64_t v16 = *(_DWORD *)(a1[3] + 40) & 0x1FFFFLL;
            v17 = (uint64_t *)v15[476];
            unint64_t v18 = v15[477];
            if ((unint64_t)v17 >= v18)
            {
              uint64_t v59 = (uint64_t *)v15[475];
              uint64_t v60 = v17 - v59;
              if ((unint64_t)(v60 + 1) >> 61) {
                goto LABEL_162;
              }
              unint64_t v61 = v18 - (void)v59;
              unint64_t v62 = (uint64_t)(v18 - (void)v59) >> 2;
              if (v62 <= v60 + 1) {
                unint64_t v62 = v60 + 1;
              }
              if (v61 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v63 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v63 = v62;
              }
              if (v63)
              {
                unint64_t v64 = (char *)sub_5714((uint64_t)(v15 + 477), v63);
                v17 = (uint64_t *)v15[476];
                uint64_t v59 = (uint64_t *)v15[475];
              }
              else
              {
                unint64_t v64 = 0;
              }
              unint64_t v103 = (uint64_t *)&v64[8 * v60];
              uint64_t *v103 = v16;
              v19 = v103 + 1;
              while (v17 != v59)
              {
                uint64_t v104 = *--v17;
                *--unint64_t v103 = v104;
              }
              v15[475] = v103;
              v15[476] = v19;
              v15[477] = &v64[8 * v63];
              if (v59) {
                operator delete(v59);
              }
            }
            else
            {
              uint64_t *v17 = v16;
              v19 = v17 + 1;
            }
            v15[476] = v19;
            break;
          case 0x7F:
            uint64_t v20 = *(void **)a1[2];
            uint64_t v21 = *(_WORD *)(a1[3] + 26) & 0x7FFF;
            uint64_t v22 = (char *)v20[479];
            unint64_t v23 = v20[480];
            if ((unint64_t)v22 >= v23)
            {
              uint64_t v65 = (char *)v20[478];
              uint64_t v66 = (v22 - v65) >> 3;
              if ((unint64_t)(v66 + 1) >> 61) {
                goto LABEL_162;
              }
              unint64_t v67 = v23 - (void)v65;
              unint64_t v68 = (uint64_t)(v23 - (void)v65) >> 2;
              if (v68 <= v66 + 1) {
                unint64_t v68 = v66 + 1;
              }
              if (v67 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v69 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v69 = v68;
              }
              if (v69)
              {
                uint64_t v70 = (char *)sub_5714((uint64_t)(v20 + 480), v69);
                uint64_t v22 = (char *)v20[479];
                uint64_t v65 = (char *)v20[478];
              }
              else
              {
                uint64_t v70 = 0;
              }
              unint64_t v105 = &v70[8 * v66];
              *(void *)unint64_t v105 = v21;
              unint64_t v24 = v105 + 8;
              while (v22 != v65)
              {
                uint64_t v106 = *((void *)v22 - 1);
                v22 -= 8;
                *((void *)v105 - 1) = v106;
                v105 -= 8;
              }
              v20[478] = v105;
              v20[479] = v24;
              v20[480] = &v70[8 * v69];
              if (v65) {
                operator delete(v65);
              }
            }
            else
            {
              *(void *)uint64_t v22 = v21;
              unint64_t v24 = v22 + 8;
            }
            v20[479] = v24;
            break;
          case 0x80:
            uint64_t v25 = *(void **)a1[2];
            uint64_t v26 = *(_DWORD *)(a1[3] + 36) & 0x3FFFFLL;
            uint64_t v27 = (uint64_t *)v25[482];
            unint64_t v28 = v25[483];
            if ((unint64_t)v27 >= v28)
            {
              uint64_t v71 = (uint64_t *)v25[481];
              uint64_t v72 = v27 - v71;
              if ((unint64_t)(v72 + 1) >> 61) {
                goto LABEL_162;
              }
              unint64_t v73 = v28 - (void)v71;
              unint64_t v74 = (uint64_t)(v28 - (void)v71) >> 2;
              if (v74 <= v72 + 1) {
                unint64_t v74 = v72 + 1;
              }
              if (v73 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v75 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v75 = v74;
              }
              if (v75)
              {
                uint64_t v76 = (char *)sub_5714((uint64_t)(v25 + 483), v75);
                uint64_t v27 = (uint64_t *)v25[482];
                uint64_t v71 = (uint64_t *)v25[481];
              }
              else
              {
                uint64_t v76 = 0;
              }
              uint64_t v107 = (uint64_t *)&v76[8 * v72];
              *uint64_t v107 = v26;
              unint64_t v29 = v107 + 1;
              while (v27 != v71)
              {
                uint64_t v108 = *--v27;
                *--uint64_t v107 = v108;
              }
              v25[481] = v107;
              v25[482] = v29;
              v25[483] = &v76[8 * v75];
              if (v71) {
                operator delete(v71);
              }
            }
            else
            {
              *uint64_t v27 = v26;
              unint64_t v29 = v27 + 1;
            }
            v25[482] = v29;
            break;
          case 0x81:
            unint64_t v30 = *(void **)a1[2];
            uint64_t v31 = *(_DWORD *)(a1[3] + 32) & 0x3FFFFLL;
            unint64_t v32 = (uint64_t *)v30[485];
            unint64_t v33 = v30[486];
            if ((unint64_t)v32 >= v33)
            {
              uint64_t v77 = (uint64_t *)v30[484];
              uint64_t v78 = v32 - v77;
              if ((unint64_t)(v78 + 1) >> 61) {
                goto LABEL_162;
              }
              unint64_t v79 = v33 - (void)v77;
              unint64_t v80 = (uint64_t)(v33 - (void)v77) >> 2;
              if (v80 <= v78 + 1) {
                unint64_t v80 = v78 + 1;
              }
              if (v79 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v81 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v81 = v80;
              }
              if (v81)
              {
                unint64_t v82 = (char *)sub_5714((uint64_t)(v30 + 486), v81);
                unint64_t v32 = (uint64_t *)v30[485];
                uint64_t v77 = (uint64_t *)v30[484];
              }
              else
              {
                unint64_t v82 = 0;
              }
              unint64_t v109 = (uint64_t *)&v82[8 * v78];
              uint64_t *v109 = v31;
              unint64_t v34 = v109 + 1;
              while (v32 != v77)
              {
                uint64_t v110 = *--v32;
                *--unint64_t v109 = v110;
              }
              v30[484] = v109;
              v30[485] = v34;
              v30[486] = &v82[8 * v81];
              if (v77) {
                operator delete(v77);
              }
            }
            else
            {
              uint64_t *v32 = v31;
              unint64_t v34 = v32 + 1;
            }
            v30[485] = v34;
            break;
          case 0x82:
            uint64_t v35 = a1[2];
            uint64_t v36 = *(void **)v35;
            uint64_t v37 = *(unsigned __int16 *)(a1[3] + 46);
            unint64_t v38 = *(char **)(*(void *)v35 + 3904);
            unint64_t v39 = *(void *)(*(void *)v35 + 3912);
            if ((unint64_t)v38 >= v39)
            {
              uint64_t v83 = (char *)v36[487];
              uint64_t v84 = (v38 - v83) >> 3;
              if ((unint64_t)(v84 + 1) >> 61) {
                goto LABEL_162;
              }
              unint64_t v85 = v39 - (void)v83;
              unint64_t v86 = (uint64_t)(v39 - (void)v83) >> 2;
              if (v86 <= v84 + 1) {
                unint64_t v86 = v84 + 1;
              }
              if (v85 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v87 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v87 = v86;
              }
              if (v87)
              {
                unint64_t v88 = (char *)sub_5714((uint64_t)(v36 + 489), v87);
                unint64_t v38 = (char *)v36[488];
                uint64_t v83 = (char *)v36[487];
              }
              else
              {
                unint64_t v88 = 0;
              }
              uint64_t v111 = &v88[8 * v84];
              *(void *)uint64_t v111 = v37;
              uint64_t v40 = v111 + 8;
              while (v38 != v83)
              {
                uint64_t v112 = *((void *)v38 - 1);
                v38 -= 8;
                *((void *)v111 - 1) = v112;
                v111 -= 8;
              }
              v36[487] = v111;
              v36[488] = v40;
              v36[489] = &v88[8 * v87];
              if (v83) {
                operator delete(v83);
              }
            }
            else
            {
              *(void *)unint64_t v38 = v37;
              uint64_t v40 = v38 + 8;
            }
            v36[488] = v40;
            break;
          case 0x83:
            uint64_t v41 = a1[2];
            uint64_t v42 = *(void **)v41;
            uint64_t v43 = *(unsigned __int16 *)(a1[3] + 44);
            unint64_t v44 = *(char **)(*(void *)v41 + 3928);
            unint64_t v45 = *(void *)(*(void *)v41 + 3936);
            if ((unint64_t)v44 >= v45)
            {
              uint64_t v89 = (char *)v42[490];
              uint64_t v90 = (v44 - v89) >> 3;
              if ((unint64_t)(v90 + 1) >> 61) {
                goto LABEL_162;
              }
              unint64_t v91 = v45 - (void)v89;
              unint64_t v92 = (uint64_t)(v45 - (void)v89) >> 2;
              if (v92 <= v90 + 1) {
                unint64_t v92 = v90 + 1;
              }
              if (v91 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v93 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v93 = v92;
              }
              if (v93)
              {
                uint64_t v94 = (char *)sub_5714((uint64_t)(v42 + 492), v93);
                unint64_t v44 = (char *)v42[491];
                uint64_t v89 = (char *)v42[490];
              }
              else
              {
                uint64_t v94 = 0;
              }
              unint64_t v113 = &v94[8 * v90];
              *(void *)unint64_t v113 = v43;
              uint64_t v46 = v113 + 8;
              while (v44 != v89)
              {
                uint64_t v114 = *((void *)v44 - 1);
                v44 -= 8;
                *((void *)v113 - 1) = v114;
                v113 -= 8;
              }
              v42[490] = v113;
              v42[491] = v46;
              v42[492] = &v94[8 * v93];
              if (v89) {
                operator delete(v89);
              }
            }
            else
            {
              *(void *)unint64_t v44 = v43;
              uint64_t v46 = v44 + 8;
            }
            v42[491] = v46;
            break;
          case 0x84:
            uint64_t v47 = a1[2];
            unint64_t v48 = *(void **)v47;
            uint64_t v49 = *(unsigned __int16 *)(a1[3] + 28);
            unint64_t v50 = *(char **)(*(void *)v47 + 3952);
            unint64_t v51 = *(void *)(*(void *)v47 + 3960);
            if ((unint64_t)v50 >= v51)
            {
              uint64_t v95 = (char *)v48[493];
              uint64_t v96 = (v50 - v95) >> 3;
              if ((unint64_t)(v96 + 1) >> 61) {
LABEL_162:
              }
                sub_566C();
              unint64_t v97 = v51 - (void)v95;
              unint64_t v98 = (uint64_t)(v51 - (void)v95) >> 2;
              if (v98 <= v96 + 1) {
                unint64_t v98 = v96 + 1;
              }
              if (v97 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v99 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v99 = v98;
              }
              if (v99)
              {
                uint64_t v100 = (char *)sub_5714((uint64_t)(v48 + 495), v99);
                unint64_t v50 = (char *)v48[494];
                uint64_t v95 = (char *)v48[493];
              }
              else
              {
                uint64_t v100 = 0;
              }
              unint64_t v115 = &v100[8 * v96];
              *(void *)unint64_t v115 = v49;
              unint64_t v52 = v115 + 8;
              while (v50 != v95)
              {
                uint64_t v116 = *((void *)v50 - 1);
                v50 -= 8;
                *((void *)v115 - 1) = v116;
                v115 -= 8;
              }
              v48[493] = v115;
              v48[494] = v52;
              v48[495] = &v100[8 * v99];
              if (v95) {
                operator delete(v95);
              }
            }
            else
            {
              *(void *)unint64_t v50 = v49;
              unint64_t v52 = v50 + 8;
            }
            v48[494] = v52;
            break;
          default:
            break;
        }
        ++v7;
      }
      while (v7 != v9);
    }
  }
  *a2 = 1;
}

void sub_1B15AC(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  if (*a2 == 1)
  {
    unint64_t v208 = (int **)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v207 = *v208;
    uint64_t v209 = (char *)v208[1] - (char *)*v208;
    if (v209)
    {
      unint64_t v210 = v209 >> 2;
      if (v210 <= 1) {
        unint64_t v210 = 1;
      }
      do
      {
        int v211 = *v207++;
        switch(v211)
        {
          case 'j':
            unint64_t v212 = (unint64_t)*(unsigned int *)(a1[3] + 40) >> 17;
            uint64_t v213 = (void *)(*(void *)a1[2] + 3328);
            goto LABEL_284;
          case 'k':
            unint64_t v212 = *(_DWORD *)(a1[3] + 40) & 0x1FFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 3352);
            goto LABEL_284;
          case 'l':
            unint64_t v212 = *(_WORD *)(a1[3] + 28) & 0x7FFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 3376);
            goto LABEL_284;
          case 'm':
            unint64_t v212 = *(_WORD *)(a1[3] + 30) & 0x7FFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 3400);
            goto LABEL_284;
          case 'n':
            unint64_t v212 = *(_WORD *)(a1[3] + 24) & 0x7FFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 3424);
            goto LABEL_284;
          case 'o':
            unint64_t v212 = *(_WORD *)(a1[3] + 26) & 0x7FFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 3448);
            goto LABEL_284;
          case 'p':
            unint64_t v212 = *(unsigned __int16 *)(a1[3] + 60);
            uint64_t v213 = (void *)(*(void *)a1[2] + 3472);
            goto LABEL_284;
          case 'q':
            unint64_t v212 = *(_DWORD *)(a1[3] + 52) & 0x1FFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 3496);
            goto LABEL_284;
          case 'r':
            unint64_t v212 = *(_DWORD *)(a1[3] + 48) & 0x1FFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 3520);
            goto LABEL_284;
          case 's':
            unint64_t v212 = *(_DWORD *)(a1[3] + 56) & 0x1FFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 3544);
            goto LABEL_284;
          case 't':
            unint64_t v212 = *(_WORD *)(a1[3] + 46) & 0x3FFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 3568);
            goto LABEL_284;
          case 'u':
            unint64_t v212 = *(_WORD *)(a1[3] + 44) & 0x3FFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 3592);
            goto LABEL_284;
          case 'v':
            unint64_t v212 = *(unsigned __int16 *)(a1[3] + 62);
            uint64_t v213 = (void *)(*(void *)a1[2] + 3616);
            goto LABEL_284;
          case 'w':
            unint64_t v212 = *(_DWORD *)(a1[3] + 32) & 0x1FFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 3640);
            goto LABEL_284;
          case 'x':
            unint64_t v212 = *(_DWORD *)(a1[3] + 36) & 0x1FFFF;
            uint64_t v213 = (void *)(*(void *)a1[2] + 3664);
LABEL_284:
            *(void *)(*v213 - 8) += v212;
            break;
          default:
            break;
        }
        --v210;
      }
      while (v210);
    }
  }
  else
  {
    if (*a2) {
      return;
    }
    v5 = (void *)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v6 = v5[1] - *v5;
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = v6 >> 2;
      if (v8 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v8;
      }
      do
      {
        switch(*(_DWORD *)(*v5 + 4 * v7))
        {
          case 'j':
            v10 = *(void **)a1[2];
            unint64_t v11 = (unint64_t)*(unsigned int *)(a1[3] + 40) >> 17;
            v12 = (unint64_t *)v10[416];
            unint64_t v13 = v10[417];
            if ((unint64_t)v12 >= v13)
            {
              unint64_t v87 = (unint64_t *)v10[415];
              uint64_t v88 = v12 - v87;
              if ((unint64_t)(v88 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v89 = v13 - (void)v87;
              unint64_t v90 = (uint64_t)(v13 - (void)v87) >> 2;
              if (v90 <= v88 + 1) {
                unint64_t v90 = v88 + 1;
              }
              if (v89 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v91 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v91 = v90;
              }
              if (v91)
              {
                unint64_t v92 = (char *)sub_5714((uint64_t)(v10 + 417), v91);
                v12 = (unint64_t *)v10[416];
                unint64_t v87 = (unint64_t *)v10[415];
              }
              else
              {
                unint64_t v92 = 0;
              }
              uint64_t v177 = (unint64_t *)&v92[8 * v88];
              *uint64_t v177 = v11;
              v14 = v177 + 1;
              while (v12 != v87)
              {
                unint64_t v178 = *--v12;
                *--uint64_t v177 = v178;
              }
              v10[415] = v177;
              v10[416] = v14;
              v10[417] = &v92[8 * v91];
              if (v87) {
                operator delete(v87);
              }
            }
            else
            {
              unint64_t *v12 = v11;
              v14 = v12 + 1;
            }
            v10[416] = v14;
            break;
          case 'k':
            v15 = *(void **)a1[2];
            uint64_t v16 = *(_DWORD *)(a1[3] + 40) & 0x1FFFFLL;
            v17 = (uint64_t *)v15[419];
            unint64_t v18 = v15[420];
            if ((unint64_t)v17 >= v18)
            {
              unint64_t v93 = (uint64_t *)v15[418];
              uint64_t v94 = v17 - v93;
              if ((unint64_t)(v94 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v95 = v18 - (void)v93;
              unint64_t v96 = (uint64_t)(v18 - (void)v93) >> 2;
              if (v96 <= v94 + 1) {
                unint64_t v96 = v94 + 1;
              }
              if (v95 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v97 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v97 = v96;
              }
              if (v97)
              {
                unint64_t v98 = (char *)sub_5714((uint64_t)(v15 + 420), v97);
                v17 = (uint64_t *)v15[419];
                unint64_t v93 = (uint64_t *)v15[418];
              }
              else
              {
                unint64_t v98 = 0;
              }
              unint64_t v179 = (uint64_t *)&v98[8 * v94];
              *unint64_t v179 = v16;
              v19 = v179 + 1;
              while (v17 != v93)
              {
                uint64_t v180 = *--v17;
                *--unint64_t v179 = v180;
              }
              v15[418] = v179;
              v15[419] = v19;
              v15[420] = &v98[8 * v97];
              if (v93) {
                operator delete(v93);
              }
            }
            else
            {
              uint64_t *v17 = v16;
              v19 = v17 + 1;
            }
            v15[419] = v19;
            break;
          case 'l':
            uint64_t v20 = *(void **)a1[2];
            uint64_t v21 = *(_WORD *)(a1[3] + 28) & 0x7FFF;
            uint64_t v22 = (char *)v20[422];
            unint64_t v23 = v20[423];
            if ((unint64_t)v22 >= v23)
            {
              unint64_t v99 = (char *)v20[421];
              uint64_t v100 = (v22 - v99) >> 3;
              if ((unint64_t)(v100 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v101 = v23 - (void)v99;
              unint64_t v102 = (uint64_t)(v23 - (void)v99) >> 2;
              if (v102 <= v100 + 1) {
                unint64_t v102 = v100 + 1;
              }
              if (v101 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v103 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v103 = v102;
              }
              if (v103)
              {
                uint64_t v104 = (char *)sub_5714((uint64_t)(v20 + 423), v103);
                uint64_t v22 = (char *)v20[422];
                unint64_t v99 = (char *)v20[421];
              }
              else
              {
                uint64_t v104 = 0;
              }
              unint64_t v181 = &v104[8 * v100];
              *(void *)unint64_t v181 = v21;
              unint64_t v24 = v181 + 8;
              while (v22 != v99)
              {
                uint64_t v182 = *((void *)v22 - 1);
                v22 -= 8;
                *((void *)v181 - 1) = v182;
                v181 -= 8;
              }
              v20[421] = v181;
              v20[422] = v24;
              v20[423] = &v104[8 * v103];
              if (v99) {
                operator delete(v99);
              }
            }
            else
            {
              *(void *)uint64_t v22 = v21;
              unint64_t v24 = v22 + 8;
            }
            v20[422] = v24;
            break;
          case 'm':
            uint64_t v25 = *(void **)a1[2];
            uint64_t v26 = *(_WORD *)(a1[3] + 30) & 0x7FFF;
            uint64_t v27 = (char *)v25[425];
            unint64_t v28 = v25[426];
            if ((unint64_t)v27 >= v28)
            {
              unint64_t v105 = (char *)v25[424];
              uint64_t v106 = (v27 - v105) >> 3;
              if ((unint64_t)(v106 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v107 = v28 - (void)v105;
              unint64_t v108 = (uint64_t)(v28 - (void)v105) >> 2;
              if (v108 <= v106 + 1) {
                unint64_t v108 = v106 + 1;
              }
              if (v107 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v109 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v109 = v108;
              }
              if (v109)
              {
                uint64_t v110 = (char *)sub_5714((uint64_t)(v25 + 426), v109);
                uint64_t v27 = (char *)v25[425];
                unint64_t v105 = (char *)v25[424];
              }
              else
              {
                uint64_t v110 = 0;
              }
              uint64_t v183 = &v110[8 * v106];
              *(void *)uint64_t v183 = v26;
              unint64_t v29 = v183 + 8;
              while (v27 != v105)
              {
                uint64_t v184 = *((void *)v27 - 1);
                v27 -= 8;
                *((void *)v183 - 1) = v184;
                v183 -= 8;
              }
              v25[424] = v183;
              v25[425] = v29;
              v25[426] = &v110[8 * v109];
              if (v105) {
                operator delete(v105);
              }
            }
            else
            {
              *(void *)uint64_t v27 = v26;
              unint64_t v29 = v27 + 8;
            }
            v25[425] = v29;
            break;
          case 'n':
            unint64_t v30 = *(void **)a1[2];
            uint64_t v31 = *(_WORD *)(a1[3] + 24) & 0x7FFF;
            unint64_t v32 = (char *)v30[428];
            unint64_t v33 = v30[429];
            if ((unint64_t)v32 >= v33)
            {
              uint64_t v111 = (char *)v30[427];
              uint64_t v112 = (v32 - v111) >> 3;
              if ((unint64_t)(v112 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v113 = v33 - (void)v111;
              unint64_t v114 = (uint64_t)(v33 - (void)v111) >> 2;
              if (v114 <= v112 + 1) {
                unint64_t v114 = v112 + 1;
              }
              if (v113 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v115 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v115 = v114;
              }
              if (v115)
              {
                uint64_t v116 = (char *)sub_5714((uint64_t)(v30 + 429), v115);
                unint64_t v32 = (char *)v30[428];
                uint64_t v111 = (char *)v30[427];
              }
              else
              {
                uint64_t v116 = 0;
              }
              unint64_t v185 = &v116[8 * v112];
              *(void *)unint64_t v185 = v31;
              unint64_t v34 = v185 + 8;
              while (v32 != v111)
              {
                uint64_t v186 = *((void *)v32 - 1);
                v32 -= 8;
                *((void *)v185 - 1) = v186;
                v185 -= 8;
              }
              v30[427] = v185;
              v30[428] = v34;
              v30[429] = &v116[8 * v115];
              if (v111) {
                operator delete(v111);
              }
            }
            else
            {
              *(void *)unint64_t v32 = v31;
              unint64_t v34 = v32 + 8;
            }
            v30[428] = v34;
            break;
          case 'o':
            uint64_t v35 = *(void **)a1[2];
            uint64_t v36 = *(_WORD *)(a1[3] + 26) & 0x7FFF;
            uint64_t v37 = (char *)v35[431];
            unint64_t v38 = v35[432];
            if ((unint64_t)v37 >= v38)
            {
              uint64_t v117 = (char *)v35[430];
              uint64_t v118 = (v37 - v117) >> 3;
              if ((unint64_t)(v118 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v119 = v38 - (void)v117;
              unint64_t v120 = (uint64_t)(v38 - (void)v117) >> 2;
              if (v120 <= v118 + 1) {
                unint64_t v120 = v118 + 1;
              }
              if (v119 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v121 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v121 = v120;
              }
              if (v121)
              {
                uint64_t v122 = (char *)sub_5714((uint64_t)(v35 + 432), v121);
                uint64_t v37 = (char *)v35[431];
                uint64_t v117 = (char *)v35[430];
              }
              else
              {
                uint64_t v122 = 0;
              }
              unint64_t v187 = &v122[8 * v118];
              *(void *)unint64_t v187 = v36;
              unint64_t v39 = v187 + 8;
              while (v37 != v117)
              {
                uint64_t v188 = *((void *)v37 - 1);
                v37 -= 8;
                *((void *)v187 - 1) = v188;
                v187 -= 8;
              }
              v35[430] = v187;
              v35[431] = v39;
              v35[432] = &v122[8 * v121];
              if (v117) {
                operator delete(v117);
              }
            }
            else
            {
              *(void *)uint64_t v37 = v36;
              unint64_t v39 = v37 + 8;
            }
            v35[431] = v39;
            break;
          case 'p':
            uint64_t v40 = a1[2];
            uint64_t v41 = *(void **)v40;
            uint64_t v42 = *(unsigned __int16 *)(a1[3] + 60);
            uint64_t v43 = *(char **)(*(void *)v40 + 3472);
            unint64_t v44 = *(void *)(*(void *)v40 + 3480);
            if ((unint64_t)v43 >= v44)
            {
              unint64_t v123 = (char *)v41[433];
              uint64_t v124 = (v43 - v123) >> 3;
              if ((unint64_t)(v124 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v125 = v44 - (void)v123;
              unint64_t v126 = (uint64_t)(v44 - (void)v123) >> 2;
              if (v126 <= v124 + 1) {
                unint64_t v126 = v124 + 1;
              }
              if (v125 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v127 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v127 = v126;
              }
              if (v127)
              {
                unint64_t v128 = (char *)sub_5714((uint64_t)(v41 + 435), v127);
                uint64_t v43 = (char *)v41[434];
                unint64_t v123 = (char *)v41[433];
              }
              else
              {
                unint64_t v128 = 0;
              }
              uint64_t v189 = &v128[8 * v124];
              *(void *)uint64_t v189 = v42;
              unint64_t v45 = v189 + 8;
              while (v43 != v123)
              {
                uint64_t v190 = *((void *)v43 - 1);
                v43 -= 8;
                *((void *)v189 - 1) = v190;
                v189 -= 8;
              }
              v41[433] = v189;
              v41[434] = v45;
              v41[435] = &v128[8 * v127];
              if (v123) {
                operator delete(v123);
              }
            }
            else
            {
              *(void *)uint64_t v43 = v42;
              unint64_t v45 = v43 + 8;
            }
            v41[434] = v45;
            break;
          case 'q':
            uint64_t v46 = *(void **)a1[2];
            uint64_t v47 = *(_DWORD *)(a1[3] + 52) & 0x1FFFFLL;
            unint64_t v48 = (uint64_t *)v46[437];
            unint64_t v49 = v46[438];
            if ((unint64_t)v48 >= v49)
            {
              uint64_t v129 = (uint64_t *)v46[436];
              uint64_t v130 = v48 - v129;
              if ((unint64_t)(v130 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v131 = v49 - (void)v129;
              unint64_t v132 = (uint64_t)(v49 - (void)v129) >> 2;
              if (v132 <= v130 + 1) {
                unint64_t v132 = v130 + 1;
              }
              if (v131 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v133 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v133 = v132;
              }
              if (v133)
              {
                uint64_t v134 = (char *)sub_5714((uint64_t)(v46 + 438), v133);
                unint64_t v48 = (uint64_t *)v46[437];
                uint64_t v129 = (uint64_t *)v46[436];
              }
              else
              {
                uint64_t v134 = 0;
              }
              unint64_t v191 = (uint64_t *)&v134[8 * v130];
              *unint64_t v191 = v47;
              unint64_t v50 = v191 + 1;
              while (v48 != v129)
              {
                uint64_t v192 = *--v48;
                *--unint64_t v191 = v192;
              }
              v46[436] = v191;
              v46[437] = v50;
              v46[438] = &v134[8 * v133];
              if (v129) {
                operator delete(v129);
              }
            }
            else
            {
              *unint64_t v48 = v47;
              unint64_t v50 = v48 + 1;
            }
            v46[437] = v50;
            break;
          case 'r':
            unint64_t v51 = *(void **)a1[2];
            uint64_t v52 = *(_DWORD *)(a1[3] + 48) & 0x1FFFFLL;
            uint64_t v53 = (uint64_t *)v51[440];
            unint64_t v54 = v51[441];
            if ((unint64_t)v53 >= v54)
            {
              uint64_t v135 = (uint64_t *)v51[439];
              uint64_t v136 = v53 - v135;
              if ((unint64_t)(v136 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v137 = v54 - (void)v135;
              unint64_t v138 = (uint64_t)(v54 - (void)v135) >> 2;
              if (v138 <= v136 + 1) {
                unint64_t v138 = v136 + 1;
              }
              if (v137 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v139 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v139 = v138;
              }
              if (v139)
              {
                uint64_t v140 = (char *)sub_5714((uint64_t)(v51 + 441), v139);
                uint64_t v53 = (uint64_t *)v51[440];
                uint64_t v135 = (uint64_t *)v51[439];
              }
              else
              {
                uint64_t v140 = 0;
              }
              unint64_t v193 = (uint64_t *)&v140[8 * v136];
              uint64_t *v193 = v52;
              unint64_t v55 = v193 + 1;
              while (v53 != v135)
              {
                uint64_t v194 = *--v53;
                *--unint64_t v193 = v194;
              }
              v51[439] = v193;
              v51[440] = v55;
              v51[441] = &v140[8 * v139];
              if (v135) {
                operator delete(v135);
              }
            }
            else
            {
              *uint64_t v53 = v52;
              unint64_t v55 = v53 + 1;
            }
            v51[440] = v55;
            break;
          case 's':
            unint64_t v56 = *(void **)a1[2];
            uint64_t v57 = *(_DWORD *)(a1[3] + 56) & 0x1FFFFLL;
            unint64_t v58 = (uint64_t *)v56[443];
            unint64_t v59 = v56[444];
            if ((unint64_t)v58 >= v59)
            {
              uint64_t v141 = (uint64_t *)v56[442];
              uint64_t v142 = v58 - v141;
              if ((unint64_t)(v142 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v143 = v59 - (void)v141;
              unint64_t v144 = (uint64_t)(v59 - (void)v141) >> 2;
              if (v144 <= v142 + 1) {
                unint64_t v144 = v142 + 1;
              }
              if (v143 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v145 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v145 = v144;
              }
              if (v145)
              {
                unint64_t v146 = (char *)sub_5714((uint64_t)(v56 + 444), v145);
                unint64_t v58 = (uint64_t *)v56[443];
                uint64_t v141 = (uint64_t *)v56[442];
              }
              else
              {
                unint64_t v146 = 0;
              }
              uint64_t v195 = (uint64_t *)&v146[8 * v142];
              *uint64_t v195 = v57;
              uint64_t v60 = v195 + 1;
              while (v58 != v141)
              {
                uint64_t v196 = *--v58;
                *--uint64_t v195 = v196;
              }
              v56[442] = v195;
              v56[443] = v60;
              v56[444] = &v146[8 * v145];
              if (v141) {
                operator delete(v141);
              }
            }
            else
            {
              *unint64_t v58 = v57;
              uint64_t v60 = v58 + 1;
            }
            v56[443] = v60;
            break;
          case 't':
            unint64_t v61 = *(void **)a1[2];
            uint64_t v62 = *(_WORD *)(a1[3] + 46) & 0x3FFF;
            unint64_t v63 = (char *)v61[446];
            unint64_t v64 = v61[447];
            if ((unint64_t)v63 >= v64)
            {
              uint64_t v147 = (char *)v61[445];
              uint64_t v148 = (v63 - v147) >> 3;
              if ((unint64_t)(v148 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v149 = v64 - (void)v147;
              unint64_t v150 = (uint64_t)(v64 - (void)v147) >> 2;
              if (v150 <= v148 + 1) {
                unint64_t v150 = v148 + 1;
              }
              if (v149 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v151 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v151 = v150;
              }
              if (v151)
              {
                uint64_t v152 = (char *)sub_5714((uint64_t)(v61 + 447), v151);
                unint64_t v63 = (char *)v61[446];
                uint64_t v147 = (char *)v61[445];
              }
              else
              {
                uint64_t v152 = 0;
              }
              unint64_t v197 = &v152[8 * v148];
              *(void *)unint64_t v197 = v62;
              uint64_t v65 = v197 + 8;
              while (v63 != v147)
              {
                uint64_t v198 = *((void *)v63 - 1);
                v63 -= 8;
                *((void *)v197 - 1) = v198;
                v197 -= 8;
              }
              v61[445] = v197;
              v61[446] = v65;
              v61[447] = &v152[8 * v151];
              if (v147) {
                operator delete(v147);
              }
            }
            else
            {
              *(void *)unint64_t v63 = v62;
              uint64_t v65 = v63 + 8;
            }
            v61[446] = v65;
            break;
          case 'u':
            uint64_t v66 = *(void **)a1[2];
            uint64_t v67 = *(_WORD *)(a1[3] + 44) & 0x3FFF;
            unint64_t v68 = (char *)v66[449];
            unint64_t v69 = v66[450];
            if ((unint64_t)v68 >= v69)
            {
              unint64_t v153 = (char *)v66[448];
              uint64_t v154 = (v68 - v153) >> 3;
              if ((unint64_t)(v154 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v155 = v69 - (void)v153;
              unint64_t v156 = (uint64_t)(v69 - (void)v153) >> 2;
              if (v156 <= v154 + 1) {
                unint64_t v156 = v154 + 1;
              }
              if (v155 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v157 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v157 = v156;
              }
              if (v157)
              {
                unint64_t v158 = (char *)sub_5714((uint64_t)(v66 + 450), v157);
                unint64_t v68 = (char *)v66[449];
                unint64_t v153 = (char *)v66[448];
              }
              else
              {
                unint64_t v158 = 0;
              }
              unint64_t v199 = &v158[8 * v154];
              *(void *)unint64_t v199 = v67;
              uint64_t v70 = v199 + 8;
              while (v68 != v153)
              {
                uint64_t v200 = *((void *)v68 - 1);
                v68 -= 8;
                *((void *)v199 - 1) = v200;
                v199 -= 8;
              }
              v66[448] = v199;
              v66[449] = v70;
              v66[450] = &v158[8 * v157];
              if (v153) {
                operator delete(v153);
              }
            }
            else
            {
              *(void *)unint64_t v68 = v67;
              uint64_t v70 = v68 + 8;
            }
            v66[449] = v70;
            break;
          case 'v':
            uint64_t v71 = a1[2];
            uint64_t v72 = *(void **)v71;
            uint64_t v73 = *(unsigned __int16 *)(a1[3] + 62);
            unint64_t v74 = *(char **)(*(void *)v71 + 3616);
            unint64_t v75 = *(void *)(*(void *)v71 + 3624);
            if ((unint64_t)v74 >= v75)
            {
              uint64_t v159 = (char *)v72[451];
              uint64_t v160 = (v74 - v159) >> 3;
              if ((unint64_t)(v160 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v161 = v75 - (void)v159;
              unint64_t v162 = (uint64_t)(v75 - (void)v159) >> 2;
              if (v162 <= v160 + 1) {
                unint64_t v162 = v160 + 1;
              }
              if (v161 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v163 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v163 = v162;
              }
              if (v163)
              {
                uint64_t v164 = (char *)sub_5714((uint64_t)(v72 + 453), v163);
                unint64_t v74 = (char *)v72[452];
                uint64_t v159 = (char *)v72[451];
              }
              else
              {
                uint64_t v164 = 0;
              }
              uint64_t v201 = &v164[8 * v160];
              *(void *)uint64_t v201 = v73;
              uint64_t v76 = v201 + 8;
              while (v74 != v159)
              {
                uint64_t v202 = *((void *)v74 - 1);
                v74 -= 8;
                *((void *)v201 - 1) = v202;
                v201 -= 8;
              }
              v72[451] = v201;
              v72[452] = v76;
              v72[453] = &v164[8 * v163];
              if (v159) {
                operator delete(v159);
              }
            }
            else
            {
              *(void *)unint64_t v74 = v73;
              uint64_t v76 = v74 + 8;
            }
            v72[452] = v76;
            break;
          case 'w':
            uint64_t v77 = *(void **)a1[2];
            uint64_t v78 = *(_DWORD *)(a1[3] + 32) & 0x1FFFFLL;
            unint64_t v79 = (uint64_t *)v77[455];
            unint64_t v80 = v77[456];
            if ((unint64_t)v79 >= v80)
            {
              uint64_t v165 = (uint64_t *)v77[454];
              uint64_t v166 = v79 - v165;
              if ((unint64_t)(v166 + 1) >> 61) {
                goto LABEL_288;
              }
              unint64_t v167 = v80 - (void)v165;
              unint64_t v168 = (uint64_t)(v80 - (void)v165) >> 2;
              if (v168 <= v166 + 1) {
                unint64_t v168 = v166 + 1;
              }
              if (v167 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v169 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v169 = v168;
              }
              if (v169)
              {
                uint64_t v170 = (char *)sub_5714((uint64_t)(v77 + 456), v169);
                unint64_t v79 = (uint64_t *)v77[455];
                uint64_t v165 = (uint64_t *)v77[454];
              }
              else
              {
                uint64_t v170 = 0;
              }
              unint64_t v203 = (uint64_t *)&v170[8 * v166];
              *unint64_t v203 = v78;
              unint64_t v81 = v203 + 1;
              while (v79 != v165)
              {
                uint64_t v204 = *--v79;
                *--unint64_t v203 = v204;
              }
              v77[454] = v203;
              v77[455] = v81;
              v77[456] = &v170[8 * v169];
              if (v165) {
                operator delete(v165);
              }
            }
            else
            {
              uint64_t *v79 = v78;
              unint64_t v81 = v79 + 1;
            }
            v77[455] = v81;
            break;
          case 'x':
            unint64_t v82 = *(void **)a1[2];
            uint64_t v83 = *(_DWORD *)(a1[3] + 36) & 0x1FFFFLL;
            uint64_t v84 = (uint64_t *)v82[458];
            unint64_t v85 = v82[459];
            if ((unint64_t)v84 >= v85)
            {
              uint64_t v171 = (uint64_t *)v82[457];
              uint64_t v172 = v84 - v171;
              if ((unint64_t)(v172 + 1) >> 61) {
LABEL_288:
              }
                sub_566C();
              unint64_t v173 = v85 - (void)v171;
              unint64_t v174 = (uint64_t)(v85 - (void)v171) >> 2;
              if (v174 <= v172 + 1) {
                unint64_t v174 = v172 + 1;
              }
              if (v173 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v175 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v175 = v174;
              }
              if (v175)
              {
                uint64_t v176 = (char *)sub_5714((uint64_t)(v82 + 459), v175);
                uint64_t v84 = (uint64_t *)v82[458];
                uint64_t v171 = (uint64_t *)v82[457];
              }
              else
              {
                uint64_t v176 = 0;
              }
              unint64_t v205 = (uint64_t *)&v176[8 * v172];
              uint64_t *v205 = v83;
              unint64_t v86 = v205 + 1;
              while (v84 != v171)
              {
                uint64_t v206 = *--v84;
                *--unint64_t v205 = v206;
              }
              v82[457] = v205;
              v82[458] = v86;
              v82[459] = &v176[8 * v175];
              if (v171) {
                operator delete(v171);
              }
            }
            else
            {
              *uint64_t v84 = v83;
              unint64_t v86 = v84 + 1;
            }
            v82[458] = v86;
            break;
          default:
            break;
        }
        ++v7;
      }
      while (v7 != v9);
    }
  }
  *a2 = 1;
}

void sub_1B240C(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  if (*a2 == 1)
  {
    unint64_t v63 = (int **)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v62 = *v63;
    uint64_t v64 = (char *)v63[1] - (char *)*v63;
    if (v64)
    {
      unint64_t v65 = v64 >> 2;
      if (v65 <= 1) {
        unint64_t v65 = 1;
      }
      do
      {
        int v66 = *v62++;
        switch(v66)
        {
          case 'y':
            uint64_t v67 = *(_DWORD *)(a1[3] + 32) & 0x7FFFF;
            unint64_t v68 = (void *)(*(void *)a1[2] + 3688);
            goto LABEL_86;
          case 'z':
            uint64_t v67 = *(_DWORD *)(a1[3] + 36) & 0x3FFFFF;
            unint64_t v68 = (void *)(*(void *)a1[2] + 3712);
            goto LABEL_86;
          case '{':
            uint64_t v67 = *(_DWORD *)(a1[3] + 28) & 0x3FFFFF;
            unint64_t v68 = (void *)(*(void *)a1[2] + 3736);
            goto LABEL_86;
          case '|':
            uint64_t v67 = *(_DWORD *)(a1[3] + 24) & 0x3FFFFF;
            unint64_t v68 = (void *)(*(void *)a1[2] + 3760);
LABEL_86:
            *(void *)(*v68 - 8) += v67;
            break;
          default:
            break;
        }
        --v65;
      }
      while (v65);
    }
  }
  else
  {
    if (*a2) {
      return;
    }
    v5 = (void *)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v6 = v5[1] - *v5;
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = v6 >> 2;
      if (v8 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v8;
      }
      do
      {
        switch(*(_DWORD *)(*v5 + 4 * v7))
        {
          case 'y':
            v10 = *(void **)a1[2];
            uint64_t v11 = *(_DWORD *)(a1[3] + 32) & 0x7FFFFLL;
            v12 = (uint64_t *)v10[461];
            unint64_t v13 = v10[462];
            if ((unint64_t)v12 >= v13)
            {
              unint64_t v30 = (uint64_t *)v10[460];
              uint64_t v31 = v12 - v30;
              if ((unint64_t)(v31 + 1) >> 61) {
                goto LABEL_90;
              }
              unint64_t v32 = v13 - (void)v30;
              unint64_t v33 = (uint64_t)(v13 - (void)v30) >> 2;
              if (v33 <= v31 + 1) {
                unint64_t v33 = v31 + 1;
              }
              if (v32 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v34 = v33;
              }
              if (v34)
              {
                uint64_t v35 = (char *)sub_5714((uint64_t)(v10 + 462), v34);
                v12 = (uint64_t *)v10[461];
                unint64_t v30 = (uint64_t *)v10[460];
              }
              else
              {
                uint64_t v35 = 0;
              }
              unint64_t v54 = (uint64_t *)&v35[8 * v31];
              uint64_t *v54 = v11;
              v14 = v54 + 1;
              while (v12 != v30)
              {
                uint64_t v55 = *--v12;
                *--unint64_t v54 = v55;
              }
              v10[460] = v54;
              v10[461] = v14;
              v10[462] = &v35[8 * v34];
              if (v30) {
                operator delete(v30);
              }
            }
            else
            {
              uint64_t *v12 = v11;
              v14 = v12 + 1;
            }
            v10[461] = v14;
            break;
          case 'z':
            v15 = *(void **)a1[2];
            uint64_t v16 = *(_DWORD *)(a1[3] + 36) & 0x3FFFFFLL;
            v17 = (uint64_t *)v15[464];
            unint64_t v18 = v15[465];
            if ((unint64_t)v17 >= v18)
            {
              uint64_t v36 = (uint64_t *)v15[463];
              uint64_t v37 = v17 - v36;
              if ((unint64_t)(v37 + 1) >> 61) {
                goto LABEL_90;
              }
              unint64_t v38 = v18 - (void)v36;
              unint64_t v39 = (uint64_t)(v18 - (void)v36) >> 2;
              if (v39 <= v37 + 1) {
                unint64_t v39 = v37 + 1;
              }
              if (v38 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v40 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v40 = v39;
              }
              if (v40)
              {
                uint64_t v41 = (char *)sub_5714((uint64_t)(v15 + 465), v40);
                v17 = (uint64_t *)v15[464];
                uint64_t v36 = (uint64_t *)v15[463];
              }
              else
              {
                uint64_t v41 = 0;
              }
              unint64_t v56 = (uint64_t *)&v41[8 * v37];
              uint64_t *v56 = v16;
              v19 = v56 + 1;
              while (v17 != v36)
              {
                uint64_t v57 = *--v17;
                *--unint64_t v56 = v57;
              }
              v15[463] = v56;
              v15[464] = v19;
              v15[465] = &v41[8 * v40];
              if (v36) {
                operator delete(v36);
              }
            }
            else
            {
              uint64_t *v17 = v16;
              v19 = v17 + 1;
            }
            v15[464] = v19;
            break;
          case '{':
            uint64_t v20 = *(void **)a1[2];
            uint64_t v21 = *(_DWORD *)(a1[3] + 28) & 0x3FFFFFLL;
            uint64_t v22 = (uint64_t *)v20[467];
            unint64_t v23 = v20[468];
            if ((unint64_t)v22 >= v23)
            {
              uint64_t v42 = (uint64_t *)v20[466];
              uint64_t v43 = v22 - v42;
              if ((unint64_t)(v43 + 1) >> 61) {
                goto LABEL_90;
              }
              unint64_t v44 = v23 - (void)v42;
              unint64_t v45 = (uint64_t)(v23 - (void)v42) >> 2;
              if (v45 <= v43 + 1) {
                unint64_t v45 = v43 + 1;
              }
              if (v44 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v46 = v45;
              }
              if (v46)
              {
                uint64_t v47 = (char *)sub_5714((uint64_t)(v20 + 468), v46);
                uint64_t v22 = (uint64_t *)v20[467];
                uint64_t v42 = (uint64_t *)v20[466];
              }
              else
              {
                uint64_t v47 = 0;
              }
              unint64_t v58 = (uint64_t *)&v47[8 * v43];
              *unint64_t v58 = v21;
              unint64_t v24 = v58 + 1;
              while (v22 != v42)
              {
                uint64_t v59 = *--v22;
                *--unint64_t v58 = v59;
              }
              v20[466] = v58;
              v20[467] = v24;
              v20[468] = &v47[8 * v46];
              if (v42) {
                operator delete(v42);
              }
            }
            else
            {
              uint64_t *v22 = v21;
              unint64_t v24 = v22 + 1;
            }
            v20[467] = v24;
            break;
          case '|':
            uint64_t v25 = *(void **)a1[2];
            uint64_t v26 = *(_DWORD *)(a1[3] + 24) & 0x3FFFFFLL;
            uint64_t v27 = (uint64_t *)v25[470];
            unint64_t v28 = v25[471];
            if ((unint64_t)v27 >= v28)
            {
              unint64_t v48 = (uint64_t *)v25[469];
              uint64_t v49 = v27 - v48;
              if ((unint64_t)(v49 + 1) >> 61) {
LABEL_90:
              }
                sub_566C();
              unint64_t v50 = v28 - (void)v48;
              unint64_t v51 = (uint64_t)(v28 - (void)v48) >> 2;
              if (v51 <= v49 + 1) {
                unint64_t v51 = v49 + 1;
              }
              if (v50 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v52 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v52 = v51;
              }
              if (v52)
              {
                uint64_t v53 = (char *)sub_5714((uint64_t)(v25 + 471), v52);
                uint64_t v27 = (uint64_t *)v25[470];
                unint64_t v48 = (uint64_t *)v25[469];
              }
              else
              {
                uint64_t v53 = 0;
              }
              uint64_t v60 = (uint64_t *)&v53[8 * v49];
              *uint64_t v60 = v26;
              unint64_t v29 = v60 + 1;
              while (v27 != v48)
              {
                uint64_t v61 = *--v27;
                *--uint64_t v60 = v61;
              }
              v25[469] = v60;
              v25[470] = v29;
              v25[471] = &v53[8 * v52];
              if (v48) {
                operator delete(v48);
              }
            }
            else
            {
              *uint64_t v27 = v26;
              unint64_t v29 = v27 + 1;
            }
            v25[470] = v29;
            break;
          default:
            break;
        }
        ++v7;
      }
      while (v7 != v9);
    }
  }
  *a2 = 1;
}

void sub_1B28DC(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  if (*a2 == 1)
  {
    uint64_t v141 = (int **)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v140 = *v141;
    uint64_t v142 = (char *)v141[1] - (char *)*v141;
    if (v142)
    {
      unint64_t v143 = v142 >> 2;
      if (v143 <= 1) {
        unint64_t v143 = 1;
      }
      do
      {
        int v144 = *v140++;
        switch(v144)
        {
          case 155:
            unint64_t v145 = *(_WORD *)(a1[3] + 34) & 0x1FFF;
            unint64_t v146 = (void *)(*(void *)a1[2] + 4504);
            goto LABEL_194;
          case 156:
            unint64_t v145 = *(_DWORD *)(a1[3] + 40) & 0x3FFFF;
            unint64_t v146 = (void *)(*(void *)a1[2] + 4528);
            goto LABEL_194;
          case 157:
            unint64_t v145 = *(_WORD *)(a1[3] + 32) & 0x1FFF;
            unint64_t v146 = (void *)(*(void *)a1[2] + 4552);
            goto LABEL_194;
          case 158:
            unint64_t v145 = ((unint64_t)*(unsigned int *)(a1[3] + 36) >> 13) & 0x3FFFF;
            unint64_t v146 = (void *)(*(void *)a1[2] + 4576);
            goto LABEL_194;
          case 159:
            unint64_t v145 = *(_DWORD *)(a1[3] + 36) & 0x1FFF;
            unint64_t v146 = (void *)(*(void *)a1[2] + 4600);
            goto LABEL_194;
          case 160:
            unint64_t v145 = *(_DWORD *)(a1[3] + 44) & 0x3FFFF;
            unint64_t v146 = (void *)(*(void *)a1[2] + 4624);
            goto LABEL_194;
          case 161:
            unint64_t v145 = *(_WORD *)(a1[3] + 28) & 0x3FFF;
            unint64_t v146 = (void *)(*(void *)a1[2] + 4648);
            goto LABEL_194;
          case 162:
            unint64_t v145 = *(_WORD *)(a1[3] + 24) & 0x3FFF;
            unint64_t v146 = (void *)(*(void *)a1[2] + 4672);
            goto LABEL_194;
          case 163:
            unint64_t v145 = *(_WORD *)(a1[3] + 30) & 0x3FFF;
            unint64_t v146 = (void *)(*(void *)a1[2] + 4696);
            goto LABEL_194;
          case 164:
            unint64_t v145 = *(_WORD *)(a1[3] + 26) & 0x3FFF;
            unint64_t v146 = (void *)(*(void *)a1[2] + 4720);
LABEL_194:
            *(void *)(*v146 - 8) += v145;
            break;
          default:
            break;
        }
        --v143;
      }
      while (v143);
    }
  }
  else
  {
    if (*a2) {
      return;
    }
    v5 = (void *)(*(void *)(v4 + 136) + 24 * *(unsigned int *)a1[1]);
    uint64_t v6 = v5[1] - *v5;
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = v6 >> 2;
      if (v8 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v8;
      }
      do
      {
        switch(*(_DWORD *)(*v5 + 4 * v7))
        {
          case 0x9B:
            v10 = *(void **)a1[2];
            uint64_t v11 = *(_WORD *)(a1[3] + 34) & 0x1FFF;
            v12 = (char *)v10[563];
            unint64_t v13 = v10[564];
            if ((unint64_t)v12 >= v13)
            {
              uint64_t v60 = (char *)v10[562];
              uint64_t v61 = (v12 - v60) >> 3;
              if ((unint64_t)(v61 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v62 = v13 - (void)v60;
              unint64_t v63 = (uint64_t)(v13 - (void)v60) >> 2;
              if (v63 <= v61 + 1) {
                unint64_t v63 = v61 + 1;
              }
              if (v62 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v64 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v64 = v63;
              }
              if (v64)
              {
                unint64_t v65 = (char *)sub_5714((uint64_t)(v10 + 564), v64);
                v12 = (char *)v10[563];
                uint64_t v60 = (char *)v10[562];
              }
              else
              {
                unint64_t v65 = 0;
              }
              unint64_t v120 = &v65[8 * v61];
              *(void *)unint64_t v120 = v11;
              v14 = v120 + 8;
              while (v12 != v60)
              {
                uint64_t v121 = *((void *)v12 - 1);
                v12 -= 8;
                *((void *)v120 - 1) = v121;
                v120 -= 8;
              }
              v10[562] = v120;
              v10[563] = v14;
              v10[564] = &v65[8 * v64];
              if (v60) {
                operator delete(v60);
              }
            }
            else
            {
              *(void *)v12 = v11;
              v14 = v12 + 8;
            }
            v10[563] = v14;
            break;
          case 0x9C:
            v15 = *(void **)a1[2];
            uint64_t v16 = *(_DWORD *)(a1[3] + 40) & 0x3FFFFLL;
            v17 = (uint64_t *)v15[566];
            unint64_t v18 = v15[567];
            if ((unint64_t)v17 >= v18)
            {
              int v66 = (uint64_t *)v15[565];
              uint64_t v67 = v17 - v66;
              if ((unint64_t)(v67 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v68 = v18 - (void)v66;
              unint64_t v69 = (uint64_t)(v18 - (void)v66) >> 2;
              if (v69 <= v67 + 1) {
                unint64_t v69 = v67 + 1;
              }
              if (v68 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v70 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v70 = v69;
              }
              if (v70)
              {
                uint64_t v71 = (char *)sub_5714((uint64_t)(v15 + 567), v70);
                v17 = (uint64_t *)v15[566];
                int v66 = (uint64_t *)v15[565];
              }
              else
              {
                uint64_t v71 = 0;
              }
              uint64_t v122 = (uint64_t *)&v71[8 * v67];
              uint64_t *v122 = v16;
              v19 = v122 + 1;
              while (v17 != v66)
              {
                uint64_t v123 = *--v17;
                *--uint64_t v122 = v123;
              }
              v15[565] = v122;
              v15[566] = v19;
              v15[567] = &v71[8 * v70];
              if (v66) {
                operator delete(v66);
              }
            }
            else
            {
              uint64_t *v17 = v16;
              v19 = v17 + 1;
            }
            v15[566] = v19;
            break;
          case 0x9D:
            uint64_t v20 = *(void **)a1[2];
            uint64_t v21 = *(_WORD *)(a1[3] + 32) & 0x1FFF;
            uint64_t v22 = (char *)v20[569];
            unint64_t v23 = v20[570];
            if ((unint64_t)v22 >= v23)
            {
              uint64_t v72 = (char *)v20[568];
              uint64_t v73 = (v22 - v72) >> 3;
              if ((unint64_t)(v73 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v74 = v23 - (void)v72;
              unint64_t v75 = (uint64_t)(v23 - (void)v72) >> 2;
              if (v75 <= v73 + 1) {
                unint64_t v75 = v73 + 1;
              }
              if (v74 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v76 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v76 = v75;
              }
              if (v76)
              {
                uint64_t v77 = (char *)sub_5714((uint64_t)(v20 + 570), v76);
                uint64_t v22 = (char *)v20[569];
                uint64_t v72 = (char *)v20[568];
              }
              else
              {
                uint64_t v77 = 0;
              }
              uint64_t v124 = &v77[8 * v73];
              *(void *)uint64_t v124 = v21;
              unint64_t v24 = v124 + 8;
              while (v22 != v72)
              {
                uint64_t v125 = *((void *)v22 - 1);
                v22 -= 8;
                *((void *)v124 - 1) = v125;
                v124 -= 8;
              }
              v20[568] = v124;
              v20[569] = v24;
              v20[570] = &v77[8 * v76];
              if (v72) {
                operator delete(v72);
              }
            }
            else
            {
              *(void *)uint64_t v22 = v21;
              unint64_t v24 = v22 + 8;
            }
            v20[569] = v24;
            break;
          case 0x9E:
            uint64_t v25 = *(void **)a1[2];
            unint64_t v26 = ((unint64_t)*(unsigned int *)(a1[3] + 36) >> 13) & 0x3FFFF;
            uint64_t v27 = (unint64_t *)v25[572];
            unint64_t v28 = v25[573];
            if ((unint64_t)v27 >= v28)
            {
              uint64_t v78 = (unint64_t *)v25[571];
              uint64_t v79 = v27 - v78;
              if ((unint64_t)(v79 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v80 = v28 - (void)v78;
              unint64_t v81 = (uint64_t)(v28 - (void)v78) >> 2;
              if (v81 <= v79 + 1) {
                unint64_t v81 = v79 + 1;
              }
              if (v80 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v82 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v82 = v81;
              }
              if (v82)
              {
                uint64_t v83 = (char *)sub_5714((uint64_t)(v25 + 573), v82);
                uint64_t v27 = (unint64_t *)v25[572];
                uint64_t v78 = (unint64_t *)v25[571];
              }
              else
              {
                uint64_t v83 = 0;
              }
              unint64_t v126 = (unint64_t *)&v83[8 * v79];
              unint64_t *v126 = v26;
              unint64_t v29 = v126 + 1;
              while (v27 != v78)
              {
                unint64_t v127 = *--v27;
                *--unint64_t v126 = v127;
              }
              v25[571] = v126;
              v25[572] = v29;
              v25[573] = &v83[8 * v82];
              if (v78) {
                operator delete(v78);
              }
            }
            else
            {
              *uint64_t v27 = v26;
              unint64_t v29 = v27 + 1;
            }
            v25[572] = v29;
            break;
          case 0x9F:
            unint64_t v30 = *(void **)a1[2];
            uint64_t v31 = *(_DWORD *)(a1[3] + 36) & 0x1FFFLL;
            unint64_t v32 = (uint64_t *)v30[575];
            unint64_t v33 = v30[576];
            if ((unint64_t)v32 >= v33)
            {
              uint64_t v84 = (uint64_t *)v30[574];
              uint64_t v85 = v32 - v84;
              if ((unint64_t)(v85 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v86 = v33 - (void)v84;
              unint64_t v87 = (uint64_t)(v33 - (void)v84) >> 2;
              if (v87 <= v85 + 1) {
                unint64_t v87 = v85 + 1;
              }
              if (v86 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v88 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v88 = v87;
              }
              if (v88)
              {
                unint64_t v89 = (char *)sub_5714((uint64_t)(v30 + 576), v88);
                unint64_t v32 = (uint64_t *)v30[575];
                uint64_t v84 = (uint64_t *)v30[574];
              }
              else
              {
                unint64_t v89 = 0;
              }
              unint64_t v128 = (uint64_t *)&v89[8 * v85];
              uint64_t *v128 = v31;
              unint64_t v34 = v128 + 1;
              while (v32 != v84)
              {
                uint64_t v129 = *--v32;
                *--unint64_t v128 = v129;
              }
              v30[574] = v128;
              v30[575] = v34;
              v30[576] = &v89[8 * v88];
              if (v84) {
                operator delete(v84);
              }
            }
            else
            {
              uint64_t *v32 = v31;
              unint64_t v34 = v32 + 1;
            }
            v30[575] = v34;
            break;
          case 0xA0:
            uint64_t v35 = *(void **)a1[2];
            uint64_t v36 = *(_DWORD *)(a1[3] + 44) & 0x3FFFFLL;
            uint64_t v37 = (uint64_t *)v35[578];
            unint64_t v38 = v35[579];
            if ((unint64_t)v37 >= v38)
            {
              unint64_t v90 = (uint64_t *)v35[577];
              uint64_t v91 = v37 - v90;
              if ((unint64_t)(v91 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v92 = v38 - (void)v90;
              unint64_t v93 = (uint64_t)(v38 - (void)v90) >> 2;
              if (v93 <= v91 + 1) {
                unint64_t v93 = v91 + 1;
              }
              if (v92 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v94 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v94 = v93;
              }
              if (v94)
              {
                unint64_t v95 = (char *)sub_5714((uint64_t)(v35 + 579), v94);
                uint64_t v37 = (uint64_t *)v35[578];
                unint64_t v90 = (uint64_t *)v35[577];
              }
              else
              {
                unint64_t v95 = 0;
              }
              uint64_t v130 = (uint64_t *)&v95[8 * v91];
              uint64_t *v130 = v36;
              unint64_t v39 = v130 + 1;
              while (v37 != v90)
              {
                uint64_t v131 = *--v37;
                *--uint64_t v130 = v131;
              }
              v35[577] = v130;
              v35[578] = v39;
              v35[579] = &v95[8 * v94];
              if (v90) {
                operator delete(v90);
              }
            }
            else
            {
              uint64_t *v37 = v36;
              unint64_t v39 = v37 + 1;
            }
            v35[578] = v39;
            break;
          case 0xA1:
            unint64_t v40 = *(void **)a1[2];
            uint64_t v41 = *(_WORD *)(a1[3] + 28) & 0x3FFF;
            uint64_t v42 = (char *)v40[581];
            unint64_t v43 = v40[582];
            if ((unint64_t)v42 >= v43)
            {
              unint64_t v96 = (char *)v40[580];
              uint64_t v97 = (v42 - v96) >> 3;
              if ((unint64_t)(v97 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v98 = v43 - (void)v96;
              unint64_t v99 = (uint64_t)(v43 - (void)v96) >> 2;
              if (v99 <= v97 + 1) {
                unint64_t v99 = v97 + 1;
              }
              if (v98 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v100 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v100 = v99;
              }
              if (v100)
              {
                unint64_t v101 = (char *)sub_5714((uint64_t)(v40 + 582), v100);
                uint64_t v42 = (char *)v40[581];
                unint64_t v96 = (char *)v40[580];
              }
              else
              {
                unint64_t v101 = 0;
              }
              unint64_t v132 = &v101[8 * v97];
              *(void *)unint64_t v132 = v41;
              unint64_t v44 = v132 + 8;
              while (v42 != v96)
              {
                uint64_t v133 = *((void *)v42 - 1);
                v42 -= 8;
                *((void *)v132 - 1) = v133;
                v132 -= 8;
              }
              v40[580] = v132;
              v40[581] = v44;
              v40[582] = &v101[8 * v100];
              if (v96) {
                operator delete(v96);
              }
            }
            else
            {
              *(void *)uint64_t v42 = v41;
              unint64_t v44 = v42 + 8;
            }
            v40[581] = v44;
            break;
          case 0xA2:
            unint64_t v45 = *(void **)a1[2];
            uint64_t v46 = *(_WORD *)(a1[3] + 24) & 0x3FFF;
            uint64_t v47 = (char *)v45[584];
            unint64_t v48 = v45[585];
            if ((unint64_t)v47 >= v48)
            {
              unint64_t v102 = (char *)v45[583];
              uint64_t v103 = (v47 - v102) >> 3;
              if ((unint64_t)(v103 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v104 = v48 - (void)v102;
              unint64_t v105 = (uint64_t)(v48 - (void)v102) >> 2;
              if (v105 <= v103 + 1) {
                unint64_t v105 = v103 + 1;
              }
              if (v104 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v106 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v106 = v105;
              }
              if (v106)
              {
                unint64_t v107 = (char *)sub_5714((uint64_t)(v45 + 585), v106);
                uint64_t v47 = (char *)v45[584];
                unint64_t v102 = (char *)v45[583];
              }
              else
              {
                unint64_t v107 = 0;
              }
              uint64_t v134 = &v107[8 * v103];
              *(void *)uint64_t v134 = v46;
              uint64_t v49 = v134 + 8;
              while (v47 != v102)
              {
                uint64_t v135 = *((void *)v47 - 1);
                v47 -= 8;
                *((void *)v134 - 1) = v135;
                v134 -= 8;
              }
              v45[583] = v134;
              v45[584] = v49;
              v45[585] = &v107[8 * v106];
              if (v102) {
                operator delete(v102);
              }
            }
            else
            {
              *(void *)uint64_t v47 = v46;
              uint64_t v49 = v47 + 8;
            }
            v45[584] = v49;
            break;
          case 0xA3:
            unint64_t v50 = *(void **)a1[2];
            uint64_t v51 = *(_WORD *)(a1[3] + 30) & 0x3FFF;
            unint64_t v52 = (char *)v50[587];
            unint64_t v53 = v50[588];
            if ((unint64_t)v52 >= v53)
            {
              unint64_t v108 = (char *)v50[586];
              uint64_t v109 = (v52 - v108) >> 3;
              if ((unint64_t)(v109 + 1) >> 61) {
                goto LABEL_198;
              }
              unint64_t v110 = v53 - (void)v108;
              unint64_t v111 = (uint64_t)(v53 - (void)v108) >> 2;
              if (v111 <= v109 + 1) {
                unint64_t v111 = v109 + 1;
              }
              if (v110 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v112 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v112 = v111;
              }
              if (v112)
              {
                unint64_t v113 = (char *)sub_5714((uint64_t)(v50 + 588), v112);
                unint64_t v52 = (char *)v50[587];
                unint64_t v108 = (char *)v50[586];
              }
              else
              {
                unint64_t v113 = 0;
              }
              uint64_t v136 = &v113[8 * v109];
              *(void *)uint64_t v136 = v51;
              unint64_t v54 = v136 + 8;
              while (v52 != v108)
              {
                uint64_t v137 = *((void *)v52 - 1);
                v52 -= 8;
                *((void *)v136 - 1) = v137;
                v136 -= 8;
              }
              v50[586] = v136;
              v50[587] = v54;
              v50[588] = &v113[8 * v112];
              if (v108) {
                operator delete(v108);
              }
            }
            else
            {
              *(void *)unint64_t v52 = v51;
              unint64_t v54 = v52 + 8;
            }
            v50[587] = v54;
            break;
          case 0xA4:
            uint64_t v55 = *(void **)a1[2];
            uint64_t v56 = *(_WORD *)(a1[3] + 26) & 0x3FFF;
            uint64_t v57 = (char *)v55[590];
            unint64_t v58 = v55[591];
            if ((unint64_t)v57 >= v58)
            {
              unint64_t v114 = (char *)v55[589];
              uint64_t v115 = (v57 - v114) >> 3;
              if ((unint64_t)(v115 + 1) >> 61) {
LABEL_198:
              }
                sub_566C();
              unint64_t v116 = v58 - (void)v114;
              unint64_t v117 = (uint64_t)(v58 - (void)v114) >> 2;
              if (v117 <= v115 + 1) {
                unint64_t v117 = v115 + 1;
              }
              if (v116 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v118 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v118 = v117;
              }
              if (v118)
              {
                unint64_t v119 = (char *)sub_5714((uint64_t)(v55 + 591), v118);
                uint64_t v57 = (char *)v55[590];
                unint64_t v114 = (char *)v55[589];
              }
              else
              {
                unint64_t v119 = 0;
              }
              unint64_t v138 = &v119[8 * v115];
              *(void *)unint64_t v138 = v56;
              uint64_t v59 = v138 + 8;
              while (v57 != v114)
              {
                uint64_t v139 = *((void *)v57 - 1);
                v57 -= 8;
                *((void *)v138 - 1) = v139;
                v138 -= 8;
              }
              v55[589] = v138;
              v55[590] = v59;
              v55[591] = &v119[8 * v118];
              if (v114) {
                operator delete(v114);
              }
            }
            else
            {
              *(void *)uint64_t v57 = v56;
              uint64_t v59 = v57 + 8;
            }
            v55[590] = v59;
            break;
          default:
            break;
        }
        ++v7;
      }
      while (v7 != v9);
    }
  }
  *a2 = 1;
}

void sub_1B3364()
{
}

uint64_t sub_1B3378(int a1, char *__s1)
{
  if (!__s1) {
    return 218;
  }
  uint64_t result = strcmp(__s1, "D7642F4CD8A1F1052D8874FFCB84623EEB5AD8DB476AAA36BB13F44E0122717D");
  if (result)
  {
    if (!strcmp(__s1, "ECCE75AB7F80F9519A3E08E3A0EE71610AE67E3B82829786B02D98C09276F560"))
    {
      return 1;
    }
    else if (!strcmp(__s1, "0D43CB377576A411251DB7D5579117D02FC1BB178830D97B5332A806AC122B37"))
    {
      return 2;
    }
    else if (!strcmp(__s1, "9E7E7B3180DA596EBA2925972639C8DC058E97904ADA86E8FA31E691D63CA97B"))
    {
      return 3;
    }
    else if (!strcmp(__s1, "FE4E8A2782700A8DEC84E195627096B91A904FF6F486B78EF381501FB9667E0F"))
    {
      return 4;
    }
    else if (!strcmp(__s1, "35E9B0A78729DBBE416E11951D26DDC657D957CE37E23B41A2915BB6CC8CF792"))
    {
      return 5;
    }
    else if (!strcmp(__s1, "992E7CAEB9808CFC06F5E69E0B80D0ABB3328FC59FA76FED7BB9529EBBC6E484"))
    {
      return 6;
    }
    else if (!strcmp(__s1, "3EBB72814821E8E8DB302E61197BC3AC6B0A02119FCD0C86BCFA54EB1B511AD2"))
    {
      return 7;
    }
    else if (!strcmp(__s1, "F89408CC4F2E499CED47E61E0AFD929E01C44D079ADF0B440EF845B984DE4956"))
    {
      return 8;
    }
    else if (!strcmp(__s1, "0DAB6425F1EAC005798A5E8220F97E433817AADFE2490BD4F4B762C38F20E22B"))
    {
      return 9;
    }
    else if (!strcmp(__s1, "7FD8B674D9FE018B3D64EA31CB94787780CD12317B2764B9BAFB60C975CDC8EB"))
    {
      return 10;
    }
    else if (!strcmp(__s1, "C04589D08BD1AA2481137A423CC2E81C537B75011557AB0EA579F58E489D9981"))
    {
      return 11;
    }
    else if (!strcmp(__s1, "7C3CD59A80673DD0787DF037FB1FB45E0EB635BFDB2554E10CBF5D056FEDAB78"))
    {
      return 12;
    }
    else if (!strcmp(__s1, "E484E42F34BF2E406D25EB38451C67D3C3C9CB9DEB9222C4F5E21E7E6729C787"))
    {
      return 13;
    }
    else if (!strcmp(__s1, "A1CD5E72A4CAD33DD4C2190F293103B9FD8B40FFE76B1A99A195768465964F91"))
    {
      return 14;
    }
    else if (!strcmp(__s1, "1FFBA951E06F1A7810DC823264210F0C13273E454D699383F3D6265630FEDD53"))
    {
      return 15;
    }
    else if (!strcmp(__s1, "3856FBD8576C0AA988700D7EF5787AAAE94A3BBFBB393B0426FA9D379DA69C91"))
    {
      return 16;
    }
    else if (!strcmp(__s1, "76F5A23AACC27615C980BE3E58B52994192195866836855BCA7C3F885796297B"))
    {
      return 17;
    }
    else if (!strcmp(__s1, "4BF63E209F7D92B4E8341476C80013664D3299327C72E7A7F0D16E1CBD4904FC"))
    {
      return 18;
    }
    else if (!strcmp(__s1, "260130B343BA0695AB911D986B3870FA0CCD0EC58E6F55895A856F37201CE9F8"))
    {
      return 19;
    }
    else if (!strcmp(__s1, "79E88035C9BC883D403F17831B8C9264E643C6B76E9B3C1451B49B0F672C32BF"))
    {
      return 20;
    }
    else if (!strcmp(__s1, "100299043F027ADADB62685130C7FBE549E29F08B58C365844FF8EC25BAEEAB0"))
    {
      return 21;
    }
    else if (!strcmp(__s1, "AA1E812506867A5F2C54D3BA3268DB5C4BB2C6B0E4F500340DD23C4E1E637D9D"))
    {
      return 22;
    }
    else if (!strcmp(__s1, "5D4640C1160E691CF9E1DA7FE475482756D03567716B9856424469B31049A457"))
    {
      return 23;
    }
    else if (!strcmp(__s1, "3476066F46CC277DE7616AAAD8FCDF2C28DA42293B231F74A62159EB6EDAC78C"))
    {
      return 24;
    }
    else if (!strcmp(__s1, "547021D0E82D62B7841769A23FC7FE04F7A63B8A0528A3F6E4C67E8B9420360E"))
    {
      return 25;
    }
    else if (!strcmp(__s1, "295D65BB175E4E4EEF9003E008E093043C9B8CE43190BE0A2D8F1771F9837033"))
    {
      return 26;
    }
    else if (!strcmp(__s1, "3AFE7FC24E518305DB9BB516AE4AA6725E13A423016B31BAFEBFD6FA09AFAFCD"))
    {
      return 27;
    }
    else if (!strcmp(__s1, "37C7DEA7C7AC62E48672D62B73746ED032AC86A05AA223DB4F373D44F106CD6A"))
    {
      return 28;
    }
    else if (!strcmp(__s1, "42EA38C66C2CC54A764D5E204FF38F3402542A5F05B7731D549F22D745429051"))
    {
      return 29;
    }
    else if (!strcmp(__s1, "F6D454657EA6A999B3D168C1A68D6592B2F348BA088B279DBF0A992754767224"))
    {
      return 30;
    }
    else if (!strcmp(__s1, "63CA0F7A21417297C42CDF8868259FBCECF5C6A5C1C994C3A1CA5F608179B458"))
    {
      return 31;
    }
    else if (!strcmp(__s1, "75D1CF68BBA66F3E658B115EF614F1449D832863CAF5F46D092488791378897F"))
    {
      return 32;
    }
    else if (!strcmp(__s1, "F4B1ED932C463D5EE2A9E1F0BEC7DDE12141635B8C1BC09662243EA36A1E2ECE"))
    {
      return 33;
    }
    else if (!strcmp(__s1, "511B8B14F417FD34A16CC128C14014AD2B4C5A60B3B053D963C78631DD6B3B89"))
    {
      return 34;
    }
    else if (!strcmp(__s1, "932639B5CA9FD3BE98F2787A2CDE095AAE9CE2D64A911486D12757EFBFD85140"))
    {
      return 35;
    }
    else if (!strcmp(__s1, "09ADF2F2D849AAB1B547CE687B45B30560D5965A6EE176E97CBC14EB63728DE2"))
    {
      return 36;
    }
    else if (!strcmp(__s1, "C2DF6BB1B96D7879744E5D54DEB55C12D7A9ECFF52AF539FC1FA63882B058A70"))
    {
      return 37;
    }
    else if (!strcmp(__s1, "8C96A68570A6DF5B4ABA9577C27042A37A60B8FBD6BC9DE3F909EC683406A5CD"))
    {
      return 38;
    }
    else if (!strcmp(__s1, "7B36DACFCE6FC736238A397E5EF2F7E25BE954A649117EE12A916CE79F75B94A"))
    {
      return 39;
    }
    else if (!strcmp(__s1, "80C734FBB111112ADB288D1CA5E1A6D5381987D38F4DFA08EFE8CC3C5F1CF131"))
    {
      return 40;
    }
    else if (!strcmp(__s1, "3A6B5C3F24147C27899AEB7FF2FE3FB579A0D79BE4AB9BE54E7F31F7AED99F24"))
    {
      return 41;
    }
    else if (!strcmp(__s1, "23C55391915968963B369CFA8F5BE79A370ADD2CB37A32A0C9267269406EC6E8"))
    {
      return 42;
    }
    else if (!strcmp(__s1, "1394031F165B7EE472518C80605434939287CE630C3E2BF45774C422646BDB52"))
    {
      return 43;
    }
    else if (!strcmp(__s1, "B664BC44BBFB5AB784B0240FFB637DC636A9B7CEE13D6D556ED1D4ED56E9DEF8"))
    {
      return 44;
    }
    else if (!strcmp(__s1, "2AD526A49877323714C9104CAF0E3F117082A43D0955315AF0F43F7AADFF2586"))
    {
      return 45;
    }
    else if (!strcmp(__s1, "0559E51C335EC81412374E33F830E804DF39F2FF796E95308A25A8A8BFA0475A"))
    {
      return 46;
    }
    else if (!strcmp(__s1, "656B51D5FF08D489CFD54BA967A44D9FBB3DEE2BEF089EADFF59F0176430773E"))
    {
      return 47;
    }
    else if (!strcmp(__s1, "08E5DC7B9F52DFF7963D2715D3927A1356E247326CAF5C76830A7D7227B991B0"))
    {
      return 48;
    }
    else if (!strcmp(__s1, "97566BDFEF237739AC2EFF164112983D98FCFAC0EE4F30C671D4908D02520208"))
    {
      return 49;
    }
    else if (!strcmp(__s1, "5ABE83ED58C646C0795991EFC53EFAF95AD3FA933AFD23A5181FDC1D4DFDFBA0"))
    {
      return 50;
    }
    else if (!strcmp(__s1, "F7FED94B5F000049299482FDF5F0D7700B1A29309A0313344D1B861FDC715239"))
    {
      return 51;
    }
    else if (!strcmp(__s1, "CD2FFA0725298FE71DCD34C05D62ABC16C9F0A5690297DF5376D65198C5D7890"))
    {
      return 52;
    }
    else if (!strcmp(__s1, "DE73E30C620D682FA8317A0FEB5087A2C63811110674D46B9894D955808CBC9E"))
    {
      return 53;
    }
    else if (!strcmp(__s1, "B1981D6FA7779DA1E867116607CFA5B05E44C5C8D8A9E8AD1906FEF7F8BA1874"))
    {
      return 54;
    }
    else if (!strcmp(__s1, "B942A1DFEF5624B827CF986CC919BB4891C1C421645311F2355CE6766AEBEF2E"))
    {
      return 55;
    }
    else if (!strcmp(__s1, "B2D70BAA5FA87BB6C253C5314B6E833D882783F1E906897B196FCC4D6572D5C6"))
    {
      return 56;
    }
    else if (!strcmp(__s1, "AD07330BE6EF87E08C9E5D058B4CBD9F71C39D7C1B916A834F263B5E7B3DFC43"))
    {
      return 57;
    }
    else if (!strcmp(__s1, "9AD2DE6034B18A80CF5573485FEEE0B7EBF72DF6DD292271C9B412FBDF8037C5"))
    {
      return 58;
    }
    else if (!strcmp(__s1, "2BBC664C4BF8238D5FC7A5376438D13CE61B9EBC1FF8EC52F6F5A80543BEACD4"))
    {
      return 59;
    }
    else if (!strcmp(__s1, "B4E21A931309227166902DC5A3E8BACAE69D267A7E733A61139712AC108C6E4E"))
    {
      return 60;
    }
    else if (!strcmp(__s1, "B0FE94C089261C381766B5366AEB1C6ACBF46BC57B4298D568C5EDFCABE30A8A"))
    {
      return 61;
    }
    else if (!strcmp(__s1, "3EFF071A6AD7AF2F6FD8A87059C9CDD5937E87D8B9B4D215C449748133129BDE"))
    {
      return 62;
    }
    else if (!strcmp(__s1, "0B5AF8D437BA25AB6225EADB7A0FC92659AAB2122AC993E00CFA2F83B0E143B3"))
    {
      return 63;
    }
    else if (!strcmp(__s1, "EE48140733BA4D00D8E6CB099101E0BBB6FDB2F71FC05FC0FEAC8A6CF3100B14"))
    {
      return 64;
    }
    else if (!strcmp(__s1, "152B31D6CDC80AD2A7F1593F1E81074F9FEB957043B213E8537F5C9098DFD449"))
    {
      return 65;
    }
    else if (!strcmp(__s1, "0E8C0AF79B626C37D4BD04D61ACC6B1841B7F784FEF6692E84A2B1971C771CF6"))
    {
      return 66;
    }
    else if (!strcmp(__s1, "12038A812C239440324EDCEB54DA13B6B7D0C4D89F61582F9A4628C4409FAAE6"))
    {
      return 67;
    }
    else if (!strcmp(__s1, "12ADE1668F06776E2CE9CC2CC563E0BD45A5346C6D883D748FD3C132E7EB8A2F"))
    {
      return 68;
    }
    else if (!strcmp(__s1, "D5D2B254E0B808929711EBFC999F2E0F884DB9876C90B056E230E4DD6D3261CE"))
    {
      return 69;
    }
    else if (!strcmp(__s1, "CA5FDEAD1B2DEC16F5B525E9AE3CA7C4EDC163EEE950D7A77A7C5284A607369F"))
    {
      return 70;
    }
    else if (!strcmp(__s1, "28B92DE785184753FAF5508E080CB8FE784D6A5214E5E6382751D52534A72FCE"))
    {
      return 71;
    }
    else if (!strcmp(__s1, "316635C054256728753D20516A98550DBF581EBA16691321F7BBCE3A9177E09D"))
    {
      return 72;
    }
    else if (!strcmp(__s1, "D2D14661D9692EBD5065F06CB4C2AC7DD14339CAEA538D5AFA4A2B5813E87D5D"))
    {
      return 73;
    }
    else if (!strcmp(__s1, "96775CCE99E1AD0C194329938D933579304BAD868B3720C34D20D27536E7AEE7"))
    {
      return 74;
    }
    else if (!strcmp(__s1, "615761368EF9DB43D1A8DF2EF1CC087B17906454F025A1E1C5BB95B022582B9B"))
    {
      return 75;
    }
    else if (!strcmp(__s1, "2A5A81F290FDE6D31DB132DD493737A7252C441023286294F3C77CE48DD4E2F0"))
    {
      return 76;
    }
    else if (!strcmp(__s1, "7262FC4EB2434704063840AB716EF14B50F3A0E5E3457E8EBF9E014325CAE94F"))
    {
      return 77;
    }
    else if (!strcmp(__s1, "A2B9B85B3AADE88EBF43D3DB522C31E6A781700C0112047F72FA920A638A69BE"))
    {
      return 78;
    }
    else if (!strcmp(__s1, "D97205C2B224673AE923C3A7A003D96258A1A774E1C9E3CD513B0706C6657D48"))
    {
      return 79;
    }
    else if (!strcmp(__s1, "0C60DB8A2A73C9B343C4B279EDF24580976BD74BD0294B1AAC17B0A4273D8C28"))
    {
      return 80;
    }
    else if (!strcmp(__s1, "27A93DA3DF54447DCB9F371C54907BEFA8F17B7FA905EDAC2B523C7A0D93A918"))
    {
      return 81;
    }
    else if (!strcmp(__s1, "F98BB9D35C454CA00A884F6B9621A30F2C78A880A96D81B5E661391D74E8455A"))
    {
      return 82;
    }
    else if (!strcmp(__s1, "AC00030F77E6F4E41BF49DC8D7A42C68813DB0C3B652C340B340C01873EB0AB7"))
    {
      return 83;
    }
    else if (!strcmp(__s1, "BA7A33DF7A125E9EE5C1036DD6DADB3B74CC4B9BA9C5C1B235C131E70B7B4E41"))
    {
      return 84;
    }
    else if (!strcmp(__s1, "038FA673BF47F15B7C5236E4863A96C910C3993AB31529A041DE199F3EEB66CB"))
    {
      return 85;
    }
    else if (!strcmp(__s1, "E44B08E42854960D4B0277D46D6181F8B07FAC3C3CCF5A6B31AA9DC9FA4057D6"))
    {
      return 86;
    }
    else if (!strcmp(__s1, "B80C09BAE4062CCC534F6E6EF6EA6E0ABEFF12048A342EB3138E7B76890D8D3B"))
    {
      return 87;
    }
    else if (!strcmp(__s1, "00EB2F035A98609505AB8DAB9B98D1FECEAA766F368932F7FE6316AE8BAEFBE0"))
    {
      return 88;
    }
    else if (!strcmp(__s1, "6368DD78E9738AAB3001F4C17EBE26BFB0414CDCC1399D092A48AB5A57536454"))
    {
      return 89;
    }
    else if (!strcmp(__s1, "C0909793BE0330B378C0CD09F0D9B9F09F599EC8C6B94C37ABA9011E83596F90"))
    {
      return 90;
    }
    else if (!strcmp(__s1, "11221127E966E92C6C18F64D312E8C9AF73DB3A9DB792E4442FCECE644A8E7B1"))
    {
      return 91;
    }
    else if (!strcmp(__s1, "FED7B076A3D7DE52B6D9A21D14FB1A49BABF975B73BE74181C4EA26976162724"))
    {
      return 92;
    }
    else if (!strcmp(__s1, "26456E27CBF6165D84C883AC666AF50E5EAAA39D07887C37BD3A9BD26A74B2FE"))
    {
      return 93;
    }
    else if (!strcmp(__s1, "F365A0CC0EEB38797FCD82D5E4AC3B2ACF44EB34D333D4AB1AD8D8891B7F8892"))
    {
      return 94;
    }
    else if (!strcmp(__s1, "A5F302F870E09D718474CBCADD4E0B3589351A5007777F1B805169B54226B875"))
    {
      return 95;
    }
    else if (!strcmp(__s1, "903B8B51F5368A75F9777D9155C6A2664116770701ED241A6D1662131A802333"))
    {
      return 96;
    }
    else if (!strcmp(__s1, "DD96D75C3E233EE9B4528803691C00E98D5F49F2B4B3B83676332ABFBB65DE07"))
    {
      return 97;
    }
    else if (!strcmp(__s1, "F2F4280636DC1065AEFE537517EE6B816C8133EF2E5C106D92DDD2B0E0DFC69D"))
    {
      return 98;
    }
    else if (!strcmp(__s1, "EA4B7DF630D01A5FC30F51DEEC420CB0F667CC57639F1C1D8E67D97B12524E0C"))
    {
      return 99;
    }
    else if (!strcmp(__s1, "89DBD24AAAD1D4D50F3F74A7040B52C5B06B4768F1E09DC89D4067D243744882"))
    {
      return 100;
    }
    else if (!strcmp(__s1, "F942A7256C77ACD182AE0B767F21133B11937660A61610A18CD14087D1F2F71C"))
    {
      return 101;
    }
    else if (!strcmp(__s1, "A739EE6D2886FEBC60795D1D8803BF19A1A3463541AB6024A90DBB8E4650F589"))
    {
      return 102;
    }
    else if (!strcmp(__s1, "7B872939683DD4D93E917C20089932C93AACDE7E7C0738CB78026B6FC178B1D9"))
    {
      return 103;
    }
    else if (!strcmp(__s1, "9EB2D21E75D0AA677C8D110763485DB3A78262C89D05CA0C3AF7EBD2D6AB99DD"))
    {
      return 104;
    }
    else if (!strcmp(__s1, "AC7E4629ABFA704A6369754CB199383D2901F0916E230FB75D765420550E8244"))
    {
      return 105;
    }
    else if (!strcmp(__s1, "FF9225FC7116F7583194D2D2F948E6CFD131F9020C7B7C9D61A8DE2F46571C5F"))
    {
      return 106;
    }
    else if (!strcmp(__s1, "3216E3D0006FC749B832DD3C33FF4B7CAE3CE455B3FE030A3EB061DC0356D829"))
    {
      return 107;
    }
    else if (!strcmp(__s1, "41E40C57A9236569333335DEA9CB52F0058A4BF366335B45406F04F7E0A93CD5"))
    {
      return 108;
    }
    else if (!strcmp(__s1, "2F5E861CD13CBCECC15CB691FCC7DCE54FC0755F96F1289D26AFB056BD6788D5"))
    {
      return 109;
    }
    else if (!strcmp(__s1, "0C7AC4ECF65C2CA6215B602A5C050FB69BFF2BA322B47A6890E2F0EE8CA922C0"))
    {
      return 110;
    }
    else if (!strcmp(__s1, "6634D05466F515CAD98B1548EE7DCC52386712E059BE4C1A3FBB157892D9D61E"))
    {
      return 111;
    }
    else if (!strcmp(__s1, "C1F228965CE72DCBDF0563CA9125430BFC5215644CF7426375AAE844D9C393CF"))
    {
      return 112;
    }
    else if (!strcmp(__s1, "860E5D173A5DA8DE4C5A88EDDF57BFB0D9E7D010DFD109852AF3D1C8480DE485"))
    {
      return 113;
    }
    else if (!strcmp(__s1, "2FAB2C822F900089CD78CBC4AB947F23F8CD8C71D0257BB20870F2437F345683"))
    {
      return 114;
    }
    else if (!strcmp(__s1, "A2AEBDCCCD11BCF937DC0DE23C78762A9FD1425DA34EE911F615F041D947D3CE"))
    {
      return 115;
    }
    else if (!strcmp(__s1, "C517BA395C2A64392D1C11AE86475E6F476E22867252458FCC5152B58A43603D"))
    {
      return 116;
    }
    else if (!strcmp(__s1, "E5FA747F28EBFE3E4BBD4BE279044F914B09502E3EB62035341300536242F90B"))
    {
      return 117;
    }
    else if (!strcmp(__s1, "7973408EAAC4FAF261DDB68AD698E34EFC1018CD38876DB49DA34E1C044F2CFC"))
    {
      return 118;
    }
    else if (!strcmp(__s1, "7EFBE7B468F2C8FF4C34E67EDC7E8F80DB3E295C6221F8408D4440A78430C64F"))
    {
      return 119;
    }
    else if (!strcmp(__s1, "D67C31C99E39309E5E09E11F7A5E7B3576972C57135463976A5539814860D051"))
    {
      return 120;
    }
    else if (!strcmp(__s1, "3473F3E1E2A85DAEEB664F0C421CDF84D3B27258796FFBB2881208B73DEFC007"))
    {
      return 121;
    }
    else if (!strcmp(__s1, "CBB7FC5C90F6950C90B30709E38AC295085E9F9A5D82EB5DF56E89752A1E0252"))
    {
      return 122;
    }
    else if (!strcmp(__s1, "1B57426DF9B957C95C4296A880A1D75B70200B72E8554E7D713D37098154E907"))
    {
      return 123;
    }
    else if (!strcmp(__s1, "F5B97BA71877E7014D8BB80B1B5750123154A26D4FD86B41AE0525EDEF44A41B"))
    {
      return 124;
    }
    else if (!strcmp(__s1, "E2175386E8858E1E5273EB120A19C734896FE34E529B7720E38F90C3E66633CC"))
    {
      return 125;
    }
    else if (!strcmp(__s1, "A5AD2AAF51022A15627C4C6C3F18D612BFF2CA7F01F65EC1C26965ED6DDC6563"))
    {
      return 126;
    }
    else if (!strcmp(__s1, "89FBB3BDB9379AD11D47A5F312EDF73706C589F07B8C14BE99A3D604DA840455"))
    {
      return 127;
    }
    else if (!strcmp(__s1, "BEE28431C5E817DF3C9C265B3672660D03A6C89EE5236507323554958AE59578"))
    {
      return 128;
    }
    else if (!strcmp(__s1, "1F6D45D5DEB05AFFD7C7C1DAC38D882FA9A9D616990FBB135621C1F0D30CA596"))
    {
      return 129;
    }
    else if (!strcmp(__s1, "24B2EDEBE37A35C073BBC2B83505D52B7FDB9C121406C6308CF528457883D4BE"))
    {
      return 130;
    }
    else if (!strcmp(__s1, "D51129E2277ED8B7AE37E82DA9F8FEB9C3FDB71EC4E4B5548B4D3763A89AF1C2"))
    {
      return 131;
    }
    else if (!strcmp(__s1, "CFEE285EA42317F1E8CE16B6BAED451F1D8029F8C057963B2486EA9093B3CD28"))
    {
      return 132;
    }
    else if (!strcmp(__s1, "AEB4C02667999241FFC01E220B4443963E1B34D3ACD2C5545F5BBE1143870378"))
    {
      return 133;
    }
    else if (!strcmp(__s1, "98A511FEF2F07DAECD3383521C19383B6DCA2C733FA4611CDFA49CC62B7B5181"))
    {
      return 134;
    }
    else if (!strcmp(__s1, "40A9788933E5BA39796E86A50864B263BC0F2291A4B895C7EA6BBB144E5DACA5"))
    {
      return 135;
    }
    else if (!strcmp(__s1, "51A34CA49D64B984F464BC878382CDD07EEF0B001EBE4F2E95026F21673969A7"))
    {
      return 136;
    }
    else if (!strcmp(__s1, "D469DF7536BAE8E1DE2CB8B3C1E14B4133343771592D97C7BCEC1D03BF0EE40A"))
    {
      return 137;
    }
    else if (!strcmp(__s1, "83B2F8BA9316B9EFB16E84445A86F4306028A166E21E7B350C8D908E696445FC"))
    {
      return 138;
    }
    else if (!strcmp(__s1, "ECE8C77FAA463F6CD7C69976F66D170E06AABA1F8EAADE7E5C2EF059C7FD1BC6"))
    {
      return 139;
    }
    else if (!strcmp(__s1, "06E83674FEE3BAEADDA04BCE4F798E64EAF9562959486A334178EFE9614AFE02"))
    {
      return 140;
    }
    else if (!strcmp(__s1, "92CB5205D6DC7B8CF67306FCBBF4D2E22C50A82E14C323C9869A8154961E1379"))
    {
      return 141;
    }
    else if (!strcmp(__s1, "CFC88028D48CFFC122779E410D958A0644A7B3219492B8F56805460AE11D3317"))
    {
      return 142;
    }
    else if (!strcmp(__s1, "87BA80BEA278BCBDE11D4ADFEA6B3C8BEF365D8260CDE3591D5B76B2C36DD853"))
    {
      return 143;
    }
    else if (!strcmp(__s1, "C38EE6AA610415ACB3D10D68E346EE868CDB70CFC2F46D887E5E152FD4A256B2"))
    {
      return 144;
    }
    else if (!strcmp(__s1, "D2D6A9827703DC8826305F130123DE83C3648F82DCB4F96DFCD7E33EA799BD62"))
    {
      return 145;
    }
    else if (!strcmp(__s1, "9B37F49C310110FE3C1D0349A0DBD1F4165E5E1873418FE3D8E02DBD2C42360F"))
    {
      return 146;
    }
    else if (!strcmp(__s1, "3E6CC5C197ACBED66DB18F36FE33CAF7D744175ADB2FE6C6FAE97B0CBB5B21CD"))
    {
      return 147;
    }
    else if (!strcmp(__s1, "250DFDD8D5BC61F9B0D9CD91F4DDCE0E4799ED7B1264EEF03FAD66612BCA288D"))
    {
      return 148;
    }
    else if (!strcmp(__s1, "6EA38ABD760FE83DDB724F359C9F761841C5BD69E5DCCC1C211D42F98751EF80"))
    {
      return 149;
    }
    else if (!strcmp(__s1, "F9F04A751DF32AED42FF9EFB131D3CD40E499AA0A99A68D0DD6778167E42BF26"))
    {
      return 150;
    }
    else if (!strcmp(__s1, "5BA476059E7B48575673F80A8DC1251E26C5B23F5DCF5BCB3AB1251D0D3424E8"))
    {
      return 151;
    }
    else if (!strcmp(__s1, "357D351342C59B72F21BD4580AD1B2F1C4C47D0006AB615A4760BC3BEBD99E48"))
    {
      return 152;
    }
    else if (!strcmp(__s1, "D613D0441777617363D2EF9031155D28A493ED4CF2B714C61332BEB8E694A21C"))
    {
      return 153;
    }
    else if (!strcmp(__s1, "8751E932723FAB8324B1EFAB05DE911953F94AB079963EC9D4882EC0F853207E"))
    {
      return 154;
    }
    else if (!strcmp(__s1, "EA870EDD0C8AD026DB44FB5C6AC53D8875D62255F794C489EAB9F8222F0616CB"))
    {
      return 155;
    }
    else if (!strcmp(__s1, "B0D00D3E15F0D45E0DAD2FE819496F3837110BDADE01AC3A17862CDDACDEE5AB"))
    {
      return 156;
    }
    else if (!strcmp(__s1, "7B4CF9B631F81D78F2CEA2F4869D0137BE4CA667AE9B13DB22A617C2BA15C075"))
    {
      return 157;
    }
    else if (!strcmp(__s1, "CA1DD5B830AB9668FC5EBD5904EB9B0113C766FCE57EF59AEC58982AE744413A"))
    {
      return 158;
    }
    else if (!strcmp(__s1, "2D29DA77B4EF8E7B1D2F3F764587274747D1C2AB05C053B4CE38AE701116BF6A"))
    {
      return 159;
    }
    else if (!strcmp(__s1, "83156D57355E76E46E7319E18EA9D6A8D20E78958733028FD3F74C3FD9B0BCC5"))
    {
      return 160;
    }
    else if (!strcmp(__s1, "95DD082534B76465BAA6B38551429C11CD11A77CB351740B05F3D18D2CD2B990"))
    {
      return 161;
    }
    else if (!strcmp(__s1, "996E91405229B0F31165936664CCE9F7D3145963C1A14FA9DD57A320E349F123"))
    {
      return 162;
    }
    else if (!strcmp(__s1, "294111BEC0EE4CFDDCE430D197B75A1CB09E21EB1C822E16CD1CBCC982D46A3F"))
    {
      return 163;
    }
    else if (!strcmp(__s1, "727820125C45F365E03E3C14E8202CFF1E0049F24543B5D589F3956E11F5C581"))
    {
      return 164;
    }
    else if (!strcmp(__s1, "33634F0DC72BA827D588E38DC75C388CF4976E4671D85148780CFAFD262B07FB"))
    {
      return 165;
    }
    else if (!strcmp(__s1, "FD6F91B4C067953424B95F0B332F0FB4A64F7E43DC4D6E8CDE26B1D5D7C07A42"))
    {
      return 166;
    }
    else if (!strcmp(__s1, "50E7E1AAC46F3CF79A6B3BB2DDC0BCDCF0ACD9011439415E47AEA7B6579F3EA8"))
    {
      return 167;
    }
    else if (!strcmp(__s1, "25C93B5B4A76FFE8A20CA68271CF612F43D0B5504B6680945F3BB046DA47213A"))
    {
      return 168;
    }
    else if (!strcmp(__s1, "B6B78FABA9FD12B688986DC5EA4D4B8B731265EDEC1E5AE52B0CAA6FC31801F2"))
    {
      return 169;
    }
    else if (!strcmp(__s1, "55DDF08ED5B641C5048444150A2D58A930D81F86EEA506CD8B4073F64FC0F1C2"))
    {
      return 170;
    }
    else if (!strcmp(__s1, "C4B3D90E89BC6B96BEB336D1A17757038334C2A490EDF56428037F1BC405BF70"))
    {
      return 171;
    }
    else if (!strcmp(__s1, "E0822A12A8DD1B222198A771537F2CE4899EB45BC94D7854E0E6FA983E6EBC89"))
    {
      return 172;
    }
    else if (!strcmp(__s1, "FB75B1EE028F765D95134B65BAFD26602EE879B247F31514268AFE1DF00830D4"))
    {
      return 173;
    }
    else if (!strcmp(__s1, "C8CAD3DF32303A6876151218FAAA63CA0642964F0528B51E0F3BBA792A0FA006"))
    {
      return 174;
    }
    else if (!strcmp(__s1, "EED11884758646FD70438F8D2661EC13F25DF1E40EC651E073736D2EFDAB9F0D"))
    {
      return 175;
    }
    else if (!strcmp(__s1, "E01BD71065BD9CE02CFEEC935E09F6DE3C3B9EFAED8F187A533C6321069B4D85"))
    {
      return 176;
    }
    else if (!strcmp(__s1, "E4079A9FE3685ED6370986B0373FFC91E49069A610571534C42255467036D7CD"))
    {
      return 177;
    }
    else if (!strcmp(__s1, "6060A012307BC0711368543129DC26F4493F2C5C30CAF9D4F782C065929930B3"))
    {
      return 178;
    }
    else if (!strcmp(__s1, "11F678510139CFDE77DC68F07F633C61D28564C9B207D45849B5E6AB72B41E0A"))
    {
      return 179;
    }
    else if (!strcmp(__s1, "9C397DD48F0AD6AAD1F9B2ABA077E5808FA3D4E452B659013FF3CEC6D1EB1472"))
    {
      return 180;
    }
    else if (!strcmp(__s1, "D1922B4CF1F4DC1E2062378D34EE4E6EAB398BD0417BC95E5EF60C5C1F53E035"))
    {
      return 181;
    }
    else if (!strcmp(__s1, "7D8633F6EB10ABA43002BB46D28FA26BFFA1093AB39728908221CE3FD922C72D"))
    {
      return 182;
    }
    else if (!strcmp(__s1, "DFF91EC9DAE4F9D14485F569D87B6AC75F93DD47C850ACF09E9DD7A3D0EFCE8A"))
    {
      return 183;
    }
    else if (!strcmp(__s1, "8F37B8C186E20EAB68B65FA965112E8C106205370CA0829C3EBD548C49C99A46"))
    {
      return 184;
    }
    else if (!strcmp(__s1, "3FAA4DE8275531852B39C91E52291523AEA993A6114D2CF7645F7C8AC1EF27CE"))
    {
      return 185;
    }
    else if (!strcmp(__s1, "6FFBFD65F64B0F892C812D9952748E8632E02C4DF155F5E233927E6D0DC88D38"))
    {
      return 186;
    }
    else if (!strcmp(__s1, "2660D91E9E44E8375C647F1F4FDD89923B3BFA26A3AF29D5937BAF8EF1E10CFE"))
    {
      return 187;
    }
    else if (!strcmp(__s1, "3CCBBD2DBDE74F294638B5661472C6041FD802D082125437CB926C2F4E201182"))
    {
      return 188;
    }
    else if (!strcmp(__s1, "0597494BBDA7FA995805FB01DD8AD6D81CC143C09F8EFB86702288F745E3F791"))
    {
      return 189;
    }
    else if (!strcmp(__s1, "0AF6A9208DBB7C0C06A19C4C9090BF87CF00BBEE2BDFD9E0C49423DD641C1174"))
    {
      return 190;
    }
    else if (!strcmp(__s1, "6CFA2D1125EAFC658FDF0E2F1A1B4F8D315296A1AFB116D0A8ECF669C026FF69"))
    {
      return 191;
    }
    else if (!strcmp(__s1, "0D32627A10C5DB983D8E5DF466E154001CBB4E945D22A4E280A08C8D0F1701A7"))
    {
      return 192;
    }
    else if (!strcmp(__s1, "B6C42286FD0AB628E79B9D4F5F10DC31C2DFD460570800BEB5C9E53651363C7D"))
    {
      return 193;
    }
    else if (!strcmp(__s1, "5DCA18DF36F9FA665E30157E71359C15F04492B59DA944CC2B10D7A925843DA7"))
    {
      return 194;
    }
    else if (!strcmp(__s1, "5851D9888A5EE313F6D80CC60F6BB6ADFC20BB0BA8D9BED753F04382DF6BED1A"))
    {
      return 195;
    }
    else if (!strcmp(__s1, "FD406D36CD5763CFC9F0DD6C37C7BDC528ADF3990CF9725229F4258C1758C94D"))
    {
      return 196;
    }
    else if (!strcmp(__s1, "EC02EE62A95DE2B0B2BC9C65A400E1318CFD7FFA894EECC7B23F8FB164A10C08"))
    {
      return 197;
    }
    else if (!strcmp(__s1, "81E23B94D526C5353E9E499DE4D53C13BAC39B09D64961C3259B99425E493446"))
    {
      return 198;
    }
    else if (!strcmp(__s1, "D36BDC945E9A3C2158D269457AE35CC5AD63543965D991AB68A2CC0556E31D50"))
    {
      return 199;
    }
    else if (!strcmp(__s1, "EEC15933C85F49CDCD9A4DC75821303FD2E5E1A8E2651667DB103FF51457DF71"))
    {
      return 200;
    }
    else if (!strcmp(__s1, "19FCC75261554C74A79C9151422F265347FC6282808C4BB8E9627195837B3682"))
    {
      return 201;
    }
    else if (!strcmp(__s1, "54D70702DEC6F85C65B8D1E26F089610058B0CDC6B23440F6FD07F26E6E23315"))
    {
      return 202;
    }
    else if (!strcmp(__s1, "244B94B5F2129A5A0083F3661EAC9C6B9EB5FB62A499E6ED236452F5BE6828F5"))
    {
      return 203;
    }
    else if (!strcmp(__s1, "2C9ACA342CA7C8F4A29CA1C798155F709AC8B8D95F0D20C549DBC00F1C42184D"))
    {
      return 204;
    }
    else if (!strcmp(__s1, "972B60C198C39199A11F25454037CADA381BB118BE18D850A36534F88A82B7F1"))
    {
      return 205;
    }
    else if (!strcmp(__s1, "0AAC94B02176D8B144479EAFEE546A608C8B5E61D7A27481868626A7820E0CB1"))
    {
      return 206;
    }
    else if (!strcmp(__s1, "5537928133BBD235A03487186F42FBFF9D0FC45873C83FD5219EB5EBF500ED10"))
    {
      return 207;
    }
    else if (!strcmp(__s1, "1ADDCB1D74CE36E8E4C6007CDB14DD6A053A9C2FBDB707345B3C5E7BB07299AA"))
    {
      return 208;
    }
    else if (!strcmp(__s1, "353FBA19946FC52BCED9C06F6EE4844496369F4985110F6E78E467505E48C88F"))
    {
      return 209;
    }
    else if (!strcmp(__s1, "E2D94E3051875514422124C186B05CDA6F417AF1FC67511A17055B65BED227AA"))
    {
      return 210;
    }
    else if (!strcmp(__s1, "E9FDDF0E4E3D3ABB4D40C135F207C0310E5BE4CCF2EC1099CB89594DD756B745"))
    {
      return 211;
    }
    else if (!strcmp(__s1, "A6DE7D11FD45FD0B0F5541862F786FAAA17E530F3CBAC5CE63EFD6C7B7B8EC27"))
    {
      return 212;
    }
    else if (!strcmp(__s1, "53E08B2D38CDBBC0D198B95302BCC632B50E773651E9BA4C57373B002114CBBC"))
    {
      return 213;
    }
    else if (!strcmp(__s1, "E21086636B17AA11D0ECA0545AB90C82D396EB03C6D33A9DE49DEEC71BFEC9A3"))
    {
      return 214;
    }
    else if (!strcmp(__s1, "18487C9D7CEF0D61908387ACBCC7316000F44757B4F9C98EA18217C35C6ECF85"))
    {
      return 215;
    }
    else if (!strcmp(__s1, "274A1E04D620A2A93E0AAFC7DB5F0BC3A6322D745709FD3011852A7608D0DC59"))
    {
      return 216;
    }
    else if (!strcmp(__s1, "A6C2B5EE1745CD5EB5C81F2B31F5E946A0C1BDC93B226BB05571EFA08555EF8F"))
    {
      return 217;
    }
    else
    {
      return 218;
    }
  }
  return result;
}

uint64_t sub_1B4B78(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = a2 - 128;
  if (a2 < 0x80)
  {
    v3 = (char *)&unk_4C794C + 4 * (int)a2;
    return *(unsigned int *)v3;
  }
  if (v2 < 0x40)
  {
    uint64_t v4 = (char *)&unk_4C7B4C;
LABEL_7:
    v3 = &v4[4 * v2];
    return *(unsigned int *)v3;
  }
  unsigned int v2 = a2 - 192;
  if (a2 - 192 < 0x1A)
  {
    uint64_t v4 = (char *)&unk_4C7C4C;
    goto LABEL_7;
  }
  return 16;
}

uint64_t sub_1B4BCC(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 8))(a1);
}

void sub_1B4C04(os_log_t log)
{
  int v1 = 136315650;
  unsigned int v2 = "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/Dependencies/AGXProfilingSupport/AGXProfilingSupport/APS/AGX"
       "PSAPSParserGen1.cpp";
  __int16 v3 = 1024;
  int v4 = 656;
  __int16 v5 = 2080;
  uint64_t v6 = "false && \"No current threadgroup size when handling THPOS_SAME_SIZE\"";
  _os_log_error_impl(&def_1C1270, log, OS_LOG_TYPE_ERROR, "%s:%u: failed assertion: %s", (uint8_t *)&v1, 0x1Cu);
}

void sub_1B4CAC()
{
  byte_771E60 = 0;
  *(_OWORD *)&qword_771E68 = 0u;
  *(_OWORD *)&qword_771E78 = 0u;
  unk_771E88 = 0u;
  qword_771E98 = 0;
  dword_771EA0 = 1065353216;
  *(_OWORD *)qword_771EA8 = 0u;
  *(_OWORD *)&qword_771EA8[2] = 0u;
  dword_771EC8 = 1065353216;
  xmmword_771ED0 = 0u;
  unk_771EE0 = 0u;
  dword_771EF0 = 1065353216;
  unk_771EF8 = 0u;
  unk_771F08 = 0u;
  dword_771F18 = 1065353216;
  xmmword_771F20 = 0u;
  unk_771F30 = 0u;
  dword_771F40 = 1065353216;
  unk_771F58 = 0u;
  unk_771F48 = 0u;
  dword_771F68 = 1065353216;
  __cxa_atexit((void (*)(void *))sub_5780, &byte_771E60, &def_1C1270);
  qword_773100 = 0;
  *(void *)algn_773108 = 0;
}

uint64_t sub_1B4D68()
{
  uint64_t result = sub_D5D4();
  qword_771FE0 = result;
  *(void *)algn_771FE8 = v1;
  return result;
}

const char *AppendString(const char *result, int *a2)
{
  if (result)
  {
    __int16 v3 = result;
    size_t v4 = strlen(result);
    int v5 = v4 + 1;
    uint64_t result = (const char *)memcpy((char *)a2 + *a2, v3, v4 + 1);
    int v6 = *a2 + v5;
  }
  else
  {
    *(void *)((char *)a2 + *a2) = 0xFFFFFFFFLL;
    int v6 = *a2 + 8;
  }
  *a2 = v6;
  return result;
}

void DYTraceEncode_InternalData(uint64_t a1, unsigned int *a2)
{
  uint64_t v3 = a1;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  *(void *)a2 = 0xFFFFD01000000024;
  a2[8] = 198;
  int v4 = *(_DWORD *)(a1 + 8);
  switch(v4)
  {
    case 101:
      uint64_t v14 = *(void *)(a1 + 40);
      if (v14)
      {
        *(void *)(a2 + 9) = 0x536C536C756943;
        uint64_t v15 = 44;
      }
      else
      {
        strcpy((char *)a2 + 36, "CiulSl");
        uint64_t v15 = 43;
      }
      bzero((char *)a2 + v15, 44 - v15);
      *a2 = 44;
      *(void *)(a2 + 11) = *(void *)v3;
      *a2 = 52;
      a2[13] = *(_DWORD *)(v3 + 8);
      *a2 = 56;
      *((void *)a2 + 7) = *(void *)(v3 + 16);
      *a2 = 64;
      AppendString(*(const char **)(v3 + 32), (int *)a2);
      uint64_t v22 = *a2;
      uint64_t v23 = (v22 + 3) & 0xFFFFFFFC;
      bzero((char *)a2 + v22, v23 - v22);
      *a2 = v23;
      *(void *)((char *)a2 + v23) = *(void *)(v3 + 24);
      unsigned int v24 = *a2 + 8;
      *a2 = v24;
      if (v14)
      {
        AppendString(*(const char **)(v3 + 40), (int *)a2);
        unsigned int v24 = *a2;
      }
      uint64_t v3 = (v24 + 3) & 0xFFFFFFFC;
      bzero((char *)a2 + v24, v3 - v24);
      break;
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 112:
    case 113:
    case 114:
    case 115:
    case 121:
    case 122:
    case 123:
    case 124:
    case 130:
    case 131:
    case 133:
    case 134:
      goto LABEL_7;
    case 107:
      strcpy((char *)a2 + 36, "Ciulul");
      *((unsigned char *)a2 + 43) = 0;
      *a2 = 44;
      *(void *)(a2 + 11) = *(void *)a1;
      *a2 = 52;
      a2[13] = *(_DWORD *)(a1 + 8);
      *a2 = 56;
      *((void *)a2 + 7) = *(void *)(a1 + 16);
      *a2 = 64;
      *((void *)a2 + 8) = *(void *)(a1 + 24);
      LODWORD(v3) = 72;
      break;
    case 108:
      strcpy((char *)a2 + 36, "CitS");
      *(_WORD *)((char *)a2 + 41) = 0;
      *((unsigned char *)a2 + 43) = 0;
      *a2 = 44;
      *(void *)(a2 + 11) = *(void *)a1;
      *a2 = 52;
      a2[13] = *(_DWORD *)(a1 + 8);
      *a2 = 56;
      *((void *)a2 + 7) = *(void *)(a1 + 16);
      *a2 = 64;
      goto LABEL_21;
    case 109:
    case 120:
      strcpy((char *)a2 + 36, "CiSululb");
      *(_WORD *)((char *)a2 + 45) = 0;
      *((unsigned char *)a2 + 47) = 0;
      *a2 = 48;
      *((void *)a2 + 6) = *(void *)a1;
      *a2 = 56;
      a2[14] = *(_DWORD *)(a1 + 8);
      *a2 = 60;
      AppendString(*(const char **)(a1 + 32), (int *)a2);
      uint64_t v7 = *a2;
      uint64_t v8 = (v7 + 3) & 0xFFFFFFFC;
      bzero((char *)a2 + v7, v8 - v7);
      *a2 = v8;
      *(void *)((char *)a2 + v8) = *(void *)(v3 + 16);
      unsigned int v9 = *a2 + 8;
      *a2 = v9;
      *(void *)((char *)a2 + v9) = *(void *)(v3 + 24);
      unsigned int v10 = *a2 + 8;
      *a2 = v10;
      *((unsigned char *)a2 + v10) = *(unsigned char *)(v3 + 40);
      uint64_t v11 = *a2 + 1;
      uint64_t v3 = (*a2 & 0xFFFFFFFC) + 4;
      v12 = (char *)a2 + v11;
      size_t v13 = v3 - v11;
      goto LABEL_23;
    case 110:
      *(void *)(a2 + 9) = 0x696C756943;
      *a2 = 44;
      *(void *)(a2 + 11) = *(void *)a1;
      *a2 = 52;
      a2[13] = *(_DWORD *)(a1 + 8);
      *a2 = 56;
      *((void *)a2 + 7) = *(void *)(a1 + 16);
      *a2 = 64;
      a2[16] = *(_DWORD *)(a1 + 24);
      LODWORD(v3) = 68;
      break;
    case 111:
      int v5 = 5597507;
      goto LABEL_3;
    case 116:
      *(void *)(a2 + 9) = 0x6C75556943;
      *a2 = 44;
      *(void *)(a2 + 11) = *(void *)a1;
      *a2 = 52;
      a2[13] = *(_DWORD *)(a1 + 8);
      *a2 = 56;
      AppendString(*(const char **)(a1 + 16), (int *)a2);
      uint64_t v16 = *a2;
      uint64_t v17 = (v16 + 3) & 0xFFFFFFFC;
      bzero((char *)a2 + v16, v17 - v16);
      *a2 = v17;
      *(void *)((char *)a2 + v17) = *(void *)(v3 + 24);
      LODWORD(v3) = *a2 + 8;
      break;
    case 117:
    case 127:
    case 128:
    case 129:
    case 132:
      int v5 = 5466435;
LABEL_3:
      a2[9] = v5;
      *a2 = 40;
      *((void *)a2 + 5) = *(void *)a1;
      *a2 = 48;
      a2[12] = *(_DWORD *)(a1 + 8);
      *a2 = 52;
      int v6 = *(const char **)(a1 + 16);
      goto LABEL_22;
    case 118:
      strcpy((char *)a2 + 36, "Ciul");
      *(_WORD *)((char *)a2 + 41) = 0;
      *((unsigned char *)a2 + 43) = 0;
      *a2 = 44;
      *(void *)(a2 + 11) = *(void *)a1;
      *a2 = 52;
      a2[13] = *(_DWORD *)(a1 + 8);
      *a2 = 56;
      uint64_t v18 = *(void *)(a1 + 16);
      goto LABEL_18;
    case 119:
      *(void *)(a2 + 9) = 0x53535369756943;
      *a2 = 44;
      *(void *)(a2 + 11) = *(void *)a1;
      *a2 = 52;
      a2[13] = *(_DWORD *)(a1 + 8);
      *a2 = 56;
      a2[14] = *(_DWORD *)(a1 + 40);
      *a2 = 60;
      AppendString(*(const char **)(a1 + 16), (int *)a2);
      AppendString(*(const char **)(v3 + 24), (int *)a2);
      int v6 = *(const char **)(v3 + 32);
      goto LABEL_22;
    case 125:
      strcpy((char *)a2 + 36, "Ciul");
      *(_WORD *)((char *)a2 + 41) = 0;
      *((unsigned char *)a2 + 43) = 0;
      *a2 = 44;
      *(void *)(a2 + 11) = *(void *)a1;
      *a2 = 52;
      a2[13] = *(_DWORD *)(a1 + 8);
      *a2 = 56;
      uint64_t v18 = *(void *)(a1 + 24);
LABEL_18:
      *((void *)a2 + 7) = v18;
      LODWORD(v3) = 64;
      break;
    case 126:
      strcpy((char *)a2 + 36, "CiSS");
      *(_WORD *)((char *)a2 + 41) = 0;
      *((unsigned char *)a2 + 43) = 0;
      *a2 = 44;
      *(void *)(a2 + 11) = *(void *)a1;
      *a2 = 52;
      a2[13] = *(_DWORD *)(a1 + 8);
      *a2 = 56;
      AppendString(*(const char **)(a1 + 16), (int *)a2);
      goto LABEL_21;
    case 135:
      strcpy((char *)a2 + 36, "CiSS");
      *(_WORD *)((char *)a2 + 41) = 0;
      *((unsigned char *)a2 + 43) = 0;
      *a2 = 44;
      *(void *)(a2 + 11) = *(void *)a1;
      *a2 = 52;
      a2[13] = *(_DWORD *)(a1 + 8);
      *a2 = 56;
      AppendString(*(const char **)(a1 + 16), (int *)a2);
      uint64_t v19 = *a2;
      uint64_t v20 = (v19 + 3) & 0xFFFFFFFC;
      bzero((char *)a2 + v19, v20 - v19);
      *a2 = v20;
LABEL_21:
      int v6 = *(const char **)(v3 + 24);
LABEL_22:
      AppendString(v6, (int *)a2);
      uint64_t v21 = *a2;
      uint64_t v3 = (v21 + 3) & 0xFFFFFFFC;
      v12 = (char *)a2 + v21;
      size_t v13 = v3 - v21;
LABEL_23:
      bzero(v12, v13);
      break;
    default:
      if (v4 == 7)
      {
        strcpy((char *)a2 + 36, "Ciui");
        *(_WORD *)((char *)a2 + 41) = 0;
        *((unsigned char *)a2 + 43) = 0;
        *a2 = 44;
        *(void *)(a2 + 11) = *(void *)a1;
        *a2 = 52;
        a2[13] = *(_DWORD *)(a1 + 8);
        *a2 = 56;
        a2[14] = *(_DWORD *)(a1 + 16);
        LODWORD(v3) = 60;
      }
      else
      {
LABEL_7:
        a2[9] = 26947;
        *a2 = 40;
        *((void *)a2 + 5) = *(void *)a1;
        *a2 = 48;
        a2[12] = *(_DWORD *)(a1 + 8);
        LODWORD(v3) = 52;
      }
      break;
  }
  *a2 = v3;
}

void DYTraceEncode_MTLCommandBuffer_restoreMTLBufferContents(uint64_t a1, unsigned int *a2)
{
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *((void *)a2 + 3) = 0;
  *(void *)a2 = 0xFFFFD80000000024;
  a2[8] = 4;
  strcpy((char *)a2 + 36, "CtU<b>ulul");
  *((unsigned char *)a2 + 47) = 0;
  *a2 = 48;
  *((void *)a2 + 6) = *(void *)a1;
  *a2 = 56;
  *((void *)a2 + 7) = *(void *)(a1 + 8);
  *a2 = 64;
  AppendString(*(const char **)(a1 + 16), (int *)a2);
  uint64_t v4 = *a2;
  uint64_t v5 = (v4 + 3) & 0xFFFFFFFC;
  bzero((char *)a2 + v4, v5 - v4);
  *a2 = v5;
  *(void *)((char *)a2 + v5) = *(void *)(a1 + 24);
  unsigned int v6 = *a2 + 8;
  *a2 = v6;
  *(void *)((char *)a2 + v6) = *(void *)(a1 + 32);
  *a2 += 8;
}

void *GTHarvesterGetMetadata(void *a1, unint64_t a2)
{
  uint64_t result = 0;
  if (a1 && a2 >= 0x10)
  {
    if (*a1 == 0x63617074757265) {
      return a1;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t GTHarvesterGetData(uint64_t result, unint64_t a2)
{
  if (result && a2 >= 0x10 && *(void *)result == 0x63617074757265)
  {
    uint64_t v2 = *(int *)(result + 12);
    if (*(_WORD *)(result + 8) == 1) {
      v2 += 16;
    }
    result += v2;
  }
  return result;
}

uint64_t GTHarvesterGetTexturePlaneCount(uint64_t result)
{
  if (result)
  {
    if (*(_WORD *)(result + 10) == 1) {
      return *(void *)(result + 16);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t GTHarvesterGetTexturePlane(uint64_t result, unint64_t a2)
{
  if (result)
  {
    if (*(_WORD *)(result + 10) == 1)
    {
      if (*(void *)(result + 16) >= a2) {
        result += 48 * a2 + 24;
      }
      else {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::enumerateIntersectionFunctionTableFunctions(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v3 = *(void **)(a1 + 272);
    if (v3)
    {
      unint64_t v5 = *(void *)(a2 + 16);
      unsigned int v6 = (void *)(a1 + 272);
      do
      {
        unint64_t v7 = v3[4];
        BOOL v8 = v7 >= v5;
        if (v7 >= v5) {
          unsigned int v9 = v3;
        }
        else {
          unsigned int v9 = v3 + 1;
        }
        if (v8) {
          unsigned int v6 = v3;
        }
        uint64_t v3 = (void *)*v9;
      }
      while (*v9);
      if (v6 != (void *)(a1 + 272) && v5 >= v6[4])
      {
        uint64_t v10 = *(void *)(*(void *)(a1 + 208) + 8);
        if (v10)
        {
          id v17 = *(id *)(v10 + 8);
          if (!v17 || (uint64_t v11 = v6[5], v11 == v6[6]))
          {
LABEL_19:
          }
          else
          {
            uint64_t v12 = 0;
            while (1)
            {
              size_t v13 = [v17 functionForKey:*(void *)(v11 + 48)];
              char v14 = *(unsigned char *)(v11 + 73);
              uint64_t v21 = v12;
              char v20 = v14;
              id v15 = v13;
              uint64_t v18 = v11;
              id v19 = v15;
              uint64_t v16 = *(void *)(a3 + 24);
              if (!v16) {
                break;
              }
              (*(void (**)(uint64_t, uint64_t *, char *, id *, uint64_t *))(*(void *)v16 + 48))(v16, &v21, &v20, &v19, &v18);

              ++v12;
              v11 += 152;

              if (v11 == v6[6]) {
                goto LABEL_19;
              }
            }
            std::__throw_bad_function_call[abi:nn180100]();
            __break(1u);
          }
        }
      }
    }
  }
}

void sub_1B97F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(a1);
}

uint64_t std::__throw_bad_function_call[abi:nn180100]()
{
  return AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::applyUsedResources();
}

void AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::applyUsedResources(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v3 = (void *)(a1 + 328);
  while (1)
  {
    uint64_t v3 = (void *)*v3;
    if (!v3) {
      break;
    }
    [v4 useResources:count:usage:];
  }
  [v4 useHeaps:count:];
}

void sub_1B98BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::buildVisibleFunctionTableInPipeline(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (!a2)
  {
    id v12 = 0;
    goto LABEL_41;
  }
  unsigned int v6 = *(id **)(*(void *)(a1 + 208) + 8);
  id v7 = v6[1];
  BOOL v8 = (char *)*v6;
  uint64_t v9 = *((void *)*v6 + 10);
  uint64_t v10 = *(void *)(a1 + 288);
  id v11 = objc_alloc_init((Class)MTLVisibleFunctionTableDescriptor);
  [v11 setFunctionCount:*(void *)(a2 + 24)];
  id v12 = [v5 newVisibleFunctionTableWithDescriptor:v11];
  unint64_t v13 = v10 + v9;

  newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, v14);
  uint64_t v52 = 0;
  memset(v51, 0, sizeof(v51));
  GTMTLIndirectResources_allResourcesByKey((uint64_t *)v51, *((_DWORD ***)v8 + 5), v13, 1, newpool);
  uint64_t v15 = *((void *)v8 + 1);
  uint64_t v54 = *(void *)(a2 + 16);
  uint64_t v16 = *(void *)(*(void *)(*find_entry(v15, &v54, 8uLL, 0) + 32) + 32);
  if (v16)
  {
    unsigned int v17 = 0;
    while (1)
    {
      unsigned int v18 = atomic_load((unsigned int *)(v16 + 4));
      unsigned int v19 = v17 + (v18 >> 6);
      unsigned int v20 = v19 - 1;
      if ((int)(v19 - 1) > 0) {
        break;
      }
      uint64_t v16 = *(void *)(v16 + 40);
      unsigned int v17 = v19 - 1;
      if (!v16) {
        goto LABEL_9;
      }
    }
    unsigned int v20 = 0;
    unsigned int v23 = v17;
    uint64_t v22 = (uint64_t *)(v8 + 16);
    uint64_t v28 = v16 - ((uint64_t)(int)v17 << 6);
    if ((*(unsigned char *)(v28 + 79) & 8) != 0) {
      uint64_t v21 = v28 + 64;
    }
    else {
      uint64_t v21 = 0;
    }
  }
  else
  {
    unsigned int v20 = 0;
LABEL_9:
    uint64_t v16 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = (uint64_t *)(v8 + 16);
    unsigned int v23 = v20;
  }
  GTMTLSMIntersectionFunctionTableStateful_processTraceFuncWithMap((uint64_t)v47, *v22, v21, (uint64_t *)v51);
  unint64_t v49 = *(unsigned int *)(v47[13] + 8);
  unint64_t v48 = (char *)apr_palloc(newpool, 16 * v49);
  bzero(v48, 16 * v49);
  unsigned int v24 = atomic_load((unsigned int *)(v16 + 4));
  unsigned int v25 = v23 + (v24 >> 6);
  uint64_t v26 = v20 + 1;
  if (v26 == v25 - 1)
  {
    uint64_t v27 = (v26 << 32) | v26;
LABEL_16:
    uint64_t v16 = *(void *)(v16 + 40);
  }
  else
  {
    uint64_t v27 = (v26 << 32) | v23;
  }
  uint64_t v29 = v16 + 64;
  while (v16)
  {
    if ((*(unsigned char *)(v29 + ((uint64_t)(HIDWORD(v27) - (int)v27) << 6) + 15) & 8) == 0) {
      break;
    }
    unint64_t v30 = (unint64_t *)(v29 + ((uint64_t)(HIDWORD(v27) - (int)v27) << 6));
    if (v13 <= *v30) {
      break;
    }
    GTMTLSMIntersectionFunctionTableStateful_processTraceFuncWithMap((uint64_t)v47, *v22, (uint64_t)v30, (uint64_t *)v51);
    unsigned int v31 = atomic_load((unsigned int *)(v16 + 4));
    int v32 = v27 + (v31 >> 6);
    uint64_t v33 = (HIDWORD(v27) + 1);
    uint64_t v27 = (v33 << 32) | v27;
    if (v33 == v32 - 1)
    {
      uint64_t v27 = (v33 << 32) | v33;
      goto LABEL_16;
    }
  }
  if (v49)
  {
    uint64_t v34 = 0;
    for (unint64_t i = 0; i < v49; ++i)
    {
      int v36 = *(_DWORD *)&v48[v34];
      if ((v36 - 2) >= 2)
      {
        if (v36 == 1)
        {
          Object = GTMTLSMContext_getObject(**((void **)v8 + 5), *(void *)&v48[v34 + 8], v13);
          if (Object)
          {
            unint64_t v38 = [v7 functionForKey:Object[5]];
            unint64_t v39 = [v5 functionHandleWithFunction:v38];
            [v12 setFunction:v39 atIndex:i];
          }
        }
      }
      else
      {
        [v12 setValue:1 atIndex:i];
      }
      v34 += 16;
    }
  }
  uint64_t v40 = 0;
  uint64_t v41 = &v50;
  do
  {
    int v42 = *((_DWORD *)v41 - 4);
    if (v42 == 2)
    {
      unint64_t v45 = GTMTLSMContext_getObject(**((void **)v8 + 5), *(v41 - 1), v13);
      if (!v45) {
        goto LABEL_39;
      }
      unint64_t v44 = [v7 visibleFunctionTableForKey:v45[1]];
      [v12 setVisibleFunctionTable:v44 atBufferIndex:v40];
      goto LABEL_38;
    }
    if (v42 == 1)
    {
      unint64_t v43 = GTMTLSMContext_getObject(**((void **)v8 + 5), *(v41 - 1), v13);
      if (v43)
      {
        unint64_t v44 = [v7 bufferForKey:v43[1]];
        [v12 setBuffer:v44 offset:*v41 atIndex:v40];
LABEL_38:
      }
    }
LABEL_39:
    ++v40;
    v41 += 3;
  }
  while (v40 != 31);
  apr_pool_destroy(newpool);

LABEL_41:

  return v12;
}

void sub_1B9CDC()
{
  JUMPOUT(0x1B9D10);
}

id AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::buildIntersectionFunctionTableInPipeline(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (!a2)
  {
    id v12 = 0;
    goto LABEL_43;
  }
  unsigned int v6 = *(id **)(*(void *)(a1 + 208) + 8);
  id v7 = v6[1];
  BOOL v8 = (char *)*v6;
  uint64_t v9 = *((void *)*v6 + 10);
  uint64_t v10 = *(void *)(a1 + 288);
  id v11 = objc_alloc_init((Class)MTLIntersectionFunctionTableDescriptor);
  [v11 setFunctionCount:*(void *)(a2 + 24)];
  id v12 = [v5 newIntersectionFunctionTableWithDescriptor:v11];
  unint64_t v13 = v10 + v9;

  newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, v14);
  uint64_t v52 = 0;
  memset(v51, 0, sizeof(v51));
  GTMTLIndirectResources_allResourcesByKey((uint64_t *)v51, *((_DWORD ***)v8 + 5), v13, 1, newpool);
  uint64_t v15 = *((void *)v8 + 1);
  uint64_t v54 = *(void *)(a2 + 16);
  uint64_t v16 = *(void *)(*(void *)(*find_entry(v15, &v54, 8uLL, 0) + 32) + 32);
  if (v16)
  {
    unsigned int v17 = 0;
    while (1)
    {
      unsigned int v18 = atomic_load((unsigned int *)(v16 + 4));
      unsigned int v19 = v17 + (v18 >> 6);
      unsigned int v20 = v19 - 1;
      if ((int)(v19 - 1) > 0) {
        break;
      }
      uint64_t v16 = *(void *)(v16 + 40);
      unsigned int v17 = v19 - 1;
      if (!v16) {
        goto LABEL_9;
      }
    }
    unsigned int v20 = 0;
    unsigned int v23 = v17;
    uint64_t v22 = (uint64_t *)(v8 + 16);
    uint64_t v28 = v16 - ((uint64_t)(int)v17 << 6);
    if ((*(unsigned char *)(v28 + 79) & 8) != 0) {
      uint64_t v21 = v28 + 64;
    }
    else {
      uint64_t v21 = 0;
    }
  }
  else
  {
    unsigned int v20 = 0;
LABEL_9:
    uint64_t v16 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = (uint64_t *)(v8 + 16);
    unsigned int v23 = v20;
  }
  GTMTLSMIntersectionFunctionTableStateful_processTraceFuncWithMap((uint64_t)v47, *v22, v21, (uint64_t *)v51);
  unint64_t v49 = *(unsigned int *)(v47[13] + 8);
  unint64_t v48 = (char *)apr_palloc(newpool, 16 * v49);
  bzero(v48, 16 * v49);
  unsigned int v24 = atomic_load((unsigned int *)(v16 + 4));
  unsigned int v25 = v23 + (v24 >> 6);
  uint64_t v26 = v20 + 1;
  if (v26 == v25 - 1)
  {
    uint64_t v27 = (v26 << 32) | v26;
LABEL_16:
    uint64_t v16 = *(void *)(v16 + 40);
  }
  else
  {
    uint64_t v27 = (v26 << 32) | v23;
  }
  uint64_t v29 = v16 + 64;
  while (v16)
  {
    if ((*(unsigned char *)(v29 + ((uint64_t)(HIDWORD(v27) - (int)v27) << 6) + 15) & 8) == 0) {
      break;
    }
    unint64_t v30 = (unint64_t *)(v29 + ((uint64_t)(HIDWORD(v27) - (int)v27) << 6));
    if (v13 <= *v30) {
      break;
    }
    GTMTLSMIntersectionFunctionTableStateful_processTraceFuncWithMap((uint64_t)v47, *v22, (uint64_t)v30, (uint64_t *)v51);
    unsigned int v31 = atomic_load((unsigned int *)(v16 + 4));
    int v32 = v27 + (v31 >> 6);
    uint64_t v33 = (HIDWORD(v27) + 1);
    uint64_t v27 = (v33 << 32) | v27;
    if (v33 == v32 - 1)
    {
      uint64_t v27 = (v33 << 32) | v33;
      goto LABEL_16;
    }
  }
  if (v49)
  {
    uint64_t v34 = 0;
    for (unint64_t i = 0; i < v49; ++i)
    {
      int v36 = *(_DWORD *)&v48[v34];
      switch(v36)
      {
        case 3:
          [v12 setOpaqueCurveIntersectionFunctionWithSignature:*(void *)&v48[v34 + 8] atIndex:i];
          break;
        case 2:
          [v12 setOpaqueTriangleIntersectionFunctionWithSignature:*(void *)&v48[v34 + 8] atIndex:i];
          break;
        case 1:
          Object = GTMTLSMContext_getObject(**((void **)v8 + 5), *(void *)&v48[v34 + 8], v13);
          if (Object)
          {
            unint64_t v38 = [v7 functionForKey:Object[5]];
            unint64_t v39 = [v5 functionHandleWithFunction:v38];
            [v12 setFunction:v39 atIndex:i];
          }
          break;
      }
      v34 += 16;
    }
  }
  uint64_t v40 = 0;
  uint64_t v41 = &v50;
  do
  {
    int v42 = *((_DWORD *)v41 - 4);
    if (v42 == 2)
    {
      unint64_t v45 = GTMTLSMContext_getObject(**((void **)v8 + 5), *(v41 - 1), v13);
      if (!v45) {
        goto LABEL_41;
      }
      unint64_t v44 = [v7 visibleFunctionTableForKey:v45[1]];
      [v12 setVisibleFunctionTable:v44 atBufferIndex:v40];
      goto LABEL_40;
    }
    if (v42 == 1)
    {
      unint64_t v43 = GTMTLSMContext_getObject(**((void **)v8 + 5), *(v41 - 1), v13);
      if (v43)
      {
        unint64_t v44 = [v7 bufferForKey:v43[1]];
        [v12 setBuffer:v44 offset:*v41 atIndex:v40];
LABEL_40:
      }
    }
LABEL_41:
    ++v40;
    v41 += 3;
  }
  while (v40 != 31);
  apr_pool_destroy(newpool);

LABEL_43:

  return v12;
}

void sub_1BA148()
{
  JUMPOUT(0x1BA17CLL);
}

void AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::generateItems(id *this)
{
  AccelerationStructureViewerServer::DataSource::generateItems((AccelerationStructureViewerServer::DataSource *)this);
  uint64_t v3 = this[23];
  uint64_t v2 = this[24];
  if (v2 != (unsigned char *)v3)
  {
    unint64_t v4 = 0;
    id v5 = this + 5;
    unsigned int v6 = (char *)(this + 34);
    uint64_t v51 = (char *)(this + 5);
    do
    {
      id v7 = (void *)*v5;
      if (*v5)
      {
        unint64_t v8 = v3[23 * v4 + 2];
        uint64_t v9 = v5;
        do
        {
          unint64_t v10 = v7[4];
          BOOL v11 = v10 >= v8;
          if (v10 >= v8) {
            id v12 = v7;
          }
          else {
            id v12 = v7 + 1;
          }
          if (v11) {
            uint64_t v9 = v7;
          }
          id v7 = (void *)*v12;
        }
        while (*v12);
        if (v9 != v5 && v8 >= v9[4])
        {
          if (v4 >= (unint64_t)[this[38] count])
          {
            unint64_t v13 = 0;
          }
          else
          {
            unint64_t v13 = [this[38] objectAtIndex:v4];
          }
          uint64_t v15 = (float **)v9[5];
          char v14 = (float **)v9[6];
          for (unint64_t i = v14; v15 != v14; ++v15)
          {
            if (v13)
            {
              unint64_t v16 = *((unsigned int *)*v15 + 15);
              if ((unint64_t)[v13 count] > v16)
              {
                unsigned int v17 = [v13 objectAtIndex:*((unsigned int *)*v15 + 15)];
                if (v17)
                {
                  objc_storeStrong((id *)*v15 + 6, v17);
                  unsigned int v18 = *v15;
                  id v19 = v17;
                  unint64_t v20 = *((void *)v18 + 2);
                  unint64_t v21 = *((void *)v18 + 3);
                  if (v20 >= v21)
                  {
                    id v52 = v19;
                    unsigned int v23 = (AccelerationStructureViewerServer::MTLAccelerationStructureDataSource *)this;
                    uint64_t v24 = *((void *)v18 + 1);
                    uint64_t v25 = (uint64_t)(v20 - v24) >> 4;
                    unint64_t v26 = v25 + 1;
                    if ((unint64_t)(v25 + 1) >> 60) {
                      abort();
                    }
                    uint64_t v27 = v21 - v24;
                    if (v27 >> 3 > v26) {
                      unint64_t v26 = v27 >> 3;
                    }
                    if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0) {
                      unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v28 = v26;
                    }
                    v54[4] = v18 + 6;
                    uint64_t v29 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(v28);
                    unsigned int v31 = &v29[16 * v25];
                    *(_WORD *)unsigned int v31 = 7;
                    *((void *)v31 + 1) = v52;
                    uint64_t v33 = *((void *)v18 + 1);
                    uint64_t v32 = *((void *)v18 + 2);
                    if (v32 == v33)
                    {
                      uint64_t v35 = &v29[16 * v25];
                      this = (id *)v23;
                    }
                    else
                    {
                      uint64_t v34 = *((void *)v18 + 2);
                      uint64_t v35 = &v29[16 * v25];
                      this = (id *)v23;
                      do
                      {
                        __int16 v36 = *(_WORD *)(v34 - 16);
                        v34 -= 16;
                        *((_WORD *)v35 - 8) = v36;
                        v35 -= 16;
                        uint64_t v37 = *(void *)(v34 + 8);
                        *(void *)(v34 + 8) = 0;
                        *((void *)v35 + 1) = v37;
                      }
                      while (v34 != v33);
                    }
                    uint64_t v22 = v31 + 16;
                    *((void *)v18 + 1) = v35;
                    *((void *)v18 + 2) = v31 + 16;
                    uint64_t v38 = *((void *)v18 + 3);
                    *((void *)v18 + 3) = &v29[16 * v30];
                    v54[2] = v32;
                    v54[3] = v38;
                    v54[0] = v33;
                    v54[1] = v33;
                    std::__split_buffer<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::~__split_buffer((uint64_t)v54);
                  }
                  else
                  {
                    *(_WORD *)unint64_t v20 = 7;
                    *(void *)(v20 + 8) = v19;
                    uint64_t v22 = (char *)(v20 + 16);
                  }
                  *((void *)v18 + 2) = v22;
                  char v14 = i;
                }
              }
            }
            unint64_t v39 = (char *)this[33];
            if (v39 != v6)
            {
              uint64_t v40 = *v15;
              unint64_t v41 = *((void *)*v15 + 9);
              do
              {
                uint64_t v42 = *((void *)v39 + 5);
                if (v41 < 0x86BCA1AF286BCA1BLL * ((*((void *)v39 + 6) - v42) >> 3))
                {
                  unint64_t v43 = (float *)(v42 + 152 * v41);
                  float v44 = v43[27];
                  v43[26] = fminf(v43[26], v40[20]);
                  v43[27] = fminf(v44, v40[21]);
                  float v45 = v43[29];
                  v43[28] = fminf(v43[28], v40[22]);
                  v43[29] = fmaxf(v45, v40[23]);
                  float v46 = v43[31];
                  v43[30] = fmaxf(v43[30], v40[24]);
                  v43[31] = fmaxf(v46, v40[25]);
                }
                uint64_t v47 = (char *)*((void *)v39 + 1);
                if (v47)
                {
                  do
                  {
                    unint64_t v48 = v47;
                    uint64_t v47 = *(char **)v47;
                  }
                  while (v47);
                }
                else
                {
                  do
                  {
                    unint64_t v48 = (char *)*((void *)v39 + 2);
                    BOOL v49 = *(void *)v48 == (void)v39;
                    unint64_t v39 = v48;
                  }
                  while (!v49);
                }
                unint64_t v39 = v48;
              }
              while (v48 != v6);
            }
          }

          uint64_t v3 = this[23];
          uint64_t v2 = this[24];
          id v5 = v51;
        }
      }
      ++v4;
    }
    while (v4 < 0xD37A6F4DE9BD37A7 * ((v2 - (unsigned char *)v3) >> 3));
  }
}

void sub_1BA4FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(unint64_t a1)
{
  if (a1 >> 60) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(16 * a1);
}

uint64_t std::__split_buffer<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 16;
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

void AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::getAccelerationStructureChildren(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  id v11 = a6;
  uint64_t v15 = off_747848;
  char v16 = *(unsigned char *)(a5 + 8);
  memset(v17, 0, sizeof(v17));
  std::vector<AccelerationStructureViewer::FilterToken>::__init_with_size[abi:nn180100]<AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*>(v17, *(void *)(a5 + 16), *(void *)(a5 + 24), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a5 + 24) - *(void *)(a5 + 16)) >> 3));
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = ___ZN33AccelerationStructureViewerServer34MTLAccelerationStructureDataSource32getAccelerationStructureChildrenEyN27AccelerationStructureViewer5RangeENS1_6FilterEU13block_pointerFvRNSt3__16vectorIPNS1_21AccelerationStructureENS4_9allocatorIS7_EEEEP7NSErrorE_block_invoke;
  v13[3] = &unk_7440A8;
  id v12 = v11;
  id v14 = v12;
  AccelerationStructureViewerServer::DataSource::getAccelerationStructureChildren(a1, a2, a3, a4, (uint64_t)&v15, v13);
  uint64_t v15 = off_747848;
  unsigned int v18 = (void **)v17;
  std::vector<AccelerationStructureViewer::FilterToken>::__destroy_vector::operator()[abi:nn180100](&v18);
}

void sub_1BA6FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::vector<AccelerationStructureViewer::FilterToken>::__init_with_size[abi:nn180100]<AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unsigned int v6 = result;
    std::vector<AccelerationStructureViewer::FilterToken>::__vallocate[abi:nn180100](result, a4);
    uint64_t result = (void *)std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>,AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*>(a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

uint64_t ___ZN33AccelerationStructureViewerServer34MTLAccelerationStructureDataSource32getAccelerationStructureChildrenEyN27AccelerationStructureViewer5RangeENS1_6FilterEU13block_pointerFvRNSt3__16vectorIPNS1_21AccelerationStructureENS4_9allocatorIS7_EEEEP7NSErrorE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void std::vector<AccelerationStructureViewer::FilterToken>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      unsigned int v6 = v4 - 24;
      id v7 = v4 - 24;
      unint64_t v8 = v4 - 24;
      do
      {
        uint64_t v9 = *(void (***)(char *))v8;
        v8 -= 24;
        (*v9)(v7);
        v6 -= 24;
        BOOL v10 = v7 == v2;
        id v7 = v8;
      }
      while (!v10);
      id v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void AccelerationStructureViewer::Filter::~Filter(AccelerationStructureViewer::Filter *this)
{
  *(void *)this = off_747848;
  uint64_t v1 = (void **)((char *)this + 16);
  std::vector<AccelerationStructureViewer::FilterToken>::__destroy_vector::operator()[abi:nn180100](&v1);
}

{
  void **v1;
  uint64_t vars8;

  *(void *)this = off_747848;
  uint64_t v1 = (void **)((char *)this + 16);
  std::vector<AccelerationStructureViewer::FilterToken>::__destroy_vector::operator()[abi:nn180100](&v1);

  operator delete();
}

char *std::vector<AccelerationStructureViewer::FilterToken>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

uint64_t std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>,AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*,AccelerationStructureViewer::FilterToken*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    uint64_t v6 = a3;
    do
    {
      *(void *)uint64_t v3 = off_747810;
      *(_DWORD *)(v3 + 8) = *(_DWORD *)(v5 + 8);
      *(void *)(v3 + 16) = *(id *)(v5 + 16);
      v5 += 24;
      v3 += 24;
      v6 += 24;
    }
    while (v5 != a2);
  }
  return v3;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(24 * a1);
}

void AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::getPrimaryAccelerationStructure(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = **(void **)(a1[26] + 8);
  Object = GTMTLSMContext_getObject(**(void **)(v4 + 40), a1[37], a1[36] + *(void *)(v4 + 80));
  if (Object && (uint64_t v6 = Object, *(_DWORD *)Object == 16))
  {
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = ___ZN33AccelerationStructureViewerServer34MTLAccelerationStructureDataSource31getPrimaryAccelerationStructureEU13block_pointerFvPN27AccelerationStructureViewer21AccelerationStructureEP7NSErrorE_block_invoke;
    v9[3] = &unk_744080;
    id v11 = a1;
    id v10 = v3;
    id v12 = v6;
    AccelerationStructureViewerServer::DataSource::getPrimaryAccelerationStructure((uint64_t)a1, v9);
  }
  else
  {
    id v7 = +[NSString stringWithFormat:@"Resource is not an acceleration structure"];
    unint64_t v8 = +[ASVError errorWithCode:8 localizedDescription:v7];
    (*((void (**)(id, void, void *))v3 + 2))(v3, 0, v8);
  }
}

void sub_1BAAE0(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void ___ZN33AccelerationStructureViewerServer34MTLAccelerationStructureDataSource31getPrimaryAccelerationStructureEU13block_pointerFvPN27AccelerationStructureViewer21AccelerationStructureEP7NSErrorE_block_invoke(void *a1, uint64_t a2, void *a3)
{
  id v13 = a3;
  if (!a2)
  {
LABEL_6:
    (*(void (**)(void))(a1[4] + 16))();
    goto LABEL_9;
  }
  int v5 = *(_DWORD *)(a2 + 64);
  if (v5)
  {
    if (*(void *)(a1[6] + 72))
    {
      uint64_t v6 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
LABEL_5:
      id v7 = *(void **)(a2 + 48);
      *(void *)(a2 + 48) = v6;
    }
    else
    {
      int v11 = v5 - 1;
      uint64_t v12 = a1[5];
      switch(v11)
      {
        case 0:
          uint64_t v6 = +[NSString stringWithFormat:@"PrimitiveAccelerationStructure 0x%llx", *(void *)(v12 + 296)];
          goto LABEL_5;
        case 1:
          uint64_t v6 = +[NSString stringWithFormat:@"InstanceAccelerationStructure 0x%llx", *(void *)(v12 + 296)];
          goto LABEL_5;
        case 2:
          uint64_t v6 = +[NSString stringWithFormat:@"PrimitiveMotionAccelerationStructure 0x%llx", *(void *)(v12 + 296)];
          goto LABEL_5;
        case 3:
          uint64_t v6 = +[NSString stringWithFormat:@"InstanceMotionAccelerationStructure 0x%llx", *(void *)(v12 + 296)];
          goto LABEL_5;
        default:
          goto LABEL_6;
      }
    }
    goto LABEL_6;
  }
  uint64_t v8 = a1[4];
  uint64_t v9 = +[NSString stringWithFormat:@"MTLAccelerationStructure is an unsupported type"];
  id v10 = +[ASVError errorWithCode:8 localizedDescription:v9];
  (*(void (**)(uint64_t, void, void *))(v8 + 16))(v8, 0, v10);

LABEL_9:
}

void sub_1BACE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::getIntersectionFunctions(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, AccelerationStructureViewer::Filter *a5, void *a6)
{
  id v10 = a6;
  int v11 = *(void **)(a1 + 272);
  if (!v11) {
    goto LABEL_12;
  }
  unint64_t v12 = *(void *)(a2 + 16);
  id v13 = (void *)(a1 + 272);
  do
  {
    unint64_t v14 = v11[4];
    BOOL v15 = v14 >= v12;
    if (v14 >= v12) {
      char v16 = v11;
    }
    else {
      char v16 = v11 + 1;
    }
    if (v15) {
      id v13 = v11;
    }
    int v11 = (void *)*v16;
  }
  while (*v16);
  if (v13 != (void *)(a1 + 272) && v12 >= v13[4])
  {
    uint64_t v30 = 0;
    unsigned int v31 = 0;
    unint64_t v32 = 0;
    id v19 = (const AccelerationStructureViewer::IntersectionFunction *)v13[5];
    unint64_t v20 = (const AccelerationStructureViewer::IntersectionFunction *)v13[6];
    if (v19 == v20)
    {
      uint64_t v28 = 0;
    }
    else
    {
      do
      {
        AccelerationStructureViewer::IntersectionFunction::IntersectionFunction((AccelerationStructureViewer::IntersectionFunction *)&v33, v19);
        int v21 = AccelerationStructureViewer::DataSourceFilterable::matches((AccelerationStructureViewer::DataSourceFilterable *)v34, a5);
        uint64_t v33 = (uint64_t *)off_744700;
        uint64_t v38 = (void **)&v37;
        std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v38);
        if (__p)
        {
          __int16 v36 = __p;
          operator delete(__p);
        }

        uint64_t v38 = (void **)v34;
        std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v38);
        if (v21)
        {
          uint64_t v22 = v31;
          if ((unint64_t)v31 >= v32)
          {
            unint64_t v24 = 0x86BCA1AF286BCA1BLL * (((uint64_t)v31 - v30) >> 3);
            unint64_t v25 = v24 + 1;
            if (v24 + 1 > 0x1AF286BCA1AF286) {
              abort();
            }
            if (0xD79435E50D79436 * ((uint64_t)(v32 - v30) >> 3) > v25) {
              unint64_t v25 = 0xD79435E50D79436 * ((uint64_t)(v32 - v30) >> 3);
            }
            if (0x86BCA1AF286BCA1BLL * ((uint64_t)(v32 - v30) >> 3) >= 0xD79435E50D7943) {
              unint64_t v26 = 0x1AF286BCA1AF286;
            }
            else {
              unint64_t v26 = v25;
            }
            uint64_t v42 = &v32;
            if (v26) {
              unint64_t v26 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunction>>(v26);
            }
            else {
              uint64_t v27 = 0;
            }
            uint64_t v38 = (void **)v26;
            unint64_t v39 = (AccelerationStructureViewer::IntersectionFunction *)(v26 + 152 * v24);
            uint64_t v40 = v39;
            unint64_t v41 = v26 + 152 * v27;
            AccelerationStructureViewer::IntersectionFunction::IntersectionFunction(v39, v19);
            uint64_t v40 = (AccelerationStructureViewer::IntersectionFunction *)((char *)v40 + 152);
            std::vector<AccelerationStructureViewer::IntersectionFunction>::__swap_out_circular_buffer(&v30, &v38);
            unsigned int v23 = v31;
            std::__split_buffer<AccelerationStructureViewer::IntersectionFunction>::~__split_buffer((uint64_t)&v38);
          }
          else
          {
            AccelerationStructureViewer::IntersectionFunction::IntersectionFunction(v31, v19);
            unsigned int v23 = (AccelerationStructureViewer::IntersectionFunction *)((char *)v22 + 152);
          }
          unsigned int v31 = v23;
        }
        id v19 = (const AccelerationStructureViewer::IntersectionFunction *)((char *)v19 + 152);
      }
      while (v19 != v20);
      uint64_t v28 = v30;
    }
    if (a3)
    {
      std::vector<AccelerationStructureViewer::IntersectionFunction>::erase((uint64_t)&v30, v28, v28 + 152 * a3);
      uint64_t v28 = v30;
    }
    if (0x86BCA1AF286BCA1BLL * (((uint64_t)v31 - v28) >> 3) > a4) {
      std::vector<AccelerationStructureViewer::IntersectionFunction>::erase((uint64_t)&v30, v28 + 152 * a4, (uint64_t)v31);
    }
    v10[2](v10, &v30, 0);
    uint64_t v33 = &v30;
    unsigned int v18 = (void ***)&v33;
  }
  else
  {
LABEL_12:
    uint64_t v33 = 0;
    v34[0] = 0;
    v34[1] = 0;
    unsigned int v17 = +[NSError errorWithDomain:@"AccelerationStructureViewerError" code:0 userInfo:0];
    ((void (**)(id, uint64_t *, void *))v10)[2](v10, (uint64_t *)&v33, v17);

    uint64_t v38 = (void **)&v33;
    unsigned int v18 = &v38;
  }
  std::vector<AccelerationStructureViewer::IntersectionFunction>::__destroy_vector::operator()[abi:nn180100](v18);
}

void sub_1BB044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  *(void *)(v13 - 136) = &a12;
  std::vector<AccelerationStructureViewer::IntersectionFunction>::__destroy_vector::operator()[abi:nn180100]((void ***)(v13 - 136));

  _Unwind_Resume(a1);
}

void std::vector<AccelerationStructureViewer::IntersectionFunction>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    int v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 152;
      id v7 = v4 - 152;
      uint64_t v8 = v4 - 152;
      do
      {
        uint64_t v9 = *(void (***)(char *))v8;
        v8 -= 152;
        (*v9)(v7);
        v6 -= 152;
        BOOL v10 = v7 == v2;
        id v7 = v8;
      }
      while (!v10);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

AccelerationStructureViewer::IntersectionFunction *AccelerationStructureViewer::IntersectionFunction::IntersectionFunction(AccelerationStructureViewer::IntersectionFunction *this, const AccelerationStructureViewer::IntersectionFunction *a2)
{
  *((void *)this + 1) = 0;
  uint64_t v4 = (void *)((char *)this + 8);
  *(void *)this = off_7442D8;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  uint64_t v5 = *((void *)a2 + 1);
  uint64_t v6 = *((void *)a2 + 2);
  if (v6 != v5)
  {
    std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__vallocate[abi:nn180100]((void *)this + 1, (v6 - v5) >> 4);
    std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__construct_at_end<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>*,std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>*>(v4, v5, v6);
  }
  *(void *)this = off_744700;
  *((void *)this + 4) = *((id *)a2 + 4);
  uint64_t v7 = *((void *)a2 + 9);
  long long v8 = *(_OWORD *)((char *)a2 + 56);
  long long v9 = *(_OWORD *)((char *)a2 + 40);
  *((void *)this + 10) = 0;
  *(_OWORD *)((char *)this + 40) = v9;
  *(_OWORD *)((char *)this + 56) = v8;
  *((void *)this + 9) = v7;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  int v11 = (unsigned char *)*((void *)a2 + 10);
  BOOL v10 = (unsigned char *)*((void *)a2 + 11);
  int64_t v12 = v10 - v11;
  if (v10 != v11)
  {
    std::vector<AccelerationStructureViewer::IntersectionFunctionTag>::__vallocate[abi:nn180100]((void *)this + 10, v12 >> 2);
    uint64_t v13 = (char *)*((void *)this + 11);
    memmove(v13, v11, v12);
    *((void *)this + 11) = &v13[4 * (v12 >> 2)];
  }
  long long v14 = *(_OWORD *)((char *)a2 + 104);
  uint64_t v15 = *((void *)a2 + 15);
  *((void *)this + 16) = 0;
  *((void *)this + 15) = v15;
  *(_OWORD *)((char *)this + 104) = v14;
  *((void *)this + 17) = 0;
  *((void *)this + 18) = 0;
  uint64_t v17 = *((void *)a2 + 16);
  uint64_t v16 = *((void *)a2 + 17);
  if (v16 != v17)
  {
    std::vector<AccelerationStructureViewer::Property>::__vallocate[abi:nn180100]((void *)this + 16, 0xEEEEEEEEEEEEEEEFLL * ((v16 - v17) >> 3));
    std::vector<AccelerationStructureViewer::Property>::__construct_at_end<AccelerationStructureViewer::Property*,AccelerationStructureViewer::Property*>((char *)this + 128, v17, v16);
  }
  return this;
}

void sub_1BB2EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100]((void ***)va);
  _Unwind_Resume(a1);
}

void std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 120;
      uint64_t v7 = v4 - 120;
      long long v8 = v4 - 120;
      do
      {
        long long v9 = *(void (***)(char *))v8;
        v8 -= 120;
        (*v9)(v7);
        v6 -= 120;
        BOOL v10 = v7 == v2;
        uint64_t v7 = v8;
      }
      while (!v10);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (id *)**a1;
  if (v2)
  {
    uint64_t v4 = (id *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 2;

        uint64_t v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void AccelerationStructureViewer::IntersectionFunction::~IntersectionFunction(AccelerationStructureViewer::IntersectionFunction *this)
{
  *(void *)this = off_744700;
  id v3 = (void **)((char *)this + 128);
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v3);
  uint64_t v2 = (void *)*((void *)this + 10);
  if (v2)
  {
    *((void *)this + 11) = v2;
    operator delete(v2);
  }

  id v3 = (void **)((char *)this + 8);
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v3);
}

{
  void *v2;
  void **v3;
  uint64_t vars8;

  *(void *)this = off_744700;
  id v3 = (void **)((char *)this + 128);
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v3);
  uint64_t v2 = (void *)*((void *)this + 10);
  if (v2)
  {
    *((void *)this + 11) = v2;
    operator delete(v2);
  }

  id v3 = (void **)((char *)this + 8);
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v3);

  operator delete();
}

void std::vector<AccelerationStructureViewer::IntersectionFunction>::erase(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v3 = a2;
    uint64_t v5 = *(void *)(a1 + 8);
    if (a3 != v5)
    {
      uint64_t v6 = 8 * ((a3 - a2) >> 3);
      do
      {
        uint64_t v7 = v3 + v6;
        std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__vdeallocate((void **)(v3 + 8));
        *(_OWORD *)(v3 + 8) = *(_OWORD *)(v3 + v6 + 8);
        uint64_t v8 = *(void *)(v3 + v6 + 32);
        *(void *)(v3 + 24) = *(void *)(v3 + v6 + 24);
        *(void *)(v7 + 8) = 0;
        *(void *)(v7 + 16) = 0;
        *(void *)(v7 + 24) = 0;
        *(void *)(v7 + 32) = 0;
        long long v9 = *(void **)(v3 + 32);
        *(void *)(v3 + 32) = v8;

        long long v10 = *(_OWORD *)(v3 + v6 + 40);
        long long v11 = *(_OWORD *)(v3 + v6 + 56);
        int64_t v12 = *(void **)(v3 + 80);
        *(void *)(v3 + 72) = *(void *)(v3 + v6 + 72);
        *(_OWORD *)(v3 + 56) = v11;
        *(_OWORD *)(v3 + 40) = v10;
        if (v12)
        {
          *(void *)(v3 + 88) = v12;
          operator delete(v12);
          *(void *)(v3 + 80) = 0;
          *(void *)(v3 + 88) = 0;
          *(void *)(v3 + 96) = 0;
        }
        *(_OWORD *)(v3 + 80) = *(_OWORD *)(v7 + 80);
        *(void *)(v3 + 96) = *(void *)(v7 + 96);
        *(void *)(v7 + 80) = 0;
        *(void *)(v7 + 88) = 0;
        *(void *)(v7 + 96) = 0;
        uint64_t v13 = *(void *)(v7 + 120);
        *(_OWORD *)(v3 + 104) = *(_OWORD *)(v7 + 104);
        *(void *)(v3 + 120) = v13;
        std::vector<AccelerationStructureViewer::Property>::__vdeallocate((void **)(v3 + 128));
        *(_OWORD *)(v3 + 128) = *(_OWORD *)(v7 + 128);
        *(void *)(v3 + 144) = *(void *)(v7 + 144);
        *(void *)(v7 + 128) = 0;
        *(void *)(v7 + 136) = 0;
        *(void *)(v7 + 144) = 0;
        v3 += 152;
      }
      while (v3 + v6 != v5);
      a3 = *(void *)(a1 + 8);
    }
    if (a3 != v3)
    {
      uint64_t v14 = a3 - 152;
      uint64_t v15 = (void (***)(void))(a3 - 152);
      uint64_t v16 = (void (***)(void))(a3 - 152);
      do
      {
        uint64_t v17 = *v16;
        v16 -= 19;
        (*v17)(v15);
        v14 -= 152;
        BOOL v18 = v15 == (void (***)(void))v3;
        uint64_t v15 = v16;
      }
      while (!v18);
    }
    *(void *)(a1 + 8) = v3;
  }
}

void std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__vdeallocate(void **a1)
{
  uint64_t v1 = (id *)*a1;
  if (*a1)
  {
    uint64_t v3 = (id *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        uint64_t v5 = v3 - 2;

        uint64_t v3 = v5;
      }
      while (v5 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<AccelerationStructureViewer::Property>::__vdeallocate(void **a1)
{
  uint64_t v1 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      uint64_t v5 = v3 - 120;
      uint64_t v6 = v3 - 120;
      uint64_t v7 = v3 - 120;
      do
      {
        uint64_t v8 = *(void (***)(char *))v7;
        v7 -= 120;
        (*v8)(v6);
        v5 -= 120;
        BOOL v9 = v6 == v1;
        uint64_t v6 = v7;
      }
      while (!v9);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunction>>(unint64_t a1)
{
  if (a1 >= 0x1AF286BCA1AF287) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(152 * a1);
}

uint64_t *std::vector<AccelerationStructureViewer::IntersectionFunction>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      uint64_t v7 = v2 + v5;
      *(void *)(v6 - 144) = 0;
      *(void *)(v6 - 136) = 0;
      *(void *)(v6 - 128) = 0;
      *(_OWORD *)(v6 - 144) = *(_OWORD *)(v2 + v5 - 144);
      *(void *)(v6 - 128) = *(void *)(v2 + v5 - 128);
      *(void *)(v7 - 136) = 0;
      *(void *)(v7 - 128) = 0;
      *(void *)(v7 - 144) = 0;
      *(void *)(v6 - 152) = off_744700;
      uint64_t v8 = *(void *)(v2 + v5 - 120);
      *(void *)(v7 - 120) = 0;
      *(void *)(v6 - 120) = v8;
      long long v9 = *(_OWORD *)(v2 + v5 - 96);
      uint64_t v10 = *(void *)(v2 + v5 - 80);
      *(_OWORD *)(v6 - 112) = *(_OWORD *)(v2 + v5 - 112);
      *(_OWORD *)(v6 - 96) = v9;
      *(void *)(v6 - 64) = 0;
      *(void *)(v6 - 56) = 0;
      *(void *)(v6 - 80) = v10;
      *(void *)(v6 - 72) = 0;
      *(_OWORD *)(v6 - 72) = *(_OWORD *)(v2 + v5 - 72);
      *(void *)(v6 - 56) = *(void *)(v2 + v5 - 56);
      *(void *)(v7 - 72) = 0;
      *(void *)(v7 - 64) = 0;
      *(void *)(v7 - 56) = 0;
      uint64_t v11 = *(void *)(v2 + v5 - 32);
      *(_OWORD *)(v6 - 48) = *(_OWORD *)(v2 + v5 - 48);
      *(void *)(v6 - 32) = v11;
      *(void *)(v6 - 24) = 0;
      *(void *)(v6 - 16) = 0;
      *(void *)(v6 - 8) = 0;
      *(_OWORD *)(v6 - 24) = *(_OWORD *)(v2 + v5 - 24);
      *(void *)(v6 - 8) = *(void *)(v2 + v5 - 8);
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      v5 -= 152;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v12 = *result;
  *uint64_t result = v4;
  a2[1] = v12;
  uint64_t v13 = result[1];
  result[1] = a2[2];
  a2[2] = v13;
  uint64_t v14 = result[2];
  result[2] = a2[3];
  a2[3] = v14;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<AccelerationStructureViewer::IntersectionFunction>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void (***)(void))(i - 152);
    *(void *)(a1 + 16) = i - 152;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *std::vector<AccelerationStructureViewer::Property>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x222222222222223) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::Property>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[120 * v4];
  return result;
}

char *std::vector<AccelerationStructureViewer::Property>::__construct_at_end<AccelerationStructureViewer::Property*,AccelerationStructureViewer::Property*>(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = *((void *)result + 1);
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t result = std::allocator<AccelerationStructureViewer::Property>::construct[abi:nn180100]<AccelerationStructureViewer::Property,AccelerationStructureViewer::Property&>(v4 + v7, a2 + v7);
      v7 += 120;
    }
    while (a2 + v7 != a3);
    v4 += v7;
  }
  *((void *)v3 + 1) = v4;
  return result;
}

void sub_1BBA04(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

char *std::allocator<AccelerationStructureViewer::Property>::construct[abi:nn180100]<AccelerationStructureViewer::Property,AccelerationStructureViewer::Property&>(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_7474F0;
  __int16 v4 = *(_WORD *)(a2 + 8);
  *(unsigned char *)(a1 + 10) = *(unsigned char *)(a2 + 10);
  *(_WORD *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = *(id *)(a2 + 16);
  long long v5 = *(_OWORD *)(a2 + 40);
  long long v6 = *(_OWORD *)(a2 + 56);
  long long v7 = *(_OWORD *)(a2 + 72);
  uint64_t v8 = *(void *)(a2 + 88);
  long long v9 = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 24) = v9;
  *(void *)(a1 + 88) = v8;
  *(_OWORD *)(a1 + 72) = v7;
  *(_OWORD *)(a1 + 56) = v6;
  *(_OWORD *)(a1 + 40) = v5;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  return std::vector<NSString * {__strong}>::__init_with_size[abi:nn180100]<NSString * {__strong}*,NSString * {__strong}*>((char *)(a1 + 96), *(void ***)(a2 + 96), *(void ***)(a2 + 104), (uint64_t)(*(void *)(a2 + 104) - *(void *)(a2 + 96)) >> 3);
}

void sub_1BBAAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *std::vector<NSString * {__strong}>::__init_with_size[abi:nn180100]<NSString * {__strong}*,NSString * {__strong}*>(char *result, void **a2, void **a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    uint64_t result = std::vector<NSString * {__strong}>::__vallocate[abi:nn180100](result, a4);
    long long v7 = (char **)*((void *)v6 + 1);
    while (a2 != a3)
    {
      uint64_t v8 = *a2++;
      uint64_t result = v8;
      *v7++ = result;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

char *std::vector<NSString * {__strong}>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(unint64_t a1)
{
  if (a1 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(8 * a1);
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::Property>>(unint64_t a1)
{
  if (a1 >= 0x222222222222223) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(120 * a1);
}

char *std::vector<AccelerationStructureViewer::IntersectionFunctionTag>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(unint64_t a1)
{
  if (a1 >> 62) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(4 * a1);
}

char *std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__construct_at_end<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>*,std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>*>(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = result[1];
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *(_WORD *)uint64_t v4 = *(_WORD *)v6;
      uint64_t result = *(id *)(v6 + 8);
      *(void *)(v4 + 8) = result;
      v4 += 16;
      v6 += 16;
    }
    while (v6 != a3);
  }
  v3[1] = v4;
  return result;
}

void AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::getIntersectionFunctionTables(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v10 = 0;
  uint64_t v4 = *(void *)(a1 + 240);
  uint64_t v5 = *(void *)(a1 + 248);
  uint64_t v6 = v5 - v4;
  if (v5 != v4)
  {
    if (v6 < 0) {
      abort();
    }
    long long v7 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>>(v6 >> 5);
    uint64_t v10 = v7;
    uint64_t v12 = &v7[32 * v8];
    long long v9 = v7;
    do
    {
      *(void *)long long v9 = off_747528;
      *((void *)v9 + 1) = *(id *)(v4 + 8);
      *((_OWORD *)v9 + 1) = *(_OWORD *)(v4 + 16);
      v4 += 32;
      v9 += 32;
      v7 += 32;
    }
    while (v4 != v5);
    uint64_t v11 = v9;
  }
  v3[2](v3, &v10, 0);
  uint64_t v13 = &v10;
  std::vector<AccelerationStructureViewer::IntersectionFunctionTable>::__destroy_vector::operator()[abi:nn180100]((void ***)&v13);
}

void sub_1BBDEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::vector<AccelerationStructureViewer::IntersectionFunctionTable>::__destroy_vector::operator()[abi:nn180100]((void ***)va);

  _Unwind_Resume(a1);
}

void std::vector<AccelerationStructureViewer::IntersectionFunctionTable>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 32;
      long long v7 = v4 - 32;
      uint64_t v8 = v4 - 32;
      do
      {
        long long v9 = *(void (***)(char *))v8;
        v8 -= 32;
        (*v9)(v7);
        v6 -= 32;
        BOOL v10 = v7 == v2;
        long long v7 = v8;
      }
      while (!v10);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>>(unint64_t a1)
{
  if (a1 >> 59) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(32 * a1);
}

void AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::~MTLAccelerationStructureDataSource(AccelerationStructureViewerServer::MTLAccelerationStructureDataSource *this)
{
  AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::~MTLAccelerationStructureDataSource(this);

  operator delete();
}

{
  void **v2;
  uint64_t vars8;

  *(void *)this = off_744000;

  uint64_t v2 = (void **)((char *)this + 352);
  std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v2);
  std::__hash_table<std::__hash_value_type<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>,std::__unordered_map_hasher<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>,std::hash<GTMTLResourceUsage_uint8_t>,std::equal_to<GTMTLResourceUsage_uint8_t>,true>,std::__unordered_map_equal<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>,std::equal_to,std::hash,true>,objc_object  {objcproto11MTLResource}* {__strong}<std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>>::~__hash_table((uint64_t)this + 312);

  std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::IntersectionFunction>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::IntersectionFunction>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::IntersectionFunction>>>>::destroy(*((char **)this + 34));
  uint64_t v2 = (void **)((char *)this + 240);
  std::vector<AccelerationStructureViewer::IntersectionFunctionTable>::__destroy_vector::operator()[abi:nn180100](&v2);

  AccelerationStructureViewerServer::DataSource::~DataSource(this);
}

void std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = (void *)*((void *)v4 - 1);
        v4 -= 8;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>,std::__unordered_map_hasher<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>,std::hash<GTMTLResourceUsage_uint8_t>,std::equal_to<GTMTLResourceUsage_uint8_t>,true>,std::__unordered_map_equal<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>,std::equal_to,std::hash,true>,objc_object  {objcproto11MTLResource}* {__strong}<std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = *(char **)v2;
      uint64_t v6 = (void **)(v2 + 24);
      std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v6);
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::IntersectionFunction>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::IntersectionFunction>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::IntersectionFunction>>>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::IntersectionFunction>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::IntersectionFunction>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::IntersectionFunction>>>>::destroy(*(void *)a1);
    std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::IntersectionFunction>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::IntersectionFunction>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::IntersectionFunction>>>>::destroy(*((void *)a1 + 1));
    uint64_t v2 = (void **)(a1 + 40);
    std::vector<AccelerationStructureViewer::IntersectionFunction>::__destroy_vector::operator()[abi:nn180100](&v2);
    operator delete(a1);
  }
}

id AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::getAllAccelerationStructureChildren(AccelerationStructureViewerServer::MTLAccelerationStructureDataSource *this, uint64_t a2, apr_pool_t *a3)
{
  long long v7 = *(id **)(*((void *)this + 26) + 8);
  uint64_t v8 = (_DWORD ***)*v7;
  id v9 = v7[1];
  unint64_t v10 = *((void *)this + 36) + *((void *)*v7 + 10);
  uint64_t v64 = 0;
  long long v63 = 0u;
  memset(v62, 0, sizeof(v62));
  GTMTLIndirectResources_allResourcesByKey((uint64_t *)v62, v8[5], v10, 1, a3);
  uint64_t v11 = v63;
  unsigned int v61 = *(_DWORD *)(v63 + 48);
  uint64_t v12 = [v9 defaultDevice];
  id v13 = [v12 newBufferWithLength:8 * v61 options:0];

  uint64_t v14 = [v9 defaultDevice];
  unint64_t v39 = v6;
  id v15 = [v14 newBufferWithLength:4 * v61 options:0];

  id v40 = v13;
  uint64_t v16 = [v40 contents];
  *(void *)(v11 + 24) = 0;
  *(void *)(v11 + 32) = 0;
  *(void *)(v11 + 16) = v11;
  *(_DWORD *)(v11 + 40) = 0;
  uint64_t v17 = apr_hash_next((apr_hash_index_t *)(v11 + 16));
  for (uint64_t i = 0; v17; ++i)
  {
    *(void *)&v16[8 * i] = **(void **)(*((void *)v17 + 1) + 16);
    uint64_t v17 = apr_hash_next(v17);
  }
  std::__sort<std::__less<unsigned long long,unsigned long long> &,unsigned long long *>();
  unint64_t v41 = [v9 accelerationStructureForKey:a2];
  id v19 = [v9 defaultCommandQueue];
  unint64_t v20 = [v19 commandBuffer];

  uint64_t v42 = v20;
  [v20 setLabel:@"com.apple.gputools.ASV.MarkAccelerationStructureChildren"];
  int v21 = [v20 computeCommandEncoder];
  uint64_t v22 = [v9 defaultDevice];
  LODWORD(v20) = [v22 supportsFamily:1004];

  if (v20)
  {
    unsigned int v57 = 0;
    unsigned int v59 = 0;
    uint64_t v60 = 0;
    uint64_t v58 = 0x100000001;
    unsigned int v59 = [*((id *)this + 28) threadExecutionWidth];
    uint64_t v60 = 0x100000001;
    unsigned int v23 = [v9 defaultDevice];
    id v24 = [v23 newBufferWithBytes:&v57 length:24 options:0];

    [v21 setComputePipelineState:*((void *)this + 27)];
    [v21 setAccelerationStructure:v41 atBufferIndex:1];
    [v21 setBuffer:v24 offset:0 atIndex:0];
    int64x2_t v55 = vdupq_n_s64(1uLL);
    uint64_t v56 = 1;
    int64x2_t v53 = v55;
    uint64_t v54 = 1;
    [v21 dispatchThreads:&v55 threadsPerThreadgroup:&v53];
    [v21 setComputePipelineState:*((void *)this + 28)];
    [v21 setAccelerationStructure:v41 atBufferIndex:1];
    [v21 setBytes:&v61 length:4 atIndex:4];
    [v21 setBuffer:v40 offset:0 atIndex:2];
    [v21 setBuffer:v15 offset:0 atIndex:3];
    [v21 dispatchThreadsWithIndirectBuffer:v24 indirectBufferOffset:0];
  }
  else
  {
    unsigned int v57 = 0;
    unsigned int v57 = [*((id *)this + 28) threadExecutionWidth];
    unint64_t v25 = [v9 defaultDevice];
    id v26 = [v25 newBufferWithLength:4 options:0];

    uint64_t v27 = [v9 defaultDevice];
    id v28 = [v27 newBufferWithLength:12 options:0];

    [v21 setComputePipelineState:*((void *)this + 27)];
    [v21 setAccelerationStructure:v41 atBufferIndex:1];
    [v21 setBuffer:v26 offset:0 atIndex:0];
    int64x2_t v51 = vdupq_n_s64(1uLL);
    uint64_t v52 = 1;
    id v49 = [*((id *)this + 27) threadExecutionWidth];
    int64x2_t v50 = v51;
    [v21 dispatchThreadgroups:&v51 threadsPerThreadgroup:&v49];
    [v21 setComputePipelineState:*((void *)this + 29)];
    [v21 setBytes:&v57 length:4 atIndex:6];
    [v21 setBuffer:v26 offset:0 atIndex:0];
    [v21 setBuffer:v28 offset:0 atIndex:5];
    int64x2_t v47 = vdupq_n_s64(1uLL);
    uint64_t v48 = 1;
    id v45 = [*((id *)this + 27) threadExecutionWidth];
    int64x2_t v46 = v47;
    [v21 dispatchThreadgroups:&v47 threadsPerThreadgroup:&v45];
    [v21 setComputePipelineState:*((void *)this + 28)];
    [v21 setAccelerationStructure:v41 atBufferIndex:1];
    [v21 setBytes:&v61 length:4 atIndex:4];
    [v21 setBuffer:v40 offset:0 atIndex:2];
    [v21 setBuffer:v15 offset:0 atIndex:3];
    uint64_t v43 = v57;
    int64x2_t v44 = vdupq_n_s64(1uLL);
    [v21 dispatchThreadgroupsWithIndirectBuffer:v28 indirectBufferOffset:0 threadsPerThreadgroup:&v43];
  }
  [v21 endEncoding];
  [v42 commit];
  [v42 waitUntilCompleted];
  if ([v42 status] == &dword_4)
  {
    id v38 = v15;
    uint64_t v29 = [v15 contents];
    id v30 = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:10];
    if (v61)
    {
      for (unint64_t j = 0; j < v61; ++j)
      {
        if (v29[j])
        {
          uint64_t v32 = *find_entry(v11, v16, 8uLL, 0);
          if (v32)
          {
            uint64_t v33 = *(void *)(v32 + 32);
            if (v33)
            {
              uint64_t v34 = [v9 accelerationStructureForKey:*(void *)(v33 + 8)];
              if (v34)
              {
                uint64_t v35 = +[NSNumber numberWithUnsignedLongLong:*(void *)(v33 + 8)];
                [v30 setObject:v34 forKey:v35];
              }
            }
          }
        }
        v16 += 8;
      }
    }
    id v36 = [v30 copy];

    id v15 = v38;
  }
  else
  {
    id v36 = &__NSDictionary0__struct;
  }

  return v36;
}

void sub_1BC74C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(uint64_t a1, id *a2, int *a3, uint64_t a4, apr_pool_t *a5, uint64_t **a6)
{
  unint64_t v168 = a2;
  if (a3)
  {
    unint64_t v10 = (apr_pool_t *)*((void *)a3 + 1);
    uint64_t v11 = *a2;
    id v167 = a2[1];
    int v12 = *a3;
    if (*a3 == 60)
    {
      uint64_t v141 = v11[1];
      uint64_t v142 = v11;
      uint64_t v166 = a3;
      v163[1] = off_747528;
      id v164 = 0;
      *(void *)&long long v165 = v10;
      uint64_t v34 = [a2[1] resourceForKey:v10];
      unint64_t v143 = v34;
      uint64_t v35 = [v34 label];
      id v36 = &send_ptr;
      if (v35
        && ([v34 label],
            uint64_t v37 = objc_claimAutoreleasedReturnValue(),
            unsigned __int8 v38 = [v37 isEqualToString:&stru_7482F0],
            v37,
            v35,
            (v38 & 1) == 0))
      {
        unint64_t v39 = [v34 label];
      }
      else
      {
        unint64_t v39 = +[NSString stringWithFormat:@"MTLIntersectionFunctionTable 0x%llx", v34];
      }
      id v40 = v164;
      id v164 = v39;

      if ((a4 & 0x8000000000000000) == 0)
      {
        unint64_t v41 = [v164 stringByAppendingFormat:@" (%zu)" a4];
        id v42 = v164;
        id v164 = v41;
      }
      v163[0] = 0;
      unint64_t v162 = 0;
      unint64_t v161 = 0;
      unint64_t v43 = *(unsigned int *)(*((void *)v166 + 13) + 8);
      if (v43)
      {
        unint64_t v153 = v163;
        int64x2_t v44 = (apr_pool_t *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunction>>(v43);
        newpool = v44;
        unint64_t v150 = v44;
        uint64_t v152 = (uint64_t)v44 + 152 * v45;
        int64x2_t v46 = (apr_pool_t *)((char *)v44 + 152 * v43);
        uint64_t v47 = 152 * v43;
        uint64_t v48 = v44;
        do
        {
          *((void *)v48 + 1) = 0;
          *((void *)v48 + 2) = 0;
          *((void *)v48 + 3) = 0;
          *(void *)uint64_t v48 = off_744700;
          *((void *)v48 + 11) = 0;
          *((void *)v48 + 12) = 0;
          *((void *)v48 + 10) = 0;
          *((void *)v48 + 17) = 0;
          *((void *)v48 + 18) = 0;
          *((void *)v48 + 16) = 0;
          *((_OWORD *)v48 + 2) = 0uLL;
          *((_OWORD *)v48 + 3) = 0uLL;
          *(_OWORD *)((char *)v48 + 59) = 0uLL;
          uint64_t v48 = (apr_pool_t *)((char *)v48 + 152);
          int64x2_t v44 = (apr_pool_t *)((char *)v44 + 152);
          v47 -= 152;
        }
        while (v47);
        unint64_t v151 = v46;
        std::vector<AccelerationStructureViewer::IntersectionFunction>::__swap_out_circular_buffer((uint64_t *)&v161, &newpool);
        std::__split_buffer<AccelerationStructureViewer::IntersectionFunction>::~__split_buffer((uint64_t)&newpool);
        *((void *)&v165 + 1) = *(unsigned int *)(*((void *)v166 + 13) + 8);
        if (DWORD2(v165))
        {
          unint64_t v49 = 0;
          uint64_t v50 = (uint64_t)v161;
          CFStringRef v51 = @"nil";
          do
          {
            unint64_t v52 = v50 + 152 * v49;
            int64x2_t v53 = *(void **)(v52 + 32);
            *(void *)(v52 + 32) = v51;

            uint64_t v54 = (uint64_t)v161;
            int64x2_t v55 = (char *)v161 + 152 * v49;
            *((void *)v55 + 5) = v49;
            *((void *)v55 + 6) = 0;
            *((void *)v55 + 7) = 0;
            *((void *)v55 + 8) = 0;
            *((_WORD *)v55 + 36) = 1;
            v55[74] = 0;
            *((_DWORD *)v55 + 19) = 0;
            uint64_t v56 = [v36[219] stringWithFormat:@"%zu" v49];
            uint64_t v57 = v56;
            unint64_t v58 = v54 + 152 * v49;
            unint64_t v61 = *(void *)(v58 + 24);
            unsigned int v59 = (void *)(v58 + 24);
            unint64_t v60 = v61;
            unint64_t v62 = (apr_pool_t **)(v59 - 2);
            unint64_t v63 = *(v59 - 1);
            if (v63 >= v61)
            {
              CFStringRef v65 = v51;
              int v66 = v36;
              uint64_t v67 = (uint64_t)(v63 - (void)*v62) >> 4;
              unint64_t v68 = v67 + 1;
              if ((unint64_t)(v67 + 1) >> 60) {
                abort();
              }
              uint64_t v69 = v60 - (void)*v62;
              if (v69 >> 3 > v68) {
                unint64_t v68 = v69 >> 3;
              }
              if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v70 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v70 = v68;
              }
              unint64_t v153 = v59;
              uint64_t v71 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(v70);
              uint64_t v73 = &v71[16 * v67];
              *(_WORD *)uint64_t v73 = 2;
              *((void *)v73 + 1) = v57;
              unint64_t v74 = *v62;
              unint64_t v75 = v62[1];
              if (v75 == *v62)
              {
                uint64_t v77 = &v71[16 * v67];
                id v36 = v66;
              }
              else
              {
                unint64_t v76 = v62[1];
                uint64_t v77 = &v71[16 * v67];
                id v36 = v66;
                do
                {
                  __int16 v78 = *((_WORD *)v76 - 8);
                  unint64_t v76 = (apr_pool_t *)((char *)v76 - 16);
                  *((_WORD *)v77 - 8) = v78;
                  v77 -= 16;
                  uint64_t v79 = *((void *)v76 + 1);
                  *((void *)v76 + 1) = 0;
                  *((void *)v77 + 1) = v79;
                }
                while (v76 != v74);
              }
              uint64_t v64 = (apr_pool_t *)(v73 + 16);
              int *v62 = (apr_pool_t *)v77;
              unint64_t v150 = v74;
              v62[1] = (apr_pool_t *)(v73 + 16);
              unint64_t v151 = v75;
              uint64_t v80 = (uint64_t)v62[2];
              v62[2] = (apr_pool_t *)&v71[16 * v72];
              uint64_t v152 = v80;
              newpool = v74;
              std::__split_buffer<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::~__split_buffer((uint64_t)&newpool);
              CFStringRef v51 = v65;
            }
            else
            {
              *(_WORD *)unint64_t v63 = 2;
              *(void *)(v63 + 8) = v56;
              uint64_t v64 = (apr_pool_t *)(v63 + 16);
            }
            v62[1] = v64;
            uint64_t v50 = (uint64_t)v161;
            unint64_t v81 = (char *)v161 + 152 * v49;
            *(_OWORD *)(v81 + 104) = xmmword_4C7F50;
            *((void *)v81 + 15) = 0x80000000800000;
            ++v49;
          }
          while (v49 < *(unsigned int *)(*((void *)v166 + 13) + 8));
        }
      }
      else
      {
        *((void *)&v165 + 1) = *(unsigned int *)(*((void *)v166 + 13) + 8);
      }
      unint64_t v82 = operator new(0x28uLL);
      *unint64_t v82 = off_7440D8;
      v82[1] = &v168;
      v82[2] = &v167;
      v82[3] = &v166;
      v82[4] = &v161;
      unint64_t v174 = v82;
      v171[0] = off_744120;
      v171[1] = &v161;
      uint64_t v172 = v171;
      newpool = v10;
      entry = find_entry(v141, &newpool, 8uLL, 0);
      if (*entry) {
        uint64_t v84 = *(void *)(*entry + 32);
      }
      else {
        uint64_t v84 = 0;
      }
      unint64_t v85 = *(void *)(a1 + 288) + *((void *)*v168 + 10);
      uint64_t v160 = 0;
      memset(v159, 0, sizeof(v159));
      GTMTLIndirectResources_allResourcesByKey((uint64_t *)v159, (_DWORD **)v11[5], v85, 1, a5);
      bzero(&newpool, 0x3A0uLL);
      LODWORD(newpool) = 60;
      __int16 v155 = 2;
      uint64_t v152 = -1;
      uint64_t v154 = -1;
      uint64_t v86 = *(void *)(v84 + 32);
      if (v86)
      {
        unsigned int v87 = 0;
        while (1)
        {
          unsigned int v88 = atomic_load((unsigned int *)(v86 + 4));
          unsigned int v89 = v87 + (v88 >> 6);
          unsigned int v90 = v89 - 1;
          if ((int)(v89 - 1) > 0) {
            break;
          }
          uint64_t v86 = *(void *)(v86 + 40);
          unsigned int v87 = v89 - 1;
          if (!v86) {
            goto LABEL_59;
          }
        }
        unsigned int v90 = 0;
        uint64_t v92 = v87;
        uint64_t v114 = v86 - ((uint64_t)(int)v87 << 6);
        if ((*(unsigned char *)(v114 + 79) & 8) != 0) {
          uint64_t v91 = v114 + 64;
        }
        else {
          uint64_t v91 = 0;
        }
      }
      else
      {
        unsigned int v90 = 0;
LABEL_59:
        uint64_t v86 = 0;
        uint64_t v91 = 0;
        unsigned int v87 = v90;
        uint64_t v92 = v90;
      }
      GTMTLSMIntersectionFunctionTableStateful_processTraceFuncWithMap((uint64_t)&newpool, v142[2], v91, (uint64_t *)v159);
      unint64_t v158 = *(unsigned int *)(v156 + 8);
      unint64_t v157 = (char *)apr_palloc(a5, 16 * v158);
      bzero(v157, 16 * v158);
      unsigned int v93 = atomic_load((unsigned int *)(v86 + 4));
      uint64_t v94 = v90 + 1;
      if (v94 == v87 + (v93 >> 6) - 1)
      {
        uint64_t v86 = *(void *)(v86 + 40);
        uint64_t v92 = v90 + 1;
      }
      uint64_t v95 = (v94 << 32) | v92;
LABEL_63:
      uint64_t v96 = v86 + 64;
      while (v86)
      {
        if ((*(unsigned char *)(v96 + ((uint64_t)(HIDWORD(v95) - (int)v95) << 6) + 15) & 8) == 0) {
          break;
        }
        uint64_t v97 = (unint64_t *)(v96 + ((uint64_t)(HIDWORD(v95) - (int)v95) << 6));
        if (v85 <= *v97) {
          break;
        }
        GTMTLSMIntersectionFunctionTableStateful_processTraceFuncWithMap((uint64_t)&newpool, v142[2], (uint64_t)v97, (uint64_t *)v159);
        unsigned int v98 = atomic_load((unsigned int *)(v86 + 4));
        int v99 = v95 + (v98 >> 6);
        uint64_t v100 = (HIDWORD(v95) + 1);
        uint64_t v95 = (v100 << 32) | v95;
        if (v100 == v99 - 1)
        {
          uint64_t v95 = (v100 << 32) | v100;
          uint64_t v86 = *(void *)(v86 + 40);
          goto LABEL_63;
        }
      }
      if (v158)
      {
        uint64_t v101 = 0;
        for (uint64_t i = 0; v158 > (unint64_t)i; uint64_t i = (void **)((char *)i + 1))
        {
          int v103 = *(_DWORD *)&v157[v101];
          if ((v103 - 2) >= 2)
          {
            if (v103 == 1)
            {
              Object = (void **)GTMTLSMContext_getObject(**((void **)*v168 + 5), *(void *)&v157[v101 + 8], v85);
              if (Object)
              {
                if (*(_DWORD *)Object == 44)
                {
                  unint64_t v146 = v85;
                  unint64_t v169 = i;
                  uint64_t v170 = Object;
                  if (!v174)
                  {
LABEL_126:
                    std::__throw_bad_function_call[abi:nn180100]();
                    __break(1u);
                    return;
                  }
                  (*(void (**)(void *, unint64_t *, void ***, void ***))(*v174 + 48))(v174, &v146, &v170, &v169);
                }
              }
            }
          }
          else
          {
            unint64_t v146 = *(void *)&v157[v101 + 8];
            uint64_t v170 = i;
            if (!v172) {
              goto LABEL_126;
            }
            (*(void (**)(void *, unint64_t *, void ***))(*v172 + 48))(v172, &v146, &v170);
          }
          v101 += 16;
        }
      }
      unint64_t v106 = *(void *)(a1 + 248);
      unint64_t v105 = *(void *)(a1 + 256);
      if (v106 >= v105)
      {
        uint64_t v108 = *(void *)(a1 + 240);
        uint64_t v109 = (uint64_t)(v106 - v108) >> 5;
        if ((unint64_t)(v109 + 1) >> 59) {
          abort();
        }
        uint64_t v110 = v105 - v108;
        uint64_t v111 = v110 >> 4;
        if (v110 >> 4 <= (unint64_t)(v109 + 1)) {
          uint64_t v111 = v109 + 1;
        }
        if ((unint64_t)v110 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v112 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v112 = v111;
        }
        if (v112) {
          unint64_t v112 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>>(v112);
        }
        else {
          uint64_t v113 = 0;
        }
        unint64_t v115 = v112 + 32 * v109;
        unint64_t v116 = v112 + 32 * v113;
        *(void *)unint64_t v115 = off_747528;
        *(void *)(v115 + 8) = v164;
        *(_OWORD *)(v115 + 16) = v165;
        unint64_t v107 = v115 + 32;
        unint64_t v117 = *(char **)(a1 + 240);
        unint64_t v118 = *(char **)(a1 + 248);
        if (v118 == v117)
        {
          *(void *)(a1 + 240) = v115;
          *(void *)(a1 + 248) = v107;
          *(void *)(a1 + 256) = v116;
        }
        else
        {
          unint64_t v119 = v115 - 32;
          do
          {
            *(void *)(v115 - 32) = off_747528;
            v115 -= 32;
            uint64_t v120 = *((void *)v118 - 3);
            *((void *)v118 - 3) = 0;
            *(void *)(v115 + 8) = v120;
            *(_OWORD *)(v115 + 16) = *((_OWORD *)v118 - 1);
            v119 -= 32;
            v118 -= 32;
          }
          while (v118 != v117);
          unint64_t v118 = *(char **)(a1 + 240);
          uint64_t v121 = *(char **)(a1 + 248);
          *(void *)(a1 + 240) = v115;
          *(void *)(a1 + 248) = v107;
          *(void *)(a1 + 256) = v116;
          if (v121 == v118)
          {
            unint64_t v118 = v121;
          }
          else
          {
            uint64_t v122 = v121 - 32;
            uint64_t v123 = v121 - 32;
            uint64_t v124 = (void (***)(char *))(v121 - 32);
            do
            {
              uint64_t v125 = *v124;
              v124 -= 4;
              (*v125)(v123);
              v122 -= 32;
              BOOL v126 = v123 == v118;
              uint64_t v123 = (char *)v124;
            }
            while (!v126);
          }
        }
        if (v118) {
          operator delete(v118);
        }
      }
      else
      {
        *(void *)unint64_t v106 = off_747528;
        *(void *)(v106 + 8) = v164;
        *(_OWORD *)(v106 + 16) = v165;
        unint64_t v107 = v106 + 32;
      }
      *(void *)(a1 + 248) = v107;
      unint64_t v127 = v165;
      unint64_t v146 = v165;
      long long v147 = 0uLL;
      uint64_t v148 = 0;
      unint64_t v128 = v161;
      uint64_t v129 = v162;
      if (v162 == v161)
      {
        uint64_t v133 = 0;
      }
      else
      {
        unint64_t v130 = 0x86BCA1AF286BCA1BLL * ((v162 - v161) >> 3);
        if (v130 >= 0x1AF286BCA1AF287) {
          abort();
        }
        uint64_t v131 = (AccelerationStructureViewer::IntersectionFunction *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunction>>(v130);
        uint64_t v133 = (char *)v131 + 152 * v132;
        *(void *)&long long v147 = v131;
        uint64_t v148 = v133;
        do
        {
          uint64_t v134 = AccelerationStructureViewer::IntersectionFunction::IntersectionFunction(v131, v128);
          unint64_t v128 = (const AccelerationStructureViewer::IntersectionFunction *)((char *)v128 + 152);
          uint64_t v131 = (AccelerationStructureViewer::IntersectionFunction *)((char *)v134 + 152);
        }
        while (v128 != v129);
        *((void *)&v147 + 1) = v131;
      }
      uint64_t v135 = *(char **)(a1 + 272);
      if (v135)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v136 = (char **)v135;
            unint64_t v137 = *((void *)v135 + 4);
            if (v127 >= v137) {
              break;
            }
            uint64_t v135 = *v136;
            unint64_t v138 = v136;
            if (!*v136) {
              goto LABEL_120;
            }
          }
          if (v137 >= v127) {
            break;
          }
          uint64_t v135 = v136[1];
          if (!v135)
          {
            unint64_t v138 = v136 + 1;
            goto LABEL_120;
          }
        }
      }
      else
      {
        unint64_t v138 = (char **)(a1 + 272);
        uint64_t v136 = (char **)(a1 + 272);
LABEL_120:
        uint64_t v139 = (char *)operator new(0x40uLL);
        *((void *)v139 + 4) = v127;
        *(_OWORD *)(v139 + 40) = v147;
        *((void *)v139 + 7) = v133;
        uint64_t v148 = 0;
        long long v147 = 0uLL;
        *(void *)uint64_t v139 = 0;
        *((void *)v139 + 1) = 0;
        *((void *)v139 + 2) = v136;
        char *v138 = v139;
        uint64_t v140 = **(void **)(a1 + 264);
        if (v140)
        {
          *(void *)(a1 + 264) = v140;
          uint64_t v139 = *v138;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 272), (uint64_t *)v139);
        ++*(void *)(a1 + 280);
      }
      uint64_t v170 = (void **)&v147;
      std::vector<AccelerationStructureViewer::IntersectionFunction>::__destroy_vector::operator()[abi:nn180100](&v170);
      std::__function::__value_func<void ()(unsigned long,unsigned long)>::~__value_func[abi:nn180100](v171);
      std::__function::__value_func<void ()(unsigned long long,GTMTLSMFunctionHandle const*,unsigned long)>::~__value_func[abi:nn180100](v173);
      newpool = (apr_pool_t *)&v161;
      std::vector<AccelerationStructureViewer::IntersectionFunction>::__destroy_vector::operator()[abi:nn180100]((void ***)&newpool);
    }
    else if (v12 == 50)
    {
      uint64_t v16 = *((void *)*a2 + 10);
      uint64_t v17 = *(void *)(a1 + 288);
      BOOL v18 = apr_array_make(a5, 4, 8);
      unint64_t v19 = v17 + v16;
      uint64_t v20 = *((void *)*a2 + 5);
      newpool = 0;
      apr_pool_create_ex(&newpool, a5, 0, v21);
      uint64_t v22 = *(_DWORD **)(v20 + 72);
      unsigned int v23 = newpool;
      id v24 = apr_array_make(newpool, 128, 8);
      GTMTLSMContext_getObjects(v22, v19, v24);
      int nelts = v24->nelts;
      if (nelts)
      {
        for (unint64_t j = 0; j < nelts; ++j)
        {
          uint64_t v27 = *(void *)&v24->elts[8 * j];
          if (*(apr_pool_t **)(v27 + 48) == v10)
          {
            *(void *)apr_array_push(v18) = v27;
            int nelts = v24->nelts;
          }
        }
      }
      apr_pool_destroy(v23);
      if (v18->nelts >= 1)
      {
        uint64_t v28 = 0;
        do
        {
          uint64_t v29 = *(void *)&v18->elts[8 * v28];
          if (v29) {
            unint64_t v30 = *(void *)(v29 + 8);
          }
          else {
            unint64_t v30 = 0;
          }
          unsigned int v31 = [v168[1] accelerationStructureForKey:v30];
          uint64_t v32 = v31;
          if (v31)
          {
            v33.n128_u64[0] = (unint64_t)[v31 uniqueIdentifier];
            v33.n128_u64[1] = v30;
            std::__tree<std::__value_type<unsigned long long,unsigned long long>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned long long>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long,unsigned long long>>(a6, v33.n128_u64[0], v33);
          }

          ++v28;
        }
        while (v28 < v18->nelts);
      }
    }
    else if (v12 == 16)
    {
      id v13 = [a2[1] accelerationStructureForKey:v10];
      uint64_t v14 = v13;
      if (v13)
      {
        v15.n128_u64[0] = (unint64_t)[v13 uniqueIdentifier];
        v15.n128_u64[1] = (unint64_t)v10;
        std::__tree<std::__value_type<unsigned long long,unsigned long long>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned long long>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long,unsigned long long>>(a6, v15.n128_u64[0], v15);
      }
    }
  }
}

void sub_1BD480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  STACK[0x400] = (unint64_t)&STACK[0x460];
  std::vector<AccelerationStructureViewer::IntersectionFunction>::__destroy_vector::operator()[abi:nn180100]((void ***)&STACK[0x400]);

  _Unwind_Resume(a1);
}

__n128 *std::__tree<std::__value_type<unsigned long long,unsigned long long>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned long long>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long,unsigned long long>>(uint64_t **a1, unint64_t a2, __n128 a3)
{
  uint64_t v5 = a1 + 1;
  uint64_t v4 = (__n128 *)a1[1];
  if (v4)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v6 = v4;
        unint64_t v7 = v4[2].n128_u64[0];
        if (v7 <= a2) {
          break;
        }
        uint64_t v4 = (__n128 *)v6->n128_u64[0];
        uint64_t v5 = (uint64_t **)v6;
        if (!v6->n128_u64[0]) {
          goto LABEL_9;
        }
      }
      if (v7 >= a2) {
        break;
      }
      uint64_t v4 = (__n128 *)v6->n128_u64[1];
      if (!v4)
      {
        uint64_t v5 = (uint64_t **)&v6->n128_u64[1];
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v6 = (__n128 *)(a1 + 1);
LABEL_9:
    uint64_t v8 = v6;
    uint64_t v6 = (__n128 *)operator new(0x30uLL);
    v6[2] = a3;
    v6->n128_u64[0] = 0;
    v6->n128_u64[1] = 0;
    v6[1].n128_u64[0] = (unint64_t)v8;
    void *v5 = (uint64_t *)v6;
    id v9 = (uint64_t *)**a1;
    unint64_t v10 = (uint64_t *)v6;
    if (v9)
    {
      *a1 = v9;
      unint64_t v10 = *v5;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v6;
}

void *std::__function::__value_func<void ()(unsigned long,unsigned long)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<void ()(unsigned long long,GTMTLSMFunctionHandle const*,unsigned long)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(GTMTLReplayController *,GTMTLSMObject const*,long,apr_pool_t *,std::map<unsigned long long,unsigned long long> &)::$_1,std::allocator<AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(GTMTLReplayController *,GTMTLSMObject const*,long,apr_pool_t *,std::map<unsigned long long,unsigned long long> &)::$_1>,void ()(unsigned long,unsigned long)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *a3;
  AccelerationStructureViewer::IntersectionFunction::IntersectionFunction((AccelerationStructureViewer::IntersectionFunction *)&v107, (const AccelerationStructureViewer::IntersectionFunction *)(**(void **)(a1 + 8) + 152 * *a3));
  char v113 = 1;
  char v112 = 0;
  id v6 = objc_alloc_init((Class)NSMutableArray);
  unint64_t v7 = v6;
  if (v4)
  {
    if (v4)
    {
      [v6 addObject:@"instancing"];
      uint64_t v8 = v115;
      if ((unint64_t)v115 >= v116)
      {
        unint64_t v10 = (char *)__p;
        uint64_t v11 = (v115 - (unsigned char *)__p) >> 2;
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 62) {
          abort();
        }
        uint64_t v13 = v116 - (void)__p;
        if ((uint64_t)(v116 - (void)__p) >> 1 > v12) {
          unint64_t v12 = v13 >> 1;
        }
        BOOL v14 = (unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL;
        unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
        if (!v14) {
          unint64_t v15 = v12;
        }
        if (v15)
        {
          unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v15);
          unint64_t v10 = (char *)__p;
          uint64_t v8 = v115;
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v17 = (char *)(v15 + 4 * v11);
        unint64_t v18 = v15 + 4 * v16;
        *(_DWORD *)uint64_t v17 = 1;
        id v9 = v17 + 4;
        while (v8 != v10)
        {
          int v19 = *((_DWORD *)v8 - 1);
          v8 -= 4;
          *((_DWORD *)v17 - 1) = v19;
          v17 -= 4;
        }
        __p = v17;
        unint64_t v115 = v9;
        unint64_t v116 = v18;
        if (v10) {
          operator delete(v10);
        }
      }
      else
      {
        *(_DWORD *)unint64_t v115 = 1;
        id v9 = v8 + 4;
      }
      unint64_t v115 = v9;
    }
    if ((v4 & 2) != 0)
    {
      [v7 addObject:@"triangle_data"];
      uint64_t v20 = v115;
      if ((unint64_t)v115 >= v116)
      {
        uint64_t v22 = (char *)__p;
        uint64_t v23 = (v115 - (unsigned char *)__p) >> 2;
        unint64_t v24 = v23 + 1;
        if ((unint64_t)(v23 + 1) >> 62) {
          abort();
        }
        uint64_t v25 = v116 - (void)__p;
        if ((uint64_t)(v116 - (void)__p) >> 1 > v24) {
          unint64_t v24 = v25 >> 1;
        }
        BOOL v14 = (unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL;
        unint64_t v26 = 0x3FFFFFFFFFFFFFFFLL;
        if (!v14) {
          unint64_t v26 = v24;
        }
        if (v26)
        {
          unint64_t v26 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v26);
          uint64_t v22 = (char *)__p;
          uint64_t v20 = v115;
        }
        else
        {
          uint64_t v27 = 0;
        }
        uint64_t v28 = (char *)(v26 + 4 * v23);
        unint64_t v29 = v26 + 4 * v27;
        *(_DWORD *)uint64_t v28 = 2;
        int v21 = v28 + 4;
        while (v20 != v22)
        {
          int v30 = *((_DWORD *)v20 - 1);
          v20 -= 4;
          *((_DWORD *)v28 - 1) = v30;
          v28 -= 4;
        }
        __p = v28;
        unint64_t v115 = v21;
        unint64_t v116 = v29;
        if (v22) {
          operator delete(v22);
        }
      }
      else
      {
        *(_DWORD *)unint64_t v115 = 2;
        int v21 = v20 + 4;
      }
      unint64_t v115 = v21;
    }
    if ((v4 & 4) != 0)
    {
      [v7 addObject:@"world_space_data"];
      unsigned int v31 = v115;
      if ((unint64_t)v115 >= v116)
      {
        __n128 v33 = (char *)__p;
        uint64_t v34 = (v115 - (unsigned char *)__p) >> 2;
        unint64_t v35 = v34 + 1;
        if ((unint64_t)(v34 + 1) >> 62) {
          abort();
        }
        uint64_t v36 = v116 - (void)__p;
        if ((uint64_t)(v116 - (void)__p) >> 1 > v35) {
          unint64_t v35 = v36 >> 1;
        }
        BOOL v14 = (unint64_t)v36 >= 0x7FFFFFFFFFFFFFFCLL;
        unint64_t v37 = 0x3FFFFFFFFFFFFFFFLL;
        if (!v14) {
          unint64_t v37 = v35;
        }
        if (v37)
        {
          unint64_t v37 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v37);
          __n128 v33 = (char *)__p;
          unsigned int v31 = v115;
        }
        else
        {
          uint64_t v38 = 0;
        }
        unint64_t v39 = (char *)(v37 + 4 * v34);
        unint64_t v40 = v37 + 4 * v38;
        *(_DWORD *)unint64_t v39 = 3;
        uint64_t v32 = v39 + 4;
        while (v31 != v33)
        {
          int v41 = *((_DWORD *)v31 - 1);
          v31 -= 4;
          *((_DWORD *)v39 - 1) = v41;
          v39 -= 4;
        }
        __p = v39;
        unint64_t v115 = v32;
        unint64_t v116 = v40;
        if (v33) {
          operator delete(v33);
        }
      }
      else
      {
        *(_DWORD *)unint64_t v115 = 3;
        uint64_t v32 = v31 + 4;
      }
      unint64_t v115 = v32;
    }
    if ((v4 & 0x10) != 0)
    {
      [v7 addObject:@"primitive_motion"];
      id v42 = v115;
      if ((unint64_t)v115 >= v116)
      {
        int64x2_t v44 = (char *)__p;
        uint64_t v45 = (v115 - (unsigned char *)__p) >> 2;
        unint64_t v46 = v45 + 1;
        if ((unint64_t)(v45 + 1) >> 62) {
          abort();
        }
        uint64_t v47 = v116 - (void)__p;
        if ((uint64_t)(v116 - (void)__p) >> 1 > v46) {
          unint64_t v46 = v47 >> 1;
        }
        BOOL v14 = (unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL;
        unint64_t v48 = 0x3FFFFFFFFFFFFFFFLL;
        if (!v14) {
          unint64_t v48 = v46;
        }
        if (v48)
        {
          unint64_t v48 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v48);
          int64x2_t v44 = (char *)__p;
          id v42 = v115;
        }
        else
        {
          uint64_t v49 = 0;
        }
        uint64_t v50 = (char *)(v48 + 4 * v45);
        unint64_t v51 = v48 + 4 * v49;
        *(_DWORD *)uint64_t v50 = 4;
        unint64_t v43 = v50 + 4;
        while (v42 != v44)
        {
          int v52 = *((_DWORD *)v42 - 1);
          v42 -= 4;
          *((_DWORD *)v50 - 1) = v52;
          v50 -= 4;
        }
        __p = v50;
        unint64_t v115 = v43;
        unint64_t v116 = v51;
        if (v44) {
          operator delete(v44);
        }
      }
      else
      {
        *(_DWORD *)unint64_t v115 = 4;
        unint64_t v43 = v42 + 4;
      }
      unint64_t v115 = v43;
    }
    if ((v4 & 8) != 0)
    {
      [v7 addObject:@"instance_motion"];
      int64x2_t v53 = v115;
      if ((unint64_t)v115 >= v116)
      {
        int64x2_t v55 = (char *)__p;
        uint64_t v56 = (v115 - (unsigned char *)__p) >> 2;
        unint64_t v57 = v56 + 1;
        if ((unint64_t)(v56 + 1) >> 62) {
          abort();
        }
        uint64_t v58 = v116 - (void)__p;
        if ((uint64_t)(v116 - (void)__p) >> 1 > v57) {
          unint64_t v57 = v58 >> 1;
        }
        BOOL v14 = (unint64_t)v58 >= 0x7FFFFFFFFFFFFFFCLL;
        unint64_t v59 = 0x3FFFFFFFFFFFFFFFLL;
        if (!v14) {
          unint64_t v59 = v57;
        }
        if (v59)
        {
          unint64_t v59 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v59);
          int64x2_t v55 = (char *)__p;
          int64x2_t v53 = v115;
        }
        else
        {
          uint64_t v60 = 0;
        }
        unint64_t v61 = (char *)(v59 + 4 * v56);
        unint64_t v62 = v59 + 4 * v60;
        *(_DWORD *)unint64_t v61 = 5;
        uint64_t v54 = v61 + 4;
        while (v53 != v55)
        {
          int v63 = *((_DWORD *)v53 - 1);
          v53 -= 4;
          *((_DWORD *)v61 - 1) = v63;
          v61 -= 4;
        }
        __p = v61;
        unint64_t v115 = v54;
        unint64_t v116 = v62;
        if (v55) {
          operator delete(v55);
        }
      }
      else
      {
        *(_DWORD *)unint64_t v115 = 5;
        uint64_t v54 = v53 + 4;
      }
      unint64_t v115 = v54;
    }
    if ((v4 & 0x20) != 0)
    {
      [v7 addObject:@"extended_limits"];
      uint64_t v64 = v115;
      if ((unint64_t)v115 >= v116)
      {
        int v66 = (char *)__p;
        uint64_t v67 = (v115 - (unsigned char *)__p) >> 2;
        unint64_t v68 = v67 + 1;
        if ((unint64_t)(v67 + 1) >> 62) {
          abort();
        }
        uint64_t v69 = v116 - (void)__p;
        if ((uint64_t)(v116 - (void)__p) >> 1 > v68) {
          unint64_t v68 = v69 >> 1;
        }
        BOOL v14 = (unint64_t)v69 >= 0x7FFFFFFFFFFFFFFCLL;
        unint64_t v70 = 0x3FFFFFFFFFFFFFFFLL;
        if (!v14) {
          unint64_t v70 = v68;
        }
        if (v70)
        {
          unint64_t v70 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v70);
          int v66 = (char *)__p;
          uint64_t v64 = v115;
        }
        else
        {
          uint64_t v71 = 0;
        }
        uint64_t v72 = (char *)(v70 + 4 * v67);
        unint64_t v73 = v70 + 4 * v71;
        *(_DWORD *)uint64_t v72 = 6;
        CFStringRef v65 = v72 + 4;
        while (v64 != v66)
        {
          int v74 = *((_DWORD *)v64 - 1);
          v64 -= 4;
          *((_DWORD *)v72 - 1) = v74;
          v72 -= 4;
        }
        __p = v72;
        unint64_t v115 = v65;
        unint64_t v116 = v73;
        if (v66) {
          operator delete(v66);
        }
      }
      else
      {
        *(_DWORD *)unint64_t v115 = 6;
        CFStringRef v65 = v64 + 4;
      }
      unint64_t v115 = v65;
    }
    if ((v4 & 0x40) != 0)
    {
      [v7 addObject:@"max_levels"];
      unint64_t v75 = v115;
      if ((unint64_t)v115 >= v116)
      {
        uint64_t v77 = (char *)__p;
        uint64_t v78 = (v115 - (unsigned char *)__p) >> 2;
        unint64_t v79 = v78 + 1;
        if ((unint64_t)(v78 + 1) >> 62) {
          abort();
        }
        uint64_t v80 = v116 - (void)__p;
        if ((uint64_t)(v116 - (void)__p) >> 1 > v79) {
          unint64_t v79 = v80 >> 1;
        }
        BOOL v14 = (unint64_t)v80 >= 0x7FFFFFFFFFFFFFFCLL;
        unint64_t v81 = 0x3FFFFFFFFFFFFFFFLL;
        if (!v14) {
          unint64_t v81 = v79;
        }
        if (v81)
        {
          unint64_t v81 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v81);
          uint64_t v77 = (char *)__p;
          unint64_t v75 = v115;
        }
        else
        {
          uint64_t v82 = 0;
        }
        uint64_t v83 = (char *)(v81 + 4 * v78);
        unint64_t v84 = v81 + 4 * v82;
        *(_DWORD *)uint64_t v83 = 8;
        unint64_t v76 = v83 + 4;
        while (v75 != v77)
        {
          int v85 = *((_DWORD *)v75 - 1);
          v75 -= 4;
          *((_DWORD *)v83 - 1) = v85;
          v83 -= 4;
        }
        __p = v83;
        unint64_t v115 = v76;
        unint64_t v116 = v84;
        if (v77) {
          operator delete(v77);
        }
      }
      else
      {
        *(_DWORD *)unint64_t v115 = 8;
        unint64_t v76 = v75 + 4;
      }
      unint64_t v115 = v76;
    }
  }
  uint64_t v86 = [v7 componentsJoinedByString:@", "];
  unsigned int v87 = +[NSString stringWithFormat:@"Opaque<%@>", v86];
  id v88 = v111;
  id v111 = v87;

  id v89 = v111;
  id v90 = v89;
  uint64_t v91 = v109;
  if (v109 >= (_WORD *)v110)
  {
    uint64_t v93 = ((char *)v109 - (char *)v108) >> 4;
    unint64_t v94 = v93 + 1;
    if ((unint64_t)(v93 + 1) >> 60) {
      abort();
    }
    uint64_t v95 = (char *)v110 - (char *)v108;
    if (v110 - v108 > v94) {
      unint64_t v94 = v95 >> 3;
    }
    if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v96 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v96 = v94;
    }
    v118[4] = (void **)&v110;
    uint64_t v97 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(v96);
    int v99 = &v97[16 * v93];
    *(_WORD *)int v99 = 2;
    *((void *)v99 + 1) = v90;
    uint64_t v101 = v108;
    uint64_t v100 = (void **)v109;
    if (v109 == (_WORD *)v108)
    {
      int v103 = &v97[16 * v93];
    }
    else
    {
      unint64_t v102 = (void **)v109;
      int v103 = &v97[16 * v93];
      do
      {
        __int16 v104 = *((_WORD *)v102 - 8);
        v102 -= 2;
        *((_WORD *)v103 - 8) = v104;
        v103 -= 16;
        unint64_t v105 = v102[1];
        v102[1] = 0;
        *((void *)v103 + 1) = v105;
      }
      while (v102 != v101);
    }
    uint64_t v92 = v99 + 16;
    uint64_t v108 = (void **)v103;
    uint64_t v109 = v99 + 16;
    unint64_t v106 = v110;
    uint64_t v110 = (void **)&v97[16 * v98];
    v118[2] = v100;
    v118[3] = v106;
    v118[0] = v101;
    v118[1] = v101;
    std::__split_buffer<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::~__split_buffer((uint64_t)v118);
  }
  else
  {
    _WORD *v109 = 2;
    *((void *)v91 + 1) = v89;
    uint64_t v92 = v91 + 8;
  }
  uint64_t v109 = v92;
  AccelerationStructureViewer::IntersectionFunction::operator=(**(void **)(a1 + 8) + 152 * v5, (uint64_t)&v107);

  unint64_t v107 = off_744700;
  v118[0] = (void **)&v117;
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](v118);
  if (__p)
  {
    unint64_t v115 = (char *)__p;
    operator delete(__p);
  }

  v118[0] = (void **)&v108;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](v118);
}

void sub_1BDED8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  *(void *)(v27 - 72) = &a26;
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100]((void ***)(v27 - 72));
  if (__p)
  {
    a21 = (uint64_t)__p;
    operator delete(__p);
  }

  *(void *)(v27 - 72) = &a11;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100]((void ***)(v27 - 72));
  _Unwind_Resume(a1);
}

uint64_t AccelerationStructureViewer::IntersectionFunction::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 == a2)
  {
    objc_storeStrong((id *)(a1 + 32), *(id *)(a1 + 32));
    return a1;
  }
  uint64_t v4 = *(_WORD **)(a1 + 8);
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  unint64_t v7 = (v5 - v6) >> 4;
  if (v7 > (uint64_t)(*(void *)(a1 + 24) - (void)v4) >> 4)
  {
    std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__vdeallocate((void **)(a1 + 8));
    if (v5 - v6 < 0) {
      goto LABEL_52;
    }
    uint64_t v8 = *(void *)(a1 + 24) - *(void *)(a1 + 8);
    uint64_t v9 = v8 >> 3;
    if (v8 >> 3 <= v7) {
      uint64_t v9 = (v5 - v6) >> 4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v9;
    }
    std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__vallocate[abi:nn180100]((void *)(a1 + 8), v10);
    uint64_t v11 = (void *)(a1 + 8);
    uint64_t v12 = v6;
    goto LABEL_13;
  }
  unint64_t v13 = (uint64_t)(*(void *)(a1 + 16) - (void)v4) >> 4;
  if (v13 < v7)
  {
    uint64_t v14 = v6 + 16 * v13;
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}> *,std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}> *,std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}> *>(*(void *)(a2 + 8), v14, v4);
    uint64_t v11 = (void *)(a1 + 8);
    uint64_t v12 = v14;
LABEL_13:
    std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__construct_at_end<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>*,std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>*>(v11, v12, v5);
    goto LABEL_17;
  }
  unint64_t v15 = (id *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}> *,std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}> *,std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}> *>(*(void *)(a2 + 8), *(void *)(a2 + 16), v4);
  uint64_t v16 = *(id **)(a1 + 16);
  if (v16 != v15)
  {
    do
    {
      uint64_t v17 = v16 - 2;

      uint64_t v16 = v17;
    }
    while (v17 != v15);
  }
  *(void *)(a1 + 16) = v15;
LABEL_17:
  objc_storeStrong((id *)(a1 + 32), *(id *)(a2 + 32));
  long long v18 = *(_OWORD *)(a2 + 40);
  long long v19 = *(_OWORD *)(a2 + 56);
  uint64_t v20 = *(char **)(a1 + 80);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v19;
  *(_OWORD *)(a1 + 40) = v18;
  int v21 = *(char **)(a2 + 80);
  uint64_t v22 = *(unsigned char **)(a2 + 88);
  size_t v23 = v22 - v21;
  unint64_t v24 = (v22 - v21) >> 2;
  uint64_t v25 = *(void *)(a1 + 96);
  if (v24 <= (v25 - (uint64_t)v20) >> 2)
  {
    uint64_t v28 = *(unsigned char **)(a1 + 88);
    unint64_t v29 = (v28 - v20) >> 2;
    if (v29 < v24)
    {
      int v30 = &v21[4 * v29];
      if (v28 != v20)
      {
        memmove(v20, *(const void **)(a2 + 80), v28 - v20);
        uint64_t v20 = *(char **)(a1 + 88);
      }
      size_t v23 = v22 - v30;
      if (v22 == v30) {
        goto LABEL_35;
      }
      unsigned int v31 = v20;
      uint64_t v32 = v30;
      goto LABEL_34;
    }
  }
  else
  {
    if (v20)
    {
      *(void *)(a1 + 88) = v20;
      operator delete(v20);
      uint64_t v25 = 0;
      *(void *)(a1 + 80) = 0;
      *(void *)(a1 + 88) = 0;
      *(void *)(a1 + 96) = 0;
    }
    if ((v23 & 0x8000000000000000) != 0) {
      goto LABEL_52;
    }
    uint64_t v26 = v25 >> 1;
    if (v25 >> 1 <= v24) {
      uint64_t v26 = (v22 - v21) >> 2;
    }
    if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v27 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v27 = v26;
    }
    std::vector<AccelerationStructureViewer::IntersectionFunctionTag>::__vallocate[abi:nn180100]((void *)(a1 + 80), v27);
    uint64_t v20 = *(char **)(a1 + 88);
  }
  if (v22 != v21)
  {
    unsigned int v31 = v20;
    uint64_t v32 = v21;
LABEL_34:
    memmove(v31, v32, v23);
  }
LABEL_35:
  uint64_t v33 = *(void *)(a1 + 128);
  *(void *)(a1 + 88) = &v20[v23];
  long long v34 = *(_OWORD *)(a2 + 104);
  *(void *)(a1 + 120) = *(void *)(a2 + 120);
  *(_OWORD *)(a1 + 104) = v34;
  uint64_t v36 = *(void *)(a2 + 128);
  uint64_t v35 = *(void *)(a2 + 136);
  unint64_t v37 = 0xEEEEEEEEEEEEEEEFLL * ((v35 - v36) >> 3);
  if (0xEEEEEEEEEEEEEEEFLL * ((*(void *)(a1 + 144) - v33) >> 3) < v37)
  {
    std::vector<AccelerationStructureViewer::Property>::__vdeallocate((void **)(a1 + 128));
    if (v37 <= 0x222222222222222)
    {
      unint64_t v38 = 0xDDDDDDDDDDDDDDDELL * ((uint64_t)(*(void *)(a1 + 144) - *(void *)(a1 + 128)) >> 3);
      if (v38 <= v37) {
        unint64_t v38 = 0xEEEEEEEEEEEEEEEFLL * ((v35 - v36) >> 3);
      }
      if (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(void *)(a1 + 144) - *(void *)(a1 + 128)) >> 3) >= 0x111111111111111) {
        unint64_t v39 = 0x222222222222222;
      }
      else {
        unint64_t v39 = v38;
      }
      std::vector<AccelerationStructureViewer::Property>::__vallocate[abi:nn180100]((void *)(a1 + 128), v39);
      unint64_t v40 = (char *)(a1 + 128);
      uint64_t v41 = v36;
      goto LABEL_45;
    }
LABEL_52:
    abort();
  }
  if (0xEEEEEEEEEEEEEEEFLL * ((*(void *)(a1 + 136) - v33) >> 3) < v37)
  {
    uint64_t v42 = v36 + 8 * ((*(void *)(a1 + 136) - v33) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<AccelerationStructureViewer::Property *,AccelerationStructureViewer::Property *,AccelerationStructureViewer::Property *>(v36, v42, v33);
    unint64_t v40 = (char *)(a1 + 128);
    uint64_t v41 = v42;
LABEL_45:
    std::vector<AccelerationStructureViewer::Property>::__construct_at_end<AccelerationStructureViewer::Property*,AccelerationStructureViewer::Property*>(v40, v41, v35);
    return a1;
  }
  uint64_t v43 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<AccelerationStructureViewer::Property *,AccelerationStructureViewer::Property *,AccelerationStructureViewer::Property *>(v36, v35, v33);
  uint64_t v44 = *(void *)(a1 + 136);
  if (v44 != v43)
  {
    uint64_t v45 = v44 - 120;
    unint64_t v46 = (void (***)(void))(v44 - 120);
    uint64_t v47 = (void (***)(void))(v44 - 120);
    do
    {
      unint64_t v48 = *v47;
      v47 -= 15;
      (*v48)(v46);
      v45 -= 120;
      BOOL v49 = v46 == (void (***)(void))v43;
      unint64_t v46 = v47;
    }
    while (!v49);
  }
  *(void *)(a1 + 136) = v43;
  return a1;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<AccelerationStructureViewer::Property *,AccelerationStructureViewer::Property *,AccelerationStructureViewer::Property *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      __int16 v6 = *(_WORD *)(v5 + 8);
      *(unsigned char *)(a3 + 10) = *(unsigned char *)(v5 + 10);
      *(_WORD *)(a3 + 8) = v6;
      objc_storeStrong((id *)(a3 + 16), *(id *)(v5 + 16));
      *(_OWORD *)(a3 + 24) = *(_OWORD *)(v5 + 24);
      long long v7 = *(_OWORD *)(v5 + 40);
      long long v8 = *(_OWORD *)(v5 + 56);
      long long v9 = *(_OWORD *)(v5 + 72);
      *(void *)(a3 + 88) = *(void *)(v5 + 88);
      *(_OWORD *)(a3 + 72) = v9;
      *(_OWORD *)(a3 + 56) = v8;
      *(_OWORD *)(a3 + 40) = v7;
      if (a3 != v5)
      {
        unint64_t v10 = (void **)(a3 + 96);
        uint64_t v11 = *(void *)(a3 + 96);
        unint64_t v13 = *(void ***)(v5 + 96);
        uint64_t v12 = *(void ***)(v5 + 104);
        unint64_t v14 = v12 - v13;
        uint64_t v15 = *(void *)(a3 + 112);
        if (v14 <= (v15 - v11) >> 3)
        {
          unint64_t v23 = (*(void *)(a3 + 104) - v11) >> 3;
          if (v23 >= v14)
          {
            unint64_t v27 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<NSString * {__strong}*,NSString * {__strong}*,NSString * {__strong}*>(*(void ***)(v5 + 96), *(void ***)(v5 + 104), *(id **)(a3 + 96));
            for (uint64_t i = *(id **)(a3 + 104); i != v27; --i)
            {
              unint64_t v29 = *(i - 1);
            }
            *(void *)(a3 + 104) = v27;
          }
          else
          {
            unint64_t v24 = &v13[v23];
            std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<NSString * {__strong}*,NSString * {__strong}*,NSString * {__strong}*>(*(void ***)(v5 + 96), v24, *(id **)(a3 + 96));
            uint64_t v25 = *(void **)(a3 + 104);
            while (v24 != v12)
            {
              uint64_t v26 = *v24++;
              *v25++ = v26;
            }
            *(void *)(a3 + 104) = v25;
          }
        }
        else
        {
          if (v11)
          {
            uint64_t v16 = *(void *)(a3 + 104);
            uint64_t v17 = *(void **)(a3 + 96);
            if (v16 != v11)
            {
              do
              {
                long long v18 = *(void **)(v16 - 8);
                v16 -= 8;
              }
              while (v16 != v11);
              uint64_t v17 = *v10;
            }
            *(void *)(a3 + 104) = v11;
            operator delete(v17);
            uint64_t v15 = 0;
            char *v10 = 0;
            *(void *)(a3 + 104) = 0;
            *(void *)(a3 + 112) = 0;
          }
          if ((char *)v12 - (char *)v13 < 0) {
            abort();
          }
          uint64_t v19 = v15 >> 2;
          if (v15 >> 2 <= v14) {
            uint64_t v19 = v12 - v13;
          }
          if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v19;
          }
          std::vector<NSString * {__strong}>::__vallocate[abi:nn180100]((void *)(a3 + 96), v20);
          int v21 = *(void **)(a3 + 104);
          while (v13 != v12)
          {
            uint64_t v22 = *v13++;
            *v21++ = v22;
          }
          *(void *)(a3 + 104) = v21;
        }
      }
      v5 += 120;
      a3 += 120;
    }
    while (v5 != a2);
  }
  return a3;
}

id *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<NSString * {__strong}*,NSString * {__strong}*,NSString * {__strong}*>(void **a1, void **a2, id *location)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      __int16 v6 = *v5++;
      objc_storeStrong(location++, v6);
    }
    while (v5 != a2);
  }
  return location;
}

_WORD *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}> *,std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}> *,std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}> *>(uint64_t a1, uint64_t a2, _WORD *a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      __int16 v6 = (id *)(a3 + 4);
      *a3 = *(_WORD *)v5;
      a3 += 8;
      objc_storeStrong(v6, *(id *)(v5 + 8));
      v5 += 16;
    }
    while (v5 != a2);
  }
  return a3;
}

uint64_t std::__function::__func<AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(GTMTLReplayController *,GTMTLSMObject const*,long,apr_pool_t *,std::map<unsigned long long,unsigned long long> &)::$_1,std::allocator<AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(GTMTLReplayController *,GTMTLSMObject const*,long,apr_pool_t *,std::map<unsigned long long,unsigned long long> &)::$_1>,void ()(unsigned long,unsigned long)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = off_744120;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(GTMTLReplayController *,GTMTLSMObject const*,long,apr_pool_t *,std::map<unsigned long long,unsigned long long> &)::$_1,std::allocator<AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(GTMTLReplayController *,GTMTLSMObject const*,long,apr_pool_t *,std::map<unsigned long long,unsigned long long> &)::$_1>,void ()(unsigned long,unsigned long)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = off_744120;
  result[1] = v3;
  return result;
}

void std::__function::__func<AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(GTMTLReplayController *,GTMTLSMObject const*,long,apr_pool_t *,std::map<unsigned long long,unsigned long long> &)::$_1,std::allocator<AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(GTMTLReplayController *,GTMTLSMObject const*,long,apr_pool_t *,std::map<unsigned long long,unsigned long long> &)::$_1>,void ()(unsigned long,unsigned long)>::~__func()
{
}

void std::__function::__func<AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(GTMTLReplayController *,GTMTLSMObject const*,long,apr_pool_t *,std::map<unsigned long long,unsigned long long> &)::$_0,std::allocator<AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(GTMTLReplayController *,GTMTLSMObject const*,long,apr_pool_t *,std::map<unsigned long long,unsigned long long> &)::$_0>,void ()(unsigned long long,GTMTLSMFunctionHandle const*,unsigned long)>::operator()(uint64_t a1, unint64_t *a2, uint64_t *a3, unint64_t *a4)
{
  uint64_t v4 = *a3;
  unint64_t v89 = *a4;
  Object = GTMTLSMContext_getObject(**(void **)(***(void ***)(a1 + 8) + 40), *(void *)(*a3 + 40), *a2);
  if (Object && *(_DWORD *)Object == 43 && v89 < *(unsigned int *)(*(void *)(**(void **)(a1 + 24) + 104) + 8))
  {
    uint64_t v86 = Object;
    AccelerationStructureViewer::IntersectionFunction::IntersectionFunction((AccelerationStructureViewer::IntersectionFunction *)&v95, (const AccelerationStructureViewer::IntersectionFunction *)(**(void **)(a1 + 32) + 152 * v89));
    char v103 = 0;
    uint64_t v100 = *(void *)(v4 + 40);
    __int16 v6 = [**(id **)(a1 + 16) functionForKey:];
    id v88 = v6;
    if (v6)
    {
      long long v7 = [v6 label];
      if (v7
        && ([v88 label],
            long long v8 = objc_claimAutoreleasedReturnValue(),
            unsigned __int8 v9 = [v8 isEqualToString:&stru_7482F0],
            v8,
            v7,
            (v9 & 1) == 0))
      {
        unint64_t v13 = [v88 label];
      }
      else
      {
        unint64_t v10 = [v88 name];
        if (v10
          && ([v88 name],
              uint64_t v11 = objc_claimAutoreleasedReturnValue(),
              unsigned __int8 v12 = [v11 isEqualToString:&stru_7482F0],
              v11,
              v10,
              (v12 & 1) == 0))
        {
          unint64_t v13 = [v88 name];
        }
        else
        {
          unint64_t v13 = +[NSString stringWithFormat:@"MTLFunction 0x%llx", v88];
        }
      }
      id v16 = v99;
      id v99 = v13;

      id v17 = v99;
      id v18 = v17;
      uint64_t v19 = v97;
      if (v97 >= v98)
      {
        uint64_t v21 = (v97 - v96) >> 4;
        unint64_t v22 = v21 + 1;
        uint64_t v15 = v86;
        if ((unint64_t)(v21 + 1) >> 60) {
          abort();
        }
        uint64_t v23 = v98 - v96;
        if ((v98 - v96) >> 3 > v22) {
          unint64_t v22 = v23 >> 3;
        }
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v24 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v24 = v22;
        }
        v111[4] = &v98;
        uint64_t v25 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(v24);
        unint64_t v27 = &v25[16 * v21];
        *(_WORD *)unint64_t v27 = 2;
        *((void *)v27 + 1) = v18;
        unint64_t v29 = v96;
        uint64_t v28 = v97;
        if (v97 == v96)
        {
          unsigned int v31 = &v25[16 * v21];
        }
        else
        {
          int v30 = v97;
          unsigned int v31 = &v25[16 * v21];
          do
          {
            __int16 v32 = *((_WORD *)v30 - 8);
            v30 -= 16;
            *((_WORD *)v31 - 8) = v32;
            v31 -= 16;
            uint64_t v33 = *((void *)v30 + 1);
            *((void *)v30 + 1) = 0;
            *((void *)v31 + 1) = v33;
          }
          while (v30 != v29);
        }
        unint64_t v20 = v27 + 16;
        unint64_t v96 = v31;
        uint64_t v97 = v27 + 16;
        long long v34 = v98;
        uint64_t v98 = &v25[16 * v26];
        v111[2] = v28;
        v111[3] = v34;
        v111[0] = v29;
        v111[1] = v29;
        std::__split_buffer<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::~__split_buffer((uint64_t)v111);
      }
      else
      {
        *(_WORD *)uint64_t v97 = 2;
        *((void *)v19 + 1) = v17;
        unint64_t v20 = v19 + 16;
        uint64_t v15 = v86;
      }
      uint64_t v97 = v20;
    }
    else
    {
      id v14 = v99;
      id v99 = 0;

      uint64_t v15 = v86;
    }
    uint64_t v101 = v15[5];
    uint64_t v102 = *(unsigned __int16 *)(v15[10] + 42);
    uint64_t v35 = v15[14];
    if (v35) {
      char v104 = *(unsigned char *)(v35 + 40) & 1;
    }
    id v85 = v88;
    unsigned int v87 = [v85 reflectionWithOptions:65539];
    id v36 = [v87 primitiveKind];
    if ((unint64_t)v36 < 3) {
      int v105 = (int)v36;
    }
    [v87 tags];
    long long v93 = 0u;
    long long v94 = 0u;
    long long v91 = 0u;
    long long v92 = 0u;
    id v37 = (id)objc_claimAutoreleasedReturnValue();
    id v38 = [v37 countByEnumeratingWithState:&v91 objects:v111 count:16];
    if (v38)
    {
      uint64_t v39 = *(void *)v92;
LABEL_34:
      uint64_t v40 = 0;
      while (2)
      {
        if (*(void *)v92 != v39) {
          objc_enumerationMutation(v37);
        }
        id v41 = *(id *)(*((void *)&v91 + 1) + 8 * v40);
        switch((unint64_t)[v41 tagType])
        {
          case 1uLL:
            uint64_t v42 = v107;
            if ((unint64_t)v107 < v108)
            {
              int v43 = 1;
              goto LABEL_52;
            }
            unint64_t v48 = (int *)__p;
            uint64_t v63 = ((char *)v107 - (unsigned char *)__p) >> 2;
            unint64_t v64 = v63 + 1;
            if ((unint64_t)(v63 + 1) >> 62) {
              abort();
            }
            uint64_t v65 = v108 - (void)__p;
            if ((uint64_t)(v108 - (void)__p) >> 1 > v64) {
              unint64_t v64 = v65 >> 1;
            }
            if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v52 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v52 = v64;
            }
            if (v52)
            {
              unint64_t v52 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v52);
              unint64_t v48 = (int *)__p;
              uint64_t v42 = v107;
            }
            else
            {
              uint64_t v53 = 0;
            }
            unint64_t v75 = (int *)(v52 + 4 * v63);
            *unint64_t v75 = 1;
            unint64_t v46 = v75 + 1;
            while (v42 != v48)
            {
              int v80 = *--v42;
              *--unint64_t v75 = v80;
            }
            goto LABEL_159;
          case 2uLL:
            uint64_t v42 = v107;
            if ((unint64_t)v107 < v108)
            {
              int v43 = 2;
              goto LABEL_52;
            }
            unint64_t v48 = (int *)__p;
            uint64_t v66 = ((char *)v107 - (unsigned char *)__p) >> 2;
            unint64_t v67 = v66 + 1;
            if ((unint64_t)(v66 + 1) >> 62) {
              abort();
            }
            uint64_t v68 = v108 - (void)__p;
            if ((uint64_t)(v108 - (void)__p) >> 1 > v67) {
              unint64_t v67 = v68 >> 1;
            }
            if ((unint64_t)v68 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v52 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v52 = v67;
            }
            if (v52)
            {
              unint64_t v52 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v52);
              unint64_t v48 = (int *)__p;
              uint64_t v42 = v107;
            }
            else
            {
              uint64_t v53 = 0;
            }
            unint64_t v75 = (int *)(v52 + 4 * v66);
            *unint64_t v75 = 2;
            unint64_t v46 = v75 + 1;
            while (v42 != v48)
            {
              int v81 = *--v42;
              *--unint64_t v75 = v81;
            }
            goto LABEL_159;
          case 3uLL:
            uint64_t v42 = v107;
            if ((unint64_t)v107 < v108)
            {
              int v43 = 3;
              goto LABEL_52;
            }
            unint64_t v48 = (int *)__p;
            uint64_t v54 = ((char *)v107 - (unsigned char *)__p) >> 2;
            unint64_t v55 = v54 + 1;
            if ((unint64_t)(v54 + 1) >> 62) {
              abort();
            }
            uint64_t v56 = v108 - (void)__p;
            if ((uint64_t)(v108 - (void)__p) >> 1 > v55) {
              unint64_t v55 = v56 >> 1;
            }
            if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v52 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v52 = v55;
            }
            if (v52)
            {
              unint64_t v52 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v52);
              unint64_t v48 = (int *)__p;
              uint64_t v42 = v107;
            }
            else
            {
              uint64_t v53 = 0;
            }
            unint64_t v75 = (int *)(v52 + 4 * v54);
            *unint64_t v75 = 3;
            unint64_t v46 = v75 + 1;
            while (v42 != v48)
            {
              int v77 = *--v42;
              *--unint64_t v75 = v77;
            }
            goto LABEL_159;
          case 4uLL:
            uint64_t v42 = v107;
            if ((unint64_t)v107 < v108)
            {
              int v43 = 5;
              goto LABEL_52;
            }
            unint64_t v48 = (int *)__p;
            uint64_t v57 = ((char *)v107 - (unsigned char *)__p) >> 2;
            unint64_t v58 = v57 + 1;
            if ((unint64_t)(v57 + 1) >> 62) {
              abort();
            }
            uint64_t v59 = v108 - (void)__p;
            if ((uint64_t)(v108 - (void)__p) >> 1 > v58) {
              unint64_t v58 = v59 >> 1;
            }
            if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v52 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v52 = v58;
            }
            if (v52)
            {
              unint64_t v52 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v52);
              unint64_t v48 = (int *)__p;
              uint64_t v42 = v107;
            }
            else
            {
              uint64_t v53 = 0;
            }
            unint64_t v75 = (int *)(v52 + 4 * v57);
            *unint64_t v75 = 5;
            unint64_t v46 = v75 + 1;
            while (v42 != v48)
            {
              int v78 = *--v42;
              *--unint64_t v75 = v78;
            }
            goto LABEL_159;
          case 5uLL:
            uint64_t v42 = v107;
            if ((unint64_t)v107 < v108)
            {
              int v43 = 4;
              goto LABEL_52;
            }
            unint64_t v48 = (int *)__p;
            uint64_t v49 = ((char *)v107 - (unsigned char *)__p) >> 2;
            unint64_t v50 = v49 + 1;
            if ((unint64_t)(v49 + 1) >> 62) {
              abort();
            }
            uint64_t v51 = v108 - (void)__p;
            if ((uint64_t)(v108 - (void)__p) >> 1 > v50) {
              unint64_t v50 = v51 >> 1;
            }
            if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v52 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v52 = v50;
            }
            if (v52)
            {
              unint64_t v52 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v52);
              unint64_t v48 = (int *)__p;
              uint64_t v42 = v107;
            }
            else
            {
              uint64_t v53 = 0;
            }
            unint64_t v75 = (int *)(v52 + 4 * v49);
            *unint64_t v75 = 4;
            unint64_t v46 = v75 + 1;
            while (v42 != v48)
            {
              int v76 = *--v42;
              *--unint64_t v75 = v76;
            }
            goto LABEL_159;
          case 6uLL:
            uint64_t v42 = v107;
            if ((unint64_t)v107 >= v108)
            {
              unint64_t v48 = (int *)__p;
              uint64_t v69 = ((char *)v107 - (unsigned char *)__p) >> 2;
              unint64_t v70 = v69 + 1;
              if ((unint64_t)(v69 + 1) >> 62) {
                abort();
              }
              uint64_t v71 = v108 - (void)__p;
              if ((uint64_t)(v108 - (void)__p) >> 1 > v70) {
                unint64_t v70 = v71 >> 1;
              }
              if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v52 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v52 = v70;
              }
              if (v52)
              {
                unint64_t v52 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v52);
                unint64_t v48 = (int *)__p;
                uint64_t v42 = v107;
              }
              else
              {
                uint64_t v53 = 0;
              }
              unint64_t v75 = (int *)(v52 + 4 * v69);
              *unint64_t v75 = 6;
              unint64_t v46 = v75 + 1;
              while (v42 != v48)
              {
                int v82 = *--v42;
                *--unint64_t v75 = v82;
              }
              goto LABEL_159;
            }
            int v43 = 6;
LABEL_52:
            int *v42 = v43;
            uint64_t v45 = v42 + 1;
            goto LABEL_53;
          case 7uLL:
            uint64_t v47 = v107;
            if ((unint64_t)v107 < v108)
            {
              *unint64_t v107 = 7;
              uint64_t v45 = v47 + 1;
              goto LABEL_53;
            }
            unint64_t v48 = (int *)__p;
            uint64_t v72 = ((char *)v107 - (unsigned char *)__p) >> 2;
            unint64_t v73 = v72 + 1;
            if ((unint64_t)(v72 + 1) >> 62) {
              abort();
            }
            uint64_t v74 = v108 - (void)__p;
            if ((uint64_t)(v108 - (void)__p) >> 1 > v73) {
              unint64_t v73 = v74 >> 1;
            }
            if ((unint64_t)v74 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v52 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v52 = v73;
            }
            if (v52)
            {
              unint64_t v52 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v52);
              unint64_t v48 = (int *)__p;
              uint64_t v47 = v107;
            }
            else
            {
              uint64_t v53 = 0;
            }
            unint64_t v75 = (int *)(v52 + 4 * v72);
            *unint64_t v75 = 7;
            unint64_t v46 = v75 + 1;
            while (v47 != v48)
            {
              int v83 = *--v47;
              *--unint64_t v75 = v83;
            }
            goto LABEL_159;
          case 8uLL:
            uint64_t v44 = v107;
            if ((unint64_t)v107 >= v108)
            {
              unint64_t v48 = (int *)__p;
              uint64_t v60 = ((char *)v107 - (unsigned char *)__p) >> 2;
              unint64_t v61 = v60 + 1;
              if ((unint64_t)(v60 + 1) >> 62) {
                abort();
              }
              uint64_t v62 = v108 - (void)__p;
              if ((uint64_t)(v108 - (void)__p) >> 1 > v61) {
                unint64_t v61 = v62 >> 1;
              }
              if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v52 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v52 = v61;
              }
              if (v52)
              {
                unint64_t v52 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v52);
                unint64_t v48 = (int *)__p;
                uint64_t v44 = v107;
              }
              else
              {
                uint64_t v53 = 0;
              }
              unint64_t v75 = (int *)(v52 + 4 * v60);
              *unint64_t v75 = 8;
              unint64_t v46 = v75 + 1;
              while (v44 != v48)
              {
                int v79 = *--v44;
                *--unint64_t v75 = v79;
              }
LABEL_159:
              __p = v75;
              unint64_t v107 = v46;
              unint64_t v108 = v52 + 4 * v53;
              if (v48) {
                operator delete(v48);
              }
            }
            else
            {
              *unint64_t v107 = 8;
              uint64_t v45 = v44 + 1;
LABEL_53:
              unint64_t v46 = v45;
            }
            unint64_t v107 = v46;
LABEL_162:

            if ((id)++v40 != v38) {
              continue;
            }
            id v38 = [v37 countByEnumeratingWithState:&v91 objects:v111 count:16];
            if (!v38) {
              goto LABEL_164;
            }
            goto LABEL_34;
          default:
            goto LABEL_162;
        }
      }
    }
LABEL_164:

    uint64_t v84 = v86[15];
    if (v84) {
      char v104 = *(unsigned char *)(v84 + 40) & 1;
    }
    AccelerationStructureViewer::IntersectionFunction::operator=(**(void **)(a1 + 32) + 152 * v89, (uint64_t)&v95);

    uint64_t v95 = off_744700;
    uint64_t v110 = (char **)&v109;
    std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100]((void ***)&v110);
    if (__p)
    {
      unint64_t v107 = (int *)__p;
      operator delete(__p);
    }

    uint64_t v110 = &v96;
    std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v110);
  }
}

void sub_1BEF68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41)
{
  *(void *)(v43 - 232) = &a41;
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100]((void ***)(v43 - 232));
  if (__p)
  {
    a36 = (uint64_t)__p;
    operator delete(__p);
  }

  *(void *)(v43 - 232) = &a26;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100]((void ***)(v43 - 232));
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(GTMTLReplayController *,GTMTLSMObject const*,long,apr_pool_t *,std::map<unsigned long long,unsigned long long> &)::$_0,std::allocator<AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(GTMTLReplayController *,GTMTLSMObject const*,long,apr_pool_t *,std::map<unsigned long long,unsigned long long> &)::$_0>,void ()(unsigned long long,GTMTLSMFunctionHandle const*,unsigned long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_7440D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(GTMTLReplayController *,GTMTLSMObject const*,long,apr_pool_t *,std::map<unsigned long long,unsigned long long> &)::$_0,std::allocator<AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(GTMTLReplayController *,GTMTLSMObject const*,long,apr_pool_t *,std::map<unsigned long long,unsigned long long> &)::$_0>,void ()(unsigned long long,GTMTLSMFunctionHandle const*,unsigned long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = off_7440D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void std::__function::__func<AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(GTMTLReplayController *,GTMTLSMObject const*,long,apr_pool_t *,std::map<unsigned long long,unsigned long long> &)::$_0,std::allocator<AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(GTMTLReplayController *,GTMTLSMObject const*,long,apr_pool_t *,std::map<unsigned long long,unsigned long long> &)::$_0>,void ()(unsigned long long,GTMTLSMFunctionHandle const*,unsigned long)>::~__func()
{
}

void ___ZN33AccelerationStructureViewerServer34MTLAccelerationStructureDataSource30encodeAccelerationStructureDAGE29MTLGenericBVHHeaderVersionSPIP14NSMutableArrayIPU35objcproto24MTLAccelerationStructure11objc_objectEPU26objcproto15MTLCommandQueue11objc_objectP26MTLCommandBufferDescriptorPU15__autoreleasingP7NSError_block_invoke(uint64_t a1)
{
  NSLog(@"Running encode completion handler for %zu", *(void *)(a1 + 40));
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = *(void *)(v2 + 32);
  uint64_t v4 = (char *)[*(id *)(v2 + 24) contents] + v3;
  switch(v4[2])
  {
    case 0:
      uint64_t v5 = *(void *)(a1 + 48);
      int v6 = 1;
      goto LABEL_6;
    case 1:
      uint64_t v7 = *(void *)(a1 + 48);
      *(_DWORD *)(v7 + 8) = 2;
      if (!*(void *)(v7 + 152)) {
        return;
      }
      uint64_t v8 = v4[8];
      break;
    case 2:
      uint64_t v5 = *(void *)(a1 + 48);
      int v6 = 3;
LABEL_6:
      *(_DWORD *)(v5 + 8) = v6;
      return;
    case 3:
      uint64_t v9 = *(void *)(a1 + 48);
      *(_DWORD *)(v9 + 8) = 4;
      if (!*(void *)(v9 + 152)) {
        return;
      }
      uint64_t v10 = *(void *)(v9 + 64);
      uint64_t v11 = (char *)[*(id *)(v9 + 56) contents];
      uint64_t v12 = v4[5];
      if (v12)
      {
        uint64_t v8 = 0;
        unint64_t v13 = &v11[v10 + 88];
        do
        {
          unsigned int v14 = *(_DWORD *)v13;
          v13 += 104;
          v8 += v14;
          --v12;
        }
        while (v12);
      }
      else
      {
        uint64_t v8 = 0;
      }
      break;
    default:
      return;
  }
  id v15 = [*(id *)(a1 + 32) newBufferWithLength:v8 << 7 options:0];
  int v16 = v4[22];
  id v17 = v15;
  id v18 = v17;
  if (v16 == 1)
  {
    uint64_t v19 = (char *)[v17 contents];
    uint64_t v20 = *(void *)(a1 + 48);
    uint64_t v21 = *(void *)(v20 + 160);
    unint64_t v22 = (char *)[*(id *)(v20 + 152) contents];
    if (v8)
    {
      uint64_t v24 = 0;
      uint64_t v25 = &v22[v21];
      float32x4_t v26 = (float32x4_t)xmmword_4C7F60;
      do
      {
        uint64_t v27 = 0;
        uint64_t v28 = &v25[64 * v24];
        float v29 = *((float *)v28 + 9);
        float v30 = *((float *)v28 + 10);
        float v31 = *((float *)v28 + 11);
        float v32 = *((float *)v28 + 12);
        float v33 = v30 * v32;
        v34.i32[3] = 0;
        v34.f32[0] = (float)((float)((float)(v31 * v31) + (float)(v30 * v30)) * -2.0) + 1.0;
        v34.f32[1] = (float)((float)(v31 * v32) + (float)(v29 * v30)) + (float)((float)(v31 * v32) + (float)(v29 * v30));
        v34.f32[2] = (float)-(float)((float)(v30 * v32) - (float)(v29 * v31))
                   - (float)((float)(v30 * v32) - (float)(v29 * v31));
        v37.i32[3] = 0;
        v37.f32[0] = (float)-(float)((float)(v31 * v32) - (float)(v29 * v30))
                   - (float)((float)(v31 * v32) - (float)(v29 * v30));
        LODWORD(v23) = *((_DWORD *)v28 + 3);
        DWORD1(v23) = *((_DWORD *)v28 + 1);
        *(void *)&long long v35 = *((void *)v28 + 2);
        float v36 = v29 * v32;
        v37.f32[1] = (float)((float)((float)(v31 * v31) + (float)(v29 * v29)) * -2.0) + 1.0;
        v37.f32[2] = (float)(v36 + (float)(v30 * v31)) + (float)(v36 + (float)(v30 * v31));
        *(float *)&unsigned int v38 = (float)(v33 + (float)(v29 * v31)) + (float)(v33 + (float)(v29 * v31));
        *(float *)&unsigned int v39 = (float)-(float)(v36 - (float)(v30 * v31)) - (float)(v36 - (float)(v30 * v31));
        *(float *)&unsigned int v40 = (float)((float)((float)(v30 * v30) + (float)(v29 * v29)) * -2.0) + 1.0;
        v41.i64[0] = __PAIR64__(v39, v38);
        v41.i64[1] = v40;
        *((void *)&v35 + 1) = *((unsigned int *)v28 + 2);
        *(void *)&long long v42 = *(void *)(v28 + 52);
        DWORD2(v42) = *((_DWORD *)v28 + 15);
        HIDWORD(v42) = 1.0;
        v78[0] = *(unsigned int *)v28;
        v78[1] = v23;
        v78[2] = v35;
        v78[3] = v42;
        do
        {
          v79.columns[v27] = (simd_float3)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v34, COERCE_FLOAT(v78[v27])), v37, *(float32x2_t *)&v78[v27], 1), v41, (float32x4_t)v78[v27], 2), v26, (float32x4_t)v78[v27], 3);
          ++v27;
        }
        while (v27 != 4);
        double v43 = invertSRTMatrix(&v79);
        float32x4_t v26 = (float32x4_t)xmmword_4C7F60;
        uint64_t v44 = (simd_float3 *)&v19[128 * v24];
        v44->i32[2] = v45;
        *(double *)v44->i64 = v43;
        v44[1].i32[2] = v46;
        v44[1].i64[0] = v47;
        v44[2].i32[2] = v48;
        v44[3].i32[2] = v49;
        v44[2].i64[0] = v50;
        v44[3].i64[0] = v51;
        simd_float3 v52 = v79.columns[1];
        v44[4] = v79.columns[0];
        v44[5] = v52;
        simd_float3 v53 = v79.columns[3];
        ++v24;
        v44[6] = v79.columns[2];
        v44[7] = v53;
      }
      while (v24 != v8);
    }
  }
  else
  {
    uint64_t v54 = (simd_float3 *)[v17 contents];
    uint64_t v55 = *(void *)(a1 + 48);
    uint64_t v56 = *(void *)(v55 + 160);
    uint64_t v57 = (char *)[*(id *)(v55 + 152) contents];
    if (v8)
    {
      unint64_t v58 = v54 + 2;
      uint64_t v59 = (simd_float3 *)&v57[v56 + 32];
      do
      {
        simd_float3 v60 = v59[-2];
        simd_float3 v61 = v59[-1];
        simd_float3 v62 = *v59;
        simd_float3 v63 = v59[1];
        v59 += 4;
        v79.columns[0] = v60;
        v79.columns[1] = v61;
        v79.columns[2] = v62;
        v79.columns[3] = v63;
        double v64 = invertSRTMatrix(&v79);
        v58[-2].i32[2] = v65;
        *(double *)v58[-2].i64 = v64;
        v58[-1].i32[2] = v66;
        v58[-1].i64[0] = v67;
        v58->i32[2] = v68;
        v58->i64[0] = v69;
        unint64_t v70 = &v58[1].i32[2];
        v58[1].i64[0] = v71;
        simd_float3 v72 = v79.columns[1];
        v58[2] = v79.columns[0];
        v58[3] = v72;
        simd_float3 v73 = v79.columns[3];
        v58[4] = v79.columns[2];
        v58[5] = v73;
        v58 += 8;
        *unint64_t v70 = v74;
        --v8;
      }
      while (v8);
    }
  }
  uint64_t v75 = *(void *)(a1 + 48);
  int v76 = *(void **)(v75 + 152);
  *(void *)(v75 + 152) = v18;
  id v77 = v18;

  *(void *)(*(void *)(a1 + 48) + 160) = 0;
}

void sub_1BF580(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double invertSRTMatrix(const simd::float4x3 *a1)
{
  float32x4_t v1 = (float32x4_t)a1->columns[1];
  float32x4_t v2 = vmulq_f32((float32x4_t)a1->columns[0], (float32x4_t)a1->columns[0]);
  float32x4_t v3 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1)));
  v3.f32[0] = sqrtf(v3.f32[0]);
  float32x4_t v4 = vmulq_f32(v1, v1);
  v4.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).u64[0];
  v4.f32[0] = sqrtf(v4.f32[0]);
  float32x4_t v5 = (float32x4_t)a1->columns[2];
  float32x4_t v6 = vmulq_f32(v5, v5);
  v6.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).u64[0];
  float32x4_t v7 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 0);
  v6.f32[0] = sqrtf(v6.f32[0]);
  v3.i32[1] = v4.i32[0];
  v3.i32[2] = v6.i32[0];
  int32x4_t v8 = (int32x4_t)vdivq_f32(v1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 0));
  int32x4_t v9 = (int32x4_t)vdivq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 0));
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vmulq_f32(vdivq_f32(_Q4, v3), (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)vdivq_f32((float32x4_t)a1->columns[0], v7), v9), v8)).u64[0];
  return result;
}

uint64_t AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::reserveAccelerationStructureDAG(AccelerationStructureViewerServer::MTLAccelerationStructureDataSource *a1, uint64_t **a2, uint64_t **a3, void *a4, unint64_t a5, void *a6)
{
  id v39 = a4;
  uint64_t v10 = a2 + 1;
  int32x4_t v9 = a2[1];
  if (v9)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v11 = (uint64_t **)v9;
        unint64_t v12 = v9[4];
        if (v12 <= a5) {
          break;
        }
        int32x4_t v9 = *v11;
        uint64_t v10 = v11;
        if (!*v11) {
          goto LABEL_9;
        }
      }
      if (v12 >= a5) {
        break;
      }
      int32x4_t v9 = v11[1];
      if (!v9)
      {
        uint64_t v10 = v11 + 1;
        goto LABEL_9;
      }
    }
    uint64_t v22 = 0;
  }
  else
  {
    uint64_t v11 = a2 + 1;
LABEL_9:
    unint64_t v13 = (uint64_t *)operator new(0x28uLL);
    void v13[4] = a5;
    *unint64_t v13 = 0;
    v13[1] = 0;
    v13[2] = (uint64_t)v11;
    void *v10 = v13;
    unsigned int v14 = (uint64_t *)**a2;
    if (v14)
    {
      *a2 = v14;
      unint64_t v13 = *v10;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a2[1], v13);
    a2[2] = (uint64_t *)((char *)a2[2] + 1);
    newpool = 0;
    apr_pool_create_ex(&newpool, 0, 0, v15);
    int v16 = newpool;
    id v17 = AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::getAllAccelerationStructureChildren(a1, a5, newpool);
    apr_pool_destroy(v16);
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    id v18 = v17;
    id v19 = [v18 countByEnumeratingWithState:&v40 objects:v45 count:16];
    if (v19)
    {
      float v36 = a2;
      uint64_t v20 = *(void *)v41;
      uint64_t v21 = (__n128 *)(a3 + 1);
      uint64_t v22 = 1;
      while (2)
      {
        for (uint64_t i = 0; i != v19; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v41 != v20) {
            objc_enumerationMutation(v18);
          }
          uint64_t v24 = *(void **)(*((void *)&v40 + 1) + 8 * i);
          uint64_t v25 = [v18 objectForKey:v24, v36];
          id v26 = [v25 uniqueIdentifier];
          uint64_t v27 = (__n128 *)v21->n128_u64[0];
          if (!v21->n128_u64[0]) {
            goto LABEL_40;
          }
          uint64_t v28 = (__n128 *)(a3 + 1);
          do
          {
            unint64_t v29 = v27[2].n128_u64[0];
            BOOL v30 = v29 >= (unint64_t)v26;
            if (v29 >= (unint64_t)v26) {
              float v31 = (__n128 **)v27;
            }
            else {
              float v31 = (__n128 **)&v27->n128_u64[1];
            }
            if (v30) {
              uint64_t v28 = v27;
            }
            uint64_t v27 = *v31;
          }
          while (*v31);
          if (v28 == v21 || (unint64_t)v26 < v28[2].n128_u64[0])
          {
LABEL_40:
            id v32 = [v24 unsignedIntegerValue];
            v33.n128_u64[0] = (unint64_t)v26;
            v33.n128_u64[1] = (unint64_t)v32;
            uint64_t v28 = std::__tree<std::__value_type<unsigned long long,unsigned long long>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned long long>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long,unsigned long long>>(a3, (unint64_t)v26, v33);
            if (v21 == v28)
            {
              *a6 = +[ASVError errorWithCode:8 localizedDescription:@"Unable to find child acceleration structure(s). Did you forgot to useResource or useHeap?"];
LABEL_34:

              uint64_t v22 = -1;
              goto LABEL_35;
            }
          }
          uint64_t v34 = AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::reserveAccelerationStructureDAG(a1, v36, a3, v39, v28[2].n128_u64[1], a6);
          if (v34 == -1) {
            goto LABEL_34;
          }

          v22 += v34;
        }
        id v19 = [v18 countByEnumeratingWithState:&v40 objects:v45 count:16];
        if (v19) {
          continue;
        }
        break;
      }
    }
    else
    {
      uint64_t v22 = 1;
    }
LABEL_35:
  }
  return v22;
}

void sub_1BF934(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

uint64_t AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::allocateAccelerationStructureDAG(uint64_t a1, uint64_t a2, uint64_t **a3, uint64_t **a4, void *a5, uint64_t a6, uint64_t a7, void *a8, unint64_t a9, void *a10, void *a11, void *a12)
{
  id v100 = a5;
  id v102 = a8;
  id v97 = a10;
  id v99 = a11;
  int v16 = a3 + 1;
  id v15 = a3[1];
  if (!v15) {
    goto LABEL_12;
  }
  id v17 = a3 + 1;
  do
  {
    unint64_t v18 = v15[4];
    BOOL v19 = v18 >= a9;
    if (v18 >= a9) {
      uint64_t v20 = (uint64_t **)v15;
    }
    else {
      uint64_t v20 = (uint64_t **)(v15 + 1);
    }
    if (v19) {
      id v17 = (uint64_t **)v15;
    }
    id v15 = *v20;
  }
  while (*v20);
  if (v17 != v16 && (unint64_t)v17[4] <= a9)
  {
    uint64_t v90 = (uint64_t)v17[5];
  }
  else
  {
LABEL_12:
    Object = GTMTLSMContext_getObject(**(void **)(**(void **)(a6 + 8) + 40), a9, *(void *)(*(void *)(*(void *)(**(void **)(a6 + 8) + 120) + 24) + (a7 << 6)));
    uint64_t v103 = a1;
    if (Object)
    {
      uint64_t v22 = Object[14];
      if (v22)
      {
        if (*(unsigned char *)v22 == 1)
        {
          uint64_t v23 = *(void *)(v22 + 8);
          uint64_t v24 = *(void *)(v22 + 16);
          id v98 = objc_alloc_init((Class)NSMutableArray);
          if (!v24) {
            goto LABEL_32;
          }
          uint64_t v25 = a3;
          uint64_t v26 = 0;
          while (1)
          {
            int v27 = *(unsigned __int8 *)(v23 + 36);
            if (!*(void *)v23) {
              goto LABEL_20;
            }
            uint64_t v28 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
            if ([v28 isEqualToString:&stru_7482F0]) {
              break;
            }
            [v98 addObject:v28];
LABEL_29:
            v23 += 136;

            ++v26;
            a1 = v103;
            if (v24 == v26)
            {
              a3 = v25;
              goto LABEL_32;
            }
          }

LABEL_20:
          if (v27 == 5)
          {
            uint64_t v28 = +[NSString stringWithFormat:@"Curve Geometry %zu", v26];
            [v98 addObject:v28];
          }
          else if (v27 == 2)
          {
            uint64_t v28 = +[NSString stringWithFormat:@"BoundingBox Geometry %zu", v26];
            [v98 addObject:v28];
          }
          else
          {
            if (v27 == 1) {
              +[NSString stringWithFormat:@"Triangle Geometry %zu", v26];
            }
            else {
            uint64_t v28 = +[NSString stringWithFormat:@"Geometry %zu", v26];
            }
            [v98 addObject:v28];
          }
          goto LABEL_29;
        }
      }
    }
    id v98 = &__NSArray0__struct;
LABEL_32:
    long long v91 = [v102 accelerationStructureForKey:a9];
    id v88 = [v91 device];
    id v89 = [v100 count];
    uint64_t v29 = *(void *)(a1 + 184);
    id v30 = [v91 uniqueIdentifier];
    uint64_t v31 = v29 + 184 * (void)v89;
    *(_DWORD *)(v31 + 8) = 0;
    id v32 = *(void **)(v31 + 24);
    uint64_t v90 = v31;
    *(void *)(v31 + 16) = v30;
    *(void *)(v31 + 24) = 0;

    __n128 v33 = *(void **)(v31 + 40);
    *(void *)(v31 + 32) = 0;
    *(void *)(v31 + 40) = 0;

    uint64_t v34 = *(void **)(v31 + 56);
    *(void *)(v31 + 48) = 0;
    *(void *)(v31 + 56) = 0;

    long long v35 = *(void **)(v31 + 72);
    *(void *)(v31 + 64) = 0;
    *(void *)(v31 + 72) = 0;

    float v36 = *(void **)(v31 + 88);
    *(void *)(v31 + 80) = 0;
    *(void *)(v31 + 88) = 0;

    float32x4_t v37 = *(void **)(v31 + 104);
    *(void *)(v31 + 96) = 0;
    *(void *)(v31 + 104) = 0;

    *(void *)(v31 + 112) = 0;
    *(void *)(v31 + 120) = 0;
    unsigned int v38 = *(void **)(v31 + 152);
    *(void *)(v31 + 152) = 0;

    id v39 = *(void **)(v31 + 168);
    *(void *)(v31 + 160) = 0;
    *(void *)(v31 + 168) = 0;

    long long v40 = *v16;
    long long v41 = v16;
    if (*v16)
    {
      while (1)
      {
        while (1)
        {
          long long v41 = (uint64_t **)v40;
          unint64_t v42 = v40[4];
          if (v42 <= a9) {
            break;
          }
          long long v40 = *v41;
          int v16 = v41;
          if (!*v41) {
            goto LABEL_39;
          }
        }
        if (v42 >= a9) {
          break;
        }
        long long v40 = v41[1];
        if (!v40)
        {
          int v16 = v41 + 1;
          goto LABEL_39;
        }
      }
    }
    else
    {
LABEL_39:
      long long v43 = (uint64_t *)operator new(0x30uLL);
      v43[4] = a9;
      v43[5] = v90;
      *long long v43 = 0;
      v43[1] = 0;
      v43[2] = (uint64_t)v41;
      *int v16 = v43;
      uint64_t v44 = (uint64_t *)**a3;
      if (v44)
      {
        *a3 = v44;
        long long v43 = *v16;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a3[1], v43);
      a3[2] = (uint64_t *)((char *)a3[2] + 1);
    }
    [v100 addObject:v91];
    [*(id *)(a1 + 304) addObject:v98];
    memset(v114, 0, sizeof(v114));
    int v115 = 1065353216;
    newpool = 0;
    apr_pool_create_ex(&newpool, 0, 0, v45);
    __int32 v46 = (AccelerationStructureViewerServer::MTLAccelerationStructureDataSource *)a1;
    uint64_t v47 = newpool;
    __int32 v48 = AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::getAllAccelerationStructureChildren(v46, a9, newpool);
    long long v92 = a3;
    apr_pool_destroy(v47);
    long long v111 = 0u;
    long long v112 = 0u;
    long long v109 = 0u;
    long long v110 = 0u;
    id v49 = v48;
    id v50 = [v49 countByEnumeratingWithState:&v109 objects:v116 count:16];
    uint64_t v51 = v103;
    if (v50)
    {
      simd_float3 v52 = (__n128 *)(a4 + 1);
      uint64_t v53 = v29 + 184 * (void)v89;
      uint64_t v54 = (uint64_t **)(v53 + 128);
      uint64_t v55 = *(void *)v110;
      uint64_t v56 = (uint64_t **)(v53 + 136);
      unint64_t v96 = (void *)(v53 + 144);
LABEL_44:
      uint64_t v57 = 0;
      while (1)
      {
        if (*(void *)v110 != v55) {
          objc_enumerationMutation(v49);
        }
        unint64_t v58 = *(void **)(*((void *)&v109 + 1) + 8 * v57);
        uint64_t v59 = [v49 objectForKey:v58];
        id v60 = [v59 uniqueIdentifier];
        simd_float3 v61 = (__n128 *)v52->n128_u64[0];
        if (!v52->n128_u64[0]) {
          goto LABEL_100;
        }
        simd_float3 v62 = (__n128 *)(a4 + 1);
        do
        {
          unint64_t v63 = v61[2].n128_u64[0];
          BOOL v64 = v63 >= (unint64_t)v60;
          if (v63 >= (unint64_t)v60) {
            __int32 v65 = (__n128 **)v61;
          }
          else {
            __int32 v65 = (__n128 **)&v61->n128_u64[1];
          }
          if (v64) {
            simd_float3 v62 = v61;
          }
          simd_float3 v61 = *v65;
        }
        while (*v65);
        if (v62 == v52 || (unint64_t)v60 < v62[2].n128_u64[0])
        {
LABEL_100:
          id v66 = [v58 unsignedIntegerValue];
          v67.n128_u64[0] = (unint64_t)v60;
          v67.n128_u64[1] = (unint64_t)v66;
          simd_float3 v62 = std::__tree<std::__value_type<unsigned long long,unsigned long long>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned long long>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long,unsigned long long>>(a4, (unint64_t)v60, v67);
          if (v52 == v62) {
            break;
          }
        }
        unint64_t v68 = v62[2].n128_u64[1];
        uint64_t v69 = [v102 accelerationStructureForKey:v68];
        unint64_t v70 = (void *)v69;
        if (v69) {
          BOOL v71 = v69 == (void)v59;
        }
        else {
          BOOL v71 = 0;
        }
        if (!v71)
        {
          *a12 = +[ASVError errorWithCode:8 localizedDescription:@"Child acceleration structure mismatch. Did you forgot to useResource?"];
          goto LABEL_93;
        }
        uint64_t v51 = v103;
        if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)v114, v68, v68))
        {
          uint64_t AccelerationStructureDAG = AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::allocateAccelerationStructureDAG(v103, a2, v92, a4, v100, a6, a7, v102, v68, v97, v99, a12);
          uint64_t v73 = AccelerationStructureDAG;
          if (!AccelerationStructureDAG)
          {
            unint64_t v70 = v59;
LABEL_93:

LABEL_94:
            uint64_t v90 = 0;
            id v85 = v49;
            goto LABEL_95;
          }
          __int32 v74 = *v56;
          if ((unint64_t)*v56 >= *v96)
          {
            uint64_t v76 = v74 - *v54;
            if ((unint64_t)(v76 + 1) >> 61) {
              abort();
            }
            uint64_t v77 = *v96 - (void)*v54;
            uint64_t v78 = v77 >> 2;
            if (v77 >> 2 <= (unint64_t)(v76 + 1)) {
              uint64_t v78 = v76 + 1;
            }
            if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v79 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v79 = v78;
            }
            if (v79) {
              unint64_t v79 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v79);
            }
            else {
              uint64_t v80 = 0;
            }
            int v81 = (uint64_t *)(v79 + 8 * v76);
            *int v81 = v73;
            uint64_t v75 = v81 + 1;
            int v82 = *v56;
            int v83 = *v54;
            if (*v56 == *v54)
            {
              uint64_t v51 = v103;
            }
            else
            {
              uint64_t v51 = v103;
              do
              {
                uint64_t v84 = *--v82;
                *--int v81 = v84;
              }
              while (v82 != v83);
              int v82 = *v54;
            }
            simd_float3 *v54 = v81;
            uint64_t *v56 = v75;
            *unint64_t v96 = v79 + 8 * v80;
            if (v82) {
              operator delete(v82);
            }
          }
          else
          {
            uint64_t *v74 = AccelerationStructureDAG;
            uint64_t v75 = v74 + 1;
            uint64_t v51 = v103;
          }
          uint64_t *v56 = v75;
        }

        if ((id)++v57 == v50)
        {
          id v50 = [v49 countByEnumeratingWithState:&v109 objects:v116 count:16];
          if (v50) {
            goto LABEL_44;
          }
          goto LABEL_87;
        }
      }
      *a12 = +[ASVError errorWithCode:8 localizedDescription:@"Unable to find child acceleration structure(s). Did you forgot to useResource or useHeap?"];
      goto LABEL_94;
    }
LABEL_87:

    id v85 = [objc_alloc((Class)MTLGenericBVHBufferSizesSPI) initWithVersion:a2];
    if ([v99 writeGenericBVHStructureSizesOfAccelerationStructure:v91 into:v85])
    {
      v104[0] = _NSConcreteStackBlock;
      v104[1] = 3221225472;
      v104[2] = ___ZN33AccelerationStructureViewerServer34MTLAccelerationStructureDataSource32allocateAccelerationStructureDAGE29MTLGenericBVHHeaderVersionSPIRNSt3__13mapIyPNS_21AccelerationStructureENS2_4lessIyEENS2_9allocatorINS2_4pairIKyS5_EEEEEERNS3_IyyS7_NS8_INS9_ISA_yEEEEEEP14NSMutableArrayIPU35objcproto24MTLAccelerationStructure11objc_objectEP17GTMTLReplayClientyP20GTMTLReplayObjectMapyPU27objcproto16MTLCommandBuffer11objc_objectPU52objcproto41MTLAccelerationStructureCommandEncoderSPI11objc_objectPU15__autoreleasingP7NSError_block_invoke;
      v104[3] = &unk_743FD0;
      uint64_t v107 = v51;
      id v108 = v89;
      id v105 = v88;
      id v86 = v85;
      id v106 = v86;
      [v97 addCompletedHandler:v104];

      id v85 = v86;
    }
    else
    {
      +[ASVError errorWithCode:2 localizedDescription:@"Your version of Metal does not support this tool"];
      uint64_t v90 = 0;
      *a12 = (id)objc_claimAutoreleasedReturnValue();
    }
LABEL_95:

    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v114);
  }

  return v90;
}

void sub_1C01D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,void *a25,void *a26,void *a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a49);
  _Unwind_Resume(a1);
}

void sub_1C01F0()
{
}

void sub_1C0200()
{
  JUMPOUT(0x1C0354);
}

void sub_1C0208(_Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  if (a2)
  {
    if (a2 == 2)
    {
      id v20 = objc_begin_catch(exc_buf);
      NSLog(@"An exception occured while generating the generic acceleration structure: %@");
      *a20 = +[ASVError errorWithCode:2 localizedDescription:@"Your graphics driver does not support this tool"];

      objc_end_catch();
      JUMPOUT(0x1C0144);
    }
    objc_begin_catch(exc_buf);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exc_buf);
}

void sub_1C0294()
{
}

void sub_1C02A0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1C02B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25)
{
  JUMPOUT(0x1C0318);
}

void sub_1C032C()
{
}

void sub_1C0344()
{
}

void sub_1C0350()
{
  JUMPOUT(0x1C035CLL);
}

uint64_t std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    int32x4_t v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = (void *)*v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return 0;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  unint64_t v12 = operator new(0x18uLL);
  void *v12 = 0;
  v12[1] = a2;
  v12[2] = a3;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }
  uint64_t v19 = *(void *)a1;
  id v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    void *v12 = *v20;
LABEL_38:
    void *v20 = v12;
    goto LABEL_39;
  }
  void *v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v19 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    unint64_t v21 = *(void *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }
    else
    {
      v21 &= v7 - 1;
    }
    id v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return 1;
}

void sub_1C05B0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void ___ZN33AccelerationStructureViewerServer34MTLAccelerationStructureDataSource32allocateAccelerationStructureDAGE29MTLGenericBVHHeaderVersionSPIRNSt3__13mapIyPNS_21AccelerationStructureENS2_4lessIyEENS2_9allocatorINS2_4pairIKyS5_EEEEEERNS3_IyyS7_NS8_INS9_ISA_yEEEEEEP14NSMutableArrayIPU35objcproto24MTLAccelerationStructure11objc_objectEP17GTMTLReplayClientyP20GTMTLReplayObjectMapyPU27objcproto16MTLCommandBuffer11objc_objectPU52objcproto41MTLAccelerationStructureCommandEncoderSPI11objc_objectPU15__autoreleasingP7NSError_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  NSLog(@"Running allocate completion handler for %zu", *(void *)(a1 + 56));
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v4 = *(void *)(v2 + 184);
  float32x4_t v5 = *(void **)(a1 + 32);
  id v6 = [*(id *)(a1 + 40) headerBufferSize];
  if ((unint64_t)v6 <= 1) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = (uint64_t)v6;
  }
  id v8 = [v5 newBufferWithLength:v7 options:0];
  int32x4_t v9 = (void *)(v4 + 184 * v3);
  uint64_t v10 = (void *)v9[3];
  v9[3] = v8;

  unint64_t v11 = *(void **)(a1 + 32);
  id v12 = [*(id *)(a1 + 40) innerNodeBufferSize];
  if ((unint64_t)v12 <= 1) {
    uint64_t v13 = 1;
  }
  else {
    uint64_t v13 = (uint64_t)v12;
  }
  id v14 = [v11 newBufferWithLength:v13 options:0];
  BOOL v15 = (void *)v9[5];
  v9[5] = v14;

  unint64_t v16 = *(void **)(a1 + 32);
  id v17 = [*(id *)(a1 + 40) leafNodeBufferSize];
  if ((unint64_t)v17 <= 1) {
    uint64_t v18 = 1;
  }
  else {
    uint64_t v18 = (uint64_t)v17;
  }
  id v19 = [v16 newBufferWithLength:v18 options:0];
  id v20 = (void *)v9[7];
  v9[7] = v19;

  unint64_t v21 = *(void **)(a1 + 32);
  id v22 = [*(id *)(a1 + 40) primitiveBufferSize];
  if ((unint64_t)v22 <= 1) {
    uint64_t v23 = 1;
  }
  else {
    uint64_t v23 = (uint64_t)v22;
  }
  id v24 = [v21 newBufferWithLength:v23 options:0];
  uint64_t v25 = (void *)v9[9];
  v9[9] = v24;

  uint64_t v26 = *(void **)(a1 + 32);
  id v27 = [*(id *)(a1 + 40) geometryBufferSize];
  if ((unint64_t)v27 <= 1) {
    uint64_t v28 = 1;
  }
  else {
    uint64_t v28 = (uint64_t)v27;
  }
  id v29 = [v26 newBufferWithLength:v28 options:0];
  id v30 = (void *)v9[11];
  v9[11] = v29;

  uint64_t v31 = *(void **)(a1 + 32);
  id v32 = [*(id *)(a1 + 40) perPrimitiveDataBufferSize];
  if ((unint64_t)v32 <= 1) {
    uint64_t v33 = 1;
  }
  else {
    uint64_t v33 = (uint64_t)v32;
  }
  id v34 = [v31 newBufferWithLength:v33 options:0];
  long long v35 = (void *)v9[13];
  v9[13] = v34;

  v9[15] = [*(id *)(a1 + 40) perPrimitiveDataBufferSize];
  float v36 = *(void **)(a1 + 32);
  id v37 = [*(id *)(a1 + 40) instanceTransformBufferSize];
  if ((unint64_t)(2 * (void)v37) <= 1) {
    uint64_t v38 = 1;
  }
  else {
    uint64_t v38 = 2 * (void)v37;
  }
  id v39 = [v36 newBufferWithLength:v38 options:0];
  long long v40 = (void *)v9[19];
  v9[19] = v39;
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }
    else
    {
      uint64_t v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }
    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      unint64_t v16 = *(void **)a1;
      *(void *)a1 = 0;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  float32x4_t v5 = operator new(8 * prime);
  id v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  id v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }
    else
    {
      v9 &= prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    id v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          *id v8 = *v14;
          void *v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          id v14 = v8;
        }
        size_t v15 = v9;
LABEL_31:
        id v8 = v14;
        id v14 = (void *)*v14;
        size_t v9 = v15;
      }
      while (v14);
    }
  }
}

uint64_t AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::MTLAccelerationStructureDataSource()
{
  uint64_t v0 = __chkstk_darwin();
  uint64_t v2 = v1;
  unint64_t v4 = v3;
  unint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v9 = v0;
  id v11 = v10;
  *(void *)(v9 + 16) = 0;
  *(void *)(v9 + 8) = v9 + 16;
  *(void *)(v9 + 48) = 0;
  *(void *)(v9 + 40) = 0;
  *(void *)(v9 + 24) = 0;
  *(void *)(v9 + 32) = v9 + 40;
  *(_OWORD *)(v9 + 56) = 0u;
  *(_OWORD *)(v9 + 72) = 0u;
  *(_DWORD *)(v9 + 88) = 1065353216;
  *(_OWORD *)(v9 + 96) = 0u;
  *(_OWORD *)(v9 + 112) = 0u;
  *(_DWORD *)(v9 + 128) = 1065353216;
  *(_OWORD *)(v9 + 136) = 0u;
  *(_OWORD *)(v9 + 152) = 0u;
  *(_DWORD *)(v9 + 168) = 1065353216;
  *(void *)(v9 + 184) = 0;
  *(void *)(v9 + 192) = 0;
  *(void *)(v9 + 200) = 0;
  *(void *)uint64_t v9 = off_744000;
  *(_OWORD *)(v9 + 216) = 0u;
  uint8x8_t v12 = (void **)(v9 + 216);
  *(_OWORD *)(v9 + 248) = 0u;
  *(_OWORD *)(v9 + 232) = 0u;
  *(void *)(v9 + 264) = v9 + 272;
  *(void *)(v9 + 272) = 0;
  *(void *)(v9 + 336) = 0;
  *(_OWORD *)(v9 + 304) = 0u;
  *(_OWORD *)(v9 + 320) = 0u;
  *(_DWORD *)(v9 + 344) = 1065353216;
  uint64_t v279 = (uint64_t *)(v9 + 312);
  unint64_t v280 = (char **)(v9 + 352);
  *(_OWORD *)(v9 + 352) = 0u;
  *(_OWORD *)(v9 + 368) = 0u;
  *(void *)(v9 + 208) = v8;
  *(void *)(v9 + 280) = 0;
  *(void *)(v9 + 288) = v6;
  unint64_t v275 = v4;
  *(void *)(v9 + 296) = v4;
  uint64_t v277 = v8;
  id v13 = *(id *)(*(void *)(v8 + 8) + 8);
  id v14 = +[NSBundle bundleForClass:objc_opt_class()];
  size_t v15 = [v13 defaultDevice];
  id v16 = [v15 newDefaultLibraryWithBundle:v14 error:v2];

  id v17 = [v16 newFunctionWithName:@"ASVAccelerationStructureInstanceCount"];
  if (v17)
  {
    uint64_t v18 = [v13 defaultDevice];
    id v19 = [v18 newComputePipelineStateWithFunction:v17 error:v2];
    id v20 = *v12;
    void *v12 = v19;

    if (!*v12) {
      goto LABEL_8;
    }
  }

  id v17 = [v16 newFunctionWithName:@"ASVMarkAccelerationStructureChildren"];
  if (v17)
  {
    unint64_t v21 = [v13 defaultDevice];
    id v22 = [v21 newComputePipelineStateWithFunction:v17 error:v2];
    uint64_t v23 = *(void **)(v9 + 224);
    *(void *)(v9 + 224) = v22;

    if (!*(void *)(v9 + 224)) {
      goto LABEL_8;
    }
  }

  id v17 = [v16 newFunctionWithName:@"ASVFillIndirectArgs"];
  if (!v17) {
    goto LABEL_7;
  }
  id v24 = [v13 defaultDevice];
  id v25 = [v24 newComputePipelineStateWithFunction:v17 error:v2];
  uint64_t v26 = *(void **)(v9 + 232);
  *(void *)(v9 + 232) = v25;

  if (!*(void *)(v9 + 232)) {
LABEL_8:
  }
    int v27 = 1;
  else {
LABEL_7:
  }
    int v27 = 0;

  if (!v27)
  {
    uint64_t v268 = v6;
    unint64_t v270 = v2;
    uint64_t v261 = v11;
    v284[0] = 0;
    v284[1] = 0;
    v283 = (uint64_t *)v284;
    newpool = 0;
    apr_pool_create_ex(&newpool, 0, 0, v28);
    id v29 = *(id **)(v277 + 8);
    id v30 = *v29;
    id v31 = v29[1];
    uint64_t v32 = *(void *)(*((void *)v30 + 15) + 24);
    if (!v32) {
      goto LABEL_97;
    }
    unint64_t v33 = *(void *)(v32 + (v6 << 6));
    InclusiveRange = GroupBuilder_findInclusiveRange(*(_DWORD *)(*((void *)v30 + 14) + 12), *(void **)(*((void *)v30 + 14) + 24), v6);
    uint64_t v35 = GroupRange_encoderWithIndirectResources((uint64_t)InclusiveRange);
    memcpy(__dst, v29 + 1414, 0x2B90uLL);
    if (!v35)
    {
      __int32 v46 = newpool;
      uint64_t v47 = apr_array_make(newpool, 16, 8);
      GTMTLSMContext_getObjects(*(_DWORD **)(*((void *)v30 + 5) + 72), v33, v47);
      if (v47->nelts >= 1)
      {
        uint64_t v48 = 0;
        do
          AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(v9, v29, *(int **)&v47->elts[8 * v48++], -1, v46, &v283);
        while (v48 < v47->nelts);
      }
      v47->int nelts = 0;
      GTMTLSMContext_getObjects(*(_DWORD **)(*((void *)v30 + 5) + 64), v33, v47);
      if (v47->nelts > 0)
      {
        uint64_t v49 = 0;
        do
          AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(v9, v29, *(int **)&v47->elts[8 * v49++], -1, v46, &v283);
        while (v49 < v47->nelts);
      }
LABEL_97:
      v266 = (void **)(v9 + 304);

      apr_pool_destroy(newpool);
      long long v111 = *(id **)(*(void *)(v9 + 208) + 8);
      id v112 = *v111;
      uint64_t v273 = *((void *)*v111 + 2);
      id v113 = v111[1];
      int v115 = GroupBuilder_findInclusiveRange(*(_DWORD *)(*((void *)v112 + 14) + 12), *(void **)(*((void *)v112 + 14) + 24), *(void *)(v9 + 288));
      if (v115)
      {
        while (1)
        {
          int v116 = *((_DWORD *)v115 + 7);
          if (IsFuncEnumCreateCommandEncoder(v116)) {
            break;
          }
          uint64_t v117 = *((unsigned int *)v115 + 4);
          if (v117) {
            v115 -= 4 * v117;
          }
          else {
            int v115 = 0;
          }
          if (!v115) {
            goto LABEL_103;
          }
        }
      }
      else
      {
LABEL_103:
        __dst[0] = 0;
        apr_pool_create_ex(__dst, 0, 0, v114);
        unint64_t v118 = __dst[0];
        unint64_t v119 = GTResourceTrackerMake(*((void *)v112 + 1), v273, __dst[0]);
        uint64_t v120 = *((void *)v112 + 14);
        if (*(int *)(v120 + 12) >= 1)
        {
          uint64_t v121 = 0;
          do
          {
            uint64_t v122 = *(void *)(v120 + 24);
            uint64_t v123 = v122 + 32 * v121;
            int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v123 + 28));
            if (FuncEnumConstructorType == 70 || FuncEnumConstructorType == 28)
            {
              unint64_t v126 = *(int *)(v122 + 32 * v121);
              unint64_t v128 = *(void *)(v123 + 8);
              unint64_t v127 = (unint64_t *)(v123 + 8);
              if (v128 > v126)
              {
                uint64_t v129 = v126 << 6;
                do
                {
                  GTResourceTrackerProcessFunction();
                  ++v126;
                  v129 += 64;
                }
                while (*v127 > v126);
                uint64_t v120 = *((void *)v112 + 14);
              }
            }
            ++v121;
          }
          while (v121 < *(int *)(v120 + 12));
        }
        Object = GTMTLSMContext_getObject(**((void **)v112 + 5), *(void *)(v9 + 296), *(void *)(v9 + 288) + *((void *)v112 + 10));
        if (!Object)
        {
LABEL_187:

          id v264 = *(id *)(*(void *)(v277 + 8) + 8);
          unint64_t v274 = [v264 defaultCommandQueue];
          id v11 = v261;
          id v196 = objc_alloc_init((Class)NSMutableArray);
          unint64_t v197 = *v266;
          char *v266 = v196;

          uint64_t v198 = [v264 defaultDevice];
          id v267 = [v198 latestSupportedGenericBVHVersion];

          v282[0] = 0;
          v282[1] = 0;
          newpool = (apr_pool_t *)v282;
          unint64_t v199 = AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::reserveAccelerationStructureDAG((AccelerationStructureViewerServer::MTLAccelerationStructureDataSource *)v9, (uint64_t **)&newpool, &v283, v264, v275, v270);
          if (v199 == -1)
          {
LABEL_245:
            std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>>>::destroy(v282[0]);

            std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>>>::destroy(v284[0]);
            goto LABEL_246;
          }
          uint64_t v200 = *(void *)(v9 + 184);
          uint64_t v201 = *(id **)(v9 + 192);
          unint64_t v202 = 0xD37A6F4DE9BD37A7 * (((uint64_t)v201 - v200) >> 3);
          unint64_t v203 = v199 - v202;
          if (v199 <= v202)
          {
            if (v199 < v202)
            {
              uint64_t v230 = (id *)(v200 + 184 * v199);
              while (v201 != v230)
              {
                v201 -= 23;
                AccelerationStructureViewerServer::AccelerationStructure::~AccelerationStructure(v201);
              }
              *(void *)(v9 + 192) = v230;
            }
          }
          else
          {
            uint64_t v204 = *(void *)(v9 + 200);
            if (0xD37A6F4DE9BD37A7 * ((v204 - (uint64_t)v201) >> 3) >= v203)
            {
              size_t v231 = 184 * ((184 * v203 - 184) / 0xB8) + 184;
              bzero(*(void **)(v9 + 192), v231);
              *(void *)(v9 + 192) = (char *)v201 + v231;
            }
            else
            {
              if (v199 > 0x1642C8590B21642) {
                abort();
              }
              unint64_t v205 = 0xD37A6F4DE9BD37A7 * ((v204 - v200) >> 3);
              uint64_t v206 = 2 * v205;
              if (2 * v205 <= v199) {
                uint64_t v206 = v199;
              }
              if (v205 >= 0xB21642C8590B21) {
                unint64_t v207 = 0x1642C8590B21642;
              }
              else {
                unint64_t v207 = v206;
              }
              unint64_t v208 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewerServer::AccelerationStructure>>(v207);
              uint64_t v209 = &v208[184 * v202];
              int v211 = &v208[184 * v210];
              size_t v212 = 184 * ((184 * v203 - 184) / 0xB8) + 184;
              bzero(v209, v212);
              uint64_t v213 = &v209[v212];
              unint64_t v215 = *(id **)(v9 + 184);
              unint64_t v214 = *(id **)(v9 + 192);
              if (v214 == v215)
              {
                *(void *)(v9 + 184) = v209;
                *(void *)(v9 + 192) = v213;
                *(void *)(v9 + 200) = v211;
              }
              else
              {
                uint64_t v216 = 0;
                do
                {
                  unint64_t v217 = &v209[v216 * 8];
                  v218 = &v214[v216];
                  id v219 = v214[v216 - 23];
                  *(v218 - 23) = 0;
                  *((void *)v217 - 23) = v219;
                  *((_OWORD *)v217 - 11) = *(_OWORD *)&v214[v216 - 22];
                  id v220 = v214[v216 - 20];
                  *(v218 - 20) = 0;
                  *((void *)v217 - 20) = v220;
                  *((void *)v217 - 19) = v214[v216 - 19];
                  id v221 = v214[v216 - 18];
                  *(v218 - 18) = 0;
                  *((void *)v217 - 18) = v221;
                  *((void *)v217 - 17) = v214[v216 - 17];
                  id v222 = v214[v216 - 16];
                  *(v218 - 16) = 0;
                  *((void *)v217 - 16) = v222;
                  *((void *)v217 - 15) = v214[v216 - 15];
                  id v223 = v214[v216 - 14];
                  *(v218 - 14) = 0;
                  *((void *)v217 - 14) = v223;
                  *((void *)v217 - 13) = v214[v216 - 13];
                  id v224 = v214[v216 - 12];
                  *(v218 - 12) = 0;
                  *((void *)v217 - 12) = v224;
                  *((void *)v217 - 11) = v214[v216 - 11];
                  id v225 = v214[v216 - 10];
                  *(v218 - 10) = 0;
                  *((void *)v217 - 10) = v225;
                  *(_OWORD *)(v217 - 72) = *(_OWORD *)&v214[v216 - 9];
                  *((void *)v217 - 6) = 0;
                  *((void *)v217 - 5) = 0;
                  *((void *)v217 - 7) = 0;
                  *(_OWORD *)(v217 - 56) = *(_OWORD *)&v214[v216 - 7];
                  *((void *)v217 - 5) = v214[v216 - 5];
                  *(v218 - 7) = 0;
                  *(v218 - 6) = 0;
                  id v226 = v214[v216 - 4];
                  *(v218 - 5) = 0;
                  *(v218 - 4) = 0;
                  *((void *)v217 - 4) = v226;
                  *((void *)v217 - 3) = v214[v216 - 3];
                  id v227 = v214[v216 - 2];
                  *(v218 - 2) = 0;
                  *((void *)v217 - 2) = v227;
                  *(v217 - 8) = (char)v214[v216 - 1];
                  v216 -= 23;
                }
                while (&v214[v216] != v215);
                unint64_t v228 = &v209[v216 * 8];
                v229 = *(id **)(v9 + 184);
                unint64_t v214 = *(id **)(v9 + 192);
                *(void *)(v9 + 184) = v228;
                *(void *)(v9 + 192) = v213;
                *(void *)(v9 + 200) = v211;
                if (v214 != v229)
                {
                  do
                    AccelerationStructureViewerServer::AccelerationStructure::~AccelerationStructure(v214 - 23);
                  while (v214 != v229);
                  unint64_t v214 = v229;
                }
              }
              if (v214) {
                operator delete(v214);
              }
            }
          }
          NSLog(@"Begin allocate");
          id v260 = objc_alloc_init((Class)NSMutableArray);
          unint64_t v232 = [v274 commandBufferWithDescriptor:v261];
          [v232 setLabel:@"ASV allocateAccelerationStructureDAG"];
          unint64_t v233 = [v232 accelerationStructureCommandEncoder];
          if (objc_opt_respondsToSelector())
          {
            unint64_t v234 = [v264 accelerationStructureForKey:v275];
            __dst[1] = 0;
            __dst[2] = 0;
            __dst[0] = (apr_pool_t *)&__dst[1];
            unint64_t v235 = v260;
            uint64_t v236 = AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::allocateAccelerationStructureDAG(v9, (uint64_t)v267, (uint64_t **)__dst, &v283, v260, v277, v268, v264, v275, v232, v233, v270);
            [v233 endEncoding];
            [v232 commit];
            [v232 waitUntilCompleted];
            if (!v236 || *(void *)(v9 + 192) == *(void *)(v9 + 184))
            {
              std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>>>::destroy((void *)__dst[1]);
            }
            else
            {
              *(_DWORD *)(v9 + 176) = 0;
              std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>>>::destroy((void *)__dst[1]);

              NSLog(@"Finish allocate");
              NSLog(@"Begin encode");
              id v237 = v260;
              id v238 = v274;
              id v269 = v261;
              unint64_t v276 = v238;
              uint64_t v259 = [v238 device];
              if (*(void *)(v9 + 192) != *(void *)(v9 + 184))
              {
                unint64_t v239 = 0;
                while (1)
                {
                  v278 = [v237 objectAtIndex:v239];
                  uint64_t v240 = *(void *)(v9 + 184);
                  id v241 = [objc_alloc((Class)MTLGenericBVHBuffersSPI) initWithVersion:v267];
                  [v241 setHeaderBuffer:*(void *)(v240 + 184 * v239 + 24)];
                  [v241 setHeaderBufferOffset:*(void *)(v240 + 184 * v239 + 32)];
                  [v241 setInnerNodeBuffer:*(void *)(v240 + 184 * v239 + 40)];
                  [v241 setInnerNodeBufferOffset:*(void *)(v240 + 184 * v239 + 48)];
                  [v241 setLeafNodeBuffer:*(void *)(v240 + 184 * v239 + 56)];
                  [v241 setLeafNodeBufferOffset:*(void *)(v240 + 184 * v239 + 64)];
                  [v241 setPrimitiveBuffer:*(void *)(v240 + 184 * v239 + 72)];
                  [v241 setPrimitiveBufferOffset:*(void *)(v240 + 184 * v239 + 80)];
                  [v241 setGeometryBuffer:*(void *)(v240 + 184 * v239 + 88)];
                  [v241 setGeometryBufferOffset:*(void *)(v240 + 184 * v239 + 96)];
                  [v241 setPerPrimitiveDataBuffer:*(void *)(v240 + 184 * v239 + 104)];
                  [v241 setPerPrimitiveDataBufferOffset:*(void *)(v240 + 184 * v239 + 112)];
                  [v241 setInstanceTransformBuffer:*(void *)(v240 + 184 * v239 + 152)];
                  [v241 setInstanceTransformBufferOffset:*(void *)(v240 + 184 * v239 + 160)];
                  uint64_t v242 = [v276 commandBufferWithDescriptor:v269];
                  [v242 setLabel:@"ASV encodeAccelerationStructureDAG"];
                  uint64_t v243 = [v242 accelerationStructureCommandEncoder];
                  if (*(void *)(v9 + 192) != *(void *)(v9 + 184))
                  {
                    unint64_t v244 = 0;
                    do
                    {
                      unint64_t v245 = [v237 objectAtIndex:v244];
                      [v243 useResource:v245 usage:1];

                      ++v244;
                    }
                    while (v244 < 0xD37A6F4DE9BD37A7
                                 * ((uint64_t)(*(void *)(v9 + 192) - *(void *)(v9 + 184)) >> 3));
                  }
                  unsigned __int8 v246 = [v243 writeGenericBVHStructureOfAccelerationStructure:v278 into:v241];
                  [v243 endEncoding];
                  [v241 setHeaderBuffer:0];
                  [v241 setInnerNodeBuffer:0];
                  [v241 setLeafNodeBuffer:0];
                  [v241 setPrimitiveBuffer:0];
                  [v241 setGeometryBuffer:0];
                  [v241 setPerPrimitiveDataBuffer:0];
                  [v241 setInstanceTransformBuffer:0];
                  if (v246)
                  {
                    __dst[0] = (apr_pool_t *)_NSConcreteStackBlock;
                    __dst[1] = (apr_pool_t *)3221225472;
                    __dst[2] = (apr_pool_t *)___ZN33AccelerationStructureViewerServer34MTLAccelerationStructureDataSource30encodeAccelerationStructureDAGE29MTLGenericBVHHeaderVersionSPIP14NSMutableArrayIPU35objcproto24MTLAccelerationStructure11objc_objectEPU26objcproto15MTLCommandQueue11objc_objectP26MTLCommandBufferDescriptorPU15__autoreleasingP7NSError_block_invoke;
                    __dst[3] = (apr_pool_t *)&unk_743FA8;
                    __dst[5] = (apr_pool_t *)v239;
                    __dst[6] = (apr_pool_t *)(v240 + 184 * v239);
                    __dst[4] = (apr_pool_t *)v259;
                    [v242 addCompletedHandler:__dst];
                    [v242 commit];
                    [v242 waitUntilCompleted];
                    if ([v242 status] == (char *)&dword_4 + 1)
                    {
                      *unint64_t v270 = [v242 error];
                      int v247 = 1;
                    }
                    else
                    {
                      int v247 = 0;
                    }
                  }
                  else
                  {
                    *unint64_t v270 = +[ASVError errorWithCode:2 localizedDescription:@"Your version of Metal does not support this tool"];
                    int v247 = 1;
                  }

                  if (v247) {
                    break;
                  }
                  if (++v239 >= 0xD37A6F4DE9BD37A7 * ((uint64_t)(*(void *)(v9 + 192) - *(void *)(v9 + 184)) >> 3))
                  {

                    unint64_t v235 = v260;
                    id v11 = v261;
                    goto LABEL_231;
                  }
                }

                unint64_t v235 = v260;
                id v11 = v261;
                goto LABEL_244;
              }

LABEL_231:
              NSLog(@"Finish encode");
              uint64_t v248 = *(unsigned int *)(v9 + 176);
              uint64_t v249 = *(void *)(v9 + 184);
              int v250 = *(_DWORD *)(v249 + 184 * v248 + 8);
              if ((v250 - 3) < 2) {
                goto LABEL_232;
              }
              if (v250 == 2)
              {
                uint64_t v251 = *(void *)(v9 + 192);
                uint64_t v252 = v251 - v249;
                if (v251 != v249)
                {
                  uint64_t v253 = 0;
                  char v254 = 0;
                  unint64_t v255 = 0xD37A6F4DE9BD37A7 * (v252 >> 3);
                  unint64_t v256 = (_DWORD *)(v249 + 8);
                  do
                  {
                    if (v248 != v253 && (*v256 - 3) < 2) {
                      char v254 = 1;
                    }
                    if (++v253 >= v255) {
                      break;
                    }
                    v256 += 46;
                  }
                  while ((v254 & 1) == 0);
                  if (v254) {
LABEL_232:
                  }
                    *(unsigned char *)(v249 + 184 * v248 + 176) = 1;
                }
              }
              id v257 = v237;
              unint64_t v232 = *(void **)(v9 + 376);
              *(void *)(v9 + 376) = v257;
            }
          }
          else
          {
            *unint64_t v270 = +[ASVError errorWithCode:2 localizedDescription:@"Your version of Metal does not support this tool"];
            [v233 endEncoding];
            [v232 commit];

            unint64_t v235 = v260;
          }

LABEL_244:
          goto LABEL_245;
        }
        uint64_t v131 = Object;
        entry = find_entry(v119[4], (unsigned char *)(v9 + 296), 8uLL, 0);
        if (*entry && (uint64_t v133 = *(void **)(*entry + 32)) != 0)
        {
          uint64_t v134 = v133[3];
          if (v134 <= 0)
          {
            uint64_t v134 = v133[4];
            if (v134 <= 0)
            {
              uint64_t v134 = v133[2];
              if (!v134) {
                goto LABEL_187;
              }
            }
          }
        }
        else
        {
          uint64_t v136 = v131[6];
          uint64_t v135 = v131 + 6;
          if (!v136) {
            goto LABEL_187;
          }
          unint64_t v137 = find_entry(v119[3], v135, 8uLL, 0);
          if (!*v137) {
            goto LABEL_187;
          }
          uint64_t v138 = *(void *)(*v137 + 32);
          if (!v138) {
            goto LABEL_187;
          }
          uint64_t v134 = *(void *)(v138 + 8);
        }
        uint64_t v139 = GroupBuilder_findInclusiveRange(*(_DWORD *)(*((void *)v112 + 14) + 12), *(void **)(*((void *)v112 + 14) + 24), v134 - *((void *)v112 + 10));
        uint64_t v140 = GroupRange_encoderWithIndirectResources((uint64_t)v139);
        if (!v140) {
          goto LABEL_187;
        }
        int v115 = (void *)v140;
        apr_pool_destroy(v118);
        int v116 = *((_DWORD *)v115 + 7);
      }
      int v141 = GetFuncEnumConstructorType(v116);
      BOOL v142 = v141 == 70 || v141 == 28;
      uint64_t v143 = v273;
      if (v142)
      {
        unint64_t v144 = *(int *)v115;
        while (v115[1] > v144)
        {
          uint64_t v145 = *(void *)(*((void *)v112 + 15) + 24);
          uint64_t v146 = v145 + (v144 << 6);
          int v147 = *(_DWORD *)(v146 + 8);
          switch(v147)
          {
            case -16047:
              uint64_t v148 = GTTraceFunc_argumentBytesWithMap((void *)v146, *(unsigned __int8 *)(v145 + (v144 << 6) + 13), v143);
              unint64_t v149 = [v113 resourceForKey:*((void *)v148 + 1)];
              unsigned __int8 v150 = v148[16];
              LOBYTE(__dst[0]) = v150;
              if (v149) {
                goto LABEL_144;
              }
              goto LABEL_186;
            case -16046:
              unint64_t v178 = GTTraceFunc_argumentBytesWithMap((void *)v146, *(unsigned __int8 *)(v145 + (v144 << 6) + 13), v143);
              uint64_t v179 = v143;
              uint64_t v180 = v178;
              unint64_t v181 = GTTraceFunc_argumentBytesWithMap((void *)v146, v178[24], v179);
              unsigned __int8 v182 = v180[16];
              LOBYTE(__dst[0]) = v182;
              if (*((void *)v180 + 1))
              {
                uint64_t v183 = v181;
                unint64_t v184 = 0;
                do
                {
                  unint64_t v185 = [v113 resourceForKey:*(void *)&v183[8 * v184]];
                  if (v185)
                  {
                    uint64_t v186 = (char **)std::__hash_table<std::__hash_value_type<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>,std::__unordered_map_hasher<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>,std::hash<GTMTLResourceUsage_uint8_t>,std::equal_to<GTMTLResourceUsage_uint8_t>,true>,std::__unordered_map_equal<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>,std::equal_to,std::hash,true>,objc_object  {objcproto11MTLResource}* {__strong}<std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>>::__emplace_unique_key_args<GTMTLResourceUsage_uint8_t,std::piecewise_construct_t const&,std::tuple<GTMTLResourceUsage_uint8_t const&>,std::piecewise_construct_t const&<>>(v279, v182, __dst);
                    std::vector<objc_object  {objcproto11MTLResource}* {__strong}>::push_back[abi:nn180100](v186 + 3, v185);
                  }
                  ++v184;
                }
                while (*((void *)v180 + 1) > v184);
              }
              goto LABEL_182;
            case -16045:
              unint64_t v149 = [v113 heapForKey:*((void *)GTTraceFunc_argumentBytesWithMap((void *)v146, *(unsigned __int8 *)(v145 + (v144 << 6) + 13), v143)+ 1)];
              if (v149) {
                goto LABEL_184;
              }
              goto LABEL_186;
            case -16044:
              unint64_t v163 = GTTraceFunc_argumentBytesWithMap((void *)v146, *(unsigned __int8 *)(v145 + (v144 << 6) + 13), v143);
              id v164 = GTTraceFunc_argumentBytesWithMap((void *)v146, v163[16], v143);
              if (*((void *)v163 + 1))
              {
                long long v165 = v164;
                unint64_t v166 = 0;
                do
                {
                  id v167 = [v113 heapForKey:*(void *)&v165[8 * v166]];
                  if (v167)
                  {
                    std::vector<objc_object  {objcproto11MTLResource}* {__strong}>::push_back[abi:nn180100](v280, v167);
                  }
                  ++v166;
                }
                while (*((void *)v163 + 1) > v166);
              }
              goto LABEL_186;
            case -16043:
              unint64_t v151 = GTTraceFunc_argumentBytesWithMap((void *)v146, *(unsigned __int8 *)(v145 + (v144 << 6) + 13), v143);
              unint64_t v149 = [v113 resourceForKey:*((void *)v151 + 1)];
              unsigned __int8 v150 = v151[16];
              LOBYTE(__dst[0]) = v150;
              if (!v149) {
                goto LABEL_186;
              }
LABEL_144:
              unint64_t v153 = (char **)std::__hash_table<std::__hash_value_type<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>,std::__unordered_map_hasher<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>,std::hash<GTMTLResourceUsage_uint8_t>,std::equal_to<GTMTLResourceUsage_uint8_t>,true>,std::__unordered_map_equal<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>,std::equal_to,std::hash,true>,objc_object  {objcproto11MTLResource}* {__strong}<std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>>::__emplace_unique_key_args<GTMTLResourceUsage_uint8_t,std::piecewise_construct_t const&,std::tuple<GTMTLResourceUsage_uint8_t const&>,std::piecewise_construct_t const&<>>(v279, v150, __dst);
              std::vector<objc_object  {objcproto11MTLResource}* {__strong}>::push_back[abi:nn180100](v153 + 3, v149);
              goto LABEL_185;
            case -16042:
              unint64_t v187 = GTTraceFunc_argumentBytesWithMap((void *)v146, *(unsigned __int8 *)(v145 + (v144 << 6) + 13), v143);
              uint64_t v188 = v143;
              uint64_t v189 = v187;
              uint64_t v190 = GTTraceFunc_argumentBytesWithMap((void *)v146, v187[24], v188);
              unsigned __int8 v191 = v189[16];
              LOBYTE(__dst[0]) = v191;
              if (*((void *)v189 + 1))
              {
                uint64_t v192 = v190;
                unint64_t v193 = 0;
                do
                {
                  uint64_t v194 = [v113 resourceForKey:*(void *)&v192[8 * v193]];
                  if (v194)
                  {
                    uint64_t v195 = (char **)std::__hash_table<std::__hash_value_type<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>,std::__unordered_map_hasher<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>,std::hash<GTMTLResourceUsage_uint8_t>,std::equal_to<GTMTLResourceUsage_uint8_t>,true>,std::__unordered_map_equal<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>,std::equal_to,std::hash,true>,objc_object  {objcproto11MTLResource}* {__strong}<std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>>::__emplace_unique_key_args<GTMTLResourceUsage_uint8_t,std::piecewise_construct_t const&,std::tuple<GTMTLResourceUsage_uint8_t const&>,std::piecewise_construct_t const&<>>(v279, v191, __dst);
                    std::vector<objc_object  {objcproto11MTLResource}* {__strong}>::push_back[abi:nn180100](v195 + 3, v194);
                  }
                  ++v193;
                }
                while (*((void *)v189 + 1) > v193);
              }
LABEL_182:
              uint64_t v143 = v273;
              goto LABEL_186;
            case -16041:
              unint64_t v149 = [v113 heapForKey:*((void *)GTTraceFunc_argumentBytesWithMap((void *)v146, *(unsigned __int8 *)(v145 + (v144 << 6) + 13), v143)+ 1)];
              if (!v149) {
                goto LABEL_186;
              }
LABEL_184:
              std::vector<objc_object  {objcproto11MTLResource}* {__strong}>::push_back[abi:nn180100](v280, v149);
LABEL_185:

LABEL_186:
              ++v144;
              break;
            case -16040:
              unint64_t v173 = GTTraceFunc_argumentBytesWithMap((void *)v146, *(unsigned __int8 *)(v145 + (v144 << 6) + 13), v143);
              unint64_t v174 = GTTraceFunc_argumentBytesWithMap((void *)v146, v173[16], v143);
              if (*((void *)v173 + 1))
              {
                unint64_t v175 = v174;
                unint64_t v176 = 0;
                do
                {
                  uint64_t v177 = [v113 heapForKey:*(void *)&v175[8 * v176]];
                  if (v177)
                  {
                    std::vector<objc_object  {objcproto11MTLResource}* {__strong}>::push_back[abi:nn180100](v280, v177);
                  }
                  ++v176;
                }
                while (*((void *)v173 + 1) > v176);
              }
              goto LABEL_186;
            default:
              switch(v147)
              {
                case -15821:
                  unint64_t v149 = [v113 heapForKey:*((void *)GTTraceFunc_argumentBytesWithMap((void *)v146, *(unsigned __int8 *)(v145 + (v144 << 6) + 13), v143)+ 1)];
                  if (v149) {
                    goto LABEL_184;
                  }
                  break;
                case -15820:
                  unint64_t v168 = GTTraceFunc_argumentBytesWithMap((void *)v146, *(unsigned __int8 *)(v145 + (v144 << 6) + 13), v143);
                  unint64_t v169 = GTTraceFunc_argumentBytesWithMap((void *)v146, v168[24], v143);
                  if (*((void *)v168 + 1))
                  {
                    uint64_t v170 = v169;
                    unint64_t v171 = 0;
                    do
                    {
                      uint64_t v172 = [v113 heapForKey:*(void *)&v170[8 * v171]];
                      if (v172)
                      {
                        std::vector<objc_object  {objcproto11MTLResource}* {__strong}>::push_back[abi:nn180100](v280, v172);
                      }
                      ++v171;
                    }
                    while (*((void *)v168 + 1) > v171);
                  }
                  break;
                case -15819:
                  uint64_t v152 = GTTraceFunc_argumentBytesWithMap((void *)v146, *(unsigned __int8 *)(v145 + (v144 << 6) + 13), v143);
                  unint64_t v149 = [v113 resourceForKey:*((void *)v152 + 1)];
                  unsigned __int8 v150 = v152[16];
                  LOBYTE(__dst[0]) = v150;
                  if (v149) {
                    goto LABEL_144;
                  }
                  break;
                case -15818:
                  uint64_t v154 = GTTraceFunc_argumentBytesWithMap((void *)v146, *(unsigned __int8 *)(v145 + (v144 << 6) + 13), v143);
                  uint64_t v155 = v143;
                  uint64_t v156 = v154;
                  unint64_t v157 = GTTraceFunc_argumentBytesWithMap((void *)v146, v154[32], v155);
                  unsigned __int8 v158 = v156[16];
                  LOBYTE(__dst[0]) = v158;
                  if (*((void *)v156 + 1))
                  {
                    uint64_t v159 = v157;
                    unint64_t v160 = 0;
                    do
                    {
                      unint64_t v161 = [v113 resourceForKey:*(void *)&v159[8 * v160]];
                      if (v161)
                      {
                        unint64_t v162 = (char **)std::__hash_table<std::__hash_value_type<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>,std::__unordered_map_hasher<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>,std::hash<GTMTLResourceUsage_uint8_t>,std::equal_to<GTMTLResourceUsage_uint8_t>,true>,std::__unordered_map_equal<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>,std::equal_to,std::hash,true>,objc_object  {objcproto11MTLResource}* {__strong}<std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>>::__emplace_unique_key_args<GTMTLResourceUsage_uint8_t,std::piecewise_construct_t const&,std::tuple<GTMTLResourceUsage_uint8_t const&>,std::piecewise_construct_t const&<>>(v279, v158, __dst);
                        std::vector<objc_object  {objcproto11MTLResource}* {__strong}>::push_back[abi:nn180100](v162 + 3, v161);
                      }
                      ++v160;
                    }
                    while (*((void *)v156 + 1) > v160);
                  }
                  goto LABEL_182;
                default:
                  goto LABEL_186;
              }
              goto LABEL_186;
          }
        }
      }
      goto LABEL_187;
    }
    int v36 = GetFuncEnumConstructorType(*(_DWORD *)(v35 + 28));
    if (v36 == 70)
    {
      int v50 = *(_DWORD *)(v32 + (v6 << 6) + 8);
      if (IsFuncEnumDrawCall(v50))
      {
        uint64_t v51 = newpool;
        if ((v50 + 15416) >= 3)
        {
          uint64_t v52 = 0;
          unint64_t v53 = (unint64_t)__dst[8];
          do
          {
            if (((v53 >> v52) & 1) == 0)
            {
              uint64_t v54 = (int *)GTMTLSMContext_getObject(**((void **)v30 + 5), (uint64_t)__dst[v52 + 10], v33);
              AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(v9, v29, v54, v52, v51, &v283);
            }
            ++v52;
          }
          while (v52 != 31);
        }
        uint64_t v55 = 0;
        unint64_t v56 = (unint64_t)__dst[247];
        do
        {
          if (((v56 >> v55) & 1) == 0)
          {
            uint64_t v57 = (int *)GTMTLSMContext_getObject(**((void **)v30 + 5), (uint64_t)__dst[v55 + 248], v33);
            AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(v9, v29, v57, v55, v51, &v283);
          }
          ++v55;
        }
        while (v55 != 31);
      }
      else if (v50 == -16137 || v50 == -15297 || v50 == -15486)
      {
        uint64_t v58 = 0;
        unint64_t v59 = (unint64_t)__dst[868];
        id v60 = newpool;
        do
        {
          if (((v59 >> v58) & 1) == 0)
          {
            simd_float3 v61 = (int *)GTMTLSMContext_getObject(**((void **)v30 + 5), (uint64_t)__dst[v58 + 869], v33);
            AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(v9, v29, v61, v58, v60, &v283);
          }
          ++v58;
        }
        while (v58 != 31);
      }
      id v62 = *v29;
      uint64_t v272 = *((void *)*v29 + 2);
      id v42 = v29[1];
      unint64_t v63 = GroupBuilder_findInclusiveRange(*(_DWORD *)(*((void *)v62 + 14) + 12), *(void **)(*((void *)v62 + 14) + 24), *(void *)(v9 + 288));
      if (!v63) {
        goto LABEL_96;
      }
      while (1)
      {
        int v64 = *((_DWORD *)v63 + 7);
        if (IsFuncEnumCreateCommandEncoder(v64)) {
          break;
        }
        uint64_t v65 = *((unsigned int *)v63 + 4);
        if (v65) {
          v63 -= 4 * v65;
        }
        else {
          unint64_t v63 = 0;
        }
        if (!v63) {
          goto LABEL_96;
        }
      }
      if (GetFuncEnumConstructorType(v64) != 70) {
        goto LABEL_96;
      }
      unint64_t v81 = *(int *)v63;
      unint64_t v82 = v63[1];
      BOOL v83 = v82 > v81;
      if (v82 <= v81) {
        goto LABEL_96;
      }
      id v263 = v31;
      id v265 = v42;
      uint64_t v84 = newpool;
      do
      {
        uint64_t v85 = *(void *)(*((void *)v62 + 15) + 24);
        uint64_t v86 = v85 + (v81 << 6);
        int v87 = *(_DWORD *)(v86 + 8);
        if (!v83)
        {
          switch(v87)
          {
            case -16043:
            case -16041:
              goto LABEL_77;
            case -16042:
              uint64_t v95 = GTTraceFunc_argumentBytesWithMap((void *)v86, *(unsigned __int8 *)(v85 + (v81 << 6) + 13), v272);
              unint64_t v96 = GTTraceFunc_argumentBytesWithMap((void *)v86, v95[24], v272);
              if (*((void *)v95 + 1))
              {
                id v97 = v96;
                unint64_t v98 = 0;
                do
                {
                  id v99 = (int *)GTMTLSMContext_getObject(**((void **)v62 + 5), *(void *)&v97[8 * v98], v33);
                  AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(v9, v29, v99, -1, v84, &v283);
                  ++v98;
                }
                while (*((void *)v95 + 1) > v98);
              }
              goto LABEL_94;
            case -16040:
              uint64_t v90 = GTTraceFunc_argumentBytesWithMap((void *)v86, *(unsigned __int8 *)(v85 + (v81 << 6) + 13), v272);
              long long v91 = GTTraceFunc_argumentBytesWithMap((void *)v86, v90[16], v272);
              if (*((void *)v90 + 1))
              {
                long long v92 = v91;
                unint64_t v93 = 0;
                do
                {
                  long long v94 = (int *)GTMTLSMContext_getObject(**((void **)v62 + 5), *(void *)&v92[8 * v93], v33);
                  AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(v9, v29, v94, -1, v84, &v283);
                  ++v93;
                }
                while (*((void *)v90 + 1) > v93);
              }
              goto LABEL_94;
            default:
              JUMPOUT(0);
          }
        }
        switch(v87)
        {
          case -15821:
          case -15819:
LABEL_77:
            id v88 = GTTraceFunc_argumentBytesWithMap((void *)v86, *(unsigned __int8 *)(v85 + (v81 << 6) + 13), v272);
            id v89 = (int *)GTMTLSMContext_getObject(**((void **)v62 + 5), *((void *)v88 + 1), v33);
            AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(v9, v29, v89, -1, v84, &v283);
            break;
          case -15820:
            id v105 = GTTraceFunc_argumentBytesWithMap((void *)v86, *(unsigned __int8 *)(v85 + (v81 << 6) + 13), v272);
            id v106 = GTTraceFunc_argumentBytesWithMap((void *)v86, v105[24], v272);
            if (*((void *)v105 + 1))
            {
              uint64_t v107 = v106;
              unint64_t v108 = 0;
              do
              {
                long long v109 = (int *)GTMTLSMContext_getObject(**((void **)v62 + 5), *(void *)&v107[8 * v108], v33);
                AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(v9, v29, v109, -1, v84, &v283);
                ++v108;
              }
              while (*((void *)v105 + 1) > v108);
            }
            break;
          case -15818:
            id v100 = GTTraceFunc_argumentBytesWithMap((void *)v86, *(unsigned __int8 *)(v85 + (v81 << 6) + 13), v272);
            uint64_t v101 = GTTraceFunc_argumentBytesWithMap((void *)v86, v100[32], v272);
            if (*((void *)v100 + 1))
            {
              id v102 = v101;
              unint64_t v103 = 0;
              do
              {
                char v104 = (int *)GTMTLSMContext_getObject(**((void **)v62 + 5), *(void *)&v102[8 * v103], v33);
                AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(v9, v29, v104, -1, v84, &v283);
                ++v103;
              }
              while (*((void *)v100 + 1) > v103);
            }
            break;
          default:
            break;
        }
LABEL_94:
        ++v81;
        unint64_t v110 = v63[1];
        BOOL v83 = v110 > v81;
        id v31 = v263;
      }
      while (v110 > v81);
    }
    else
    {
      if (v36 != 28) {
        goto LABEL_97;
      }
      uint64_t v37 = 0;
      unint64_t v38 = (unint64_t)__dst[9];
      id v39 = newpool;
      do
      {
        if (((v38 >> v37) & 1) == 0)
        {
          long long v40 = (int *)GTMTLSMContext_getObject(**((void **)v30 + 5), (uint64_t)__dst[v37 + 11], v33);
          AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(v9, v29, v40, v37, v39, &v283);
        }
        ++v37;
      }
      while (v37 != 31);
      id v41 = *v29;
      uint64_t v271 = *((void *)*v29 + 2);
      id v42 = v29[1];
      long long v43 = GroupBuilder_findInclusiveRange(*(_DWORD *)(*((void *)v41 + 14) + 12), *(void **)(*((void *)v41 + 14) + 24), *(void *)(v9 + 288));
      if (!v43) {
        goto LABEL_96;
      }
      while (1)
      {
        int v44 = *((_DWORD *)v43 + 7);
        if (IsFuncEnumCreateCommandEncoder(v44)) {
          break;
        }
        uint64_t v45 = *((unsigned int *)v43 + 4);
        if (v45) {
          v43 -= 4 * v45;
        }
        else {
          long long v43 = 0;
        }
        if (!v43) {
          goto LABEL_96;
        }
      }
      if (GetFuncEnumConstructorType(v44) != 28) {
        goto LABEL_96;
      }
      unint64_t v66 = *(int *)v43;
      if (v43[1] <= v66) {
        goto LABEL_96;
      }
      id v262 = v31;
      id v265 = v42;
      do
      {
        uint64_t v67 = *(void *)(*((void *)v41 + 15) + 24);
        uint64_t v68 = v67 + (v66 << 6);
        switch(*(_DWORD *)(v68 + 8))
        {
          case 0xFFFFC151:
          case 0xFFFFC153:
            uint64_t v69 = GTTraceFunc_argumentBytesWithMap((void *)v68, *(unsigned __int8 *)(v67 + (v66 << 6) + 13), v271);
            unint64_t v70 = (int *)GTMTLSMContext_getObject(**((void **)v41 + 5), *((void *)v69 + 1), v33);
            AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(v9, v29, v70, -1, v39, &v283);
            break;
          case 0xFFFFC152:
            uint64_t v76 = GTTraceFunc_argumentBytesWithMap((void *)v68, *(unsigned __int8 *)(v67 + (v66 << 6) + 13), v271);
            uint64_t v77 = GTTraceFunc_argumentBytesWithMap((void *)v68, v76[24], v271);
            if (*((void *)v76 + 1))
            {
              uint64_t v78 = v77;
              unint64_t v79 = 0;
              do
              {
                uint64_t v80 = (int *)GTMTLSMContext_getObject(**((void **)v41 + 5), *(void *)&v78[8 * v79], v33);
                AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(v9, v29, v80, -1, v39, &v283);
                ++v79;
              }
              while (*((void *)v76 + 1) > v79);
            }
            break;
          case 0xFFFFC154:
            BOOL v71 = GTTraceFunc_argumentBytesWithMap((void *)v68, *(unsigned __int8 *)(v67 + (v66 << 6) + 13), v271);
            simd_float3 v72 = GTTraceFunc_argumentBytesWithMap((void *)v68, v71[16], v271);
            if (*((void *)v71 + 1))
            {
              uint64_t v73 = v72;
              unint64_t v74 = 0;
              do
              {
                uint64_t v75 = (int *)GTMTLSMContext_getObject(**((void **)v41 + 5), *(void *)&v73[8 * v74], v33);
                AccelerationStructureViewerServer::MTLAccelerationStructureDataSource::visitResourceObject(v9, v29, v75, -1, v39, &v283);
                ++v74;
              }
              while (*((void *)v71 + 1) > v74);
            }
            break;
          default:
            break;
        }
        ++v66;
      }
      while (v43[1] > v66);
      id v31 = v262;
    }
    id v42 = v265;
LABEL_96:

    goto LABEL_97;
  }
LABEL_246:

  return v9;
}

void sub_1C262C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void **a27,uint64_t a28,uint64_t a29,uint64_t a30,void **a31,void *a32)
{
  apr_pool_destroy(v33);
  std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>>>::destroy(a32);

  a31 = a27;
  std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&a31);
  std::__hash_table<std::__hash_value_type<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>,std::__unordered_map_hasher<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>,std::hash<GTMTLResourceUsage_uint8_t>,std::equal_to<GTMTLResourceUsage_uint8_t>,true>,std::__unordered_map_equal<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>,std::equal_to,std::hash,true>,objc_object  {objcproto11MTLResource}* {__strong}<std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>>::~__hash_table(a26);

  std::__tree<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::IntersectionFunction>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::IntersectionFunction>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AccelerationStructureViewer::IntersectionFunction>>>>::destroy(*(char **)(v32 + 272));
  a31 = (void **)(v32 + 240);
  std::vector<AccelerationStructureViewer::IntersectionFunctionTable>::__destroy_vector::operator()[abi:nn180100](&a31);

  AccelerationStructureViewerServer::DataSource::~DataSource((AccelerationStructureViewerServer::DataSource *)v32);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,AccelerationStructureViewerServer::AccelerationStructure *>>>::destroy(a1[1]);
    operator delete(a1);
  }
}

void AccelerationStructureViewerServer::AccelerationStructure::~AccelerationStructure(id *this)
{
  id v2 = this[16];
  if (v2)
  {
    this[17] = v2;
    operator delete(v2);
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewerServer::AccelerationStructure>>(unint64_t a1)
{
  if (a1 >= 0x1642C8590B21643) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(184 * a1);
}

void *std::__hash_table<std::__hash_value_type<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>,std::__unordered_map_hasher<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>,std::hash<GTMTLResourceUsage_uint8_t>,std::equal_to<GTMTLResourceUsage_uint8_t>,true>,std::__unordered_map_equal<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>,std::equal_to,std::hash,true>,objc_object  {objcproto11MTLResource}* {__strong}<std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>>::__emplace_unique_key_args<GTMTLResourceUsage_uint8_t,std::piecewise_construct_t const&,std::tuple<GTMTLResourceUsage_uint8_t const&>,std::piecewise_construct_t const&<>>(uint64_t *a1, unsigned __int8 a2, unsigned char *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      id v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((unsigned __int8 *)v10 + 16) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          id v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint8x8_t v12 = a1 + 2;
  id v10 = operator new(0x30uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((unsigned char *)v10 + 16) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  float v13 = (float)(unint64_t)(a1[3] + 1);
  float v14 = *((float *)a1 + 8);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      int8x8_t prime = (int8x8_t)v17;
    }
    else {
      int8x8_t prime = (int8x8_t)v16;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = a1[1];
    }
    if (*(void *)&prime > v7) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }
      else
      {
        uint64_t v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }
      if (*(void *)&prime <= v25) {
        int8x8_t prime = (int8x8_t)v25;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          id v19 = operator new(8 * *(void *)&prime);
          id v20 = (void *)*a1;
          *a1 = (uint64_t)v19;
          if (v20) {
            operator delete(v20);
          }
          uint64_t v21 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v21++) = 0;
          while (*(void *)&prime != v21);
          id v22 = (void *)*v12;
          if (*v12)
          {
            unint64_t v23 = v22[1];
            uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(void *)&prime) {
                v23 %= *(void *)&prime;
              }
            }
            else
            {
              v23 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v23) = v12;
            uint64_t v28 = (void *)*v22;
            if (*v22)
            {
              do
              {
                unint64_t v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(void *)&prime) {
                    v29 %= *(void *)&prime;
                  }
                }
                else
                {
                  v29 &= *(void *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(void *)(*a1 + 8 * v29))
                  {
                    *(void *)(*a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  void *v22 = *v28;
                  void *v28 = **(void **)(*a1 + 8 * v29);
                  **(void **)(*a1 + 8 * v29) = v28;
                  uint64_t v28 = v22;
                }
                unint64_t v29 = v23;
LABEL_55:
                id v22 = v28;
                uint64_t v28 = (void *)*v28;
                unint64_t v23 = v29;
              }
              while (v28);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        id v34 = (void *)*a1;
        *a1 = 0;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v7 = 0;
        a1[1] = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v30 = *a1;
  id v31 = *(void **)(*a1 + 8 * v3);
  if (v31)
  {
    void *v10 = *v31;
LABEL_72:
    *id v31 = v10;
    goto LABEL_73;
  }
  void *v10 = *v12;
  void *v12 = v10;
  *(void *)(v30 + 8 * v3) = v12;
  if (*v10)
  {
    unint64_t v32 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    id v31 = (void *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return v10;
}

void sub_1C2E70(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>,void *>>>::operator()[abi:nn180100](1, v1);
  _Unwind_Resume(a1);
}

void std::vector<objc_object  {objcproto11MTLResource}* {__strong}>::push_back[abi:nn180100](char **a1, void *a2)
{
  unint64_t v5 = a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (v5 - *a1) >> 3;
    if ((unint64_t)(v7 + 1) >> 61) {
      abort();
    }
    uint64_t v8 = v4 - (void)*a1;
    uint64_t v9 = v8 >> 2;
    if (v8 >> 2 <= (unint64_t)(v7 + 1)) {
      uint64_t v9 = v7 + 1;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v9;
    }
    if (v10)
    {
      if (v10 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v11 = (char *)operator new(8 * v10);
    }
    else
    {
      unint64_t v11 = 0;
    }
    uint8x8_t v12 = &v11[8 * v7];
    float v13 = &v11[8 * v10];
    *(void *)uint8x8_t v12 = a2;
    unint64_t v6 = v12 + 8;
    BOOL v15 = *a1;
    float v14 = a1[1];
    if (v14 == *a1)
    {
      int64x2_t v17 = vdupq_n_s64((unint64_t)v14);
    }
    else
    {
      do
      {
        uint64_t v16 = *((void *)v14 - 1);
        v14 -= 8;
        *(void *)float v14 = 0;
        *((void *)v12 - 1) = v16;
        v12 -= 8;
      }
      while (v14 != v15);
      int64x2_t v17 = *(int64x2_t *)a1;
    }
    *a1 = v12;
    a1[1] = v6;
    a1[2] = v13;
    id v19 = (char *)v17.i64[1];
    uint64_t v18 = (char *)v17.i64[0];
    while (v19 != v18)
    {
      id v20 = (void *)*((void *)v19 - 1);
      v19 -= 8;
    }
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *(void *)unint64_t v5 = a2;
    unint64_t v6 = v5 + 8;
  }
  a1[1] = v6;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<GTMTLResourceUsage_uint8_t,std::vector<objc_object  {objcproto11MTLResource}* {__strong}>>,void *>>>::operator()[abi:nn180100](char a1, void **__p)
{
  if (a1)
  {
    unint64_t v3 = __p + 3;
    std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v3);
  }
  if (__p)
  {
    operator delete(__p);
  }
}

void sub_1C30AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1C3194(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void AccelerationStructureViewer::DataSourceQueryEncoder::encodeString(uint64_t a1, uint64_t a2, void *a3)
{
  id v10 = a3;
  id v5 = [v10 smallestEncoding];
  unint64_t v6 = [v10 dataUsingEncoding:v5];
  memset(v11, 0, sizeof(v11));
  std::vector<unsigned char>::__append(v11, (size_t)[v6 length] + 8);
  uint64_t v7 = (void *)v11[0];
  unint64_t v8 = v11[0];
  *(void *)v11[0] = v5;
  id v9 = v6;
  memcpy((void *)(v8 + 8), [v9 bytes], (size_t)[v9 length]);
  (*(void (**)(uint64_t, uint64_t, char *, void *))(*(void *)a1 + 24))(a1, a2, (char *)[v9 length] + 8, v7);
  operator delete(v7);
}

void sub_1C32CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, void *__p)
{
  _Unwind_Resume(a1);
}

void std::vector<unsigned char>::__append(unint64_t *a1, size_t a2)
{
  id v5 = (char *)a1[1];
  unint64_t v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    unint64_t v6 = *a1;
    uint64_t v7 = &v5[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0) {
      abort();
    }
    unint64_t v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (unint64_t)operator new(v10);
    }
    else {
      unint64_t v11 = 0;
    }
    uint8x8_t v12 = &v7[v11];
    float v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      unint64_t v11 = (unint64_t)v12;
    }
    else
    {
      float v14 = &v5[~v6];
      do
      {
        char v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      id v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

uint64_t AccelerationStructureViewer::DataSourceQuerySizeCalculator::encodeObject(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t, uint64_t, void, void))(*(void *)a1 + 24))(a1, a2, 0, 0);
  id v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16);

  return v5(a3, a1);
}

uint64_t AccelerationStructureViewer::DataSourceQuerySizeCalculator::encode(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 16) += a3 + 12;
  return result;
}

uint64_t AccelerationStructureViewer::DataSourceQuerySizeCalculator::push(uint64_t result)
{
  *(void *)(result + 16) += 10;
  return result;
}

void AccelerationStructureViewer::DataSourceQuerySizeCalculator::~DataSourceQuerySizeCalculator(AccelerationStructureViewer::DataSourceQuerySizeCalculator *this)
{
}

uint64_t AccelerationStructureViewer::DataSourceQueryBlobEncoder::pop(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 24);
  if (v1) {
    *(void *)(this + 24) = v1 - 1;
  }
  return this;
}

uint64_t AccelerationStructureViewer::DataSourceQueryBlobEncoder::encodeObject(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[2];
  (*(void (**)(void *, uint64_t, void, void))(*a1 + 24))(a1, a2, 0, 0);
  int v6 = *((_DWORD *)a1 + 4);
  uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)a3 + 16))(a3, a1);
  *(_DWORD *)(a1[132] + v5 + 8) = *((_DWORD *)a1 + 4) - v6;
  return result;
}

void *AccelerationStructureViewer::DataSourceQueryBlobEncoder::encode(void *result, uint64_t a2, size_t a3, void *__src)
{
  uint64_t v4 = result[3];
  if (v4)
  {
    int v6 = result;
    uint64_t v7 = result[132] + result[v4 + 3];
    ++*(void *)(v7 + 2);
    uint64_t v8 = result[132] + result[2];
    *(void *)uint64_t v8 = a2;
    *(_DWORD *)(v8 + 8) = a3;
    uint64_t v9 = result[2] + 12;
    result[2] = v9;
    uint64_t result = memcpy((void *)(result[132] + v9), __src, a3);
    v6[2] += a3;
  }
  return result;
}

void *AccelerationStructureViewer::DataSourceQueryBlobEncoder::push(void *result, __int16 a2)
{
  result[result[3] + 4] = result[2];
  uint64_t v2 = result[2];
  ++result[3];
  uint64_t v3 = result[132] + v2;
  *(_WORD *)uint64_t v3 = a2;
  *(void *)(v3 + 2) = 0;
  result[2] += 10;
  return result;
}

void AccelerationStructureViewer::DataSourceQueryBlobEncoder::~DataSourceQueryBlobEncoder(AccelerationStructureViewer::DataSourceQueryBlobEncoder *this)
{
}

uint64_t AccelerationStructureViewer::DataSourceArray::decode()
{
  return 0;
}

uint64_t AccelerationStructureViewer::DataSourceArray::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, void))(*(void *)a2 + 16))(a2, 0);
  unint64_t v6 = (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3;
  (*(void (**)(uint64_t, void, uint64_t, unint64_t *))(*(void *)a2 + 24))(a2, 0, 8, &v6);
  if (v6)
  {
    for (unint64_t i = 0; i < v6; ++i)
      (*(void (**)(uint64_t, unint64_t, void))(*(void *)a2 + 40))(a2, i + 100000, *(void *)(*(void *)(a1 + 8) + 8 * i));
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
}

void AccelerationStructureViewer::DataSourceArray::~DataSourceArray(AccelerationStructureViewer::DataSourceArray *this)
{
  AccelerationStructureViewer::DataSourceArray::~DataSourceArray(this);

  operator delete();
}

{
  void *v2;
  void *v3;

  *(void *)this = off_7441F8;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }
}

uint64_t AccelerationStructureViewer::DataSourceArray_StrongRef::decode(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a3 >> 5 < 0xC35)
  {
    if (a3) {
      return 1;
    }
    unint64_t v6 = *(void *)a2 + 8;
    if (v6 > *(void *)(a2 + 16))
    {
      uint64_t result = 0;
      *(unsigned char *)(a2 + 24) = 1;
      return result;
    }
    unint64_t v7 = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
    *(void *)a2 = v6;
    uint64_t v8 = *(void *)(a1 + 8);
    uint64_t v9 = *(void *)(a1 + 16);
    unint64_t v10 = (v9 - v8) >> 3;
    if (v7 <= v10)
    {
      if (v7 >= v10) {
        goto LABEL_27;
      }
      uint64_t v24 = v8 + 8 * v7;
    }
    else
    {
      unint64_t v11 = v7 - v10;
      uint64_t v12 = *(void *)(a1 + 24);
      if (v7 - v10 > (v12 - v9) >> 3)
      {
        if (v7 >> 61) {
          goto LABEL_49;
        }
        uint64_t v13 = v12 - v8;
        uint64_t v14 = v13 >> 2;
        if (v13 >> 2 <= v7) {
          uint64_t v14 = v7;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v15 = v14;
        }
        uint64_t v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v15);
        int64x2_t v17 = &v16[8 * v10];
        id v19 = &v16[8 * v18];
        bzero(v17, 8 * v11);
        id v20 = &v17[8 * v11];
        id v22 = *(char **)(a1 + 8);
        uint64_t v21 = *(char **)(a1 + 16);
        if (v21 != v22)
        {
          do
          {
            uint64_t v23 = *((void *)v21 - 1);
            v21 -= 8;
            *((void *)v17 - 1) = v23;
            v17 -= 8;
          }
          while (v21 != v22);
          uint64_t v21 = *(char **)(a1 + 8);
        }
        *(void *)(a1 + 8) = v17;
        *(void *)(a1 + 16) = v20;
        *(void *)(a1 + 24) = v19;
        if (v21) {
          operator delete(v21);
        }
LABEL_27:
        unint64_t v25 = *(char **)(a1 + 32);
        uint8x8_t v26 = *(unsigned char **)(a1 + 40);
        unint64_t v27 = (v26 - v25) >> 1;
        if (v7 <= v27)
        {
          if (v7 < v27) {
            *(void *)(a1 + 40) = &v25[2 * v7];
          }
LABEL_45:
          if (!v7) {
            return 1;
          }
LABEL_46:
          uint64_t v38 = 0;
          do
          {
            *(void *)(*(void *)(a1 + 8) + 8 * v38) = 0;
            *(_WORD *)(*(void *)(a1 + 32) + 2 * v38++) = 16;
          }
          while (v7 != v38);
          return 1;
        }
        unint64_t v28 = v7 - v27;
        uint64_t v29 = *(void *)(a1 + 48);
        if (v7 - v27 <= (v29 - (uint64_t)v26) >> 1)
        {
          bzero(*(void **)(a1 + 40), 2 * v28);
          *(void *)(a1 + 40) = &v26[2 * v28];
          goto LABEL_46;
        }
        if ((v7 & 0x8000000000000000) == 0)
        {
          unint64_t v30 = v29 - (void)v25;
          if (v30 <= v7) {
            unint64_t v31 = v7;
          }
          else {
            unint64_t v31 = v30;
          }
          if (v30 >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v32 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v32 = v31;
          }
          if (v32 < 0) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unint64_t v33 = (char *)operator new(2 * v32);
          id v34 = &v33[2 * v27];
          uint64_t v35 = &v33[2 * v32];
          bzero(v34, 2 * v28);
          int v36 = &v34[2 * v28];
          while (v26 != v25)
          {
            __int16 v37 = *((_WORD *)v26 - 1);
            v26 -= 2;
            *((_WORD *)v34 - 1) = v37;
            v34 -= 2;
          }
          *(void *)(a1 + 32) = v34;
          *(void *)(a1 + 40) = v36;
          *(void *)(a1 + 48) = v35;
          if (v25) {
            operator delete(v25);
          }
          goto LABEL_45;
        }
LABEL_49:
        abort();
      }
      bzero(*(void **)(a1 + 16), 8 * v11);
      uint64_t v24 = v9 + 8 * v11;
    }
    *(void *)(a1 + 16) = v24;
    goto LABEL_27;
  }
  unint64_t v4 = a3 - 100000;
  if (a3 - 100000 < (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3)
  {
    __int16 v39 = 0;
    *(void *)(*(void *)(a1 + 8) + 8 * v4) = AccelerationStructureViewer::DataSourceQueryBlobDecoder::decode(a2, &v39);
    *(_WORD *)(*(void *)(a1 + 32) + 2 * v4) = v39;
    return 1;
  }
  return 0;
}

uint64_t AccelerationStructureViewer::DataSourceQueryBlobDecoder::decode(uint64_t a1, _WORD *a2)
{
  unint64_t v2 = *(void *)a1 + 10;
  if (v2 <= *(void *)(a1 + 16))
  {
    int v3 = *(unsigned __int16 *)(*(void *)(a1 + 8) + *(void *)a1);
    *(void *)a1 = v2;
    if (a2) {
      *a2 = v3;
    }
    switch(v3)
    {
      case 0:
        operator new();
      case 1:
        operator new();
      case 2:
        operator new();
      case 3:
        operator new();
      case 4:
        operator new();
      case 5:
        operator new();
      case 6:
        operator new();
      case 7:
        operator new();
      case 8:
        operator new();
      case 9:
        operator new();
      case 10:
        operator new();
      case 11:
        operator new();
      case 12:
        operator new();
      case 13:
        operator new();
      case 14:
        operator new();
      case 15:
        operator new();
      case 17:
        operator new();
      case 18:
        operator new();
      case 19:
        operator new();
      case 20:
        operator new();
      case 21:
        operator new();
      case 22:
        operator new();
      case 23:
        operator new();
      default:
        return 0;
    }
  }
  else
  {
    *(unsigned char *)(a1 + 24) = 1;
  }
  return 0;
}

void sub_1C4334(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t AccelerationStructureViewer::Primitive::decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 <= 17)
  {
    switch(a3)
    {
      case 2:
        unint64_t v12 = *(void *)a2 + 2;
        if (v12 > *(void *)(a2 + 16)) {
          goto LABEL_42;
        }
        int v13 = *(unsigned __int16 *)(*(void *)(a2 + 8) + *(void *)a2);
        *(void *)a2 = v12;
        *(_DWORD *)(a1 + 32) = v13;
        break;
      case 3:
        if ((unint64_t)(*(void *)a2 + 4) <= *(void *)(a2 + 16))
        {
          *(_DWORD *)(a1 + 40) = *(_DWORD *)(*(void *)(a2 + 8) + *(void *)a2);
LABEL_66:
          uint64_t v11 = *(void *)a2 + 4;
LABEL_67:
          *(void *)a2 = v11;
          return 1;
        }
LABEL_42:
        uint64_t result = 0;
        *(unsigned char *)(a2 + 24) = 1;
        return result;
      case 11:
        if ((unint64_t)(*(void *)a2 + 4) <= *(void *)(a2 + 16))
        {
          *(_DWORD *)(a1 + 56) = *(_DWORD *)(*(void *)(a2 + 8) + *(void *)a2);
          goto LABEL_66;
        }
        goto LABEL_42;
    }
    return 1;
  }
  switch(a3)
  {
    case 18:
      __int16 v29 = 0;
      uint64_t v4 = AccelerationStructureViewer::DataSourceQueryBlobDecoder::decode(a2, &v29);
      uint64_t v5 = (void *)v4;
      if (v4) {
        BOOL v6 = v29 == 0;
      }
      else {
        BOOL v6 = 0;
      }
      char v7 = !v6;
      char v28 = v7;
      if (v6)
      {
        uint64_t v16 = *(uint64_t **)(v4 + 8);
        unint64_t v15 = *(uint64_t **)(v4 + 16);
        if (v16 != v15)
        {
          int64x2_t v17 = (void *)(a1 + 104);
          uint64_t v18 = *(uint64_t **)(v4 + 8);
          do
          {
            if (*(_WORD *)(v5[4] + (((uint64_t)v16 - v5[1]) >> 2)) == 11)
            {
              uint64_t v19 = *v18;
              unint64_t v21 = *(void *)(a1 + 112);
              unint64_t v20 = *(void *)(a1 + 120);
              if (v21 >= v20)
              {
                unint64_t v23 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v21 - *v17) >> 3);
                unint64_t v24 = v23 + 1;
                if (v23 + 1 > 0x222222222222222) {
                  abort();
                }
                unint64_t v25 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v20 - *v17) >> 3);
                if (2 * v25 > v24) {
                  unint64_t v24 = 2 * v25;
                }
                if (v25 >= 0x111111111111111) {
                  unint64_t v26 = 0x222222222222222;
                }
                else {
                  unint64_t v26 = v24;
                }
                uint64_t v34 = a1 + 120;
                if (v26) {
                  unint64_t v26 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::Property>>(v26);
                }
                else {
                  uint64_t v27 = 0;
                }
                unint64_t v30 = v26;
                uint64_t v31 = v26 + 120 * v23;
                uint64_t v32 = v31;
                unint64_t v33 = v26 + 120 * v27;
                std::allocator<AccelerationStructureViewer::Property>::construct[abi:nn180100]<AccelerationStructureViewer::Property,AccelerationStructureViewer::Property const&>(v31, v19);
                v32 += 120;
                std::vector<AccelerationStructureViewer::Property>::__swap_out_circular_buffer((uint64_t *)(a1 + 104), &v30);
                unint64_t v22 = *(void *)(a1 + 112);
                std::__split_buffer<AccelerationStructureViewer::Property>::~__split_buffer((uint64_t)&v30);
              }
              else
              {
                std::allocator<AccelerationStructureViewer::Property>::construct[abi:nn180100]<AccelerationStructureViewer::Property,AccelerationStructureViewer::Property const&>(*(void *)(a1 + 112), *v18);
                unint64_t v22 = v21 + 120;
                *(void *)(a1 + 112) = v21 + 120;
              }
              *(void *)(a1 + 112) = v22;
              unint64_t v15 = (uint64_t *)v5[2];
            }
            ++v18;
            ++v16;
          }
          while (v18 != v15);
        }
      }
      else if (!v4)
      {
        goto LABEL_64;
      }
      (*(void (**)(void *))(*v5 + 8))(v5);
      if (v28) {
        goto LABEL_64;
      }
      return 1;
    case 28:
      LOWORD(v30) = 0;
      uint64_t result = AccelerationStructureViewer::DataSourceQueryBlobDecoder::decode(a2, &v30);
      if (result) {
        BOOL v9 = (unsigned __int16)v30 == 15;
      }
      else {
        BOOL v9 = 0;
      }
      char v10 = !v9;
      if (v9)
      {
        long long v14 = *(_OWORD *)(result + 8);
        *(void *)(a1 + 92) = *(void *)(result + 24);
        *(_OWORD *)(a1 + 76) = v14;
      }
      else if (!result)
      {
        return result;
      }
      (*(void (**)(uint64_t))(*(void *)result + 8))(result);
      if ((v10 & 1) == 0) {
        return 1;
      }
LABEL_64:
      uint64_t result = 0;
      break;
    case 32:
      if ((unint64_t)(*(void *)a2 + 4) > *(void *)(a2 + 16)) {
        goto LABEL_42;
      }
      *(_DWORD *)(a1 + 48) = *(_DWORD *)(*(void *)(a2 + 8) + *(void *)a2);
      goto LABEL_66;
    case 33:
      if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
        goto LABEL_42;
      }
      *(void *)(a1 + 64) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
      goto LABEL_38;
    case 34:
      if ((unint64_t)(*(void *)a2 + 4) > *(void *)(a2 + 16)) {
        goto LABEL_42;
      }
      *(_DWORD *)(a1 + 72) = *(_DWORD *)(*(void *)(a2 + 8) + *(void *)a2);
      goto LABEL_66;
    case 35:
      if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
        goto LABEL_42;
      }
      *(void *)(a1 + 40) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
      goto LABEL_38;
    case 36:
      if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
        goto LABEL_42;
      }
      *(void *)(a1 + 48) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
      goto LABEL_38;
    case 37:
      if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
        goto LABEL_42;
      }
      *(void *)(a1 + 56) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
LABEL_38:
      uint64_t v11 = *(void *)a2 + 8;
      goto LABEL_67;
    default:
      return 1;
  }
  return result;
}

void sub_1C47C8(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

char *std::allocator<AccelerationStructureViewer::Property>::construct[abi:nn180100]<AccelerationStructureViewer::Property,AccelerationStructureViewer::Property const&>(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_7474F0;
  __int16 v4 = *(_WORD *)(a2 + 8);
  *(unsigned char *)(a1 + 10) = *(unsigned char *)(a2 + 10);
  *(_WORD *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = *(id *)(a2 + 16);
  long long v5 = *(_OWORD *)(a2 + 40);
  long long v6 = *(_OWORD *)(a2 + 56);
  long long v7 = *(_OWORD *)(a2 + 72);
  uint64_t v8 = *(void *)(a2 + 88);
  long long v9 = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 24) = v9;
  *(void *)(a1 + 88) = v8;
  *(_OWORD *)(a1 + 72) = v7;
  *(_OWORD *)(a1 + 56) = v6;
  *(_OWORD *)(a1 + 40) = v5;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  return std::vector<NSString * {__strong}>::__init_with_size[abi:nn180100]<NSString * {__strong}*,NSString * {__strong}*>((char *)(a1 + 96), *(void ***)(a2 + 96), *(void ***)(a2 + 104), (uint64_t)(*(void *)(a2 + 104) - *(void *)(a2 + 96)) >> 3);
}

void sub_1C490C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *std::vector<AccelerationStructureViewer::Property>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      uint64_t v7 = v2 + v5;
      *(void *)(v6 - 120) = off_7474F0;
      __int16 v8 = *(_WORD *)(v2 + v5 - 112);
      *(unsigned char *)(v6 - 110) = *(unsigned char *)(v2 + v5 - 110);
      *(_WORD *)(v6 - 112) = v8;
      uint64_t v9 = *(void *)(v2 + v5 - 104);
      *(void *)(v7 - 104) = 0;
      *(void *)(v6 - 104) = v9;
      *(_OWORD *)(v6 - 96) = *(_OWORD *)(v2 + v5 - 96);
      long long v10 = *(_OWORD *)(v2 + v5 - 80);
      long long v11 = *(_OWORD *)(v2 + v5 - 48);
      uint64_t v12 = *(void *)(v2 + v5 - 32);
      *(_OWORD *)(v6 - 64) = *(_OWORD *)(v2 + v5 - 64);
      *(_OWORD *)(v6 - 48) = v11;
      *(_OWORD *)(v6 - 80) = v10;
      *(void *)(v6 - 32) = v12;
      *(void *)(v6 - 24) = 0;
      *(void *)(v6 - 16) = 0;
      *(void *)(v6 - 8) = 0;
      *(_OWORD *)(v6 - 24) = *(_OWORD *)(v2 + v5 - 24);
      *(void *)(v6 - 8) = *(void *)(v2 + v5 - 8);
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      v5 -= 120;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v13 = *result;
  *uint64_t result = v4;
  a2[1] = v13;
  uint64_t v14 = result[1];
  result[1] = a2[2];
  a2[2] = v14;
  uint64_t v15 = result[2];
  result[2] = a2[3];
  a2[3] = v15;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<AccelerationStructureViewer::Property>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void (***)(void))(i - 120);
    *(void *)(a1 + 16) = i - 120;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t AccelerationStructureViewer::CurvePrimitive::encode(uint64_t a1, void *a2)
{
  (*(void (**)(void *, uint64_t))(*a2 + 16))(a2, 23);
  AccelerationStructureViewer::Primitive::encode(a1, a2);
  uint64_t v4 = *(uint64_t (**)(void *))(*a2 + 48);

  return v4(a2);
}

void AccelerationStructureViewer::Primitive::encode(uint64_t a1, void *a2)
{
  __int16 v23 = *(_DWORD *)(a1 + 32);
  (*(void (**)(void *, uint64_t, uint64_t, __int16 *))(*a2 + 24))(a2, 2, 2, &v23);
  uint64_t v4 = a1 + 40;
  uint64_t v5 = *(void (**)(void *, uint64_t, uint64_t, uint64_t))(*a2 + 24);
  if (a2[1] < 0xAuLL)
  {
    v5(a2, 3, 4, v4);
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(*a2 + 24))(a2, 32, 4, a1 + 48);
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(*a2 + 24))(a2, 11, 4, a1 + 56);
  }
  else
  {
    v5(a2, 35, 8, v4);
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(*a2 + 24))(a2, 36, 8, a1 + 48);
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(*a2 + 24))(a2, 37, 8, a1 + 56);
  }
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(*a2 + 24))(a2, 33, 8, a1 + 64);
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(*a2 + 24))(a2, 34, 4, a1 + 72);
  unint64_t v20 = off_744460;
  long long v21 = *(_OWORD *)(a1 + 76);
  uint64_t v22 = *(void *)(a1 + 92);
  (*(void (**)(void *, uint64_t, void (***)(AccelerationStructureViewer::BoundingBox *__hidden)))(*a2 + 40))(a2, 28, &v20);
  uint64_t v16 = off_7441F8;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  uint64_t v6 = *(void *)(a1 + 104);
  if (v6 != *(void *)(a1 + 112))
  {
    uint64_t v7 = 0;
    do
    {
      if ((unint64_t)v7 >= (unint64_t)v18)
      {
        uint64_t v8 = (uint64_t)((uint64_t)v7 - v17) >> 3;
        if ((unint64_t)(v8 + 1) >> 61) {
          abort();
        }
        unint64_t v9 = (uint64_t)(v18 - v17) >> 2;
        if (v9 <= v8 + 1) {
          unint64_t v9 = v8 + 1;
        }
        if ((void)v18 - (void)v17 >= 0x7FFFFFFFFFFFFFF8uLL) {
          unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v10 = v9;
        }
        if (v10) {
          unint64_t v10 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v10);
        }
        else {
          uint64_t v11 = 0;
        }
        uint64_t v12 = (void *)(v10 + 8 * v8);
        void *v12 = v6;
        uint64_t v7 = v12 + 1;
        uint64_t v13 = (char *)*((void *)&v17 + 1);
        uint64_t v14 = (char *)v17;
        if (*((void *)&v17 + 1) != (void)v17)
        {
          do
          {
            uint64_t v15 = *((void *)v13 - 1);
            v13 -= 8;
            *--uint64_t v12 = v15;
          }
          while (v13 != v14);
          uint64_t v13 = (char *)v17;
        }
        *(void *)&long long v17 = v12;
        *((void *)&v17 + 1) = v7;
        *(void *)&long long v18 = v10 + 8 * v11;
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        *v7++ = v6;
      }
      *((void *)&v17 + 1) = v7;
      v6 += 120;
    }
    while (v6 != *(void *)(a1 + 112));
  }
  (*(void (**)(void *, uint64_t, void (***)(AccelerationStructureViewer::DataSourceArray *__hidden)))(*a2 + 40))(a2, 18, &v16);
  AccelerationStructureViewer::DataSourceArray::~DataSourceArray((AccelerationStructureViewer::DataSourceArray *)&v16);
}

void sub_1C4E94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void AccelerationStructureViewer::CurvePrimitive::~CurvePrimitive(AccelerationStructureViewer::CurvePrimitive *this)
{
  *(void *)this = off_7445E8;
  uint64_t v1 = (void **)((char *)this + 8);
  uint64_t v2 = (void **)((char *)this + 104);
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = v1;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v2);

  operator delete();
}

{
  void **v1;
  void **v2;

  *(void *)this = off_7445E8;
  uint64_t v1 = (void **)((char *)this + 8);
  uint64_t v2 = (void **)((char *)this + 104);
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = v1;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

void AccelerationStructureViewer::Primitive::~Primitive(AccelerationStructureViewer::Primitive *this)
{
  *(void *)this = off_7445E8;
  uint64_t v1 = (void **)((char *)this + 8);
  uint64_t v2 = (void **)((char *)this + 104);
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = v1;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v2);

  operator delete();
}

{
  void **v1;
  void **v2;

  *(void *)this = off_7445E8;
  uint64_t v1 = (void **)((char *)this + 8);
  uint64_t v2 = (void **)((char *)this + 104);
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = v1;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

uint64_t AccelerationStructureViewer::BoundingBoxPrimitive::encode(uint64_t a1, void *a2)
{
  (*(void (**)(void *, uint64_t))(*a2 + 16))(a2, 21);
  AccelerationStructureViewer::Primitive::encode(a1, a2);
  uint64_t v4 = *(uint64_t (**)(void *))(*a2 + 48);

  return v4(a2);
}

void AccelerationStructureViewer::BoundingBoxPrimitive::~BoundingBoxPrimitive(AccelerationStructureViewer::BoundingBoxPrimitive *this)
{
  *(void *)this = off_7445E8;
  uint64_t v1 = (void **)((char *)this + 8);
  uint64_t v2 = (void **)((char *)this + 104);
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = v1;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v2);

  operator delete();
}

{
  void **v1;
  void **v2;

  *(void *)this = off_7445E8;
  uint64_t v1 = (void **)((char *)this + 8);
  uint64_t v2 = (void **)((char *)this + 104);
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = v1;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

uint64_t AccelerationStructureViewer::TrianglePrimitive::encode(uint64_t a1, void *a2)
{
  (*(void (**)(void *, uint64_t))(*a2 + 16))(a2, 20);
  AccelerationStructureViewer::Primitive::encode(a1, a2);
  uint64_t v4 = *(uint64_t (**)(void *))(*a2 + 48);

  return v4(a2);
}

void AccelerationStructureViewer::TrianglePrimitive::~TrianglePrimitive(AccelerationStructureViewer::TrianglePrimitive *this)
{
  *(void *)this = off_7445E8;
  uint64_t v1 = (void **)((char *)this + 8);
  uint64_t v2 = (void **)((char *)this + 104);
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = v1;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v2);

  operator delete();
}

{
  void **v1;
  void **v2;

  *(void *)this = off_7445E8;
  uint64_t v1 = (void **)((char *)this + 8);
  uint64_t v2 = (void **)((char *)this + 104);
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = v1;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

uint64_t AccelerationStructureViewer::InvalidPrimitive::encode(uint64_t a1, void *a2)
{
  (*(void (**)(void *, uint64_t))(*a2 + 16))(a2, 19);
  AccelerationStructureViewer::Primitive::encode(a1, a2);
  uint64_t v4 = *(uint64_t (**)(void *))(*a2 + 48);

  return v4(a2);
}

void AccelerationStructureViewer::InvalidPrimitive::~InvalidPrimitive(AccelerationStructureViewer::InvalidPrimitive *this)
{
  *(void *)this = off_7445E8;
  uint64_t v1 = (void **)((char *)this + 8);
  uint64_t v2 = (void **)((char *)this + 104);
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = v1;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v2);

  operator delete();
}

{
  void **v1;
  void **v2;

  *(void *)this = off_7445E8;
  uint64_t v1 = (void **)((char *)this + 8);
  uint64_t v2 = (void **)((char *)this + 104);
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = v1;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

uint64_t AccelerationStructureViewer::BoundingBox::decode(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a3 >> 5 >= 0xC35)
  {
    if (a3 - 100000 > 5) {
      return 0;
    }
    if ((unint64_t)(*(void *)a2 + 4) > *(void *)(a2 + 16))
    {
      uint64_t result = 0;
      *(unsigned char *)(a2 + 24) = 1;
      return result;
    }
    *(_DWORD *)(a1 + 4 * (a3 - 100000) + 8) = *(_DWORD *)(*(void *)(a2 + 8) + *(void *)a2);
    *(void *)a2 += 4;
  }
  return 1;
}

uint64_t AccelerationStructureViewer::BoundingBox::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 15);
  uint64_t v4 = 0;
  uint64_t v5 = a1 + 8;
  do
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, v4 + 100000, 4, v5);
    ++v4;
    v5 += 4;
  }
  while (v4 != 6);
  uint64_t v6 = *(uint64_t (**)(uint64_t))(*(void *)a2 + 48);

  return v6(a2);
}

void AccelerationStructureViewer::BoundingBox::~BoundingBox(AccelerationStructureViewer::BoundingBox *this)
{
}

uint64_t AccelerationStructureViewer::DataSourceQueryRequest_StrongRef::decode(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = 1;
  switch(a3)
  {
    case 23:
      if (a4 != 8) {
        return 0;
      }
      if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
        goto LABEL_18;
      }
      a1[1] = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
      goto LABEL_21;
    case 24:
      if (a4 != 8) {
        return 0;
      }
      if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
        goto LABEL_18;
      }
      a1[3] = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
      goto LABEL_21;
    case 25:
      if (a4 != 8) {
        return 0;
      }
      if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
        goto LABEL_18;
      }
      a1[4] = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
      goto LABEL_21;
    case 26:
      __int16 v6 = 12;
      a1[5] = AccelerationStructureViewer::DataSourceQueryBlobDecoder::decode(a2, &v6);
      return 1;
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
      return result;
    case 32:
      if (a4 != 8) {
        return 0;
      }
      if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
        goto LABEL_18;
      }
      a1[6] = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
      goto LABEL_21;
    default:
      if (a3 != 3) {
        return result;
      }
      if (a4 != 8) {
        return 0;
      }
      if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16))
      {
LABEL_18:
        uint64_t result = 0;
        *(unsigned char *)(a2 + 24) = 1;
      }
      else
      {
        a1[2] = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
LABEL_21:
        *(void *)a2 += 8;
      }
      return result;
  }
}

uint64_t AccelerationStructureViewer::DataSourceQueryRequest::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 14);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 3, 8, a1 + 16);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 32, 8, a1 + 48);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 23, 8, a1 + 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 24, 8, a1 + 24);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 25, 8, a1 + 32);
  if (*(void *)(a1 + 40)) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, 26);
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)a2 + 48);

  return v4(a2);
}

void AccelerationStructureViewer::DataSourceQueryRequest_StrongRef::~DataSourceQueryRequest_StrongRef(AccelerationStructureViewer::DataSourceQueryRequest_StrongRef *this)
{
  *(void *)this = off_744770;
  uint64_t v1 = *((void *)this + 5);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  operator delete();
}

{
  uint64_t v1;

  *(void *)this = off_744770;
  uint64_t v1 = *((void *)this + 5);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

BOOL AccelerationStructureViewer::FilterToken::decode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 == 2)
  {
    if (a4 != 2) {
      return 0;
    }
    uint64_t v4 = *(void *)a2;
    if ((unint64_t)(*(void *)a2 + 2) <= *(void *)(a2 + 16))
    {
      uint64_t v5 = (_WORD *)(a1 + 10);
      goto LABEL_14;
    }
LABEL_11:
    BOOL result = 0;
    *(unsigned char *)(a2 + 24) = 1;
    return result;
  }
  if (a3 != 27) {
    return a3 != 22
  }
        || (AccelerationStructureViewer::DataSourceQueryBlobDecoder::consumeString((uint64_t *)a2, (void **)(a1 + 16), a4) & 1) != 0;
  if (a4 != 2) {
    return 0;
  }
  uint64_t v4 = *(void *)a2;
  if ((unint64_t)(*(void *)a2 + 2) > *(void *)(a2 + 16)) {
    goto LABEL_11;
  }
  uint64_t v5 = (_WORD *)(a1 + 8);
LABEL_14:
  _WORD *v5 = *(_WORD *)(*(void *)(a2 + 8) + v4);
  *(void *)a2 += 2;
  return 1;
}

uint64_t AccelerationStructureViewer::DataSourceQueryBlobDecoder::consumeString(uint64_t *a1, void **a2, uint64_t a3)
{
  uint64_t v4 = *a1;
  unint64_t v5 = a1[2];
  if (*a1 + a3 <= v5 && v4 + 8 <= v5)
  {
    uint64_t v9 = *(void *)(a1[1] + v4);
    *a1 = v4 + 8;
    size_t v10 = a3 - 8;
    if (a3 != 8)
    {
      memset(__dst, 0, sizeof(__dst));
      std::vector<unsigned char>::__append((unint64_t *)__dst, a3 - 8);
      size_t v12 = a1[2];
      size_t v13 = *a1 + v10;
      BOOL v6 = v13 <= v12;
      if (v13 > v12)
      {
        *((unsigned char *)a1 + 24) = 1;
        uint64_t v14 = __dst[0];
        if (!__dst[0]) {
          return v6;
        }
      }
      else
      {
        uint64_t v14 = __dst[0];
        memcpy(__dst[0], (const void *)(a1[1] + *a1), v10);
        *a1 += v10;
        uint64_t v15 = +[NSData dataWithBytes:v14 length:v10];
        id v16 = [objc_alloc((Class)NSString) initWithData:v15 encoding:v9];
        long long v17 = *a2;
        *a2 = v16;

        if (!v14) {
          return v6;
        }
      }
      operator delete(v14);
      return v6;
    }
    uint64_t v11 = *a2;
    *a2 = &stru_7482F0;

    return 1;
  }
  else
  {
    BOOL v6 = 0;
    *((unsigned char *)a1 + 24) = 1;
  }
  return v6;
}

void sub_1C5CF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    operator delete(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AccelerationStructureViewer::FilterToken::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 13);
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 32))(a2, 22, *(void *)(a1 + 16));
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 2, 2, a1 + 10);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 27, 2, a1 + 8);
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)a2 + 48);

  return v4(a2);
}

void AccelerationStructureViewer::FilterToken::~FilterToken(id *this)
{
  operator delete();
}

{
}

uint64_t AccelerationStructureViewer::Filter::decode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 == 21)
  {
    __int16 v36 = 0;
    uint64_t v6 = AccelerationStructureViewer::DataSourceQueryBlobDecoder::decode(a2, &v36);
    uint64_t v7 = (void *)v6;
    if (v6) {
      BOOL v8 = v36 == 0;
    }
    else {
      BOOL v8 = 0;
    }
    char v9 = !v8;
    char v35 = v9;
    if (v8)
    {
      uint64_t v11 = *(uint64_t **)(v6 + 8);
      for (uint64_t i = *(uint64_t **)(v6 + 16); v11 != i; ++v11)
      {
        if (*(_WORD *)(v7[4] + (((uint64_t)v11 - v7[1]) >> 2)) == 13)
        {
          uint64_t v12 = *v11;
          unint64_t v14 = *(void *)(a1 + 24);
          unint64_t v13 = *(void *)(a1 + 32);
          if (v14 >= v13)
          {
            uint64_t v16 = *(void *)(a1 + 16);
            unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - v16) >> 3);
            unint64_t v18 = v17 + 1;
            if (v17 + 1 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - v16) >> 3);
            if (2 * v19 > v18) {
              unint64_t v18 = 2 * v19;
            }
            if (v19 >= 0x555555555555555) {
              unint64_t v20 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v20 = v18;
            }
            if (v20)
            {
              uint64_t v22 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v20);
            }
            else
            {
              uint64_t v22 = 0;
              uint64_t v21 = 0;
            }
            __int16 v23 = &v22[24 * v17];
            unint64_t v24 = &v22[24 * v21];
            *(void *)__int16 v23 = off_747810;
            *((_DWORD *)v23 + 2) = *(_DWORD *)(v12 + 8);
            *((void *)v23 + 2) = *(id *)(v12 + 16);
            uint64_t v15 = v23 + 24;
            unint64_t v25 = *(char **)(a1 + 16);
            unint64_t v26 = *(char **)(a1 + 24);
            if (v26 == v25)
            {
              *(void *)(a1 + 16) = v23;
              *(void *)(a1 + 24) = v15;
              *(void *)(a1 + 32) = v24;
            }
            else
            {
              uint64_t v27 = 0;
              do
              {
                char v28 = &v23[v27];
                *((void *)v28 - 3) = off_747810;
                *((_DWORD *)v28 - 4) = *(_DWORD *)&v26[v27 - 16];
                uint64_t v29 = *(void *)&v26[v27 - 8];
                *(void *)&v26[v27 - 8] = 0;
                *((void *)v28 - 1) = v29;
                v27 -= 24;
              }
              while (&v26[v27] != v25);
              unint64_t v26 = *(char **)(a1 + 16);
              unint64_t v30 = *(char **)(a1 + 24);
              *(void *)(a1 + 16) = &v23[v27];
              *(void *)(a1 + 24) = v15;
              *(void *)(a1 + 32) = v24;
              if (v30 == v26)
              {
                unint64_t v26 = v30;
              }
              else
              {
                uint64_t v31 = v30 - 24;
                uint64_t v32 = v30 - 24;
                unint64_t v33 = (void (***)(char *))(v30 - 24);
                do
                {
                  uint64_t v34 = *v33;
                  v33 -= 3;
                  (*v34)(v32);
                  v31 -= 24;
                  BOOL v8 = v32 == v26;
                  uint64_t v32 = (char *)v33;
                }
                while (!v8);
              }
            }
            if (v26) {
              operator delete(v26);
            }
          }
          else
          {
            *(void *)unint64_t v14 = off_747810;
            *(_DWORD *)(v14 + 8) = *(_DWORD *)(v12 + 8);
            *(void *)(v14 + 16) = *(id *)(v12 + 16);
            uint64_t v15 = (char *)(v14 + 24);
          }
          *(void *)(a1 + 24) = v15;
          uint64_t i = (uint64_t *)v7[2];
        }
      }
    }
    else if (!v6)
    {
      return 0;
    }
    (*(void (**)(void *))(*v7 + 8))(v7);
    if (v35) {
      return 0;
    }
  }
  else if (a3 == 2)
  {
    if (a4 == 1)
    {
      if ((unint64_t)(*(void *)a2 + 1) > *(void *)(a2 + 16))
      {
        uint64_t result = 0;
        *(unsigned char *)(a2 + 24) = 1;
        return result;
      }
      *(unsigned char *)(a1 + 8) = *(unsigned char *)(*(void *)(a2 + 8) + (*(void *)a2)++);
      return 1;
    }
    return 0;
  }
  return 1;
}

void sub_1C61F4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void AccelerationStructureViewer::Filter::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 12);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 2, 1, a1 + 8);
  unint64_t v14 = off_7441F8;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4 != *(void *)(a1 + 24))
  {
    unint64_t v5 = 0;
    do
    {
      if ((unint64_t)v5 >= (unint64_t)v16)
      {
        uint64_t v6 = (uint64_t)((uint64_t)v5 - v15) >> 3;
        if ((unint64_t)(v6 + 1) >> 61) {
          abort();
        }
        unint64_t v7 = (uint64_t)(v16 - v15) >> 2;
        if (v7 <= v6 + 1) {
          unint64_t v7 = v6 + 1;
        }
        if ((void)v16 - (void)v15 >= 0x7FFFFFFFFFFFFFF8uLL) {
          unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v8 = v7;
        }
        if (v8) {
          unint64_t v8 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v8);
        }
        else {
          uint64_t v9 = 0;
        }
        size_t v10 = (void *)(v8 + 8 * v6);
        void *v10 = v4;
        unint64_t v5 = v10 + 1;
        uint64_t v11 = (char *)*((void *)&v15 + 1);
        uint64_t v12 = (char *)v15;
        if (*((void *)&v15 + 1) != (void)v15)
        {
          do
          {
            uint64_t v13 = *((void *)v11 - 1);
            v11 -= 8;
            *--size_t v10 = v13;
          }
          while (v11 != v12);
          uint64_t v11 = (char *)v15;
        }
        *(void *)&long long v15 = v10;
        *((void *)&v15 + 1) = v5;
        *(void *)&long long v16 = v8 + 8 * v9;
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *v5++ = v4;
      }
      *((void *)&v15 + 1) = v5;
      v4 += 24;
    }
    while (v4 != *(void *)(a1 + 24));
  }
  (*(void (**)(uint64_t, uint64_t, void (***)(AccelerationStructureViewer::DataSourceArray *__hidden)))(*(void *)a2 + 40))(a2, 21, &v14);
  (*(void (**)(uint64_t))(*(void *)a2 + 48))(a2);
  AccelerationStructureViewer::DataSourceArray::~DataSourceArray((AccelerationStructureViewer::DataSourceArray *)&v14);
}

void sub_1C6420(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  AccelerationStructureViewer::DataSourceArray::~DataSourceArray((AccelerationStructureViewer::DataSourceArray *)va);
  _Unwind_Resume(a1);
}

uint64_t AccelerationStructureViewer::Property::decode(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a3 >> 5 < 0xC35)
  {
    switch(a3)
    {
      case 0x14uLL:
        switch(*(unsigned char *)(a1 + 10))
        {
          case 0:
            return (AccelerationStructureViewer::DataSourceQueryBlobDecoder::consumeString((uint64_t *)a2, (void **)(a1 + 16), a4) & 1) != 0;
          case 1:
            if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
              goto LABEL_17;
            }
            *(void *)(a1 + 32) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
            uint64_t v9 = *(void *)a2 + 8;
            goto LABEL_30;
          case 2:
            if ((unint64_t)(*(void *)a2 + 4) > *(void *)(a2 + 16)) {
              goto LABEL_17;
            }
            *(_DWORD *)(a1 + 24) = *(_DWORD *)(*(void *)(a2 + 8) + *(void *)a2);
            goto LABEL_7;
          case 3:
            unint64_t v30 = *(void *)a2 + 1;
            if (v30 > *(void *)(a2 + 16)) {
              goto LABEL_17;
            }
            int v31 = *(unsigned __int8 *)(*(void *)(a2 + 8) + *(void *)a2);
            *(void *)a2 = v30;
            *(unsigned char *)(a1 + 40) = v31 != 0;
            return 1;
          case 6:
            if ((unint64_t)(*(void *)a2 + 4) > *(void *)(a2 + 16)) {
              goto LABEL_17;
            }
            *(_DWORD *)(a1 + 92) = *(_DWORD *)(*(void *)(a2 + 8) + *(void *)a2);
            goto LABEL_7;
          default:
            return 1;
        }
      case 0x13uLL:
        if ((unint64_t)(*(void *)a2 + 1) > *(void *)(a2 + 16)) {
          goto LABEL_17;
        }
        *(unsigned char *)(a1 + 10) = *(unsigned char *)(*(void *)(a2 + 8) + *(void *)a2);
        uint64_t v9 = *(void *)a2 + 1;
        break;
      case 2uLL:
        if ((unint64_t)(*(void *)a2 + 2) > *(void *)(a2 + 16)) {
          goto LABEL_17;
        }
        *(_WORD *)(a1 + 8) = *(_WORD *)(*(void *)(a2 + 8) + *(void *)a2);
        uint64_t v9 = *(void *)a2 + 2;
        break;
      default:
        return 1;
    }
LABEL_30:
    *(void *)a2 = v9;
    return 1;
  }
  unint64_t v7 = a3 - 100000;
  int v8 = *(unsigned __int8 *)(a1 + 10);
  if ((v8 - 7) < 2) {
    goto LABEL_5;
  }
  if (v8 != 5)
  {
    if (v8 == 4)
    {
LABEL_5:
      if ((unint64_t)(*(void *)a2 + 4) <= *(void *)(a2 + 16))
      {
        *(_DWORD *)(a1 + 4 * v7 + 44) = *(_DWORD *)(*(void *)(a2 + 8) + *(void *)a2);
LABEL_7:
        uint64_t v9 = *(void *)a2 + 4;
        goto LABEL_30;
      }
LABEL_17:
      uint64_t result = 0;
      *(unsigned char *)(a2 + 24) = 1;
      return result;
    }
    return 1;
  }
  unint64_t v11 = a3 - 99999;
  uint64_t v12 = *(void *)(a1 + 96);
  uint64_t v13 = *(void *)(a1 + 104);
  unint64_t v14 = (v13 - v12) >> 3;
  if (a3 - 99999 <= v14)
  {
    if (v11 < v14)
    {
      uint64_t v28 = v12 + 8 * v11;
      while (v13 != v28)
      {
        uint64_t v29 = *(void **)(v13 - 8);
        v13 -= 8;
      }
      *(void *)(a1 + 104) = v28;
    }
  }
  else
  {
    unint64_t v15 = v11 - v14;
    uint64_t v16 = *(void *)(a1 + 112);
    if (v11 - v14 <= (v16 - v13) >> 3)
    {
      bzero(*(void **)(a1 + 104), 8 * v15);
      *(void *)(a1 + 104) = v13 + 8 * v15;
    }
    else
    {
      if (v11 >> 61) {
        abort();
      }
      uint64_t v36 = a1 + 112;
      uint64_t v17 = v16 - v12;
      if (v17 >> 2 > v11) {
        unint64_t v11 = v17 >> 2;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v11;
      }
      unint64_t v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v18);
      unint64_t v20 = &v19[8 * v14];
      uint64_t v22 = &v19[8 * v21];
      char v35 = v22;
      bzero(v20, 8 * v15);
      __int16 v23 = &v20[8 * v15];
      v34.i64[1] = (uint64_t)v23;
      unint64_t v25 = *(void **)(a1 + 96);
      unint64_t v24 = *(void **)(a1 + 104);
      if (v24 == v25)
      {
        int64x2_t v27 = vdupq_n_s64((unint64_t)v24);
      }
      else
      {
        do
        {
          uint64_t v26 = *--v24;
          void *v24 = 0;
          *((void *)v20 - 1) = v26;
          v20 -= 8;
        }
        while (v24 != v25);
        int64x2_t v27 = *(int64x2_t *)(a1 + 96);
        __int16 v23 = (char *)v34.i64[1];
        uint64_t v22 = v35;
      }
      *(void *)(a1 + 96) = v20;
      *(void *)(a1 + 104) = v23;
      int64x2_t v34 = v27;
      uint64_t v32 = *(char **)(a1 + 112);
      *(void *)(a1 + 112) = v22;
      char v35 = v32;
      uint64_t v33 = v27.i64[0];
      std::__split_buffer<NSString * {__strong}>::~__split_buffer((uint64_t)&v33);
    }
  }
  uint64_t result = AccelerationStructureViewer::DataSourceQueryBlobDecoder::consumeString((uint64_t *)a2, (void **)(*(void *)(a1 + 96) + 8 * v7), a4);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t std::__split_buffer<NSString * {__strong}>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t AccelerationStructureViewer::Property::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 11);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 2, 2, a1 + 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 19, 1, a1 + 10);
  switch(*(unsigned char *)(a1 + 10))
  {
    case 0:
      if (*(void *)(a1 + 16)) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 32))(a2, 20);
      }
      return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
    case 1:
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 20, 8, a1 + 32);
      return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
    case 2:
      uint64_t v4 = a1 + 24;
      goto LABEL_13;
    case 3:
      char v11 = *(unsigned char *)(a1 + 40);
      (*(void (**)(uint64_t, uint64_t, uint64_t, char *))(*(void *)a2 + 24))(a2, 20, 1, &v11);
      return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
    case 4:
    case 7:
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 100000, 4, a1 + 44);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 100001, 4, a1 + 48);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 100002, 4, a1 + 52);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 100003, 4, a1 + 56);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 100004, 4, a1 + 60);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 100005, 4, a1 + 64);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 100006, 4, a1 + 68);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 100007, 4, a1 + 72);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 100008, 4, a1 + 76);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 100009, 4, a1 + 80);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 100010, 4, a1 + 84);
      uint64_t v4 = a1 + 88;
      unint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24);
      uint64_t v6 = 100011;
      goto LABEL_15;
    case 5:
      uint64_t v7 = *(void *)(a1 + 96);
      if (*(void *)(a1 + 104) != v7)
      {
        unint64_t v8 = 0;
        do
        {
          (*(void (**)(uint64_t, unint64_t, void))(*(void *)a2 + 32))(a2, v8 + 100000, *(void *)(v7 + 8 * v8));
          ++v8;
          uint64_t v7 = *(void *)(a1 + 96);
        }
        while (v8 < (*(void *)(a1 + 104) - v7) >> 3);
      }
      return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
    case 6:
      uint64_t v4 = a1 + 92;
LABEL_13:
      unint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24);
      uint64_t v9 = a2;
      uint64_t v6 = 20;
      goto LABEL_16;
    case 8:
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 100000, 4, a1 + 44);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 100001, 4, a1 + 48);
      uint64_t v4 = a1 + 52;
      unint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24);
      uint64_t v6 = 100002;
LABEL_15:
      uint64_t v9 = a2;
LABEL_16:
      v5(v9, v6, 4, v4);
      break;
    default:
      return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
}

void AccelerationStructureViewer::Property::~Property(id *this)
{
  *this = off_7474F0;
  uint64_t v2 = this + 12;
  std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v2);

  operator delete();
}

{
  void **v2;

  *this = off_7474F0;
  uint64_t v2 = this + 12;
  std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v2);
}

void AccelerationStructureViewer::DataSourceError_StrongRef::finish(AccelerationStructureViewer::DataSourceError_StrongRef *this)
{
  uint64_t v1 = *((void *)this + 5);
  if (v1)
  {
    uint64_t v3 = *((void *)this + 4);
    uint64_t v4 = *((void *)this + 6);
    NSErrorUserInfoKey v8 = NSLocalizedDescriptionKey;
    uint64_t v9 = v4;
    unint64_t v5 = +[NSDictionary dictionaryWithObjects:&v9 forKeys:&v8 count:1];
    uint64_t v6 = +[ASVError errorWithDomain:v1 code:v3 userInfo:v5];
    uint64_t v7 = (void *)*((void *)this + 1);
    *((void *)this + 1) = v6;
  }
}

void sub_1C6FB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t AccelerationStructureViewer::DataSourceError_StrongRef::decode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 <= 16)
  {
    if (a3 == 15)
    {
      if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16))
      {
        uint64_t result = 0;
        *(unsigned char *)(a2 + 24) = 1;
        return result;
      }
      *(void *)(a1 + 32) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
      *(void *)a2 += 8;
    }
    else if (a3 == 16 {
           && (AccelerationStructureViewer::DataSourceQueryBlobDecoder::consumeString((uint64_t *)a2, (void **)(a1 + 40), a4) & 1) == 0)
    }
    {
      return 0;
    }
    return 1;
  }
  if (a3 != 17)
  {
    if (a3 == 100000) {
      *(void *)(a1 + 16) = AccelerationStructureViewer::DataSourceQueryBlobDecoder::decode(a2, (_WORD *)(a1 + 24));
    }
    return 1;
  }
  uint64_t result = AccelerationStructureViewer::DataSourceQueryBlobDecoder::consumeString((uint64_t *)a2, (void **)(a1 + 48), a4);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t AccelerationStructureViewer::DataSourceError::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 10);
  id v7 = [*(id *)(a1 + 8) code];
  (*(void (**)(uint64_t, uint64_t, uint64_t, id *))(*(void *)a2 + 24))(a2, 15, 8, &v7);
  uint64_t v4 = [*(id *)(a1 + 8) domain];
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)a2 + 32))(a2, 16, v4);

  unint64_t v5 = [*(id *)(a1 + 8) localizedDescription];
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)a2 + 32))(a2, 17, v5);

  if (*(void *)(a1 + 16)) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, 100000);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
}

void sub_1C723C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void AccelerationStructureViewer::DataSourceError_StrongRef::~DataSourceError_StrongRef(AccelerationStructureViewer::DataSourceError_StrongRef *this)
{
  AccelerationStructureViewer::DataSourceError_StrongRef::~DataSourceError_StrongRef(this);

  operator delete();
}

{
  uint64_t v2;

  *(void *)this = off_7442A0;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

uint64_t AccelerationStructureViewer::Geometry::decode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 <= 17)
  {
    switch(a3)
    {
      case 1:
        return (AccelerationStructureViewer::DataSourceQueryBlobDecoder::consumeString((uint64_t *)a2, (void **)(a1 + 48), a4) & 1) != 0;
      case 2:
        unint64_t v11 = *(void *)a2 + 2;
        if (v11 > *(void *)(a2 + 16)) {
          goto LABEL_38;
        }
        int v12 = *(unsigned __int16 *)(*(void *)(a2 + 8) + *(void *)a2);
        *(void *)a2 = v11;
        *(_DWORD *)(a1 + 32) = v12;
        return 1;
      case 3:
        if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
          goto LABEL_38;
        }
        *(void *)(a1 + 40) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
        goto LABEL_21;
      case 6:
        unint64_t v9 = *(void *)a2 + 1;
        if (v9 > *(void *)(a2 + 16)) {
          goto LABEL_38;
        }
        int v10 = *(unsigned __int8 *)(*(void *)(a2 + 8) + *(void *)a2);
        *(void *)a2 = v9;
        *(unsigned char *)(a1 + 56) = v10 == 1;
        return 1;
      case 7:
        if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
          goto LABEL_38;
        }
        *(void *)(a1 + 72) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
LABEL_21:
        uint64_t v8 = *(void *)a2 + 8;
        goto LABEL_63;
      case 11:
        if ((unint64_t)(*(void *)a2 + 4) > *(void *)(a2 + 16)) {
          goto LABEL_38;
        }
        *(_DWORD *)(a1 + 60) = *(_DWORD *)(*(void *)(a2 + 8) + *(void *)a2);
        goto LABEL_62;
      default:
        return 1;
    }
  }
  if (a3 == 18)
  {
    __int16 v32 = 0;
    uint64_t v13 = AccelerationStructureViewer::DataSourceQueryBlobDecoder::decode(a2, &v32);
    unint64_t v14 = (void *)v13;
    if (v13) {
      BOOL v15 = v32 == 0;
    }
    else {
      BOOL v15 = 0;
    }
    char v16 = !v15;
    char v31 = v16;
    if (v15)
    {
      unint64_t v19 = *(uint64_t **)(v13 + 8);
      unint64_t v18 = *(uint64_t **)(v13 + 16);
      if (v19 != v18)
      {
        unint64_t v20 = (void *)(a1 + 104);
        uint64_t v21 = *(uint64_t **)(v13 + 8);
        do
        {
          if (*(_WORD *)(v14[4] + (((uint64_t)v19 - v14[1]) >> 2)) == 11)
          {
            uint64_t v22 = *v21;
            unint64_t v24 = *(void *)(a1 + 112);
            unint64_t v23 = *(void *)(a1 + 120);
            if (v24 >= v23)
            {
              unint64_t v26 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v24 - *v20) >> 3);
              unint64_t v27 = v26 + 1;
              if (v26 + 1 > 0x222222222222222) {
                abort();
              }
              unint64_t v28 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v23 - *v20) >> 3);
              if (2 * v28 > v27) {
                unint64_t v27 = 2 * v28;
              }
              if (v28 >= 0x111111111111111) {
                unint64_t v29 = 0x222222222222222;
              }
              else {
                unint64_t v29 = v27;
              }
              uint64_t v37 = a1 + 120;
              if (v29) {
                unint64_t v29 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::Property>>(v29);
              }
              else {
                uint64_t v30 = 0;
              }
              unint64_t v33 = v29;
              uint64_t v34 = v29 + 120 * v26;
              uint64_t v35 = v34;
              unint64_t v36 = v29 + 120 * v30;
              std::allocator<AccelerationStructureViewer::Property>::construct[abi:nn180100]<AccelerationStructureViewer::Property,AccelerationStructureViewer::Property const&>(v34, v22);
              v35 += 120;
              std::vector<AccelerationStructureViewer::Property>::__swap_out_circular_buffer((uint64_t *)(a1 + 104), &v33);
              unint64_t v25 = *(void *)(a1 + 112);
              std::__split_buffer<AccelerationStructureViewer::Property>::~__split_buffer((uint64_t)&v33);
            }
            else
            {
              std::allocator<AccelerationStructureViewer::Property>::construct[abi:nn180100]<AccelerationStructureViewer::Property,AccelerationStructureViewer::Property const&>(*(void *)(a1 + 112), *v21);
              unint64_t v25 = v24 + 120;
              *(void *)(a1 + 112) = v24 + 120;
            }
            *(void *)(a1 + 112) = v25;
            unint64_t v18 = (uint64_t *)v14[2];
          }
          ++v21;
          ++v19;
        }
        while (v21 != v18);
      }
    }
    else if (!v13)
    {
      return 0;
    }
    (*(void (**)(void *))(*v14 + 8))(v14);
    return (v31 & 1) == 0;
  }
  if (a3 == 31)
  {
    if ((unint64_t)(*(void *)a2 + 4) > *(void *)(a2 + 16))
    {
LABEL_38:
      uint64_t result = 0;
      *(unsigned char *)(a2 + 24) = 1;
      return result;
    }
    *(_DWORD *)(a1 + 64) = *(_DWORD *)(*(void *)(a2 + 8) + *(void *)a2);
LABEL_62:
    uint64_t v8 = *(void *)a2 + 4;
LABEL_63:
    *(void *)a2 = v8;
    return 1;
  }
  if (a3 != 28) {
    return 1;
  }
  LOWORD(v33) = 0;
  uint64_t result = AccelerationStructureViewer::DataSourceQueryBlobDecoder::decode(a2, &v33);
  if (result) {
    BOOL v6 = (unsigned __int16)v33 == 15;
  }
  else {
    BOOL v6 = 0;
  }
  char v7 = !v6;
  if (v6)
  {
    long long v17 = *(_OWORD *)(result + 8);
    *(void *)(a1 + 96) = *(void *)(result + 24);
    *(_OWORD *)(a1 + 80) = v17;
LABEL_40:
    (*(void (**)(uint64_t))(*(void *)result + 8))(result);
    return (v7 & 1) == 0;
  }
  if (result) {
    goto LABEL_40;
  }
  return result;
}

void sub_1C76CC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t AccelerationStructureViewer::CurveGeometry::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 22);
  AccelerationStructureViewer::Geometry::encode(a1, a2);
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)a2 + 48);

  return v4(a2);
}

void AccelerationStructureViewer::Geometry::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 32))(a2, 1, *(void *)(a1 + 48));
  __int16 v22 = *(_DWORD *)(a1 + 32);
  (*(void (**)(uint64_t, uint64_t, uint64_t, __int16 *))(*(void *)a2 + 24))(a2, 2, 2, &v22);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 11, 4, a1 + 60);
  char v21 = *(unsigned char *)(a1 + 56);
  (*(void (**)(uint64_t, uint64_t, uint64_t, char *))(*(void *)a2 + 24))(a2, 6, 1, &v21);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 7, 8, a1 + 72);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 3, 8, a1 + 40);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 31, 4, a1 + 64);
  unint64_t v18 = off_744460;
  long long v19 = *(_OWORD *)(a1 + 80);
  uint64_t v20 = *(void *)(a1 + 96);
  (*(void (**)(uint64_t, uint64_t, void (***)(AccelerationStructureViewer::BoundingBox *__hidden)))(*(void *)a2 + 40))(a2, 28, &v18);
  unint64_t v14 = off_7441F8;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  uint64_t v4 = *(void *)(a1 + 104);
  if (v4 != *(void *)(a1 + 112))
  {
    unint64_t v5 = 0;
    do
    {
      if ((unint64_t)v5 >= (unint64_t)v16)
      {
        uint64_t v6 = (uint64_t)((uint64_t)v5 - v15) >> 3;
        if ((unint64_t)(v6 + 1) >> 61) {
          abort();
        }
        unint64_t v7 = (uint64_t)(v16 - v15) >> 2;
        if (v7 <= v6 + 1) {
          unint64_t v7 = v6 + 1;
        }
        if ((void)v16 - (void)v15 >= 0x7FFFFFFFFFFFFFF8uLL) {
          unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v8 = v7;
        }
        if (v8) {
          unint64_t v8 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v8);
        }
        else {
          uint64_t v9 = 0;
        }
        int v10 = (void *)(v8 + 8 * v6);
        void *v10 = v4;
        unint64_t v5 = v10 + 1;
        unint64_t v11 = (char *)*((void *)&v15 + 1);
        int v12 = (char *)v15;
        if (*((void *)&v15 + 1) != (void)v15)
        {
          do
          {
            uint64_t v13 = *((void *)v11 - 1);
            v11 -= 8;
            *--int v10 = v13;
          }
          while (v11 != v12);
          unint64_t v11 = (char *)v15;
        }
        *(void *)&long long v15 = v10;
        *((void *)&v15 + 1) = v5;
        *(void *)&long long v16 = v8 + 8 * v9;
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *v5++ = v4;
      }
      *((void *)&v15 + 1) = v5;
      v4 += 120;
    }
    while (v4 != *(void *)(a1 + 112));
  }
  (*(void (**)(uint64_t, uint64_t, void (***)(AccelerationStructureViewer::DataSourceArray *__hidden)))(*(void *)a2 + 40))(a2, 18, &v14);
  AccelerationStructureViewer::DataSourceArray::~DataSourceArray((AccelerationStructureViewer::DataSourceArray *)&v14);
}

void sub_1C7B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void AccelerationStructureViewer::CurveGeometry::~CurveGeometry(id *this)
{
  AccelerationStructureViewer::Geometry::~Geometry(this);

  operator delete();
}

void AccelerationStructureViewer::Geometry::~Geometry(id *this)
{
  *this = off_7444D0;
  uint64_t v2 = this + 13;
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v2);

  uint64_t v2 = this + 1;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

{
  uint64_t vars8;

  AccelerationStructureViewer::Geometry::~Geometry(this);

  operator delete();
}

uint64_t AccelerationStructureViewer::BoundingBoxGeometry::decode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = AccelerationStructureViewer::Geometry::decode(a1, a2, a3, a4);
  if (result)
  {
    if (a3 == 8)
    {
      if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16))
      {
        uint64_t result = 0;
        *(unsigned char *)(a2 + 24) = 1;
        return result;
      }
      *(void *)(a1 + 128) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
      *(void *)a2 += 8;
    }
    return 1;
  }
  return result;
}

uint64_t AccelerationStructureViewer::BoundingBoxGeometry::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 9);
  AccelerationStructureViewer::Geometry::encode(a1, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 8, 8, a1 + 128);
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)a2 + 48);

  return v4(a2);
}

void AccelerationStructureViewer::BoundingBoxGeometry::~BoundingBoxGeometry(id *this)
{
  AccelerationStructureViewer::Geometry::~Geometry(this);

  operator delete();
}

uint64_t AccelerationStructureViewer::TriangleGeometry::decode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = AccelerationStructureViewer::Geometry::decode(a1, a2, a3, a4);
  if (result)
  {
    if (a3 == 10)
    {
      if ((unint64_t)(*(void *)a2 + 8) <= *(void *)(a2 + 16))
      {
        *(void *)(a1 + 136) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
        goto LABEL_9;
      }
    }
    else
    {
      if (a3 != 9) {
        return 1;
      }
      if ((unint64_t)(*(void *)a2 + 8) <= *(void *)(a2 + 16))
      {
        *(void *)(a1 + 128) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
LABEL_9:
        *(void *)a2 += 8;
        return 1;
      }
    }
    uint64_t result = 0;
    *(unsigned char *)(a2 + 24) = 1;
  }
  return result;
}

uint64_t AccelerationStructureViewer::TriangleGeometry::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 8);
  AccelerationStructureViewer::Geometry::encode(a1, a2);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 9, 8, a1 + 128);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 10, 8, a1 + 136);
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)a2 + 48);

  return v4(a2);
}

void AccelerationStructureViewer::TriangleGeometry::~TriangleGeometry(id *this)
{
  AccelerationStructureViewer::Geometry::~Geometry(this);

  operator delete();
}

uint64_t AccelerationStructureViewer::InvalidGeometry::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 7);
  AccelerationStructureViewer::Geometry::encode(a1, a2);
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)a2 + 48);

  return v4(a2);
}

void AccelerationStructureViewer::InvalidGeometry::~InvalidGeometry(id *this)
{
  AccelerationStructureViewer::Geometry::~Geometry(this);

  operator delete();
}

BOOL AccelerationStructureViewer::IntersectionFunction::decode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((unint64_t)a3 >> 5 < 0xC35)
  {
    if (a3 <= 27)
    {
      switch(a3)
      {
        case 0:
          if (a4 != 4) {
            return 0;
          }
          unint64_t v7 = *(void *)a2 + 4;
          if (v7 > *(void *)(a2 + 16)) {
            goto LABEL_5;
          }
          std::vector<unsigned int>::size_type v8 = *(unsigned int *)(*(void *)(a2 + 8) + *(void *)a2);
          *(void *)a2 = v7;
          uint64_t v9 = (void **)(a1 + 80);
          std::vector<AccelerationStructureViewer::IntersectionFunctionTag>::resize((std::vector<unsigned int> *)(a1 + 80), v8);
          if (v8) {
            bzero(*v9, 4 * v8);
          }
          return 1;
        case 1:
          return (AccelerationStructureViewer::DataSourceQueryBlobDecoder::consumeString((uint64_t *)a2, (void **)(a1 + 32), a4) & 1) != 0;
        case 3:
          if (a4 != 8) {
            return 0;
          }
          if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
            goto LABEL_5;
          }
          *(void *)(a1 + 48) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
          goto LABEL_36;
        case 4:
          if (a4 != 8) {
            return 0;
          }
          if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
            goto LABEL_5;
          }
          *(void *)(a1 + 56) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
          goto LABEL_36;
        case 5:
          if (a4 != 8) {
            return 0;
          }
          if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
            goto LABEL_5;
          }
          *(void *)(a1 + 64) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
          goto LABEL_36;
        case 6:
          if (a4 != 1) {
            return 0;
          }
          unint64_t v13 = *(void *)a2 + 1;
          if (v13 > *(void *)(a2 + 16)) {
            goto LABEL_5;
          }
          int v14 = *(unsigned __int8 *)(*(void *)(a2 + 8) + *(void *)a2);
          *(void *)a2 = v13;
          *(unsigned char *)(a1 + 74) = v14 == 2;
          return 1;
        case 7:
          if (a4 != 8) {
            return 0;
          }
          if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
            goto LABEL_5;
          }
          *(void *)(a1 + 40) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
LABEL_36:
          uint64_t v12 = *(void *)a2 + 8;
          break;
        default:
          return 1;
      }
LABEL_37:
      *(void *)a2 = v12;
      return 1;
    }
    switch(a3)
    {
      case 30:
        if (a4 == 1)
        {
          unint64_t v15 = *(void *)a2 + 1;
          if (v15 > *(void *)(a2 + 16)) {
            goto LABEL_5;
          }
          int v16 = *(unsigned __int8 *)(*(void *)(a2 + 8) + *(void *)a2);
          *(void *)a2 = v15;
          *(unsigned char *)(a1 + 72) = v16 == 2;
          return 1;
        }
        break;
      case 29:
        if (a4 == 1)
        {
          unint64_t v17 = *(void *)a2 + 1;
          if (v17 > *(void *)(a2 + 16)) {
            goto LABEL_5;
          }
          int v18 = *(unsigned __int8 *)(*(void *)(a2 + 8) + *(void *)a2);
          *(void *)a2 = v17;
          *(unsigned char *)(a1 + 73) = v18 == 2;
          return 1;
        }
        break;
      case 28:
        __int16 v19 = 0;
        uint64_t v10 = AccelerationStructureViewer::DataSourceQueryBlobDecoder::decode(a2, &v19);
        if (v10 && v19 == 15)
        {
          long long v11 = *(_OWORD *)(v10 + 8);
          *(void *)(a1 + 120) = *(void *)(v10 + 24);
          *(_OWORD *)(a1 + 104) = v11;
          (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
          return 1;
        }
        if (v10) {
          (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
        }
        break;
      default:
        return 1;
    }
    return 0;
  }
  BOOL result = 0;
  if (a4 == 4)
  {
    uint64_t v6 = *(void *)(a1 + 80);
    if (a3 - 100000 < (unint64_t)((*(void *)(a1 + 88) - v6) >> 2))
    {
      if ((unint64_t)(*(void *)a2 + 4) > *(void *)(a2 + 16))
      {
LABEL_5:
        BOOL result = 0;
        *(unsigned char *)(a2 + 24) = 1;
        return result;
      }
      *(_DWORD *)(v6 + 4 * (a3 - 100000)) = *(_DWORD *)(*(void *)(a2 + 8) + *(void *)a2);
      uint64_t v12 = *(void *)a2 + 4;
      goto LABEL_37;
    }
  }
  return result;
}

void std::vector<AccelerationStructureViewer::IntersectionFunctionTag>::resize(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __sz)
{
  std::vector<unsigned int>::pointer begin = this->__begin_;
  std::vector<unsigned int>::pointer end = this->__end_;
  std::vector<unsigned int>::size_type v5 = end - this->__begin_;
  if (__sz <= v5)
  {
    if (__sz >= v5) {
      return;
    }
    __int16 v19 = &begin[__sz];
    goto LABEL_15;
  }
  std::vector<unsigned int>::size_type v6 = __sz - v5;
  value = this->__end_cap_.__value_;
  if (__sz - v5 <= value - end)
  {
    bzero(this->__end_, 4 * v6);
    __int16 v19 = &end[v6];
LABEL_15:
    this->__end_ = v19;
    return;
  }
  if (__sz >> 62) {
    abort();
  }
  uint64_t v8 = (char *)value - (char *)begin;
  std::vector<unsigned int>::size_type v9 = v8 >> 1;
  if (v8 >> 1 <= __sz) {
    std::vector<unsigned int>::size_type v9 = __sz;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v10 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  long long v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v10);
  std::vector<unsigned int>::pointer v12 = this->__begin_;
  std::vector<unsigned int>::pointer v13 = this->__end_;
  int v14 = &v11[4 * v5];
  int v16 = (unsigned int *)&v11[4 * v15];
  bzero(v14, 4 * v6);
  unint64_t v17 = (unsigned int *)&v14[4 * v6];
  while (v13 != v12)
  {
    int v18 = *--v13;
    *((_DWORD *)v14 - 1) = v18;
    v14 -= 4;
  }
  this->__begin_ = (std::vector<unsigned int>::pointer)v14;
  this->__end_ = v17;
  this->__end_cap_.__value_ = v16;
  if (v12)
  {
    operator delete(v12);
  }
}

void AccelerationStructureViewer::IntersectionFunction::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 6);
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 32))(a2, 1, *(void *)(a1 + 32));
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 3, 8, a1 + 48);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 4, 8, a1 + 56);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 5, 8, a1 + 64);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 13, 4, a1 + 76);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 7, 8, a1 + 40);
  if (*(unsigned char *)(a1 + 73)) {
    char v4 = 2;
  }
  else {
    char v4 = 1;
  }
  char v28 = v4;
  (*(void (**)(uint64_t, uint64_t, uint64_t, char *))(*(void *)a2 + 24))(a2, 29, 1, &v28);
  if (*(unsigned char *)(a1 + 74)) {
    char v5 = 2;
  }
  else {
    char v5 = 1;
  }
  char v28 = v5;
  (*(void (**)(uint64_t, uint64_t, uint64_t, char *))(*(void *)a2 + 24))(a2, 6, 1, &v28);
  if (*(unsigned char *)(a1 + 72)) {
    char v6 = 2;
  }
  else {
    char v6 = 1;
  }
  char v28 = v6;
  (*(void (**)(uint64_t, uint64_t, uint64_t, char *))(*(void *)a2 + 24))(a2, 30, 1, &v28);
  unint64_t v25 = off_744460;
  long long v26 = *(_OWORD *)(a1 + 104);
  uint64_t v27 = *(void *)(a1 + 120);
  (*(void (**)(uint64_t, uint64_t, void (***)(AccelerationStructureViewer::BoundingBox *__hidden)))(*(void *)a2 + 40))(a2, 28, &v25);
  char v21 = off_7441F8;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  uint64_t v7 = *(void *)(a1 + 128);
  if (v7 != *(void *)(a1 + 136))
  {
    uint64_t v8 = 0;
    do
    {
      if ((unint64_t)v8 >= (unint64_t)v23)
      {
        uint64_t v9 = (uint64_t)((uint64_t)v8 - v22) >> 3;
        if ((unint64_t)(v9 + 1) >> 61) {
          abort();
        }
        unint64_t v10 = (uint64_t)(v23 - v22) >> 2;
        if (v10 <= v9 + 1) {
          unint64_t v10 = v9 + 1;
        }
        if ((void)v23 - (void)v22 >= 0x7FFFFFFFFFFFFFF8uLL) {
          unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v11 = v10;
        }
        if (v11) {
          unint64_t v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v11);
        }
        else {
          uint64_t v12 = 0;
        }
        std::vector<unsigned int>::pointer v13 = (void *)(v11 + 8 * v9);
        *std::vector<unsigned int>::pointer v13 = v7;
        uint64_t v8 = v13 + 1;
        int v14 = (char *)*((void *)&v22 + 1);
        uint64_t v15 = (char *)v22;
        if (*((void *)&v22 + 1) != (void)v22)
        {
          do
          {
            uint64_t v16 = *((void *)v14 - 1);
            v14 -= 8;
            *--std::vector<unsigned int>::pointer v13 = v16;
          }
          while (v14 != v15);
          int v14 = (char *)v22;
        }
        *(void *)&long long v22 = v13;
        *((void *)&v22 + 1) = v8;
        *(void *)&long long v23 = v11 + 8 * v12;
        if (v14) {
          operator delete(v14);
        }
      }
      else
      {
        *v8++ = v7;
      }
      *((void *)&v22 + 1) = v8;
      v7 += 120;
    }
    while (v7 != *(void *)(a1 + 136));
  }
  (*(void (**)(uint64_t, uint64_t, void (***)(AccelerationStructureViewer::DataSourceArray *__hidden)))(*(void *)a2 + 40))(a2, 18, &v21);
  int v20 = (*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2;
  (*(void (**)(uint64_t, void, uint64_t, int *))(*(void *)a2 + 24))(a2, 0, 4, &v20);
  uint64_t v17 = *(void *)(a1 + 80);
  if (*(void *)(a1 + 88) != v17)
  {
    uint64_t v18 = 0;
    unint64_t v19 = 0;
    do
    {
      (*(void (**)(uint64_t, unint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, v19 + 100000, 4, v17 + v18);
      ++v19;
      uint64_t v17 = *(void *)(a1 + 80);
      v18 += 4;
    }
    while (v19 < (*(void *)(a1 + 88) - v17) >> 2);
  }
  (*(void (**)(uint64_t))(*(void *)a2 + 48))(a2);
  AccelerationStructureViewer::DataSourceArray::~DataSourceArray((AccelerationStructureViewer::DataSourceArray *)&v21);
}

void sub_1C8998(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  AccelerationStructureViewer::DataSourceArray::~DataSourceArray((AccelerationStructureViewer::DataSourceArray *)va);
  _Unwind_Resume(a1);
}

BOOL AccelerationStructureViewer::IntersectionFunctionTable::decode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    if (a3 != 3) {
      return a3 != 1
    }
          || (AccelerationStructureViewer::DataSourceQueryBlobDecoder::consumeString((uint64_t *)a2, (void **)(a1 + 8), a4) & 1) != 0;
    uint64_t v5 = *(void *)a2;
    if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16))
    {
LABEL_9:
      BOOL result = 0;
      *(unsigned char *)(a2 + 24) = 1;
      return result;
    }
    char v6 = (void *)(a1 + 16);
  }
  else
  {
    uint64_t v5 = *(void *)a2;
    if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
      goto LABEL_9;
    }
    char v6 = (void *)(a1 + 24);
  }
  *char v6 = *(void *)(*(void *)(a2 + 8) + v5);
  *(void *)a2 += 8;
  return 1;
}

uint64_t AccelerationStructureViewer::IntersectionFunctionTable::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 5);
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 32))(a2, 1, *(void *)(a1 + 8));
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 3, 8, a1 + 16);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 0, 8, a1 + 24);
  char v4 = *(uint64_t (**)(uint64_t))(*(void *)a2 + 48);

  return v4(a2);
}

void AccelerationStructureViewer::IntersectionFunctionTable::~IntersectionFunctionTable(id *this)
{
  operator delete();
}

{
}

BOOL AccelerationStructureViewer::Instance::decode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 <= 10)
  {
    if (a3 == 1) {
      return (AccelerationStructureViewer::DataSourceQueryBlobDecoder::consumeString((uint64_t *)a2, (void **)(a1 + 48), a4) & 1) != 0;
    }
    if (a3 != 3) {
      return 1;
    }
    if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16))
    {
LABEL_13:
      BOOL result = 0;
      *(unsigned char *)(a2 + 24) = 1;
      return result;
    }
    *(void *)(a1 + 32) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
LABEL_40:
    *(void *)a2 += 8;
    return 1;
  }
  switch(a3)
  {
    case 11:
      if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16)) {
        goto LABEL_13;
      }
      *(void *)(a1 + 40) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
      goto LABEL_40;
    case 18:
      __int16 v24 = 0;
      uint64_t v8 = (void *)AccelerationStructureViewer::DataSourceQueryBlobDecoder::decode(a2, &v24);
      uint64_t v9 = v8;
      if (v8 && !v24)
      {
        unint64_t v11 = (uint64_t *)v8[1];
        unint64_t v10 = (uint64_t *)v8[2];
        if (v11 != v10)
        {
          uint64_t v12 = (void *)(a1 + 80);
          std::vector<unsigned int>::pointer v13 = (uint64_t *)v8[1];
          do
          {
            if (*(_WORD *)(v9[4] + (((uint64_t)v11 - v9[1]) >> 2)) == 11)
            {
              uint64_t v14 = *v13;
              unint64_t v16 = *(void *)(a1 + 88);
              unint64_t v15 = *(void *)(a1 + 96);
              if (v16 >= v15)
              {
                unint64_t v18 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v16 - *v12) >> 3);
                unint64_t v19 = v18 + 1;
                if (v18 + 1 > 0x222222222222222) {
                  abort();
                }
                unint64_t v20 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v15 - *v12) >> 3);
                if (2 * v20 > v19) {
                  unint64_t v19 = 2 * v20;
                }
                if (v20 >= 0x111111111111111) {
                  unint64_t v21 = 0x222222222222222;
                }
                else {
                  unint64_t v21 = v19;
                }
                uint64_t v29 = a1 + 96;
                if (v21) {
                  unint64_t v21 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::Property>>(v21);
                }
                else {
                  uint64_t v22 = 0;
                }
                unint64_t v25 = v21;
                uint64_t v26 = v21 + 120 * v18;
                uint64_t v27 = v26;
                unint64_t v28 = v21 + 120 * v22;
                std::allocator<AccelerationStructureViewer::Property>::construct[abi:nn180100]<AccelerationStructureViewer::Property,AccelerationStructureViewer::Property const&>(v26, v14);
                v27 += 120;
                std::vector<AccelerationStructureViewer::Property>::__swap_out_circular_buffer((uint64_t *)(a1 + 80), &v25);
                unint64_t v17 = *(void *)(a1 + 88);
                std::__split_buffer<AccelerationStructureViewer::Property>::~__split_buffer((uint64_t)&v25);
              }
              else
              {
                std::allocator<AccelerationStructureViewer::Property>::construct[abi:nn180100]<AccelerationStructureViewer::Property,AccelerationStructureViewer::Property const&>(*(void *)(a1 + 88), *v13);
                unint64_t v17 = v16 + 120;
                *(void *)(a1 + 88) = v16 + 120;
              }
              *(void *)(a1 + 88) = v17;
              unint64_t v10 = (uint64_t *)v9[2];
            }
            ++v13;
            ++v11;
          }
          while (v13 != v10);
        }
        (*(void (**)(void *))(*v9 + 8))(v9);
        return 1;
      }
      if (v8)
      {
        long long v23 = *(void (**)(void))(*v8 + 8);
        goto LABEL_44;
      }
      break;
    case 28:
      LOWORD(v25) = 0;
      uint64_t v5 = AccelerationStructureViewer::DataSourceQueryBlobDecoder::decode(a2, &v25);
      if (v5 && (unsigned __int16)v25 == 15)
      {
        long long v6 = *(_OWORD *)(v5 + 8);
        *(void *)(a1 + 72) = *(void *)(v5 + 24);
        *(_OWORD *)(a1 + 56) = v6;
        (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        return 1;
      }
      if (v5)
      {
        long long v23 = *(void (**)(void))(*(void *)v5 + 8);
LABEL_44:
        v23();
      }
      break;
    default:
      return 1;
  }
  return 0;
}

void sub_1C8FA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v10 + 88) = v11;
  _Unwind_Resume(exception_object);
}

void AccelerationStructureViewer::Instance::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 4);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 11, 8, a1 + 40);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 3, 8, a1 + 32);
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 32))(a2, 1, *(void *)(a1 + 48));
  unint64_t v18 = off_744460;
  long long v19 = *(_OWORD *)(a1 + 56);
  uint64_t v20 = *(void *)(a1 + 72);
  (*(void (**)(uint64_t, uint64_t, void (***)(AccelerationStructureViewer::BoundingBox *__hidden)))(*(void *)a2 + 40))(a2, 28, &v18);
  uint64_t v14 = off_7441F8;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4 != *(void *)(a1 + 88))
  {
    uint64_t v5 = 0;
    do
    {
      if ((unint64_t)v5 >= (unint64_t)v16)
      {
        uint64_t v6 = (uint64_t)((uint64_t)v5 - v15) >> 3;
        if ((unint64_t)(v6 + 1) >> 61) {
          abort();
        }
        unint64_t v7 = (uint64_t)(v16 - v15) >> 2;
        if (v7 <= v6 + 1) {
          unint64_t v7 = v6 + 1;
        }
        if ((void)v16 - (void)v15 >= 0x7FFFFFFFFFFFFFF8uLL) {
          unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v8 = v7;
        }
        if (v8) {
          unint64_t v8 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v8);
        }
        else {
          uint64_t v9 = 0;
        }
        uint64_t v10 = (void *)(v8 + 8 * v6);
        void *v10 = v4;
        uint64_t v5 = v10 + 1;
        uint64_t v11 = (char *)*((void *)&v15 + 1);
        uint64_t v12 = (char *)v15;
        if (*((void *)&v15 + 1) != (void)v15)
        {
          do
          {
            uint64_t v13 = *((void *)v11 - 1);
            v11 -= 8;
            *--uint64_t v10 = v13;
          }
          while (v11 != v12);
          uint64_t v11 = (char *)v15;
        }
        *(void *)&long long v15 = v10;
        *((void *)&v15 + 1) = v5;
        *(void *)&long long v16 = v8 + 8 * v9;
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *v5++ = v4;
      }
      *((void *)&v15 + 1) = v5;
      v4 += 120;
    }
    while (v4 != *(void *)(a1 + 88));
  }
  (*(void (**)(uint64_t, uint64_t, void (***)(AccelerationStructureViewer::DataSourceArray *__hidden)))(*(void *)a2 + 40))(a2, 18, &v14);
  (*(void (**)(uint64_t))(*(void *)a2 + 48))(a2);
  AccelerationStructureViewer::DataSourceArray::~DataSourceArray((AccelerationStructureViewer::DataSourceArray *)&v14);
}

void sub_1C927C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  AccelerationStructureViewer::DataSourceArray::~DataSourceArray((AccelerationStructureViewer::DataSourceArray *)va);
  _Unwind_Resume(a1);
}

void AccelerationStructureViewer::Instance::~Instance(id *this)
{
  *this = off_744498;
  uint64_t v2 = this + 10;
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v2);

  uint64_t v2 = this + 1;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v2);

  operator delete();
}

{
  void **v2;

  *this = off_744498;
  uint64_t v2 = this + 10;
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v2);

  uint64_t v2 = this + 1;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

uint64_t AccelerationStructureViewer::InstanceMotionAccelerationStructure::decode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = AccelerationStructureViewer::AccelerationStructure::decode(a1, a2, a3, a4);
  if (result)
  {
    if (!a3)
    {
      if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16))
      {
        uint64_t result = 0;
        *(unsigned char *)(a2 + 24) = 1;
        return result;
      }
      *(void *)(a1 + 120) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
      *(void *)a2 += 8;
    }
    return 1;
  }
  return result;
}

uint64_t AccelerationStructureViewer::AccelerationStructure::decode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 <= 11)
  {
    if (a3 != 1)
    {
      if (a3 == 2)
      {
        if ((unint64_t)(*(void *)a2 + 2) <= *(void *)(a2 + 16))
        {
          *(_WORD *)(a1 + 64) = *(_WORD *)(*(void *)(a2 + 8) + *(void *)a2);
          uint64_t v7 = *(void *)a2 + 2;
          goto LABEL_48;
        }
        goto LABEL_23;
      }
      if (a3 == 3)
      {
        if ((unint64_t)(*(void *)a2 + 8) <= *(void *)(a2 + 16))
        {
          *(void *)(a1 + 32) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
          goto LABEL_19;
        }
LABEL_23:
        uint64_t result = 0;
        *(unsigned char *)(a2 + 24) = 1;
        return result;
      }
      return 1;
    }
    if (AccelerationStructureViewer::DataSourceQueryBlobDecoder::consumeString((uint64_t *)a2, (void **)(a1 + 48), a4)) {
      return 1;
    }
  }
  else
  {
    if (a3 <= 17)
    {
      if (a3 == 12)
      {
        if ((unint64_t)(*(void *)a2 + 8) <= *(void *)(a2 + 16))
        {
          *(void *)(a1 + 56) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
          goto LABEL_19;
        }
        goto LABEL_23;
      }
      if (a3 == 14)
      {
        if ((unint64_t)(*(void *)a2 + 8) <= *(void *)(a2 + 16))
        {
          *(void *)(a1 + 40) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
LABEL_19:
          uint64_t v7 = *(void *)a2 + 8;
LABEL_48:
          *(void *)a2 = v7;
          return 1;
        }
        goto LABEL_23;
      }
      return 1;
    }
    if (a3 == 18)
    {
      __int16 v25 = 0;
      uint64_t v9 = (void *)AccelerationStructureViewer::DataSourceQueryBlobDecoder::decode(a2, &v25);
      uint64_t v10 = v9;
      if (v9 && !v25)
      {
        uint64_t v12 = (uint64_t *)v9[1];
        uint64_t v11 = (uint64_t *)v9[2];
        if (v12 != v11)
        {
          uint64_t v13 = (void *)(a1 + 96);
          uint64_t v14 = (uint64_t *)v9[1];
          do
          {
            if (*(_WORD *)(v10[4] + (((uint64_t)v12 - v10[1]) >> 2)) == 11)
            {
              uint64_t v15 = *v14;
              unint64_t v17 = *(void *)(a1 + 104);
              unint64_t v16 = *(void *)(a1 + 112);
              if (v17 >= v16)
              {
                unint64_t v19 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v17 - *v13) >> 3);
                unint64_t v20 = v19 + 1;
                if (v19 + 1 > 0x222222222222222) {
                  abort();
                }
                unint64_t v21 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v16 - *v13) >> 3);
                if (2 * v21 > v20) {
                  unint64_t v20 = 2 * v21;
                }
                if (v21 >= 0x111111111111111) {
                  unint64_t v22 = 0x222222222222222;
                }
                else {
                  unint64_t v22 = v20;
                }
                uint64_t v30 = a1 + 112;
                if (v22) {
                  unint64_t v22 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::Property>>(v22);
                }
                else {
                  uint64_t v23 = 0;
                }
                unint64_t v26 = v22;
                uint64_t v27 = v22 + 120 * v19;
                uint64_t v28 = v27;
                unint64_t v29 = v22 + 120 * v23;
                std::allocator<AccelerationStructureViewer::Property>::construct[abi:nn180100]<AccelerationStructureViewer::Property,AccelerationStructureViewer::Property const&>(v27, v15);
                v28 += 120;
                std::vector<AccelerationStructureViewer::Property>::__swap_out_circular_buffer((uint64_t *)(a1 + 96), &v26);
                unint64_t v18 = *(void *)(a1 + 104);
                std::__split_buffer<AccelerationStructureViewer::Property>::~__split_buffer((uint64_t)&v26);
              }
              else
              {
                std::allocator<AccelerationStructureViewer::Property>::construct[abi:nn180100]<AccelerationStructureViewer::Property,AccelerationStructureViewer::Property const&>(*(void *)(a1 + 104), *v14);
                unint64_t v18 = v17 + 120;
                *(void *)(a1 + 104) = v17 + 120;
              }
              *(void *)(a1 + 104) = v18;
              uint64_t v11 = (uint64_t *)v10[2];
            }
            ++v14;
            ++v12;
          }
          while (v14 != v11);
        }
        (*(void (**)(void *))(*v10 + 8))(v10);
        return 1;
      }
      if (v9)
      {
        __int16 v24 = *(void (**)(void))(*v9 + 8);
        goto LABEL_52;
      }
    }
    else
    {
      if (a3 != 28) {
        return 1;
      }
      LOWORD(v26) = 0;
      uint64_t v5 = AccelerationStructureViewer::DataSourceQueryBlobDecoder::decode(a2, &v26);
      if (v5 && (unsigned __int16)v26 == 15)
      {
        long long v6 = *(_OWORD *)(v5 + 8);
        *(void *)(a1 + 84) = *(void *)(v5 + 24);
        *(_OWORD *)(a1 + 68) = v6;
        (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        return 1;
      }
      if (v5)
      {
        __int16 v24 = *(void (**)(void))(*(void *)v5 + 8);
LABEL_52:
        v24();
      }
    }
  }
  return 0;
}

void sub_1C9784(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<AccelerationStructureViewer::Property>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t AccelerationStructureViewer::InstanceMotionAccelerationStructure::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 18);
  AccelerationStructureViewer::AccelerationStructure::encode(a1, a2);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 0, 8, a1 + 120);
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)a2 + 48);

  return v4(a2);
}

void AccelerationStructureViewer::AccelerationStructure::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 32))(a2, 1, *(void *)(a1 + 48));
  __int16 v21 = *(_DWORD *)(a1 + 64);
  (*(void (**)(uint64_t, uint64_t, uint64_t, __int16 *))(*(void *)a2 + 24))(a2, 2, 2, &v21);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 3, 8, a1 + 32);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 12, 8, a1 + 56);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 14, 8, a1 + 40);
  unint64_t v18 = off_744460;
  long long v19 = *(_OWORD *)(a1 + 68);
  uint64_t v20 = *(void *)(a1 + 84);
  (*(void (**)(uint64_t, uint64_t, void (***)(AccelerationStructureViewer::BoundingBox *__hidden)))(*(void *)a2 + 40))(a2, 28, &v18);
  uint64_t v14 = off_7441F8;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  uint64_t v4 = *(void *)(a1 + 96);
  if (v4 != *(void *)(a1 + 104))
  {
    uint64_t v5 = 0;
    do
    {
      if ((unint64_t)v5 >= (unint64_t)v16)
      {
        uint64_t v6 = (uint64_t)((uint64_t)v5 - v15) >> 3;
        if ((unint64_t)(v6 + 1) >> 61) {
          abort();
        }
        unint64_t v7 = (uint64_t)(v16 - v15) >> 2;
        if (v7 <= v6 + 1) {
          unint64_t v7 = v6 + 1;
        }
        if ((void)v16 - (void)v15 >= 0x7FFFFFFFFFFFFFF8uLL) {
          unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v8 = v7;
        }
        if (v8) {
          unint64_t v8 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v8);
        }
        else {
          uint64_t v9 = 0;
        }
        uint64_t v10 = (void *)(v8 + 8 * v6);
        void *v10 = v4;
        uint64_t v5 = v10 + 1;
        uint64_t v11 = (char *)*((void *)&v15 + 1);
        uint64_t v12 = (char *)v15;
        if (*((void *)&v15 + 1) != (void)v15)
        {
          do
          {
            uint64_t v13 = *((void *)v11 - 1);
            v11 -= 8;
            *--uint64_t v10 = v13;
          }
          while (v11 != v12);
          uint64_t v11 = (char *)v15;
        }
        *(void *)&long long v15 = v10;
        *((void *)&v15 + 1) = v5;
        *(void *)&long long v16 = v8 + 8 * v9;
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        *v5++ = v4;
      }
      *((void *)&v15 + 1) = v5;
      v4 += 120;
    }
    while (v4 != *(void *)(a1 + 104));
  }
  (*(void (**)(uint64_t, uint64_t, void (***)(AccelerationStructureViewer::DataSourceArray *__hidden)))(*(void *)a2 + 40))(a2, 18, &v14);
  AccelerationStructureViewer::DataSourceArray::~DataSourceArray((AccelerationStructureViewer::DataSourceArray *)&v14);
}

void sub_1C9B40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void AccelerationStructureViewer::InstanceMotionAccelerationStructure::~InstanceMotionAccelerationStructure(id *this)
{
  AccelerationStructureViewer::InstanceAccelerationStructure::~InstanceAccelerationStructure(this);

  operator delete();
}

void AccelerationStructureViewer::InstanceAccelerationStructure::~InstanceAccelerationStructure(id *this)
{
  *this = off_744310;
  uint64_t v2 = this + 12;
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v2);

  uint64_t v2 = this + 1;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

{
  uint64_t vars8;

  AccelerationStructureViewer::InstanceAccelerationStructure::~InstanceAccelerationStructure(this);

  operator delete();
}

void AccelerationStructureViewer::AccelerationStructure::~AccelerationStructure(id *this)
{
  *this = off_744310;
  uint64_t v2 = this + 12;
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v2);

  uint64_t v2 = this + 1;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v2);

  operator delete();
}

{
  void **v2;

  *this = off_744310;
  uint64_t v2 = this + 12;
  std::vector<AccelerationStructureViewer::Property>::__destroy_vector::operator()[abi:nn180100](&v2);

  uint64_t v2 = this + 1;
  std::vector<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

uint64_t AccelerationStructureViewer::InstanceAccelerationStructure::decode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = AccelerationStructureViewer::AccelerationStructure::decode(a1, a2, a3, a4);
  if (result)
  {
    if (!a3)
    {
      if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16))
      {
        uint64_t result = 0;
        *(unsigned char *)(a2 + 24) = 1;
        return result;
      }
      *(void *)(a1 + 120) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
      *(void *)a2 += 8;
    }
    return 1;
  }
  return result;
}

uint64_t AccelerationStructureViewer::InstanceAccelerationStructure::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 3);
  AccelerationStructureViewer::AccelerationStructure::encode(a1, a2);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 0, 8, a1 + 120);
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)a2 + 48);

  return v4(a2);
}

uint64_t AccelerationStructureViewer::PrimitiveMotionAccelerationStructure::decode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = AccelerationStructureViewer::AccelerationStructure::decode(a1, a2, a3, a4);
  if (result)
  {
    if (!a3)
    {
      if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16))
      {
        uint64_t result = 0;
        *(unsigned char *)(a2 + 24) = 1;
        return result;
      }
      *(void *)(a1 + 120) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
      *(void *)a2 += 8;
    }
    return 1;
  }
  return result;
}

uint64_t AccelerationStructureViewer::PrimitiveMotionAccelerationStructure::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 17);
  AccelerationStructureViewer::AccelerationStructure::encode(a1, a2);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 0, 8, a1 + 120);
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)a2 + 48);

  return v4(a2);
}

void AccelerationStructureViewer::PrimitiveMotionAccelerationStructure::~PrimitiveMotionAccelerationStructure(id *this)
{
  AccelerationStructureViewer::InstanceAccelerationStructure::~InstanceAccelerationStructure(this);

  operator delete();
}

uint64_t AccelerationStructureViewer::PrimitiveAccelerationStructure::decode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = AccelerationStructureViewer::AccelerationStructure::decode(a1, a2, a3, a4);
  if (result)
  {
    if (!a3)
    {
      if ((unint64_t)(*(void *)a2 + 8) > *(void *)(a2 + 16))
      {
        uint64_t result = 0;
        *(unsigned char *)(a2 + 24) = 1;
        return result;
      }
      *(void *)(a1 + 120) = *(void *)(*(void *)(a2 + 8) + *(void *)a2);
      *(void *)a2 += 8;
    }
    return 1;
  }
  return result;
}

uint64_t AccelerationStructureViewer::PrimitiveAccelerationStructure::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 2);
  AccelerationStructureViewer::AccelerationStructure::encode(a1, a2);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)a2 + 24))(a2, 0, 8, a1 + 120);
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)a2 + 48);

  return v4(a2);
}

void AccelerationStructureViewer::PrimitiveAccelerationStructure::~PrimitiveAccelerationStructure(id *this)
{
  AccelerationStructureViewer::InstanceAccelerationStructure::~InstanceAccelerationStructure(this);

  operator delete();
}

uint64_t AccelerationStructureViewer::InvalidAccelerationStructure::encode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, 3);
  AccelerationStructureViewer::AccelerationStructure::encode(a1, a2);
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)a2 + 48);

  return v4(a2);
}

void AccelerationStructureViewer::InvalidAccelerationStructure::~InvalidAccelerationStructure(id *this)
{
  AccelerationStructureViewer::InstanceAccelerationStructure::~InstanceAccelerationStructure(this);

  operator delete();
}

void AccelerationStructureViewer::DataSourceArray_StrongRef::~DataSourceArray_StrongRef(AccelerationStructureViewer::DataSourceArray_StrongRef *this)
{
  AccelerationStructureViewer::DataSourceArray_StrongRef::~DataSourceArray_StrongRef(this);

  operator delete();
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = off_744230;
  uint64_t v2 = (void *)*((void *)this + 1);
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v2 != v3)
  {
    do
    {
      if (*v2) {
        (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
      }
      ++v2;
    }
    while (v2 != v3);
    uint64_t v2 = (void *)*((void *)this + 1);
  }
  *((void *)this + 2) = v2;
  *((void *)this + 5) = *((void *)this + 4);

  AccelerationStructureViewer::DataSourceArray::~DataSourceArray(this);
}

uint64_t AccelerationStructureViewer::DataSourceError::decode()
{
  return 0;
}

void AccelerationStructureViewer::DataSourceError::~DataSourceError(id *this)
{
  operator delete();
}

{
}

uint64_t AccelerationStructureViewer::DataSourceQueryRequest::decode()
{
  return 0;
}

void AccelerationStructureViewer::DataSourceQueryRequest::~DataSourceQueryRequest(AccelerationStructureViewer::DataSourceQueryRequest *this)
{
}

uint64_t AccelerationStructureViewer::DataSourceFilterable::matches(AccelerationStructureViewer::DataSourceFilterable *this, AccelerationStructureViewer::Filter *a2)
{
  id v4 = objc_alloc_init((Class)NSNumberFormatter);
  uint64_t v5 = *((void *)a2 + 2);
  uint64_t v27 = a2;
  uint64_t v28 = *((void *)a2 + 3);
  if (v5 == v28)
  {
    uint64_t v24 = 1;
  }
  else
  {
    unint64_t v26 = v3;
    while (2)
    {
      int v30 = *(_DWORD *)(v5 + 8);
      id v31 = *(id *)(v5 + 16);
      uint64_t v6 = [v31 lowercaseString];
      unint64_t v8 = *(id **)this;
      unint64_t v7 = (unsigned __int16 *)*((void *)this + 1);
      while (v8 != (id *)v7)
      {
        int v9 = *(unsigned __int16 *)v8;
        id v10 = v8[1];
        uint64_t v11 = v10;
        if (HIWORD(v30)) {
          BOOL v12 = v9 == HIWORD(v30);
        }
        else {
          BOOL v12 = 1;
        }
        if (v12)
        {
          uint64_t v13 = [v10 lowercaseString];
          uint64_t v14 = v13;
          switch((__int16)v30)
          {
            case 0:
              unsigned int v20 = [v13 containsString:v6];
              goto LABEL_21;
            case 1:
              unsigned __int8 v21 = [v13 containsString:v6];
              goto LABEL_24;
            case 2:
              unsigned int v20 = [v13 isEqualToString:v6];
LABEL_21:
              unsigned int v22 = v20;

              if (v22) {
                goto LABEL_36;
              }
              goto LABEL_32;
            case 3:
              unsigned __int8 v21 = [v13 isEqualToString:v6];
LABEL_24:
              unsigned __int8 v23 = v21;

              if ((v23 & 1) == 0) {
                goto LABEL_36;
              }
              goto LABEL_32;
            case 4:
            case 5:
            case 6:
            case 7:
              long long v15 = [v4 numberFromString:v6];
              long long v16 = [v4 numberFromString:v14];
              long long v17 = v16;
              if (v15 && v16) {
                id v18 = [v16 compare:v15];
              }
              else {
                id v18 = [v14 localizedCaseInsensitiveCompare:v6];
              }
              unint64_t v19 = (unint64_t)v18;
              switch((__int16)v30)
              {
                case 4:

                  if (v19 == 1) {
                    goto LABEL_36;
                  }
                  goto LABEL_32;
                case 5:
                  break;
                case 6:

                  if (v19 == -1) {
                    goto LABEL_36;
                  }
                  goto LABEL_32;
                case 7:
                  unint64_t v19 = (unint64_t)v18 + 1;
                  break;
                default:

                  goto LABEL_27;
              }

              if (v19 >= 2) {
                goto LABEL_32;
              }
LABEL_36:

              break;
            default:
LABEL_27:

              goto LABEL_32;
          }
          goto LABEL_34;
        }
LABEL_32:

        v8 += 2;
      }
      if (*((unsigned char *)v27 + 8) == 1)
      {

        uint64_t v24 = 0;
        goto LABEL_39;
      }
LABEL_34:

      v5 += 24;
      if (v5 != v28) {
        continue;
      }
      break;
    }
    uint64_t v24 = 1;
LABEL_39:
    uint64_t v3 = v26;
  }

  return v24;
}

void sub_1CA6B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1CA7A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1CA80C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1CA874(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1CA97C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1CAA6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GTUSCSamplingStreamingManagerHelper::CleanupGPURawCounters(uint64_t this)
{
  if (*(void *)(this + 16))
  {
    uint64_t v1 = this;
    uint64_t v2 = *(void **)(this + 24);
    *(void *)(this + 24) = 0;

    uint64_t v3 = *(void **)(v1 + 16);
    *(void *)(v1 + 16) = 0;

    return GRCReleaseAllCounterSourceGroup();
  }
  return this;
}

void GTUSCSamplingStreamingManagerHelper::SetupGPURawCounters(GTUSCSamplingStreamingManagerHelper *this)
{
  GTUSCSamplingStreamingManagerHelper::CleanupGPURawCounters((uint64_t)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance);
  uint64_t v1 = GRCCopyAllCounterSourceGroup();
  uint64_t v2 = (void *)xmmword_772038;
  *(void *)&xmmword_772038 = v1;

  if ((void)xmmword_772038 && [(id)xmmword_772038 count])
  {
    id v31 = [(id)xmmword_772038 firstObject];
    uint64_t v37 = [v31 sourceList];
    if (v37 && [v37 count])
    {
      if (objc_opt_respondsToSelector())
      {
        uint64_t v3 = [v31 features];
        dword_772898 = GPURawCounterSupportFlags(v3);

        id v4 = [v31 features];

        if (v4)
        {
          uint64_t v5 = [v31 features];
          uint64_t v6 = [v5 objectForKeyedSubscript:@"ConstantAGX_CoreConfig"];

          if (v6) {
            objc_storeStrong((id *)&qword_7727E8, v6);
          }
        }
        std::vector<unsigned int>::value_type __x = 0;
        std::vector<unsigned int>::resize((std::vector<unsigned int> *)&xmmword_772798, (std::vector<unsigned int>::size_type)[v37 count], &__x);
        for (unint64_t i = 0; i < (unint64_t)[v37 count]; ++i)
        {
          unint64_t v8 = [v37 objectAtIndexedSubscript:i];
          if (objc_opt_respondsToSelector())
          {
            int v9 = [v8 features];
            *(_DWORD *)(xmmword_772798 + 4 * i) = GPURawCounterSupportFlags(v9);
          }
        }
      }
      id v36 = +[NSMutableArray arrayWithCapacity:3];
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      obunint64_t j = v37;
      id v10 = [obj countByEnumeratingWithState:&v42 objects:v48 count:16];
      if (v10)
      {
        uint64_t v34 = *(void *)v43;
LABEL_17:
        uint64_t v11 = 0;
        id v33 = v10;
        while (1)
        {
          if (*(void *)v43 != v34) {
            objc_enumerationMutation(obj);
          }
          BOOL v12 = *(void **)(*((void *)&v42 + 1) + 8 * v11);
          if (![v12 ringBufferNum])
          {

            goto LABEL_47;
          }
          uint64_t v13 = [v12 name];
          unsigned int v14 = [v13 containsString:@"RDE"];
          if (v14) {
            goto LABEL_24;
          }
          long long v15 = [v12 name];
          if ([v15 hasPrefix:@"Firmware"]) {
            break;
          }
          unint64_t v29 = [v12 name];
          unsigned __int8 v30 = [v29 containsString:@"APS_USC"];

          if (v30)
          {
            int v16 = 1;
            goto LABEL_25;
          }
LABEL_42:
          if ((id)++v11 == v33)
          {
            id v10 = [obj countByEnumeratingWithState:&v42 objects:v48 count:16];
            if (v10) {
              goto LABEL_17;
            }
            goto LABEL_44;
          }
        }

LABEL_24:
        int v16 = 0;
LABEL_25:
        [v36 addObject:v12];
        HIDWORD(qword_7728A0) += v14;
        if (((v14 & 1) != 0 || [obj count] == (char *)&def_1C1270 + 1) && !qword_772810)
        {
          uint64_t v17 = +[NSMutableArray arrayWithCapacity:10];
          id v18 = (void *)qword_772810;
          qword_772810 = v17;

          unint64_t v19 = [v12 availableCounters];
          long long v40 = 0u;
          long long v41 = 0u;
          long long v38 = 0u;
          long long v39 = 0u;
          id v20 = v19;
          id v21 = [v20 countByEnumeratingWithState:&v38 objects:v47 count:16];
          if (v21)
          {
            uint64_t v22 = *(void *)v39;
            do
            {
              for (unint64_t j = 0; j != v21; unint64_t j = (char *)j + 1)
              {
                if (*(void *)v39 != v22) {
                  objc_enumerationMutation(v20);
                }
                uint64_t v24 = *(void **)(*((void *)&v38 + 1) + 8 * (void)j);
                __int16 v25 = [v24 name];
                unsigned int v26 = [v25 hasPrefix:@"GRC_SHADER_PROFILER_DATA_"];

                if (v26)
                {
                  uint64_t v27 = (void *)qword_772810;
                  uint64_t v28 = [v24 name];
                  [v27 addObject:v28];
                }
              }
              id v21 = [v20 countByEnumeratingWithState:&v38 objects:v47 count:16];
            }
            while (v21);
          }
        }
        else if (v16)
        {
          LODWORD(qword_7728A8) = [v36 count] - 1;
        }
        goto LABEL_42;
      }
LABEL_44:

      if ([v36 count])
      {
        objc_storeStrong((id *)&xmmword_772038 + 1, v36);
        qword_772048 = (uint64_t)[v31 sampleMarker];
      }
LABEL_47:
    }
  }
}

void sub_1CAFC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

uint64_t GPURawCounterSupportFlags(NSDictionary *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    uint64_t v3 = [(NSDictionary *)v1 allKeys];
    uint64_t v4 = 0;
    id v5 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
    if (v5)
    {
      uint64_t v6 = *(void *)v12;
      do
      {
        for (unint64_t i = 0; i != v5; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v12 != v6) {
            objc_enumerationMutation(v3);
          }
          unint64_t v8 = [&off_758FE0 objectForKeyedSubscript:*(void *)(*((void *)&v11 + 1) + 8 * i)];
          int v9 = v8;
          if (v8) {
            uint64_t v4 = [v8 unsignedIntValue] | v4;
          }
        }
        id v5 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
      }
      while (v5);
    }
  }
  else
  {
    uint64_t v4 = 0;
  }

  return v4;
}

void sub_1CB200(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<unsigned int>::resize(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __sz, std::vector<unsigned int>::const_reference __x)
{
  std::vector<unsigned int>::pointer begin = this->__begin_;
  std::vector<unsigned int>::pointer end = this->__end_;
  std::vector<unsigned int>::size_type v7 = end - this->__begin_;
  if (__sz <= v7)
  {
    if (__sz < v7) {
      this->__end_ = &begin[__sz];
    }
  }
  else
  {
    value = this->__end_cap_.__value_;
    if (__sz - v7 <= value - end)
    {
      unsigned __int8 v23 = &end[__sz - v7];
      std::vector<unsigned int>::size_type v24 = 4 * __sz - 4 * v7;
      do
      {
        *end++ = *__x;
        v24 -= 4;
      }
      while (v24);
      this->__end_ = v23;
    }
    else
    {
      if (__sz >> 62) {
        abort();
      }
      unint64_t v10 = (char *)value - (char *)begin;
      std::vector<unsigned int>::size_type v11 = ((char *)value - (char *)begin) >> 1;
      if (v11 <= __sz) {
        std::vector<unsigned int>::size_type v11 = __sz;
      }
      if (v10 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v11;
      }
      long long v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(v12);
      long long v15 = (unsigned int *)&v13[4 * v7];
      int v16 = (unsigned int *)&v13[4 * __sz];
      std::vector<unsigned int>::size_type v17 = 4 * __sz - 4 * v7;
      id v18 = v15;
      do
      {
        *v18++ = *__x;
        v17 -= 4;
      }
      while (v17);
      unint64_t v19 = (unsigned int *)&v13[4 * v14];
      std::vector<unsigned int>::pointer v20 = this->__begin_;
      for (std::vector<unsigned int>::pointer i = this->__end_; i != v20; --i)
      {
        unsigned int v22 = *(i - 1);
        *--long long v15 = v22;
      }
      this->__begin_ = v15;
      this->__end_ = v16;
      this->__end_cap_.__value_ = v19;
      if (v20)
      {
        operator delete(v20);
      }
    }
  }
}

id GTUSCSamplingStreamingManagerHelper::ResetSourceForPostProcessing(id *this)
{
  id result = [this[3] count];
  if (result)
  {
    uint64_t v3 = 0;
    unsigned int v4 = 1;
    do
    {
      id v5 = [this[3] objectAtIndexedSubscript:v3];
      [v5 resetRawDataPostProcessor];

      uint64_t v3 = v4;
      id result = [this[3] count];
    }
    while ((unint64_t)result > v4++);
  }
  return result;
}

void sub_1CB3D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GTUSCSamplingStreamingManagerHelper::SetupSourceForDerivedCounters(id *this, NSDictionary *a2, unsigned int a3, int a4, int a5)
{
  long long v44 = a2;
  int v9 = [this[2] firstObject];
  if (!v9)
  {
    uint64_t v15 = 0;
    goto LABEL_39;
  }
  if (!a3)
  {
    if ((a4 & 1) != 0 || GTAGXPerfStateControl::IsGPUPerformanceStateInduced((GTAGXPerfStateControl *)(this + 5)))
    {
      unint64_t v10 = [this[2] firstObject];
      [v10 setOptions:&off_758DD8];
LABEL_6:

      goto LABEL_7;
    }
    uint64_t v36 = *((unsigned int *)*this + 18);
    if (v36)
    {
      GTAGXPerfStateControl::EnableConsistentGPUPerfState((uint64_t)(this + 5), v36);
      uint64_t v37 = GTApplePMPPerfStateControl::EnableConsistentPerfState((GTApplePMPPerfStateControl *)(this + 8), *((_DWORD *)*this + 18) - 1);
      id v38 = this[261];
      this[261] = (id)v37;

      unint64_t v10 = [this[2] firstObject];
      [v10 setOptions:&off_758DB0];
      goto LABEL_6;
    }
    uint64_t v39 = GTApplePMPPerfStateControl::EnableConsistentPerfState((GTApplePMPPerfStateControl *)(this + 8), 1u);
    id v40 = this[261];
    this[261] = (id)v39;

    v50[0] = @"DisableOverlap";
    v50[1] = @"LockGPUPerfState";
    v51[0] = &__kCFBooleanTrue;
    long long v41 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)*this + 17)];
    v51[1] = v41;
    long long v42 = +[NSDictionary dictionaryWithObjects:v51 forKeys:v50 count:2];
    long long v43 = [this[2] firstObject];
    [v43 setOptions:v42];
  }
LABEL_7:
  if (a5)
  {
    std::vector<unsigned int>::size_type v11 = [this[2] firstObject];
    unint64_t v12 = [v11 options];
    id v13 = [v12 mutableCopy];

    [v13 setObject:&__kCFBooleanTrue forKeyedSubscript:@"ReduceCDMCluster"];
    uint64_t v14 = [this[2] firstObject];
    [v14 setOptions:v13];
  }
  else
  {
    if (!a3 || !a4) {
      goto LABEL_14;
    }
    int v16 = [this[2] firstObject];
    std::vector<unsigned int>::size_type v17 = [v16 options];
    id v13 = [v17 mutableCopy];

    [v13 removeObjectForKey:@"ReduceCDMCluster"];
    uint64_t v14 = [this[2] firstObject];
    [v14 setOptions:v13];
  }

LABEL_14:
  id v18 = [(NSDictionary *)v44 objectForKeyedSubscript:@"passList"];
  unint64_t v19 = [v18 objectAtIndexedSubscript:a3];

  if (v19)
  {
    unint64_t v20 = 0;
    double v21 = *((double *)this + 394) + *((double *)this + 394);
    if (v21 <= 1.0) {
      double v22 = 10240.0;
    }
    else {
      double v22 = v21 * 10240.0;
    }
    unint64_t v23 = (unint64_t)v22;
    while (1)
    {
      if (v20 >= (unint64_t)[this[3] count])
      {
        uint64_t v15 = 1;
        goto LABEL_38;
      }
      std::vector<unsigned int>::size_type v24 = [this[3] objectAtIndexedSubscript:v20];
      __int16 v25 = [v24 name];
      unsigned __int8 v26 = [v25 containsString:@"APS_USC"];

      if ((v26 & 1) == 0)
      {
        if (!a3)
        {
          uint64_t v27 = this[238];
          if (v20 < ((unint64_t)((unsigned char *)this[239] - v27) >> 2)
            && (*(_DWORD *)&v27[4 * v20] & 0x20) != 0)
          {
            v48[0] = @"SWResetOnRead";
            v48[1] = @"RingBufferSizeInKB";
            v49[0] = &__kCFBooleanTrue;
            uint64_t v28 = +[NSNumber numberWithUnsignedLong:v23];
            v49[1] = v28;
            unint64_t v29 = +[NSDictionary dictionaryWithObjects:v49 forKeys:v48 count:2];
            [v24 setOptions:v29];
          }
          else
          {
            CFStringRef v46 = @"RingBufferSizeInKB";
            uint64_t v28 = +[NSNumber numberWithUnsignedLong:v23];
            uint64_t v47 = v28;
            unint64_t v29 = +[NSDictionary dictionaryWithObjects:&v47 forKeys:&v46 count:1];
            [v24 setOptions:v29];
          }

          unsigned __int8 v30 = [v24 name];
          unsigned int v31 = [v30 containsString:@"BMPR_RDE_1"];

          uint64_t v32 = 257;
          if (v31) {
            uint64_t v32 = 256;
          }
          [v24 requestTriggers:this[v32] firstErrorIndex:0];
        }
        id v33 = [v19 objectAtIndexedSubscript:v20];
        if (![v33 count])
        {
          id v34 = this[249];

          id v33 = v34;
        }
        uint64_t v45 = 0;
        if (([v24 requestCounters:v33 firstErrorIndex:&v45] & 1) == 0
          || ([v24 setEnabled:1] & 1) == 0)
        {

          break;
        }
      }
      ++v20;
    }
  }
  uint64_t v15 = 0;
LABEL_38:

LABEL_39:
  return v15;
}

void sub_1CB8EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManagerHelper::ReplaySingleFrameForUSCSampling()
{
  uint64_t v0 = __chkstk_darwin();
  uint64_t v2 = v1;
  id v89 = v3;
  BOOL v83 = v4;
  uint64_t v86 = v5;
  uint64_t v6 = v0;
  id v82 = v7;
  unint64_t v8 = v2;
  uint64_t v84 = [*(id *)(*(void *)v6 + 16) objectForKeyedSubscript:@"perEncoderDrawCallCount"];
  int v9 = **(id ***)v6;
  id v10 = v9[1];
  uint64_t v96 = (uint64_t)v9;
  std::vector<unsigned int>::size_type v11 = (uint64_t *)*v9;
  uint64_t v12 = *((void *)*v9 + 2);
  id v13 = [v10 defaultDevice];
  id v14 = [v13 newEvent];

  std::vector<std::pair<unsigned long long,unsigned long long>>::reserve(v89, *(void *)(v6 + 2272));
  uint64_t v15 = [v10 defaultCommandQueue];
  int v16 = [v15 commandBuffer];
  uint64_t v95 = v12;
  unint64_t v98 = v10;
  uint64_t v85 = v8;

  long long v91 = v14;
  [v16 encodeSignalEvent:v14 value:GTUSCSamplingStreamingManagerHelper::ReplaySingleFrameForUSCSampling(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &,std::unordered_map<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>> &,std::vector<std::pair<unsigned long long,unsigned long long>> &,GTMTLFXTracingDelegate *,void({block_pointer})(void))::signalCounter];
  [v16 commit];
  uint64_t v77 = v16;
  std::vector<unsigned int>::size_type v17 = (unsigned int *)(v96 + 22480);
  unint64_t v18 = *(unsigned int *)(v96 + 22480);
  if (v11[13] + v11[12] > v18)
  {
    unsigned int v78 = 0;
    char v79 = 0;
    unsigned int v81 = 0;
    char v88 = 0;
    uint64_t v90 = v11;
    while (1)
    {
      uint64_t v19 = *(unsigned int *)(v96 + 22484);
      unint64_t v20 = *v17;
      uint64_t v97 = *(void *)(v11[15] + 24);
      uint64_t v21 = v97 + (v20 << 6);
      double v22 = (int *)(v21 + 8);
      int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v21 + 8));
      if (FuncEnumConstructorType == 25)
      {
        if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>((void *)(v6 + 2248), v20))
        {
          unint64_t v23 = [v98 defaultCommandQueue];
          std::vector<unsigned int>::size_type v24 = [v23 commandBuffer];

          [v24 encodeWaitForEvent:v91 value:GTUSCSamplingStreamingManagerHelper::ReplaySingleFrameForUSCSampling(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &,std::unordered_map<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>> &,std::vector<std::pair<unsigned long long,unsigned long long>> &,GTMTLFXTracingDelegate *,void({block_pointer})(void))::signalCounter++];
          [v24 encodeSignalEvent:v91];
          v100[0] = _NSConcreteStackBlock;
          v100[1] = 3221225472;
          v100[2] = ___ZN35GTUSCSamplingStreamingManagerHelper31ReplaySingleFrameForUSCSamplingERNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS0_4hashIjEENS0_8equal_toIjEENS0_9allocatorINS0_4pairIKjS2_EEEEEERNS1_IjNS0_6vectorI27GTCoalescedEncoderIndexInfoNS7_ISF_EEEES4_S6_NS7_INS8_IS9_SH_EEEEEERNSE_INS8_IyyEENS7_ISM_EEEEP22GTMTLFXTracingDelegateU13block_pointerFvvE_block_invoke;
          v100[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
          v100[4] = v89;
          [v24 addCompletedHandler:v100];
          [v24 commit];
        }
        int v93 = GTMTLReplayController_restoreCommandBuffer(v96, v21);
      }
      else
      {
        int v93 = 0;
      }
      GTMTLReplayController_updateCommandEncoder(v96, v21);
      uint64_t v25 = v18 | (v19 << 32);
      if (*(_DWORD *)(v6 + 2176) == -1) {
        goto LABEL_25;
      }
      int v26 = *v22;
      if (IsFuncEnumDrawCall(*v22)) {
        break;
      }
      if (v26 <= -16138)
      {
        BOOL v28 = v26 == -16327;
        int v29 = -16220;
      }
      else
      {
        BOOL v27 = (v26 + 16137) > 0x3B || ((1 << (v26 + 9)) & 0xC00000000000001) == 0;
        BOOL v28 = !v27 || v26 == -15486;
        int v29 = -15297;
      }
      BOOL v30 = v28 || v26 == v29;
      if (v30 || (v26 + 15416) <= 2) {
        break;
      }
      if (IsFuncEnumSampledBlitCall(v26) || IsFuncEnumSampledBlitCallAGX(v26))
      {
        [*(id *)(v6 + 1944) addSampledCallFunctionIndex:v25 forIndex:v78++ forEncoder:v81 atEncoderIndex:[*(int *)(v6 + 1928) - 1] forType:@"Blit" v76];
        goto LABEL_25;
      }
LABEL_26:
      if (v26 > -16247)
      {
        if (v26 > -15588)
        {
          if (v26 <= -15365)
          {
            if (v26 == -15587)
            {
LABEL_65:
              uint64_t v46 = *(void *)(v6 + 1928);
              *(void *)(v6 + 1928) = v46 + 1;
              **(_DWORD **)(v6 + 1936) = **(unsigned __int8 **)(v6 + 1936) | (v46 << 8);
              *(void *)(v6 + 1936) += 24;
              *(void *)(v6 + 1976) += 24;
              GTMTLReplayController_defaultDispatchFunction(v96, v21);
              uint64_t v47 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)v21, *(unsigned __int8 *)(v97 + (v20 << 6) + 13), v95)+ 1);
              unsigned int v81 = [v98 globalTraceIdForEncoder:v47 ofType:0];
              unsigned int v31 = [v98 blitCommandEncoderForKey:v47];
              GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints((_DWORD *)v6, v86, v21, v81, v31, *(void *)(v6 + 1928) - 1, v25, v83);
              unsigned int v78 = 0;
              goto LABEL_92;
            }
            if (v26 == -15586)
            {
              uint64_t v36 = +[NSNumber numberWithUnsignedInt:*v17];
              unsigned int v31 = [v84 objectForKeyedSubscript:v36];

              if (v31)
              {
                id v37 = [v31 unsignedIntegerValue];
                uint64_t v38 = *(void *)(v6 + 1928);
                *(void *)(v6 + 1928) = v38 + 1;
                **(_DWORD **)(v6 + 1936) = **(unsigned __int8 **)(v6 + 1936) | (v38 << 8);
                *(void *)(v6 + 1936) += 24;
                uint64_t v39 = GTTraceFunc_argumentBytesWithMap((void *)v21, *(unsigned __int8 *)(v97 + (v20 << 6) + 13), v95);
                int v87 = [v98 commandBufferForKey:*(void *)v39];
                bzero(v101, 0x2B90uLL);
                GTMTLSMCommandEncoder_processTraceFunc((uint64_t)v101, (uint64_t *)v21, v95);
                uint64_t v40 = v102;
                long long v41 = [v98 computePassDescriptorMap];
                long long v42 = MakeMTLComputePassDescriptor(v40, v41);

                id v43 = v42;
                [v43 setAllowCommandEncoderCoalescing:1];
                long long v44 = [v87 sampledComputeCommandEncoderWithDescriptor:v43 programInfoBuffer:*(void *)(v6 + 1936) capacity:v37];
                GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints((_DWORD *)v6, v86, v21, [v44 globalTraceObjectID], v44, *(void *)(v6 + 1928) - 1, v25, v83);
                [v98 setComputeCommandEncoder:v44 forKey:*((void *)v39 + 1)];
                *(void *)(v6 + 1936) += 24 * (void)v37;
                *(void *)(v6 + 1976) += 24 * (void)v37 + 24;

                uint64_t v45 = v43;
                goto LABEL_76;
              }
LABEL_91:
              GTMTLReplayController_dispatchForUSCSampling(v96, v21, v98, v95, *(void **)(v6 + 1944), (*(_DWORD *)(v6 + 1928) - 1));
              unsigned int v31 = 0;
LABEL_92:

              goto LABEL_93;
            }
            goto LABEL_59;
          }
          if (v26 == -15364)
          {
LABEL_66:
            uint64_t v48 = *(void *)(v6 + 1928);
            *(void *)(v6 + 1928) = v48 + 1;
            **(_DWORD **)(v6 + 1936) = **(unsigned __int8 **)(v6 + 1936) | (v48 << 8);
            *(void *)(v6 + 1936) += 24;
            *(void *)(v6 + 1976) += 24;
            GTMTLReplayController_defaultDispatchFunction(v96, v21);
            uint64_t v49 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)v21, *(unsigned __int8 *)(v97 + (v20 << 6) + 13), v95)+ 1);
            id v50 = [v98 globalTraceIdForEncoder:v49 ofType:0];
            unsigned int v31 = [v98 accelerationStructureCommandEncoderForKey:v49];
            GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints((_DWORD *)v6, v86, v21, v50, v31, *(void *)(v6 + 1928) - 1, v25, v83);
            [*(id *)(v6 + 1944) addOtherEncoderFunctionIndex:v25 forEncoder:v50 atEncoderIndex:(*(_DWORD *)(v6 + 1928) - 1) forType:@"AccelerationStructure"];
            goto LABEL_92;
          }
          if (v26 == -15318 || v26 == -15316) {
            goto LABEL_56;
          }
        }
        else
        {
          if (v26 > -16015)
          {
            if (v26 == -16014)
            {
              uint64_t v69 = +[NSNumber numberWithUnsignedInt:*v17];
              unsigned int v31 = [v84 objectForKeyedSubscript:v69];

              if (!v31) {
                goto LABEL_91;
              }
              id v76 = [v31 unsignedIntegerValue];
              uint64_t v70 = *(void *)(v6 + 1928);
              *(void *)(v6 + 1928) = v70 + 1;
              **(_DWORD **)(v6 + 1936) = **(unsigned __int8 **)(v6 + 1936) | (v70 << 8);
              *(void *)(v6 + 1936) += 24;
              BOOL v71 = GTTraceFunc_argumentBytesWithMap((void *)v21, *(unsigned __int8 *)(v97 + (v20 << 6) + 13), v95);
              int v87 = [v98 commandBufferForKey:*(void *)v71];
              id v43 = objc_alloc_init((Class)MTLComputePassDescriptor);
              [v43 setAllowCommandEncoderCoalescing:1];
              [v43 setDispatchType:*((void *)v71 + 2)];
              uint64_t v45 = [v87 sampledComputeCommandEncoderWithDescriptor:v43 programInfoBuffer:*(void *)(v6 + 1936) capacity:v76];
              GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints((_DWORD *)v6, v86, v21, [v45 globalTraceObjectID], v45, *(void *)(v6 + 1928) - 1, v25, v83);
              [v98 setComputeCommandEncoder:v45 forKey:*((void *)v71 + 1)];
              *(void *)(v6 + 1936) += 24 * (void)v76;
              uint64_t v58 = *(void *)(v6 + 1976) + 24 * (void)v76 + 24;
LABEL_75:
              *(void *)(v6 + 1976) = v58;
LABEL_76:

              goto LABEL_92;
            }
            if (v26 != -15908)
            {
              if (v26 == -15673) {
                goto LABEL_66;
              }
              goto LABEL_59;
            }
            goto LABEL_56;
          }
          if (v26 == -16246)
          {
            if (v79)
            {
              [v98 removeRenderCommandEncoderForKey:*(void *)GTTraceFunc_argumentBytesWithMap((void *)v21, *(unsigned __int8 *)(v97 + (v20 << 6) + 13), v95)];
              char v79 = 1;
            }
            else
            {
LABEL_79:
              GTMTLReplayController_dispatchForUSCSampling(v96, v21, v98, v95, *(void **)(v6 + 1944), (*(_DWORD *)(v6 + 1928) - 1));
              char v79 = 0;
            }
            goto LABEL_93;
          }
          if (v26 == -16202)
          {
LABEL_56:
            if (!(v88 & 1 | (v85 == 0)))
            {
              v85[2]();
              int v26 = *v22;
            }
            char v88 = 1;
          }
        }
LABEL_59:
        if (v26 >> 2 == 1073737833)
        {
          GTUSCSamplingStreamingManagerHelper::DispatchExpandedIndirectCommand();
          goto LABEL_93;
        }
        goto LABEL_60;
      }
      if (v26 > -16362)
      {
        switch(v26)
        {
          case -16361:
            goto LABEL_56;
          case -16360:
          case -16359:
          case -16358:
          case -16357:
          case -16356:
            goto LABEL_59;
          case -16355:
            unsigned int v31 = [*(id *)(v96 + 8) defaultCommandQueue];
            [v31 finish];
            goto LABEL_92;
          case -16354:
            goto LABEL_65;
          case -16353:
            uint64_t v51 = +[NSNumber numberWithUnsignedInt:*v17];
            unsigned int v31 = [v84 objectForKeyedSubscript:v51];

            if (!v31) {
              goto LABEL_91;
            }
            id v76 = [v31 unsignedIntegerValue];
            uint64_t v52 = *(void *)(v6 + 1928);
            *(void *)(v6 + 1928) = v52 + 1;
            **(_DWORD **)(v6 + 1936) = **(unsigned __int8 **)(v6 + 1936) | (v52 << 8);
            *(void *)(v6 + 1936) += 24;
            unint64_t v53 = GTTraceFunc_argumentBytesWithMap((void *)v21, *(unsigned __int8 *)(v97 + (v20 << 6) + 13), v95);
            uint64_t RenderPassDescriptor = GetRenderPassDescriptor();
            uint64_t v55 = v53;
            int v87 = [v98 commandBufferForKey:*(void *)v53];
            unint64_t v56 = [v98 renderPassDescriptorMap];
            uint64_t v45 = MakeMTLRenderPassDescriptor(RenderPassDescriptor, v56);
            uint64_t v57 = 2 * (void)v76 + 2;

            id v43 = [v87 sampledRenderCommandEncoderWithDescriptor:v45 programInfoBuffer:*(void *)(v6 + 1936) capacity:v57];
            GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints((_DWORD *)v6, v86, v21, [v43 globalTraceObjectID], v43, *(void *)(v6 + 1928) - 1, v25, 0);
            [v98 setRenderCommandEncoder:v43 forKey:*((void *)v55 + 1)];
            *(void *)(v6 + 1936) += 24 * v57;
            uint64_t v58 = *(void *)(v6 + 1976) + 48 * (void)v76 + 72;
            goto LABEL_75;
          case -16352:
            unint64_t v59 = +[NSNumber numberWithUnsignedInt:*v17];
            unsigned int v31 = [v84 objectForKeyedSubscript:v59];

            if (!v31) {
              goto LABEL_91;
            }
            id v76 = [v31 unsignedIntegerValue];
            uint64_t v60 = *(void *)(v6 + 1928);
            *(void *)(v6 + 1928) = v60 + 1;
            **(_DWORD **)(v6 + 1936) = **(unsigned __int8 **)(v6 + 1936) | (v60 << 8);
            *(void *)(v6 + 1936) += 24;
            simd_float3 v61 = GTTraceFunc_argumentBytesWithMap((void *)v21, *(unsigned __int8 *)(v97 + (v20 << 6) + 13), v95);
            int v87 = [v98 commandBufferForKey:*(void *)v61];
            id v43 = objc_alloc_init((Class)MTLComputePassDescriptor);
            [v43 setAllowCommandEncoderCoalescing:1];
            uint64_t v45 = [v87 sampledComputeCommandEncoderWithDescriptor:v43 programInfoBuffer:*(void *)(v6 + 1936) capacity:v76];
            GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints((_DWORD *)v6, v86, v21, [v45 globalTraceObjectID], v45, *(void *)(v6 + 1928) - 1, v25, v83);
            [v98 setComputeCommandEncoder:v45 forKey:*((void *)v61 + 1)];
            *(void *)(v6 + 1936) += 24 * (void)v76;
            *(void *)(v6 + 1976) += 24 * (void)v76 + 24;

            goto LABEL_76;
          case -16351:
            id v62 = +[NSNumber numberWithUnsignedInt:*v17];
            unsigned int v31 = [v84 objectForKeyedSubscript:v62];

            if (v31)
            {
              id v80 = [v31 unsignedIntegerValue];
              uint64_t v63 = *(void *)(v6 + 1928);
              *(void *)(v6 + 1928) = v63 + 1;
              **(_DWORD **)(v6 + 1936) = **(unsigned __int8 **)(v6 + 1936) | (v63 << 8);
              *(void *)(v6 + 1936) += 24;
              int v64 = GTTraceFunc_argumentBytesWithMap((void *)v21, *(unsigned __int8 *)(v97 + (v20 << 6) + 13), v95);
              uint64_t v65 = GetRenderPassDescriptor();
              unint64_t v66 = v64;
              int v87 = [v98 commandBufferForKey:*(void *)v64];
              uint64_t v67 = [v98 renderPassDescriptorMap];
              uint64_t v45 = MakeMTLRenderPassDescriptor(v65, v67);
              uint64_t v68 = 2 * (void)v80 + 2;

              id v43 = [v87 sampledRenderCommandEncoderWithDescriptor:v45 programInfoBuffer:*(void *)(v6 + 1936) capacity:v68];
              GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints((_DWORD *)v6, v86, v21, [v43 globalTraceObjectID], v43, *(void *)(v6 + 1928) - 1, v25, 0);
              [v98 setParallelRenderCommandEncoder:v43 forKey:*((void *)v66 + 1)];
              *(void *)(v6 + 1936) += 24 * v68;
              *(void *)(v6 + 1976) += 48 * (void)v80 + 72;
              char v79 = 1;
              goto LABEL_76;
            }
            GTMTLReplayController_dispatchForUSCSampling(v96, v21, v98, v95, *(void **)(v6 + 1944), (*(_DWORD *)(v6 + 1928) - 1));
            unsigned int v31 = 0;
            char v79 = 1;
            goto LABEL_92;
          default:
            if (v26 == -16286)
            {
              simd_float3 v72 = GTTraceFunc_argumentBytesWithMap((void *)v21, *(unsigned __int8 *)(v97 + (v20 << 6) + 13), v95);
              unsigned int v31 = [v98 parallelRenderCommandEncoderForKey:*(void *)v72];
              [v98 setRenderCommandEncoder:v31 forKey:*((void *)v72 + 1)];
              goto LABEL_92;
            }
            if (v26 == -16285) {
              goto LABEL_79;
            }
            break;
        }
        goto LABEL_59;
      }
      if (v26 != -20474 && v26 != -20457) {
        goto LABEL_59;
      }
      if (v82)
      {
        id v34 = GTTraceFunc_targetContext(v21, v90[2]);
        if (*v22 == -20474) {
          [v98 spatialScalerForKey:v34];
        }
        else {
        uint64_t v35 = [v98 temporalScalerForKey:v34];
        }
        uint64_t v73 = DEVICEOBJECT(v35);

        [v73 setTracingDelegate:v82];
        [v82 setFunctionIndex:v25];
      }
LABEL_60:
      GTMTLReplayController_dispatchForUSCSampling(v96, v21, v98, v95, *(void **)(v6 + 1944), (*(_DWORD *)(v6 + 1928) - 1));
LABEL_93:
      if (v93)
      {
        unint64_t v74 = [v98 commandBufferForKey:*((void *)GTTraceFunc_argumentBytesWithMap((void *)v21, *(unsigned __int8 *)(v97 + (v20 << 6) + 13), v95)+ 1)];
        [v74 encodeWaitForEvent:v91 value:GTUSCSamplingStreamingManagerHelper::ReplaySingleFrameForUSCSampling(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &,std::unordered_map<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>> &,std::vector<std::pair<unsigned long long,unsigned long long>> &,GTMTLFXTracingDelegate *,void({block_pointer})(void))::signalCounter++];
        [v74 encodeSignalEvent:v91];
      }
      if (FuncEnumConstructorType == 25)
      {
        uint64_t v75 = [v98 commandBufferForKey:*(void *)GTTraceFunc_argumentBytesWithMap(v21, *(unsigned __int8 *)(v97 + (v20 << 6) + 13), v95) + 1];
        v99[0] = _NSConcreteStackBlock;
        v99[1] = 3221225472;
        v99[2] = ___ZN35GTUSCSamplingStreamingManagerHelper31ReplaySingleFrameForUSCSamplingERNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS0_4hashIjEENS0_8equal_toIjEENS0_9allocatorINS0_4pairIKjS2_EEEEEERNS1_IjNS0_6vectorI27GTCoalescedEncoderIndexInfoNS7_ISF_EEEES4_S6_NS7_INS8_IS9_SH_EEEEEERNSE_INS8_IyyEENS7_ISM_EEEEP22GTMTLFXTracingDelegateU13block_pointerFvvE_block_invoke_2;
        v99[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
        v99[4] = v89;
        [v75 addCompletedHandler:v99];
      }
      unint64_t v18 = *v17 + 1;
      unsigned int *v17 = v18;
      std::vector<unsigned int>::size_type v11 = v90;
      if (v90[13] + v90[12] <= v18) {
        goto LABEL_100;
      }
    }
    [*(id *)(v6 + 1944) addSampledCallFunctionIndex:v25, v76, v77];
LABEL_25:
    int v26 = *v22;
    goto LABEL_26;
  }
LABEL_100:
}

void sub_1CCB58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33)
{
  _Unwind_Resume(a1);
}

void ScopedReplayConfiguration::~ScopedReplayConfiguration(ScopedReplayConfiguration *this)
{
  if (*((unsigned char *)this + 16))
  {
    uint64_t v2 = [*(id *)(*((void *)this + 1) + 8) defaultCommandQueue];
    [v2 setGPUPriority:1];
  }
  [(id)g_commandBufferDescriptor setErrorOptions:*(void *)this];
}

void sub_1CCDCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NSString *AddShaderBinary(NSMutableDictionary *a1, NSData *a2, objc_object *a3, int a4, uint64_t a5, NSString *a6, int a7, NSString *a8)
{
  uint64_t v36 = a1;
  uint64_t v15 = a2;
  uint64_t v35 = a3;
  int v16 = a6;
  std::vector<unsigned int>::size_type v17 = a8;
  if (v16)
  {
    unint64_t v18 = v16;
  }
  else
  {
    uLong v19 = crc32(0, 0, 0);
    unint64_t v20 = v15;
    unint64_t v18 = +[NSString stringWithFormat:@"%0.8x_%p", crc32(v19, (const Bytef *)[(NSData *)v20 bytes], (uInt)[(NSData *)v20 length]), v35];
  }
  uint64_t v21 = v18;
  unint64_t v23 = objc_opt_new();
  std::vector<unsigned int>::size_type v24 = v23;
  if (a7) {
    [v23 setObject:&__kCFBooleanTrue forKeyedSubscript:@"dylib"];
  }
  if (v17) {
    [v24 setObject:v17 forKeyedSubscript:@"type"];
  }
  if (a4)
  {
    if (v15)
    {
      uint64_t v25 = +[GTShaderProfilerBinaryAnalysisResult analyzeBinary:v15 targetIndex:a5 isaPrinter:0];
      if (v25)
      {
        id v37 = 0;
        int v26 = +[NSKeyedArchiver archivedDataWithRootObject:v25 requiringSecureCoding:1 error:&v37];
        id v27 = v37;
        if (v27 || !v26)
        {
          CFStringRef v42 = @"binary";
          id v43 = v15;
          id v33 = +[NSDictionary dictionaryWithObjects:&v43 forKeys:&v42 count:1];
          [v24 addEntriesFromDictionary:v33];

          id v29 = [v24 copy];
          [(NSMutableDictionary *)v36 setObject:v29 forKeyedSubscript:v21];
        }
        else
        {
          v44[0] = @"binary";
          v44[1] = @"binaryAnalysis";
          v45[0] = v15;
          v45[1] = v26;
          BOOL v28 = +[NSDictionary dictionaryWithObjects:v45 forKeys:v44 count:2];
          [v24 addEntriesFromDictionary:v28];

          id v29 = [v24 copy];
          [(NSMutableDictionary *)v36 setObject:v29 forKeyedSubscript:v21];
        }
      }
      else
      {
        CFStringRef v40 = @"binary";
        long long v41 = v15;
        uint64_t v32 = +[NSDictionary dictionaryWithObjects:&v41 forKeys:&v40 count:1];
        [v24 addEntriesFromDictionary:v32];

        id v27 = [v24 copy];
        [(NSMutableDictionary *)v36 setObject:v27 forKeyedSubscript:v21];
      }
    }
    else
    {
      id v31 = [v24 copy];
      [(NSMutableDictionary *)v36 setObject:v31 forKeyedSubscript:v21];
    }
  }
  else
  {
    if (v15)
    {
      CFStringRef v38 = @"binary";
      uint64_t v39 = v15;
      BOOL v30 = +[NSDictionary dictionaryWithObjects:&v39 forKeys:&v38 count:1];
      [v24 addEntriesFromDictionary:v30];
    }
    [(NSMutableDictionary *)v36 setObject:v24 forKeyedSubscript:v21];
  }

  return v21;
}

void sub_1CD198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

id GTUSCSamplingStreamingManagerHelper::AllocUSCSamplingAddressBuffer(GTUSCSamplingStreamingManagerHelper *this)
{
  uint64_t v2 = objc_alloc_init(ProgramAddressTableCollector);
  uint64_t v3 = (void *)*((void *)this + 243);
  *((void *)this + 243) = v2;

  id v4 = *(id *)(*(void *)this + 16);
  id v5 = [v4 objectForKeyedSubscript:@"perEncoderDrawCallCount"];
  id v6 = [v5 count];

  id v7 = [v4 objectForKeyedSubscript:@"totalDrawCallCount"];
  id v8 = [v7 unsignedIntegerValue];

  id v9 = objc_alloc((Class)NSMutableData);
  unint64_t v10 = 12 * (2 * (void)v8 + 8 * (void)v6);
  if (v10 <= 0x15555) {
    unint64_t v10 = 87381;
  }
  id v11 = [v9 initWithLength:24 * v10];
  uint64_t v12 = (void *)*((void *)this + 246);
  *((void *)this + 246) = v11;

  memset([*((id *)this + 246) mutableBytes], 255, (size_t)[*((id *)this + 246) length]);
  id v13 = *((id *)this + 246);

  return v13;
}

void sub_1CD374(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      id v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  id v5 = *(void **)a1;
  *(void *)a1 = 0;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

void HarvestInfo::~HarvestInfo(id *this)
{
}

void std::vector<std::pair<unsigned long long,unsigned long long>>::reserve(void **a1, unint64_t a2)
{
  if (a2 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4)
  {
    if (a2 >> 60) {
      abort();
    }
    int64_t v3 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    id v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(a2);
    id v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF0];
    id v7 = &v4[16 * v6];
    id v9 = (char *)*a1;
    id v8 = (char *)a1[1];
    unint64_t v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        *((_OWORD *)v10 - 1) = *((_OWORD *)v8 - 1);
        v10 -= 16;
        v8 -= 16;
      }
      while (v8 != v9);
      id v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  id v5 = *(void **)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  id result = (void *)*v5;
  if (*v5)
  {
    do
    {
      unint64_t v7 = result[1];
      if (v7 == a2)
      {
        if (result[2] == a2) {
          return result;
        }
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= *(void *)&v2) {
            v7 %= *(void *)&v2;
          }
        }
        else
        {
          v7 &= *(void *)&v2 - 1;
        }
        if (v7 != v4) {
          return 0;
        }
      }
      id result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void ___ZN35GTUSCSamplingStreamingManagerHelper31ReplaySingleFrameForUSCSamplingERNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS0_4hashIjEENS0_8equal_toIjEENS0_9allocatorINS0_4pairIKjS2_EEEEEERNS1_IjNS0_6vectorI27GTCoalescedEncoderIndexInfoNS7_ISF_EEEES4_S6_NS7_INS8_IS9_SH_EEEEEERNSE_INS8_IyyEENS7_ISM_EEEEP22GTMTLFXTracingDelegateU13block_pointerFvvE_block_invoke(uint64_t a1, void *a2)
{
  id v22 = a2;
  [v22 GPUStartTime];
  unint64_t v4 = NClockTimeFromCommandBufferTime(v3);
  [v22 GPUEndTime];
  unint64_t v6 = NClockTimeFromCommandBufferTime(v5);
  unint64_t v7 = v6;
  id v8 = *(void ***)(a1 + 32);
  unint64_t v10 = (unint64_t *)v8[1];
  unint64_t v9 = (unint64_t)v8[2];
  if ((unint64_t)v10 >= v9)
  {
    uint64_t v12 = ((char *)v10 - (unsigned char *)*v8) >> 4;
    unint64_t v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60) {
      abort();
    }
    uint64_t v14 = v9 - (void)*v8;
    if (v14 >> 3 > v13) {
      unint64_t v13 = v14 >> 3;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v15 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    int v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(v15);
    std::vector<unsigned int>::size_type v17 = (unint64_t *)&v16[16 * v12];
    uLong v19 = &v16[16 * v18];
    unint64_t *v17 = v4;
    v17[1] = v7;
    id v11 = v17 + 2;
    uint64_t v21 = (char *)*v8;
    unint64_t v20 = (char *)v8[1];
    if (v20 != *v8)
    {
      do
      {
        *((_OWORD *)v17 - 1) = *((_OWORD *)v20 - 1);
        v17 -= 2;
        v20 -= 16;
      }
      while (v20 != v21);
      unint64_t v20 = (char *)*v8;
    }
    *id v8 = v17;
    v8[1] = v11;
    v8[2] = v19;
    if (v20) {
      operator delete(v20);
    }
  }
  else
  {
    unint64_t *v10 = v4;
    v10[1] = v6;
    id v11 = v10 + 2;
  }
  v8[1] = v11;
}

void sub_1CD6CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t GetRenderPassDescriptor()
{
  uint64_t v0 = __chkstk_darwin();
  uint64_t v2 = v1;
  double v3 = (uint64_t *)v0;
  bzero(v5, 0x2B90uLL);
  GTMTLSMCommandEncoder_processTraceFunc((uint64_t)v5, v3, v2);
  if (v5[0] == 70 || v5[0] == 65) {
    return v6;
  }
  else {
    return 0;
  }
}

void GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(_DWORD *a1, void *a2, uint64_t a3, unsigned int a4, void *a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  unsigned int v102 = a4;
  id v14 = a5;
  unint64_t v15 = DEVICEOBJECT(v14);
  int v16 = a1[538] + a1[539];
  int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(a3 + 8));
  if (FuncEnumConstructorType <= 27)
  {
    if (FuncEnumConstructorType == 17)
    {
      if (a4) {
        unsigned int v30 = a4;
      }
      else {
        unsigned int v30 = a7;
      }
      unsigned int v98 = v30;
      *(void *)&long long v99 = __PAIR64__(v16, a6);
      *((void *)&v99 + 1) = 0x200000004;
      uint64_t v100 = a7;
      unint64_t v101 = 0;
      std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::__emplace_unique_key_args<unsigned int,unsigned int &,GTEncoderSampleIndexInfo>((uint64_t)a2, v30, v30, &v99);
      if (a8)
      {
        id v31 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(a8, v30, &v98);
        uint64_t v32 = v31;
        unint64_t v34 = v31[4];
        unint64_t v33 = v31[5];
        if (v34 >= v33)
        {
          uint64_t v56 = v31[3];
          uint64_t v57 = (uint64_t)(v34 - v56) >> 4;
          unint64_t v58 = v57 + 1;
          if ((unint64_t)(v57 + 1) >> 60) {
            abort();
          }
          uint64_t v59 = v33 - v56;
          if (v59 >> 3 > v58) {
            unint64_t v58 = v59 >> 3;
          }
          if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v60 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v60 = v58;
          }
          simd_float3 v61 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(v60);
          id v62 = &v61[16 * v57];
          int v64 = &v61[16 * v63];
          *(_DWORD *)id v62 = a6;
          *((void *)v62 + 1) = a7;
          uint64_t v35 = v62 + 16;
          unint64_t v66 = (char *)v32[3];
          uint64_t v65 = (char *)v32[4];
          if (v65 != v66)
          {
            do
            {
              *((_OWORD *)v62 - 1) = *((_OWORD *)v65 - 1);
              v62 -= 16;
              v65 -= 16;
            }
            while (v65 != v66);
            uint64_t v65 = (char *)v32[3];
          }
          v32[3] = v62;
          v32[4] = v35;
          v32[5] = v64;
          if (v65) {
            operator delete(v65);
          }
        }
        else
        {
          *(_DWORD *)unint64_t v34 = a6;
          *(void *)(v34 + 8) = a7;
          uint64_t v35 = (char *)(v34 + 16);
        }
        v32[4] = v35;
      }
      if (!a1[529] || !a1[528] || (objc_opt_respondsToSelector() & 1) == 0) {
        goto LABEL_96;
      }
      uint64_t v36 = GTSampleBufferManager::CurrentSampleBuffer((GTSampleBufferManager *)(a1 + 526));
      if (!v36
        || ([v15 setMTLCounterSampleLocationWithBuffer:v36 startIndex:a1[538] endIndex:(a1[538] + 1)] & 1) == 0)
      {
        uint64_t v67 = +[NSString stringWithFormat:@"Error, fail to set counter sample location for %lu", a6];
        uint64_t v68 = __stdoutp;
        int v69 = g_runningInCI;
        id v70 = v67;
        BOOL v71 = (const char *)[v70 UTF8String];
        simd_float3 v72 = "#CI_ERROR# ";
        if (!v69) {
          simd_float3 v72 = "";
        }
        fprintf(v68, "%s%s %u: %s\n", v72, "void GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(std::unordered_map<uint32_t, GTEncoderSampleIndexInfo> &, const GTTraceFunc *, uint32_t, __strong id<MTLCommandEncoder>, size_t, uint64_t, std::unordered_map<uint32_t, std::vector<GTCoalescedEncoderIndexInfo>> *)", 5637, v71);
        id v55 = v70;
        GTMTLReplay_handleError(101, (uint64_t)[v55 UTF8String], "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTUSCSamplingStreamingManager.mm", (uint64_t)"AddEncoderSamplePoints", 5637, 1);
        goto LABEL_93;
      }
    }
    else
    {
      if (FuncEnumConstructorType != 21) {
        goto LABEL_96;
      }
      *(void *)&long long v99 = __PAIR64__(v16, a6);
      *((void *)&v99 + 1) = 0x200000002;
      uint64_t v100 = a7;
      unint64_t v101 = 0;
      std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::__emplace_unique_key_args<unsigned int,unsigned int &,GTEncoderSampleIndexInfo>((uint64_t)a2, a4, a4, &v99);
      if (a8)
      {
        unint64_t v20 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(a8, a4, &v102);
        uint64_t v21 = v20;
        unint64_t v23 = v20[4];
        unint64_t v22 = v20[5];
        if (v23 >= v22)
        {
          uint64_t v73 = v20[3];
          uint64_t v74 = (uint64_t)(v23 - v73) >> 4;
          unint64_t v75 = v74 + 1;
          if ((unint64_t)(v74 + 1) >> 60) {
            goto LABEL_97;
          }
          uint64_t v76 = v22 - v73;
          if (v76 >> 3 > v75) {
            unint64_t v75 = v76 >> 3;
          }
          if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v77 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v75;
          }
          unsigned int v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(v77);
          char v79 = &v78[16 * v74];
          unsigned int v81 = &v78[16 * v80];
          *(_DWORD *)char v79 = a6;
          *((void *)v79 + 1) = a7;
          std::vector<unsigned int>::size_type v24 = v79 + 16;
          BOOL v83 = (char *)v21[3];
          id v82 = (char *)v21[4];
          if (v82 != v83)
          {
            do
            {
              *((_OWORD *)v79 - 1) = *((_OWORD *)v82 - 1);
              v79 -= 16;
              v82 -= 16;
            }
            while (v82 != v83);
            id v82 = (char *)v21[3];
          }
          v21[3] = v79;
          v21[4] = v24;
          v21[5] = v81;
          if (v82) {
            operator delete(v82);
          }
        }
        else
        {
          *(_DWORD *)unint64_t v23 = a6;
          *(void *)(v23 + 8) = a7;
          std::vector<unsigned int>::size_type v24 = (char *)(v23 + 16);
        }
        v21[4] = v24;
      }
      if (!a1[529] || !a1[528] || (objc_opt_respondsToSelector() & 1) == 0) {
        goto LABEL_96;
      }
      uint64_t v36 = GTSampleBufferManager::CurrentSampleBuffer((GTSampleBufferManager *)(a1 + 526));
      if (!v36
        || ([v15 setMTLCounterSampleLocationWithBuffer:v36 startIndex:a1[538] endIndex:(a1[538] + 1)] & 1) == 0)
      {
        uint64_t v90 = +[NSString stringWithFormat:@"Error, fail to set counter sample location for %lu", a6];
        long long v91 = __stdoutp;
        int v92 = g_runningInCI;
        id v93 = v90;
        long long v94 = (const char *)[v93 UTF8String];
        uint64_t v95 = "#CI_ERROR# ";
        if (!v92) {
          uint64_t v95 = "";
        }
        fprintf(v91, "%s%s %u: %s\n", v95, "void GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(std::unordered_map<uint32_t, GTEncoderSampleIndexInfo> &, const GTTraceFunc *, uint32_t, __strong id<MTLCommandEncoder>, size_t, uint64_t, std::unordered_map<uint32_t, std::vector<GTCoalescedEncoderIndexInfo>> *)", 5605, v94);
        id v55 = v93;
        GTMTLReplay_handleError(101, (uint64_t)[v55 UTF8String], "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTUSCSamplingStreamingManager.mm", (uint64_t)"AddEncoderSamplePoints", 5605, 1);
        goto LABEL_93;
      }
    }
LABEL_85:
    int v37 = a1[538] + 2;
    goto LABEL_86;
  }
  if (FuncEnumConstructorType == 28)
  {
    *(void *)&long long v99 = __PAIR64__(v16, a6);
    *((void *)&v99 + 1) = 0x200000004;
    uint64_t v100 = a7;
    unint64_t v101 = 0;
    std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::__emplace_unique_key_args<unsigned int,unsigned int &,GTEncoderSampleIndexInfo>((uint64_t)a2, a4, a4, &v99);
    if (!a8) {
      goto LABEL_40;
    }
    uint64_t v25 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(a8, a4, &v102);
    int v26 = v25;
    unint64_t v28 = v25[4];
    unint64_t v27 = v25[5];
    if (v28 < v27)
    {
      *(_DWORD *)unint64_t v28 = a6;
      *(void *)(v28 + 8) = a7;
      id v29 = (char *)(v28 + 16);
LABEL_39:
      v26[4] = v29;
LABEL_40:
      if (!a1[529] || !a1[528] || (objc_opt_respondsToSelector() & 1) == 0) {
        goto LABEL_96;
      }
      uint64_t v36 = GTSampleBufferManager::CurrentSampleBuffer((GTSampleBufferManager *)(a1 + 526));
      if (!v36
        || ([v15 setMTLCounterSampleLocationWithBuffer:v36 startIndex:a1[538] endIndex:(a1[538] + 1)] & 1) == 0)
      {
        uint64_t v49 = +[NSString stringWithFormat:@"Error, fail to set counter sample location for %lu", a6];
        id v50 = __stdoutp;
        int v51 = g_runningInCI;
        id v52 = v49;
        unint64_t v53 = (const char *)[v52 UTF8String];
        uint64_t v54 = "#CI_ERROR# ";
        if (!v51) {
          uint64_t v54 = "";
        }
        fprintf(v50, "%s%s %u: %s\n", v54, "void GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(std::unordered_map<uint32_t, GTEncoderSampleIndexInfo> &, const GTTraceFunc *, uint32_t, __strong id<MTLCommandEncoder>, size_t, uint64_t, std::unordered_map<uint32_t, std::vector<GTCoalescedEncoderIndexInfo>> *)", 5576, v53);
        id v55 = v52;
        GTMTLReplay_handleError(101, (uint64_t)[v55 UTF8String], "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTUSCSamplingStreamingManager.mm", (uint64_t)"AddEncoderSamplePoints", 5576, 1);
        goto LABEL_93;
      }
      goto LABEL_85;
    }
    uint64_t v38 = v25[3];
    uint64_t v39 = (uint64_t)(v28 - v38) >> 4;
    unint64_t v40 = v39 + 1;
    if (!((unint64_t)(v39 + 1) >> 60))
    {
      uint64_t v41 = v27 - v38;
      if (v41 >> 3 > v40) {
        unint64_t v40 = v41 >> 3;
      }
      if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v42 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v42 = v40;
      }
      id v43 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(v42);
      long long v44 = &v43[16 * v39];
      uint64_t v46 = &v43[16 * v45];
      *(_DWORD *)long long v44 = a6;
      *((void *)v44 + 1) = a7;
      id v29 = v44 + 16;
      uint64_t v48 = (char *)v26[3];
      uint64_t v47 = (char *)v26[4];
      if (v47 != v48)
      {
        do
        {
          *((_OWORD *)v44 - 1) = *((_OWORD *)v47 - 1);
          v44 -= 16;
          v47 -= 16;
        }
        while (v47 != v48);
        uint64_t v47 = (char *)v26[3];
      }
      v26[3] = v44;
      v26[4] = v29;
      v26[5] = v46;
      if (v47) {
        operator delete(v47);
      }
      goto LABEL_39;
    }
LABEL_97:
    abort();
  }
  if (FuncEnumConstructorType == 65 || FuncEnumConstructorType == 70)
  {
    if (objc_opt_respondsToSelector())
    {
      unsigned int v18 = [v15 tileWidth];
      unsigned int v19 = [v15 tileHeight];
    }
    else
    {
      unsigned int v19 = 0;
      unsigned int v18 = 0;
    }
    *(void *)&long long v99 = __PAIR64__(v16, a6);
    *((void *)&v99 + 1) = 0x400000000;
    uint64_t v100 = a7;
    unint64_t v101 = __PAIR64__(v19, v18);
    std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::__emplace_unique_key_args<unsigned int,unsigned int &,GTEncoderSampleIndexInfo>((uint64_t)a2, a4, a4, &v99);
    if (a1[529])
    {
      if (a1[528] && (objc_opt_respondsToSelector() & 1) != 0)
      {
        uint64_t v36 = GTSampleBufferManager::CurrentSampleBuffer((GTSampleBufferManager *)(a1 + 526));
        if (v36
          && ([v15 setMTLCounterSampleLocationWithBuffer:v36 vertexStartIndex:a1[538] vertexEndIndex:(a1[538] + 1) fragmentStartIndex:(a1[538] + 2) fragmentEndIndex:(a1[538] + 3)] & 1) != 0)
        {
          int v37 = a1[538] + 4;
LABEL_86:
          a1[538] = v37;
LABEL_95:

          goto LABEL_96;
        }
        uint64_t v84 = +[NSString stringWithFormat:@"Error, fail to set counter sample location for %lu", a6];
        uint64_t v85 = __stdoutp;
        int v86 = g_runningInCI;
        id v87 = v84;
        char v88 = (const char *)[v87 UTF8String];
        id v89 = "#CI_ERROR# ";
        if (!v86) {
          id v89 = "";
        }
        fprintf(v85, "%s%s %u: %s\n", v89, "void GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(std::unordered_map<uint32_t, GTEncoderSampleIndexInfo> &, const GTTraceFunc *, uint32_t, __strong id<MTLCommandEncoder>, size_t, uint64_t, std::unordered_map<uint32_t, std::vector<GTCoalescedEncoderIndexInfo>> *)", 5548, v88);
        id v55 = v87;
        GTMTLReplay_handleError(101, (uint64_t)[v55 UTF8String], "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTUSCSamplingStreamingManager.mm", (uint64_t)"AddEncoderSamplePoints", 5548, 1);
LABEL_93:

        uint64_t v96 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>(a2, a4);
        if (v96) {
          *((_DWORD *)v96 + 9) = 0;
        }
        goto LABEL_95;
      }
    }
  }
LABEL_96:
}

void sub_1CDFB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GTUSCSamplingStreamingManagerHelper::DispatchExpandedIndirectCommand()
{
  uint64_t v0 = __chkstk_darwin();
  uint64_t v2 = v1;
  unint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v84 = v0;
  uint64_t v9 = *(void *)v7;
  p = **(apr_pool_t ***)(v7 + 152);
  GTMTLSMContext_indirectCommandBufferResources((uint64_t)v99, *(_DWORD ***)(v9 + 40), *v5, p);
  GetExecuteCommandsInBufferArgs((uint64_t)&v93, (uint64_t)v6, *(void *)(v9 + 16));
  uint64_t v72 = (uint64_t)v6;
  Object = GTMTLSMContext_getObject(**(void **)(v9 + 40), v93, *v6);
  GTMTLCreateIndirectCommandEncoder((uint64_t)v97, Object[13]);
  memset(v91, 0, sizeof(v91));
  int v92 = 1065353216;
  memcpy(v90, (const void *)(v8 + 11312), sizeof(v90));
  id v11 = *(id *)(v8 + 8);
  uint64_t v12 = v11;
  uint64_t v74 = v8;
  int v13 = *(_DWORD *)(v8 + 11312);
  BOOL v83 = v4;
  if (v13 == 28)
  {
    if ((GT_SUPPORT_0 & 0x10) != 0)
    {
      int v86 = v11;
      id v87 = [*(id *)(v8 + 8) computeCommandEncoderForKey:*(void *)(v8 + 11320) v72];
      uint64_t v45 = v95;
      if (v95)
      {
        uint64_t v46 = 0;
        unsigned int v78 = (unsigned int *)(v8 + 22480);
        int v82 = v94;
        uint64_t v80 = v96;
        uint64_t v47 = v98;
        do
        {
          uint64_t v48 = (v46 + v82);
          uint64_t v49 = v80 + v47 * (int)v48;
          uint64_t v100 = v49;
          memcpy(__dst, &v90[7], 0x8D0uLL);
          int IndirectCommand = GTMTLSMComputeCommandEncoder_loadIndirectCommand((uint64_t)&v90[7], v97, v49, v99);
          GTMTLReplayController_restoreComputeCommandEncoder(v87, (uint64_t)__dst, (uint64_t)&v90[7], v86);
          unint64_t v51 = v90[8];
          if (!std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v91, v90[8]))
          {
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)v91, v51, v51);
            id v52 = [v86 computePipelineStateForKey:v90[8]];
            unint64_t v53 = v52;
            if (v52)
            {
              uint64_t v54 = *(void **)(v84 + 1944);
              id v55 = getComputePipelineBinaries(v52);
              [v54 addBinaries:v55];

              unint64_t v4 = v83;
            }
          }
          DYMTLDispatchComputeCommandEncoder(v87, (uint64_t)v97, v49);
          if (IndirectCommand)
          {
            [*(id *)(v84 + 1944) addSampledCallFunctionIndex:*v78 | (unint64_t)(v48 << 32)];
            if (v4)
            {
              uint64_t v88 = 0;
              uint64_t v56 = DEVICEOBJECT(v87);
              [v56 commandBatchIdRangeMin:(char *)&v88 + 4 max:&v88];

              uint64_t v57 = v4[1];
              unint64_t v58 = (unint64_t)v4[2];
              if ((unint64_t)v57 >= v58)
              {
                uint64_t v60 = (v57 - *v4) >> 3;
                unint64_t v61 = v60 + 1;
                if ((unint64_t)(v60 + 1) >> 61) {
                  abort();
                }
                uint64_t v62 = v58 - (void)*v4;
                if (v62 >> 2 > v61) {
                  unint64_t v61 = v62 >> 2;
                }
                if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v63 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v63 = v61;
                }
                int v64 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v63);
                unint64_t v66 = &v64[8 * v60];
                *(_DWORD *)unint64_t v66 = HIDWORD(v88);
                *((_DWORD *)v66 + 1) = v88;
                uint64_t v68 = *v4;
                uint64_t v67 = v4[1];
                int v69 = v66;
                if (v67 != *v4)
                {
                  do
                  {
                    uint64_t v70 = *((void *)v67 - 1);
                    v67 -= 8;
                    *((void *)v69 - 1) = v70;
                    v69 -= 8;
                  }
                  while (v67 != v68);
                  uint64_t v67 = *v4;
                }
                uint64_t v59 = v66 + 8;
                *unint64_t v4 = v69;
                v4[1] = v66 + 8;
                v4[2] = &v64[8 * v65];
                if (v67) {
                  operator delete(v67);
                }
              }
              else
              {
                *(_DWORD *)uint64_t v57 = HIDWORD(v88);
                *((_DWORD *)v57 + 1) = v88;
                uint64_t v59 = v57 + 8;
              }
              v4[1] = v59;
            }
          }
          ++v46;
        }
        while (v46 != v45);
      }
      uint64_t v12 = v86;
      GTMTLReplayController_restoreComputeCommandEncoder(v87, (uint64_t)&v90[7], v74 + 11368, v86);
      goto LABEL_63;
    }
  }
  else if (v13 == 70)
  {
    id v87 = [v11 executeIndirectCommandBufferMap];
    unsigned int v81 = v2;
    id v14 = [*(id *)(v8 + 8) renderCommandEncoderForKey:*(void *)(v8 + 11320)];
    uint64_t v79 = v95;
    if (v95)
    {
      uint64_t v15 = 0;
      uint64_t v73 = (unsigned int *)(v8 + 22480);
      int v77 = v94;
      uint64_t v75 = v98;
      uint64_t v76 = v96;
      uint64_t v85 = v12;
      do
      {
        uint64_t v16 = (v15 + v77);
        uint64_t v17 = v76 + v75 * (int)v16;
        uint64_t v100 = v17;
        memcpy(__dst, &v90[7], sizeof(__dst));
        int v18 = GTMTLSMRenderCommandEncoder_loadIndirectCommand((uint64_t)&v90[7], v97, v17, v99);
        GTMTLReplayController_restoreRenderCommandEncoder(v14, (uint64_t)__dst, (uint64_t)&v90[7], v12);
        unsigned int v19 = [v12 renderPipelineStateForKey:v90[1075]];
        unint64_t v20 = v90[1075];
        if (!std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v91, v90[1075]))
        {
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)v91, v20, v20);
          uint64_t v21 = [v85 renderPipelineStateForKey:v90[1075]];
          unint64_t v22 = v21;
          if (v21)
          {
            unint64_t v23 = *(void **)(v84 + 1944);
            std::vector<unsigned int>::size_type v24 = getRenderPipelineBinaries(v21);
            [v23 addBinaries:v24];
          }
        }
        if (v81) {
          int v25 = v18;
        }
        else {
          int v25 = 0;
        }
        if (v25 != 1 || (v26 = *v81, *v81 == -1) || (*unsigned int v81 = v26 - 1, v26))
        {
          unint64_t v27 = 0;
          int v28 = 0;
        }
        else
        {
          unint64_t v27 = GTUSCSamplingStreamingManagerHelper::RenderDummyDrawCall((void *)v84, v74, v14, 0, v90[1075], v72);
          [v14 setRenderPipelineState:v19];
          int v28 = 1;
        }
        DYMTLDrawRenderCommandEncoder(v14, (uint64_t)v97, v17, (uint64_t)v99, v87);
        if (v18)
        {
          [*(id *)(v84 + 1944) addSampledCallFunctionIndex:*v73 | (unint64_t)(v16 << 32)];
          if (v83)
          {
            uint64_t v88 = 0;
            id v29 = DEVICEOBJECT(v14);
            [v29 commandBatchIdRangeMin:(char *)&v88 + 4 max:&v88];

            unsigned int v30 = v83[1];
            unint64_t v31 = (unint64_t)v83[2];
            if ((unint64_t)v30 >= v31)
            {
              uint64_t v34 = (v30 - *v83) >> 3;
              unint64_t v35 = v34 + 1;
              if ((unint64_t)(v34 + 1) >> 61) {
                abort();
              }
              uint64_t v36 = v31 - (void)*v83;
              if (v36 >> 2 > v35) {
                unint64_t v35 = v36 >> 2;
              }
              if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v37 = v35;
              }
              uint64_t v38 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v37);
              unint64_t v40 = &v38[8 * v34];
              *(_DWORD *)unint64_t v40 = HIDWORD(v88);
              *((_DWORD *)v40 + 1) = v88;
              unint64_t v42 = *v83;
              uint64_t v41 = v83[1];
              id v43 = v40;
              if (v41 != *v83)
              {
                do
                {
                  uint64_t v44 = *((void *)v41 - 1);
                  v41 -= 8;
                  *((void *)v43 - 1) = v44;
                  v43 -= 8;
                }
                while (v41 != v42);
                uint64_t v41 = *v83;
              }
              uint64_t v32 = v40 + 8;
              *BOOL v83 = v43;
              v83[1] = v40 + 8;
              v83[2] = &v38[8 * v39];
              if (v41) {
                operator delete(v41);
              }
            }
            else
            {
              *(_DWORD *)unsigned int v30 = HIDWORD(v88);
              *((_DWORD *)v30 + 1) = v88;
              uint64_t v32 = v30 + 8;
            }
            v83[1] = v32;
          }
          else if (v28)
          {
            id v33 = GTUSCSamplingStreamingManagerHelper::RenderDummyDrawCall((void *)v84, v74, v14, v27, v90[1075], v72);
            [v14 setRenderPipelineState:v19];
          }
        }

        ++v15;
        uint64_t v12 = v85;
      }
      while (v15 != v79);
    }
    GTMTLReplayController_restoreRenderCommandEncoder(v14, (uint64_t)&v90[7], v74 + 11368, v12);

LABEL_63:
  }
  apr_pool_clear(p);

  return std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v91);
}

void sub_1CE758(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&STACK[0x5760]);
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper31ReplaySingleFrameForUSCSamplingERNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS0_4hashIjEENS0_8equal_toIjEENS0_9allocatorINS0_4pairIKjS2_EEEEEERNS1_IjNS0_6vectorI27GTCoalescedEncoderIndexInfoNS7_ISF_EEEES4_S6_NS7_INS8_IS9_SH_EEEEEERNSE_INS8_IyyEENS7_ISM_EEEEP22GTMTLFXTracingDelegateU13block_pointerFvvE_block_invoke_2(uint64_t a1, void *a2)
{
  id v22 = a2;
  [v22 GPUStartTime];
  unint64_t v4 = NClockTimeFromCommandBufferTime(v3);
  [v22 GPUEndTime];
  unint64_t v6 = NClockTimeFromCommandBufferTime(v5);
  unint64_t v7 = v6;
  uint64_t v8 = *(void ***)(a1 + 32);
  unint64_t v10 = (unint64_t *)v8[1];
  unint64_t v9 = (unint64_t)v8[2];
  if ((unint64_t)v10 >= v9)
  {
    uint64_t v12 = ((char *)v10 - (unsigned char *)*v8) >> 4;
    unint64_t v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60) {
      abort();
    }
    uint64_t v14 = v9 - (void)*v8;
    if (v14 >> 3 > v13) {
      unint64_t v13 = v14 >> 3;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v15 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    uint64_t v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<ASVDataSourceFilterTokenType,NSString * {__strong}>>>(v15);
    uint64_t v17 = (unint64_t *)&v16[16 * v12];
    unsigned int v19 = &v16[16 * v18];
    unint64_t *v17 = v4;
    v17[1] = v7;
    id v11 = v17 + 2;
    uint64_t v21 = (char *)*v8;
    unint64_t v20 = (char *)v8[1];
    if (v20 != *v8)
    {
      do
      {
        *((_OWORD *)v17 - 1) = *((_OWORD *)v20 - 1);
        v17 -= 2;
        v20 -= 16;
      }
      while (v20 != v21);
      unint64_t v20 = (char *)*v8;
    }
    *uint64_t v8 = v17;
    v8[1] = v11;
    v8[2] = v19;
    if (v20) {
      operator delete(v20);
    }
  }
  else
  {
    unint64_t *v10 = v4;
    v10[1] = v6;
    id v11 = v10 + 2;
  }
  v8[1] = v11;
}

void sub_1CE948(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

unint64_t NClockTimeFromCommandBufferTime(double a1)
{
  unsigned int v2 = dword_772020;
  if (!dword_772020)
  {
    mach_timebase_info((mach_timebase_info_t)&NClockTimeFromCommandBufferTime(double)::timebaseInfo);
    unsigned int v2 = dword_772020;
  }
  return (unint64_t)((double)v2
                          * a1
                          * 1000000000.0
                          / (double)(NClockTimeFromCommandBufferTime(double)::timebaseInfo | 0x41CDCD6500000000uLL));
}

id GTUSCSamplingStreamingManagerHelper::RenderDummyDrawCall(void *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6)
{
  id v11 = a3;
  id v12 = a4;
  if (v12)
  {
LABEL_2:
    [v11 setRenderPipelineState:v12];
    int v13 = *(_DWORD *)(a6 + 8);
    if (v13 == -16137 || v13 == -15297 || v13 == -15486)
    {
      int64x2_t v37 = vdupq_n_s64(1uLL);
      uint64_t v38 = 1;
      [v11 dispatchThreadsPerTile:&v37];
    }
    else
    {
      [v11 drawPrimitives:3 vertexStart:0 vertexCount:0 instanceCount:1];
    }
    goto LABEL_22;
  }
  Object = GTMTLSMContext_getObject(**(void **)(*(void *)a2 + 40), a5, *(void *)a6);
  id v17 = *(id *)(*(void *)*a1 + 8);
  if (!a1[287])
  {
    uint64_t v18 = [*(id *)(*(void *)*a1 + 8) defaultDevice];
    id v39 = 0;
    id v19 = [v18 newLibraryWithSource:@"#include <metal_stdlib>\n\nusing namespace metal;\n\nstruct TransformMatrices\n{\n    float4 modelview_projection_matrix[4];\n};\n\nstruct VertexOutput\n{\n    float4 pos [[position]];\n    float4 color;\n};\n\nvertex VertexOutput defaultVertexProgram(uint vid [[ vertex_id ]])\n{\n    VertexOutput out;\n\n    out.pos   = float4(0.0, 0.0, 0.0, 1.0);\n    out.color = float4(0.0, 0.0, 0.0, 1.0);\n\n    return out;\n}\n\nvertex void rasterizationDisabledVertexProgram(uint vid [[ vertex_id ]])\n{\n}\n\nfragment float4 defaultFragmentProgram(VertexOutput vo [[ stage_in ]])\n{\n    return float4(vo.color.bgr, 1.0f);\n}\n\nkernel void defaultKernel()\n{\n\n}\n\n" options:];
            0,
            &v39);
    id v20 = v39;

    id v21 = [v19 newFunctionWithName:@"defaultVertexProgram"];
    id v22 = (void *)a1[287];
    a1[287] = v21;

    id v23 = [v19 newFunctionWithName:@"defaultFragmentProgram"];
    std::vector<unsigned int>::size_type v24 = (void *)a1[286];
    a1[286] = v23;

    id v25 = [v19 newFunctionWithName:@"rasterizationDisabledVertexProgram"];
    int v26 = (void *)a1[288];
    a1[288] = v25;

    id v27 = [v19 newFunctionWithName:@"defaultKernel"];
    int v28 = (void *)a1[289];
    a1[289] = v27;
  }
  uint64_t v29 = Object[6];
  if (!v29)
  {
    uint64_t v32 = Object[8];
    if (v32 && a1[289])
    {
      id v33 = [v17 renderPipelineDescriptorMap];
      unint64_t v31 = MakeMTLTileRenderPipelineDescriptor(v32, v33);

      [v31 setTileFunction:a1[289]];
      uint64_t v34 = [*(id *)(*(void *)*a1 + 8) defaultDevice];
      id v35 = [v34 newRenderPipelineStateWithTileDescriptor:v31 options:0 reflection:0 error:0];
      goto LABEL_27;
    }
LABEL_21:

    id v12 = 0;
    goto LABEL_22;
  }
  if (!a1[287] || !a1[286]) {
    goto LABEL_21;
  }
  unsigned int v30 = [v17 renderPipelineDescriptorMap];
  unint64_t v31 = MakeMTLRenderPipelineDescriptorWithoutResourceIndex(v29, v30);

  if ([v31 isRasterizationEnabled])
  {
    [v31 setVertexFunction:a1[287]];
    [v31 setFragmentFunction:a1[286]];
  }
  else
  {
    [v31 setVertexFunction:a1[288]];
  }
  uint64_t v34 = [v17 defaultDevice];
  id v35 = [v34 newRenderPipelineStateWithDescriptor:v31 error:0];
LABEL_27:
  id v12 = v35;

  if (v12) {
    goto LABEL_2;
  }
LABEL_22:

  return v12;
}

void sub_1CECCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::__emplace_unique_key_args<unsigned int,unsigned int &,GTEncoderSampleIndexInfo>(uint64_t a1, unsigned int a2, int a3, _OWORD *a4)
{
  unint64_t v8 = a2;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (v9 <= a2) {
        unint64_t v4 = a2 % v9;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & a2;
    }
    id v11 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      for (std::vector<unsigned int>::pointer i = *v11; i; std::vector<unsigned int>::pointer i = (uint64_t *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t v14 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v14 = 0;
  *((void *)v14 + 1) = v8;
  *((_DWORD *)v14 + 4) = a3;
  long long v15 = a4[1];
  *(_OWORD *)(v14 + 24) = *a4;
  *(_OWORD *)(v14 + 40) = v15;
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    BOOL v18 = 1;
    if (v9 >= 3) {
      BOOL v18 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v9);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v21);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v9 <= v8) {
        unint64_t v4 = v8 % v9;
      }
      else {
        unint64_t v4 = v8;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & v8;
    }
  }
  uint64_t v22 = *(void *)a1;
  id v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)uint64_t v14 = *v23;
LABEL_38:
    *id v23 = v14;
    goto LABEL_39;
  }
  *(void *)uint64_t v14 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v14;
  *(void *)(v22 + 8 * v4) = a1 + 16;
  if (*(void *)v14)
  {
    unint64_t v24 = *(void *)(*(void *)v14 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v24 >= v9) {
        v24 %= v9;
      }
    }
    else
    {
      v24 &= v9 - 1;
    }
    id v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
}

void sub_1CEF5C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

id GTSampleBufferManager::CurrentSampleBuffer(GTSampleBufferManager *this)
{
  int v2 = *((_DWORD *)this + 12);
  unint64_t v3 = (v2 + 3) / (*((_DWORD *)this + 2) >> 3);
  double v5 = (void *)*((void *)this + 3);
  unint64_t v4 = (void *)*((void *)this + 4);
  unint64_t v6 = v4 - v5;
  if (v6 <= v3)
  {
    if (v5 != v4) {
      *((_DWORD *)v4 - 1) = v2;
    }
    unint64_t v7 = *((void *)this + 5);
    if ((unint64_t)v4 >= v7)
    {
      uint64_t v9 = v7 - (void)v5;
      if (v9 >> 2 <= v6 + 1) {
        uint64_t v10 = v6 + 1;
      }
      else {
        uint64_t v10 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v11 = v10;
      }
      id v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v11);
      unint64_t v13 = &v12[8 * v6];
      long long v15 = &v12[8 * v14];
      *(void *)unint64_t v13 = 0;
      unint64_t v8 = v13 + 8;
      float v17 = (char *)*((void *)this + 3);
      float v16 = (char *)*((void *)this + 4);
      if (v16 != v17)
      {
        do
        {
          uint64_t v18 = *((void *)v16 - 1);
          v16 -= 8;
          *((void *)v13 - 1) = v18;
          v13 -= 8;
        }
        while (v16 != v17);
        float v16 = (char *)*((void *)this + 3);
      }
      *((void *)this + 3) = v13;
      *((void *)this + 4) = v8;
      *((void *)this + 5) = v15;
      if (v16) {
        operator delete(v16);
      }
    }
    else
    {
      *unint64_t v4 = 0;
      unint64_t v8 = v4 + 1;
    }
    *((void *)this + 4) = v8;
    int v19 = *((_DWORD *)this + 13) + *((_DWORD *)this + 12);
    *((_DWORD *)this + 12) = 0;
    *((_DWORD *)this + 13) = v19;
    if ((unint64_t)[*((id *)this + 2) count] <= v3)
    {
      size_t v21 = *(void **)this;
      uint64_t v22 = *((unsigned int *)this + 2);
      id v23 = +[NSString stringWithFormat:@"GTMTLReplayer_StreamingManager_Buffer_%u", v3];
      id v24 = [v21 newCounterSampleBufferWithLength:v22 label:v23 error:0];

      if (v24) {
        [*((id *)this + 2) addObject:v24];
      }
    }
  }
  if ((unint64_t)[*((id *)this + 2) count] <= v3)
  {
    id v25 = 0;
  }
  else
  {
    id v25 = [*((id *)this + 2) objectAtIndexedSubscript:v3];
  }

  return v25;
}

void sub_1CF11C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>(void *a1, unsigned int a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  double v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (id result = *v5; result; id result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2) {
          v7 %= v2;
        }
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  id v12 = a1 + 2;
  uint64_t v10 = operator new(0x30uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  float v13 = (float)(unint64_t)(a1[3] + 1);
  float v14 = *((float *)a1 + 8);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v6 = v3;
    goto LABEL_64;
  }
  BOOL v15 = 1;
  if (v7 >= 3) {
    BOOL v15 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v16 = v15 | (2 * v7);
  unint64_t v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17) {
    int8x8_t prime = (int8x8_t)v17;
  }
  else {
    int8x8_t prime = (int8x8_t)v16;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v7 = a1[1];
  }
  if (*(void *)&prime <= v7)
  {
    if (*(void *)&prime >= v7) {
      goto LABEL_60;
    }
    unint64_t v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
    if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      unint64_t v25 = std::__next_prime(v25);
    }
    else
    {
      uint64_t v27 = 1 << -(char)__clz(v25 - 1);
      if (v25 >= 2) {
        unint64_t v25 = v27;
      }
    }
    if (*(void *)&prime <= v25) {
      int8x8_t prime = (int8x8_t)v25;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = a1[1];
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      uint64_t v34 = (void *)*a1;
      *a1 = 0;
      if (v34) {
        operator delete(v34);
      }
      unint64_t v7 = 0;
      a1[1] = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  int v19 = operator new(8 * *(void *)&prime);
  unint64_t v20 = (void *)*a1;
  *a1 = (uint64_t)v19;
  if (v20) {
    operator delete(v20);
  }
  uint64_t v21 = 0;
  a1[1] = (uint64_t)prime;
  do
    *(void *)(*a1 + 8 * v21++) = 0;
  while (*(void *)&prime != v21);
  uint64_t v22 = (void *)*v12;
  if (*v12)
  {
    unint64_t v23 = v22[1];
    uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(void *)&prime) {
        v23 %= *(void *)&prime;
      }
    }
    else
    {
      v23 &= *(void *)&prime - 1;
    }
    *(void *)(*a1 + 8 * v23) = v12;
    int v28 = (void *)*v22;
    if (*v22)
    {
      do
      {
        unint64_t v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(void *)&prime) {
            v29 %= *(void *)&prime;
          }
        }
        else
        {
          v29 &= *(void *)&prime - 1;
        }
        if (v29 != v23)
        {
          if (!*(void *)(*a1 + 8 * v29))
          {
            *(void *)(*a1 + 8 * v29) = v22;
            goto LABEL_56;
          }
          void *v22 = *v28;
          void *v28 = **(void **)(*a1 + 8 * v29);
          **(void **)(*a1 + 8 * v29) = v28;
          int v28 = v22;
        }
        unint64_t v29 = v23;
LABEL_56:
        uint64_t v22 = v28;
        int v28 = (void *)*v28;
        unint64_t v23 = v29;
      }
      while (v28);
    }
  }
  unint64_t v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v6) {
      v6 %= v7;
    }
  }
  else
  {
    unint64_t v6 = (v7 - 1) & v6;
  }
LABEL_64:
  uint64_t v30 = *a1;
  unint64_t v31 = *(void **)(*a1 + 8 * v6);
  if (v31)
  {
    void *v10 = *v31;
LABEL_72:
    *unint64_t v31 = v10;
    goto LABEL_73;
  }
  void *v10 = *v12;
  void *v12 = v10;
  *(void *)(v30 + 8 * v6) = v12;
  if (*v10)
  {
    unint64_t v32 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    unint64_t v31 = (void *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return v10;
}

void sub_1CF5D4(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,void *>>>::operator()[abi:nn180100](1, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,void *>>>::operator()[abi:nn180100](char a1, void *__p)
{
  if (a1)
  {
    unint64_t v3 = (void *)__p[3];
    if (v3)
    {
      __p[4] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void GTUSCSamplingStreamingManagerHelper::InitQueryShaderInfo(GTUSCSamplingStreamingManagerHelper *this, GTUSCSamplingStreamingManager *a2)
{
  GTUSCSamplingStreamingManagerHelper::Init(this, a2);
  GTUSCSamplingStreamingManagerHelper::SetupGPURawCounters(v2);
  unint64_t v3 = (GTUSCSamplingStreamingManagerHelper *)[*((id *)&xmmword_772038 + 1) count];
  if (v3)
  {
    unint64_t v4 = v3;
    unint64_t v5 = v3 != (GTUSCSamplingStreamingManagerHelper *)((char *)&def_1C1270 + 1);
    unint64_t v6 = (unint64_t)v3 - 1 <= 1 ? 1uLL : (unint64_t)v3 - 1;
    std::vector<std::vector<GTMMappedBuffer>>::reserve(&xmmword_772958, v6);
    std::vector<std::vector<GTMMappedBuffer>>::reserve(&qword_772940, v6);
    std::vector<std::vector<GTMMappedBuffer>>::reserve(&xmmword_772988, v6);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::reserve(&qword_7729A0, v6);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::reserve(&xmmword_7729B8, v6);
    std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::reserve((void *)&xmmword_7729C8 + 1, v6);
    if ((unint64_t)v4 > v5)
    {
      do
        GTUSCSamplingStreamingManagerHelper::SetupBufferForSourceAtIndex((GTUSCSamplingStreamingManagerHelper *)v5++, 1);
      while (v4 != (GTUSCSamplingStreamingManagerHelper *)v5);
    }
  }
  uint64_t v7 = +[NSMutableArray arrayWithCapacity:7];
  uint8x8_t v8 = (void *)qword_7727F0;
  qword_7727F0 = v7;

  for (uint64_t i = 0; i != 7; ++i)
  {
    uint64_t v10 = (void *)qword_7727F0;
    unint64_t v11 = [&off_758A08 objectAtIndexedSubscript:i];
    id v12 = +[GPURawCounterSelect selectWithName:v11 options:0];
    [v10 addObject:v12];
  }
  float v13 = [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) objectForKeyedSubscript:@"profileCounters"];
  id v108 = [v13 mutableCopy];

  float v14 = [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) objectForKeyedSubscript:@"profileCounters32"];
  unint64_t v103 = +[NSSet setWithArray:v14];

  unint64_t v15 = (unint64_t)[(id)qword_772810 count];
  char v16 = HIDWORD(qword_7728A0) > 1;
  uint64_t v17 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [*((id *)&xmmword_772038 + 1) count]);
  uint64_t v18 = (void *)xmmword_772800;
  *(void *)&xmmword_772800 = v17;

  unint64_t v112 = v15 >> v16;
  char v104 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", (char *)[v108 count] + (v15 >> v16));
  int v19 = +[NSMutableSet setWithCapacity:](NSMutableSet, "setWithCapacity:", [v108 count]);
  for (unsigned int j = 0; (unint64_t)[v108 count] > j; ++j)
  {
    uint64_t v21 = [v108 objectAtIndexedSubscript:j];
    unsigned int v22 = [v103 containsObject:v21];

    unint64_t v23 = [v108 objectAtIndexedSubscript:j];
    if (v22) {
      uint64_t v24 = 32;
    }
    else {
      uint64_t v24 = 16;
    }
    CFStringRef v127 = @"Width";
    unint64_t v25 = +[NSNumber numberWithUnsignedInteger:v24];
    unint64_t v128 = v25;
    uint8x8_t v26 = +[NSDictionary dictionaryWithObjects:&v128 forKeys:&v127 count:1];
    uint64_t v27 = +[GPURawCounterSelect selectWithName:v23 options:v26];
    [v104 addObject:v27];

    int v28 = [v108 objectAtIndexedSubscript:j];
    [v19 addObject:v28];
  }
  unint64_t v29 = +[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", [v108 count]);
  for (unint64_t k = 0; k < (unint64_t)[*((id *)&xmmword_772038 + 1) count]; ++k)
  {
    uint64_t v30 = [*((id *)&xmmword_772038 + 1) objectAtIndexedSubscript:];
    unint64_t v31 = [v30 availableCounters];
    long long v119 = 0u;
    long long v120 = 0u;
    long long v117 = 0u;
    long long v118 = 0u;
    id v32 = v31;
    id v33 = [v32 countByEnumeratingWithState:&v117 objects:v126 count:16];
    if (v33)
    {
      uint64_t v34 = *(void *)v118;
      do
      {
        for (m = 0; m != v33; m = (char *)m + 1)
        {
          if (*(void *)v118 != v34) {
            objc_enumerationMutation(v32);
          }
          uint64_t v36 = *(void **)(*((void *)&v117 + 1) + 8 * (void)m);
          int64x2_t v37 = [v36 name];
          unsigned int v38 = [v19 containsObject:v37];

          if (v38)
          {
            id v39 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [v36 counterValueType]);
            unint64_t v40 = [v36 name];
            [v29 setObject:v39 forKeyedSubscript:v40];
          }
        }
        id v33 = [v32 countByEnumeratingWithState:&v117 objects:v126 count:16];
      }
      while (v33);
    }
  }
  uint64_t v100 = GTUSCSamplingStreamingManagerHelper::SubDividedCounterDictionary(v104);
  uint64_t v41 = [v100 objectForKeyedSubscript:@"passList"];
  id v105 = [v41 objectAtIndexedSubscript:0];

  long long v99 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", 4 * (void)[(id)qword_772810 count] + 7);
  unint64_t v101 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v104 count]);
  unsigned int v102 = +[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", [v100 count]);
  unint64_t v109 = 0;
  unint64_t v111 = 0;
  for (unint64_t n = 0; n < (unint64_t)[v105 count]; unint64_t n = v107 + 1)
  {
    id v106 = [v105 objectAtIndexedSubscript:n];
    unint64_t v107 = n;
    if ([v106 count])
    {
      +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v106 count]);
      id v43 = (id)objc_claimAutoreleasedReturnValue();
      long long v115 = 0u;
      long long v116 = 0u;
      long long v113 = 0u;
      long long v114 = 0u;
      id v44 = v106;
      id v45 = [v44 countByEnumeratingWithState:&v113 objects:v125 count:16];
      if (v45)
      {
        uint64_t v46 = *(void *)v114;
        do
        {
          for (iuint64_t i = 0; ii != v45; iuint64_t i = (char *)ii + 1)
          {
            if (*(void *)v114 != v46) {
              objc_enumerationMutation(v44);
            }
            uint64_t v48 = [*(id *)(*((void *)&v113 + 1) + 8 * (void)ii) name];
            [v43 addObject:v48];
          }
          id v45 = [v44 countByEnumeratingWithState:&v113 objects:v125 count:16];
        }
        while (v45);
      }

      uint64_t v49 = [*((id *)&xmmword_772038 + 1) objectAtIndexedSubscript:v107];
      id v50 = [v49 name];
      [v102 setObject:v43 forKeyedSubscript:v50];

      [v101 addObjectsFromArray:v43];
      id v51 = [(id)qword_7727F0 copy];
      id v52 = +[NSMutableArray arrayWithArray:v51];

      [v52 addObjectsFromArray:v44];
      [(id)xmmword_772800 addObject:v52];
      unint64_t v53 = [*((id *)&xmmword_772038 + 1) objectAtIndexedSubscript:v107];
      uint64_t v54 = [v53 name];
      if ([v54 isEqualToString:@"RDE_0"])
      {

        goto LABEL_45;
      }
      uint64_t v60 = [*((id *)&xmmword_772038 + 1) objectAtIndexedSubscript:v107];
      unint64_t v61 = [v60 name];
      unsigned int v62 = [v61 isEqualToString:@"RDE"];

      if (v62) {
LABEL_45:
      }
        unint64_t v111 = v107;

      goto LABEL_47;
    }
    if (HIDWORD(qword_7728A0) >= 2
      && [(id)qword_772810 count]
      && ([*((id *)&xmmword_772038 + 1) objectAtIndexedSubscript:n],
          id v55 = objc_claimAutoreleasedReturnValue(),
          [v55 name],
          uint64_t v56 = objc_claimAutoreleasedReturnValue(),
          unsigned int v57 = [v56 isEqualToString:@"RDE_1"],
          v56,
          v55,
          v57))
    {
      unint64_t v58 = (void *)xmmword_772800;
      id v43 = [(id)qword_7727F0 mutableCopy];
      [v58 addObject:v43];
      unint64_t v109 = v107;
    }
    else
    {
      uint64_t v59 = (void *)xmmword_772800;
      id v43 = (id)objc_opt_new();
      [v59 addObject:v43];
    }
LABEL_47:
  }
  id v63 = v101;

  if (HIDWORD(qword_7728A0) <= 1) {
    unint64_t v64 = (unint64_t)[(id)qword_772810 count];
  }
  else {
    unint64_t v64 = ((unint64_t)[(id)qword_772810 count] + 1) >> 1;
  }
  unint64_t v65 = 8 * v64;
  unint64_t v66 = 224 - (void)[(id)xmmword_772800 count];
  if (v66 >= 8 * v64)
  {
    unsigned int v67 = 0;
    do
    {
      if (v112)
      {
        for (junsigned int j = 0; jj != v112; ++jj)
        {
          int v69 = [(id)xmmword_772800 objectAtIndexedSubscript:v111];
          uint64_t v70 = [(id)qword_772810 objectAtIndexedSubscript:jj];
          BOOL v71 = +[GPURawCounterSelect selectWithName:v70 options:0];
          [v69 addObject:v71];
        }
      }
      unint64_t v72 = v112;
      if (HIDWORD(qword_7728A0) >= 2)
      {
        while (v72 < (unint64_t)[(id)qword_772810 count])
        {
          uint64_t v73 = [(id)xmmword_772800 objectAtIndexedSubscript:v109];
          uint64_t v74 = [(id)qword_772810 objectAtIndexedSubscript:v72];
          uint64_t v75 = +[GPURawCounterSelect selectWithName:v74 options:0];
          [v73 addObject:v75];

          ++v72;
        }
      }
      if (v67 > 2) {
        break;
      }
      ++v67;
      v66 -= v65;
    }
    while (v66 >= v65);
  }
  uint64_t v76 = +[NSMutableArray arrayWithCapacity:2];
  int v77 = (void *)xmmword_772820;
  *(void *)&xmmword_772820 = v76;

  unsigned int v78 = (void *)xmmword_772820;
  uint64_t v79 = +[GPURawCounterSourceTriggerSelect selectWithName:@"TimerNClock" options:&off_758E00];
  [v78 addObject:v79];

  uint64_t v80 = (void *)xmmword_772820;
  unsigned int v81 = +[GPURawCounterSourceTriggerSelect selectWithName:@"KickBoundary" options:0];
  [v80 addObject:v81];

  uint64_t v82 = +[NSMutableArray arrayWithCapacity:1];
  BOOL v83 = (void *)*((void *)&xmmword_772820 + 1);
  *((void *)&xmmword_772820 + 1) = v82;

  uint64_t v84 = (void *)*((void *)&xmmword_772820 + 1);
  uint64_t v85 = +[GPURawCounterSourceTriggerSelect selectWithName:@"TimerNClock" options:&off_758E28];
  [v84 addObject:v85];

  uint64_t v86 = +[NSMutableArray arrayWithCapacity:1];
  id v87 = (void *)qword_772830;
  qword_772830 = v86;

  uint64_t v88 = (void *)qword_772830;
  id v89 = +[GPURawCounterSourceTriggerSelect selectWithName:@"KickBoundary" options:0];
  [v88 addObject:v89];

  if (v112)
  {
    v123[0] = @"BufferSizeInKB";
    uint64_t v90 = +[NSNumber numberWithUnsignedLong:20480];
    v123[1] = @"RingBufferSizeInKB";
    v124[0] = v90;
    long long v91 = +[NSNumber numberWithUnsignedLong:20480];
    v124[1] = v91;
    uint64_t v92 = +[NSDictionary dictionaryWithObjects:v124 forKeys:v123 count:2];
    uint64_t v93 = (void *)*((void *)&xmmword_772840 + 1);
    *((void *)&xmmword_772840 + 1) = v92;
  }
  else
  {
    v121[1] = @"BufferSizeInKB";
    v122[0] = &off_7596D8;
    v121[0] = @"ShaderProfiler";
    uint64_t v90 = +[NSNumber numberWithUnsignedLong:20480 * qword_7728A0];
    v122[1] = v90;
    uint64_t v94 = +[NSDictionary dictionaryWithObjects:v122 forKeys:v121 count:2];
    long long v91 = (void *)*((void *)&xmmword_772840 + 1);
    *((void *)&xmmword_772840 + 1) = v94;
  }

  id v95 = GTUSCSamplingStreamingManagerHelper::AllocUSCSamplingAddressBuffer((GTUSCSamplingStreamingManagerHelper *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance);
  qword_7727B8 = (uint64_t)[(id)qword_7727D8 mutableBytes];
  [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) setObject:v63 forKeyedSubscript:@"limiter sample counters"];
  [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) setObject:v29 forKeyedSubscript:@"Counter Info"];
  [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) setObject:v102 forKeyedSubscript:@"Limiter Counter List Map"];
  (*(void (**)(void))(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 32) + 16))();
  HIDWORD(qword_7728A8) = 12;
  [*((id *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 1) setup];
  uint64_t v96 = [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16) objectForKeyedSubscript:@"AnalyzeBinaries"];
  BOOL v97 = v96 == 0;

  if (!v97)
  {
    uint64_t v98 = [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16) objectForKeyedSubscript:@"AnalyzeBinaries"];
    byte_7728B1 = [v98 BOOLValue];
  }
}

void sub_1D041C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,_Unwind_Exception *exception_object)
{
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManagerHelper::Init(GTUSCSamplingStreamingManagerHelper *this, GTUSCSamplingStreamingManager *a2)
{
  if ((void)GTUSCSamplingStreamingManagerHelper::Instance(void)::instance) {
    GTUSCSamplingStreamingManagerHelper::CleanUp((GTUSCSamplingStreamingManagerHelper *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance);
  }
  else {
    ClearCaches();
  }
  if (!(void)xmmword_7729E8)
  {
    dispatch_semaphore_t v3 = dispatch_semaphore_create(0);
    unint64_t v4 = (void *)xmmword_7729E8;
    *(void *)&xmmword_7729E8 = v3;
  }
  *(void *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance = this;
  atomic_store((unint64_t)this, (unint64_t *)&xmmword_772AC8);
  unint64_t v5 = [*(id *)(*(void *)this + 8) defaultDevice];
  GTAGXPerfStateControl::InitWithDevice((uint64_t)&unk_772050, v5);

  qword_772068 = 30;
  CFDictionaryRef v6 = IOServiceMatching("ApplePMP");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v6);
  if (MatchingService)
  {
    int v8 = 2;
    if (!dword_772780) {
      int v8 = 13;
    }
  }
  else
  {
    CFDictionaryRef v9 = IOServiceMatching("ApplePMPv2");
    io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v9);
    if (!MatchingService) {
      goto LABEL_21;
    }
    dword_772780 = 1;
    int v8 = 2;
  }
  for (uint64_t i = 0; i != 5; ++i)
    *((_DWORD *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + i + 471) = v8 + i;
  uint64_t v11 = IOServiceOpen(MatchingService, mach_task_self_, 0, (io_connect_t *)qword_772070);
  if (v11)
  {
    uint64_t v12 = v11;
    float v13 = +[NSString stringWithUTF8String:mach_error_string(v11)];
    float v14 = +[NSString stringWithFormat:@"IOServiceOpen (0x%x - %@)", v12, v13];

    unint64_t v15 = __stdoutp;
    int v16 = g_runningInCI;
    id v17 = v14;
    uint64_t v18 = (const char *)[v17 UTF8String];
    int v19 = "#CI_ERROR# ";
    if (!v16) {
      int v19 = "";
    }
    fprintf(v15, "%s%s %u: %s\n", v19, "BOOL GTApplePMPPerfStateControl::Open(io_service_t)", 182, v18);
    id v20 = v17;
    GTMTLReplay_handleError(101, (uint64_t)[v20 UTF8String], "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTApplePMPPerfStateControl.mm", (uint64_t)"Open", 182, 2);
  }
  else if (LODWORD(qword_772070[0]) {
         && (memset(output, 0, sizeof(output)),
  }
             outputCnt[0] = 1,
             !IOConnectCallMethod(qword_772070[0], dword_772784, 0, 0, 0, 0, (uint64_t *)output, outputCnt, 0, 0)))
  {
    qword_772778 = *(void *)&output[0];
    if (*(void *)&output[0])
    {
      uint64_t v39 = 0;
      while (LODWORD(qword_772070[0]))
      {
        *(void *)&output[0] = v39;
        size_t v40 = 16;
        if (!dword_772780) {
          size_t v40 = 10;
        }
        size_t outputStructCnt = v40;
        uint64_t v41 = IOConnectCallMethod(qword_772070[0], dword_77278C, (const uint64_t *)output, 1u, 0, 0, 0, 0, outputCnt, &outputStructCnt);
        uint64_t v42 = v41;
        if (v41)
        {
          id v43 = +[NSString stringWithUTF8String:mach_error_string(v41)];
          id v44 = +[NSString stringWithFormat:@"_getDVFSDomainName (0x%x - %@)", v42, v43];

          id v45 = __stdoutp;
          int v46 = g_runningInCI;
          id v47 = v44;
          uint64_t v48 = (const char *)[v47 UTF8String];
          uint64_t v49 = "#CI_ERROR# ";
          if (!v46) {
            uint64_t v49 = "";
          }
          fprintf(v45, "%s%s %u: %s\n", v49, "NSString *GTApplePMPPerfStateControl::GetDVFSDomainName(uint64_t)", 266, v48);
          id v50 = v47;
          GTMTLReplay_handleError(101, (uint64_t)[v50 UTF8String], "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTApplePMPPerfStateControl.mm", (uint64_t)"GetDVFSDomainName", 266, 2);
        }
        if (outputStructCnt)
        {
          id v51 = +[NSString stringWithUTF8String:outputCnt];
          if (!v51) {
            goto LABEL_63;
          }
        }
        else
        {
          id v51 = &stru_7482F0;
        }
        if (![(__CFString *)v51 length]) {
          goto LABEL_63;
        }
        id v52 = [(__CFString *)v51 copy];
        unint64_t v53 = (char *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 56 * v39;
        uint64_t v54 = (void *)*((void *)v53 + 10);
        *((void *)v53 + 10) = v52;

        if (!LODWORD(qword_772070[0])) {
          goto LABEL_63;
        }
        long long v79 = 0u;
        long long v80 = 0u;
        long long v77 = 0u;
        long long v78 = 0u;
        long long v75 = 0u;
        long long v76 = 0u;
        memset(outputCnt, 0, sizeof(outputCnt));
        *(void *)&output[0] = v39;
        LODWORD(outputStructCnt) = 3;
        uint64_t v55 = IOConnectCallMethod(qword_772070[0], dword_772788, (const uint64_t *)output, 1u, 0, 0, (uint64_t *)outputCnt, (uint32_t *)&outputStructCnt, 0, 0);
        uint64_t v56 = v55;
        if (v55)
        {
          unsigned int v57 = +[NSString stringWithUTF8String:mach_error_string(v55)];
          unint64_t v58 = +[NSString stringWithFormat:@"_getNumDVFSStates (0x%x - %@)", v56, v57];

          uint64_t v59 = __stdoutp;
          int v60 = g_runningInCI;
          id v61 = v58;
          unsigned int v62 = (const char *)[v61 UTF8String];
          id v63 = "#CI_ERROR# ";
          if (!v60) {
            id v63 = "";
          }
          fprintf(v59, "%s%s %u: %s\n", v63, "uint64_t GTApplePMPPerfStateControl::GetNumDVFSStates(uint64_t, uint64_t *, uint64_t *)", 228, v62);
          id v64 = v61;
          GTMTLReplay_handleError(101, (uint64_t)[v64 UTF8String], "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTApplePMPPerfStateControl.mm", (uint64_t)"GetNumDVFSStates", 228, 2);
        }
        uint64_t v65 = *(void *)outputCnt;
        if (!*(void *)outputCnt) {
          goto LABEL_63;
        }
        unint64_t v66 = 0;
        *(_OWORD *)(v53 + 120) = *(_OWORD *)&outputCnt[2];
        while (v66 < [&off_758BA0 count])
        {
          unsigned int v67 = [&off_758BA0 objectAtIndexedSubscript:v66];
          if ([(__CFString *)v51 hasPrefix:v67])
          {
            uint64_t v68 = (char *)[v67 length];
            if (v68 + 1 >= [(__CFString *)v51 length])
            {
              unsigned int v69 = [v67 hasPrefix:@"DCS"];
              uint64_t v70 = v65 - 1;
              BOOL v71 = (void *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 7 * v39;
              v71[12] = (unint64_t)(v65 - 1) >> (v69 ^ 1);
              v71[13] = v65 - 1;
              if (!v69) {
                uint64_t v70 = 0;
              }
              v71[11] = v70;

              break;
            }
          }

          ++v66;
        }

        if (++v39 >= (unint64_t)qword_772778) {
          goto LABEL_21;
        }
      }
      id v51 = 0;
LABEL_63:
    }
  }
  else
  {
    qword_772778 = 0;
  }
LABEL_21:
  uint64_t v21 = [*(id *)(*(void *)this + 8) defaultDevice];
  unsigned int v22 = DEVICEOBJECT(v21);
  io_registry_entry_t v23 = [v22 acceleratorPort];

  uint64_t v24 = GTProfilerConfigurationVariables(v23);
  unint64_t v25 = (void *)qword_7727E8;
  qword_7727E8 = v24;

  uint8x8_t v26 = [GTPerfStatsHelper alloc];
  uint64_t v27 = [(GTPerfStatsHelper *)v26 initWithConfigurationVariables:qword_7727E8];
  int v28 = (void *)*((void *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 1);
  *((void *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 1) = v27;

  [*((id *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 1) setup];
  uint64_t v29 = GTAGXPerfStateControl::ConsistentGPUPerfStateLevel((GTAGXPerfStateControl *)&unk_772050, 0);
  uint64_t v30 = (void *)qword_772858;
  qword_772858 = v29;

  unint64_t v31 = [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16) objectForKeyedSubscript:@"GPUState"];
  if (!v31
    || ([*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16) objectForKeyedSubscript:@"GPUState"], v32 = objc_claimAutoreleasedReturnValue(), unsigned int v33 = objc_msgSend(v32, "unsignedIntValue"), v32, v31, !v33))
  {
    if (qword_772858)
    {
      uint64_t v34 = [(id)qword_772858 objectForKeyedSubscript:@"mapped state"];
      if (v34)
      {
        id v72 = v34;
        BOOL v35 = [v34 count] == (char *)&def_1C1270 + 3;
        uint64_t v34 = v72;
        if (v35)
        {
          uint64_t v36 = [v72 objectAtIndexedSubscript:1];
          unsigned int v37 = [v36 unsignedIntValue];
          uint64_t v38 = GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
          *(_DWORD *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 64) = 100 * v37;
          *(_DWORD *)(v38 + 68) = 100 * v37;

          uint64_t v34 = v72;
        }
      }
    }
  }
}

void sub_1D0F80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13)
{
  _Unwind_Resume(a1);
}

id GTUSCSamplingStreamingManagerHelper::SubDividedCounterDictionary(void *a1)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x3032000000;
  uint64_t v12 = __Block_byref_object_copy_;
  float v13 = __Block_byref_object_dispose_;
  id v14 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = ___ZNK35GTUSCSamplingStreamingManagerHelper27SubDividedCounterDictionaryEP14NSMutableArrayIP19GPURawCounterSelectE_block_invoke;
  v5[3] = &unk_746960;
  uint64_t v7 = &v9;
  int v8 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
  id v1 = a1;
  id v6 = v1;
  unint64_t v2 = +[NSBlockOperation blockOperationWithBlock:v5];
  [v2 setQueuePriority:8];
  [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v2];
  [v2 waitUntilFinished];
  id v3 = (id)v10[5];

  _Block_object_dispose(&v9, 8);

  return v3;
}

void sub_1D1170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void ___ZNK35GTUSCSamplingStreamingManagerHelper27SubDividedCounterDictionaryEP14NSMutableArrayIP19GPURawCounterSelectE_block_invoke(void *a1)
{
  id v5 = [*(id *)(a1[6] + 16) firstObject];
  uint64_t v2 = [v5 subDivideCounterList:a1[4] withOptions:0];
  uint64_t v3 = *(void *)(a1[5] + 8);
  unint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_1D1234(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::vector<std::vector<GTMMappedBuffer>>::reserve(void *result, unint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(result[2] - *result) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v2 = result;
    uint64_t v3 = result[1] - *result;
    void v5[4] = result + 2;
    v5[0] = std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(a2);
    v5[1] = v5[0] + v3;
    v5[2] = v5[0] + v3;
    v5[3] = v5[0] + 24 * v4;
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer(v2, v5);
    return (void *)std::__split_buffer<std::vector<GTMMappedBuffer>>::~__split_buffer((uint64_t)v5);
  }
  return result;
}

void *std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::reserve(void *result, unint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(result[2] - *result) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v2 = result;
    uint64_t v3 = result[1] - *result;
    void v5[4] = result + 2;
    v5[0] = std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(a2);
    v5[1] = v5[0] + v3;
    v5[2] = v5[0] + v3;
    v5[3] = v5[0] + 24 * v4;
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer(v2, v5);
    return (void *)std::__split_buffer<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::~__split_buffer((uint64_t)v5);
  }
  return result;
}

void *std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::reserve(void *result, unint64_t a2)
{
  if (a2 > (uint64_t)(result[2] - *result) >> 3)
  {
    if (a2 >> 61) {
      abort();
    }
    uint64_t v2 = (char **)result;
    uint64_t v3 = result[1] - *result;
    unint64_t v15 = result + 2;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(a2);
    uint64_t v7 = *v2;
    id v6 = v2[1];
    if (v6 == *v2)
    {
      int64x2_t v10 = vdupq_n_s64((unint64_t)v6);
      int v8 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    }
    else
    {
      int v8 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
      do
      {
        uint64_t v9 = *((void *)v6 - 1);
        v6 -= 8;
        *(void *)id v6 = 0;
        *((void *)v8 - 1) = v9;
        v8 -= 8;
      }
      while (v6 != v7);
      int64x2_t v10 = *(int64x2_t *)v2;
    }
    *uint64_t v2 = v8;
    v2[1] = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    int64x2_t v13 = v10;
    uint64_t v11 = v2[2];
    v2[2] = &v4[8 * v5];
    id v14 = v11;
    uint64_t v12 = v10.i64[0];
    return (void *)std::__split_buffer<NSString * {__strong}>::~__split_buffer((uint64_t)&v12);
  }
  return result;
}

void GTUSCSamplingStreamingManagerHelper::SetupBufferForSourceAtIndex(GTUSCSamplingStreamingManagerHelper *this, int a2)
{
  uint64_t v3 = [*((id *)&xmmword_772038 + 1) objectAtIndexedSubscript:this];
  long long v175 = 0uLL;
  unint64_t v176 = 0;
  uint64_t v4 = *((void *)&xmmword_772958 + 1);
  if (*((void *)&xmmword_772958 + 1) >= (unint64_t)xmmword_772968)
  {
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&xmmword_772958 + 1) - xmmword_772958) >> 3);
    unint64_t v7 = v6 + 1;
    if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    if (0x5555555555555556 * ((uint64_t)(xmmword_772968 - xmmword_772958) >> 3) > v7) {
      unint64_t v7 = 0x5555555555555556 * ((uint64_t)(xmmword_772968 - xmmword_772958) >> 3);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(xmmword_772968 - xmmword_772958) >> 3) >= 0x555555555555555) {
      unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v8 = v7;
    }
    uint64_t v180 = &xmmword_772968;
    uint64_t v9 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v8);
    int64x2_t v10 = &v9[3 * v6];
    uint64_t v177 = v9;
    v178.i64[0] = (uint64_t)v10;
    uint64_t v179 = &v9[3 * v11];
    uint64_t *v10 = 0;
    v10[1] = 0;
    v10[2] = 0;
    *(_OWORD *)int64x2_t v10 = v175;
    v10[2] = v176;
    long long v175 = 0uLL;
    unint64_t v176 = 0;
    v178.i64[1] = (uint64_t)(v10 + 3);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer(&xmmword_772958, &v177);
    uint64_t v5 = *((void *)&xmmword_772958 + 1);
    std::__split_buffer<std::vector<GTMMappedBuffer>>::~__split_buffer((uint64_t)&v177);
  }
  else
  {
    **((void **)&xmmword_772958 + 1) = 0;
    *(void *)(v4 + 8) = 0;
    *(void *)(v4 + 16) = 0;
    uint64_t v5 = v4 + 24;
    *((void *)&xmmword_772958 + 1) = v4 + 24;
  }
  *((void *)&xmmword_772958 + 1) = v5;
  uint64_t v177 = (void **)&v175;
  std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v177);
  std::vector<GTMMappedBuffer>::reserve((uint64_t *)(*((void *)&xmmword_772958 + 1) - 24), [v3 ringBufferNum]);
  if ((a2 & 1) == 0)
  {
    unsigned int v14 = [v3 ringBufferNum];
    uint64_t v15 = v14;
    int v16 = (DynamicBuffer *)xmmword_772978;
    unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(xmmword_772978 - *((void *)&xmmword_772968 + 1)) >> 4);
    unint64_t v18 = v14 - v17;
    if (v14 <= v17)
    {
      if (v14 < v17)
      {
        uint64_t v65 = *((void *)&xmmword_772968 + 1) + 48 * v14;
        while (v16 != (DynamicBuffer *)v65)
        {
          unint64_t v66 = (void *)*((void *)v16 - 3);
          if (v66)
          {
            *((void *)v16 - 2) = v66;
            operator delete(v66);
          }
          int v16 = (DynamicBuffer *)((char *)v16 - 48);
        }
        *(void *)&xmmword_772978 = v65;
      }
    }
    else if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&xmmword_772978 + 1) - xmmword_772978) >> 4) >= v18)
    {
      uint64_t v173 = xmmword_772978 + 48 * v18;
      uint64_t v174 = 48 * v14 - 16 * ((uint64_t)(xmmword_772978 - *((void *)&xmmword_772968 + 1)) >> 4);
      do
      {
        DynamicBuffer::DynamicBuffer(v16);
        int v16 = (DynamicBuffer *)((char *)v16 + 48);
        v174 -= 48;
      }
      while (v174);
      *(void *)&xmmword_772978 = v173;
    }
    else
    {
      uint64_t v180 = (long long *)((char *)&xmmword_772978 + 8);
      unint64_t v19 = 0x5555555555555556 * ((uint64_t)(*((void *)&xmmword_772978 + 1) - *((void *)&xmmword_772968 + 1)) >> 4);
      if (v19 <= v14) {
        unint64_t v19 = v14;
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&xmmword_772978 + 1) - *((void *)&xmmword_772968 + 1)) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v20 = 0x555555555555555;
      }
      else {
        unint64_t v20 = v19;
      }
      uint64_t v21 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<DynamicBuffer>>(v20);
      unsigned int v22 = (DynamicBuffer *)&v21[6 * v17];
      uint64_t v177 = v21;
      v178.i64[0] = (uint64_t)v22;
      v178.i64[1] = (uint64_t)v22;
      uint64_t v179 = &v21[6 * v23];
      uint64_t v24 = 3 * v15;
      unint64_t v25 = &v21[6 * v15];
      uint64_t v26 = 16 * v24 - 48 * v17;
      do
      {
        DynamicBuffer::DynamicBuffer(v22);
        unsigned int v22 = (DynamicBuffer *)((char *)v22 + 48);
        v26 -= 48;
      }
      while (v26);
      v178.i64[1] = (uint64_t)v25;
      std::vector<DynamicBuffer>::__swap_out_circular_buffer((uint64_t *)&xmmword_772968 + 1, &v177);
      std::__split_buffer<DynamicBuffer>::~__split_buffer((uint64_t)&v177);
    }
  }
  long long v175 = 0uLL;
  unint64_t v176 = 0;
  uint64_t v12 = xmmword_772948;
  if ((unint64_t)xmmword_772948 >= *((void *)&xmmword_772948 + 1))
  {
    unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)xmmword_772948 - qword_772940) >> 3);
    unint64_t v28 = v27 + 1;
    if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    if (0x5555555555555556 * ((*((void *)&xmmword_772948 + 1) - qword_772940) >> 3) > v28) {
      unint64_t v28 = 0x5555555555555556 * ((*((void *)&xmmword_772948 + 1) - qword_772940) >> 3);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((*((void *)&xmmword_772948 + 1) - qword_772940) >> 3) >= 0x555555555555555) {
      unint64_t v29 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v29 = v28;
    }
    uint64_t v180 = (long long *)((char *)&xmmword_772948 + 8);
    uint64_t v30 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v29);
    unint64_t v31 = &v30[3 * v27];
    uint64_t v177 = v30;
    v178.i64[0] = (uint64_t)v31;
    uint64_t v179 = &v30[3 * v32];
    *unint64_t v31 = 0;
    v31[1] = 0;
    v31[2] = 0;
    *(_OWORD *)unint64_t v31 = v175;
    v31[2] = v176;
    long long v175 = 0uLL;
    unint64_t v176 = 0;
    v178.i64[1] = (uint64_t)(v31 + 3);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer(&qword_772940, &v177);
    uint64_t v13 = xmmword_772948;
    std::__split_buffer<std::vector<GTMMappedBuffer>>::~__split_buffer((uint64_t)&v177);
  }
  else
  {
    *(_OWORD *)xmmword_772948 = 0uLL;
    *(void *)(v12 + 16) = 0;
    *(_OWORD *)uint64_t v12 = v175;
    *(void *)(v12 + 16) = v176;
    long long v175 = 0uLL;
    unint64_t v176 = 0;
    uint64_t v13 = v12 + 24;
    *(void *)&xmmword_772948 = v12 + 24;
  }
  *(void *)&xmmword_772948 = v13;
  uint64_t v177 = (void **)&v175;
  std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v177);
  std::vector<GTMMappedBuffer>::reserve((uint64_t *)(xmmword_772948 - 24), [v3 ringBufferNum]);
  long long v175 = 0uLL;
  unint64_t v176 = 0;
  uint64_t v33 = *((void *)&xmmword_772988 + 1);
  if (*((void *)&xmmword_772988 + 1) >= qword_772998)
  {
    unint64_t v35 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&xmmword_772988 + 1) - xmmword_772988) >> 3);
    unint64_t v36 = v35 + 1;
    if (v35 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    if (0x5555555555555556 * ((uint64_t)(qword_772998 - xmmword_772988) >> 3) > v36) {
      unint64_t v36 = 0x5555555555555556 * ((uint64_t)(qword_772998 - xmmword_772988) >> 3);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(qword_772998 - xmmword_772988) >> 3) >= 0x555555555555555) {
      unint64_t v37 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v37 = v36;
    }
    uint64_t v180 = (long long *)&qword_772998;
    uint64_t v38 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v37);
    uint64_t v39 = &v38[3 * v35];
    uint64_t v177 = v38;
    v178.i64[0] = (uint64_t)v39;
    uint64_t v179 = &v38[3 * v40];
    void *v39 = 0;
    v39[1] = 0;
    v39[2] = 0;
    *(_OWORD *)uint64_t v39 = v175;
    v39[2] = v176;
    long long v175 = 0uLL;
    unint64_t v176 = 0;
    v178.i64[1] = (uint64_t)(v39 + 3);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer(&xmmword_772988, &v177);
    uint64_t v34 = *((void *)&xmmword_772988 + 1);
    std::__split_buffer<std::vector<GTMMappedBuffer>>::~__split_buffer((uint64_t)&v177);
  }
  else
  {
    **((void **)&xmmword_772988 + 1) = 0;
    *(void *)(v33 + 8) = 0;
    *(void *)(v33 + 16) = 0;
    *(_OWORD *)uint64_t v33 = v175;
    *(void *)(v33 + 16) = v176;
    long long v175 = 0uLL;
    unint64_t v176 = 0;
    uint64_t v34 = v33 + 24;
    *((void *)&xmmword_772988 + 1) = v33 + 24;
  }
  *((void *)&xmmword_772988 + 1) = v34;
  uint64_t v177 = (void **)&v175;
  std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v177);
  std::vector<GTMMappedBuffer>::reserve((uint64_t *)(*((void *)&xmmword_772988 + 1) - 24), [v3 ringBufferNum]);
  long long v175 = 0uLL;
  unint64_t v176 = 0;
  uint64_t v41 = xmmword_7729A8;
  if ((unint64_t)xmmword_7729A8 >= *((void *)&xmmword_7729A8 + 1))
  {
    unint64_t v43 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)xmmword_7729A8 - qword_7729A0) >> 3);
    unint64_t v44 = v43 + 1;
    if (v43 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    if (0x5555555555555556 * ((*((void *)&xmmword_7729A8 + 1) - qword_7729A0) >> 3) > v44) {
      unint64_t v44 = 0x5555555555555556 * ((*((void *)&xmmword_7729A8 + 1) - qword_7729A0) >> 3);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((*((void *)&xmmword_7729A8 + 1) - qword_7729A0) >> 3) >= 0x555555555555555) {
      unint64_t v45 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v45 = v44;
    }
    uint64_t v180 = (long long *)((char *)&xmmword_7729A8 + 8);
    int v46 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v45);
    id v47 = &v46[3 * v43];
    uint64_t v177 = v46;
    v178.i64[0] = (uint64_t)v47;
    uint64_t v179 = &v46[3 * v48];
    char *v47 = 0;
    v47[1] = 0;
    v47[2] = 0;
    *(_OWORD *)id v47 = v175;
    v47[2] = v176;
    long long v175 = 0uLL;
    unint64_t v176 = 0;
    v178.i64[1] = (uint64_t)(v47 + 3);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer(&qword_7729A0, &v177);
    uint64_t v42 = xmmword_7729A8;
    std::__split_buffer<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::~__split_buffer((uint64_t)&v177);
  }
  else
  {
    *(_OWORD *)xmmword_7729A8 = 0uLL;
    *(void *)(v41 + 16) = 0;
    *(_OWORD *)uint64_t v41 = v175;
    *(void *)(v41 + 16) = v176;
    long long v175 = 0uLL;
    unint64_t v176 = 0;
    uint64_t v42 = v41 + 24;
    *(void *)&xmmword_7729A8 = v41 + 24;
  }
  *(void *)&xmmword_7729A8 = v42;
  uint64_t v177 = (void **)&v175;
  std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v177);
  std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::reserve((void *)(xmmword_7729A8 - 24), [v3 ringBufferNum]);
  long long v175 = 0uLL;
  unint64_t v176 = 0;
  uint64_t v49 = *((void *)&xmmword_7729B8 + 1);
  if (*((void *)&xmmword_7729B8 + 1) >= (unint64_t)xmmword_7729C8)
  {
    unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&xmmword_7729B8 + 1) - xmmword_7729B8) >> 3);
    unint64_t v52 = v51 + 1;
    if (v51 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    if (0x5555555555555556 * ((uint64_t)(xmmword_7729C8 - xmmword_7729B8) >> 3) > v52) {
      unint64_t v52 = 0x5555555555555556 * ((uint64_t)(xmmword_7729C8 - xmmword_7729B8) >> 3);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(xmmword_7729C8 - xmmword_7729B8) >> 3) >= 0x555555555555555) {
      unint64_t v53 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v53 = v52;
    }
    uint64_t v180 = &xmmword_7729C8;
    uint64_t v54 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v53);
    uint64_t v55 = &v54[3 * v51];
    uint64_t v177 = v54;
    v178.i64[0] = (uint64_t)v55;
    uint64_t v179 = &v54[3 * v56];
    *uint64_t v55 = 0;
    v55[1] = 0;
    v55[2] = 0;
    *(_OWORD *)uint64_t v55 = v175;
    v55[2] = v176;
    long long v175 = 0uLL;
    unint64_t v176 = 0;
    v178.i64[1] = (uint64_t)(v55 + 3);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer(&xmmword_7729B8, &v177);
    uint64_t v50 = *((void *)&xmmword_7729B8 + 1);
    std::__split_buffer<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::~__split_buffer((uint64_t)&v177);
  }
  else
  {
    **((void **)&xmmword_7729B8 + 1) = 0;
    *(void *)(v49 + 8) = 0;
    *(void *)(v49 + 16) = 0;
    *(_OWORD *)uint64_t v49 = v175;
    *(void *)(v49 + 16) = v176;
    long long v175 = 0uLL;
    unint64_t v176 = 0;
    uint64_t v50 = v49 + 24;
    *((void *)&xmmword_7729B8 + 1) = v49 + 24;
  }
  *((void *)&xmmword_7729B8 + 1) = v50;
  uint64_t v177 = (void **)&v175;
  std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v177);
  std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::reserve((void *)(*((void *)&xmmword_7729B8 + 1) - 24), [v3 ringBufferNum]);
  dispatch_semaphore_t v57 = dispatch_semaphore_create(1);
  dispatch_semaphore_t v58 = v57;
  uint64_t v59 = qword_7729D8;
  if (qword_7729D8 >= (unint64_t)qword_7729E0)
  {
    uint64_t v61 = (qword_7729D8 - *((void *)&xmmword_7729C8 + 1)) >> 3;
    if ((unint64_t)(v61 + 1) >> 61) {
      abort();
    }
    unint64_t v62 = (qword_7729E0 - *((void *)&xmmword_7729C8 + 1)) >> 2;
    if (v62 <= v61 + 1) {
      unint64_t v62 = v61 + 1;
    }
    if ((unint64_t)(qword_7729E0 - *((void *)&xmmword_7729C8 + 1)) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v63 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v63 = v62;
    }
    uint64_t v180 = (long long *)&qword_7729E0;
    if (v63) {
      unint64_t v63 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v63);
    }
    else {
      uint64_t v64 = 0;
    }
    unsigned int v67 = (dispatch_semaphore_t *)(v63 + 8 * v61);
    uint64_t v68 = v63 + 8 * v64;
    uint64_t v179 = (void **)v68;
    dispatch_semaphore_t *v67 = v58;
    uint64_t v60 = (uint64_t)(v67 + 1);
    v178.i64[1] = (uint64_t)(v67 + 1);
    uint64_t v70 = (void *)*((void *)&xmmword_7729C8 + 1);
    unsigned int v69 = (void *)qword_7729D8;
    if (qword_7729D8 == *((void *)&xmmword_7729C8 + 1))
    {
      int64x2_t v72 = vdupq_n_s64(qword_7729D8);
    }
    else
    {
      do
      {
        BOOL v71 = *--v69;
        *unsigned int v69 = 0;
        *--unsigned int v67 = v71;
      }
      while (v69 != v70);
      int64x2_t v72 = *(int64x2_t *)((char *)&xmmword_7729C8 + 8);
      uint64_t v60 = v178.i64[1];
      uint64_t v68 = (uint64_t)v179;
    }
    *((void *)&xmmword_7729C8 + 1) = v67;
    qword_7729D8 = v60;
    int64x2_t v178 = v72;
    uint64_t v73 = qword_7729E0;
    qword_7729E0 = v68;
    uint64_t v179 = (void **)v73;
    uint64_t v177 = (void **)v72.i64[0];
    std::__split_buffer<NSString * {__strong}>::~__split_buffer((uint64_t)&v177);
  }
  else
  {
    *(void *)qword_7729D8 = v57;
    uint64_t v60 = v59 + 8;
  }
  qword_7729D8 = v60;
  unsigned int v74 = [v3 ringBufferNum:v175, v176];
  dword_77289C += v74;
  unsigned int v75 = [v3 ringBufferNum];
  unsigned int v76 = 0;
  unsigned int v77 = qword_7728A0;
  if (qword_7728A0 <= v75) {
    unsigned int v77 = v75;
  }
  LODWORD(qword_7728A0) = v77;
  while (v76 < [v3 ringBufferNum])
  {
    if (a2)
    {
      uint64_t v78 = *((void *)&xmmword_772958 + 1);
      unint64_t v79 = *(void *)(*((void *)&xmmword_772958 + 1) - 16);
      unint64_t v80 = *(void *)(*((void *)&xmmword_772958 + 1) - 8);
      if (v79 >= v80)
      {
        uint64_t v86 = *(void *)(*((void *)&xmmword_772958 + 1) - 24);
        unint64_t v87 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v79 - v86) >> 3);
        unint64_t v88 = v87 + 1;
        if (v87 + 1 > 0x222222222222222) {
          abort();
        }
        unint64_t v89 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v80 - v86) >> 3);
        if (2 * v89 > v88) {
          unint64_t v88 = 2 * v89;
        }
        if (v89 >= 0x111111111111111) {
          unint64_t v90 = 0x222222222222222;
        }
        else {
          unint64_t v90 = v88;
        }
        uint64_t v180 = (long long *)(*((void *)&xmmword_772958 + 1) - 8);
        if (v90) {
          unint64_t v90 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::Property>>(v90);
        }
        else {
          uint64_t v91 = 0;
        }
        uint64_t v177 = (void **)v90;
        v178.i64[0] = v90 + 120 * v87;
        v178.i64[1] = v178.i64[0];
        uint64_t v179 = (void **)(v90 + 120 * v91);
        GTMMappedBuffer::GTMMappedBuffer((GTMMappedBuffer *)v178.i64[0], 0x8000000uLL, 0x1000000u);
        v178.i64[1] += 120;
        std::vector<GTMMappedBuffer>::__swap_out_circular_buffer((uint64_t *)(v78 - 24), &v177);
        unint64_t v81 = *(void *)(v78 - 16);
        std::__split_buffer<GTMMappedBuffer>::~__split_buffer((uint64_t)&v177);
      }
      else
      {
        GTMMappedBuffer::GTMMappedBuffer(*(GTMMappedBuffer **)(*((void *)&xmmword_772958 + 1) - 16), 0x8000000uLL, 0x1000000u);
        unint64_t v81 = v79 + 120;
        *(void *)(v78 - 16) = v79 + 120;
      }
      *(void *)(v78 - 16) = v81;
      uint64_t v98 = *((void *)&xmmword_772988 + 1);
      unint64_t v99 = *(void *)(*((void *)&xmmword_772988 + 1) - 16);
      unint64_t v100 = *(void *)(*((void *)&xmmword_772988 + 1) - 8);
      if (v99 >= v100)
      {
        uint64_t v102 = *(void *)(*((void *)&xmmword_772988 + 1) - 24);
        unint64_t v103 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v99 - v102) >> 3);
        unint64_t v104 = v103 + 1;
        if (v103 + 1 > 0x222222222222222) {
          abort();
        }
        unint64_t v105 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v100 - v102) >> 3);
        if (2 * v105 > v104) {
          unint64_t v104 = 2 * v105;
        }
        if (v105 >= 0x111111111111111) {
          unint64_t v106 = 0x222222222222222;
        }
        else {
          unint64_t v106 = v104;
        }
        uint64_t v180 = (long long *)(*((void *)&xmmword_772988 + 1) - 8);
        if (v106) {
          unint64_t v106 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::Property>>(v106);
        }
        else {
          uint64_t v107 = 0;
        }
        uint64_t v177 = (void **)v106;
        v178.i64[0] = v106 + 120 * v103;
        v178.i64[1] = v178.i64[0];
        uint64_t v179 = (void **)(v106 + 120 * v107);
        GTMMappedBuffer::GTMMappedBuffer((GTMMappedBuffer *)v178.i64[0], 0x8000000uLL, 0x2000000u);
        v178.i64[1] += 120;
        std::vector<GTMMappedBuffer>::__swap_out_circular_buffer((uint64_t *)(v98 - 24), &v177);
        unint64_t v101 = *(void *)(v98 - 16);
        std::__split_buffer<GTMMappedBuffer>::~__split_buffer((uint64_t)&v177);
      }
      else
      {
        GTMMappedBuffer::GTMMappedBuffer(*(GTMMappedBuffer **)(*((void *)&xmmword_772988 + 1) - 16), 0x8000000uLL, 0x2000000u);
        unint64_t v101 = v99 + 120;
        *(void *)(v98 - 16) = v99 + 120;
      }
      *(void *)(v98 - 16) = v101;
      uint64_t v118 = xmmword_772948;
      unint64_t v119 = *(void *)(xmmword_772948 - 16);
      unint64_t v120 = *(void *)(xmmword_772948 - 8);
      if (v119 < v120)
      {
        GTMMappedBuffer::GTMMappedBuffer(*(GTMMappedBuffer **)(xmmword_772948 - 16), 0x100000uLL, 0x100000u);
LABEL_144:
        unint64_t v128 = v119 + 120;
        *(void *)(v118 - 16) = v119 + 120;
        goto LABEL_158;
      }
      uint64_t v121 = *(void *)(xmmword_772948 - 24);
      unint64_t v122 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v119 - v121) >> 3);
      unint64_t v123 = v122 + 1;
      if (v122 + 1 > 0x222222222222222) {
        abort();
      }
      unint64_t v124 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v120 - v121) >> 3);
      if (2 * v124 > v123) {
        unint64_t v123 = 2 * v124;
      }
      if (v124 >= 0x111111111111111) {
        unint64_t v125 = 0x222222222222222;
      }
      else {
        unint64_t v125 = v123;
      }
      uint64_t v180 = (long long *)(xmmword_772948 - 8);
      if (v125) {
        unint64_t v125 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::Property>>(v125);
      }
      else {
        uint64_t v126 = 0;
      }
      uint64_t v177 = (void **)v125;
      v178.i64[0] = v125 + 120 * v122;
      v178.i64[1] = v178.i64[0];
      uint64_t v179 = (void **)(v125 + 120 * v126);
      GTMMappedBuffer::GTMMappedBuffer((GTMMappedBuffer *)v178.i64[0], 0x100000uLL, 0x100000u);
      v178.i64[1] += 120;
      std::vector<GTMMappedBuffer>::__swap_out_circular_buffer((uint64_t *)(v118 - 24), &v177);
    }
    else
    {
      uint64_t v82 = *((void *)&xmmword_772988 + 1);
      unint64_t v83 = *(void *)(*((void *)&xmmword_772988 + 1) - 16);
      unint64_t v84 = *(void *)(*((void *)&xmmword_772988 + 1) - 8);
      if (v83 >= v84)
      {
        uint64_t v92 = *(void *)(*((void *)&xmmword_772988 + 1) - 24);
        unint64_t v93 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v83 - v92) >> 3);
        unint64_t v94 = v93 + 1;
        if (v93 + 1 > 0x222222222222222) {
          abort();
        }
        unint64_t v95 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v84 - v92) >> 3);
        if (2 * v95 > v94) {
          unint64_t v94 = 2 * v95;
        }
        if (v95 >= 0x111111111111111) {
          unint64_t v96 = 0x222222222222222;
        }
        else {
          unint64_t v96 = v94;
        }
        uint64_t v180 = (long long *)(*((void *)&xmmword_772988 + 1) - 8);
        if (v96) {
          unint64_t v96 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::Property>>(v96);
        }
        else {
          uint64_t v97 = 0;
        }
        uint64_t v177 = (void **)v96;
        v178.i64[0] = v96 + 120 * v93;
        v178.i64[1] = v178.i64[0];
        uint64_t v179 = (void **)(v96 + 120 * v97);
        GTMMappedBuffer::GTMMappedBuffer((GTMMappedBuffer *)v178.i64[0], 0x4000uLL, 0x4000u);
        v178.i64[1] += 120;
        std::vector<GTMMappedBuffer>::__swap_out_circular_buffer((uint64_t *)(v82 - 24), &v177);
        unint64_t v85 = *(void *)(v82 - 16);
        std::__split_buffer<GTMMappedBuffer>::~__split_buffer((uint64_t)&v177);
      }
      else
      {
        GTMMappedBuffer::GTMMappedBuffer(*(GTMMappedBuffer **)(*((void *)&xmmword_772988 + 1) - 16), 0x4000uLL, 0x4000u);
        unint64_t v85 = v83 + 120;
        *(void *)(v82 - 16) = v83 + 120;
      }
      *(void *)(v82 - 16) = v85;
      uint64_t v108 = *((void *)&xmmword_772958 + 1);
      unint64_t v109 = *(void *)(*((void *)&xmmword_772958 + 1) - 16);
      unint64_t v110 = *(void *)(*((void *)&xmmword_772958 + 1) - 8);
      if (v109 >= v110)
      {
        uint64_t v112 = *(void *)(*((void *)&xmmword_772958 + 1) - 24);
        unint64_t v113 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v109 - v112) >> 3);
        unint64_t v114 = v113 + 1;
        if (v113 + 1 > 0x222222222222222) {
          abort();
        }
        unint64_t v115 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v110 - v112) >> 3);
        if (2 * v115 > v114) {
          unint64_t v114 = 2 * v115;
        }
        if (v115 >= 0x111111111111111) {
          unint64_t v116 = 0x222222222222222;
        }
        else {
          unint64_t v116 = v114;
        }
        uint64_t v180 = (long long *)(*((void *)&xmmword_772958 + 1) - 8);
        if (v116) {
          unint64_t v116 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::Property>>(v116);
        }
        else {
          uint64_t v117 = 0;
        }
        uint64_t v177 = (void **)v116;
        v178.i64[0] = v116 + 120 * v113;
        v178.i64[1] = v178.i64[0];
        uint64_t v179 = (void **)(v116 + 120 * v117);
        GTMMappedBuffer::GTMMappedBuffer((GTMMappedBuffer *)v178.i64[0], 0x4000uLL, 0x4000u);
        v178.i64[1] += 120;
        std::vector<GTMMappedBuffer>::__swap_out_circular_buffer((uint64_t *)(v108 - 24), &v177);
        unint64_t v111 = *(void *)(v108 - 16);
        std::__split_buffer<GTMMappedBuffer>::~__split_buffer((uint64_t)&v177);
      }
      else
      {
        GTMMappedBuffer::GTMMappedBuffer(*(GTMMappedBuffer **)(*((void *)&xmmword_772958 + 1) - 16), 0x4000uLL, 0x4000u);
        unint64_t v111 = v109 + 120;
        *(void *)(v108 - 16) = v109 + 120;
      }
      *(void *)(v108 - 16) = v111;
      uint64_t v118 = xmmword_772948;
      unint64_t v119 = *(void *)(xmmword_772948 - 16);
      unint64_t v127 = *(void *)(xmmword_772948 - 8);
      if (v119 < v127)
      {
        GTMMappedBuffer::GTMMappedBuffer(*(GTMMappedBuffer **)(xmmword_772948 - 16), 0x4000uLL, 0x4000u);
        goto LABEL_144;
      }
      uint64_t v129 = *(void *)(xmmword_772948 - 24);
      unint64_t v130 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v119 - v129) >> 3);
      unint64_t v131 = v130 + 1;
      if (v130 + 1 > 0x222222222222222) {
        abort();
      }
      unint64_t v132 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v127 - v129) >> 3);
      if (2 * v132 > v131) {
        unint64_t v131 = 2 * v132;
      }
      if (v132 >= 0x111111111111111) {
        unint64_t v133 = 0x222222222222222;
      }
      else {
        unint64_t v133 = v131;
      }
      uint64_t v180 = (long long *)(xmmword_772948 - 8);
      if (v133) {
        unint64_t v133 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::Property>>(v133);
      }
      else {
        uint64_t v134 = 0;
      }
      uint64_t v177 = (void **)v133;
      v178.i64[0] = v133 + 120 * v130;
      v178.i64[1] = v178.i64[0];
      uint64_t v179 = (void **)(v133 + 120 * v134);
      GTMMappedBuffer::GTMMappedBuffer((GTMMappedBuffer *)v178.i64[0], 0x4000uLL, 0x4000u);
      v178.i64[1] += 120;
      std::vector<GTMMappedBuffer>::__swap_out_circular_buffer((uint64_t *)(v118 - 24), &v177);
    }
    unint64_t v128 = *(void *)(v118 - 16);
    std::__split_buffer<GTMMappedBuffer>::~__split_buffer((uint64_t)&v177);
LABEL_158:
    *(void *)(v118 - 16) = v128;
    uint64_t v135 = xmmword_7729A8;
    dispatch_semaphore_t v136 = dispatch_semaphore_create(0);
    dispatch_semaphore_t v137 = v136;
    uint64_t v138 = *(dispatch_semaphore_t **)(v135 - 16);
    unint64_t v139 = *(void *)(v135 - 8);
    if ((unint64_t)v138 >= v139)
    {
      uint64_t v141 = *(void *)(v135 - 24);
      uint64_t v142 = ((uint64_t)v138 - v141) >> 3;
      if ((unint64_t)(v142 + 1) >> 61) {
        abort();
      }
      uint64_t v143 = v139 - v141;
      uint64_t v144 = v143 >> 2;
      if (v143 >> 2 <= (unint64_t)(v142 + 1)) {
        uint64_t v144 = v142 + 1;
      }
      if ((unint64_t)v143 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v145 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v145 = v144;
      }
      uint64_t v180 = (long long *)(v135 - 8);
      if (v145) {
        unint64_t v145 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v145);
      }
      else {
        uint64_t v146 = 0;
      }
      int v147 = (dispatch_semaphore_t *)(v145 + 8 * v142);
      unint64_t v148 = v145 + 8 * v146;
      uint64_t v179 = (void **)v148;
      *int v147 = v137;
      uint64_t v140 = v147 + 1;
      v178.i64[1] = (uint64_t)(v147 + 1);
      unsigned __int8 v150 = *(void **)(v135 - 24);
      unint64_t v149 = *(void **)(v135 - 16);
      if (v149 == v150)
      {
        uint64_t v152 = *(void ***)(v135 - 16);
      }
      else
      {
        do
        {
          unint64_t v151 = *--v149;
          void *v149 = 0;
          *--int v147 = v151;
        }
        while (v149 != v150);
        uint64_t v152 = *(void ***)(v135 - 24);
        unint64_t v149 = *(void **)(v135 - 16);
        uint64_t v140 = (void *)v178.i64[1];
        unint64_t v148 = (unint64_t)v179;
      }
      *(void *)(v135 - 24) = v147;
      v178.i64[0] = (uint64_t)v152;
      *(void *)(v135 - 16) = v140;
      v178.i64[1] = (uint64_t)v149;
      unint64_t v153 = *(void ***)(v135 - 8);
      *(void *)(v135 - 8) = v148;
      uint64_t v179 = v153;
      uint64_t v177 = v152;
      std::__split_buffer<NSString * {__strong}>::~__split_buffer((uint64_t)&v177);
    }
    else
    {
      dispatch_semaphore_t *v138 = v136;
      uint64_t v140 = v138 + 1;
    }
    *(void *)(v135 - 16) = v140;
    uint64_t v154 = *((void *)&xmmword_7729B8 + 1);
    dispatch_semaphore_t v155 = dispatch_semaphore_create(0);
    dispatch_semaphore_t v156 = v155;
    unint64_t v157 = *(dispatch_semaphore_t **)(v154 - 16);
    unint64_t v158 = *(void *)(v154 - 8);
    if ((unint64_t)v157 >= v158)
    {
      uint64_t v160 = *(void *)(v154 - 24);
      uint64_t v161 = ((uint64_t)v157 - v160) >> 3;
      if ((unint64_t)(v161 + 1) >> 61) {
        abort();
      }
      uint64_t v162 = v158 - v160;
      uint64_t v163 = v162 >> 2;
      if (v162 >> 2 <= (unint64_t)(v161 + 1)) {
        uint64_t v163 = v161 + 1;
      }
      if ((unint64_t)v162 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v164 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v164 = v163;
      }
      uint64_t v180 = (long long *)(v154 - 8);
      if (v164) {
        unint64_t v164 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v164);
      }
      else {
        uint64_t v165 = 0;
      }
      unint64_t v166 = (dispatch_semaphore_t *)(v164 + 8 * v161);
      unint64_t v167 = v164 + 8 * v165;
      uint64_t v179 = (void **)v167;
      *unint64_t v166 = v156;
      uint64_t v159 = v166 + 1;
      v178.i64[1] = (uint64_t)(v166 + 1);
      unint64_t v169 = *(void **)(v154 - 24);
      unint64_t v168 = *(void **)(v154 - 16);
      if (v168 == v169)
      {
        unint64_t v171 = *(void ***)(v154 - 16);
      }
      else
      {
        do
        {
          uint64_t v170 = *--v168;
          *unint64_t v168 = 0;
          *--unint64_t v166 = v170;
        }
        while (v168 != v169);
        unint64_t v171 = *(void ***)(v154 - 24);
        unint64_t v168 = *(void **)(v154 - 16);
        uint64_t v159 = (void *)v178.i64[1];
        unint64_t v167 = (unint64_t)v179;
      }
      *(void *)(v154 - 24) = v166;
      v178.i64[0] = (uint64_t)v171;
      *(void *)(v154 - 16) = v159;
      v178.i64[1] = (uint64_t)v168;
      uint64_t v172 = *(void ***)(v154 - 8);
      *(void *)(v154 - 8) = v167;
      uint64_t v179 = v172;
      uint64_t v177 = v171;
      std::__split_buffer<NSString * {__strong}>::~__split_buffer((uint64_t)&v177);
    }
    else
    {
      dispatch_semaphore_t *v157 = v155;
      uint64_t v159 = v157 + 1;
    }
    *(void *)(v154 - 16) = v159;
    ++v76;
  }
}

void sub_1D2490(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  id v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        GTMMappedBuffer::~GTMMappedBuffer((GTMMappedBuffer *)(v4 - 120));
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *std::vector<GTMMappedBuffer>::reserve(uint64_t *result, unint64_t a2)
{
  if (0xEEEEEEEEEEEEEEEFLL * ((result[2] - *result) >> 3) < a2)
  {
    uint64_t v2 = result;
    uint64_t v3 = result[1] - *result;
    void v5[4] = result + 2;
    v5[0] = std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::Property>>(a2);
    v5[1] = v5[0] + v3;
    v5[2] = v5[0] + v3;
    v5[3] = v5[0] + 120 * v4;
    std::vector<GTMMappedBuffer>::__swap_out_circular_buffer(v2, v5);
    return (uint64_t *)std::__split_buffer<GTMMappedBuffer>::~__split_buffer((uint64_t)v5);
  }
  return result;
}

void sub_1D26A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<GTMMappedBuffer>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void GTMMappedBuffer::GTMMappedBuffer(GTMMappedBuffer *this, unint64_t a2, unsigned int a3)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 4) = 0xFFFFFFFFLL;
  *((_DWORD *)this + 10) = a3;
  *((_OWORD *)this + 3) = 0u;
  unint64_t v4 = a3;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 14) = 0;
  if (a3 <= a2)
  {
    unint64_t v6 = +[NSFileManager defaultManager];
    unsigned __int8 v7 = [v6 fileExistsAtPath:@"/tmp/com.apple.gputools.profiling"];

    if ((v7 & 1) == 0)
    {
      unint64_t v8 = +[NSFileManager defaultManager];
      [v8 createDirectoryAtPath:@"/tmp/com.apple.gputools.profiling" withIntermediateDirectories:1 attributes:0 error:0];
    }
    uint64_t v9 = +[NSUUID UUID];
    int64x2_t v10 = [v9 UUIDString];
    uint64_t v11 = +[NSString stringWithFormat:@"%@/Temp_%@_%d.mmapbuffer", @"/tmp/com.apple.gputools.profiling", v10, rand()];
    uint64_t v12 = (void *)*((void *)this + 3);
    *((void *)this + 3) = v11;

    int v13 = open((const char *)[*((id *)this + 3) UTF8String], 1538, 438);
    *((_DWORD *)this + 8) = v13;
    if (v13 < 0)
    {
      uint64_t v49 = __error();
      uint64_t v50 = +[NSString stringWithFormat:@"%s", strerror(*v49)];
      unint64_t v51 = __stdoutp;
      int v52 = g_runningInCI;
      id v53 = v50;
      uint64_t v54 = (const char *)[v53 UTF8String];
      uint64_t v55 = "#CI_ERROR# ";
      if (!v52) {
        uint64_t v55 = "";
      }
      fprintf(v51, "%s%s %u: %s\n", v55, "GTMMappedBuffer::GTMMappedBuffer(size_t, size_t)", 1027, v54);
      id v48 = v53;
      GTMTLReplay_handleError(101, (uint64_t)[v48 UTF8String], "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTUSCSamplingStreamingManager.mm", (uint64_t)"GTMMappedBuffer", 1027, 1);
    }
    else
    {
      lseek(v13, a2, 0);
      write(*((_DWORD *)this + 8), "A", 1uLL);
      uint64_t v14 = 0;
      int v56 = a2;
      if (a2 / v4 <= 1) {
        uint64_t v15 = 1;
      }
      else {
        uint64_t v15 = a2 / v4;
      }
      do
      {
        int v16 = mmap(0, *((unsigned int *)this + 10), 3, 2, *((_DWORD *)this + 8), v14 * *((unsigned int *)this + 10));
        unint64_t v17 = v16;
        if (v16 == (void *)-1)
        {
          uint64_t v24 = __error();
          unint64_t v25 = +[NSString stringWithFormat:@"%s", strerror(*v24)];
          uint64_t v26 = __stdoutp;
          int v27 = g_runningInCI;
          id v28 = v25;
          unint64_t v29 = (const char *)[v28 UTF8String];
          uint64_t v30 = "#CI_ERROR# ";
          if (!v27) {
            uint64_t v30 = "";
          }
          fprintf(v26, "%s%s %u: %s\n", v30, "GTMMappedBuffer::GTMMappedBuffer(size_t, size_t)", 1037, v29);
          id v31 = v28;
          GTMTLReplay_handleError(101, (uint64_t)[v31 UTF8String], "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTUSCSamplingStreamingManager.mm", (uint64_t)"GTMMappedBuffer", 1037, 1);
        }
        else
        {
          uint64_t v19 = *((void *)this + 12);
          unint64_t v18 = *((void *)this + 13);
          uint64_t v20 = (uint64_t)(v18 - v19) >> 5;
          unint64_t v21 = *((void *)this + 14);
          if (v18 >= v21)
          {
            unint64_t v32 = v20 + 1;
            if ((unint64_t)(v20 + 1) >> 59) {
              abort();
            }
            uint64_t v33 = v21 - v19;
            if (v33 >> 4 > v32) {
              unint64_t v32 = v33 >> 4;
            }
            if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v34 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v34 = v32;
            }
            unint64_t v35 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>>(v34);
            unint64_t v37 = &v35[32 * v20];
            int v38 = *((_DWORD *)this + 10);
            *(void *)unint64_t v37 = v20;
            *((void *)v37 + 1) = v17;
            *((_DWORD *)v37 + 5) = 0;
            *((_DWORD *)v37 + 6) = 0;
            *((_DWORD *)v37 + 4) = v38;
            uint64_t v40 = (char *)*((void *)this + 12);
            uint64_t v39 = (char *)*((void *)this + 13);
            uint64_t v41 = v37;
            if (v39 != v40)
            {
              do
              {
                long long v42 = *((_OWORD *)v39 - 1);
                *((_OWORD *)v41 - 2) = *((_OWORD *)v39 - 2);
                *((_OWORD *)v41 - 1) = v42;
                v41 -= 32;
                v39 -= 32;
              }
              while (v39 != v40);
              uint64_t v39 = (char *)*((void *)this + 12);
            }
            uint64_t v23 = v37 + 32;
            *((void *)this + 12) = v41;
            *((void *)this + 13) = v37 + 32;
            *((void *)this + 14) = &v35[32 * v36];
            if (v39) {
              operator delete(v39);
            }
          }
          else
          {
            int v22 = *((_DWORD *)this + 10);
            *(void *)unint64_t v18 = v20;
            *(void *)(v18 + 8) = v16;
            *(_DWORD *)(v18 + 20) = 0;
            *(_DWORD *)(v18 + 24) = 0;
            *(_DWORD *)(v18 + 16) = v22;
            uint64_t v23 = (char *)(v18 + 32);
          }
          *((void *)this + 13) = v23;
        }
        ++v14;
      }
      while (v14 != v15);
      *((_DWORD *)this + 9) = v56;
      uint64_t v43 = objc_opt_new();
      unint64_t v44 = (void *)*((void *)this + 2);
      *((void *)this + 2) = v43;

      dispatch_semaphore_t v45 = dispatch_semaphore_create(1);
      int v46 = *(void **)this;
      *(void *)this = v45;

      dispatch_semaphore_t v47 = dispatch_semaphore_create(1);
      id v48 = (id)*((void *)this + 1);
      *((void *)this + 1) = v47;
    }
  }
}

void sub_1D2B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  uint64_t v15 = *(void **)(v13 + 96);
  if (v15)
  {
    *(void *)(v13 + 104) = v15;
    operator delete(v15);
  }
  std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100](a13);

  _Unwind_Resume(a1);
}

void std::vector<GTMMappedBuffer>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1[1];
  uint64_t v52 = *a1;
  uint64_t v3 = a2[1];
  if (v2 == *a1)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    uint64_t v4 = a1[1];
    uint64_t v5 = a2[1];
    do
    {
      unint64_t v6 = *(void **)(v4 - 120);
      v4 -= 120;
      *(void *)(v5 - 120) = v6;
      v5 -= 120;
      *(void *)(v3 - 112) = *(id *)(v4 + 8);
      *(void *)(v3 - 104) = *(id *)(v4 + 16);
      *(void *)(v3 - 96) = *(id *)(v4 + 24);
      long long v7 = *(_OWORD *)(v4 + 32);
      *(_OWORD *)(v3 - 72) = 0u;
      uint64_t v8 = v3 - 72;
      *(_OWORD *)(v3 - 88) = v7;
      *(_OWORD *)(v8 + 16) = 0u;
      *(_OWORD *)(v8 + 32) = 0u;
      unint64_t v9 = *(void *)(v4 + 80);
      unint64_t v10 = v9 / 0xAA;
      uint64_t v11 = *(void *)(v4 + 56);
      if (*(void *)(v4 + 64) == v11)
      {
        unint64_t v12 = 0;
        unint64_t v15 = 0;
        uint64_t v14 = (void *)(v11 + 8 * ((*(void *)(v2 - 32) + v9) / 0xAA));
      }
      else
      {
        unint64_t v12 = *(void *)(v11 + 8 * (v9 / 0xAA)) + 24 * (v9 % 0xAA);
        unint64_t v13 = *(void *)(v2 - 32) + v9;
        uint64_t v14 = (void *)(v11 + 8 * (v13 / 0xAA));
        unint64_t v15 = *v14 + 24 * (v13 % 0xAA);
      }
      if (v15 != v12)
      {
        int v16 = (void *)(v11 + 8 * v10);
        uint64_t v17 = 170 * (v14 - v16)
            - 0x5555555555555555 * ((uint64_t)(v15 - *v14) >> 3)
            + 0x5555555555555555 * ((uint64_t)(v12 - *v16) >> 3);
        if (v17)
        {
          unint64_t v18 = (v17 + 1) / 0xAAuLL;
          if (-170 * v18 == ~v17) {
            unint64_t v19 = (v17 + 1) / 0xAAuLL;
          }
          else {
            unint64_t v19 = v18 + 1;
          }
          if (v19)
          {
            uint64_t v56 = v3 - 48;
            *(void *)&long long v54 = std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v19);
            *((void *)&v54 + 1) = v54;
            *(void *)&long long v55 = v54;
            *((void *)&v55 + 1) = v54 + 8 * v20;
            do
            {
              id v53 = operator new(0xFF0uLL);
              std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_back(&v54, &v53);
              --v19;
            }
            while (v19);
            for (uint64_t i = *(void **)(v3 - 56);
                  i != *(void **)(v3 - 64);
                  std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_front((uint64_t)&v54, i))
            {
              --i;
            }
            int v22 = *(void **)(v3 - 72);
            uint64_t v23 = *((void *)&v54 + 1);
            long long v24 = v55;
            *(_OWORD *)(v3 - 72) = v54;
            *(_OWORD *)(v3 - 56) = v24;
            if (v22)
            {
              operator delete(v22);
              uint64_t v25 = *(void *)(v3 - 64);
              uint64_t v26 = *(void *)(v3 - 56);
            }
            else
            {
              uint64_t v25 = v23;
              uint64_t v26 = v24;
            }
            uint64_t v28 = *(void *)(v3 - 32);
            unint64_t v30 = *(void *)(v3 - 40) + v28;
            unint64_t v29 = (uint64_t *)(v25 + 8 * (v30 / 0xAA));
            if (v26 == v25) {
              unint64_t v27 = 0;
            }
            else {
              unint64_t v27 = *v29 + 24 * (v30 % 0xAA);
            }
          }
          else
          {
            unint64_t v27 = 0;
            uint64_t v28 = 0;
            unint64_t v29 = 0;
          }
          uint64_t v31 = (uint64_t)(v27 - *v29) / 24 + v17;
          if (v31 < 1)
          {
            unint64_t v35 = 169 - v31;
            unint64_t v32 = &v29[-(v35 / 0xAA)];
            uint64_t v33 = *v32;
            unint64_t v34 = 169 - v35 % 0xAA;
          }
          else
          {
            unint64_t v32 = &v29[v31 / 0xAAuLL];
            uint64_t v33 = *v32;
            unint64_t v34 = v31 % 0xAAuLL;
          }
          uint64_t v36 = v33 + 24 * v34;
          while (v27 != v36)
          {
            uint64_t v37 = v36;
            if (v29 != v32) {
              uint64_t v37 = *v29 + 4080;
            }
            if (v27 == v37)
            {
              uint64_t v37 = v27;
            }
            else
            {
              unint64_t v38 = v27;
              do
              {
                long long v39 = *(_OWORD *)v12;
                *(void *)(v38 + 16) = *(void *)(v12 + 16);
                *(_OWORD *)unint64_t v38 = v39;
                v12 += 24;
                if (v12 - *v16 == 4080)
                {
                  unint64_t v40 = v16[1];
                  ++v16;
                  unint64_t v12 = v40;
                }
                v38 += 24;
              }
              while (v38 != v37);
              uint64_t v28 = *(void *)(v3 - 32);
            }
            v28 -= 0x5555555555555555 * ((uint64_t)(v37 - v27) >> 3);
            *(void *)(v3 - 32) = v28;
            if (v29 == v32) {
              break;
            }
            unint64_t v41 = v29[1];
            ++v29;
            unint64_t v27 = v41;
          }
        }
      }
      *(void *)(v3 - 24) = 0;
      *(void *)(v3 - 16) = 0;
      *(void *)(v3 - 8) = 0;
      uint64_t v43 = *(unsigned char **)(v2 - 24);
      long long v42 = *(unsigned char **)(v2 - 16);
      int64_t v44 = v42 - v43;
      if (v42 != v43)
      {
        if (v42 - v43 < 0) {
          abort();
        }
        dispatch_semaphore_t v45 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTable>>(v44 >> 5);
        *(void *)(v3 - 24) = v45;
        *(void *)(v3 - 16) = v45;
        *(void *)(v3 - 8) = &v45[32 * v46];
        memmove(v45, v43, v44);
        *(void *)(v3 - 16) = &v45[32 * (v44 >> 5)];
      }
      uint64_t v2 = v4;
      uint64_t v3 = v5;
    }
    while (v4 != v52);
  }
  a2[1] = v5;
  uint64_t v47 = *a1;
  *a1 = v5;
  a2[1] = v47;
  uint64_t v48 = a1[1];
  a1[1] = a2[2];
  a2[2] = v48;
  uint64_t v49 = a1[2];
  a1[2] = a2[3];
  a2[3] = v49;
  *a2 = a2[1];
}

void sub_1D2FE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p)
{
  std::__split_buffer<ProfileEvent *>::~__split_buffer(v13);

  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<GTMMappedBuffer>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 120;
    GTMMappedBuffer::~GTMMappedBuffer((GTMMappedBuffer *)(i - 120));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void GTMMappedBuffer::~GTMMappedBuffer(GTMMappedBuffer *this)
{
  uint64_t v2 = (void *)*((void *)this + 12);
  uint64_t v3 = *((void *)this + 13);
  if (v2 != (void *)v3 && *((_DWORD *)this + 9))
  {
    do
    {
      munmap(*(void **)(v3 - 24), *((unsigned int *)this + 10));
      uint64_t v4 = *((void *)this + 12);
      uint64_t v3 = *((void *)this + 13) - 32;
      *((void *)this + 13) = v3;
    }
    while (v4 != v3);
    close(*((_DWORD *)this + 8));
    uint64_t v5 = +[NSFileManager defaultManager];
    [v5 removeItemAtPath:*((void *)this + 3) error:0];

    uint64_t v2 = (void *)*((void *)this + 12);
  }
  if (v2)
  {
    *((void *)this + 13) = v2;
    operator delete(v2);
  }
  std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100]((void *)this + 6);
}

void sub_1D3158(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  uint64_t v5 = *(void **)(v1 + 96);
  if (v5)
  {
    *(void *)(v1 + 104) = v5;
    operator delete(v5);
  }
  std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100]((void *)(v1 + 48));

  _Unwind_Resume(a1);
}

uint64_t std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100](void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 85;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 170;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    long long v7 = *v2++;
    operator delete(v7);
  }

  return std::__split_buffer<ProfileEvent *>::~__split_buffer((uint64_t)a1);
}

void std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_back(void *a1, void *a2)
{
  unint64_t v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    unint64_t v5 = (char *)a1[1];
    uint64_t v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1) {
        unint64_t v16 = 1;
      }
      else {
        unint64_t v16 = (uint64_t)&v4[-*a1] >> 2;
      }
      uint64_t v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v16);
      unint64_t v19 = &v17[8 * (v16 >> 2)];
      uint64_t v20 = (uint64_t *)a1[1];
      unint64_t v4 = v19;
      uint64_t v21 = a1[2] - (void)v20;
      if (v21)
      {
        unint64_t v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v22 = 8 * (v21 >> 3);
        uint64_t v23 = &v17[8 * (v16 >> 2)];
        do
        {
          uint64_t v24 = *v20++;
          *(void *)uint64_t v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      uint64_t v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        unint64_t v4 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v7 = v6 >> 3;
      BOOL v8 = v6 >> 3 < -1;
      uint64_t v9 = (v6 >> 3) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      uint64_t v13 = &v5[-8 * v12];
      int64_t v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        unint64_t v4 = (char *)a1[1];
      }
      unint64_t v15 = &v4[8 * v11];
      unint64_t v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(void *)unint64_t v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_front(uint64_t a1, void *a2)
{
  unint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(unsigned char **)(a1 + 16);
    uint64_t v7 = *(unsigned char **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = (v7 - v4) >> 2;
      }
      uint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v11);
      unint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      unint64_t v15 = *(uint64_t **)(a1 + 8);
      unint64_t v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        unint64_t v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v18 = 8 * (v17 >> 3);
        unint64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)unint64_t v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        unint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      unint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        unint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    unint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

void *std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer(void *result, void *a2)
{
  uint64_t v3 = (void *)*result;
  uint64_t v2 = (void *)result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    *(void *)(v4 - 24) = 0;
    *(void *)(v4 - 16) = 0;
    v4 -= 24;
    *(void *)(v4 + 16) = 0;
    long long v5 = *(_OWORD *)(v2 - 3);
    v2 -= 3;
    *(_OWORD *)uint64_t v4 = v5;
    *(void *)(v4 + 16) = v2[2];
    *uint64_t v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  a2[1] = v4;
  uint64_t v6 = (void *)*result;
  *id result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v6 = v4;
    std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v6);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void DynamicBuffer::DynamicBuffer(DynamicBuffer *this)
{
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  uint64_t v2 = (char *)operator new(0xC00uLL);
  *((void *)this + 3) = v2;
  *((void *)this + 4) = v2;
  *((void *)this + 5) = v2 + 3072;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<DynamicBuffer>>(unint64_t a1)
{
  if (a1 >= 0x555555555555556) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(48 * a1);
}

uint64_t *std::vector<DynamicBuffer>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 48;
      uint64_t v6 = *(void *)(v3 - 32);
      *(_OWORD *)(v4 - 48) = *(_OWORD *)(v3 - 48);
      *(void *)(v4 - 32) = v6;
      *(void *)(v4 - 24) = 0;
      *(void *)(v4 - 16) = 0;
      *(void *)(v4 - 8) = 0;
      *(_OWORD *)(v4 - 24) = *(_OWORD *)(v3 - 24);
      *(void *)(v4 - 8) = *(void *)(v3 - 8);
      *(void *)(v3 - 24) = 0;
      *(void *)(v3 - 16) = 0;
      *(void *)(v3 - 8) = 0;
      v3 -= 48;
      v4 -= 48;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  uint64_t v7 = *result;
  *id result = v5;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<DynamicBuffer>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + 16) = v2 - 48;
    uint64_t v4 = *(void **)(v2 - 24);
    if (v4)
    {
      *(void *)(v2 - 16) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 48;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__split_buffer<std::vector<GTMMappedBuffer>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v6 = v4;
    std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v6);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void GTUSCSamplingStreamingManagerHelper::CleanUp(GTUSCSamplingStreamingManagerHelper *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)&GTUSCSamplingStreamingManagerHelper::CleanUp(void)::localSpinLock);
  if (!atomic_load((unint64_t *)this + 340)) {
    goto LABEL_50;
  }
  atomic_store(0, (unint64_t *)this + 340);
  atomic_store(1u, (unsigned __int8 *)this + 2764);
  dispatch_semaphore_wait(*((dispatch_semaphore_t *)this + 312), 0xFFFFFFFFFFFFFFFFLL);
  uint64_t v3 = (void *)*((void *)this + 274);
  if (v3)
  {
    [v3 cleanup];
    uint64_t v4 = (void *)*((void *)this + 274);
    *((void *)this + 274) = 0;
  }
  if (*(void *)this) {
    *(void *)this = 0;
  }
  GTUSCSamplingStreamingManagerHelper::CleanupGPURawCounters((uint64_t)this);
  ClearCaches();
  uint64_t v5 = (void *)*((void *)this + 1);
  *((void *)this + 1) = 0;

  GTApplePMPPerfStateControl::Close((GTUSCSamplingStreamingManagerHelper *)((char *)this + 64));
  std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::clear((void *)this + 281);
  uint64_t v6 = (void **)*((void *)this + 295);
  uint64_t v7 = (void **)*((void *)this + 294);
  while (v6 != v7)
  {
    v6 -= 3;
    dispatch_semaphore_t v57 = v6;
    std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v57);
  }
  *((void *)this + 295) = v7;
  std::vector<std::vector<GTMMappedBuffer>>::shrink_to_fit((uint64_t)this + 2352);
  uint64_t v8 = (void **)*((void *)this + 292);
  uint64_t v9 = (void **)*((void *)this + 291);
  while (v8 != v9)
  {
    v8 -= 3;
    dispatch_semaphore_t v57 = v8;
    std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v57);
  }
  *((void *)this + 292) = v9;
  std::vector<std::vector<GTMMappedBuffer>>::shrink_to_fit((uint64_t)this + 2328);
  uint64_t v10 = (void **)*((void *)this + 301);
  unint64_t v11 = (void **)*((void *)this + 300);
  while (v10 != v11)
  {
    v10 -= 3;
    dispatch_semaphore_t v57 = v10;
    std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v57);
  }
  *((void *)this + 301) = v11;
  std::vector<std::vector<GTMMappedBuffer>>::shrink_to_fit((uint64_t)this + 2400);
  uint64_t v12 = (void **)*((void *)this + 304);
  uint64_t v13 = (void **)*((void *)this + 303);
  while (v12 != v13)
  {
    v12 -= 3;
    dispatch_semaphore_t v57 = v12;
    std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v57);
  }
  *((void *)this + 304) = v13;
  std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::shrink_to_fit((uint64_t)this + 2424);
  uint64_t v14 = (void **)*((void *)this + 307);
  unint64_t v15 = (void **)*((void *)this + 306);
  while (v14 != v15)
  {
    v14 -= 3;
    dispatch_semaphore_t v57 = v14;
    std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v57);
  }
  *((void *)this + 307) = v15;
  std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::shrink_to_fit((uint64_t)this + 2448);
  unint64_t v16 = (void **)*((void *)this + 310);
  uint64_t v17 = (void **)*((void *)this + 309);
  if (v16 != v17)
  {
    do
    {
      uint64_t v18 = *--v16;
    }
    while (v16 != v17);
    unint64_t v16 = (void **)*((void *)this + 309);
  }
  *((void *)this + 310) = v17;
  unint64_t v19 = v17 - v16;
  if (v19 < (uint64_t)(*((void *)this + 311) - (void)v16) >> 3)
  {
    uint64_t v61 = (char *)this + 2488;
    if (v17 == v16)
    {
      uint64_t v24 = 0;
      uint64_t v22 = 8 * v19;
    }
    else
    {
      uint64_t v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v17 - v16);
      uint64_t v17 = (void **)*((void *)this + 310);
      uint64_t v21 = (void **)*((void *)this + 309);
      uint64_t v22 = (uint64_t)&v20[8 * v19];
      uint64_t v59 = (void **)v22;
      uint64_t v24 = &v20[8 * v23];
      if (v17 != v21)
      {
        uint64_t v25 = &v20[8 * v19];
        do
        {
          uint64_t v26 = (uint64_t)*--v17;
          char *v17 = 0;
          *((void *)v25 - 1) = v26;
          v25 -= 8;
        }
        while (v17 != v21);
        unint64_t v27 = (void **)*((void *)this + 309);
        uint64_t v17 = (void **)*((void *)this + 310);
        goto LABEL_32;
      }
    }
    unint64_t v27 = v17;
    uint64_t v25 = (char *)v22;
LABEL_32:
    *((void *)this + 309) = v25;
    *((void *)this + 310) = v22;
    uint64_t v28 = (void **)*((void *)this + 311);
    *((void *)this + 311) = v24;
    uint64_t v59 = v17;
    uint64_t v60 = v28;
    dispatch_semaphore_t v57 = v27;
    dispatch_semaphore_t v58 = v27;
    std::__split_buffer<NSString * {__strong}>::~__split_buffer((uint64_t)&v57);
  }
  std::vector<std::vector<ProfileEvent>>::__clear[abi:nn180100]((uint64_t *)this + 275);
  unint64_t v29 = *((void *)this + 275);
  int64x2_t v30 = *((int64x2_t *)this + 138);
  int64x2_t v31 = vshrq_n_s64(vsubq_s64(v30, vdupq_n_s64(v29)), 3uLL);
  unint64_t v32 = 0xAAAAAAAAAAAAAAABLL * v31.i64[0];
  unint64_t v33 = v32;
  if (0xAAAAAAAAAAAAAAABLL * v31.i64[1] > v32)
  {
    uint64_t v61 = (char *)this + 2216;
    if (v30.i64[0] == v29)
    {
      unint64_t v34 = 0;
      uint64_t v35 = 0;
    }
    else
    {
      unint64_t v34 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v32);
    }
    dispatch_semaphore_t v57 = v34;
    dispatch_semaphore_t v58 = &v34[3 * v33];
    uint64_t v59 = v58;
    uint64_t v60 = &v34[3 * v35];
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer((void *)this + 275, &v57);
    std::__split_buffer<std::vector<std::pair<unsigned int,unsigned int>>>::~__split_buffer((uint64_t)&v57);
  }
  uint64_t v36 = (void *)*((void *)this + 278);
  *((void *)this + 279) = v36;
  if (*((void **)this + 280) != v36)
  {
    *((void *)this + 278) = 0;
    *((void *)this + 279) = 0;
    *((void *)this + 280) = 0;
    if (v36) {
      operator delete(v36);
    }
  }
  std::vector<DynamicBuffer>::__clear[abi:nn180100]((uint64_t *)this + 297);
  unint64_t v37 = *((void *)this + 297);
  int64x2_t v38 = *((int64x2_t *)this + 149);
  int64x2_t v39 = vshrq_n_s64(vsubq_s64(v38, vdupq_n_s64(v37)), 4uLL);
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * v39.i64[0];
  unint64_t v41 = v40;
  if (0xAAAAAAAAAAAAAAABLL * v39.i64[1] > v40)
  {
    uint64_t v61 = (char *)this + 2392;
    if (v38.i64[0] == v37)
    {
      long long v42 = 0;
      uint64_t v43 = 0;
    }
    else
    {
      long long v42 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<DynamicBuffer>>(v40);
    }
    dispatch_semaphore_t v57 = v42;
    dispatch_semaphore_t v58 = &v42[6 * v41];
    uint64_t v59 = v58;
    uint64_t v60 = &v42[6 * v43];
    std::vector<DynamicBuffer>::__swap_out_circular_buffer((uint64_t *)this + 297, &v57);
    std::__split_buffer<DynamicBuffer>::~__split_buffer((uint64_t)&v57);
  }
  int64_t v44 = (void *)*((void *)this + 314);
  *((void *)this + 314) = 0;

  dispatch_semaphore_t v45 = (void *)*((void *)this + 313);
  *((void *)this + 313) = 0;

  uint64_t v46 = (void *)*((void *)this + 315);
  *((void *)this + 315) = 0;

  uint64_t v47 = (void *)*((void *)this + 316);
  *((void *)this + 316) = 0;

  *((unsigned char *)this + 2184) = 1;
  *((_DWORD *)this + 541) = 0;
  *((void *)this + 271) = 1;
  *((void *)this + 241) = 0;
  uint64_t v48 = (void *)*((void *)this + 246);
  *((void *)this + 246) = 0;

  *((void *)this + 247) = 0;
  *((void *)this + 269) = 0;
  *((void *)this + 267) = *((void *)this + 266);
  uint64_t v49 = (void *)*((void *)this + 274);
  *((void *)this + 274) = 0;

  uint64_t v50 = (void *)*((void *)this + 286);
  *((void *)this + 286) = 0;

  unint64_t v51 = (void *)*((void *)this + 287);
  *((void *)this + 287) = 0;

  uint64_t v52 = (void *)*((void *)this + 289);
  *((void *)this + 289) = 0;

  id v53 = (void *)*((void *)this + 290);
  *((void *)this + 290) = 0;

  atomic_store(0, (unsigned int *)this + 684);
  atomic_store(0, (unsigned int *)this + 685);
  atomic_store(0, (unsigned int *)this + 686);
  atomic_store(0, (unsigned int *)this + 687);
  atomic_store(0, (unsigned int *)this + 688);
  atomic_store(0, (unint64_t *)this + 341);
  atomic_store(0, (unsigned int *)this + 689);
  atomic_store(0, (unsigned __int8 *)this + 2760);
  atomic_store(0, (unsigned __int8 *)this + 2761);
  atomic_store(0, (unsigned __int8 *)this + 2763);
  atomic_store(0, (unsigned __int8 *)this + 2764);
  uint64_t v54 = *((void *)this + 392);
  uint64_t v55 = *((void *)this + 391);
  while (v54 != v55)
  {
    uint64_t v56 = *(void **)(v54 - 32);
    v54 -= 32;
  }
  *((void *)this + 392) = v55;
LABEL_50:
  os_unfair_lock_unlock((os_unfair_lock_t)&GTUSCSamplingStreamingManagerHelper::CleanUp(void)::localSpinLock);
}

void sub_1D3C44(_Unwind_Exception *a1)
{
}

void ClearCaches(void)
{
  uint64_t v10 = +[NSFileManager defaultManager];
  if ([v10 fileExistsAtPath:@"/tmp/com.apple.gputools.profiling"])
  {
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    id v12 = 0;
    uint64_t v0 = [v10 contentsOfDirectoryAtPath:@"/tmp/com.apple.gputools.profiling" error:&v12];
    id v1 = v12;
    id v2 = [v0 countByEnumeratingWithState:&v13 objects:v17 count:16];
    if (v2)
    {
      uint64_t v3 = *(void *)v14;
      do
      {
        for (uint64_t i = 0; i != v2; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v14 != v3) {
            objc_enumerationMutation(v0);
          }
          uint64_t v5 = *(void **)(*((void *)&v13 + 1) + 8 * i);
          uint64_t v6 = [v5 pathExtension];
          BOOL v7 = [v6 caseInsensitiveCompare:@"mmapbuffer"] == 0;

          if (v7)
          {
            uint64_t v8 = [@"/tmp/com.apple.gputools.profiling" stringByAppendingPathComponent:v5];
            id v11 = v1;
            [v10 removeItemAtPath:v8 error:&v11];
            id v9 = v11;

            id v1 = v9;
          }
        }
        id v2 = [v0 countByEnumeratingWithState:&v13 objects:v17 count:16];
      }
      while (v2);
    }
  }
  else
  {
    [v10 createDirectoryAtPath:@"/tmp/com.apple.gputools.profiling" withIntermediateDirectories:1 attributes:0 error:0];
  }
}

void sub_1D3E44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<GTMMappedBuffer>>::shrink_to_fit(uint64_t result)
{
  unint64_t v1 = *(void *)result;
  int64x2_t v2 = *(int64x2_t *)(result + 8);
  int64x2_t v3 = vshrq_n_s64(vsubq_s64(v2, vdupq_n_s64(*(void *)result)), 3uLL);
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * v3.i64[0];
  unint64_t v5 = v4;
  if (0xAAAAAAAAAAAAAAABLL * v3.i64[1] > v4)
  {
    uint64_t v6 = (void *)result;
    uint64_t v13 = result + 16;
    if (v2.i64[0] == v1)
    {
      BOOL v7 = 0;
      uint64_t v8 = 0;
    }
    else
    {
      BOOL v7 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v4);
    }
    id v9 = v7;
    uint64_t v10 = &v7[24 * v5];
    id v11 = v10;
    id v12 = &v7[24 * v8];
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer(v6, &v9);
    return std::__split_buffer<std::vector<GTMMappedBuffer>>::~__split_buffer((uint64_t)&v9);
  }
  return result;
}

uint64_t std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::shrink_to_fit(uint64_t result)
{
  unint64_t v1 = *(void *)result;
  int64x2_t v2 = *(int64x2_t *)(result + 8);
  int64x2_t v3 = vshrq_n_s64(vsubq_s64(v2, vdupq_n_s64(*(void *)result)), 3uLL);
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * v3.i64[0];
  unint64_t v5 = v4;
  if (0xAAAAAAAAAAAAAAABLL * v3.i64[1] > v4)
  {
    uint64_t v6 = (void *)result;
    uint64_t v13 = result + 16;
    if (v2.i64[0] == v1)
    {
      BOOL v7 = 0;
      uint64_t v8 = 0;
    }
    else
    {
      BOOL v7 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v4);
    }
    id v9 = v7;
    uint64_t v10 = &v7[24 * v5];
    id v11 = v10;
    id v12 = &v7[24 * v8];
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer(v6, &v9);
    return std::__split_buffer<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::~__split_buffer((uint64_t)&v9);
  }
  return result;
}

void std::vector<DynamicBuffer>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 48)
  {
    unint64_t v4 = *(void **)(i - 24);
    if (v4)
    {
      *(void *)(i - 16) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

uint64_t std::__split_buffer<std::vector<std::pair<unsigned int,unsigned int>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    unint64_t v4 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v4)
    {
      *(void *)(v2 - 16) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void GTUSCSamplingStreamingManagerHelper::SetupMTLCounterAPIBuffer(GTUSCSamplingStreamingManagerHelper *this)
{
  id v5 = *(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16);
  unint64_t v1 = [*(id *)(*(void *)GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) defaultDevice];
  uint64_t v2 = DEVICEOBJECT(v1);

  if (v2
    && *(_DWORD *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 76)
    && (void)xmmword_772798 != *((void *)&xmmword_772798 + 1))
  {
    uint64_t v3 = xmmword_772798 + 4;
    do
    {
      if ((*(unsigned char *)(v3 - 4) & 0x10) != 0) {
        break;
      }
      BOOL v4 = v3 == *((void *)&xmmword_772798 + 1);
      v3 += 4;
    }
    while (!v4);
  }
}

void sub_1D4178(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void std::vector<std::pair<unsigned int,unsigned int>>::reserve(void **a1, unint64_t a2)
{
  if (a2 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      abort();
    }
    int64_t v3 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    BOOL v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(a2);
    id v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    BOOL v7 = &v4[8 * v6];
    id v9 = (char *)*a1;
    uint64_t v8 = (char *)a1[1];
    uint64_t v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        uint64_t v11 = *((void *)v8 - 1);
        v8 -= 8;
        *((void *)v10 - 1) = v11;
        v10 -= 8;
      }
      while (v8 != v9);
      uint64_t v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void ___ZN35GTUSCSamplingStreamingManagerHelper20InitBatchIdFilteringEP29GTUSCSamplingStreamingManager_block_invoke(uint64_t a1)
{
  unint64_t v1 = *(uint64_t ***)(a1 + 32);
  GTMTLReplayController_prePlayForProfiling(**v1);
  uint64_t v56 = [(id)(*v1)[2] objectForKeyedSubscript:@"perEncoderDrawCallCount"];
  uint64_t v54 = v1;
  uint64_t v2 = **v1;
  id v57 = *(id *)(v2 + 8);
  int64_t v3 = *(uint64_t **)v2;
  uint64_t v55 = *(void *)(*(void *)v2 + 16);
  id v53 = [*(id *)(v2 + 8) defaultCommandQueue];
  char v65 = 0;
  uint64_t v63 = v2;
  BOOL v4 = (unsigned int *)(v2 + 22480);
  if (v3[13] + v3[12] > (unint64_t)*(unsigned int *)(v2 + 22480))
  {
    dispatch_semaphore_t v58 = v3;
    unint64_t v59 = 0;
    int v5 = 0;
    uint64_t v52 = v54 + 278;
    do
    {
      uint64_t v7 = *(void *)(v3[15] + 24);
      uint64_t v8 = *v4;
      uint64_t v9 = v7 + (v8 << 6);
      uint64_t v11 = (int *)(v9 + 8);
      int v10 = *(_DWORD *)(v9 + 8);
      int FuncEnumConstructorType = GetFuncEnumConstructorType(v10);
      if (FuncEnumConstructorType == 25)
      {
        GTMTLReplayController_restoreCommandBuffer(v63, v7 + (v8 << 6));
        int v10 = *v11;
      }
      uint64_t v60 = v8;
      uint64_t v61 = v7;
      context = v6;
      uint64_t v13 = v4;
      BOOL v14 = IsFuncEnumGPUCommandCall(v10);
      int v15 = IsFuncEnumEndEncoding(v10);
      int v16 = (v14 | v15) & v5;
      if (v16 == 1)
      {
        uint64_t v17 = GTTraceFunc_targetContext(v9, v3[2]);
        uint64_t v18 = 0;
        int v19 = *(_DWORD *)(v63 + 11312);
        if (v19 > 64)
        {
          if (v19 == 65)
          {
            uint64_t v20 = [v57 parallelRenderCommandEncoderForKey:v17];
            uint64_t v21 = DEVICEOBJECT(v20);
            goto LABEL_16;
          }
          if (v19 == 70)
          {
            uint64_t v20 = [v57 renderCommandEncoderForKey:v17];
            uint64_t v21 = DEVICEOBJECT(v20);
            goto LABEL_16;
          }
        }
        else
        {
          if (v19 == 21)
          {
            uint64_t v20 = [v57 blitCommandEncoderForKey:v17];
            uint64_t v21 = DEVICEOBJECT(v20);
            goto LABEL_16;
          }
          if (v19 == 28)
          {
            uint64_t v20 = [v57 computeCommandEncoderForKey:v17];
            uint64_t v21 = DEVICEOBJECT(v20);
LABEL_16:
            uint64_t v18 = (void *)v21;
          }
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      GTMTLReplayController_updateCommandEncoder(v63, v9);
      if (*v11 >> 2 == 1073737833) {
        GTUSCSamplingStreamingManagerHelper::DispatchExpandedIndirectCommand();
      }
      else {
        DispatchFunction((id *)v63, v9, &v65);
      }
      v5 &= v15 ^ 1;
      if (GTMTLReplayHost_IsFuncEnumSampledEncoder(*v11, 1, 0))
      {
        BOOL v4 = v13;
        uint64_t v22 = +[NSNumber numberWithUnsignedInt:*v13];
        uint64_t v23 = [v56 objectForKeyedSubscript:v22];

        if (v23) {
          int v5 = 1;
        }
        unint64_t v24 = v59;
        if (v23) {
          unint64_t v24 = v59 + 1;
        }
        unint64_t v59 = v24;
      }
      else if (v16)
      {
        uint64_t v64 = 0;
        BOOL v4 = v13;
        if (v18)
        {
          if (v14)
          {
            [v18 commandBatchIdRangeMin:(char *)&v64 + 4 max:&v64];
            uint64_t v25 = v54[279];
            unint64_t v26 = (unint64_t)v54[280];
            if ((unint64_t)v25 >= v26)
            {
              uint64_t v38 = v25 - *v52;
              unint64_t v39 = v38 + 1;
              if ((unint64_t)(v38 + 1) >> 61) {
                abort();
              }
              uint64_t v40 = v26 - (void)*v52;
              if (v40 >> 2 > v39) {
                unint64_t v39 = v40 >> 2;
              }
              if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v41 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v41 = v39;
              }
              long long v42 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v41);
              int64_t v44 = &v42[8 * v38];
              *(_DWORD *)int64_t v44 = HIDWORD(v64);
              *((_DWORD *)v44 + 1) = v64;
              dispatch_semaphore_t v45 = v54[279];
              uint64_t v46 = v54[278];
              uint64_t v47 = v44;
              if (v45 != v46)
              {
                do
                {
                  uint64_t v48 = *--v45;
                  *((void *)v47 - 1) = v48;
                  v47 -= 8;
                }
                while (v45 != v46);
                dispatch_semaphore_t v45 = *v52;
              }
              v54[278] = (uint64_t *)v47;
              unint64_t v27 = (uint64_t *)(v44 + 8);
              v54[279] = (uint64_t *)(v44 + 8);
              v54[280] = (uint64_t *)&v42[8 * v43];
              if (v45) {
                operator delete(v45);
              }
            }
            else
            {
              *(_DWORD *)uint64_t v25 = HIDWORD(v64);
              *((_DWORD *)v25 + 1) = v64;
              unint64_t v27 = v25 + 1;
            }
            v54[279] = v27;
          }
          else if (v15 && v54[278] != v54[279])
          {
            unsigned int v28 = [v18 commandBatchIdOffset];
            unint64_t v29 = (int32x2_t *)v54[278];
            int64x2_t v30 = (int32x2_t *)v54[279];
            if (v29 != v30)
            {
              int32x2_t v31 = vdup_n_s32(v28);
              unint64_t v32 = (int32x2_t *)v54[278];
              do
              {
                int32x2_t *v32 = vsub_s32(*v32, v31);
                ++v32;
              }
              while (v32 != v30);
            }
            if (v59)
            {
              unint64_t v33 = v54[275];
              if (v59 <= 0xAAAAAAAAAAAAAAABLL * (v54[276] - v33))
              {
                unint64_t v34 = &v33[3 * v59];
                uint64_t v35 = (uint64_t *)*(v34 - 3);
                *(v34 - 3) = (uint64_t)v29;
                v54[278] = v35;
                uint64_t v36 = (uint64_t *)*(v34 - 2);
                *(v34 - 2) = (uint64_t)v54[279];
                v54[279] = v36;
                unint64_t v37 = (uint64_t *)*(v34 - 1);
                *(v34 - 1) = (uint64_t)v54[280];
                v54[280] = v37;
              }
            }
          }
        }
      }
      else
      {
        BOOL v4 = v13;
      }
      if (FuncEnumConstructorType == 25)
      {
        uint64_t v49 = [v57 commandBufferForKey:[*(void **)((char *)v9 + GTTraceFunc_argumentBytesWithMap(v9, *(unsigned char *)(v61 + (v60 << 6) + 13), v55) + 1)]];
        uint64_t v50 = DEVICEOBJECT(v49);

        [v50 setDisableDeferredEndEncoding:1];
      }

      unint64_t v51 = *v4 + 1;
      *BOOL v4 = v51;
      int64_t v3 = v58;
    }
    while (v58[13] + v58[12] > v51);
  }
  [v53 finish:v52];
}

void sub_1D4780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void DispatchFunction(id *a1, uint64_t a2, unsigned char *a3)
{
  id v15 = a1[1];
  uint64_t v6 = *((void *)*a1 + 2);
  int v7 = *(_DWORD *)(a2 + 8);
  if (v7 > -16286)
  {
    if (v7 == -16285)
    {
      *a3 = 0;
      goto LABEL_14;
    }
    if (v7 == -16246)
    {
      if (*a3)
      {
        [v15 removeRenderCommandEncoderForKey:[GTTraceFunc_argumentBytesWithMap(a2, *(unsigned __int8 *)(a2 + 13), *((void *)*a1 + 2))]];
        goto LABEL_15;
      }
      goto LABEL_14;
    }
  }
  else
  {
    if (v7 == -16351)
    {
      *a3 = 1;
      int v10 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v6);
      uint64_t v11 = GTTraceFunc_argumentBytesWithMap((void *)a2, v10[16], v6);
      uint64_t v9 = [v15 commandBufferForKey:*(void *)v10];
      id v12 = [v15 renderPassDescriptorMap];
      uint64_t v13 = MakeMTLRenderPassDescriptor((uint64_t)v11, v12);

      BOOL v14 = [v9 renderCommandEncoderWithDescriptor:v13];
      [v15 setParallelRenderCommandEncoder:v14 forKey:*((void *)v10 + 1)];

      goto LABEL_10;
    }
    if (v7 == -16286)
    {
      uint64_t v8 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), *((void *)*a1 + 2));
      uint64_t v9 = [v15 parallelRenderCommandEncoderForKey:*(void *)v8];
      [v15 setRenderCommandEncoder:v9 forKey:*((void *)v8 + 1)];
LABEL_10:

      goto LABEL_15;
    }
  }
  if (v7 >> 2 == 1073737833)
  {
    GTMTLReplayController_executeCommandsInBuffer((uint64_t *)a1, (unint64_t *)a2, 0, 0xFFFFFFFFFFFFFFFFLL);
    goto LABEL_15;
  }
LABEL_14:
  GTMTLReplayController_defaultDispatchFunction((uint64_t)a1, a2);
LABEL_15:
}

{
  uint64_t v6;
  int v7;
  char *v8;
  void *v9;
  char *v10;
  uint64_t RenderPassDescriptor;
  void *v12;
  void *v13;
  void *v14;
  id v15;
  uint64_t vars8;

  id v15 = a1[1];
  uint64_t v6 = *((void *)*a1 + 2);
  int v7 = *(_DWORD *)(a2 + 8);
  if (v7 > -16286)
  {
    if (v7 == -16285)
    {
      *a3 = 0;
    }
    else if (v7 == -16246 && *a3)
    {
      [v15 removeRenderCommandEncoderForKey:*(void *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), *((void *)*a1 + 2))];
      goto LABEL_13;
    }
  }
  else
  {
    if (v7 == -16351)
    {
      *a3 = 1;
      int v10 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v6);
      uint64_t RenderPassDescriptor = GetRenderPassDescriptor();
      uint64_t v9 = [v15 commandBufferForKey:*(void *)v10];
      id v12 = [v15 renderPassDescriptorMap];
      uint64_t v13 = MakeMTLRenderPassDescriptor(RenderPassDescriptor, v12);

      BOOL v14 = [v9 renderCommandEncoderWithDescriptor:v13];
      [v15 setParallelRenderCommandEncoder:v14 forKey:*((void *)v10 + 1)];

      goto LABEL_10;
    }
    if (v7 == -16286)
    {
      uint64_t v8 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), *((void *)*a1 + 2));
      uint64_t v9 = [v15 parallelRenderCommandEncoderForKey:*(void *)v8];
      [v15 setRenderCommandEncoder:v9 forKey:*((void *)v8 + 1)];
LABEL_10:

      goto LABEL_13;
    }
  }
  GTMTLReplayController_defaultDispatchFunction((uint64_t)a1, a2);
LABEL_13:
}

void sub_1D49EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::string::basic_string[abi:nn180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    uint64_t v8 = (uint64_t *)a2;
  }
  else {
    uint64_t v8 = *(uint64_t **)a2;
  }
  if (v7 >= 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  unint64_t v11 = v10;
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v12) {
        unint64_t v3 = v10 % v12;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v10;
    }
    id v15 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v15)
    {
      for (uint64_t i = *v15; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v17 = *((void *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2)) {
            return;
          }
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t v18 = operator new(0x28uLL);
  *uint64_t v18 = 0;
  v18[1] = v11;
  int v19 = (std::string *)(v18 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v18[4] = *(void *)(a3 + 16);
  }
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v21 = *(float *)(a1 + 32);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    BOOL v22 = 1;
    if (v12 >= 3) {
      BOOL v22 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v12);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v25);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v3 = v11 % v12;
      }
      else {
        unint64_t v3 = v11;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v11;
    }
  }
  uint64_t v26 = *(void *)a1;
  unint64_t v27 = *(void **)(*(void *)a1 + 8 * v3);
  if (v27)
  {
    *uint64_t v18 = *v27;
LABEL_47:
    *unint64_t v27 = v18;
    goto LABEL_48;
  }
  *uint64_t v18 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v18;
  *(void *)(v26 + 8 * v3) = a1 + 16;
  if (*v18)
  {
    unint64_t v28 = *(void *)(*v18 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v28 >= v12) {
        v28 %= v12;
      }
    }
    else
    {
      v28 &= v12 - 1;
    }
    unint64_t v27 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_47;
  }
LABEL_48:
  ++*(void *)(a1 + 24);
}

void sub_1D4D38(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:nn180100](0, v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  size_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](uint64_t *a1, unint64_t a2)
{
  if (a2 > 0x20)
  {
    if (a2 <= 0x40)
    {
      uint64_t v5 = *(uint64_t *)((char *)a1 + a2 - 16);
      uint64_t v6 = *a1 - 0x3C5A37A36834CED9 * (v5 + a2);
      uint64_t v8 = a1[2];
      uint64_t v7 = a1[3];
      uint64_t v9 = __ROR8__(v6 + v7, 52);
      uint64_t v10 = v6 + a1[1];
      uint64_t v11 = __ROR8__(v10, 7);
      uint64_t v12 = v10 + v8;
      uint64_t v13 = *(uint64_t *)((char *)a1 + a2 - 32) + v8;
      uint64_t v14 = *(uint64_t *)((char *)a1 + a2 - 8) + v7;
      uint64_t v15 = __ROR8__(v14 + v13, 52);
      uint64_t v16 = v11 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v5 + a2), 37) + v9;
      uint64_t v17 = __ROR8__(v13, 37);
      uint64_t v18 = *(uint64_t *)((char *)a1 + a2 - 24) + v13;
      uint64_t v19 = __ROR8__(v18, 7);
      uint64_t v20 = v16 + __ROR8__(v12, 31);
      uint64_t v21 = v18 + v5;
      uint64_t v22 = v21 + v14;
      unint64_t v23 = 0x9AE16A3B2F90404FLL;
      unint64_t v24 = 0xC3A5C85C97CB3127 * (v22 + v20) - 0x651E95C4D06FBFB1 * (v12 + v7 + v17 + v19 + v15 + __ROR8__(v21, 31));
      unint64_t v25 = v20 - 0x3C5A37A36834CED9 * (v24 ^ (v24 >> 47));
      return (v25 ^ (v25 >> 47)) * v23;
    }
    unint64_t v4 = 0x9DDFEA08EB382D69;
    uint64_t v32 = *(uint64_t *)((char *)a1 + a2 - 48);
    uint64_t v33 = *(uint64_t *)((char *)a1 + a2 - 40);
    uint64_t v34 = *(uint64_t *)((char *)a1 + a2 - 24);
    uint64_t v36 = *(uint64_t *)((char *)a1 + a2 - 64);
    uint64_t v35 = *(uint64_t *)((char *)a1 + a2 - 56);
    uint64_t v37 = *(uint64_t *)((char *)a1 + a2 - 16);
    uint64_t v38 = *(uint64_t *)((char *)a1 + a2 - 8);
    unint64_t v39 = v35 + v37;
    unint64_t v40 = 0x9DDFEA08EB382D69
        * (v34 ^ ((0x9DDFEA08EB382D69 * (v34 ^ (v32 + a2))) >> 47) ^ (0x9DDFEA08EB382D69 * (v34 ^ (v32 + a2))));
    unint64_t v41 = 0x9DDFEA08EB382D69 * (v40 ^ (v40 >> 47));
    unint64_t v42 = v36 + a2 + v35 + v32;
    uint64_t v43 = v42 + v33;
    unint64_t v44 = __ROR8__(v42, 44) + v36 + a2 + __ROR8__(v33 + v36 + a2 - 0x622015F714C7D297 * (v40 ^ (v40 >> 47)), 21);
    uint64_t v45 = v35 + v37 + *(uint64_t *)((char *)a1 + a2 - 32) - 0x4B6D499041670D8DLL;
    uint64_t v46 = v45 + v34 + v37;
    uint64_t v47 = __ROR8__(v46, 44);
    uint64_t v48 = v46 + v38;
    uint64_t v49 = v47 + v45 + __ROR8__(v45 + v33 + v38, 21);
    uint64_t v51 = *a1;
    uint64_t v50 = a1 + 4;
    unint64_t v52 = v51 - 0x4B6D499041670D8DLL * v33;
    uint64_t v53 = -(uint64_t)((a2 - 1) & 0xFFFFFFFFFFFFFFC0);
    do
    {
      uint64_t v54 = *(v50 - 3);
      uint64_t v55 = v52 + v43 + v39 + v54;
      uint64_t v56 = v50[2];
      uint64_t v57 = v50[3];
      uint64_t v58 = v50[1];
      unint64_t v39 = v58 + v43 - 0x4B6D499041670D8DLL * __ROR8__(v39 + v44 + v56, 42);
      uint64_t v59 = v41 + v48;
      uint64_t v60 = *(v50 - 2);
      uint64_t v61 = *(v50 - 1);
      uint64_t v62 = *(v50 - 4) - 0x4B6D499041670D8DLL * v44;
      uint64_t v63 = v62 + v48 + v61;
      uint64_t v64 = v62 + v54 + v60;
      uint64_t v43 = v64 + v61;
      uint64_t v65 = __ROR8__(v64, 44) + v62;
      unint64_t v66 = (0xB492B66FBE98F273 * __ROR8__(v55, 37)) ^ v49;
      unint64_t v52 = 0xB492B66FBE98F273 * __ROR8__(v59, 33);
      unint64_t v44 = v65 + __ROR8__(v63 + v66, 21);
      unint64_t v67 = v52 + v49 + *v50;
      uint64_t v48 = v67 + v58 + v56 + v57;
      uint64_t v49 = __ROR8__(v67 + v58 + v56, 44) + v67 + __ROR8__(v39 + v60 + v67 + v57, 21);
      v50 += 8;
      unint64_t v41 = v66;
      v53 += 64;
    }
    while (v53);
    unint64_t v68 = v52
        - 0x622015F714C7D297
        * ((0x9DDFEA08EB382D69
          * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) ^ ((0x9DDFEA08EB382D69 * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) >> 47));
    unint64_t v69 = 0x9DDFEA08EB382D69
        * (v68 ^ (v66
                - 0x4B6D499041670D8DLL * (v39 ^ (v39 >> 47))
                - 0x622015F714C7D297
                * ((0x9DDFEA08EB382D69
                  * (v48 ^ ((0x9DDFEA08EB382D69 * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69 * (v48 ^ v43)))) ^ ((0x9DDFEA08EB382D69 * (v48 ^ ((0x9DDFEA08EB382D69 * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69 * (v48 ^ v43)))) >> 47))));
    unint64_t v70 = 0x9DDFEA08EB382D69 * (v68 ^ (v69 >> 47) ^ v69);
    goto LABEL_13;
  }
  if (a2 > 0x10)
  {
    uint64_t v26 = a1[1];
    unint64_t v27 = 0xB492B66FBE98F273 * *a1;
    uint64_t v28 = __ROR8__(0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8), 30) + __ROR8__(v27 - v26, 43);
    unint64_t v29 = v27 + a2 + __ROR8__(v26 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8);
    unint64_t v23 = 0x9DDFEA08EB382D69;
    unint64_t v30 = 0x9DDFEA08EB382D69 * (v29 ^ (v28 - 0x3C5A37A36834CED9 * *(uint64_t *)((char *)a1 + a2 - 16)));
    unint64_t v31 = v29 ^ (v30 >> 47) ^ v30;
LABEL_8:
    unint64_t v25 = 0x9DDFEA08EB382D69 * v31;
    return (v25 ^ (v25 >> 47)) * v23;
  }
  if (a2 < 9)
  {
    if (a2 >= 4)
    {
      uint64_t v72 = *(unsigned int *)((char *)a1 + a2 - 4);
      unint64_t v23 = 0x9DDFEA08EB382D69;
      unint64_t v73 = 0x9DDFEA08EB382D69 * (((8 * *(_DWORD *)a1) + a2) ^ v72);
      unint64_t v31 = v72 ^ (v73 >> 47) ^ v73;
      goto LABEL_8;
    }
    unint64_t v4 = 0x9AE16A3B2F90404FLL;
    if (!a2) {
      return v4;
    }
    unint64_t v70 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                   * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
LABEL_13:
    v4 *= v70 ^ (v70 >> 47);
    return v4;
  }
  uint64_t v2 = *(uint64_t *)((char *)a1 + a2 - 8);
  uint64_t v3 = __ROR8__(v2 + a2, a2);
  return (0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69
          * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) >> 47))) ^ v2;
}

BOOL std::equal_to<std::string>::operator()[abi:nn180100](unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
  }
  if (!a1[23]) {
    return 1;
  }
  uint64_t v6 = v2 - 1;
  do
  {
    int v8 = *a1++;
    int v7 = v8;
    int v10 = *a2++;
    int v9 = v10;
    BOOL v12 = v6-- != 0;
    BOOL v13 = v7 == v9;
    BOOL v14 = v7 == v9;
  }
  while (v13 && v12);
  return v14;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:nn180100](char a1, void **__p)
{
  if (a1)
  {
    if (*((char *)__p + 39) < 0) {
      operator delete(__p[2]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  int v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    int v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    int v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

uint64_t GTUSCSamplingStreamingManagerHelper::SetupBumperCounters(GTUSCSamplingStreamingManagerHelper *this, NSDictionary *a2)
{
  uint64_t v2 = this;
  uint64_t v3 = [(GTUSCSamplingStreamingManagerHelper *)v2 objectForKeyedSubscript:@"passNum"];
  unsigned int v18 = [v3 unsignedIntValue];

  id v19 = [*((id *)&xmmword_772038 + 1) count];
  unint64_t v4 = 0;
  id v20 = [*((id *)&xmmword_772038 + 1) count];
  while (v4 < (unint64_t)[*((id *)&xmmword_772038 + 1) count])
  {
    int v5 = [*((id *)&xmmword_772038 + 1) objectAtIndexedSubscript:v4];
    for (unint64_t i = 0; i < (unint64_t)[&off_758A20 count]; ++i)
    {
      std::string::size_type v7 = [v5 name];
      int v8 = [&off_758A20 objectAtIndexedSubscript:i];
      unsigned int v9 = [v7 isEqualToString:v8];

      if (v9) {
        *(&v19 + i) = (id)v4;
      }
    }

    ++v4;
  }
  if (v18)
  {
    uint64_t v10 = 0;
    unint64_t v11 = (unint64_t)v19;
    unint64_t v12 = (unint64_t)v20;
    do
    {
      BOOL v13 = [(GTUSCSamplingStreamingManagerHelper *)v2 objectForKeyedSubscript:@"passList"];
      BOOL v14 = [v13 objectAtIndexedSubscript:v10];

      if (v11 < (unint64_t)[v14 count] && v12 < (unint64_t)objc_msgSend(v14, "count"))
      {
        uint64_t v15 = [v14 objectAtIndexedSubscript:v12];
        uint64_t v16 = [v14 objectAtIndexedSubscript:v11];
        [v14 setObject:v16 atIndexedSubscript:v12];

        [v14 setObject:v15 atIndexedSubscript:v11];
      }

      ++v10;
    }
    while (v18 != v10);
  }

  return v18;
}

void sub_1D55B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManagerHelper::StreamBatchIdFilteredCounters(GTUSCSamplingStreamingManagerHelper *this)
{
  unsigned __int8 v1 = atomic_load(byte_772AF4);
  if (v1) {
    return;
  }
  id v158 = (id)objc_opt_new();
  if (qword_7728A8 == -1)
  {
    uint64_t v10 = [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 48) objectForKeyedSubscript:@"DerivedCounterDictionary"];
    unint64_t v11 = [v10 objectForKeyedSubscript:@"DerivedCounters"];
    unint64_t v12 = [v11 objectForKeyedSubscript:@"CSInvocation"];
    id v164 = [v12 objectForKeyedSubscript:@"counters"];
  }
  else
  {
    uint64_t v2 = std::string::basic_string[abi:nn180100]<0>(&v236, "CSInvocation");
    CountersForDerivedCounter = GTAGXProfilingSupportHelper::GetCountersForDerivedCounter((uint64_t)v2);
    unint64_t v4 = CountersForDerivedCounter;
    if (SHIBYTE(v238) < 0)
    {
      operator delete(v236);
      if (v4) {
        goto LABEL_5;
      }
    }
    else if (CountersForDerivedCounter)
    {
LABEL_5:
      int v5 = +[NSMutableArray arrayWithCapacity:0xAAAAAAAAAAAAAAABLL * ((v4[1] - *v4) >> 3)];
      uint64_t v6 = *v4;
      uint64_t v7 = v4[1];
      if (*v4 != v7)
      {
        do
        {
          uint64_t v8 = v6;
          if (*(char *)(v6 + 23) < 0) {
            uint64_t v8 = *(void *)v6;
          }
          unsigned int v9 = +[NSString stringWithUTF8String:v8];
          [v5 addObject:v9];

          v6 += 24;
        }
        while (v6 != v7);
      }
      id v164 = [v5 copy];

      goto LABEL_13;
    }
    id v164 = 0;
  }
  if (!qword_7727E8) {
    goto LABEL_19;
  }
LABEL_13:
  BOOL v13 = [(id)qword_7727E8 objectForKeyedSubscript:@"num_cores"];
  unsigned int v14 = [v13 unsignedIntValue];

  uint64_t v15 = [(id)qword_7727E8 objectForKeyedSubscript:@"num_mgpus"];
  unsigned int v16 = [v15 unsignedIntValue];

  unsigned int v17 = v16 <= 1 ? 1 : v16;
  if (v14 / v17 >= 5) {
    BOOL v163 = [v164 count] == &dword_4;
  }
  else {
LABEL_19:
  }
    BOOL v163 = 0;
  obunsigned int j = [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16) objectForKeyedSubscript:@"profileCounters"];
  unsigned int v18 = &send_ptr;
  if (qword_7728A8 == -1) {
    goto LABEL_111;
  }
  long long v200 = 0u;
  long long v201 = 0u;
  LODWORD(v202) = 1065353216;
  long long v208 = 0u;
  long long v209 = 0u;
  long long v210 = 0u;
  long long v211 = 0u;
  obunsigned int j = obj;
  id v19 = [obj countByEnumeratingWithState:&v208 objects:&v227 count:16];
  if (!v19) {
    goto LABEL_35;
  }
  uint64_t v20 = *(void *)v209;
  do
  {
    for (unint64_t i = 0; i != v19; unint64_t i = (char *)i + 1)
    {
      if (*(void *)v209 != v20) {
        objc_enumerationMutation(obj);
      }
      uint64_t v22 = std::string::basic_string[abi:nn180100]<0>(&v236, (char *)[*(id *)(*((void *)&v208 + 1) + 8 * i) UTF8String]);
      unint64_t v23 = GTAGXProfilingSupportHelper::GetCountersForDerivedCounter((uint64_t)v22);
      unint64_t v24 = v23;
      if (SHIBYTE(v238) < 0)
      {
        operator delete(v236);
        if (!v24) {
          continue;
        }
      }
      else if (!v23)
      {
        continue;
      }
      uint64_t v25 = *v24;
      uint64_t v26 = v24[1];
      while (v25 != v26)
      {
        std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)&v200, v25, v25);
        v25 += 24;
      }
    }
    id v19 = [obj countByEnumeratingWithState:&v208 objects:&v227 count:16];
  }
  while (v19);
LABEL_35:

  unint64_t v27 = [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16) objectForKeyedSubscript:@"batchFilteredDerivedCounters"];
  if (v27)
  {
    id v161 = v27;
    id v159 = v27;
    unint64_t v166 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v159 count]);
    long long v218 = 0u;
    long long v219 = 0u;
    LODWORD(v220) = 1065353216;
    *(_OWORD *)__p = 0u;
    long long v223 = 0u;
    memset(v224, 0, 32);
    id v170 = v159;
    id v28 = [v170 countByEnumeratingWithState:__p objects:&v236 count:16];
    if (!v28) {
      goto LABEL_87;
    }
    uint64_t v178 = *(void *)v223;
    while (2)
    {
      uint64_t v29 = 0;
      while (2)
      {
        if (*(void *)v223 != v178) {
          objc_enumerationMutation(v170);
        }
        unint64_t v30 = (char *)[*((id *)__p[1] + v29) UTF8String];
        unint64_t v31 = operator new(0x28uLL);
        *unint64_t v31 = 0;
        v31[1] = 0;
        std::string::basic_string[abi:nn180100]<0>(v31 + 2, v30);
        int v32 = *((char *)v31 + 39);
        if (v32 >= 0) {
          uint64_t v33 = v31 + 2;
        }
        else {
          uint64_t v33 = (uint64_t *)v31[2];
        }
        if (v32 >= 0) {
          unint64_t v34 = *((unsigned __int8 *)v31 + 39);
        }
        else {
          unint64_t v34 = v31[3];
        }
        v31[1] = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v33, v34);
        unint64_t v35 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v33, v34);
        unint64_t v36 = v35;
        v31[1] = v35;
        unint64_t v37 = *((void *)&v218 + 1);
        if (*((void *)&v218 + 1))
        {
          uint8x8_t v38 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v218 + 8));
          v38.i16[0] = vaddlv_u8(v38);
          unint64_t v39 = v38.u32[0];
          if (v38.u32[0] > 1uLL)
          {
            unint64_t v40 = v35;
            if (*((void *)&v218 + 1) <= v35) {
              unint64_t v40 = v35 % *((void *)&v218 + 1);
            }
          }
          else
          {
            unint64_t v40 = (*((void *)&v218 + 1) - 1) & v35;
          }
          unint64_t v41 = *(unsigned __int8 ***)(v218 + 8 * v40);
          if (v41)
          {
            for (unsigned int j = *v41; j; unsigned int j = *(unsigned __int8 **)j)
            {
              unint64_t v43 = *((void *)j + 1);
              if (v43 == v36)
              {
                if (std::equal_to<std::string>::operator()[abi:nn180100](j + 16, (unsigned __int8 *)v31 + 16))
                {
                  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:nn180100](1, (void **)v31);
                  goto LABEL_85;
                }
              }
              else
              {
                if (v39 > 1)
                {
                  if (v43 >= v37) {
                    v43 %= v37;
                  }
                }
                else
                {
                  v43 &= v37 - 1;
                }
                if (v43 != v40) {
                  break;
                }
              }
            }
          }
        }
        float v44 = (float)(unint64_t)(*((void *)&v219 + 1) + 1);
        if (!v37 || (float)(*(float *)&v220 * (float)v37) < v44)
        {
          BOOL v45 = (v37 & (v37 - 1)) != 0;
          if (v37 < 3) {
            BOOL v45 = 1;
          }
          unint64_t v46 = v45 | (2 * v37);
          unint64_t v47 = vcvtps_u32_f32(v44 / *(float *)&v220);
          if (v46 <= v47) {
            size_t v48 = v47;
          }
          else {
            size_t v48 = v46;
          }
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)&v218, v48);
          unint64_t v37 = *((void *)&v218 + 1);
          unint64_t v36 = v31[1];
        }
        uint8x8_t v49 = (uint8x8_t)vcnt_s8((int8x8_t)v37);
        v49.i16[0] = vaddlv_u8(v49);
        if (v49.u32[0] > 1uLL)
        {
          if (v36 >= v37) {
            v36 %= v37;
          }
        }
        else
        {
          v36 &= v37 - 1;
        }
        uint64_t v50 = v218;
        uint64_t v51 = *(void **)(v218 + 8 * v36);
        if (v51)
        {
          *unint64_t v31 = *v51;
          goto LABEL_83;
        }
        *unint64_t v31 = v219;
        *(void *)&long long v219 = v31;
        *(void *)(v50 + 8 * v36) = &v219;
        if (*v31)
        {
          unint64_t v52 = *(void *)(*v31 + 8);
          if (v49.u32[0] > 1uLL)
          {
            if (v52 >= v37) {
              v52 %= v37;
            }
          }
          else
          {
            v52 &= v37 - 1;
          }
          uint64_t v51 = (void *)(v218 + 8 * v52);
LABEL_83:
          void *v51 = v31;
        }
        ++*((void *)&v219 + 1);
LABEL_85:
        if ((id)++v29 != v28) {
          continue;
        }
        break;
      }
      id v28 = [v170 countByEnumeratingWithState:__p objects:&v236 count:16];
      if (v28) {
        continue;
      }
      break;
    }
LABEL_87:

    for (uint64_t k = qword_772A20; k; uint64_t k = *(void *)k)
    {
      uint64_t v54 = (void *)(k + 16);
      if (std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(v218, *((unint64_t *)&v218 + 1), k + 16))
      {
        if (*(char *)(k + 39) < 0) {
          uint64_t v54 = (void *)*v54;
        }
        uint64_t v55 = +[NSString stringWithUTF8String:v54];
        [v166 addObject:v55];
      }
    }
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v218);

    uint64_t v56 = (void *)xmmword_772C58;
    *(void *)&xmmword_772C58 = v166;

    uint64_t v57 = objc_opt_new();
    uint64_t v58 = objc_opt_new();
    long long v206 = 0u;
    long long v207 = 0u;
    long long v204 = 0u;
    long long v205 = 0u;
    id v59 = (id)xmmword_772C58;
    id v60 = [v59 countByEnumeratingWithState:&v204 objects:&v236 count:16];
    if (v60)
    {
      uint64_t v61 = *(void *)v205;
      do
      {
        for (m = 0; m != v60; m = (char *)m + 1)
        {
          if (*(void *)v205 != v61) {
            objc_enumerationMutation(v59);
          }
          std::string::basic_string[abi:nn180100]<0>(__p, (char *)[*(id *)(*((void *)&v204 + 1) + 8 * (void)m) UTF8String]);
          uint64_t v63 = GTAGXProfilingSupportHelper::GetCountersForDerivedCounter((uint64_t)__p);
          uint64_t v64 = v63;
          if (SBYTE7(v223) < 0)
          {
            operator delete(__p[0]);
            if (!v64) {
              continue;
            }
          }
          else if (!v63)
          {
            continue;
          }
          uint64_t v65 = *v64;
          uint64_t v66 = v64[1];
          while (v65 != v66)
          {
            uint64_t v67 = v65;
            if (*(char *)(v65 + 23) < 0) {
              uint64_t v67 = *(void *)v65;
            }
            unint64_t v68 = +[NSString stringWithUTF8String:v67];
            [v58 addObject:v68];

            v65 += 24;
          }
        }
        id v60 = [v59 countByEnumeratingWithState:&v204 objects:&v236 count:16];
      }
      while (v60);
    }

    uint64_t v69 = [v58 allObjects];

    obunsigned int j = (id)v69;
    unint64_t v27 = v161;
  }

  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v200);
  unsigned int v18 = &send_ptr;
LABEL_111:
  unint64_t v70 = [v18[208] setWithArray:obj];
  [v70 addObjectsFromArray:&off_758A08];
  BOOL v71 = +[NSMutableDictionary dictionaryWithCapacity:4096];
  for (unint64_t n = 0; n < (unint64_t)[*((id *)&xmmword_772038 + 1) count]; ++n)
  {
    [*((id *)&xmmword_772038 + 1) objectAtIndexedSubscript:];
    id v171 = (id)objc_claimAutoreleasedReturnValue();
    uint64_t v72 = [v171 availableCounters];
    long long v202 = 0u;
    long long v203 = 0u;
    long long v200 = 0u;
    long long v201 = 0u;
    id v73 = v72;
    id v74 = [v73 countByEnumeratingWithState:&v200 objects:__p count:16];
    if (v74)
    {
      uint64_t v75 = *(void *)v201;
      do
      {
        for (iunint64_t i = 0; ii != v74; iunint64_t i = (char *)ii + 1)
        {
          if (*(void *)v201 != v75) {
            objc_enumerationMutation(v73);
          }
          unsigned int v77 = *(void **)(*((void *)&v200 + 1) + 8 * (void)ii);
          uint64_t v78 = [v77 name];
          unsigned int v79 = [v70 containsObject:v78];

          if (v79)
          {
            unint64_t v80 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [v77 counterValueType]);
            unint64_t v81 = [v77 name];
            [v71 setObject:v80 forKeyedSubscript:v81];
          }
        }
        id v74 = [v73 countByEnumeratingWithState:&v200 objects:__p count:16];
      }
      while (v74);
    }
  }
  [v158 setDictionary:v71];
  uint64_t v82 = (char *)[obj count];
  uint64_t v180 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", &v82[(void)[(id)qword_7727F0 count]]);
  [v180 addObjectsFromArray:qword_7727F0];
  long long v198 = 0u;
  long long v199 = 0u;
  long long v196 = 0u;
  long long v197 = 0u;
  id v83 = obj;
  id v84 = [v83 countByEnumeratingWithState:&v196 objects:&v218 count:16];
  if (v84)
  {
    uint64_t v85 = *(void *)v197;
    do
    {
      for (junsigned int j = 0; jj != v84; junsigned int j = (char *)jj + 1)
      {
        if (*(void *)v197 != v85) {
          objc_enumerationMutation(v83);
        }
        id v87 = *(id *)(*((void *)&v196 + 1) + 8 * (void)jj);
        if ([v87 isEqualToString:@"MTLStat_nSec"])
        {
          uint64_t v88 = 0;
        }
        else
        {
          if (![v87 isEqualToString:@"MTLStatTotalGPUCycles"]) {
            goto LABEL_133;
          }
          uint64_t v88 = 1;
        }
        uint64_t v89 = [&off_758A08 objectAtIndexedSubscript:v88];

        id v87 = (id)v89;
LABEL_133:
        unint64_t v90 = +[GPURawCounterSelect selectWithName:v87 options:0];
        [v180 addObject:v90];
      }
      id v84 = [v83 countByEnumeratingWithState:&v196 objects:&v218 count:16];
    }
    while (v84);
  }

  GTUSCSamplingStreamingManagerHelper::SubDividedCounterDictionary(v180);
  uint64_t v91 = (GTUSCSamplingStreamingManagerHelper *)objc_claimAutoreleasedReturnValue();
  uint64_t v92 = v91;
  if (!v91) {
    goto LABEL_196;
  }
  uint64_t v154 = v91;
  id v93 = [(GTUSCSamplingStreamingManagerHelper *)v91 count];
  uint64_t v92 = v154;
  if (!v93) {
    goto LABEL_196;
  }
  __p[0] = 0;
  __p[1] = __p;
  *(void *)&long long v223 = 0x5812000000;
  *((void *)&v223 + 1) = __Block_byref_object_copy__310;
  unsigned __int8 v150 = &v224[16];
  memset(&v224[8], 0, 32);
  *(void *)id v224 = __Block_byref_object_dispose__311;
  uint64_t v225 = 0;
  int v226 = 1065353216;
  unsigned int v169 = GTUSCSamplingStreamingManagerHelper::SetupBumperCounters(v154, v94);
  uint64_t v165 = v154;
  unint64_t v153 = +[NSMutableDictionary dictionaryWithCapacity:[(GTUSCSamplingStreamingManagerHelper *)v165 count]];
  unint64_t v95 = [v153 objectForKeyedSubscript:@"passNum"];
  [v153 setObject:v95 forKeyedSubscript:@"passNum"];

  unint64_t v96 = [(GTUSCSamplingStreamingManagerHelper *)v165 objectForKeyedSubscript:@"passNum"];
  LODWORD(v95) = [v96 unsignedIntValue];

  uint64_t v160 = v95;
  +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:");
  id v162 = (id)objc_claimAutoreleasedReturnValue();
  if (v95)
  {
    uint64_t v167 = 0;
    do
    {
      uint64_t v97 = [(GTUSCSamplingStreamingManagerHelper *)v165 objectForKeyedSubscript:@"passList"];
      id v172 = [v97 objectAtIndexedSubscript:v167];

      uint64_t v98 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v172 count]);
      long long v220 = 0u;
      long long v221 = 0u;
      long long v218 = 0u;
      long long v219 = 0u;
      id v173 = v172;
      id obja = (id)v98;
      id v99 = [v173 countByEnumeratingWithState:&v218 objects:&v236 count:16];
      if (v99)
      {
        uint64_t v100 = *(void *)v219;
        do
        {
          for (kuint64_t k = 0; kk != v99; kuint64_t k = (char *)kk + 1)
          {
            if (*(void *)v219 != v100) {
              objc_enumerationMutation(v173);
            }
            uint64_t v102 = *(void **)(*((void *)&v218 + 1) + 8 * (void)kk);
            unint64_t v103 = [(id)qword_7727F0 arrayByAddingObjectsFromArray:v102];
            unint64_t v104 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v103 count]);
            long long v210 = 0u;
            long long v211 = 0u;
            long long v208 = 0u;
            long long v209 = 0u;
            id v105 = v102;
            id v106 = [v105 countByEnumeratingWithState:&v208 objects:&v227 count:16];
            if (v106)
            {
              uint64_t v107 = *(void *)v209;
              do
              {
                for (mm = 0; mm != v106; mm = (char *)mm + 1)
                {
                  if (*(void *)v209 != v107) {
                    objc_enumerationMutation(v105);
                  }
                  unint64_t v109 = [*(id *)(*((void *)&v208 + 1) + 8 * (void)mm) name];
                  [v104 addObject:v109];
                }
                id v106 = [v105 countByEnumeratingWithState:&v208 objects:&v227 count:16];
              }
              while (v106);
            }

            [obja addObject:v104];
          }
          id v99 = [v173 countByEnumeratingWithState:&v218 objects:&v236 count:16];
        }
        while (v99);
      }

      [v162 addObject:obja];
      ++v167;
    }
    while (v167 != v160);
  }
  [v153 setObject:v162 forKeyedSubscript:@"passList"];

  unint64_t v110 = [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16) objectForKeyedSubscript:@"perEncoderDrawCallCount"];
  id v151 = [v110 count];

  dispatch_semaphore_t v156 = objc_opt_new();
  GTUSCSamplingStreamingManagerHelper::CleanupGPURawCounters((uint64_t)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance);
  unsigned __int8 v111 = atomic_load(byte_772AF4);
  if (v111) {
    goto LABEL_195;
  }
  id v174 = 0;
  char v152 = 0;
  while (2)
  {
    uint64_t v112 = [*(id *)((char *)&xmmword_7728B4 + 4) nextPerEncoderBatchList:v156];

    if (v112)
    {
      dispatch_semaphore_wait((dispatch_semaphore_t)xmmword_7729E8, 0xFFFFFFFFFFFFFFFFLL);
      GTUSCSamplingStreamingManagerHelper::SetupGPURawCounters(context);
      id v174 = v112;
      unint64_t v113 = [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16) objectForKeyedSubscript:@"perEncoderIndexDrawCallCount"];
      unint64_t v114 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v113 count]);
      unint64_t v115 = 0;
      uint64_t v116 = 0;
      while (v115 < (unint64_t)[v113 count])
      {
        uint64_t v117 = +[NSNumber numberWithUnsignedInteger:v115];
        uint64_t v118 = [v113 objectForKeyedSubscript:v117];
        BOOL v119 = [v118 unsignedIntegerValue] == 0;

        if (v119)
        {
          [v114 addObject:&off_7596F0];
        }
        else
        {
          unint64_t v120 = [v174 objectAtIndexedSubscript:v116];
          [v114 addObject:v120];

          ++v116;
        }
        ++v115;
      }

      id v157 = [v156 copy];
      unint64_t v168 = objc_opt_new();
      uint64_t v236 = 0;
      id v237 = &v236;
      uint64_t v238 = 0x4812000000;
      unint64_t v239 = __Block_byref_object_copy__312;
      uint64_t v240 = __Block_byref_object_dispose__313;
      id v241 = &unk_4E231D;
      memset(v242, 0, 24);
      id v227 = 0;
      unint64_t v228 = &v227;
      uint64_t v229 = 0x4812000000;
      uint64_t v230 = __Block_byref_object_copy__315;
      size_t v231 = __Block_byref_object_dispose__316;
      unint64_t v232 = &unk_4E231D;
      unint64_t v234 = 0;
      uint64_t v235 = 0;
      unint64_t v233 = 0;
      std::vector<std::vector<DYMTLEncoderInfo>>::resize(v242, v169);
      id objb = (id)objc_opt_new();
      if (v169)
      {
        int v121 = 0;
        unint64_t v122 = 0;
        do
        {
          std::vector<std::vector<DYMTLEncoderInfo>>::reserve(v237 + 6, 2 * (void)v151);
          unint64_t v123 = objc_opt_new();
          v185[0] = _NSConcreteStackBlock;
          v185[1] = 3221225472;
          v185[2] = ___ZN35GTUSCSamplingStreamingManagerHelper29StreamBatchIdFilteredCountersEv_block_invoke;
          v185[3] = &unk_7447A0;
          uint64_t v192 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
          unint64_t v124 = v165;
          int v193 = v121;
          BOOL v195 = v163;
          uint64_t v186 = v124;
          uint64_t v189 = &v236;
          uint64_t v190 = &v227;
          id v187 = v114;
          unsigned __int8 v191 = __p;
          id v125 = v123;
          id v188 = v125;
          unsigned int v194 = v169;
          uint64_t v126 = +[NSBlockOperation blockOperationWithBlock:v185];
          unint64_t v127 = v126;
          if (v122) {
            [v126 addDependency:v122];
          }
          [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v127];
          [v127 setQueuePriority:-8];
          v181[0] = _NSConcreteStackBlock;
          v181[1] = 3221225472;
          v181[2] = ___ZN35GTUSCSamplingStreamingManagerHelper29StreamBatchIdFilteredCountersEv_block_invoke_2;
          v181[3] = &unk_745EA8;
          unint64_t v184 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
          id v128 = v125;
          id v182 = v128;
          id v183 = v168;
          uint64_t v129 = +[NSBlockOperation blockOperationWithBlock:v181];
          [v129 addDependency:v127];
          [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:v129];
          [objb addDependency:v129];

          ++v121;
          unint64_t v122 = v129;
        }
        while (v169 != v121);
      }
      else
      {
        uint64_t v129 = 0;
      }
      [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:objb];
      [objb waitUntilFinished];
      GTUSCSamplingStreamingManagerHelper::CleanupGPURawCounters((uint64_t)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance);
      unsigned __int8 v130 = atomic_load(byte_772AF4);
      if ((v130 & 1) == 0)
      {
        unint64_t v131 = +[NSMutableArray arrayWithCapacity:v169];
        if (v169)
        {
          uint64_t v132 = 0;
          do
          {
            unint64_t v133 = +[NSData dataWithBytes:*(void *)((char *)v237[6] + v132) length:*(void *)((char *)v237[6] + v132 + 8) - *(void *)((char *)v237[6] + v132)];
            [v131 addObject:v133];

            v132 += 24;
          }
          while (24 * v169 != v132);
        }
        v216[0] = @"Derived Counter Sample Data";
        v216[1] = @"Subdivided Dictionary";
        v217[0] = v168;
        v217[1] = v153;
        v217[2] = v131;
        v216[2] = @"Encoder Infos";
        v216[3] = @"Encoder Tile Info";
        uint64_t v134 = +[NSData dataWithBytes:v228[6] length:(char *)v228[7] - (char *)v228[6]];
        v217[3] = v134;
        v217[4] = v114;
        v216[4] = @"BatchInfos";
        v216[5] = @"Counter Info";
        v217[5] = v158;
        v216[6] = @"Num Encoders";
        uint64_t v135 = +[NSNumber numberWithUnsignedInteger:v151];
        v217[6] = v135;
        v216[7] = @"Source Sample Marker";
        dispatch_semaphore_t v136 = +[NSNumber numberWithUnsignedLongLong:qword_772048];
        v217[7] = v136;
        v217[8] = &__kCFBooleanTrue;
        v216[8] = @"Batch Filtered Counters";
        v216[9] = @"Derived Counters Info Data";
        dispatch_semaphore_t v137 = *(void **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 48);
        uint64_t v138 = v137;
        if (!v137)
        {
          unint64_t v149 = objc_opt_new();
          uint64_t v138 = v149;
        }
        v216[10] = @"HighPriorityBatchInfo";
        v217[9] = v138;
        v217[10] = v157;
        unint64_t v139 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v217, v216, 11, v149, v150);
        uint64_t v140 = +[NSMutableDictionary dictionaryWithDictionary:v139];

        if (!v137) {
        if (v152)
        }
        {
LABEL_184:
          char v152 = 1;
        }
        else
        {
          if (qword_7728A8 != -1)
          {
            uint64_t v142 = GTAGXProfilingSupportHelper::RemappedCSV(v141);
            uint64_t v143 = v142;
            if (v142 && [v142 length]) {
              [v140 setObject:v143 forKeyedSubscript:@"csv"];
            }

            goto LABEL_184;
          }
          char v152 = 0;
        }
        if ((void)xmmword_772C58)
        {
          v214[0] = @"DerivedCounterDictionary";
          CFStringRef v212 = @"DerivedCounters";
          uint64_t v213 = xmmword_772C58;
          uint64_t v144 = +[NSDictionary dictionaryWithObjects:&v213 forKeys:&v212 count:1];
          v214[1] = @"DerivedCounterConfigurationVariables";
          v215[0] = v144;
          v215[1] = qword_7727E8;
          unint64_t v145 = +[NSDictionary dictionaryWithObjects:v215 forKeys:v214 count:2];
          [v140 setObject:v145 forKeyedSubscript:@"Derived Counters Info Data"];
        }
        uint64_t v146 = *(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 32);
        id v147 = [v140 copy];
        (*(void (**)(uint64_t, id))(v146 + 16))(v146, v147);
      }
      _Block_object_dispose(&v227, 8);
      if (v233)
      {
        unint64_t v234 = v233;
        operator delete(v233);
      }
      _Block_object_dispose(&v236, 8);
      id v227 = (void **)v242;
      std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&v227);

      dispatch_semaphore_signal((dispatch_semaphore_t)xmmword_7729E8);
      unsigned __int8 v148 = atomic_load(byte_772AF4);
      if (v148) {
        goto LABEL_194;
      }
      continue;
    }
    break;
  }
  id v174 = 0;
LABEL_194:

LABEL_195:
  _Block_object_dispose(__p, 8);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v150);
  uint64_t v92 = v154;
LABEL_196:
}

void sub_1D6E50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,_Unwind_Exception *exception_objecta,uint64_t a34,uint64_t a35,void *a36)
{
  _Block_object_dispose(&STACK[0x3E0], 8);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(a10);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__310(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0;
  *(void *)(result + 48) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0;
  uint64_t v5 = a2[8];
  uint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 64;
    void *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t __Block_byref_object_dispose__311(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(a1 + 48);
}

__n128 __Block_byref_object_copy__312(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__313(uint64_t a1)
{
  unsigned __int8 v1 = (void **)(a1 + 48);
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

__n128 __Block_byref_object_copy__315(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__316(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void std::vector<std::vector<DYMTLEncoderInfo>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v6 = a2 - v5;
  if (a2 <= v5)
  {
    if (a2 < v5)
    {
      uint64_t v15 = v3 + 24 * a2;
      if (v4 != v15)
      {
        uint64_t v16 = a1[1];
        do
        {
          unsigned int v18 = *(void **)(v16 - 24);
          v16 -= 24;
          unsigned int v17 = v18;
          if (v18)
          {
            *(void *)(v4 - 16) = v17;
            operator delete(v17);
          }
          uint64_t v4 = v16;
        }
        while (v16 != v15);
      }
      a1[1] = v15;
    }
  }
  else
  {
    uint64_t v7 = a1[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v7 - v4) >> 3) >= v6)
    {
      size_t v19 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero((void *)a1[1], v19);
      a1[1] = v4 + v19;
    }
    else
    {
      if (a2 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      v20[4] = a1 + 2;
      unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - v3) >> 3);
      uint64_t v9 = 2 * v8;
      if (2 * v8 <= a2) {
        uint64_t v9 = a2;
      }
      if (v8 >= 0x555555555555555) {
        unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v10 = v9;
      }
      unint64_t v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v10);
      unint64_t v12 = &v11[24 * v5];
      v20[0] = v11;
      v20[1] = v12;
      v20[3] = &v11[24 * v13];
      size_t v14 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero(v12, v14);
      v20[2] = &v12[v14];
      std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer(a1, v20);
      std::__split_buffer<std::vector<std::pair<unsigned int,unsigned int>>>::~__split_buffer((uint64_t)v20);
    }
  }
}

void *std::vector<std::vector<DYMTLEncoderInfo>>::reserve(void *result, unint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(result[2] - *result) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v2 = result;
    uint64_t v3 = result[1] - *result;
    void v5[4] = result + 2;
    v5[0] = std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(a2);
    v5[1] = v5[0] + v3;
    v5[2] = v5[0] + v3;
    v5[3] = v5[0] + 24 * v4;
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer(v2, v5);
    return (void *)std::__split_buffer<std::vector<std::pair<unsigned int,unsigned int>>>::~__split_buffer((uint64_t)v5);
  }
  return result;
}

void ___ZN35GTUSCSamplingStreamingManagerHelper29StreamBatchIdFilteredCountersEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 80);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 2764));
  if ((v2 & 1) == 0)
  {
    GTMTLReplayController_prePlayForProfiling(**(void **)v1);
    DisableComputeEncoderCoalescing(**(GTMTLReplayController ***)v1, 1);
    unsigned int v4 = *(_DWORD *)(a1 + 88);
    BOOL v5 = v4 || *(unsigned char *)(a1 + 96) == 0;
    BOOL v6 = !v5;
    if (GTUSCSamplingStreamingManagerHelper::SetupSourceForDerivedCounters((id *)v1, *(NSDictionary **)(a1 + 32), v4, 1, v6))
    {
      uint64_t v7 = [*(id *)(v1 + 16) firstObject];
      unsigned __int8 v8 = [v7 startSampling];

      if (v8)
      {
        unsigned int v9 = *(_DWORD *)(a1 + 88);
        if (v9) {
          unint64_t v10 = 0;
        }
        else {
          unint64_t v10 = (char **)(*(void *)(*(void *)(a1 + 64) + 8) + 48);
        }
        GTUSCSamplingStreamingManagerHelper::ReplayForDerivedCounters(v1, (char **)(*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 48) + 24 * v9), v10, *(void **)(a1 + 40), (void *)(*(void *)(*(void *)(a1 + 72) + 8) + 48), 0);
        unint64_t v12 = GTUSCSamplingStreamingManagerHelper::DrainRawDerivedCounterData((id *)v1);
        if (v12) {
          [*(id *)(a1 + 48) setArray:v12];
        }

        uint64_t v13 = [*(id *)(v1 + 16) firstObject];
        [v13 stopSampling];

        DisableComputeEncoderCoalescing(**(GTMTLReplayController ***)v1, 0);
        if (*(_DWORD *)(a1 + 88) + 1 == *(_DWORD *)(a1 + 92))
        {
          GTAGXPerfStateControl::DisableConsistentGPUPerfState((GTAGXPerfStateControl *)(v1 + 40));
          GTApplePMPPerfStateControl::DisableConsistentPerfState((GTApplePMPPerfStateControl *)(v1 + 64));
        }
      }
    }
  }
}

void sub_1D78E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper29StreamBatchIdFilteredCountersEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 2764));
  if ((v2 & 1) == 0)
  {
    BOOL v5 = GTUSCSamplingStreamingManagerHelper::PostProcessRawDerivedCounterData(v1, *(void **)(a1 + 32));
    if (v5) {
      [*(id *)(a1 + 40) addObject:v5];
    }
  }
}

void sub_1D7984(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  unsigned __int8 v2 = (char *)**a1;
  if (v2)
  {
    unsigned int v4 = (char *)v1[1];
    BOOL v5 = **a1;
    if (v4 != v2)
    {
      BOOL v6 = (char *)v1[1];
      do
      {
        unsigned __int8 v8 = (void *)*((void *)v6 - 3);
        v6 -= 24;
        uint64_t v7 = v8;
        if (v8)
        {
          *((void *)v4 - 2) = v7;
          operator delete(v7);
        }
        unsigned int v4 = v6;
      }
      while (v6 != v2);
      BOOL v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

id GTUSCSamplingStreamingManagerHelper::PostProcessRawDerivedCounterData(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([*(id *)(a1 + 24) count] && objc_msgSend(v3, "count"))
  {
    unsigned int v4 = &send_ptr;
    id v23 = v3;
    unint64_t v24 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v3 count]);
    unint64_t v5 = 0;
    uint64_t v21 = a1;
LABEL_4:
    if (v5 >= (unint64_t)[v3 count])
    {
      id v18 = v24;
    }
    else
    {
      BOOL v6 = [v3 objectAtIndexedSubscript:v5];
      uint64_t v7 = [v4[204] arrayWithCapacity:[v6 count]];
      unint64_t v22 = v5;
      unsigned __int8 v8 = [*(id *)(a1 + 24) objectAtIndexedSubscript:v5];
      for (unint64_t i = 0; ; ++i)
      {
        if (i >= (unint64_t)[v6 count])
        {
          [v24 addObject:v7];

          id v3 = v23;
          unint64_t v5 = v22 + 1;
          a1 = v21;
          unsigned int v4 = &send_ptr;
          goto LABEL_4;
        }
        unint64_t v10 = [v6 objectAtIndexedSubscript:i];
        unint64_t v11 = (char *)[v10 length];
        uint64_t v25 = 0;
        uint64_t v26 = 0;
        unint64_t v12 = 4 * (void)[v10 length];
        if (v12 <= 0x4000) {
          unint64_t v12 = 0x4000;
        }
        unint64_t v13 = (v12 + 7) & 0xFFFFFFFFFFFFFFF8;
        size_t v14 = +[NSMutableData dataWithLength:v13];
        id v15 = v10;
        id v16 = [v15 bytes];
        id v17 = v14;
        LOBYTE(v20) = 1;
        if ((objc_msgSend(v8, "postProcessRawDataWithRingBufferIndex:source:sourceSize:sourceRead:sourceWrite:output:outputSize:outputRead:outputWrite:isLast:", i, v16, v11 + 8, &v26, v11, objc_msgSend(v17, "mutableBytes"), v13, 0, &v25, v20) & 1) == 0)break; {
        [v17 setLength:v25];
        }
        [v7 addObject:v17];
      }
      NSLog(@"Failed to post process ringBuffer[%lu], srcSize[%llu], srcRead[%llu], srcWrite[%llu], outputSize[%llu], bufferWritten[%llu]", i, v11 + 8, v26, v11, v13, v25);

      id v18 = 0;
      id v3 = v23;
    }
  }
  else
  {
    id v18 = 0;
  }

  return v18;
}

void sub_1D7CA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

void DisableComputeEncoderCoalescing(GTMTLReplayController *a1, uint64_t a2)
{
  if (a1)
  {
    id var1 = a1->var1;
    if (var1)
    {
      unsigned int v4 = [var1 defaultDevice];
      DEVICEOBJECT(v4);
      id v5 = (id)objc_claimAutoreleasedReturnValue();

      if (v5 && (objc_opt_respondsToSelector() & 1) != 0) {
        [v5 setDisableComputeEncoderCoalescing:a2];
      }
    }
  }
}

void sub_1D7DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManagerHelper::ReplayForDerivedCounters(uint64_t a1, char **a2, char **a3, void *a4, void *a5, void *a6)
{
  id v9 = a4;
  id v131 = a6;
  unint64_t v120 = [*(id *)(*(void *)a1 + 16) objectForKeyedSubscript:@"perEncoderDrawCallCount"];
  uint64_t v10 = **(void **)a1;
  v136[1] = v10;
  BOOL v137 = v9 == 0;
  if (!v9)
  {
    unint64_t v11 = [*(id *)(v10 + 8) defaultCommandQueue];
    [v11 setGPUPriority:0];
  }
  v136[0] = [(id)g_commandBufferDescriptor errorOptions];
  [(id)g_commandBufferDescriptor setErrorOptions:0];
  id v125 = *(id *)(v10 + 8);
  unint64_t v12 = *(uint64_t **)v10;
  [*(id *)(v10 + 8) defaultCommandQueue];
  uint64_t v117 = v123 = a3;
  uint64_t v126 = v9;
  uint64_t v133 = v10;
  unint64_t v13 = (unsigned int *)(v10 + 22480);
  if (a5)
  {
    *(void *)(a1 + 2152) = 0;
    *(void *)(a1 + 2136) = *(void *)(a1 + 2128);
  }
  char v135 = 0;
  id v128 = (id ***)a1;
  *(void *)(a1 + 1928) = -1;
  unsigned int v134 = -1;
  if (v12[13] + v12[12] > (unint64_t)*v13)
  {
    unint64_t v118 = 0;
    uint64_t v132 = (unsigned int *)(v10 + 22480);
    do
    {
      uint64_t v15 = *v13;
      uint64_t v129 = *(void *)(v12[15] + 24);
      context = v14;
      uint64_t v16 = v129 + (v15 << 6);
      id v17 = (int *)(v16 + 8);
      int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v16 + 8));
      if (FuncEnumConstructorType == 25) {
        GTMTLReplayController_restoreCommandBuffer(v133, v16);
      }
      GTMTLReplayController_updateCommandEncoder(v133, v16);
      uint64_t v18 = *(void *)v132;
      if (*v17 == -20474)
      {
        if (!v131) {
          goto LABEL_18;
        }
      }
      else if (!v131 || *v17 != -20457)
      {
        goto LABEL_18;
      }
      size_t v19 = GTTraceFunc_targetContext(v16, v12[2]);
      if (*v17 == -20474) {
        [v125 spatialScalerForKey:v19];
      }
      else {
      uint64_t v20 = [v125 temporalScalerForKey:v19];
      }
      uint64_t v21 = DEVICEOBJECT(v20);

      [v21 setTracingDelegate:v131];
      [v131 setFunctionIndex:v18];

LABEL_18:
      uint64_t v124 = v18;
      unint64_t v22 = **v128;
      id v23 = v22[1];
      unint64_t v24 = *v22;
      uint64_t v25 = *((void *)*v22 + 2);
      if (v126)
      {
        unsigned int v26 = *v17;
        if ((IsFuncEnumDrawCall(*v17) & 1) != 0
          || (v26 != -16137 ? (BOOL v27 = v26 == -15297) : (BOOL v27 = 1), !v27 ? (v28 = v26 == -15486) : (v28 = 1), v28))
        {
          unsigned int v29 = v134;
          if (v134 == -1)
          {
            BOOL v30 = 0;
          }
          else
          {
            --v134;
            BOOL v30 = v29 == 0;
          }
          unint64_t v31 = [v23 renderCommandEncoderForKey:GTTraceFunc_targetContext(v16, v25)];
          int v32 = [v23 renderPipelineStateForKey:v22[2489]];
          if (v30)
          {
            uint64_t v33 = GTUSCSamplingStreamingManagerHelper::RenderDummyDrawCall(v128, (uint64_t)v22, v31, 0, (uint64_t)v22[2489], v16);
            [v31 setRenderPipelineState:v32];
          }
          else
          {
            uint64_t v33 = 0;
          }
          GTMTLReplayController_defaultDispatchFunction((uint64_t)v22, v16);
          if (v30)
          {
            id v34 = GTUSCSamplingStreamingManagerHelper::RenderDummyDrawCall(v128, (uint64_t)v22, v31, v33, (uint64_t)v22[2489], v16);
            [v31 setRenderPipelineState:v32];
          }
          goto LABEL_41;
        }
        if (v26 >> 2 == 1073737833)
        {
          GTUSCSamplingStreamingManagerHelper::DispatchExpandedIndirectCommand();
          goto LABEL_42;
        }
      }
      DispatchFunction(v22, v16, &v135);
      if (GetFuncEnumConstructorType(*v17) == 21)
      {
        uint64_t v35 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)v16, *(unsigned __int8 *)(v129 + (v15 << 6) + 13), v25)+ 1);
        if (std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>(a5, [v23 globalTraceIdForEncoder:v35 ofType:0]))
        {
          unint64_t v31 = [v23 blitCommandEncoderForKey:v35];
          [v31 endEncoding];
          int v32 = [v23 commandBufferForKey:GTTraceFunc_targetContext(v16, v24[2])];
          uint64_t v33 = [v32 computeCommandEncoder];
          [v33 endEncoding];
          GTMTLReplayController_defaultDispatchFunction((uint64_t)v22, v16);
LABEL_41:
        }
      }
LABEL_42:

      if (!GTMTLReplayHost_IsFuncEnumSampledEncoder(*v17, 1, 0)) {
        goto LABEL_129;
      }
      unint64_t v36 = +[NSNumber numberWithUnsignedInt:*v132];
      unint64_t v37 = [v120 objectForKeyedSubscript:v36];

      if (v37)
      {
        uint64_t v38 = v129 + (v15 << 6);
        unsigned int v40 = *(unsigned __int8 *)(v38 + 13);
        unint64_t v39 = (unsigned __int8 *)(v38 + 13);
        uint64_t v41 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)v16, v40, v12[2]) + 1);
        unint64_t v42 = [v125 commandBufferForKey:GTTraceFunc_targetContext(v16, v12[2])];
        unint64_t v122 = v42;
        unsigned int v43 = [v42 globalTraceObjectID];
        if (v135) {
          uint64_t v44 = 160;
        }
        else {
          uint64_t v44 = 11312;
        }
        if (v123)
        {
          unint64_t v46 = v123[1];
          unint64_t v45 = (unint64_t)v123[2];
          if ((unint64_t)v46 >= v45)
          {
            uint64_t v48 = (v46 - *v123) >> 3;
            if ((unint64_t)(v48 + 1) >> 61) {
              abort();
            }
            uint64_t v49 = v45 - (void)*v123;
            uint64_t v50 = v49 >> 2;
            if (v49 >> 2 <= (unint64_t)(v48 + 1)) {
              uint64_t v50 = v48 + 1;
            }
            if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v51 = v50;
            }
            if (v51) {
              unint64_t v51 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v51);
            }
            else {
              uint64_t v52 = 0;
            }
            uint64_t v53 = (char *)(v51 + 8 * v48);
            *(void *)uint64_t v53 = 0;
            unint64_t v47 = v53 + 8;
            uint64_t v55 = *v123;
            uint64_t v54 = v123[1];
            if (v54 == *v123)
            {
              uint64_t v57 = v123;
            }
            else
            {
              do
              {
                uint64_t v56 = *((void *)v54 - 1);
                v54 -= 8;
                *((void *)v53 - 1) = v56;
                v53 -= 8;
              }
              while (v54 != v55);
              uint64_t v57 = v123;
              uint64_t v54 = *v123;
            }
            void *v57 = v53;
            v57[1] = v47;
            v57[2] = (char *)(v51 + 8 * v52);
            if (v54) {
              operator delete(v54);
            }
          }
          else
          {
            *(void *)unint64_t v46 = 0;
            unint64_t v47 = v46 + 8;
          }
          v123[1] = v47;
          unint64_t v42 = v122;
        }
        int v58 = *(_DWORD *)(v133 + v44);
        if (v58 > 27)
        {
          if (v58 != 70)
          {
            if (v58 == 65)
            {
              uint64_t v71 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)v16, *v39, v12[2]) + 1);
              uint64_t v72 = [v125 parallelRenderCommandEncoderForKey:v41];
              id v60 = DEVICEOBJECT(v72);

              if (a5)
              {
                unsigned int v73 = [v125 globalTraceIdForEncoder:v71 ofType:1];
                uint64_t v74 = (uint64_t)v128[241] + 1;
                v128[241] = (id **)v74;
                GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(v128, a5, v16, v73, v60, v74, v124, 0);
              }
              if (v123 && (objc_opt_respondsToSelector() & 1) != 0)
              {
                *((_DWORD *)v123[1] - 2) = [v60 tileWidth];
                *((_DWORD *)v123[1] - 1) = [v60 tileHeight];
              }
LABEL_89:
              if (v60)
              {
                id v79 = v126;
                id v80 = v60;
                if (v126)
                {
                  unint64_t v42 = v122;
                  if (v118 < (unint64_t)[v79 count])
                  {
                    unint64_t v81 = [v79 objectAtIndexedSubscript:];
                    unsigned int v134 = [v81 unsignedIntValue];

                    unsigned int v82 = v134;
                    if (v134 != -1)
                    {
                      id v83 = v128[275];
                      if (v118 < 0xAAAAAAAAAAAAAAABLL * (v128[276] - v83))
                      {
                        id v84 = &v83[3 * v118];
                        uint64_t v85 = *v84;
                        BOOL v86 = v134 >= (unint64_t)(v84[1] - *v84);
                        unsigned int v87 = v134;
                        if (!v86)
                        {
                          uint64_t v88 = (unsigned int *)&v85[v134];
                          unsigned int v87 = *v88;
                          unsigned int v82 = v88[1];
                        }
                        BOOL v89 = *v17 == -16353 || *v17 == -16351;
                        if (v89) {
                          uint64_t v90 = v87 + 1;
                        }
                        else {
                          uint64_t v90 = v87;
                        }
                        if (v89) {
                          uint64_t v91 = v82 + 1;
                        }
                        else {
                          uint64_t v91 = v82;
                        }
                        [v80 filterCounterRangeWithFirstBatch:v90 lastBatch:v91 filterIndex:0];
                      }
                    }
                    ++v118;
                  }
                }
                else
                {
                  unint64_t v42 = v122;
                }

                uint64_t v92 = v43 | ((void)[v80 globalTraceObjectID] << 32);
                id v93 = a2;
                unint64_t v95 = a2[1];
                unint64_t v94 = (unint64_t)a2[2];
                if ((unint64_t)v95 >= v94)
                {
                  uint64_t v97 = *a2;
                  uint64_t v98 = (v95 - *a2) >> 3;
                  unint64_t v99 = v98 + 1;
                  if ((unint64_t)(v98 + 1) >> 61) {
                    abort();
                  }
                  uint64_t v100 = v94 - (void)v97;
                  if (v100 >> 2 > v99) {
                    unint64_t v99 = v100 >> 2;
                  }
                  if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v101 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v101 = v99;
                  }
                  if (v101)
                  {
                    if (v101 >> 61) {
                      std::__throw_bad_array_new_length[abi:nn180100]();
                    }
                    uint64_t v102 = (char *)operator new(8 * v101);
                    id v93 = a2;
                  }
                  else
                  {
                    uint64_t v102 = 0;
                  }
                  unint64_t v103 = &v102[8 * v98];
                  *(void *)unint64_t v103 = v92;
                  unint64_t v96 = v103 + 8;
                  if (v95 != v97)
                  {
                    do
                    {
                      uint64_t v104 = *((void *)v95 - 1);
                      v95 -= 8;
                      *((void *)v103 - 1) = v104;
                      v103 -= 8;
                    }
                    while (v95 != v97);
                    unint64_t v95 = *v93;
                  }
                  *id v93 = v103;
                  v93[1] = v96;
                  v93[2] = &v102[8 * v101];
                  if (v95)
                  {
                    operator delete(v95);
                    id v93 = a2;
                  }
                  unint64_t v42 = v122;
                }
                else
                {
                  *(void *)unint64_t v95 = v92;
                  unint64_t v96 = v95 + 8;
                }
                v93[1] = v96;
              }
              else
              {
                unint64_t v42 = v122;
              }
            }
            else if (v58 == 28)
            {
              id v59 = [v125 computeCommandEncoderForKey:v41];
              id v60 = DEVICEOBJECT(v59);

              if (a5)
              {
                unsigned int v61 = [v60 globalTraceObjectID];
                uint64_t v62 = (uint64_t)v128[241] + 1;
                v128[241] = (id **)v62;
                GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(v128, a5, v16, v61, v60, v62, v124, 0);
              }
              goto LABEL_89;
            }
LABEL_128:

LABEL_129:
            if (FuncEnumConstructorType == 25)
            {
              uint64_t v105 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)v16, *(unsigned __int8 *)(v129 + (v15 << 6) + 13), v12[2])+ 1);
              if (v126)
              {
                id v106 = [v125 commandBufferForKey:v105];
                uint64_t v107 = DEVICEOBJECT(v106);

                [v107 setDisableDeferredEndEncoding:1];
              }
              uint64_t v108 = [*(id *)(v133 + 8) defaultDevice];
              unint64_t v109 = +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:70 width:16 height:16 mipmapped:0];
              [v109 setUsage:4];
              id v110 = [v108 newTextureWithDescriptor:v109];
              unsigned __int8 v111 = +[MTLRenderPassDescriptor renderPassDescriptor];
              uint64_t v112 = objc_opt_new();
              [v112 setTexture:v110];
              [v112 setLoadAction:2];
              [v112 setStoreAction:1];
              [v112 setClearColor:0.0, 0.0, 0.0, 1.0];
              unint64_t v113 = [v111 colorAttachments];
              [v113 setObject:v112 atIndexedSubscript:0];

              unint64_t v114 = [*(id *)(v133 + 8) commandBufferForKey:v105];
              unint64_t v115 = [v114 renderCommandEncoderWithDescriptor:v111];
              [v115 setLabel:@"GPUToolsCounterProfilingEmptyRender"];
              [v115 endEncoding];
            }
            goto LABEL_133;
          }
          uint64_t v66 = [v125 renderCommandEncoderForKey:v41];
          uint64_t v67 = DEVICEOBJECT(v66);

          id v68 = v67;
          id v60 = v68;
          if (a5)
          {
            unsigned int v69 = [v68 globalTraceObjectID];
            uint64_t v70 = (uint64_t)v128[241] + 1;
            v128[241] = (id **)v70;
            GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(v128, a5, v16, v69, v60, v70, v124, 0);
          }
          if (v123 && (objc_opt_respondsToSelector() & 1) != 0)
          {
            *((_DWORD *)v123[1] - 2) = [v60 tileWidth];
            *((_DWORD *)v123[1] - 1) = [v60 tileHeight];
          }
LABEL_88:

          goto LABEL_89;
        }
        if (v58 == 17)
        {
          uint64_t v75 = [v125 accelerationStructureCommandEncoderForKey:v41];
          unsigned int v76 = DEVICEOBJECT(v75);

          id v65 = v76;
          id v60 = v65;
          if (!a5) {
            goto LABEL_88;
          }
        }
        else
        {
          if (v58 != 21) {
            goto LABEL_128;
          }
          uint64_t v63 = [v125 blitCommandEncoderForKey:v41];
          uint64_t v64 = DEVICEOBJECT(v63);

          id v65 = v64;
          id v60 = v65;
          if (!a5) {
            goto LABEL_88;
          }
        }
        unsigned int v77 = [v65 globalTraceObjectID];
        uint64_t v78 = (uint64_t)v128[241] + 1;
        v128[241] = (id **)v78;
        GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(v128, a5, v16, v77, v60, v78, v124, 0);
        goto LABEL_88;
      }
LABEL_133:
      unint64_t v13 = v132;
      unint64_t v116 = *v132 + 1;
      unsigned int *v132 = v116;
    }
    while (v12[13] + v12[12] > v116);
  }
  [v117 finish];

  ScopedReplayConfiguration::~ScopedReplayConfiguration((ScopedReplayConfiguration *)v136);
}

void sub_1D8A84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25)
{
  ScopedReplayConfiguration::~ScopedReplayConfiguration((ScopedReplayConfiguration *)(v28 - 112));
  _Unwind_Resume(a1);
}

id GTUSCSamplingStreamingManagerHelper::DrainRawDerivedCounterData(id *this)
{
  if ([this[3] count])
  {
    unsigned __int8 v2 = &send_ptr;
    uint64_t v16 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [this[3] count]);
    for (unint64_t i = 0; ; ++i)
    {
      if (i >= (unint64_t)[this[3] count])
      {
        id v14 = v16;
        goto LABEL_17;
      }
      unsigned int v4 = [this[3] objectAtIndexedSubscript:i];
      id v5 = [v2[204] arrayWithCapacity:[v4 ringBufferNum]];
      if ([v4 isEnabled]) {
        break;
      }
LABEL_15:
    }
    for (uint64_t j = 0; ; uint64_t j = (j + 1))
    {
      if (j >= [v4 ringBufferNum])
      {
        [v16 addObject:v5];
        unsigned __int8 v2 = &send_ptr;
        goto LABEL_15;
      }
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      unsigned int v17 = 0;
      if (([v4 ringBufferInfoAtIndex:j base:&v19 size:(char *)&v18 + 4 dataOffset:&v18 dataSize:&v17] & 1) == 0)break; {
      uint64_t v7 = +[NSMutableData dataWithCapacity:v17];
      }
      unsigned __int8 v8 = v7;
      unsigned int v9 = v17;
      if (v17 + v18 <= HIDWORD(v18))
      {
        [v7 appendBytes:v19 + v18 length:v17];
      }
      else
      {
        int v10 = HIDWORD(v18) - v18;
        [v7 appendBytes:v19 + v18 length:(HIDWORD(v18) - v18)];
        [v8 appendBytes:v19 length:v9 - v10];
      }
      unsigned int v11 = [v4 drainRingBufferAtIndex:j dataSize:v17];
      if (v11 != v17)
      {
        unint64_t v12 = [v4 name];
        NSLog(@"Fail, unexpected drain count for source %@!", v12);
      }
      [v5 addObject:v8];
    }
    unint64_t v13 = [v4 name];
    NSLog(@"Fail, unable to retrieve ring buffer info from source %@!", v13);

    id v14 = 0;
LABEL_17:
  }
  else
  {
    id v14 = 0;
  }

  return v14;
}

void sub_1D8ECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManagerHelper::GatherCommandBufferRestoreInfo(uint64_t **this)
{
  GTMTLReplayController_prePlayForProfiling(**this);
  uint64_t v2 = **this;
  id v3 = *(void **)v2;
  unsigned int v4 = (_DWORD *)(v2 + 22480);
  if (*(void *)(*(void *)v2 + 104) + *(void *)(*(void *)v2 + 96) > (unint64_t)*(unsigned int *)(v2 + 22480))
  {
    while (1)
    {
      uint64_t v6 = *(void *)(v3[15] + 24) + ((unint64_t)*v4 << 6);
      int v7 = GetFuncEnumConstructorType(*(_DWORD *)(v6 + 8)) == 25
         ? GTMTLReplayController_restoreCommandBuffer(v2, v6)
         : 0;
      GTMTLReplayController_updateCommandEncoder(v2, v6);
      if (*(_DWORD *)(v6 + 8) >> 2 == 1073737833) {
        break;
      }
      GTMTLReplayController_defaultDispatchFunction(**this, v6);
      if (v7) {
        goto LABEL_9;
      }
LABEL_10:
      unint64_t v8 = (*v4 + 1);
      *unsigned int v4 = v8;
      if (v3[13] + v3[12] <= v8)
      {
        uint64_t v2 = **this;
        goto LABEL_12;
      }
    }
    GTMTLReplayController_executeCommandsInBuffer((uint64_t *)v2, (unint64_t *)v6, 0, 0xFFFFFFFFFFFFFFFFLL);
    if (!v7) {
      goto LABEL_10;
    }
LABEL_9:
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long>((uint64_t)(this + 281), *v4, *v4);
    goto LABEL_10;
  }
LABEL_12:
  *(_DWORD *)(v2 + 22484) = 0;
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unsigned int v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (unint64_t i = (void *)*v9; i; unint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  unint64_t v12 = operator new(0x18uLL);
  void *v12 = 0;
  v12[1] = a2;
  v12[2] = a3;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    void *v12 = *v20;
LABEL_38:
    void *v20 = v12;
    goto LABEL_39;
  }
  void *v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v19 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    unint64_t v21 = *(void *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }
    else
    {
      v21 &= v7 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
}

void sub_1D9278(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManagerHelper::SetupBuffersForAPSSource(GTUSCSamplingStreamingManagerHelper *this)
{
  if (qword_7728A8 != -1)
  {
    [*((id *)&xmmword_772038 + 1) count];
    uint64_t v1 = 0;
    if ([*((id *)&xmmword_772038 + 1) count])
    {
      unint64_t v2 = 0;
      do
      {
        unint64_t v3 = [*((id *)&xmmword_772038 + 1) objectAtIndexedSubscript:v2];
        for (unint64_t i = 0; i < (unint64_t)[&off_758A38 count]; ++i)
        {
          id v5 = [v3 name];
          uint64_t v6 = [&off_758A38 objectAtIndexedSubscript:i];
          unsigned int v7 = [v5 isEqualToString:v6];

          if (v7)
          {
            uint8x8_t v8 = (char *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8 * v1++;
            *((void *)v8 + 388) = v2;
          }
        }

        ++v2;
      }
      while (v2 < (unint64_t)[*((id *)&xmmword_772038 + 1) count]);
    }
    std::vector<std::vector<GTMMappedBuffer>>::reserve(&xmmword_772958, v1 + 1);
    std::vector<std::vector<GTMMappedBuffer>>::reserve(&qword_772940, v1 + 1);
    std::vector<std::vector<GTMMappedBuffer>>::reserve(&xmmword_772988, v1 + 1);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::reserve(&qword_7729A0, v1 + 1);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::reserve(&xmmword_7729B8, v1 + 1);
    std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::reserve((void *)&xmmword_7729C8 + 1, v1 + 1);
    *(void *)unint64_t v16 = (int)qword_7728A8;
    *(_OWORD *)&v16[8] = xmmword_772C48;
    unsigned int v9 = std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(3uLL);
    uint64_t v10 = 0;
    *(_OWORD *)unsigned int v9 = *(_OWORD *)v16;
    v9[2] = *(void *)&v16[16];
    do
    {
      unint64_t v11 = (GTUSCSamplingStreamingManagerHelper *)v9[v10];
      if (v11 != (GTUSCSamplingStreamingManagerHelper *)-1) {
        GTUSCSamplingStreamingManagerHelper::SetupBufferForSourceAtIndex(v11, v11 != (GTUSCSamplingStreamingManagerHelper *)(int)qword_7728A8);
      }
      ++v10;
    }
    while (v10 != 3);
    dispatch_semaphore_t v12 = dispatch_semaphore_create(0);
    float v13 = (void *)xmmword_7729F8;
    *(void *)&xmmword_7729F8 = v12;

    dispatch_semaphore_t v14 = dispatch_semaphore_create(0);
    BOOL v15 = (void *)*((void *)&xmmword_7729E8 + 1);
    *((void *)&xmmword_7729E8 + 1) = v14;

    if (v9)
    {
      operator delete(v9);
    }
  }
}

void sub_1D9500(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManagerHelper::ForceDrainAllSourceBuffers(GTUSCSamplingStreamingManagerHelper *this)
{
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  uint64_t v1 = this;
  id v2 = [(GTUSCSamplingStreamingManagerHelper *)v1 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (v2)
  {
    uint64_t v3 = *(void *)v8;
    do
    {
      unsigned int v4 = 0;
      do
      {
        if (*(void *)v8 != v3) {
          objc_enumerationMutation(v1);
        }
        uint64_t v5 = 0;
        uint64_t v6 = *(void **)(*((void *)&v7 + 1) + 8 * (void)v4);
        while (v5 < objc_msgSend(v6, "ringBufferNum", (void)v7))
        {
          if ([v6 isEnabled]) {
            [v6 drainRingBufferAtIndex:v5 dataSize:0x40000000];
          }
          uint64_t v5 = (v5 + 1);
        }
        unsigned int v4 = (char *)v4 + 1;
      }
      while (v4 != v2);
      id v2 = [(GTUSCSamplingStreamingManagerHelper *)v1 countByEnumeratingWithState:&v7 objects:v11 count:16];
    }
    while (v2);
  }
}

void sub_1D9664(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

intptr_t GTUSCSamplingStreamingManagerHelper::DrainAllSourceBuffers(intptr_t this, uint64_t a2)
{
  if (this != a2)
  {
    uint64_t v3 = this;
    do
    {
      unsigned int v4 = *(NSObject ***)v3;
      uint64_t v5 = *(NSObject ***)(v3 + 8);
      while (v4 != v5)
      {
        uint64_t v6 = *v4++;
        this = dispatch_semaphore_signal(v6);
      }
      v3 += 24;
    }
    while (v3 != a2);
  }
  return this;
}

void GTUSCSamplingStreamingManagerHelper::PollAndDrainSourceRingBuffer(GTUSCSamplingStreamingManagerHelper *this, unsigned int a2, uint64_t a3)
{
  atomic_fetch_add((atomic_uint *volatile)this + 688, 1u);
  if ([*((id *)this + 3) count] == (char *)&def_1C1270 + 1) {
    unsigned int v6 = 0;
  }
  else {
    unsigned int v6 = a2 + 1;
  }
  if (*((_DWORD *)this + 544) != -1)
  {
    if (a2 == 2)
    {
      long long v7 = (char *)this + 3112;
    }
    else
    {
      if (a2 != 1) {
        goto LABEL_10;
      }
      long long v7 = (char *)this + 3104;
    }
    unsigned int v6 = *(_DWORD *)v7;
  }
LABEL_10:
  unsigned __int8 v8 = atomic_load((unsigned __int8 *)this + 2763);
  if ((v8 & 1) == 0)
  {
    unsigned int v9 = a2;
    BOOL v30 = (std::condition_variable *)((char *)this + 2768);
    uint64_t v10 = v6;
    while (1)
    {
      unsigned __int8 v11 = atomic_load((unsigned __int8 *)this + 2764);
      if (v11) {
        goto LABEL_36;
      }
      dispatch_semaphore_t v12 = *(NSObject **)(*(void *)(*((void *)this + 303) + 24 * v9) + 8 * a3);
      dispatch_time_t v13 = dispatch_time(0, 30000000);
      intptr_t v14 = dispatch_semaphore_wait(v12, v13);
      unsigned __int8 v15 = atomic_load((unsigned __int8 *)this + 2761);
      if (v15)
      {
        intptr_t v16 = v14;
        unsigned __int8 v17 = atomic_load((unsigned __int8 *)this + 2760);
        if ((v17 & 1) == 0 || !v14) {
          break;
        }
      }
LABEL_32:
      unsigned __int8 v28 = atomic_load((unsigned __int8 *)this + 2763);
      if (v28) {
        goto LABEL_36;
      }
    }
    uint64_t v18 = *(void *)(*((void *)this + 294) + 24 * v9);
    uint64_t v19 = [*((id *)this + 3) objectAtIndexedSubscript:v10, v30];
    unsigned __int8 v20 = atomic_load((unsigned __int8 *)this + 2760);
    id v21 = v19;
    if (![v21 isEnabled]) {
      goto LABEL_25;
    }
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    unsigned int v31 = 0;
    if (([v21 ringBufferInfoAtIndex:a3 base:&v33 size:(char *)&v32 + 4 dataOffset:&v32 dataSize:&v31] & 1) == 0|| !v31|| !(v20 & 1 | (v31 >> 13)))
    {
      goto LABEL_25;
    }
    unint64_t v22 = (dispatch_semaphore_t *)(v18 + 120 * a3);
    if (v32 + v31 <= HIDWORD(v32)) {
      GTMMappedBuffer::MemcpyFromSourceBuffer(v22, &v33[v32], v31, 0, 0);
    }
    else {
      GTMMappedBuffer::MemcpyFromSourceBuffer(v22, &v33[v32], HIDWORD(v32) - v32, v33, v31 - (HIDWORD(v32) - v32));
    }
    unsigned int v23 = [v21 drainRingBufferAtIndex:a3 dataSize:v31];
    unsigned int v24 = v31;
    if (v23 || !v31)
    {

      if (v24)
      {
        atomic_fetch_add((atomic_uint *volatile)this + 685, 1u);
        goto LABEL_28;
      }
    }
    else
    {
LABEL_25:
    }
    unsigned __int8 v25 = atomic_load((unsigned __int8 *)this + 2760);
    if ((v25 & 1) == 0
      || (v26 = atomic_load((unsigned int *)this + 685), unsigned int v27 = atomic_load((unsigned int *)this + 686), v26 != v27))
    {
LABEL_29:
      if (!v16 && atomic_fetch_add((atomic_uint *volatile)this + 687, 1u) + 1 == *((_DWORD *)this + 541)) {
        std::condition_variable::notify_all(v30);
      }
      goto LABEL_32;
    }
LABEL_28:
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(*((void *)this + 306) + 24 * v9)
                                                      + 8 * a3));
    goto LABEL_29;
  }
LABEL_36:
  atomic_fetch_add((atomic_uint *volatile)this + 688, 0xFFFFFFFF);
  if (!atomic_load((unsigned int *)this + 688))
  {
    std::condition_variable::notify_all((std::condition_variable *)((char *)this + 2992));
  }
}

void sub_1D99AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *DynamicBuffer::AddBuffer2(DynamicBuffer *this, const unsigned __int8 *__src, const unsigned __int8 *a3)
{
  unsigned int v6 = (os_unfair_lock_s *)((char *)this + 16);
  while (1)
  {
    uint64_t v7 = *((void *)this + 1);
    unsigned int v9 = (void *)*((void *)this + 3);
    unsigned __int8 v8 = (void *)*((void *)this + 4);
    if (v7 == 0xAAAAAAAAAAAAAAABLL * (v8 - v9))
    {
      unint64_t v10 = *((void *)this + 5);
      if ((unint64_t)v8 >= v10)
      {
        unint64_t v12 = v7 + 1;
        if ((unint64_t)(v7 + 1) > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - (void)v9) >> 3);
        if (2 * v13 > v12) {
          unint64_t v12 = 2 * v13;
        }
        if (v13 >= 0x555555555555555) {
          unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v14 = v12;
        }
        if (v14)
        {
          if (v14 > 0xAAAAAAAAAAAAAAALL) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unsigned __int8 v15 = (char *)operator new(24 * v14);
        }
        else
        {
          unsigned __int8 v15 = 0;
        }
        intptr_t v16 = &v15[24 * v7];
        *(void *)intptr_t v16 = 0;
        *((void *)v16 + 1) = 0;
        *((void *)v16 + 2) = 0x1000000;
        unsigned __int8 v17 = v16;
        if (v8 != v9)
        {
          do
          {
            long long v18 = *(_OWORD *)(v8 - 3);
            *((void *)v17 - 1) = *(v8 - 1);
            *(_OWORD *)(v17 - 24) = v18;
            v17 -= 24;
            v8 -= 3;
          }
          while (v8 != v9);
          unsigned __int8 v8 = (void *)*((void *)this + 3);
        }
        unsigned __int8 v11 = v16 + 24;
        *((void *)this + 3) = v17;
        *((void *)this + 4) = v16 + 24;
        *((void *)this + 5) = &v15[24 * v14];
        if (v8) {
          operator delete(v8);
        }
      }
      else
      {
        *unsigned __int8 v8 = 0;
        v8[1] = 0;
        unsigned __int8 v11 = v8 + 3;
        v8[2] = 0x1000000;
      }
      *((void *)this + 4) = v11;
      if ((unint64_t)a3 <= 0x1000000) {
        size_t v19 = 0x1000000;
      }
      else {
        size_t v19 = (size_t)a3;
      }
      *(v11 - 1) = v19;
      *(v11 - 3) = malloc_type_malloc(v19, 0x3DACA7DBuLL);
      *(v11 - 2) = 0;
      uint64_t v7 = *((void *)this + 1);
      unsigned int v9 = (void *)*((void *)this + 3);
    }
    unsigned __int8 v20 = &v9[3 * v7];
    uint64_t v21 = v20[1];
    unint64_t v22 = 0x1000000 - v21;
    size_t v23 = 0x1000000 - v21 >= (unint64_t)a3 ? (size_t)a3 : 0x1000000 - v21;
    __n128 result = memcpy((void *)(*v20 + v21), __src, v23);
    v20[1] += v23;
    if (v22 >= (unint64_t)a3) {
      break;
    }
    unsigned __int8 v25 = &a3[-v23];
    os_unfair_lock_lock(v6);
    ++*((void *)this + 1);
    os_unfair_lock_unlock(v6);
    __src = (const unsigned __int8 *)(&a3[(void)__src] - v25);
    a3 = v25;
  }
  return result;
}

void *GTMMappedBuffer::MemcpyFromSourceBuffer(dispatch_semaphore_t *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5)
{
  unsigned int v10 = a5 + a3;
  __n128 result = GTMMappedBuffer::Allocate(this, a5 + a3);
  if (!result) {
    return result;
  }
  unint64_t v12 = result;
  unint64_t v13 = result + 4096;
  memcpy(result + 4096, a2, a3);
  memcpy((char *)v13 + a3, a4, a5);
  dispatch_semaphore_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
  unint64_t v14 = this[8];
  unsigned __int8 v15 = this[7];
  if (v14 == v15) {
    uint64_t v16 = 0;
  }
  else {
    uint64_t v16 = 170 * (v14 - v15) - 1;
  }
  unint64_t v17 = (unint64_t)this[10];
  unint64_t v18 = (unint64_t)this[11] + v17;
  if (v16 == v18)
  {
    size_t v19 = this + 6;
    if (v17 < 0xAA)
    {
      unint64_t v33 = v14 - v15;
      dispatch_semaphore_t v34 = this[9];
      dispatch_semaphore_t v35 = this[6];
      if (v33 >= v34 - v35)
      {
        if (v34 == v35) {
          unint64_t v36 = 1;
        }
        else {
          unint64_t v36 = ((char *)v34 - (char *)v35) >> 2;
        }
        unsigned int v77 = (char *)(this + 9);
        *(void *)&long long v75 = std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v36);
        *((void *)&v75 + 1) = v75 + 8 * v33;
        *(void *)&long long v76 = *((void *)&v75 + 1);
        *((void *)&v76 + 1) = v75 + 8 * v37;
        uint64_t v74 = operator new(0xFF0uLL);
        std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_back(&v75, &v74);
        for (unint64_t i = this[8];
              i != (void *)this[7];
              std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_front((uint64_t)&v75, i))
        {
          --i;
        }
        long long v40 = v75;
        long long v41 = v76;
        *(void *)&long long v75 = this[6];
        unint64_t v39 = (void *)v75;
        *((void *)&v75 + 1) = i;
        *((_OWORD *)this + 3) = v40;
        *((_OWORD *)this + 4) = v41;
        if (v39) {
          operator delete(v39);
        }
        goto LABEL_46;
      }
      if (v34 != v14)
      {
        *(void *)&long long v75 = operator new(0xFF0uLL);
        std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_back(this + 6, &v75);
LABEL_46:
        unsigned __int8 v15 = this[7];
        unint64_t v18 = (unint64_t)this[10] + (void)this[11];
        goto LABEL_47;
      }
      *(void *)&long long v75 = operator new(0xFF0uLL);
      std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_front((uint64_t)(this + 6), &v75);
      uint64_t v53 = this[7];
      unint64_t v14 = this[8];
      isa = v53->isa;
      uint64_t v54 = v53 + 1;
      uint64_t v21 = isa;
      this[7] = v54;
      if (v14 == this[9])
      {
        uint64_t v56 = (char *)v54 - (char *)*v19;
        if (v54 > *v19)
        {
          uint64_t v57 = v56 >> 3;
          BOOL v25 = v56 >> 3 < -1;
          uint64_t v58 = (v56 >> 3) + 2;
          if (v25) {
            uint64_t v59 = v58;
          }
          else {
            uint64_t v59 = v57 + 1;
          }
          uint64_t v60 = -(v59 >> 1);
          uint64_t v61 = v59 >> 1;
          uint64_t v62 = &v54[-v61];
          int64_t v63 = (char *)v14 - (char *)v54;
          if (v14 != v54)
          {
            memmove(&v54[-v61], v54, (char *)v14 - (char *)v54);
            uint64_t v54 = this[7];
          }
          unint64_t v14 = ((char *)v62 + v63);
          uint64_t v64 = &v54[v60];
          goto LABEL_44;
        }
        if (v14 == *v19) {
          unint64_t v67 = 1;
        }
        else {
          unint64_t v67 = ((char *)v14 - (char *)*v19) >> 2;
        }
        unsigned int v43 = std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v67);
        uint64_t v44 = &v43[v67 >> 2];
        unint64_t v46 = &v43[v68];
        unsigned int v69 = (char *)this[7];
        unint64_t v14 = v44;
        uint64_t v70 = (char *)this[8] - v69;
        if (v70)
        {
          unint64_t v14 = ((char *)v44 + (v70 & 0xFFFFFFFFFFFFFFF8));
          uint64_t v71 = 8 * (v70 >> 3);
          uint64_t v72 = &v43[v67 >> 2];
          do
          {
            unsigned int v73 = *(objc_class **)v69;
            v69 += 8;
            v72->isa = v73;
            ++v72;
            v71 -= 8;
          }
          while (v71);
        }
LABEL_32:
        dispatch_semaphore_t v52 = this[6];
        this[6] = v43;
        this[7] = v44;
        this[8] = v14;
        this[9] = v46;
        if (v52)
        {
          operator delete(v52);
          unint64_t v14 = this[8];
        }
      }
    }
    else
    {
      this[10] = (dispatch_semaphore_t)(v17 - 170);
      unint64_t v22 = v15->isa;
      unsigned __int8 v20 = v15 + 1;
      uint64_t v21 = v22;
      this[7] = v20;
      if (this[9] == v14)
      {
        uint64_t v23 = (char *)v20 - (char *)*v19;
        if (v20 > *v19)
        {
          uint64_t v24 = v23 >> 3;
          BOOL v25 = v23 >> 3 < -1;
          uint64_t v26 = (v23 >> 3) + 2;
          if (v25) {
            uint64_t v27 = v26;
          }
          else {
            uint64_t v27 = v24 + 1;
          }
          uint64_t v28 = -(v27 >> 1);
          uint64_t v29 = v27 >> 1;
          BOOL v30 = &v20[-v29];
          int64_t v31 = (char *)v14 - (char *)v20;
          if (v14 == v20)
          {
            dispatch_semaphore_t v32 = v14;
          }
          else
          {
            memmove(&v20[-v29], v20, (char *)v14 - (char *)v20);
            dispatch_semaphore_t v32 = this[7];
          }
          unint64_t v14 = ((char *)v30 + v31);
          uint64_t v64 = &v32[v28];
LABEL_44:
          this[7] = v64;
          this[8] = v14;
          goto LABEL_45;
        }
        if (v14 == *v19) {
          unint64_t v42 = 1;
        }
        else {
          unint64_t v42 = ((char *)v14 - (char *)*v19) >> 2;
        }
        unsigned int v43 = std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v42);
        uint64_t v44 = &v43[v42 >> 2];
        unint64_t v46 = &v43[v45];
        unint64_t v47 = (char *)this[7];
        unint64_t v14 = v44;
        uint64_t v48 = (char *)this[8] - v47;
        if (v48)
        {
          unint64_t v14 = ((char *)v44 + (v48 & 0xFFFFFFFFFFFFFFF8));
          uint64_t v49 = 8 * (v48 >> 3);
          uint64_t v50 = &v43[v42 >> 2];
          do
          {
            unint64_t v51 = *(objc_class **)v47;
            v47 += 8;
            v50->isa = v51;
            ++v50;
            v49 -= 8;
          }
          while (v49);
        }
        goto LABEL_32;
      }
    }
LABEL_45:
    v14->isa = v21;
    ++this[8];
    goto LABEL_46;
  }
LABEL_47:
  unint64_t v65 = (unint64_t)v15[v18 / 0xAA].isa + 24 * (v18 % 0xAA);
  *(void *)unint64_t v65 = v12;
  *(void *)(v65 + 8) = v13;
  *(_DWORD *)(v65 + 16) = v10;
  this[11] = (dispatch_semaphore_t)((char *)this[11] + 1);
  uint64_t v66 = *this;

  return (void *)dispatch_semaphore_signal(v66);
}

void sub_1D9F8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p)
{
  operator delete(v11);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *GTMMappedBuffer::Allocate(dispatch_semaphore_t *this, unsigned int a2)
{
  dispatch_semaphore_wait(this[1], 0xFFFFFFFFFFFFFFFFLL);
  dispatch_semaphore_t v4 = this[12];
  dispatch_semaphore_t v5 = this[13];
  if (v4 == v5)
  {
LABEL_7:
    unsigned __int8 v8 = 0;
  }
  else
  {
    unsigned int v6 = a2;
    while (1)
    {
      unsigned int isa = v4[3].isa;
      if (HIDWORD(v4[2].isa) == isa)
      {
        unsigned int isa = 0;
        HIDWORD(v4[2].isa) = 0;
        LODWORD(v4[3].isa) = 0;
      }
      if ((unint64_t)a2 + 32776 < LODWORD(v4[2].isa) - isa) {
        break;
      }
      v4 += 4;
      if (v4 == v5) {
        goto LABEL_7;
      }
    }
    unsigned int v9 = (unint64_t *)((char *)v4[1].isa + isa);
    *unsigned int v9 = (v6 + 8) | ((unint64_t)v4->isa << 32) | 0xCADDAC0000000000;
    unsigned __int8 v8 = v9 + 1;
    LODWORD(v4[3].isa) += v6 + 8;
  }
  dispatch_semaphore_signal(this[1]);
  return v8;
}

void GTUSCSamplingStreamingManagerHelper::PostProcessRawData(GTUSCSamplingStreamingManagerHelper *this, unsigned int a2, unsigned int a3)
{
  atomic_fetch_add((atomic_uint *volatile)this + 688, 1u);
  if ([*((id *)this + 3) count] == (char *)&def_1C1270 + 1) {
    unsigned int v5 = 0;
  }
  else {
    unsigned int v5 = a2 + 1;
  }
  unsigned int v128 = a2;
  if (*((_DWORD *)this + 544) != -1)
  {
    if (a2 == 2)
    {
      unsigned int v6 = (char *)this + 3112;
    }
    else
    {
      if (a2 != 1) {
        goto LABEL_10;
      }
      unsigned int v6 = (char *)this + 3104;
    }
    unsigned int v5 = *(_DWORD *)v6;
  }
LABEL_10:
  unint64_t v127 = [*((id *)this + 3) objectAtIndexedSubscript:v5];
  unsigned __int8 v7 = atomic_load((unsigned __int8 *)this + 2763);
  if ((v7 & 1) == 0)
  {
    unsigned int v118 = a2;
    uint64_t v117 = 120 * a3;
    do
    {
      unsigned __int8 v8 = atomic_load((unsigned __int8 *)this + 2764);
      if (v8) {
        break;
      }
      dispatch_semaphore_wait(*(dispatch_semaphore_t *)(*(void *)(*((void *)this + 306) + 24 * v118) + 8 * a3), 0xFFFFFFFFFFFFFFFFLL);
      unsigned __int8 v9 = atomic_load((unsigned __int8 *)this + 2763);
      if (v9) {
        break;
      }
      unsigned __int8 v10 = atomic_load((unsigned __int8 *)this + 2764);
      if (v10) {
        break;
      }
      dispatch_semaphore_wait(*(dispatch_semaphore_t *)(*((void *)this + 309) + 8 * v128), 0xFFFFFFFFFFFFFFFFLL);
      uint64_t v11 = *(void *)(*((void *)this + 294) + 24 * v128) + v117;
      uint64_t v12 = *(void *)(*((void *)this + 300) + 24 * v128);
      uint64_t v13 = *(void *)(*((void *)this + 291) + 24 * v128);
      dispatch_semaphore_wait(*(dispatch_semaphore_t *)v11, 0xFFFFFFFFFFFFFFFFLL);
      long long v141 = *(_OWORD *)(v11 + 48);
      *(_OWORD *)(v11 + 48) = 0u;
      long long v142 = *(_OWORD *)(v11 + 64);
      *(_OWORD *)(v11 + 64) = 0u;
      long long v143 = *(_OWORD *)(v11 + 80);
      *(_OWORD *)(v11 + 80) = 0u;
      id v125 = (GTMMappedBuffer *)v11;
      dispatch_semaphore_signal(*(dispatch_semaphore_t *)v11);
      v140[0] = 0;
      int64x2_t v139 = 0u;
      if (*((void *)&v143 + 1))
      {
        if (*((void *)&v143 + 1) > 0xAAAAAAAAAAAAAAAuLL) {
          abort();
        }
        *(void *)&long long v138 = v140;
        unint64_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(*((unint64_t *)&v143 + 1));
        *(void *)BOOL v137 = v14;
        *(void *)&v137[8] = v14;
        uint64_t v16 = &v14[24 * v15];
        *(void *)&v137[16] = v14;
        *(void *)&v137[24] = v16;
        uint64_t v17 = v139.i64[1];
        uint64_t v18 = v139.i64[0];
        if (v139.i64[1] == v139.i64[0])
        {
          int64x2_t v22 = vdupq_n_s64(v139.u64[1]);
          size_t v19 = v14;
        }
        else
        {
          size_t v19 = v14;
          do
          {
            long long v20 = *(_OWORD *)(v17 - 24);
            v17 -= 24;
            *(_OWORD *)(v19 - 24) = v20;
            v19 -= 24;
            uint64_t v21 = *(void *)(v17 + 16);
            *(void *)(v17 + 16) = 0;
            *((void *)v19 + 2) = v21;
          }
          while (v17 != v18);
          int64x2_t v22 = v139;
          uint64_t v16 = *(char **)&v137[24];
          unint64_t v14 = *(char **)&v137[16];
        }
        v139.i64[0] = (uint64_t)v19;
        v139.i64[1] = (uint64_t)v14;
        *(int64x2_t *)&v137[8] = v22;
        uint64_t v23 = v140[0];
        v140[0] = v16;
        *(void *)&v137[24] = v23;
        *(void *)BOOL v137 = v22.i64[0];
        std::__split_buffer<std::tuple<unsigned char *,unsigned long long,NSMutableData * {__strong}>>::~__split_buffer((uint64_t)v137);
      }
      unint64_t v123 = (dispatch_semaphore_t *)(v12 + v117);
      uint64_t v126 = (dispatch_semaphore_t *)(v13 + v117);
      unsigned __int8 v24 = atomic_load((unsigned __int8 *)this + 2760);
      if ((v24 & 1) == 0) {
        goto LABEL_33;
      }
      if ((void)v142 == *((void *)&v141 + 1)) {
        goto LABEL_33;
      }
      BOOL v25 = (unint64_t *)(*((void *)&v141 + 1) + 8 * ((unint64_t)v143 / 0xAA));
      unint64_t v26 = *v25;
      unint64_t v27 = *v25 + 24 * ((unint64_t)v143 % 0xAA);
      unint64_t v28 = *(void *)(*((void *)&v141 + 1) + 8 * ((*((void *)&v143 + 1) + (void)v143) / 0xAAuLL))
          + 24 * ((*((void *)&v143 + 1) + (void)v143) % 0xAAuLL);
      if (v27 == v28) {
        goto LABEL_33;
      }
      int v29 = 0;
      do
      {
        if (*(_DWORD *)(v27 + 16)) {
          ++v29;
        }
        v27 += 24;
        if (v27 - v26 == 4080)
        {
          unint64_t v30 = v25[1];
          ++v25;
          unint64_t v26 = v30;
          unint64_t v27 = v30;
        }
      }
      while (v27 != v28);
      if (!v29)
      {
LABEL_33:
        unsigned __int8 v31 = atomic_load((unsigned __int8 *)this + 2760);
        if (v31)
        {
          dispatch_semaphore_wait(*v126, 0xFFFFFFFFFFFFFFFFLL);
          dispatch_semaphore_t v32 = (_OWORD *)(v13 + 120 * a3);
          *(_OWORD *)BOOL v137 = v32[3];
          v32[3] = 0u;
          *(_OWORD *)&v137[16] = v32[4];
          v32[4] = 0u;
          long long v138 = v32[5];
          v32[5] = 0u;
          dispatch_semaphore_signal(*v126);
          if (*((void *)&v138 + 1))
          {
            unint64_t v33 = *(void *)(*(void *)&v137[8] + 8 * ((unint64_t)v138 / 0xAA))
                + 24 * ((unint64_t)v138 % 0xAA);
            dispatch_semaphore_t v34 = *(unsigned __int8 **)v33;
            uint64_t v35 = *(void *)(v33 + 8);
            uint64_t v36 = *(unsigned int *)(v33 + 16);
            uint64_t v38 = +[NSMutableData dataWithBytes:v35 length:v36];
            GTMMappedBuffer::Deallocate((uint64_t)v126, v34);
            uint64_t v136 = 0;
            id v39 = v38;
            id v40 = [v39 bytes];
            id v41 = [v39 length];
            unsigned __int8 v42 = atomic_load((unsigned __int8 *)this + 2760);
            GTMMappedBuffer::PostProcessRawDataFromSource(&v133, v123, v127, (uint64_t)v40, (uint64_t)v41, &v136, a3, v42 & 1);
            unint64_t v43 = v134;
            if (v134 && v43 <= (unint64_t)[v39 length])
            {
              id v44 = v39;
              GTMMappedBuffer::MemcpyFromSourceBuffer(v126, (unsigned __int8 *)[v44 length] + (void)objc_msgSend(v44, "bytes") - v43, v43, 0, 0);
            }
            uint64_t v45 = v136;
            unint64_t v46 = v133;
            if (v136 && v133)
            {
              unint64_t v47 = (void *)v139.i64[1];
              if (v139.i64[1] >= v140[0])
              {
                unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((v139.i64[1] - v139.i64[0]) >> 3);
                unint64_t v50 = v49 + 1;
                if (v49 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  abort();
                }
                if (0x5555555555555556 * ((v140[0] - v139.i64[0]) >> 3) > v50) {
                  unint64_t v50 = 0x5555555555555556 * ((v140[0] - v139.i64[0]) >> 3);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((v140[0] - v139.i64[0]) >> 3) >= 0x555555555555555) {
                  unint64_t v51 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v51 = v50;
                }
                id v147 = v140;
                if (v51) {
                  unint64_t v51 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v51);
                }
                else {
                  uint64_t v52 = 0;
                }
                uint64_t v53 = (void *)(v51 + 24 * v49);
                uint64_t v144 = v51;
                v145.i64[0] = (uint64_t)v53;
                unint64_t v146 = v51 + 24 * v52;
                *uint64_t v53 = v45;
                v53[1] = v46;
                v53[2] = v135;
                uint64_t v48 = v53 + 3;
                v145.i64[1] = (uint64_t)(v53 + 3);
                uint64_t v54 = v139.i64[1];
                uint64_t v55 = v139.i64[0];
                if (v139.i64[1] == v139.i64[0])
                {
                  int64x2_t v58 = vdupq_n_s64(v139.u64[1]);
                }
                else
                {
                  do
                  {
                    long long v56 = *(_OWORD *)(v54 - 24);
                    v54 -= 24;
                    *(_OWORD *)(v53 - 3) = v56;
                    v53 -= 3;
                    uint64_t v57 = *(void *)(v54 + 16);
                    *(void *)(v54 + 16) = 0;
                    v53[2] = v57;
                  }
                  while (v54 != v55);
                  int64x2_t v58 = v139;
                  uint64_t v48 = (void *)v145.i64[1];
                  unint64_t v46 = v133;
                }
                v139.i64[0] = (uint64_t)v53;
                v139.i64[1] = (uint64_t)v48;
                int64x2_t v145 = v58;
                unint64_t v59 = v140[0];
                v140[0] = v146;
                unint64_t v146 = v59;
                uint64_t v144 = v58.i64[0];
                std::__split_buffer<std::tuple<unsigned char *,unsigned long long,NSMutableData * {__strong}>>::~__split_buffer((uint64_t)&v144);
              }
              else
              {
                *(void *)v139.i64[1] = v136;
                v47[1] = v46;
                v47[2] = v135;
                uint64_t v48 = v47 + 3;
              }
              v139.i64[1] = (uint64_t)v48;
            }
            atomic_fetch_add((atomic_ullong *volatile)this + 341, v46);
          }
          std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100](v137);
        }
        int v29 = 0;
      }
      int v122 = v29;
      if ((void)v142 != *((void *)&v141 + 1))
      {
        uint64_t v60 = (void *)(*((void *)&v141 + 1) + 8 * ((unint64_t)v143 / 0xAA));
        unint64_t v61 = *v60 + 24 * ((unint64_t)v143 % 0xAA);
        unint64_t v124 = *(void *)(*((void *)&v141 + 1) + 8 * ((*((void *)&v143 + 1) + (void)v143) / 0xAAuLL))
             + 24 * ((*((void *)&v143 + 1) + (void)v143) % 0xAAuLL);
        if (v61 != v124)
        {
          int v62 = 0;
          int64_t v63 = (_OWORD *)(v13 + 120 * a3);
          unint64_t v120 = v63 + 4;
          int v121 = v63 + 3;
          BOOL v119 = v63 + 5;
          do
          {
            unint64_t v133 = 0;
            if (*(_DWORD *)(v61 + 16))
            {
              dispatch_semaphore_wait(*v126, 0xFFFFFFFFFFFFFFFFLL);
              *(_OWORD *)BOOL v137 = *v121;
              _OWORD *v121 = 0u;
              *(_OWORD *)&v137[16] = *v120;
              *unint64_t v120 = 0u;
              long long v138 = *v119;
              *BOOL v119 = 0u;
              dispatch_semaphore_signal(*v126);
              if (*((void *)&v138 + 1))
              {
                unint64_t v64 = *(void *)(*(void *)&v137[8] + 8 * ((unint64_t)v138 / 0xAA))
                    + 24 * ((unint64_t)v138 % 0xAA);
                uint64_t v66 = *(unsigned __int8 **)v64;
                unint64_t v65 = *(const void **)(v64 + 8);
                size_t v67 = *(unsigned int *)(v64 + 16);
                if (v67 > 0x8000)
                {
                  long long v75 = +[NSMutableData dataWithCapacity:(*(_DWORD *)(v61 + 16) + v67)];
                  [v75 appendBytes:v65 length:v67];
                  [v75 appendBytes:*(void *)(v61 + 8) length:*(unsigned int *)(v61 + 16)];
                  id v69 = v75;
                  id v68 = [v69 bytes];
                  unsigned int v70 = [v69 length];
                }
                else
                {
                  id v68 = (id)(*(void *)v61 - v67 + 0x8000);
                  memcpy(v68, v65, v67);
                  id v69 = 0;
                  unsigned int v70 = *(_DWORD *)(v61 + 16) + v67;
                }
                GTMMappedBuffer::Deallocate((uint64_t)v126, v66);
              }
              else
              {
                id v69 = 0;
                id v68 = *(id *)(v61 + 8);
                unsigned int v70 = *(_DWORD *)(v61 + 16);
              }
              GTMMappedBuffer::PostProcessRawDataFromSource(&v144, v123, v127, (uint64_t)v68, v70, &v133, a3, ++v62 == v122);
              unint64_t v72 = v144;
              if (v145.i64[0])
              {
                unint64_t v76 = *(unsigned int *)(v61 + 16);
                BOOL v77 = v76 >= v145.i64[0];
                unint64_t v78 = v76 - v145.i64[0];
                if (v77) {
                  GTMMappedBuffer::MemcpyFromSourceBuffer(v126, (unsigned __int8 *)(*(void *)(v61 + 8) + v78), v145.u32[0], 0, 0);
                }
              }
              atomic_fetch_add((atomic_ullong *volatile)this + 341, v72);
              id v73 = (id)v145.i64[1];

              std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100](v137);
              unint64_t v71 = v133;
            }
            else
            {
              unint64_t v71 = 0;
              unint64_t v72 = 0;
              id v73 = 0;
            }
            GTMMappedBuffer::Deallocate((uint64_t)v125, *(unsigned __int8 **)v61);
            if (v71 && v72)
            {
              id v79 = (void *)v139.i64[1];
              if (v139.i64[1] >= v140[0])
              {
                unint64_t v81 = 0xAAAAAAAAAAAAAAABLL * ((v139.i64[1] - v139.i64[0]) >> 3);
                unint64_t v82 = v81 + 1;
                if (v81 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  abort();
                }
                if (0x5555555555555556 * ((v140[0] - v139.i64[0]) >> 3) > v82) {
                  unint64_t v82 = 0x5555555555555556 * ((v140[0] - v139.i64[0]) >> 3);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((v140[0] - v139.i64[0]) >> 3) >= 0x555555555555555) {
                  unint64_t v83 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v83 = v82;
                }
                *(void *)&long long v138 = v140;
                if (v83) {
                  unint64_t v83 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v83);
                }
                else {
                  uint64_t v84 = 0;
                }
                uint64_t v85 = (unint64_t *)(v83 + 24 * v81);
                *(void *)BOOL v137 = v83;
                *(void *)&v137[8] = v85;
                *(void *)&v137[24] = v83 + 24 * v84;
                unint64_t *v85 = v71;
                v85[1] = v72;
                v85[2] = (unint64_t)v73;
                id v80 = v85 + 3;
                *(void *)&v137[16] = v85 + 3;
                uint64_t v86 = v139.i64[1];
                uint64_t v87 = v139.i64[0];
                if (v139.i64[1] == v139.i64[0])
                {
                  int64x2_t v90 = vdupq_n_s64(v139.u64[1]);
                }
                else
                {
                  do
                  {
                    long long v88 = *(_OWORD *)(v86 - 24);
                    v86 -= 24;
                    *(_OWORD *)(v85 - 3) = v88;
                    v85 -= 3;
                    unint64_t v89 = *(void *)(v86 + 16);
                    *(void *)(v86 + 16) = 0;
                    v85[2] = v89;
                  }
                  while (v86 != v87);
                  int64x2_t v90 = v139;
                  id v80 = *(void **)&v137[16];
                }
                v139.i64[0] = (uint64_t)v85;
                v139.i64[1] = (uint64_t)v80;
                *(int64x2_t *)&v137[8] = v90;
                uint64_t v91 = v140[0];
                v140[0] = *(void *)&v137[24];
                *(void *)&v137[24] = v91;
                *(void *)BOOL v137 = v90.i64[0];
                std::__split_buffer<std::tuple<unsigned char *,unsigned long long,NSMutableData * {__strong}>>::~__split_buffer((uint64_t)v137);
              }
              else
              {
                *(void *)v139.i64[1] = v71;
                v79[1] = v72;
                v79[2] = v73;
                id v80 = v79 + 3;
              }
              v139.i64[1] = (uint64_t)v80;
            }

            v61 += 24;
            if (v61 - *v60 == 4080)
            {
              unint64_t v92 = v60[1];
              ++v60;
              unint64_t v61 = v92;
            }
          }
          while (v61 != v124);
        }
      }
      dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*((void *)this + 309) + 8 * v128));
      uint64_t v94 = v139.i64[1];
      for (uint64_t i = v139.i64[0]; i != v94; i += 24)
      {
        id v96 = *(id *)(i + 16);
        uint64_t v97 = v96;
        if (v96)
        {
          id v101 = v96;
        }
        else
        {
          id v98 = objc_alloc((Class)NSData);
          uint64_t v99 = *(void *)i;
          uint64_t v100 = *(void *)(i + 8);
          v130[0] = _NSConcreteStackBlock;
          v130[1] = 3221225472;
          v130[2] = ___ZN35GTUSCSamplingStreamingManagerHelper18PostProcessRawDataEjj_block_invoke;
          v130[3] = &__block_descriptor_48_e12_v24__0_v8Q16l;
          v130[4] = this;
          unsigned int v131 = v128;
          unsigned int v132 = a3;
          id v101 = [v98 initWithBytesNoCopy:v99 length:v100 deallocator:v130];
        }
        uint64_t v102 = v101;
        v151[0] = v101;
        v150[0] = @"ShaderProfilerData";
        v150[1] = @"Source";
        unint64_t v103 = [v127 name];
        v151[1] = v103;
        v150[2] = @"SourceIndex";
        uint64_t v104 = +[NSNumber numberWithUnsignedInt:v128];
        v151[2] = v104;
        v150[3] = @"RingBufferIndex";
        uint64_t v105 = +[NSNumber numberWithUnsignedInt:a3];
        v151[3] = v105;
        id v106 = +[NSDictionary dictionaryWithObjects:v151 forKeys:v150 count:4];

        (*(void (**)(void))(*(void *)(*(void *)this + 32) + 16))();
      }
      if (*((void *)&v143 + 1)) {
        atomic_fetch_add((atomic_uint *volatile)this + 686, DWORD2(v143));
      }
      unsigned __int8 v107 = atomic_load((unsigned __int8 *)this + 2760);
      if (v107)
      {
        unsigned int v108 = atomic_load((unsigned int *)this + 687);
        if (v108 == *((_DWORD *)this + 541))
        {
          unsigned int v109 = atomic_load((unsigned int *)this + 685);
          unsigned int v110 = atomic_load((unsigned int *)this + 686);
          if (v109 == v110)
          {
            CFStringRef v148 = @"Post Processing Frame Marker";
            uint64_t v111 = atomic_load((unsigned int *)this + 689);
            uint64_t v112 = +[NSNumber numberWithUnsignedInt:v111];
            unint64_t v149 = v112;
            unint64_t v113 = +[NSDictionary dictionaryWithObjects:&v149 forKeys:&v148 count:1];

            (*(void (**)(void))(*(void *)(*(void *)this + 32) + 16))();
            unsigned __int8 v114 = atomic_load((unsigned __int8 *)this + 2761);
            if (v114) {
              std::condition_variable::notify_all((std::condition_variable *)((char *)this + 2768));
            }
            std::condition_variable::notify_all((std::condition_variable *)this + 60);
          }
        }
      }
      *(void *)BOOL v137 = &v139;
      std::vector<std::tuple<unsigned char *,unsigned long long,NSMutableData * {__strong}>>::__destroy_vector::operator()[abi:nn180100]((void ***)v137);
      std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100](&v141);
      unsigned __int8 v115 = atomic_load((unsigned __int8 *)this + 2763);
    }
    while ((v115 & 1) == 0);
  }
  atomic_fetch_add((atomic_uint *volatile)this + 688, 0xFFFFFFFF);
  if (!atomic_load((unsigned int *)this + 688)) {
    std::condition_variable::notify_all((std::condition_variable *)((char *)this + 2992));
  }
}

void sub_1DACE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void **a33,uint64_t a34,id a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47)
{
  std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100](&a37);
  a33 = (void **)&a43;
  std::vector<std::tuple<unsigned char *,unsigned long long,NSMutableData * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&a33);
  std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100](&a47);

  _Unwind_Resume(a1);
}

uint64_t GTMMappedBuffer::Deallocate(uint64_t this, unsigned __int8 *a2)
{
  if (a2)
  {
    id v2 = (void *)this;
    if (*(void *)(this + 96) != *(void *)(this + 104))
    {
      if (*(_DWORD *)(this + 36))
      {
        this = dispatch_semaphore_wait(*(dispatch_semaphore_t *)(this + 8), 0xFFFFFFFFFFFFFFFFLL);
        unint64_t v6 = *((void *)a2 - 1);
        unsigned int v5 = a2 - 8;
        unint64_t v4 = v6;
        if (v6 >> 40 == 13295020)
        {
          uint64_t v7 = v2[12];
          if (BYTE4(v4) < (unint64_t)((v2[13] - v7) >> 5))
          {
            uint64_t v8 = v7 + 32 * BYTE4(v4);
            uint64_t v9 = (uint64_t)&v5[-*(void *)(v8 + 8)];
            if (v9 >= 0 && *(_DWORD *)(v8 + 16) > v9) {
              *(_DWORD *)(v7 + 32 * BYTE4(v4) + 20) += v4;
            }
            unsigned __int8 v10 = v2[1];
            return dispatch_semaphore_signal(v10);
          }
        }
      }
    }
  }
  return this;
}

void GTMMappedBuffer::PostProcessRawDataFromSource(void *a1, dispatch_semaphore_t *a2, void *a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, char a8)
{
  id v15 = a3;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  if (a5)
  {
    if (((8 * a5 / 5uLL + 7) & 0x7FFFFFFFFFFFFFF8) <= 0x4000) {
      unint64_t v16 = 0x4000;
    }
    else {
      unint64_t v16 = (8 * a5 / 5uLL + 7) & 0x7FFFFFFFFFFFFFF8;
    }
    uint64_t v17 = GTMMappedBuffer::Allocate(a2, v16);
    *a6 = v17;
    if (v17)
    {
      id v18 = v17;
LABEL_9:
      ++GTMMappedBuffer::PostProcessRawDataFromSource(objc_object  {objcproto19GPURawCounterSource}*,unsigned char *,unsigned long long,unsigned long long,objc_object  {objcproto19GPURawCounterSource}*&,unsigned int,BOOL)::ppData;
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      LOBYTE(v21) = a8;
      [v15 postProcessRawDataWithRingBufferIndex:a7 source:a4 sourceSize:a5 + 8 sourceRead:&v24 sourceWrite:a5 output:v18 outputSize:v16 outputRead:0 outputWrite:&v23 isLast:v21];
      unint64_t v20 = (a5 + 8 + v24) / (unint64_t)(a5 + 8) * (a5 + 8) - (v24 + 8);
      *a1 = v23;
      a1[1] = v20;
      goto LABEL_10;
    }
    size_t v19 = +[NSMutableData dataWithLength:v16];
    a1[2] = v19;
    if (v19)
    {
      id v18 = [v19 mutableBytes];
      *a6 = v18;
      goto LABEL_9;
    }
  }
LABEL_10:
}

void sub_1DB028(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::tuple<unsigned char *,unsigned long long,NSMutableData * {__strong}>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t ___ZN35GTUSCSamplingStreamingManagerHelper18PostProcessRawDataEjj_block_invoke(uint64_t result, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(result + 32);
  uint64_t v3 = *(void *)(v2 + 2400);
  uint64_t v4 = *(void *)(v2 + 2408);
  if (v3 != v4)
  {
    unint64_t v5 = *(unsigned int *)(result + 40);
    if (0xAAAAAAAAAAAAAAABLL * ((v4 - v3) >> 3) > v5)
    {
      unint64_t v6 = *(unsigned int *)(result + 44);
      uint64_t v8 = (uint64_t *)(v3 + 24 * v5);
      uint64_t v7 = *v8;
      if (0xEEEEEEEEEEEEEEEFLL * ((v8[1] - *v8) >> 3) < v6) {
        return GTMMappedBuffer::Deallocate(v7 + 120 * v6, a2);
      }
    }
  }
  return result;
}

void std::vector<std::tuple<unsigned char *,unsigned long long,NSMutableData * {__strong}>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (id *)**a1;
  if (v2)
  {
    uint64_t v4 = (id *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unint64_t v6 = v4 - 3;

        uint64_t v4 = v6;
      }
      while (v6 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void GTUSCSamplingStreamingManagerHelper::SignalAndWaitForAllThreadsToTerminate(GTUSCSamplingStreamingManagerHelper *this)
{
  uint64_t v1 = qword_7729A0;
  uint64_t v2 = xmmword_7729A8;
  while (v1 != v2)
  {
    uint64_t v3 = *(NSObject ***)v1;
    uint64_t v4 = *(NSObject ***)(v1 + 8);
    while (v3 != v4)
    {
      unint64_t v5 = *v3++;
      dispatch_semaphore_signal(v5);
    }
    v1 += 24;
  }
  uint64_t v7 = (NSObject ***)*((void *)&xmmword_7729B8 + 1);
  for (uint64_t i = (NSObject ***)xmmword_7729B8; i != v7; i += 3)
  {
    uint64_t v8 = *i;
    uint64_t v9 = i[1];
    while (v8 != v9)
    {
      unsigned __int8 v10 = *v8++;
      dispatch_semaphore_signal(v10);
    }
  }
  v12.__m_ = (std::unique_lock<std::mutex>::mutex_type *)&qword_772B98;
  v12.__owns_ = 1;
  std::mutex::lock((std::mutex *)&qword_772B98);
  while (atomic_load((unsigned int *)&unk_772AE8))
    std::condition_variable::wait((std::condition_variable *)&qword_772BD8, &v12);
  if (v12.__owns_) {
    std::mutex::unlock(v12.__m_);
  }
}

std::__thread_struct ***std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_0>>::~unique_ptr[abi:nn180100](std::__thread_struct ***result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    std::unique_ptr<std::__thread_struct>::reset[abi:nn180100](v1);
    operator delete();
  }
  return result;
}

std::__thread_struct *std::unique_ptr<std::__thread_struct>::reset[abi:nn180100](std::__thread_struct **a1)
{
  __n128 result = *a1;
  *a1 = 0;
  if (result)
  {
    std::__thread_struct::~__thread_struct(result);
    operator delete();
  }
  return result;
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_1>>(std::__thread_struct **a1)
{
  uint64_t v4 = a1;
  uint64_t v1 = std::__thread_local_data();
  uint64_t v2 = *v4;
  *uint64_t v4 = 0;
  pthread_setspecific(v1->__key_, v2);
  GTUSCSamplingStreamingManagerHelper::PostProcessRawData((GTUSCSamplingStreamingManagerHelper *)v4[1], *((_DWORD *)v4 + 4), *((_DWORD *)v4 + 5));
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_0>>::~unique_ptr[abi:nn180100](&v4);
  return 0;
}

void sub_1DB368(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_0>>::~unique_ptr[abi:nn180100]((std::__thread_struct ***)va);
  _Unwind_Resume(a1);
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_0>>(std::__thread_struct **a1)
{
  uint64_t v4 = a1;
  uint64_t v1 = std::__thread_local_data();
  uint64_t v2 = *v4;
  *uint64_t v4 = 0;
  pthread_setspecific(v1->__key_, v2);
  GTUSCSamplingStreamingManagerHelper::PollAndDrainSourceRingBuffer((GTUSCSamplingStreamingManagerHelper *)v4[1], *((_DWORD *)v4 + 4), *((unsigned int *)v4 + 5));
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_0>>::~unique_ptr[abi:nn180100](&v4);
  return 0;
}

void sub_1DB3D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_0>>::~unique_ptr[abi:nn180100]((std::__thread_struct ***)va);
  _Unwind_Resume(a1);
}

uint64_t GTUSCSamplingStreamingManagerHelper::InitForPreSamplingWait(uint64_t this)
{
  if (!*(_DWORD *)(*(void *)this + 72))
  {
    uint64_t v1 = this;
    dispatch_semaphore_t v2 = dispatch_semaphore_create(0);
    uint64_t v3 = *(void **)(v1 + 2520);
    *(void *)(v1 + 2520) = v2;

    dispatch_semaphore_t v4 = dispatch_semaphore_create(0);
    unint64_t v5 = *(void **)(v1 + 2528);
    *(void *)(v1 + 2528) = v4;

    operator new();
  }
  return this;
}

void sub_1DB4F4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  std::__thread_struct::~__thread_struct(v10);
  operator delete();
}

std::__thread_struct ***std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::InitForPreSamplingWait(void)::$_0>>::~unique_ptr[abi:nn180100](std::__thread_struct ***result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1)
  {
    std::unique_ptr<std::__thread_struct>::reset[abi:nn180100](v1);
    operator delete();
  }
  return result;
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::InitForPreSamplingWait(void)::$_0>>(std::__thread_struct **a1)
{
  unsigned __int8 v10 = a1;
  uint64_t v1 = std::__thread_local_data();
  dispatch_semaphore_t v2 = *v10;
  std::__thread_struct *v10 = 0;
  pthread_setspecific(v1->__key_, v2);
  uint64_t v3 = v10[1];
  while (1)
  {
    unsigned __int8 v4 = atomic_load((unsigned __int8 *)&v3[345].__p_ + 1);
    if (v4) {
      break;
    }
    unsigned __int8 v5 = atomic_load((unsigned __int8 *)&v3[345].__p_ + 4);
    if (v5) {
      break;
    }
    p = v3[315].__p_;
    dispatch_time_t v7 = dispatch_time(0, 250000);
    if (!dispatch_semaphore_wait(p, v7)) {
      break;
    }
    unsigned __int8 v8 = atomic_load((unsigned __int8 *)&v3[345].__p_ + 2);
    if (v8) {
      GTUSCSamplingStreamingManagerHelper::ForceDrainAllSourceBuffers(v3[3].__p_);
    }
  }
  atomic_store(0, (unsigned __int8 *)&v3[345].__p_ + 2);
  dispatch_semaphore_signal((dispatch_semaphore_t)v3[316].__p_);
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::InitForPreSamplingWait(void)::$_0>>::~unique_ptr[abi:nn180100](&v10);
  return 0;
}

void sub_1DB650(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::InitForPreSamplingWait(void)::$_0>>::~unique_ptr[abi:nn180100]((std::__thread_struct ***)va);
  _Unwind_Resume(a1);
}

unsigned __int8 *GTUSCSamplingStreamingManagerHelper::WaitForPreSampling(unsigned __int8 *this)
{
  if (!*(_DWORD *)(*(void *)this + 72))
  {
    uint64_t v1 = this;
    atomic_store(1u, this + 2762);
    usleep(0x30D40u);
    dispatch_semaphore_signal(*((dispatch_semaphore_t *)v1 + 315));
    dispatch_semaphore_t v2 = *((void *)v1 + 316);
    return (unsigned __int8 *)dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
  }
  return this;
}

void GTUSCSamplingStreamingManagerHelper::StreamShaderProfilingData(GTUSCSamplingStreamingManagerHelper *this)
{
  unsigned __int8 v1 = atomic_load(byte_772AF4);
  if ((v1 & 1) == 0)
  {
    uint64_t v2 = -1431655765 * ((*((void *)&xmmword_772958 + 1) - (void)xmmword_772958) >> 3);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
      {
        if (-286331153
           * ((*(void *)(xmmword_772958 + 24 * i + 8) - *(void *)(xmmword_772958 + 24 * i)) >> 3))
        {
          operator new();
        }
      }
    }
    uint64_t v18 = *(void *)GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
    unsigned __int8 v4 = [*(id *)(*(void *)GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) defaultDevice];
    size_t v19 = v4;
    if (v4)
    {
      atomic_store(HIDWORD(qword_7728A8), (unsigned int *)&xmmword_772AD8);
      v65[0] = 0;
      v65[1] = v65;
      v65[2] = 0x2020000000;
      v65[3] = 0;
      unsigned __int8 v5 = atomic_load((unsigned __int8 *)&unk_772AF3);
      if ((v5 & 1) == 0)
      {
        do
        {
          unsigned __int8 v6 = atomic_load(byte_772AF4);
          if (v6) {
            break;
          }
          unint64_t v20 = objc_opt_new();
          dispatch_time_t v7 = 0;
          int v8 = 3;
          do
          {
            v63[0] = 0;
            v63[1] = (pthread_t)v63;
            v63[2] = (pthread_t)0x3032000000;
            v63[3] = (pthread_t)__Block_byref_object_copy_;
            v63[4] = (pthread_t)__Block_byref_object_dispose_;
            id v64 = (id)objc_opt_new();
            v61[0] = 0;
            v61[1] = v61;
            v61[2] = 0x5812000000;
            v61[3] = __Block_byref_object_copy__310;
            v61[4] = __Block_byref_object_dispose__311;
            memset(&v61[5], 0, 40);
            int v62 = 1065353216;
            v59[0] = 0;
            v59[1] = (pthread_t)v59;
            v59[2] = (pthread_t)0x5812000000;
            v59[3] = (pthread_t)__Block_byref_object_copy__415;
            v59[4] = (pthread_t)__Block_byref_object_dispose__416;
            memset(&v59[5], 0, 40);
            int v60 = 1065353216;
            sched_param v50 = 0;
            unint64_t v51 = &v50;
            uint64_t v52 = 0x4812000000;
            uint64_t v53 = __Block_byref_object_copy__417;
            uint64_t v54 = __Block_byref_object_dispose__418;
            uint64_t v55 = &unk_4E231D;
            uint64_t v57 = 0;
            uint64_t v58 = 0;
            __p = 0;
            v48[0] = 0;
            v48[1] = v48;
            void v48[2] = 0x3032000000;
            v48[3] = __Block_byref_object_copy_;
            v48[4] = __Block_byref_object_dispose_;
            id v49 = 0;
            unsigned __int8 v10 = objc_opt_new();
            v46[0] = 0;
            v46[1] = v46;
            v46[2] = 0x3032000000;
            v46[3] = __Block_byref_object_copy_;
            v46[4] = __Block_byref_object_dispose_;
            id v47 = (id)objc_opt_new();
            v36[0] = _NSConcreteStackBlock;
            v36[1] = 3221225472;
            v36[2] = ___ZN35GTUSCSamplingStreamingManagerHelper25StreamShaderProfilingDataEv_block_invoke;
            v36[3] = &unk_7448D8;
            uint64_t v45 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
            uint64_t v38 = v61;
            id v39 = &v50;
            id v40 = v59;
            id v41 = v65;
            id v21 = v10;
            id v37 = v21;
            unsigned __int8 v42 = v63;
            unint64_t v43 = v46;
            id v44 = v48;
            int64x2_t v22 = +[NSBlockOperation blockOperationWithBlock:v36];
            v26[0] = _NSConcreteStackBlock;
            v26[1] = 3221225472;
            v26[2] = ___ZN35GTUSCSamplingStreamingManagerHelper25StreamShaderProfilingDataEv_block_invoke_2;
            v26[3] = &unk_7447E8;
            dispatch_semaphore_t v34 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
            uint64_t v35 = v18;
            unint64_t v27 = v19;
            unint64_t v28 = v61;
            int v29 = v59;
            unint64_t v30 = &v50;
            unsigned __int8 v31 = v63;
            dispatch_semaphore_t v32 = v46;
            unint64_t v33 = v48;
            uint64_t v11 = +[NSBlockOperation blockOperationWithBlock:v26];
            std::unique_lock<std::mutex> v12 = v11;
            if (v7) {
              [v11 addDependency:v7];
            }
            [v12 setQueuePriority:-8];
            [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v12];
            if (dword_77286C && dword_772868)
            {
              v23[0] = _NSConcreteStackBlock;
              v23[1] = 3221225472;
              v23[2] = ___ZN35GTUSCSamplingStreamingManagerHelper25StreamShaderProfilingDataEv_block_invoke_3;
              v23[3] = &unk_7463C0;
              BOOL v25 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
              id v24 = v21;
              uint64_t v13 = +[NSBlockOperation blockOperationWithBlock:v23];
              [v13 addDependency:v12];
              [v22 addDependency:v13];
              [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v13];
            }
            else
            {
              [v22 addDependency:v12];
            }
            [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:v22];
            [v20 addDependency:v22];

            _Block_object_dispose(v46, 8);
            _Block_object_dispose(v48, 8);

            _Block_object_dispose(&v50, 8);
            if (__p)
            {
              uint64_t v57 = __p;
              operator delete(__p);
            }
            _Block_object_dispose(v59, 8);
            std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table((uint64_t)&v59[6]);
            _Block_object_dispose(v61, 8);
            std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v61[6]);
            _Block_object_dispose(v63, 8);

            dispatch_time_t v7 = v22;
            --v8;
          }
          while (v8);
          [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:v20];
          [v20 waitUntilFinished];

          unsigned __int8 v14 = atomic_load((unsigned __int8 *)&unk_772AF3);
        }
        while ((v14 & 1) == 0);
      }
      GTUSCSamplingStreamingManagerHelper::SignalAndWaitForAllThreadsToTerminate(v4);
      uint64_t v15 = *(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 32);
      v66[0] = @"usc sampling address mappings";
      unint64_t v16 = [(id)xmmword_7727C0 mappings];
      v66[1] = @"usc sampling address data";
      v67[0] = v16;
      v67[1] = qword_7727D8;
      uint64_t v17 = +[NSDictionary dictionaryWithObjects:v67 forKeys:v66 count:2];
      (*(void (**)(uint64_t, void *))(v15 + 16))(v15, v17);

      _Block_object_dispose(v65, 8);
    }
  }
}

void sub_1DC048(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31)
{
  _Block_object_dispose((const void *)(v33 - 192), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__415(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0;
  *(void *)(result + 48) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0;
  uint64_t v5 = a2[8];
  uint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 64;
    void *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t __Block_byref_object_dispose__416(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table(a1 + 48);
}

__n128 __Block_byref_object_copy__417(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__418(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void ___ZN35GTUSCSamplingStreamingManagerHelper25StreamShaderProfilingDataEv_block_invoke(void *a1)
{
  uint64_t v2 = a1[12];
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v2 + 2763));
  if (v3 & 1) == 0 || (unsigned __int8 v4 = atomic_load((unsigned __int8 *)(v2 + 2764)), (v4))
  {
    __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v2 + 2928);
    __lk.__owns_ = 1;
    std::mutex::lock((std::mutex *)(v2 + 2928));
    unsigned int v5 = atomic_load((unsigned int *)(v2 + 2740));
    unsigned int v6 = atomic_load((unsigned int *)(v2 + 2744));
    if (v5 != v6)
    {
      do
      {
        std::condition_variable::wait((std::condition_variable *)(v2 + 2880), &__lk);
        unsigned int v7 = atomic_load((unsigned int *)(v2 + 2740));
        unsigned int v8 = atomic_load((unsigned int *)(v2 + 2744));
      }
      while (v7 != v8);
    }
    [*(id *)(v2 + 8) gatherStats];
    uint64_t v99 = +[NSMutableDictionary dictionaryWithCapacity:*(void *)(*(void *)(a1[5] + 8) + 72)];
    id v98 = +[NSMutableDictionary dictionaryWithCapacity:*(void *)(*(void *)(a1[5] + 8) + 72)];
    uint64_t v9 = *(void *)(a1[6] + 8);
    unint64_t v10 = *(void *)(v9 + 48);
    uint64_t v11 = *(unint64_t **)(v9 + 56);
    unint64_t v12 = 126 - 2 * __clz((uint64_t)((uint64_t)v11 - v10) >> 4);
    if (v11 == (unint64_t *)v10) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = v12;
    }
    std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>(v10, v11, v13, 1);
    unint64_t v95 = +[NSMutableArray arrayWithCapacity:(uint64_t)(*(void *)(*(void *)(a1[6] + 8) + 56) - *(void *)(*(void *)(a1[6] + 8) + 48)) >> 4];
    uint64_t v94 = +[NSMutableData dataWithCapacity:*(void *)(*(void *)(a1[6] + 8) + 56) - *(void *)(*(void *)(a1[6] + 8) + 48)];
    [v94 appendBytes:*(void *)(*(void *)(a1[6] + 8) + 48) length:*(void *)(*(void *)(a1[6] + 8) + 56) - *(void *)(*(void *)(a1[6] + 8) + 48)];
    uint64_t v14 = a1[6];
    uint64_t v15 = *(void *)(v14 + 8);
    uint64_t v16 = *(void *)(v15 + 48);
    uint64_t v17 = *(void *)(v15 + 56);
    id v96 = a1;
    if (v16 == v17) {
      unint64_t v18 = 0;
    }
    else {
      unint64_t v18 = *(void *)(v16 + 8);
    }
    uint64_t v104 = v2;
    if ((unint64_t)(v17 - v16) >= 0x11)
    {
      uint64_t v19 = 0;
      unint64_t v20 = 1;
      do
      {
        if (v18 < *(void *)(v16 + v19 + 16))
        {
          id v21 = +[NSNumber numberWithUnsignedLongLong:v18];
          v117[0] = v21;
          int64x2_t v22 = +[NSNumber numberWithUnsignedLongLong:*(void *)(*(void *)(*(void *)(v96[6] + 8) + 48) + v19 + 16) - 1];
          v117[1] = v22;
          uint64_t v23 = +[NSArray arrayWithObjects:v117 count:2];
          [v95 addObject:v23];

          uint64_t v14 = v96[6];
        }
        uint64_t v24 = *(void *)(v14 + 8);
        uint64_t v16 = *(void *)(v24 + 48);
        uint64_t v25 = *(void *)(v24 + 56);
        if (v18 <= *(void *)(v16 + v19 + 24)) {
          unint64_t v18 = *(void *)(v16 + v19 + 24);
        }
        ++v20;
        v19 += 16;
      }
      while (v20 < (v25 - v16) >> 4);
    }
    for (uint64_t i = *(uint64_t ***)(*(void *)(v96[5] + 8) + 64); i; uint64_t i = (uint64_t **)*i)
    {
      unint64_t v27 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)i + 6)];
      unint64_t v28 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)i + 4)];
      [v99 setObject:v27 forKeyedSubscript:v28];

      int v29 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)i + 7)];
      v116[0] = v29;
      unint64_t v30 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)i + 8)];
      v116[1] = v30;
      unsigned __int8 v31 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)i + 9)];
      v116[2] = v31;
      dispatch_semaphore_t v32 = +[NSNumber numberWithUnsignedLongLong:i[5]];
      v116[3] = v32;
      uint64_t v33 = +[NSArray arrayWithObjects:v116 count:4];
      dispatch_semaphore_t v34 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)i + 4)];
      [v98 setObject:v33 forKeyedSubscript:v34];
    }
    uint64_t v97 = +[NSMutableDictionary dictionaryWithCapacity:*(void *)(*(void *)(v96[7] + 8) + 72)];
    for (uint64_t j = *(uint64_t ***)(*(void *)(v96[7] + 8) + 64); j; uint64_t j = (uint64_t **)*j)
    {
      uint64_t v36 = +[NSMutableArray arrayWithCapacity:((char *)j[4] - (char *)j[3]) >> 4];
      id v37 = (unsigned int *)j[3];
      uint64_t v38 = (unsigned int *)j[4];
      while (v37 != v38)
      {
        id v39 = +[NSNumber numberWithUnsignedInt:*v37];
        v115[0] = v39;
        id v40 = +[NSNumber numberWithUnsignedLongLong:*((void *)v37 + 1)];
        v115[1] = v40;
        id v41 = +[NSArray arrayWithObjects:v115 count:2];
        [v36 addObject:v41];

        v37 += 4;
      }
      unsigned __int8 v42 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)j + 4)];
      [v97 setObject:v36 forKeyedSubscript:v42];
    }
    id v107 = 0;
    int64x2_t v90 = +[NSKeyedArchiver archivedDataWithRootObject:v99 requiringSecureCoding:1 error:&v107];
    id v43 = v107;
    id v44 = (char *)[*(id *)(v104 + 1968) mutableBytes];
    uint64_t v45 = *(void *)(*(void *)(v96[8] + 8) + 24);
    uint64_t v91 = +[NSData dataWithBytesNoCopy:&v44[v45] length:*(void *)(v104 + 1976) - v45 freeWhenDone:0];
    id v106 = v43;
    unint64_t v92 = +[NSKeyedArchiver archivedDataWithRootObject:v98 requiringSecureCoding:1 error:&v106];
    id v46 = v106;

    id v105 = v46;
    id v93 = +[NSKeyedArchiver archivedDataWithRootObject:v97 requiringSecureCoding:1 error:&v105];
    id v89 = v105;

    uint64_t v47 = v104;
    uint64_t v48 = *(void **)(v104 + 1944);
    if (*(int *)(v104 + 2180) >= 2)
    {
      id v88 = [v48 mappings];
      uint64_t v102 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v88 count]);
      unint64_t v103 = objc_opt_new();
      sched_param v50 = objc_opt_new();
      long long v111 = 0u;
      long long v112 = 0u;
      long long v109 = 0u;
      long long v110 = 0u;
      obuint64_t j = v88;
      id v51 = [obj countByEnumeratingWithState:&v109 objects:v118 count:16];
      if (v51)
      {
        uint64_t v101 = *(void *)v110;
        do
        {
          for (uint64_t k = 0; k != v51; uint64_t k = (char *)k + 1)
          {
            if (*(void *)v110 != v101) {
              objc_enumerationMutation(obj);
            }
            uint64_t v53 = *(void **)(*((void *)&v109 + 1) + 8 * (void)k);
            id v54 = [v53 mutableCopy];
            uint64_t v55 = [v53 objectForKeyedSubscript:@"encIndex"];
            unsigned int v56 = [v55 unsignedIntValue];

            unint64_t v57 = *(void *)(v104 + 1960);
            uint64_t v58 = [v53 objectForKeyedSubscript:@"drawCallIndex"];
            id v59 = [v58 unsignedIntValue];

            int v60 = [v53 objectForKeyedSubscript:@"mappedSize"];
            uint64_t v61 = (uint64_t)[v60 unsignedLongLongValue];

            int v62 = [v53 objectForKeyedSubscript:@"type"];
            int64_t v63 = [v53 objectForKeyedSubscript:@"binaryUniqueId"];
            id v64 = GTShaderProfilerGenerateComputedKey(v56 % v57, (uint64_t)v59, v61, v62);
            unint64_t v65 = [v50 objectForKeyedSubscript:v64];
            LOBYTE(v61) = v65 == 0;

            if ((v61 & 1) == 0)
            {
              uint64_t v66 = [v103 objectForKeyedSubscript:v64];
              unsigned int v67 = [v66 unsignedIntValue];

              uint64_t v68 = v67 + 1;
              uint64_t v69 = +[NSString stringWithFormat:@"%@_%u", v64, v68];

              unsigned int v70 = +[NSNumber numberWithUnsignedInt:v68];
              [v103 setObject:v70 forKeyedSubscript:v69];

              id v64 = (void *)v69;
            }
            [v50 setObject:v63 forKeyedSubscript:v64];
            unint64_t v71 = [*(id *)(v104 + 1952) objectForKeyedSubscript:v64];
            [v54 setObject:v71 forKeyedSubscript:@"binaryUniqueId"];

            [v102 addObject:v54];
          }
          id v51 = [obj countByEnumeratingWithState:&v109 objects:v118 count:16];
        }
        while (v51);
      }

      id v49 = [v102 copy];
      uint64_t v47 = v104;
    }
    else
    {
      id v49 = [v48 mappings];
    }
    unint64_t v72 = objc_alloc_init(ProgramAddressTableCollector);
    id v73 = *(void **)(v47 + 1944);
    *(void *)(v47 + 1944) = v72;

    v113[0] = @"Frame Index";
    uint64_t v74 = v104;
    uint64_t v75 = atomic_load((unsigned int *)(v104 + 2756));
    unint64_t v76 = +[NSNumber numberWithUnsignedInt:v75];
    v114[0] = v76;
    v114[1] = v91;
    v113[1] = @"Program Address Buffer";
    v113[2] = @"Program Address Mappings";
    _OWORD v114[2] = v49;
    v114[3] = v90;
    v113[3] = @"TraceId to BatchId";
    v113[4] = @"Source Sample Marker";
    BOOL v77 = +[NSNumber numberWithUnsignedLongLong:*(void *)(v74 + 32)];
    uint64_t v78 = v96[4];
    v114[4] = v77;
    v114[5] = v78;
    v113[5] = @"Frame Encoder Time Data";
    v113[6] = @"TraceId to SampleIndex";
    v114[6] = v92;
    v113[7] = @"MTLFX TraceIds";
    uint64_t v79 = [*(id *)(*(void *)(v96[9] + 8) + 40) mtlfxTracingInfo];
    id v80 = (void *)v79;
    unint64_t v81 = &__NSDictionary0__struct;
    if (v79) {
      unint64_t v82 = (void *)v79;
    }
    else {
      unint64_t v82 = &__NSDictionary0__struct;
    }
    v114[7] = v82;
    v113[8] = @"Frame Consistent Perf Info";
    uint64_t v83 = v96[11];
    v114[8] = *(void *)(*(void *)(v96[10] + 8) + 40);
    v114[9] = v95;
    v113[9] = @"Restore Timestamps";
    v113[10] = @"Command Buffer Timestamps";
    v114[10] = v94;
    v113[11] = @"PState Info Data";
    if (*(void *)(*(void *)(v83 + 8) + 40)) {
      unint64_t v81 = *(void **)(*(void *)(v83 + 8) + 40);
    }
    v114[11] = v81;
    v114[12] = v93;
    v113[12] = @"TraceId to Coalesced BatchId";
    v113[13] = @"PState non-consistent";
    uint64_t v84 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(*(void *)v104 + 68)];
    v114[13] = v84;
    uint64_t v85 = +[NSDictionary dictionaryWithObjects:v114 forKeys:v113 count:14];

    (*(void (**)(void))(*(void *)(*(void *)v104 + 32) + 16))();
    *(void *)(*(void *)(v96[8] + 8) + 24) = *(void *)(v104 + 1976);
    atomic_fetch_add((atomic_uint *volatile)(v104 + 2736), 0xFFFFFFFF);
    unint64_t v86 = atomic_load((unint64_t *)(v104 + 2728));
    if (v86 > 0x3000000 || (int v87 = atomic_load((unsigned int *)(v104 + 2736)), v87 <= 0)) {
      atomic_store(1u, (unsigned __int8 *)(v104 + 2763));
    }

    if (__lk.__owns_) {
      std::mutex::unlock(__lk.__m_);
    }
  }
}

void sub_1DCE30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, void *a20,void *a21,void *a22,uint64_t a23,uint64_t a24,void *a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,std::mutex *a31,char a32)
{
  if (a32) {
    std::mutex::unlock(a31);
  }
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper25StreamShaderProfilingDataEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 2763));
  if (v2) {
    return;
  }
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v1 + 2764));
  if (v3) {
    return;
  }
  atomic_store(0, (unsigned __int8 *)(v1 + 2760));
  GTUSCSamplingStreamingManagerHelper::InitForPreSamplingWait(v1);
  GTMTLReplayController_prePlayForProfiling(**(void **)v1);
  usleep(0x7A120u);
  if (*(_DWORD *)(v1 + 2180) == 1) {
    uint64_t v5 = 100000;
  }
  else {
    uint64_t v5 = 0;
  }
  [*(id *)(v1 + 8) startCollectingPerfStatsAtInterval:1000000 andPeriodicSamplesAtInterval:v5];
  id v6 = *(id *)(v1 + 2080);
  unsigned int v7 = [*(id *)(v1 + 16) firstObject];
  id v8 = [*(id *)(v1 + 24) count];
  if (!v8) {
    goto LABEL_35;
  }
  int v9 = *(unsigned __int8 *)(v1 + 2186);
  if (GTAGXPerfStateControl::IsGPUPerformanceStateInduced((GTAGXPerfStateControl *)(v1 + 40)))
  {
    v59[0] = @"DisableOverlap";
    unint64_t v10 = +[NSNumber numberWithBool:v9 == 0];
    v60[0] = v10;
    uint64_t v11 = +[NSDictionary dictionaryWithObjects:v60 forKeys:v59 count:1];
    [v7 setOptions:v11];
  }
  else
  {
    uint64_t v12 = *(unsigned int *)(*(void *)v1 + 72);
    if (v12)
    {
      GTAGXPerfStateControl::EnableConsistentGPUPerfState(v1 + 40, v12);
      uint64_t v13 = GTApplePMPPerfStateControl::EnableConsistentPerfState((GTApplePMPPerfStateControl *)(v1 + 64), *(_DWORD *)(*(void *)v1 + 72) - 1);
      uint64_t v14 = *(void **)(v1 + 2088);
      *(void *)(v1 + 2088) = v13;

      v59[0] = @"DisableOverlap";
      unint64_t v10 = +[NSNumber numberWithBool:v9 == 0];
      v60[0] = v10;
      uint64_t v11 = +[NSDictionary dictionaryWithObjects:v60 forKeys:v59 count:1];
      [v7 setOptions:v11];
    }
    else
    {
      uint64_t v15 = GTApplePMPPerfStateControl::EnableConsistentPerfState((GTApplePMPPerfStateControl *)(v1 + 64), 1u);
      uint64_t v16 = *(void **)(v1 + 2088);
      *(void *)(v1 + 2088) = v15;

      v59[0] = @"LockGPUPerfState";
      unint64_t v10 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(*(void *)v1 + 68)];
      v59[1] = @"DisableOverlap";
      v60[0] = v10;
      uint64_t v11 = +[NSNumber numberWithBool:v9 == 0];
      v60[1] = v11;
      uint64_t v17 = +[NSDictionary dictionaryWithObjects:v60 forKeys:v59 count:2];
      [v7 setOptions:v17];
    }
  }

  if (!*(unsigned char *)(v1 + 2184))
  {
    unint64_t v18 = 0;
    goto LABEL_14;
  }
  uint64_t v44 = 0;
  unsigned int v45 = 1;
  while (1)
  {
    id v46 = [*(id *)(v1 + 2008) objectAtIndexedSubscript:v44];
    BOOL v47 = [v46 count] == 0;

    if (!v47) {
      break;
    }
LABEL_52:
    uint64_t v44 = v45;
    if ((unint64_t)v8 <= v45++)
    {
      int v51 = 0;
      goto LABEL_55;
    }
  }
  uint64_t v48 = [*(id *)(v1 + 24) objectAtIndexedSubscript:v44];
  uint64_t v49 = *(void *)(v1 + 1904);
  if (v45 - 1 >= ((unint64_t)(*(void *)(v1 + 1912) - v49) >> 2)
    || (*(_DWORD *)(v49 + 4 * v44) & 0x10) == 0)
  {

    goto LABEL_52;
  }

  int v51 = 1;
LABEL_55:
  int v52 = *(_DWORD *)(v1 + 2116);
  if (v52) {
    int v52 = *(_DWORD *)(v1 + 2112) != 0;
  }
  if ((v51 | v52) == 1)
  {
    uint64_t v53 = *(std::unique_lock<std::mutex>::mutex_type **)(v1 + 2048);
    __lk.__m_ = v53;
    *(void *)&__lk.__owns_ = v53;
  }
  else
  {
    __lk.__m_ = *(std::unique_lock<std::mutex>::mutex_type **)(v1 + 2040);
    *(void *)&__lk.__owns_ = __lk.__m_;
    uint64_t v53 = *(std::unique_lock<std::mutex>::mutex_type **)(v1 + 2048);
  }
  uint64_t v58 = v53;
  unint64_t v18 = +[NSArray arrayWithObjects:&__lk count:3];
LABEL_14:
  char v19 = 0;
  for (unsigned int i = 0; ; unsigned int i = v21 + 1)
  {
    unint64_t v21 = i;
    if ((unint64_t)[*(id *)(v1 + 24) count] <= i) {
      break;
    }
    int64x2_t v22 = [*(id *)(v1 + 2008) objectAtIndexedSubscript:i];
    BOOL v23 = [v22 count] == 0;

    if (!v23)
    {
      uint64_t v24 = [*(id *)(v1 + 24) objectAtIndexedSubscript:v21];
      if (*(unsigned char *)(v1 + 2184))
      {
        if ((unint64_t)[v18 count] <= v21)
        {
          id v26 = *(id *)(v1 + 2048);
        }
        else
        {
          id v26 = [v18 objectAtIndexedSubscript:v21];
        }
        uint64_t v55 = v26;
        [v24 requestTriggers:nil firstErrorIndex:nil];
        if ((v19 & 1) != 0
          || (uint64_t v27 = *(void *)(v1 + 1904),
              v21 >= ((unint64_t)(*(void *)(v1 + 1912) - v27) >> 2)))
        {
          [v24 setOptions:*(void *)(v1 + 2080)];
        }
        else if ((*(_DWORD *)(v27 + 4 * v21) & 0x10) != 0)
        {
          int v29 = +[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", [*(id *)(v1 + 2080) count]);
          [v29 setObject:&__kCFBooleanTrue forKeyedSubscript:@"KickTimestamp"];
          if (*(void *)(v1 + 2080)) {
            [v29 addEntriesFromDictionary:];
          }
          [v24 setOptions:v29];

          char v19 = 1;
        }
        else
        {
          char v19 = 0;
        }
        uint64_t v56 = 0;
        unint64_t v28 = [*(id *)(v1 + 2008) objectAtIndexedSubscript:v21];
        unsigned __int8 v54 = [v24 requestCounters:v28 firstErrorIndex:&v56];

        if ((v54 & 1) == 0)
        {

          goto LABEL_34;
        }
      }
      unsigned int v25 = [v24 setEnabled:1];

      if (!v25) {
        goto LABEL_34;
      }
    }
  }
  *(unsigned char *)(v1 + 2184) = 0;
LABEL_34:

LABEL_35:
  atomic_store(0, (unsigned int *)(v1 + 2748));
  unint64_t v30 = [*(id *)(v1 + 16) firstObject];
  unsigned __int8 v31 = [v30 startSampling];

  if (v31)
  {
    GTUSCSamplingStreamingManagerHelper::ResetSourceForPostProcessing((id *)v1);
    GTUSCSamplingStreamingManagerHelper::WaitForPreSampling((unsigned __int8 *)v1);
    atomic_store(1u, (unsigned __int8 *)(v1 + 2761));
    atomic_store(1u, (unsigned __int8 *)(v1 + 2761));
    dispatch_semaphore_t v32 = [*(id *)(*(void *)(a1 + 96) + 8) defaultCommandQueue];
    [*(id *)(a1 + 32) mapShaderSampleBufferWithBuffer:0 capacity:0 size:0];
    *(void *)&__lk.__owns_ = *(void *)(a1 + 96);
    LOBYTE(v58) = 0;
    __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)[(id)g_commandBufferDescriptor errorOptions];
    [(id)g_commandBufferDescriptor setErrorOptions:0];
    GTUSCSamplingStreamingManagerHelper::ReplaySingleFrameForUSCSampling();
    [v32 finish];
    ScopedReplayConfiguration::~ScopedReplayConfiguration((ScopedReplayConfiguration *)&__lk);
    [*(id *)(a1 + 32) unmapShaderSampleBuffer];
    atomic_store(1u, (unsigned __int8 *)(v1 + 2760));
    atomic_fetch_add((atomic_uint *volatile)(v1 + 2756), 1u);
    GTUSCSamplingStreamingManagerHelper::DrainAllSourceBuffers(*(void *)(v1 + 2424), *(void *)(v1 + 2432));
    __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v1 + 2816);
    __lk.__owns_ = 1;
    std::mutex::lock((std::mutex *)(v1 + 2816));
    int v34 = *(_DWORD *)(v1 + 2164);
    unsigned int v35 = atomic_load((unsigned int *)(v1 + 2748));
    if (v34 != v35)
    {
      do
      {
        std::condition_variable::wait((std::condition_variable *)(v1 + 2768), &__lk);
        int v36 = *(_DWORD *)(v1 + 2164);
        unsigned int v37 = atomic_load((unsigned int *)(v1 + 2748));
      }
      while (v36 != v37);
    }
    uint64_t v38 = GTAGXPerfStateControl::ConsistentGPUPerfStateLevel((GTAGXPerfStateControl *)(v1 + 40), 0);
    if (v38) {
      [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) setDictionary:v38];
    }
    id v39 = [*(id *)(v1 + 16) firstObject];
    [v39 stopSampling];

    [*(id *)(v1 + 8) gatherStats];
    [*(id *)(v1 + 8) stopCollectingStats];
    id v40 = [*(id *)(v1 + 8) exportStats];
    id v41 = [v40 copy];
    uint64_t v42 = *(void *)(*(void *)(a1 + 80) + 8);
    id v43 = *(void **)(v42 + 40);
    *(void *)(v42 + 40) = v41;

    [*(id *)(v1 + 8) reset];
    GTAGXPerfStateControl::DisableConsistentGPUPerfState((GTAGXPerfStateControl *)(v1 + 40));
    GTApplePMPPerfStateControl::DisableConsistentPerfState((GTApplePMPPerfStateControl *)(v1 + 64));
    atomic_store(0, (unsigned __int8 *)(v1 + 2761));

    if (__lk.__owns_) {
      std::mutex::unlock(__lk.__m_);
    }
  }
  else
  {
    [*(id *)(v1 + 8) stopCollectingStats];
    [*(id *)(v1 + 8) reset];
    GTUSCSamplingStreamingManagerHelper::WaitForPreSampling((unsigned __int8 *)v1);
    GTAGXPerfStateControl::DisableConsistentGPUPerfState((GTAGXPerfStateControl *)(v1 + 40));
    GTApplePMPPerfStateControl::DisableConsistentPerfState((GTApplePMPPerfStateControl *)(v1 + 64));
  }
}

void sub_1DD8E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::mutex *a13, char a14)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper25StreamShaderProfilingDataEv_block_invoke_3(uint64_t a1)
{
  unsigned __int8 v2 = *(void **)(a1 + 40);
  GTSampleBufferManager::ResolveSampleBuffers((GTSampleBufferManager *)(v2 + 263));
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  if (v3) {
    [*(id *)(a1 + 32) setData:v3];
  }
  v2[269] = 0;
  v2[267] = v2[266];
}

void sub_1DDAC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id GTSampleBufferManager::ResolveSampleBuffers(GTSampleBufferManager *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (*((void *)this + 3) == v1)
  {
    unsigned int v7 = 0;
  }
  else
  {
    int v3 = *((_DWORD *)this + 12);
    *((_DWORD *)this + 13) += v3;
    *(_DWORD *)(v1 - 4) = v3;
    id v4 = [objc_alloc((Class)NSMutableArray) initWithCapacity:[*((id *)this + 2) count]];
    uint64_t v21 = 0;
    int64x2_t v22 = &v21;
    uint64_t v23 = 0x2020000000;
    uint64_t v24 = 0;
    uint64_t v5 = (void *)*((void *)this + 2);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = ___ZN21GTSampleBufferManager20ResolveSampleBuffersEv_block_invoke;
    void v17[3] = &unk_744928;
    char v19 = &v21;
    unint64_t v20 = this;
    id v6 = v4;
    id v18 = v6;
    [v5 enumerateObjectsUsingBlock:v17];
    unsigned int v7 = +[NSMutableData dataWithCapacity:v22[3]];
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    id v8 = v6;
    id v9 = [v8 countByEnumeratingWithState:&v13 objects:v25 count:16];
    if (v9)
    {
      uint64_t v10 = *(void *)v14;
      do
      {
        for (unsigned int i = 0; i != v9; unsigned int i = (char *)i + 1)
        {
          if (*(void *)v14 != v10) {
            objc_enumerationMutation(v8);
          }
          [v7 appendData:*(void *)(*((void *)&v13 + 1) + 8 * i) v13];
        }
        id v9 = [v8 countByEnumeratingWithState:&v13 objects:v25 count:16];
      }
      while (v9);
    }

    _Block_object_dispose(&v21, 8);
  }

  return v7;
}

void sub_1DDCD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN21GTSampleBufferManager20ResolveSampleBuffersEv_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = (unsigned int *)(*(void *)(*(void *)(a1 + 48) + 24) + 8 * a3);
  id v8 = v5;
  unsigned int v7 = [v5 resolveCounterRange:*v6, v6[1]];
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += [v7 length];
  [*(id *)(a1 + 32) addObject:v7];
}

void sub_1DDDAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>(unint64_t result, unint64_t *a2, uint64_t a3, char a4)
{
  id v9 = (unint64_t *)result;
LABEL_2:
  uint64_t v10 = a2 - 2;
  uint64_t k = v9;
  while (1)
  {
    id v9 = k;
    uint64_t v12 = (char *)a2 - (char *)k;
    unint64_t v13 = ((char *)a2 - (char *)k) >> 4;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          unint64_t v45 = *v10;
          unint64_t v46 = *k;
          if (*v10 < *k || v46 >= v45 && *(a2 - 1) < k[1])
          {
            *uint64_t k = v45;
            *(a2 - 2) = v46;
            unint64_t v47 = k[1];
            k[1] = *(a2 - 1);
            *(a2 - 1) = v47;
          }
          break;
        case 3uLL:
          __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(k, k + 2, a2 - 2);
          break;
        case 4uLL:
          __n128 result = (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(k, k + 2, k + 4, a2 - 2);
          break;
        case 5uLL:
          __n128 result = (unint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(k, k + 2, k + 4, k + 6, a2 - 2);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 383)
    {
      uint64_t v48 = k + 2;
      BOOL v50 = k == a2 || v48 == a2;
      if (a4)
      {
        if (v50) {
          return result;
        }
        uint64_t v51 = 0;
        int v52 = k;
        while (2)
        {
          uint64_t v53 = v52;
          int v52 = v48;
          unint64_t v54 = v53[2];
          unint64_t v55 = *v53;
          if (v54 < *v53)
          {
            unint64_t v56 = v53[3];
            goto LABEL_112;
          }
          if (v55 >= v54)
          {
            unint64_t v56 = v53[3];
            if (v56 < v53[1])
            {
LABEL_112:
              v53[2] = v55;
              v52[1] = v53[1];
              unint64_t v57 = k;
              if (v53 != k)
              {
                uint64_t v58 = v51;
                do
                {
                  unint64_t v59 = *(unint64_t *)((char *)k + v58 - 16);
                  if (v54 >= v59)
                  {
                    if (v59 < v54)
                    {
                      unint64_t v57 = v53;
                      goto LABEL_121;
                    }
                    unint64_t v57 = (unint64_t *)((char *)k + v58);
                    unint64_t v60 = *(unint64_t *)((char *)k + v58 - 8);
                    if (v56 >= v60) {
                      goto LABEL_121;
                    }
                  }
                  else
                  {
                    unint64_t v60 = *(unint64_t *)((char *)k + v58 - 8);
                  }
                  v53 -= 2;
                  uint64_t v61 = (unint64_t *)((char *)k + v58);
                  unint64_t *v61 = v59;
                  v61[1] = v60;
                  v58 -= 16;
                }
                while (v58);
                unint64_t v57 = k;
              }
LABEL_121:
              unint64_t *v57 = v54;
              v57[1] = v56;
            }
          }
          uint64_t v48 = v52 + 2;
          v51 += 16;
          if (v52 + 2 == a2) {
            return result;
          }
          continue;
        }
      }
      if (v50) {
        return result;
      }
      while (2)
      {
        BOOL v77 = v9;
        id v9 = v48;
        unint64_t v78 = v77[2];
        unint64_t v79 = *v77;
        if (v78 >= *v77)
        {
          if (v79 >= v78)
          {
            unint64_t v80 = v77[3];
            if (v80 < v77[1]) {
              goto LABEL_159;
            }
          }
        }
        else
        {
          unint64_t v80 = v77[3];
          do
          {
            do
            {
LABEL_159:
              unint64_t v81 = v77;
              unint64_t v82 = v79;
              unint64_t v83 = *(v77 - 2);
              v77 -= 2;
              unint64_t v79 = v83;
              unint64_t v84 = v77[3];
              v77[4] = v82;
              v77[5] = v84;
            }
            while (v78 < v83);
          }
          while (v79 >= v78 && v80 < *(v81 - 1));
          *unint64_t v81 = v78;
          v81[1] = v80;
        }
        uint64_t v48 = v9 + 2;
        if (v9 + 2 == a2) {
          return result;
        }
        continue;
      }
    }
    if (!a3) {
      break;
    }
    unint64_t v14 = v13 >> 1;
    long long v15 = &k[2 * (v13 >> 1)];
    if ((unint64_t)v12 >= 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(v9, &v9[2 * (v13 >> 1)], a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(v9 + 2, v15 - 2, a2 - 4);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(v9 + 4, &v9[2 * v14 + 2], a2 - 6);
      __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(v15 - 2, v15, &v9[2 * v14 + 2]);
      long long v16 = *(_OWORD *)v9;
      *(_OWORD *)id v9 = *(_OWORD *)v15;
      *(_OWORD *)long long v15 = v16;
    }
    else
    {
      __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(&v9[2 * (v13 >> 1)], v9, a2 - 2);
    }
    --a3;
    unint64_t v17 = *v9;
    if ((a4 & 1) != 0 || (unint64_t v18 = *(v9 - 2), v18 < v17))
    {
LABEL_14:
      unint64_t v20 = v9[1];
      for (unsigned int i = v9 + 2; ; i += 2)
      {
        unint64_t v22 = *i;
        if (*i >= v17 && (v17 < v22 || i[1] >= v20)) {
          break;
        }
      }
      if (i - 2 == v9)
      {
        uint64_t j = a2;
        if (i < a2)
        {
          unint64_t v26 = *v10;
          uint64_t j = a2 - 2;
          if (*v10 >= v17)
          {
            uint64_t j = a2 - 2;
            do
            {
              if (v17 >= v26)
              {
                if (j[1] < v20 || i >= j) {
                  break;
                }
              }
              else if (i >= j)
              {
                break;
              }
              unint64_t v28 = *(j - 2);
              j -= 2;
              unint64_t v26 = v28;
            }
            while (v28 >= v17);
          }
        }
      }
      else
      {
        unint64_t v23 = *v10;
        for (uint64_t j = a2 - 2; v23 >= v17 && (v17 < v23 || j[1] >= v20); j -= 2)
        {
          unint64_t v25 = *(j - 2);
          unint64_t v23 = v25;
        }
      }
      uint64_t k = i;
      if (i < j)
      {
        unint64_t v29 = *j;
        uint64_t k = i;
        unint64_t v30 = j;
        do
        {
          *uint64_t k = v29;
          unint64_t *v30 = v22;
          unint64_t v31 = k[1];
          k[1] = v30[1];
          v30[1] = v31;
          do
          {
            do
            {
              unint64_t v32 = k[2];
              k += 2;
              unint64_t v22 = v32;
            }
            while (v32 < v17);
          }
          while (v17 >= v22 && k[1] < v20);
          do
          {
            unint64_t v33 = *(v30 - 2);
            v30 -= 2;
            unint64_t v29 = v33;
          }
          while (v33 >= v17 && (v17 < v29 || v30[1] >= v20));
        }
        while (k < v30);
      }
      if (k - 2 != v9)
      {
        *id v9 = *(k - 2);
        v9[1] = *(k - 1);
      }
      *(k - 2) = v17;
      *(k - 1) = v20;
      if (i < j) {
        goto LABEL_51;
      }
      BOOL v34 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(v9, k - 2);
      __n128 result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(k, a2);
      if (result)
      {
        a2 = k - 2;
        if (v34) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v34)
      {
LABEL_51:
        __n128 result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>(v9, k - 2, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      if (v17 < v18)
      {
        unint64_t v19 = v9[1];
      }
      else
      {
        unint64_t v19 = v9[1];
        if (*(v9 - 1) < v19) {
          goto LABEL_14;
        }
      }
      unint64_t v35 = *v10;
      if (v17 >= *v10 && (v35 < v17 || v19 >= *(a2 - 1)))
      {
        for (uint64_t k = v9 + 2; k < a2 && v17 >= *k && (*k < v17 || v19 >= k[1]); k += 2)
          ;
      }
      else
      {
        uint64_t k = v9;
        do
        {
          unint64_t v37 = k[2];
          k += 2;
          unint64_t v36 = v37;
        }
        while (v17 >= v37 && (v36 < v17 || v19 >= k[1]));
      }
      m = a2;
      if (k < a2)
      {
        for (m = a2 - 2; v17 < v35 || v35 >= v17 && v19 < m[1]; m -= 2)
        {
          unint64_t v39 = *(m - 2);
          unint64_t v35 = v39;
        }
      }
      if (k < m)
      {
        unint64_t v40 = *k;
        unint64_t v41 = *m;
        do
        {
          *uint64_t k = v41;
          unint64_t *m = v40;
          unint64_t v42 = k[1];
          k[1] = m[1];
          m[1] = v42;
          do
          {
            unint64_t v43 = k[2];
            k += 2;
            unint64_t v40 = v43;
          }
          while (v17 >= v43 && (v40 < v17 || v19 >= k[1]));
          do
          {
            do
            {
              unint64_t v44 = *(m - 2);
              m -= 2;
              unint64_t v41 = v44;
            }
            while (v17 < v44);
          }
          while (v41 >= v17 && v19 < m[1]);
        }
        while (k < m);
      }
      BOOL v4 = k - 2 >= v9;
      BOOL v5 = k - 2 == v9;
      if (k - 2 != v9)
      {
        *id v9 = *(k - 2);
        v9[1] = *(k - 1);
      }
      a4 = 0;
      *(k - 2) = v17;
      *(k - 1) = v19;
    }
  }
  if (k != a2)
  {
    int64_t v62 = (v13 - 2) >> 1;
    int64_t v63 = v62;
    while (2)
    {
      int64_t v64 = v63;
      if (v62 >= v63)
      {
        uint64_t v65 = (2 * v63) | 1;
        uint64_t v66 = &k[2 * v65];
        if (2 * v64 + 2 < (uint64_t)v13)
        {
          unint64_t v67 = v66[2];
          if (*v66 < v67 || v67 >= *v66 && k[2 * v65 + 1] < v66[3])
          {
            v66 += 2;
            uint64_t v65 = 2 * v64 + 2;
          }
        }
        uint64_t v68 = &k[2 * v64];
        unint64_t v69 = *v66;
        unint64_t v70 = *v68;
        if (*v66 >= *v68)
        {
          if (v70 < v69)
          {
            unint64_t v71 = v68[1];
            goto LABEL_136;
          }
          unint64_t v71 = k[2 * v64 + 1];
          if (v66[1] >= v71)
          {
LABEL_136:
            unint64_t *v68 = v69;
            v68[1] = v66[1];
            if (v62 >= v65)
            {
              while (1)
              {
                uint64_t v73 = 2 * v65;
                uint64_t v65 = (2 * v65) | 1;
                unint64_t v72 = &k[2 * v65];
                uint64_t v74 = v73 + 2;
                if (v74 < (uint64_t)v13)
                {
                  unint64_t v75 = v72[2];
                  if (*v72 < v75 || v75 >= *v72 && k[2 * v65 + 1] < v72[3])
                  {
                    v72 += 2;
                    uint64_t v65 = v74;
                  }
                }
                unint64_t v76 = *v72;
                if (*v72 < v70 || v70 >= v76 && v72[1] < v71) {
                  break;
                }
                *uint64_t v66 = v76;
                v66[1] = v72[1];
                uint64_t v66 = v72;
                if (v62 < v65) {
                  goto LABEL_138;
                }
              }
            }
            unint64_t v72 = v66;
LABEL_138:
            *unint64_t v72 = v70;
            v72[1] = v71;
          }
        }
      }
      int64_t v63 = v64 - 1;
      if (v64) {
        continue;
      }
      break;
    }
    uint64_t v85 = (unint64_t)v12 >> 4;
    while (2)
    {
      int64_t v86 = 0;
      unint64_t v87 = *k;
      unint64_t v88 = k[1];
      uint64_t v89 = v85 - 2;
      if (v85 < 2) {
        uint64_t v89 = v85 - 1;
      }
      uint64_t v90 = v89 >> 1;
      uint64_t v91 = k;
      do
      {
        unint64_t v92 = v91;
        int64_t v93 = v86 + 1;
        v91 += 2 * v86 + 2;
        uint64_t v94 = 2 * v86;
        __n128 result = (2 * v86) | 1;
        int64_t v86 = result;
        uint64_t v95 = v94 + 2;
        if (v95 < v85)
        {
          __n128 result = (unint64_t)(v91 + 2);
          unint64_t v96 = v91[2];
          if (*v91 < v96 || v96 >= *v91 && v92[2 * v93 + 1] < v91[3])
          {
            v91 += 2;
            int64_t v86 = v95;
          }
        }
        unint64_t *v92 = *v91;
        v92[1] = v91[1];
      }
      while (v86 <= v90);
      if (v91 == a2 - 2)
      {
        unint64_t *v91 = v87;
        v91[1] = v88;
      }
      else
      {
        unint64_t *v91 = *(a2 - 2);
        v91[1] = *(a2 - 1);
        *(a2 - 2) = v87;
        *(a2 - 1) = v88;
        uint64_t v97 = (char *)v91 - (char *)k + 16;
        if (v97 >= 17)
        {
          unint64_t v98 = (v97 >> 4) - 2;
          unint64_t v99 = v98 >> 1;
          uint64_t v100 = &k[2 * (v98 >> 1)];
          unint64_t v101 = *v100;
          unint64_t v102 = *v91;
          if (*v100 < *v91)
          {
            unint64_t v103 = v91[1];
            goto LABEL_178;
          }
          if (v102 >= v101)
          {
            __n128 result = k[2 * v99 + 1];
            unint64_t v103 = v91[1];
            if (result < v103)
            {
LABEL_178:
              unint64_t *v91 = v101;
              v91[1] = k[2 * v99 + 1];
              if (v98 >= 2)
              {
                while (1)
                {
                  unint64_t v105 = v99 - 1;
                  unint64_t v99 = (v99 - 1) >> 1;
                  uint64_t v104 = &k[2 * v99];
                  unint64_t v106 = *v104;
                  if (*v104 >= v102)
                  {
                    if (v102 < v106) {
                      break;
                    }
                    __n128 result = k[2 * v99 + 1];
                    if (result >= v103) {
                      break;
                    }
                  }
                  else
                  {
                    __n128 result = v104[1];
                  }
                  *uint64_t v100 = v106;
                  v100[1] = result;
                  uint64_t v100 = &k[2 * v99];
                  if (v105 <= 1) {
                    goto LABEL_185;
                  }
                }
              }
              uint64_t v104 = v100;
LABEL_185:
              unint64_t *v104 = v102;
              v104[1] = v103;
            }
          }
        }
      }
      a2 -= 2;
      if (v85-- <= 2) {
        return result;
      }
      continue;
    }
  }
  return result;
}

unint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(unint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *result;
  if (*a2 >= *result && (v4 < v3 || a2[1] >= result[1]))
  {
    unint64_t v7 = *a3;
    if (*a3 < v3 || v3 >= v7 && a3[1] < a2[1])
    {
      *a2 = v7;
      *a3 = v3;
      id v8 = a2 + 1;
      unint64_t v9 = a2[1];
      a2[1] = a3[1];
      a3[1] = v9;
      unint64_t v10 = *a2;
      unint64_t v11 = *result;
      if (*a2 < *result || v11 >= v10 && *v8 < result[1])
      {
        *result++ = v10;
        *a2 = v11;
LABEL_18:
        unint64_t v15 = *result;
        *__n128 result = *v8;
        *id v8 = v15;
      }
    }
  }
  else
  {
    unint64_t v5 = *a3;
    if (*a3 < v3 || v3 >= v5 && a3[1] < a2[1])
    {
      *result++ = v5;
      *a3 = v4;
      id v6 = a3 + 1;
LABEL_17:
      id v8 = v6;
      goto LABEL_18;
    }
    *__n128 result = v3;
    *a2 = v4;
    unint64_t v12 = result[1];
    result[1] = a2[1];
    a2[1] = v12;
    unint64_t v13 = *a3;
    unint64_t v14 = *a2;
    if (*a3 < *a2 || v14 >= v13 && a3[1] < v12)
    {
      *a2 = v13;
      *a3 = v14;
      id v6 = a3 + 1;
      __n128 result = a2 + 1;
      goto LABEL_17;
    }
  }
  return result;
}

unint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  __n128 result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a2, a3);
  unint64_t v9 = *a4;
  unint64_t v10 = *a3;
  if (*a4 < *a3 || v10 >= v9 && a4[1] < a3[1])
  {
    *a3 = v9;
    *a4 = v10;
    unint64_t v11 = a3[1];
    a3[1] = a4[1];
    a4[1] = v11;
    unint64_t v12 = *a3;
    unint64_t v13 = *a2;
    if (*a3 < *a2 || v13 >= v12 && a3[1] < a2[1])
    {
      *a2 = v12;
      *a3 = v13;
      unint64_t v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      unint64_t v15 = *a2;
      unint64_t v16 = *a1;
      if (*a2 < *a1 || v16 >= v15 && a2[1] < a1[1])
      {
        *a1 = v15;
        *a2 = v16;
        unint64_t v17 = a1[1];
        a1[1] = a2[1];
        a2[1] = v17;
      }
    }
  }
  return result;
}

unint64_t *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  __n128 result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a2, a3, a4);
  unint64_t v11 = *a5;
  unint64_t v12 = *a4;
  if (*a5 < *a4 || v12 >= v11 && a5[1] < a4[1])
  {
    *a4 = v11;
    *a5 = v12;
    unint64_t v13 = a4[1];
    a4[1] = a5[1];
    a5[1] = v13;
    unint64_t v14 = *a4;
    unint64_t v15 = *a3;
    if (*a4 < *a3 || v15 >= v14 && a4[1] < a3[1])
    {
      *a3 = v14;
      *a4 = v15;
      unint64_t v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      unint64_t v17 = *a3;
      unint64_t v18 = *a2;
      if (*a3 < *a2 || v18 >= v17 && a3[1] < a2[1])
      {
        *a2 = v17;
        *a3 = v18;
        unint64_t v19 = a2[1];
        a2[1] = a3[1];
        a3[1] = v19;
        unint64_t v20 = *a2;
        unint64_t v21 = *a1;
        if (*a2 < *a1 || v21 >= v20 && a2[1] < a1[1])
        {
          *a1 = v20;
          *a2 = v21;
          unint64_t v22 = a1[1];
          a1[1] = a2[1];
          a2[1] = v22;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(unint64_t *a1, unint64_t *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v6 = *(a2 - 2);
      unint64_t v7 = *a1;
      if (v6 < *a1 || v7 >= v6 && *(a2 - 1) < a1[1])
      {
        *a1 = v6;
        *(a2 - 2) = v7;
        unint64_t v8 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      unint64_t v9 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a1 + 2, a1 + 4);
      unint64_t v10 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  do
  {
    unint64_t v13 = *v10;
    unint64_t v14 = *v9;
    if (*v10 >= *v9)
    {
      if (v14 < v13) {
        goto LABEL_23;
      }
      unint64_t v15 = v10[1];
      if (v15 >= v9[1]) {
        goto LABEL_23;
      }
    }
    else
    {
      unint64_t v15 = v10[1];
    }
    unint64_t *v10 = v14;
    v10[1] = v9[1];
    unint64_t v16 = a1;
    if (v9 == a1) {
      goto LABEL_22;
    }
    uint64_t v17 = v11;
    while (1)
    {
      unint64_t v18 = (char *)a1 + v17;
      unint64_t v19 = *(unint64_t *)((char *)a1 + v17 + 16);
      if (v13 < v19)
      {
        unint64_t v20 = *((void *)v18 + 3);
        goto LABEL_18;
      }
      if (v19 < v13)
      {
        unint64_t v16 = v9;
        goto LABEL_22;
      }
      unint64_t v20 = *(unint64_t *)((char *)a1 + v17 + 24);
      if (v15 >= v20) {
        break;
      }
LABEL_18:
      v9 -= 2;
      *((void *)v18 + 4) = v19;
      *(unint64_t *)((char *)a1 + v17 + 40) = v20;
      v17 -= 16;
      if (v17 == -32)
      {
        unint64_t v16 = a1;
        goto LABEL_22;
      }
    }
    unint64_t v16 = (unint64_t *)((char *)a1 + v17 + 32);
LABEL_22:
    *unint64_t v16 = v13;
    v16[1] = v15;
    if (++v12 == 8) {
      return v10 + 2 == a2;
    }
LABEL_23:
    unint64_t v9 = v10;
    v11 += 16;
    v10 += 2;
  }
  while (v10 != a2);
  return 1;
}

void GTUSCSamplingStreamingManagerHelper::SetupSourceForFrameTime(id *this, uint64_t a2, int a3)
{
  unint64_t v6 = [this[2] firstObject];
  if ([this[3] count])
  {
    if (!GTAGXPerfStateControl::IsGPUPerformanceStateInduced((GTAGXPerfStateControl *)(this + 5)))
    {
      uint64_t v7 = *((unsigned int *)*this + 18);
      if (v7)
      {
        GTAGXPerfStateControl::EnableConsistentGPUPerfState((uint64_t)(this + 5), v7);
        uint64_t v8 = GTApplePMPPerfStateControl::EnableConsistentPerfState((GTApplePMPPerfStateControl *)(this + 8), *((_DWORD *)*this + 18) - 1);
        id v9 = this[261];
        this[261] = (id)v8;
      }
      else
      {
        uint64_t v10 = GTApplePMPPerfStateControl::EnableConsistentPerfState((GTApplePMPPerfStateControl *)(this + 8), 1u);
        id v11 = this[261];
        this[261] = (id)v10;

        CFStringRef v19 = @"LockGPUPerfState";
        int v12 = +[NSNumber numberWithUnsignedInt:a2];
        unint64_t v20 = v12;
        unint64_t v13 = +[NSDictionary dictionaryWithObjects:&v20 forKeys:&v19 count:1];
        [v6 setOptions:v13];
      }
    }
    unint64_t v14 = [this[3] lastObject];
    unint64_t v15 = v14;
    if (!a3) {
      goto LABEL_7;
    }
    if (([v14 requestTriggers:this[257] firstErrorIndex:0] & 1) == 0)
    {
      uint64_t v17 = [v15 name];
      NSLog(@"Fail, error while requesting triggers for %@", v17);
    }
    [v15 setOptions:0];
    if ([v15 requestCounters:this[249] firstErrorIndex:0])
    {
LABEL_7:
      if ([v15 setEnabled:1])
      {
LABEL_10:

        goto LABEL_11;
      }
      unint64_t v16 = [v15 name];
      NSLog(@"Fail, error while enabling source[%@]", v16);
    }
    else
    {
      id v18 = [this[249] count];
      unint64_t v16 = [v15 name];
      NSLog(@"Fail, error while requesting %lu counter for source[%@]", v18, v16);
    }

    goto LABEL_10;
  }
LABEL_11:
}

void sub_1DEF5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GTUSCSamplingStreamingManagerHelper::DrainRawFrameData(id *this)
{
  if ([this[3] count])
  {
    unsigned __int8 v2 = [this[3] firstObject];
    unint64_t v3 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v2 ringBufferNum]);

    uint64_t v4 = [this[3] lastObject];
    if ([v4 isEnabled])
    {
      for (uint64_t i = 0; ; uint64_t i = (i + 1))
      {
        if (i >= [v4 ringBufferNum])
        {
          id v12 = v3;
          goto LABEL_16;
        }
        uint64_t v16 = 0;
        uint64_t v17 = 0;
        unsigned int v15 = 0;
        if (([v4 ringBufferInfoAtIndex:i base:&v17 size:(char *)&v16 + 4 dataOffset:&v16 dataSize:&v15] & 1) == 0)break; {
        unint64_t v6 = +[NSMutableData dataWithCapacity:v15];
        }
        uint64_t v7 = v6;
        unsigned int v8 = v15;
        if (v15 + v16 <= HIDWORD(v16))
        {
          [v6 appendBytes:v17 + v16 length:v15];
        }
        else
        {
          int v9 = HIDWORD(v16) - v16;
          [v6 appendBytes:v17 + v16 length:(HIDWORD(v16) - v16)];
          [v7 appendBytes:v17 length:v8 - v9];
        }
        unsigned int v10 = [v4 drainRingBufferAtIndex:i dataSize:v15];
        if (v10 != v15)
        {
          id v11 = [v4 name];
          NSLog(@"Fail, unexpected drain count for source %@!", v11);
        }
        [v3 addObject:v7];
      }
      unint64_t v13 = [v4 name];
      NSLog(@"Fail, unable to retrieve ring buffer info from source %@!", v13);
    }
    id v12 = 0;
LABEL_16:
  }
  else
  {
    id v12 = 0;
  }

  return v12;
}

void sub_1DF1B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GTUSCSamplingStreamingManagerHelper::PostProcessFrameData(id *a1, void *a2)
{
  id v3 = a2;
  if ([v3 count])
  {
    GTUSCSamplingStreamingManagerHelper::ResetSourceForPostProcessing(a1);
    uint64_t v4 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v3 count]);
    unint64_t v5 = [a1[3] lastObject];
    for (unint64_t i = 0; ; ++i)
    {
      if (i >= (unint64_t)[v3 count])
      {
        id v15 = v4;
        goto LABEL_11;
      }
      uint64_t v7 = [v3 objectAtIndexedSubscript:i];
      unsigned int v8 = (char *)[v7 length];
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      unint64_t v9 = 4 * (void)[v7 length];
      if (v9 <= 0x4000) {
        unint64_t v9 = 0x4000;
      }
      unint64_t v10 = (v9 + 7) & 0xFFFFFFFFFFFFFFF8;
      id v11 = +[NSMutableData dataWithLength:v10];
      id v12 = v7;
      id v13 = [v12 bytes];
      id v14 = v11;
      LOBYTE(v17) = 1;
      if ((objc_msgSend(v5, "postProcessRawDataWithRingBufferIndex:source:sourceSize:sourceRead:sourceWrite:output:outputSize:outputRead:outputWrite:isLast:", i, v13, v8 + 8, &v19, v8, objc_msgSend(v14, "mutableBytes"), v10, 0, &v18, v17) & 1) == 0)break; {
      [v14 setLength:v18];
      }
      [v4 addObject:v14];
    }
    id v15 = 0;
LABEL_11:
  }
  else
  {
    id v15 = 0;
  }

  return v15;
}

void sub_1DF3D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__483(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__484(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<std::unordered_map<unsigned int,GTEncoderSampleIndexInfo>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

void std::vector<std::tuple<unsigned long long,unsigned long long,unsigned long long>>::reserve(void **a1, unint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v3 = ((unsigned char *)a1[1] - (unsigned char *)*a1) / 24;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(a2);
    unint64_t v5 = &v4[24 * v3];
    uint64_t v7 = &v4[24 * v6];
    unint64_t v9 = (char *)*a1;
    unsigned int v8 = (char *)a1[1];
    unint64_t v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        long long v11 = *(_OWORD *)(v8 - 24);
        *((void *)v10 - 1) = *((void *)v8 - 1);
        *(_OWORD *)(v10 - 24) = v11;
        v10 -= 24;
        v8 -= 24;
      }
      while (v8 != v9);
      unsigned int v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void ___ZN35GTUSCSamplingStreamingManagerHelper19StreamFrameTimeDataEv_block_invoke(uint64_t a1)
{
  unsigned __int8 v2 = *(id **)(a1 + 48);
  GTMTLReplayController_prePlayForProfiling(*(void *)*v2);
  GTUSCSamplingStreamingManagerHelper::SetupSourceForFrameTime(v2, *(unsigned int *)(a1 + 56), *(_DWORD *)(a1 + 60) == 0);
  DisableComputeEncoderCoalescing(*(GTMTLReplayController **)*v2, 1);
  uint64_t v3 = [v2[2] firstObject];
  [v3 startSampling];

  uint64_t v35 = a1;
  unsigned int v5 = *(_DWORD *)(a1 + 60);
  uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 48);
  unint64_t v47 = *(unsigned int **)*v2;
  uint64_t v7 = (uint64_t)v47;
  char v48 = 0;
  id v46 = [(id)g_commandBufferDescriptor errorOptions];
  [(id)g_commandBufferDescriptor setErrorOptions:0];
  id v8 = *(id *)(*(void *)*v2 + 8);
  uint64_t v41 = **(void **)*v2;
  id v42 = v8;
  uint64_t v34 = *(void *)(v41 + 16);
  unint64_t v9 = [v8 defaultDevice];
  id v39 = [v9 newCommandQueue];

  unint64_t v10 = [v42 defaultDevice];
  unint64_t v36 = v4;
  uint64_t v38 = v2;
  id v40 = [v10 newEvent];
  long long v11 = v47 + 5620;

  unsigned __int8 v45 = 0;
  uint64_t v44 = *(void *)(*(void *)v47 + 120);
  unsigned int v43 = *(_DWORD *)(v44 + 12);
  if (v47[5620] < v43)
  {
    unint64_t v37 = (void *)(v6 + 40 * v5);
    do
    {
      uint64_t v13 = *(void *)(v44 + 24);
      uint64_t v14 = *v11;
      uint64_t v15 = v13 + (v14 << 6);
      int v17 = *(_DWORD *)(v15 + 8);
      uint64_t v16 = (int *)(v15 + 8);
      if (GetFuncEnumConstructorType(v17) == 25) {
        int v18 = GTMTLReplayController_restoreCommandBuffer(v7, v13 + (v14 << 6));
      }
      else {
        int v18 = 0;
      }
      GTMTLReplayController_updateCommandEncoder(v7, v13 + (v14 << 6));
      DispatchFunction((id *)v7, v13 + (v14 << 6), &v45);
      if (GetFuncEnumConstructorType(*v16) == 21)
      {
        uint64_t v27 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)(v13 + (v14 << 6)), *(unsigned __int8 *)(v13 + (v14 << 6) + 13), v34)+ 1);
        if (std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>(v37, [v42 globalTraceIdForEncoder:v27 ofType:0]))
        {
          unint64_t v33 = [v42 blitCommandEncoderForKey:v27];
          [v33 endEncoding];
          unint64_t v32 = [v42 commandBufferForKey:GTTraceFunc_targetContext(v13 + (v14 << 6), *(void *)(v41 + 16))];
          unint64_t v28 = [v32 computeCommandEncoder];
          [v28 endEncoding];
          DispatchFunction((id *)v7, v13 + (v14 << 6), &v45);
        }
      }
      if (v18)
      {
        uint64_t v19 = [v42 commandBufferForKey:*(void *)GTTraceFunc_argumentBytesWithMap((void *)(v13 + (v14 << 6)), *(unsigned __int8 *)(v13 + (v14 << 6) + 13), *(void *)(v41 + 16))+ 1];
        ++GTUSCSamplingStreamingManagerHelper::ReplayForTimingCounters(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &)::signalCounter;
        [v19 encodeSignalEvent:v40];
        unint64_t v20 = [v39 commandBuffer];
        [v20 encodeWaitForEvent:v40 value:GTUSCSamplingStreamingManagerHelper::ReplayForTimingCounters(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &)::signalCounter++];
        [v20 encodeSignalEvent:v40];
        [v20 commit];
        [v19 encodeWaitForEvent:v40 value:GTUSCSamplingStreamingManagerHelper::ReplayForTimingCounters(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &)::signalCounter];
      }
      else
      {
        int v21 = *v16;
        if (!GTMTLReplayHost_IsFuncEnumSampledEncoder(v21, 1, 0)) {
          goto LABEL_13;
        }
        int FuncEnumConstructorType = GetFuncEnumConstructorType(v21);
        int v23 = v45;
        if (v45 != (FuncEnumConstructorType == 65)) {
          goto LABEL_13;
        }
        uint64_t v24 = FuncEnumConstructorType == 65;
        uint64_t v25 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)(v13 + (v14 << 6)), *(unsigned __int8 *)(v13 + (v14 << 6) + 13), *(void *)(v41 + 16))+ 1);
        LODWORD(v24) = [v42 globalTraceIdForEncoder:v25 ofType:v24];
        uint64_t v19 = [v42 encoderForKey:v25 ofType:v23 != 0];
        GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(v38, v37, v13 + (v14 << 6), v24, v19, v37[3], 0, 0);
      }

LABEL_13:
      unsigned int v26 = *v11 + 1;
      *long long v11 = v26;
    }
    while (v26 < v43);
  }
  *(_DWORD *)(v7 + 22484) = 0;
  unint64_t v29 = [*(id *)(v7 + 8) defaultCommandQueue];
  [v29 finish];

  ScopedReplayConfiguration::~ScopedReplayConfiguration((ScopedReplayConfiguration *)&v46);
  unint64_t v30 = GTUSCSamplingStreamingManagerHelper::DrainRawFrameData(v38);
  if (v30) {
    [*(id *)(v35 + 32) setArray:v30];
  }

  unint64_t v31 = [v38[2] firstObject];
  [v31 stopSampling];

  DisableComputeEncoderCoalescing(*(GTMTLReplayController **)*v38, 0);
  GTAGXPerfStateControl::DisableConsistentGPUPerfState((GTAGXPerfStateControl *)(v38 + 5));

  GTApplePMPPerfStateControl::DisableConsistentPerfState((GTApplePMPPerfStateControl *)(v38 + 8));
}

void sub_1DFA2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, uint64_t a19, void *a20)
{
  ScopedReplayConfiguration::~ScopedReplayConfiguration((ScopedReplayConfiguration *)(v20 - 104));
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper19StreamFrameTimeDataEv_block_invoke_2(uint64_t a1)
{
  unsigned __int8 v2 = *(void **)(a1 + 40);
  uint64_t v3 = GTSampleBufferManager::ResolveSampleBuffers((GTSampleBufferManager *)(v2 + 263));
  if (v3)
  {
    id v5 = v3;
    uint64_t v4 = [*(id *)(a1 + 32) objectAtIndexedSubscript:*(unsigned int *)(a1 + 48)];
    [v4 setData:v5];

    uint64_t v3 = v5;
  }
  v2[269] = 0;
  v2[267] = v2[266];
}

void sub_1DFB88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper19StreamFrameTimeDataEv_block_invoke_3(uint64_t a1)
{
  unsigned __int8 v2 = *(id **)(a1 + 48);
  uint64_t v4 = GTUSCSamplingStreamingManagerHelper::PostProcessFrameData(v2, *(void **)(a1 + 32));
  if (v4) {
    [*(id *)(a1 + 40) addObject:v4];
  }
}

void sub_1DFC18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<unsigned int>::reserve(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  if (__n > this->__end_cap_.__value_ - this->__begin_)
  {
    if (__n >> 62) {
      abort();
    }
    int64_t v3 = (char *)this->__end_ - (char *)this->__begin_;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::IntersectionFunctionTag>>(__n);
    id v5 = (unsigned int *)&v4[v3 & 0xFFFFFFFFFFFFFFFCLL];
    uint64_t v7 = (unsigned int *)&v4[4 * v6];
    std::vector<unsigned int>::pointer begin = this->__begin_;
    std::vector<unsigned int>::pointer end = this->__end_;
    unint64_t v10 = v5;
    if (end != this->__begin_)
    {
      unint64_t v10 = v5;
      do
      {
        unsigned int v11 = *--end;
        *--unint64_t v10 = v11;
      }
      while (end != begin);
    }
    this->__begin_ = v10;
    this->__end_ = v5;
    this->__end_cap_.__value_ = v7;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

void std::vector<std::unordered_map<unsigned int,GTEncoderSampleIndexInfo>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  unsigned __int8 v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    id v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v4 - 40);
      while ((void *)v4 != v2);
      id v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void ___ZN35GTUSCSamplingStreamingManagerHelper18CalculateFrameTimeEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(uint64_t ***)(a1 + 40);
  GTMTLReplayController_prePlayForProfiling(**v1);
  unsigned __int8 v2 = (id *)**v1;
  id v14 = v2[1];
  int64_t v3 = *v2;
  uint64_t v4 = v2 + 2810;
  if (*((void *)*v2 + 13) + *((void *)*v2 + 12) > (unint64_t)*((unsigned int *)v2 + 5620))
  {
    uint64_t v5 = v3[2];
    do
    {
      uint64_t v7 = *(void *)(v3[15] + 24);
      uint64_t v8 = *v4;
      int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v7 + (v8 << 6) + 8));
      if (FuncEnumConstructorType == 25) {
        GTMTLReplayController_restoreCommandBuffer((uint64_t)v2, v7 + (v8 << 6));
      }
      GTMTLReplayController_updateCommandEncoder((uint64_t)v2, v7 + (v8 << 6));
      GTMTLReplayController_defaultDispatchFunction((uint64_t)v2, v7 + (v8 << 6));
      if (FuncEnumConstructorType == 25)
      {
        unint64_t v10 = [v14 commandBufferForKey:*(void *)GTTraceFunc_argumentBytesWithMap((void *)(v7 + (v8 << 6)), *(unsigned __int8 *)(v7 + (v8 << 6) + 13), v5)+ 1];
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 3221225472;
        v15[2] = ___ZN35GTUSCSamplingStreamingManagerHelper18CalculateFrameTimeEv_block_invoke_2;
        v15[3] = &unk_744860;
        v15[4] = *(void *)(a1 + 32);
        [v10 addCompletedHandler:v15];
      }
      unint64_t v11 = (*v4 + 1);
      *uint64_t v4 = v11;
    }
    while (v3[13] + v3[12] > v11);
  }
  id v12 = [v2[1] defaultCommandQueue];
  [v12 finish];
}

void sub_1DFF10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper18CalculateFrameTimeEv_block_invoke_2(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  [v3 GPUStartTime];
  uint64_t v5 = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
  v8[0] = v5;
  [v3 GPUEndTime];
  uint64_t v6 = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
  v8[1] = v6;
  uint64_t v7 = +[NSArray arrayWithObjects:v8 count:2];
  [v4 addObject:v7];
}

void sub_1E0038(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GTUSCSamplingStreamingManagerHelper::GatherFrameMiscEncoderPostProcessedData(char a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v19 = a2;
  id v21 = a3;
  id v9 = a5;
  v29[0] = _NSConcreteStackBlock;
  v29[1] = 3221225472;
  v29[2] = ___ZN35GTUSCSamplingStreamingManagerHelper39GatherFrameMiscEncoderPostProcessedDataEbP14NSMutableArrayIP6NSDataEP13NSMutableDataRNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS7_4hashIjEENS7_8equal_toIjEENS7_9allocatorINS7_4pairIKjS9_EEEEEEP11NSOperation_block_invoke;
  v29[3] = &unk_744888;
  unint64_t v31 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
  uint64_t v32 = a4;
  char v33 = a1;
  id v10 = (id)objc_opt_new();
  id v30 = v10;
  unint64_t v11 = +[NSBlockOperation blockOperationWithBlock:v29];
  id v12 = v11;
  if (v9) {
    [v11 addDependency:v9, v19, v21];
  }
  [*(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v12 v19];
  [v12 setQueuePriority:-8];
  uint64_t v13 = objc_opt_new();
  if (dword_77286C && dword_772868)
  {
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 3221225472;
    v26[2] = ___ZN35GTUSCSamplingStreamingManagerHelper39GatherFrameMiscEncoderPostProcessedDataEbP14NSMutableArrayIP6NSDataEP13NSMutableDataRNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS7_4hashIjEENS7_8equal_toIjEENS7_9allocatorINS7_4pairIKjS9_EEEEEEP11NSOperation_block_invoke_2;
    v26[3] = &unk_7463C0;
    unint64_t v28 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
    id v27 = v21;
    id v14 = +[NSBlockOperation blockOperationWithBlock:v26];
    [v14 addDependency:v12];
    [v13 addDependency:v14];
    [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v14];
  }
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  v22[2] = ___ZN35GTUSCSamplingStreamingManagerHelper39GatherFrameMiscEncoderPostProcessedDataEbP14NSMutableArrayIP6NSDataEP13NSMutableDataRNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS7_4hashIjEENS7_8equal_toIjEENS7_9allocatorINS7_4pairIKjS9_EEEEEEP11NSOperation_block_invoke_3;
  v22[3] = &unk_745EA8;
  uint64_t v25 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
  id v15 = v10;
  id v23 = v15;
  id v16 = v20;
  id v24 = v16;
  int v17 = +[NSBlockOperation blockOperationWithBlock:v22];
  [v17 addDependency:v12];
  [v13 addDependency:v17];
  [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:v17];
  [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:v13];

  return v13;
}

void sub_1E0364(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper39GatherFrameMiscEncoderPostProcessedDataEbP14NSMutableArrayIP6NSDataEP13NSMutableDataRNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS7_4hashIjEENS7_8equal_toIjEENS7_9allocatorINS7_4pairIKjS9_EEEEEEP11NSOperation_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  GTMTLReplayController_prePlayForProfiling(**(void **)v2);
  GTUSCSamplingStreamingManagerHelper::SetupSourceForFrameTime((id *)v2, *(unsigned int *)(*(void *)v2 + 68), 0);
  int64_t v63 = (GTUSCSamplingStreamingManagerHelper *)v2;
  id v3 = [*(id *)(v2 + 16) firstObject];
  unsigned __int8 v4 = [v3 startSampling];

  if (v4)
  {
    int64_t v62 = *(void **)(a1 + 48);
    int v65 = *(unsigned __int8 *)(a1 + 56);
    uint64_t v67 = **(void **)v63;
    v70[1] = v67;
    char v71 = 0;
    v70[0] = [(id)g_commandBufferDescriptor errorOptions];
    [(id)g_commandBufferDescriptor setErrorOptions:0];
    id v6 = *(id *)(**(void **)v63 + 8);
    uint64_t v7 = ***(uint64_t ****)v63;
    uint64_t v56 = v7[15];
    uint64_t v57 = v7[14];
    uint64_t v8 = [v6 defaultDevice];
    id v9 = [v8 newEvent];

    id v10 = [v6 defaultCommandQueue];
    unint64_t v11 = [v10 commandBuffer];
    uint64_t v53 = v5;
    uint64_t v54 = a1;

    unint64_t v60 = v9;
    [v11 encodeSignalEvent:v9 value:GTUSCSamplingStreamingManagerHelper::ReplayFrameWithMiscEncoderSyncEvents(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &,BOOL)::signalCounter];
    [v11 commit];
    unint64_t v55 = v11;
    if (v7[13] + v7[12] > (unint64_t)*(unsigned int *)(**(void **)v63 + 22480))
    {
      uint64_t v61 = 0;
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      uint64_t v58 = (unsigned int *)(v67 + 22480);
      int64_t v64 = v6;
      do
      {
        uint64_t v15 = *(void *)(v7[15] + 24);
        uint64_t v16 = *v58;
        uint64_t v17 = v15 + (v16 << 6);
        uint64_t v68 = (int *)(v17 + 8);
        int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v17 + 8));
        if (FuncEnumConstructorType == 25)
        {
          GTMTLReplayController_restoreCommandBuffer(v67, v15 + (v16 << 6));
          uint64_t v61 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)(v15 + (v16 << 6)), *(unsigned __int8 *)(v15 + (v16 << 6) + 13), v7[2])+ 1);
          int FuncEnumConstructorType = GetFuncEnumConstructorType(*v68);
        }
        if ((FuncEnumConstructorType | 4) == 0x15)
        {
          id v19 = [v6 commandBufferForKey:v61];
          [v19 encodeWaitForEvent:v60 value:GTUSCSamplingStreamingManagerHelper::ReplayFrameWithMiscEncoderSyncEvents(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &,BOOL)::signalCounter++];
          [v19 encodeSignalEvent:v60];
          uint64_t v12 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)(v15 + (v16 << 6)), *(unsigned __int8 *)(v15 + (v16 << 6) + 13), v7[2])+ 1);
          if (v65)
          {
            InclusiveRange = GroupBuilder_findInclusiveRange(*(_DWORD *)(v57 + 12), *(void **)(v57 + 24), *v58);
            unint64_t v21 = InclusiveRange[1];
            unint64_t v22 = v21 - *InclusiveRange;
            if (v21 <= *InclusiveRange)
            {
              uint64_t v14 = v13;
            }
            else
            {
              id v23 = (int *)(*(void *)(v56 + 24) + (*InclusiveRange << 6) + 8);
              uint64_t v14 = v13;
              do
              {
                int v25 = *v23;
                v23 += 16;
                int v24 = v25;
                if (IsFuncEnumSampledBlitCall(v25) || IsFuncEnumSampledBlitCallAGX(v24)) {
                  ++v14;
                }
                uint64_t v13 = v14;
                --v22;
              }
              while (v22);
            }
          }

          uint64_t v26 = v14;
          id v6 = v64;
        }
        else
        {
          uint64_t v26 = v14;
        }
        GTMTLReplayController_updateCommandEncoder(v67, v17);
        uint64_t v66 = v12;
        if (v65 && ((int v27 = *v68, IsFuncEnumSampledBlitCall(*v68)) || IsFuncEnumSampledBlitCallAGX(v27)))
        {
          uint64_t v14 = v26 - 1;
          if (v26 && v13 != v26)
          {
            unint64_t v28 = [v6 blitCommandEncoderForKey:v12];
            [v28 endEncoding];
            unint64_t v29 = [v6 commandBufferForKey:v61];
            [v29 encodeWaitForEvent:v60 value:GTUSCSamplingStreamingManagerHelper::ReplayFrameWithMiscEncoderSyncEvents(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &,BOOL)::signalCounter++];
            [v29 encodeSignalEvent:v60];
            id v30 = [v29 blitCommandEncoder];
            if (std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>(v62, [v30 globalTraceObjectID]))
            {
              [v30 endEncoding];
              unint64_t v31 = [v29 computeCommandEncoder];
              [v31 endEncoding];
              uint64_t v32 = [v29 blitCommandEncoder];

              id v30 = (void *)v32;
              uint64_t v12 = v66;
            }
            [v64 setBlitCommandEncoder:v30 forKey:v12];
            unsigned int v33 = [v64 globalTraceIdForEncoder:v12 ofType:0];
            memset(v72, 0, sizeof(v72));
            DWORD2(v72[0]) = -16354;
            GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(v63, v62, (uint64_t)v72, v33, v30, v62[3], 0, 0);

            id v6 = v64;
          }
        }
        else
        {
          uint64_t v14 = v26;
        }
        GTMTLReplayController_defaultDispatchFunction(v67, v17);
        int v34 = *v68;
        if (GetFuncEnumConstructorType(*v68) == 21)
        {
          unsigned int v35 = [v6 globalTraceIdForEncoder:v12 ofType:0];
          uint64_t v36 = v12;
          unsigned int v37 = v35;
          uint64_t v38 = [v6 blitCommandEncoderForKey:v36];
          if (std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>(v62, v37))
          {
            [v38 endEncoding];
            id v39 = [v6 commandBufferForKey:GTTraceFunc_targetContext(v17, v7[2])];
            id v40 = [v39 computeCommandEncoder];
            [v40 endEncoding];
            GTMTLReplayController_defaultDispatchFunction(v67, v17);
            unsigned int v37 = [v64 globalTraceIdForEncoder:v66 ofType:0];

            id v6 = v64;
          }
          GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(v63, v62, v17, v37, v38, v62[3], 0, 0);
          uint64_t v12 = v66;

          int v34 = *v68;
        }
        if (!v65 && v34 == -16376)
        {
          uint64_t v41 = [v6 commandBufferForKey:v61];
          [v41 encodeWaitForEvent:v60 value:GTUSCSamplingStreamingManagerHelper::ReplayFrameWithMiscEncoderSyncEvents(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &,BOOL)::signalCounter++];
          [v41 encodeSignalEvent:v60];

          int v34 = *v68;
        }
        if (GetFuncEnumConstructorType(v34) == 17)
        {
          unsigned int v42 = [v6 globalTraceIdForEncoder:v12 ofType:0];
          uint64_t v43 = v12;
          unsigned int v44 = v42;
          unsigned __int8 v45 = [v6 accelerationStructureCommandEncoderForKey:v43];
          if (std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>(v62, v44))
          {
            [v45 endEncoding];
            id v46 = [v6 commandBufferForKey:GTTraceFunc_targetContext(v17, v7[2])];
            unint64_t v47 = [v46 computeCommandEncoder];
            [v47 endEncoding];
            GTMTLReplayController_defaultDispatchFunction(v67, v17);
            unsigned int v44 = [v64 globalTraceIdForEncoder:v66 ofType:0];

            id v6 = v64;
          }
          GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(v63, v62, v17, v44, v45, v62[3], 0, 0);
          uint64_t v12 = v66;

          int v34 = *v68;
        }
        if (v34 == -15642)
        {
          char v48 = [v6 commandBufferForKey:v61];
          [v48 encodeWaitForEvent:v60 value:GTUSCSamplingStreamingManagerHelper::ReplayFrameWithMiscEncoderSyncEvents(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &,BOOL)::signalCounter++];
          [v48 encodeSignalEvent:v60];
        }
        uint64_t v49 = **(void **)v63;
        unint64_t v50 = (*(_DWORD *)(v49 + 22480) + 1);
        *(_DWORD *)(v49 + 22480) = v50;
      }
      while (v7[13] + v7[12] > v50);
    }
    uint64_t v51 = [*(id *)(v67 + 8) defaultCommandQueue];
    [v51 finish];

    ScopedReplayConfiguration::~ScopedReplayConfiguration((ScopedReplayConfiguration *)v70);
    int v52 = GTUSCSamplingStreamingManagerHelper::DrainRawFrameData((id *)v63);
    if (v52) {
      [*(id *)(v54 + 32) setArray:v52];
    }

    id v69 = [*((id *)v63 + 2) firstObject];
    [v69 stopSampling];
  }
}

void sub_1E0C04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id a25,char a26)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper39GatherFrameMiscEncoderPostProcessedDataEbP14NSMutableArrayIP6NSDataEP13NSMutableDataRNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS7_4hashIjEENS7_8equal_toIjEENS7_9allocatorINS7_4pairIKjS9_EEEEEEP11NSOperation_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  GTSampleBufferManager::ResolveSampleBuffers((GTSampleBufferManager *)(v2 + 263));
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  if (v3) {
    [*(id *)(a1 + 32) setData:v3];
  }
  v2[269] = 0;
  v2[267] = v2[266];
}

void sub_1E0DAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper39GatherFrameMiscEncoderPostProcessedDataEbP14NSMutableArrayIP6NSDataEP13NSMutableDataRNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS7_4hashIjEENS7_8equal_toIjEENS7_9allocatorINS7_4pairIKjS9_EEEEEEP11NSOperation_block_invoke_3(uint64_t a1)
{
  GTUSCSamplingStreamingManagerHelper::PostProcessFrameData(*(id **)(a1 + 48), *(void **)(a1 + 32));
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  if (v2) {
    [*(id *)(a1 + 40) setArray:v2];
  }
}

void sub_1E0E20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManagerHelper::StreamEncoderDerivedCounterData(GTUSCSamplingStreamingManagerHelper *this)
{
  unsigned __int8 v1 = atomic_load(byte_772AF4);
  if (v1) {
    return;
  }
  id v171 = [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 48) objectForKeyedSubscript:@"DerivedCounterDictionary"];
  if (qword_7728A8 == -1)
  {
    id v9 = [v171 objectForKeyedSubscript:@"DerivedCounters"];
    id v10 = [v9 mutableCopy];

    long long v199 = v10;
    unint64_t v11 = [v10 objectForKeyedSubscript:@"CSInvocation"];
    id v179 = [v11 objectForKeyedSubscript:@"counters"];

    goto LABEL_13;
  }
  std::string::basic_string[abi:nn180100]<0>(&__p, "CSInvocation");
  CountersForDerivedCounter = GTAGXProfilingSupportHelper::GetCountersForDerivedCounter((uint64_t)&__p);
  id v3 = CountersForDerivedCounter;
  if (SHIBYTE(v264) < 0)
  {
    operator delete(__p);
    if (v3) {
      goto LABEL_5;
    }
LABEL_12:
    long long v199 = 0;
    id v179 = 0;
    goto LABEL_13;
  }
  if (!CountersForDerivedCounter) {
    goto LABEL_12;
  }
LABEL_5:
  unsigned __int8 v4 = +[NSMutableArray arrayWithCapacity:0xAAAAAAAAAAAAAAABLL * ((v3[1] - *v3) >> 3)];
  uint64_t v5 = *v3;
  uint64_t v6 = v3[1];
  if (*v3 != v6)
  {
    do
    {
      uint64_t v7 = v5;
      if (*(char *)(v5 + 23) < 0) {
        uint64_t v7 = *(void *)v5;
      }
      uint64_t v8 = +[NSString stringWithUTF8String:v7];
      [v4 addObject:v8];

      v5 += 24;
    }
    while (v5 != v6);
  }
  id v179 = [v4 copy];

  long long v199 = 0;
LABEL_13:
  unint64_t v185 = +[NSSet setWithArray:v179];
  long long v198 = +[NSMutableSet setWithCapacity:](NSMutableSet, "setWithCapacity:", [&off_758A50 count]);
  if (qword_7728A8 == -1)
  {
    long long v295 = 0u;
    long long v294 = 0u;
    long long v293 = 0u;
    long long v292 = 0u;
    id v12 = [&off_758A50 countByEnumeratingWithState:&v292 objects:v310 count:16];
    if (v12)
    {
      uint64_t v13 = *(void *)v293;
      do
      {
        for (unint64_t i = 0; i != v12; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v293 != v13) {
            objc_enumerationMutation(&off_758A50);
          }
          uint64_t v15 = [v199 objectForKeyedSubscript:*(void *)(*((void *)&v292 + 1) + 8 * i)];
          uint64_t v16 = v15;
          if (v15)
          {
            uint64_t v17 = [v15 objectForKeyedSubscript:@"counters"];
            if (v17) {
              [v198 addObjectsFromArray:v17];
            }
          }
        }
        id v12 = [&off_758A50 countByEnumeratingWithState:&v292 objects:v310 count:16];
      }
      while (v12);
    }
  }
  if (qword_7727E8)
  {
    int v18 = [(id)qword_7727E8 objectForKeyedSubscript:@"num_cores"];
    unsigned int v19 = [v18 unsignedIntValue];

    uint64_t v20 = [(id)qword_7727E8 objectForKeyedSubscript:@"num_mgpus"];
    unsigned int v21 = [v20 unsignedIntValue];

    if (v21 <= 1) {
      unsigned int v22 = 1;
    }
    else {
      unsigned int v22 = v21;
    }
    BOOL v23 = v19 / v22 > 4;
  }
  else
  {
    BOOL v23 = 1;
  }
  BOOL v194 = v23;
  long long v202 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v179 count]);
  if (v194)
  {
    long long v291 = 0u;
    long long v290 = 0u;
    long long v289 = 0u;
    long long v288 = 0u;
    id v24 = v179;
    id v25 = [v24 countByEnumeratingWithState:&v288 objects:v309 count:16];
    if (v25)
    {
      uint64_t v26 = *(void *)v289;
      do
      {
        for (uint64_t j = 0; j != v25; uint64_t j = (char *)j + 1)
        {
          if (*(void *)v289 != v26) {
            objc_enumerationMutation(v24);
          }
          unint64_t v28 = +[GPURawCounterSelect selectWithName:*(void *)(*((void *)&v288 + 1) + 8 * (void)j) options:0];
          [v202 addObject:v28];
        }
        id v25 = [v24 countByEnumeratingWithState:&v288 objects:v309 count:16];
      }
      while (v25);
    }
  }
  if (qword_7728A8 == -1)
  {
    CFStringRef v307 = @"FRGTicks";
    unint64_t v31 = [v199 objectForKeyedSubscript:];
    v308 = v31;
    uint64_t v32 = +[NSDictionary dictionaryWithObjects:&v308 forKeys:&v307 count:1];
    GTMTLReplayHost_rawCounters(v32);
    id v30 = (uint64_t **)objc_claimAutoreleasedReturnValue();

LABEL_51:
    goto LABEL_52;
  }
  std::string::basic_string[abi:nn180100]<0>(&__p, "FRGTicks");
  unint64_t v29 = GTAGXProfilingSupportHelper::GetCountersForDerivedCounter((uint64_t)&__p);
  id v30 = (uint64_t **)v29;
  if ((SHIBYTE(v264) & 0x80000000) == 0)
  {
    if (!v29) {
      goto LABEL_52;
    }
    goto LABEL_46;
  }
  operator delete(__p);
  if (v30)
  {
LABEL_46:
    unint64_t v31 = objc_opt_new();
    unsigned int v33 = *v30;
    int v34 = v30[1];
    if (*v30 != v34)
    {
      do
      {
        unsigned int v35 = v33;
        if (*((char *)v33 + 23) < 0) {
          unsigned int v35 = (uint64_t *)*v33;
        }
        uint64_t v36 = +[NSString stringWithUTF8String:v35];
        [v31 addObject:v36];

        v33 += 3;
      }
      while (v33 != v34);
    }
    id v30 = (uint64_t **)[v31 copy];
    goto LABEL_51;
  }
LABEL_52:
  uint64_t v37 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v30 count]);
  uint64_t v38 = (void *)qword_7727F8;
  qword_7727F8 = v37;

  long long v287 = 0u;
  long long v286 = 0u;
  long long v285 = 0u;
  long long v284 = 0u;
  obuint64_t j = v30;
  id v39 = [obj countByEnumeratingWithState:&v284 objects:v306 count:16];
  if (v39)
  {
    uint64_t v40 = *(void *)v285;
    do
    {
      for (uint64_t k = 0; k != v39; uint64_t k = (char *)k + 1)
      {
        if (*(void *)v285 != v40) {
          objc_enumerationMutation(obj);
        }
        unsigned int v42 = +[GPURawCounterSelect selectWithName:*(void *)(*((void *)&v284 + 1) + 8 * (void)k) options:&off_758E78];
        [(id)qword_7727F8 addObject:v42];
      }
      id v39 = [obj countByEnumeratingWithState:&v284 objects:v306 count:16];
    }
    while (v39);
  }

  if (qword_7728A8 == -1)
  {
    unint64_t v47 = GTMTLReplayHost_rawCounters(v199);
    id v180 = [v47 copy];
  }
  else
  {
    id v180 = (id)objc_opt_new();
    uint64_t v43 = qword_772A50;
    for (uint64_t m = xmmword_772A58; v43 != m; v43 += 24)
    {
      uint64_t v45 = v43;
      if (*(char *)(v43 + 23) < 0) {
        uint64_t v45 = *(void *)v43;
      }
      id v46 = +[NSString stringWithUTF8String:v45];
      [v180 addObject:v46];
    }
  }
  char v48 = +[NSMutableSet setWithArray:v180];
  uint64_t v49 = obj;
  [v48 addObjectsFromArray:&off_758A08];
  if (v179) {
    [v48 addObjectsFromArray:v179];
  }
  [v48 addObjectsFromArray:obj];
  unint64_t v50 = +[NSMutableDictionary dictionaryWithCapacity:4096];
  for (unint64_t n = 0; n < [*((id *)&xmmword_772038 + 1) count]; ++n)
  {
    uint64_t v192 = [*((id *)&xmmword_772038 + 1) objectAtIndexedSubscript:];
    uint64_t v51 = [v192 availableCounters];
    long long v283 = 0u;
    long long v282 = 0u;
    long long v281 = 0u;
    long long v280 = 0u;
    id v52 = v51;
    id v53 = [v52 countByEnumeratingWithState:&v280 objects:v305 count:16];
    if (v53)
    {
      uint64_t v54 = *(void *)v281;
      do
      {
        for (iunint64_t i = 0; ii != v53; iunint64_t i = (char *)ii + 1)
        {
          if (*(void *)v281 != v54) {
            objc_enumerationMutation(v52);
          }
          uint64_t v56 = *(void **)(*((void *)&v280 + 1) + 8 * (void)ii);
          uint64_t v57 = [v56 name];
          unsigned int v58 = [v48 containsObject:v57];

          if (v58)
          {
            unint64_t v59 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [v56 counterValueType]);
            unint64_t v60 = [v56 name];
            [v50 setObject:v59 forKeyedSubscript:v60];
          }
        }
        id v53 = [v52 countByEnumeratingWithState:&v280 objects:v305 count:16];
      }
      while (v53);
    }

    uint64_t v49 = obj;
  }
  uint64_t v61 = (char *)[v180 count];
  int v193 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", &v61[(void)[(id)qword_7727F0 count]]);
  [v193 addObjectsFromArray:qword_7727F0];
  long long v279 = 0u;
  long long v278 = 0u;
  long long v277 = 0u;
  long long v276 = 0u;
  id v201 = v180;
  id v62 = [v201 countByEnumeratingWithState:&v276 objects:v304 count:16];
  if (v62)
  {
    uint64_t v63 = *(void *)v277;
    do
    {
      for (juint64_t j = 0; jj != v62; juint64_t j = (char *)jj + 1)
      {
        if (*(void *)v277 != v63) {
          objc_enumerationMutation(v201);
        }
        int v65 = *(void **)(*((void *)&v276 + 1) + 8 * (void)jj);
        if (([v65 isEqualToString:@"MTLStat_nSec"] & 1) == 0
          && ([v49 containsObject:v65] & 1) == 0
          && (!v194 || ([v185 containsObject:v65] & 1) == 0))
        {
          if ([v198 containsObject:v65]) {
            uint64_t v66 = &off_758EA0;
          }
          else {
            uint64_t v66 = 0;
          }
          uint64_t v67 = v66;
          uint64_t v68 = +[GPURawCounterSelect selectWithName:v65 options:v67];
          [v193 addObject:v68];

          uint64_t v49 = obj;
        }
      }
      id v62 = [v201 countByEnumeratingWithState:&v276 objects:v304 count:16];
    }
    while (v62);
  }

  if (qword_7727F8)
  {
    id v170 = GTUSCSamplingStreamingManagerHelper::SubDividedCounterDictionary((void *)qword_7727F8);
  }
  else
  {
    id v170 = 0;
  }
  GTUSCSamplingStreamingManagerHelper::SubDividedCounterDictionary(v193);
  uint64_t v167 = (NSDictionary *)objc_claimAutoreleasedReturnValue();
  DeepMutableCopy(v167);
  id v69 = (GTUSCSamplingStreamingManagerHelper *)objc_claimAutoreleasedReturnValue();
  unint64_t v70 = v69;
  if (v69)
  {
    uint64_t v177 = v69;
    if ([(GTUSCSamplingStreamingManagerHelper *)v69 count])
    {
      char v71 = [(GTUSCSamplingStreamingManagerHelper *)v70 objectForKeyedSubscript:@"passNum"];
      unsigned int v188 = [v71 unsignedIntValue];

      if (v170)
      {
        unint64_t v72 = [v170 objectForKeyedSubscript:@"passNum"];
        BOOL v73 = [v72 unsignedIntValue] == 1;

        if (v73)
        {
          GTUSCSamplingStreamingManagerHelper::SetupBumperCounters(v177, v74);
          unint64_t v75 = [v170 objectForKeyedSubscript:@"passList"];
          unint64_t v76 = [v75 objectAtIndexedSubscript:0];

          if (v188)
          {
            for (kuint64_t k = 0; kk != v188; ++kk)
            {
              unint64_t v78 = [(GTUSCSamplingStreamingManagerHelper *)v177 objectForKeyedSubscript:@"passList"];
              unint64_t v79 = [v78 objectAtIndexedSubscript:kk];

              for (muint64_t m = 0; mm < (unint64_t)[v79 count]; ++mm)
              {
                unint64_t v81 = [v76 objectAtIndexedSubscript:mm];
                BOOL v82 = [v81 count] == 0;

                if (!v82)
                {
                  unint64_t v83 = [v79 objectAtIndexedSubscript:mm];
                  unint64_t v84 = [v76 objectAtIndexedSubscript:mm];
                  [v83 addObjectsFromArray:v84];
                }
              }
            }
          }
          if ([v202 count])
          {
            ++v188;
            uint64_t v85 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:");
            [(GTUSCSamplingStreamingManagerHelper *)v177 setObject:v85 forKeyedSubscript:@"passNum"];
          }
          if ([v202 count])
          {
            int64_t v86 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [*((id *)&xmmword_772038 + 1) count]);
            for (nunint64_t n = 0; nn < (unint64_t)[*((id *)&xmmword_772038 + 1) count]; ++nn)
            {
              unint64_t v88 = objc_opt_new();
              [v86 addObject:v88];

              uint64_t v89 = [v76 objectAtIndexedSubscript:nn];
              BOOL v90 = [v89 count] == 0;

              if (!v90)
              {
                uint64_t v91 = [v86 objectAtIndexedSubscript:nn];
                unint64_t v92 = [(id)qword_7727F0 arrayByAddingObjectsFromArray:v202];
                [v91 addObjectsFromArray:v92];
              }
            }
            int64_t v93 = [(GTUSCSamplingStreamingManagerHelper *)v177 objectForKeyedSubscript:@"passList"];
            [v93 addObject:v86];
          }
        }
      }
      uint64_t v95 = objc_opt_new();
      id v174 = (void *)v95;
      uint64_t v270 = 0;
      uint64_t v271 = &v270;
      uint64_t v272 = 0x3032000000;
      uint64_t v273 = __Block_byref_object_copy_;
      unint64_t v274 = __Block_byref_object_dispose_;
      id v275 = (id)objc_opt_new();
      __p = 0;
      p_p = &__p;
      uint64_t v264 = 0x5812000000;
      id v265 = __Block_byref_object_copy__310;
      memset(v267, 0, sizeof(v267));
      v266 = __Block_byref_object_dispose__311;
      uint64_t v268 = 0;
      int v269 = 1065353216;
      v260[0] = 0;
      v260[1] = v260;
      v260[2] = 0x5812000000;
      v260[3] = __Block_byref_object_copy__310;
      memset(&v260[5], 0, 40);
      v260[4] = __Block_byref_object_dispose__311;
      int v261 = 1065353216;
      uint64_t v253 = 0;
      char v254 = &v253;
      uint64_t v255 = 0x4812000000;
      unint64_t v256 = __Block_byref_object_copy__312;
      id v257 = __Block_byref_object_dispose__313;
      unint64_t v258 = &unk_4E231D;
      memset(v259, 0, sizeof(v259));
      unint64_t v244 = 0;
      unint64_t v245 = &v244;
      uint64_t v246 = 0x4812000000;
      int v247 = __Block_byref_object_copy__315;
      uint64_t v248 = __Block_byref_object_dispose__316;
      uint64_t v249 = &unk_4E231D;
      uint64_t v252 = 0;
      int v250 = 0;
      uint64_t v251 = 0;
      unint64_t v168 = (char *)v188;
      std::vector<std::vector<DYMTLEncoderInfo>>::resize(v259, v188);
      id v162 = *(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16);
      unint64_t v96 = [v162 objectForKeyedSubscript:@"perEncoderDrawCallCount"];
      id v165 = [v96 count];

      unint64_t v176 = objc_opt_new();
      uint64_t v178 = objc_opt_new();
      if (v188)
      {
        uint64_t v97 = 0;
        for (int i1 = 0; i1 != v188; ++i1)
        {
          std::vector<std::vector<DYMTLEncoderInfo>>::reserve(v254 + 6, 2 * (void)v165);
          unint64_t v99 = objc_opt_new();
          v231[0] = _NSConcreteStackBlock;
          v231[1] = 3221225472;
          v231[2] = ___ZN35GTUSCSamplingStreamingManagerHelper31StreamEncoderDerivedCounterDataEv_block_invoke;
          v231[3] = &unk_7448B0;
          uint64_t v240 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
          unint64_t v232 = v177;
          int v241 = i1;
          BOOL v243 = v194;
          id v100 = v179;
          unsigned int v242 = v188;
          id v233 = v100;
          uint64_t v235 = &v253;
          uint64_t v236 = &v244;
          id v237 = &__p;
          uint64_t v238 = v260;
          unint64_t v239 = &v270;
          id v101 = v99;
          id v234 = v101;
          unint64_t v102 = +[NSBlockOperation blockOperationWithBlock:v231];
          unint64_t v103 = v102;
          if (v97) {
            [v102 addDependency:v97];
          }
          [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v103];
          [v103 setQueuePriority:-8];
          v227[0] = _NSConcreteStackBlock;
          v227[1] = 3221225472;
          v227[2] = ___ZN35GTUSCSamplingStreamingManagerHelper31StreamEncoderDerivedCounterDataEv_block_invoke_2;
          v227[3] = &unk_745EA8;
          uint64_t v230 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
          id v104 = v101;
          id v228 = v104;
          id v229 = v176;
          unint64_t v105 = +[NSBlockOperation blockOperationWithBlock:v227];
          [v105 addDependency:v103];
          [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:v105];
          [v178 addDependency:v105];
          id v106 = v105;

          if (!i1 && dword_77286C && dword_772868)
          {
            v224[0] = _NSConcreteStackBlock;
            v224[1] = 3221225472;
            v224[2] = ___ZN35GTUSCSamplingStreamingManagerHelper31StreamEncoderDerivedCounterDataEv_block_invoke_3;
            v224[3] = &unk_7463C0;
            int v226 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
            id v225 = v174;
            id v107 = +[NSBlockOperation blockOperationWithBlock:v224];
            [v107 addDependency:v106];
            [v178 addDependency:v107];
            [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v107];
          }
          uint64_t v97 = v106;
        }
      }
      else
      {
        id v106 = 0;
      }
      BOOL v163 = v106;
      [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:v178];
      [v178 waitUntilFinished];
      long long v175 = +[NSMutableArray arrayWithCapacity:v188];
      if (v188)
      {
        uint64_t v108 = 0;
        do
        {
          long long v109 = +[NSData dataWithBytes:*(void *)(v254[6] + v108) length:*(void *)(v254[6] + v108 + 8) - *(void *)(v254[6] + v108)];
          [v175 addObject:v109];

          v108 += 24;
        }
        while (24 * v188 != v108);
      }
      id v164 = +[NSMutableDictionary dictionaryWithCapacity:[(GTUSCSamplingStreamingManagerHelper *)v177 count]];
      long long v110 = [v164 objectForKeyedSubscript:@"passNum"];
      [v164 setObject:v110 forKeyedSubscript:@"passNum"];

      unint64_t v166 = +[NSMutableArray arrayWithCapacity:v188];
      long long v111 = v177;
      if (v188)
      {
        id v172 = 0;
        do
        {
          long long v112 = [(GTUSCSamplingStreamingManagerHelper *)v111 objectForKeyedSubscript:@"passList"];
          id v181 = [v112 objectAtIndexedSubscript:v172];

          uint64_t v189 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v181 count]);
          long long v222 = 0u;
          long long v223 = 0u;
          long long v220 = 0u;
          long long v221 = 0u;
          id v182 = v181;
          id v113 = [v182 countByEnumeratingWithState:&v220 objects:v303 count:16];
          if (v113)
          {
            uint64_t v186 = *(void *)v221;
            do
            {
              id v195 = v113;
              for (i2 = 0; i2 != v195; i2 = (char *)i2 + 1)
              {
                if (*(void *)v221 != v186) {
                  objc_enumerationMutation(v182);
                }
                unsigned __int8 v115 = *(void **)(*((void *)&v220 + 1) + 8 * (void)i2);
                unint64_t v116 = [(id)qword_7727F0 arrayByAddingObjectsFromArray:v115];
                uint64_t v117 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v116 count]);
                long long v218 = 0u;
                long long v219 = 0u;
                long long v216 = 0u;
                long long v217 = 0u;
                id v118 = v115;
                id v119 = [v118 countByEnumeratingWithState:&v216 objects:v302 count:16];
                if (v119)
                {
                  uint64_t v120 = *(void *)v217;
                  do
                  {
                    for (i3 = 0; i3 != v119; i3 = (char *)i3 + 1)
                    {
                      if (*(void *)v217 != v120) {
                        objc_enumerationMutation(v118);
                      }
                      int v122 = [*(id *)(*((void *)&v216 + 1) + 8 * (void)i3) name];
                      [v117 addObject:v122];
                    }
                    id v119 = [v118 countByEnumeratingWithState:&v216 objects:v302 count:16];
                  }
                  while (v119);
                }

                [v189 addObject:v117];
              }
              id v113 = [v182 countByEnumeratingWithState:&v220 objects:v303 count:16];
            }
            while (v113);
          }

          [v166 addObject:v189];
          ++v172;
          long long v111 = v177;
        }
        while (v172 != v168);
      }
      unint64_t v123 = p_p;
      unint64_t v124 = (unint64_t)p_p[9];
      if (v124)
      {
        if (v124 >> 60) {
          abort();
        }
        size_t v125 = 16 * v124;
        uint64_t v126 = (char *)operator new(16 * v124);
        bzero(v126, v125);
        unint64_t v127 = &v126[v125];
      }
      else
      {
        uint64_t v126 = 0;
        unint64_t v127 = 0;
      }
      for (i4 = (unsigned int *)v123[8]; i4; i4 = *(unsigned int **)i4)
      {
        unint64_t v129 = i4[6];
        if ((v127 - v126) >> 4 > v129)
        {
          unsigned __int8 v130 = &v126[16 * v129];
          unint64_t v131 = i4[7] | ((unint64_t)*((unsigned int *)v130 + 1) << 32);
          *(void *)unsigned __int8 v130 = v131;
          unint64_t v132 = v131 & 0xFFFF0000FFFFFFFFLL | ((unint64_t)*((unsigned __int16 *)i4 + 16) << 32);
          *(void *)unsigned __int8 v130 = v132;
          *(void *)unsigned __int8 v130 = v132 & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)i4[9] << 48);
          *((void *)v130 + 1) = *((void *)i4 + 5);
        }
      }
      id v159 = v126;
      if (!dword_772014) {
        mach_timebase_info((mach_timebase_info_t)&GTUSCSamplingStreamingManagerHelper::StreamEncoderDerivedCounterData(void)::timebaseInfo);
      }
      uint64_t v160 = +[NSMutableData dataWithBytes:v126 length:v127 - v126];
      long long v214 = 0u;
      long long v215 = 0u;
      long long v212 = 0u;
      long long v213 = 0u;
      id v173 = v176;
      unint64_t v133 = 0;
      unint64_t v134 = (char *)[v173 countByEnumeratingWithState:&v212 objects:v301 count:16];
      if (v134)
      {
        uint64_t v135 = 0;
        uint64_t v169 = *(void *)v213;
        do
        {
          uint64_t v136 = 0;
          id v161 = v134;
          do
          {
            if (*(void *)v213 != v169) {
              objc_enumerationMutation(v173);
            }
            BOOL v137 = *(void **)(*((void *)&v212 + 1) + 8 * (void)v136);
            long long v208 = 0u;
            long long v209 = 0u;
            long long v210 = 0u;
            long long v211 = 0u;
            id v196 = v137;
            id v138 = [v196 countByEnumeratingWithState:&v208 objects:v300 count:16];
            id v183 = v136;
            unint64_t v187 = v133;
            uint64_t v190 = v135;
            unint64_t v139 = 0;
            if (v138)
            {
              uint64_t v140 = *(void *)v209;
              do
              {
                for (i5 = 0; i5 != v138; i5 = (char *)i5 + 1)
                {
                  if (*(void *)v209 != v140) {
                    objc_enumerationMutation(v196);
                  }
                  long long v142 = *(void **)(*((void *)&v208 + 1) + 8 * (void)i5);
                  long long v204 = 0u;
                  long long v205 = 0u;
                  long long v206 = 0u;
                  long long v207 = 0u;
                  id v143 = v142;
                  id v144 = [v143 countByEnumeratingWithState:&v204 objects:v299 count:16];
                  if (v144)
                  {
                    uint64_t v145 = *(void *)v205;
                    do
                    {
                      for (i6 = 0; i6 != v144; i6 = (char *)i6 + 1)
                      {
                        if (*(void *)v205 != v145) {
                          objc_enumerationMutation(v143);
                        }
                        v139 += (unint64_t)[*(id *)(*((void *)&v204 + 1) + 8 * (void)i6) length];
                      }
                      id v144 = [v143 countByEnumeratingWithState:&v204 objects:v299 count:16];
                    }
                    while (v144);
                  }
                }
                id v138 = [v196 countByEnumeratingWithState:&v208 objects:v300 count:16];
              }
              while (v138);
            }

            NSLog(@"Total RDE Counter Data for pass %u %llu kB", v190, v139 >> 10);
            unint64_t v133 = v139 + v187;
            uint64_t v135 = (v190 + 1);
            uint64_t v136 = v183 + 1;
          }
          while (v183 + 1 != v161);
          unint64_t v134 = (char *)[v173 countByEnumeratingWithState:&v212 objects:v301 count:16];
        }
        while (v134);
      }

      id v147 = (void *)qword_772850;
      if (!qword_772850) {
        id v147 = &__NSDictionary0__struct;
      }
      id v148 = v147;
      NSLog(@"Total RDE Counter Data %llu kB", v133 >> 10);
      [v164 setObject:v166 forKeyedSubscript:@"passList"];
      v297[0] = @"Derived Counter Sample Data";
      v297[1] = @"Subdivided Dictionary";
      v298[0] = v173;
      v298[1] = v164;
      v298[2] = v175;
      v297[2] = @"Encoder Infos";
      v297[3] = @"Encoder Tile Info";
      unint64_t v149 = +[NSData dataWithBytes:v245[6] length:(char *)v245[7] - (char *)v245[6]];
      v298[3] = v149;
      v297[4] = @"MTLFX TraceIds";
      id v197 = v148;
      uint64_t v150 = [(id)v271[5] mtlfxTracingInfo];
      if (v150) {
        id v151 = (void *)v150;
      }
      else {
        id v151 = &__NSDictionary0__struct;
      }
      v298[4] = v151;
      v298[5] = v50;
      v297[5] = @"Counter Info";
      v297[6] = @"Num Encoders";
      unsigned __int8 v191 = (void *)v150;
      id v184 = +[NSNumber numberWithUnsignedInteger:v165];
      v298[6] = v184;
      v298[7] = v174;
      v297[7] = @"Encoder Time Sample Data";
      v297[8] = @"Encoder Sample Index Data";
      v298[8] = v160;
      v297[9] = @"Timebase";
      char v152 = +[NSNumber numberWithUnsignedInt:GTUSCSamplingStreamingManagerHelper::StreamEncoderDerivedCounterData(void)::timebaseInfo];
      v296[0] = v152;
      unint64_t v153 = +[NSNumber numberWithUnsignedInt:dword_772014];
      v296[1] = v153;
      uint64_t v154 = +[NSArray arrayWithObjects:v296 count:2];
      v298[9] = v154;
      v297[10] = @"Source Sample Marker";
      dispatch_semaphore_t v155 = +[NSNumber numberWithUnsignedLongLong:qword_772048];
      v298[10] = v155;
      v297[11] = @"Derived Counters Info Data";
      dispatch_semaphore_t v156 = *(void **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 48);
      if (!v156) {
        dispatch_semaphore_t v156 = &__NSDictionary0__struct;
      }
      v298[11] = v156;
      v298[12] = v197;
      v297[12] = @"Perf Info";
      v297[13] = @"Fragment Counter";
      if (obj)
      {
        id v157 = [obj firstObject];
      }
      else
      {
        id v157 = &stru_7482F0;
      }
      v298[13] = v157;
      id v158 = +[NSDictionary dictionaryWithObjects:v298 forKeys:v297 count:14];
      if (obj) {

      }
      (*(void (**)(void))(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 32) + 16))();
      if (v159) {
        operator delete(v159);
      }

      _Block_object_dispose(&v244, 8);
      if (v250)
      {
        uint64_t v251 = v250;
        operator delete(v250);
      }
      _Block_object_dispose(&v253, 8);
      unint64_t v244 = (void **)v259;
      std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&v244);
      _Block_object_dispose(v260, 8);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v260[6]);
      _Block_object_dispose(&__p, 8);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v267[8]);
      _Block_object_dispose(&v270, 8);

      unint64_t v70 = v177;
    }
  }
}

void sub_1E2A5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *__p, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, uint64_t a20,void *a21,void *a22,uint64_t a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,void *a31,void *a32,void *a33,uint64_t a34,void *a35,_Unwind_Exception *exception_objecta,uint64_t a37,void *a38,uint64_t a39,void *a40,void *a41,uint64_t a42,void *a43,void *a44)
{
  if (__p) {
    operator delete(__p);
  }

  _Block_object_dispose(&STACK[0x340], 8);
  id v46 = (void *)STACK[0x370];
  if (STACK[0x370])
  {
    STACK[0x378] = (unint64_t)v46;
    operator delete(v46);
  }
  _Block_object_dispose(&STACK[0x388], 8);
  STACK[0x340] = a14;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&STACK[0x340]);
  _Block_object_dispose(&STACK[0x3D0], 8);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(a15);
  _Block_object_dispose(&STACK[0x428], 8);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(a16);
  _Block_object_dispose(&STACK[0x480], 8);

  _Unwind_Resume(a1);
}

id DeepMutableCopy(NSDictionary *a1)
{
  unsigned __int8 v1 = a1;
  id v2 = v1;
  if (v1)
  {
    +[NSMutableDictionary dictionaryWithCapacity:[(NSDictionary *)v1 count]];
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = ___ZL15DeepMutableCopyP12NSDictionary_block_invoke;
    v5[3] = &unk_7453B0;
    id v3 = (id)objc_claimAutoreleasedReturnValue();
    id v6 = v3;
    [(NSDictionary *)v2 enumerateKeysAndObjectsUsingBlock:v5];
  }
  else
  {
    id v3 = 0;
  }

  return v3;
}

void sub_1E3234(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper31StreamEncoderDerivedCounterDataEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 96);
  GTMTLReplayController_prePlayForProfiling(**(void **)v2);
  DisableComputeEncoderCoalescing(**(GTMTLReplayController ***)v2, 1);
  id v3 = *(NSDictionary **)(a1 + 32);
  unsigned int v4 = *(_DWORD *)(a1 + 104);
  int v5 = *(unsigned char *)(a1 + 112)
    && [*(id *)(a1 + 40) count]
    && *(_DWORD *)(a1 + 104) + 1 == *(_DWORD *)(a1 + 108);
  if (GTUSCSamplingStreamingManagerHelper::SetupSourceForDerivedCounters((id *)v2, v3, v4, 0, v5))
  {
    id v6 = [*(id *)(v2 + 16) firstObject];
    unsigned __int8 v7 = [v6 startSampling];

    if (v7)
    {
      if (!*(_DWORD *)(*(void *)v2 + 72))
      {
        usleep(0x30D40u);
        GTUSCSamplingStreamingManagerHelper::ForceDrainAllSourceBuffers(*(GTUSCSamplingStreamingManagerHelper **)(v2 + 24));
      }
      GTUSCSamplingStreamingManagerHelper::ResetSourceForPostProcessing((id *)v2);
      unsigned int v8 = *(_DWORD *)(a1 + 104);
      if (v8)
      {
        id v9 = 0;
        id v10 = 0;
        uint64_t v11 = a1 + 80;
      }
      else
      {
        id v9 = (char **)(*(void *)(*(void *)(a1 + 64) + 8) + 48);
        uint64_t v11 = a1 + 72;
        id v10 = *(void **)(*(void *)(*(void *)(a1 + 88) + 8) + 40);
      }
      GTUSCSamplingStreamingManagerHelper::ReplayForDerivedCounters(v2, (char **)(*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 48) + 24 * v8), v9, 0, (void *)(*(void *)(*(void *)v11 + 8) + 48), v10);
      uint64_t v13 = GTUSCSamplingStreamingManagerHelper::DrainRawDerivedCounterData((id *)v2);
      if (v13) {
        [*(id *)(a1 + 48) setArray:v13];
      }

      uint64_t v14 = [*(id *)(v2 + 16) firstObject];
      [v14 stopSampling];

      DisableComputeEncoderCoalescing(**(GTMTLReplayController ***)v2, 0);
      if (*(_DWORD *)(a1 + 104) + 1 == *(_DWORD *)(a1 + 108))
      {
        GTAGXPerfStateControl::DisableConsistentGPUPerfState((GTAGXPerfStateControl *)(v2 + 40));
        GTApplePMPPerfStateControl::DisableConsistentPerfState((GTApplePMPPerfStateControl *)(v2 + 64));
      }
    }
  }
}

void sub_1E342C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper31StreamEncoderDerivedCounterDataEv_block_invoke_2(uint64_t a1)
{
  GTUSCSamplingStreamingManagerHelper::PostProcessRawDerivedCounterData(*(void *)(a1 + 48), *(void **)(a1 + 32));
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  if (v2) {
    [*(id *)(a1 + 40) addObject:v2];
  }
}

void sub_1E34A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper31StreamEncoderDerivedCounterDataEv_block_invoke_3(uint64_t a1)
{
  id v2 = *(void **)(a1 + 40);
  GTSampleBufferManager::ResolveSampleBuffers((GTSampleBufferManager *)(v2 + 263));
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  if (v3) {
    [*(id *)(a1 + 32) setData:v3];
  }
  v2[269] = 0;
  v2[267] = v2[266];
}

void sub_1E3524(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZL15DeepMutableCopyP12NSDictionary_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v7 = a2;
  int v5 = a3;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v6 = DeepMutableCopy(v5);
    [*(id *)(a1 + 32) setObject:v6 forKeyedSubscript:v7];
LABEL_5:

    goto LABEL_7;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v6 = DeepMutableCopy((NSArray *)v5);
    [*(id *)(a1 + 32) setObject:v6 forKeyedSubscript:v7];
    goto LABEL_5;
  }
  [*(id *)(a1 + 32) setObject:v5 forKeyedSubscript:v7];
LABEL_7:
}

void sub_1E3628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id DeepMutableCopy(NSArray *a1)
{
  unsigned __int8 v1 = a1;
  id v2 = v1;
  if (v1)
  {
    +[NSMutableArray arrayWithCapacity:[(NSArray *)v1 count]];
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = ___ZL15DeepMutableCopyP7NSArray_block_invoke;
    v5[3] = &unk_744950;
    id v3 = (id)objc_claimAutoreleasedReturnValue();
    id v6 = v3;
    [(NSArray *)v2 enumerateObjectsUsingBlock:v5];
  }
  else
  {
    id v3 = 0;
  }

  return v3;
}

void sub_1E372C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL15DeepMutableCopyP7NSArray_block_invoke(uint64_t a1, void *a2)
{
  id v7 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v3 = *(void **)(a1 + 32);
    unsigned int v4 = DeepMutableCopy(v7);
    [v3 addObject:v4];
LABEL_5:

    goto LABEL_7;
  }
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  id v6 = *(void **)(a1 + 32);
  if (isKindOfClass)
  {
    unsigned int v4 = DeepMutableCopy((NSArray *)v7);
    [v6 addObject:v4];
    goto LABEL_5;
  }
  [*(id *)(a1 + 32) addObject:v7];
LABEL_7:
}

void sub_1E3824(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper17StreamGPUTimelineEv_block_invoke(uint64_t a1)
{
}

void GTUSCSamplingStreamingManagerHelper::InitAPSStreaming(GTUSCSamplingStreamingManagerHelper *this, GTUSCSamplingStreamingManager *a2)
{
  if (xmmword_7728B4 != 2)
  {
    GTUSCSamplingStreamingManagerHelper::Init(this, a2);
    GTUSCSamplingStreamingManagerHelper::SetupGPURawCounters(v3);
    GTAGXProfilingSupportHelper::Initialize((GTAGXProfilingSupportHelper *)qword_7727E8, v4);
  }
  GTUSCSamplingStreamingManagerHelper::CleanupForAPSStreaming(this);
  GTUSCSamplingStreamingManagerHelper::SetupGPURawCounters(v2);
  id v5 = GTUSCSamplingStreamingManagerHelper::AllocUSCSamplingAddressBuffer((GTUSCSamplingStreamingManagerHelper *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance);
  qword_7727B8 = (uint64_t)[(id)qword_7727D8 mutableBytes];
  id v6 = [[ProgramAddressTableCollector alloc] initForHarvestingBinaries];
  id v7 = (void *)xmmword_7727C0;
  *(void *)&xmmword_7727C0 = v6;

  if (qword_7728A8 != -1)
  {
    GTUSCSamplingStreamingManagerHelper::SetupBuffersForAPSSource(v8);
    id v9 = [*((id *)&xmmword_772038 + 1) objectAtIndexedSubscript:(int)qword_7728A8];
    if ((qword_772C98 & 2) != 0)
    {
      id v11 = [[GTGPUAPSConfig alloc] initForMinimumInfoTimeline];
    }
    else
    {
      if (xmmword_7728B4 == 2) {
        id v10 = [[GTGPUAPSConfig alloc] initForTimeline];
      }
      else {
        id v10 = [[GTGPUAPSConfig alloc] initForProfiling];
      }
      id v11 = v10;
      id v12 = *(void **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16);
      if (xmmword_7728B4 == 2) {
        [v12 objectForKeyedSubscript:@"TimelineConfig"];
      }
      else {
      uint64_t v13 = [v12 objectForKeyedSubscript:@"apsProfilingConfig"];
      }
      if (v13) {
        [v11 readConfig:v13];
      }
    }
    uint64_t v14 = [v11 grcOptions];
    uint64_t v15 = (void *)qword_772838;
    qword_772838 = v14;

    uint64_t v16 = +[NSMutableArray arrayWithCapacity:1];
    uint64_t v17 = (void *)xmmword_772840;
    *(void *)&xmmword_772840 = v16;

    int v18 = (void *)xmmword_772840;
    unsigned int v19 = [v11 grcTrigger];
    uint64_t v20 = +[GPURawCounterSourceTriggerSelect selectWithName:@"KickAndStateTracing" options:v19];
    [v18 addObject:v20];

    if (xmmword_7728B4 == 2) {
      unsigned int v21 = @"Timeline";
    }
    else {
      unsigned int v21 = @"Profiling";
    }
    unsigned int v22 = v21;
    uint64_t v23 = *(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 32);
    CFStringRef v26 = @"Streaming APS Profiling";
    int v27 = v22;
    id v24 = +[NSDictionary dictionaryWithObjects:&v27 forKeys:&v26 count:1];
    (*(void (**)(uint64_t, void *))(v23 + 16))(v23, v24);

    GTUSCSamplingStreamingManagerHelper::InitRDELimiterCounters(v25);
  }
}

void sub_1E3B0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManagerHelper::CleanupForAPSStreaming(GTUSCSamplingStreamingManagerHelper *this)
{
  atomic_store(0, byte_772AF0);
  atomic_store(0, &byte_772AF0[1]);
  atomic_store(0, (unsigned __int8 *)&unk_772AF3);
  qword_7727B0 = 0;
  dword_77289C = 0;
  qword_7728A0 = 1;
  id v2 = (void **)*((void *)&xmmword_772958 + 1);
  unsigned __int8 v1 = (void **)xmmword_772958;
  while (v2 != v1)
  {
    v2 -= 3;
    uint64_t v17 = v2;
    std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v17);
  }
  *((void *)&xmmword_772958 + 1) = v1;
  uint64_t v3 = qword_772940;
  unsigned int v4 = (void **)xmmword_772948;
  while (v4 != (void **)v3)
  {
    v4 -= 3;
    uint64_t v17 = v4;
    std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v17);
  }
  *(void *)&xmmword_772948 = v3;
  id v6 = (void **)*((void *)&xmmword_772988 + 1);
  id v5 = (void **)xmmword_772988;
  while (v6 != v5)
  {
    v6 -= 3;
    uint64_t v17 = v6;
    std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v17);
  }
  *((void *)&xmmword_772988 + 1) = v5;
  uint64_t v7 = qword_7729A0;
  unsigned int v8 = (void **)xmmword_7729A8;
  while (v8 != (void **)v7)
  {
    v8 -= 3;
    uint64_t v17 = v8;
    std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v17);
  }
  *(void *)&xmmword_7729A8 = v7;
  id v10 = (void **)*((void *)&xmmword_7729B8 + 1);
  id v9 = (void **)xmmword_7729B8;
  while (v10 != v9)
  {
    v10 -= 3;
    uint64_t v17 = v10;
    std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v17);
  }
  *((void *)&xmmword_7729B8 + 1) = v9;
  uint64_t v11 = *((void *)&xmmword_7729C8 + 1);
  for (uint64_t i = qword_7729D8; i != v11; i -= 8)
  {
    uint64_t v13 = *(void **)(i - 8);
  }
  qword_7729D8 = v11;
  uint64_t v14 = xmmword_772C68;
  uint64_t v15 = *((void *)&xmmword_772C58 + 1);
  while (v14 != v15)
  {
    uint64_t v16 = *(void **)(v14 - 32);
    v14 -= 32;
  }
  *(void *)&xmmword_772C68 = v15;
}

void GTUSCSamplingStreamingManagerHelper::InitRDELimiterCounters(GTUSCSamplingStreamingManagerHelper *this)
{
  unsigned __int8 v1 = [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) objectForKeyedSubscript:@"profileCounters"];
  id v73 = [v1 mutableCopy];

  id v2 = [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) objectForKeyedSubscript:@"profileCounters32"];
  uint64_t v3 = +[NSSet setWithArray:v2];

  uint64_t v4 = qword_772A80;
  uint64_t v5 = xmmword_772A88;
  memset(v89, 0, sizeof(v89));
  int v90 = 1065353216;
  char v71 = (void *)v3;
  if (qword_772A80 != (void)xmmword_772A88)
  {
    do
    {
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)v89, v4, v4);
      v4 += 24;
    }
    while (v4 != v5);
  }
  uint64_t v6 = +[NSMutableArray arrayWithCapacity:0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&xmmword_772A38 + 1) - xmmword_772A38) >> 3)];
  uint64_t v7 = (void *)xmmword_772800;
  *(void *)&xmmword_772800 = v6;

  unint64_t v76 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v73 count]);
  unsigned int v8 = +[NSMutableSet setWithCapacity:](NSMutableSet, "setWithCapacity:", [v73 count]);
  uint64_t v10 = *((void *)&xmmword_772A38 + 1);
  for (uint64_t i = xmmword_772A38; i != v10; i += 24)
  {
    uint64_t v11 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(*(uint64_t *)&v89[0], *((unint64_t *)&v89[0] + 1), i);
    int v12 = *(char *)(i + 23);
    uint64_t v13 = i;
    if (v11)
    {
      if (v12 < 0) {
        uint64_t v13 = *(void *)i;
      }
      uint64_t v14 = +[NSString stringWithUTF8String:v13];
      uint64_t v15 = +[GPURawCounterSelect selectWithName:v14 options:&off_758EC8];
      [v76 addObject:v15];
    }
    else
    {
      if (v12 < 0) {
        uint64_t v13 = *(void *)i;
      }
      uint64_t v14 = +[NSString stringWithUTF8String:v13];
      uint64_t v15 = +[GPURawCounterSelect selectWithName:v14 options:&off_758EF0];
      [v76 addObject:v15];
    }

    uint64_t v16 = i;
    if (*(char *)(i + 23) < 0) {
      uint64_t v16 = *(void *)i;
    }
    uint64_t v17 = +[NSString stringWithUTF8String:v16];
    [v8 addObject:v17];
  }
  if (xmmword_7728B4 == 1)
  {
    unsigned int v19 = (uint64_t *)*((void *)&xmmword_772A68 + 1);
    for (uint64_t j = (uint64_t *)xmmword_772A68; j != v19; j += 3)
    {
      uint64_t v20 = j;
      if (*((char *)j + 23) < 0) {
        uint64_t v20 = (uint64_t *)*j;
      }
      unsigned int v21 = +[NSString stringWithUTF8String:v20];
      unsigned int v22 = +[GPURawCounterSelect selectWithName:v21 options:&off_758F18];
      [v76 addObject:v22];

      uint64_t v23 = j;
      if (*((char *)j + 23) < 0) {
        uint64_t v23 = (uint64_t *)*j;
      }
      id v24 = +[NSString stringWithUTF8String:v23];
      [v8 addObject:v24];
    }
  }
  id v25 = +[NSMutableDictionary dictionaryWithCapacity:0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&xmmword_772A38 + 1) - xmmword_772A38) >> 3)];
  for (unint64_t k = 0; k < (unint64_t)[*((id *)&xmmword_772038 + 1) count]; ++k)
  {
    BOOL v77 = [*((id *)&xmmword_772038 + 1) objectAtIndexedSubscript:];
    CFStringRef v26 = [v77 availableCounters];
    long long v87 = 0u;
    long long v88 = 0u;
    long long v85 = 0u;
    long long v86 = 0u;
    id v27 = v26;
    id v28 = [v27 countByEnumeratingWithState:&v85 objects:v94 count:16];
    if (v28)
    {
      uint64_t v29 = *(void *)v86;
      do
      {
        for (uint64_t m = 0; m != v28; uint64_t m = (char *)m + 1)
        {
          if (*(void *)v86 != v29) {
            objc_enumerationMutation(v27);
          }
          unint64_t v31 = *(void **)(*((void *)&v85 + 1) + 8 * (void)m);
          uint64_t v32 = [v31 name];
          unsigned int v33 = [v8 containsObject:v32];

          if (v33)
          {
            int v34 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [v31 counterValueType]);
            unsigned int v35 = [v31 name];
            [v25 setObject:v34 forKeyedSubscript:v35];
          }
        }
        id v28 = [v27 countByEnumeratingWithState:&v85 objects:v94 count:16];
      }
      while (v28);
    }
  }
  uint64_t v36 = (void *)qword_7727F8;
  qword_7727F8 = 0;

  uint64_t v37 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [&off_758A08 count]);
  uint64_t v38 = (void *)qword_7727F0;
  qword_7727F0 = v37;

  for (uint64_t n = 0; n != 7; ++n)
  {
    uint64_t v40 = (void *)qword_7727F0;
    uint64_t v41 = [&off_758A08 objectAtIndexedSubscript:n];
    unsigned int v42 = +[GPURawCounterSelect selectWithName:v41 options:0];
    [v40 addObject:v42];
  }
  unint64_t v72 = GTUSCSamplingStreamingManagerHelper::SubDividedCounterDictionary(v76);
  uint64_t v43 = [v72 objectForKeyedSubscript:@"passList"];
  unint64_t v78 = [v43 objectAtIndexedSubscript:0];

  uint64_t v74 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v76 count]);
  unint64_t v75 = +[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", [v72 count]);
  for (iuint64_t i = 0; ii < (unint64_t)[v78 count]; ++ii)
  {
    unint64_t v80 = [v78 objectAtIndexedSubscript:ii];
    if ([v80 count])
    {
      uint64_t v45 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v80 count]);
      long long v83 = 0u;
      long long v84 = 0u;
      long long v81 = 0u;
      long long v82 = 0u;
      id v46 = v80;
      id v47 = [v46 countByEnumeratingWithState:&v81 objects:v93 count:16];
      if (v47)
      {
        uint64_t v48 = *(void *)v82;
        do
        {
          for (juint64_t j = 0; jj != v47; juint64_t j = (char *)jj + 1)
          {
            if (*(void *)v82 != v48) {
              objc_enumerationMutation(v46);
            }
            unint64_t v50 = [*(id *)(*((void *)&v81 + 1) + 8 * (void)jj) name];
            [v45 addObject:v50];
          }
          id v47 = [v46 countByEnumeratingWithState:&v81 objects:v93 count:16];
        }
        while (v47);
      }

      uint64_t v51 = [*((id *)&xmmword_772038 + 1) objectAtIndexedSubscript:ii];
      id v52 = [v51 name];
      [v75 setObject:v45 forKeyedSubscript:v52];

      [v74 addObjectsFromArray:v45];
      if (ii == (int)qword_7728A8)
      {
        id v53 = objc_opt_new();
      }
      else
      {
        id v55 = [(id)qword_7727F0 copy];
        id v53 = +[NSMutableArray arrayWithArray:v55];
      }
      [v53 addObjectsFromArray:v46];
      [(id)xmmword_772800 addObject:v53];
    }
    else
    {
      uint64_t v54 = (void *)xmmword_772800;
      uint64_t v45 = objc_opt_new();
      [v54 addObject:v45];
    }
  }
  id v56 = v74;

  [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) setObject:v56 forKeyedSubscript:@"limiter sample counters"];
  [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) setObject:v25 forKeyedSubscript:@"Counter Info"];
  [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) setObject:v75 forKeyedSubscript:@"Limiter Counter List Map"];
  uint64_t v57 = +[NSNumber numberWithBool:byte_772AC0];
  [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) setObject:v57 forKeyedSubscript:@"Uarch Enabled"];

  if (xmmword_7728B4 == 2)
  {
    unint64_t v59 = GTAGXProfilingSupportHelper::RemappedCSV(v58);
    if (v59) {
      [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) setObject:v59 forKeyedSubscript:@"CSV"];
    }
  }
  (*(void (**)(void))(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 32) + 16))();
  uint64_t v60 = +[NSMutableArray arrayWithCapacity:1];
  uint64_t v61 = (void *)qword_772830;
  qword_772830 = v60;

  id v62 = (void *)qword_772830;
  uint64_t v63 = +[GPURawCounterSourceTriggerSelect selectWithName:@"KickBoundary" options:0];
  [v62 addObject:v63];

  uint64_t v64 = +[NSMutableArray arrayWithCapacity:1];
  int v65 = (void *)*((void *)&xmmword_772820 + 1);
  *((void *)&xmmword_772820 + 1) = v64;

  if ((qword_772C98 & 2) != 0) {
    uint64_t v66 = 1200;
  }
  else {
    uint64_t v66 = 240;
  }
  uint64_t v67 = (void *)*((void *)&xmmword_772820 + 1);
  CFStringRef v91 = @"Period";
  uint64_t v68 = +[NSNumber numberWithUnsignedInteger:v66];
  unint64_t v92 = v68;
  id v69 = +[NSDictionary dictionaryWithObjects:&v92 forKeys:&v91 count:1];
  unint64_t v70 = +[GPURawCounterSourceTriggerSelect selectWithName:@"TimerNClock" options:v69];
  [v67 addObject:v70];

  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v89);
}

void sub_1E4724(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, void *a11, void *a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a35);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  int v6 = *(char *)(a3 + 23);
  if (v6 >= 0) {
    uint64_t v7 = (uint64_t *)a3;
  }
  else {
    uint64_t v7 = *(uint64_t **)a3;
  }
  if (v6 >= 0) {
    unint64_t v8 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    unint64_t v8 = *(void *)(a3 + 8);
  }
  unint64_t v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v7, v8);
  if (!a2) {
    return 0;
  }
  unint64_t v10 = v9;
  uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v11.i16[0] = vaddlv_u8(v11);
  unint64_t v12 = v11.u32[0];
  if (v11.u32[0] > 1uLL)
  {
    unint64_t v13 = v9;
    if (v9 >= a2) {
      unint64_t v13 = v9 % a2;
    }
  }
  else
  {
    unint64_t v13 = (a2 - 1) & v9;
  }
  uint64_t v14 = *(unsigned __int8 ***)(a1 + 8 * v13);
  if (!v14) {
    return 0;
  }
  for (uint64_t i = *v14; i; uint64_t i = *(unsigned __int8 **)i)
  {
    unint64_t v16 = *((void *)i + 1);
    if (v16 == v10)
    {
      if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a3)) {
        return i;
      }
    }
    else
    {
      if (v12 > 1)
      {
        if (v16 >= a2) {
          v16 %= a2;
        }
      }
      else
      {
        v16 &= a2 - 1;
      }
      if (v16 != v13) {
        return 0;
      }
    }
  }
  return i;
}

BOOL GTUSCSamplingStreamingManagerHelper::StreamAPS(GTUSCSamplingStreamingManagerHelper *this)
{
  unsigned __int8 v1 = atomic_load(byte_772AF4);
  BOOL v2 = 1;
  if ((v1 & 1) == 0 && qword_7728A8 != -1)
  {
    uint64_t v16 = *(void *)GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
    uint64_t v17 = [*(id *)(*(void *)GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) defaultCommandQueue];
    [v17 finish];
    GTUSCSamplingStreamingManagerHelper::InitForPreSamplingWait((uint64_t)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance);
    uint64_t v3 = -1431655765 * ((*((void *)&xmmword_772958 + 1) - (void)xmmword_772958) >> 3);
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
      {
        unsigned int v5 = (*(_DWORD *)(xmmword_772958 + 24 * i + 8) - *(_DWORD *)(xmmword_772958 + 24 * i)) / 120;
        if (i)
        {
          if (v5) {
            goto LABEL_11;
          }
        }
        else
        {
          unsigned int v6 = v5 / qword_772CB8;
          if (v5 / qword_772CB8 * qword_772CB8 != v5) {
            ++v6;
          }
          HIDWORD(qword_772CB8) = v6 - 1;
          dword_772CC0 = v5 - (v6 - 1) * qword_772CB8;
          if (v5) {
LABEL_11:
          }
            operator new();
        }
      }
    }
    usleep(0x3E8u);
    uint64_t v7 = [*(id *)(v16 + 8) defaultDevice];
    if (v7)
    {
      sched_param v62 = 0;
      uint64_t v63 = &v62;
      uint64_t v64 = 0x5812000000;
      int v65 = __Block_byref_object_copy__310;
      memset(v67, 0, sizeof(v67));
      uint64_t v66 = __Block_byref_object_dispose__311;
      uint64_t v68 = 0;
      int v69 = 1065353216;
      v60[0] = 0;
      v60[1] = (pthread_t)v60;
      void v60[2] = (pthread_t)0x5812000000;
      v60[3] = (pthread_t)__Block_byref_object_copy__415;
      memset(&v60[5], 0, 40);
      v60[4] = (pthread_t)__Block_byref_object_dispose__416;
      int v61 = 1065353216;
      sched_param v51 = 0;
      id v52 = &v51;
      uint64_t v53 = 0x4812000000;
      uint64_t v54 = __Block_byref_object_copy__417;
      id v55 = __Block_byref_object_dispose__418;
      id v56 = &unk_4E231D;
      uint64_t v59 = 0;
      __p = 0;
      unsigned int v58 = 0;
      v50[0] = 0;
      v50[1] = v50;
      void v50[2] = 0x2020000000;
      v50[3] = 0;
      v49[0] = 0;
      v49[1] = v49;
      void v49[2] = 0x2020000000;
      v49[3] = 0;
      v48[0] = 0;
      v48[1] = (pthread_t)v48;
      void v48[2] = (pthread_t)0x4012000000;
      v48[3] = (pthread_t)__Block_byref_object_copy__680;
      v48[4] = (pthread_t)__Block_byref_object_dispose__681;
      void v48[5] = (pthread_t)&unk_4E231D;
      v46[0] = 0;
      v46[1] = v46;
      v46[2] = 0x3032000000;
      v46[3] = __Block_byref_object_copy_;
      v46[4] = __Block_byref_object_dispose_;
      id v47 = (id)objc_opt_new();
      unint64_t v9 = objc_opt_new();
      v44[0] = 0;
      v44[1] = v44;
      void v44[2] = 0x3032000000;
      v44[3] = __Block_byref_object_copy_;
      v44[4] = __Block_byref_object_dispose_;
      id v45 = (id)objc_opt_new();
      v34[0] = _NSConcreteStackBlock;
      v34[1] = 3221225472;
      v34[2] = ___ZN35GTUSCSamplingStreamingManagerHelper9StreamAPSEv_block_invoke;
      v34[3] = &unk_7448D8;
      uint64_t v36 = &v62;
      uint64_t v37 = &v51;
      uint64_t v43 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
      uint64_t v38 = v60;
      id v15 = v9;
      id v35 = v15;
      id v39 = v46;
      uint64_t v40 = v44;
      uint64_t v41 = v49;
      unsigned int v42 = v50;
      unint64_t v10 = +[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v34, v9);
      uint64_t v30 = 0;
      unint64_t v31 = &v30;
      uint64_t v32 = 0x2020000000;
      char v33 = 0;
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 3221225472;
      v18[2] = ___ZN35GTUSCSamplingStreamingManagerHelper9StreamAPSEv_block_invoke_2;
      v18[3] = &unk_744900;
      uint64_t v20 = v50;
      unsigned int v21 = v49;
      uint64_t v29 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
      unsigned int v22 = v48;
      id v19 = v7;
      uint64_t v23 = &v62;
      id v24 = v60;
      id v25 = &v51;
      CFStringRef v26 = v46;
      id v27 = v44;
      id v28 = &v30;
      uint8x8_t v11 = +[NSBlockOperation blockOperationWithBlock:v18];
      [v11 setQueuePriority:-8];
      [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v11];
      [v10 addDependency:v11];
      [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:v10];
      unint64_t v12 = (GTUSCSamplingStreamingManagerHelper *)[v10 waitUntilFinished];
      atomic_store(1u, (unsigned __int8 *)&unk_772AF3);
      GTUSCSamplingStreamingManagerHelper::SignalAndWaitForAllThreadsToTerminate(v12);
      unsigned __int8 v13 = atomic_load(byte_772AF4);
      BOOL v2 = (v13 & 1) != 0 || *((unsigned char *)v31 + 24) != 0;

      _Block_object_dispose(&v30, 8);
      _Block_object_dispose(v44, 8);

      _Block_object_dispose(v46, 8);
      _Block_object_dispose(v48, 8);
      _Block_object_dispose(v49, 8);
      _Block_object_dispose(v50, 8);
      _Block_object_dispose(&v51, 8);
      if (__p)
      {
        unsigned int v58 = __p;
        operator delete(__p);
      }
      _Block_object_dispose(v60, 8);
      std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table((uint64_t)&v60[6]);
      _Block_object_dispose(&v62, 8);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v67[8]);
    }
    else
    {
      BOOL v2 = 1;
    }
  }
  return v2;
}

void sub_1E52F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,std::thread a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose(&a47, 8);

  _Block_object_dispose(&a53, 8);
  _Block_object_dispose(&a59, 8);
  _Block_object_dispose(&a67, 8);
  _Block_object_dispose(&a71, 8);
  _Block_object_dispose(&STACK[0x210], 8);
  uint64_t v74 = (void *)STACK[0x240];
  if (STACK[0x240])
  {
    STACK[0x248] = (unint64_t)v74;
    operator delete(v74);
  }
  _Block_object_dispose(&STACK[0x258], 8);
  std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table(a11);
  _Block_object_dispose((const void *)(v72 - 192), 8);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(a12);

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__680(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

void ___ZN35GTUSCSamplingStreamingManagerHelper9StreamAPSEv_block_invoke(void *a1)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)(a1[12] + 2764));
  if (v1) {
    return;
  }
  uint64_t v97 = a1[12];
  unint64_t v102 = +[NSMutableDictionary dictionaryWithCapacity:*(void *)(*(void *)(a1[5] + 8) + 72)];
  id v101 = +[NSMutableDictionary dictionaryWithCapacity:*(void *)(*(void *)(a1[5] + 8) + 72)];
  unint64_t v99 = +[NSMutableDictionary dictionaryWithCapacity:*(void *)(*(void *)(a1[5] + 8) + 72)];
  uint64_t v3 = *(void *)(a1[6] + 8);
  unint64_t v4 = *(void *)(v3 + 48);
  unsigned int v5 = *(unint64_t **)(v3 + 56);
  unint64_t v6 = 126 - 2 * __clz((uint64_t)((uint64_t)v5 - v4) >> 4);
  if (v5 == (unint64_t *)v4) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v6;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>(v4, v5, v7, 1);
  unint64_t v98 = +[NSMutableArray arrayWithCapacity:(uint64_t)(*(void *)(*(void *)(a1[6] + 8) + 56) - *(void *)(*(void *)(a1[6] + 8) + 48)) >> 4];
  uint64_t v95 = +[NSMutableData dataWithCapacity:*(void *)(*(void *)(a1[6] + 8) + 56) - *(void *)(*(void *)(a1[6] + 8) + 48)];
  [v95 appendBytes:*(void *)(*(void *)(a1[6] + 8) + 48) length:*(void *)(*(void *)(a1[6] + 8) + 56) - *(void *)(*(void *)(a1[6] + 8) + 48)];
  uint64_t v8 = *(void *)(a1[6] + 8);
  unint64_t v9 = *(void *)(v8 + 48);
  unint64_t v10 = *(unint64_t **)(v8 + 56);
  unint64_t v11 = 126 - 2 * __clz((uint64_t)((uint64_t)v10 - v9) >> 4);
  if (v10 == (unint64_t *)v9) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = v11;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>(v9, v10, v12, 1);
  uint64_t v13 = *(void *)(a1[6] + 8);
  uint64_t v14 = *(void *)(v13 + 48);
  uint64_t v15 = *(void *)(v13 + 56);
  if (v14 == v15) {
    unint64_t v16 = 0;
  }
  else {
    unint64_t v16 = *(void *)(v14 + 8);
  }
  if ((unint64_t)(v15 - v14) >= 0x11)
  {
    uint64_t v17 = 0;
    unint64_t v18 = 1;
    do
    {
      if (v16 < *(void *)(v14 + v17 + 16))
      {
        id v19 = +[NSNumber numberWithUnsignedLongLong:v16];
        v114[0] = v19;
        uint64_t v20 = +[NSNumber numberWithUnsignedLongLong:*(void *)(*(void *)(*(void *)(a1[6] + 8) + 48) + v17 + 16) - 1];
        v114[1] = v20;
        unsigned int v21 = +[NSArray arrayWithObjects:v114 count:2];
        [v98 addObject:v21];

        uint64_t v13 = *(void *)(a1[6] + 8);
        uint64_t v14 = *(void *)(v13 + 48);
      }
      if (v16 <= *(void *)(v14 + v17 + 24)) {
        unint64_t v16 = *(void *)(v14 + v17 + 24);
      }
      ++v18;
      v17 += 16;
    }
    while (v18 < (*(void *)(v13 + 56) - v14) >> 4);
  }
  for (uint64_t i = *(uint64_t **)(*(void *)(a1[5] + 8) + 64); i; uint64_t i = (uint64_t *)*i)
  {
    uint64_t v23 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)i + 6)];
    id v24 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)i + 4)];
    [v102 setObject:v23 forKeyedSubscript:v24];

    id v25 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)i + 7)];
    v113[0] = v25;
    CFStringRef v26 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)i + 8)];
    v113[1] = v26;
    id v27 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)i + 9)];
    v113[2] = v27;
    id v28 = +[NSNumber numberWithUnsignedLongLong:i[5]];
    v113[3] = v28;
    uint64_t v29 = +[NSArray arrayWithObjects:v113 count:4];
    uint64_t v30 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)i + 4)];
    [v101 setObject:v29 forKeyedSubscript:v30];

    if (*((_DWORD *)i + 12))
    {
      unint64_t v31 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:");
      v112[0] = v31;
      uint64_t v32 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)i + 13)];
      v112[1] = v32;
      char v33 = +[NSArray arrayWithObjects:v112 count:2];
      int v34 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)i + 4)];
      [v99 setObject:v33 forKeyedSubscript:v34];
    }
  }
  id v100 = +[NSMutableDictionary dictionaryWithCapacity:*(void *)(*(void *)(a1[7] + 8) + 72)];
  for (uint64_t j = *(uint64_t ***)(*(void *)(a1[7] + 8) + 64); j; uint64_t j = (uint64_t **)*j)
  {
    uint64_t v36 = +[NSMutableArray arrayWithCapacity:((char *)j[4] - (char *)j[3]) >> 4];
    uint64_t v38 = (unsigned int *)j[3];
    uint64_t v37 = (unsigned int *)j[4];
    while (v38 != v37)
    {
      id v39 = +[NSNumber numberWithUnsignedInt:*v38];
      v111[0] = v39;
      uint64_t v40 = +[NSNumber numberWithUnsignedLongLong:*((void *)v38 + 1)];
      v111[1] = v40;
      uint64_t v41 = +[NSArray arrayWithObjects:v111 count:2];
      [v36 addObject:v41];

      v38 += 4;
    }
    unsigned int v42 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)j + 4)];
    [v100 setObject:v36 forKeyedSubscript:v42];
  }
  id v107 = 0;
  unint64_t v92 = +[NSKeyedArchiver archivedDataWithRootObject:v102 requiringSecureCoding:1 error:&v107];
  id v43 = v107;
  id v106 = v43;
  CFStringRef v91 = +[NSKeyedArchiver archivedDataWithRootObject:v101 requiringSecureCoding:1 error:&v106];
  id v44 = v106;

  id v105 = v44;
  int v90 = +[NSKeyedArchiver archivedDataWithRootObject:v99 requiringSecureCoding:1 error:&v105];
  id v45 = v105;

  id v104 = v45;
  uint64_t v89 = +[NSKeyedArchiver archivedDataWithRootObject:v100 requiringSecureCoding:1 error:&v104];
  id v85 = v104;

  id v46 = [*(id *)(v97 + 1944) mappings];
  if (v46)
  {
    int64_t v93 = [*(id *)(v97 + 1944) mappings];
  }
  else
  {
    int64_t v93 = &__NSArray0__struct;
  }

  uint64_t v47 = [*(id *)(v97 + 1944) binaries];
  if (v47) {
    uint64_t v48 = (void *)v47;
  }
  else {
    uint64_t v48 = &__NSDictionary0__struct;
  }
  uint64_t v94 = v48;
  int v49 = *(_DWORD *)(v97 + 2188);
  if (v49)
  {
    if (v49 == 1)
    {
      unsigned int v86 = 0;
      goto LABEL_39;
    }
    int v50 = 1;
  }
  else
  {
    int v50 = *(unsigned char *)(v97 + 3184) & 1;
  }
  unsigned int v86 = v50;
LABEL_39:
  unint64_t v96 = objc_opt_new();
  [v96 setObject:&off_759D38 forKeyedSubscript:@"version"];
  sched_param v51 = +[NSNumber numberWithDouble:*(double *)(v97 + 3160)];
  [v96 setObject:v51 forKeyedSubscript:@"fractionOfCores"];

  id v52 = +[NSNumber numberWithDouble:*(double *)(v97 + 3168)];
  [v96 setObject:v52 forKeyedSubscript:@"thresholdInSeconds"];

  uint64_t v53 = +[NSNumber numberWithUnsignedLongLong:(*(void *)(v97 + 3184) >> 1) & 1];
  [v96 setObject:v53 forKeyedSubscript:@"usingMinimumTracingMode"];

  uint64_t v54 = +[NSNumber numberWithUnsignedLongLong:*(void *)(v97 + 3176)];
  [v96 setObject:v54 forKeyedSubscript:@"drawCountThreshold"];

  id v55 = +[NSMutableArray arrayWithCapacity:*(void *)(v97 + 3200)];
  id v56 = *(void **)(v97 + 3192);
  unint64_t v57 = *(void *)(v97 + 3200);
  int v58 = v57 & 0x3F;
  if (v57 > 0x3F || (v57 & 0x3F) != 0)
  {
    int v59 = 0;
    int v60 = 0;
    int v61 = &v56[v57 >> 6];
    do
    {
      sched_param v62 = +[NSNumber numberWithBool:(*v56 >> v60) & 1];
      [v55 addObject:v62];

      v56 += v59 == 63;
      if (v59 == 63) {
        int v60 = 0;
      }
      else {
        ++v60;
      }
      int v59 = v60;
    }
    while (v56 != v61 || v58 != v60);
  }
  id v63 = [v55 copy];
  [v96 setObject:v63 forKeyedSubscript:@"usedCoreMasks"];

  mach_timebase_info info = 0;
  mach_timebase_info(&info);
  uint64_t v64 = *(void **)(v97 + 2088);
  if (!v64) {
    uint64_t v64 = &__NSDictionary0__struct;
  }
  id v88 = v64;
  v109[0] = @"Program Address Mappings";
  v109[1] = @"TraceId to BatchId";
  v110[0] = v93;
  v110[1] = v92;
  v109[2] = @"Source Sample Marker";
  uint64_t v65 = +[NSNumber numberWithUnsignedLongLong:*(void *)(v97 + 32)];
  uint64_t v66 = a1[4];
  v110[2] = v65;
  v110[3] = v66;
  v109[3] = @"Frame Encoder Time Data";
  v109[4] = @"TraceId to SampleIndex";
  v110[4] = v91;
  v110[5] = v90;
  v109[5] = @"TraceId to Tile Info";
  v109[6] = @"MTLFX TraceIds";
  long long v83 = (void *)v65;
  uint64_t v67 = [*(id *)(*(void *)(a1[8] + 8) + 40) mtlfxTracingInfo];
  long long v84 = (void *)v67;
  if (v67) {
    uint64_t v68 = (void *)v67;
  }
  else {
    uint64_t v68 = &__NSDictionary0__struct;
  }
  v110[6] = v68;
  v109[7] = @"Frame Consistent Perf Info";
  v110[7] = *(void *)(*(void *)(a1[9] + 8) + 40);
  v110[8] = v98;
  v109[8] = @"Restore Timestamps";
  v109[9] = @"Command Buffer Timestamps";
  v110[9] = v95;
  v110[10] = v89;
  v109[10] = @"TraceId to Coalesced BatchId";
  v109[11] = @"Configuration Variables";
  v110[11] = *(void *)(v97 + 1984);
  v109[12] = @"useOverlap";
  long long v82 = +[NSNumber numberWithBool:v86];
  v110[12] = v82;
  v110[13] = v94;
  v109[13] = @"Binaries";
  v109[14] = @"Streaming Counters";
  long long v87 = +[NSNumber numberWithBool:*(_DWORD *)(v97 + 2188) == 1];
  v110[14] = v87;
  v109[15] = @"Kick State Trigger Options";
  long long v81 = [*(id *)(v97 + 2072) firstObject];
  int v69 = [v81 options];
  if (v69)
  {
    unint64_t v79 = [*(id *)(v97 + 2072) firstObject];
    unint64_t v70 = [v79 options];
  }
  else
  {
    unint64_t v70 = &__NSDictionary0__struct;
  }
  char v71 = *(void **)(v97 + 2064);
  if (!v71) {
    char v71 = &__NSDictionary0__struct;
  }
  unint64_t v80 = v70;
  v110[15] = v70;
  v110[16] = v71;
  v109[16] = @"APS Options";
  v109[17] = @"Continuous Time";
  uint64_t v72 = +[NSNumber numberWithUnsignedLongLong:*(void *)(*(void *)(a1[10] + 8) + 24)];
  v110[17] = v72;
  v109[18] = @"Absolute Time";
  id v73 = +[NSNumber numberWithUnsignedLongLong:*(void *)(*(void *)(a1[11] + 8) + 24)];
  v110[18] = v73;
  v109[19] = @"Timebase";
  uint64_t v74 = +[NSNumber numberWithUnsignedInt:info.numer];
  v108[0] = v74;
  unint64_t v75 = +[NSNumber numberWithUnsignedInt:info.denom];
  v108[1] = v75;
  unint64_t v76 = +[NSArray arrayWithObjects:v108 count:2];
  v110[19] = v76;
  v110[20] = v96;
  v109[20] = @"apsProfilingConfig";
  v109[21] = @"Perf Info";
  v110[21] = v88;
  v109[22] = @"ReplayerGPUTime";
  BOOL v77 = +[NSNumber numberWithDouble:*(double *)(v97 + 3152)];
  v110[22] = v77;
  unint64_t v78 = +[NSDictionary dictionaryWithObjects:v110 forKeys:v109 count:23];

  if (v69)
  {
  }
  (*(void (**)(void))(*(void *)(*(void *)v97 + 32) + 16))();
}

void sub_1E611C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,uint64_t a26,void *a27,void *a28,void *a29,void *a30,void *a31)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper9StreamAPSEv_block_invoke_2(uint64_t a1)
{
  unsigned __int8 v1 = *(GTMTLReplayController ****)(a1 + 112);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)v1 + 2763);
  if ((v2 & 1) == 0)
  {
    unsigned __int8 v3 = atomic_load((unsigned __int8 *)v1 + 2764);
    if ((v3 & 1) == 0)
    {
      atomic_store(0, (unsigned __int8 *)v1 + 2760);
      if (*((_DWORD *)v1 + 544) != -1)
      {
        long long v111 = [v1[2] firstObject];
        int v4 = *((_DWORD *)v1 + 547);
        BOOL v5 = v4 == 1 || (v4 | (_BYTE)v1[398] & 1) == 0;
        if (GTAGXPerfStateControl::IsGPUPerformanceStateInduced((GTAGXPerfStateControl *)(v1 + 5)))
        {
          CFStringRef v117 = @"DisableOverlap";
          unint64_t v6 = +[NSNumber numberWithBool:v5];
          int v122 = v6;
          uint64_t v7 = +[NSDictionary dictionaryWithObjects:&v122 forKeys:&v117 count:1];
          uint64_t v8 = [v1[2] firstObject];
          [v8 setOptions:v7];
        }
        else
        {
          uint64_t v9 = *((unsigned int *)*v1 + 18);
          if (v9)
          {
            GTAGXPerfStateControl::EnableConsistentGPUPerfState((uint64_t)(v1 + 5), v9);
            uint64_t v10 = GTApplePMPPerfStateControl::EnableConsistentPerfState((GTApplePMPPerfStateControl *)(v1 + 8), *((_DWORD *)*v1 + 18) - 1);
            unint64_t v11 = v1[261];
            v1[261] = (GTMTLReplayController **)v10;

            CFStringRef v117 = @"DisableOverlap";
            unint64_t v6 = +[NSNumber numberWithBool:v5];
            int v122 = v6;
            uint64_t v7 = +[NSDictionary dictionaryWithObjects:&v122 forKeys:&v117 count:1];
            uint64_t v8 = [v1[2] firstObject];
            [v8 setOptions:v7];
          }
          else
          {
            uint64_t v12 = GTApplePMPPerfStateControl::EnableConsistentPerfState((GTApplePMPPerfStateControl *)(v1 + 8), 1u);
            uint64_t v13 = v1[261];
            v1[261] = (GTMTLReplayController **)v12;

            CFStringRef v117 = @"DisableOverlap";
            unint64_t v6 = +[NSNumber numberWithBool:v5];
            int v122 = v6;
            CFStringRef v118 = @"LockGPUPerfState";
            uint64_t v7 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)*v1 + 17)];
            unint64_t v123 = v7;
            uint64_t v8 = +[NSDictionary dictionaryWithObjects:&v122 forKeys:&v117 count:2];
            uint64_t v14 = [v1[2] firstObject];
            [v14 setOptions:v8];
          }
        }

        uint64_t v15 = [v1[3] objectAtIndexedSubscript:*((int *)v1 + 544)];
        [v15 setOptions:v1[258]];
        [v15 requestTriggers:v1[259] firstErrorIndex:0];
        __lk.__m_ = 0;
        unint64_t v16 = [v1[251] objectAtIndexedSubscript:*((int *)v1 + 544)];
        unsigned __int8 v17 = [v15 requestCounters:v16 firstErrorIndex:&__lk];

        if (v17)
        {
          unsigned int v18 = [v15 setEnabled:1];

          if (v18)
          {
            double v19 = *((double *)v1 + 394) + *((double *)v1 + 394);
            if (v19 <= 1.0) {
              double v20 = 10240.0;
            }
            else {
              double v20 = v19 * 10240.0;
            }
            id v21 = [v1[3] count];
            if (v21)
            {
              uint64_t v22 = 0;
              unsigned int v23 = 1;
              do
              {
                id v24 = [v1[251] objectAtIndexedSubscript:v22];
                [v24 count];

                uint64_t v22 = v23;
              }
              while ((unint64_t)v21 > v23++);
            }
            for (unsigned int i = 0; ; unsigned int i = v27 + 1)
            {
              uint64_t v27 = i;
              if ((unint64_t)[v1[3] count] <= i) {
                break;
              }
              id v28 = [v1[251] objectAtIndexedSubscript:i];
              if ([v28 count])
              {
                BOOL v29 = i == *((_DWORD *)v1 + 544);

                if (!v29)
                {
                  uint64_t v15 = [v1[3] objectAtIndexedSubscript:v27];
                  CFStringRef v116 = @"RingBufferSizeInKB";
                  uint64_t v30 = +[NSNumber numberWithUnsignedLong:(unint64_t)v20];
                  __lk.__m_ = v30;
                  uint64_t v31 = +[NSDictionary dictionaryWithObjects:&__lk forKeys:&v116 count:1];
                  [v15 setOptions:v31];

                  [v15 requestTriggers:v1[256] firstErrorIndex:0];
                  CFStringRef v115 = 0;
                  uint64_t v32 = [v1[251] objectAtIndexedSubscript:v27];
                  LOBYTE(v31) = [v15 requestCounters:v32 firstErrorIndex:&v115];

                  if ((v31 & 1) == 0) {
                    goto LABEL_29;
                  }
                  unsigned int v33 = [v15 setEnabled:1];

                  if (!v33) {
                    break;
                  }
                }
              }
              else
              {
              }
            }
          }
        }
        else
        {
LABEL_29:
        }
      }
      int v34 = *((_DWORD *)v1 + 547);
      CFStringRef v35 = @"T";
      if (!v34) {
        CFStringRef v35 = @"P";
      }
      if (v34 == 1) {
        CFStringRef v36 = @"C";
      }
      else {
        CFStringRef v36 = v35;
      }
      id v112 = [@"/tmp/com.apple.gputools.profiling" stringByAppendingPathComponent:v36];
      if (*((_DWORD *)v1 + 544) != -1)
      {
        long long v109 = +[NSFileManager defaultManager];
        [v109 removeItemAtPath:v112 error:0];
        [v109 createDirectoryAtPath:v112 withIntermediateDirectories:1 attributes:0 error:0];
        uint64_t v37 = [v1[3] objectAtIndexedSubscript:*((int *)v1 + 544)];
        unsigned int v38 = [v37 ringBufferNum];

        if (v38)
        {
          id v39 = [v1[3] objectAtIndexedSubscript:*((int *)v1 + 544)];
          unsigned int v40 = [v39 ringBufferNum];

          if (v40)
          {
            unint64_t v41 = 0;
            unsigned int v42 = (int64x2_t *)(v1 + 391);
            uint64_t v43 = v40;
            do
            {
              unint64_t v44 = (unint64_t)v1[392];
              id v45 = v1[393];
              if (v44 >= (unint64_t)v45)
              {
                uint64_t v47 = v42->i64[0];
                uint64_t v48 = (uint64_t)(v44 - v42->i64[0]) >> 5;
                unint64_t v49 = v48 + 1;
                if ((unint64_t)(v48 + 1) >> 59) {
                  abort();
                }
                uint64_t v50 = (uint64_t)v45 - v47;
                if (v50 >> 4 > v49) {
                  unint64_t v49 = v50 >> 4;
                }
                if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFE0) {
                  unint64_t v51 = 0x7FFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v51 = v49;
                }
                if (v51)
                {
                  if (v51 >> 59) {
                    std::__throw_bad_array_new_length[abi:nn180100]();
                  }
                  id v52 = (char *)operator new(32 * v51);
                }
                else
                {
                  id v52 = 0;
                }
                uint64_t v53 = &v52[32 * v48];
                *(_OWORD *)uint64_t v53 = 0u;
                *((_OWORD *)v53 + 1) = 0u;
                if (v44 == v47)
                {
                  int64x2_t v57 = vdupq_n_s64(v44);
                  uint64_t v54 = &v52[32 * v48];
                }
                else
                {
                  uint64_t v54 = &v52[32 * v48];
                  do
                  {
                    uint64_t v55 = *(void *)(v44 - 32);
                    v44 -= 32;
                    *(void *)unint64_t v44 = 0;
                    *((void *)v54 - 4) = v55;
                    v54 -= 32;
                    long long v56 = *(_OWORD *)(v44 + 8);
                    *((void *)v54 + 3) = *(void *)(v44 + 24);
                    *(_OWORD *)(v54 + 8) = v56;
                  }
                  while (v44 != v47);
                  int64x2_t v57 = *v42;
                }
                id v46 = (GTMTLReplayController **)(v53 + 32);
                v1[391] = (GTMTLReplayController **)v54;
                v1[392] = (GTMTLReplayController **)(v53 + 32);
                v1[393] = (GTMTLReplayController **)&v52[32 * v51];
                int v58 = (char *)v57.i64[1];
                int v59 = (char *)v57.i64[0];
                while (v58 != v59)
                {
                  int v60 = (void *)*((void *)v58 - 4);
                  v58 -= 32;
                }
                if (v59) {
                  operator delete(v59);
                }
              }
              else
              {
                id v46 = (GTMTLReplayController **)(v44 + 32);
                *(_OWORD *)unint64_t v44 = 0u;
                *(_OWORD *)(v44 + 16) = 0u;
              }
              v1[392] = v46;
              int v61 = +[NSString stringWithFormat:@"f_%u.raw", v41];
              uint64_t v62 = [v112 stringByAppendingPathComponent:v61];
              id v63 = *(v46 - 4);
              *(v46 - 4) = (GTMTLReplayController *)v62;

              *((_DWORD *)v46 - 2) = *((_DWORD *)v1 + 544);
              *((_DWORD *)v46 - 1) = v41;
              if ((*(unint64_t *)((char *)v1[399] + ((v41 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v41))
              {
                uint64_t v64 = fopen((const char *)[(GTMTLReplayController *)*(v46 - 4) UTF8String], "wb");
                *(v46 - 3) = (GTMTLReplayController *)v64;
                if (!v64)
                {
                  uint64_t v65 = +[NSString stringWithFormat:@"Error, fail to open file %@", *(v46 - 4)];
                  uint64_t v66 = __stdoutp;
                  int v67 = g_runningInCI;
                  id v68 = v65;
                  int v69 = (const char *)[v68 UTF8String];
                  unint64_t v70 = "#CI_ERROR# ";
                  if (!v67) {
                    unint64_t v70 = "";
                  }
                  fprintf(v66, "%s%s %u: %s\n", v70, "void GTUSCSamplingStreamingManagerHelper::SetupAPSDataFiles(NSString *__strong)", 6974, v69);
                  id v71 = v68;
                  GTMTLReplay_handleError(101, (uint64_t)[v71 UTF8String], "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTUSCSamplingStreamingManager.mm", (uint64_t)"SetupAPSDataFiles", 6974, 1);
                }
              }
              ++v41;
            }
            while (v41 != v43);
          }
        }
      }
      GTMTLReplayController_prePlayForProfiling((uint64_t)**v1);
      uint64_t v72 = a1;
      mach_get_times();
      id v73 = **v1;
      id v107 = v73->var1;
      atomic_store(0, (unsigned int *)v1 + 687);
      [*(id *)(v72 + 32) mapShaderSampleBufferWithBuffer:0 capacity:0 size:0];
      long long v110 = [v73->var1 defaultCommandQueue];
      unint64_t v123 = v73;
      LOBYTE(v124) = 0;
      int v122 = (GTMTLReplayController *)[(id)g_commandBufferDescriptor errorOptions];
      [(id)g_commandBufferDescriptor setErrorOptions:0];
      if (*((_DWORD *)v1 + 547) == 1) {
        DisableComputeEncoderCoalescing(**v1, 1);
      }
      GTUSCSamplingStreamingManagerHelper::ReplaySingleFrameForUSCSampling();
      if (*((_DWORD *)v1 + 547) == 1) {
        DisableComputeEncoderCoalescing(**v1, 0);
      }
      [v110 finish];
      ScopedReplayConfiguration::~ScopedReplayConfiguration((ScopedReplayConfiguration *)&v122);
      [*(id *)(a1 + 32) unmapShaderSampleBuffer];
      usleep(0x7530u);
      atomic_store(1u, (unsigned __int8 *)v1 + 2760);
      atomic_fetch_add((atomic_uint *volatile)v1 + 689, 1u);
      uint64_t v75 = GTAGXPerfStateControl::ConsistentGPUPerfStateLevel((GTAGXPerfStateControl *)(v1 + 5), 0);
      uint64_t v108 = (void *)v75;
      if (v75) {
        [*(id *)(*(void *)(*(void *)(a1 + 96) + 8) + 40) setDictionary:v75];
      }
      GTUSCSamplingStreamingManagerHelper::DrainAllSourceBuffers((intptr_t)v1[303], (uint64_t)v1[304]);
      __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v1 + 352);
      __lk.__owns_ = 1;
      std::mutex::lock((std::mutex *)v1 + 44);
      int v76 = *((_DWORD *)v1 + 541);
      unsigned int v77 = atomic_load((unsigned int *)v1 + 687);
      if (v76 != v77)
      {
        do
        {
          std::condition_variable::wait((std::condition_variable *)(v1 + 346), &__lk);
          int v78 = *((_DWORD *)v1 + 541);
          unsigned int v79 = atomic_load((unsigned int *)v1 + 687);
        }
        while (v78 != v79);
      }
      atomic_store(0, (unsigned __int8 *)v1 + 2761);
      unint64_t v80 = [v1[2] firstObject];
      [v80 stopSampling];

      GTAGXPerfStateControl::DisableConsistentGPUPerfState((GTAGXPerfStateControl *)(v1 + 5));
      GTApplePMPPerfStateControl::DisableConsistentPerfState((GTApplePMPPerfStateControl *)(v1 + 8));
      dispatch_semaphore_signal((dispatch_semaphore_t)v1[313]);
      dispatch_semaphore_wait((dispatch_semaphore_t)v1[314], 0xFFFFFFFFFFFFFFFFLL);
      long long v81 = (id *)v1[391];
      long long v82 = v1[392];
      if (v81 == (id *)v82)
      {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 104) + 8) + 24) = 0;
      }
      else
      {
        BOOL v83 = 0;
        uint64_t v84 = a1;
        do
        {
          id v85 = (FILE *)v81[1];
          if (v85)
          {
            fseek(v85, 0, 2);
            v81[2] = (id)ftell((FILE *)v81[1]);
            fclose((FILE *)v81[1]);
            if (v83)
            {
              BOOL v83 = 1;
            }
            else
            {
              unsigned int v86 = fopen((const char *)[*v81 UTF8String], "rb");
              unint64_t v87 = (unint64_t)v81[2];
              if (v87 <= 0x200000)
              {
                if (v87 < 0x1000)
                {
LABEL_92:
                  BOOL v83 = 0;
                }
                else
                {
                  uint64_t v88 = 0;
                  uint64_t v89 = 0;
                  unint64_t v90 = v87 >> 12;
                  if (v87 >> 12 <= 1) {
                    uint64_t v91 = 1;
                  }
                  else {
                    uint64_t v91 = v87 >> 12;
                  }
                  BOOL v83 = 1;
                  while (1)
                  {
                    fseek(v86, v88, 0);
                    ftell(v86);
                    int v92 = fgetc(v86);
                    if (v92 != 15 && v92 != -1) {
                      break;
                    }
                    BOOL v83 = ++v89 < v90;
                    v88 += 4096;
                    if (v91 == v89) {
                      goto LABEL_92;
                    }
                  }
                }
                fseek(v86, 0, 2);
              }
              else
              {
                BOOL v83 = 1;
              }
              fclose(v86);
            }
            v81[1] = 0;
            uint64_t v84 = a1;
          }
          v81 += 4;
        }
        while (v81 != (id *)v82);
        *(unsigned char *)(*(void *)(*(void *)(v84 + 104) + 8) + 24) = v83;
        if (v83)
        {
          int64_t v93 = +[NSFileManager defaultManager];
          uint64_t v94 = v1[391];
          uint64_t v95 = v1[392];
          while (v94 != v95)
          {
            unsigned __int8 v96 = [v93 fileExistsAtPath:*v94];
            if (v94[2]) {
              unsigned __int8 v97 = v96;
            }
            else {
              unsigned __int8 v97 = 0;
            }
            if (v97)
            {
              unint64_t v98 = [v1[3] objectAtIndexedSubscript:*((unsigned int *)v94 + 6)];
              CFStringRef v117 = @"APSTraceDataFile";
              int v122 = *v94;
              CFStringRef v118 = @"Source";
              unint64_t v99 = [v98 name];
              unint64_t v123 = v99;
              CFStringRef v119 = @"SourceIndex";
              id v100 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)v94 + 6)];
              unint64_t v124 = v100;
              CFStringRef v120 = @"RingBufferIndex";
              id v101 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)v94 + 7)];
              size_t v125 = v101;
              CFStringRef v121 = @"Serial";
              ++GTUSCSamplingStreamingManagerHelper::StreamAPSDataFiles(void)::serial;
              unint64_t v102 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:");
              uint64_t v126 = v102;
              unint64_t v103 = +[NSDictionary dictionaryWithObjects:&v122 forKeys:&v117 count:5];

              ((void (*)(void))(*v1)[4]->var2)();
              [v93 removeItemAtPath:*v94 error:0];
            }
            v94 += 4;
          }
          CFStringRef v115 = @"Post Processing Frame Marker";
          uint64_t v104 = atomic_load((unsigned int *)v1 + 689);
          id v105 = +[NSNumber numberWithUnsignedInt:v104];
          CFStringRef v116 = v105;
          id v106 = +[NSDictionary dictionaryWithObjects:&v116 forKeys:&v115 count:1];

          ((void (*)(void))(*v1)[4]->var2)();
        }
      }
      if (__lk.__owns_) {
        std::mutex::unlock(__lk.__m_);
      }
    }
  }
}

void sub_1E720C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::mutex *a23,char a24)
{
  _Unwind_Resume(a1);
}

unsigned __int8 *___ZN35GTUSCSamplingStreamingManagerHelper9StreamAPSEv_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  unsigned __int8 v2 = [*(id *)(v1 + 16) firstObject];
  [v2 startSampling];

  __n128 result = GTUSCSamplingStreamingManagerHelper::WaitForPreSampling((unsigned __int8 *)v1);
  atomic_store(1u, (unsigned __int8 *)(v1 + 2761));
  return result;
}

void sub_1E74C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StreamAPS(void)::$_2>>(std::__thread_struct **a1)
{
  id v24 = a1;
  uint64_t v1 = std::__thread_local_data();
  unsigned __int8 v2 = *v24;
  void *v24 = 0;
  pthread_setspecific(v1->__key_, v2);
  unsigned __int8 v3 = v24[1];
  do
  {
    unsigned __int8 v4 = atomic_load((unsigned __int8 *)&v3[345].__p_ + 3);
    if (v4) {
      break;
    }
    unsigned __int8 v5 = atomic_load((unsigned __int8 *)&v3[345].__p_ + 4);
    if (v5) {
      break;
    }
    p = v3[313].__p_;
    dispatch_time_t v7 = dispatch_time(0, 250000);
    intptr_t v23 = dispatch_semaphore_wait(p, v7);
    uint64_t v8 = v3[392].__p_;
    uint64_t v9 = v3[391].__p_;
    if (v8 != v9)
    {
      unint64_t v10 = 0;
      do
      {
        unint64_t v11 = (char *)v9 + 32 * v10;
        uint64_t v12 = (FILE *)*((void *)v11 + 1);
        if (v12)
        {
          unsigned int v13 = *((_DWORD *)v11 + 7);
          uint64_t v14 = v3[297].__p_;
          uint64_t v15 = (char *)v14 + 48 * v13;
          os_unfair_lock_lock((os_unfair_lock_t)v15 + 4);
          if (v23) {
            unint64_t v16 = *((void *)v15 + 1);
          }
          else {
            unint64_t v16 = 0xAAAAAAAAAAAAAAABLL
          }
                * ((uint64_t)(*((void *)v14 + 6 * v13 + 4) - *((void *)v14 + 6 * v13 + 3)) >> 3);
          os_unfair_lock_unlock((os_unfair_lock_t)v15 + 4);
          unint64_t v17 = *(void *)v15;
          if (v16 > *(void *)v15 && v16 - *(void *)v15 != 0)
          {
            double v19 = (void *)((char *)v14 + 48 * v13 + 24);
            do
            {
              uint64_t v20 = *v19 + 24 * v17;
              int v21 = fileno(v12);
              write(v21, *(const void **)v20, *(void *)(v20 + 8));
              unint64_t v17 = *(void *)v15 + 1;
              *(void *)uint64_t v15 = v17;
              if (*(void *)v20)
              {
                free(*(void **)v20);
                *(void *)uint64_t v20 = 0;
                *(void *)(v20 + 8) = 0;
                *(void *)(v20 + 16) = 0;
                unint64_t v17 = *(void *)v15;
              }
            }
            while (v17 < v16);
            if (!v23)
            {
              *((void *)v14 + 6 * v13 + 4) = *v19;
              *(void *)uint64_t v15 = 0;
              *((void *)v15 + 1) = 0;
            }
          }
          uint64_t v8 = v3[392].__p_;
          uint64_t v9 = v3[391].__p_;
        }
        ++v10;
      }
      while (v10 < (v8 - v9) >> 5);
    }
  }
  while (v23);
  dispatch_semaphore_signal((dispatch_semaphore_t)v3[314].__p_);
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::InitForPreSamplingWait(void)::$_0>>::~unique_ptr[abi:nn180100](&v24);
  return 0;
}

void sub_1E76A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::InitForPreSamplingWait(void)::$_0>>::~unique_ptr[abi:nn180100]((std::__thread_struct ***)va);
  _Unwind_Resume(a1);
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StreamAPS(void)::$_1>>(std::__thread_struct **a1)
{
  unsigned __int8 v4 = a1;
  uint64_t v1 = std::__thread_local_data();
  unsigned __int8 v2 = *v4;
  *unsigned __int8 v4 = 0;
  pthread_setspecific(v1->__key_, v2);
  GTUSCSamplingStreamingManagerHelper::PostProcessRawData((GTUSCSamplingStreamingManagerHelper *)v4[1], *((_DWORD *)v4 + 4), *((_DWORD *)v4 + 5));
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_0>>::~unique_ptr[abi:nn180100](&v4);
  return 0;
}

void sub_1E771C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_0>>::~unique_ptr[abi:nn180100]((std::__thread_struct ***)va);
  _Unwind_Resume(a1);
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StreamAPS(void)::$_0>>(std::__thread_struct **a1)
{
  id v39 = a1;
  uint64_t v1 = std::__thread_local_data();
  unsigned __int8 v2 = *v39;
  void *v39 = 0;
  pthread_setspecific(v1->__key_, v2);
  unsigned __int8 v3 = v39[1];
  if (SLODWORD(v3[272].__p_) >= 1)
  {
    unsigned int v4 = *((_DWORD *)v39 + 4);
    uint64_t v5 = *((unsigned int *)v39 + 5);
    if (v4)
    {
      GTUSCSamplingStreamingManagerHelper::PollAndDrainSourceRingBuffer((GTUSCSamplingStreamingManagerHelper *)v39[1], v4, *((unsigned int *)v39 + 5));
      goto LABEL_40;
    }
    unint64_t v6 = -[std::__thread_struct_imp objectAtIndexedSubscript:](v3[3].__p_, "objectAtIndexedSubscript:");
    CFStringRef v35 = (atomic_uint *)&v3[344];
    atomic_fetch_add((atomic_uint *volatile)&v3[344], 1u);
    unsigned __int8 v7 = atomic_load((unsigned __int8 *)&v3[345].__p_ + 3);
    if ((v7 & 1) == 0)
    {
      int v8 = v5 + 1;
      uint64_t v36 = v5;
      int v38 = v5 + 1;
      while (1)
      {
        unsigned __int8 v9 = atomic_load((unsigned __int8 *)&v3[345].__p_ + 4);
        if (v9) {
          goto LABEL_37;
        }
        unint64_t v10 = *(NSObject **)(*(void *)v3[303].__p_ + 8 * v5);
        dispatch_time_t v11 = dispatch_time(0, 500000);
        intptr_t v37 = dispatch_semaphore_wait(v10, v11);
        unsigned __int8 v12 = atomic_load((unsigned __int8 *)&v3[345].__p_ + 1);
        if (v12)
        {
          int p = (int)v3[402].__p_;
          unint64_t v14 = (p * v5);
          uint64_t v15 = v3[391].__p_;
          unsigned int v16 = p * v8;
          if (v16 >= ((unint64_t)(v3[392].__p_ - v15) >> 5)) {
            unsigned int v16 = (unint64_t)(v3[392].__p_ - v15) >> 5;
          }
          if (v14 < v16)
          {
            uint64_t v17 = 48 * v14;
            uint64_t v18 = (32 * v14) | 0x1C;
            while (1)
            {
              if (objc_msgSend(v6, "isEnabled", v35))
              {
                unint64_t v41 = 0;
                memset(v40, 0, sizeof(v40));
                if ([v6 ringBufferInfoAtIndex:*(unsigned int *)((char *)v15 + v18) base:&v41 size:&v40[2] dataOffset:&v40[1] dataSize:v40])
                {
                  unsigned int v19 = v40[0];
                  if (v40[0] >> 13) {
                    break;
                  }
                  unsigned __int8 v20 = atomic_load((unsigned __int8 *)&v3[345]);
                  if (v20)
                  {
                    unsigned int v19 = v40[0];
                    if (v40[0]) {
                      break;
                    }
                  }
                }
              }
LABEL_25:
              ++v14;
              uint64_t v15 = v3[391].__p_;
              unint64_t v26 = (unint64_t)(v3[392].__p_ - v15) >> 5;
              unsigned int v27 = LODWORD(v3[402].__p_) * v8;
              if (v27 >= v26) {
                unint64_t v26 = v26;
              }
              else {
                unint64_t v26 = v27;
              }
              v17 += 48;
              v18 += 32;
              if (v14 >= v26) {
                goto LABEL_29;
              }
            }
            if ((*(void *)((char *)v3[399].__p_ + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v14))
            {
              int v21 = v40[2];
              unsigned int v22 = v19 + v40[1];
              intptr_t v23 = (std::__thread_struct_imp *)((char *)v3[297].__p_ + v17);
              id v24 = v41;
              id v25 = &v41[v40[1]];
              if (v19 + v40[1] <= v40[2]) {
                goto LABEL_21;
              }
              DynamicBuffer::AddBuffer2((DynamicBuffer *)((char *)v3[297].__p_ + v17), v25, (const unsigned __int8 *)(v40[2] - v40[1]));
              unsigned int v19 = v22 - v21;
              if (v22 != v21)
              {
                id v25 = v24;
LABEL_21:
                DynamicBuffer::AddBuffer2(v23, v25, (const unsigned __int8 *)v19);
              }
            }
            int v8 = v38;
            if ([v6 drainRingBufferAtIndex:*(unsigned int *)((char *)v15 + v18) dataSize:v40[0]]|| !v40[0])
            {
              atomic_fetch_add((atomic_uint *volatile)&v3[342].__p_ + 1, 1u);
              atomic_fetch_add((atomic_uint *volatile)&v3[343], 1u);
            }
            goto LABEL_25;
          }
LABEL_29:
          uint64_t v5 = v36;
          if (!v37) {
            break;
          }
          unsigned __int8 v28 = atomic_load((unsigned __int8 *)&v3[345]);
          if (v28) {
            break;
          }
        }
        unsigned __int8 v29 = atomic_load((unsigned __int8 *)&v3[345].__p_ + 3);
        if (v29) {
          goto LABEL_37;
        }
      }
      uint64_t v30 = (atomic_uint *)&v3[343].__p_ + 1;
      uint64_t v31 = 402;
      if (HIDWORD(v3[402].__p_) == v36) {
        uint64_t v31 = 403;
      }
      atomic_fetch_add(v30, v3[v31].__p_);
      unsigned int v32 = atomic_load((unsigned int *)v30);
      if (v32 == HIDWORD(v3[270].__p_)) {
        std::condition_variable::notify_all((std::condition_variable *)&v3[346]);
      }
    }
LABEL_37:
    atomic_fetch_add(v35, 0xFFFFFFFF);
    if (!atomic_load((unsigned int *)v35)) {
      std::condition_variable::notify_all((std::condition_variable *)&v3[374]);
    }
  }
LABEL_40:
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_0>>::~unique_ptr[abi:nn180100](&v39);
  return 0;
}

void sub_1E7A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);

  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_0>>::~unique_ptr[abi:nn180100]((std::__thread_struct ***)va);
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper23StreamHarvestedBinariesEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(uint64_t ***)(a1 + 40);
  GTMTLReplayController_prePlayForProfiling(**v1);
  uint64_t v2 = **v1;
  id v69 = [objc_alloc((Class)NSMutableArray) initWithCapacity:1024];
  *(void *)&long long v70 = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:128];
  *((void *)&v70 + 1) = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:128];
  id v71 = (NSMutableDictionary *)[objc_alloc((Class)NSMutableDictionary) initWithCapacity:128];
  id v54 = v69;
  uint64_t v72 = (NSMutableDictionary *)[objc_alloc((Class)NSMutableDictionary) initWithCapacity:128];
  id v48 = *(id *)(v2 + 8);
  memset(v67, 0, sizeof(v67));
  int v68 = 1065353216;
  memset(v65, 0, sizeof(v65));
  int v66 = 1065353216;
  __int p = 0;
  id v63 = 0;
  uint64_t v64 = 0;
  unsigned int v4 = [[ProgramAddressTableCollector alloc] initForHarvestingBinaries];
  uint64_t v5 = v1[243];
  v1[243] = v4;

  uint64_t v6 = objc_opt_new();
  unsigned __int8 v7 = v1[244];
  v1[244] = (uint64_t *)v6;

  v1[245] = 0;
  unint64_t v51 = [*(id *)(v2 + 8) defaultDevice];
  uint64_t v50 = [*(id *)(v2 + 8) defaultCommandQueue];
  [v51 mapShaderSampleBufferWithBuffer:0 capacity:0 size:0];
  v77[1] = v2;
  char v78 = 0;
  v77[0] = [(id)g_commandBufferDescriptor errorOptions];
  [(id)g_commandBufferDescriptor setErrorOptions:0];
  GTUSCSamplingStreamingManagerHelper::ReplaySingleFrameForUSCSampling();
  [v50 finish];
  ScopedReplayConfiguration::~ScopedReplayConfiguration((ScopedReplayConfiguration *)v77);
  [v51 unmapShaderSampleBuffer];
  unint64_t v49 = [v1[243] mappings];
  id v52 = [v1[243] binaries];
  uint64_t v55 = objc_opt_new();
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  obuint64_t j = v49;
  id v9 = [obj countByEnumeratingWithState:&v58 objects:v77 count:16];
  if (v9)
  {
    id v56 = *(id *)v59;
    do
    {
      unint64_t v10 = 0;
      do
      {
        if (*(id *)v59 != v56) {
          objc_enumerationMutation(obj);
        }
        dispatch_time_t v11 = *(void **)(*((void *)&v58 + 1) + 8 * (void)v10);
        unsigned __int8 v12 = [v11 objectForKeyedSubscript:@"encID"];
        [v12 unsignedIntValue];

        unsigned int v13 = [v11 objectForKeyedSubscript:@"encIndex"];
        id v14 = [v13 unsignedIntValue];

        uint64_t v15 = [v11 objectForKeyedSubscript:@"drawCallIndex"];
        id v16 = [v15 unsignedIntValue];

        uint64_t v17 = [v11 objectForKeyedSubscript:@"index"];
        unsigned int v18 = [v17 unsignedIntValue];

        unsigned int v19 = [v11 objectForKeyedSubscript:@"mappedSize"];
        id v20 = [v19 unsignedLongLongValue];

        int v21 = [v11 objectForKeyedSubscript:@"type"];
        unsigned int v22 = [v11 objectForKeyedSubscript:@"binaryUniqueId"];
        if (([v21 isEqualToString:@"AccelerationStructure"] & 1) == 0)
        {
          intptr_t v23 = GTShaderProfilerGenerateComputedKey((uint64_t)v14, (uint64_t)v16, (uint64_t)v20, v21);
          id v24 = [v1[244] objectForKeyedSubscript:v23];
          BOOL v25 = v24 == 0;

          if (!v25)
          {
            unint64_t v26 = [v55 objectForKeyedSubscript:v23];
            unsigned int v27 = [v26 unsignedIntValue];

            uint64_t v28 = v27 + 1;
            uint64_t v29 = +[NSString stringWithFormat:@"%@_%u", v23, v28];

            uint64_t v30 = +[NSNumber numberWithUnsignedInt:v28];
            [v55 setObject:v30 forKeyedSubscript:v29];

            intptr_t v23 = (void *)v29;
          }
          [v1[244] setObject:v22 forKeyedSubscript:v23];
          if (v18 != -1)
          {
            id v31 = [v54 count];
            id v32 = v69;
            if (v31 == (id)v16)
            {
              unsigned int v33 = objc_opt_new();
              [v32 addObject:v33];
            }
            id v54 = v32;
            int v34 = [v32 objectAtIndexedSubscript:v16];
            CFStringRef v35 = [v34 objectForKeyedSubscript:@"mutiple binary keys"];
            BOOL v36 = v35 == 0;

            if (v36)
            {
              intptr_t v37 = objc_opt_new();
              [v34 setObject:v37 forKeyedSubscript:@"mutiple binary keys"];
            }
            int v38 = [v52 objectForKeyedSubscript:v22];
            if ([v21 isEqualToString:@"vertex"])
            {
              id v39 = AddShaderBinary((NSMutableDictionary *)v70, v38, v22, *((unsigned __int8 *)v1 + 2185), *((unsigned int *)*v1 + 19), (NSString *)&v22->isa, 0, (NSString *)v21);
              [v34 setObject:v39 forKeyedSubscript:@"vertex shader key"];

              unsigned int v40 = [v34 objectForKeyedSubscript:@"mutiple binary keys"];
              unint64_t v41 = AddShaderBinary(v72, v38, v22, *((unsigned __int8 *)v1 + 2185), *((unsigned int *)*v1 + 19), (NSString *)&v22->isa, 0, (NSString *)v21);
              [v40 addObject:v41];
              goto LABEL_21;
            }
            if ([v21 isEqualToString:@"fragment"])
            {
              unsigned int v42 = AddShaderBinary(*((NSMutableDictionary **)&v70 + 1), v38, v22, *((unsigned __int8 *)v1 + 2185), *((unsigned int *)*v1 + 19), (NSString *)&v22->isa, 0, (NSString *)v21);
              [v34 setObject:v42 forKeyedSubscript:@"fragment shader key"];

              unsigned int v40 = [v34 objectForKeyedSubscript:@"mutiple binary keys"];
              unint64_t v41 = AddShaderBinary(v72, v38, v22, *((unsigned __int8 *)v1 + 2185), *((unsigned int *)*v1 + 19), (NSString *)&v22->isa, 0, (NSString *)v21);
              [v40 addObject:v41];
              goto LABEL_21;
            }
            if (([v21 isEqualToString:@"compute"] & 1) != 0
              || [v21 isEqualToString:@"tile"])
            {
              uint64_t v43 = AddShaderBinary(v71, v38, v22, *((unsigned __int8 *)v1 + 2185), *((unsigned int *)*v1 + 19), (NSString *)&v22->isa, 0, (NSString *)v21);
              [v34 setObject:v43 forKeyedSubscript:@"compute kernel key"];

              unsigned int v40 = [v34 objectForKeyedSubscript:@"mutiple binary keys"];
              unint64_t v41 = AddShaderBinary(v72, v38, v22, *((unsigned __int8 *)v1 + 2185), *((unsigned int *)*v1 + 19), (NSString *)&v22->isa, 0, (NSString *)v21);
              [v40 addObject:v41];
              goto LABEL_21;
            }
            if ([v21 containsString:@"dynamic-libraries"])
            {
              unsigned int v40 = [v34 objectForKeyedSubscript:@"mutiple binary keys"];
              unint64_t v41 = AddShaderBinary(v72, v38, v22, *((unsigned __int8 *)v1 + 2185), *((unsigned int *)*v1 + 19), (NSString *)&v22->isa, 1, (NSString *)v21);
              [v40 addObject:v41];
LABEL_21:
            }
          }
        }
        unint64_t v10 = (char *)v10 + 1;
      }
      while (v9 != v10);
      id v44 = [obj countByEnumeratingWithState:&v58 objects:v77 count:16];
      id v9 = v44;
    }
    while (v44);
  }

  v1[245] = v1[241];
  v1[241] = 0;
  id v45 = GTUSCSamplingStreamingManagerHelper::AllocUSCSamplingAddressBuffer((GTUSCSamplingStreamingManagerHelper *)v1);
  v73[0] = @"draw call info";
  v73[1] = @"mutiple binary info";
  v74[0] = v54;
  v74[1] = v72;
  v73[2] = @"internal binary keys";
  v73[3] = @"vertex fetch shader info";
  v74[2] = &__NSArray0__struct;
  v74[3] = &__NSDictionary0__struct;
  long long v75 = v70;
  v73[4] = @"vertex shader info";
  v73[5] = @"fragment shader info";
  v73[6] = @"compute kernel info";
  int v76 = v71;
  id v57 = +[NSDictionary dictionaryWithObjects:v74 forKeys:v73 count:7];

  if (__p)
  {
    id v63 = __p;
    operator delete(__p);
  }
  std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table((uint64_t)v65);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v67);

  id v46 = *(void **)(a1 + 32);
  if (v46) {
    [v46 setObject:v57 forKeyedSubscript:@"Havested Binaries"];
  }
}

void sub_1E8458(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  _Unwind_Resume(a1);
}

void ___ZN29GTUSCSamplingStreamingManagerC2EP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryU13block_pointerFvS5_E_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)v1;
  unsigned __int8 v3 = [*(id *)(v1 + 16) objectForKeyedSubscript:@"GPUState"];
  unsigned __int8 v12 = v3;
  if (!v3 || (unsigned int v4 = [v3 unsignedIntValue], *(_DWORD *)(v1 + 72) = v4, v5 = v12, !v4))
  {
    *(_DWORD *)(v1 + 72) = 0;
    uint64_t v6 = ExpectedState(v2);
    unsigned __int8 v7 = v6;
    if (v6)
    {
      [v6 doubleValue];
      double v9 = floor(v8);
      unsigned int v10 = (v9 * 100.0);
      *(_DWORD *)(v1 + 64) = v10;
      *(_DWORD *)(v1 + 68) = (ceil(v8) * 100.0);
      double v11 = v8 - v9;
      *(double *)(v1 + 24) = v11;
      if (v11 <= 2.22044605e-16) {
        *(_DWORD *)(v1 + 68) = v10;
      }
    }
    else
    {
      *(int32x2_t *)(v1 + 64) = vdup_n_s32(0x12Cu);
    }

    uint64_t v5 = v12;
  }
}

void sub_1E8780(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t GTUSCSamplingStreamingManager::GTUSCSamplingStreamingManager(uint64_t a1, uint64_t a2, id *a3, void *a4, void *a5)
{
  id v9 = a4;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  id v10 = v9;
  *(void *)(a1 + 16) = v10;
  id v11 = objc_retainBlock(a5);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = v11;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 76) = 0x7FFFFFFF;
  uint64_t v12 = objc_opt_new();
  unsigned int v13 = *(void **)(a1 + 40);
  *(void *)(a1 + 40) = v12;

  uint64_t v14 = objc_opt_new();
  uint64_t v15 = *(void **)(a1 + 48);
  *(void *)(a1 + 48) = v14;

  *(void *)(a1 + 24) = 0x3FF0000000000000;
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = ___ZN29GTUSCSamplingStreamingManagerC2EP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryU13block_pointerFvS5_E_block_invoke;
  v18[3] = &__block_descriptor_40_e5_v8__0l;
  void v18[4] = a1;
  id v16 = +[NSBlockOperation blockOperationWithBlock:v18];
  [v16 setQueuePriority:8];
  [*a3 addOperation:v16];
  [v16 waitUntilFinished];

  return a1;
}

void sub_1E88D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(id *this)
{
}

void GTUSCSamplingStreamingManager::InitTargetIndex(id *this)
{
  uint64_t v2 = [this[2] objectForKeyedSubscript:@"MetalPluginName"];
  id v3 = this[7];
  this[7] = (id)v2;

  if (this[7])
  {
    unsigned int v4 = [this[2] objectForKeyedSubscript:@"gpuTarget"];
    id v5 = v4;
    if (v4) {
      *((_DWORD *)this + 19) = [v4 intValue];
    }
  }
  else
  {
    io_registry_entry_t IOAccelerator = GetIOAccelerator();
    uint64_t v7 = GetMetalPluginName(IOAccelerator, (_DWORD *)this + 19);
    id v5 = this[7];
    this[7] = (id)v7;
  }

  if (*((_DWORD *)this + 19) == 0x7FFFFFFF) {
    *((_DWORD *)this + 19) = MetalPluginTarget(this[7]);
  }
}

void sub_1E8A18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManager::InitDerivedCountersInfo(id *this)
{
  GTUSCSamplingStreamingManager::InitTargetIndex(this);
  uint64_t v2 = [this[2] objectForKeyedSubscript:@"derivedCounterInfo"];
  id v3 = this[6];
  this[6] = (id)v2;
}

void GTUSCSamplingStreamingManagerHelper::Instance(GTUSCSamplingStreamingManagerHelper *this)
{
  {
    if (v1)
    {
      GTUSCSamplingStreamingManagerHelper::GTUSCSamplingStreamingManagerHelper(v1);
      __cxa_atexit((void (*)(void *))GTUSCSamplingStreamingManagerHelper::~GTUSCSamplingStreamingManagerHelper, &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance, &def_1C1270);
    }
  }
}

void GTUSCSamplingStreamingManagerHelper::GTUSCSamplingStreamingManagerHelper(GTUSCSamplingStreamingManagerHelper *this)
{
  byte_772058 = 0;
  xmmword_772038 = 0u;
  *(_OWORD *)&qword_772048 = 0u;
  GTUSCSamplingStreamingManagerHelper::Instance(void)::instance = 0u;
  qword_772060 = 0;
  qword_772068 = 0;
  qword_772070[0] = 0x300000000;
  bzero(&unk_772078, 0x70CuLL);
  unk_7727A8 = 0u;
  xmmword_772798 = 0u;
  xmmword_7727C0 = 0u;
  unk_7727D0 = 0u;
  unk_7727E0 = 0u;
  *(_OWORD *)&qword_7727F0 = 0u;
  xmmword_772800 = 0u;
  *(_OWORD *)&qword_772810 = 0u;
  xmmword_772820 = 0u;
  *(_OWORD *)&qword_772830 = 0u;
  xmmword_772840 = 0u;
  *(_OWORD *)&qword_772850 = 0u;
  unk_772860 = 0u;
  unk_772870 = 0u;
  xmmword_772880 = 0u;
  unk_772890 = 0u;
  qword_7728A0 = 0;
  qword_7728A8 = 0xFFFFFFFFLL;
  unk_7728B0 = 257;
  byte_7728B2 = 1;
  unk_772900 = 0u;
  xmmword_7728E4 = 0u;
  unk_7728F4 = 0u;
  xmmword_7728C4 = 0u;
  unk_7728D4 = 0u;
  xmmword_7728B4 = 0u;
  dword_772910 = 1065353216;
  xmmword_772918 = 0u;
  xmmword_772928 = 0u;
  unk_772938 = 0u;
  xmmword_772948 = 0u;
  xmmword_772958 = 0u;
  xmmword_772968 = 0u;
  xmmword_772978 = 0u;
  xmmword_772988 = 0u;
  *(_OWORD *)&qword_772998 = 0u;
  xmmword_7729A8 = 0u;
  xmmword_7729B8 = 0u;
  xmmword_7729C8 = 0u;
  *(_OWORD *)&qword_7729D8 = 0u;
  xmmword_7729E8 = 0u;
  xmmword_7729F8 = 0u;
  xmmword_772A08 = 0u;
  unk_772A18 = 0u;
  qword_772A28 = 0;
  dword_772A30 = 1065353216;
  xmmword_772A38 = 0u;
  unk_772A48 = 0u;
  xmmword_772A58 = 0u;
  xmmword_772A68 = 0u;
  unk_772A78 = 0u;
  xmmword_772A88 = 0u;
  xmmword_772A98 = 0u;
  xmmword_772AA8 = 0u;
  dword_772AB8 = 1065353216;
  byte_772AC0 = 0;
  xmmword_772AC8 = 0u;
  xmmword_772AD8 = 0u;
  *(long long *)((char *)&xmmword_772AD8 + 13) = 0u;
  qword_772AF8 = 1018212795;
  unk_772B00 = 0u;
  unk_772B10 = 0u;
  qword_772B20 = 0;
  qword_772B28 = 850045863;
  unk_772B30 = 0u;
  unk_772B40 = 0u;
  unk_772B50 = 0u;
  qword_772B60 = 0;
  qword_772B68 = 1018212795;
  unk_772B70 = 0u;
  unk_772B80 = 0u;
  qword_772B90 = 0;
  qword_772B98 = 850045863;
  unk_772BA0 = 0u;
  unk_772BB0 = 0u;
  unk_772BC0 = 0u;
  qword_772BD0 = 0;
  qword_772BD8 = 1018212795;
  *(_OWORD *)algn_772BE0 = 0u;
  *(_OWORD *)&algn_772BE0[16] = 0u;
  qword_772C00 = 0;
  qword_772C08 = 850045863;
  qword_772C40 = 0;
  *(_OWORD *)&algn_772C10[32] = 0u;
  *(_OWORD *)&algn_772C10[16] = 0u;
  *(_OWORD *)algn_772C10 = 0u;
  *((void *)&xmmword_772C48 + 1) = -1;
  *(void *)&xmmword_772C48 = -1;
  qword_772C78 = 0;
  xmmword_772C68 = 0u;
  xmmword_772C58 = 0u;
  xmmword_772C80 = xmmword_4C7F70;
  qword_772C90 = 50000;
  qword_772C98 = qword_772C98 & 0xFFFFFFFFFFFFFFFCLL | 1;
  qword_772CA8 = 0;
  qword_772CA0 = 0;
  qword_772CB0 = 0;
  qword_772CB8 = 4;
  dword_772CC0 = 0;
}

void GTUSCSamplingStreamingManagerHelper::~GTUSCSamplingStreamingManagerHelper(GTUSCSamplingStreamingManagerHelper *this)
{
  dispatch_semaphore_signal(*((dispatch_semaphore_t *)this + 312));
  GTUSCSamplingStreamingManagerHelper::CleanUp(this);
  uint64_t v2 = (void *)*((void *)this + 399);
  if (v2) {
    operator delete(v2);
  }
  uint64_t v6 = (void **)((char *)this + 3128);
  std::vector<SourceFileInfo>::__destroy_vector::operator()[abi:nn180100](&v6);

  std::mutex::~mutex((std::mutex *)((char *)this + 3040));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 2992));
  std::mutex::~mutex((std::mutex *)((char *)this + 2928));
  std::condition_variable::~condition_variable((std::condition_variable *)this + 60);
  std::mutex::~mutex((std::mutex *)this + 44);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 2768));
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table((uint64_t)this + 2672);
  for (uint64_t i = 2648; i != 2552; i -= 24)
  {
    uint64_t v6 = (void **)((char *)this + i);
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v6);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table((uint64_t)this + 2536);

  uint64_t v6 = (void **)((char *)this + 2472);
  std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v6);
  uint64_t v6 = (void **)((char *)this + 2448);
  std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v6);
  uint64_t v6 = (void **)((char *)this + 2424);
  std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v6);
  uint64_t v6 = (void **)((char *)this + 2400);
  std::vector<std::vector<GTMMappedBuffer>>::__destroy_vector::operator()[abi:nn180100](&v6);
  uint64_t v6 = (void **)((char *)this + 2376);
  std::vector<DynamicBuffer>::__destroy_vector::operator()[abi:nn180100](&v6);
  uint64_t v6 = (void **)((char *)this + 2352);
  std::vector<std::vector<GTMMappedBuffer>>::__destroy_vector::operator()[abi:nn180100](&v6);
  uint64_t v6 = (void **)((char *)this + 2328);
  std::vector<std::vector<GTMMappedBuffer>>::__destroy_vector::operator()[abi:nn180100](&v6);

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)this + 2248);
  unsigned int v4 = (void *)*((void *)this + 278);
  if (v4)
  {
    *((void *)this + 279) = v4;
    operator delete(v4);
  }
  uint64_t v6 = (void **)((char *)this + 2200);
  std::vector<std::vector<ProfileEvent>>::__destroy_vector::operator()[abi:nn180100](&v6);

  GTSampleBufferManager::~GTSampleBufferManager((id *)this + 263);
  id v5 = (void *)*((void *)this + 238);
  if (v5)
  {
    *((void *)this + 239) = v5;
    operator delete(v5);
  }
  GTApplePMPPerfStateControl::~GTApplePMPPerfStateControl((GTUSCSamplingStreamingManagerHelper *)((char *)this + 64));
  GTAGXPerfStateControl::~GTAGXPerfStateControl((id *)this + 5);
}

void sub_1E8FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v12 = *(void **)(v10 + 3192);
  if (v12) {
    operator delete(v12);
  }
  a10 = (void **)(v10 + 3128);
  std::vector<SourceFileInfo>::__destroy_vector::operator()[abi:nn180100](&a10);

  std::mutex::~mutex((std::mutex *)(v10 + 3040));
  std::condition_variable::~condition_variable((std::condition_variable *)(v10 + 2992));
  std::mutex::~mutex((std::mutex *)(v10 + 2928));
  std::condition_variable::~condition_variable((std::condition_variable *)(v10 + 2880));
  std::mutex::~mutex((std::mutex *)(v10 + 2816));
  std::condition_variable::~condition_variable((std::condition_variable *)(v10 + 2768));
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table(v10 + 2672);
  for (uint64_t i = 0; i != -96; i -= 24)
  {
    a10 = (void **)(v10 + 2648 + i);
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&a10);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table(v10 + 2536);

  a10 = (void **)(v10 + 2472);
  std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&a10);
  a10 = (void **)(v10 + 2448);
  std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__destroy_vector::operator()[abi:nn180100](&a10);
  a10 = (void **)(v10 + 2424);
  std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__destroy_vector::operator()[abi:nn180100](&a10);
  a10 = (void **)(v10 + 2400);
  std::vector<std::vector<GTMMappedBuffer>>::__destroy_vector::operator()[abi:nn180100](&a10);
  a10 = (void **)(v10 + 2376);
  std::vector<DynamicBuffer>::__destroy_vector::operator()[abi:nn180100](&a10);
  a10 = (void **)(v10 + 2352);
  std::vector<std::vector<GTMMappedBuffer>>::__destroy_vector::operator()[abi:nn180100](&a10);
  a10 = (void **)(v10 + 2328);
  std::vector<std::vector<GTMMappedBuffer>>::__destroy_vector::operator()[abi:nn180100](&a10);

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v10 + 2248);
  uint64_t v14 = *(void **)(v10 + 2224);
  if (v14)
  {
    *(void *)(v10 + 2232) = v14;
    operator delete(v14);
  }
  a10 = (void **)(v10 + 2200);
  std::vector<std::vector<ProfileEvent>>::__destroy_vector::operator()[abi:nn180100](&a10);

  GTSampleBufferManager::~GTSampleBufferManager((id *)(v10 + 2104));
  uint64_t v15 = *(void **)(v10 + 1904);
  if (v15)
  {
    *(void *)(v10 + 1912) = v15;
    operator delete(v15);
  }
  GTApplePMPPerfStateControl::~GTApplePMPPerfStateControl((GTApplePMPPerfStateControl *)(v10 + 64));
  GTAGXPerfStateControl::~GTAGXPerfStateControl((id *)(v10 + 40));

  _Unwind_Resume(a1);
}

void std::vector<SourceFileInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unsigned int v4 = (char *)v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = (void *)*((void *)v4 - 4);
        v4 -= 32;
      }
      while (v4 != v2);
      id v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      id v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::string>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  unsigned int v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    unsigned int v4 = (void **)v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v6);
      }
      while (v4 != v2);
      id v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::vector<GTMMappedBuffer>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    unsigned int v4 = (void **)v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v6);
      }
      while (v4 != v2);
      id v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<DynamicBuffer>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<DynamicBuffer>::__clear[abi:nn180100]((uint64_t *)v2);
    id v3 = **a1;
    operator delete(v3);
  }
}

void GTSampleBufferManager::~GTSampleBufferManager(id *this)
{
  [this[2] removeAllObjects];
  id v2 = *this;
  *this = 0;

  id v3 = this[3];
  if (v3)
  {
    this[4] = v3;
    operator delete(v3);
  }
}

void sub_1E94AC(_Unwind_Exception *a1)
{
  id v3 = *(void **)(v1 + 24);
  if (v3)
  {
    *(void *)(v1 + 32) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(a1);
}

void GTApplePMPPerfStateControl::~GTApplePMPPerfStateControl(GTApplePMPPerfStateControl *this)
{
  GTApplePMPPerfStateControl::Close(this);
  for (uint64_t i = 1752; i != -40; i -= 56)
}

void sub_1E9520(_Unwind_Exception *a1)
{
  for (uint64_t i = 1752; i != -40; i -= 56)

  _Unwind_Resume(a1);
}

void GTAGXPerfStateControl::~GTAGXPerfStateControl(id *this)
{
  io_connect_t v2 = *(_DWORD *)this;
  if (v2)
  {
    IOServiceClose(v2);
    *(_DWORD *)this = 0;
  }
}

void sub_1E9580(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GPURawCounterSetupParams::~GPURawCounterSetupParams(id *this)
{
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::string>>,0>(uint64_t a1)
{
  id v3 = (void **)(a1 + 24);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v3);
  if (*(char *)(a1 + 23) < 0)
  {
    io_connect_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

float64_t GetTextureRendererUniform(uint64_t a1, float64_t *a2, int a3, uint64_t a4, uint64_t a5, float64x2_t a6, float64_t a7, float64x2_t a8, float64_t a9, float64x2_t a10, float64_t a11, double a12, double a13, double a14, double a15)
{
  v17.f64[0] = a2[8];
  v18.f64[0] = a2[9];
  v17.f64[1] = a2[12];
  v19.f64[0] = *a2;
  v20.f64[0] = a2[1];
  v19.f64[1] = a2[4];
  v18.f64[1] = a2[13];
  v20.f64[1] = a2[5];
  *(float32x4_t *)a1 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v19), v17);
  *(float32x4_t *)(a1 + 16) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v20), v18);
  v17.f64[0] = a2[10];
  v18.f64[0] = a2[11];
  v22.f64[1] = a2[14];
  v19.f64[0] = a2[2];
  v20.f64[0] = a2[3];
  v19.f64[1] = a2[6];
  float32x4_t v21 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v19), v22);
  v18.f64[1] = a2[15];
  v20.f64[1] = a2[7];
  v22.f64[0] = a14;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(float32x4_t *)(a1 + 32) = v21;
  *(float32x4_t *)(a1 + 48) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v20), v18);
  if (a3)
  {
    v23.i64[0] = a4;
    v23.i64[1] = a5;
    float64x2_t v24 = vcvtq_f64_u64(v23);
    double v25 = a14 / v24.f64[0];
    if (a14 / v24.f64[0] >= a15 / v24.f64[1]) {
      double v25 = a15 / v24.f64[1];
    }
    v22.f64[1] = a15;
    float32x2_t v26 = vcvt_f32_f64(vmulq_n_f64(v24, v25 / a12));
    __asm { FMOV            V4.2D, #0.5 }
    a8 = vmulq_f64(vsubq_f64(vdivq_f64(v22, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a12, 0)), vcvtq_f64_f32(v26)), _Q4);
  }
  else
  {
    a8.f64[1] = a9;
    a10.f64[1] = a11;
    float32x2_t v26 = vcvt_f32_f64(a10);
    v22.f64[1] = a15;
  }
  *(float32x2_t *)(a1 + 64) = vcvt_f32_f64(a8);
  *(float32x2_t *)(a1 + 72) = v26;
  a6.f64[1] = a7;
  *(float32x2_t *)&a6.f64[0] = vcvt_f32_f64(a6);
  float v33 = a12;
  *(float *)(a1 + 96) = v33;
  *(float32x2_t *)(a1 + 80) = vcvt_f32_f64(v22);
  *(float64_t *)(a1 + 88) = a6.f64[0];
  return a6.f64[0];
}

void EncodeAttachment(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, unint64_t a8, unint64_t a9, unsigned __int8 a10)
{
  id v17 = a3;
  id v24 = a6;
  id v18 = a7;
  float64x2_t v19 = *(void **)(*(void *)(a1 + 8) + 16);
  id v20 = a4;
  float32x4_t v21 = GTMTLReplayController_resizeTexture(v19, a1 + 96, a2, a5, a8, a9, 0);
  uint64_t v26 = 0;
  memset(v25, 0, sizeof(v25));
  float64x2_t v22 = [v20 device];
  id v23 = [v20 pixelFormat];

  GTMTLPixelFormatGetInfoForDevice((uint64_t)v25, (uint64_t)v22, (uint64_t)v23);
  [v17 drawTexture:v21 isDepthStencil:(BYTE8(v25[0]) & 0x60) != 0 shrinkToFit:a10];
  if (v24) {
    [v17 drawOverlay:v24 color:*(unsigned int *)(a1 + 72) shrinkToFit:a10];
  }
  if (v18) {
    [v17 drawOverlay:v18 color:*(unsigned int *)(a1 + 76) shrinkToFit:a10];
  }
}

void GTMTLReplayClient_displayAttachment(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  GTMTLReplayController_debugSubCommandStop(v6, a3, a4);
  uint64_t v7 = GTMTLReplayController_renderPassDescriptor(v6);
  uint64_t v8 = 0;
  uint64_t v9 = a3;
  uint64_t v10 = *(uint64_t **)(*(void *)v6 + 40);
  id v11 = (uint64_t *)(v7 + 8);
  uint64_t v12 = 0xFFFFFFFFLL;
  uint64_t v13 = 0xFFFFFFFFLL;
  do
  {
    uint64_t v15 = *v11;
    v11 += 8;
    uint64_t v14 = v15;
    if (v15)
    {
      uint64_t v13 = (int)v13 >= 0 ? v13 : v8;
      Object = GTMTLSMContext_getObject(*v10, v14, *(void *)(*(void *)v6 + 80) + v9);
      if (Object)
      {
        if (Object[24]) {
          uint64_t v12 = v8;
        }
        else {
          uint64_t v12 = v12;
        }
      }
    }
    ++v8;
  }
  while (v8 != 8);
  if ((v12 & 0x80000000) != 0)
  {
    if ((v13 & 0x80000000) != 0)
    {
      if (*(void *)(v7 + 680))
      {
        id v17 = (uint64_t *)(v7 + 672);
        uint64_t v12 = 8;
      }
      else
      {
        if (!*(void *)(v7 + 728)) {
          return;
        }
        id v17 = (uint64_t *)(v7 + 720);
        uint64_t v12 = 9;
      }
    }
    else
    {
      id v17 = (uint64_t *)(v7 + ((unint64_t)v13 << 6));
      uint64_t v12 = v13;
    }
  }
  else
  {
    id v17 = (uint64_t *)(v7 + ((unint64_t)v12 << 6));
  }
  uint64_t v18 = *v17;
  if (*v17)
  {
    float64x2_t v19 = (unsigned __int16 *)v17 + 10;
    id v20 = (unsigned __int8 *)v17 + 26;
    float32x4_t v21 = (unsigned __int16 *)v17 + 9;
  }
  else
  {
    uint64_t v18 = v17[1];
    if (!v18) {
      return;
    }
    float64x2_t v19 = (unsigned __int16 *)v17 + 11;
    id v20 = (unsigned __int8 *)(v17 + 3);
    float32x4_t v21 = (unsigned __int16 *)(v17 + 2);
  }
  uint64_t v22 = *v20;
  uint64_t v23 = *v19;
  uint64_t v24 = *v21;
  if (*(unsigned char *)(a2 + 10))
  {
    int v92 = 0;
    long long v81 = GTMTLReplayController_generateOutlineTexture(v6, (id *)(a1 + 96), &v92);
    double v25 = v92;
    GTMTLReplay_handleNSError(v25);
  }
  else
  {
    long long v81 = 0;
  }
  if (*(unsigned char *)(a2 + 9))
  {
    uint64_t v91 = 0;
    unint64_t v80 = GTMTLReplayController_generateWireframeTexture();
    id v26 = 0;
    GTMTLReplay_handleNSError(v26);
  }
  else
  {
    unint64_t v80 = 0;
  }
  uint64_t v27 = *(void *)(*(void *)v6 + 40);
  BOOL v83 = GTMTLSMContext_getObject(*(void *)v27, v18, *(void *)(*(void *)v6 + 80) + v9);
  if (v83[24])
  {
    uint64_t v28 = apr_array_make(*(apr_pool_t **)a1, 16, 8);
    GTMTLSMContext_getObjects(*(_DWORD **)(v27 + 240), *(void *)(*(void *)v6 + 80) + v9, v28);
    id v29 = [objc_alloc((Class)NSMutableArray) initWithCapacity:v28->nelts];
    id v30 = [objc_alloc((Class)NSMutableArray) initWithCapacity:v28->nelts];
    id v31 = v30;
    if (v28->nelts >= 1)
    {
      id v85 = v30;
      uint64_t v32 = v6;
      uint64_t v33 = 0;
      LODWORD(v34) = -1;
      do
      {
        CFStringRef v35 = v29;
        uint64_t v36 = *(void *)&v28->elts[8 * v33];
        if (*(void *)(v36 + 8) == v83[24]) {
          uint64_t v34 = v33;
        }
        else {
          uint64_t v34 = v34;
        }
        v98[0] = &off_759810;
        v97[0] = @"type";
        v97[1] = @"object";
        intptr_t v37 = +[NSNumber numberWithUnsignedLongLong:*(void *)(v36 + 48)];
        v98[1] = v37;
        v98[2] = &off_759828;
        v97[2] = @"DependencyGraphRequestedTextureLevel";
        v97[3] = @"DependencyGraphRequestedTextureSlice";
        v98[3] = &off_759828;
        v98[4] = &off_759828;
        v97[4] = @"DependencyGraphRequestedTextureAttachmentIndex";
        v97[5] = @"DependencyGraphRequestedTextureDepthPlane";
        v98[5] = &off_759828;
        int v38 = +[NSDictionary dictionaryWithObjects:v98 forKeys:v97 count:6];

        id v39 = *(void **)(v32 + 40);
        unsigned int v40 = +[NSNumber numberWithUnsignedLongLong:*(void *)(v36 + 48)];
        unint64_t v41 = [v39 objectForKeyedSubscript:v40];

        if (!v41)
        {
          unint64_t v41 = [*(id *)(v32 + 8) textureForKey:*(void *)(v36 + 48)];
        }
        id v29 = v35;
        [v35 addObject:v38];
        [v85 addObject:v41];

        ++v33;
      }
      while (v33 < v28->nelts);
      uint64_t v6 = v32;
      id v31 = v85;
      goto LABEL_43;
    }
  }
  else
  {
    v96[0] = &off_759810;
    v95[0] = @"type";
    v95[1] = @"object";
    unsigned int v42 = +[NSNumber numberWithUnsignedLongLong:v18];
    v96[1] = v42;
    v95[2] = @"DependencyGraphRequestedTextureLevel";
    uint64_t v43 = +[NSNumber numberWithUnsignedShort:v22];
    v96[2] = v43;
    v95[3] = @"DependencyGraphRequestedTextureSlice";
    id v44 = +[NSNumber numberWithUnsignedShort:v23];
    v96[3] = v44;
    v95[4] = @"DependencyGraphRequestedTextureAttachmentIndex";
    id v45 = +[NSNumber numberWithUnsignedInt:v12];
    v96[4] = v45;
    v95[5] = @"DependencyGraphRequestedTextureDepthPlane";
    id v46 = +[NSNumber numberWithUnsignedShort:v24];
    v96[5] = v46;
    uint64_t v47 = +[NSDictionary dictionaryWithObjects:v96 forKeys:v95 count:6];

    id v48 = *(void **)(v6 + 40);
    unint64_t v49 = +[NSNumber numberWithUnsignedLongLong:v18];
    uint64_t v50 = [v48 objectForKeyedSubscript:v49];

    if (!v50)
    {
      uint64_t v50 = [*(id *)(v6 + 8) textureForKey:v18];
    }
    uint64_t v94 = v47;
    uint64_t v51 = +[NSArray arrayWithObjects:&v94 count:1];
    int64_t v93 = v50;
    id v29 = (id)v51;
    id v31 = +[NSArray arrayWithObjects:&v93 count:1];

    uint64_t v28 = 0;
  }
  uint64_t v34 = 0xFFFFFFFFLL;
LABEL_43:
  GTMTLReplayClient_waitForUntrackedWritesToComplete(v6, v31);
  unsigned int v79 = v29;
  id v52 = GTMTLReplayClient_retrieveTexturesForResize((id *)v6, v29, v31, 1, 0);
  uint64_t v53 = [*(id *)(v6 + 8) defaultCommandQueue];
  id v54 = InternalCommandBuffer(v53, @"DisplayAttachment");

  uint64_t v55 = [GTMTLTextureRenderEncoder alloc];
  id v56 = [*(id *)(v6 + 8) defaultDevice];
  id v57 = [(GTMTLTextureRenderEncoder *)v55 initWithDevice:v56];

  unsigned int v86 = v31;
  long long v82 = v52;
  if (v83[24])
  {
    long long v58 = v54;
    if (v28->nelts >= 1)
    {
      uint64_t v59 = 0;
      do
      {
        long long v60 = [*(id *)(v6 + 8) layerForKey:*(void *)(*(void *)&v28->elts[8 * v59] + 40)];
        [v60 drawableSize];
        double v62 = v61;
        double v64 = v63;
        if (v60) {
          [v60 transform];
        }
        else {
          memset(v90, 0, sizeof(v90));
        }
        [(GTMTLTextureRenderEncoder *)v57 setTransform:v90];
        [v60 bounds];
        double v66 = v65;
        double v68 = v67;
        double v70 = v69;
        double v72 = v71;
        [v60 contentsScale];
        -[GTMTLTextureRenderEncoder setBounds:contentsScale:](v57, "setBounds:contentsScale:", v66, v68, v70, v72, v73);
        [v60 anchorPoint];
        -[GTMTLTextureRenderEncoder setAnchor:](v57, "setAnchor:");
        if (v34 == v59)
        {
          uint64_t v74 = [v86 objectAtIndexedSubscript:v34];
          long long v75 = [v82 objectAtIndexedSubscript:v34];
          long long v58 = v54;
          EncodeAttachment(a1, v54, v57, v74, v75, v80, v81, (unint64_t)v62, (unint64_t)v64, 0);
        }
        else
        {
          uint64_t v74 = [v86 objectAtIndexedSubscript:v59];
          long long v75 = [v82 objectAtIndexedSubscript:v59];
          long long v58 = v54;
          EncodeAttachment(a1, v54, v57, v74, v75, 0, 0, (unint64_t)v62, (unint64_t)v64, 0);
        }

        ++v59;
      }
      while (v59 < v28->nelts);
    }
  }
  else
  {
    -[GTMTLTextureRenderEncoder setBounds:contentsScale:](v57, "setBounds:contentsScale:", 0.0, 0.0, (double)*(unint64_t *)(v6 + 22464), (double)*(unint64_t *)(v6 + 22472), 1.0);
    int v76 = [v31 objectAtIndexedSubscript:0];
    unsigned int v77 = [v52 objectAtIndexedSubscript:0];
    EncodeAttachment(a1, v54, v57, v76, v77, v80, v81, *(void *)(v6 + 22464), *(void *)(v6 + 22472), 1u);

    long long v58 = v54;
  }
  v87[0] = _NSConcreteStackBlock;
  v87[1] = 3221225472;
  v87[2] = __GTMTLReplayClient_displayAttachment_block_invoke;
  v87[3] = &unk_746888;
  uint64_t v88 = v57;
  uint64_t v89 = a1;
  char v78 = v57;
  [v58 addCompletedHandler:v87];
  GTMTLReplay_commitCommandBuffer(v58);
}

id GTMTLShaderDebugger_generateTrace()
{
  uint64_t v0 = __chkstk_darwin();
  v470 = v1;
  obuint64_t j = (uint64_t *)v0;
  id v3 = v2;
  unint64_t v516 = 0;
  int p = 0;
  v499 = 0;
  long long v514 = 0u;
  id v515 = 0;
  long long v505 = 0u;
  char v504 = 0;
  long long v500 = 0u;
  long long v501 = 0u;
  long long v502 = 0u;
  long long v503 = 0u;
  id v506 = objc_alloc_init((Class)NSDictionary);

  long long v507 = 0u;
  long long v508 = 0u;

  uint64_t v509 = 0;
  uint64_t v510 = 0x7FFFFFFFFFFFFFFFLL;
  id v511 = 0;

  uint64_t v512 = 2;
  long long v513 = 0u;

  *(void *)&long long v514 = 0;
  apr_pool_create_ex(&p, 0, 0, v4);
  id v5 = v3;
  v471 = v5;
  if (!v5)
  {
    if (v470)
    {
      GTShaderDebuggerMakeError(1u, @"Internal error: nil request", 0, 0, 0);
      id v68 = (id)objc_claimAutoreleasedReturnValue();
LABEL_54:
      uint64_t v69 = 0;
      id v58 = 0;
LABEL_77:
      uint64_t v91 = 0;
      void *v470 = v68;
      goto LABEL_80;
    }
LABEL_55:
    uint64_t v69 = 0;
    id v58 = 0;
LABEL_79:
    uint64_t v91 = 0;
    goto LABEL_80;
  }
  uint64_t v6 = [v5 objectForKeyedSubscript:@"ProtocolVersion"];
  unsigned int v7 = [v6 intValue];

  uint64_t v8 = v471;
  if (v7) {
    goto LABEL_34;
  }
LABEL_8:
  id v18 = v8;
  float64x2_t v19 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerFunctionIndex"];
  id v20 = (char *)[v19 unsignedIntegerValue];

  float32x4_t v21 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerSubCommandIndex"];
  id v490 = [v21 unsignedIntegerValue];

  if (v20)
  {
    uint64_t v22 = *obj;
    uint64_t v23 = *(void *)(*(void *)(*obj + 120) + 24);
    uint64_t v24 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerFunctionId"];
    id v495 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerLibraryId"];
    double v25 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerLibraryType"];
    v485 = v20 - 1;
    if ([v25 isEqualToString:@"Online"])
    {
      id v26 = (unint64_t *)(v23 + ((void)v485 << 6));
      AliasStreauint64_t m = (uint64_t *)GetAliasStream(*(void *)(v22 + 24), (uint64_t)[v495 unsignedLongLongValue], *v26);
      if (AliasStream) {
        uint64_t v28 = *AliasStream;
      }
      else {
        uint64_t v28 = 0;
      }
      uint64_t Object = GTMTLSMContext_lastObject(**(void **)(v22 + 40), v28, *v26);
      if (!Object || *(unsigned char *)(Object + 161) != 2)
      {
        id v17 = 0;
LABEL_31:

        goto LABEL_32;
      }
      id v29 = StringFromArchive(*(void **)v22, obj[19], *(char **)(Object + 96));
      uint64_t v33 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerInstrumentFunctions"];
      uint64_t v34 = +[NSNumber numberWithUnsignedLongLong:v28];
      CFStringRef v35 = [v34 stringValue];
      uint64_t v36 = [v33 objectForKeyedSubscript:v35];

      id v37 = objc_alloc_init((Class)NSMutableDictionary);
      [v37 setObject:v29 forKeyedSubscript:@"Code"];
      if ([v36 count]) {
        [v37 setObject:v36 forKeyedSubscript:@"SelectFunctions"];
      }
      id v523 = v495;
      id v38 = [v37 copy];
      id v524 = v38;
      id v30 = +[NSDictionary dictionaryWithObjects:&v524 forKeys:&v523 count:1];

      CFStringRef v31 = @"SourceLibs";
    }
    else
    {
      id v29 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerInstrumentedMetallib"];
      id v523 = v495;
      id v524 = v29;
      id v30 = +[NSDictionary dictionaryWithObjects:&v524 forKeys:&v523 count:1];
      CFStringRef v31 = @"MetalLibs";
    }

    v520 = v24;
    v521[0] = (id)v31;
    v521[1] = @"FunctionUIDs";
    v522[0] = v30;
    id v39 = +[NSArray arrayWithObjects:&v520 count:1];
    v522[1] = v39;
    uint64_t v481 = +[NSDictionary dictionaryWithObjects:v522 forKeys:v521 count:2];

    unsigned int v40 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerTraceBufferSize"];
    id v41 = [v40 unsignedIntegerValue];

    unsigned int v42 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerPipelineCreationTimeout"];
    id v43 = [v42 unsignedIntegerValue];

    v519[0] = @"TraceBufferSize";
    id v44 = +[NSNumber numberWithUnsignedInteger:v41];
    v534 = v44;
    v519[1] = @"PSOCompileTimeout";
    id v45 = +[NSNumber numberWithUnsignedInteger:v43];
    v519[2] = @"SkipMetadataGen";
    uint64_t v535 = (uint64_t)v45;
    v536 = (uint64_t (*)(uint64_t, void *, void *))&__kCFBooleanFalse;
    id v495 = +[NSDictionary dictionaryWithObjects:&v534 forKeys:v519 count:3];

    double v25 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIType"];
    switch((unint64_t)[v25 unsignedIntegerValue])
    {
      case 0uLL:
        id v46 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMinPositionX"];
        uint64_t v47 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMinPositionY"];
        id v48 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMinPositionZ"];
        v472 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMaxPositionX"];
        unint64_t v49 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMaxPositionY"];
        uint64_t v50 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMaxPositionZ"];
        *(void *)&long long v526 = @"Type";
        *((void *)&v526 + 1) = @"MinPositionX";
        *(void *)__dst = &off_759E40;
        *(void *)&__dst[8] = v46;
        *(void *)&long long v527 = @"MinPositionY";
        *((void *)&v527 + 1) = @"MinPositionZ";
        *(void *)&__dst[16] = v47;
        *(void *)&__dst[24] = v48;
        *(void *)&long long v528 = @"MaxPositionX";
        *((void *)&v528 + 1) = @"MaxPositionY";
        *(void *)&__dst[32] = v472;
        *(void *)&__dst[40] = v49;
        *(void *)&long long v529 = @"MaxPositionZ";
        *(void *)&__dst[48] = v50;
        uint64_t v51 = +[NSDictionary dictionaryWithObjects:__dst forKeys:&v526 count:7];
        goto LABEL_24;
      case 1uLL:
        id v46 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIInstanceId"];
        uint64_t v47 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIAmplificationId"];
        id v48 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIVertexIds"];
        *(void *)&long long v526 = @"Type";
        *((void *)&v526 + 1) = @"InstanceID";
        *(void *)__dst = &off_759E10;
        *(void *)&__dst[8] = v46;
        *(void *)&long long v527 = @"AmplificationID";
        *((void *)&v527 + 1) = @"VertexIDs";
        *(void *)&__dst[16] = v47;
        *(void *)&__dst[24] = v48;
        uint64_t v53 = +[NSDictionary dictionaryWithObjects:__dst forKeys:&v526 count:4];
        goto LABEL_27;
      case 2uLL:
        id v46 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMinPositionX"];
        uint64_t v47 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMinPositionY"];
        id v48 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMaxPositionX"];
        v472 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMaxPositionY"];
        unint64_t v49 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMinSampleId"];
        uint64_t v50 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMaxSampleId"];
        id v52 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIRenderTargetArrayIndex"];
        *(void *)&long long v526 = @"Type";
        *((void *)&v526 + 1) = @"MinPositionX";
        *(void *)__dst = &off_759E28;
        *(void *)&__dst[8] = v46;
        *(void *)&long long v527 = @"MinPositionY";
        *((void *)&v527 + 1) = @"MaxPositionX";
        *(void *)&__dst[16] = v47;
        *(void *)&__dst[24] = v48;
        *(void *)&long long v528 = @"MaxPositionY";
        *((void *)&v528 + 1) = @"MinSampleID";
        *(void *)&__dst[32] = v472;
        *(void *)&__dst[40] = v49;
        *(void *)&long long v529 = @"MaxSampleID";
        *((void *)&v529 + 1) = @"RenderTargetArrayIndex";
        *(void *)&__dst[48] = v50;
        *(void *)&__dst[56] = v52;
        uint64_t v51 = +[NSDictionary dictionaryWithObjects:__dst forKeys:&v526 count:8];

LABEL_24:
        goto LABEL_28;
      case 3uLL:
        id v46 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIInstanceId"];
        uint64_t v47 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIAmplificationId"];
        id v48 = [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIPatchIds"];
        *(void *)&long long v526 = @"Type";
        *((void *)&v526 + 1) = @"InstanceID";
        *(void *)__dst = &off_759E58;
        *(void *)&__dst[8] = v46;
        *(void *)&long long v527 = @"AmplificationID";
        *((void *)&v527 + 1) = @"PatchIDs";
        *(void *)&__dst[16] = v47;
        *(void *)&__dst[24] = v48;
        uint64_t v53 = +[NSDictionary dictionaryWithObjects:__dst forKeys:&v526 count:4];
LABEL_27:
        uint64_t v51 = (void *)v53;
LABEL_28:

        *(void *)&long long v539 = &off_759E28;
        *(void *)&long long v530 = @"ProtocolVersion";
        *((void *)&v530 + 1) = @"FunctionIndex";
        id v54 = +[NSNumber numberWithUnsignedInteger:v485];
        *((void *)&v539 + 1) = v54;
        *(void *)&long long v531 = @"SubCommandIndex";
        uint64_t v55 = +[NSNumber numberWithUnsignedInteger:v490];
        *(void *)&long long v540 = v55;
        *((void *)&v540 + 1) = v481;
        *((void *)&v531 + 1) = @"Program";
        *(void *)&long long v532 = @"ROI";
        *((void *)&v532 + 1) = @"Options";
        *(void *)&long long v541 = v51;
        *((void *)&v541 + 1) = v495;
        id v17 = +[NSDictionary dictionaryWithObjects:&v539 forKeys:&v530 count:6];

        break;
      default:
        GTMTLReplay_handleError(101, (uint64_t)"Unknown region of interest type", "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_shaderDebugger_internal.m", (uint64_t)"_UpgradeRequest_to_StarSkyE_from_StarSky", 759, 4);
        id v17 = 0;
        break;
    }
    uint64_t v24 = (void *)v481;
    goto LABEL_31;
  }
  id v17 = 0;
LABEL_32:

  while (1)
  {
    id v56 = v17;

    id v57 = [v56 objectForKeyedSubscript:@"ProtocolVersion"];

    unsigned int v7 = [v57 intValue];
    uint64_t v8 = v56;
    if (!v7) {
      goto LABEL_8;
    }
LABEL_34:
    if (v7 != 2) {
      break;
    }
    id v9 = v8;
    uint64_t v10 = [v9 objectForKeyedSubscript:@"Program"];
    id v11 = [v10 mutableCopy];

    uint64_t v12 = [v11 objectForKeyedSubscript:@"UseGlobalRelocation"];
    if ([v12 BOOLValue]) {
      uint64_t v13 = 2;
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = +[NSNumber numberWithUnsignedInt:v13];
    [v11 setObject:v14 forKeyedSubscript:@"TraceBufferBindingType"];

    id v15 = [v9 mutableCopy];
    id v16 = [v11 copy];
    [v15 setObject:v16 forKeyedSubscript:@"Program"];

    [v15 setObject:&off_759E40 forKeyedSubscript:@"ProtocolVersion"];
    id v17 = [v15 copy];
  }
  if (v7 != 3)
  {
    while (1)
      ;
  }
  if (!v8)
  {
    if (v470)
    {
      GTShaderDebuggerMakeError(1u, @"Internal error: Unexpected request: Upgrade failure", 0, 0, 0);
      id v68 = (id)objc_claimAutoreleasedReturnValue();
      goto LABEL_54;
    }
    goto LABEL_55;
  }
  id v58 = v8;
  long long v539 = 0u;
  long long v540 = 0u;
  long long v541 = 0u;
  long long v542 = 0u;
  id v59 = [&off_758CA8 countByEnumeratingWithState:&v539 objects:__dst count:16];
  if (v59)
  {
    uint64_t v60 = *(void *)v540;
    while (2)
    {
      for (uint64_t i = 0; i != v59; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v540 != v60) {
          objc_enumerationMutation(&off_758CA8);
        }
        double v62 = [v58 objectForKeyedSubscript:*(void *)(*((void *)&v539 + 1) + 8 * i)];
        BOOL v63 = v62 == 0;

        if (v63)
        {

          goto LABEL_75;
        }
      }
      id v59 = [&off_758CA8 countByEnumeratingWithState:&v539 objects:__dst count:16];
      if (v59) {
        continue;
      }
      break;
    }
  }
  double v64 = [v58 objectForKeyedSubscript:@"Program"];
  double v65 = [v64 objectForKeyedSubscript:@"FunctionUIDs"];
  BOOL v66 = v65 == 0;

  if (v66) {
    goto LABEL_74;
  }
  double v67 = [v64 objectForKeyedSubscript:@"MetalLibs"];
  if (!v67)
  {
    double v70 = [v64 objectForKeyedSubscript:@"SourceLibs"];
    BOOL v71 = v70 == 0;

    if (!v71) {
      goto LABEL_57;
    }
LABEL_74:

    goto LABEL_75;
  }

LABEL_57:
  double v72 = [v58 objectForKeyedSubscript:@"ROI"];
  double v73 = [v72 objectForKeyedSubscript:@"Type"];
  uint64_t v74 = v73;
  if (!v73 || (unint64_t v75 = (unint64_t)[v73 unsignedIntegerValue] - 1, v75 > 5))
  {
LABEL_73:

LABEL_75:
    if (v470)
    {
      GTShaderDebuggerMakeError(1u, @"Internal error: Invalid request", 0, 0, 0);
      id v68 = (id)objc_claimAutoreleasedReturnValue();
      uint64_t v69 = 0;
      goto LABEL_77;
    }
    uint64_t v69 = 0;
    goto LABEL_79;
  }
  int v76 = off_746A58[v75];
  long long v533 = 0u;
  long long v532 = 0u;
  long long v531 = 0u;
  long long v530 = 0u;
  id v77 = [v76 countByEnumeratingWithState:&v530 objects:&v526 count:16];
  if (v77)
  {
    uint64_t v78 = *(void *)v531;
LABEL_61:
    uint64_t v79 = 0;
    while (1)
    {
      if (*(void *)v531 != v78) {
        objc_enumerationMutation(v76);
      }
      unint64_t v80 = [v72 objectForKeyedSubscript:*(void *)(*((void *)&v530 + 1) + 8 * v79)];
      BOOL v81 = v80 == 0;

      if (v81) {
        goto LABEL_73;
      }
      if (v77 == (id)++v79)
      {
        id v77 = [v76 countByEnumeratingWithState:&v530 objects:&v526 count:16];
        if (v77) {
          goto LABEL_61;
        }
        break;
      }
    }
  }

  long long v82 = [v58 objectForKeyedSubscript:@"Options"];
  BOOL v83 = [v82 objectForKeyedSubscript:@"SkipMetadataGen"];

  unsigned int v84 = [v83 BOOLValue];
  id v85 = [v58 objectForKeyedSubscript:@"Options"];
  unsigned int v86 = [v85 objectForKeyedSubscript:@"SaveTempsDir"];

  if ([v86 length]) {
    uint64_t v87 = v84 ^ 1 | 8;
  }
  else {
    uint64_t v87 = v84 ^ 1;
  }
  uint64_t v88 = [v58 objectForKeyedSubscript:@"Program"];
  uint64_t v89 = [v88 objectForKeyedSubscript:@"TraceBufferBindingType"];

  unsigned int v90 = [v89 integerValue];
  if (v90 == 2)
  {
    v87 |= 4uLL;
  }
  else if (v90 == 1)
  {
    v87 |= 2uLL;
  }

  id v162 = [(id)obj[1] defaultDevice];
  unsigned int v163 = [v162 supportsFamily:1001];

  if (v163) {
    uint64_t v69 = v87;
  }
  else {
    uint64_t v69 = v87 | 0x10;
  }
  id v58 = v58;
  uint64_t v91 = v58;
LABEL_80:

  if (!v91)
  {
LABEL_138:

    goto LABEL_139;
  }
  int v92 = [v91 objectForKeyedSubscript:@"FunctionIndex"];
  unsigned int v93 = [v92 unsignedIntValue];

  uint64_t v94 = *(void *)(*(void *)(*obj + 120) + 24);
  if (v69)
  {
    if (_IsLLVMDylibLoaded_onceToken != -1) {
      dispatch_once(&_IsLLVMDylibLoaded_onceToken, &__block_literal_global_8092);
    }
    if ((_IsLLVMDylibLoaded_llvmLoaded & 1) == 0)
    {
      id v100 = +[NSBundle mainBundle];
      unint64_t v98 = [v100 infoDictionary];

      id v101 = [v98 objectForKeyedSubscript:@"DTPlatformName"];
      unint64_t v102 = [v98 objectForKeyedSubscript:@"DTPlatformVersion"];
      if ([v101 length] && objc_msgSend(v102, "length"))
      {
        unint64_t v103 = [&off_7594E0 objectForKeyedSubscript:v101];
        uint64_t v104 = v103;
        if (v103)
        {
          id v105 = [v103 stringByAppendingString:v102];
          id v106 = [v105 stringByAppendingString:@" or later"];
        }
        else
        {
          id v106 = 0;
        }
      }
      else
      {
        id v106 = 0;
      }
      if (v106) {
        CFStringRef v150 = v106;
      }
      else {
        CFStringRef v150 = @"the latest version available";
      }
      id v151 = [@"Please update your target OS to " stringByAppendingString:v150];
      if (v470)
      {
        GTShaderDebuggerMakeError(4u, @"Debugging information not available from the target OS", v151, 0, 0);
        void *v470 = (id)objc_claimAutoreleasedReturnValue();
      }

      goto LABEL_137;
    }
  }
  if ((v69 & 4) == 0) {
    goto LABEL_86;
  }
  unint64_t v98 = [(id)obj[1] defaultDevice];
  if ((objc_opt_respondsToSelector() & 1) == 0 || ![v98 supportsTLS]) {
    goto LABEL_127;
  }
  if (objc_opt_respondsToSelector()) {
    unsigned int v99 = [v98 supportsGlobalVariableRelocationCompute] ^ 1;
  }
  else {
    unsigned int v99 = 1;
  }
  if (objc_opt_respondsToSelector()) {
    char v148 = [v98 supportsGlobalVariableRelocationRender] ^ 1;
  }
  else {
    char v148 = 1;
  }
  int v149 = *(_DWORD *)(v94 + ((unint64_t)v93 << 6) + 8);
  if ((v149 + 16079) >= 2 && v149 != -16327 && v149 != -16220)
  {
    if ((v148 & 1) == 0) {
      goto LABEL_158;
    }
LABEL_127:
    if (v470)
    {
      GTShaderDebuggerMakeError(4u, @"The metal device does not support debugging shaders in pipelines created with multiple metal libraries", 0, 0, 0);
      void *v470 = (id)objc_claimAutoreleasedReturnValue();
    }
LABEL_137:

    goto LABEL_138;
  }
  if (v99) {
    goto LABEL_127;
  }
LABEL_158:

LABEL_86:
  uint64_t v95 = [v471 objectForKeyedSubscript:@"Options"];
  unsigned __int8 v96 = [v95 objectForKeyedSubscript:@"SaveTempsDir"];

  if ([v96 length])
  {
    id v97 = v96;
  }
  else
  {
    NSTemporaryDirectory();
    id v97 = (id)objc_claimAutoreleasedReturnValue();
  }
  id v107 = v97;
  uint64_t v108 = [v97 stringByAppendingPathComponent:@"GTMTLReplay_ShaderDebugger"];
  long long v109 = +[NSFileManager defaultManager];
  id v518 = 0;
  unsigned __int8 v110 = [v109 createDirectoryAtPath:v108 withIntermediateDirectories:1 attributes:0 error:&v518];
  id v111 = v518;

  if (v110)
  {
    v499 = (unsigned int *)obj;
    objc_storeStrong((id *)&v514 + 1, v91);
    objc_storeStrong(&v515, v108);
    unint64_t v516 = v69;
  }
  else if (v470)
  {
    GTShaderDebuggerMakeError(1u, @"Internal error", 0, v111, 0);
    void *v470 = (id)objc_claimAutoreleasedReturnValue();
  }

  if ((v110 & 1) == 0) {
    goto LABEL_139;
  }
  id v112 = [*((id *)&v514 + 1) objectForKeyedSubscript:@"FunctionIndex"];
  unsigned int v113 = [v112 unsignedIntValue];

  unsigned __int8 v114 = [*((id *)&v514 + 1) objectForKeyedSubscript:@"SubCommandIndex"];
  int v115 = [v114 unsignedIntValue];

  CFStringRef v116 = v499;
  unsigned int v117 = v113 + 1;
  GTMTLReplayController_debugSubCommandResume(v499, v117, v115);
  unsigned int v118 = v499[2828];
  if (v118 != 28 && v118 != 70)
  {
    unsigned int v136 = v118 - 1;
    if (v136 > 0x55) {
      BOOL v137 = "Unknown";
    }
    else {
      BOOL v137 = (&off_7479A0)[v136];
    }
    uint64_t v154 = +[NSString stringWithUTF8String:v137];
    dispatch_semaphore_t v155 = +[NSString stringWithFormat:@"Unsupported encoder: \"%@\"", v154];

    if (v470)
    {
      GTShaderDebuggerMakeError(4u, v155, 0, 0, 0);
      void *v470 = (id)objc_claimAutoreleasedReturnValue();
    }

    goto LABEL_139;
  }
  v499[5620] = v117;
  v116[5621] = v115;
  CFStringRef v119 = v499;
  CFStringRef v120 = (uint64_t *)(v499 + 5620);
  unsigned int v121 = v499[5620];
  uint64_t v122 = *(void *)(*(void *)(*(void *)v499 + 120) + 24);
  unint64_t v123 = [*((id *)&v514 + 1) objectForKeyedSubscript:@"ROI"];
  unint64_t v124 = [v123 objectForKeyedSubscript:@"Type"];
  unsigned int v467 = [v124 integerValue];

  uint64_t v125 = v122 + ((unint64_t)(v121 - 1) << 6);
  if (*(_DWORD *)(v125 + 8) >> 2 == 1073737833)
  {
    uint64_t v126 = apr_palloc(p, 0xD0uLL);
    uint64_t v127 = (uint64_t)v126;
    if (v126)
    {
      v126[11] = 0u;
      v126[12] = 0u;
      v126[9] = 0u;
      v126[10] = 0u;
      v126[7] = 0u;
      v126[8] = 0u;
      v126[5] = 0u;
      v126[6] = 0u;
      v126[3] = 0u;
      v126[4] = 0u;
      v126[1] = 0u;
      v126[2] = 0u;
      _OWORD *v126 = 0u;
    }
    uint64_t v128 = *(void *)v119;
    GTMTLSMContext_indirectCommandBufferResources((uint64_t)__dst, *(_DWORD ***)(*(void *)v119 + 40), *(void *)v125, p);
    long long v129 = *(_OWORD *)&__dst[48];
    *(_OWORD *)(v127 + 144) = *(_OWORD *)&__dst[32];
    *(_OWORD *)(v127 + 160) = v129;
    *(_OWORD *)(v127 + 176) = *(_OWORD *)&__dst[64];
    *(void *)(v127 + 192) = *(void *)&__dst[80];
    long long v130 = *(_OWORD *)&__dst[16];
    *(_OWORD *)(v127 + 112) = *(_OWORD *)__dst;
    *(_OWORD *)(v127 + 128) = v130;
    *(void *)&long long v528 = 0;
    long long v527 = 0u;
    long long v526 = 0u;
    GetExecuteCommandsInBufferArgs((uint64_t)&v526, v125, *(void *)(v128 + 16));
    unint64_t v131 = GTMTLSMContext_getObject(**(void **)(v128 + 40), v526, *(void *)v125);
    GTMTLCreateIndirectCommandEncoder(v127, v131[13]);
    uint64_t v132 = *((void *)&v527 + 1) + *(void *)(v127 + 104) * *((unsigned int *)v120 + 1);
    *(void *)(v127 + 200) = v132;
    if (v119[2828] == 70)
    {
      memcpy(__dst, v119 + 2842, sizeof(__dst));
      if (GTMTLSMRenderCommandEncoder_loadIndirectCommand((uint64_t)(v119 + 2842), (void *)v127, *(void *)(v127 + 200), (uint64_t *)(v127 + 112)))
      {
        uint64_t v133 = *((void *)v119 + 1415);
        id v134 = *((id *)v119 + 1);
        uint64_t v135 = [v134 renderCommandEncoderForKey:v133];
        GTMTLReplayController_restoreRenderCommandEncoder(v135, (uint64_t)__dst, (uint64_t)(v119 + 2842), v134);

        goto LABEL_114;
      }
LABEL_150:
      if (!v470) {
        goto LABEL_139;
      }
      GTShaderDebuggerMakeError(1u, @"Internal error: Failed to decode ICB", 0, 0, 0);
      id v159 = (id)objc_claimAutoreleasedReturnValue();
      goto LABEL_152;
    }
    if ((GT_SUPPORT_0 & 0x10) == 0) {
      goto LABEL_150;
    }
    memcpy(__dst, v119 + 2842, 0x8D0uLL);
    if (!GTMTLSMComputeCommandEncoder_loadIndirectCommand((uint64_t)(v119 + 2842), (void *)v127, v132, (uint64_t *)(v127 + 112)))goto LABEL_150; {
    uint64_t v156 = *((void *)v119 + 1415);
    }
    id v157 = *((id *)v119 + 1);
    id v158 = [v157 computeCommandEncoderForKey:v156];
    GTMTLReplayController_restoreComputeCommandEncoder(v158, (uint64_t)__dst, (uint64_t)(v119 + 2842), v157);
  }
  else
  {
    uint64_t v127 = 0;
  }
LABEL_114:
  unint64_t v138 = *(void *)v125;
  unsigned int v139 = v499[2828];
  *(void *)&long long v462 = v127;
  *((void *)&v462 + 1) = v125;
  if (v139 == 70)
  {
    uint64_t v160 = GTMTLSMContext_getObject(**(void **)(*(void *)v499 + 40), *((void *)v499 + 2489), v138);
    if (v160)
    {
      uint64_t v161 = v160[7];
      if (v161)
      {
        switch(v467)
        {
          case 1u:
          case 4u:
            long long v142 = (uint64_t *)(v161 + 24);
            id v143 = (_WORD *)(v161 + 198);
            id v144 = (uint64_t *)(v499 + 2848);
            uint64_t v145 = (uint64_t *)(v499 + 3034);
            unint64_t v146 = (uint64_t *)(v499 + 3290);
            v486 = (uint64_t *)(v499 + 2844);
            uint64_t v147 = 2910;
            goto LABEL_435;
          case 2u:
            long long v142 = (uint64_t *)(v161 + 32);
            id v143 = (_WORD *)(v161 + 200);
            id v144 = (uint64_t *)(v499 + 3324);
            uint64_t v145 = (uint64_t *)(v499 + 3448);
            unint64_t v146 = (uint64_t *)(v499 + 3704);
            v486 = (uint64_t *)(v499 + 3322);
            uint64_t v147 = 3386;
            goto LABEL_435;
          case 3u:
            long long v142 = (uint64_t *)(v161 + 56);
            id v143 = (_WORD *)(v161 + 202);
            id v144 = (uint64_t *)(v499 + 4566);
            uint64_t v145 = (uint64_t *)(v499 + 4690);
            unint64_t v146 = (uint64_t *)(v499 + 4946);
            v486 = (uint64_t *)(v499 + 4564);
            uint64_t v147 = 4628;
            goto LABEL_435;
          case 5u:
            long long v142 = (uint64_t *)(v161 + 40);
            id v143 = (_WORD *)(v161 + 204);
            id v144 = (uint64_t *)(v499 + 3738);
            uint64_t v145 = (uint64_t *)(v499 + 3862);
            unint64_t v146 = (uint64_t *)(v499 + 4118);
            v486 = (uint64_t *)(v499 + 3736);
            uint64_t v147 = 3800;
            goto LABEL_435;
          case 6u:
            long long v142 = (uint64_t *)(v161 + 48);
            id v143 = (_WORD *)(v161 + 206);
            id v144 = (uint64_t *)(v499 + 4152);
            uint64_t v145 = (uint64_t *)(v499 + 4276);
            unint64_t v146 = (uint64_t *)(v499 + 4532);
            v486 = (uint64_t *)(v499 + 4150);
            uint64_t v147 = 4214;
            goto LABEL_435;
          default:
            GTMTLReplay_handleError(101, (uint64_t)"Unreachable", "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_shaderDebugger_internal.m", (uint64_t)"_SetCurrentEncoderResourceBindings", 934, 4);
            goto LABEL_165;
        }
      }
    }
    goto LABEL_165;
  }
  if (v139 != 28
    || (uint64_t v140 = GTMTLSMContext_getObject(**(void **)(*(void *)v499 + 40), *((void *)v499 + 1422), v138)) == 0
    || (uint64_t v141 = v140[8]) == 0)
  {
LABEL_165:
    id v144 = 0;
    uint64_t v145 = 0;
    unint64_t v146 = 0;
    v486 = 0;
    id obja = 0;
    uint64_t v164 = 0;
    uint64_t v165 = 0;
    uint64_t v166 = 0;
    char v167 = 1;
    goto LABEL_166;
  }
  long long v142 = (uint64_t *)(v141 + 32);
  id v143 = (_WORD *)(v141 + 94);
  id v144 = (uint64_t *)(v499 + 2850);
  uint64_t v145 = (uint64_t *)(v499 + 3036);
  unint64_t v146 = (uint64_t *)(v499 + 3292);
  v486 = (uint64_t *)(v499 + 2846);
  uint64_t v147 = 2912;
LABEL_435:
  id obja = (uint64_t *)&v499[v147];
  char v167 = 0;
  uint64_t v402 = (unsigned __int16)*v143;
  uint64_t v166 = 16;
  uint64_t v165 = 128;
  uint64_t v164 = 31;
  if (*v143)
  {
    uint64_t v403 = *v142;
    if (*v142)
    {
      id v482 = objc_alloc_init((Class)NSMutableDictionary);
      id v473 = objc_alloc_init((Class)NSMutableDictionary);
      id v496 = objc_alloc_init((Class)NSMutableDictionary);
      id v491 = objc_alloc_init((Class)NSMutableDictionary);
      id v404 = objc_alloc_init((Class)NSMutableDictionary);
      id v461 = objc_alloc_init((Class)NSMutableDictionary);
      uint64_t v405 = (unsigned __int8 *)(v403 + 18);
      while (1)
      {
        unsigned int v406 = *(v405 - 2);
        if (v406 > 2)
        {
          if (v406 == 3)
          {
            uint64_t v407 = +[NSNumber numberWithUnsignedLongLong:v146[*v405]];
            v408 = +[NSNumber numberWithUnsignedChar:*v405];
            [v491 setObject:v407 forKeyedSubscript:v408];
            goto LABEL_449;
          }
          if (v406 == 24)
          {
            uint64_t v407 = +[NSNumber numberWithUnsignedLongLong:v144[*v405]];
            v408 = +[NSNumber numberWithUnsignedChar:*v405];
            [v404 setObject:v407 forKeyedSubscript:v408];
            goto LABEL_449;
          }
        }
        else
        {
          if (!*(v405 - 2))
          {
            unint64_t v409 = *v405;
            uint64_t v410 = v144[v409];
            if ((*(unint64_t *)((char *)v486 + ((v409 >> 3) & 0x18)) >> v409))
            {
              uint64_t v411 = obja[v409];
              uint64_t v407 = +[NSNumber numberWithUnsignedLongLong:v410];
              *(void *)__dst = v407;
              v408 = +[NSNumber numberWithUnsignedLongLong:v411];
              *(void *)&__dst[8] = v408;
              v412 = +[NSArray arrayWithObjects:__dst count:2];
              uint64_t v413 = +[NSNumber numberWithUnsignedChar:*v405];
              [v482 setObject:v412 forKeyedSubscript:v413];
            }
            else
            {
              uint64_t v407 = +[NSNumber numberWithUnsignedLongLong:v410];
              v408 = +[NSNumber numberWithUnsignedChar:*v405];
              [v473 setObject:v407 forKeyedSubscript:v408];
            }
            goto LABEL_449;
          }
          if (v406 == 2)
          {
            uint64_t v407 = +[NSNumber numberWithUnsignedLongLong:v145[*v405]];
            v408 = +[NSNumber numberWithUnsignedChar:*v405];
            [v496 setObject:v407 forKeyedSubscript:v408];
LABEL_449:
          }
        }
        v405 += 56;
        if (!--v402)
        {
          id v414 = [v482 copy];
          uint64_t v415 = (void *)v501;
          *(void *)&long long v501 = v414;

          id v416 = [v473 copy];
          unint64_t v417 = (void *)*((void *)&v501 + 1);
          *((void *)&v501 + 1) = v416;

          id v418 = [v496 copy];
          uint64_t v419 = (void *)v502;
          *(void *)&long long v502 = v418;

          id v420 = [v491 copy];
          uint64_t v421 = (void *)*((void *)&v502 + 1);
          *((void *)&v502 + 1) = v420;

          id v422 = [v404 copy];
          uint64_t v423 = (void *)v503;
          *(void *)&long long v503 = v422;

          id v424 = [v461 copy];
          uint64_t v425 = (void *)*((void *)&v503 + 1);
          *((void *)&v503 + 1) = v424;

          BOOL v190 = 1;
          goto LABEL_183;
        }
      }
    }
  }
LABEL_166:
  id v482 = objc_alloc_init((Class)NSMutableDictionary);
  id v473 = objc_alloc_init((Class)NSMutableDictionary);
  id v496 = objc_alloc_init((Class)NSMutableDictionary);
  id v491 = objc_alloc_init((Class)NSMutableDictionary);
  if ((v167 & 1) == 0)
  {
    uint64_t v168 = 0;
    do
    {
      if (v145[v168])
      {
        uint64_t v169 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:");
        id v170 = +[NSNumber numberWithUnsignedChar:v168];
        [v496 setObject:v169 forKeyedSubscript:v170];
      }
      ++v168;
    }
    while (v165 != v168);
    uint64_t v171 = 0;
    do
    {
      if (v146[v171])
      {
        id v172 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:");
        id v173 = +[NSNumber numberWithUnsignedChar:v171];
        [v491 setObject:v172 forKeyedSubscript:v173];
      }
      ++v171;
    }
    while (v166 != v171);
    uint64_t v174 = 0;
    do
    {
      if (v144[v174])
      {
        if (((unint64_t)v486[v174 >> 6] >> v174))
        {
          uint64_t v175 = obja[v174];
          unint64_t v176 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:");
          *(void *)__dst = v176;
          uint64_t v177 = +[NSNumber numberWithUnsignedLongLong:v175];
          *(void *)&__dst[8] = v177;
          uint64_t v178 = +[NSArray arrayWithObjects:__dst count:2];
          id v179 = +[NSNumber numberWithUnsignedChar:v174];
          [v482 setObject:v178 forKeyedSubscript:v179];
        }
        else
        {
          unint64_t v176 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:");
          uint64_t v177 = +[NSNumber numberWithUnsignedChar:v174];
          [v473 setObject:v176 forKeyedSubscript:v177];
        }
      }
      ++v174;
    }
    while (v164 != v174);
  }
  id v180 = [v482 copy];
  id v181 = (void *)v501;
  *(void *)&long long v501 = v180;

  id v182 = [v473 copy];
  id v183 = (void *)*((void *)&v501 + 1);
  *((void *)&v501 + 1) = v182;

  id v184 = [v496 copy];
  unint64_t v185 = (void *)v502;
  *(void *)&long long v502 = v184;

  id v186 = [v491 copy];
  unint64_t v187 = (void *)*((void *)&v502 + 1);
  *((void *)&v502 + 1) = v186;

  unsigned int v188 = (void *)v503;
  *(void *)&long long v503 = &__NSDictionary0__struct;

  uint64_t v189 = (void *)*((void *)&v503 + 1);
  *((void *)&v503 + 1) = &__NSDictionary0__struct;

  BOOL v190 = [v473 count] == 0;
LABEL_183:
  BOOL objb = v190;

  uint64_t v483 = *(void *)v499;
  InclusiveRange = GroupBuilder_findInclusiveRange(*(_DWORD *)(*(void *)(*(void *)v499 + 112) + 12), *(void **)(*(void *)(*(void *)v499 + 112) + 24), v499[5620]);
  if (InclusiveRange)
  {
    do
    {
      BOOL CommandEncoder = IsFuncEnumCreateCommandEncoder(*((_DWORD *)InclusiveRange + 7));
      if (CommandEncoder) {
        break;
      }
      uint64_t v193 = *((unsigned int *)InclusiveRange + 4);
      if (v193) {
        InclusiveRange -= 4 * v193;
      }
      else {
        InclusiveRange = 0;
      }
    }
    while (InclusiveRange);
    char v194 = !CommandEncoder;
  }
  else
  {
    char v194 = 1;
  }
  if (objb)
  {
    id v474 = 0;
    id v487 = 0;
  }
  else
  {
    id v487 = objc_alloc_init((Class)NSMutableDictionary);
    id v474 = objc_alloc_init((Class)NSMutableDictionary);
  }
  id v497 = objc_alloc_init((Class)NSMutableOrderedSet);
  id v492 = objc_alloc_init((Class)NSMutableOrderedSet);
  if (v194)
  {
    BOOL v195 = 0;
  }
  else
  {
    unint64_t v196 = *InclusiveRange + 1;
    if (v196 >= InclusiveRange[1])
    {
      BOOL v458 = 0;
    }
    else
    {
      BOOL v458 = 0;
      uint64_t v456 = (int)(v467 - 1);
      do
      {
        uint64_t v197 = *(void *)(*(void *)(v483 + 120) + 24);
        uint64_t v198 = v197 + (v196 << 6);
        int v201 = *(_DWORD *)(v198 + 8);
        long long v200 = (int *)(v198 + 8);
        int v199 = v201;
        if (v201 > -15820)
        {
          switch(v199)
          {
            case -15819:
              long long v219 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), *(unsigned __int8 *)(v197 + (v196 << 6) + 13), *(void *)(v483 + 16));
              if (v456 > 5) {
                uint64_t v220 = 0;
              }
              else {
                uint64_t v220 = qword_4C8440[v456];
              }
              if ((*((void *)v219 + 3) & v220) != 0)
              {
                id v229 = +[NSNumber numberWithUnsignedLongLong:*((void *)v219 + 1)];
                [v497 addObject:v229];
              }
              break;
            case -15818:
              long long v221 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), *(unsigned __int8 *)(v197 + (v196 << 6) + 13), *(void *)(v483 + 16));
              long long v222 = v221;
              if (v456 > 5) {
                uint64_t v223 = 0;
              }
              else {
                uint64_t v223 = qword_4C8440[v456];
              }
              if ((*((void *)v221 + 3) & v223) != 0)
              {
                uint64_t v230 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), v221[32], *(void *)(v483 + 16));
                if (*((void *)v222 + 1))
                {
                  size_t v231 = v230;
                  unint64_t v232 = 0;
                  do
                  {
                    id v233 = +[NSNumber numberWithUnsignedLongLong:*(void *)&v231[8 * v232]];
                    [v497 addObject:v233];

                    ++v232;
                  }
                  while (v232 < *((void *)v222 + 1));
                }
              }
              break;
            case -15732:
              BOOL v458 = *((_DWORD *)GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), *(unsigned __int8 *)(v197 + (v196 << 6) + 13), *(void *)(v483 + 16))+ 2) != 0;
              break;
          }
        }
        else
        {
          switch(v199)
          {
            case -16047:
            case -16043:
              long long v202 = +[NSNumber numberWithUnsignedLongLong:*((void *)GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), *(unsigned __int8 *)(v197 + (v196 << 6) + 13), *(void *)(v483 + 16))+ 1)];
              [v497 addObject:v202];

              break;
            case -16046:
              long long v209 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), *(unsigned __int8 *)(v197 + (v196 << 6) + 13), *(void *)(v483 + 16));
              long long v210 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), v209[24], *(void *)(v483 + 16));
              if (*((void *)v209 + 1))
              {
                long long v211 = v210;
                unint64_t v212 = 0;
                do
                {
                  long long v213 = +[NSNumber numberWithUnsignedLongLong:*(void *)&v211[8 * v212]];
                  [v497 addObject:v213];

                  ++v212;
                }
                while (v212 < *((void *)v209 + 1));
              }
              break;
            case -16045:
            case -16041:
              long long v203 = +[NSNumber numberWithUnsignedLongLong:*((void *)GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), *(unsigned __int8 *)(v197 + (v196 << 6) + 13), *(void *)(v483 + 16))+ 1)];
              [v492 addObject:v203];

              break;
            case -16044:
              long long v204 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), *(unsigned __int8 *)(v197 + (v196 << 6) + 13), *(void *)(v483 + 16));
              long long v205 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), v204[16], *(void *)(v483 + 16));
              if (*((void *)v204 + 1))
              {
                long long v206 = v205;
                unint64_t v207 = 0;
                do
                {
                  long long v208 = +[NSNumber numberWithUnsignedLongLong:*(void *)&v206[8 * v207]];
                  [v492 addObject:v208];

                  ++v207;
                }
                while (v207 < *((void *)v204 + 1));
              }
              break;
            case -16042:
              id v224 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), *(unsigned __int8 *)(v197 + (v196 << 6) + 13), *(void *)(v483 + 16));
              id v225 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), v224[24], *(void *)(v483 + 16));
              if (*((void *)v224 + 1))
              {
                int v226 = v225;
                unint64_t v227 = 0;
                do
                {
                  id v228 = +[NSNumber numberWithUnsignedLongLong:*(void *)&v226[8 * v227]];
                  [v497 addObject:v228];

                  ++v227;
                }
                while (v227 < *((void *)v224 + 1));
              }
              break;
            case -16040:
              long long v214 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), *(unsigned __int8 *)(v197 + (v196 << 6) + 13), *(void *)(v483 + 16));
              long long v215 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), v214[16], *(void *)(v483 + 16));
              if (*((void *)v214 + 1))
              {
                long long v216 = v215;
                unint64_t v217 = 0;
                do
                {
                  long long v218 = +[NSNumber numberWithUnsignedLongLong:*(void *)&v216[8 * v217]];
                  [v492 addObject:v218];

                  ++v217;
                }
                while (v217 < *((void *)v214 + 1));
              }
              break;
            default:
              break;
          }
        }
        if (!objb)
        {
          int v234 = *v200;
          switch(*v200)
          {
            case -15456:
              if (v467 == 2) {
                goto LABEL_262;
              }
              break;
            case -15455:
              if (v467 == 2)
              {
                uint64_t v252 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), *(unsigned __int8 *)(v197 + (v196 << 6) + 13), *(void *)(v483 + 16));
                uint64_t v253 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), v252[24], *(void *)(v483 + 16));
                uint64_t v254 = *((void *)v252 + 2);
                if (v254)
                {
                  uint64_t v255 = v253;
                  uint64_t v256 = *((void *)v252 + 1);
                  do
                  {
                    uint64_t v257 = *(void *)v255;
                    v255 += 8;
                    unint64_t v258 = +[NSNumber numberWithUnsignedLongLong:v257];
                    uint64_t v259 = +[NSNumber numberWithUnsignedLongLong:v256];
                    [v487 setObject:v258 forKeyedSubscript:v259];

                    ++v256;
                    --v254;
                  }
                  while (v254);
                }
              }
              break;
            case -15454:
            case -15453:
            case -15452:
            case -15449:
            case -15448:
            case -15447:
              break;
            case -15451:
              if (v467 == 3) {
                goto LABEL_262;
              }
              break;
            case -15450:
              if (v467 == 3)
              {
                unint64_t v244 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), *(unsigned __int8 *)(v197 + (v196 << 6) + 13), *(void *)(v483 + 16));
                unint64_t v245 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), v244[24], *(void *)(v483 + 16));
                uint64_t v246 = *((void *)v244 + 2);
                if (!v246) {
                  goto LABEL_262;
                }
                int v247 = v245;
                uint64_t v248 = *((void *)v244 + 1);
                do
                {
                  uint64_t v249 = *(void *)v247;
                  v247 += 8;
                  int v250 = +[NSNumber numberWithUnsignedLongLong:v249];
                  uint64_t v251 = +[NSNumber numberWithUnsignedLongLong:v248];
                  [v487 setObject:v250 forKeyedSubscript:v251];

                  ++v248;
                  --v246;
                }
                while (v246);
                goto LABEL_252;
              }
              break;
            case -15446:
              if (v467 == 1) {
                goto LABEL_262;
              }
              break;
            case -15445:
              if (v467 == 1)
              {
                id v263 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), *(unsigned __int8 *)(v197 + (v196 << 6) + 13), *(void *)(v483 + 16));
                uint64_t v264 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), v263[24], *(void *)(v483 + 16));
                uint64_t v265 = *((void *)v263 + 2);
                if (v265)
                {
                  v266 = v264;
                  uint64_t v267 = *((void *)v263 + 1);
                  do
                  {
                    uint64_t v268 = *(void *)v266;
                    v266 += 8;
                    int v269 = +[NSNumber numberWithUnsignedLongLong:v268];
                    uint64_t v270 = +[NSNumber numberWithUnsignedLongLong:v267];
                    [v487 setObject:v269 forKeyedSubscript:v270];

                    ++v267;
                    --v265;
                  }
                  while (v265);
                }
              }
              break;
            default:
              if (v234 == -15581)
              {
LABEL_252:
                if (v467 == 3)
                {
LABEL_262:
                  id v260 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), *(unsigned __int8 *)(v197 + (v196 << 6) + 13), *(void *)(v483 + 16));
                  int v261 = +[NSNumber numberWithUnsignedLongLong:*((void *)v260 + 1)];
                  id v262 = +[NSNumber numberWithUnsignedLongLong:*((void *)v260 + 2)];
                  [v487 setObject:v261 forKeyedSubscript:v262];
                }
              }
              else if (v234 == -15580 && v467 == 3)
              {
                uint64_t v236 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), *(unsigned __int8 *)(v197 + (v196 << 6) + 13), *(void *)(v483 + 16));
                id v237 = GTTraceFunc_argumentBytesWithMap((void *)(v197 + (v196 << 6)), v236[24], *(void *)(v483 + 16));
                uint64_t v238 = *((void *)v236 + 2);
                if (v238)
                {
                  unint64_t v239 = v237;
                  uint64_t v240 = *((void *)v236 + 1);
                  do
                  {
                    uint64_t v241 = *(void *)v239;
                    v239 += 8;
                    unsigned int v242 = +[NSNumber numberWithUnsignedLongLong:v241];
                    BOOL v243 = +[NSNumber numberWithUnsignedLongLong:v240];
                    [v487 setObject:v242 forKeyedSubscript:v243];

                    ++v240;
                    --v238;
                  }
                  while (v238);
                }
              }
              break;
          }
        }
        ++v196;
      }
      while (v196 < InclusiveRange[1]);
    }
    BOOL v195 = v458;
  }
  if (!objb && ([v487 count] || objc_msgSend(v474, "count")))
  {
    id v271 = [*((id *)&v501 + 1) mutableCopy];
    long long v541 = 0u;
    long long v542 = 0u;
    long long v539 = 0u;
    long long v540 = 0u;
    id v272 = v487;
    id v273 = [v272 countByEnumeratingWithState:&v539 objects:__dst count:16];
    if (v273)
    {
      uint64_t v274 = *(void *)v540;
      do
      {
        for (uint64_t j = 0; j != v273; uint64_t j = (char *)j + 1)
        {
          if (*(void *)v540 != v274) {
            objc_enumerationMutation(v272);
          }
          [v271 removeObjectForKey:*(void *)(*((void *)&v539 + 1) + 8 * (void)j)];
        }
        id v273 = [v272 countByEnumeratingWithState:&v539 objects:__dst count:16];
      }
      while (v273);
    }

    long long v533 = 0u;
    long long v532 = 0u;
    long long v531 = 0u;
    long long v530 = 0u;
    id v276 = v474;
    id v277 = [v276 countByEnumeratingWithState:&v530 objects:&v526 count:16];
    if (v277)
    {
      uint64_t v278 = *(void *)v531;
      do
      {
        for (unint64_t k = 0; k != v277; unint64_t k = (char *)k + 1)
        {
          if (*(void *)v531 != v278) {
            objc_enumerationMutation(v276);
          }
          [v271 removeObjectForKey:*(void *)(*((void *)&v530 + 1) + 8 * (void)k)];
        }
        id v277 = [v276 countByEnumeratingWithState:&v530 objects:&v526 count:16];
      }
      while (v277);
    }

    id v280 = [v271 copy];
    long long v281 = (void *)*((void *)&v501 + 1);
    *((void *)&v501 + 1) = v280;

    id v282 = [v272 copy];
    long long v283 = (void *)v503;
    *(void *)&long long v503 = v282;

    id v284 = [v276 copy];
    long long v285 = (void *)*((void *)&v503 + 1);
    *((void *)&v503 + 1) = v284;
  }
  uint64_t v286 = [v492 array];
  long long v287 = (void *)v500;
  *(void *)&long long v500 = v286;

  uint64_t v288 = [v497 array];
  long long v289 = (void *)*((void *)&v500 + 1);
  *((void *)&v500 + 1) = v288;

  char v504 = v504 & 0xFE | v195;
  long long v505 = v462;
  v484 = [*((id *)&v514 + 1) objectForKeyedSubscript:@"Program"];
  v475 = [v484 objectForKeyedSubscript:@"Stitching"];
  if ([v475 count])
  {
    id v498 = v475;
    id v488 = [v506 copy];
    v493 = [v498 objectForKeyedSubscript:@"DAGMetalLibs"];
    if ((GTShaderDebuggerMakeRuntimeLibrariesFromMetallibs((id *)&v499, v493, v470) & 1) == 0)
    {
      id v312 = [v488 copy];
      v313 = v506;
      id v506 = v312;

      goto LABEL_423;
    }
    v468 = [v498 objectForKeyedSubscript:@"DAGFunctionUIDs"];
    if ((GTShaderDebuggerMakeRuntimeFunctions((uint64_t)&v499, v468, v470) & 1) == 0)
    {
      id v314 = [v488 copy];
      uint64_t v315 = v506;
      id v506 = v314;

      goto LABEL_423;
    }
    id v290 = [v506 copy];
    long long v291 = [v488 allKeys];
    long long v292 = [v290 allKeys];
    id v293 = [v292 mutableCopy];

    [v293 removeObjectsInArray:v291];
    id v459 = [v293 copy];

    id v294 = [v498 objectForKeyedSubscript:@"LibraryUIDs"];
    id v463 = [v506 mutableCopy];
    v465 = [*((id *)v499 + 1) defaultDevice];
    long long v295 = *(uint64_t **)(*(void *)v499 + 40);
    unint64_t v296 = **((void **)&v505 + 1);
    long long v526 = 0u;
    long long v527 = 0u;
    long long v528 = 0u;
    long long v529 = 0u;
    id objc = v294;
    id v297 = [objc countByEnumeratingWithState:&v526 objects:__dst count:16];
    if (v297)
    {
      uint64_t v298 = *(void *)v527;
LABEL_295:
      uint64_t v299 = 0;
      while (1)
      {
        if (*(void *)v527 != v298) {
          objc_enumerationMutation(objc);
        }
        unint64_t v300 = *(void **)(*((void *)&v526 + 1) + 8 * v299);
        v301 = _ObjectUIDsWithAliasID((void **)&v499, (uint64_t)[v300 unsignedLongLongValue]);
        if (![v301 count])
        {
          unint64_t v316 = +[NSString stringWithFormat:@"Internal error: Library '%@' not found", v300];
          if (v470)
          {
            GTShaderDebuggerMakeError(1u, v316, 0, 0, 0);
            void *v470 = (id)objc_claimAutoreleasedReturnValue();
          }
          goto LABEL_320;
        }
        v302 = [v301 firstObject];
        uint64_t v303 = GTMTLSMContext_lastObject(*v295, (uint64_t)[v302 unsignedLongLongValue], v296);

        if (!v303) {
          break;
        }
        if (*(unsigned char *)(v303 + 161) != 6)
        {
          unint64_t v316 = +[NSString stringWithFormat:@"Internal error: Unexpected library data type (%d)", *(unsigned __int8 *)(v303 + 161)];
          if (v470)
          {
            GTShaderDebuggerMakeError(1u, v316, 0, 0, 0);
            void *v470 = (id)objc_claimAutoreleasedReturnValue();
          }
LABEL_320:

LABEL_329:
LABEL_330:
          int v311 = 0;
          unint64_t v310 = objc;
          goto LABEL_331;
        }
        uint64_t v304 = *(void *)(v303 + 72);
        if (!v304)
        {
          if (v470)
          {
            uint64_t v317 = *(void *)(v303 + 80);
            if (v317) {
              unint64_t v318 = @"-[MTLDevice newLibraryWithDAG:functions:error:] is not supported";
            }
            else {
              unint64_t v318 = @"Internal error: Failed to read stitched library descriptor";
            }
            if (v317) {
              unsigned int v319 = 4;
            }
            else {
              unsigned int v319 = 1;
            }
            GTShaderDebuggerMakeError(v319, v318, 0, 0, 0);
            void *v470 = (id)objc_claimAutoreleasedReturnValue();
          }
          goto LABEL_329;
        }
        unint64_t v305 = MakeMTLStitchedLibraryDescriptor(v304, v506);
        *(void *)&long long v539 = 0;
        id v306 = [v465 newLibraryWithStitchedDescriptor:v305 error:&v539];
        id v307 = (id)v539;
        if (v306)
        {
          v308 = +[NSNumber numberWithUnsignedLongLong:*(void *)(v303 + 8)];
          [v463 setObject:v306 forKeyedSubscript:v308];
        }
        else if (v470)
        {
          GTShaderDebuggerMakeError(1u, @"Internal error: Failed to set up runtime stitched library", 0, v307, 0);
          void *v470 = (id)objc_claimAutoreleasedReturnValue();
        }

        if (!v306) {
          goto LABEL_330;
        }
        if (v297 == (id)++v299)
        {
          id v297 = [objc countByEnumeratingWithState:&v526 objects:__dst count:16];
          if (v297) {
            goto LABEL_295;
          }
          goto LABEL_309;
        }
      }
      unint64_t v316 = +[NSString stringWithFormat:@"Internal error: Library '%@' not found", v300];
      if (v470)
      {
        GTShaderDebuggerMakeError(1u, v316, 0, 0, 0);
        void *v470 = (id)objc_claimAutoreleasedReturnValue();
      }
      goto LABEL_320;
    }
LABEL_309:

    id v309 = [v463 copy];
    unint64_t v310 = v506;
    id v506 = v309;
    int v311 = 1;
LABEL_331:

    id v320 = [v506 mutableCopy];
    [v320 removeObjectsForKeys:v459];
    id v321 = [v320 copy];
    unint64_t v322 = v506;
    id v506 = v321;

    if (!v311) {
      goto LABEL_424;
    }
  }
  v455 = [v484 objectForKeyedSubscript:@"SourceLibs"];
  if ([v455 count])
  {
    id v498 = v455;
    v466 = (char *)[v498 count];
    if (!v466)
    {
      if (v470)
      {
        GTShaderDebuggerMakeError(4u, @"No source", 0, 0, 0);
        void *v470 = (id)objc_claimAutoreleasedReturnValue();
      }

      goto LABEL_423;
    }
    id v445 = *((id *)v499 + 1);
    v460 = [v445 defaultDevice];
    id v451 = [v460 argumentBuffersSupport];
    id v448 = objc_alloc_init((Class)NSMutableDictionary);
    id v447 = [v506 mutableCopy];
    unint64_t v323 = [v445 dynamicLibraries];
    id v449 = [v323 mutableCopy];

    v457 = v466 - 1;
    uint64_t v324 = (v516 >> 2) & 1;
    if (v466 != (unsigned char *)&def_1C1270 + 1) {
      LODWORD(v324) = 1;
    }
    int v450 = v324;
    v325 = (unint64_t *)*((void *)&v505 + 1);
    v326 = *(uint64_t **)(*(void *)v499 + 40);
    id v464 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", objc_msgSend(v498, "count"));
    id v469 = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:[v498 count]];
    long long v541 = 0u;
    long long v542 = 0u;
    long long v539 = 0u;
    long long v540 = 0u;
    id v498 = v498;
    id v327 = [v498 countByEnumeratingWithState:&v539 objects:__dst count:16];
    if (v327)
    {
      uint64_t v328 = *(void *)v540;
LABEL_338:
      uint64_t v329 = 0;
      while (1)
      {
        if (*(void *)v540 != v328) {
          objc_enumerationMutation(v498);
        }
        unint64_t v330 = *(void **)(*((void *)&v539 + 1) + 8 * v329);
        id v331 = [v330 unsignedIntegerValue];
        v332 = (void *)GetAliasStream(*(void *)(*(void *)v499 + 24), (uint64_t)v331, **((void **)&v505 + 1));
        uint64_t v333 = v332 ? *v332 : 0;
        unint64_t v334 = +[NSNumber numberWithUnsignedLongLong:v333];
        uint64_t v335 = GTMTLSMContext_lastObject(*v326, (uint64_t)[v334 unsignedLongLongValue], *v325);
        if (!v335 || *(unsigned char *)(v335 + 161) != 2) {
          break;
        }
        unint64_t v336 = +[NSValue valueWithPointer:v335];
        [v464 setObject:v336 forKeyedSubscript:v334];

        [v469 setObject:v330 forKeyedSubscript:v334];
        if (v327 == (id)++v329)
        {
          id v327 = [v498 countByEnumeratingWithState:&v539 objects:__dst count:16];
          if (!v327) {
            goto LABEL_348;
          }
          goto LABEL_338;
        }
      }
      v386 = +[NSString stringWithFormat:@"Invalid library \"%@\": Expected library with source", v334];
      if (v470)
      {
        GTShaderDebuggerMakeError(4u, v386, 0, 0, 0);
        void *v470 = (id)objc_claimAutoreleasedReturnValue();
      }

      v494 = 0;
      int v387 = 0;
      v388 = v498;
LABEL_412:

      if (v387) {
        goto LABEL_413;
      }
LABEL_423:

LABEL_424:
      goto LABEL_139;
    }
LABEL_348:

    v337 = [v464 allKeys];
    v534 = _NSConcreteStackBlock;
    uint64_t v535 = 3221225472;
    v536 = __GTShaderDebuggerMakeRuntimeLibrariesFromSources_block_invoke;
    v537 = &unk_7469C8;
    id v454 = v464;
    id v538 = v454;
    v338 = [v337 sortedArrayUsingComparator:&v534];

    long long v533 = 0u;
    long long v532 = 0u;
    long long v531 = 0u;
    long long v530 = 0u;
    id v446 = v338;
    id v339 = [v446 countByEnumeratingWithState:&v530 objects:&v526 count:16];
    if (!v339)
    {
      v494 = 0;
LABEL_410:

      id v390 = [v447 copy];
      uint64_t v391 = v506;
      id v506 = v390;

      id v392 = [v448 copy];
      uint64_t v389 = (void *)v507;
      *(void *)&long long v507 = v392;
      int v387 = 1;
LABEL_411:

      v388 = v538;
      goto LABEL_412;
    }
    v494 = 0;
    uint64_t v453 = *(void *)v531;
LABEL_350:
    uint64_t v340 = 0;
    id v452 = v339;
    while (1)
    {
      if (*(void *)v531 != v453) {
        objc_enumerationMutation(v446);
      }
      unint64_t v341 = *(void **)(*((void *)&v530 + 1) + 8 * v340);
      id objd = [v469 objectForKeyedSubscript:v341];
      unint64_t v342 = [v454 objectForKeyedSubscript:v341];
      v343 = [v342 pointerValue];

      v489 = [v498 objectForKeyedSubscript:objd];
      v344 = [v489 objectForKeyedSubscript:@"Code"];
      if (v466 == (unsigned char *)&def_1C1270 + 1)
      {
        [v448 setObject:v344 forKeyedSubscript:@"/program_source"];
        goto LABEL_362;
      }
      uint64_t v345 = +[NSCharacterSet newlineCharacterSet];
      id v346 = [v344 rangeOfCharacterFromSet:v345];

      if (v346 == (id)0x7FFFFFFFFFFFFFFFLL) {
        goto LABEL_355;
      }
      v350 = [v344 substringToIndex:v346];
      if (([v350 containsString:@"#line"] & 1) == 0
        && ([v350 containsString:@"# line"] & 1) == 0)
      {
        break;
      }
      id v351 = v494;
LABEL_361:

      v494 = v351;
LABEL_362:
      uint64_t v354 = v343[13];
      if (v354)
      {
        MakeMTLCompileOptions(v354, v449);
        id v355 = (id)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        id v355 = objc_alloc_init((Class)MTLCompileOptions);
      }
      v356 = v355;
      id v357 = objc_alloc_init((Class)NSMutableArray);
      unint64_t v358 = [v356 additionalCompilerArguments];
      id v359 = [v358 length];

      if (v359)
      {
        unint64_t v360 = [v356 additionalCompilerArguments];
        [v357 addObject:v360];
      }
      if (v466 == (unsigned char *)&def_1C1270 + 1) {
        [v357 addObject:@"-fno-tracepoint-instrument-line-markers"];
      }
      v361 = [v489 objectForKeyedSubscript:@"SelectFunctions"];
      if (v361)
      {
        [v357 addObject:@"-fno-tracepoint-default-instrument"];
        v362 = [v361 componentsJoinedByString:@","];
        uint64_t v363 = [@"-ftracepoint-instrument-functions=" stringByAppendingString:v362];
        [v357 addObject:v363];
      }
      if (!v451) {
        [v357 addObject:@"-fno-tracepoint-instrument-argument-buffers"];
      }
      if (v450)
      {
        [v357 addObject:@"-dynamic-libtracepoint"];
        [v357 addObject:@"-Wl,-mllvm"];
        [v357 addObject:@"-Wl,-disable-legacy-trace-buffer"];
        [v357 addObject:@"-fexternally-initialized"];
        [v357 addObject:@"-Wl,-mllvm"];
        [v357 addObject:@"-Wl,-external-initialization"];
        [v357 addObject:@"-Wl,-mllvm"];
        v364 = +[NSNumber numberWithInteger:v457];
        uint64_t v365 = [v364 stringValue];
        v366 = [@"-Wl,__trace.base_id=" stringByAppendingString:v365];
        [v357 addObject:v366];

        --v457;
      }

      [v356 setTracingEnabled:1];
      uint64_t v367 = [v357 componentsJoinedByString:@" "];
      [v356 setAdditionalCompilerArguments:v367];

      if (*((unsigned char *)v343 + 160) == 1)
      {
        [v356 setLibraryType:1];
        id v368 = v515;
        uint64_t v369 = [v341 stringValue];
        v370 = [v369 stringByAppendingPathExtension:@"metallib"];
        uint64_t v371 = [v368 stringByAppendingPathComponent:v370];
        [v356 setInstallName:v371];
      }
      v522[0] = v494;
      id v372 = [v460 newLibraryWithSource:v344 options:v356 error:v522];
      id v373 = v522[0];

      if (!v372)
      {
        if (v470)
        {
          GTShaderDebuggerMakeError(1u, @"Internal error: Failed to set up main function", 0, v373, 0);
          void *v470 = (id)objc_claimAutoreleasedReturnValue();
        }
        int v383 = 1;
        goto LABEL_397;
      }
      if (*((unsigned char *)v343 + 160) == 1)
      {
        v521[0] = v373;
        id v374 = [v460 newDynamicLibrary:v372 error:v521];
        id v375 = v521[0];

        if (v374)
        {
          uint64_t DylibObjectIDForParentLibrary = _FindDylibObjectIDForParentLibrary((unint64_t **)&v499, (uint64_t)v343, v376, v377);
          if (DylibObjectIDForParentLibrary)
          {
            uint64_t v379 = DylibObjectIDForParentLibrary;
            v380 = +[NSNumber numberWithUnsignedLongLong:DylibObjectIDForParentLibrary];
            [v447 setObject:v374 forKeyedSubscript:v380];

            uint64_t v381 = +[NSNumber numberWithUnsignedLongLong:v343[1]];
            [v447 setObject:v372 forKeyedSubscript:v381];

            v382 = +[NSNumber numberWithUnsignedLongLong:v379];
            [v449 setObject:v374 forKeyedSubscript:v382];

            int v383 = 0;
LABEL_396:
            id v373 = v375;
            goto LABEL_397;
          }
          uint64_t v385 = +[NSString stringWithFormat:@"Internal error: Failed to resolve dynamic library \"%@\"", v341];
          if (v470)
          {
            GTShaderDebuggerMakeError(1u, v385, 0, 0, 0);
            void *v470 = (id)objc_claimAutoreleasedReturnValue();
          }
        }
        else if (v470)
        {
          GTShaderDebuggerMakeError(1u, @"Internal error: Failed to set up dynamic library", 0, v375, 0);
          void *v470 = (id)objc_claimAutoreleasedReturnValue();
        }

        int v383 = 1;
        goto LABEL_396;
      }
      v384 = +[NSNumber numberWithUnsignedLongLong:v343[1]];
      [v447 setObject:v372 forKeyedSubscript:v384];

      int v383 = 0;
LABEL_397:

      v494 = v373;
LABEL_398:

      if (v383)
      {
        int v387 = 0;
        uint64_t v389 = v446;
        goto LABEL_411;
      }
      if (v452 == (id)++v340)
      {
        id v339 = [v446 countByEnumeratingWithState:&v530 objects:&v526 count:16];
        if (v339) {
          goto LABEL_350;
        }
        goto LABEL_410;
      }
    }

LABEL_355:
    id v347 = v515;
    unint64_t v348 = [v341 stringValue];
    v349 = [v348 stringByAppendingPathExtension:@"metal"];
    v350 = [v347 stringByAppendingPathComponent:v349];

    v519[0] = v494;
    LODWORD(v349) = [v344 writeToFile:v350 atomically:1 encoding:4 error:v519];
    id v351 = v519[0];

    if (!v349)
    {

      if (v470)
      {
        GTShaderDebuggerMakeError(1u, @"Internal error trying to disambiguate libraries", 0, v351, 0);
        void *v470 = (id)objc_claimAutoreleasedReturnValue();
      }
      int v383 = 1;
      v494 = v351;
      goto LABEL_398;
    }
    unint64_t v352 = +[NSString stringWithFormat:@"#line 1 \"%@\"\n", v350];
    uint64_t v353 = [v352 stringByAppendingString:v344];

    v344 = (void *)v353;
    goto LABEL_361;
  }
LABEL_413:
  uint64_t v393 = [v484 objectForKeyedSubscript:@"MetalLibs"];
  if ([v393 count]
    && !GTShaderDebuggerMakeRuntimeLibrariesFromMetallibs((id *)&v499, v393, v470))
  {
    goto LABEL_422;
  }
  v394 = [v484 objectForKeyedSubscript:@"DependentLibs"];
  if ([v394 count]
    && !GTShaderDebuggerMakeRuntimeLibrariesFromDependentLibs((uint64_t)&v499, v394, v470))
  {
LABEL_421:

LABEL_422:
    id v498 = v455;
    goto LABEL_423;
  }
  uint64_t v395 = [v484 objectForKeyedSubscript:@"FunctionUIDs"];
  if (!GTShaderDebuggerMakeRuntimeFunctions((uint64_t)&v499, v395, v470))
  {

    goto LABEL_421;
  }
  if (v393) {
    [v393 allKeys];
  }
  else {
  v396 = [v455 allKeys];
  }
  char DebugMetadata = GTShaderDebuggerMakeDebugMetadata((uint64_t)&v499, v395, v396, v470);

  if ((DebugMetadata & 1) == 0 || !GTShaderDebuggerMakeTraceBuffer((uint64_t)&v499, v470)) {
    goto LABEL_139;
  }
  unsigned int v400 = v499[2828];
  if (v400 != 70)
  {
    if (v400 == 28)
    {
      int PSOCompute = GTShaderDebuggerMakePSOCompute((uint64_t)&v499, v470, v398, v399);
      goto LABEL_453;
    }
    GTMTLReplay_handleError(101, (uint64_t)"Unreachable", "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_shaderDebugger.m", (uint64_t)"GTMTLShaderDebugger_makePipelineState", 141, 4);
    if (!v470) {
      goto LABEL_139;
    }
    GTShaderDebuggerMakeError(1u, @"Internal error: Unknown encoder", 0, 0, 0);
    id v159 = (id)objc_claimAutoreleasedReturnValue();
LABEL_152:
    void *v470 = v159;
    goto LABEL_139;
  }
  int PSOCompute = GTShaderDebuggerMakePSORender((id *)&v499, v470);
LABEL_453:
  if (!PSOCompute) {
    goto LABEL_139;
  }
  GTShaderDebuggerJITResources(&v499);
  v426 = v499;
  unsigned int v427 = v499[2828];
  if (v427 == 28)
  {
    if (GTShaderDebuggerEncodeResourcesCompute(&v499, v470)) {
      goto LABEL_461;
    }
LABEL_139:
    GTShaderDebuggerContextDeinit(&v499);
    char v152 = 0;
    goto LABEL_140;
  }
  if (v427 == 70 && (GTShaderDebuggerEncodeResourcesRender(&v499, v470) & 1) == 0) {
    goto LABEL_139;
  }
LABEL_461:
  if (!GTShaderDebuggerExecuteEncoder((uint64_t *)&v499, v470)) {
    goto LABEL_139;
  }
  id v428 = *((id *)v426 + 1);
  *(void *)&long long v539 = 0;
  *((void *)&v539 + 1) = &v539;
  *(void *)&long long v540 = 0x2020000000;
  BYTE8(v540) = 0;
  *(void *)__dst = 0;
  *(void *)&__dst[8] = __dst;
  *(void *)&__dst[16] = 0x3032000000;
  *(void *)&__dst[24] = __Block_byref_object_copy__413;
  *(void *)&__dst[32] = __Block_byref_object_dispose__414;
  *(void *)&__dst[40] = 0;
  unint64_t v429 = [v428 commandBufferForKey:*((void *)v426 + 1419)];
  *(void *)&long long v526 = _NSConcreteStackBlock;
  *((void *)&v526 + 1) = 3221225472;
  *(void *)&long long v527 = __GTMTLShaderDebugger_executeCommandEncoder_block_invoke;
  *((void *)&v527 + 1) = &unk_744978;
  *(void *)&long long v528 = __dst;
  *((void *)&v528 + 1) = &v539;
  [v429 addCompletedHandler:&v526];

  [v428 commitCommandBuffers];
  int v430 = [*((id *)v426 + 1) defaultCommandQueue];
  [v430 finish];

  if (*(unsigned char *)(*((void *)&v539 + 1) + 24))
  {
    int v431 = (char *)[*(id *)(*(void *)&__dst[8] + 40) code];
    if (v431 != (unsigned char *)&dword_8 + 1 && v431 != (unsigned char *)&def_1C1270 + 3
      || GTShaderDebuggerValidateUserEncoderBindings((uint64_t)&v499, v470))
    {
      v432 = [*(id *)(*(void *)&__dst[8] + 40) localizedDescription];
      v433 = [@"Internal error: Problem encountered during execution: " stringByAppendingString:v432];

      if (v470)
      {
        if ((v516 & 0x10) != 0) {
          unsigned int v434 = 4;
        }
        else {
          unsigned int v434 = 3;
        }
        GTShaderDebuggerMakeError(v434, v433, 0, *(void **)(*(void *)&__dst[8] + 40), 0);
        void *v470 = (id)objc_claimAutoreleasedReturnValue();
      }
    }
    _Block_object_dispose(__dst, 8);

    _Block_object_dispose(&v539, 8);
    goto LABEL_139;
  }
  _Block_object_dispose(__dst, 8);

  _Block_object_dispose(&v539, 8);
  id v435 = v471;
  *(void *)&long long v539 = 0;
  v436 = GTShaderDebuggerMakeTraceData((uint64_t)&v499, &v539);
  id v437 = (id)v539;
  v438 = v437;
  if (v436)
  {
    *(void *)__dst = v436;
    *(void *)&long long v526 = @"TraceData";
    *((void *)&v526 + 1) = @"ResourceMapping";
    v439 = GTShaderDebuggerMakeResourceMappings((uint64_t **)&v499);
    *(void *)&__dst[8] = v439;
    v440 = +[NSDictionary dictionaryWithObjects:__dst forKeys:&v526 count:2];
    v441 = +[NSMutableDictionary dictionaryWithDictionary:v440];

    id v442 = v511;
    if (v442) {
      [v441 setObject:v442 forKeyedSubscript:@"TraceMetadata"];
    }
    char v152 = GTShaderDebuggerSanitizeResponse(v441, v435, v499, v470);

    goto LABEL_485;
  }
  if ([v437 code] == (char *)&def_1C1270 + 3)
  {
    char v443 = GTShaderDebuggerValidateUserComputeDispatch(&v499, v470);
    if (v470) {
      char v444 = v443;
    }
    else {
      char v444 = 0;
    }
    if ((v444 & 1) == 0) {
      goto LABEL_482;
    }
LABEL_484:
    char v152 = 0;
    void *v470 = v438;
    goto LABEL_485;
  }
  if (v470) {
    goto LABEL_484;
  }
LABEL_482:
  char v152 = 0;
LABEL_485:

  GTShaderDebuggerContextDeinit(&v499);
LABEL_140:
  __destructor_8_S_S_s8_s16_S_s24_s32_s40_s48_s56_s64_S_s96_s104_s112_s120_S_s128_s136_S_s152_S_s168_s176_s184_s192_s200((uint64_t)&v499);

  return v152;
}

void sub_1EF55C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  _Block_object_dispose(&STACK[0x208], 8);
  _Block_object_dispose((const void *)(v35 - 176), 8);
  __destructor_8_S_S_s8_s16_S_s24_s32_s40_s48_s56_s64_S_s96_s104_s112_s120_S_s128_s136_S_s152_S_s168_s176_s184_s192_s200((uint64_t)&a35);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__413(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__414(uint64_t a1)
{
}

void __destructor_8_S_S_s8_s16_S_s24_s32_s40_s48_s56_s64_S_s96_s104_s112_s120_S_s128_s136_S_s152_S_s168_s176_s184_s192_s200(uint64_t a1)
{
  __destructor_8_s0_s8_s16_s24_s32_s40(a1 + 24);
  id v2 = *(void **)(a1 + 200);
}

void __destructor_8_s0_s8_s16_s24_s32_s40(uint64_t a1)
{
  id v2 = *(void **)(a1 + 40);
}

apr_array_header_t *LoadUniqueIdentifierResourceGroup(int **a1, unsigned int a2, apr_pool_t *p)
{
  int v5 = **a1;
  *a1 += 2;
  uint64_t v6 = apr_array_make(p, v5, 32);
  if (v5 >= 1)
  {
    do
    {
      unsigned int v7 = apr_array_push(v6);
      uint64_t v8 = *a1;
      uint64_t v9 = *(void *)*a1;
      *a1 += 2;
      v7[1] = v9;
      uint64_t v10 = *((void *)v8 + 1);
      *a1 = v8 + 4;
      *unsigned int v7 = v10;
      if (a2 >= 0x41)
      {
        uint64_t v11 = *((void *)v8 + 2);
        *a1 = v8 + 6;
        v7[2] = v11;
      }
      --v5;
    }
    while (v5);
  }
  return v6;
}

id MakeMTLRenderPassAttachmentDescriptor(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 8);
  id v7 = a3;
  uint64_t v8 = +[NSNumber numberWithUnsignedLongLong:v6];
  uint64_t v9 = [v7 objectForKeyedSubscript:v8];
  [v5 setTexture:v9];

  [v5 setLevel:*(unsigned __int8 *)(a2 + 24)];
  [v5 setSlice:*(unsigned __int16 *)(a2 + 22)];
  [v5 setDepthPlane:*(unsigned __int16 *)(a2 + 16)];
  uint64_t v10 = +[NSNumber numberWithUnsignedLongLong:*(void *)a2];
  uint64_t v11 = [v7 objectForKeyedSubscript:v10];

  [v5 setResolveTexture:v11];
  [v5 setResolveLevel:*(unsigned __int8 *)(a2 + 26)];
  [v5 setResolveSlice:*(unsigned __int16 *)(a2 + 20)];
  [v5 setResolveDepthPlane:*(unsigned __int16 *)(a2 + 18)];
  [v5 setLoadAction:*(unsigned __int8 *)(a2 + 25)];
  [v5 setStoreAction:*(unsigned __int8 *)(a2 + 27)];
  [v5 setStoreActionOptions:*(unsigned __int8 *)(a2 + 28)];
  if (objc_opt_respondsToSelector()) {
    [v5 setYInvert:*(unsigned char *)(a2 + 29) != 0];
  }

  return v5;
}

id MakeMTLTextureDescriptorWithoutResourceIndex(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)MTLTextureDescriptor);
  [v2 setTextureType:*(unsigned __int8 *)(a1 + 49)];
  [v2 setPixelFormat:*(unsigned __int16 *)(a1 + 34)];
  [v2 setWidth:*(unsigned int *)(a1 + 24)];
  [v2 setHeight:*(unsigned __int16 *)(a1 + 32)];
  [v2 setDepth:*(unsigned __int16 *)(a1 + 30)];
  [v2 setMipmapLevelCount:*(unsigned __int8 *)(a1 + 45)];
  [v2 setSampleCount:*(unsigned __int8 *)(a1 + 47)];
  [v2 setArrayLength:*(unsigned __int16 *)(a1 + 28)];
  [v2 setFramebufferOnly:*(unsigned char *)(a1 + 43) != 0];
  [v2 setIsDrawable:*(unsigned char *)(a1 + 44) != 0];
  [v2 setUsage:*(unsigned int *)(a1 + 20)];
  if (objc_opt_respondsToSelector()) {
    [v2 setRotation:*(unsigned __int8 *)(a1 + 46)];
  }
  [v2 setResourceOptions:*(unsigned __int16 *)(a1 + 36)];
  [v2 setAllowGPUOptimizedContents:*(unsigned char *)(a1 + 38) != 0];
  if (objc_opt_respondsToSelector()) {
    [v2 setSwizzleKey:*(unsigned int *)(a1 + 16)];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setSparseSurfaceDefaultValue:*(unsigned __int8 *)(a1 + 48)];
  }
  [v2 setWriteSwizzleEnabled:*(unsigned char *)(a1 + 50) != 0];
  if (objc_opt_respondsToSelector()) {
    [v2 setCompressionType:*(unsigned __int8 *)(a1 + 41)];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setCompressionFootprint:*(unsigned __int8 *)(a1 + 39)];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setCompressionMode:*(unsigned __int8 *)(a1 + 40)];
  }

  return v2;
}

id MakeMTLTextureDescriptorWithResourceIndex(uint64_t a1)
{
  id v2 = MakeMTLTextureDescriptorWithoutResourceIndex(a1);
  [v2 setForceResourceIndex:*(void *)(a1 + 8) != 0];
  [v2 setResourceIndex:*(void *)(a1 + 8)];

  return v2;
}

id MakeMTLBufferDescriptor(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)MTLBufferDescriptor);
  [v2 setLength:*(void *)a1];
  [v2 setResourceOptions:*(unsigned __int16 *)(a1 + 32)];
  [v2 setNoCopy:*(unsigned char *)(a1 + 34) != 0];

  return v2;
}

id MakeMTLRenderPipelineColorAttachmentDescriptor(void *a1, unsigned __int16 *a2)
{
  id v3 = a1;
  [v3 setBlendingEnabled:*((unsigned char *)a2 + 3) != 0];
  [v3 setSourceRGBBlendFactor:*((unsigned __int8 *)a2 + 8)];
  [v3 setDestinationRGBBlendFactor:*((unsigned __int8 *)a2 + 5)];
  [v3 setRgbBlendOperation:*((unsigned __int8 *)a2 + 6)];
  [v3 setSourceAlphaBlendFactor:*((unsigned __int8 *)a2 + 7)];
  [v3 setDestinationAlphaBlendFactor:*((unsigned __int8 *)a2 + 4)];
  [v3 setAlphaBlendOperation:*((unsigned __int8 *)a2 + 2)];
  [v3 setWriteMask:*((unsigned __int8 *)a2 + 9)];
  [v3 setPixelFormat:*a2];

  return v3;
}

id CreateObjectArrayWithMap(uint64_t *a1, int a2, void *a3)
{
  id v5 = a3;
  id v6 = [objc_alloc((Class)NSMutableArray) initWithCapacity:a2];
  if (a2 >= 1)
  {
    uint64_t v7 = a2;
    do
    {
      uint64_t v8 = *a1++;
      uint64_t v9 = +[NSNumber numberWithUnsignedLongLong:v8];
      uint64_t v10 = [v5 objectForKeyedSubscript:v9];

      if (v10) {
        [v6 addObject:v10];
      }

      --v7;
    }
    while (v7);
  }
  id v11 = [v6 copy];

  return v11;
}

id MakeMTLRenderPipelineDescriptorWithoutResourceIndex(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)MTLRenderPipelineDescriptor);
  id v5 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 1296)];
  id v6 = [v3 objectForKeyedSubscript:v5];
  [v4 setVertexFunction:v6];

  uint64_t v7 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 1176)];
  uint64_t v8 = [v3 objectForKeyedSubscript:v7];
  [v4 setFragmentFunction:v8];

  id v9 = [v4 vertexDescriptor];
  uint64_t v10 = 0;
  id v11 = (unsigned __int8 *)(a1 + 10);
  do
  {
    uint64_t v12 = [v9 layouts];
    id v13 = [v12 objectAtIndexedSubscript:v10];
    [v13 setStride:*(void *)(v11 - 10)];
    [v13 setStepRate:*((unsigned __int16 *)v11 - 1)];
    unsigned int v14 = *v11;
    v11 += 16;
    [v13 setStepFunction:v14];

    ++v10;
  }
  while (v10 != 31);
  uint64_t v15 = 0;
  id v16 = (unsigned __int8 *)(a1 + 501);
  do
  {
    id v17 = [v9 attributes];
    id v18 = [v17 objectAtIndexedSubscript:v15];
    [v18 setFormat:*v16];
    [v18 setOffset:*(unsigned int *)(v16 - 5)];
    [v18 setBufferIndex:*(v16 - 1)];

    ++v15;
    v16 += 8;
  }
  while (v15 != 31);

  [v4 setRasterSampleCount:*(void *)(a1 + 1272)];
  [v4 setSampleMask:*(void *)(a1 + 1288)];
  LODWORD(v19) = *(_DWORD *)(a1 + 1332);
  [v4 setSampleCoverage:v19];
  [v4 setAlphaToCoverageEnabled:*(unsigned char *)(a1 + 1480) != 0];
  [v4 setAlphaToOneEnabled:*(unsigned char *)(a1 + 1481) != 0];
  [v4 setRasterizationEnabled:*(unsigned char *)(a1 + 1493) != 0];
  [v4 setDepthAttachmentPixelFormat:*(unsigned __int16 *)(a1 + 1340)];
  [v4 setStencilAttachmentPixelFormat:*(unsigned __int16 *)(a1 + 1352)];
  uint64_t v20 = 0;
  float32x4_t v21 = (unsigned __int16 *)(a1 + 744);
  do
  {
    uint64_t v22 = [v4 colorAttachments];
    uint64_t v23 = [v22 objectAtIndexedSubscript:v20];

    ++v20;
    v21 += 8;
  }
  while (v20 != 8);
  if (*(void *)(a1 + 1200))
  {
    uint64_t v24 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    [v4 setLabel:v24];
  }
  [v4 setInputPrimitiveTopology:*(unsigned __int8 *)(a1 + 1485)];
  [v4 setTessellationPartitionMode:*(unsigned __int8 *)(a1 + 1505)];
  [v4 setMaxTessellationFactor:*(void *)(a1 + 1208)];
  [v4 setTessellationFactorScaleEnabled:*(unsigned char *)(a1 + 1502) != 0];
  [v4 setTessellationFactorFormat:*(unsigned __int8 *)(a1 + 1501)];
  [v4 setTessellationControlPointIndexType:*(unsigned __int8 *)(a1 + 1500)];
  [v4 setTessellationFactorStepFunction:*(unsigned __int8 *)(a1 + 1503)];
  [v4 setTessellationOutputWindingOrder:*(unsigned __int8 *)(a1 + 1504)];
  for (uint64_t i = 0; i != 31; ++i)
  {
    id v26 = [v4 vertexBuffers];
    id v27 = [v26 objectAtIndexedSubscript:i];
    [v27 setMutability:*(unsigned __int8 *)(a1 + 1447 + i)];
  }
  for (uint64_t j = 0; j != 31; ++j)
  {
    id v29 = [v4 fragmentBuffers];
    id v30 = [v29 objectAtIndexedSubscript:j];
    [v30 setMutability:*(unsigned __int8 *)(a1 + 1354 + j)];
  }
  [v4 setSupportIndirectCommandBuffers:*(unsigned char *)(a1 + 1499) != 0];
  if (objc_opt_respondsToSelector()) {
    [v4 setVertexAmplificationMode:*(unsigned __int8 *)(a1 + 1507)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setMaxVertexAmplificationCount:*(unsigned int *)(a1 + 1328)];
  }
  CFStringRef v31 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 1264)];
  uint64_t v32 = [v3 objectForKeyedSubscript:v31];
  [v4 setPipelineLibrary:v32];

  if (objc_opt_respondsToSelector()) {
    [v4 setLogicOperation:*(unsigned __int8 *)(a1 + 1486)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setAlphaTestFunction:*(unsigned __int8 *)(a1 + 1479)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setVertexDepthCompareClampMask:*(unsigned int *)(a1 + 1336)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setFragmentDepthCompareClampMask:*(unsigned int *)(a1 + 1324)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setLogicOperationEnabled:*(unsigned char *)(a1 + 1487) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setOpenGLModeEnabled:*(unsigned char *)(a1 + 1489) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setPointCoordLowerLeft:*(unsigned char *)(a1 + 1490) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setPointSizeOutputVS:*(unsigned char *)(a1 + 1491) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setTwoSideEnabled:*(unsigned char *)(a1 + 1506) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setAlphaTestEnabled:*(unsigned char *)(a1 + 1478) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setPointSmoothEnabled:*(unsigned char *)(a1 + 1492) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setClipDistanceEnableMask:*(unsigned __int8 *)(a1 + 1482)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setColorSampleCount:*(void *)(a1 + 1160)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setSampleCoverageInvert:*(unsigned char *)(a1 + 1494) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setNeedsCustomBorderColorSamplers:*(unsigned char *)(a1 + 1488) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setDepthStencilWriteDisabled:*(unsigned char *)(a1 + 1483) != 0];
  }
  [v4 setForceSoftwareVertexFetch:*(unsigned char *)(a1 + 1484) != 0];
  uint64_t v33 = GTData_MakeDictionary(*(void *)(a1 + 1144), *(void *)(a1 + 1152));
  [v4 setPluginData:v33];

  uint64_t v34 = GTData_MakeDictionary(*(void *)(a1 + 1128), *(void *)(a1 + 1136));
  [v4 setDriverCompilerOptions:v34];

  uint64_t v35 = *(void *)(a1 + 1312);
  if (v35)
  {
    uint64_t v36 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 1304), v35, v3);
    [v4 setVertexPreloadedLibraries:v36];
  }
  uint64_t v37 = *(void *)(a1 + 1192);
  if (v37)
  {
    id v38 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 1184), v37, v3);
    [v4 setFragmentPreloadedLibraries:v38];
  }
  id v39 = [v4 vertexLinkedFunctions];
  MakeMTLLinkedFunctions(v39, a1 + 1064, v3);

  unsigned int v40 = [v4 fragmentLinkedFunctions];
  MakeMTLLinkedFunctions(v40, a1 + 872, v3);

  id v41 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 1240)];
  unsigned int v42 = [v3 objectForKeyedSubscript:v41];
  [v4 setObjectFunction:v42];

  id v43 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 1216)];
  id v44 = [v3 objectForKeyedSubscript:v43];
  [v4 setMeshFunction:v44];

  for (uint64_t k = 0; k != 31; ++k)
  {
    id v46 = [v4 objectBuffers];
    id v47 = [v46 objectAtIndexedSubscript:k];
    [v47 setMutability:*(unsigned __int8 *)(a1 + 1416 + k)];
  }
  for (uint64_t m = 0; m != 31; ++m)
  {
    unint64_t v49 = [v4 meshBuffers];
    id v50 = [v49 objectAtIndexedSubscript:m];
    [v50 setMutability:*(unsigned __int8 *)(a1 + 1385 + m)];
  }
  uint64_t v51 = *(void *)(a1 + 1256);
  if (v51)
  {
    id v52 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 1248), v51, v3);
    [v4 setObjectPreloadedLibraries:v52];
  }
  uint64_t v53 = *(void *)(a1 + 1232);
  if (v53)
  {
    id v54 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 1224), v53, v3);
    [v4 setMeshPreloadedLibraries:v54];
  }
  uint64_t v55 = [v4 objectLinkedFunctions];
  MakeMTLLinkedFunctions(v55, a1 + 1000, v3);

  id v56 = [v4 meshLinkedFunctions];
  MakeMTLLinkedFunctions(v56, a1 + 936, v3);

  if (objc_opt_respondsToSelector()) {
    [v4 setSupportAddingVertexBinaryFunctions:*(unsigned char *)(a1 + 1498) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setSupportAddingFragmentBinaryFunctions:*(unsigned char *)(a1 + 1495) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setSupportAddingObjectBinaryFunctions:*(unsigned char *)(a1 + 1497) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setSupportAddingMeshBinaryFunctions:*(unsigned char *)(a1 + 1496) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setExplicitVisibilityGroupID:*(unsigned int *)(a1 + 1320)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setMaxVertexCallStackDepth:*(unsigned __int16 *)(a1 + 1350)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setMaxFragmentCallStackDepth:*(unsigned __int16 *)(a1 + 1344)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setMaxObjectCallStackDepth:*(unsigned __int16 *)(a1 + 1348)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setMaxMeshCallStackDepth:*(unsigned __int16 *)(a1 + 1346)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setMaxAccelerationStructureTraversalDepth:*(unsigned __int16 *)(a1 + 1342)];
  }
  id v57 = v4;

  return v57;
}

id GTData_MakeDictionary(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v4 = objc_opt_class();
    uint64_t v5 = objc_opt_class();
    uint64_t v6 = objc_opt_class();
    uint64_t v7 = objc_opt_class();
    uint64_t v8 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", v4, v5, v6, v7, objc_opt_class(), 0);
    id v9 = +[NSData dataWithBytesNoCopy:a1 length:a2 freeWhenDone:0];
    id v18 = 0;
    uint64_t v10 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v8 fromData:v9 error:&v18];
    id v11 = v18;

    if (v11)
    {
      if (s_logUsingOsLog)
      {
        uint64_t v12 = gt_default_log();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          id v13 = [v11 localizedDescription];
          id v14 = [v13 UTF8String];
          *(_DWORD *)buf = 136315138;
          id v20 = v14;
          _os_log_error_impl(&def_1C1270, v12, OS_LOG_TYPE_ERROR, "warning: %s", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v15 = __stderrp;
        uint64_t v12 = [v11 localizedDescription];
        id v16 = +[NSString stringWithFormat:@"warning: %s", [v12 UTF8String]];
        fprintf(v15, "%s\n", (const char *)[v16 UTF8String]);
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
  }

  return v10;
}

void MakeMTLLinkedFunctions(void *a1, uint64_t a2, void *a3)
{
  id v20 = a1;
  id v5 = a3;
  if (*(void *)(a2 + 56) + *(void *)(a2 + 24) + *(void *)(a2 + 8) + *(void *)(a2 + 40))
  {
    id v6 = v20;
    id v7 = v5;
    uint64_t v8 = *(void *)(a2 + 24);
    if (v8)
    {
      id v9 = CreateObjectArrayWithMap(*(uint64_t **)(a2 + 16), v8, v7);
      [v6 setFunctions:v9];
    }
    uint64_t v10 = *(void *)(a2 + 8);
    if (v10)
    {
      id v11 = CreateObjectArrayWithMap(*(uint64_t **)a2, v10, v7);
      [v6 setBinaryFunctions:v11];
    }
    uint64_t v12 = *(void *)(a2 + 56);
    if (v12)
    {
      id v13 = CreateObjectArrayWithMap(*(uint64_t **)(a2 + 48), v12, v7);
      [v6 setPrivateFunctions:v13];
    }
    if (*(void *)(a2 + 40))
    {
      id v14 = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:*(void *)(a2 + 40)];
      if (*(void *)(a2 + 40))
      {
        uint64_t v15 = 0;
        unint64_t v16 = 0;
        do
        {
          id v17 = +[NSString stringWithUTF8String:*(void *)(*(void *)(a2 + 32) + v15)];
          id v18 = CreateObjectArrayWithMap(*(uint64_t **)(*(void *)(a2 + 32) + v15 + 8), *(_DWORD *)(*(void *)(a2 + 32) + v15 + 16), v7);
          [v14 setObject:v18 forKeyedSubscript:v17];

          ++v16;
          v15 += 24;
        }
        while (*(void *)(a2 + 40) > v16);
      }
      id v19 = [v14 copy];
      [v6 setGroups:v19];
    }
  }
}

id MakeMTLRenderPipelineDescriptorWithResourceIndex(uint64_t a1, void *a2)
{
  id v3 = MakeMTLRenderPipelineDescriptorWithoutResourceIndex(a1, a2);
  uint64_t v4 = v3;
  if (*(unsigned char *)(a1 + 1499)) {
    [v3 setResourceIndex:*(void *)(a1 + 1280)];
  }

  return v4;
}

id MakeMTLMeshRenderPipelineDescriptorWithoutResourceIndex(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)MTLMeshRenderPipelineDescriptor);
  if (*(void *)(a1 + 352))
  {
    id v5 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    [v4 setLabel:v5];
  }
  id v6 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 368)];
  id v7 = [v3 objectForKeyedSubscript:v6];
  [v4 setObjectFunction:v7];

  uint64_t v8 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 360)];
  id v9 = [v3 objectForKeyedSubscript:v8];
  [v4 setMeshFunction:v9];

  uint64_t v10 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 344)];
  id v11 = [v3 objectForKeyedSubscript:v10];
  [v4 setFragmentFunction:v11];

  if (objc_opt_respondsToSelector()) {
    [v4 setMaxTotalThreadsPerObjectThreadgroup:*(unsigned __int16 *)(a1 + 406)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setMaxTotalThreadsPerMeshThreadgroup:*(unsigned __int16 *)(a1 + 404)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setObjectThreadgroupSizeIsMultipleOfThreadExecutionWidth:*(unsigned char *)(a1 + 507) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setMeshThreadgroupSizeIsMultipleOfThreadExecutionWidth:*(unsigned char *)(a1 + 506) != 0];
  }
  [v4 setPayloadMemoryLength:*(void *)(a1 + 376)];
  uint64_t v12 = *(void *)(a1 + 336);
  long long v30 = *(_OWORD *)(a1 + 320);
  uint64_t v31 = v12;
  [v4 setMaxThreadgroupsPerMeshGrid:&v30];
  for (uint64_t i = 0; i != 31; ++i)
  {
    id v14 = [v4 objectBuffers];
    uint64_t v15 = [v14 objectAtIndexedSubscript:i];
    [v15 setMutability:*(unsigned __int8 *)(a1 + 472 + i)];
  }
  for (uint64_t j = 0; j != 31; ++j)
  {
    id v17 = [v4 meshBuffers];
    id v18 = [v17 objectAtIndexedSubscript:j];
    [v18 setMutability:*(unsigned __int8 *)(a1 + 441 + j)];
  }
  for (uint64_t k = 0; k != 31; ++k)
  {
    id v20 = [v4 fragmentBuffers];
    float32x4_t v21 = [v20 objectAtIndexedSubscript:k];
    [v21 setMutability:*(unsigned __int8 *)(a1 + 410 + k)];
  }
  [v4 setRasterSampleCount:*(unsigned __int8 *)(a1 + 508)];
  [v4 setAlphaToCoverageEnabled:*(unsigned char *)(a1 + 503) != 0];
  [v4 setAlphaToOneEnabled:*(unsigned char *)(a1 + 504) != 0];
  [v4 setRasterizationEnabled:*(unsigned char *)(a1 + 509) != 0];
  if (objc_opt_respondsToSelector()) {
    [v4 setMaxVertexAmplificationCount:*(unsigned int *)(a1 + 396)];
  }
  uint64_t v22 = 0;
  uint64_t v23 = (unsigned __int16 *)a1;
  do
  {
    uint64_t v24 = [v4 colorAttachments];
    double v25 = [v24 objectAtIndexedSubscript:v22];

    ++v22;
    v23 += 8;
  }
  while (v22 != 8);
  [v4 setDepthAttachmentPixelFormat:*(unsigned __int16 *)(a1 + 400)];
  [v4 setStencilAttachmentPixelFormat:*(unsigned __int16 *)(a1 + 408)];
  if (objc_opt_respondsToSelector()) {
    [v4 setSupportIndirectCommandBuffers:*(unsigned char *)(a1 + 510) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setExplicitVisibilityGroupID:*(unsigned int *)(a1 + 392)];
  }
  id v26 = [v4 objectLinkedFunctions];
  MakeMTLLinkedFunctions(v26, a1 + 256, v3);

  id v27 = [v4 meshLinkedFunctions];
  MakeMTLLinkedFunctions(v27, a1 + 192, v3);

  uint64_t v28 = [v4 fragmentLinkedFunctions];
  MakeMTLLinkedFunctions(v28, a1 + 128, v3);

  if (objc_opt_respondsToSelector()) {
    [v4 setMaxAccelerationStructureTraversalDepth:*(unsigned __int16 *)(a1 + 402)];
  }

  return v4;
}

id MakeMTLMeshRenderPipelineDescriptorWithResourceIndex(uint64_t a1, void *a2)
{
  id v3 = MakeMTLMeshRenderPipelineDescriptorWithoutResourceIndex(a1, a2);
  id v4 = v3;
  if (*(unsigned char *)(a1 + 510)) {
    [v3 setResourceIndex:*(void *)(a1 + 384)];
  }

  return v4;
}

id MakeMTLStencilDescriptor(void *a1, unsigned int *a2)
{
  id v3 = a1;
  [v3 setStencilCompareFunction:*((unsigned __int8 *)a2 + 10)];
  [v3 setStencilFailureOperation:*((unsigned __int8 *)a2 + 11)];
  [v3 setDepthFailureOperation:*((unsigned __int8 *)a2 + 8)];
  [v3 setDepthStencilPassOperation:*((unsigned __int8 *)a2 + 9)];
  [v3 setReadMask:*a2];
  [v3 setWriteMask:a2[1]];

  return v3;
}

id MakeMTLDepthStencilDescriptor(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)MTLDepthStencilDescriptor);
  [v2 setDepthCompareFunction:*(unsigned __int8 *)(a1 + 40)];
  [v2 setDepthWriteEnabled:*(unsigned char *)(a1 + 41) != 0];
  if (*(void *)(a1 + 32))
  {
    id v3 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    [v2 setLabel:v3];
  }
  id v4 = [v2 frontFaceStencil];

  id v5 = [v2 backFaceStencil];

  return v2;
}

id MakeMTLSamplerDescriptorWithoutResourceIndex(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)MTLSamplerDescriptor);
  [v2 setMinFilter:*(unsigned __int8 *)(a1 + 56)];
  [v2 setMagFilter:*(unsigned __int8 *)(a1 + 55)];
  [v2 setMipFilter:*(unsigned __int8 *)(a1 + 57)];
  [v2 setMaxAnisotropy:*(void *)(a1 + 8)];
  [v2 setSAddressMode:*(unsigned __int8 *)(a1 + 61)];
  [v2 setTAddressMode:*(unsigned __int8 *)(a1 + 63)];
  [v2 setRAddressMode:*(unsigned __int8 *)(a1 + 59)];
  [v2 setNormalizedCoordinates:*(unsigned char *)(a1 + 58) != 0];
  LODWORD(v3) = *(_DWORD *)(a1 + 44);
  [v2 setLodMinClamp:v3];
  LODWORD(v4) = *(_DWORD *)(a1 + 40);
  [v2 setLodMaxClamp:v4];
  if (*(void *)a1)
  {
    id v5 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    [v2 setLabel:v5];
  }
  [v2 setLodAverage:*(unsigned char *)(a1 + 54) != 0];
  [v2 setCompareFunction:*(unsigned __int8 *)(a1 + 51)];
  [v2 setBorderColor:*(unsigned __int8 *)(a1 + 50)];
  [v2 setSupportArgumentBuffers:*(unsigned char *)(a1 + 62) != 0];
  if (objc_opt_respondsToSelector()) {
    [v2 setCustomBorderColorValue_0:*(unsigned int *)(a1 + 24)];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setCustomBorderColorValue_1:*(unsigned int *)(a1 + 28)];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setCustomBorderColorValue_2:*(unsigned int *)(a1 + 32)];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setCustomBorderColorValue_3:*(unsigned int *)(a1 + 36)];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setForceSeamsOnCubemapFiltering:*(unsigned char *)(a1 + 53) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setPixelFormat:*(unsigned __int16 *)(a1 + 48)];
  }

  return v2;
}

id MakeMTLSamplerDescriptorWithResourceIndex(uint64_t a1)
{
  id v2 = MakeMTLSamplerDescriptorWithoutResourceIndex(a1);
  [v2 setForceResourceIndex:*(void *)(a1 + 16) != 0];
  [v2 setResourceIndex:*(void *)(a1 + 16)];

  return v2;
}

id MakeMTLHeapDescriptor(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)MTLHeapDescriptor);
  [v2 setSize:*(void *)(a1 + 8)];
  if (objc_opt_respondsToSelector()) {
    [v2 setType:*(unsigned __int8 *)(a1 + 19)];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setResourceOptions:*(unsigned __int16 *)(a1 + 16)];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setSparsePageSize:*(unsigned __int8 *)(a1 + 18)];
  }

  return v2;
}

id MakeMTLIndirectCommandBufferDescriptorWithoutResourceIndex(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)MTLIndirectCommandBufferDescriptor);
  [v2 setCommandTypes:*(unsigned __int16 *)(a1 + 8)];
  if (objc_opt_respondsToSelector()) {
    [v2 setInheritPipelineState:*(unsigned char *)(a1 + 11) != 0];
  }
  [v2 setInheritBuffers:*(unsigned char *)(a1 + 10) != 0];
  [v2 setMaxVertexBufferBindCount:*(unsigned __int8 *)(a1 + 18)];
  [v2 setMaxFragmentBufferBindCount:*(unsigned __int8 *)(a1 + 12)];
  if (objc_opt_respondsToSelector()) {
    [v2 setMaxKernelBufferBindCount:*(unsigned __int8 *)(a1 + 13)];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setMaxKernelThreadgroupMemoryBindCount:*(unsigned __int8 *)(a1 + 14)];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setSupportRayTracing:*(unsigned char *)(a1 + 20) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setMaxObjectBufferBindCount:*(unsigned __int8 *)(a1 + 16)];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setMaxMeshBufferBindCount:*(unsigned __int8 *)(a1 + 15)];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setMaxObjectThreadgroupMemoryBindCount:*(unsigned __int8 *)(a1 + 17)];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setSupportDynamicAttributeStride:*(unsigned char *)(a1 + 19) != 0];
  }

  return v2;
}

id MakeMTLIndirectCommandBufferDescriptorWithResourceIndex(void *a1)
{
  id v2 = MakeMTLIndirectCommandBufferDescriptorWithoutResourceIndex((uint64_t)a1);
  [v2 setResourceIndex:*a1];

  return v2;
}

id MakeMTLComputePipelineDescriptorWithoutResourceIndex(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)MTLComputePipelineDescriptor);
  id v5 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 848)];
  id v6 = [v3 objectForKeyedSubscript:v5];
  [v4 setComputeFunction:v6];

  [v4 setThreadGroupSizeIsMultipleOfThreadExecutionWidth:*(unsigned char *)(a1 + 958) != 0];
  if (*(void *)(a1 + 872))
  {
    id v7 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    [v4 setLabel:v7];
  }
  id v8 = [v4 stageInputDescriptor];
  uint64_t v9 = 0;
  uint64_t v10 = (unsigned __int8 *)(a1 + 10);
  do
  {
    id v11 = [v8 layouts];
    id v12 = [v11 objectAtIndexedSubscript:v9];
    [v12 setStride:*(void *)(v10 - 10)];
    [v12 setStepRate:*((unsigned __int16 *)v10 - 1)];
    unsigned int v13 = *v10;
    v10 += 16;
    [v12 setStepFunction:v13];

    ++v9;
  }
  while (v9 != 31);
  uint64_t v14 = 0;
  uint64_t v15 = (unsigned __int8 *)(a1 + 501);
  do
  {
    unint64_t v16 = [v8 attributes];
    id v17 = [v16 objectAtIndexedSubscript:v14];
    [v17 setFormat:*v15];
    [v17 setOffset:*(unsigned int *)(v15 - 5)];
    [v17 setBufferIndex:*(v15 - 1)];

    ++v14;
    v15 += 8;
  }
  while (v14 != 31);
  [v8 setIndexType:*(unsigned __int8 *)(a1 + 745)];
  [v8 setIndexBufferIndex:*(unsigned __int8 *)(a1 + 744)];

  for (uint64_t i = 0; i != 31; ++i)
  {
    id v19 = [v4 buffers];
    id v20 = [v19 objectAtIndexedSubscript:i];
    [v20 setMutability:*(unsigned __int8 *)(a1 + 920 + i)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setSupportIndirectCommandBuffers:*(unsigned char *)(a1 + 956) != 0];
  }
  [v4 setMaxTotalThreadsPerThreadgroup:*(unsigned __int16 *)(a1 + 918)];
  float32x4_t v21 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 880)];
  uint64_t v22 = [v3 objectForKeyedSubscript:v21];
  [v4 setPipelineLibrary:v22];

  uint64_t v23 = *(void *)(a1 + 864);
  if (v23)
  {
    uint64_t v24 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 856), v23, v3);
    [v4 setFunctionPointers:v24];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setTextureWriteRoundingMode:*(unsigned __int8 *)(a1 + 957)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setOpenGLModeEnabled:*(unsigned char *)(a1 + 954) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setOpenCLModeEnabled:*(unsigned char *)(a1 + 953) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setNeedsCustomBorderColorSamplers:*(unsigned char *)(a1 + 952) != 0];
  }
  double v25 = GTData_MakeDictionary(*(void *)(a1 + 832), *(void *)(a1 + 840));
  [v4 setPluginData:v25];

  id v26 = GTData_MakeDictionary(*(void *)(a1 + 816), *(void *)(a1 + 824));
  [v4 setDriverCompilerOptions:v26];

  if (objc_opt_respondsToSelector()) {
    [v4 setMaxCallStackDepth:*(unsigned __int16 *)(a1 + 916)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setSupportAddingBinaryFunctions:*(unsigned char *)(a1 + 955) != 0];
  }
  id v27 = [v4 linkedFunctions];
  MakeMTLLinkedFunctions(v27, a1 + 752, v3);

  uint64_t v28 = *(void *)(a1 + 896);
  if (v28)
  {
    id v29 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 888), v28, v3);
    [v4 setPreloadedLibraries:v29];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setMaxAccelerationStructureTraversalDepth:*(unsigned __int16 *)(a1 + 914)];
  }

  return v4;
}

id MakeMTLComputePipelineDescriptorWithResourceIndex(uint64_t a1, void *a2)
{
  id v3 = MakeMTLComputePipelineDescriptorWithoutResourceIndex(a1, a2);
  id v4 = v3;
  if (*(unsigned char *)(a1 + 956)) {
    [v3 setResourceIndex:*(void *)(a1 + 904)];
  }

  return v4;
}

id MakeMTLTileRenderPipelineDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)MTLTileRenderPipelineDescriptor);
  if (*(void *)(a1 + 96))
  {
    id v5 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    [v4 setLabel:v5];
  }
  id v6 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 120)];
  id v7 = [v3 objectForKeyedSubscript:v6];
  [v4 setTileFunction:v7];

  [v4 setRasterSampleCount:*(unsigned __int16 *)(a1 + 134)];
  for (uint64_t i = 0; i != 8; ++i)
  {
    uint64_t v9 = [v4 colorAttachments];
    uint64_t v10 = [v9 objectAtIndexedSubscript:i];
    [v10 setPixelFormat:*(unsigned __int16 *)(a1 + 2 * i + 64)];
  }
  [v4 setThreadgroupSizeMatchesTileSize:*(unsigned char *)(a1 + 169) != 0];
  for (uint64_t j = 0; j != 31; ++j)
  {
    id v12 = [v4 tileBuffers];
    unsigned int v13 = [v12 objectAtIndexedSubscript:j];
    [v13 setMutability:*(unsigned __int8 *)(a1 + j + 136)];
  }
  uint64_t v14 = GTData_MakeDictionary(*(void *)(a1 + 80), *(void *)(a1 + 88));
  [v4 setPluginData:v14];

  uint64_t v15 = *(void *)(a1 + 112);
  if (v15)
  {
    unint64_t v16 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 104), v15, v3);
    [v4 setPreloadedLibraries:v16];
  }
  id v17 = [v4 linkedFunctions];
  MakeMTLLinkedFunctions(v17, a1, v3);

  if (objc_opt_respondsToSelector()) {
    [v4 setSupportAddingBinaryFunctions:*(unsigned char *)(a1 + 168) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setMaxCallStackDepth:*(unsigned __int16 *)(a1 + 130)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setMaxAccelerationStructureTraversalDepth:*(unsigned __int16 *)(a1 + 128)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setMaxTotalThreadsPerThreadgroup:*(unsigned __int16 *)(a1 + 132)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setColorSampleCount:*(unsigned __int8 *)(a1 + 167)];
  }

  return v4;
}

id MakeMTLCommandQueueDescriptor(unsigned int *a1)
{
  id v2 = objc_alloc_init((Class)MTLCommandQueueDescriptor);
  [v2 setMaxCommandBufferCount:*a1];
  if (objc_opt_respondsToSelector()) {
    [v2 setQosLevel:*((unsigned __int8 *)a1 + 8)];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setCommitSynchronously:*((unsigned char *)a1 + 4) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setIsOpenGLQueue:*((unsigned char *)a1 + 7) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setDisableCrossQueueHazardTracking:*((unsigned char *)a1 + 6) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setCommitsWithQoS:*((unsigned char *)a1 + 5) != 0];
  }

  return v2;
}

id MakeMTLIOCommandQueueDescriptor(unsigned int *a1)
{
  id v2 = objc_alloc_init((Class)MTLIOCommandQueueDescriptor);
  [v2 setMaxCommandBufferCount:*a1];
  [v2 setPriority:*((unsigned __int8 *)a1 + 4)];
  [v2 setType:*((unsigned __int8 *)a1 + 5)];

  return v2;
}

id MakeMTLVisibleFunctionTableDescriptorWithoutResourceIndex(void *a1)
{
  id v2 = objc_alloc_init((Class)MTLVisibleFunctionTableDescriptor);
  [v2 setFunctionCount:*a1];

  return v2;
}

id MakeMTLVisibleFunctionTableDescriptorWithResourceIndex(void *a1)
{
  id v2 = objc_alloc_init((Class)MTLVisibleFunctionTableDescriptor);
  [v2 setFunctionCount:*a1];
  [v2 setForceResourceIndex:a1[1] != 0];
  [v2 setResourceIndex:a1[1]];

  return v2;
}

id MakeMTLBlitPassDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)MTLBlitPassDescriptor);
  uint64_t v5 = 0;
  id v6 = (uint64_t *)(a1 + 8);
  do
  {
    if (*v6)
    {
      id v7 = [v4 sampleBufferAttachments];
      id v8 = [v7 objectAtIndexedSubscript:v5];
      uint64_t v9 = *v6;
      id v10 = v3;
      id v11 = +[NSNumber numberWithUnsignedLongLong:v9];
      id v12 = [v10 objectForKeyedSubscript:v11];

      [v8 setSampleBuffer:v12];
      [v8 setStartOfEncoderSampleIndex:v6[1]];
      [v8 setEndOfEncoderSampleIndex:*(v6 - 1)];
    }
    ++v5;
    v6 += 3;
  }
  while (v5 != 4);

  return v4;
}

id MakeMTLComputePassDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)MTLComputePassDescriptor);
  [v4 setDispatchType:*(unsigned __int8 *)(a1 + 96)];
  uint64_t v5 = 0;
  id v6 = (uint64_t *)(a1 + 8);
  do
  {
    if (*v6)
    {
      id v7 = [v4 sampleBufferAttachments];
      id v8 = [v7 objectAtIndexedSubscript:v5];
      uint64_t v9 = *v6;
      id v10 = v3;
      id v11 = +[NSNumber numberWithUnsignedLongLong:v9];
      id v12 = [v10 objectForKeyedSubscript:v11];

      [v8 setSampleBuffer:v12];
      [v8 setStartOfEncoderSampleIndex:v6[1]];
      [v8 setEndOfEncoderSampleIndex:*(v6 - 1)];
    }
    ++v5;
    v6 += 3;
  }
  while (v5 != 4);

  return v4;
}

id MakeMTLResourceStatePassDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)MTLResourceStatePassDescriptor);
  uint64_t v5 = 0;
  id v6 = (uint64_t *)(a1 + 8);
  do
  {
    if (*v6)
    {
      id v7 = [v4 sampleBufferAttachments];
      id v8 = [v7 objectAtIndexedSubscript:v5];
      uint64_t v9 = *v6;
      id v10 = v3;
      id v11 = +[NSNumber numberWithUnsignedLongLong:v9];
      id v12 = [v10 objectForKeyedSubscript:v11];

      [v8 setSampleBuffer:v12];
      [v8 setStartOfEncoderSampleIndex:v6[1]];
      [v8 setEndOfEncoderSampleIndex:*(v6 - 1)];
    }
    ++v5;
    v6 += 3;
  }
  while (v5 != 4);

  return v4;
}

id MakeMTLAccelerationStructurePassDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)MTLAccelerationStructurePassDescriptor);
  uint64_t v5 = 0;
  id v6 = (uint64_t *)(a1 + 8);
  do
  {
    if (*v6)
    {
      id v7 = [v4 sampleBufferAttachments];
      id v8 = [v7 objectAtIndexedSubscript:v5];
      uint64_t v9 = *v6;
      id v10 = v3;
      id v11 = +[NSNumber numberWithUnsignedLongLong:v9];
      id v12 = [v10 objectForKeyedSubscript:v11];

      [v8 setSampleBuffer:v12];
      [v8 setStartOfEncoderSampleIndex:v6[1]];
      [v8 setEndOfEncoderSampleIndex:*(v6 - 1)];
    }
    ++v5;
    v6 += 3;
  }
  while (v5 != 4);

  return v4;
}

id MakeMTLIntersectionFunctionTableDescriptorWithoutResourceIndex(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)MTLIntersectionFunctionTableDescriptor);
  [v2 setFunctionCount:*(unsigned int *)(a1 + 8)];

  return v2;
}

id MakeMTLIntersectionFunctionTableDescriptorWithResourceIndex(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)MTLIntersectionFunctionTableDescriptor);
  [v2 setFunctionCount:*(unsigned int *)(a1 + 8)];
  [v2 setForceResourceIndex:*(void *)a1 != 0];
  [v2 setResourceIndex:*(void *)a1];

  return v2;
}

id MakeMTLRenderPipelineFunctionsDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)MTLRenderPipelineFunctionsDescriptor);
  uint64_t v5 = *(void *)(a1 + 72);
  if (v5)
  {
    id v6 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 64), v5, v3);
    [v4 setVertexAdditionalBinaryFunctions:v6];
  }
  uint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    id v8 = CreateObjectArrayWithMap(*(uint64_t **)a1, v7, v3);
    [v4 setFragmentAdditionalBinaryFunctions:v8];
  }
  uint64_t v9 = *(void *)(a1 + 56);
  if (v9)
  {
    id v10 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 48), v9, v3);
    [v4 setTileAdditionalBinaryFunctions:v10];
  }
  uint64_t v11 = *(void *)(a1 + 24);
  if (v11)
  {
    id v12 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 16), v11, v3);
    [v4 setMeshAdditionalBinaryFunctions:v12];
  }
  uint64_t v13 = *(void *)(a1 + 40);
  if (v13)
  {
    uint64_t v14 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 32), v13, v3);
    [v4 setObjectAdditionalBinaryFunctions:v14];
  }

  return v4;
}

id MakeMTLResidencySetDescriptor(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)MTLResidencySetDescriptor);
  [v2 setEvictsImmediately:*(unsigned char *)(a1 + 16) != 0];
  if (objc_opt_respondsToSelector()) {
    [v2 setInitialCapacity:*(void *)a1];
  }
  if (*(void *)(a1 + 8))
  {
    id v3 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    [v2 setLabel:v3];
  }

  return v2;
}

id MakeMTLTextureDescriptorFromTextureWithoutResourceIndex(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc_init((Class)MTLTextureDescriptor);
  [v2 setTextureType:[v1 textureType]];
  [v2 setPixelFormat:[v1 pixelFormat]];
  [v2 setUsage:[v1 usage]];
  [v2 setWidth:[v1 width]];
  [v2 setHeight:[v1 height]];
  [v2 setDepth:[v1 depth]];
  [v2 setArrayLength:[v1 arrayLength]];
  [v2 setStorageMode:[v1 storageMode]];
  [v2 setSampleCount:[v1 sampleCount]];
  [v2 setCpuCacheMode:[v1 cpuCacheMode]];
  [v2 setMipmapLevelCount:[v1 mipmapLevelCount]];
  if (objc_opt_respondsToSelector()) {
    [v2 setHazardTrackingMode:[v1 hazardTrackingMode]];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setAllowGPUOptimizedContents:[v1 allowGPUOptimizedContents]];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setSwizzle:[v1 swizzle]];
  }
  if (objc_opt_respondsToSelector() & 1) != 0 && (objc_opt_respondsToSelector()) {
    [v2 setSwizzleKey:[v1 swizzleKey]];
  }
  if (objc_opt_respondsToSelector() & 1) != 0 && (objc_opt_respondsToSelector()) {
    [v2 setRotation:[v1 rotation]];
  }
  if (objc_opt_respondsToSelector() & 1) != 0 && (objc_opt_respondsToSelector()) {
    [v2 setSparseSurfaceDefaultValue:[v1 sparseSurfaceDefaultValue]];
  }
  if (objc_opt_respondsToSelector() & 1) != 0 && (objc_opt_respondsToSelector()) {
    [v2 setCompressionType:[v1 compressionType]];
  }
  if (objc_opt_respondsToSelector() & 1) != 0 && (objc_opt_respondsToSelector()) {
    [v2 setCompressionFootprint:[v1 compressionFootprint]];
  }

  return v2;
}

void MakeGTMTLSamplerDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 label];
  uint64_t v5 = (const char *)[v4 UTF8String];

  if (v5) {
    strlen(v5);
  }
  __chkstk_darwin();
  uint64_t v7 = (char *)&v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v7, v6);
  id v8 = v3;
  *(_OWORD *)a1 = GTMTLSamplerDescriptorDefaults;
  *(_OWORD *)(a1 + 16) = unk_4C9940;
  *(_OWORD *)(a1 + 32) = xmmword_4C9950;
  *(_OWORD *)(a1 + 48) = unk_4C9960;
  id v9 = v8;
  id v10 = [v9 label];
  uint64_t v11 = (const char *)[v10 UTF8String];
  id v12 = v11;
  if (!v11 || (size_t v13 = strlen(v11), v14 = v13 + 1, v13 == -1))
  {
    size_t v14 = 0;
    uint64_t v7 = 0;
  }
  memcpy(v7, v12, v14);

  *(unsigned char *)(a1 + 56) = [v9 minFilter];
  *(unsigned char *)(a1 + 55) = [v9 magFilter];
  *(unsigned char *)(a1 + 57) = [v9 mipFilter];
  *(void *)(a1 + 8) = [v9 maxAnisotropy];
  *(unsigned char *)(a1 + 61) = [v9 sAddressMode];
  *(unsigned char *)(a1 + 63) = [v9 tAddressMode];
  *(unsigned char *)(a1 + 59) = [v9 rAddressMode];
  *(unsigned char *)(a1 + 58) = [v9 normalizedCoordinates];
  [v9 lodMinClamp];
  *(_DWORD *)(a1 + 44) = v15;
  [v9 lodMaxClamp];
  *(_DWORD *)(a1 + 40) = v16;
  *(void *)a1 = v7;
  *(unsigned char *)(a1 + 54) = [v9 lodAverage];
  *(unsigned char *)(a1 + 51) = [v9 compareFunction];
  *(unsigned char *)(a1 + 50) = [v9 borderColor];
  *(unsigned char *)(a1 + 62) = [v9 supportArgumentBuffers];
  if (objc_opt_respondsToSelector()) {
    *(void *)(a1 + 16) = [v9 resourceIndex];
  }
  *(unsigned char *)(a1 + 52) = [v9 forceResourceIndex];
  if (objc_opt_respondsToSelector()) {
    *(_DWORD *)(a1 + 24) = [v9 customBorderColorValue];
  }
  if (objc_opt_respondsToSelector()) {
    *(_DWORD *)(a1 + 28) = [v9 customBorderColorValue];
  }
  if (objc_opt_respondsToSelector()) {
    *(_DWORD *)(a1 + 32) = [v9 customBorderColorValue];
  }
  if (objc_opt_respondsToSelector()) {
    *(_DWORD *)(a1 + 36) = [v9 customBorderColorValue];
  }
  if (objc_opt_respondsToSelector()) {
    *(unsigned char *)(a1 + 53) = [v9 forceSeamsOnCubemapFiltering];
  }
  if (objc_opt_respondsToSelector()) {
    *(_WORD *)(a1 + 48) = (unsigned __int16)[v9 pixelFormat];
  }

  id v17 = [v9 label];

  id v18 = v17;
  *(void *)a1 = [v18 UTF8String];
}

id MakeMTLRenderPassDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)MTLRenderPassDescriptor);
  uint64_t v5 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 792)];
  size_t v6 = [v3 objectForKeyedSubscript:v5];
  [v4 setVisibilityResultBuffer:v6];

  uint64_t v7 = 0;
  uint64_t v8 = a1;
  do
  {
    if (*(void *)(v8 + 8))
    {
      id v9 = [v4 colorAttachments];
      id v10 = [v9 objectAtIndexedSubscript:v7];
      [MakeMTLRenderPassAttachmentDescriptor(v10, v8, v3) setClearColor:*(double *)(v8 + 32), *(double *)(v8 + 40), *(double *)(v8 + 48), *(double *)(v8 + 56)];
    }
    v8 += 64;
    ++v7;
  }
  while (v7 != 8);
  id v11 = [v4 depthAttachment];
  [MakeMTLRenderPassAttachmentDescriptor(v11, a1 + 672, v3) setClearDepth:*(double *)(a1 + 704)];
  [v11 setDepthResolveFilter:*(unsigned __int8 *)(a1 + 712)];

  id v12 = [v4 stencilAttachment];
  [MakeMTLRenderPassAttachmentDescriptor(v12, a1 + 720, v3) setClearStencil:*(unsigned int *)(a1 + 752)];
  if (objc_opt_respondsToSelector()) {
    [v12 setStencilResolveFilter:*(unsigned __int8 *)(a1 + 756)];
  }

  [v4 setRenderTargetArrayLength:*(unsigned __int16 *)(a1 + 806)];
  if (objc_opt_respondsToSelector()) {
    [v4 setImageblockSampleLength:*(unsigned __int16 *)(a1 + 804)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setThreadgroupMemoryLength:*(unsigned int *)(a1 + 800)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setTileWidth:*(unsigned __int16 *)(a1 + 814)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setTileHeight:*(unsigned __int16 *)(a1 + 812)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setRenderTargetWidth:*(unsigned __int16 *)(a1 + 810)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setRenderTargetHeight:*(unsigned __int16 *)(a1 + 808)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setDefaultRasterSampleCount:*(unsigned __int8 *)(a1 + 816)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setOpenGLModeEnabled:*(unsigned char *)(a1 + 818) != 0];
  }
  size_t v13 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 784)];
  size_t v14 = [v3 objectForKeyedSubscript:v13];
  [v4 setRasterizationRateMap:v14];

  if (objc_opt_respondsToSelector()) {
    [v4 setDitherEnabled:*(unsigned char *)(a1 + 817) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setDefaultColorSampleCount:*(void *)(a1 + 776)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setPointCoordYFlipEnabled:*(unsigned char *)(a1 + 819) != 0];
  }
  uint64_t v15 = 0;
  int v16 = (void *)(a1 + 544);
  do
  {
    if (*(v16 - 2))
    {
      id v17 = [v4 sampleBufferAttachments];
      id v18 = [v17 objectAtIndexedSubscript:v15];
      uint64_t v19 = *(v16 - 2);
      id v20 = v3;
      float32x4_t v21 = +[NSNumber numberWithUnsignedLongLong:v19];
      uint64_t v22 = [v20 objectForKeyedSubscript:v21];

      [v18 setSampleBuffer:v22];
      [v18 setStartOfVertexSampleIndex:*v16];
      [v18 setEndOfVertexSampleIndex:*(v16 - 3)];
      [v18 setStartOfFragmentSampleIndex:*(v16 - 1)];
      [v18 setEndOfFragmentSampleIndex:*(v16 - 4)];
    }
    ++v15;
    v16 += 5;
  }
  while (v15 != 4);
  if (objc_opt_respondsToSelector()) {
    [v4 setSkipEmptyTilesOnClearEnabled:*(unsigned char *)(a1 + 820) != 0];
  }

  [v4 setSamplePositions:*(void *)(a1 + 760) count:*(void *)(a1 + 768)];

  return v4;
}

id MakeMTLRasterizationRateMapDescriptor(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = 8 * v2;
  __chkstk_darwin();
  id v4 = (char *)v22 - ((8 * v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v4, 8 * v2);
  if (*(void *)(a1 + 16))
  {
    v22[1] = v22;
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      uint64_t v7 = (unsigned __int16 *)(*(void *)(a1 + 8) + v5);
      uint64_t v8 = v7[8];
      uint64_t v9 = v7[10];
      uint64_t v10 = v7[9];
      id v11 = objc_alloc((Class)MTLRasterizationRateLayerDescriptor);
      uint64_t v23 = v8;
      uint64_t v24 = v9;
      uint64_t v25 = v10;
      id v12 = [v11 initWithSampleCount:&v23];
      size_t v13 = *(void **)&v4[8 * v6];
      *(void *)&v4[8 * v6] = v12;

      memcpy([v12 horizontalSampleStorage], *(const void **)(*(void *)(a1 + 8) + v5), 4 * v8);
      memcpy([v12 verticalSampleStorage], *(const void **)(*(void *)(a1 + 8) + v5 + 8), 4 * v9);
      ++v6;
      unint64_t v14 = *(void *)(a1 + 16);
      v5 += 24;
    }
    while (v6 < v14);
  }
  else
  {
    unint64_t v14 = 0;
  }
  uint64_t v15 = *(unsigned __int16 *)(a1 + 30);
  uint64_t v16 = *(unsigned __int16 *)(a1 + 28);
  uint64_t v23 = *(unsigned __int16 *)(a1 + 32);
  uint64_t v24 = v15;
  uint64_t v25 = v16;
  id v17 = +[MTLRasterizationRateMapDescriptor rasterizationRateMapDescriptorWithScreenSize:&v23 layerCount:v14 layers:(char *)v22 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0)];
  if (*(void *)a1)
  {
    id v18 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    [v17 setLabel:v18];
  }
  if (objc_opt_respondsToSelector()) {
    [v17 setMutability:*(unsigned __int8 *)(a1 + 34)];
  }
  if (objc_opt_respondsToSelector())
  {
    LODWORD(v19) = *(_DWORD *)(a1 + 24);
    [v17 setMinFactor:v19];
  }
  if (objc_opt_respondsToSelector()) {
    [v17 setSkipSampleValidationAndApplySampleAtTileGranularity:*(unsigned char *)(a1 + 35) != 0];
  }
  if (v2)
  {
    id v20 = v4 - 8;
    do
    {

      v3 -= 8;
    }
    while (v3);
  }

  return v17;
}

id MakeMTLCounterSampleBufferDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)MTLCounterSampleBufferDescriptor);
  uint64_t v5 = +[NSString stringWithUTF8String:*(void *)(a1 + 8)];
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  uint64_t v16 = v3;
  unint64_t v6 = [v3 counterSets];
  id v7 = [v6 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v18;
    while (2)
    {
      for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v18 != v9) {
          objc_enumerationMutation(v6);
        }
        id v11 = *(void **)(*((void *)&v17 + 1) + 8 * i);
        id v12 = [v11 name];
        unsigned int v13 = [v5 isEqualToString:v12];

        if (v13)
        {
          [v4 setCounterSet:v11];
          goto LABEL_11;
        }
      }
      id v8 = [v6 countByEnumeratingWithState:&v17 objects:v21 count:16];
      if (v8) {
        continue;
      }
      break;
    }
  }
LABEL_11:

  if (*(void *)a1)
  {
    unint64_t v14 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    [v4 setLabel:v14];
  }
  [v4 setStorageMode:*(unsigned __int8 *)(a1 + 44)];
  [v4 setSampleCount:*(unsigned int *)(a1 + 40)];

  return v4;
}

id MakeMTLCompileOptions(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)MTLCompileOptions);
  uint64_t v5 = GTData_MakeDictionary(*(void *)a1, *(void *)(a1 + 8));
  [v4 setPreprocessorMacros:v5];

  [v4 setDebuggingEnabled:*(unsigned char *)(a1 + 56) != 0];
  [v4 setLanguageVersion:*(unsigned int *)(a1 + 48)];
  if (*(void *)(a1 + 16))
  {
    unint64_t v6 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    [v4 setAdditionalCompilerArguments:v6];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setPreserveInvariance:*(unsigned char *)(a1 + 62) != 0];
  }
  if (*(void *)(a1 + 24))
  {
    id v7 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    [v4 setInstallName:v7];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setLibraryType:*(unsigned __int8 *)(a1 + 58)];
  }
  uint64_t v8 = *(void *)(a1 + 40);
  if (v8)
  {
    uint64_t v9 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 32), v8, v3);
    [v4 setLibraries:v9];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setSourceLanguage:*(unsigned __int8 *)(a1 + 63)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setOptimizationLevel:*(unsigned __int8 *)(a1 + 61)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setCompileSymbolVisibility:*(unsigned __int8 *)(a1 + 55)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setAllowReferencingUndefinedSymbols:*(unsigned char *)(a1 + 54) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setMaxTotalThreadsPerThreadgroup:*(unsigned __int16 *)(a1 + 52)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setMathFloatingPointFunctions:*(unsigned __int8 *)(a1 + 59)];
  }
  if (objc_opt_respondsToSelector()) {
    [v4 setMathMode:*(unsigned __int8 *)(a1 + 60)];
  }

  return v4;
}

id MakeMTLFunctionConstantValues(void *a1)
{
  id v2 = objc_alloc_init((Class)MTLFunctionConstantValues);
  unint64_t v3 = a1[1];
  if (v3)
  {
    uint64_t v4 = 0;
    for (unint64_t i = 0; i < v3; ++i)
    {
      uint64_t v6 = *(void *)(*a1 + v4);
      if (v6)
      {
        [v2 setConstantValue:v6 type:*(unsigned __int8 *)(*a1 + v4 + 27) atIndex:*(unsigned __int16 *)(*a1 + v4 + 24)];
        unint64_t v3 = a1[1];
      }
      v4 += 32;
    }
  }

  return v2;
}

id MakeMTLFunctionDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)MTLFunctionDescriptor);
  [v4 setOptions:*(unsigned __int8 *)(a1 + 40)];
  if (*(void *)(a1 + 8))
  {
    uint64_t v5 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    [v4 setName:v5];
  }
  if (*(void *)(a1 + 32))
  {
    uint64_t v6 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    [v4 setSpecializedName:v6];
  }
  if (*(void *)a1)
  {
    id v7 = MakeMTLFunctionConstantValues(*(void **)a1);
    [v4 setConstantValues:v7];
  }
  if (*(void *)(a1 + 24) && (objc_opt_respondsToSelector() & 1) != 0)
  {
    uint64_t v8 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 16), *(_DWORD *)(a1 + 24), v3);
    [v4 setPrivateFunctions:v8];
  }

  return v4;
}

id MakeMTLAccelerationStructureDescriptor(unsigned __int8 *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  int v5 = *a1;
  switch(v5)
  {
    case 3:
      id v112 = objc_alloc_init((Class)MTLIndirectInstanceAccelerationStructureDescriptor);
      unsigned int v113 = +[NSNumber numberWithUnsignedLongLong:*((void *)a1 + 1)];
      unsigned __int8 v114 = [v4 objectForKeyedSubscript:v113];
      [v112 setInstanceDescriptorBuffer:v114];

      [v112 setInstanceDescriptorBufferOffset:*((void *)a1 + 2)];
      int v115 = +[NSNumber numberWithUnsignedLongLong:*((void *)a1 + 3)];
      CFStringRef v116 = [v4 objectForKeyedSubscript:v115];
      [v112 setInstanceCountBuffer:v116];

      [v112 setInstanceCountBufferOffset:*((void *)a1 + 4)];
      unsigned int v117 = +[NSNumber numberWithUnsignedLongLong:*((void *)a1 + 5)];
      unsigned int v118 = [v4 objectForKeyedSubscript:v117];
      [v112 setMotionTransformBuffer:v118];

      [v112 setMotionTransformBufferOffset:*((void *)a1 + 6)];
      CFStringRef v119 = +[NSNumber numberWithUnsignedLongLong:*((void *)a1 + 7)];
      CFStringRef v120 = [v4 objectForKeyedSubscript:v119];
      [v112 setMotionTransformCountBuffer:v120];

      id v97 = v112;
      [v112 setMotionTransformCountBufferOffset:*((void *)a1 + 8)];
      [v112 setMaxInstanceCount:*((unsigned int *)a1 + 20)];
      [v112 setInstanceDescriptorStride:*((unsigned int *)a1 + 21)];
      [v112 setMaxMotionTransformCount:*((unsigned int *)a1 + 22)];
      [v112 setInstanceDescriptorType:a1[92]];
      if (objc_opt_respondsToSelector()) {
        [v112 setMotionTransformStride:*((void *)a1 + 9)];
      }
      if (objc_opt_respondsToSelector()) {
        [v112 setMotionTransformType:a1[93]];
      }
      if (objc_opt_respondsToSelector()) {
        [v112 setInstanceTransformationMatrixLayout:a1[94]];
      }
      break;
    case 2:
      uint64_t v100 = a1[1];
      id v101 = objc_alloc_init((Class)MTLInstanceAccelerationStructureDescriptor);
      [v101 setUsage:v100];
      unint64_t v102 = +[NSNumber numberWithUnsignedLongLong:*((void *)a1 + 2)];
      unint64_t v103 = [v4 objectForKeyedSubscript:v102];
      [v101 setInstanceDescriptorBuffer:v103];

      [v101 setInstanceDescriptorBufferOffset:*((void *)a1 + 4)];
      [v101 setInstanceDescriptorStride:*((unsigned int *)a1 + 15)];
      uint64_t v104 = v101;
      [v101 setInstanceCount:*((unsigned int *)a1 + 16)];
      id v105 = [objc_alloc((Class)NSMutableArray) initWithCapacity:*((unsigned int *)a1 + 14)];
      if (*((_DWORD *)a1 + 14))
      {
        unint64_t v106 = 0;
        do
        {
          id v107 = +[NSNumber numberWithUnsignedLongLong:*(void *)(*((void *)a1 + 1) + 8 * v106)];
          uint64_t v108 = [v4 objectForKeyedSubscript:v107];
          [v105 addObject:v108];

          ++v106;
        }
        while (v106 < *((unsigned int *)a1 + 14));
      }
      if ([v105 count]) {
        id v109 = v105;
      }
      else {
        id v109 = 0;
      }
      [v104 setInstancedAccelerationStructures:v109];
      [v104 setInstanceDescriptorType:a1[72]];
      unsigned __int8 v110 = +[NSNumber numberWithUnsignedLongLong:*((void *)a1 + 3)];
      id v111 = [v4 objectForKeyedSubscript:v110];
      [v104 setMotionTransformBuffer:v111];

      id v97 = v104;
      [v104 setMotionTransformBufferOffset:*((void *)a1 + 5)];
      [v104 setMotionTransformCount:*((unsigned int *)a1 + 17)];
      if (objc_opt_respondsToSelector()) {
        [v104 setMotionTransformStride:*((void *)a1 + 6)];
      }
      if (objc_opt_respondsToSelector()) {
        [v104 setMotionTransformType:a1[73]];
      }
      if (objc_opt_respondsToSelector()) {
        [v104 setInstanceTransformationMatrixLayout:a1[74]];
      }

      break;
    case 1:
      uint64_t v6 = a1[1];
      id v131 = v3;
      id v122 = objc_alloc_init((Class)MTLPrimitiveAccelerationStructureDescriptor);
      [v122 setUsage:v6];
      id v130 = [objc_alloc((Class)NSMutableArray) initWithCapacity:*((void *)a1 + 2)];
      if (*((void *)a1 + 2))
      {
        unint64_t v7 = 0;
        uint64_t v8 = &send_ptr;
        long long v129 = a1;
        uint64_t v9 = &send_ptr;
        uint64_t v125 = v4;
        do
        {
          uint64_t v10 = *((void *)a1 + 1);
          id v11 = (void *)(v10 + 136 * v7);
          id v12 = v131;
          unsigned int v13 = v12;
          switch(*((unsigned char *)v11 + 36))
          {
            case 1:
              unint64_t v14 = v7;
              uint64_t v15 = v10 + 136 * v7;
              id v16 = v12;
              id v17 = objc_alloc_init((Class)MTLAccelerationStructureTriangleGeometryDescriptor);
              long long v18 = [v8[211] numberWithUnsignedLongLong:*(void *)(v15 + 80)];
              [v16 objectForKeyedSubscript:v18];
              v19 = uint64_t v132 = v11;
              [v17 setVertexBuffer:v19];

              [v17 setVertexBufferOffset:*(void *)(v15 + 88)];
              [v17 setVertexStride:*(void *)(v15 + 96)];
              long long v20 = [v8[211] numberWithUnsignedLongLong:*(void *)(v15 + 40)];
              float32x4_t v21 = [v16 objectForKeyedSubscript:v20];
              [v17 setIndexBuffer:v21];

              id v11 = v132;
              [v17 setIndexBufferOffset:*(void *)(v15 + 48)];
              [v17 setIndexType:*(unsigned __int8 *)(v15 + 104)];
              [v17 setTriangleCount:*(void *)(v15 + 72)];
              if (objc_opt_respondsToSelector()) {
                [v17 setVertexFormat:*((unsigned __int8 *)v132 + 106)];
              }
              unint64_t v7 = v14;
              if (objc_opt_respondsToSelector())
              {
                uint64_t v22 = v10 + 136 * v14;
                uint64_t v23 = +[NSNumber numberWithUnsignedLongLong:*(void *)(v22 + 56)];
                uint64_t v24 = [v16 objectForKeyedSubscript:v23];
                [v17 setTransformationMatrixBuffer:v24];

                id v11 = v132;
                [v17 setTransformationMatrixBufferOffset:*(void *)(v22 + 64)];
              }
              if (objc_opt_respondsToSelector()) {
                [v17 setTransformationMatrixLayout:*((unsigned __int8 *)v11 + 105)];
              }

              uint64_t v8 = &send_ptr;
              uint64_t v9 = &send_ptr;
              break;
            case 2:
              uint64_t v25 = (void *)(v10 + 136 * v7);
              id v17 = objc_alloc_init((Class)MTLAccelerationStructureBoundingBoxGeometryDescriptor);
              id v26 = [v8[211] numberWithUnsignedLongLong:v25[5]];
              id v27 = [v13 objectForKeyedSubscript:v26];
              [v17 setBoundingBoxBuffer:v27];

              uint64_t v9 = &send_ptr;
              id v11 = v25;
              id v4 = v125;
              [v17 setBoundingBoxBufferOffset:v25[6]];
              [v17 setBoundingBoxStride:v25[8]];
              [v17 setBoundingBoxCount:v25[7]];
              break;
            case 3:
              uint64_t v133 = v10 + 136 * v7;
              unint64_t v135 = v7;
              uint64_t v137 = v10;
              id v123 = v12;
              id v28 = v12;
              id v126 = objc_alloc_init((Class)MTLAccelerationStructureMotionTriangleGeometryDescriptor);
              id v29 = [objc_alloc((Class)NSMutableArray) initWithCapacity:*(void *)(v133 + 88)];
              if (*(void *)(v133 + 88))
              {
                uint64_t v30 = 0;
                unint64_t v31 = 0;
                uint64_t v32 = (void *)(v137 + 136 * v7 + 80);
                do
                {
                  id v33 = objc_alloc_init((Class)v9[170]);
                  uint64_t v34 = [v8[211] numberWithUnsignedLongLong:*(void *)(*v32 + v30)];
                  uint64_t v35 = [v28 objectForKeyedSubscript:v34];
                  [v33 setBuffer:v35];

                  uint64_t v8 = &send_ptr;
                  [v33 setOffset:*(void *)(*v32 + v30 + 8)];
                  [v29 addObject:v33];

                  ++v31;
                  v30 += 16;
                }
                while (*(void *)(v133 + 88) > v31);
              }
              id v36 = [v29 copy];
              [v126 setVertexBuffers:v36];

              uint64_t v37 = v137 + 136 * v7;
              [v126 setVertexStride:*(void *)(v37 + 96)];
              id v38 = [v8[211] numberWithUnsignedLongLong:*(void *)(v133 + 40)];
              id v39 = [v28 objectForKeyedSubscript:v38];
              [v126 setIndexBuffer:v39];

              id v17 = v126;
              [v126 setIndexBufferOffset:*(void *)(v37 + 48)];
              [v126 setIndexType:*(unsigned __int8 *)(v37 + 104)];
              [v126 setTriangleCount:*(void *)(v37 + 72)];
              id v11 = (void *)v133;
              if (objc_opt_respondsToSelector()) {
                [v126 setVertexFormat:*(unsigned __int8 *)(v133 + 106)];
              }
              unint64_t v7 = v135;
              if (objc_opt_respondsToSelector())
              {
                uint64_t v40 = v137 + 136 * v135;
                id v41 = [v8[211] numberWithUnsignedLongLong:*(void *)(v40 + 56)];
                unsigned int v42 = [v28 objectForKeyedSubscript:v41];
                [v126 setTransformationMatrixBuffer:v42];

                uint64_t v8 = &send_ptr;
                id v11 = (void *)v133;
                [v126 setTransformationMatrixBufferOffset:*(void *)(v40 + 64)];
              }
              id v4 = v125;
              unsigned int v13 = v123;
              if (objc_opt_respondsToSelector()) {
                [v126 setTransformationMatrixLayout:*((unsigned __int8 *)v11 + 105)];
              }

              uint64_t v9 = &send_ptr;
              uint64_t v10 = v137;
              break;
            case 4:
              id v134 = (void *)(v10 + 136 * v7);
              uint64_t v138 = v10;
              id v127 = objc_alloc_init((Class)MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor);
              id v43 = v13;
              id v44 = v9;
              id v45 = [objc_alloc((Class)NSMutableArray) initWithCapacity:v134[6]];
              if (v134[6])
              {
                uint64_t v46 = 0;
                unint64_t v47 = 0;
                id v48 = v134 + 5;
                do
                {
                  id v49 = objc_alloc_init((Class)v44[170]);
                  id v50 = [v8[211] numberWithUnsignedLongLong:*(void *)(*v48 + v46)];
                  uint64_t v51 = [v43 objectForKeyedSubscript:v50];
                  [v49 setBuffer:v51];

                  uint64_t v8 = &send_ptr;
                  [v49 setOffset:*(void *)(*v48 + v46 + 8)];
                  [v45 addObject:v49];

                  ++v47;
                  v46 += 16;
                }
                while (v134[6] > v47);
              }
              id v52 = [v45 copy];
              id v17 = v127;
              [v127 setBoundingBoxBuffers:v52];

              uint64_t v53 = v138 + 136 * v7;
              [v127 setBoundingBoxStride:*(void *)(v53 + 64)];
              [v127 setBoundingBoxCount:*(void *)(v53 + 56)];

              id v4 = v125;
              uint64_t v9 = v44;
              unsigned int v13 = v43;
              uint64_t v10 = v138;
              goto LABEL_38;
            case 5:
              uint64_t v54 = v10 + 136 * v7;
              id v17 = objc_alloc_init((Class)MTLAccelerationStructureCurveGeometryDescriptor);
              uint64_t v55 = [v8[211] numberWithUnsignedLongLong:*(void *)(v54 + 40)];
              id v56 = [v13 objectForKeyedSubscript:v55];
              [v17 setControlPointBuffer:v56];

              [v17 setControlPointBufferOffset:*(void *)(v54 + 48)];
              id v57 = +[NSNumber numberWithUnsignedLongLong:*(void *)(v54 + 88)];
              id v58 = [v13 objectForKeyedSubscript:v57];
              [v17 setRadiusBuffer:v58];

              [v17 setRadiusBufferOffset:*(void *)(v54 + 96)];
              [v17 setControlPointCount:*(void *)(v54 + 56)];
              [v17 setControlPointStride:*(void *)(v54 + 64)];
              [v17 setRadiusStride:*(void *)(v54 + 104)];
              id v59 = +[NSNumber numberWithUnsignedLongLong:*(void *)(v54 + 72)];
              uint64_t v60 = [v13 objectForKeyedSubscript:v59];
              [v17 setIndexBuffer:v60];

              uint64_t v8 = &send_ptr;
              id v11 = (void *)v54;
              [v17 setIndexBufferOffset:*(void *)(v54 + 80)];
              [v17 setSegmentCount:*(void *)(v54 + 120)];
              [v17 setSegmentControlPointCount:*(void *)(v54 + 112)];
              [v17 setControlPointFormat:*(unsigned __int8 *)(v54 + 128)];
              [v17 setRadiusFormat:*(unsigned __int8 *)(v54 + 133)];
              [v17 setIndexType:*(unsigned __int8 *)(v54 + 132)];
              [v17 setCurveType:*(unsigned __int8 *)(v54 + 130)];
              [v17 setCurveBasis:*(unsigned __int8 *)(v54 + 129)];
              uint64_t v61 = *(unsigned __int8 *)(v54 + 131);
              uint64_t v9 = &send_ptr;
              [v17 setEndCaps:v61];
              break;
            case 6:
              id v134 = (void *)(v10 + 136 * v7);
              unint64_t v136 = v7;
              uint64_t v62 = v10;
              BOOL v63 = v12;
              uint64_t v139 = v62;
              uint64_t v64 = v62 + 136 * v7;
              id v128 = objc_alloc_init((Class)MTLAccelerationStructureMotionCurveGeometryDescriptor);
              id v65 = objc_alloc((Class)NSMutableArray);
              uint64_t v67 = *(void *)(v64 + 48);
              BOOL v66 = (unint64_t *)(v64 + 48);
              id v68 = [v65 initWithCapacity:v67];
              if (*v66)
              {
                uint64_t v69 = 0;
                unint64_t v70 = 0;
                BOOL v71 = v66 - 1;
                do
                {
                  id v72 = objc_alloc_init((Class)v9[170]);
                  double v73 = [v8[211] numberWithUnsignedLongLong:*(void *)(*v71 + v69)];
                  uint64_t v74 = [v63 objectForKeyedSubscript:v73];
                  [v72 setBuffer:v74];

                  uint64_t v8 = &send_ptr;
                  [v72 setOffset:*(void *)(*v71 + v69 + 8)];
                  [v68 addObject:v72];

                  ++v70;
                  v69 += 16;
                }
                while (*v66 > v70);
              }
              unint64_t v124 = v68;
              id v75 = objc_alloc((Class)NSMutableArray);
              uint64_t v76 = v139 + 136 * v136;
              uint64_t v78 = *(void *)(v76 + 96);
              id v77 = (unint64_t *)(v76 + 96);
              id v79 = [v75 initWithCapacity:v78];
              if (*v77)
              {
                uint64_t v80 = 0;
                unint64_t v81 = 0;
                long long v82 = (void *)(v139 + 136 * v136 + 88);
                do
                {
                  id v83 = objc_alloc_init((Class)v9[170]);
                  unsigned int v84 = [v8[211] numberWithUnsignedLongLong:*(void *)(*v82 + v80)];
                  id v85 = [v63 objectForKeyedSubscript:v84];
                  [v83 setBuffer:v85];

                  uint64_t v8 = &send_ptr;
                  [v83 setOffset:*(void *)(*v82 + v80 + 8)];
                  [v79 addObject:v83];

                  ++v81;
                  v80 += 16;
                }
                while (*v77 > v81);
              }
              id v86 = [v124 copy];
              id v17 = v128;
              [v128 setControlPointBuffers:v86];

              id v87 = [v79 copy];
              [v128 setRadiusBuffers:v87];

              uint64_t v88 = v139 + 136 * v136;
              [v128 setControlPointCount:*(void *)(v88 + 56)];
              [v128 setControlPointStride:*(void *)(v88 + 64)];
              [v128 setRadiusStride:*(void *)(v88 + 104)];
              uint64_t v89 = [v8[211] numberWithUnsignedLongLong:*(void *)(v88 + 72)];
              unsigned int v90 = [v63 objectForKeyedSubscript:v89];
              [v128 setIndexBuffer:v90];

              uint64_t v8 = &send_ptr;
              [v128 setIndexBufferOffset:*(void *)(v88 + 80)];
              [v128 setSegmentCount:*(void *)(v88 + 120)];
              [v128 setControlPointFormat:*(unsigned __int8 *)(v88 + 128)];
              [v128 setRadiusFormat:*(unsigned __int8 *)(v88 + 133)];
              [v128 setIndexType:*(unsigned __int8 *)(v88 + 132)];
              [v128 setSegmentControlPointCount:*(void *)(v88 + 112)];
              [v128 setCurveType:*(unsigned __int8 *)(v88 + 130)];
              [v128 setCurveBasis:*(unsigned __int8 *)(v88 + 129)];
              uint64_t v91 = *(unsigned __int8 *)(v88 + 131);
              unint64_t v7 = v136;
              [v128 setEndCaps:v91];

              id v4 = v125;
              unsigned int v13 = v63;
              uint64_t v10 = v139;
LABEL_38:
              id v11 = v134;
              break;
            default:
              id v17 = 0;
              break;
          }
          uint64_t v92 = v10 + 136 * v7;
          [v17 setIntersectionFunctionTableOffset:*(unsigned int *)(v92 + 32)];
          [v17 setOpaque:*(unsigned char *)(v92 + 37) != 0];
          [v17 setAllowDuplicateIntersectionFunctionInvocation:*(unsigned char *)(v92 + 38) != 0];
          if (*v11)
          {
            unsigned int v93 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
            [v17 setLabel:v93];
          }
          if (objc_opt_respondsToSelector())
          {
            uint64_t v94 = v10 + 136 * v7;
            uint64_t v95 = [v8[211] numberWithUnsignedLongLong:*(void *)(v94 + 8)];
            unsigned __int8 v96 = [v13 objectForKeyedSubscript:v95];
            [v17 setPrimitiveDataBuffer:v96];

            uint64_t v8 = &send_ptr;
            [v17 setPrimitiveDataBufferOffset:*(void *)(v94 + 16)];
            [v17 setPrimitiveDataStride:*(unsigned int *)(v94 + 24)];
            [v17 setPrimitiveDataElementSize:*(unsigned int *)(v94 + 28)];
          }

          [v130 addObject:v17];
          ++v7;
          a1 = v129;
        }
        while (*((void *)v129 + 2) > v7);
      }
      id v97 = v122;
      [v122 setGeometryDescriptors:v130];
      LODWORD(v98) = *((_DWORD *)a1 + 8);
      [v122 setMotionStartTime:v98];
      LODWORD(v99) = *((_DWORD *)a1 + 6);
      [v122 setMotionEndTime:v99];
      [v122 setMotionKeyframeCount:*((unsigned int *)a1 + 7)];
      [v122 setMotionStartBorderMode:a1[37]];
      [v122 setMotionEndBorderMode:a1[36]];

      break;
    default:
      id v97 = 0;
      break;
  }

  return v97;
}

id MakeMTLIntersectionFunctionDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)MTLIntersectionFunctionDescriptor);
  [v4 setOptions:*(unsigned __int8 *)(a1 + 40)];
  if (*(void *)(a1 + 8))
  {
    int v5 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    [v4 setName:v5];
  }
  if (*(void *)(a1 + 32))
  {
    uint64_t v6 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    [v4 setSpecializedName:v6];
  }
  if (*(void *)a1)
  {
    unint64_t v7 = MakeMTLFunctionConstantValues(*(void **)a1);
    [v4 setConstantValues:v7];
  }
  if (*(void *)(a1 + 24) && (objc_opt_respondsToSelector() & 1) != 0)
  {
    uint64_t v8 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 16), *(_DWORD *)(a1 + 24), v3);
    [v4 setPrivateFunctions:v8];
  }

  return v4;
}

id MakeMTLStitchedLibraryDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)MTLStitchedLibraryDescriptor);
  [v4 setOptions:*(unsigned __int8 *)(a1 + 20)];
  int v5 = MakeMTLFunctionStitchingGraphArray(*(void *)a1, *(unsigned __int16 *)(a1 + 16));
  [v4 setFunctionGraphs:v5];

  uint64_t v6 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 8), *(unsigned __int16 *)(a1 + 18), v3);

  [v4 setFunctions:v6];

  return v4;
}

id MakeMTLFunctionStitchingGraphArray(uint64_t a1, int a2)
{
  uint64_t v30 = a2;
  id v28 = [objc_alloc((Class)NSMutableArray) initWithCapacity:];
  id v31 = objc_alloc_init((Class)NSMutableDictionary);
  if (a2 >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v29 = a1;
    while (1)
    {
      uint64_t v5 = a1 + 40 * v4;
      uint64_t v6 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", *(void *)v5, v28);
      uint64_t v7 = MakeMTLFunctionStitchingFunctionNodeArray(*(unsigned __int8 **)(v5 + 8), *(unsigned __int16 *)(v5 + 32), v31);
      uint64_t v8 = (void *)v7;
      uint64_t v9 = &__NSArray0__struct;
      if (v7) {
        uint64_t v9 = (void *)v7;
      }
      id v10 = v9;

      id v11 = MakeMTLFunctionStitchingFunctionNode(*(unsigned __int8 **)(v5 + 16), v31);
      uint64_t v12 = *(unsigned __int16 *)(v5 + 34);
      if (*(_WORD *)(v5 + 34))
      {
        unsigned int v13 = *(unsigned __int8 **)(v5 + 24);
        id v14 = [objc_alloc((Class)NSMutableArray) initWithCapacity:v12];
        while (1)
        {
          int v16 = *v13;
          v13 += 8;
          int v15 = v16;
          if (v16 == 1) {
            break;
          }
          if (v15 == 2)
          {
            id v17 = (Class *)MTLFunctionStitchingAttributeKernel_ptr;
LABEL_11:
            id v18 = objc_alloc_init(*v17);
            [v14 addObject:v18];
          }
          if (!--v12)
          {
            id v19 = [v14 copy];

            goto LABEL_15;
          }
        }
        id v17 = (Class *)MTLFunctionStitchingAttributeAlwaysInline_ptr;
        goto LABEL_11;
      }
      id v19 = 0;
LABEL_15:
      a1 = v29;
      long long v20 = &__NSArray0__struct;
      if (v19) {
        long long v20 = v19;
      }
      id v21 = v20;

      int v22 = *(unsigned __int8 *)(v29 + 40 * v4 + 36);
      if (v22 == 2) {
        break;
      }
      if (v22 == 1)
      {
        uint64_t v23 = (Class *)MTLFunctionStitchingGraph_ptr;
LABEL_21:
        id v24 = [objc_alloc(*v23) initWithFunctionName:v6 nodes:v10 outputNode:v11 attributes:v21];
        [v28 addObject:v24];
      }
      if (++v4 == v30) {
        goto LABEL_23;
      }
    }
    uint64_t v23 = (Class *)MTLFunctionStitchingGraphSPI_ptr;
    goto LABEL_21;
  }
LABEL_23:
  uint64_t v25 = v28;
  id v26 = [v28 copy];

  return v26;
}

id MakeMTLFunctionStitchingFunctionNodeArray(unsigned __int8 *a1, unsigned int a2, void *a3)
{
  id v5 = a3;
  if (a2)
  {
    uint64_t v6 = a2;
    id v7 = [objc_alloc((Class)NSMutableArray) initWithCapacity:a2];
    do
    {
      uint64_t v8 = MakeMTLFunctionStitchingFunctionNode(a1, v5);
      [v7 addObject:v8];

      a1 += 48;
      --v6;
    }
    while (v6);
    id v9 = [v7 copy];
  }
  else
  {
    id v9 = 0;
  }

  return v9;
}

id MakeMTLFunctionStitchingFunctionNode(unsigned __int8 *a1, void *a2)
{
  id v3 = a2;
  if (!a1)
  {
    uint64_t v6 = 0;
    goto LABEL_40;
  }
  uint64_t v4 = *((void *)a1 + 4);
  if (!v4
    || (+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *((void *)a1 + 4)), v5 = objc_claimAutoreleasedReturnValue(), [v3 objectForKeyedSubscript:v5], uint64_t v6 = objc_claimAutoreleasedReturnValue(), v5, !v6))
  {
    id v7 = +[NSString stringWithUTF8String:*((void *)a1 + 1)];
    uint64_t v8 = *((void *)a1 + 2);
    id v9 = (char *)*((unsigned __int16 *)a1 + 20);
    id v10 = v3;
    if (v9)
    {
      id v11 = [objc_alloc((Class)NSMutableArray) initWithCapacity:v9];
      do
      {
        switch(*(unsigned char *)v8)
        {
          case 1:
          case 2:
          case 0xC:
            MakeMTLFunctionStitchingFunctionNode(v8, v10);
            id v12 = (id)objc_claimAutoreleasedReturnValue();
            goto LABEL_19;
          case 3:
            id v12 = [objc_alloc((Class)MTLFunctionStitchingInputNode) initWithArgumentIndex:*(unsigned __int16 *)(v8 + 12)];
            goto LABEL_19;
          case 4:
            unsigned int v13 = (objc_class *)MTLFunctionStitchingInputBuffer;
            goto LABEL_15;
          case 5:
            id v12 = [objc_alloc((Class)MTLFunctionStitchingInputBufferAddress) initWithBindIndex:*(unsigned __int16 *)(v8 + 12) byteOffset:*(unsigned int *)(v8 + 8) dereference:*(unsigned char *)(v8 + 14) != 0];
            goto LABEL_19;
          case 6:
            unsigned int v13 = (objc_class *)MTLFunctionStitchingInputTexture;
            goto LABEL_15;
          case 7:
            unsigned int v13 = (objc_class *)MTLFunctionStitchingInputSampler;
            goto LABEL_15;
          case 8:
            unsigned int v13 = (objc_class *)MTLFunctionStitchingInputThreadgroup;
            goto LABEL_15;
          case 9:
            unsigned int v13 = (objc_class *)MTLFunctionStitchingInputImageblock;
LABEL_15:
            id v12 = [[v13 alloc] initWithBindIndex:*(unsigned __int16 *)(v8 + 12)];
            goto LABEL_19;
          case 0xA:
            id v14 = (objc_class *)MTLFunctionStitchingBuiltinThreadPositionInGrid;
            goto LABEL_18;
          case 0xB:
            id v14 = (objc_class *)MTLFunctionStitchingBuiltinThreadPositionInThreadgroup;
LABEL_18:
            id v12 = objc_alloc_init(v14);
LABEL_19:
            int v15 = v12;
            [v11 addObject:v12];

            break;
          default:
            break;
        }
        v8 += 48;
        --v9;
      }
      while (v9);
      id v9 = (char *)[v11 copy];
    }
    if (v9) {
      int v16 = v9;
    }
    else {
      int v16 = (char *)&__NSArray0__struct;
    }
    id v17 = v16;

    uint64_t v18 = MakeMTLFunctionStitchingFunctionNodeArray(*((void *)a1 + 3), *((unsigned __int16 *)a1 + 21), v10);
    id v19 = (void *)v18;
    if (v18) {
      long long v20 = (void *)v18;
    }
    else {
      long long v20 = &__NSArray0__struct;
    }
    id v21 = v20;

    int v22 = *a1;
    switch(v22)
    {
      case 1:
        id v24 = (objc_class *)MTLFunctionStitchingFunctionNode;
        break;
      case 12:
        id v24 = (objc_class *)MTLFunctionStitchingEarlyReturnNode;
        break;
      case 2:
        id v23 = [objc_alloc((Class)MTLFunctionStitchingFunctionNodeSPI) initWithName:v7 arguments:v17 controlDependencies:v21 isEarlyReturn:a1[44] != 0];
LABEL_36:
        uint64_t v6 = v23;
        if (v4)
        {
          uint64_t v25 = +[NSNumber numberWithUnsignedLongLong:v4];
          [v10 setObject:v6 forKeyedSubscript:v25];
        }
        goto LABEL_39;
      default:
        uint64_t v6 = 0;
LABEL_39:

        goto LABEL_40;
    }
    id v23 = [[v24 alloc] initWithName:v7 arguments:v17 controlDependencies:v21];
    goto LABEL_36;
  }
LABEL_40:

  return v6;
}

id MakeMTLStitchedLibraryDescriptorSPI(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)MTLStitchedLibraryDescriptorSPI);
  [v4 setOptions:*(unsigned __int8 *)(a1 + 20)];
  id v5 = MakeMTLFunctionStitchingGraphArray(*(void *)a1, *(unsigned __int16 *)(a1 + 16));
  [v4 setFunctionGraphs:v5];

  uint64_t v6 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 8), *(unsigned __int16 *)(a1 + 18), v3);

  [v4 setFunctions:v6];

  return v4;
}

id MakeMTLAccelerationStructureAllocationDescriptor(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)MTLAccelerationStructureAllocationDescriptor);
  [v2 setStorageMode:*(unsigned __int8 *)(a1 + 9)];
  [v2 setForceResourceIndex:*(void *)a1 != 0];
  [v2 setResourceIndex:*(void *)a1];

  return v2;
}

id MakeMTLFXSpatialScalerDescriptor(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)MTLFXSpatialScalerDescriptor);
  [v2 setInputWidth:*(void *)a1];
  [v2 setInputHeight:*(void *)(a1 + 8)];
  [v2 setOutputWidth:*(void *)(a1 + 16)];
  [v2 setOutputHeight:*(void *)(a1 + 24)];
  [v2 setColorTextureFormat:*(unsigned __int16 *)(a1 + 32)];
  [v2 setOutputTextureFormat:*(unsigned __int16 *)(a1 + 34)];
  [v2 setColorProcessingMode:*(unsigned __int8 *)(a1 + 36)];

  return v2;
}

id MakeMTLFXTemporalScalerDescriptor(unsigned __int16 *a1)
{
  id v2 = objc_alloc_init((Class)MTLFXTemporalScalerDescriptor);
  [v2 setColorTextureFormat:*a1];
  [v2 setDepthTextureFormat:a1[1]];
  [v2 setMotionTextureFormat:a1[2]];
  if (objc_opt_respondsToSelector()) {
    [v2 setReactiveMaskTextureEnabled:*((unsigned char *)a1 + 58) != 0];
  }
  if (objc_opt_respondsToSelector()) {
    [v2 setReactiveMaskTextureFormat:a1[4]];
  }
  [v2 setOutputTextureFormat:a1[3]];
  [v2 setInputWidth:*((void *)a1 + 2)];
  [v2 setInputHeight:*((void *)a1 + 3)];
  [v2 setOutputWidth:*((void *)a1 + 4)];
  [v2 setOutputHeight:*((void *)a1 + 5)];
  LODWORD(v3) = *((_DWORD *)a1 + 12);
  [v2 setInputContentMinScale:v3];
  LODWORD(v4) = *((_DWORD *)a1 + 13);
  [v2 setInputContentMaxScale:v4];
  [v2 setAutoExposureEnabled:*((unsigned char *)a1 + 56) != 0];
  [v2 setInputContentPropertiesEnabled:*((unsigned char *)a1 + 57) != 0];
  if (objc_opt_respondsToSelector()) {
    [v2 setRequiresSynchronousInitialization:*((unsigned char *)a1 + 59) != 0];
  }

  return v2;
}

id ValidateLibrary(void *a1)
{
  id v1 = a1;
  if ((dword_77313C & 0x80000) != 0)
  {
    id v2 = +[NSProcessInfo processInfo];
    double v3 = v2;
    if (v2)
    {
      [v2 operatingSystemVersion];
      uint64_t v4 = v11;
      [v3 operatingSystemVersion];
      uint64_t v5 = v10;
      [v3 operatingSystemVersion];
      uint64_t v6 = v9;
    }
    else
    {
      uint64_t v6 = 0;
      uint64_t v5 = 0;
      uint64_t v4 = 0;
    }
    id v7 = +[NSString stringWithFormat:@"air64-apple-%s%ld.%ld.%ld", "ios", v4, v5, v6];
    [v1 setOverrideTriple:v7];
  }

  return v1;
}

id MTLDevice_newLibraryWithFile(void *a1, uint64_t a2, void *a3)
{
  id v8 = 0;
  id v4 = [a1 newLibraryWithURL:a2 error:&v8];
  id v5 = v8;
  uint64_t v6 = v5;
  if (a3) {
    *a3 = v5;
  }
  ValidateLibrary(v4);
  objc_claimAutoreleasedReturnValue();

  return v4;
}

id MTLDevice_newLibraryWithData(void *a1, uint64_t a2, void *a3)
{
  id v8 = 0;
  id v4 = [a1 newLibraryWithData:a2 error:&v8];
  id v5 = v8;
  uint64_t v6 = v5;
  if (a3) {
    *a3 = v5;
  }
  ValidateLibrary(v4);
  objc_claimAutoreleasedReturnValue();

  return v4;
}

void GTMTLReplay_commitCommandBuffer(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    id v2 = v1;
    LogCommandBuffer(@"Committed", v1);
    AddHandlers(v2);
    [v2 commit];
    id v1 = v2;
    if ((dword_77313C & 2) != 0)
    {
      [v2 waitUntilCompleted];
      id v1 = v2;
    }
  }
}

void LogCommandBuffer(void *a1, void *a2)
{
  id v4 = a1;
  id v5 = a2;
  uint64_t v6 = v5;
  if (s_logUsingOsLog)
  {
    id v7 = gt_tagged_log(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id v8 = [v6 label];
      if (v8)
      {
        id v2 = [v6 label];
        uint64_t v9 = (const char *)[v2 UTF8String];
      }
      else
      {
        uint64_t v9 = "no label";
      }
      *(_DWORD *)buf = 138412802;
      id v14 = v4;
      __int16 v15 = 2048;
      int v16 = v6;
      __int16 v17 = 2080;
      uint64_t v18 = v9;
      _os_log_impl(&def_1C1270, v7, OS_LOG_TYPE_INFO, "%@: %lx (%s)", buf, 0x20u);
      if (v8) {
    }
      }
  }
  else
  {
    uint64_t v10 = __stdoutp;
    id v7 = [v5 label];
    if (v7)
    {
      id v2 = [v6 label];
      uint64_t v11 = (const char *)[v2 UTF8String];
    }
    else
    {
      uint64_t v11 = "no label";
    }
    id v12 = +[NSString stringWithFormat:@"%@: %lx (%s)", v4, v6, v11];
    fprintf(v10, "%s\n", (const char *)[v12 UTF8String]);

    if (v7) {
  }
    }
}

void AddHandlers(void *a1)
{
  id v1 = a1;
  if (GTMTLReplayDefaults_logCommandBufferHandlers()) {
    [v1 addScheduledHandler:&__block_literal_global];
  }
  [v1 addCompletedHandler:&__block_literal_global_52];
}

void GTMTLReplay_commitCommandBufferAndWaitUntilSubmitted(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    id v2 = v1;
    LogCommandBuffer(@"Commit and wait until submitted", v1);
    AddHandlers(v2);
    [v2 commitAndWaitUntilSubmitted];
    id v1 = v2;
    if ((dword_77313C & 2) != 0)
    {
      [v2 waitUntilCompleted];
      id v1 = v2;
    }
  }
}

id PreferDevice(uint64_t a1)
{
  uint64_t Object = GTMTLSMContext_getObject(**(void **)(a1 + 40), 1, *(void *)(a1 + 80));
  unsigned int v3 = (dword_77313C >> 19) & 1;
  if (*(unsigned char *)(Object[5] + 102) != 1) {
    unsigned int v3 = 1;
  }
  if (v3) {
    int v4 = 0x80000;
  }
  else {
    int v4 = 0;
  }
  dword_77313C = v4 | dword_77313C & 0xFFF7FFFF;
  size_t FileWithFilename = GTCaptureArchive_getFileWithFilename(*(void *)a1, "is_almond");
  unsigned int v6 = (dword_77313C >> 19) & 1;
  if (FileWithFilename) {
    unsigned int v6 = 1;
  }
  if (v6) {
    int v7 = 0x80000;
  }
  else {
    int v7 = 0;
  }
  dword_77313C = v7 | dword_77313C & 0xFFF7FFFF;
  id v8 = MTLCreateSystemDefaultDevice();
  uint64_t v9 = DEVICEOBJECT(v8);
  char v10 = objc_opt_respondsToSelector();

  if (v10) {
    [v8 setShaderDebugInfoCaching:1];
  }
  if ((dword_77313C & 0x80000) != 0)
  {
    uint64_t v11 = DEVICEOBJECT(v8);
    char v12 = objc_opt_respondsToSelector();

    if (v12) {
      [v8 allowLibrariesFromOtherPlatforms];
    }
  }

  return v8;
}

BOOL BeginDebugArchivePath(apr_pool_t **a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  char v12 = a5;
  unsigned int v13 = a1;
  id v14 = v12;
  id v15 = v9;
  DataSource = GTMTLReplayController_makeDataSource((const char *)[v15 UTF8String], *a1);
  __int16 v17 = DataSource;
  if (!DataSource)
  {
    v14[2](v14, 0);
    goto LABEL_107;
  }
  uint64_t v138 = v14;
  uint64_t v140 = v10;
  uint64_t v18 = PreferDevice((uint64_t)DataSource);
  uint64_t v137 = v13;
  id v19 = *v13;
  id v136 = v18;
  long long v20 = +[NSProcessInfo processInfo];
  id v21 = [v20 operatingSystemVersionString];
  int v22 = apr_pstrdup(v19, (const char *)[v21 UTF8String]);

  id v23 = apr_palloc(v19, 0x30uLL);
  id v24 = v23;
  if (v23)
  {
    *id v23 = 0u;
    v23[1] = 0u;
  }
  *((void *)v23 + 4) = "iOS";
  *((void *)v23 + 5) = v22;
  uint64_t v25 = [v136 targetDeviceArchitecture];
  *(_DWORD *)id v24 = [v25 cpuType];
  *((_DWORD *)v24 + 1) = [v25 subType];
  *((_WORD *)v24 + 4) = (unsigned __int16)[v25 version];
  *((unsigned char *)v24 + 10) = [v25 version] >> 16;
  *((unsigned char *)v24 + 11) = [v25 version] >> 24;
  *((_DWORD *)v24 + 3) = [v25 versionCombined];
  *((void *)v24 + 2) = [v25 driverVersion];

  if (*(_DWORD *)v24 != 16777235) {
    goto LABEL_45;
  }
  uint64_t v26 = 0;
  unsigned int v27 = *((_DWORD *)v24 + 1) & 0xFFFFFF;
  if (v27 <= 0x162)
  {
    if ((*((_DWORD *)v24 + 1) & 0xFFFFFFu) <= 0xD1)
    {
      if ((*((_DWORD *)v24 + 1) & 0xFFFFFFu) > 0xA2)
      {
        if (v27 != 163 && v27 != 179)
        {
          if (v27 != 194) {
            goto LABEL_45;
          }
          goto LABEL_46;
        }
      }
      else if (v27 - 67 > 0x30 || ((1 << (v27 - 67)) & 0x1000100010001) == 0)
      {
        goto LABEL_45;
      }
    }
    else
    {
      char v28 = *((unsigned char *)v24 + 4) + 29;
      if (v27 - 227 > 0x3F) {
        goto LABEL_8;
      }
      if (((1 << v28) & 0x100010000) != 0) {
        goto LABEL_42;
      }
      if (((1 << v28) & 0x1000000000001) == 0)
      {
        if (((1 << v28) & 0x8000800000000000) != 0) {
          goto LABEL_46;
        }
LABEL_8:
        uint64_t v29 = v27 - 291;
        if (v29 > 0x3F) {
          goto LABEL_12;
        }
        if (((1 << (v27 - 35)) & 0x8000000080008000) != 0) {
          goto LABEL_46;
        }
        if (((1 << (v27 - 35)) & 0x100000001) == 0)
        {
          if (v29 != 48)
          {
LABEL_12:
            if (v27 != 210) {
              goto LABEL_45;
            }
            goto LABEL_46;
          }
LABEL_19:
          uint64_t v26 = 3;
          goto LABEL_46;
        }
        goto LABEL_42;
      }
    }
LABEL_108:
    uint64_t v26 = 1;
    goto LABEL_46;
  }
  if ((*((_DWORD *)v24 + 1) & 0xFFFFFFu) > 0x1B2)
  {
    if ((*((_DWORD *)v24 + 1) & 0xFFFFFFu) > 0x231)
    {
      unsigned int v31 = v27 - 562;
      if (v31 <= 0x30 && ((1 << v31) & 0x1000100010001) != 0) {
        goto LABEL_46;
      }
      goto LABEL_45;
    }
    if (v27 - 498 <= 0x30 && ((1 << (v27 + 14)) & 0x1000100010001) != 0) {
      goto LABEL_46;
    }
    if (v27 != 435)
    {
      if (v27 != 482) {
        goto LABEL_45;
      }
      goto LABEL_46;
    }
    goto LABEL_42;
  }
  uint64_t v30 = v27 - 355;
  if (v30 <= 0x3F)
  {
    if (((1 << (v27 - 99)) & 0x8000800080008000) != 0) {
      goto LABEL_46;
    }
    if (((1 << (v27 - 99)) & 0x100010001) != 0) {
      goto LABEL_19;
    }
    if (v30 == 48)
    {
LABEL_42:
      uint64_t v26 = 2;
      goto LABEL_46;
    }
  }
  if (v27 == 419) {
    goto LABEL_108;
  }
  if (v27 != 434) {
LABEL_45:
  }
    uint64_t v26 = 0xFFFFFFFFLL;
LABEL_46:
  *((void *)v24 + 3) = v26;

  unint64_t v135 = v11;
  unint64_t v146 = v17;
  uint64_t v139 = v15;
  if (v17[6])
  {
    char v152 = objc_alloc_init(GTCaptureArchiveOverrideKey);
    long long v159 = 0u;
    long long v160 = 0u;
    long long v161 = 0u;
    long long v162 = 0u;
    obuint64_t j = [(id)v17[6] filenameOverrides];
    id v149 = [obj countByEnumeratingWithState:&v159 objects:v163 count:16];
    if (v149)
    {
      uint64_t v147 = *(void *)v160;
      id v144 = v24;
      do
      {
        for (unint64_t i = 0; i != v149; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v160 != v147) {
            objc_enumerationMutation(obj);
          }
          uint64_t v33 = *(void *)(*((void *)&v159 + 1) + 8 * i);
          uint64_t v34 = [(id)v17[6] filenameOverrides];
          uint64_t v35 = [v34 objectForKeyedSubscript:v33];

          id v36 = +[NSString stringWithUTF8String:*((void *)v24 + 4)];
          [(GTCaptureArchiveOverrideKey *)v152 setPlatform:v36];
          uint64_t v37 = +[NSNumber numberWithUnsignedLongLong:*((void *)v24 + 3)];
          [(GTCaptureArchiveOverrideKey *)v152 setRiaGeneration:v37];

          id v38 = [v35 objectForKeyedSubscript:v152];
          if (v38) {
            goto LABEL_55;
          }
          [(GTCaptureArchiveOverrideKey *)v152 setPlatform:0];
          id v39 = +[NSNumber numberWithUnsignedLongLong:*((void *)v24 + 3)];
          [(GTCaptureArchiveOverrideKey *)v152 setRiaGeneration:v39];

          id v38 = [v35 objectForKeyedSubscript:v152];
          if (v38
            || ([(GTCaptureArchiveOverrideKey *)v152 setPlatform:v36],
                [(GTCaptureArchiveOverrideKey *)v152 setRiaGeneration:0],
                [v35 objectForKeyedSubscript:v152],
                (id v38 = objc_claimAutoreleasedReturnValue()) != 0))
          {
LABEL_55:
            dispatch_semaphore_t v155 = v36;
            uint64_t v40 = *v17;
            id v41 = [v38 originalFilename];
            unsigned int v42 = (const char *)[v41 UTF8String];
            id v43 = [v38 overrideFilename];
            id v44 = (const char *)[v43 UTF8String];
            *(void *)&long long newpool = 0;
            apr_pool_create_ex((apr_pool_t **)&newpool, *(apr_pool_t **)(v40 + 8), 0, v45);
            uint64_t v46 = (apr_pool_t *)newpool;
            unint64_t v47 = gt_filepath_merge(*(const char **)v40, v44, (apr_pool_t *)newpool);
            id v48 = fopen(v47, "r");
            id v49 = v48;
            if (v48)
            {
              memset(&v173, 0, sizeof(v173));
              int v50 = fileno(v48);
              if (!fstat(v50, &v173))
              {
                key = apr_pstrdup(*(apr_pool_t **)(v40 + 8), v42);
                uint64_t v51 = apr_pstrdup(*(apr_pool_t **)(v40 + 8), v44);
                id v52 = *(apr_array_header_t **)(v40 + 48);
                int nelts = v52->nelts;
                *(void *)apr_array_push(v52) = v51;
                LODWORD(v51) = (LODWORD(v173.st_size) + vm_page_size - 1) & -(int)vm_page_size;
                uint64_t v54 = apr_array_push(*(apr_array_header_t **)(v40 + 80));
                _DWORD *v54 = v51;
                v54[1] = nelts;
                *((void *)v54 + 1) = 0;
                *((void *)v54 + 2) = 2;
                apr_hash_set(*(apr_hash_t **)(v40 + 88), key, -1, v54);
              }
            }
            fclose(v49);
            apr_pool_destroy(v46);

            id v24 = v144;
            __int16 v17 = v146;
            id v36 = v155;
          }
        }
        id v149 = [obj countByEnumeratingWithState:&v159 objects:v163 count:16];
      }
      while (v149);
    }
  }
  id v55 = v136;
  id v56 = objc_alloc_init((Class)NSMutableArray);
  for (uint64_t j = 0; j != 17; ++j)
  {
    uint64_t v58 = qword_4C8150[j];
    if ([v55 supportsFamily:v58])
    {
      id v59 = +[NSNumber numberWithInteger:v58];
      [v56 addObject:v59];
    }
  }
  *(void *)&long long newpool = @"argumentBuffersSupport";
  uint64_t v156 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [v55 argumentBuffersSupport]);
  *(void *)&v173.st_dev = v156;
  *((void *)&newpool + 1) = @"supportsTLS";
  if (objc_opt_respondsToSelector()) {
    id v60 = [v55 supportsTLS];
  }
  else {
    id v60 = 0;
  }
  unint64_t v153 = +[NSNumber numberWithInt:v60];
  v173.st_ino = (__darwin_ino64_t)v153;
  *(void *)&long long v169 = @"supportsGlobalVariableRelocation";
  if (objc_opt_respondsToSelector()) {
    id v61 = [v55 supportsGlobalVariableRelocation];
  }
  else {
    id v61 = 0;
  }
  CFStringRef v150 = +[NSNumber numberWithInt:v61];
  *(void *)&v173.st_uid = v150;
  *((void *)&v169 + 1) = @"supportsGlobalVariableRelocationCompute";
  if (objc_opt_respondsToSelector()) {
    id v62 = [v55 supportsGlobalVariableRelocationCompute];
  }
  else {
    id v62 = 0;
  }
  BOOL v63 = +[NSNumber numberWithInt:v62];
  *(void *)&v173.st_rdev = v63;
  *(void *)&long long v170 = @"supportsGlobalVariableRelocationRender";
  if (objc_opt_respondsToSelector()) {
    id v64 = [v55 supportsGlobalVariableRelocationRender];
  }
  else {
    id v64 = 0;
  }
  id v65 = +[NSNumber numberWithInt:v64];
  v173.st_atimespec.tv_sec = (__darwin_time_t)v65;
  *((void *)&v170 + 1) = @"supportsDynamicLibraries";
  if (objc_opt_respondsToSelector()) {
    id v66 = [v55 supportsDynamicLibraries];
  }
  else {
    id v66 = 0;
  }
  uint64_t v67 = +[NSNumber numberWithInt:v66];
  v173.st_atimespec.tv_nsec = (uint64_t)v67;
  *(void *)&long long v171 = @"supportsRenderDynamicLibraries";
  if (objc_opt_respondsToSelector()) {
    id v68 = [v55 supportsRenderDynamicLibraries];
  }
  else {
    id v68 = 0;
  }
  uint64_t v69 = +[NSNumber numberWithInt:v68];
  v173.st_mtimespec.tv_sec = (__darwin_time_t)v69;
  *((void *)&v171 + 1) = @"supportsFunctionPointers";
  if (objc_opt_respondsToSelector()) {
    id v70 = [v55 supportsFunctionPointers];
  }
  else {
    id v70 = 0;
  }
  BOOL v71 = v55;
  id v72 = +[NSNumber numberWithInt:v70];
  v173.st_mtimespec.tv_nsec = (uint64_t)v72;
  CFStringRef v172 = @"supportsFunctionPointersFromRender";
  if (objc_opt_respondsToSelector()) {
    id v73 = [v55 supportsFunctionPointersFromRender];
  }
  else {
    id v73 = 0;
  }
  uint64_t v74 = +[NSNumber numberWithInt:v73];
  v173.st_ctimespec.tv_sec = (__darwin_time_t)v74;
  id v75 = +[NSDictionary dictionaryWithObjects:&v173 forKeys:&newpool count:9];

  v166[0] = @"shaderDebuggerSupport";
  v166[1] = @"deviceVendorName";
  v167[0] = &off_759840;
  uint64_t v76 = [v71 vendorName];
  v167[1] = v76;
  id v77 = +[NSDictionary dictionaryWithObjects:v167 forKeys:v166 count:2];

  BOOL v78 = [v71 argumentBuffersSupport] != 0;
  LODWORD(v76) = objc_opt_respondsToSelector();
  unsigned int v79 = [v71 supportsFamily:1006];
  v164[0] = @"SupportedFamilies";
  v164[1] = @"FeatureSupport";
  v165[0] = v56;
  v165[1] = v75;
  v165[2] = v77;
  v164[2] = @"DebugSupport";
  v164[3] = @"ResourceAccessTrackingSupport";
  uint64_t v80 = +[NSNumber numberWithBool:v78 & v79 & v76];
  v165[3] = v80;
  uint64_t v81 = +[NSDictionary dictionaryWithObjects:v165 forKeys:v164 count:4];

  id v157 = v71;
  uint64_t v154 = (void *)v81;
  v138[2](v138, v81);
  id v82 = v139;
  id v83 = [objc_alloc((Class)NSURL) initFileURLWithPath:v82 isDirectory:1];

  id v84 = [objc_alloc((Class)NSURL) initWithString:@"metadata" relativeToURL:v83];
  id v85 = [objc_alloc((Class)NSDictionary) initWithContentsOfURL:v84 error:0];

  id v86 = v137[35];
  id v151 = v85;
  id v87 = [v85 objectForKeyedSubscript:@"DYCaptureEngine.launch_dictionary"];
  uint64_t v88 = [v87 objectForKeyedSubscript:@"title"];
  [(apr_pool_t *)v86 setWindowTitle:v88];

  id v89 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v90 = *(void *)(v146[5] + 88);
  int v91 = *(_DWORD *)(v90 + 12);
  if (v91 >= 1)
  {
    for (uint64_t k = 0; k < v91; ++k)
    {
      uint64_t v93 = *(void *)(*(void *)(v90 + 24) + 8 * k);
      if (*(void *)(v93 + 128))
      {
        uint64_t v94 = +[NSNumber numberWithUnsignedLongLong:*(void *)(v93 + 8)];
        uint64_t v95 = +[NSString stringWithUTF8String:*(void *)(v93 + 128)];
        [v89 setObject:v94 forKey:v95];

        int v91 = *(_DWORD *)(v90 + 12);
      }
    }
  }
  id v96 = v140;
  id v97 = v89;
  char v148 = v96;
  id v98 = [objc_alloc((Class)NSURL) initFileURLWithPath:v96];
  id v99 = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:[v97 count]];
  uint64_t v100 = +[NSFileManager defaultManager];
  v165[0] = NSURLNameKey;
  id v101 = +[NSArray arrayWithObjects:v165 count:1];
  id obja = v100;
  uint64_t v145 = v98;
  unint64_t v102 = [v100 enumeratorAtURL:v98 includingPropertiesForKeys:v101 options:0 errorHandler:0];

  long long v170 = 0u;
  long long v171 = 0u;
  long long newpool = 0u;
  long long v169 = 0u;
  id v103 = v102;
  id v104 = [v103 countByEnumeratingWithState:&newpool objects:&v173 count:16];
  if (v104)
  {
    id v105 = v104;
    uint64_t v106 = *(void *)v169;
    do
    {
      for (uint64_t m = 0; m != v105; uint64_t m = (char *)m + 1)
      {
        if (*(void *)v169 != v106) {
          objc_enumerationMutation(v103);
        }
        uint64_t v108 = *(void **)(*((void *)&newpool + 1) + 8 * (void)m);
        id v109 = [v108 pathExtension];
        unsigned int v110 = [v109 isEqualToString:@"metallib"];

        if (v110)
        {
          id v111 = [v108 lastPathComponent];
          id v112 = [v111 stringByDeletingPathExtension];

          unsigned int v113 = [v97 objectForKeyedSubscript:v112];
          if (v113) {
            [v99 setObject:v108 forKeyedSubscript:v113];
          }
        }
      }
      id v105 = [v103 countByEnumeratingWithState:&newpool objects:&v173 count:16];
    }
    while (v105);
  }

  id v11 = v135;
  UpdateDebugFileCache(v135, v99, v97, v148);
  unsigned __int8 v114 = [[GTMTLReplayObjectMap alloc] initWithDevice:v157];
  GTMTLReplaySupport_init(v157);
  __int16 v17 = v146;
  GTMTLReplayController_initializeArgumentBufferSupport((uint64_t)v146, v157, v114);
  GTMTLReplayController_populateUnusedResources(v146, v114);
  v137[1] = (apr_pool_t *)GTMTLReplayController_makeController((uint64_t)v146, *v137, v157, v114, v97, v99);
  GTMTLReplayWireframeRenderer_initWithDevice((uint64_t)(v137 + 12), v157);
  [(apr_pool_t *)v137[35] setOrientation:[(GTMTLReplayObjectMap *)v114 interfaceOrientation]];
  [(apr_pool_t *)v137[35] setDevice:v157];
  int v115 = v137[35];
  [(GTMTLReplayObjectMap *)v114 contentRect];
  double v117 = v116;
  double v119 = v118;
  double v121 = v120;
  double v123 = v122;
  [(GTMTLReplayObjectMap *)v114 windowRect];
  double v125 = v124;
  double v127 = v126;
  double v129 = v128;
  double v131 = v130;
  uint64_t v132 = [(GTMTLReplayObjectMap *)v114 windowProperties];
  -[apr_pool_t setContentRect:windowRect:properties:](v115, "setContentRect:windowRect:properties:", v132, v117, v119, v121, v123, v125, v127, v129, v131);

  v158[0] = _NSConcreteStackBlock;
  v158[1] = 3221225472;
  v158[2] = __BeginDebugArchivePath_block_invoke;
  v158[3] = &__block_descriptor_40_e5_v8__0l;
  v158[4] = v137;
  uint64_t v133 = +[NSBlockOperation blockOperationWithBlock:v158];
  [v133 setQueuePriority:-8];
  [(apr_pool_t *)v137[32] addOperation:v133];

  id v15 = v139;
  id v10 = v140;
  id v14 = v138;
LABEL_107:

  return v17 != 0;
}

void __BeginDebugArchivePath_block_invoke(uint64_t a1)
{
  size_t v2 = os_proc_available_memory();
  uint64_t v3 = v2 - 0x10000000;
  if (v2 - 0x10000000 >= 0x18000000) {
    uint64_t v3 = 402653184;
  }
  if (v2 >> 28) {
    unint64_t v4 = v3;
  }
  else {
    unint64_t v4 = 0;
  }
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);

  GTMTLReplayController_optimizeRestores(v5, v4);
}

uint64_t CleanupSandboxExtensionURL(void *a1)
{
  return 0;
}

uint64_t CleanupSandboxExtension()
{
  return 0;
}

void sub_1F98C8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__738(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__739(uint64_t a1)
{
}

void sub_1FA1EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void BatchFilteredResume()
{
}

void BatchFilteredPause()
{
}

NSObject *NewResourceData(void *a1, void *a2, void *a3, void *a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, void *a9)
{
  id v12 = a1;
  id v87 = a2;
  id v86 = a3;
  id v85 = a4;
  unsigned int v13 = a9;
  id v14 = &_dispatch_data_empty;
  id v15 = &_dispatch_data_empty;
  id v82 = v13;
  int size = dispatch_data_get_size(v13);
  id v16 = v12;
  __int16 v17 = (char *)[v16 bytes];
  uint64_t v81 = v16;
  id v18 = [v16 length];
  if ((unint64_t)v18 >= 9)
  {
    unint64_t v19 = (unint64_t)v18;
    unint64_t v20 = 8;
    unint64_t v83 = (unint64_t)v18;
    id v84 = v17;
    do
    {
      int v22 = &v17[v20];
      int v23 = *(_DWORD *)&v17[v20 + 4];
      if (v23 == -16236 || v23 == -10236)
      {
        id v89 = v21;
        uint64_t v109 = 0;
        long long v107 = 0u;
        int64x2_t v108 = 0u;
        long long v105 = 0u;
        long long v106 = 0u;
        long long v103 = 0u;
        long long v104 = 0u;
        DYTraceDecode_MTLTexture_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage((uint64_t)&v103, (uint64_t)&v17[v20], (*(_DWORD *)v22 - 36), 0);
        uint64_t v25 = *((void *)&v107 + 1);
        uint64_t v26 = +[NSString stringWithUTF8String:*((void *)&v107 + 1)];
        unsigned int v27 = [v87 objectForKeyedSubscript:v26];

        char v28 = +[NSString stringWithUTF8String:v25];
        uint64_t v29 = [v86 objectForKeyedSubscript:v28];
        id v30 = [v29 unsignedLongLongValue];

        id v97 = v30;
        unsigned int v31 = +[NSNumber numberWithUnsignedLongLong:v30];
        id v99 = [v85 objectForKeyedSubscript:v31];

        id v32 = v27;
        uint64_t v33 = (int *)[v32 bytes];
        id v98 = v32;
        id v34 = [v32 length];
        unint64_t v88 = v20;
        if (!v33 || (unint64_t)v34 < 0x10 || *(void *)v33 != 0x63617074757265) {
          goto LABEL_38;
        }
        uint64_t v93 = *((_WORD *)v33 + 5) == 1 ? *((void *)v33 + 2) : 0;
        if (*(void *)v33 == 0x63617074757265)
        {
          uint64_t v53 = v33[3];
          if (*((_WORD *)v33 + 4) == 1) {
            v53 += 16;
          }
          uint64_t v92 = (char *)v33 + v53;
        }
        else
        {
          uint64_t v92 = (char *)v33;
        }
        if (v93)
        {
          uint64_t v54 = 0;
          uint64_t v55 = 0;
          id v56 = v33 + 16;
          do
          {
            *(_WORD *)(a5 + 34) = *((void *)v56 - 5);
            id v57 = [v99 objectForKeyedSubscript:@"DependencyGraphRequestedTextureSlice"];
            id v58 = [v57 unsignedLongLongValue];
            if (v58) {
              __int16 v59 = (__int16)v58;
            }
            else {
              __int16 v59 = v107;
            }

            id v60 = [v99 objectForKeyedSubscript:@"DependencyGraphRequestedTextureLevel"];
            id v61 = [v60 unsignedLongLongValue];
            if (v61) {
              char v62 = (char)v61;
            }
            else {
              char v62 = BYTE8(v106);
            }

            BOOL v63 = [v99 objectForKeyedSubscript:@"DependencyGraphRequestedTextureAttachmentIndex"];
            id v64 = [v63 unsignedLongLongValue];
            if (v64) {
              int v65 = (int)v64;
            }
            else {
              int v65 = v55;
            }

            uint64_t v66 = (*a7)++;
            uint64_t v67 = *((void *)v56 - 5);
            if ((unsigned __int16)v67 == 255 || (unsigned __int16)v67 == 260)
            {
              LOWORD(v67) = 252;
              if (v65) {
                LOWORD(v67) = 253;
              }
            }
            uint64_t v68 = v103;
            int v69 = *v56;
            uint64_t v70 = a6 + 80 * v66;
            int v71 = v105;
            __int16 v72 = WORD4(v105);
            __int16 v73 = v106;
            *(void *)uint64_t v70 = v97;
            *(void *)(v70 + 8) = v68;
            *(void *)(v70 + 16) = a8;
            *(_DWORD *)(v70 + 24) = size;
            *(_DWORD *)(v70 + 28) = v69;
            *(_WORD *)(v70 + 32) = 0;
            *(unsigned char *)(v70 + 34) = 1;
            *(void *)(v70 + 35) = 0;
            *(void *)(v70 + 40) = 0;
            *(_DWORD *)(v70 + 48) = v71;
            *(_WORD *)(v70 + 52) = v72;
            *(_WORD *)(v70 + 54) = v73;
            *(void *)(v70 + 56) = (unsigned __int16)v67;
            *(int32x2_t *)(v70 + 64) = vmovn_s64(v108);
            *(_WORD *)(v70 + 72) = 0;
            *(_WORD *)(v70 + 74) = v59;
            *(unsigned char *)(v70 + 76) = v62;
            *(unsigned char *)(v70 + 77) = v65;
            *(_WORD *)(v70 + 78) = 0;
            size_t v74 = *(void *)v56;
            v56 += 12;
            v101[0] = _NSConcreteStackBlock;
            v101[1] = 3221225472;
            v101[2] = __NewResourceData_block_invoke_2;
            v101[3] = &unk_746170;
            id v102 = v98;
            id v75 = dispatch_data_create(&v92[v54], v74, 0, v101);
            dispatch_data_t concat = dispatch_data_create_concat(v14, v75);

            size_t v77 = dispatch_data_get_size(v75);
            v54 += v77;
            size += v77;

            ++v55;
            id v14 = concat;
          }
          while (v93 != v55);
        }
        else
        {
LABEL_38:
          dispatch_data_t concat = v14;
        }

        id v14 = concat;
        unint64_t v19 = v83;
        __int16 v17 = v84;
        unint64_t v20 = v88;
        id v21 = v89;
      }
      else if (v23 == -10240)
      {
        *(void *)&long long v105 = 0;
        long long v103 = 0u;
        long long v104 = 0u;
        uint64_t v90 = v21;
        DYTraceDecode_MTLCommandBuffer_restoreMTLBufferContents((uint64_t)&v103, (uint64_t)&v17[v20]);
        uint64_t v35 = v104;
        id v36 = +[NSString stringWithUTF8String:(void)v104];
        uint64_t v37 = [v87 objectForKeyedSubscript:v36];

        id v38 = +[NSString stringWithUTF8String:v35];
        id v39 = [v86 objectForKeyedSubscript:v38];
        id v40 = [v39 unsignedLongLongValue];

        uint64_t v41 = (*a7)++;
        unint64_t v42 = v20;
        uint64_t v43 = a6 + 80 * v41;
        uint64_t v44 = *((void *)&v103 + 1);
        unsigned int v45 = [v37 length];
        int v46 = DWORD2(v104);
        *(void *)uint64_t v43 = v40;
        *(void *)(v43 + 8) = v44;
        *(void *)(v43 + 16) = a8;
        *(_DWORD *)(v43 + 24) = size;
        *(_DWORD *)(v43 + 28) = v45;
        *(_WORD *)(v43 + 32) = 0;
        *(unsigned char *)(v43 + 34) = 2;
        *(_DWORD *)(v43 + 35) = 0;
        *(unsigned char *)(v43 + 39) = 0;
        *(_DWORD *)(v43 + 40) = v46;
        *(_OWORD *)(v43 + 44) = 0u;
        *(_OWORD *)(v43 + 60) = 0u;
        *(_DWORD *)(v43 + 76) = 0;
        unint64_t v20 = v42;
        id v47 = v37;
        id v48 = [v47 bytes];
        id v49 = [v47 length];
        destructor[0] = _NSConcreteStackBlock;
        destructor[1] = 3221225472;
        destructor[2] = __NewResourceData_block_invoke;
        destructor[3] = &unk_746170;
        id v111 = v47;
        id v50 = v47;
        uint64_t v51 = dispatch_data_create(v48, (size_t)v49, 0, destructor);
        dispatch_data_t v52 = dispatch_data_create_concat(v14, v51);

        size += dispatch_data_get_size(v51);
        id v21 = v90;
        id v14 = v52;
      }
      uint64_t v78 = *(unsigned int *)v22;
      if ((v22[33] & 0x10) != 0)
      {
        uint64_t v79 = *(unsigned int *)v22;
        do
        {
          v22 += v78;
          uint64_t v78 = *(unsigned int *)v22;
          v79 += v78;
        }
        while ((v22[33] & 0x20) == 0);
      }
      else
      {
        uint64_t v79 = *(unsigned int *)v22;
      }
      v20 += v79;
    }
    while (v20 < v19);
  }

  return v14;
}

id __NewResourceData_block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) length];
}

id __NewResourceData_block_invoke_2(uint64_t a1)
{
  return [*(id *)(a1 + 32) length];
}

void sub_1FC7E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id *location, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,id a45)
{
}

void sub_1FCB24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t CleanupSandboxExtensionURL_811(void *a1)
{
  return 0;
}

BOOL UpdateDebugFileCache(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  id v26 = a4;
  id v10 = [objc_alloc((Class)NSURL) initFileURLWithPath:v26 isDirectory:1];
  char v28 = v8;
  uint64_t v29 = v9;
  unsigned int v27 = v10;
  if (v7)
  {
    uint64_t v35 = 0;
    id v36 = &v35;
    uint64_t v37 = 0x2020000000;
    char v38 = 1;
    v30[0] = _NSConcreteStackBlock;
    v30[1] = 3221225472;
    v30[2] = __UpdateDebugFileCache_block_invoke;
    v30[3] = &unk_7449E0;
    id v31 = v10;
    id v34 = &v35;
    id v32 = v9;
    id v33 = v8;
    [v7 enumerateKeysAndObjectsUsingBlock:v30, v7];
    BOOL v11 = *((unsigned char *)v36 + 24) != 0;

    _Block_object_dispose(&v35, 8);
  }
  else
  {
    id v12 = +[NSFileManager defaultManager];
    v45[0] = NSURLNameKey;
    v45[1] = NSURLIsDirectoryKey;
    unsigned int v13 = +[NSArray arrayWithObjects:v45 count:2];
    id v14 = [v12 enumeratorAtURL:v27 includingPropertiesForKeys:v13 options:4 errorHandler:0];

    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    id v15 = v14;
    id v16 = [v15 countByEnumeratingWithState:&v40 objects:v44 count:16];
    if (v16)
    {
      uint64_t v17 = *(void *)v41;
      do
      {
        for (unint64_t i = 0; i != v16; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v41 != v17) {
            objc_enumerationMutation(v15);
          }
          unint64_t v19 = *(void **)(*((void *)&v40 + 1) + 8 * i);
          id v39 = 0;
          [v19 getResourceValue:&v39 forKey:NSURLIsDirectoryKey error:0];
          id v20 = v39;
          if (([v20 BOOLValue] & 1) == 0)
          {
            id v21 = [v19 lastPathComponent];
            int v22 = [v21 stringByDeletingPathExtension];
            int v23 = [v29 objectForKeyedSubscript:v22];

            if (v23) {
              [v28 setObject:v19 forKeyedSubscript:v23];
            }
          }
        }
        id v16 = [v15 countByEnumeratingWithState:&v40 objects:v44 count:16];
      }
      while (v16);
    }

    BOOL v11 = 1;
  }

  return v11;
}

void sub_1FD4DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __StoreDebugFileCache_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = a2;
  id v7 = objc_alloc((Class)NSURL);
  id v8 = +[NSString stringWithFormat:@"%@.metallib", v6];

  id v9 = [v7 initFileURLWithPath:v8 relativeToURL:*(void *)(a1 + 32)];
  id v11 = 0;
  [v5 writeToURL:v9 options:0 error:&v11];

  id v10 = v11;
  if (v10) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
  }
}

void __UpdateDebugFileCache_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = objc_alloc((Class)NSURL);
  id v8 = +[NSString stringWithFormat:@"%@.metallib", v5];
  id v9 = [v7 initFileURLWithPath:v8 relativeToURL:*(void *)(a1 + 32)];

  id v12 = 0;
  [v6 writeToURL:v9 options:0 error:&v12];

  id v10 = v12;
  if (v10)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 0;
  }
  else
  {
    id v11 = [*(id *)(a1 + 40) objectForKeyedSubscript:v5];
    if (v11) {
      [*(id *)(a1 + 48) setObject:v9 forKeyedSubscript:v11];
    }
  }
}

void sub_200880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  GTAGXPerfStateControl::~GTAGXPerfStateControl((id *)va);

  _Unwind_Resume(a1);
}

void sub_201094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t GTMTLCreateIndirectCommandEncoder(uint64_t result, uint64_t a2)
{
  *(void *)&long long v2 = -1;
  *((void *)&v2 + 1) = -1;
  *(_OWORD *)(result + 80) = v2;
  *(_OWORD *)(result + 96) = v2;
  *(_OWORD *)(result + 48) = v2;
  *(_OWORD *)(result + 64) = v2;
  *(_OWORD *)(result + 16) = v2;
  *(_OWORD *)(result + 32) = v2;
  *(void *)__n128 result = a2;
  *(void *)(result + 8) = 0;
  if (*(unsigned char *)(a2 + 11))
  {
    uint64_t v3 = 8;
  }
  else
  {
    *(void *)(result + 16) = 8;
    uint64_t v3 = 16;
  }
  if (!*(unsigned char *)(a2 + 10))
  {
    uint64_t v4 = *(unsigned __int8 *)(a2 + 18);
    *(void *)(result + 24) = v3;
    *(void *)(result + 32) = v3 + 8 * v4;
    uint64_t v5 = v4 + *(unsigned __int8 *)(a2 + 12);
    uint64_t v6 = v3 + 8 * v5;
    uint64_t v7 = v5 + *(unsigned __int8 *)(a2 + 16);
    *(void *)(result + 40) = v6;
    *(void *)(result + 48) = v3 + 8 * v7;
    uint64_t v8 = v7 + *(unsigned __int8 *)(a2 + 15);
    *(void *)(result + 56) = v3 + 8 * v8;
    v3 += 8 * (v8 + *(unsigned __int8 *)(a2 + 13));
  }
  uint64_t v9 = *(unsigned __int8 *)(a2 + 17);
  *(void *)(result + 64) = v3;
  *(void *)(result + 72) = v3 + 8 * v9;
  uint64_t v10 = v9 + *(unsigned __int8 *)(a2 + 14);
  uint64_t v11 = v3 + 8 * v10;
  uint64_t v12 = *(unsigned __int16 *)(a2 + 8);
  *(void *)(result + 80) = v11;
  if (*(unsigned char *)(a2 + 19))
  {
    if ((v12 & 0xF) != 0)
    {
      uint64_t v13 = *(unsigned __int8 *)(a2 + 18);
    }
    else
    {
      if ((v12 & 0x60) == 0) {
        goto LABEL_12;
      }
      uint64_t v13 = *(unsigned __int8 *)(a2 + 13);
    }
    uint64_t v11 = v3 + 8 * (v10 + v13);
  }
LABEL_12:
  if (*(unsigned char *)(a2 + 21))
  {
    *(void *)(result + 88) = v11;
    v11 += 8;
  }
  unint64_t v14 = (v12 << 63 >> 63) & 0x28;
  if ((v12 & 2) != 0) {
    unint64_t v14 = 56;
  }
  uint64_t v15 = 72;
  if ((v12 & 4) != 0) {
    unint64_t v14 = 72;
  }
  if ((v12 & 8) != 0) {
    unint64_t v14 = 80;
  }
  if ((v12 & 0x60) != 0) {
    unint64_t v14 = 120;
  }
  if (v14 <= 0x48) {
    uint64_t v16 = 72;
  }
  else {
    uint64_t v16 = v14;
  }
  if ((v12 & 0x80) != 0) {
    unint64_t v14 = v16;
  }
  if (v14 > 0x48) {
    uint64_t v15 = v14;
  }
  if ((v12 & 0x100) != 0) {
    unint64_t v14 = v15;
  }
  *(void *)(result + 96) = v11;
  *(void *)(result + 104) = v11 + v14;
  return result;
}

double GetExecuteCommandsInBufferArgs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  switch(*(_DWORD *)(a2 + 8))
  {
    case 0xFFFFC1A4:
    case 0xFFFFC1A6:
      uint64_t v10 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a3);
      *(_OWORD *)a1 = *(_OWORD *)(v10 + 8);
      uint64_t v9 = *((void *)v10 + 4);
      *(void *)(a1 + 16) = *((void *)v10 + 3);
      unsigned int v8 = v10[40];
      goto LABEL_4;
    case 0xFFFFC1A5:
    case 0xFFFFC1A7:
      uint64_t v6 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a3);
      uint64_t v7 = GTTraceFunc_argumentBlobWithMap((void *)a2, v6[41], a3);
      *(void *)a1 = *((void *)v6 + 1);
      *(_OWORD *)(a1 + 8) = *(_OWORD *)(v7 + 16);
      unsigned int v8 = v6[40];
      uint64_t v9 = *((void *)v6 + 4);
LABEL_4:
      uint64_t v11 = GTTraceMemoryMap_argumentBlobAtIndex(v8, a3, v9);
      if (v11)
      {
        uint64_t v13 = v11 + 16;
        uint64_t v14 = *(unsigned int *)(v11 + 12);
      }
      else
      {
        uint64_t v13 = 0;
        uint64_t v14 = 0;
      }
      *(void *)(a1 + 24) = v13;
      *(void *)(a1 + 32) = v14;
      break;
    default:
      *(void *)(a1 + 32) = 0;
      double result = 0.0;
      *(_OWORD *)a1 = 0u;
      *(_OWORD *)(a1 + 16) = 0u;
      break;
  }
  return result;
}

_UNKNOWN **GTMTLReplayClient_embeddedQueryShaderInfo(uint64_t a1, id *a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = v5;
  if (!v5)
  {
    uint64_t v9 = 0;
    goto LABEL_26;
  }
  uint64_t v7 = [v5 objectForKeyedSubscript:@"gpuTarget"];
  id v31 = v7;
  if (v7) {
    unsigned int v8 = [v7 intValue];
  }
  else {
    unsigned int v8 = 0x7FFFFFFF;
  }
  id v10 = [v6 objectForKeyedSubscript:@"MetalPluginName"];
  uint64_t v11 = v10;
  if (v8 == 0x7FFFFFFF)
  {
    if (!v10)
    {
      unsigned int v8 = 0x7FFFFFFF;
LABEL_12:
      unsigned int v43 = v8;
      id v27 = v6;
      uint64_t v12 = [v27 objectForKeyedSubscript:@"MetalPluginName"];
      if (!v12)
      {
        io_registry_entry_t IOAccelerator = GetIOAccelerator();
        uint64_t v12 = GetMetalPluginName(IOAccelerator, &v43);
      }
      uint64_t v29 = v12;
      id v14 = objc_alloc((Class)NSMutableDictionary);
      CFStringRef v46 = @"MetalPluginName";
      uint64_t v47 = v29;
      uint64_t v15 = +[NSDictionary dictionaryWithObjects:&v47 forKeys:&v46 count:1];
      [v14 initWithDictionary:v15];

      id v32 = objc_alloc_init((Class)NSOperation);
      v42[0] = 0;
      v42[1] = v42;
      v42[2] = 0x3032000000;
      v42[3] = __Block_byref_object_copy__74;
      v42[4] = __Block_byref_object_dispose__75;
      v42[5] = 0;
      v41[0] = _NSConcreteStackBlock;
      v41[1] = 3221225472;
      v41[2] = ___ZL29EmbeddedQueryShaderInfoLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryi_block_invoke;
      v41[3] = &unk_747578;
      v41[4] = v42;
      v41[5] = a1;
      uint64_t v16 = +[NSBlockOperation blockOperationWithBlock:v41];
      [v16 setQueuePriority:-8];
      [*a2 addOperation:v16];
      [v32 addDependency:v16];

      v40[0] = 0;
      v40[1] = v40;
      v40[2] = 0x3032000000;
      _DWORD v40[3] = __Block_byref_object_copy__74;
      v40[4] = __Block_byref_object_dispose__75;
      v40[5] = 0;
      v36[0] = _NSConcreteStackBlock;
      v36[1] = 3221225472;
      v36[2] = ___ZL29EmbeddedQueryShaderInfoLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryi_block_invoke_2;
      v36[3] = &unk_746960;
      char v38 = v40;
      uint64_t v39 = a1;
      char v28 = (NSDictionary *)v27;
      uint64_t v37 = v28;
      uint64_t v17 = +[NSBlockOperation blockOperationWithBlock:v36];
      [v17 setQueuePriority:-8];
      [*a2 addOperation:v17];
      [v32 addDependency:v17];
      [v17 waitUntilFinished];

      *(void *)uint64_t v35 = 0;
      unsigned int v34 = 0;
      double v33 = 1.0;
      GetConsistentPStates(v28, &v35[1], v35, &v33, &v34);
      id v18 = [*(id *)(a1 + 8) defaultDevice];
      id v30 = DYMTLReplayFrameProfiler_loadAnalysis(v18);

      if (v30)
      {
        unint64_t v19 = [v30 objectForKeyedSubscript:@"DerivedCounterDictionary"];
        id v20 = v19;
        if (v19)
        {
          id v21 = [v19 objectForKeyedSubscript:@"DerivedCounters"];
          int v22 = v21;
          if (v21)
          {
            uint64_t v23 = [v21 objectForKeyedSubscript:@"ParameterBufferBytesUsed"];
            id v24 = (void *)v23;
            if (v23)
            {
              CFStringRef v44 = @"ParameterBufferBytesUsed";
              uint64_t v45 = v23;
              uint64_t v25 = +[NSDictionary dictionaryWithObjects:&v45 forKeys:&v44 count:1];
              GTMTLReplayHost_rawCounters(v25);
              objc_claimAutoreleasedReturnValue();
            }
          }
        }
      }
      operator new();
    }
    unsigned int v8 = MetalPluginTarget(v10);
  }

  if ((v8 & 0x80000000) != 0) {
    goto LABEL_12;
  }
  uint64_t v9 = &off_7590F8;

LABEL_26:

  return v9;
}

void sub_2024D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,void *a31,void *a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a46, 8);
  _Block_object_dispose(&a58, 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__74(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__75(uint64_t a1)
{
}

void ___ZL29EmbeddedQueryShaderInfoLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryi_block_invoke(uint64_t a1)
{
  GTMTLReplayController_prePlayForProfiling(*(void *)(a1 + 40));
  uint64_t v26 = a1;
  long long v2 = *(unsigned int **)(a1 + 40);
  id v31 = objc_alloc_init((Class)NSMutableArray);
  id v30 = objc_alloc_init((Class)NSMutableDictionary);
  id v29 = objc_alloc_init((Class)NSMutableDictionary);
  id v3 = objc_alloc_init((Class)NSMutableDictionary);
  id v4 = *((id *)v2 + 1);
  id v5 = v4;
  uint64_t v6 = *(void **)v2;
  uint64_t v7 = v2 + 5620;
  if (*(void *)(*(void *)v2 + 104) + *(void *)(*(void *)v2 + 96) > (unint64_t)v2[5620])
  {
    id v28 = v4;
    while (1)
    {
      uint64_t v9 = *(void *)(v6[15] + 24) + ((unint64_t)*v7 << 6);
      id v10 = (int *)(v9 + 8);
      if (GetFuncEnumConstructorType(*(_DWORD *)(v9 + 8)) == 25) {
        GTMTLReplayController_restoreCommandBuffer((uint64_t)v2, v9);
      }
      GTMTLReplayController_updateCommandEncoder((uint64_t)v2, v9);
      GTMTLReplayController_defaultDispatchFunction((uint64_t)v2, v9);
      int v11 = *v10;
      if ((IsFuncEnumDrawCall(*v10) & 1) == 0)
      {
        BOOL v12 = (v11 + 16079) < 2 || v11 == -16220;
        if (!v12 && v11 != -16327) {
          goto LABEL_21;
        }
      }
      unsigned int v14 = v2[2828];
      if (v14 == 28) {
        break;
      }
      if (v14 == 70)
      {
        uint64_t v15 = [v5 renderPipelineStateForKey:*((void *)v2 + 2489)];
        if (IsFuncEnumDrawCall(*v10))
        {
          id v32 = v8;
          v37[0] = @"vertex shader key";
          id v16 = [v15 newVertexShaderDebugInfo];
          uint64_t v17 = AddShaderBinary(v30, v16);
          v37[1] = @"fragment shader key";
          v38[0] = v17;
          id v18 = [v15 newFragmentShaderDebugInfo];
          unint64_t v19 = AddShaderBinary(v29, v18);
          v38[1] = v19;
          +[NSDictionary dictionaryWithObjects:v38 forKeys:v37 count:2];
          id v21 = v20 = v3;
          [v31 addObject:v21];

          id v3 = v20;
          id v5 = v28;

          goto LABEL_19;
        }
        goto LABEL_20;
      }
LABEL_21:
      unint64_t v22 = (*v7 + 1);
      *uint64_t v7 = v22;
      if (v6[13] + v6[12] <= v22) {
        goto LABEL_22;
      }
    }
    id v32 = v8;
    uint64_t v15 = [v5 computeCommandEncoderForKey:*((void *)v2 + 1415)];
    CFStringRef v35 = @"compute kernel key";
    id v16 = [v15 newKernelDebugInfo];
    uint64_t v17 = AddShaderBinary(v3, v16);
    id v36 = v17;
    id v18 = +[NSDictionary dictionaryWithObjects:&v36 forKeys:&v35 count:1];
    [v31 addObject:v18];
LABEL_19:

    unsigned int v8 = v32;
LABEL_20:

    goto LABEL_21;
  }
LABEL_22:
  v33[0] = @"draw call info";
  v33[1] = @"vertex fetch shader info";
  v34[0] = v31;
  v34[1] = &__NSDictionary0__struct;
  v33[2] = @"vertex shader info";
  v33[3] = @"fragment shader info";
  v34[2] = v30;
  v34[3] = v29;
  v33[4] = @"compute kernel info";
  void v34[4] = v3;
  uint64_t v23 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v34, v33, 5, v26);

  uint64_t v24 = *(void *)(*(void *)(v27 + 32) + 8);
  uint64_t v25 = *(void **)(v24 + 40);
  *(void *)(v24 + 40) = v23;
}

void ___ZL29EmbeddedQueryShaderInfoLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryi_block_invoke_2(uint64_t a1)
{
  __int16 v73 = *(id **)(a1 + 48);
  id v2 = *(id *)(a1 + 32);
  vm_address_t address = 0;
  id v62 = v2;
  id v3 = [v2 objectForKeyedSubscript:@"uscBufferSize"];
  uint64_t v57 = a1;
  vm_size_t v4 = (void)[v3 unsignedIntegerValue] << 20;

  if (v4 - 1 >= 0x1FFFFFF) {
    vm_size_t v4 = 0x2000000;
  }
  vm_allocate(mach_task_self_, &address, v4, 1);
  memset((void *)address, 255, v4);
  id v58 = v73[1];
  [v58 defaultDevice];
  id v60 = v59 = v4;
  [v60 mapShaderSampleBufferWithBuffer:address capacity:v4 / 0xC size:v4];
  mach_timebase_info(&info);
  uint64_t v82 = 0;
  unint64_t v83 = (unsigned __int8 *)&v82;
  uint64_t v84 = 0x2020000000;
  uint64_t v64 = mach_absolute_time();
  id v5 = [objc_alloc((Class)NSMutableData) initWithLength:2097144];
  memset([v5 mutableBytes], 255, (size_t)[v5 length]);
  id v67 = v5;
  uint64_t v6 = (int *)[v67 mutableBytes];
  int v65 = [v62 objectForKeyedSubscript:@"perEncoderDrawCallCount"];
  memset(v80, 0, sizeof(v80));
  int v81 = 1065353216;
  uint64_t v7 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  queue = dispatch_queue_create("com.apple.MTLReplayer.memoryPresure", v7);

  unsigned int v8 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_memorypressure, 0, 2uLL, queue);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = ___ZL18PerformUSCSamplingP21GTMTLReplayControllerP12NSDictionary_block_invoke;
  handler[3] = &unk_744E20;
  handler[4] = &v82;
  dispatch_source_set_event_handler(v8, handler);
  source = v8;
  dispatch_activate(v8);
  uint64_t v66 = objc_alloc_init(ProgramAddressTableCollector);
  uint64_t v74 = 0;
  uint64_t v9 = 0;
  int v10 = 0;
  uint64_t v78 = (unsigned int *)(v73 + 2810);
  do
  {
    int v68 = v10;
    GTMTLReplayController_prePlayForProfiling((uint64_t)v73);
    id v72 = v65;
    id v69 = v67;
    uint64_t v70 = v66;
    id v77 = v73[1];
    int v11 = *v73;
    if (*((void *)*v73 + 13) + *((void *)*v73 + 12) > (unint64_t)*v78)
    {
      char v71 = 0;
      uint64_t v75 = v11[2];
      while (1)
      {
        uint64_t v13 = *(void *)(v11[15] + 24);
        uint64_t v14 = *v78;
        uint64_t v15 = v13 + (v14 << 6);
        int v18 = *(_DWORD *)(v15 + 8);
        uint64_t v17 = (int *)(v15 + 8);
        int v16 = v18;
        if (GetFuncEnumConstructorType(v18) == 25)
        {
          GTMTLReplayController_restoreCommandBuffer((uint64_t)v73, v13 + (v14 << 6));
          int v16 = *v17;
        }
        if (v16 <= -16287) {
          break;
        }
        if (v16 <= -16247)
        {
          if (v16 != -16286)
          {
            if (v16 != -16285) {
              goto LABEL_29;
            }
LABEL_28:
            GTMTLReplayController_dispatchForUSCSampling((uint64_t)v73, v13 + (v14 << 6), v77, v75, v70, (v9 - 1));
            char v71 = 0;
            goto LABEL_30;
          }
          double v33 = GTTraceFunc_argumentBytesWithMap((void *)(v13 + (v14 << 6)), *(unsigned __int8 *)(v13 + (v14 << 6) + 13), v75);
          unsigned int v34 = [v77 parallelRenderCommandEncoderForKey:*(void *)v33];
          [v77 setRenderCommandEncoder:v34 forKey:*((void *)v33 + 1)];
          goto LABEL_25;
        }
        if (v16 != -16246)
        {
          if (v16 != -16014)
          {
LABEL_29:
            GTMTLReplayController_dispatchForUSCSampling((uint64_t)v73, v13 + (v14 << 6), v77, v75, v70, (v9 - 1));
            goto LABEL_30;
          }
          id v29 = +[NSNumber numberWithUnsignedInt:*v78];
          uint64_t v76 = [v72 objectForKeyedSubscript:v29];

          id v30 = [v76 unsignedIntegerValue];
          *uint64_t v6 = *(unsigned __int8 *)v6 | (v9 << 8);
          id v31 = v6 + 6;
          id v32 = GTTraceFunc_argumentBytesWithMap((void *)(v13 + (v14 << 6)), *(unsigned __int8 *)(v13 + (v14 << 6) + 13), v75);
          uint64_t v24 = [v77 commandBufferForKey:*(void *)v32];
          uint64_t v26 = [v24 sampledComputeCommandEncoderWithDispatchType:*((void *)v32 + 2) programInfoBuffer:v31 capacity:v30];
          LODWORD(v88[0]) = [v26 globalTraceObjectID];
          *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>((uint64_t)v80, v88[0], v88)+ 5) = v9++;
          [v77 setComputeCommandEncoder:v26 forKey:*((void *)v32 + 1)];
LABEL_23:
          uint64_t v6 = &v31[6 * (void)v30];
          uint64_t v28 = 24 * (void)v30 + 24;
          goto LABEL_24;
        }
        if ((v71 & 1) == 0) {
          goto LABEL_28;
        }
        [v77 removeRenderCommandEncoderForKey:*(void *)GTTraceFunc_argumentBytesWithMap((void *)(v13 + (v14 << 6)), *(unsigned __int8 *)(v13 + (v14 << 6) + 13), v75)];
        char v71 = 1;
LABEL_30:
        unint64_t v44 = *v78 + 1;
        *uint64_t v78 = v44;
        if (v11[13] + v11[12] <= v44) {
          goto LABEL_31;
        }
      }
      switch(v16)
      {
        case -16353:
          CFStringRef v35 = +[NSNumber numberWithUnsignedInt:*v78];
          uint64_t v76 = [v72 objectForKeyedSubscript:v35];

          id v36 = [v76 unsignedIntegerValue];
          *uint64_t v6 = *(unsigned __int8 *)v6 | (v9 << 8);
          uint64_t v37 = v6 + 6;
          char v38 = GTTraceFunc_argumentBytesWithMap((void *)(v13 + (v14 << 6)), *(unsigned __int8 *)(v13 + (v14 << 6) + 13), v75);
          uint64_t RenderPassDescriptor = GetRenderPassDescriptor();
          uint64_t v24 = [v77 commandBufferForKey:*(void *)v38];
          long long v40 = [v77 renderPassDescriptorMap];
          uint64_t v26 = MakeMTLRenderPassDescriptor(RenderPassDescriptor, v40);

          long long v41 = [v24 sampledRenderCommandEncoderWithDescriptor:v26 programInfoBuffer:v37 capacity:2 * (void)v36 + 2];
          LODWORD(v88[0]) = [v41 globalTraceObjectID];
          *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>((uint64_t)v80, v88[0], v88)+ 5) = v9++;
          [v77 setRenderCommandEncoder:v41 forKey:*((void *)v38 + 1)];

          uint64_t v6 = &v37[12 * (void)v36 + 12];
          uint64_t v28 = 48 * (void)v36 + 72;
          break;
        case -16352:
          long long v42 = +[NSNumber numberWithUnsignedInt:*v78];
          uint64_t v76 = [v72 objectForKeyedSubscript:v42];

          id v30 = [v76 unsignedIntegerValue];
          *uint64_t v6 = *(unsigned __int8 *)v6 | (v9 << 8);
          id v31 = v6 + 6;
          unsigned int v43 = GTTraceFunc_argumentBytesWithMap((void *)(v13 + (v14 << 6)), *(unsigned __int8 *)(v13 + (v14 << 6) + 13), v75);
          uint64_t v24 = [v77 commandBufferForKey:*(void *)v43];
          uint64_t v26 = [v24 sampledComputeCommandEncoderWithProgramInfoBuffer:v31 capacity:v30];
          LODWORD(v88[0]) = [v26 globalTraceObjectID];
          *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>((uint64_t)v80, v88[0], v88)+ 5) = v9++;
          [v77 setComputeCommandEncoder:v26 forKey:*((void *)v43 + 1)];
          goto LABEL_23;
        case -16351:
          unint64_t v19 = +[NSNumber numberWithUnsignedInt:*v78];
          uint64_t v76 = [v72 objectForKeyedSubscript:v19];

          id v20 = [v76 unsignedIntegerValue];
          *uint64_t v6 = *(unsigned __int8 *)v6 | (v9 << 8);
          id v21 = v6 + 6;
          unint64_t v22 = GTTraceFunc_argumentBytesWithMap((void *)(v13 + (v14 << 6)), *(unsigned __int8 *)(v13 + (v14 << 6) + 13), v75);
          uint64_t v23 = GetRenderPassDescriptor();
          uint64_t v24 = [v77 commandBufferForKey:*(void *)v22];
          uint64_t v25 = [v77 renderPassDescriptorMap];
          uint64_t v26 = MakeMTLRenderPassDescriptor(v23, v25);

          uint64_t v27 = [v24 sampledRenderCommandEncoderWithDescriptor:v26 programInfoBuffer:v21 capacity:2 * (void)v20 + 2];
          LODWORD(v88[0]) = [v27 globalTraceObjectID];
          *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>((uint64_t)v80, v88[0], v88)+ 5) = v9++;
          [v77 setParallelRenderCommandEncoder:v27 forKey:*((void *)v22 + 1)];

          uint64_t v6 = &v21[12 * (void)v20 + 12];
          uint64_t v28 = 48 * (void)v20 + 72;
          char v71 = 1;
          break;
        default:
          goto LABEL_29;
      }
LABEL_24:

      v74 += v28;
      unsigned int v34 = v76;
LABEL_25:

      goto LABEL_30;
    }
LABEL_31:

    uint64_t v45 = (mach_absolute_time() - v64) * info.numer / info.denom;
    unsigned __int8 v46 = atomic_load(v83 + 24);
    unsigned __int8 v48 = (v46 & 1) == 0 && v45 > 0x3B9AC9FF;
    id v49 = v83 + 24;
    atomic_store(v48, v83 + 24);
    if (v68 == 1199) {
      break;
    }
    int v10 = v68 + 1;
    unsigned __int8 v50 = atomic_load(v49);
  }
  while ((v50 & 1) == 0);
  dispatch_source_cancel(source);
  [v60 unmapShaderSampleBuffer];
  [v69 setLength:v74];
  v87[0] = @"usc sampling sample data";
  id v51 = objc_alloc((Class)NSData);
  id v52 = [v51 initWithBytesNoCopy:address length:v59 deallocator:&__block_literal_global_1058];
  v88[0] = v52;
  v87[1] = @"usc sampling address mappings";
  uint64_t v53 = [(ProgramAddressTableCollector *)v70 mappings];
  v87[2] = @"usc sampling address data";
  v88[1] = v53;
  v88[2] = v69;
  uint64_t v54 = +[NSDictionary dictionaryWithObjects:v88 forKeys:v87 count:3];

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v80);
  _Block_object_dispose(&v82, 8);

  uint64_t v55 = *(void *)(*(void *)(v57 + 40) + 8);
  id v56 = *(void **)(v55 + 40);
  *(void *)(v55 + 40) = v54;
}

void sub_2036EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, void *a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a37);
  _Block_object_dispose((const void *)(v39 - 192), 8);

  _Unwind_Resume(a1);
}

void GetConsistentPStates(NSDictionary *a1, unsigned int *a2, unsigned int *a3, double *a4, unsigned int *a5)
{
  int v16 = a1;
  uint64_t v9 = [(NSDictionary *)v16 objectForKeyedSubscript:@"GPUState"];
  int v10 = v9;
  if (!v9 || (unsigned int v11 = [v9 unsignedIntValue], (*a5 = v11) == 0))
  {
    BOOL v12 = [(NSDictionary *)v16 objectForKeyedSubscript:@"XPState"];
    uint64_t v13 = v12;
    if (v12)
    {
      [v12 doubleValue];
      double v15 = floor(v14);
      *a2 = (v15 * 100.0);
      *a3 = (ceil(v14) * 100.0);
      *a4 = v14 - v15;
    }
    else
    {
      *a3 = 3;
      *a2 = 3;
    }
  }
}

void sub_203A28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id ProfilingTimingDataLegacy(uint64_t a1, id *a2, void *a3, void *a4, void *a5, int a6, int a7, int a8, uint64_t a9)
{
  id v16 = a3;
  id v17 = a4;
  id v18 = a5;
  v39[0] = 0;
  v39[1] = v39;
  v39[2] = 0x3032000000;
  v39[3] = __Block_byref_object_copy__74;
  v39[4] = __Block_byref_object_dispose__75;
  unint64_t v19 = +[NSArray arrayWithObjects:@"MTLStatCommandBufferIndex", @"MTLStatEncoderIndex", @"MTLStatCommandIndex", @"MTLStat_nSec", @"MTLStatDataMaster", @"MTLStatSampleLocation", @"MTLStatTotalGPUCycles", 0];
  id v40 = [v19 mutableCopy];

  v27[0] = _NSConcreteStackBlock;
  v27[1] = 3221225472;
  v27[2] = ___ZL25ProfilingTimingDataLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryP19NSMutableDictionaryS6_P14NSMutableArrayIP8NSNumberEjjjP21GTAGXPerfStateControl_block_invoke;
  v27[3] = &unk_744E88;
  id v32 = v39;
  uint64_t v33 = a1;
  id v20 = objc_alloc_init((Class)NSOperation);
  id v28 = v20;
  unsigned int v34 = a2;
  int v36 = a6;
  id v21 = v18;
  id v29 = v21;
  uint64_t v35 = a9;
  int v37 = a8;
  int v38 = a7;
  id v22 = v16;
  id v30 = v22;
  id v23 = v17;
  id v31 = v23;
  uint64_t v24 = +[NSBlockOperation blockOperationWithBlock:v27];
  [v24 setQueuePriority:-8];
  [*a2 addOperation:v24];
  [v20 addDependency:v24];
  [a2[1] addOperation:v20];
  id v25 = v20;

  _Block_object_dispose(v39, 8);

  return v25;
}

void sub_203CBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,void *a22,void *a23)
{
  _Block_object_dispose((const void *)(v27 - 136), 8);
  _Unwind_Resume(a1);
}

void GRCInfo::GRCInfo(GRCInfo *this, GTMTLReplayController *a2, int a3, GTAGXPerfStateControl *a4)
{
  *(void *)this = a2;
  *((void *)this + 1) = a4;
  *((_OWORD *)this + 1) = 0u;
  id v5 = (id *)((char *)this + 16);
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_DWORD *)this + 16) = a3;
  *((_WORD *)this + 34) = 0;
  GRCReleaseAllCounterSourceGroup();
  uint64_t v6 = GRCCopyAllCounterSourceGroup();
  id v7 = *v5;
  id *v5 = (id)v6;

  if (*v5 && [*v5 count])
  {
    id v23 = [*v5 firstObject];
    uint64_t v24 = [v23 sourceList];
    if (!v24 || ![v24 count]) {
      goto LABEL_21;
    }
    obuint64_t j = +[NSMutableArray arrayWithCapacity:3];
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    id v8 = v24;
    id v9 = [v8 countByEnumeratingWithState:&v27 objects:v31 count:16];
    if (v9)
    {
      uint64_t v10 = *(void *)v28;
LABEL_7:
      uint64_t v11 = 0;
      while (1)
      {
        if (*(void *)v28 != v10) {
          objc_enumerationMutation(v8);
        }
        BOOL v12 = *(void **)(*((void *)&v27 + 1) + 8 * v11);
        if (![v12 ringBufferNum]) {
          break;
        }
        uint64_t v13 = [v12 name];
        unsigned int v14 = [v13 hasPrefix:@"Firmware"];

        if (v14) {
          [obj addObject:v12];
        }
        if (v9 == (id)++v11)
        {
          id v9 = [v8 countByEnumeratingWithState:&v27 objects:v31 count:16];
          if (v9) {
            goto LABEL_7;
          }
          goto LABEL_15;
        }
      }
    }
    else
    {
LABEL_15:

      if (![obj count])
      {
LABEL_20:

LABEL_21:
        goto LABEL_22;
      }
      objc_storeStrong((id *)this + 3, obj);
      *((void *)this + 4) = [v23 sampleMarker];
      uint64_t v15 = +[NSMutableArray arrayWithCapacity:7];
      id v16 = (void *)*((void *)this + 6);
      *((void *)this + 6) = v15;

      for (uint64_t i = 0; i != 7; ++i)
      {
        id v18 = (void *)*((void *)this + 6);
        unint64_t v19 = [&off_758AC8 objectAtIndexedSubscript:i];
        id v20 = +[GPURawCounterSelect selectWithName:v19 options:0];
        [v18 addObject:v20];
      }
      id v8 = +[GPURawCounterSourceTriggerSelect selectWithName:@"KickBoundary" options:0];
      uint64_t v21 = +[NSMutableArray arrayWithObject:v8];
      id v22 = (void *)*((void *)this + 5);
      *((void *)this + 5) = v21;
    }
    goto LABEL_20;
  }
LABEL_22:
}

void sub_204014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11)
{
  GPURawCounterSetupParams::~GPURawCounterSetupParams(v12);
  _Unwind_Resume(a1);
}

void DisableComputeEncoderCoalescing(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    id v2 = *(void **)(a1 + 8);
    if (v2)
    {
      vm_size_t v4 = [v2 defaultDevice];
      DEVICEOBJECT(v4);
      id v5 = (id)objc_claimAutoreleasedReturnValue();

      if (v5 && (objc_opt_respondsToSelector() & 1) != 0) {
        [v5 setDisableComputeEncoderCoalescing:a2];
      }
    }
  }
}

void sub_204160(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__130(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__131(uint64_t a1)
{
  id v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void ___ZL14GPUTimeDataGRCP26GTMTLReplayOperationQueuesP14NSMutableArrayIP8NSNumberEjR7GRCInfo_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8);
  unint64_t v3 = *(void *)(v2 + 48);
  vm_size_t v4 = *(unint64_t **)(v2 + 56);
  unint64_t v5 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v4 - v3) >> 3));
  if (v4 == (unint64_t *)v3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v5;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *,false>(v3, v4, v6, 1);
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  id v8 = *(unint64_t **)(v7 + 48);
  id v9 = *(unint64_t **)(v7 + 56);
  if (v8 == v9)
  {
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    do
    {
      unint64_t v12 = *v8;
      unint64_t v13 = v8[1];
      v8 += 3;
      if (v11 <= v12) {
        unint64_t v11 = v12;
      }
      BOOL v14 = v13 >= v11;
      unint64_t v15 = v13 - v11;
      if (v13 > v11) {
        unint64_t v11 = v13;
      }
      if (!v14) {
        unint64_t v15 = 0;
      }
      v10 += v15;
    }
    while (v8 != v9);
  }
  id v16 = +[NSNumber numberWithUnsignedLongLong:v10];
  [*(id *)(a1 + 32) setObject:atIndexedSubscript:];
  [*(id *)(a1 + 32) setObject:v16 atIndexedSubscript:0];
}

void sub_2042B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZL14GPUTimeDataGRCP26GTMTLReplayOperationQueuesP14NSMutableArrayIP8NSNumberEjR7GRCInfo_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = a1;
  GTMTLReplayController_prePlayForProfiling(**(void **)(a1 + 40));
  GRCInfo::SetupSource(*(void *)(v1 + 40), *(unsigned int *)(v1 + 48), 0, 0);
  uint64_t v2 = [*(id *)(*(void *)(v1 + 40) + 16) firstObject];
  [v2 startSampling];

  vm_size_t v4 = *(id ***)(v1 + 40);
  uint64_t v5 = *(void *)(*(void *)(v1 + 32) + 8);
  v30[1] = *v4;
  char v31 = 0;
  v30[0] = [(id)g_commandBufferDescriptor errorOptions];
  [(id)g_commandBufferDescriptor setErrorOptions:0];
  id v26 = (*v4)[1];
  uint64_t v6 = *v4;
  uint64_t v7 = (uint64_t *)**v4;
  char v29 = 0;
  if (v7[13] + v7[12] > (unint64_t)*((unsigned int *)v6 + 5620))
  {
    id v22 = v3;
    uint64_t v23 = v1;
    uint64_t v8 = v7[15];
    uint64_t v24 = v28;
    uint64_t v25 = v5 + 48;
    do
    {
      uint64_t v10 = *(void *)(v8 + 24);
      unint64_t v11 = *v4;
      uint64_t v12 = *((unsigned int *)*v4 + 5620);
      int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v10 + (v12 << 6) + 8));
      if (FuncEnumConstructorType == 25)
      {
        GTMTLReplayController_restoreCommandBuffer((uint64_t)v11, v10 + (v12 << 6));
        unint64_t v11 = *v4;
      }
      GTMTLReplayController_updateCommandEncoder((uint64_t)v11, v10 + (v12 << 6));
      DispatchFunction(*v4, v10 + (v12 << 6), &v29);
      if (FuncEnumConstructorType == 25)
      {
        BOOL v14 = [v26 commandBufferForKey:*(unsigned __int8 *)(v10 + (v12 << 6) + 13)];
        v27[0] = _NSConcreteStackBlock;
        v27[1] = 3221225472;
        v28[0] = ___ZN7GRCInfo23ReplayForTimingCountersERNSt3__16vectorINS0_5tupleIJyyyEEENS0_9allocatorIS3_EEEE_block_invoke;
        v28[1] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
        v28[2] = v25;
        [v14 addCompletedHandler:v27];
      }
      uint64_t v6 = *v4;
      unint64_t v15 = (*((_DWORD *)*v4 + 5620) + 1);
      *((_DWORD *)*v4 + 5620) = v15;
    }
    while (v7[13] + v7[12] > v15);
    unint64_t v3 = v22;
    uint64_t v1 = v23;
  }
  *((_DWORD *)v6 + 5621) = 0;
  id v16 = [v6[1] defaultCommandQueue:v22, v23, v24];
  [v16 finish];

  GRCInfo::ScopedReplayConfiguration::~ScopedReplayConfiguration((GRCInfo::ScopedReplayConfiguration *)v30);
  id v17 = *(id **)(v1 + 40);
  id v18 = GRCInfo::DrainRawFrameData(v17);
  id v19 = GRCInfo::PostProcessFrameData((uint64_t)v17, v18);

  id v20 = [*(id *)(*(void *)(v1 + 40) + 16) firstObject];
  [v20 stopSampling];

  GRCInfo::AddConsistencyInfo(*(GRCInfo **)(v1 + 40));
  uint64_t v21 = *(GTAGXPerfStateControl **)(*(void *)(v1 + 40) + 8);

  GTAGXPerfStateControl::DisableConsistentGPUPerfState(v21);
}

void sub_204584(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__236(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0;
  *(void *)(result + 48) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0;
  uint64_t v5 = a2[8];
  unint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 64;
    void *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t __Block_byref_object_dispose__237(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(a1 + 48);
}

__n128 __Block_byref_object_copy__238(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__239(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void ___ZL15KickTimeDataGRCP26GTMTLReplayOperationQueuesP19NSMutableDictionaryjR7GRCInfoP7NSArray_block_invoke(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) firstObject];
  if (!v2) {
    goto LABEL_55;
  }
  unint64_t v3 = *(void **)(*(void *)(a1 + 56) + 8);
  unint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 72);
  uint64_t v6 = (char *)v3[6];
  uint64_t v5 = (char *)v3[7];
  unint64_t v7 = 0x8E38E38E38E38E39 * ((v5 - v6) >> 3);
  unint64_t v8 = v4 - v7;
  id v52 = v2;
  if (v4 <= v7)
  {
    if (v4 < v7) {
      v3[7] = &v6[72 * v4];
    }
    goto LABEL_22;
  }
  uint64_t v9 = v3[8];
  if (0x8E38E38E38E38E39 * ((v9 - (uint64_t)v5) >> 3) >= v8)
  {
    bzero(v5, 72 * ((72 * v8 - 72) / 0x48) + 72);
    v3[7] = &v5[72 * ((72 * v8 - 72) / 0x48) + 72];
  }
  else
  {
    if (v4 > 0x38E38E38E38E38ELL) {
      abort();
    }
    unint64_t v10 = 0x8E38E38E38E38E39 * ((v9 - (uint64_t)v6) >> 3);
    if (2 * v10 > v4) {
      unint64_t v4 = 2 * v10;
    }
    if (v10 >= 0x1C71C71C71C71C7) {
      unint64_t v11 = 0x38E38E38E38E38ELL;
    }
    else {
      unint64_t v11 = v4;
    }
    if (v11 > 0x38E38E38E38E38ELL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v12 = (char *)operator new(72 * v11);
    unint64_t v13 = &v12[8 * ((v5 - v6) >> 3)];
    BOOL v14 = &v12[72 * v11];
    size_t v15 = 72 * ((72 * v8 - 72) / 0x48) + 72;
    bzero(v13, v15);
    id v16 = &v13[v15];
    if (v5 == v6)
    {
      uint64_t v2 = v52;
    }
    else
    {
      uint64_t v2 = v52;
      do
      {
        *(_OWORD *)(v13 - 72) = *(_OWORD *)(v5 - 72);
        long long v17 = *(_OWORD *)(v5 - 56);
        long long v18 = *(_OWORD *)(v5 - 40);
        long long v19 = *(_OWORD *)(v5 - 24);
        *((void *)v13 - 1) = *((void *)v5 - 1);
        *(_OWORD *)(v13 - 24) = v19;
        *(_OWORD *)(v13 - 40) = v18;
        *(_OWORD *)(v13 - 56) = v17;
        v13 -= 72;
        v5 -= 72;
      }
      while (v5 != v6);
      uint64_t v5 = v6;
    }
    v3[6] = v13;
    v3[7] = v16;
    v3[8] = v14;
    if (!v5) {
      goto LABEL_22;
    }
    operator delete(v5);
  }
  uint64_t v2 = v52;
LABEL_22:
  id v20 = v2;
  uint64_t v21 = (char *)[v20 bytes];
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  while (1)
  {
    int NextMarker = GRCInfo::FindNextMarker((GRCInfo *)v20, v23, *(void *)(*(void *)(a1 + 72) + 32));
    int v25 = NextMarker;
    if (NextMarker == -1) {
      break;
    }
    id v26 = &v21[8 * NextMarker];
    long long v27 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>((void *)(*(void *)(*(void *)(a1 + 64) + 8) + 48), *((_DWORD *)v26 + 8));
    uint64_t v23 = (NSData *)(v25 + 8);
    if (v27)
    {
      BOOL v28 = *((void *)v26 + 3) > 5uLL || (*((void *)v26 + 3) & 1) == 0;
      if (v28
        || (unint64_t v29 = *((unsigned int *)v27 + 6),
            uint64_t v30 = *(void *)(*(void *)(a1 + 56) + 8),
            uint64_t v31 = *(void *)(v30 + 48),
            0x8E38E38E38E38E39 * ((*(void *)(v30 + 56) - v31) >> 3) <= v29))
      {
        id v32 = (uint64_t *)(v26 + 8);
      }
      else
      {
        id v32 = (uint64_t *)(v26 + 8);
        unint64_t v33 = 125 * (*((void *)v26 + 1) - v22);
        *(void *)(v31 + 72 * v29) += v33 / 3;
        if ([*(id *)(a1 + 32) count])
        {
          if (*(_WORD *)v26) {
            *(void *)(v31 + 72 * v29 + 56) += *((void *)v26 + 8);
          }
        }
        unint64_t v34 = v33 / 3;
        uint64_t v35 = *((void *)v26 + 3);
        switch(v35)
        {
          case 5:
            *(void *)(v31 + 72 * v29 + 24) += 2 * v34;
            int v37 = 4;
            break;
          case 3:
            uint64_t v38 = v31 + 72 * v29;
            *(void *)(v38 + 16) += v34;
            *(void *)(v38 + 40) += *((void *)v26 + 2);
            int v37 = 2;
            break;
          case 1:
            uint64_t v36 = v31 + 72 * v29;
            *(void *)(v36 + 8) += v34;
            *(void *)(v36 + 32) += *((void *)v26 + 2);
            int v37 = 1;
            break;
          default:
            goto LABEL_38;
        }
        *(_DWORD *)(v31 + 72 * v29 + 64) |= v37;
      }
LABEL_38:
      uint64_t v22 = *v32;
    }
  }
  uint64_t v39 = &send_ptr;
  uint64_t v57 = objc_opt_new();
  id v56 = objc_opt_new();
  uint64_t v55 = objc_opt_new();
  uint64_t v54 = objc_opt_new();
  uint64_t v40 = *(void *)(*(void *)(a1 + 56) + 8);
  uint64_t v41 = *(void *)(v40 + 48);
  for (uint64_t i = *(void *)(v40 + 56); v41 != i; v41 += 72)
  {
    if (*(_DWORD *)(v41 + 64))
    {
      long long v42 = +[NSNumber numberWithUnsignedLongLong:*(void *)v41];
      [v57 addObject:v42];

      if ([*(id *)(a1 + 32) count])
      {
        unsigned int v43 = +[NSNumber numberWithUnsignedLongLong:*(void *)(v41 + 56)];
        [v54 addObject:v43];
      }
      unint64_t v44 = [v39[204] arrayWithCapacity:3, v52];
      uint64_t v45 = v39;
      unsigned __int8 v46 = [v39[204] arrayWithCapacity:3];
      if (*(_DWORD *)(v41 + 64)) {
        int v47 = *(_DWORD *)(v41 + 64);
      }
      else {
        int v47 = 2;
      }
      do
      {
        unsigned int v48 = v47 & -v47;
        uint64_t v49 = v48 >> 1;
        unsigned __int8 v50 = +[NSNumber numberWithUnsignedLongLong:*(void *)(v41 + 8 * v49 + 8)];
        [v44 addObject:v50];

        id v51 = +[NSNumber numberWithUnsignedLongLong:*(void *)(v41 + 8 * v49 + 32)];
        [v46 addObject:v51];

        v47 ^= v48;
      }
      while (v47);
      [v56 addObject:v44];
      [v55 addObject:v46];

      uint64_t v39 = v45;
    }
  }
  [*(id *)(a1 + 40) setObject:v57 forKeyedSubscript:@"encoder time data" v52];
  [*(id *)(a1 + 40) setObject:v56 forKeyedSubscript:@"kick time data"];
  [*(id *)(a1 + 40) setObject:v55 forKeyedSubscript:@"kick cycle data"];
  if ([v54 count]) {
    [*(id *)(a1 + 40) setObject:v54 forKeyedSubscript:@"tilerParamBufBytesUsedArray"];
  }

  uint64_t v2 = v53;
LABEL_55:
}

void sub_204C74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  _Unwind_Resume(a1);
}

void ___ZL15KickTimeDataGRCP26GTMTLReplayOperationQueuesP19NSMutableDictionaryjR7GRCInfoP7NSArray_block_invoke_2(uint64_t a1)
{
  GTMTLReplayController_prePlayForProfiling(**(void **)(a1 + 56));
  GRCInfo::SetupSource(*(void *)(a1 + 56), *(unsigned int *)(a1 + 64), 1, *(void **)(a1 + 32));
  uint64_t v2 = [*(id *)(*(void *)(a1 + 56) + 16) firstObject];
  [v2 startSampling];

  GRCInfo::ReplayForKickCounters(*(GTMTLReplayController ***)(a1 + 56), (uint64_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 48));
  unint64_t v4 = GRCInfo::DrainRawFrameData(*(id **)(a1 + 56));
  uint64_t v5 = GRCInfo::PostProcessFrameData(*(void *)(a1 + 56), v4);
  if (v5) {
    [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setArray:v5];
  }

  uint64_t v6 = [*(id *)(*(void *)(a1 + 56) + 16) firstObject];
  [v6 stopSampling];

  GRCInfo::AddConsistencyInfo(*(GRCInfo **)(a1 + 56));
  unint64_t v7 = *(GTAGXPerfStateControl **)(*(void *)(a1 + 56) + 8);

  GTAGXPerfStateControl::DisableConsistentGPUPerfState(v7);
}

void sub_204E1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__241(uint64_t a1, uint64_t a2)
{
  return std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__hash_table(a1 + 48, (uint64_t *)(a2 + 48));
}

uint64_t __Block_byref_object_dispose__242(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(a1 + 48);
}

__n128 __Block_byref_object_copy__243(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__244(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void ___ZL20BlitSplitTimeDataGRCP26GTMTLReplayOperationQueuesP19NSMutableDictionaryjR7GRCInfo_block_invoke(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) firstObject];
  if (v2)
  {
    id v22 = v2;
    uint64_t v24 = 0;
    std::vector<unsigned long long>::resize((char **)(*(void *)(*(void *)(a1 + 48) + 8) + 48), *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 72), &v24);
    id v3 = v22;
    unint64_t v4 = (char *)[v3 bytes];
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    while (1)
    {
      int NextMarker = GRCInfo::FindNextMarker((GRCInfo *)v3, v6, *(void *)(*(void *)(a1 + 64) + 32));
      int v8 = NextMarker;
      if (NextMarker == -1) {
        break;
      }
      uint64_t v9 = &v4[8 * NextMarker];
      unint64_t v10 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>((void *)(*(void *)(*(void *)(a1 + 56) + 8) + 48), *((_DWORD *)v9 + 8));
      uint64_t v6 = (NSData *)(v8 + 8);
      if (v10)
      {
        BOOL v11 = *((void *)v9 + 3) > 5uLL || (*((void *)v9 + 3) & 1) == 0;
        if (v11
          || (unint64_t v12 = *((unsigned int *)v10 + 5),
              uint64_t v13 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 48),
              v12 >= (*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 56) - v13) >> 3))
        {
          BOOL v14 = (uint64_t *)(v9 + 8);
        }
        else
        {
          uint64_t v15 = *((void *)v9 + 1);
          BOOL v14 = (uint64_t *)(v9 + 8);
          *(void *)(v13 + 8 * v12) += 125 * (v15 - v5) / 3uLL;
        }
        uint64_t v5 = *v14;
      }
    }
    id v16 = objc_opt_new();
    uint64_t v17 = *(void *)(*(void *)(a1 + 48) + 8);
    long long v18 = *(void **)(v17 + 48);
    for (uint64_t i = *(void **)(v17 + 56); v18 != i; ++v18)
    {
      if (*v18)
      {
        id v20 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:");
        [v16 addObject:v20];
      }
    }
    uint64_t v21 = +[NSDictionary dictionaryWithObject:v16, @"PerDrawNsecTimes", v22 forKey];
    [*(id *)(a1 + 32) setObject:v21 forKeyedSubscript:@"SplitEncoderData"];

    uint64_t v2 = v23;
  }
}

void sub_205074(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  _Unwind_Resume(a1);
}

void ___ZL20BlitSplitTimeDataGRCP26GTMTLReplayOperationQueuesP19NSMutableDictionaryjR7GRCInfo_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = a1;
  GTMTLReplayController_prePlayForProfiling(**(void **)(a1 + 48));
  GRCInfo::SetupSource(*(void *)(v1 + 48), *(unsigned int *)(v1 + 56), 1, 0);
  uint64_t v2 = [*(id *)(*(void *)(v1 + 48) + 16) firstObject];
  [v2 startSampling];

  id v3 = *(GTMTLReplayController ***)(v1 + 48);
  uint64_t v44 = *(void *)(*(void *)(v1 + 32) + 8);
  GRCInfo::ScopedReplayConfiguration::ScopedReplayConfiguration((GRCInfo::ScopedReplayConfiguration *)v52, *v3);
  id v4 = (*v3)->var1;
  var0 = (uint64_t *)(*v3)->var0;
  uint64_t v41 = var0[15];
  uint64_t v42 = var0[14];
  uint64_t v6 = [v4 defaultDevice];
  id v45 = [v6 newEvent];

  unint64_t v7 = *v3;
  if (var0[13] + var0[12] > (unint64_t)(*v3)->var24.var0)
  {
    uint64_t v39 = v1;
    uint64_t v49 = var0;
    unsigned __int8 v50 = v4;
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v43 = v44 + 48;
    do
    {
      uint64_t v10 = *(void *)(var0[15] + 24);
      BOOL v11 = *v3;
      uint64_t v12 = (*v3)->var24.var0;
      uint64_t v13 = v10 + (v12 << 6);
      uint64_t v15 = (int *)(v13 + 8);
      int v14 = *(_DWORD *)(v13 + 8);
      if (GetFuncEnumConstructorType(v14) == 25)
      {
        GTMTLReplayController_restoreCommandBuffer((uint64_t)v11, v10 + (v12 << 6));
        uint64_t v47 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)(v10 + (v12 << 6)), *(unsigned __int8 *)(v10 + (v12 << 6) + 13), v49[2])+ 1);
        int v14 = *v15;
      }
      if (v14 == -16354)
      {
        id v16 = [v50 commandBufferForKey:v47];
        ++GRCInfo::ReplayFrameWithBlitSyncEvents(std::unordered_map<unsigned int,unsigned int> &,BOOL)::signalCounter;
        [v16 encodeSignalEvent:v45];
        [v16 encodeWaitForEvent:v45 value:GRCInfo::ReplayFrameWithBlitSyncEvents(std::unordered_map<unsigned int,unsigned int> &,BOOL)::signalCounter];
        uint64_t v9 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)(v10 + (v12 << 6)), *(unsigned __int8 *)(v10 + (v12 << 6) + 13), v49[2])+ 1);
        InclusiveRange = GroupBuilder_findInclusiveRange(*(_DWORD *)(v42 + 12), *(void **)(v42 + 24), (*v3)->var24.var0);
        unint64_t v18 = InclusiveRange[1];
        unint64_t v19 = v18 - *InclusiveRange;
        if (v18 > *InclusiveRange)
        {
          id v20 = (int *)(*(void *)(v41 + 24) + (*InclusiveRange << 6) + 8);
          do
          {
            int v22 = *v20;
            v20 += 16;
            int v21 = v22;
            if (IsFuncEnumSampledBlitCall(v22) || IsFuncEnumSampledBlitCallAGX(v21)) {
              ++v8;
            }
            --v19;
          }
          while (v19);
        }

        uint64_t v23 = v8;
      }
      else
      {
        uint64_t v23 = v46;
      }
      GTMTLReplayController_updateCommandEncoder((uint64_t)*v3, v13);
      int v24 = *v15;
      if (IsFuncEnumSampledBlitCall(*v15) || IsFuncEnumSampledBlitCallAGX(v24))
      {
        uint64_t v46 = v23 - 1;
        if (v23 && v8 != v23)
        {
          uint64_t v25 = v9;
          id v26 = [v50 blitCommandEncoderForKey:v9];
          [v26 endEncoding];
          long long v27 = [v50 commandBufferForKey:v47];
          ++GRCInfo::ReplayFrameWithBlitSyncEvents(std::unordered_map<unsigned int,unsigned int> &,BOOL)::signalCounter;
          [v27 encodeSignalEvent:v45];
          [v27 encodeWaitForEvent:v45 value:GRCInfo::ReplayFrameWithBlitSyncEvents(std::unordered_map<unsigned int,unsigned int> &,BOOL)::signalCounter];
          BOOL v28 = [v27 blitCommandEncoder];
          [v50 setBlitCommandEncoder:v28 forKey:v25];
          unsigned int v51 = [v50 globalTraceIdForEncoder:v25 ofType:0];
          uint64_t v29 = *(void *)(v44 + 72);
          *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v43, v51, &v51)+ 5) = v29;

          uint64_t v9 = v25;
        }
      }
      else
      {
        uint64_t v46 = v23;
      }
      GTMTLReplayController_defaultDispatchFunction((uint64_t)*v3, v13);
      int v30 = *v15;
      var0 = v49;
      if (*v15 == -16354)
      {
        unsigned int v51 = [v50 globalTraceIdForEncoder:v9 ofType:0];
        uint64_t v31 = *(void *)(v44 + 72);
        *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v43, v51, &v51)+ 5) = v31;
        int v30 = *v15;
      }
      if (v30 == -16376)
      {
        id v32 = [v50 commandBufferForKey:v47];
        ++GRCInfo::ReplayFrameWithBlitSyncEvents(std::unordered_map<unsigned int,unsigned int> &,BOOL)::signalCounter;
        [v32 encodeSignalEvent:v45];
        [v32 encodeWaitForEvent:v45 value:GRCInfo::ReplayFrameWithBlitSyncEvents(std::unordered_map<unsigned int,unsigned int> &,BOOL)::signalCounter];
      }
      unint64_t v7 = *v3;
      unint64_t v33 = (*v3)->var24.var0 + 1;
      (*v3)->var24.var0 = v33;
    }
    while (v49[13] + v49[12] > v33);
    id v4 = v50;
    uint64_t v1 = v39;
  }
  unint64_t v34 = [v7->var1 defaultCommandQueue];
  [v34 finish];

  GRCInfo::ScopedReplayConfiguration::~ScopedReplayConfiguration((GRCInfo::ScopedReplayConfiguration *)v52);
  uint64_t v35 = GRCInfo::DrainRawFrameData(*(id **)(v1 + 48));
  uint64_t v36 = GRCInfo::PostProcessFrameData(*(void *)(v1 + 48), v35);
  if (v36) {
    [*(id *)(*(void *)(*(void *)(v1 + 40) + 8) + 40) setArray:v36];
  }

  int v37 = [*(id *)(*(void *)(v1 + 48) + 16) firstObject];
  [v37 stopSampling];

  GRCInfo::AddConsistencyInfo(*(GRCInfo **)(v1 + 48));
  uint64_t v38 = *(GTAGXPerfStateControl **)(*(void *)(v1 + 48) + 8);

  GTAGXPerfStateControl::DisableConsistentGPUPerfState(v38);
}

void sub_2055A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GRCInfo::~GRCInfo(id *this)
{
}

void sub_2056C4(_Unwind_Exception *a1)
{
  GPURawCounterSetupParams::~GPURawCounterSetupParams(v1 + 2);
  _Unwind_Resume(a1);
}

id *std::unique_ptr<GTAGXPerfStateControl>::reset[abi:nn180100](id **a1)
{
  __n128 result = *a1;
  *a1 = 0;
  if (result)
  {
    GTAGXPerfStateControl::~GTAGXPerfStateControl(result);
    operator delete();
  }
  return result;
}

void GRCInfo::SetupSource(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  id v7 = a4;
  uint64_t v8 = [*(id *)(a1 + 16) firstObject];
  uint64_t v9 = *(void **)(a1 + 48);
  if (v7)
  {
    id v10 = [v9 arrayByAddingObjectsFromArray:v7];
  }
  else
  {
    id v10 = v9;
  }
  BOOL v11 = v10;
  if ([*(id *)(a1 + 24) count])
  {
    uint64_t v12 = *(void **)(*(void *)a1 + 8);
    if (a3)
    {
      if (IsGPUPerformanceStateInduced(v12))
      {
        uint64_t v13 = [*(id *)(a1 + 16) firstObject];
        [v13 setOptions:&off_759170];

        goto LABEL_14;
      }
      uint64_t v14 = *(unsigned int *)(a1 + 64);
      if (!v14)
      {
        v26[0] = @"DisableOverlap";
        v26[1] = @"LockGPUPerfState";
        v27[0] = &__kCFBooleanTrue;
        uint64_t v17 = +[NSNumber numberWithUnsignedInt:a2];
        v27[1] = v17;
        unint64_t v18 = +[NSDictionary dictionaryWithObjects:v27 forKeys:v26 count:2];
        unint64_t v19 = [*(id *)(a1 + 16) firstObject];
        [v19 setOptions:v18];

LABEL_14:
        id v20 = [*(id *)(a1 + 24) firstObject];
        if (([v20 requestTriggers:*(void *)(a1 + 40) firstErrorIndex:0] & 1) == 0)
        {
          int v21 = [v20 name];
          NSLog(@"Fail, error while requesting triggers for %@", v21);
        }
        [v20 setOptions:0];
        if ([v20 requestCounters:v11 firstErrorIndex:0])
        {
          if ([v20 setEnabled:1])
          {
LABEL_21:

            goto LABEL_22;
          }
          int v22 = [v20 name];
          NSLog(@"Fail, error while enabling source[%@]", v22);
        }
        else
        {
          id v23 = [*(id *)(a1 + 48) count];
          int v22 = [v20 name];
          NSLog(@"Fail, error while requesting %lu counter for source[%@]", v23, v22);
        }

        goto LABEL_21;
      }
    }
    else
    {
      if (IsGPUPerformanceStateInduced(v12)) {
        goto LABEL_14;
      }
      uint64_t v14 = *(unsigned int *)(a1 + 64);
      if (!v14)
      {
        CFStringRef v24 = @"LockGPUPerfState";
        uint64_t v15 = +[NSNumber numberWithUnsignedInt:a2];
        uint64_t v25 = v15;
        id v16 = +[NSDictionary dictionaryWithObjects:&v25 forKeys:&v24 count:1];
        [v8 setOptions:v16];

        goto LABEL_14;
      }
    }
    GTAGXPerfStateControl::EnableConsistentGPUPerfState(*(void *)(a1 + 8), v14);
    goto LABEL_14;
  }
LABEL_22:
}

void sub_205A0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GRCInfo::DrainRawFrameData(id *this)
{
  if ([this[3] count])
  {
    uint64_t v2 = [this[3] firstObject];
    id v3 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v2 ringBufferNum]);

    id v4 = [this[3] lastObject];
    if ([v4 isEnabled])
    {
      for (uint64_t i = 0; ; uint64_t i = (i + 1))
      {
        if (i >= [v4 ringBufferNum])
        {
          id v12 = v3;
          goto LABEL_16;
        }
        uint64_t v16 = 0;
        uint64_t v17 = 0;
        unsigned int v15 = 0;
        if (([v4 ringBufferInfoAtIndex:i base:&v17 size:(char *)&v16 + 4 dataOffset:&v16 dataSize:&v15] & 1) == 0)break; {
        uint64_t v6 = +[NSMutableData dataWithCapacity:v15];
        }
        id v7 = v6;
        unsigned int v8 = v15;
        if (v15 + v16 <= HIDWORD(v16))
        {
          [v6 appendBytes:v17 + v16 length:v15];
        }
        else
        {
          int v9 = HIDWORD(v16) - v16;
          [v6 appendBytes:v17 + v16 length:(HIDWORD(v16) - v16)];
          [v7 appendBytes:v17 length:v8 - v9];
        }
        unsigned int v10 = [v4 drainRingBufferAtIndex:i dataSize:v15];
        if (v10 != v15)
        {
          BOOL v11 = [v4 name];
          NSLog(@"Fail, unexpected drain count for source %@!", v11);
        }
        [v3 addObject:v7];
      }
      uint64_t v13 = [v4 name];
      NSLog(@"Fail, unable to retrieve ring buffer info from source %@!", v13);
    }
    id v12 = 0;
LABEL_16:
  }
  else
  {
    id v12 = 0;
  }

  return v12;
}

void sub_205CAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GRCInfo::PostProcessFrameData(uint64_t a1, void *a2)
{
  id v19 = a2;
  if ([v19 count])
  {
    id v3 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v19 count]);
    id v4 = [*(id *)(a1 + 24) lastObject];
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    obuint64_t j = v19;
    id v5 = [obj countByEnumeratingWithState:&v23 objects:v27 count:16];
    if (v5)
    {
      uint64_t v6 = *(void *)v24;
      while (2)
      {
        for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v24 != v6) {
            objc_enumerationMutation(obj);
          }
          unsigned int v8 = *(void **)(*((void *)&v23 + 1) + 8 * i);
          [v4 resetRawDataPostProcessor];
          uint64_t v21 = 0;
          uint64_t v22 = 0;
          id v9 = [v8 length];
          if ((unint64_t)(4 * (void)v9) <= 0x4000) {
            uint64_t v10 = 0x4000;
          }
          else {
            uint64_t v10 = 4 * (void)v9;
          }
          BOOL v11 = +[NSMutableData dataWithLength:v10];
          if ([v8 length])
          {
            id v12 = v8;
            id v13 = [v12 bytes];
            id v14 = [v12 length];
            id v15 = v11;
            LOBYTE(v18) = 1;
            if ((objc_msgSend(v4, "postProcessRawDataWithSource:sourceSize:sourceRead:output:outputSize:outputWritten:isLast:", v13, v14, &v22, objc_msgSend(v15, "mutableBytes"), objc_msgSend(v15, "length"), &v21, v18) & 1) == 0)
            {

              id v16 = 0;
              goto LABEL_17;
            }
          }
          [v11 setLength:v21];
          [v3 addObject:v11];
        }
        id v5 = [obj countByEnumeratingWithState:&v23 objects:v27 count:16];
        if (v5) {
          continue;
        }
        break;
      }
    }

    id v16 = v3;
LABEL_17:
  }
  else
  {
    id v16 = 0;
  }

  return v16;
}

void sub_205F78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void GRCInfo::AddConsistencyInfo(GRCInfo *this)
{
  if (!*((_DWORD *)this + 16)) {
    return;
  }
  uint64_t v2 = GTAGXPerfStateControl::ConsistentGPUPerfStateLevel(*((GTAGXPerfStateControl **)this + 1), 0);
  if (v2)
  {
    id v9 = v2;
    if (*((void *)this + 7))
    {
      if (*((unsigned char *)this + 68))
      {
        id v3 = [v2 objectForKeyedSubscript:@"enabled"];
        *((unsigned char *)this + 68) = [v3 BOOLValue];

        uint64_t v2 = v9;
      }
      else
      {
        *((unsigned char *)this + 68) = 0;
      }
      if (!*((unsigned char *)this + 69))
      {
        *((unsigned char *)this + 69) = 0;
        goto LABEL_13;
      }
      id v7 = [v2 objectForKeyedSubscript:@"consistent"];
      unsigned __int8 v8 = [v7 BOOLValue];
    }
    else
    {
      uint64_t v4 = [v2 objectForKeyedSubscript:@"level"];
      id v5 = (void *)*((void *)this + 7);
      *((void *)this + 7) = v4;

      uint64_t v6 = [v9 objectForKeyedSubscript:@"enabled"];
      *((unsigned char *)this + 68) = [v6 BOOLValue];

      id v7 = [v9 objectForKeyedSubscript:@"consistent"];
      unsigned __int8 v8 = [v7 BOOLValue];
    }
    *((unsigned char *)this + 69) = v8;

    uint64_t v2 = v9;
  }
LABEL_13:
}

void sub_20610C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

GRCInfo::ScopedReplayConfiguration *GRCInfo::ScopedReplayConfiguration::ScopedReplayConfiguration(GRCInfo::ScopedReplayConfiguration *this, GTMTLReplayController *a2)
{
  *((void *)this + 1) = a2;
  *((unsigned char *)this + 16) = 1;
  id v3 = [a2->var1 defaultCommandQueue];
  [v3 setGPUPriority:0];

  *(void *)this = [(id)g_commandBufferDescriptor errorOptions];
  [(id)g_commandBufferDescriptor setErrorOptions:0];
  return this;
}

void sub_2061A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    id v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v10 = operator new(0x18uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  id v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    id v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_2063B0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void GRCInfo::ScopedReplayConfiguration::~ScopedReplayConfiguration(GRCInfo::ScopedReplayConfiguration *this)
{
  if (*((unsigned char *)this + 16))
  {
    uint64_t v2 = [*(id *)(*((void *)this + 1) + 8) defaultCommandQueue];
    [v2 setGPUPriority:1];
  }
  [(id)g_commandBufferDescriptor setErrorOptions:*(void *)this];
}

void sub_206420(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<unsigned long long>::resize(char **a1, unint64_t a2, void *a3)
{
  unint64_t v6 = *a1;
  id v5 = a1[1];
  unint64_t v7 = (v5 - *a1) >> 3;
  if (a2 <= v7)
  {
    if (a2 < v7) {
      a1[1] = &v6[8 * a2];
    }
  }
  else
  {
    id v9 = a1[2];
    if (a2 - v7 <= (v9 - v5) >> 3)
    {
      long long v23 = &v5[8 * (a2 - v7)];
      uint64_t v24 = 8 * a2 - 8 * v7;
      do
      {
        *(void *)id v5 = *a3;
        v5 += 8;
        v24 -= 8;
      }
      while (v24);
      a1[1] = v23;
    }
    else
    {
      if (a2 >> 61) {
        abort();
      }
      unint64_t v10 = v9 - v6;
      unint64_t v11 = (v9 - v6) >> 2;
      if (v11 <= a2) {
        unint64_t v11 = a2;
      }
      if (v10 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v11;
      }
      float v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v12);
      unint64_t v15 = &v13[8 * v7];
      unint64_t v16 = &v13[8 * a2];
      uint64_t v17 = 8 * a2 - 8 * v7;
      uint64_t v18 = v15;
      do
      {
        *(void *)uint64_t v18 = *a3;
        v18 += 8;
        v17 -= 8;
      }
      while (v17);
      id v19 = &v13[8 * v14];
      unint64_t v20 = *a1;
      for (uint64_t i = a1[1]; i != v20; i -= 8)
      {
        uint64_t v22 = *((void *)i - 1);
        *((void *)v15 - 1) = v22;
        v15 -= 8;
      }
      *a1 = v15;
      a1[1] = v16;
      a1[2] = v19;
      if (v20)
      {
        operator delete(v20);
      }
    }
  }
}

uint64_t GRCInfo::FindNextMarker(GRCInfo *this, NSData *a2, uint64_t a3)
{
  unsigned int v4 = a2;
  id v5 = this;
  unsigned int v6 = [(GRCInfo *)v5 length];
  unint64_t v7 = v5;
  uint8x8_t v8 = [(GRCInfo *)v7 bytes];
  unsigned int v9 = (v6 - 64) >> 3;
  BOOL v10 = v9 >= v4;
  unsigned int v11 = v9 - v4;
  if (v10)
  {
    uint64_t v12 = v4;
    unsigned int v13 = v11 + 1;
    while (v8[v12] != a3)
    {
      ++v12;
      if (!--v13) {
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    uint64_t v12 = 0xFFFFFFFFLL;
  }

  return v12;
}

void sub_2065EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__hash_table(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *(void *)__n128 result = v2;
  *(void *)(result + 8) = a2[1];
  a2[1] = 0;
  uint64_t v5 = a2[2];
  unint64_t v3 = a2 + 2;
  uint64_t v4 = v5;
  *(void *)(result + 16) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 24) = v6;
  *(_DWORD *)(result + 32) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 16;
    void *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

void GRCInfo::ReplayForKickCounters(GTMTLReplayController **a1, uint64_t *a2)
{
  GRCInfo::ScopedReplayConfiguration::ScopedReplayConfiguration((GRCInfo::ScopedReplayConfiguration *)v51, *a1);
  id v47 = (*a1)->var1;
  uint64_t v4 = *a1;
  var0 = (uint64_t *)(*a1)->var0;
  char v50 = 0;
  if (var0[13] + var0[12] > (unint64_t)v4->var24.var0)
  {
    uint64_t v46 = a2 + 2;
    uint64_t v48 = var0[15];
    LODWORD(v49) = -1;
    do
    {
      uint64_t v7 = *(void *)(v48 + 24);
      uint64_t v8 = (*a1)->var24.var0;
      GTMTLReplayController_updateCommandEncoder((uint64_t)*a1, v7 + (v8 << 6));
      DispatchFunction((id *)&(*a1)->var0, v7 + (v8 << 6), &v50);
      uint64_t v9 = v7 + (v8 << 6);
      unint64_t v10 = *(unsigned int *)(v9 + 8);
      int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v9 + 8));
      if (FuncEnumConstructorType == 25) {
        uint64_t v12 = (v49 + 1);
      }
      else {
        uint64_t v12 = v49;
      }
      uint64_t v49 = v12;
      if (!GTMTLReplayHost_IsFuncEnumSampledEncoder(v10, 1, 0)
        || v50 != (FuncEnumConstructorType == 65))
      {
        goto LABEL_80;
      }
      unsigned int v13 = [v47 globalTraceIdForEncoder:*(void *)(v7 + (v8 << 6)) ofType:FuncEnumConstructorType == 65];
      unsigned int v14 = v13;
      uint64_t v15 = a2[3];
      unint64_t v16 = v13;
      unint64_t v17 = a2[1];
      if (v17)
      {
        uint8x8_t v18 = (uint8x8_t)vcnt_s8((int8x8_t)v17);
        v18.i16[0] = vaddlv_u8(v18);
        if (v18.u32[0] > 1uLL)
        {
          unint64_t v10 = v13;
          if (v17 <= v13) {
            unint64_t v10 = v13 % v17;
          }
        }
        else
        {
          unint64_t v10 = (v17 - 1) & v13;
        }
        id v19 = *(uint64_t ***)(*a2 + 8 * v10);
        if (v19)
        {
          for (uint64_t i = *v19; i; uint64_t i = (uint64_t *)*i)
          {
            unint64_t v21 = i[1];
            if (v21 == v13)
            {
              if (*((_DWORD *)i + 4) == v13) {
                goto LABEL_80;
              }
            }
            else
            {
              if (v18.u32[0] > 1uLL)
              {
                if (v21 >= v17) {
                  v21 %= v17;
                }
              }
              else
              {
                v21 &= v17 - 1;
              }
              if (v21 != v10) {
                break;
              }
            }
          }
        }
      }
      uint64_t v22 = operator new(0x20uLL);
      void *v22 = 0;
      v22[1] = v16;
      *((_DWORD *)v22 + 4) = v14;
      *(void *)((char *)v22 + 20) = v49 | (v15 << 32);
      float v23 = (float)(unint64_t)(v15 + 1);
      float v24 = *((float *)a2 + 8);
      if (v17 && (float)(v24 * (float)v17) >= v23)
      {
        unint64_t v16 = v10;
        goto LABEL_70;
      }
      BOOL v25 = (v17 & (v17 - 1)) != 0;
      if (v17 < 3) {
        BOOL v25 = 1;
      }
      unint64_t v26 = v25 | (2 * v17);
      unint64_t v27 = vcvtps_u32_f32(v23 / v24);
      if (v26 <= v27) {
        int8x8_t prime = (int8x8_t)v27;
      }
      else {
        int8x8_t prime = (int8x8_t)v26;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        unint64_t v17 = a2[1];
      }
      if (*(void *)&prime <= v17)
      {
        if (*(void *)&prime >= v17) {
          goto LABEL_66;
        }
        unint64_t v35 = vcvtps_u32_f32((float)(unint64_t)a2[3] / *((float *)a2 + 8));
        if (v17 < 3 || (uint8x8_t v36 = (uint8x8_t)vcnt_s8((int8x8_t)v17), v36.i16[0] = vaddlv_u8(v36), v36.u32[0] > 1uLL))
        {
          unint64_t v35 = std::__next_prime(v35);
        }
        else
        {
          uint64_t v37 = 1 << -(char)__clz(v35 - 1);
          if (v35 >= 2) {
            unint64_t v35 = v37;
          }
        }
        if (*(void *)&prime <= v35) {
          int8x8_t prime = (int8x8_t)v35;
        }
        if (*(void *)&prime >= v17)
        {
          unint64_t v17 = a2[1];
          goto LABEL_66;
        }
        if (!*(void *)&prime)
        {
          uint64_t v44 = (void *)*a2;
          *a2 = 0;
          if (v44) {
            operator delete(v44);
          }
          unint64_t v17 = 0;
          a2[1] = 0;
          goto LABEL_66;
        }
      }
      if (*(void *)&prime >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v29 = operator new(8 * *(void *)&prime);
      int v30 = (void *)*a2;
      *a2 = (uint64_t)v29;
      if (v30) {
        operator delete(v30);
      }
      uint64_t v31 = 0;
      a2[1] = (uint64_t)prime;
      do
        *(void *)(*a2 + 8 * v31++) = 0;
      while (*(void *)&prime != v31);
      id v32 = (void *)*v46;
      if (*v46)
      {
        unint64_t v33 = v32[1];
        uint8x8_t v34 = (uint8x8_t)vcnt_s8(prime);
        v34.i16[0] = vaddlv_u8(v34);
        if (v34.u32[0] > 1uLL)
        {
          if (v33 >= *(void *)&prime) {
            v33 %= *(void *)&prime;
          }
        }
        else
        {
          v33 &= *(void *)&prime - 1;
        }
        *(void *)(*a2 + 8 * v33) = v46;
        uint64_t v38 = (void *)*v32;
        if (*v32)
        {
          do
          {
            unint64_t v39 = v38[1];
            if (v34.u32[0] > 1uLL)
            {
              if (v39 >= *(void *)&prime) {
                v39 %= *(void *)&prime;
              }
            }
            else
            {
              v39 &= *(void *)&prime - 1;
            }
            if (v39 != v33)
            {
              if (!*(void *)(*a2 + 8 * v39))
              {
                *(void *)(*a2 + 8 * v39) = v32;
                goto LABEL_62;
              }
              void *v32 = *v38;
              *uint64_t v38 = **(void **)(*a2 + 8 * v39);
              **(void **)(*a2 + 8 * v39) = v38;
              uint64_t v38 = v32;
            }
            unint64_t v39 = v33;
LABEL_62:
            id v32 = v38;
            uint64_t v38 = (void *)*v38;
            unint64_t v33 = v39;
          }
          while (v38);
        }
      }
      unint64_t v17 = (unint64_t)prime;
LABEL_66:
      if ((v17 & (v17 - 1)) != 0)
      {
        if (v17 <= v16) {
          v16 %= v17;
        }
      }
      else
      {
        unint64_t v16 = (v17 - 1) & v16;
      }
LABEL_70:
      uint64_t v40 = *a2;
      uint64_t v41 = *(void **)(*a2 + 8 * v16);
      if (v41)
      {
        void *v22 = *v41;
LABEL_78:
        void *v41 = v22;
        goto LABEL_79;
      }
      void *v22 = *v46;
      void *v46 = v22;
      *(void *)(v40 + 8 * v16) = v46;
      if (*v22)
      {
        unint64_t v42 = *(void *)(*v22 + 8);
        if ((v17 & (v17 - 1)) != 0)
        {
          if (v42 >= v17) {
            v42 %= v17;
          }
        }
        else
        {
          v42 &= v17 - 1;
        }
        uint64_t v41 = (void *)(*a2 + 8 * v42);
        goto LABEL_78;
      }
LABEL_79:
      ++a2[3];
LABEL_80:
      uint64_t v4 = *a1;
      unint64_t v43 = (*a1)->var24.var0 + 1;
      (*a1)->var24.var0 = v43;
    }
    while (var0[13] + var0[12] > v43);
  }
  v4->var24.id var1 = 0;
  id v45 = [v4->var1 defaultCommandQueue:v46];
  [v45 finish];

  GRCInfo::ScopedReplayConfiguration::~ScopedReplayConfiguration((GRCInfo::ScopedReplayConfiguration *)v51);
}

void sub_206BD0(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);

  GRCInfo::ScopedReplayConfiguration::~ScopedReplayConfiguration((GRCInfo::ScopedReplayConfiguration *)va);
  _Unwind_Resume(a1);
}

void sub_206DCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZN7GRCInfo23ReplayForTimingCountersERNSt3__16vectorINS0_5tupleIJyyyEEENS0_9allocatorIS3_EEEE_block_invoke(uint64_t a1, void *a2)
{
  id v24 = a2;
  unint64_t v3 = [v24 label];
  unsigned __int8 v4 = [v3 hasPrefix:@"com.apple.gputools.replay"];

  uint64_t v5 = v24;
  if ((v4 & 1) == 0)
  {
    [v24 GPUStartTime];
    double v7 = v6;
    [v24 GPUEndTime];
    unint64_t v8 = (unint64_t)(v7 * 1000000000.0);
    unint64_t v10 = (unint64_t)(v9 * 1000000000.0);
    uint64_t v11 = *(void *)(a1 + 32);
    uint64_t v12 = *(unint64_t **)(v11 + 8);
    unint64_t v13 = *(void *)(v11 + 16);
    if ((unint64_t)v12 >= v13)
    {
      unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
      unint64_t v16 = *(unint64_t **)v11;
      unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v12 - *(void *)v11) >> 3);
      unint64_t v18 = v17 + 1;
      if (v17 + 1 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v16) >> 3);
      if (2 * v19 > v18) {
        unint64_t v18 = 2 * v19;
      }
      if (v19 < 0x555555555555555) {
        unint64_t v15 = v18;
      }
      if (v15)
      {
        unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v15);
        unint64_t v16 = *(unint64_t **)v11;
        uint64_t v12 = *(unint64_t **)(v11 + 8);
      }
      else
      {
        uint64_t v20 = 0;
      }
      unint64_t v21 = (unint64_t *)(v15 + 24 * v17);
      unint64_t v22 = v15 + 24 * v20;
      *unint64_t v21 = v8;
      v21[1] = v10;
      v21[2] = (unint64_t)v24;
      unsigned int v14 = v21 + 3;
      if (v12 != v16)
      {
        do
        {
          long long v23 = *(_OWORD *)(v12 - 3);
          *(v21 - 1) = *(v12 - 1);
          *(_OWORD *)(v21 - 3) = v23;
          v21 -= 3;
          v12 -= 3;
        }
        while (v12 != v16);
        unint64_t v16 = *(unint64_t **)v11;
      }
      *(void *)uint64_t v11 = v21;
      *(void *)(v11 + 8) = v14;
      *(void *)(v11 + 16) = v22;
      if (v16) {
        operator delete(v16);
      }
      uint64_t v5 = v24;
    }
    else
    {
      unint64_t *v12 = v8;
      v12[1] = v10;
      unsigned int v14 = v12 + 3;
      uint64_t v5 = v24;
      v12[2] = (unint64_t)v24;
    }
    *(void *)(v11 + 8) = v14;
  }
}

void sub_206FC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *,false>(unint64_t result, unint64_t *a2, uint64_t a3, char a4)
{
  double v9 = (unint64_t *)result;
LABEL_2:
  unint64_t v10 = a2 - 3;
  uint64_t k = v9;
  while (1)
  {
    double v9 = k;
    uint64_t v12 = (char *)a2 - (char *)k;
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * (a2 - k);
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          unint64_t v65 = *v10;
          unint64_t v66 = *k;
          if (*v10 < *k || v66 >= v65 && ((v67 = *(a2 - 2), unint64_t v68 = k[1], v67 < v68) || v68 >= v67 && *(a2 - 1) < k[2]))
          {
            *uint64_t k = v65;
            *(a2 - 3) = v66;
            unint64_t v69 = k[1];
            k[1] = *(a2 - 2);
            *(a2 - 2) = v69;
            unint64_t v70 = k[2];
            k[2] = *(a2 - 1);
            *(a2 - 1) = v70;
          }
          break;
        case 3uLL:
          __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(k, k + 3, a2 - 3);
          break;
        case 4uLL:
          __n128 result = (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(k, k + 3, k + 6, a2 - 3);
          break;
        case 5uLL:
          __n128 result = (unint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(k, k + 3, k + 6, k + 9, a2 - 3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 575) {
      break;
    }
    if (!a3)
    {
      if (k == a2) {
        return result;
      }
      int64_t v87 = (v13 - 2) >> 1;
      int64_t v88 = v87;
      while (1)
      {
        int64_t v89 = v88;
        if (v87 >= v88)
        {
          uint64_t v90 = (2 * v88) | 1;
          int v91 = &k[3 * v90];
          if (2 * v89 + 2 < (uint64_t)v13)
          {
            unint64_t v92 = v91[3];
            if (*v91 < v92
              || v92 >= *v91 && ((unint64_t v105 = v91[1], v106 = v91[4], v105 < v106) || v106 >= v105 && v91[2] < v91[5]))
            {
              v91 += 3;
              uint64_t v90 = 2 * v89 + 2;
            }
          }
          uint64_t v93 = &k[3 * v89];
          unint64_t v94 = *v91;
          unint64_t v95 = *v93;
          if (*v91 >= *v93)
          {
            if (v95 < v94)
            {
              unint64_t v96 = v93[1];
LABEL_167:
              unint64_t v97 = v93[2];
              while (1)
              {
                *uint64_t v93 = v94;
                v93[1] = v91[1];
                v93[2] = v91[2];
                if (v87 < v90) {
                  goto LABEL_182;
                }
                uint64_t v93 = v91;
                uint64_t v98 = 2 * v90;
                uint64_t v90 = (2 * v90) | 1;
                int v91 = &k[3 * v90];
                uint64_t v99 = v98 + 2;
                if (v99 < (uint64_t)v13)
                {
                  unint64_t v100 = v91[3];
                  if (*v91 < v100
                    || v100 >= *v91 && ((unint64_t v101 = v91[1], v102 = v91[4], v101 < v102) || v102 >= v101 && v91[2] < v91[5]))
                  {
                    v91 += 3;
                    uint64_t v90 = v99;
                  }
                }
                unint64_t v94 = *v91;
                if (*v91 < v95) {
                  break;
                }
                if (v95 >= v94)
                {
                  unint64_t v103 = v91[1];
                  if (v103 < v96 || v96 >= v103 && v91[2] < v97) {
                    break;
                  }
                }
              }
              int v91 = v93;
LABEL_182:
              unint64_t *v91 = v95;
              v91[1] = v96;
              _OWORD v91[2] = v97;
              goto LABEL_184;
            }
            unint64_t v104 = v91[1];
            unint64_t v96 = v93[1];
            if (v104 >= v96 && (v96 < v104 || v91[2] >= v93[2])) {
              goto LABEL_167;
            }
          }
        }
LABEL_184:
        int64_t v88 = v89 - 1;
        if (!v89)
        {
          int64_t v119 = v12 / 0x18uLL;
          while (1)
          {
            uint64_t v120 = 0;
            unint64_t v121 = *k;
            unint64_t v122 = k[1];
            unint64_t v123 = k[2];
            uint64_t v124 = v119 - 2;
            if (v119 < 2) {
              uint64_t v124 = v119 - 1;
            }
            uint64_t v125 = v124 >> 1;
            double v126 = k;
            do
            {
              __n128 result = (unint64_t)v126;
              v126 += 3 * v120 + 3;
              uint64_t v127 = 2 * v120;
              uint64_t v120 = (2 * v120) | 1;
              int64_t v128 = v127 + 2;
              if (v128 < v119)
              {
                unint64_t v129 = v126[3];
                if (*v126 < v129
                  || v129 >= *v126
                  && ((v130 = v126[1], unint64_t v131 = v126[4], v130 < v131) || v131 >= v130 && v126[2] < v126[5]))
                {
                  v126 += 3;
                  uint64_t v120 = v128;
                }
              }
              *(void *)__n128 result = *v126;
              *(void *)(result + 8) = v126[1];
              *(void *)(result + 16) = v126[2];
            }
            while (v120 <= v125);
            if (v126 == a2 - 3)
            {
              unint64_t *v126 = v121;
              v126[1] = v122;
              v126[2] = v123;
              goto LABEL_240;
            }
            unint64_t *v126 = *(a2 - 3);
            v126[1] = *(a2 - 2);
            v126[2] = *(a2 - 1);
            *(a2 - 3) = v121;
            *(a2 - 2) = v122;
            *(a2 - 1) = v123;
            uint64_t v132 = (char *)v126 - (char *)k + 24;
            if (v132 < 25) {
              goto LABEL_240;
            }
            unint64_t v133 = 0xAAAAAAAAAAAAAAABLL * (v132 >> 3) - 2;
            unint64_t v134 = v133 >> 1;
            unint64_t v135 = &k[3 * (v133 >> 1)];
            unint64_t v136 = *v135;
            unint64_t v137 = *v126;
            if (*v135 >= *v126)
            {
              if (v137 < v136) {
                goto LABEL_240;
              }
              __n128 result = v135[1];
              unint64_t v138 = v126[1];
              if (result >= v138)
              {
                if (v138 < result) {
                  goto LABEL_240;
                }
                __n128 result = v135[2];
                if (result >= v126[2]) {
                  goto LABEL_240;
                }
              }
            }
            else
            {
              unint64_t v138 = v126[1];
            }
            __n128 result = v126[2];
            unint64_t *v126 = v136;
            v126[1] = v135[1];
            v126[2] = v135[2];
            if (v133 < 2) {
              goto LABEL_239;
            }
            while (1)
            {
              uint64_t v139 = v135;
              unint64_t v140 = v134 - 1;
              unint64_t v134 = (v134 - 1) >> 1;
              unint64_t v135 = &k[3 * v134];
              unint64_t v141 = *v135;
              if (*v135 >= v137) {
                break;
              }
              unint64_t v142 = v135[1];
LABEL_236:
              *uint64_t v139 = v141;
              v139[1] = v142;
              v139[2] = v135[2];
              if (v140 <= 1) {
                goto LABEL_239;
              }
            }
            if (v137 >= v141)
            {
              unint64_t v142 = v135[1];
              if (v142 < v138 || v138 >= v142 && v135[2] < result) {
                goto LABEL_236;
              }
            }
            unint64_t v135 = v139;
LABEL_239:
            *unint64_t v135 = v137;
            v135[1] = v138;
            v135[2] = result;
LABEL_240:
            a2 -= 3;
            if (v119-- <= 2) {
              return result;
            }
          }
        }
      }
    }
    unint64_t v14 = v13 >> 1;
    unint64_t v15 = &k[3 * (v13 >> 1)];
    if ((unint64_t)v12 >= 0xC01)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(v9, &v9[3 * (v13 >> 1)], a2 - 3);
      uint64_t v16 = 3 * v14;
      unint64_t v17 = &v9[3 * v14 - 3];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(v9 + 3, v17, a2 - 6);
      unint64_t v18 = &v9[v16 + 3];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(v9 + 6, v18, a2 - 9);
      __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(v17, v15, v18);
      long long v19 = *(_OWORD *)v9;
      *(_OWORD *)double v9 = *(_OWORD *)v15;
      *(_OWORD *)unint64_t v15 = v19;
      unint64_t v20 = v9[2];
      v9[2] = v15[2];
      v15[2] = v20;
    }
    else
    {
      __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(&v9[3 * (v13 >> 1)], v9, a2 - 3);
    }
    --a3;
    unint64_t v21 = *v9;
    if ((a4 & 1) != 0 || (unint64_t v22 = *(v9 - 3), v22 < v21))
    {
LABEL_16:
      unint64_t v25 = v9[1];
      unint64_t v26 = v9[2];
      for (uint64_t i = v9 + 3; ; i += 3)
      {
        unint64_t v28 = *i;
        if (*i >= v21)
        {
          if (v21 < v28) {
            break;
          }
          unint64_t v29 = i[1];
          if (v29 >= v25 && (v25 < v29 || i[2] >= v26)) {
            break;
          }
        }
      }
      if (i - 3 == v9)
      {
        uint64_t j = a2;
        if (i < a2)
        {
          unint64_t v34 = *v10;
          uint64_t j = a2 - 3;
          if (*v10 >= v21)
          {
            uint64_t j = a2 - 3;
            do
            {
              if (v21 < v34) {
                goto LABEL_37;
              }
              unint64_t v35 = j[1];
              if (v35 < v25) {
                break;
              }
              if (v25 >= v35)
              {
                if (j[2] < v26 || i >= j) {
                  break;
                }
              }
              else
              {
LABEL_37:
                if (i >= j) {
                  break;
                }
              }
              unint64_t v37 = *(j - 3);
              j -= 3;
              unint64_t v34 = v37;
            }
            while (v37 >= v21);
          }
        }
      }
      else
      {
        unint64_t v30 = *v10;
        for (uint64_t j = a2 - 3; v30 >= v21; j -= 3)
        {
          if (v21 >= v30)
          {
            unint64_t v32 = j[1];
            if (v32 < v25 || v25 >= v32 && j[2] < v26) {
              break;
            }
          }
          unint64_t v33 = *(j - 3);
          unint64_t v30 = v33;
        }
      }
      uint64_t k = i;
      if (i < j)
      {
        unint64_t v38 = *j;
        uint64_t k = i;
        unint64_t v39 = j;
        do
        {
          *uint64_t k = v38;
          unint64_t *v39 = v28;
          unint64_t v40 = k[1];
          k[1] = v39[1];
          v39[1] = v40;
          unint64_t v41 = k[2];
          k[2] = v39[2];
          v39[2] = v41;
          do
          {
            do
            {
              unint64_t v42 = k[3];
              k += 3;
              unint64_t v28 = v42;
            }
            while (v42 < v21);
            if (v21 < v28) {
              break;
            }
            unint64_t v43 = k[1];
          }
          while (v43 < v25 || v25 >= v43 && k[2] < v26);
          while (1)
          {
            unint64_t v44 = *(v39 - 3);
            v39 -= 3;
            unint64_t v38 = v44;
            if (v44 < v21) {
              break;
            }
            if (v21 >= v38)
            {
              unint64_t v45 = v39[1];
              if (v45 < v25 || v25 >= v45 && v39[2] < v26) {
                break;
              }
            }
          }
        }
        while (k < v39);
      }
      if (k - 3 != v9)
      {
        *double v9 = *(k - 3);
        v9[1] = *(k - 2);
        v9[2] = *(k - 1);
      }
      *(k - 3) = v21;
      *(k - 2) = v25;
      *(k - 1) = v26;
      if (i < j)
      {
LABEL_63:
        __n128 result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *,false>(v9, k - 3, a3, a4 & 1);
        a4 = 0;
      }
      else
      {
        BOOL v46 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(v9, k - 3);
        __n128 result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(k, a2);
        if (result)
        {
          a2 = k - 3;
          if (v46) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v46) {
          goto LABEL_63;
        }
      }
    }
    else
    {
      if (v21 < v22)
      {
        unint64_t v24 = v9[1];
      }
      else
      {
        unint64_t v23 = *(v9 - 2);
        unint64_t v24 = v9[1];
        if (v23 < v24 || v24 >= v23 && *(v9 - 1) < v9[2]) {
          goto LABEL_16;
        }
      }
      unint64_t v47 = v9[2];
      unint64_t v48 = *v10;
      if (v21 < *v10 || v48 >= v21 && ((unint64_t v64 = *(a2 - 2), v24 < v64) || v64 >= v24 && v47 < *(a2 - 1)))
      {
        uint64_t k = v9;
        while (1)
        {
          unint64_t v50 = k[3];
          k += 3;
          unint64_t v49 = v50;
          if (v21 < v50) {
            break;
          }
          if (v49 >= v21)
          {
            unint64_t v51 = k[1];
            if (v24 < v51 || v51 >= v24 && v47 < k[2]) {
              break;
            }
          }
        }
      }
      else
      {
        for (uint64_t k = v9 + 3; k < a2; k += 3)
        {
          if (v21 < *k) {
            break;
          }
          if (*k >= v21)
          {
            unint64_t v63 = k[1];
            if (v24 < v63 || v63 >= v24 && v47 < k[2]) {
              break;
            }
          }
        }
      }
      uint64_t m = a2;
      if (k < a2)
      {
        for (uint64_t m = a2 - 3; ; m -= 3)
        {
          if (v21 >= v48)
          {
            if (v48 < v21) {
              break;
            }
            unint64_t v53 = m[1];
            if (v24 >= v53 && (v53 < v24 || v47 >= m[2])) {
              break;
            }
          }
          unint64_t v54 = *(m - 3);
          unint64_t v48 = v54;
        }
      }
      if (k < m)
      {
        unint64_t v55 = *k;
        unint64_t v56 = *m;
        do
        {
          *uint64_t k = v56;
          unint64_t *m = v55;
          unint64_t v57 = k[1];
          k[1] = m[1];
          m[1] = v57;
          unint64_t v58 = k[2];
          k[2] = m[2];
          m[2] = v58;
          while (1)
          {
            unint64_t v59 = k[3];
            k += 3;
            unint64_t v55 = v59;
            if (v21 < v59) {
              break;
            }
            if (v55 >= v21)
            {
              unint64_t v60 = k[1];
              if (v24 < v60 || v60 >= v24 && v47 < k[2]) {
                break;
              }
            }
          }
          do
          {
            do
            {
              unint64_t v61 = *(m - 3);
              m -= 3;
              unint64_t v56 = v61;
            }
            while (v21 < v61);
            if (v56 < v21) {
              break;
            }
            unint64_t v62 = m[1];
          }
          while (v24 < v62 || v62 >= v24 && v47 < m[2]);
        }
        while (k < m);
      }
      BOOL v4 = k - 3 >= v9;
      BOOL v5 = k - 3 == v9;
      if (k - 3 != v9)
      {
        *double v9 = *(k - 3);
        v9[1] = *(k - 2);
        v9[2] = *(k - 1);
      }
      a4 = 0;
      *(k - 3) = v21;
      *(k - 2) = v24;
      *(k - 1) = v47;
    }
  }
  char v71 = k + 3;
  BOOL v73 = k == a2 || v71 == a2;
  if ((a4 & 1) == 0)
  {
    if (v73) {
      return result;
    }
    while (1)
    {
      long long v107 = v9;
      double v9 = v71;
      unint64_t v108 = v107[3];
      unint64_t v109 = *v107;
      if (v108 < *v107) {
        break;
      }
      if (v109 >= v108)
      {
        unint64_t v110 = v107[4];
        unint64_t v111 = v107[1];
        if (v110 < v111 || v111 >= v110 && v107[5] < v107[2]) {
          goto LABEL_200;
        }
      }
LABEL_207:
      char v71 = v9 + 3;
      if (v9 + 3 == a2) {
        return result;
      }
    }
    unint64_t v110 = v107[4];
LABEL_200:
    unint64_t v112 = v107[5];
    do
    {
      do
      {
        unsigned int v113 = v107;
        unint64_t v114 = v109;
        unint64_t v115 = *(v107 - 3);
        v107 -= 3;
        unint64_t v109 = v115;
        unint64_t v116 = v107[4];
        unint64_t v117 = v107[5];
        v107[6] = v114;
        v107[7] = v116;
        v107[8] = v117;
      }
      while (v108 < v115);
      if (v109 < v108) {
        break;
      }
      unint64_t v118 = *(v113 - 2);
    }
    while (v110 < v118 || v118 >= v110 && v112 < *(v113 - 1));
    *unsigned int v113 = v108;
    v113[1] = v110;
    v113[2] = v112;
    goto LABEL_207;
  }
  if (v73) {
    return result;
  }
  uint64_t v74 = 0;
  uint64_t v75 = k;
  while (2)
  {
    uint64_t v76 = v75;
    uint64_t v75 = v71;
    unint64_t v77 = v76[3];
    unint64_t v78 = *v76;
    if (v77 >= *v76)
    {
      if (v78 < v77) {
        goto LABEL_155;
      }
      unint64_t v79 = v76[4];
      unint64_t v80 = v76[1];
      if (v79 >= v80 && (v80 < v79 || v76[5] >= v76[2])) {
        goto LABEL_155;
      }
    }
    else
    {
      unint64_t v79 = v76[4];
    }
    unint64_t v81 = v76[5];
    v76[3] = v78;
    v75[1] = v76[1];
    v75[2] = v76[2];
    uint64_t v82 = k;
    if (v76 == k) {
      goto LABEL_154;
    }
    uint64_t v83 = v74;
    while (2)
    {
      unint64_t v84 = *(unint64_t *)((char *)k + v83 - 24);
      if (v77 < v84)
      {
        unint64_t v85 = *(unint64_t *)((char *)k + v83 - 16);
        goto LABEL_151;
      }
      if (v84 < v77) {
        break;
      }
      unint64_t v85 = *(unint64_t *)((char *)k + v83 - 16);
      if (v79 < v85) {
        goto LABEL_151;
      }
      if (v85 >= v79)
      {
        uint64_t v82 = (unint64_t *)((char *)k + v83);
        __n128 result = *(unint64_t *)((char *)k + v83 - 8);
        if (v81 >= result) {
          goto LABEL_154;
        }
LABEL_151:
        v76 -= 3;
        id v86 = (unint64_t *)((char *)k + v83);
        unint64_t *v86 = v84;
        v86[1] = v85;
        v86[2] = *(unint64_t *)((char *)k + v83 - 8);
        v83 -= 24;
        if (!v83)
        {
          uint64_t v82 = k;
          goto LABEL_154;
        }
        continue;
      }
      break;
    }
    uint64_t v82 = v76;
LABEL_154:
    *uint64_t v82 = v77;
    v82[1] = v79;
    v82[2] = v81;
LABEL_155:
    char v71 = v75 + 3;
    v74 += 24;
    if (v75 + 3 != a2) {
      continue;
    }
    return result;
  }
}

unint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(unint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *result;
  if (*a2 < *result || v4 >= v3 && ((unint64_t v29 = a2[1], v30 = result[1], v29 < v30) || v30 >= v29 && a2[2] < result[2]))
  {
    unint64_t v5 = *a3;
    if (*a3 < v3 || v3 >= v5 && ((v19 = a3[1], unint64_t v20 = a2[1], v19 < v20) || v20 >= v19 && a3[2] < a2[2]))
    {
      *__n128 result = v5;
      *a3 = v4;
      unint64_t v6 = result[1];
      result[1] = a3[1];
      a3[1] = v6;
      double v7 = (uint64_t *)(result + 2);
    }
    else
    {
      *__n128 result = v3;
      *a2 = v4;
      unint64_t v21 = result[1];
      result[1] = a2[1];
      a2[1] = v21;
      double v7 = (uint64_t *)(a2 + 2);
      unint64_t v22 = result[2];
      result[2] = a2[2];
      a2[2] = v22;
      unint64_t v23 = *a3;
      unint64_t v24 = *a2;
      if (*a3 >= *a2)
      {
        if (v24 < v23) {
          return result;
        }
        unint64_t v25 = a3[1];
        unint64_t v26 = a2[1];
        if (v25 >= v26 && (v26 < v25 || a3[2] >= v22)) {
          return result;
        }
      }
      *a2 = v23;
      *a3 = v24;
      unint64_t v27 = a2[1];
      a2[1] = a3[1];
      a3[1] = v27;
    }
    unint64_t v13 = (uint64_t *)(a3 + 2);
    goto LABEL_27;
  }
  unint64_t v8 = *a3;
  if (*a3 < v3 || v3 >= v8 && ((unint64_t v9 = a3[1], v10 = a2[1], v9 < v10) || v10 >= v9 && a3[2] < a2[2]))
  {
    *a2 = v8;
    *a3 = v3;
    unint64_t v11 = a2[1];
    a2[1] = a3[1];
    a3[1] = v11;
    unint64_t v13 = (uint64_t *)(a2 + 2);
    unint64_t v12 = a2[2];
    a2[2] = a3[2];
    a3[2] = v12;
    unint64_t v14 = *a2;
    unint64_t v15 = *result;
    if (*a2 < *result || v15 >= v14 && ((unint64_t v16 = a2[1], v17 = result[1], v16 < v17) || v17 >= v16 && *v13 < result[2]))
    {
      *__n128 result = v14;
      *a2 = v15;
      unint64_t v18 = result[1];
      result[1] = a2[1];
      a2[1] = v18;
      double v7 = (uint64_t *)(result + 2);
LABEL_27:
      uint64_t v28 = *v7;
      *double v7 = *v13;
      *unint64_t v13 = v28;
    }
  }
  return result;
}

unint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  __n128 result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(a1, a2, a3);
  unint64_t v9 = *a4;
  unint64_t v10 = *a3;
  if (*a4 < *a3 || v10 >= v9 && ((unint64_t v11 = a4[1], v12 = a3[1], v11 < v12) || v12 >= v11 && a4[2] < a3[2]))
  {
    *a3 = v9;
    *a4 = v10;
    unint64_t v13 = a3[1];
    a3[1] = a4[1];
    a4[1] = v13;
    unint64_t v14 = a3[2];
    a3[2] = a4[2];
    a4[2] = v14;
    unint64_t v15 = *a3;
    unint64_t v16 = *a2;
    if (*a3 < *a2 || v16 >= v15 && ((v17 = a3[1], unint64_t v18 = a2[1], v17 < v18) || v18 >= v17 && a3[2] < a2[2]))
    {
      *a2 = v15;
      *a3 = v16;
      unint64_t v19 = a2[1];
      a2[1] = a3[1];
      a3[1] = v19;
      unint64_t v20 = a2[2];
      a2[2] = a3[2];
      a3[2] = v20;
      unint64_t v21 = *a2;
      unint64_t v22 = *a1;
      if (*a2 < *a1 || v22 >= v21 && ((unint64_t v23 = a2[1], v24 = a1[1], v23 < v24) || v24 >= v23 && a2[2] < a1[2]))
      {
        *a1 = v21;
        *a2 = v22;
        unint64_t v25 = a1[1];
        a1[1] = a2[1];
        a2[1] = v25;
        unint64_t v26 = a1[2];
        a1[2] = a2[2];
        a2[2] = v26;
      }
    }
  }
  return result;
}

unint64_t *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  __n128 result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(a1, a2, a3, a4);
  unint64_t v11 = *a5;
  unint64_t v12 = *a4;
  if (*a5 < *a4 || v12 >= v11 && ((unint64_t v33 = a5[1], v34 = a4[1], v33 < v34) || v34 >= v33 && a5[2] < a4[2]))
  {
    *a4 = v11;
    *a5 = v12;
    unint64_t v13 = a4[1];
    a4[1] = a5[1];
    a5[1] = v13;
    unint64_t v14 = a4[2];
    a4[2] = a5[2];
    a5[2] = v14;
    unint64_t v15 = *a4;
    unint64_t v16 = *a3;
    if (*a4 < *a3 || v16 >= v15 && ((v17 = a4[1], unint64_t v18 = a3[1], v17 < v18) || v18 >= v17 && a4[2] < a3[2]))
    {
      *a3 = v15;
      *a4 = v16;
      unint64_t v19 = a3[1];
      a3[1] = a4[1];
      a4[1] = v19;
      unint64_t v20 = a3[2];
      a3[2] = a4[2];
      a4[2] = v20;
      unint64_t v21 = *a3;
      unint64_t v22 = *a2;
      if (*a3 < *a2 || v22 >= v21 && ((unint64_t v23 = a3[1], v24 = a2[1], v23 < v24) || v24 >= v23 && a3[2] < a2[2]))
      {
        *a2 = v21;
        *a3 = v22;
        unint64_t v25 = a2[1];
        a2[1] = a3[1];
        a3[1] = v25;
        unint64_t v26 = a2[2];
        a2[2] = a3[2];
        a3[2] = v26;
        unint64_t v27 = *a2;
        unint64_t v28 = *a1;
        if (*a2 < *a1 || v28 >= v27 && ((unint64_t v29 = a2[1], v30 = a1[1], v29 < v30) || v30 >= v29 && a2[2] < a1[2]))
        {
          *a1 = v27;
          *a2 = v28;
          unint64_t v31 = a1[1];
          a1[1] = a2[1];
          a2[1] = v31;
          unint64_t v32 = a1[2];
          a1[2] = a2[2];
          a2[2] = v32;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(unint64_t *a1, unint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      unint64_t v6 = *(a2 - 3);
      unint64_t v7 = *a1;
      if (v6 < *a1 || v7 >= v6 && ((v26 = *(a2 - 2), unint64_t v27 = a1[1], v26 < v27) || v27 >= v26 && *(a2 - 1) < a1[2]))
      {
        *a1 = v6;
        *(a2 - 3) = v7;
        unint64_t v8 = a1[1];
        a1[1] = *(a2 - 2);
        *(a2 - 2) = v8;
        unint64_t v9 = a1[2];
        a1[2] = *(a2 - 1);
        *(a2 - 1) = v9;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(a1, a1 + 3, a2 - 3);
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(a1, a1 + 3, a1 + 6, a2 - 3);
      return 1;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(a1, a1 + 3, a1 + 6, a1 + 9, a2 - 3);
      return 1;
    default:
      unint64_t v10 = a1 + 6;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>(a1, a1 + 3, a1 + 6);
      unint64_t v11 = a1 + 9;
      if (a1 + 9 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  do
  {
    unint64_t v14 = *v11;
    unint64_t v15 = *v10;
    if (*v11 >= *v10)
    {
      if (v15 < v14) {
        goto LABEL_27;
      }
      unint64_t v16 = v11[1];
      unint64_t v25 = v10[1];
      if (v16 >= v25 && (v25 < v16 || v11[2] >= v10[2])) {
        goto LABEL_27;
      }
    }
    else
    {
      unint64_t v16 = v11[1];
    }
    unint64_t v17 = v11[2];
    *unint64_t v11 = v15;
    v11[1] = v10[1];
    v11[2] = v10[2];
    unint64_t v18 = a1;
    if (v10 == a1) {
      goto LABEL_26;
    }
    uint64_t v19 = v12;
    while (1)
    {
      unint64_t v20 = (char *)a1 + v19;
      unint64_t v21 = *(unint64_t *)((char *)a1 + v19 + 24);
      if (v14 < v21)
      {
        unint64_t v22 = *((void *)v20 + 4);
        goto LABEL_17;
      }
      if (v21 < v14) {
        goto LABEL_24;
      }
      unint64_t v22 = *(unint64_t *)((char *)a1 + v19 + 32);
      if (v16 >= v22)
      {
        if (v22 < v16)
        {
LABEL_24:
          unint64_t v18 = v10;
          goto LABEL_26;
        }
        if (v17 >= *(unint64_t *)((char *)a1 + v19 + 40)) {
          break;
        }
      }
LABEL_17:
      v10 -= 3;
      *((void *)v20 + 6) = v21;
      unint64_t v23 = (char *)a1 + v19;
      uint64_t v24 = *(unint64_t *)((char *)a1 + v19 + 40);
      *((void *)v23 + 7) = v22;
      *((void *)v23 + 8) = v24;
      v19 -= 24;
      if (v19 == -48)
      {
        unint64_t v18 = a1;
        goto LABEL_26;
      }
    }
    unint64_t v18 = (unint64_t *)((char *)a1 + v19 + 48);
LABEL_26:
    *unint64_t v18 = v14;
    v18[1] = v16;
    v18[2] = v17;
    if (++v13 == 8) {
      return v11 + 3 == a2;
    }
LABEL_27:
    unint64_t v10 = v11;
    v12 += 24;
    v11 += 3;
  }
  while (v11 != a2);
  return 1;
}

void ___ZL25ProfilingTimingDataLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryP19NSMutableDictionaryS6_P14NSMutableArrayIP8NSNumberEjjjP21GTAGXPerfStateControl_block_invoke(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = [*(id *)(*(void *)(a1 + 72) + 8) defaultCommandQueue];
  [v2 setStatEnabled:1];
  unint64_t v3 = [v2 availableCounters];
  if (IsCounterAvailable(v3, @"SW_PBUsed"))
  {
    CFStringRef v4 = @"SW_PBUsed";
  }
  else
  {
    if (!IsCounterAvailable(v3, @"_fedf2c59")) {
      goto LABEL_6;
    }
    CFStringRef v4 = @"_fedf2c59";
  }
  [*(id *)(*(void *)(*(void *)(v1 + 64) + 8) + 40) addObject:v4];
LABEL_6:
  unint64_t v5 = [v2 subdivideCounterList:*(void *)(*(void *)(*(void *)(v1 + 64) + 8) + 40)];
  [v2 setStatEnabled:0];
  unint64_t v6 = *(void **)(v1 + 32);
  unint64_t v7 = CalculateFrameTimeLegacy(*(uint64_t **)(v1 + 72), *(id **)(v1 + 80), v5, *(_DWORD *)(v1 + 96), *(void **)(v1 + 40), 0, *(_DWORD *)(v1 + 100), *(void *)(v1 + 88));
  [v6 addDependency:v7];

  unint64_t v8 = *(void **)(v1 + 32);
  unint64_t v9 = CalculateFrameTimeLegacy(*(uint64_t **)(v1 + 72), *(id **)(v1 + 80), v5, *(_DWORD *)(v1 + 104), *(void **)(v1 + 40), 1, *(_DWORD *)(v1 + 100), *(void *)(v1 + 88));
  [v8 addDependency:v9];

  unint64_t v10 = CollectCounters(*(GTMTLReplayController **)(v1 + 72), *(GTMTLReplayOperationQueues **)(v1 + 80), *(NSArray **)(*(void *)(*(void *)(v1 + 64) + 8) + 40), v5, *(void **)(v1 + 48), (NSMutableDictionary *)*(unsigned int *)(v1 + 104), *(_DWORD *)(v1 + 100), *(void *)(v1 + 88), v38);
  unint64_t v11 = *(void **)(v1 + 48);
  uint64_t v12 = (NSArray *)*(id *)(*(void *)(*(void *)(v1 + 64) + 8) + 40);
  unint64_t v53 = _NSConcreteStackBlock;
  uint64_t v54 = 3221225472;
  unint64_t v55 = ___ZL17TimeDataOperationP7NSArrayP19NSMutableDictionaryP26GTMTLReplayOperationQueues_block_invoke;
  unint64_t v56 = &unk_7451D8;
  unint64_t v57 = v12;
  id v58 = v11;
  int v13 = v12;
  id v14 = v58;
  unint64_t v15 = +[NSBlockOperation blockOperationWithBlock:&v53];

  [v15 addDependency:v10];
  [*(id *)(*(void *)(v1 + 80) + 8) addOperation:v15];
  [*(id *)(v1 + 32) addDependency:v15];
  uint64_t v16 = *(void *)(v1 + 72);
  unint64_t v17 = *(void **)(v1 + 56);
  int32x2_t v18 = *(int32x2_t *)(v1 + 100);
  long long v49 = *(_OWORD *)(v1 + 80);
  id v45 = *(id *)(*(void *)(*(void *)(v1 + 64) + 8) + 40);
  uint64_t v19 = v5;
  id v44 = v17;
  uint64_t v46 = v16;
  unint64_t v50 = [*(id *)(v16 + 8) defaultCommandQueue];
  unint64_t v20 = [(NSArray *)v19 count];
  unint64_t v51 = v19;
  id v52 = [objc_alloc((Class)NSMutableArray) initWithCapacity:v20];
  if (v20)
  {
    unint64_t v21 = v20;
    do
    {
      unint64_t v22 = +[NSMutableData dataWithCapacity:0x10000];
      [v52 addObject:v22];

      --v21;
    }
    while (v21);
  }
  unint64_t v23 = &send_ptr;
  v70[0] = _NSConcreteStackBlock;
  v70[1] = 3221225472;
  void v70[2] = ___ZL21CollectBlitSplitTimesP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke;
  v70[3] = &unk_746080;
  id v24 = v45;
  id v71 = v24;
  id v48 = v52;
  id v72 = v48;
  id v43 = v44;
  id v73 = v43;
  uint64_t v25 = +[NSBlockOperation blockOperationWithBlock:v70];
  unint64_t v26 = (void *)v25;
  if (v20)
  {
    id v39 = v24;
    uint64_t v40 = v1;
    unint64_t v27 = v20;
    unint64_t v47 = (void *)v25;
    unint64_t v41 = v10;
    unint64_t v42 = v3;
    unint64_t v28 = 0;
    int32x2_t v29 = vrev64_s32(v18);
    uint64_t v30 = v49;
    do
    {
      unint64_t v31 = v23[187];
      v66[0] = _NSConcreteStackBlock;
      v66[1] = 3221225472;
      void v66[2] = ___ZL21CollectBlitSplitTimesP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke_2;
      v66[3] = &unk_745EA8;
      id v32 = v48;
      id v67 = v32;
      unint64_t v69 = v28;
      unint64_t v33 = v51;
      unint64_t v68 = v33;
      unint64_t v34 = [v31 blockOperationWithBlock:v66];
      [v47 addDependency:v34];
      unint64_t v35 = v23[187];
      unint64_t v53 = _NSConcreteStackBlock;
      uint64_t v54 = 3221225472;
      unint64_t v55 = ___ZL21CollectBlitSplitTimesP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke_3;
      unint64_t v56 = &unk_7468B0;
      uint64_t v61 = v46;
      unint64_t v57 = v33;
      unint64_t v62 = v28;
      uint64_t v63 = 12;
      id v58 = v32;
      id v36 = v34;
      id v59 = v36;
      int32x2_t v65 = v29;
      long long v64 = v49;
      id v60 = v50;
      unint64_t v37 = [v35 blockOperationWithBlock:&v53];
      [v37 setQueuePriority:-8];
      [*(id *)v49 addOperation:v37];

      ++v28;
      unint64_t v23 = &send_ptr;
    }
    while (v27 != v28);
    unint64_t v3 = v42;
    unint64_t v10 = v41;
    uint64_t v1 = v40;
    unint64_t v26 = v47;
    id v24 = v39;
  }
  else
  {
    uint64_t v30 = v49;
  }
  [*(id *)(v30 + 8) addOperation:v26];

  [*(id *)(v1 + 32) addDependency:v26];
}

void sub_208A34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id IsCounterAvailable(NSArray *a1, NSString *a2)
{
  unint64_t v3 = a1;
  CFStringRef v4 = a2;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  unint64_t v5 = v3;
  id v6 = [(NSArray *)v5 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v11;
    while (2)
    {
      for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v11 != v7) {
          objc_enumerationMutation(v5);
        }
        if (-[NSString isEqualToString:](v4, "isEqualToString:", *(void *)(*((void *)&v10 + 1) + 8 * i), (void)v10))
        {
          id v6 = &def_1C1270 + 1;
          goto LABEL_11;
        }
      }
      id v6 = [(NSArray *)v5 countByEnumeratingWithState:&v10 objects:v14 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }
LABEL_11:

  return v6;
}

void sub_208CDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id CalculateFrameTimeLegacy(uint64_t *a1, id *a2, void *a3, int a4, void *a5, uint64_t a6, int a7, uint64_t a8)
{
  id v25 = a3;
  id v26 = a5;
  id v24 = [(id)a1[1] defaultCommandQueue];
  [v25 count];
  v43[0] = 0;
  v43[1] = v43;
  v43[2] = 0x4812000000;
  v43[3] = __Block_byref_object_copy__130;
  v43[4] = __Block_byref_object_dispose__131;
  v43[5] = &unk_4E231D;
  id v45 = 0;
  uint64_t v46 = 0;
  id v44 = 0;
  std::vector<std::tuple<unsigned long long,unsigned long long,unsigned long long>>::reserve(&v44, 0x80uLL);
  v39[0] = _NSConcreteStackBlock;
  v39[1] = 3221225472;
  v39[2] = ___ZL24CalculateFrameTimeLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yjP14NSMutableArrayIP8NSNumberEmjP21GTAGXPerfStateControl_block_invoke;
  v39[3] = &unk_746960;
  unint64_t v41 = v43;
  id v15 = v26;
  id v40 = v15;
  uint64_t v42 = a6;
  uint64_t v16 = +[NSBlockOperation blockOperationWithBlock:v39];
  uint64_t v17 = *a1;
  v27[0] = _NSConcreteStackBlock;
  v27[1] = 3221225472;
  void v27[2] = ___ZL24CalculateFrameTimeLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yjP14NSMutableArrayIP8NSNumberEmjP21GTAGXPerfStateControl_block_invoke_2;
  v27[3] = &unk_744ED8;
  id v32 = a1;
  id v18 = v24;
  id v28 = v18;
  uint64_t v33 = a8;
  uint64_t v34 = 0;
  int v37 = a7;
  int v38 = a4;
  id v19 = v25;
  id v29 = v19;
  unint64_t v31 = v43;
  uint64_t v35 = v17;
  id v36 = a2;
  id v20 = v16;
  id v30 = v20;
  unint64_t v21 = +[NSBlockOperation blockOperationWithBlock:v27];
  [v21 setQueuePriority:-8];
  [*a2 addOperation:v21];
  id v22 = v20;

  _Block_object_dispose(v43, 8);
  if (v44)
  {
    id v45 = v44;
    operator delete(v44);
  }

  return v22;
}

void sub_208F80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30)
{
  _Block_object_dispose((const void *)(v31 - 176), 8);
  uint64_t v33 = *(void **)(v31 - 128);
  if (v33)
  {
    *(void *)(v31 - 120) = v33;
    operator delete(v33);
  }

  _Unwind_Resume(a1);
}

id CollectCounters(GTMTLReplayController *a1, GTMTLReplayOperationQueues *a2, NSArray *a3, NSArray *a4, void *a5, NSMutableDictionary *a6, int a7, uint64_t a8, GTAGXPerfStateControl *a9)
{
  int v32 = (int)a6;
  long long v13 = a3;
  id v14 = a4;
  id v15 = a5;
  uint64_t v31 = a1;
  int v37 = [a1->var1 defaultCommandQueue];
  uint64_t v16 = [(NSArray *)v14 count];
  id v17 = [objc_alloc((Class)NSMutableArray) initWithCapacity:v16];
  if (v16)
  {
    id v18 = v16;
    do
    {
      id v19 = +[NSMutableData dataWithCapacity:0x10000];
      [v17 addObject:v19];

      --v18;
    }
    while (v18);
  }
  v70[0] = 0;
  v70[1] = v70;
  void v70[2] = 0x2020000000;
  char v71 = 0;
  v68[0] = 0;
  v68[1] = v68;
  v68[2] = 0x2020000000;
  char v69 = 0;
  v66[0] = 0;
  v66[1] = v66;
  void v66[2] = 0x3032000000;
  v66[3] = __Block_byref_object_copy__74;
  void v66[4] = __Block_byref_object_dispose__75;
  id v67 = (id)objc_opt_new();
  v57[0] = _NSConcreteStackBlock;
  v57[1] = 3221225472;
  v57[2] = ___ZL15CollectCountersP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke;
  v57[3] = &unk_744F00;
  id v29 = v15;
  id v58 = v29;
  id v30 = v13;
  id v59 = v30;
  id v36 = v14;
  id v60 = v36;
  long long v64 = v66;
  int32x2_t v65 = v16;
  id v35 = v17;
  id v61 = v35;
  unint64_t v62 = v70;
  uint64_t v63 = v68;
  id v20 = +[NSBlockOperation blockOperationWithBlock:](NSBlockOperation, "blockOperationWithBlock:", v57, v15, v14, v13);
  if (v16)
  {
    unint64_t v21 = 0;
    do
    {
      id v22 = v16;
      v53[0] = _NSConcreteStackBlock;
      v53[1] = 3221225472;
      v53[2] = ___ZL15CollectCountersP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke_2;
      v53[3] = &unk_745EA8;
      id v23 = v35;
      id v54 = v23;
      unint64_t v56 = v21;
      id v24 = v36;
      unint64_t v55 = v24;
      id v25 = +[NSBlockOperation blockOperationWithBlock:v53];
      [v20 addDependency:v25];
      v38[0] = _NSConcreteStackBlock;
      v38[1] = 3221225472;
      void v38[2] = ___ZL15CollectCountersP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke_3;
      v38[3] = &unk_744F28;
      uint64_t v46 = v31;
      id v39 = v24;
      unint64_t v47 = v21;
      uint64_t v48 = 63;
      id v40 = v23;
      long long v49 = a2;
      id v26 = v25;
      int v51 = v32;
      int v52 = a7;
      id v41 = v26;
      uint64_t v50 = a8;
      id v42 = v37;
      id v43 = v66;
      id v44 = v70;
      id v45 = v68;
      unint64_t v27 = +[NSBlockOperation blockOperationWithBlock:v38];
      [v27 setQueuePriority:-8];
      uint64_t v16 = v22;
      [a2->var0 addOperation:v27];

      ++v21;
    }
    while (v22 != v21);
  }
  [a2->var1 addOperation:v20];

  _Block_object_dispose(v66, 8);
  _Block_object_dispose(v68, 8);
  _Block_object_dispose(v70, 8);

  return v20;
}

void sub_209470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50,void *a51,void *a52,void *a53)
{
  _Block_object_dispose((const void *)(v54 - 216), 8);
  _Block_object_dispose((const void *)(v54 - 168), 8);
  _Block_object_dispose((const void *)(v54 - 136), 8);

  _Unwind_Resume(a1);
}

void ___ZL17TimeDataOperationP7NSArrayP19NSMutableDictionaryP26GTMTLReplayOperationQueues_block_invoke(uint64_t a1)
{
  uint64_t v1 = [*(id *)(a1 + 32) lastObject];
  if ([@"SW_PBUsed" isEqualToString:v1])
  {

LABEL_4:
    uint64_t v4 = a1;
    unsigned int v38 = [*(id *)(a1 + 32) count] - 1;
    goto LABEL_6;
  }
  uint64_t v2 = [*(id *)(a1 + 32) lastObject];
  unsigned int v3 = [@"_fedf2c59" isEqualToString:v2];

  if (v3) {
    goto LABEL_4;
  }
  unsigned int v38 = -1;
  uint64_t v4 = a1;
LABEL_6:
  id v25 = [*(id *)(v4 + 40) objectForKeyedSubscript:@"AverageSamples"];
  int v32 = objc_opt_new();
  uint64_t v33 = objc_opt_new();
  uint64_t v34 = objc_opt_new();
  id v30 = objc_opt_new();
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  obuint64_t j = v25;
  id v23 = [obj countByEnumeratingWithState:&v49 objects:v55 count:16];
  if (v23)
  {
    uint64_t v24 = *(void *)v50;
    do
    {
      for (uint64_t i = 0; i != v23; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v50 != v24) {
          objc_enumerationMutation(obj);
        }
        unint64_t v5 = *(void **)(*((void *)&v49 + 1) + 8 * i);
        long long v45 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v48 = 0u;
        id v29 = v5;
        id v35 = [v29 countByEnumeratingWithState:&v45 objects:v54 count:16];
        if (v35)
        {
          uint64_t v31 = *(void *)v46;
          do
          {
            for (uint64_t j = 0; j != v35; uint64_t j = (char *)j + 1)
            {
              if (*(void *)v46 != v31) {
                objc_enumerationMutation(v29);
              }
              id v6 = *(void **)(*((void *)&v45 + 1) + 8 * (void)j);
              id v40 = objc_opt_new();
              id v39 = objc_opt_new();
              long long v43 = 0u;
              long long v44 = 0u;
              long long v41 = 0u;
              long long v42 = 0u;
              id v37 = v6;
              id v7 = [v37 countByEnumeratingWithState:&v41 objects:v53 count:16];
              if (v7)
              {
                uint64_t v8 = *(void *)v42;
                unint64_t v9 = &off_759960;
                long long v10 = &off_759960;
                do
                {
                  for (uint64_t k = 0; k != v7; uint64_t k = (char *)k + 1)
                  {
                    if (*(void *)v42 != v8) {
                      objc_enumerationMutation(v37);
                    }
                    long long v12 = *(void **)(*((void *)&v41 + 1) + 8 * (void)k);
                    long long v13 = [v12 objectAtIndexedSubscript:3];
                    id v14 = [v13 objectAtIndexedSubscript:0];
                    uint64_t v15 = +[NSNumber numberWithUnsignedLongLong:][v14 unsignedLongLongValue]+ [v10 unsignedLongLongValue];

                    long long v10 = (_UNKNOWN **)v15;
                    uint64_t v16 = [v12 objectAtIndexedSubscript:3];
                    id v17 = [v16 objectAtIndexedSubscript:0];
                    [v40 addObject:v17];

                    id v18 = [v12 objectAtIndexedSubscript:6];
                    id v19 = [v18 objectAtIndexedSubscript:0];
                    [v39 addObject:v19];

                    if (v38 != -1)
                    {
                      id v20 = [v12 objectAtIndexedSubscript:v38];
                      unint64_t v21 = [v20 objectAtIndexedSubscript:0];
                      uint64_t v22 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", (char *)[v21 unsignedLongLongValue]+ [v9 unsignedLongLongValue]);

                      unint64_t v9 = (_UNKNOWN **)v22;
                    }
                  }
                  id v7 = [v37 countByEnumeratingWithState:&v41 objects:v53 count:16];
                }
                while (v7);
              }
              else
              {
                unint64_t v9 = &off_759960;
                long long v10 = &off_759960;
              }

              [v32 addObject:v10];
              [v33 addObject:v40];
              [v34 addObject:v39];
              if (v38 != -1) {
                [v30 addObject:v9];
              }
            }
            id v35 = [v29 countByEnumeratingWithState:&v45 objects:v54 count:16];
          }
          while (v35);
        }
      }
      id v23 = [obj countByEnumeratingWithState:&v49 objects:v55 count:16];
    }
    while (v23);
  }

  [*(id *)(a1 + 40) setObject:v32 forKeyedSubscript:@"encoder time data"];
  [*(id *)(a1 + 40) setObject:v33 forKeyedSubscript:@"kick time data"];
  [*(id *)(a1 + 40) setObject:v34 forKeyedSubscript:@"kick cycle data"];
  if (v38 != -1) {
    [*(id *)(a1 + 40) setObject:v30 forKeyedSubscript:@"tilerParamBufBytesUsedArray"];
  }
}

void sub_209AF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *a19, void *a20,void *a21)
{
  _Unwind_Resume(a1);
}

void ___ZL21CollectBlitSplitTimesP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(void **)(a1 + 32);
  unsigned int v3 = [*(id *)(a1 + 40) objectAtIndexedSubscript:0];
  id v4 = v2;
  id v36 = v3;
  unint64_t v5 = (unint64_t)[v36 length];
  id v6 = [v4 count];
  id v7 = [v4 count];
  id v8 = v36;
  unint64_t v9 = (uint64_t *)[v8 bytes];
  unint64_t v10 = 8 * (void)v6;
  if (8 * (uint64_t)v6 <= v5)
  {
    id v14 = v9;
    id v33 = v8;
    uint64_t v34 = v1;
    id v35 = v4;
    long long v11 = 0;
    long long v12 = 0;
    unint64_t v15 = 0;
    uint64_t v16 = 0;
    unint64_t v17 = v5 / v10;
    if (v17 <= 1) {
      uint64_t v18 = 1;
    }
    else {
      uint64_t v18 = v17;
    }
    uint64_t v19 = -1;
    uint64_t v20 = -1;
    id v37 = v7;
    do
    {
      uint64_t v21 = v20;
      uint64_t v20 = *v14;
      if (*v14 == v21) {
        uint64_t v22 = v19;
      }
      else {
        uint64_t v22 = -1;
      }
      uint64_t v19 = v14[1];
      if (v19 == v22)
      {
        uint64_t v19 = v22;
      }
      else if ((unint64_t)v12 >= v15)
      {
        uint64_t v23 = (v12 - v11) >> 3;
        unint64_t v24 = v23 + 1;
        if ((unint64_t)(v23 + 1) >> 61) {
          abort();
        }
        if ((uint64_t)(v15 - (void)v11) >> 2 > v24) {
          unint64_t v24 = (uint64_t)(v15 - (void)v11) >> 2;
        }
        if (v15 - (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v25 = v24;
        }
        if (v25) {
          unint64_t v25 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v25);
        }
        else {
          uint64_t v26 = 0;
        }
        unint64_t v27 = (char *)(v25 + 8 * v23);
        *(void *)unint64_t v27 = 0;
        id v28 = v27 + 8;
        while (v12 != v11)
        {
          uint64_t v29 = *((void *)v12 - 1);
          v12 -= 8;
          *((void *)v27 - 1) = v29;
          v27 -= 8;
        }
        unint64_t v15 = v25 + 8 * v26;
        if (v11) {
          operator delete(v11);
        }
        long long v11 = v27;
        long long v12 = v28;
        id v7 = v37;
      }
      else
      {
        *(void *)long long v12 = 0;
        v12 += 8;
      }
      *((void *)v12 - 1) += v14[3];
      v14 += (uint64_t)v7;
      ++v16;
    }
    while (v16 != v18);
    long long v13 = v11;
    uint64_t v1 = v34;
    id v4 = v35;
    id v8 = v33;
  }
  else
  {
    long long v11 = 0;
    long long v12 = 0;
    long long v13 = 0;
  }
  id v38 = +[NSMutableArray arrayWithCapacity:(v12 - v13) >> 3];
  if (v11 != v12)
  {
    id v30 = v11;
    do
    {
      uint64_t v31 = +[NSNumber numberWithUnsignedLongLong:*(void *)v30];
      [v38 addObject:v31];

      v30 += 8;
    }
    while (v30 != v12);
  }
  if (v11) {
    operator delete(v11);
  }

  int v32 = +[NSDictionary dictionaryWithObject:v38 forKey:@"PerDrawNsecTimes"];
  [*(id *)(v1 + 48) setObject:v32 forKeyedSubscript:@"SplitEncoderData"];
}

void sub_209F00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id a14)
{
  _Unwind_Resume(a1);
}

void ___ZL21CollectBlitSplitTimesP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke_2(uint64_t a1)
{
  unsigned int v3 = [*(id *)(a1 + 32) objectAtIndexedSubscript:*(void *)(a1 + 48)];
  uint64_t v2 = [*(id *)(a1 + 40) objectAtIndexedSubscript:*(void *)(a1 + 48)];
  SortCounterData(v3, (uint64_t)[v2 count]);
}

void sub_20A004(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id ___ZL21CollectBlitSplitTimesP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke_3(uint64_t a1)
{
  uint64_t v2 = *(GTMTLReplayController **)(a1 + 64);
  unsigned int v3 = [*(id *)(a1 + 32) objectAtIndexedSubscript:*(void *)(a1 + 72)];
  CollectCounterData(v2, v3, *(void *)(a1 + 80), *(NSArray **)(a1 + 40), *(void *)(a1 + 72), *(GTMTLReplayOperationQueues **)(a1 + 88), *(NSOperation **)(a1 + 48), *(unsigned int *)(a1 + 104), 1, *(_DWORD *)(a1 + 108), *(GTAGXPerfStateControl **)(a1 + 96));

  [*(id *)(a1 + 56) finish];
  [*(id *)(a1 + 56) setStatEnabled:0];
  [*(id *)(a1 + 56) setGPUPriority:1];
  id v4 = *(void **)(*(void *)(a1 + 88) + 8);
  uint64_t v5 = *(void *)(a1 + 48);

  return [v4 addOperation:v5];
}

void sub_20A0D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CollectCounterData(GTMTLReplayController *a1, NSArray *a2, uint64_t a3, NSArray *a4, uint64_t a5, GTMTLReplayOperationQueues *a6, NSOperation *a7, uint64_t a8, BOOL a9, unsigned int a10, GTAGXPerfStateControl *a11)
{
  unint64_t v17 = a2;
  id v73 = a4;
  char v71 = a7;
  if (a9) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = 4;
  }
  NSUInteger v19 = [(NSArray *)v17 count];
  uint64_t v90 = a1;
  uint64_t v20 = [a1->var1 defaultCommandQueue];
  uint64_t v74 = v20;
  [v20 setStatEnabled:1];
  [v20 setGPUPriority:0];
  if (*((void *)a11 + 2) || *((_DWORD *)a11 + 1) == 1)
  {
    if (!GTAGXPerfStateControl::IsGPUPerformanceStateInduced(a11)) {
      GTAGXPerfStateControl::EnableConsistentGPUPerfState((uint64_t)a11, a10);
    }
    goto LABEL_8;
  }
  if (!a8)
  {
LABEL_8:
    [v20 setStatOptions:0x10000000];
    goto LABEL_9;
  }
  id v67 = [v90->var1 defaultDevice];
  if (objc_opt_respondsToSelector()) {
    [v67 setConsistentGPUPerfStateTo:a8];
  }
  [v20 setStatOptions:2415919104];

LABEL_9:
  [v20 setStatLocations:a3];
  [v20 requestCounters:v17 withIndex:a5];
  uint64_t v21 = [v20 counterInfo];
  NSUInteger v82 = v19;
  uint64_t v85 = v18;
  uint64_t v87 = a5;
  unint64_t v80 = a6;
  unsigned __int8 v102 = 0;
  std::vector<BOOL>::vector(v101, [(NSArray *)v17 count], &v102);
  long long v97 = 0u;
  long long v98 = 0u;
  long long v99 = 0u;
  long long v100 = 0u;
  uint64_t v22 = v17;
  id v23 = [(NSArray *)v22 countByEnumeratingWithState:&v97 objects:v103 count:16];
  if (v23)
  {
    int v24 = 0;
    uint64_t v25 = *(void *)v98;
    do
    {
      for (uint64_t i = 0; i != v23; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v98 != v25) {
          objc_enumerationMutation(v22);
        }
        unint64_t v27 = [v21 objectForKeyedSubscript:*(void *)(*((void *)&v97 + 1) + 8 * i)];
        id v28 = [v27 objectForKeyedSubscript:@"type"];

        unsigned int v29 = [v28 characterAtIndex:0];
        uint64_t v30 = (v24 + i) >> 6;
        uint64_t v31 = 1 << (v24 + i);
        if (v29 == 68) {
          uint64_t v32 = *((void *)v101[0] + v30) | v31;
        }
        else {
          uint64_t v32 = *((void *)v101[0] + v30) & ~v31;
        }
        *((void *)v101[0] + v30) = v32;
      }
      id v23 = [(NSArray *)v22 countByEnumeratingWithState:&v97 objects:v103 count:16];
      v24 += (int)i;
    }
    while (v23);
  }

  unint64_t v70 = [(NSArray *)v73 objectAtIndexedSubscript:v87];
  v91[0] = _NSConcreteStackBlock;
  v91[1] = 3321888768;
  _OWORD v91[2] = ___ZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS2_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControl_block_invoke;
  v91[3] = &unk_744F88;
  uint64_t v94 = v85;
  NSUInteger v95 = v82;
  std::vector<BOOL>::vector(__p, (uint64_t)v101);
  id v69 = v70;
  id v92 = v69;
  unint64_t v68 = v71;
  uint64_t v93 = v68;
  __p[3] = v80;
  [v74 addPerfSampleHandler:v91];
  id v33 = v90->var1;
  var0 = (uint64_t *)v90->var0;
  unint64_t v81 = v33;
  if (a9)
  {
    uint64_t v75 = var0[14];
    id v86 = [v33 defaultCommandQueue];
    p_var24 = &v90->var24;
    if (var0[13] + var0[12] > (unint64_t)v90->var24.var0)
    {
      uint64_t v83 = 0;
      uint64_t v35 = 0;
      uint64_t v78 = 0;
      uint64_t v76 = 0;
      uint64_t v72 = var0[15];
      do
      {
        uint64_t v37 = *(void *)(var0[15] + 24);
        uint64_t v38 = p_var24->var0;
        uint64_t v39 = v37 + (v38 << 6);
        long long v41 = (int *)(v39 + 8);
        int v40 = *(_DWORD *)(v39 + 8);
        if (GetFuncEnumConstructorType(v40) == 25)
        {
          [v86 setStatLocations:0];
          GTMTLReplayController_restoreCommandBuffer((uint64_t)v90, v37 + (v38 << 6));
          [v86 setStatLocations:a3];
          uint64_t v76 = *((unsigned int *)GTTraceFunc_argumentBytesWithMap((void *)(v37 + (v38 << 6)), *(unsigned __int8 *)(v37 + (v38 << 6) + 13), var0[2])+ 2);
          int v40 = *v41;
        }
        if (GetFuncEnumConstructorType(v40) == 21)
        {
          uint64_t v78 = *((unsigned int *)GTTraceFunc_argumentBytesWithMap((void *)(v37 + (v38 << 6)), *(unsigned __int8 *)(v37 + (v38 << 6) + 13), var0[2])+ 2);
          InclusiveRange = GroupBuilder_findInclusiveRange(*(_DWORD *)(v75 + 12), *(void **)(v75 + 24), p_var24->var0);
          unint64_t v43 = InclusiveRange[1];
          unint64_t v44 = v43 - *InclusiveRange;
          if (v43 > *InclusiveRange)
          {
            long long v45 = (int *)(*(void *)(v72 + 24) + (*InclusiveRange << 6) + 8);
            do
            {
              int v47 = *v45;
              v45 += 16;
              int v46 = v47;
              if (IsFuncEnumSampledBlitCall(v47) || IsFuncEnumSampledBlitCallAGX(v46)) {
                ++v35;
              }
              --v44;
            }
            while (v44);
          }
          uint64_t v48 = v35;
        }
        else
        {
          uint64_t v48 = v83;
        }
        GTMTLReplayController_updateCommandEncoder((uint64_t)v90, v39);
        int v49 = *v41;
        if (IsFuncEnumSampledBlitCall(*v41) || IsFuncEnumSampledBlitCallAGX(v49))
        {
          uint64_t v83 = v48 - 1;
          if (v48 && v35 != v48)
          {
            long long v50 = [v81 blitCommandEncoderForKey:v78];
            [v50 endEncoding];
            long long v51 = [v81 commandBufferForKey:v76];
            long long v52 = [v51 blitCommandEncoder];
            [v81 setBlitCommandEncoder:v52 forKey:v78];
          }
        }
        else
        {
          uint64_t v83 = v48;
        }
        GTMTLReplayController_defaultDispatchFunction((uint64_t)v90, v39);
        unint64_t v53 = p_var24->var0 + 1;
        p_var24->var0 = v53;
      }
      while (var0[13] + var0[12] > v53);
    }
  }
  else
  {
    id v86 = [v33 defaultCommandQueue];
    unsigned __int8 v102 = 0;
    uint64_t v54 = &v90->var24;
    for (unint64_t j = v90->var24.var0; var0[13] + var0[12] > j; v54->var0 = j)
    {
      uint64_t v57 = *(void *)(var0[15] + 24);
      uint64_t v58 = v54->var0;
      int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v57 + (v58 << 6) + 8));
      if (FuncEnumConstructorType == 25)
      {
        [v86 setStatLocations:0];
        GTMTLReplayController_restoreCommandBuffer((uint64_t)v90, v57 + (v58 << 6));
        [v86 setStatLocations:a3];
      }
      GTMTLReplayController_updateCommandEncoder((uint64_t)v90, v57 + (v58 << 6));
      DispatchFunction((id *)&v90->var0, v57 + (v58 << 6), &v102);
      if (FuncEnumConstructorType == 25)
      {
        uint64_t v60 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)(v57 + (v58 << 6)), *(unsigned __int8 *)(v57 + (v58 << 6) + 13), var0[2])+ 1);
        id v61 = [v90->var1 defaultCommandQueue];
        if ([v61 isStatEnabled])
        {
          int64_t v89 = [v90->var1 defaultDevice];
          unint64_t v79 = +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:70 width:16 height:16 mipmapped:0];
          [v79 setUsage:4];
          id v84 = [v89 newTextureWithDescriptor:v79];
          unint64_t v62 = +[MTLRenderPassDescriptor renderPassDescriptor];
          uint64_t v63 = objc_opt_new();
          [v63 setTexture:v84];
          [v63 setLoadAction:2];
          [v63 setStoreAction:1];
          [v63 setClearColor:0.0, 0.0, 0.0, 1.0];
          long long v64 = [v62 colorAttachments];
          [v64 setObject:v63 atIndexedSubscript:0];

          int32x2_t v65 = [v90->var1 commandBufferForKey:v60];
          unint64_t v66 = [v65 renderCommandEncoderWithDescriptor:v62];
          [v66 setLabel:@"GPUToolsCounterProfilingEmptyRender"];
          [v66 endEncoding];
        }
      }
      unint64_t j = v54->var0 + 1;
    }
  }

  if (__p[0]) {
    operator delete(__p[0]);
  }

  if (v101[0]) {
    operator delete(v101[0]);
  }
}

void sub_20A90C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p)
{
  _Unwind_Resume(a1);
}

void *std::vector<BOOL>::vector(void *a1, unint64_t a2, unsigned __int8 *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<BOOL>::__vallocate[abi:nn180100](a1, a2);
    int v6 = *a3;
    unint64_t v7 = a1[1];
    unint64_t v8 = v7 + a2;
    a1[1] = v7 + a2;
    if (v7)
    {
      unint64_t v9 = v8 - 1;
      if (((v8 - 1) ^ (v7 - 1)) < 0x40)
      {
LABEL_10:
        uint64_t v13 = *a1 + 8 * (v7 >> 6);
        int v14 = v7 & 0x3F;
        if (v6) {
          std::__fill_n[abi:nn180100]<true,std::vector<BOOL>>(&v13, a2);
        }
        else {
          std::__fill_n[abi:nn180100]<false,std::vector<BOOL>>((uint64_t)&v13, a2);
        }
        return a1;
      }
    }
    else
    {
      unint64_t v9 = v8 - 1;
    }
    unint64_t v10 = v9 >> 6;
    if (v8 >= 0x41) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = 0;
    }
    *(void *)(*a1 + 8 * v11) = 0;
    goto LABEL_10;
  }
  return a1;
}

void ___ZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS2_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControl_block_invoke(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a2;
  id v8 = a3;
  unint64_t v9 = v8;
  if (v8 && a4)
  {
    id v10 = [v8 copy];
    uint64_t v13 = _NSConcreteStackBlock;
    uint64_t v14 = 3321888768;
    unint64_t v15 = ___ZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS2_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControl_block_invoke_2;
    uint64_t v16 = &unk_744F50;
    uint64_t v19 = a4;
    long long v20 = *(_OWORD *)(a1 + 48);
    id v11 = v10;
    id v17 = v11;
    std::vector<BOOL>::vector(&__p, a1 + 64);
    id v18 = *(id *)(a1 + 32);
    long long v12 = +[NSBlockOperation blockOperationWithBlock:&v13];
    [*(id *)(a1 + 40) addDependency:v12, v13, v14, v15, v16];
    [*(id *)(*(void *)(a1 + 88) + 8) addOperation:v12];

    if (__p) {
      operator delete(__p);
    }
  }
}

void sub_20ACF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void *std::vector<BOOL>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (!v4) {
    return a1;
  }
  std::vector<BOOL>::__vallocate[abi:nn180100](a1, v4);
  uint64_t v5 = *(void **)a2;
  unint64_t v6 = *(void *)(a2 + 8);
  unint64_t v7 = a1[1];
  unint64_t v8 = v7 + v6;
  a1[1] = v7 + v6;
  if (v7)
  {
    unint64_t v9 = v8 - 1;
    if (((v8 - 1) ^ (v7 - 1)) < 0x40) {
      goto LABEL_10;
    }
  }
  else
  {
    unint64_t v9 = v8 - 1;
  }
  unint64_t v10 = v9 >> 6;
  if (v8 >= 0x41) {
    unint64_t v11 = v10;
  }
  else {
    unint64_t v11 = 0;
  }
  *(void *)(*a1 + 8 * v11) = 0;
LABEL_10:
  int v12 = v6 & 0x3F;
  if (v6 > 0x3F || (v6 & 0x3F) != 0)
  {
    int v13 = 0;
    int v14 = 0;
    unint64_t v15 = &v5[v6 >> 6];
    int v16 = v7 & 0x3F;
    id v17 = (uint64_t *)(*a1 + 8 * (v7 >> 6));
    do
    {
      uint64_t v18 = 1 << v16;
      if ((*v5 >> v14)) {
        uint64_t v19 = *v17 | v18;
      }
      else {
        uint64_t v19 = *v17 & ~v18;
      }
      uint64_t *v17 = v19;
      ++v14;
      v5 += v13 == 63;
      if (v13 == 63) {
        int v14 = 0;
      }
      v17 += v16 == 63;
      if (v16 == 63) {
        int v16 = 0;
      }
      else {
        ++v16;
      }
      int v13 = v14;
    }
    while (v5 != v15 || v12 != v14);
  }
  return a1;
}

void *std::vector<BOOL>::__vallocate[abi:nn180100](void *a1, uint64_t a2)
{
  if (a2 < 0) {
    abort();
  }
  BOOL result = std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(((unint64_t)(a2 - 1) >> 6) + 1);
  *a1 = result;
  a1[1] = 0;
  a1[2] = v4;
  return result;
}

void __destroy_helper_block_ea8_64c39_ZTSNSt3__16vectorIbNS_9allocatorIbEEEE(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 64);
  if (v1) {
    operator delete(v1);
  }
}

void *__copy_helper_block_ea8_64c39_ZTSNSt3__16vectorIbNS_9allocatorIbEEEE(uint64_t a1, uint64_t a2)
{
  return std::vector<BOOL>::vector((void *)(a1 + 64), a2 + 64);
}

void ___ZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS2_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControl_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 56);
  unint64_t v4 = *(void *)(a1 + 64);
  if (v4)
  {
    if (v4 >> 61) {
      abort();
    }
    uint64_t v5 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(*(void *)(a1 + 64));
    bzero(v5, 8 * v4);
    unint64_t v6 = &v5[8 * v4];
  }
  else
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
  }
  unint64_t v7 = 0;
  unint64_t v8 = v2 - v3;
  long long v50 = 0;
  long long v51 = 0;
  long long v52 = 0;
  if ((unint64_t)(v2 - v3) >= 2)
  {
    if (v8 >= 0x1555555555555556) {
      abort();
    }
    unint64_t v9 = v8 >> 1;
    unint64_t v10 = (char **)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v8 >> 1);
    uint64_t v11 = 3 * v9;
    long long v50 = v10;
    long long v52 = &v10[3 * v12];
    unint64_t v7 = (uint64_t *)&v10[3 * v9];
    uint64_t v13 = 8 * v11;
    do
    {
      void *v10 = 0;
      v10[1] = 0;
      v10[2] = 0;
      if (v6 != v5)
      {
        std::vector<NSString * {__strong}>::__vallocate[abi:nn180100](v10, (v6 - v5) >> 3);
        int v14 = v10[1];
        memmove(v14, v5, v6 - v5);
        v10[1] = &v14[8 * ((v6 - v5) >> 3)];
      }
      v10 += 3;
      v13 -= 24;
    }
    while (v13);
    long long v51 = v7;
  }
  if (v5) {
    operator delete(v5);
  }
  unint64_t v15 = (uint64_t *)v50;
  if (v50 != (char **)v7)
  {
    unint64_t v16 = *(void *)(a1 + 56);
    if (v16 < *(void *)(a1 + 48))
    {
      id v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 8 * v16;
      do
      {
        long long v20 = (char *)[*(id *)(a1 + 32) bytes];
        uint64_t v21 = *(void *)(a1 + 64);
        uint64_t v22 = &v20[8 * v21 * v16];
        if (*(void *)v22 != -1)
        {
          if (*((void *)v22 + 5) == 1)
          {
            id v17 = &v20[8 * v21 * v16];
          }
          else
          {
            if (v21)
            {
              unint64_t v23 = 0;
              uint64_t v24 = *(void *)(a1 + 72);
              uint64_t v25 = v50[3 * v18];
              do
              {
                uint64_t v26 = *(void *)&v20[8 * v23 + v21 * v19];
                if ((*(void *)(v24 + ((v23 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v23)) {
                  v26 -= *(void *)&v17[8 * v23];
                }
                *(void *)&v25[8 * v23++] = v26;
              }
              while (v21 != v23);
            }
            ++v18;
          }
        }
        ++v16;
        v19 += 8;
      }
      while (v16 < *(void *)(a1 + 48));
      unint64_t v15 = (uint64_t *)v50;
      unint64_t v7 = v51;
    }
    unint64_t v27 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (v7 - v15));
    if (v7 == v15) {
      uint64_t v28 = 0;
    }
    else {
      uint64_t v28 = v27;
    }
    _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEELb0EEEvT1_SJ_T0_NS_15iterator_traitsISJ_E15difference_typeEb(v15, v7, v28, 1);
    __int p = 0;
    __dst = 0;
    uint64_t v49 = 0;
    std::vector<unsigned long long>::reserve(&__p, ((*(void *)(a1 + 48) - *(void *)(a1 + 56)) >> 1) * *(void *)(a1 + 64));
    std::vector<unsigned long long>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned long long *>,std::__wrap_iter<unsigned long long *>>(&__p, (char *)__dst, *v50, v50[1], (v50[1] - *v50) >> 3);
    uint64_t v30 = v50;
    unsigned int v29 = v51;
    if (0xAAAAAAAAAAAAAAABLL * (((char *)v51 - (char *)v50) >> 3) >= 2)
    {
      unint64_t v31 = 1;
      do
      {
        uint64_t v32 = 0;
        id v33 = (char *)__p;
        int64_t v34 = ((unsigned char *)__dst - (unsigned char *)__p) >> 3;
        unint64_t v35 = *(void *)(a1 + 64);
        unint64_t v36 = v34 - v35;
        uint64_t v37 = v30[3 * v31];
        do
        {
          uint64_t v38 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v32];
          uint64_t v39 = *((void *)__p + v36 + v38);
          uint64_t v40 = *(void *)&v37[8 * v38];
        }
        while (v39 == v40 && v32++ != 3);
        if (v39 == v40)
        {
          *((void *)__p + v36 + 3) += *((void *)v37 + 3);
          if (v35 >= 7)
          {
            unint64_t v42 = 6 - v35;
            unint64_t v43 = &v33[8 * v34];
            unint64_t v44 = (uint64_t *)(v37 + 48);
            do
            {
              uint64_t v45 = *v44++;
              *(void *)&v43[8 * v42] += v45;
            }
            while (!__CFADD__(v42++, 1));
          }
        }
        else
        {
          std::vector<unsigned long long>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned long long *>,std::__wrap_iter<unsigned long long *>>(&__p, (char *)__dst, v37, v30[3 * v31 + 1], (v30[3 * v31 + 1] - v37) >> 3);
          uint64_t v30 = v50;
          unsigned int v29 = v51;
        }
        ++v31;
      }
      while (v31 < 0xAAAAAAAAAAAAAAABLL * (((char *)v29 - (char *)v30) >> 3));
    }
    [*(id *)(a1 + 40) appendBytes:__p length:(unsigned char *)__dst - (unsigned char *)__p];
    if (__p)
    {
      __dst = __p;
      operator delete(__p);
    }
  }
  __int p = &v50;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
}

void sub_20B25C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char *__p, char *a10, uint64_t a11, char a12)
{
  if (__p)
  {
    a10 = __p;
    operator delete(__p);
  }
  __int p = &a12;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_72c39_ZTSNSt3__16vectorIbNS_9allocatorIbEEEE(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 72);
  if (v1) {
    operator delete(v1);
  }
}

void *__copy_helper_block_ea8_72c39_ZTSNSt3__16vectorIbNS_9allocatorIbEEEE(uint64_t a1, uint64_t a2)
{
  return std::vector<BOOL>::vector((void *)(a1 + 72), a2 + 72);
}

void _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEELb0EEEvT1_SJ_T0_NS_15iterator_traitsISJ_E15difference_typeEb(uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
LABEL_1:
  uint64_t v198 = a2 - 3;
  unint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    uint64_t v11 = (char *)a2 - (char *)v10;
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * (a2 - v10);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          uint64_t v101 = 0;
          uint64_t v102 = *v198;
          uint64_t v103 = *v10;
          break;
        case 3uLL:
          _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_(v10, v10 + 3, v198);
          return;
        case 4uLL:
          _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEvT1_SJ_SJ_SJ_T0_(v10, v10 + 3, v10 + 6, v198);
          return;
        case 5uLL:
          _ZNSt3__124__sort5_maybe_branchlessB8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEELi0EEEvT1_SJ_SJ_SJ_SJ_T0_(v10, v10 + 3, v10 + 6, v10 + 9, v198);
          return;
        default:
          JUMPOUT(0);
      }
      while (1)
      {
        uint64_t v104 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v101];
        unint64_t v105 = *(void *)(v102 + 8 * v104);
        unint64_t v106 = *(void *)(v103 + 8 * v104);
        if (v105 != v106) {
          break;
        }
        if (++v101 == 4) {
          return;
        }
      }
      if (v105 < v106)
      {
        uint64_t *v10 = v102;
        *(a2 - 3) = v103;
        uint64_t v177 = v10[1];
        v10[1] = *(a2 - 2);
        *(a2 - 2) = v177;
        uint64_t v178 = v10[2];
        v10[2] = *(a2 - 1);
        *(a2 - 1) = v178;
      }
      return;
    }
    if (v11 <= 575)
    {
      long long v107 = v10 + 3;
      BOOL v109 = v10 == a2 || v107 == a2;
      if (a4)
      {
        if (!v109)
        {
          unint64_t v110 = v10;
          do
          {
            uint64_t v111 = 0;
            unint64_t v112 = v110;
            unint64_t v110 = v107;
            uint64_t v113 = v112[3];
            while (1)
            {
              uint64_t v114 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v111];
              unint64_t v115 = *(void *)(v113 + 8 * v114);
              unint64_t v116 = *(void *)(*v112 + 8 * v114);
              if (v115 != v116) {
                break;
              }
              if (++v111 == 4) {
                goto LABEL_159;
              }
            }
            if (v115 < v116)
            {
              long long v117 = *((_OWORD *)v112 + 2);
              *long long v107 = 0;
              v107[1] = 0;
              unint64_t v118 = v107;
              v107[2] = 0;
              while (1)
              {
                int64_t v119 = v118;
                unint64_t v118 = v112;
                *(_OWORD *)int64_t v119 = *(_OWORD *)v112;
                v119[2] = v112[2];
                *unint64_t v112 = 0;
                v112[1] = 0;
                void v112[2] = 0;
                if (v112 == v10) {
                  break;
                }
                uint64_t v120 = 0;
                v112 -= 3;
                while (1)
                {
                  uint64_t v121 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v120];
                  unint64_t v122 = *(void *)(v113 + 8 * v121);
                  unint64_t v123 = *(void *)(*(v118 - 3) + 8 * v121);
                  if (v122 != v123) {
                    break;
                  }
                  if (++v120 == 4) {
                    goto LABEL_156;
                  }
                }
                if (v122 >= v123) {
                  goto LABEL_156;
                }
              }
              unint64_t v118 = v10;
LABEL_156:
              uint64_t v124 = (void *)*v118;
              if (*v118)
              {
                v118[1] = (uint64_t)v124;
                long long v199 = v117;
                operator delete(v124);
                long long v117 = v199;
              }
              *unint64_t v118 = v113;
              *(_OWORD *)(v118 + 1) = v117;
            }
LABEL_159:
            long long v107 = v110 + 3;
          }
          while (v110 + 3 != a2);
        }
      }
      else if (!v109)
      {
        do
        {
          uint64_t v179 = 0;
          id v180 = a1;
          a1 = v107;
          uint64_t v181 = v180[3];
          while (1)
          {
            uint64_t v182 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v179];
            unint64_t v183 = *(void *)(v181 + 8 * v182);
            unint64_t v184 = *(void *)(*v180 + 8 * v182);
            if (v183 != v184) {
              break;
            }
            if (++v179 == 4) {
              goto LABEL_238;
            }
          }
          if (v183 < v184)
          {
            long long v185 = *((_OWORD *)v180 + 2);
            *a1 = 0;
            a1[1] = 0;
            id v186 = a1;
            a1[2] = 0;
            do
            {
              uint64_t v187 = 0;
              unsigned int v188 = v186;
              id v186 = v180;
              *(_OWORD *)unsigned int v188 = *(_OWORD *)v180;
              v188[2] = v180[2];
              *id v180 = 0;
              v180[1] = 0;
              v180[2] = 0;
              uint64_t v190 = *(v180 - 3);
              v180 -= 3;
              uint64_t v189 = v190;
              while (1)
              {
                uint64_t v191 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v187];
                unint64_t v192 = *(void *)(v181 + 8 * v191);
                unint64_t v193 = *(void *)(v189 + 8 * v191);
                if (v192 != v193) {
                  break;
                }
                if (++v187 == 4) {
                  goto LABEL_237;
                }
              }
            }
            while (v192 < v193);
LABEL_237:
            *id v186 = v181;
            *(_OWORD *)(v186 + 1) = v185;
          }
LABEL_238:
          long long v107 = a1 + 3;
        }
        while (a1 + 3 != a2);
      }
      return;
    }
    if (!a3) {
      break;
    }
    unint64_t v13 = v12 >> 1;
    int v14 = &v10[3 * (v12 >> 1)];
    if ((unint64_t)v11 >= 0xC01)
    {
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_(a1, &a1[3 * (v12 >> 1)], v198);
      uint64_t v15 = 3 * v13;
      unint64_t v16 = &a1[v15];
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_(a1 + 3, v16 - 3, a2 - 6);
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_(a1 + 6, &a1[v15 + 3], a2 - 9);
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_(v16 - 3, v14, &a1[v15 + 3]);
      long long v17 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)v14;
      *(_OWORD *)int v14 = v17;
      uint64_t v18 = a1[2];
      a1[2] = v16[2];
      v16[2] = v18;
    }
    else
    {
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_(&a1[3 * (v12 >> 1)], a1, v198);
    }
    --a3;
    uint64_t v22 = *a1;
    if (a4)
    {
LABEL_18:
      long long v32 = *(_OWORD *)(a1 + 1);
      *a1 = 0;
      a1[1] = 0;
      id v33 = a1;
      a1[2] = 0;
      do
      {
        uint64_t v34 = 0;
        unint64_t v35 = v33;
        uint64_t v37 = v33[3];
        v33 += 3;
        uint64_t v36 = v37;
        while (1)
        {
          uint64_t v38 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v34];
          unint64_t v39 = *(void *)(v36 + 8 * v38);
          unint64_t v40 = *(void *)(v22 + 8 * v38);
          if (v39 != v40) {
            break;
          }
          if (++v34 == 4) {
            goto LABEL_24;
          }
        }
      }
      while (v39 < v40);
LABEL_24:
      long long v41 = a2;
      if (v35 == a1)
      {
        long long v41 = a2;
        do
        {
          if (v33 >= v41) {
            break;
          }
          uint64_t v48 = 0;
          uint64_t v50 = *(v41 - 3);
          v41 -= 3;
          uint64_t v49 = v50;
          while (1)
          {
            uint64_t v51 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v48];
            unint64_t v52 = *(void *)(v49 + 8 * v51);
            unint64_t v53 = *(void *)(v22 + 8 * v51);
            if (v52 != v53) {
              break;
            }
            if (++v48 == 4) {
              goto LABEL_40;
            }
          }
          LOBYTE(v20) = v52 < v53;
LABEL_40:
          ;
        }
        while (v52 == v53 || (v20 & 1) == 0);
      }
      else
      {
        do
        {
          uint64_t v42 = 0;
          uint64_t v44 = *(v41 - 3);
          v41 -= 3;
          uint64_t v43 = v44;
          while (1)
          {
            uint64_t v45 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v42];
            unint64_t v46 = *(void *)(v43 + 8 * v45);
            unint64_t v47 = *(void *)(v22 + 8 * v45);
            if (v46 != v47) {
              break;
            }
            if (++v42 == 4) {
              goto LABEL_30;
            }
          }
          LOBYTE(v20) = v46 < v47;
LABEL_30:
          ;
        }
        while (v46 == v47 || (v20 & 1) == 0);
      }
      if (v33 >= v41)
      {
        unint64_t v10 = v33;
      }
      else
      {
        uint64_t v54 = *v41;
        unint64_t v10 = v33;
        unint64_t v55 = v41;
        do
        {
          uint64_t *v10 = v54;
          *unint64_t v55 = v36;
          uint64_t v56 = v10[1];
          v10[1] = v55[1];
          v55[1] = v56;
          uint64_t v57 = v10[2];
          v10[2] = v55[2];
          v55[2] = v57;
          do
          {
            uint64_t v58 = 0;
            uint64_t v59 = v10[3];
            v10 += 3;
            uint64_t v36 = v59;
            while (1)
            {
              uint64_t v60 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v58];
              unint64_t v61 = *(void *)(v36 + 8 * v60);
              unint64_t v62 = *(void *)(v22 + 8 * v60);
              if (v61 != v62) {
                break;
              }
              if (++v58 == 4) {
                goto LABEL_50;
              }
            }
          }
          while (v61 < v62);
          do
          {
LABEL_50:
            uint64_t v63 = 0;
            uint64_t v64 = *(v55 - 3);
            v55 -= 3;
            uint64_t v54 = v64;
            while (1)
            {
              uint64_t v65 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v63];
              unint64_t v66 = *(void *)(v54 + 8 * v65);
              unint64_t v67 = *(void *)(v22 + 8 * v65);
              if (v66 != v67) {
                break;
              }
              if (++v63 == 4) {
                goto LABEL_55;
              }
            }
            BOOL v21 = v66 < v67;
LABEL_55:
            ;
          }
          while (v66 == v67 || !v21);
        }
        while (v10 < v55);
      }
      unint64_t v68 = (void *)*a1;
      if (v10 - 3 == a1)
      {
        if (v68)
        {
          *(v10 - 2) = (uint64_t)v68;
          long long v195 = v32;
          operator delete(v68);
          long long v32 = v195;
        }
      }
      else
      {
        if (v68)
        {
          a1[1] = (uint64_t)v68;
          long long v194 = v32;
          operator delete(v68);
          long long v32 = v194;
          *a1 = 0;
          a1[1] = 0;
          a1[2] = 0;
        }
        *(_OWORD *)a1 = *(_OWORD *)(v10 - 3);
        a1[2] = *(v10 - 1);
        *(v10 - 3) = 0;
        *(v10 - 2) = 0;
        *(v10 - 1) = 0;
      }
      *(v10 - 3) = v22;
      *((_OWORD *)v10 - 1) = v32;
      if (v33 < v41) {
        goto LABEL_69;
      }
      BOOL v69 = _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEbT1_SJ_T0_(a1, v10 - 3);
      if (_ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEbT1_SJ_T0_(v10, a2))
      {
        a2 = v10 - 3;
        if (v69) {
          return;
        }
        goto LABEL_1;
      }
      if (!v69)
      {
LABEL_69:
        _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEELb0EEEvT1_SJ_T0_NS_15iterator_traitsISJ_E15difference_typeEb(a1, v10 - 3, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      uint64_t v23 = 0;
      while (1)
      {
        uint64_t v24 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v23];
        unint64_t v25 = *(void *)(*(a1 - 3) + 8 * v24);
        unint64_t v26 = *(void *)(v22 + 8 * v24);
        if (v25 != v26) {
          break;
        }
        if (++v23 == 4) {
          goto LABEL_13;
        }
      }
      if (v25 < v26) {
        goto LABEL_18;
      }
LABEL_13:
      uint64_t v27 = 0;
      long long v28 = *(_OWORD *)(a1 + 1);
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
      while (1)
      {
        uint64_t v29 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v27];
        unint64_t v30 = *(void *)(v22 + 8 * v29);
        unint64_t v31 = *(void *)(*v198 + 8 * v29);
        if (v30 != v31) {
          break;
        }
        if (++v27 == 4)
        {
          unint64_t v10 = a1;
          do
          {
LABEL_79:
            v10 += 3;
            if (v10 >= a2) {
              break;
            }
            uint64_t v76 = 0;
            while (1)
            {
              uint64_t v77 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v76];
              unint64_t v78 = *(void *)(v22 + 8 * v77);
              unint64_t v79 = *(void *)(*v10 + 8 * v77);
              if (v78 != v79) {
                break;
              }
              if (++v76 == 4) {
                goto LABEL_85;
              }
            }
            BOOL v19 = v78 < v79;
LABEL_85:
            ;
          }
          while (v78 == v79 || !v19);
          goto LABEL_87;
        }
      }
      unint64_t v10 = a1;
      if (v30 >= v31) {
        goto LABEL_79;
      }
      do
      {
        uint64_t v70 = 0;
        uint64_t v72 = v10[3];
        v10 += 3;
        uint64_t v71 = v72;
        while (1)
        {
          uint64_t v73 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v70];
          unint64_t v74 = *(void *)(v22 + 8 * v73);
          unint64_t v75 = *(void *)(v71 + 8 * v73);
          if (v74 != v75) {
            break;
          }
          if (++v70 == 4) {
            goto LABEL_76;
          }
        }
        BOOL v19 = v74 < v75;
LABEL_76:
        ;
      }
      while (v74 == v75 || !v19);
LABEL_87:
      unint64_t v80 = a2;
      if (v10 < a2)
      {
        unint64_t v80 = a2;
        do
        {
          uint64_t v81 = 0;
          uint64_t v83 = *(v80 - 3);
          v80 -= 3;
          uint64_t v82 = v83;
          while (1)
          {
            uint64_t v84 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v81];
            unint64_t v85 = *(void *)(v22 + 8 * v84);
            unint64_t v86 = *(void *)(v82 + 8 * v84);
            if (v85 != v86) {
              break;
            }
            if (++v81 == 4) {
              goto LABEL_94;
            }
          }
        }
        while (v85 < v86);
      }
LABEL_94:
      if (v10 < v80)
      {
        uint64_t v87 = *v10;
        uint64_t v88 = *v80;
        do
        {
          uint64_t *v10 = v88;
          uint64_t *v80 = v87;
          uint64_t v89 = v10[1];
          v10[1] = v80[1];
          v80[1] = v89;
          uint64_t v90 = v10[2];
          v10[2] = v80[2];
          _OWORD v80[2] = v90;
          do
          {
            uint64_t v91 = 0;
            uint64_t v92 = v10[3];
            v10 += 3;
            uint64_t v87 = v92;
            while (1)
            {
              uint64_t v93 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v91];
              unint64_t v94 = *(void *)(v22 + 8 * v93);
              unint64_t v95 = *(void *)(v87 + 8 * v93);
              if (v94 != v95) {
                break;
              }
              if (++v91 == 4) {
                goto LABEL_102;
              }
            }
            LOBYTE(v20) = v94 < v95;
LABEL_102:
            ;
          }
          while (v94 == v95 || (v20 & 1) == 0);
          do
          {
            uint64_t v96 = 0;
            uint64_t v97 = *(v80 - 3);
            v80 -= 3;
            uint64_t v88 = v97;
            while (1)
            {
              uint64_t v98 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v96];
              unint64_t v20 = *(void *)(v22 + 8 * v98);
              unint64_t v99 = *(void *)(v88 + 8 * v98);
              if (v20 != v99) {
                break;
              }
              if (++v96 == 4) {
                goto LABEL_109;
              }
            }
          }
          while (v20 < v99);
LABEL_109:
          ;
        }
        while (v10 < v80);
      }
      long long v100 = (void *)*a1;
      BOOL v4 = v10 - 3 >= a1;
      BOOL v5 = v10 - 3 == a1;
      if (v10 - 3 == a1)
      {
        if (v100)
        {
          *(v10 - 2) = (uint64_t)v100;
          long long v197 = v28;
          operator delete(v100);
          long long v28 = v197;
        }
      }
      else
      {
        if (v100)
        {
          a1[1] = (uint64_t)v100;
          long long v196 = v28;
          operator delete(v100);
          long long v28 = v196;
          *a1 = 0;
          a1[1] = 0;
          a1[2] = 0;
        }
        *(_OWORD *)a1 = *(_OWORD *)(v10 - 3);
        a1[2] = *(v10 - 1);
        *(v10 - 3) = 0;
        *(v10 - 2) = 0;
        *(v10 - 1) = 0;
      }
      a4 = 0;
      *(v10 - 3) = v22;
      *((_OWORD *)v10 - 1) = v28;
    }
  }
  if (v10 != a2)
  {
    int64_t v125 = (v12 - 2) >> 1;
    int64_t v126 = v125;
    do
    {
      int64_t v127 = v126;
      if (v125 < v126) {
        goto LABEL_192;
      }
      uint64_t v128 = (2 * v126) | 1;
      unint64_t v129 = &v10[3 * v128];
      if (2 * v127 + 2 < (uint64_t)v12)
      {
        uint64_t v130 = 0;
        while (1)
        {
          uint64_t v131 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v130];
          unint64_t v132 = *(void *)(*v129 + 8 * v131);
          unint64_t v133 = *(void *)(v129[3] + 8 * v131);
          if (v132 != v133) {
            break;
          }
          if (++v130 == 4) {
            goto LABEL_171;
          }
        }
        if (v132 < v133)
        {
          v129 += 3;
          uint64_t v128 = 2 * v127 + 2;
        }
      }
LABEL_171:
      uint64_t v134 = 0;
      unint64_t v135 = &v10[3 * v127];
      uint64_t v136 = *v135;
      while (1)
      {
        uint64_t v137 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v134];
        unint64_t v138 = *(void *)(*v129 + 8 * v137);
        unint64_t v139 = *(void *)(v136 + 8 * v137);
        if (v138 != v139) {
          break;
        }
        if (++v134 == 4) {
          goto LABEL_176;
        }
      }
      if (v138 < v139) {
        goto LABEL_192;
      }
LABEL_176:
      long long v140 = *(_OWORD *)&v10[3 * v127 + 1];
      *unint64_t v135 = 0;
      v135[1] = 0;
      v135[2] = 0;
LABEL_177:
      do
      {
        unint64_t v141 = v129;
        *(_OWORD *)unint64_t v135 = *(_OWORD *)v129;
        v135[2] = v129[2];
        *unint64_t v129 = 0;
        v129[1] = 0;
        v129[2] = 0;
        if (v125 < v128) {
          break;
        }
        uint64_t v142 = (2 * v128) | 1;
        unint64_t v129 = &v10[3 * v142];
        uint64_t v128 = 2 * v128 + 2;
        if (v128 >= (uint64_t)v12)
        {
LABEL_182:
          uint64_t v128 = v142;
        }
        else
        {
          uint64_t v143 = 0;
          while (1)
          {
            uint64_t v144 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v143];
            unint64_t v145 = *(void *)(*v129 + 8 * v144);
            unint64_t v146 = *(void *)(v129[3] + 8 * v144);
            if (v145 != v146) {
              break;
            }
            if (++v143 == 4) {
              goto LABEL_182;
            }
          }
          if (v145 >= v146) {
            uint64_t v128 = v142;
          }
          else {
            v129 += 3;
          }
        }
        uint64_t v147 = 0;
        while (1)
        {
          uint64_t v148 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v147];
          unint64_t v149 = *(void *)(*v129 + 8 * v148);
          unint64_t v150 = *(void *)(v136 + 8 * v148);
          if (v149 != v150) {
            break;
          }
          if (++v147 == 4)
          {
            unint64_t v135 = v141;
            goto LABEL_177;
          }
        }
        unint64_t v135 = v141;
      }
      while (v149 >= v150);
      *unint64_t v141 = v136;
      *(_OWORD *)(v141 + 1) = v140;
LABEL_192:
      int64_t v126 = v127 - 1;
    }
    while (v127);
    int64_t v151 = v11 / 0x18uLL;
    while (2)
    {
      uint64_t v152 = 0;
      uint64_t v154 = *v10;
      uint64_t v153 = v10[1];
      uint64_t v155 = v10[2];
      v10[1] = 0;
      v10[2] = 0;
      uint64_t v156 = v10;
      uint64_t *v10 = 0;
      do
      {
        id v157 = v156;
        v156 += 3 * v152 + 3;
        uint64_t v158 = 2 * v152;
        uint64_t v152 = (2 * v152) | 1;
        if (v158 + 2 < v151)
        {
          uint64_t v159 = 0;
          while (1)
          {
            uint64_t v160 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v159];
            unint64_t v161 = *(void *)(*v156 + 8 * v160);
            unint64_t v162 = *(void *)(v156[3] + 8 * v160);
            if (v161 != v162) {
              break;
            }
            if (++v159 == 4) {
              goto LABEL_202;
            }
          }
          if (v161 < v162)
          {
            v156 += 3;
            uint64_t v152 = v158 + 2;
          }
        }
LABEL_202:
        *(_OWORD *)id v157 = *(_OWORD *)v156;
        v157[2] = v156[2];
        *uint64_t v156 = 0;
        v156[1] = 0;
        v156[2] = 0;
      }
      while (v152 <= (uint64_t)((unint64_t)(v151 - 2) >> 1));
      if (v156 != a2 - 3)
      {
        *(_OWORD *)uint64_t v156 = *(_OWORD *)(a2 - 3);
        v156[2] = *(a2 - 1);
        *(a2 - 3) = v154;
        *(a2 - 2) = v153;
        *(a2 - 1) = v155;
        uint64_t v163 = (char *)v156 - (char *)v10 + 24;
        if (v163 >= 25)
        {
          uint64_t v164 = 0;
          unint64_t v165 = (v163 / 0x18uLL - 2) >> 1;
          uint64_t v166 = &v10[3 * v165];
          uint64_t v167 = *v156;
          while (1)
          {
            uint64_t v168 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v164];
            unint64_t v169 = *(void *)(*v166 + 8 * v168);
            unint64_t v170 = *(void *)(v167 + 8 * v168);
            if (v169 != v170) {
              break;
            }
            if (++v164 == 4) {
              goto LABEL_211;
            }
          }
          if (v169 < v170)
          {
            uint64_t v153 = v156[1];
            uint64_t v155 = v156[2];
            v156[1] = 0;
            v156[2] = 0;
            CFStringRef v172 = v156;
            *uint64_t v156 = 0;
            do
            {
              uint64_t v156 = v166;
              *(_OWORD *)CFStringRef v172 = *(_OWORD *)v166;
              v172[2] = v166[2];
              *uint64_t v166 = 0;
              v166[1] = 0;
              void v166[2] = 0;
              if (!v165) {
                break;
              }
              uint64_t v173 = 0;
              unint64_t v165 = (v165 - 1) >> 1;
              uint64_t v166 = &v10[3 * v165];
              while (1)
              {
                uint64_t v174 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v173];
                unint64_t v175 = *(void *)(*v166 + 8 * v174);
                unint64_t v176 = *(void *)(v167 + 8 * v174);
                if (v175 != v176) {
                  break;
                }
                if (++v173 == 4) {
                  goto LABEL_222;
                }
              }
              CFStringRef v172 = v156;
            }
            while (v175 < v176);
LABEL_222:
            *uint64_t v156 = v167;
LABEL_210:
            v156[1] = v153;
            v156[2] = v155;
          }
        }
LABEL_211:
        a2 -= 3;
        if (v151-- <= 2) {
          return;
        }
        continue;
      }
      break;
    }
    *uint64_t v156 = v154;
    goto LABEL_210;
  }
}

void std::vector<unsigned long long>::reserve(void **a1, unint64_t a2)
{
  if (a2 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      abort();
    }
    int64_t v3 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    BOOL v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(a2);
    BOOL v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    unint64_t v7 = &v4[8 * v6];
    unint64_t v8 = (char *)*a1;
    unint64_t v9 = (char *)a1[1];
    unint64_t v10 = v5;
    if (v9 != *a1)
    {
      unint64_t v10 = v5;
      do
      {
        uint64_t v11 = *((void *)v9 - 1);
        v9 -= 8;
        *((void *)v10 - 1) = v11;
        v10 -= 8;
      }
      while (v9 != v8);
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void std::vector<unsigned long long>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned long long *>,std::__wrap_iter<unsigned long long *>>(void **a1, char *__dst, char *__src, char *a4, uint64_t a5)
{
  if (a5 < 1) {
    return;
  }
  uint64_t v6 = __src;
  unint64_t v9 = a1 + 2;
  unint64_t v10 = a1[2];
  unint64_t v11 = (unint64_t)a1[1];
  if (a5 > (uint64_t)&v10[-v11] >> 3)
  {
    unint64_t v12 = *a1;
    unint64_t v13 = a5 + ((uint64_t)(v11 - (void)*a1) >> 3);
    if (v13 >> 61) {
      abort();
    }
    uint64_t v14 = (__dst - v12) >> 3;
    uint64_t v15 = v10 - v12;
    if (v15 >> 2 > v13) {
      unint64_t v13 = v15 >> 2;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v16 = v13;
    }
    __p[4] = v9;
    if (v16) {
      unint64_t v16 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v16);
    }
    else {
      uint64_t v17 = 0;
    }
    uint64_t v27 = (void *)(v16 + 8 * v14);
    __p[0] = (void *)v16;
    __p[1] = v27;
    __p[3] = (void *)(v16 + 8 * v17);
    uint64_t v28 = 8 * a5;
    uint64_t v29 = &v27[a5];
    do
    {
      uint64_t v30 = *(void *)v6;
      v6 += 8;
      *v27++ = v30;
      v28 -= 8;
    }
    while (v28);
    __p[2] = v29;
    std::vector<unsigned long long>::__swap_out_circular_buffer(a1, (uint64_t)__p, __dst);
    if (__p[0]) {
      operator delete(__p[0]);
    }
    return;
  }
  uint64_t v18 = v11 - (void)__dst;
  uint64_t v19 = (uint64_t)(v11 - (void)__dst) >> 3;
  if (v19 >= a5)
  {
    unint64_t v20 = &__src[8 * a5];
    uint64_t v22 = (char *)a1[1];
LABEL_17:
    uint64_t v23 = &__dst[8 * a5];
    uint64_t v24 = &v22[-8 * a5];
    unint64_t v25 = v22;
    if ((unint64_t)v24 < v11)
    {
      unint64_t v25 = v22;
      do
      {
        uint64_t v26 = *(void *)v24;
        v24 += 8;
        *(void *)unint64_t v25 = v26;
        v25 += 8;
      }
      while ((unint64_t)v24 < v11);
    }
    a1[1] = v25;
    if (v22 != v23) {
      memmove(&v22[-8 * ((v22 - v23) >> 3)], __dst, v22 - v23);
    }
    if (v20 != v6)
    {
      memmove(__dst, v6, v20 - v6);
    }
    return;
  }
  unint64_t v20 = &__src[8 * v19];
  int64_t v21 = a4 - v20;
  if (a4 != v20) {
    memmove(a1[1], &__src[8 * v19], a4 - v20);
  }
  uint64_t v22 = (char *)(v11 + v21);
  a1[1] = (void *)(v11 + v21);
  if (v18 >= 1) {
    goto LABEL_17;
  }
}

char *std::vector<unsigned long long>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  BOOL v5 = *(char **)(a2 + 8);
  uint64_t v6 = (char *)*a1;
  unint64_t v7 = v5;
  if (*a1 != __src)
  {
    unint64_t v8 = __src;
    unint64_t v7 = *(char **)(a2 + 8);
    do
    {
      uint64_t v9 = *((void *)v8 - 1);
      v8 -= 8;
      *((void *)v7 - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  unint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    unint64_t v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  unint64_t v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  uint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

uint64_t *_ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = *a2;
  uint64_t v5 = *result;
  while (1)
  {
    uint64_t v6 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v3];
    unint64_t v7 = *(void *)(v4 + 8 * v6);
    unint64_t v8 = *(void *)(v5 + 8 * v6);
    if (v7 != v8) {
      break;
    }
    if (++v3 == 4) {
      goto LABEL_10;
    }
  }
  if (v7 >= v8)
  {
LABEL_10:
    uint64_t v14 = 0;
    uint64_t v15 = *a3;
    while (1)
    {
      uint64_t v16 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v14];
      unint64_t v17 = *(void *)(v15 + 8 * v16);
      unint64_t v18 = *(void *)(v4 + 8 * v16);
      if (v17 != v18) {
        break;
      }
      if (++v14 == 4) {
        return result;
      }
    }
    if (v17 < v18)
    {
      uint64_t v19 = 0;
      *a2 = v15;
      *a3 = v4;
      uint64_t v20 = a2[1];
      a2[1] = a3[1];
      a3[1] = v20;
      uint64_t v22 = a2 + 2;
      uint64_t v21 = a2[2];
      a2[2] = a3[2];
      a3[2] = v21;
      uint64_t v23 = *a2;
      uint64_t v24 = *result;
      while (1)
      {
        uint64_t v25 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v19];
        unint64_t v26 = *(void *)(v23 + 8 * v25);
        unint64_t v27 = *(void *)(v24 + 8 * v25);
        if (v26 != v27) {
          break;
        }
        if (++v19 == 4) {
          return result;
        }
      }
      if (v26 < v27)
      {
        *BOOL result = v23;
        *a2 = v24;
        uint64_t v39 = result[1];
        result[1] = a2[1];
        a2[1] = v39;
        uint64_t v29 = result + 2;
LABEL_30:
        uint64_t v41 = *v29;
        *uint64_t v29 = *v22;
        uint64_t *v22 = v41;
      }
    }
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = *a3;
    while (1)
    {
      uint64_t v11 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v9];
      unint64_t v12 = *(void *)(v10 + 8 * v11);
      unint64_t v13 = *(void *)(v4 + 8 * v11);
      if (v12 != v13) {
        break;
      }
      if (++v9 == 4) {
        goto LABEL_21;
      }
    }
    if (v12 < v13)
    {
      *BOOL result = v10;
      *a3 = v5;
      uint64_t v28 = result[1];
      result[1] = a3[1];
      a3[1] = v28;
      uint64_t v29 = result + 2;
LABEL_29:
      uint64_t v22 = a3 + 2;
      goto LABEL_30;
    }
LABEL_21:
    uint64_t v30 = 0;
    *BOOL result = v4;
    *a2 = v5;
    uint64_t v31 = result[1];
    result[1] = a2[1];
    uint64_t v29 = a2 + 2;
    uint64_t v32 = a2[2];
    a2[1] = v31;
    uint64_t v33 = result[2];
    result[2] = v32;
    a2[2] = v33;
    uint64_t v34 = *a3;
    uint64_t v35 = *a2;
    while (1)
    {
      uint64_t v36 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v30];
      unint64_t v37 = *(void *)(v34 + 8 * v36);
      unint64_t v38 = *(void *)(v35 + 8 * v36);
      if (v37 != v38) {
        break;
      }
      if (++v30 == 4) {
        return result;
      }
    }
    if (v37 < v38)
    {
      *a2 = v34;
      *a3 = v35;
      uint64_t v40 = a2[1];
      a2[1] = a3[1];
      a3[1] = v40;
      goto LABEL_29;
    }
  }
  return result;
}

uint64_t *_ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEvT1_SJ_SJ_SJ_T0_(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  BOOL result = _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_(a1, a2, a3);
  uint64_t v9 = 0;
  uint64_t v10 = *a4;
  uint64_t v11 = *a3;
  while (1)
  {
    uint64_t v12 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v9];
    unint64_t v13 = *(void *)(v10 + 8 * v12);
    unint64_t v14 = *(void *)(v11 + 8 * v12);
    if (v13 != v14) {
      break;
    }
    if (++v9 == 4) {
      return result;
    }
  }
  if (v13 < v14)
  {
    uint64_t v15 = 0;
    *a3 = v10;
    *a4 = v11;
    uint64_t v16 = a3[1];
    a3[1] = a4[1];
    a4[1] = v16;
    uint64_t v17 = a3[2];
    a3[2] = a4[2];
    a4[2] = v17;
    uint64_t v18 = *a3;
    uint64_t v19 = *a2;
    while (1)
    {
      uint64_t v20 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v15];
      unint64_t v21 = *(void *)(v18 + 8 * v20);
      unint64_t v22 = *(void *)(v19 + 8 * v20);
      if (v21 != v22) {
        break;
      }
      if (++v15 == 4) {
        return result;
      }
    }
    if (v21 < v22)
    {
      uint64_t v23 = 0;
      *a2 = v18;
      *a3 = v19;
      uint64_t v24 = a2[1];
      a2[1] = a3[1];
      a3[1] = v24;
      uint64_t v25 = a2[2];
      a2[2] = a3[2];
      a3[2] = v25;
      uint64_t v26 = *a2;
      uint64_t v27 = *a1;
      while (1)
      {
        uint64_t v28 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v23];
        unint64_t v29 = *(void *)(v26 + 8 * v28);
        unint64_t v30 = *(void *)(v27 + 8 * v28);
        if (v29 != v30) {
          break;
        }
        if (++v23 == 4) {
          return result;
        }
      }
      if (v29 < v30)
      {
        *a1 = v26;
        *a2 = v27;
        uint64_t v31 = a1[1];
        a1[1] = a2[1];
        a2[1] = v31;
        uint64_t v32 = a1[2];
        a1[2] = a2[2];
        a2[2] = v32;
      }
    }
  }
  return result;
}

uint64_t *_ZNSt3__124__sort5_maybe_branchlessB8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEELi0EEEvT1_SJ_SJ_SJ_SJ_T0_(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  BOOL result = _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEvT1_SJ_SJ_SJ_T0_(a1, a2, a3, a4);
  uint64_t v11 = 0;
  uint64_t v12 = *a5;
  uint64_t v13 = *a4;
  while (1)
  {
    uint64_t v14 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v11];
    unint64_t v15 = *(void *)(v12 + 8 * v14);
    unint64_t v16 = *(void *)(v13 + 8 * v14);
    if (v15 != v16) {
      break;
    }
    if (++v11 == 4) {
      return result;
    }
  }
  if (v15 < v16)
  {
    uint64_t v17 = 0;
    *a4 = v12;
    *a5 = v13;
    uint64_t v18 = a4[1];
    a4[1] = a5[1];
    a5[1] = v18;
    uint64_t v19 = a4[2];
    a4[2] = a5[2];
    a5[2] = v19;
    uint64_t v20 = *a4;
    uint64_t v21 = *a3;
    while (1)
    {
      uint64_t v22 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v17];
      unint64_t v23 = *(void *)(v20 + 8 * v22);
      unint64_t v24 = *(void *)(v21 + 8 * v22);
      if (v23 != v24) {
        break;
      }
      if (++v17 == 4) {
        return result;
      }
    }
    if (v23 < v24)
    {
      uint64_t v25 = 0;
      *a3 = v20;
      *a4 = v21;
      uint64_t v26 = a3[1];
      a3[1] = a4[1];
      a4[1] = v26;
      uint64_t v27 = a3[2];
      a3[2] = a4[2];
      a4[2] = v27;
      uint64_t v28 = *a3;
      uint64_t v29 = *a2;
      while (1)
      {
        uint64_t v30 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v25];
        unint64_t v31 = *(void *)(v28 + 8 * v30);
        unint64_t v32 = *(void *)(v29 + 8 * v30);
        if (v31 != v32) {
          break;
        }
        if (++v25 == 4) {
          return result;
        }
      }
      if (v31 < v32)
      {
        uint64_t v33 = 0;
        *a2 = v28;
        *a3 = v29;
        uint64_t v34 = a2[1];
        a2[1] = a3[1];
        a3[1] = v34;
        uint64_t v35 = a2[2];
        a2[2] = a3[2];
        a3[2] = v35;
        uint64_t v36 = *a2;
        uint64_t v37 = *a1;
        while (1)
        {
          uint64_t v38 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v33];
          unint64_t v39 = *(void *)(v36 + 8 * v38);
          unint64_t v40 = *(void *)(v37 + 8 * v38);
          if (v39 != v40) {
            break;
          }
          if (++v33 == 4) {
            return result;
          }
        }
        if (v39 < v40)
        {
          *a1 = v36;
          *a2 = v37;
          uint64_t v41 = a1[1];
          a1[1] = a2[1];
          a2[1] = v41;
          uint64_t v42 = a1[2];
          a1[2] = a2[2];
          a2[2] = v42;
        }
      }
    }
  }
  return result;
}

BOOL _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEbT1_SJ_T0_(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v6 = 0;
      uint64_t v7 = *(a2 - 3);
      uint64_t v8 = *a1;
      while (1)
      {
        uint64_t v9 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v6];
        unint64_t v10 = *(void *)(v7 + 8 * v9);
        unint64_t v11 = *(void *)(v8 + 8 * v9);
        if (v10 != v11) {
          break;
        }
        if (++v6 == 4) {
          return 1;
        }
      }
      if (v10 < v11)
      {
        *a1 = v7;
        *(a2 - 3) = v8;
        uint64_t v29 = a1[1];
        a1[1] = *(a2 - 2);
        *(a2 - 2) = v29;
        uint64_t v30 = a1[2];
        a1[2] = *(a2 - 1);
        *(a2 - 1) = v30;
      }
      return 1;
    case 3uLL:
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_(a1, a1 + 3, a2 - 3);
      return 1;
    case 4uLL:
      _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEvT1_SJ_SJ_SJ_T0_(a1, a1 + 3, a1 + 6, a2 - 3);
      return 1;
    case 5uLL:
      _ZNSt3__124__sort5_maybe_branchlessB8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEELi0EEEvT1_SJ_SJ_SJ_SJ_T0_(a1, a1 + 3, a1 + 6, a1 + 9, a2 - 3);
      return 1;
    default:
      uint64_t v12 = a1 + 6;
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_(a1, a1 + 3, a1 + 6);
      uint64_t v13 = a1 + 9;
      if (a1 + 9 == a2) {
        return 1;
      }
      int v14 = 0;
      break;
  }
  while (2)
  {
    uint64_t v15 = 0;
    uint64_t v16 = *v13;
    while (1)
    {
      uint64_t v17 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v15];
      unint64_t v18 = *(void *)(v16 + 8 * v17);
      unint64_t v19 = *(void *)(*v12 + 8 * v17);
      if (v18 != v19) {
        break;
      }
      if (++v15 == 4) {
        goto LABEL_25;
      }
    }
    if (v18 < v19)
    {
      long long v20 = *(_OWORD *)(v13 + 1);
      *uint64_t v13 = 0;
      v13[1] = 0;
      uint64_t v21 = v13;
      v13[2] = 0;
      while (1)
      {
        *(_OWORD *)uint64_t v21 = *(_OWORD *)v12;
        v21[2] = v12[2];
        uint64_t *v12 = 0;
        v12[1] = 0;
        v12[2] = 0;
        if (v12 == a1) {
          break;
        }
        uint64_t v21 = v12;
        uint64_t v22 = 0;
        uint64_t v24 = *(v12 - 3);
        v12 -= 3;
        uint64_t v23 = v24;
        while (1)
        {
          uint64_t v25 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v22];
          unint64_t v26 = *(void *)(v16 + 8 * v25);
          unint64_t v27 = *(void *)(v23 + 8 * v25);
          if (v26 != v27) {
            break;
          }
          if (++v22 == 4) {
            goto LABEL_22;
          }
        }
        if (v26 >= v27) {
          goto LABEL_22;
        }
      }
      uint64_t v21 = a1;
LABEL_22:
      uint64_t v28 = (void *)*v21;
      if (*v21)
      {
        v21[1] = (uint64_t)v28;
        long long v31 = v20;
        operator delete(v28);
        long long v20 = v31;
      }
      *uint64_t v21 = v16;
      *(_OWORD *)(v21 + 1) = v20;
      if (++v14 == 8) {
        return v13 + 3 == a2;
      }
    }
LABEL_25:
    uint64_t v12 = v13;
    v13 += 3;
    if (v13 != a2) {
      continue;
    }
    return 1;
  }
}

void *std::vector<unsigned long long>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<NSString * {__strong}>::__vallocate[abi:nn180100](a1, v5 >> 3);
    uint64_t v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

void SortCounterData(NSMutableData *a1, uint64_t a2)
{
  uint64_t v3 = a1;
  NSUInteger v4 = [(NSMutableData *)v3 length];
  int64_t v5 = v3;
  qsort([(NSMutableData *)v5 mutableBytes], v4 / (8 * a2), 8 * a2, (int (__cdecl *)(const void *, const void *))compareSampleData);
}

void sub_20CA94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t compareSampleData@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = 0;
  while (1)
  {
    uint64_t v4 = compareSampleData(void const*,void const*)::kCounterCompare[v3];
    unint64_t v5 = a1[v4];
    unint64_t v6 = a2[v4];
    if (v6 < v5) {
      LODWORD(a3) = 1;
    }
    a3 = v5 < v6 ? 0xFFFFFFFFLL : a3;
    if (v6 != v5) {
      break;
    }
    if (++v3 == 4) {
      return 0;
    }
  }
  return a3;
}

void ___ZL15CollectCountersP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 48);
  uint64_t v2 = *(void **)(a1 + 56);
  id v3 = *(id *)(a1 + 40);
  id v44 = v1;
  id v42 = v2;
  unint64_t v52 = (char *)[v44 count];
  uint64_t v4 = [v42 objectAtIndexedSubscript:0];
  unint64_t v5 = [v44 objectAtIndexedSubscript:0];
  unint64_t v54 = (unint64_t)[v4 length];
  id v6 = [v5 count];

  unint64_t v49 = (unint64_t)[v3 count];
  unint64_t v50 = 8 * (void)v6;
  unint64_t v46 = v54 / (8 * (uint64_t)v6);
  id v43 = +[NSMutableData dataWithLength:8 * v46 * 2 * v49];
  if (v52)
  {
    uint64_t v7 = 0;
    if (v46 <= 1) {
      unint64_t v8 = 1;
    }
    else {
      unint64_t v8 = v54 / (8 * (uint64_t)v6);
    }
    do
    {
      uint64_t v9 = [v44 objectAtIndexedSubscript:v7];
      id v10 = [v9 count];
      if (v10)
      {
        for (uint64_t i = 0; i != v10; uint64_t i = (char *)i + 1)
        {
          uint64_t v12 = [v9 objectAtIndexedSubscript:i];
          v60[(void)i] = [v3 indexOfObject:v12];
        }
      }
      id v13 = [v42 objectAtIndexedSubscript:v7];
      int v14 = (char *)[v13 bytes];
      uint64_t v15 = (char *)[v43 mutableBytes];
      if (v50 <= v54)
      {
        uint64_t v16 = 0;
        do
        {
          if (v10)
          {
            for (unint64_t j = 0; j != v10; unint64_t j = (char *)j + 1)
            {
              uint64_t v18 = v60[(void)j];
              if (v18 != 0x7FFFFFFFFFFFFFFFLL)
              {
                unint64_t v19 = &v15[16 * v18];
                *(void *)unint64_t v19 = *(void *)&v14[8 * (void)j];
                *((void *)v19 + 1) = *((void *)v14 + 6);
              }
            }
          }
          v14 += 8 * (void)v10;
          v15 += 16 * v49;
          ++v16;
        }
        while (v16 != v8);
      }

      ++v7;
    }
    while (v7 != v52);
  }
  uint64_t v45 = objc_opt_new();
  id v20 = v43;
  uint64_t v21 = [v20 bytes];
  id v39 = v20;
  uint64_t v22 = [v39 bytes];
  if (v50 <= v54)
  {
    uint64_t v48 = 0;
    unint64_t v53 = 0;
    unint64_t v55 = 0;
    if (v46 <= 1) {
      uint64_t v23 = 1;
    }
    else {
      uint64_t v23 = v46;
    }
    uint64_t v41 = v23;
    uint64_t v51 = v22 + 5;
    while (1)
    {
      unint64_t v47 = v22;
      if (*v22 == *v21)
      {
        if (v22[2] != v21[2])
        {

          unint64_t v55 = 0;
        }
        if (v53) {
          goto LABEL_29;
        }
      }
      else
      {

        unint64_t v55 = 0;
      }
      unint64_t v53 = +[NSMutableArray array];
      [v45 addObject:v53];
LABEL_29:
      if (!v55)
      {
        unint64_t v55 = +[NSMutableArray array];
        [v53 addObject:v55];
      }
      uint64_t v24 = +[NSMutableArray arrayWithCapacity:v49];
      [v55 addObject:v24];
      uint64_t v25 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", (char *)[v45 count] - 1);
      v60[0] = v25;
      v60[1] = &off_759978;
      unint64_t v26 = +[NSArray arrayWithObjects:v60 count:2];
      [v24 addObject:v26];

      unint64_t v27 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", (char *)[v53 count] - 1);
      v59[0] = v27;
      v59[1] = &off_759978;
      uint64_t v28 = +[NSArray arrayWithObjects:v59 count:2];
      [v24 addObject:v28];

      uint64_t v29 = v51;
      unint64_t v30 = v49 - 2;
      if (v49 > 2)
      {
        do
        {
          long long v31 = +[NSNumber numberWithUnsignedLongLong:*(v29 - 1)];
          v58[0] = v31;
          unint64_t v32 = +[NSNumber numberWithUnsignedLongLong:*v29];
          v58[1] = v32;
          uint64_t v33 = +[NSArray arrayWithObjects:v58 count:2];
          [v24 addObject:v33];

          v29 += 2;
          --v30;
        }
        while (v30);
      }

      uint64_t v21 = v47;
      uint64_t v22 = &v47[2 * v49];
      v51 += 2 * v49;
      if (++v48 == v41) {
        goto LABEL_34;
      }
    }
  }
  unint64_t v53 = 0;
  unint64_t v55 = 0;
LABEL_34:
  id v34 = v45;

  [*(id *)(a1 + 32) setObject:v34 forKeyedSubscript:@"AverageSamples"];
  [*(id *)(a1 + 32) setObject:*(void *)(a1 + 48) forKeyedSubscript:@"counterLists"];
  [*(id *)(a1 + 32) setObject:*(void *)(a1 + 40) forKeyedSubscript:@"counters"];
  uint64_t v35 = +[NSNumber numberWithUnsignedInteger:*(void *)(a1 + 88)];
  [*(id *)(a1 + 32) setObject:v35 forKeyedSubscript:@"numberOfPasses"];

  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24))
  {
    v56[0] = @"enabled";
    uint64_t v36 = +[NSNumber numberWithBool:1];
    v57[0] = v36;
    v56[1] = @"consistent";
    uint64_t v37 = +[NSNumber numberWithBool:*(unsigned __int8 *)(*(void *)(*(void *)(a1 + 72) + 8) + 24)];
    v57[1] = v37;
    v56[2] = @"level";
    v57[2] = *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
    uint64_t v38 = +[NSDictionary dictionaryWithObjects:v57 forKeys:v56 count:3];
    [*(id *)(a1 + 32) setObject:v38 forKeyedSubscript:@"Frame Consistent Perf Info"];
  }
  else
  {
    [*(id *)(a1 + 32) setObject:&off_759120 forKeyedSubscript:@"Frame Consistent Perf Info"];
  }
}

void sub_20D180(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL15CollectCountersP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke_2(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) objectAtIndexedSubscript:*(void *)(a1 + 48)];
  uint64_t v2 = [*(id *)(a1 + 40) objectAtIndexedSubscript:*(void *)(a1 + 48)];
  SortCounterData(v3, (uint64_t)[v2 count]);
}

void sub_20D364(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id ___ZL15CollectCountersP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke_3(uint64_t a1)
{
  GTMTLReplayController_prePlayForProfiling(*(void *)(a1 + 88));
  uint64_t v2 = *(GTMTLReplayController **)(a1 + 88);
  id v3 = [*(id *)(a1 + 32) objectAtIndexedSubscript:*(void *)(a1 + 96)];
  CollectCounterData(v2, v3, *(void *)(a1 + 104), *(NSArray **)(a1 + 40), *(void *)(a1 + 96), *(GTMTLReplayOperationQueues **)(a1 + 112), *(NSOperation **)(a1 + 48), *(unsigned int *)(a1 + 128), 0, *(_DWORD *)(a1 + 132), *(GTAGXPerfStateControl **)(a1 + 120));

  [*(id *)(a1 + 56) finish];
  [*(id *)(a1 + 56) setStatEnabled:0];
  [*(id *)(a1 + 56) setGPUPriority:1];
  uint64_t v4 = *(void *)(a1 + 120);
  if (*(void *)(v4 + 16) || *(_DWORD *)(v4 + 4) == 1)
  {
    unint64_t v5 = GTAGXPerfStateControl::ConsistentGPUPerfStateLevel((GTAGXPerfStateControl *)v4, 0);
    if (v5)
    {
      if ([*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) length])
      {
        uint64_t v6 = *(void *)(*(void *)(a1 + 72) + 8);
        if (*(unsigned char *)(v6 + 24))
        {
          uint64_t v7 = [v5 objectForKeyedSubscript:@"enabled"];
          *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = [v7 BOOLValue];
        }
        else
        {
          *(unsigned char *)(v6 + 24) = 0;
        }
        if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24))
        {
          *(unsigned char *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = 0;
          goto LABEL_13;
        }
        unint64_t v11 = [v5 objectForKeyedSubscript:@"consistent"];
        unsigned __int8 v12 = [v11 BOOLValue];
      }
      else
      {
        unint64_t v8 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
        uint64_t v9 = [v5 objectForKeyedSubscript:@"level"];
        [v8 setString:v9];

        id v10 = [v5 objectForKeyedSubscript:@"enabled"];
        *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = [v10 BOOLValue];

        unint64_t v11 = [v5 objectForKeyedSubscript:@"consistent"];
        unsigned __int8 v12 = [v11 BOOLValue];
      }
      *(unsigned char *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = v12;
    }
LABEL_13:

    uint64_t v4 = *(void *)(a1 + 120);
  }
  GTAGXPerfStateControl::DisableConsistentGPUPerfState((GTAGXPerfStateControl *)v4);
  id v13 = *(void **)(*(void *)(a1 + 112) + 8);
  uint64_t v14 = *(void *)(a1 + 48);

  return [v13 addOperation:v14];
}

void sub_20D594(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL24CalculateFrameTimeLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yjP14NSMutableArrayIP8NSNumberEmjP21GTAGXPerfStateControl_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8);
  unint64_t v3 = *(void *)(v2 + 48);
  uint64_t v4 = *(unint64_t **)(v2 + 56);
  unint64_t v5 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v4 - v3) >> 3));
  if (v4 == (unint64_t *)v3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v5;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *,false>(v3, v4, v6, 1);
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  unint64_t v8 = *(unint64_t **)(v7 + 48);
  uint64_t v9 = *(unint64_t **)(v7 + 56);
  if (v8 == v9)
  {
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    do
    {
      unint64_t v12 = *v8;
      unint64_t v13 = v8[1];
      v8 += 3;
      if (v11 <= v12) {
        unint64_t v11 = v12;
      }
      BOOL v14 = v13 >= v11;
      unint64_t v15 = v13 - v11;
      if (v13 > v11) {
        unint64_t v11 = v13;
      }
      if (!v14) {
        unint64_t v15 = 0;
      }
      v10 += v15;
    }
    while (v8 != v9);
  }
  id v16 = +[NSNumber numberWithUnsignedLongLong:v10];
  [*(id *)(a1 + 32) setObject:atIndexedSubscript:];
}

void sub_20D6A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id ___ZL24CalculateFrameTimeLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yjP14NSMutableArrayIP8NSNumberEmjP21GTAGXPerfStateControl_block_invoke_2(uint64_t a1)
{
  GTMTLReplayController_prePlayForProfiling(*(void *)(a1 + 64));
  [*(id *)(a1 + 32) setStatEnabled:1];
  [*(id *)(a1 + 32) isStatEnabled];
  [*(id *)(a1 + 32) setGPUPriority:0];
  uint64_t v2 = *(void *)(a1 + 72);
  if (*(void *)(v2 + 16) || *(_DWORD *)(v2 + 4) == 1)
  {
    if (!GTAGXPerfStateControl::IsGPUPerformanceStateInduced((GTAGXPerfStateControl *)v2)) {
      GTAGXPerfStateControl::EnableConsistentGPUPerfState(*(void *)(a1 + 72), *(unsigned int *)(a1 + 104));
    }
    [*(id *)(a1 + 32) setStatOptions:805306368];
  }
  else if (*(_DWORD *)(a1 + 108))
  {
    uint64_t v7 = [*(id *)(*(void *)(a1 + 64) + 8) defaultDevice];
    if (objc_opt_respondsToSelector()) {
      [v7 setConsistentGPUPerfStateTo:*(unsigned int *)(a1 + 108)];
    }
    [*(id *)(a1 + 32) setStatOptions:2952790016];
  }
  [*(id *)(a1 + 32) setStatLocations:*(void *)(a1 + 80)];
  unint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = [*(id *)(a1 + 40) objectAtIndexedSubscript:0];
  [v3 requestCounters:v4 withIndex:0];

  unint64_t v5 = *(void **)(a1 + 32);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = ___ZL24CalculateFrameTimeLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yjP14NSMutableArrayIP8NSNumberEmjP21GTAGXPerfStateControl_block_invoke_3;
  v8[3] = &unk_744EB0;
  v8[4] = *(void *)(a1 + 56);
  [v5 addPerfSampleHandler:v8];
  GTMTLReplayController_playTo(*(void *)(a1 + 64), *(void *)(*(void *)(a1 + 88) + 104) + *(void *)(*(void *)(a1 + 88) + 96));
  [*(id *)(a1 + 32) finish];
  [*(id *)(a1 + 32) setGPUPriority:1];
  [*(id *)(a1 + 32) setStatEnabled:0];
  GTAGXPerfStateControl::DisableConsistentGPUPerfState(*(GTAGXPerfStateControl **)(a1 + 72));
  return [*(id *)(*(void *)(a1 + 96) + 8) addOperation:*(void *)(a1 + 48)];
}

void sub_20D870(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL24CalculateFrameTimeLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yjP14NSMutableArrayIP8NSNumberEmjP21GTAGXPerfStateControl_block_invoke_3(uint64_t a1, void *a2, void *a3)
{
  id v26 = a2;
  id v5 = a3;
  uint64_t v6 = [v26 label];
  unsigned __int8 v7 = [v6 hasPrefix:@"com.apple.gputools.replay"];

  if ((v7 & 1) == 0)
  {
    [v26 GPUStartTime];
    double v9 = v8;
    [v26 GPUEndTime];
    unint64_t v10 = (unint64_t)(v9 * 1000000000.0);
    unint64_t v12 = (unint64_t)(v11 * 1000000000.0);
    unint64_t v13 = *(void **)(*(void *)(a1 + 32) + 8);
    BOOL v14 = (unint64_t *)v13[7];
    unint64_t v15 = v13[8];
    if ((unint64_t)v14 >= v15)
    {
      unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
      uint64_t v18 = (unint64_t *)v13[6];
      unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * (v14 - v18);
      unint64_t v20 = v19 + 1;
      if (v19 + 1 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v15 - (void)v18) >> 3);
      if (2 * v21 > v20) {
        unint64_t v20 = 2 * v21;
      }
      if (v21 < 0x555555555555555) {
        unint64_t v17 = v20;
      }
      if (v17)
      {
        unint64_t v17 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v17);
        uint64_t v18 = (unint64_t *)v13[6];
        BOOL v14 = (unint64_t *)v13[7];
      }
      else
      {
        uint64_t v22 = 0;
      }
      uint64_t v23 = (unint64_t *)(v17 + 24 * v19);
      unint64_t v24 = v17 + 24 * v22;
      *uint64_t v23 = v10;
      v23[1] = v12;
      v23[2] = (unint64_t)v26;
      id v16 = v23 + 3;
      if (v14 != v18)
      {
        do
        {
          long long v25 = *(_OWORD *)(v14 - 3);
          *(v23 - 1) = *(v14 - 1);
          *(_OWORD *)(v23 - 3) = v25;
          v23 -= 3;
          v14 -= 3;
        }
        while (v14 != v18);
        uint64_t v18 = (unint64_t *)v13[6];
      }
      v13[6] = v23;
      v13[7] = v16;
      v13[8] = v24;
      if (v18) {
        operator delete(v18);
      }
    }
    else
    {
      unint64_t *v14 = v10;
      v14[1] = v12;
      id v16 = v14 + 3;
      v14[2] = (unint64_t)v26;
    }
    v13[7] = v16;
  }
}

void sub_20DA44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL18PerformUSCSamplingP21GTMTLReplayControllerP12NSDictionary_block_invoke(uint64_t result)
{
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    double v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  unint64_t v10 = operator new(0x18uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  unint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    unint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_20DC8C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void ___ZL18PerformUSCSamplingP21GTMTLReplayControllerP12NSDictionary_block_invoke_2(id a1, void *a2, unint64_t a3)
{
}

void GTMTLReplayClient_embeddedDerivedCounterData(uint64_t a1, uint64_t a2, void *a3)
{
  id v3 = a3;
  double v9 = objc_opt_new();
  if (v3)
  {
    uint64_t v4 = [v3 objectForKeyedSubscript:@"profileCounters"];
    [v9 setObject:v4 forKeyedSubscript:@"profileCounters"];
  }
  else
  {
    id v5 = [*(id *)(a1 + 8) defaultDevice];
    uint64_t v4 = DYMTLReplayFrameProfiler_loadAnalysis(v5);

    [v9 addEntriesFromDictionary:v4];
  }

  unsigned int v11 = 0x7FFFFFFF;
  [v3 objectForKeyedSubscript:@"MetalPluginName"];
  if (objc_claimAutoreleasedReturnValue())
  {
    unint64_t v6 = [v3 objectForKeyedSubscript:@"gpuTarget"];
    unint64_t v7 = v6;
    if (v6) {
      unsigned int v11 = [v6 intValue];
    }
  }
  else
  {
    io_registry_entry_t IOAccelerator = GetIOAccelerator();
    GetMetalPluginName(IOAccelerator, &v11);
    objc_claimAutoreleasedReturnValue();
  }
  operator new();
}

void sub_20F730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, id *a18, uint64_t a19, void *a20,void *a21,void *a22,uint64_t a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,void *a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,_Unwind_Exception *exception_objecta,void *a43,void *__p,uint64_t a45,void *a46,id *a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a67, 8);
  STACK[0x2E0] = a17;
  std::vector<std::unordered_map<unsigned int,GTEncoderSampleIndexInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&STACK[0x2E0]);

  _Block_object_dispose(&STACK[0x220], 8);
  GRCInfo::~GRCInfo(a18);

  std::unique_ptr<GTAGXPerfStateControl>::reset[abi:nn180100](&a47);
  _Unwind_Resume(a1);
}

void ___ZL31CollectDerivedCounterDataLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryP21GTAGXPerfStateControl_block_invoke(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) objectForKeyedSubscript:@"profileCounters"];
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v4 = *(void **)(a1 + 40);
  id v5 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
  long long v24 = *(_OWORD *)(a1 + 64);
  id v6 = v2;
  id v23 = v5;
  v35[0] = @"MTLStatCommandBufferIndex";
  v35[1] = @"MTLStatEncoderIndex";
  unsigned int v35[2] = @"MTLStatCommandIndex";
  v35[3] = @"MTLStat_nSec";
  v35[4] = @"MTLStatDataMaster";
  v35[5] = @"MTLStatSampleLocation";
  v35[6] = @"MTLStatTotalGPUCycles";
  id v21 = v6;
  unint64_t v7 = +[NSArray arrayWithObjects:v35 count:7];
  uint8x8_t v8 = +[NSSet setWithArray:v7];
  double v9 = +[NSMutableArray arrayWithCapacity:[v7 count] + [v21 count]];
  uint64_t v22 = v4;
  [v9 addObjectsFromArray:v7];
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  id v10 = v21;
  id v11 = [v10 countByEnumeratingWithState:&v25 objects:v29 count:16];
  if (v11)
  {
    uint64_t v12 = *(void *)v26;
    do
    {
      for (uint64_t i = 0; i != v11; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v26 != v12) {
          objc_enumerationMutation(v10);
        }
        uint64_t v14 = *(void *)(*((void *)&v25 + 1) + 8 * i);
        if (([v8 containsObject:v14] & 1) == 0) {
          [v9 addObject:v14];
        }
      }
      id v11 = [v10 countByEnumeratingWithState:&v25 objects:v29 count:16];
    }
    while (v11);
  }

  unint64_t v15 = objc_opt_new();
  v29[0] = _NSConcreteStackBlock;
  v29[1] = 3221225472;
  v29[2] = ___ZL18DerivedCounterDataP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayP19NSMutableDictionaryjP21GTAGXPerfStateControl_block_invoke;
  v29[3] = &unk_7450B0;
  uint64_t v33 = v3;
  id v16 = v9;
  id v30 = v16;
  id v17 = v23;
  id v31 = v17;
  long long v34 = v24;
  id v18 = v15;
  id v32 = v18;
  unint64_t v19 = +[NSBlockOperation blockOperationWithBlock:v29];
  [v19 setQueuePriority:-8];
  [*(id *)v24 addOperation:v19];
  id v20 = v18;

  [v22 addDependency:v20];
  [*(id *)(*(void *)(a1 + 64) + 8) addOperation:*(void *)(a1 + 40)];
}

void sub_21007C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

id __Block_byref_object_copy__256(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(id *)(a2 + 64);
  id v4 = *(id *)(a2 + 72);
  uint64_t v5 = *(void *)(a2 + 80);
  id v6 = *(void **)(a2 + 88);
  *(void *)(a1 + 72) = v4;
  *(void *)(a1 + 80) = v5;
  *(void *)(a1 + 88) = v6;
  *(void *)(a1 + 96) = *(id *)(a2 + 96);
  id result = *(id *)(a2 + 104);
  *(void *)(a1 + 104) = result;
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  return result;
}

void __Block_byref_object_dispose__257(uint64_t a1)
{
}

__n128 __Block_byref_object_copy__262(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__263(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<std::unordered_map<unsigned int,GTEncoderSampleIndexInfo>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

void ___ZL28CollectDerivedCounterDataGRCP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryP21GTAGXPerfStateControl_block_invoke(uint64_t a1)
{
  GTMTLReplayController_prePlayForProfiling(*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 48));
  uint64_t v2 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v3 = *(unsigned int *)(a1 + 64);
  uint64_t v4 = *(unsigned int *)(a1 + 68);
  id v5 = *(id *)(a1 + 32);
  id v6 = [*(id *)(v2 + 64) firstObject];
  if (v6)
  {
    if (!v4)
    {
      if (IsGPUPerformanceStateInduced(*(void **)(*(void *)(v2 + 48) + 8)))
      {
        unint64_t v7 = [*(id *)(v2 + 64) firstObject];
        [v7 setOptions:&off_759198];
      }
      else
      {
        uint64_t v8 = *(unsigned int *)(v2 + 112);
        if (v8)
        {
          GTAGXPerfStateControl::EnableConsistentGPUPerfState(*(void *)(v2 + 56), v8);
        }
        else
        {
          v38[0] = @"DisableOverlap";
          v38[1] = @"LockGPUPerfState";
          v39[0] = &__kCFBooleanTrue;
          double v9 = +[NSNumber numberWithUnsignedInt:v3];
          v39[1] = v9;
          id v10 = +[NSDictionary dictionaryWithObjects:v39 forKeys:v38 count:2];
          id v11 = [*(id *)(v2 + 64) firstObject];
          [v11 setOptions:v10];
        }
      }
    }
    uint64_t v12 = [v5 objectForKeyedSubscript:@"passList"];
    float v13 = [v12 objectAtIndexedSubscript:v4];

    if (v13)
    {
      for (unint64_t i = 0; i < (unint64_t)[*(id *)(v2 + 72) count]; ++i)
      {
        unint64_t v15 = [*(id *)(v2 + 72) objectAtIndexedSubscript:i];
        id v16 = v15;
        if (!v4)
        {
          [v15 setOptions:0];
          if (([v16 requestTriggers:*(void *)(v2 + 88) firstErrorIndex:0] & 1) == 0)
          {
            uint64_t v17 = *(void *)(v2 + 88);
            id v18 = [v16 name];
            NSLog(@"Failed to set %@ Trigger for %@", v17, v18);
          }
        }
        unint64_t v19 = [v13 objectAtIndexedSubscript:i];
        if (![v19 count])
        {
          id v20 = *(id *)(v2 + 96);

          unint64_t v19 = v20;
        }
        unint64_t v37 = 0;
        if (([v16 requestCounters:v19 firstErrorIndex:&v37] & 1) == 0)
        {
          uint64_t v36 = v37;
          id v35 = [v19 count];
          unint64_t v29 = v37;
          id v30 = [v19 count];
          if (v29 >= (unint64_t)v30)
          {
            id v31 = &stru_7482F0;
          }
          else
          {
            long long v34 = [v19 objectAtIndexedSubscript:v37];
            id v31 = [v34 name];
          }
          uint64_t v33 = [v16 name];
          NSLog(@"Fail, error while requesting counter[%u/%lu] (%@) for source[%@] in pass[%u]", v36, v35, v31, v33, v4);

          if (v29 < (unint64_t)v30)
          {
          }
          NSLog(@"%@\n", v19);
          goto LABEL_34;
        }
        if (([v16 setEnabled:1] & 1) == 0)
        {
          id v32 = [v16 name];
          NSLog(@"Fail, error while enabling source[%@] in pass[%u]", v32, v4);

LABEL_34:
          goto LABEL_35;
        }
      }
      id v21 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 64) firstObject];
      unsigned __int8 v22 = [v21 startSampling];

      if (v22)
      {
        GRCInfo::ReplayForKickCounters((GTMTLReplayController **)(*(void *)(*(void *)(a1 + 48) + 8) + 48), (uint64_t *)(*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 48) + 40 * *(unsigned int *)(a1 + 68)));
        long long v24 = (id *)(*(void *)(*(void *)(a1 + 48) + 8) + 48);
        long long v25 = GRCInfo::DrainRawFrameData(v24);
        long long v26 = GRCInfo::PostProcessFrameData((uint64_t)v24, v25);

        if (v26) {
          [*(id *)(a1 + 40) addObject:v26];
        }

        long long v27 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 64) firstObject];
        [v27 stopSampling];

        if (*(_DWORD *)(a1 + 68) + 1 == *(_DWORD *)(a1 + 72))
        {
          GRCInfo::AddConsistencyInfo((GRCInfo *)(*(void *)(*(void *)(a1 + 48) + 8) + 48));
          long long v28 = *(GTAGXPerfStateControl **)(*(void *)(*(void *)(a1 + 48) + 8) + 56);
          GTAGXPerfStateControl::DisableConsistentGPUPerfState(v28);
        }
      }
    }
    else
    {
LABEL_35:
    }
  }
  else
  {
  }
}

void sub_2106C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*,false>(unint64_t result, unsigned int *a2, uint64_t a3, char a4)
{
  double v9 = (unsigned int *)result;
  while (2)
  {
    id v10 = a2 - 2;
    id v11 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          double v9 = v11;
          uint64_t v12 = (char *)a2 - (char *)v11;
          unint64_t v13 = ((char *)a2 - (char *)v11) >> 3;
          if (v5 || !v4)
          {
            switch(v13)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                unsigned int v71 = *(a2 - 2);
                BOOL v5 = v71 == *v11;
                BOOL v72 = v71 < *v11;
                if (v5) {
                  BOOL v72 = *(a2 - 1) < v11[1];
                }
                if (v72)
                {
                  int32x2_t v73 = *(int32x2_t *)v11;
                  *(void *)id v11 = *(void *)v10;
                  *(int32x2_t *)id v10 = v73;
                }
                break;
              case 3uLL:
                __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(v11, v11 + 2, a2 - 2);
                break;
              case 4uLL:
                __n128 result = (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(v11, v11 + 2, v11 + 4, a2 - 2);
                break;
              case 5uLL:
                __n128 result = (unint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(v11, v11 + 2, v11 + 4, v11 + 6, a2 - 2);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v12 <= 191)
          {
            unint64_t v74 = v11 + 2;
            BOOL v76 = v11 == a2 || v74 == a2;
            if (a4)
            {
              if (!v76)
              {
                uint64_t v77 = 0;
                unint64_t v78 = v11;
                do
                {
                  unsigned int v79 = v78[2];
                  unsigned int v80 = v78[3];
                  unsigned int v81 = *v78;
                  unsigned int v82 = v78[1];
                  unint64_t v78 = v74;
                  BOOL v83 = v80 < v82;
                  BOOL v5 = v79 == v81;
                  BOOL v84 = v79 < v81;
                  if (!v5) {
                    BOOL v83 = v84;
                  }
                  if (v83)
                  {
                    uint64_t v85 = *(void *)v78;
                    uint64_t v86 = HIDWORD(*(void *)v78);
                    uint64_t v87 = v77;
                    while (1)
                    {
                      uint64_t v88 = (char *)v11 + v87;
                      *(void *)((char *)v11 + v87 + 8) = *(void *)((char *)v11 + v87);
                      if (!v87) {
                        break;
                      }
                      unsigned int v89 = *((_DWORD *)v88 - 2);
                      BOOL v90 = *((_DWORD *)v88 - 1) > v86;
                      BOOL v5 = v89 == v85;
                      BOOL v91 = v89 > v85;
                      if (!v5) {
                        BOOL v90 = v91;
                      }
                      v87 -= 8;
                      if (!v90)
                      {
                        uint64_t v92 = (unsigned int *)((char *)v11 + v87 + 8);
                        goto LABEL_110;
                      }
                    }
                    uint64_t v92 = v11;
LABEL_110:
                    *(void *)uint64_t v92 = v85;
                  }
                  unint64_t v74 = v78 + 2;
                  v77 += 8;
                }
                while (v78 + 2 != a2);
              }
            }
            else if (!v76)
            {
              do
              {
                unsigned int v136 = v9[2];
                unsigned int v137 = v9[3];
                unsigned int v138 = *v9;
                unsigned int v139 = v9[1];
                double v9 = v74;
                BOOL v140 = v137 < v139;
                BOOL v5 = v136 == v138;
                BOOL v141 = v136 < v138;
                if (v5) {
                  BOOL v141 = v140;
                }
                if (v141)
                {
                  uint64_t v142 = *(void *)v74;
                  uint64_t v143 = HIDWORD(*(void *)v74);
                  do
                  {
                    uint64_t v144 = v74;
                    uint64_t v145 = *((void *)v74 - 1);
                    v74 -= 2;
                    *(void *)uint64_t v144 = v145;
                    unsigned int v146 = *(v144 - 4);
                    BOOL v147 = *(v144 - 3) > v143;
                    BOOL v5 = v146 == v142;
                    BOOL v148 = v146 > v142;
                    if (!v5) {
                      BOOL v147 = v148;
                    }
                  }
                  while (v147);
                  *(void *)unint64_t v74 = v142;
                }
                unint64_t v74 = v9 + 2;
              }
              while (v9 + 2 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v11 != a2)
            {
              int64_t v93 = (v13 - 2) >> 1;
              int64_t v94 = v93;
              do
              {
                int64_t v95 = v94;
                if (v93 >= v94)
                {
                  uint64_t v96 = (2 * v94) | 1;
                  uint64_t v97 = (uint32x2_t *)&v11[2 * v96];
                  if (2 * v95 + 2 < (uint64_t)v13)
                  {
                    uint32x2_t v98 = v97[1];
                    uint32x2_t v99 = vcgt_u32(v98, *v97);
                    unsigned __int32 v101 = (unsigned __int32)*v97;
                    __int8 v100 = v99.i8[4];
                    if (v101 != v98.i32[0]) {
                      __int8 v100 = v99.i8[0];
                    }
                    if (v100)
                    {
                      unsigned __int32 v101 = (unsigned __int32)v97[1];
                      ++v97;
                      uint64_t v96 = 2 * v95 + 2;
                    }
                  }
                  else
                  {
                    unsigned __int32 v101 = v97->i32[0];
                  }
                  uint64_t v102 = (uint32x2_t *)&v11[2 * v95];
                  __n128 result = v102->u32[1];
                  BOOL v5 = v101 == v102->i32[0];
                  BOOL v103 = v101 < v102->i32[0];
                  if (v5) {
                    BOOL v103 = v97->i32[1] < result;
                  }
                  if (!v103)
                  {
                    uint32x2_t v104 = *v102;
                    unint64_t v105 = HIDWORD(*(unint64_t *)v102);
                    do
                    {
                      unint64_t v106 = v102;
                      uint64_t v102 = v97;
                      *unint64_t v106 = *v97;
                      if (v93 < v96) {
                        break;
                      }
                      uint64_t v107 = (2 * v96) | 1;
                      uint64_t v97 = (uint32x2_t *)&v11[2 * v107];
                      uint64_t v96 = 2 * v96 + 2;
                      if (v96 < (uint64_t)v13)
                      {
                        uint32x2_t v108 = v97[1];
                        uint32x2_t v109 = vcgt_u32(v108, *v97);
                        unsigned int v111 = *v97;
                        __int8 v110 = v109.i8[4];
                        if (v111 != v108.i32[0]) {
                          __int8 v110 = v109.i8[0];
                        }
                        if (v110)
                        {
                          unsigned int v111 = v97[1];
                          ++v97;
                        }
                        else
                        {
                          uint64_t v96 = v107;
                        }
                      }
                      else
                      {
                        unsigned int v111 = v97->i32[0];
                        uint64_t v96 = v107;
                      }
                      BOOL v112 = v97->i32[1] < v105;
                      BOOL v5 = v111 == v104.i32[0];
                      __n128 result = v111 < v104.i32[0];
                      if (!v5) {
                        BOOL v112 = result;
                      }
                    }
                    while (!v112);
                    *uint64_t v102 = v104;
                  }
                }
                int64_t v94 = v95 - 1;
              }
              while (v95);
              uint64_t v113 = (unint64_t)v12 >> 3;
              do
              {
                uint64_t v114 = 0;
                int32x2_t v115 = *(int32x2_t *)v11;
                uint64_t v116 = v113 - 2;
                if (v113 < 2) {
                  uint64_t v116 = v113 - 1;
                }
                uint64_t v117 = v116 >> 1;
                unint64_t v118 = (int32x2_t *)v11;
                do
                {
                  int64_t v119 = &v118[v114 + 1];
                  uint64_t v120 = (2 * v114) | 1;
                  uint64_t v121 = 2 * v114 + 2;
                  if (v121 < v113)
                  {
                    int32x2_t v122 = v119[1];
                    unsigned __int8 v123 = vceq_s32(*v119, v122).u8[0];
                    uint32x2_t v124 = vcgt_u32((uint32x2_t)v122, (uint32x2_t)*v119);
                    __n128 result = v124.u32[1];
                    __int8 v125 = (v123 & 1) != 0 ? v124.i8[4] : v124.i8[0];
                    if (v125)
                    {
                      ++v119;
                      uint64_t v120 = v121;
                    }
                  }
                  *unint64_t v118 = *v119;
                  unint64_t v118 = v119;
                  uint64_t v114 = v120;
                }
                while (v120 <= v117);
                a2 -= 2;
                if (v119 == (int32x2_t *)a2)
                {
                  *int64_t v119 = v115;
                }
                else
                {
                  *int64_t v119 = *(int32x2_t *)a2;
                  *(int32x2_t *)a2 = v115;
                  uint64_t v126 = (char *)v119 - (char *)v11 + 8;
                  if (v126 >= 9)
                  {
                    unint64_t v127 = (unint64_t)((v126 >> 3) - 2) >> 1;
                    uint64_t v128 = (uint32x2_t *)&v11[2 * v127];
                    int32x2_t v129 = *v119;
                    uint32x2_t v130 = vcgt_u32((uint32x2_t)*v119, *v128);
                    __int8 v131 = (vceq_s32((int32x2_t)*v128, *v119).u8[0] & 1) != 0 ? v130.i8[4] : v130.i8[0];
                    if (v131)
                    {
                      do
                      {
                        unint64_t v132 = v119;
                        int64_t v119 = (int32x2_t *)v128;
                        void *v132 = *v128;
                        if (!v127) {
                          break;
                        }
                        unint64_t v127 = (v127 - 1) >> 1;
                        uint64_t v128 = (uint32x2_t *)&v11[2 * v127];
                        uint32x2_t v133 = vcgt_u32((uint32x2_t)v129, *v128);
                        __int8 v134 = (vceq_s32((int32x2_t)*v128, v129).u8[0] & 1) != 0 ? v133.i8[4] : v133.i8[0];
                      }
                      while ((v134 & 1) != 0);
                      *int64_t v119 = v129;
                    }
                  }
                }
              }
              while (v113-- > 2);
            }
            return result;
          }
          unint64_t v14 = v13 >> 1;
          unint64_t v15 = &v11[2 * (v13 >> 1)];
          if ((unint64_t)v12 >= 0x401)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(v9, &v9[2 * (v13 >> 1)], a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(v9 + 2, v15 - 2, a2 - 4);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(v9 + 4, &v9[2 * v14 + 2], a2 - 6);
            __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(v15 - 2, v15, &v9[2 * v14 + 2]);
            uint64_t v16 = *(void *)v9;
            *(void *)double v9 = *(void *)v15;
            *(void *)unint64_t v15 = v16;
          }
          else
          {
            __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(&v9[2 * (v13 >> 1)], v9, a2 - 2);
          }
          --a3;
          if (a4) {
            break;
          }
          unsigned int v17 = *(v9 - 2);
          BOOL v5 = v17 == *v9;
          BOOL v18 = v17 < *v9;
          if (v5) {
            BOOL v18 = *(v9 - 1) < v9[1];
          }
          if (v18) {
            break;
          }
          uint64_t v44 = *(void *)v9;
          uint64_t v45 = HIDWORD(*(void *)v9);
          unsigned int v46 = *(a2 - 2);
          BOOL v5 = v46 == *(void *)v9;
          BOOL v47 = v46 > *(void *)v9;
          if (v5) {
            BOOL v47 = *(a2 - 1) > v45;
          }
          if (v47)
          {
            id v11 = v9;
            do
            {
              unsigned int v48 = v11[2];
              unsigned int v49 = v11[3];
              v11 += 2;
              BOOL v50 = v49 > v45;
              BOOL v5 = v48 == v44;
              BOOL v51 = v48 > v44;
              if (v5) {
                BOOL v51 = v50;
              }
            }
            while (!v51);
          }
          else
          {
            unint64_t v52 = v9 + 2;
            do
            {
              id v11 = v52;
              if (v52 >= a2) {
                break;
              }
              unsigned int v53 = *v52;
              BOOL v54 = v11[1] > v45;
              BOOL v5 = v53 == v44;
              BOOL v55 = v53 > v44;
              if (!v5) {
                BOOL v54 = v55;
              }
              unint64_t v52 = v11 + 2;
            }
            while (!v54);
          }
          uint64_t v56 = a2;
          if (v11 < a2)
          {
            uint64_t v56 = a2;
            do
            {
              unsigned int v57 = *(v56 - 2);
              unsigned int v58 = *(v56 - 1);
              v56 -= 2;
              BOOL v59 = v58 > v45;
              BOOL v5 = v57 == v44;
              BOOL v60 = v57 > v44;
              if (v5) {
                BOOL v60 = v59;
              }
            }
            while (v60);
          }
          while (v11 < v56)
          {
            int32x2_t v61 = *(int32x2_t *)v11;
            *(void *)id v11 = *(void *)v56;
            *(int32x2_t *)uint64_t v56 = v61;
            do
            {
              unsigned int v62 = v11[2];
              unsigned int v63 = v11[3];
              v11 += 2;
              BOOL v64 = v63 > v45;
              BOOL v5 = v62 == v44;
              BOOL v65 = v62 > v44;
              if (v5) {
                BOOL v65 = v64;
              }
            }
            while (!v65);
            do
            {
              unsigned int v66 = *(v56 - 2);
              unsigned int v67 = *(v56 - 1);
              v56 -= 2;
              BOOL v68 = v67 > v45;
              BOOL v5 = v66 == v44;
              BOOL v69 = v66 > v44;
              if (v5) {
                BOOL v69 = v68;
              }
            }
            while (v69);
          }
          uint64_t v70 = v11 - 2;
          BOOL v4 = v11 - 2 >= v9;
          BOOL v5 = v11 - 2 == v9;
          if (v11 - 2 != v9) {
            *(void *)double v9 = *(void *)v70;
          }
          a4 = 0;
          *(void *)uint64_t v70 = v44;
        }
        uint64_t v19 = *(void *)v9;
        uint64_t v20 = HIDWORD(*(void *)v9);
        id v21 = v9;
        do
        {
          unsigned __int8 v22 = v21;
          unsigned int v23 = v21[2];
          v21 += 2;
          BOOL v24 = v23 < v19;
          if (v23 == v19) {
            BOOL v24 = v22[3] < v20;
          }
        }
        while (v24);
        long long v25 = a2;
        if (v22 == v9)
        {
          long long v25 = a2;
          do
          {
            if (v21 >= v25) {
              break;
            }
            unsigned int v30 = *(v25 - 2);
            unsigned int v31 = *(v25 - 1);
            v25 -= 2;
            BOOL v32 = v31 < v20;
            BOOL v5 = v30 == v19;
            BOOL v33 = v30 < v19;
            if (v5) {
              BOOL v33 = v32;
            }
          }
          while (!v33);
        }
        else
        {
          do
          {
            unsigned int v26 = *(v25 - 2);
            unsigned int v27 = *(v25 - 1);
            v25 -= 2;
            BOOL v28 = v27 < v20;
            BOOL v5 = v26 == v19;
            BOOL v29 = v26 < v19;
            if (v5) {
              BOOL v29 = v28;
            }
          }
          while (!v29);
        }
        if (v21 < v25)
        {
          long long v34 = v21;
          id v35 = v25;
          do
          {
            uint64_t v36 = *(void *)v34;
            *(void *)long long v34 = *(void *)v35;
            *(void *)id v35 = v36;
            do
            {
              unsigned __int8 v22 = v34;
              unsigned int v37 = v34[2];
              v34 += 2;
              BOOL v38 = v37 < v19;
              if (v37 == v19) {
                BOOL v38 = v22[3] < v20;
              }
            }
            while (v38);
            do
            {
              unsigned int v39 = *(v35 - 2);
              unsigned int v40 = *(v35 - 1);
              v35 -= 2;
              BOOL v41 = v40 < v20;
              BOOL v5 = v39 == v19;
              BOOL v42 = v39 < v19;
              if (v5) {
                BOOL v42 = v41;
              }
            }
            while (!v42);
          }
          while (v34 < v35);
        }
        if (v22 != v9) {
          *(void *)double v9 = *(void *)v22;
        }
        *(void *)unsigned __int8 v22 = v19;
        if (v21 >= v25) {
          break;
        }
LABEL_43:
        __n128 result = std::__introsort<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*,false>(v9, v22, a3, a4 & 1);
        a4 = 0;
        id v11 = v22 + 2;
      }
      BOOL v43 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(v9, v22);
      id v11 = v22 + 2;
      __n128 result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(v22 + 2, a2);
      if (result) {
        break;
      }
      if (!v43) {
        goto LABEL_43;
      }
    }
    a2 = v22;
    if (!v43) {
      continue;
    }
    return result;
  }
}

char *std::vector<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData,std::allocator<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData>>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    abort();
  }
  __n128 result = (char *)operator new(16 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * a2];
  return result;
}

void std::vector<std::vector<std::vector<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData,std::allocator<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData>>>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    BOOL v4 = (void **)v1[1];
    BOOL v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        id v6 = v4;
        std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&v6);
      }
      while (v4 != v2);
      BOOL v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

unsigned int *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(unsigned int *result, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = a2[1];
  BOOL v5 = *a2 < *result;
  if (*a2 == *result) {
    BOOL v5 = v4 < result[1];
  }
  BOOL v6 = a3[1] < v4;
  BOOL v7 = *a3 == v3;
  BOOL v8 = *a3 < v3;
  if (!v7) {
    BOOL v6 = v8;
  }
  if (v5)
  {
    uint64_t v9 = *(void *)result;
    if (v6)
    {
      *(void *)__n128 result = *(void *)a3;
LABEL_17:
      *(void *)a3 = v9;
      return result;
    }
    *(void *)__n128 result = *(void *)a2;
    *(void *)a2 = v9;
    BOOL v13 = *a3 < v9;
    if (*a3 == v9) {
      BOOL v13 = a3[1] < HIDWORD(v9);
    }
    if (v13)
    {
      *(void *)a2 = *(void *)a3;
      goto LABEL_17;
    }
  }
  else if (v6)
  {
    uint64_t v10 = *(void *)a2;
    *(void *)a2 = *(void *)a3;
    *(void *)a3 = v10;
    BOOL v11 = *a2 < *result;
    if (*a2 == *result) {
      BOOL v11 = a2[1] < result[1];
    }
    if (v11)
    {
      uint64_t v12 = *(void *)result;
      *(void *)__n128 result = *(void *)a2;
      *(void *)a2 = v12;
    }
  }
  return result;
}

unsigned int *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  __n128 result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(a1, a2, a3);
  BOOL v9 = *a4 < *a3;
  if (*a4 == *a3) {
    BOOL v9 = a4[1] < a3[1];
  }
  if (v9)
  {
    uint64_t v10 = *(void *)a3;
    *(void *)a3 = *(void *)a4;
    *(void *)a4 = v10;
    BOOL v11 = *a3 < *a2;
    if (*a3 == *a2) {
      BOOL v11 = a3[1] < a2[1];
    }
    if (v11)
    {
      uint64_t v12 = *(void *)a2;
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v12;
      BOOL v13 = *a2 < *a1;
      if (*a2 == *a1) {
        BOOL v13 = a2[1] < a1[1];
      }
      if (v13)
      {
        uint64_t v14 = *(void *)a1;
        *(void *)a1 = *(void *)a2;
        *(void *)a2 = v14;
      }
    }
  }
  return result;
}

unsigned int *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  __n128 result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(a1, a2, a3, a4);
  BOOL v11 = *a5 < *a4;
  if (*a5 == *a4) {
    BOOL v11 = a5[1] < a4[1];
  }
  if (v11)
  {
    uint64_t v12 = *(void *)a4;
    *(void *)a4 = *(void *)a5;
    *(void *)a5 = v12;
    BOOL v13 = *a4 < *a3;
    if (*a4 == *a3) {
      BOOL v13 = a4[1] < a3[1];
    }
    if (v13)
    {
      uint64_t v14 = *(void *)a3;
      *(void *)a3 = *(void *)a4;
      *(void *)a4 = v14;
      BOOL v15 = *a3 < *a2;
      if (*a3 == *a2) {
        BOOL v15 = a3[1] < a2[1];
      }
      if (v15)
      {
        uint64_t v16 = *(void *)a2;
        *(void *)a2 = *(void *)a3;
        *(void *)a3 = v16;
        BOOL v17 = *a2 < *a1;
        if (*a2 == *a1) {
          BOOL v17 = a2[1] < a1[1];
        }
        if (v17)
        {
          uint64_t v18 = *(void *)a1;
          *(void *)a1 = *(void *)a2;
          *(void *)a2 = v18;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(unsigned int *a1, unsigned int *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *(a2 - 2);
      BOOL v7 = v6 == *a1;
      BOOL v8 = v6 < *a1;
      if (v7) {
        BOOL v8 = *(a2 - 1) < a1[1];
      }
      if (v8)
      {
        uint64_t v9 = *(void *)a1;
        *(void *)a1 = *((void *)a2 - 1);
        *((void *)a2 - 1) = v9;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      uint64_t v10 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>(a1, a1 + 2, a1 + 4);
      BOOL v11 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    BOOL v14 = *v11 < *v10;
    if (*v11 == *v10) {
      BOOL v14 = v11[1] < v10[1];
    }
    if (v14)
    {
      uint64_t v15 = *(void *)v11;
      uint64_t v16 = HIDWORD(*(void *)v11);
      uint64_t v17 = v12;
      while (1)
      {
        uint64_t v18 = (char *)a1 + v17;
        *(void *)((char *)a1 + v17 + 24) = *(void *)((char *)a1 + v17 + 16);
        if (v17 == -16) {
          break;
        }
        unsigned int v19 = *((_DWORD *)v18 + 2);
        BOOL v20 = *((_DWORD *)v18 + 3) > v16;
        BOOL v7 = v19 == v15;
        BOOL v21 = v19 > v15;
        if (!v7) {
          BOOL v20 = v21;
        }
        v17 -= 8;
        if (!v20)
        {
          unsigned __int8 v22 = (unsigned int *)((char *)a1 + v17 + 24);
          goto LABEL_18;
        }
      }
      unsigned __int8 v22 = a1;
LABEL_18:
      *(void *)unsigned __int8 v22 = v15;
      if (++v13 == 8) {
        return v11 + 2 == a2;
      }
    }
    uint64_t v10 = v11;
    v12 += 8;
    v11 += 2;
    if (v11 == a2) {
      return 1;
    }
  }
}

void ___ZNK7GRCInfo27SubDividedCounterDictionaryEP14NSMutableArrayIP19GPURawCounterSelectEP26GTMTLReplayOperationQueues_block_invoke(void *a1)
{
  id v5 = [*(id *)(a1[6] + 16) firstObject];
  uint64_t v2 = [v5 subDivideCounterList:a1[4] withOptions:0];
  uint64_t v3 = *(void *)(a1[5] + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_21165C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZL18DerivedCounterDataP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayP19NSMutableDictionaryjP21GTAGXPerfStateControl_block_invoke(uint64_t a1)
{
  id v5 = [*(id *)(*(void *)(a1 + 56) + 8) defaultCommandQueue];
  [v5 setStatEnabled:1];
  uint64_t v2 = [v5 subdivideCounterList:*(void *)(a1 + 32)];
  [v5 setStatEnabled:0];
  uint64_t v3 = CollectCounters(*(GTMTLReplayController **)(a1 + 56), *(GTMTLReplayOperationQueues **)(a1 + 64), *(NSArray **)(a1 + 32), v2, *(void **)(a1 + 40), 0, 0, *(void *)(a1 + 72), v4);
  [*(id *)(a1 + 48) addDependency:v3];
  [*(id *)(*(void *)(a1 + 64) + 8) addOperation:*(void *)(a1 + 48)];
}

void sub_211738(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void GTMTLReplayClient_streamShaderProfilingData(uint64_t a1, id *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  uint64_t v44 = v7;
  if (v7)
  {
    uint64_t v51 = 0;
    unint64_t v52 = (id *)&v51;
    uint64_t v53 = 0x8012000000;
    BOOL v54 = __Block_byref_object_copy__1109;
    BOOL v55 = __Block_byref_object_dispose__1110;
    uint64_t v56 = "!0 3";
    BOOL v41 = a2;
    id v42 = v8;
    GTUSCSamplingStreamingManager::GTUSCSamplingStreamingManager((uint64_t)v57, a1, a2, v7, v8);
    uint64_t v9 = v52;
    GTUSCSamplingStreamingManager::InitTargetIndex(v52 + 6);
    uint64_t v10 = (id *)v9[6];
    id v11 = v9[12];
    int v12 = *((_DWORD *)v9 + 31);
    id v45 = v9[11];
    id v46 = v11;
    int v13 = [v10[1] defaultDevice];
    BOOL v14 = DYMTLReplayFrameProfiler_loadAnalysis(v13);
    [v46 addEntriesFromDictionary:v14];

    BOOL v43 = [v46 objectForKeyedSubscript:@"DerivedCounterDictionary"];
    unsigned int v48 = objc_opt_new();
    uint64_t v15 = [v43 objectForKeyedSubscript:@"DerivedCounters"];
    if (v12)
    {
      uint64_t v16 = 0;
      uint64_t v17 = +[NSSet setWithArray:](NSSet, "setWithArray:", &off_758A98, v15);
    }
    else
    {
      uint64_t v18 = +[NSSet setWithArray:](NSSet, "setWithArray:", &off_758A68, v15);
      uint64_t v17 = +[NSSet setWithArray:&off_758A80];
      uint64_t v16 = (void *)v18;
    }
    unsigned int v49 = v16;
    BOOL v47 = objc_opt_new();
    unsigned int v19 = (_UNKNOWN **)objc_opt_new();
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    id v20 = v15;
    id v21 = [v20 countByEnumeratingWithState:&v58 objects:v66 count:16];
    if (v21)
    {
      uint64_t v22 = *(void *)v59;
      do
      {
        for (unint64_t i = 0; i != v21; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v59 != v22) {
            objc_enumerationMutation(v20);
          }
          BOOL v24 = *(void **)(*((void *)&v58 + 1) + 8 * i);
          if ([v17 containsObject:v24])
          {
            long long v25 = [v20 objectForKeyedSubscript:v24];
            [v48 setObject:v25 forKeyedSubscript:v24];
          }
          if ([v49 containsObject:v24])
          {
            unsigned int v26 = [v20 objectForKeyedSubscript:v24];
            [v47 setObject:v26 forKeyedSubscript:v24];
          }
          if ([v24 isEqualToString:@"FRGTicks"])
          {
            BOOL v64 = v24;
            unsigned int v27 = [v20 objectForKeyedSubscript:v24];
            BOOL v65 = v27;
            BOOL v28 = +[NSDictionary dictionaryWithObjects:&v65 forKeys:&v64 count:1];
            uint64_t v29 = GTMTLReplayHost_rawCounters(v28);

            unsigned int v19 = (_UNKNOWN **)v29;
          }
        }
        id v21 = [v20 countByEnumeratingWithState:&v58 objects:v66 count:16];
      }
      while (v21);
    }

    unsigned int v30 = GTMTLReplayHost_rawCounters(v48);
    unsigned int v31 = +[NSMutableArray arrayWithArray:v30];

    BOOL v32 = GTMTLReplayHost_rawCounters(v47);
    if (![v19 count])
    {

      unsigned int v19 = &off_758AB0;
    }
    [v31 addObjectsFromArray:v19];
    [v45 setObject:v31 forKeyedSubscript:@"profileCounters"];
    if ([v32 count]) {
      [v45 setObject:v32 forKeyedSubscript:@"profileCounters32"];
    }
    BOOL v33 = [v46 objectForKeyedSubscript:@"DerivedCounterConfigurationVariables"];
    BOOL v34 = v33 == 0;

    if (!v34)
    {
      id v35 = [v46 objectForKeyedSubscript:@"DerivedCounterConfigurationVariables"];
      [v45 setObject:v35 forKeyedSubscript:@"DerivedCounterConfigurationVariables"];
    }
    CFStringRef v62 = @"DerivedCounters";
    unsigned int v63 = v48;
    uint64_t v36 = +[NSDictionary dictionaryWithObjects:&v63 forKeys:&v62 count:1];
    [v45 setObject:v36 forKeyedSubscript:@"DerivedCounterDictionary"];

    unsigned int v37 = [v46 objectForKeyedSubscript:@"DerivedCounterScript"];
    [v45 setObject:v37 forKeyedSubscript:@"DerivedCounterScript"];

    BOOL v38 = [v46 objectForKeyedSubscript:@"DerivedCounterAnalysis"];
    [v45 setObject:v38 forKeyedSubscript:@"DerivedCounterAnalysis"];

    unsigned int v39 = [v46 objectForKeyedSubscript:@"DerivedCounterAnalysisFunctions"];
    [v45 setObject:v39 forKeyedSubscript:@"DerivedCounterAnalysisFunctions"];

    v50[0] = _NSConcreteStackBlock;
    v50[1] = 3221225472;
    void v50[2] = __GTMTLReplayClient_streamShaderProfilingData_block_invoke;
    v50[3] = &unk_744E20;
    void v50[4] = &v51;
    unsigned int v40 = +[NSBlockOperation blockOperationWithBlock:v50];
    [v41[1] addOperation:v40];

    _Block_object_dispose(&v51, 8);
    GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(v57);
    id v8 = v42;
  }
}

void sub_211D90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, id *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  _Block_object_dispose(&a25, 8);
  GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(a11);

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__1109(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(id *)(a2 + 64);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a1 + 80) = objc_retainBlock(*(id *)(a2 + 80));
  *(void *)(a1 + 88) = *(id *)(a2 + 88);
  *(void *)(a1 + 96) = *(id *)(a2 + 96);
  *(void *)(a1 + 104) = *(id *)(a2 + 104);
  __n128 result = *(__n128 *)(a2 + 112);
  *(__n128 *)(a1 + 112) = result;
  return result;
}

void __Block_byref_object_dispose__1110(uint64_t a1)
{
}

void sub_2131B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, id a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  if (v41) {
    operator delete(v41);
  }

  if (__p) {
    operator delete(__p);
  }

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a29);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a37);

  _Unwind_Resume(a1);
}

void GTMTLReplayClient_streamDerivedCounterData(uint64_t a1, id *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (v7)
  {
    uint64_t v11 = 0;
    int v12 = (id *)&v11;
    uint64_t v13 = 0x8012000000;
    BOOL v14 = __Block_byref_object_copy__1109;
    uint64_t v15 = __Block_byref_object_dispose__1110;
    uint64_t v16 = "!0 3";
    GTUSCSamplingStreamingManager::GTUSCSamplingStreamingManager((uint64_t)v17, a1, a2, v7, v8);
    GTUSCSamplingStreamingManager::InitDerivedCountersInfo(v12 + 6);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = __GTMTLReplayClient_streamDerivedCounterData_block_invoke;
    v10[3] = &unk_744E20;
    v10[4] = &v11;
    uint64_t v9 = +[NSBlockOperation blockOperationWithBlock:v10];
    [a2[1] addOperation:v9];

    _Block_object_dispose(&v11, 8);
    GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(v17);
  }
}

void sub_2137B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);

  _Block_object_dispose(va, 8);
  GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(v9);

  _Unwind_Resume(a1);
}

void sub_213A00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL GTMTLReplayClient_streamBatchFilteredData(uint64_t a1, id *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (v7)
  {
    uint64_t v12 = 0;
    uint64_t v13 = (id *)&v12;
    uint64_t v14 = 0x8012000000;
    uint64_t v15 = __Block_byref_object_copy__1109;
    uint64_t v16 = __Block_byref_object_dispose__1110;
    uint64_t v17 = "!0 3";
    GTUSCSamplingStreamingManager::GTUSCSamplingStreamingManager((uint64_t)v18, a1, a2, v7, v8);
    GTUSCSamplingStreamingManager::InitDerivedCountersInfo(v13 + 6);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = __GTMTLReplayClient_streamBatchFilteredData_block_invoke;
    unint64_t v11[3] = &unk_744E20;
    v11[4] = &v12;
    uint64_t v9 = +[NSBlockOperation blockOperationWithBlock:v11];
    [a2[1] addOperation:v9];

    _Block_object_dispose(&v12, 8);
    GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(v18);
  }

  return v7 != 0;
}

void sub_213B80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);

  _Block_object_dispose(va, 8);
  GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(v9);

  _Unwind_Resume(a1);
}

void sub_21406C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTMTLReplayClient_collectGPUShaderTimelineData(uint64_t a1, id *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  uint64_t v56 = v7;
  if (v7)
  {
    uint64_t v63 = 0;
    BOOL v64 = &v63;
    uint64_t v65 = 0x8012000000;
    unsigned int v66 = __Block_byref_object_copy__1109;
    unsigned int v67 = __Block_byref_object_dispose__1110;
    BOOL v68 = "!0 3";
    unsigned int v49 = a2;
    id v50 = v8;
    GTUSCSamplingStreamingManager::GTUSCSamplingStreamingManager((uint64_t)v69, a1, a2, v7, v8);
    uint64_t v9 = v64;
    GTUSCSamplingStreamingManager::InitTargetIndex((id *)v64 + 6);
    uint64_t v10 = v9[6];
    uint64_t v11 = (void *)v9[11];
    uint64_t v12 = (void *)v9[12];
    id v57 = v11;
    id v58 = v12;
    uint64_t v13 = [*(id *)(v10 + 8) defaultDevice];
    uint64_t v14 = DYMTLReplayFrameProfiler_loadAnalysis(v13);
    [v58 addEntriesFromDictionary:v14];

    unint64_t v52 = [v58 objectForKeyedSubscript:@"DerivedCounterDictionary"];
    uint64_t v51 = [v52 objectForKeyedSubscript:@"Instruments"];
    uint64_t v15 = [v51 objectForKeyedSubscript:@"Profiles"];
    uint64_t v53 = [v15 objectForKeyedSubscript:@"Set1"];

    BOOL v54 = [v53 objectForKeyedSubscript:@"DerivedCounters"];
    uint64_t v16 = [v53 objectForKeyedSubscript:@"RawCounterWidth"];
    id v17 = objc_msgSend(objc_alloc((Class)NSMutableSet), "initWithCapacity:", objc_msgSend(v54, "count"));
    long long v80 = 0u;
    long long v81 = 0u;
    long long v78 = 0u;
    long long v79 = 0u;
    obunint64_t j = v54;
    id v18 = [obj countByEnumeratingWithState:&v78 objects:v88 count:16];
    if (v18)
    {
      uint64_t v19 = *(void *)v79;
      do
      {
        for (unint64_t i = 0; i != v18; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v79 != v19) {
            objc_enumerationMutation(obj);
          }
          id v21 = [*(id *)(*((void *)&v78 + 1) + 8 * i) objectForKeyedSubscript:@"Name"];
          if (v21) {
            [v17 addObject:v21];
          }
        }
        id v18 = [obj countByEnumeratingWithState:&v78 objects:v88 count:16];
      }
      while (v18);
    }

    unsigned int v48 = [v52 objectForKeyedSubscript:@"DerivedCounters"];
    long long v60 = objc_opt_new();
    long long v59 = objc_opt_new();
    long long v76 = 0u;
    long long v77 = 0u;
    long long v74 = 0u;
    long long v75 = 0u;
    id v22 = v48;
    id v23 = [v22 countByEnumeratingWithState:&v74 objects:v87 count:16];
    if (v23)
    {
      uint64_t v24 = *(void *)v75;
      do
      {
        for (unint64_t j = 0; j != v23; unint64_t j = (char *)j + 1)
        {
          if (*(void *)v75 != v24) {
            objc_enumerationMutation(v22);
          }
          unsigned int v26 = *(void **)(*((void *)&v74 + 1) + 8 * (void)j);
          if ([v17 containsObject:v26])
          {
            unsigned int v27 = [v22 objectForKeyedSubscript:v26];
            [v60 setObject:v27 forKeyedSubscript:v26];
          }
          if ([v26 isEqualToString:@"FRGTicks"])
          {
            uint64_t v85 = v26;
            BOOL v28 = [v22 objectForKeyedSubscript:v26];
            uint64_t v86 = v28;
            uint64_t v29 = +[NSDictionary dictionaryWithObjects:&v86 forKeys:&v85 count:1];
            unsigned int v30 = GTMTLReplayHost_rawCounters(v29);
            [v59 setArray:v30];
          }
        }
        id v23 = [v22 countByEnumeratingWithState:&v74 objects:v87 count:16];
      }
      while (v23);
    }

    unsigned int v31 = GTMTLReplayHost_rawCounters(v60);
    BOOL v55 = +[NSMutableArray arrayWithArray:v31];

    [v55 addObjectsFromArray:v59];
    id v32 = [objc_alloc((Class)NSMutableArray) initWithCapacity:[v55 count]];
    long long v72 = 0u;
    long long v73 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    id v33 = v55;
    id v34 = [v33 countByEnumeratingWithState:&v70 objects:v84 count:16];
    if (v34)
    {
      uint64_t v35 = *(void *)v71;
      do
      {
        for (uint64_t k = 0; k != v34; uint64_t k = (char *)k + 1)
        {
          if (*(void *)v71 != v35) {
            objc_enumerationMutation(v33);
          }
          uint64_t v37 = *(void *)(*((void *)&v70 + 1) + 8 * (void)k);
          BOOL v38 = [v16 objectForKeyedSubscript:v37];
          unsigned int v39 = v38;
          if (!v38 || [v38 integerValue] == &stru_20) {
            [v32 addObject:v37];
          }
        }
        id v34 = [v33 countByEnumeratingWithState:&v70 objects:v84 count:16];
      }
      while (v34);
    }

    [v57 setObject:v33 forKeyedSubscript:@"profileCounters"];
    [v57 setObject:v32 forKeyedSubscript:@"profileCounters32"];
    unsigned int v40 = [v58 objectForKeyedSubscript:@"DerivedCounterConfigurationVariables"];
    BOOL v41 = v40 == 0;

    if (!v41)
    {
      id v42 = [v58 objectForKeyedSubscript:@"DerivedCounterConfigurationVariables"];
      [v57 setObject:v42 forKeyedSubscript:@"DerivedCounterConfigurationVariables"];
    }
    CFStringRef v82 = @"DerivedCounters";
    BOOL v83 = v60;
    BOOL v43 = +[NSDictionary dictionaryWithObjects:&v83 forKeys:&v82 count:1];
    [v57 setObject:v43 forKeyedSubscript:@"DerivedCounterDictionary"];

    uint64_t v44 = [v58 objectForKeyedSubscript:@"DerivedCounterScript"];
    [v57 setObject:v44 forKeyedSubscript:@"DerivedCounterScript"];

    id v45 = [v58 objectForKeyedSubscript:@"DerivedCounterAnalysis"];
    [v57 setObject:v45 forKeyedSubscript:@"DerivedCounterAnalysis"];

    id v46 = [v58 objectForKeyedSubscript:@"DerivedCounterAnalysisFunctions"];
    [v57 setObject:v46 forKeyedSubscript:@"DerivedCounterAnalysisFunctions"];

    v62[0] = _NSConcreteStackBlock;
    v62[1] = 3221225472;
    v62[2] = __GTMTLReplayClient_collectGPUShaderTimelineData_block_invoke;
    v62[3] = &unk_744E20;
    _OWORD v62[4] = &v63;
    BOOL v47 = +[NSBlockOperation blockOperationWithBlock:v62];
    [v49[1] addOperation:v47];

    _Block_object_dispose(&v63, 8);
    GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(v69);
    id v8 = v50;
  }
}

void sub_214860(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, id *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a29, 8);
  GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(a11);

  _Unwind_Resume(a1);
}

void sub_214BD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  _Unwind_Resume(a1);
}

void GTMTLReplayClient_addBatchFilteringRequest(void *a1)
{
  uint64_t v1 = a1;
  GTUSCSamplingStreamingManagerHelper::Instance(v1);
  id v7 = v1;
  uint64_t v2 = [(GTUSCSamplingStreamingManagerHelper *)v7 objectForKeyedSubscript:@"highPriorityBatches"];
  if (v2)
  {
    id v3 = qword_7728B8;
    uint64_t v4 = [(GTUSCSamplingStreamingManagerHelper *)v7 objectForKeyedSubscript:@"HighPriorityBatchInfo"];
    [v3 nextPerEncoderBatchListForHighPriorityBatches:v2 withHighPriorityInfo:v4];
  }
  else
  {
    id v5 = [(GTUSCSamplingStreamingManagerHelper *)v7 objectForKeyedSubscript:@"pause"];

    if (v5)
    {
      [qword_7728B8 pause];
    }
    else
    {
      unsigned int v6 = [(GTUSCSamplingStreamingManagerHelper *)v7 objectForKeyedSubscript:@"resume"];

      if (v6) {
        [qword_7728B8 resume];
      }
    }
  }
}

void sub_214CFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v13 = v12;

  _Unwind_Resume(a1);
}

void GTMTLReplayClient_collectAPSData(uint64_t a1, id *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (v7)
  {
    uint64_t v11 = 0;
    uint64_t v12 = (id *)&v11;
    uint64_t v13 = 0x8012000000;
    uint64_t v14 = __Block_byref_object_copy__1109;
    uint64_t v15 = __Block_byref_object_dispose__1110;
    uint64_t v16 = "!0 3";
    GTUSCSamplingStreamingManager::GTUSCSamplingStreamingManager((uint64_t)v17, a1, a2, v7, v8);
    GTUSCSamplingStreamingManager::InitTargetIndex(v12 + 6);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = __GTMTLReplayClient_collectAPSData_block_invoke;
    v10[3] = &unk_744E20;
    v10[4] = &v11;
    uint64_t v9 = +[NSBlockOperation blockOperationWithBlock:v10];
    [a2[1] addOperation:v9];

    _Block_object_dispose(&v11, 8);
    GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(v17);
  }
}

void sub_214E88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);

  _Block_object_dispose(va, 8);
  GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(v9);

  _Unwind_Resume(a1);
}

void sub_215CFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, id a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  _Unwind_Resume(a1);
}

uint64_t GTCoreOperationControl_getOperation(uint64_t a1)
{
  uint64_t v4 = a1;
  pthread_mutex_lock((pthread_mutex_t *)(control + 8));
  entry = find_entry(*(void *)control, &v4, 8uLL, 0);
  if (*entry) {
    uint64_t v2 = *(void *)(*entry + 32);
  }
  else {
    uint64_t v2 = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(control + 8));
  return v2;
}

void sub_216218(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t GTCoreOperationControl_addOperation(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)(control + 8));
  uint64_t v2 = apr_palloc(**(apr_pool_t ***)control, 0x20uLL);
  v2[1] = 0;
  v2[2] = 0;
  *uint64_t v2 = a1;
  *((unsigned char *)v2 + 24) = 0;
  apr_hash_set(*(apr_hash_t **)control, v2, 8, v2);
  id v3 = (pthread_mutex_t *)(control + 8);

  return pthread_mutex_unlock(v3);
}

uint64_t GTCoreOperationControl_removeOperation(uint64_t a1)
{
  uint64_t v4 = a1;
  pthread_mutex_lock((pthread_mutex_t *)(control + 8));
  entry = find_entry(*(void *)control, &v4, 8uLL, 0);
  if (*entry)
  {
    uint64_t v2 = *(const void **)(*entry + 32);
    if (v2) {
      apr_hash_set(*(apr_hash_t **)control, v2, 8, 0);
    }
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(control + 8));
}

uint64_t DYMTLDrawRenderCommandEncoder(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  id v9 = a1;
  id v10 = a5;
  uint64_t v11 = *(void *)(a3 + *(void *)(a2 + 8));
  uint64_t v12 = 1;
  uint64_t v13 = 0;
  switch(v11)
  {
    case 0:
      goto LABEL_31;
    case 1:
      [v9 drawPrimitives:*(void *)(a3 + *(void *)(a2 + 96)) vertexStart:*(void *)(a3 + *(void *)(a2 + 96) + 8) vertexCount:*(void *)(a3 + *(void *)(a2 + 96) + 16) instanceCount:*(void *)(a3 + *(void *)(a2 + 96) + 24) baseInstance:*(void *)(a3 + *(void *)(a2 + 96) + 32)];
      break;
    case 2:
      id v18 = (void *)(a3 + *(void *)(a2 + 96));
      uint64_t v19 = *(void **)(*(void *)a4 + 24);
      unint64_t v20 = *(int *)(*(void *)a4 + 12);
      unint64_t v21 = v18[3];
      id v22 = GTMTLGPUAddressResource_resourceForGPUAddress(v19, v20, v21);
      if (v22)
      {
        unint64_t v23 = v21 - *v22;
        uint64_t v24 = v22[2];
      }
      else
      {
        unint64_t v23 = 0;
        uint64_t v24 = 0;
      }
      id v42 = GetObjectForKey(v10, v24);
      uint64_t v12 = v42 != 0;
      if (v42) {
        [v9 drawIndexedPrimitives:*v18 indexCount:v18[1] indexType:v18[2] indexBuffer:v42 indexBufferOffset:v23 instanceCount:v18[4] baseVertex:v18[5] baseInstance:v18[6]];
      }
      goto LABEL_19;
    case 3:
    case 5:
    case 6:
    case 7:
      break;
    case 4:
      long long v25 = (void *)(*(void *)(a2 + 96) + a3);
      unsigned int v26 = *(void **)(*(void *)a4 + 24);
      unint64_t v27 = *(int *)(*(void *)a4 + 12);
      unint64_t v28 = v25[6];
      uint64_t v29 = GTMTLGPUAddressResource_resourceForGPUAddress(v26, v27, v28);
      if (v29)
      {
        unint64_t v30 = v28 - *v29;
        uint64_t v31 = v29[2];
      }
      else
      {
        unint64_t v30 = 0;
        uint64_t v31 = 0;
      }
      id v42 = GetObjectForKey(v10, v31);
      int v43 = v42 != 0;
      unsigned int v44 = v31 == 0;
      uint64_t v12 = v43 ^ v44;
      if (v43 != v44) {
        [v9 drawPatches:v25[3] patchStart:v25[4] patchCount:v25[5] patchIndexBuffer:v42 patchIndexBufferOffset:v30 instanceCount:v25[7] baseInstance:v25[8]];
      }
LABEL_19:

      break;
    case 8:
      uint64_t v32 = *(void *)(a2 + 96) + a3;
      id v33 = (void *)(v32 + 24);
      unint64_t v34 = *(void *)(v32 + 48);
      uint64_t v35 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*(void *)a4 + 24), *(int *)(*(void *)a4 + 12), v34);
      if (v35)
      {
        unint64_t v36 = v34 - *v35;
        uint64_t v37 = v35[2];
      }
      else
      {
        unint64_t v36 = 0;
        uint64_t v37 = 0;
      }
      id v45 = GetObjectForKey(v10, v37);
      unsigned int v46 = (v45 != 0) ^ (v37 == 0);
      BOOL v47 = *(void **)(*(void *)a4 + 24);
      unint64_t v48 = *(int *)(*(void *)a4 + 12);
      unint64_t v49 = v33[4];
      id v50 = GTMTLGPUAddressResource_resourceForGPUAddress(v47, v48, v49);
      if (v50)
      {
        unint64_t v51 = v49 - *v50;
        uint64_t v52 = v50[2];
      }
      else
      {
        unint64_t v51 = 0;
        uint64_t v52 = 0;
      }
      uint64_t v53 = GetObjectForKey(v10, v52);
      if (v53) {
        uint64_t v12 = v46;
      }
      else {
        uint64_t v12 = 0;
      }
      if (v12 == 1) {
        [v9 drawIndexedPatches:*v33 patchStart:v33[1] patchCount:v33[2] patchIndexBuffer:v45 patchIndexBufferOffset:v36 controlPointIndexBuffer:v53 controlPointIndexBufferOffset:v51 instanceCount:v33[5] baseInstance:v33[6]];
      }

      break;
    default:
      if (v11 == 128)
      {
        BOOL v38 = (long long *)(a3 + *(void *)(a2 + 96));
        uint64_t v39 = *((void *)v38 + 2);
        long long v65 = *v38;
        uint64_t v66 = v39;
        uint64_t v40 = *((void *)v38 + 5);
        long long v63 = *(long long *)((char *)v38 + 24);
        uint64_t v64 = v40;
        uint64_t v41 = *((void *)v38 + 8);
        long long v61 = v38[3];
        uint64_t v62 = v41;
        [v9 drawMeshThreadgroups:&v65 threadsPerObjectThreadgroup:&v63 threadsPerMeshThreadgroup:&v61];
      }
      else if (v11 == 256)
      {
        uint64_t v14 = (long long *)(a3 + *(void *)(a2 + 96));
        uint64_t v15 = *((void *)v14 + 2);
        long long v59 = *v14;
        uint64_t v60 = v15;
        uint64_t v16 = *((void *)v14 + 5);
        long long v57 = *(long long *)((char *)v14 + 24);
        uint64_t v58 = v16;
        uint64_t v17 = *((void *)v14 + 8);
        long long v55 = v14[3];
        uint64_t v56 = v17;
        [v9 drawMeshThreads:&v59 threadsPerObjectThreadgroup:&v57 threadsPerMeshThreadgroup:&v55];
      }
      break;
  }
  uint64_t v13 = v12;
LABEL_31:

  return v13;
}

id GetObjectForKey(void *a1, uint64_t a2)
{
  id v3 = a1;
  uint64_t v4 = +[NSNumber numberWithUnsignedLongLong:a2];
  id v5 = [v3 objectForKeyedSubscript:v4];

  return v5;
}

uint64_t DYMTLDispatchComputeCommandEncoder(void *a1, uint64_t a2, uint64_t a3)
{
  id v5 = a1;
  unsigned int v6 = v5;
  uint64_t v7 = *(void *)(a3 + *(void *)(a2 + 8));
  if (v7 == 64)
  {
    uint64_t v11 = *(void *)(a2 + 96) + a3;
    uint64_t v12 = *(void *)(v11 + 88);
    long long v18 = *(_OWORD *)(v11 + 72);
    uint64_t v19 = v12;
    uint64_t v13 = *(void *)(v11 + 112);
    long long v16 = *(_OWORD *)(v11 + 96);
    uint64_t v17 = v13;
    [v5 dispatchThreads:&v18 threadsPerThreadgroup:&v16];
  }
  else
  {
    if (v7 != 32)
    {
      uint64_t v14 = 0;
      goto LABEL_7;
    }
    uint64_t v8 = *(void *)(a2 + 96) + a3;
    uint64_t v9 = *(void *)(v8 + 88);
    long long v22 = *(_OWORD *)(v8 + 72);
    uint64_t v23 = v9;
    uint64_t v10 = *(void *)(v8 + 112);
    long long v20 = *(_OWORD *)(v8 + 96);
    uint64_t v21 = v10;
    [v5 dispatchThreadgroups:&v22 threadsPerThreadgroup:&v20];
  }
  uint64_t v14 = 1;
LABEL_7:

  return v14;
}

void GTMTLEncodeIndirectCommandBufferWithRange(void *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, void *a7)
{
  id v11 = a1;
  id v12 = a7;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v142 = 0u;
  long long v143 = 0u;
  long long v141 = 0u;
  GTMTLCreateIndirectCommandEncoder((uint64_t)&v141, a4);
  int v13 = *(unsigned __int16 *)(a4 + 8);
  if ((v13 & 0xFE70) == 0)
  {
    id v116 = v11;
    id v131 = v11;
    id v115 = v12;
    id v136 = v12;
    uint64_t v129 = a2 + a3;
    if (a2 < a2 + a3)
    {
      uint64_t v41 = *((void *)&v147 + 1);
      uint64_t v127 = *((void *)&v141 + 1);
      uint64_t v42 = a5 + a2 * *((void *)&v147 + 1);
      uint64_t v118 = *((void *)&v147 + 1);
      do
      {
        uint64_t v44 = a5 + v41 * a2;
        unint64_t v139 = a2;
        id v45 = [v131 indirectRenderCommandAtIndex:a2];
        unsigned int v46 = v45;
        uint64_t v47 = *(void *)(v44 + v127);
        switch(v47)
        {
          case 0:
            [v45 reset];
            goto LABEL_112;
          case 1:
            [v45 drawPrimitives:*(void *)(v44 + v147) vertexStart:*(void *)(v44 + v147 + 8) vertexCount:*(void *)(v44 + v147 + 16) instanceCount:*(void *)(v44 + v147 + 24) baseInstance:*(void *)(v44 + v147 + 32)];
            break;
          case 2:
            unint64_t v51 = (void *)(v44 + v147);
            unint64_t v52 = *(void *)(v44 + v147 + 24);
            uint64_t v53 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*a6 + 24), *(int *)(*a6 + 12), v52);
            if (v53)
            {
              unint64_t v54 = v52 - *v53;
              uint64_t v55 = v53[2];
            }
            else
            {
              unint64_t v54 = 0;
              uint64_t v55 = 0;
            }
            long long v71 = GetObjectForKey(v136, v55);
            if (v71) {
              [v46 drawIndexedPrimitives:*v51 indexCount:v51[1] indexType:v51[2] indexBuffer:v71 indexBufferOffset:v54 instanceCount:v51[4] baseVertex:v51[5] baseInstance:v51[6]];
            }
            else {
              [v46 reset];
            }

            break;
          case 3:
          case 5:
          case 6:
          case 7:
            break;
          case 4:
            uint64_t v56 = v147;
            long long v57 = (void *)(v147 + v44);
            unint64_t v58 = *(void *)(v147 + v44 + 48);
            long long v59 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*a6 + 24), *(int *)(*a6 + 12), v58);
            uint64_t v60 = v44;
            if (v59)
            {
              unint64_t v123 = v58 - *v59;
              uint64_t v61 = v59[2];
            }
            else
            {
              unint64_t v123 = 0;
              uint64_t v61 = 0;
            }
            long long v72 = GetObjectForKey(v136, v61);
            BOOL v73 = v61 == 0;
            long long v74 = (unint64_t *)(v60 + v56);
            unint64_t v75 = *v74;
            long long v76 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*a6 + 24), *(int *)(*a6 + 12), *v74);
            uint64_t v77 = v42;
            if (v76)
            {
              unint64_t v78 = v75 - *v76;
              uint64_t v79 = v76[2];
            }
            else
            {
              unint64_t v78 = 0;
              uint64_t v79 = 0;
            }
            uint64_t v85 = GetObjectForKey(v136, v79);
            uint64_t v86 = (void *)v85;
            if (v85) {
              int v87 = (v72 != 0) ^ v73;
            }
            else {
              int v87 = 0;
            }
            if (v87 == 1) {
              [v46 drawPatches:v57[3] patchStart:v57[4] patchCount:v57[5] patchIndexBuffer:v72 patchIndexBufferOffset:v123 instanceCount:v57[7] baseInstance:v57[8] tessellationFactorBuffer:v85 tessellationFactorBufferOffset:v78 tessellationFactorBufferInstanceStride:v74[1]];
            }
            else {
              [v46 reset];
            }
            uint64_t v41 = v118;
            uint64_t v42 = v77;
            uint64_t v44 = v60;
            goto LABEL_83;
          case 8:
            uint64_t v62 = v147;
            uint64_t v63 = v147 + v44;
            unint64_t v64 = *(void *)(v147 + v44 + 48);
            long long v65 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*a6 + 24), *(int *)(*a6 + 12), v64);
            uint32x2_t v133 = v43;
            uint64_t v66 = v44;
            if (v65)
            {
              unint64_t v124 = v64 - *v65;
              uint64_t v67 = v65[2];
            }
            else
            {
              unint64_t v124 = 0;
              uint64_t v67 = 0;
            }
            long long v80 = (void *)(v63 + 24);
            long long v72 = GetObjectForKey(v136, v67);
            BOOL v81 = v67 == 0;
            unint64_t v82 = v80[4];
            BOOL v83 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*a6 + 24), *(int *)(*a6 + 12), v82);
            if (v83)
            {
              unint64_t v120 = v82 - *v83;
              uint64_t v84 = v83[2];
            }
            else
            {
              unint64_t v120 = 0;
              uint64_t v84 = 0;
            }
            uint64_t v86 = GetObjectForKey(v136, v84);
            if (v86) {
              int v88 = (v72 != 0) ^ v81;
            }
            else {
              int v88 = 0;
            }
            uint64_t v89 = v66 + v62;
            unint64_t v90 = *(void *)(v66 + v62);
            BOOL v91 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*a6 + 24), *(int *)(*a6 + 12), v90);
            if (v91)
            {
              unint64_t v92 = v90 - *v91;
              uint64_t v93 = v91[2];
            }
            else
            {
              unint64_t v92 = 0;
              uint64_t v93 = 0;
            }
            uint64_t v94 = GetObjectForKey(v136, v93);
            int64_t v95 = (void *)v94;
            if (v94) {
              int v96 = v88;
            }
            else {
              int v96 = 0;
            }
            if (v96 == 1) {
              [v46 drawIndexedPatches:*v80 patchStart:v80[1] patchCount:v80[2] patchIndexBuffer:v72 patchIndexBufferOffset:v124 controlPointIndexBuffer:v86 controlPointIndexBufferOffset:v120 instanceCount:v80[5] baseInstance:v80[6] tessellationFactorBuffer:v94 tessellationFactorBufferOffset:v92 tessellationFactorBufferInstanceStride:*(void *)(v89 + 8)];
            }
            else {
              [v46 reset];
            }
            uint64_t v41 = v118;
            int v43 = v133;
            uint64_t v44 = v66;

LABEL_83:
            break;
          default:
            if (v47 == 128)
            {
              uint64_t v68 = *(void *)(v44 + v147 + 16);
              long long v154 = *(_OWORD *)(v44 + v147);
              *(void *)&long long v155 = v68;
              uint64_t v69 = *(void *)(v44 + v147 + 40);
              long long v159 = *(_OWORD *)(v44 + v147 + 24);
              uint64_t v160 = v69;
              uint64_t v70 = *(void *)(v44 + v147 + 64);
              long long v157 = *(_OWORD *)(v44 + v147 + 48);
              uint64_t v158 = v70;
              [v45 drawMeshThreadgroups:&v154 threadsPerObjectThreadgroup:&v159 threadsPerMeshThreadgroup:&v157];
            }
            else if (v47 == 256)
            {
              uint64_t v48 = *(void *)(v44 + v147 + 16);
              long long v152 = *(_OWORD *)(v44 + v147);
              uint64_t v153 = v48;
              uint64_t v49 = *(void *)(v44 + v147 + 40);
              long long v150 = *(_OWORD *)(v44 + v147 + 24);
              uint64_t v151 = v49;
              uint64_t v50 = *(void *)(v44 + v147 + 64);
              long long v148 = *(_OWORD *)(v44 + v147 + 48);
              uint64_t v149 = v50;
              [v45 drawMeshThreads:&v152 threadsPerObjectThreadgroup:&v150 threadsPerMeshThreadgroup:&v148];
            }
            break;
        }
        uint64_t v97 = (unsigned char *)v141;
        if (!*(unsigned char *)(v141 + 11))
        {
          uint64_t v98 = *(void *)(v44 + v142);
          if (v98)
          {
            uint64_t v99 = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier(a6[3], v98);
            __int8 v100 = GetObjectForKey(v136, v99);
            if (v100) {
              [v46 setRenderPipelineState:v100];
            }
          }
        }
        if (v97[19]) {
          uint64_t v101 = v44 + v146;
        }
        else {
          uint64_t v101 = 0;
        }
        if (!v97[10])
        {
          uint64_t v121 = v44;
          uint64_t v125 = v42;
          __int8 v134 = v43;
          uint64_t v102 = *((void *)&v142 + 1);
          uint64_t v103 = v97[18];
          id v104 = v46;
          id v105 = v136;
          if (v103)
          {
            uint64_t v106 = 0;
            uint64_t v107 = v42 + v102;
            do
            {
              uint64_t v108 = *(void *)(v107 + 8 * v106);
              if (v108)
              {
                uint32x2_t v109 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*a6 + 24), *(int *)(*a6 + 12), *(void *)(v107 + 8 * v106));
                if (v109)
                {
                  uint64_t v110 = v108 - *v109;
                  uint64_t v111 = v109[2];
                }
                else
                {
                  uint64_t v110 = 0;
                  uint64_t v111 = 0;
                }
                BOOL v112 = GetObjectForKey(v105, v111);
                if (v112)
                {
                  if (v101) {
                    [v104 setVertexBuffer:v112 offset:v110 attributeStride:*(void *)(v101 + 8 * v106) atIndex:v106];
                  }
                  else {
                    [v104 setVertexBuffer:v112 offset:v110 atIndex:v106];
                  }
                }
              }
              ++v106;
            }
            while (v103 != v106);
          }

          uint64_t v44 = v121;
          GTMTLEncodeIndirectBufferBindings(v104, v121 + v143, v97[12], 2, (uint64_t)a6, v105);
          GTMTLEncodeIndirectBufferBindings(v104, v121 + *((void *)&v143 + 1), v97[16], 8, (uint64_t)a6, v105);
          GTMTLEncodeIndirectBufferBindings(v104, v121 + v144, v97[15], 16, (uint64_t)a6, v105);
          uint64_t v41 = v118;
          uint64_t v42 = v125;
          int v43 = v134;
        }
        if (v97[17])
        {
          unint64_t v113 = 0;
          uint64_t v114 = v42 + v145;
          do
          {
            [v46 setObjectThreadgroupMemoryLength:*(void *)(v114 + 8 * v113) atIndex:v113];
            ++v113;
          }
          while (v113 < v97[17]);
        }
        if (v97[21] && *(void *)(v44 + *((void *)&v146 + 1))) {
          [v46 setBarrier];
        }
LABEL_112:

        a2 = v139 + 1;
        v42 += v41;
      }
      while (v139 + 1 != v129);
    }

    uint64_t v40 = v131;
LABEL_114:

    id v12 = v115;
    id v11 = v116;
    goto LABEL_115;
  }
  if ((v13 & 0xFFFFFF9F) == 0)
  {
    id v116 = v11;
    id v132 = v11;
    id v115 = v12;
    id v14 = v12;
    uint64_t v130 = a2 + a3;
    if (a2 < a2 + a3)
    {
      uint64_t v15 = *((void *)&v147 + 1);
      uint64_t v122 = v147;
      long long v16 = (unsigned char *)v141;
      uint64_t v117 = v142;
      uint64_t v119 = v147 + 72;
      uint64_t v126 = v146;
      uint64_t v128 = *((void *)&v141 + 1);
      uint64_t v17 = a5 + *((void *)&v144 + 1) + a2 * *((void *)&v147 + 1);
      uint64_t v18 = a5 + *((void *)&v145 + 1) + a2 * *((void *)&v147 + 1);
      while (1)
      {
        uint64_t v20 = a5 + v15 * a2;
        uint64_t v21 = *(void *)(v20 + v128);
        unint64_t v138 = a2;
        long long v22 = [v132 indirectComputeCommandAtIndex:a2];
        uint64_t v23 = v22;
        if (v21 == 64) {
          break;
        }
        if (v21 == 32)
        {
          uint64_t v24 = *(void *)(v20 + v119 + 16);
          long long v159 = *(_OWORD *)(v20 + v119);
          uint64_t v160 = v24;
          uint64_t v25 = *(void *)(v20 + v119 + 40);
          long long v157 = *(_OWORD *)(v20 + v119 + 24);
          uint64_t v158 = v25;
          [v22 concurrentDispatchThreadgroups:&v159 threadsPerThreadgroup:&v157];
          goto LABEL_11;
        }
        if (v21) {
          goto LABEL_13;
        }
        [v22 reset];
LABEL_33:

        a2 = v138 + 1;
        v17 += v15;
        v18 += v15;
        if (v138 + 1 == v130) {
          goto LABEL_34;
        }
      }
      uint64_t v26 = *(void *)(v20 + v119 + 16);
      long long v152 = *(_OWORD *)(v20 + v119);
      uint64_t v153 = v26;
      uint64_t v27 = *(void *)(v20 + v119 + 40);
      long long v150 = *(_OWORD *)(v20 + v119 + 24);
      uint64_t v151 = v27;
      [v22 concurrentDispatchThreads:&v152 threadsPerThreadgroup:&v150];
LABEL_11:
      long long v28 = *(_OWORD *)(v20 + v122 + 16);
      long long v154 = *(_OWORD *)(v20 + v122);
      long long v155 = v28;
      long long v156 = *(_OWORD *)(v20 + v122 + 32);
      [v23 setStageInRegion:&v154];
      if (*(unsigned char *)(v20 + v122 + 64)) {
        [v23 setBarrier];
      }
LABEL_13:
      unint64_t v135 = v19;
      if (!v16[11])
      {
        uint64_t v29 = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier(a6[4], *(void *)(v20 + v117));
        unint64_t v30 = GetObjectForKey(v14, v29);
        [v23 setComputePipelineState:v30];
      }
      if (v16[19]) {
        uint64_t v31 = v20 + v126;
      }
      else {
        uint64_t v31 = 0;
      }
      if (!v16[10])
      {
        unsigned __int8 v32 = v16[13];
        if (v32)
        {
          for (unint64_t i = 0; i < v32; ++i)
          {
            uint64_t v34 = *(void *)(v17 + 8 * i);
            if (v34)
            {
              uint64_t v35 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*a6 + 24), *(int *)(*a6 + 12), *(void *)(v17 + 8 * i));
              if (v35)
              {
                uint64_t v36 = v34 - *v35;
                uint64_t v37 = v35[2];
              }
              else
              {
                uint64_t v36 = 0;
                uint64_t v37 = 0;
              }
              BOOL v38 = GetObjectForKey(v14, v37);
              if (v31) {
                [v23 setKernelBuffer:v38 offset:v36 attributeStride:*(void *)(v31 + 8 * i) atIndex:i];
              }
              else {
                [v23 setKernelBuffer:v38 offset:v36 atIndex:i];
              }

              unsigned __int8 v32 = v16[13];
            }
          }
        }
      }
      uint64_t v19 = v135;
      if (v16[14])
      {
        unint64_t v39 = 0;
        do
        {
          [v23 setThreadgroupMemoryLength:*(void *)(v18 + 8 * v39) atIndex:v39];
          ++v39;
        }
        while (v39 < v16[14]);
      }
      goto LABEL_33;
    }
LABEL_34:

    uint64_t v40 = v132;
    goto LABEL_114;
  }
LABEL_115:
}

void GTMTLEncodeIndirectBufferBindings(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  id v18 = a1;
  id v11 = a6;
  if (a3)
  {
    uint64_t v12 = 0;
    do
    {
      uint64_t v13 = *(void *)(a2 + 8 * v12);
      if (v13)
      {
        id v14 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*(void *)a5 + 24), *(int *)(*(void *)a5 + 12), *(void *)(a2 + 8 * v12));
        if (v14)
        {
          uint64_t v15 = v13 - *v14;
          uint64_t v16 = v14[2];
        }
        else
        {
          uint64_t v15 = 0;
          uint64_t v16 = 0;
        }
        uint64_t v17 = GetObjectForKey(v11, v16);
        if (v17)
        {
          switch(a4)
          {
            case 16:
              [v18 setMeshBuffer:v17 offset:v15 atIndex:v12];
              break;
            case 8:
              [v18 setObjectBuffer:v17 offset:v15 atIndex:v12];
              break;
            case 2:
              [v18 setFragmentBuffer:v17 offset:v15 atIndex:v12];
              break;
          }
        }
      }
      ++v12;
    }
    while (a3 != v12);
  }
}

CFStringRef _StringForError(uint64_t a1)
{
  if (a1 <= 511)
  {
    switch(a1)
    {
      case 1:
        return (const __CFString *)+[NSString stringWithFormat:@"invalid filename (%ld)", 1];
      case 2:
        return (const __CFString *)+[NSString stringWithFormat:@"data is too large (%ld)", 2];
      case 3:
        return (const __CFString *)+[NSString stringWithFormat:@"IO failure (%ld)", 3];
      case 4:
        return (const __CFString *)+[NSString stringWithFormat:@"out of memory (%ld)", 4];
      case 5:
        uint64_t v3 = 5;
        goto LABEL_64;
      case 6:
        uint64_t v3 = 6;
LABEL_64:
        CFStringRef result = +[NSString stringWithFormat:@"Unable to connect to the device. (%ld)", v3];
        break;
      case 7:
        CFStringRef result = +[NSString stringWithFormat:@"read-only capture archive (%ld)", 7];
        break;
      case 8:
        CFStringRef result = +[NSString stringWithFormat:@"truncated capture archive store (%ld)", 8];
        break;
      case 9:
        CFStringRef result = +[NSString stringWithFormat:@"truncated capture archive index (%ld)", 9];
        break;
      case 10:
        CFStringRef result = +[NSString stringWithFormat:@"invalid capture archive index (%ld)", 10];
        break;
      case 11:
        CFStringRef result = +[NSString stringWithFormat:@"unknown capture archive index version (%ld)", 11];
        break;
      case 12:
        CFStringRef result = +[NSString stringWithFormat:@"file exists in capture archive (%ld)", 12];
        break;
      case 13:
        CFStringRef result = +[NSString stringWithFormat:@"file does not exists in capture archive (%ld)", 13];
        break;
      case 14:
        CFStringRef result = +[NSString stringWithFormat:@"capture archive does not exist (%ld)", 14];
        break;
      case 15:
        CFStringRef result = +[NSString stringWithFormat:@"missing capture archive index (%ld)", 15];
        break;
      case 16:
        CFStringRef result = +[NSString stringWithFormat:@"invalid capture archive metadata (%ld)", 16];
        break;
      case 17:
      case 27:
        return 0;
      case 18:
        CFStringRef result = +[NSString stringWithFormat:@"corrupted capture archive store (%ld)", 18];
        break;
      case 19:
        CFStringRef result = +[NSString stringWithFormat:@"could not write capture archive metadata (%ld)", 19];
        break;
      case 20:
        CFStringRef result = +[NSString stringWithFormat:@"capture archive has been closed (%ld)", 20];
        break;
      case 21:
        CFStringRef result = +[NSString stringWithFormat:@"already tried to launch guest app (%ld)", 21];
        break;
      case 22:
        CFStringRef result = +[NSString stringWithFormat:@"invalid launch dictionary (%ld)", 22];
        break;
      case 23:
        CFStringRef result = +[NSString stringWithFormat:@"guest app not found (%ld)", 23];
        break;
      case 24:
        CFStringRef result = +[NSString stringWithFormat:@"guest app launch timed out (%ld)", 24];
        break;
      case 25:
        CFStringRef result = +[NSString stringWithFormat:@"invalid guest app session (%ld)", 25];
        break;
      case 26:
        CFStringRef result = +[NSString stringWithFormat:@"guest app has not been launched yet (%ld)", 26];
        break;
      case 28:
        CFStringRef result = +[NSString stringWithFormat:@"did not find interpose dylib (%ld)", 28];
        break;
      case 29:
        CFStringRef result = +[NSString stringWithFormat:@"failed to launch guest app (%ld)", 29];
        break;
      case 30:
        CFStringRef result = +[NSString stringWithFormat:@"guest app terminated (%ld)", 30];
        break;
      case 31:
        CFStringRef result = +[NSString stringWithFormat:@"lost transport connection (%ld)", 31];
        break;
      case 32:
        CFStringRef result = +[NSString stringWithFormat:@"invalid transport (%ld)", 32];
        break;
      case 33:
        CFStringRef result = +[NSString stringWithFormat:@"transport is not connected (%ld)", 33];
        break;
      case 34:
        CFStringRef result = +[NSString stringWithFormat:@"message has already been sent (%ld)", 34];
        break;
      case 35:
        CFStringRef result = +[NSString stringWithFormat:@"in-reply-to message has not been sent (%ld)", 35];
        break;
      case 36:
        CFStringRef result = +[NSString stringWithFormat:@"failed to encode message attributes (%ld)", 36];
        break;
      case 37:
        CFStringRef result = +[NSString stringWithFormat:@"connect timed out (%ld)", 37];
        break;
      case 38:
        CFStringRef result = +[NSString stringWithFormat:@"undefined socket path (%ld)", 38];
        break;
      case 39:
        CFStringRef result = +[NSString stringWithFormat:@"socket path is too long (%ld)", 39];
        break;
      case 40:
        CFStringRef result = +[NSString stringWithFormat:@"message originated from this transport (%ld)", 40];
        break;
      case 41:
        CFStringRef result = +[NSString stringWithFormat:@"initialized function stream with immutable data but swapping is required (%ld)", 41];
        break;
      case 42:
        CFStringRef result = +[NSString stringWithFormat:@"transfer refused (%ld)", 42];
        break;
      case 43:
        CFStringRef result = +[NSString stringWithFormat:@"protocol error (%ld)", 43];
        break;
      case 44:
        CFStringRef result = +[NSString stringWithFormat:@"path outside destination root (%ld)", 44];
        break;
      case 45:
        CFStringRef result = +[NSString stringWithFormat:@"transfer aborted (%ld)", 45];
        break;
      case 46:
        CFStringRef result = +[NSString stringWithFormat:@"unknown item type (%ld)", 46];
        break;
      default:
        switch(a1)
        {
          case 256:
            CFStringRef result = +[NSString stringWithFormat:@"invalid socket descriptor (%ld)", 256];
            break;
          case 257:
            CFStringRef result = +[NSString stringWithFormat:@"invalid socket url (%ld)", 257];
            break;
          case 258:
            CFStringRef result = +[NSString stringWithFormat:@"transport source cancelled (%ld)", 258];
            break;
          case 259:
            CFStringRef result = +[NSString stringWithFormat:@"corrupt transport message header (%ld)", 259];
            break;
          case 260:
            CFStringRef result = +[NSString stringWithFormat:@"corrupt transport message attributes (%ld)", 260];
            break;
          case 261:
            CFStringRef result = +[NSString stringWithFormat:@"message too large (%ld)", 261];
            break;
          default:
            return 0;
        }
        break;
    }
    return result;
  }
  if (a1 <= 2047)
  {
    if (a1 <= 1023)
    {
      uint64_t v2 = a1 - 512;
      CFStringRef result = @"Device connection lost.";
      switch(v2)
      {
        case 0:
          CFStringRef result = +[NSString stringWithFormat:@"guest app crashed (%ld)", 512];
          break;
        case 1:
          CFStringRef result = +[NSString stringWithFormat:@"another capture session is active (%ld)", 513];
          break;
        case 2:
          CFStringRef result = +[NSString stringWithFormat:@"capture session is already active (%ld)", 514];
          break;
        case 3:
          CFStringRef result = +[NSString stringWithFormat:@"capture session activation failed (%ld)", 515];
          break;
        case 4:
          CFStringRef result = +[NSString stringWithFormat:@"inferior already running (%ld)", 516];
          break;
        case 5:
          CFStringRef result = +[NSString stringWithFormat:@"GL dispatch table mismatch (%ld)", 517];
          break;
        case 6:
          CFStringRef result = +[NSString stringWithFormat:@"inferior and host session ids mismatch (%ld)", 518];
          break;
        case 7:
          return result;
        default:
          return 0;
      }
      return result;
    }
    if (a1 <= 1279)
    {
      switch(a1)
      {
        case 1024:
          return (const __CFString *)+[NSString stringWithFormat:@"truncated data (%ld)", 1024];
        case 1025:
          return (const __CFString *)+[NSString stringWithFormat:@"invalid transport message payload (%ld)", 1025];
        case 1026:
          return (const __CFString *)+[NSString stringWithFormat:@"unexpected transport message (%ld)", 1026];
      }
    }
    else if (a1 > 1791)
    {
      if (a1 == 1792) {
        return (const __CFString *)+[NSString stringWithFormat:@"no data (%ld)", 1792];
      }
      if (a1 == 1793) {
        return (const __CFString *)+[NSString stringWithFormat:@"guest app session error (%ld)", 1793];
      }
    }
    else
    {
      if (a1 == 1280) {
        return (const __CFString *)+[NSString stringWithFormat:@"invalid function stream header (%ld)", 1280];
      }
      if (a1 == 1536) {
        return (const __CFString *)+[NSString stringWithFormat:@"position does not exist in archive (%ld)", 1536];
      }
    }
    return 0;
  }
  if (a1 <= 4351)
  {
    if (a1 > 2304)
    {
      switch(a1)
      {
        case 2305:
          return (const __CFString *)+[NSString stringWithFormat:@"no archive data (%ld)", 2305];
        case 2306:
          return (const __CFString *)+[NSString stringWithFormat:@"no thumbnail support (%ld)", 2306];
        case 4096:
          return (const __CFString *)+[NSString stringWithFormat:@"failed to create core symbolicator (%ld)", 4096];
      }
    }
    else
    {
      switch(a1)
      {
        case 2048:
          return (const __CFString *)+[NSString stringWithFormat:@"already replaying (%ld)", 2048];
        case 2049:
          return (const __CFString *)+[NSString stringWithFormat:@"no loaded archives (%ld)", 2049];
        case 2304:
          return (const __CFString *)+[NSString stringWithFormat:@"no resource streamer (%ld)", 2304];
      }
    }
    return 0;
  }
  switch(a1)
  {
    case 4608:
      CFStringRef result = +[NSString stringWithFormat:@"Cannot find the specified username and host (%ld)", 4608];
      break;
    case 4609:
      CFStringRef result = +[NSString stringWithFormat:@"Specified remote machine is not available. Please make sure to login with specified user (%ld)", 4609];
      break;
    case 4610:
      CFStringRef result = +[NSString stringWithFormat:@"Cannot find the target path provided (%ld)", 4610];
      break;
    case 4611:
      CFStringRef result = +[NSString stringWithFormat:@"Cannot authenticate SSH, make sure the authentication is done right (%ld)", 4611];
      break;
    case 4612:
      CFStringRef result = +[NSString stringWithFormat:@"Cannot find Xcode.app on the remote machine. Please make sure that Xcode.app is in the Applications folder (%ld)", 4612];
      break;
    case 4613:
      CFStringRef result = +[NSString stringWithFormat:@"Metal.framework is not available on the remote machine (%ld)", 4613];
      break;
    case 4614:
      CFStringRef result = +[NSString stringWithFormat:@"Missing environment variables, please make sure all the required environment variables are enabled (%ld)", 4614];
      break;
    default:
      if (a1 == 4352)
      {
        CFStringRef result = +[NSString stringWithFormat:@"Shader profiler failed due to an internal error (%ld)", 4352];
      }
      else
      {
        if (a1 != 4353) {
          return 0;
        }
        CFStringRef result = +[NSString stringWithFormat:@"Shader profiler does not support multi-context captures (%ld)", 4353];
      }
      break;
  }
  return result;
}

void sub_218B08(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_218C30(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void sub_2190A4()
{
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v0);
  operator delete();
}

void sub_21AE58(_Unwind_Exception *exception_object)
{
}

void sub_21AE90(void *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    if (a2 == 2)
    {
      *(void *)(v2 + 40) = 0;
      objc_end_catch();
    }
    JUMPOUT(0x21ADECLL);
  }
  JUMPOUT(0x21AE80);
}

void __Block_byref_object_copy__1487(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__1488(uint64_t a1)
{
}

void sub_21D83C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t GPUTools::VMBuffer::_alloc(GPUTools::VMBuffer *this, vm_size_t a2, uint64_t a3)
{
  int v3 = 0;
  vm_address_t address = 0;
  if (3 * vm_page_size <= a2) {
    vm_size_t v4 = (a2 + vm_page_size - 1) & -(uint64_t)vm_page_size;
  }
  else {
    vm_size_t v4 = 3 * vm_page_size;
  }
  vm_size_t v5 = v4 + v4 * a3;
  while (1)
  {
    vm_map_t v6 = mach_task_self_;
    vm_size_t v7 = vm_page_size + v5;
    if (!vm_allocate(mach_task_self_, &address, vm_page_size + v5, 1))
    {
      vm_address_t v8 = address;
      vm_address_t v9 = address + v4;
      target_vm_address_t address = address + v4;
      uint64_t v10 = a3;
      if (a3)
      {
        while (!vm_deallocate(v6, v9, v4))
        {
          cur_protectiouint64_t n = 0;
          if (vm_remap(v6, &target_address, v4, 0, 0, v6, address, 0, (vm_prot_t *)&cur_protection + 1, (vm_prot_t *)&cur_protection, 2u))
          {
            break;
          }
          vm_address_t v9 = target_address + v4;
          target_address += v4;
          if (!--v10)
          {
            vm_address_t v8 = address;
            goto LABEL_11;
          }
        }
        goto LABEL_12;
      }
LABEL_11:
      if (!vm_protect(v6, v8 + v7 - vm_page_size, vm_page_size, 0, 0)) {
        break;
      }
    }
LABEL_12:
    vm_deallocate(mach_task_self_, address, vm_page_size + v5);
    if (++v3 == 5) {
      return 0;
    }
  }
  *(void *)this = address;
  *((void *)this + 1) = v4;
  *((void *)this + 2) = a3;
  return 1;
}

vm_address_t *GPUTools::VMBuffer::_dealloc(vm_address_t *this)
{
  if (*this)
  {
    uint64_t v1 = this;
    this = (vm_address_t *)vm_deallocate(mach_task_self_, *this, vm_page_size + this[1] + this[1] * this[2]);
    v1[1] = 0;
    v1[2] = 0;
    *uint64_t v1 = 0;
  }
  return this;
}

void sub_21E2C4()
{
}

void sub_21E384()
{
}

void sub_220718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t smt_poll_thread_entry(void *a1)
{
  uint64_t v2 = a1[1];
  int v3 = (void *)a1[2];
  snprintf(__str, 0x40uLL, "gputools.smt_poll.%p", a1);
  pthread_setname_np(__str);
  while (!*((unsigned char *)a1 + 24))
  {
    dispatch_sync(v2, v3);
    usleep(0x1F40u);
  }

  return 0;
}

void sub_221828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL CallIO<AGXConsistentPerfStateControlRec,AGXConsistentPerfStateControlRec>(mach_port_t a1, void *inputStruct, void *outputStruct, uint64_t a4)
{
  if (!a1) {
    return 0;
  }
  size_t outputStructCnt = 8;
  uint64_t v5 = IOConnectCallStructMethod(a1, 0x41u, inputStruct, 8uLL, outputStruct, &outputStructCnt);
  BOOL v6 = v5 == 0;
  if (v5 && g_runningInCI)
  {
    vm_size_t v7 = +[NSString stringWithFormat:@"IOConnectCallStructMethod method:%u for:%s failed (0x%x - %s)", 65, a4, v5, mach_error_string(v5)];
    vm_address_t v8 = [v7 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "];

    vm_address_t v9 = __stdoutp;
    id v10 = v8;
    fprintf(v9, "#CI-ERROR# %s\n", (const char *)[v10 UTF8String]);
  }
  return v6;
}

void sub_222E28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t RecommendedState(void *a1, uint64_t a2, unsigned int a3)
{
  id v5 = a1;
  BOOL v6 = v5;
  if (v5)
  {
    [v5 doubleValue];
    double v8 = v7;
    vm_address_t v9 = (double *)operator new(0x18uLL);
    uint64_t v10 = 0;
    LODWORD(v11) = 0;
    *vm_address_t v9 = (double)a2;
    v9[1] = (double)HIDWORD(a2);
    v9[2] = (double)a3;
    double v12 = 1.79769313e308;
    do
    {
      double v13 = vabdd_f64(v9[v10], v8 + -2.22044605e-16);
      double v14 = v13 + (double)v10++ * 0.2;
      if (v14 >= v12)
      {
        uint64_t v11 = v11;
      }
      else
      {
        double v12 = v13;
        uint64_t v11 = v10;
      }
    }
    while (v10 != 3);
    operator delete(v9);
  }
  else
  {
    uint64_t v11 = 0;
  }

  return v11;
}

void sub_222F04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTAGXPerfStateControl::InitWithDevice(uint64_t a1, void *a2)
{
  id v10 = a2;
  if ((objc_opt_respondsToSelector() & 1) != 0
    && (objc_opt_respondsToSelector() & 1) != 0
    && (objc_opt_respondsToSelector() & 1) != 0
    && (objc_opt_respondsToSelector() & 1) != 0)
  {
    objc_storeStrong((id *)(a1 + 16), a2);
    goto LABEL_11;
  }
  io_service_t IOAccelerator = GetIOAccelerator();
  if (IOServiceOpen(IOAccelerator, mach_task_self_, 1u, (io_connect_t *)a1))
  {
    int v5 = 2;
LABEL_10:
    *(_DWORD *)(a1 + 4) = v5;
    goto LABEL_11;
  }
  uint64_t outputStruct = 258;
  if (CallIO<AGXConsistentPerfStateControlRec,AGXConsistentPerfStateControlRec>(*(_DWORD *)a1, &outputStruct, &outputStruct, (uint64_t)"ConsistentPerfState_Get"))
  {
    int v5 = 1;
    goto LABEL_10;
  }
  if (g_runningInCI)
  {
    BOOL v6 = +[NSString stringWithFormat:@"Error, fail to get consistent perf status!\n"];
    double v7 = [v6 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "];

    double v8 = __stdoutp;
    id v9 = v7;
    fprintf(v8, "#CI-ERROR# %s\n", (const char *)[v9 UTF8String]);
  }
  *(_DWORD *)(a1 + 4) = 2;
  if (*(_DWORD *)a1)
  {
    IOServiceClose(*(_DWORD *)a1);
    *(_DWORD *)a1 = 0;
  }
LABEL_11:
}

void sub_2230B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  _Unwind_Resume(a1);
}

void GTAGXPerfStateControl::EnableConsistentGPUPerfState(uint64_t a1, uint64_t a2)
{
  vm_size_t v4 = *(void **)(a1 + 16);
  if (v4)
  {
    if ([v4 enableConsistentPerfState:a2])
    {
      usleep(0x186A0u);
    }
    else if (g_runningInCI)
    {
      +[NSString stringWithFormat:@"Error, fail to set consistent perf state to level = %u!\n", a2];
      id v18 = (id)objc_claimAutoreleasedReturnValue();
      uint64_t v16 = [v18 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "];

      uint64_t v17 = __stdoutp;
      id v19 = v16;
      fprintf(v17, "#CI-ERROR# %s\n", (const char *)[v19 UTF8String]);
    }
  }
  else
  {
    mach_port_t v5 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      uint64_t outputStruct = 256;
      BOOL v6 = CallIO<AGXConsistentPerfStateControlRec,AGXConsistentPerfStateControlRec>(v5, &outputStruct, &outputStruct, (uint64_t)"ConsistentPerfState_Lock");
      *(unsigned char *)(a1 + 8) = v6;
      if (!v6 && g_runningInCI)
      {
        double v7 = +[NSString stringWithFormat:@"Error, fail to acquire consistent perf state SPI access!\n"];
        double v8 = [v7 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "];

        id v9 = __stdoutp;
        id v10 = v8;
        fprintf(v9, "#CI-ERROR# %s\n", (const char *)[v10 UTF8String]);
      }
      if (v6)
      {
        uint64_t outputStruct = 1;
        BYTE1(outputStruct) = a2;
        BOOL v11 = CallIO<AGXConsistentPerfStateControlRec,AGXConsistentPerfStateControlRec>(*(_DWORD *)a1, &outputStruct, &outputStruct, (uint64_t)"ConsistentPerfState_Set");
        if (!v11 && g_runningInCI)
        {
          double v12 = +[NSString stringWithFormat:@"Error, fail to set consistent perf state to level = %u!\n", a2];
          double v13 = [v12 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "];

          double v14 = __stdoutp;
          id v15 = v13;
          fprintf(v14, "#CI-ERROR# %s\n", (const char *)[v15 UTF8String]);
        }
        if (v11) {
          usleep(0x30D40u);
        }
      }
    }
  }
}

void sub_223378(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  _Unwind_Resume(a1);
}

void GTAGXPerfStateControl::DisableConsistentGPUPerfState(GTAGXPerfStateControl *this)
{
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    [v2 disableConsistentPerfState];
  }
  else
  {
    mach_port_t v3 = *(_DWORD *)this;
    if (*(_DWORD *)this)
    {
      if (*((unsigned char *)this + 8))
      {
        uint64_t outputStruct = 0;
        if (!CallIO<AGXConsistentPerfStateControlRec,AGXConsistentPerfStateControlRec>(v3, &outputStruct, &outputStruct, (uint64_t)"ConsistentPerfState_Unlock"))
        {
          if (g_runningInCI)
          {
            vm_size_t v4 = +[NSString stringWithFormat:@"Error, fail to release consistent perf state SPI access!\n"];
            mach_port_t v5 = [v4 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "];

            BOOL v6 = __stdoutp;
            id v7 = v5;
            fprintf(v6, "#CI-ERROR# %s\n", (const char *)[v7 UTF8String]);
          }
        }
      }
    }
  }
}

void sub_2234A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_UNKNOWN **GTAGXPerfStateControl::ConsistentGPUPerfStateLevel(GTAGXPerfStateControl *this, NSNumber *a2)
{
  mach_port_t v3 = a2;
  vm_size_t v4 = (void *)*((void *)this + 2);
  unint64_t v58 = v3;
  if (v4)
  {
    mach_port_t v5 = [v4 getConsistentPerfStateInfoAndReset:1];
    if (!v5)
    {
      if (g_runningInCI)
      {
        uint64_t v40 = +[NSString stringWithFormat:@"Error, fail to get consistent perf state status!\n"];
        uint64_t v41 = [v40 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "];

        uint64_t v42 = __stdoutp;
        id v43 = v41;
        fprintf(v42, "#CI-ERROR# %s\n", (const char *)[v43 UTF8String]);
      }
      BOOL v6 = &off_7591C0;
      goto LABEL_30;
    }
    BOOL v6 = (_UNKNOWN **)objc_opt_new();
    [v6 setObject:&__kCFBooleanTrue forKeyedSubscript:@"supported"];
    id v7 = [v5 objectForKeyedSubscript:@"is_enabled"];
    double v8 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [v7 BOOLValue]);
    [v6 setObject:v8 forKeyedSubscript:@"enabled"];

    id v9 = [v5 objectForKeyedSubscript:@"was_consistent"];
    id v10 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [v9 BOOLValue]);
    [v6 setObject:v10 forKeyedSubscript:@"consistent"];

    BOOL v11 = [v5 objectForKeyedSubscript:@"level"];
    double v12 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v11 unsignedIntValue]);
    [v6 setObject:v12 forKeyedSubscript:@"level"];

    double v13 = [*((id *)this + 2) getConsistentPerfStateMappingTable];
    double v14 = v13;
    if (!v13)
    {
      if (g_runningInCI)
      {
        uint64_t v44 = +[NSString stringWithFormat:@"Error, fail to get consistent perf mapping table!\n"];
        id v45 = [v44 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "];

        unsigned int v46 = __stdoutp;
        id v47 = v45;
        fprintf(v46, "#CI-ERROR# %s\n", (const char *)[v47 UTF8String]);
      }
      goto LABEL_29;
    }
    id v15 = [v13 objectForKeyedSubscript:@"min_pstate"];
    id v16 = [v15 unsignedIntValue];
    uint64_t v17 = [v14 objectForKeyedSubscript:@"mid_pstate"];
    id v18 = [v17 unsignedIntValue];
    id v19 = [v14 objectForKeyedSubscript:@"max_pstate"];
    id v20 = [v19 unsignedIntValue];

    uint64_t v21 = +[NSNumber numberWithUnsignedInt:RecommendedState(v58, v16 | ((void)v18 << 32), v20)];
    [v6 setObject:v21 forKeyedSubscript:@"recommended"];

    long long v22 = +[NSNumber numberWithUnsignedInt:v16];
    v60[0] = v22;
    uint64_t v23 = +[NSNumber numberWithUnsignedInt:v18];
    v60[1] = v23;
    uint64_t v24 = +[NSNumber numberWithUnsignedInt:v20];
    void v60[2] = v24;
    uint64_t v25 = +[NSArray arrayWithObjects:v60 count:3];
    [v6 setObject:v25 forKeyedSubscript:@"mapped state"];

    uint64_t v26 = [v5 objectForKeyedSubscript:@"level"];
    unsigned int v27 = [v26 unsignedIntValue];

    switch(v27)
    {
      case 1u:
        long long v28 = +[NSNumber numberWithUnsignedInt:v16];
        [v6 setObject:v28 forKeyedSubscript:@"mapping"];
        break;
      case 2u:
        long long v28 = +[NSNumber numberWithUnsignedInt:v18];
        [v6 setObject:v28 forKeyedSubscript:@"mapping"];
        break;
      case 3u:
        long long v28 = +[NSNumber numberWithUnsignedInt:v20];
        [v6 setObject:v28 forKeyedSubscript:@"mapping"];
        break;
      default:
LABEL_29:

LABEL_30:
        goto LABEL_39;
    }

    goto LABEL_29;
  }
  uint64_t v29 = v3;
  if (*(_DWORD *)this)
  {
    unint64_t v30 = objc_opt_new();
    uint64_t v31 = +[NSNumber numberWithBool:*((_DWORD *)this + 1) == 1];
    [v30 setObject:v31 forKeyedSubscript:@"supported"];

    uint64_t outputStruct = 258;
    if (!CallIO<AGXConsistentPerfStateControlRec,AGXConsistentPerfStateControlRec>(*(_DWORD *)this, &outputStruct, &outputStruct, (uint64_t)"ConsistentPerfState_Get"))
    {
      if (g_runningInCI)
      {
        uint64_t v49 = +[NSString stringWithFormat:@"Error, fail to get consistent perf mapping table!\n"];
        uint64_t v50 = [v49 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "];

        unint64_t v51 = __stdoutp;
        id v52 = v50;
        fprintf(v51, "#CI-ERROR# %s\n", (const char *)[v52 UTF8String]);
      }
      unint64_t v64 = &__kCFBooleanFalse;
      CFStringRef v61 = @"enabled";
      CFStringRef v62 = @"supported";
      uint64_t v53 = +[NSNumber numberWithBool:*((_DWORD *)this + 1) == 1];
      long long v65 = v53;
      BOOL v6 = +[NSDictionary dictionaryWithObjects:&v64 forKeys:&v61 count:2];

      goto LABEL_38;
    }
    CFStringRef v61 = @"enabled";
    unsigned __int8 v32 = +[NSNumber numberWithBool:BYTE2(outputStruct) == 1];
    unint64_t v64 = v32;
    CFStringRef v62 = @"consistent";
    id v33 = +[NSNumber numberWithBool:BYTE3(outputStruct) == 1];
    long long v65 = v33;
    CFStringRef v63 = @"level";
    uint64_t v34 = +[NSNumber numberWithUnsignedChar:BYTE4(outputStruct)];
    uint64_t v66 = v34;
    uint64_t v35 = +[NSDictionary dictionaryWithObjects:&v64 forKeys:&v61 count:3];
    [v30 addEntriesFromDictionary:v35];

    uint64_t outputStruct = 3;
    if (CallIO<AGXConsistentPerfStateControlRec,AGXConsistentPerfStateControlRec>(*(_DWORD *)this, &outputStruct, &outputStruct, (uint64_t)"ConsistentPerfState_GetMappingTable"))
    {
      if (v29)
      {
        uint64_t v36 = +[NSNumber numberWithUnsignedInt:RecommendedState(v29, BYTE1(outputStruct) | ((unint64_t)BYTE2(outputStruct) << 32), BYTE3(outputStruct))];
        [v30 setObject:v36 forKeyedSubscript:@"recommended"];
      }
      uint64_t v37 = [v30 objectForKeyedSubscript:@"level"];
      unsigned int v38 = [v37 unsignedIntValue];

      switch(v38)
      {
        case 1u:
          id v39 = +[NSNumber numberWithUnsignedChar:BYTE1(outputStruct)];
          [v30 setObject:v39 forKeyedSubscript:@"mapping"];
          goto LABEL_35;
        case 2u:
          id v39 = +[NSNumber numberWithUnsignedChar:BYTE2(outputStruct)];
          [v30 setObject:v39 forKeyedSubscript:@"mapping"];
          goto LABEL_35;
        case 3u:
          id v39 = +[NSNumber numberWithUnsignedChar:BYTE3(outputStruct)];
          [v30 setObject:v39 forKeyedSubscript:@"mapping"];
LABEL_35:

          break;
      }
    }
    else if (g_runningInCI)
    {
      unint64_t v54 = +[NSString stringWithFormat:@"Error, fail to get consistent perf state status!\n"];
      uint64_t v55 = [v54 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "];

      uint64_t v56 = __stdoutp;
      id v39 = v55;
      fprintf(v56, "#CI-ERROR# %s\n", (const char *)[v39 UTF8String]);
      goto LABEL_35;
    }
    id v48 = v30;
    unint64_t v30 = v48;
    goto LABEL_37;
  }
  unint64_t v64 = &__kCFBooleanFalse;
  CFStringRef v61 = @"enabled";
  CFStringRef v62 = @"supported";
  unint64_t v30 = +[NSNumber numberWithBool:*((_DWORD *)this + 1) == 1];
  long long v65 = v30;
  id v48 = +[NSDictionary dictionaryWithObjects:&v64 forKeys:&v61 count:2];
LABEL_37:
  BOOL v6 = (_UNKNOWN **)v48;
LABEL_38:

LABEL_39:

  return v6;
}

void sub_223DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

BOOL GTAGXPerfStateControl::IsGPUPerformanceStateInduced(GTAGXPerfStateControl *this)
{
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    mach_port_t v3 = [v2 getConsistentPerfStateInfoAndReset:1];
    vm_size_t v4 = v3;
    if (v3)
    {
      id v5 = [v3 objectForKeyedSubscript:@"is_enabled"];
      id v6 = [v5 BOOLValue];
    }
    else
    {
      if (!g_runningInCI)
      {
        id v6 = 0;
        goto LABEL_10;
      }
      double v8 = +[NSString stringWithFormat:@"Error, fail to get consistent perf state status!\n"];
      id v9 = [v8 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "];

      id v10 = __stdoutp;
      id v5 = v9;
      fprintf(v10, "#CI-ERROR# %s\n", (const char *)[v5 UTF8String]);
      id v6 = 0;
    }

LABEL_10:
    return (BOOL)v6;
  }
  mach_port_t v7 = *(_DWORD *)this;
  if (!*(_DWORD *)this) {
    return 0;
  }
  uint64_t outputStruct = 258;
  if (!CallIO<AGXConsistentPerfStateControlRec,AGXConsistentPerfStateControlRec>(v7, &outputStruct, &outputStruct, (uint64_t)"ConsistentPerfState_Get"))
  {
    if (g_runningInCI)
    {
      BOOL v11 = +[NSString stringWithFormat:@"Error, fail to get consistent perf state status!\n"];
      double v12 = [v11 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "];

      double v13 = __stdoutp;
      id v14 = v12;
      fprintf(v13, "#CI-ERROR# %s\n", (const char *)[v14 UTF8String]);
    }
    return 0;
  }
  return BYTE2(outputStruct) == 1;
}

void sub_2241A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::deque<unsigned int>::~deque[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  mach_port_t v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      mach_port_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 512;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 1024;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      mach_port_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<std::pair<NSDictionary * {__strong},NSArray * {__strong}>>::__base_destruct_at_end[abi:nn180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 16)
  {

    unint64_t v5 = *(void **)(i - 16);
  }
  *(void *)(a1 + 8) = a2;
}

void sub_224614(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_224994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(uint64_t a1, unsigned int a2, int a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  double v12 = operator new(0x18uLL);
  void *v12 = 0;
  v12[1] = v6;
  *((_DWORD *)v12 + 4) = a3;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v19 = *(void *)a1;
  id v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    void *v12 = *v20;
LABEL_38:
    void *v20 = v12;
    goto LABEL_39;
  }
  void *v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v19 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    unint64_t v21 = *(void *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }
    else
    {
      v21 &= v7 - 1;
    }
    id v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
}

void sub_224C08(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_224D88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::deque<unsigned int>::__maybe_remove_front_spare[abi:nn180100](uint64_t a1)
{
  if (*(void *)(a1 + 32) >= 0x800uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 1024;
  }
}

void sub_225740(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p)
{
  _Unwind_Resume(a1);
}

void sub_225950(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TranslateGTMTLArgument(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v60 = a2;
  id v7 = [v60 name];
  id v8 = [v7 UTF8String];
  id v9 = [v60 name];
  if ([v9 UTF8String])
  {
    id v10 = [v60 name];
    size_t v11 = strlen((const char *)[v10 UTF8String]);
    size_t v12 = v11 + 1;
    if (v11 == -1) {
      float v13 = 0;
    }
    else {
      float v13 = (void *)a3[23];
    }
    a3[23] += v12;
    if (a4) {
      memcpy(v13, v8, v12);
    }
  }
  else
  {
    float v13 = 0;
  }

  unsigned __int8 v14 = [v60 access];
  unsigned __int8 v15 = [v60 isActive];
  unsigned __int8 v16 = [v60 index];
  unsigned __int8 v17 = [v60 type];
  size_t v18 = (int *)[v60 type];
  uint64_t v19 = 0;
  unsigned __int16 v20 = 0;
  unsigned __int8 v58 = v14;
  long long v59 = v13;
  unsigned __int8 v57 = v16;
  unsigned __int8 v56 = v15;
  unsigned __int8 v55 = v17;
  if ((uint64_t)v18 > 15)
  {
    if (v18 == &dword_10)
    {
      id v43 = v60;
      uint64_t v44 = [v43 imageBlockDataSize];
      unint64_t v45 = v44 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)[v43 aliasImplicitImageBlockRenderTarget] << 32);
      unsigned int v46 = [v43 aliasImplicitImageBlock];
      uint64_t v47 = 0x10000000000;
      if (!v46) {
        uint64_t v47 = 0;
      }
      uint64_t v23 = v45 | v47;
      id v48 = [v43 imageBlockMasterStructMembers];
      if (!v48)
      {
LABEL_39:
        uint64_t v49 = [v43 dataTypeDescription];
        uint64_t v25 = TranslateGTMTLType(v49, a3, a4);
        unint64_t v24 = 0;
LABEL_40:

        unsigned __int16 v20 = 0;
        unsigned __int16 v21 = 0;
        unsigned __int8 v22 = 0;
        uint64_t v19 = 0;
        if (!a4) {
          goto LABEL_29;
        }
        goto LABEL_28;
      }
    }
    else
    {
      if (v18 != (int *)((char *)&dword_10 + 1))
      {
        unsigned __int16 v21 = 0;
        unsigned __int8 v22 = 0;
        uint64_t v23 = 0;
        unint64_t v24 = 0;
        uint64_t v25 = 0;
        if (v18 != (int *)((char *)&stru_20.cmd + 3)) {
          goto LABEL_27;
        }
        id v31 = v60;
        unsigned __int8 v32 = [v31 meshVertexStruct];
        uint64_t v23 = TranslateGTMTLStructType(v32, a3, a4);

        id v33 = [v31 meshPrimitiveStruct];
        uint64_t v19 = TranslateGTMTLStructType(v33, a3, a4);

        unsigned __int16 v20 = (unsigned __int16)[v31 meshVertexCount];
        unsigned __int16 v21 = (unsigned __int16)[v31 meshPrimitiveCount];
        unsigned __int8 v22 = [v31 meshTopologyType];
        uint64_t v34 = [v31 builtInType];
        unsigned __int8 v35 = [v31 builtInDataType];

        uint64_t v25 = 0;
        unint64_t v24 = v34 & 0xFFFFFFFFFFFF00FFLL | ((unint64_t)v35 << 8);
        if (!a4) {
          goto LABEL_29;
        }
LABEL_28:
        *(void *)a1 = v59;
        *(void *)(a1 + 8) = v25;
        *(unsigned char *)(a1 + 16) = v55;
        *(unsigned char *)(a1 + 17) = v58;
        *(unsigned char *)(a1 + 18) = v57;
        *(unsigned char *)(a1 + 19) = v56 | 2;
        *(_DWORD *)(a1 + 20) = 0;
        *(void *)(a1 + 24) = v24;
        *(void *)(a1 + 32) = v23;
        *(void *)(a1 + 40) = v19;
        *(_WORD *)(a1 + 48) = v20;
        *(_WORD *)(a1 + 50) = v21;
        *(unsigned char *)(a1 + 52) = v22;
        *(_WORD *)(a1 + 53) = 0;
        *(unsigned char *)(a1 + 55) = 0;
        goto LABEL_29;
      }
      id v43 = v60;
      unsigned __int8 v50 = [v43 imageBlockKind];
      unint64_t v51 = [v43 imageBlockDataSize] | ((unint64_t)v50 << 48);
      unint64_t v52 = v51 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)[v43 aliasImplicitImageBlockRenderTarget] << 32);
      unsigned int v53 = [v43 aliasImplicitImageBlock];
      uint64_t v54 = 0x10000000000;
      if (!v53) {
        uint64_t v54 = 0;
      }
      uint64_t v23 = v52 | v54;
      id v48 = [v43 dataTypeDescription];
      if (v48) {
        goto LABEL_39;
      }
    }
    uint64_t v49 = [v43 imageBlockMasterStructMembers];
    unint64_t v24 = TranslateGTMTLStructType(v49, a3, a4);
    uint64_t v25 = 0;
    goto LABEL_40;
  }
  if (!v18)
  {
    unsigned __int16 v36 = (unsigned __int16)[v60 bufferAlignment];
    unint64_t v37 = [v60 bufferDataSize] | ((unint64_t)v36 << 32);
    unint64_t v38 = v37 & 0xFF00FFFFFFFFFFFFLL | ((unint64_t)[v60 bufferDataType] << 48);
    unsigned int v39 = [v60 isVertexDescriptorBuffer];
    uint64_t v40 = 0x100000000000000;
    if (!v39) {
      uint64_t v40 = 0;
    }
    unint64_t v24 = v38 | v40;
    goto LABEL_26;
  }
  if (v18 == (int *)((char *)&def_1C1270 + 1))
  {
    unsigned __int16 v41 = (unsigned __int16)[v60 threadgroupMemoryAlignment];
    unint64_t v24 = [v60 threadgroupMemoryDataSize] | ((unint64_t)v41 << 32);
LABEL_26:
    uint64_t v42 = [v60 dataTypeDescription];
    uint64_t v25 = TranslateGTMTLType(v42, a3, a4);

    unsigned __int16 v20 = 0;
    unsigned __int16 v21 = 0;
    unsigned __int8 v22 = 0;
    uint64_t v19 = 0;
    uint64_t v23 = 0;
LABEL_27:
    if (!a4) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  unsigned __int16 v21 = 0;
  unsigned __int8 v22 = 0;
  uint64_t v23 = 0;
  unint64_t v24 = 0;
  uint64_t v25 = 0;
  if (v18 != (int *)((char *)&def_1C1270 + 2)) {
    goto LABEL_27;
  }
  unsigned __int8 v26 = [v60 textureDataType];
  unint64_t v27 = [v60 textureType] | ((unint64_t)v26 << 8);
  unint64_t v28 = v27 & 0xFFFFFFFFFF00FFFFLL | ((unint64_t)[v60 arrayLength] << 16);
  unsigned int v29 = [v60 isDepthTexture];
  unsigned __int16 v20 = 0;
  unsigned __int16 v21 = 0;
  unsigned __int8 v22 = 0;
  uint64_t v19 = 0;
  uint64_t v23 = 0;
  uint64_t v25 = 0;
  uint64_t v30 = 0x1000000;
  if (!v29) {
    uint64_t v30 = 0;
  }
  unint64_t v24 = v28 | v30;
  if (a4) {
    goto LABEL_28;
  }
LABEL_29:
}

uint64_t TranslateGTMTLType(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  unint64_t v6 = v5;
  if (v5)
  {
    id v7 = (char *)[v5 dataType];
    uint64_t v8 = 0;
    if ((uint64_t)v7 > 57)
    {
      if (v7 == (unsigned char *)&stru_20.vmaddr + 2)
      {
        uint64_t v8 = a2[19];
        a2[19] = v8 + 16;
        if (a3)
        {
          *(unsigned char *)uint64_t v8 = 58;
          id v14 = v6;
          *(unsigned char *)(v8 + 10) = [v14 access];
          *(unsigned char *)(v8 + 8) = [v14 textureDataType];
          unsigned __int8 v15 = [v14 textureType];

          *(unsigned char *)(v8 + 9) = v15;
        }
      }
      else if (v7 == (unsigned char *)&stru_20.vmaddr + 4)
      {
        id v9 = v6;
        uint64_t v8 = a2[15];
        a2[15] = v8 + 24;
        size_t v12 = [v9 elementTypeDescription];
        uint64_t v13 = TranslateGTMTLType(v12, a2, a3);

        if (a3)
        {
          *(unsigned char *)uint64_t v8 = 60;
          *(unsigned char *)(v8 + 23) = [v9 access];
          *(_WORD *)(v8 + 20) = (unsigned __int16)[v9 alignment];
          *(_DWORD *)(v8 + 16) = [v9 dataSize];
          *(unsigned char *)(v8 + 22) = [v9 elementType];
          *(void *)(v8 + 8) = v13;
        }
        goto LABEL_13;
      }
    }
    else
    {
      if (v7 == (unsigned char *)&def_1C1270 + 1)
      {
        uint64_t v8 = TranslateGTMTLStructType(v6, a2, a3);
        goto LABEL_17;
      }
      if (v7 == (unsigned char *)&def_1C1270 + 2)
      {
        id v9 = v6;
        uint64_t v8 = a2[18];
        a2[18] = v8 + 32;
        id v10 = [v9 elementTypeDescription];
        uint64_t v11 = TranslateGTMTLType(v10, a2, a3);

        if (a3)
        {
          *(unsigned char *)uint64_t v8 = 2;
          *(_WORD *)(v8 + 20) = (unsigned __int16)[v9 arrayLength];
          *(unsigned char *)(v8 + 24) = [v9 elementType];
          *(_DWORD *)(v8 + 16) = [v9 stride];
          *(_WORD *)(v8 + 22) = (unsigned __int16)[v9 argumentIndexStride];
          *(void *)(v8 + 8) = v11;
          if (objc_opt_respondsToSelector()) {
            *(unsigned char *)(v8 + 25) = [v9 aluType];
          }
        }
LABEL_13:
      }
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
LABEL_17:

  return v8;
}

uint64_t TranslateGTMTLStructType(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  unint64_t v6 = v5;
  if (v5)
  {
    uint64_t v7 = a2[16];
    uint64_t v8 = a2[17];
    a2[16] = v7 + 24;
    id v9 = [v5 members];
    a2[17] += 32 * (void)[v9 count];

    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    obunint64_t j = [v6 members];
    id v33 = [obj countByEnumeratingWithState:&v34 objects:v38 count:16];
    if (v33)
    {
      uint64_t v27 = v7;
      unint64_t v28 = v6;
      int v10 = 0;
      uint64_t v32 = *(void *)v35;
      uint64_t v26 = v8;
      uint64_t v29 = v8 + 25;
      do
      {
        uint64_t v11 = 0;
        int v30 = v10;
        size_t v12 = (unsigned char *)(v29 + 32 * v10);
        do
        {
          if (*(void *)v35 != v32) {
            objc_enumerationMutation(obj);
          }
          id v13 = *(id *)(*((void *)&v34 + 1) + 8 * (void)v11);
          id v14 = [v13 name];
          id v15 = [v14 UTF8String];
          id v16 = [v13 name];
          if ([v16 UTF8String])
          {
            id v17 = [v13 name];
            size_t v18 = strlen((const char *)[v17 UTF8String]);
            size_t v19 = v18 + 1;
            if (v18 == -1) {
              unsigned __int16 v20 = 0;
            }
            else {
              unsigned __int16 v20 = (void *)a2[23];
            }
            a2[23] += v19;
            if (a3) {
              memcpy(v20, v15, v19);
            }
          }
          else
          {
            unsigned __int16 v20 = 0;
          }

          unsigned __int16 v21 = [v13 dataTypeDescription];
          uint64_t v22 = TranslateGTMTLType(v21, a2, a3);

          if (a3)
          {
            *(void *)(v12 - 25) = v20;
            *(_DWORD *)(v12 - 9) = [v13 offset];
            *(v12 - 1) = [v13 dataType];
            *(_WORD *)(v12 - 5) = (unsigned __int16)[v13 argumentIndex];
            *(_WORD *)(v12 - 3) = (unsigned __int16)[v13 indirectArgumentIndex];
            *(void *)(v12 - 17) = v22;
            if (objc_opt_respondsToSelector())
            {
              id v23 = v13;
              unsigned char *v12 = [v23 aluType];
            }
          }

          uint64_t v11 = (char *)v11 + 1;
          v12 += 32;
        }
        while (v33 != v11);
        int v10 = v30 + v11;
        id v33 = [obj countByEnumeratingWithState:&v34 objects:v38 count:16];
      }
      while (v33);
      uint64_t v7 = v27;
      unint64_t v6 = v28;
      uint64_t v8 = v26;
    }
    else
    {
      int v10 = 0;
    }

    if (a3)
    {
      *(unsigned char *)uint64_t v7 = 1;
      if (v10) {
        uint64_t v24 = v8;
      }
      else {
        uint64_t v24 = 0;
      }
      *(void *)(v7 + 8) = v24;
      *(_DWORD *)(v7 + 16) = v10;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }

  return v7;
}

uint64_t **std::unique_ptr<MTLGRCStreamingSampleHelper>::reset[abi:nn180100](uint64_t **result, uint64_t *a2)
{
  uint64_t v2 = *result;
  *CFStringRef result = a2;
  if (v2)
  {
    uint64_t v3 = *v2;
    *uint64_t v2 = 0;
    if (v3)
    {
      atomic_store(1u, (unsigned __int8 *)(v3 + 140));
      [*(id *)(v3 + 48) cancelAllOperations];

      std::unique_ptr<GRCSplitBlitTimeData>::reset[abi:nn180100]((id **)(v3 + 24), 0);
      std::unique_ptr<GRCSplitBlitTimeData>::reset[abi:nn180100]((id **)(v3 + 16), 0);
      std::unique_ptr<GRCCurrentFrameStream>::reset[abi:nn180100]((uint64_t *)(v3 + 8), 0);

      operator delete();
    }
    operator delete();
  }
  return result;
}

void sub_226574(_Unwind_Exception *a1)
{
  std::unique_ptr<GRCSplitBlitTimeData>::reset[abi:nn180100]((id **)(v1 + 24), 0);
  std::unique_ptr<GRCSplitBlitTimeData>::reset[abi:nn180100]((id **)(v1 + 16), 0);
  std::unique_ptr<GRCCurrentFrameStream>::reset[abi:nn180100]((uint64_t *)(v1 + 8), 0);

  _Unwind_Resume(a1);
}

void sub_226C9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  if (v32) {
    operator delete(v32);
  }
  operator delete(v31);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a23);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a29);

  _Unwind_Resume(a1);
}

void sub_227120(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_2274DC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_2276FC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_2278FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_227984()
{
}

void sub_227B74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_227D14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_227DFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_228194(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_2282DC(_Unwind_Exception *a1)
{
  unint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_2283F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void sub_228470(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_228598(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void sub_22868C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22875C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_228890(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_228DDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, void *a19, void *__p,uint64_t a21,uint64_t a22)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_229448(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37)
{
  _Unwind_Resume(a1);
}

void sub_2295D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_229698(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_22975C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_229820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_22A298(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t *a26)
{
  std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>::reset[abi:nn180100](&a26);
  _Unwind_Resume(a1);
}

uint64_t **std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>::reset[abi:nn180100](uint64_t **result)
{
  uint64_t v1 = *result;
  *CFStringRef result = 0;
  if (v1)
  {
    std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelperImpl>::reset[abi:nn180100](v1, 0);
    operator delete();
  }
  return result;
}

void sub_22A838(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t *a25,char a26,uint64_t a27,char a28,int a29,char a30,uint64_t a31,char a32)
{
  _Unwind_Resume(a1);
}

void sub_22AB00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22AC78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22AE3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22B01C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned int,double>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,double>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,double>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,double>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(float *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    id v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          int v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  int v10 = operator new(0x20uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[3] = 0;
  float v12 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v13 = a1[8];
  if (v7 && (float)(v13 * (float)v7) >= v12)
  {
    unint64_t v6 = v3;
    goto LABEL_64;
  }
  BOOL v14 = 1;
  if (v7 >= 3) {
    BOOL v14 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v15 = v14 | (2 * v7);
  unint64_t v16 = vcvtps_u32_f32(v12 / v13);
  if (v15 <= v16) {
    int8x8_t prime = (int8x8_t)v16;
  }
  else {
    int8x8_t prime = (int8x8_t)v15;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v7 = *((void *)a1 + 1);
  }
  if (*(void *)&prime <= v7)
  {
    if (*(void *)&prime >= v7) {
      goto LABEL_60;
    }
    unint64_t v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v7 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
    {
      unint64_t v24 = std::__next_prime(v24);
    }
    else
    {
      uint64_t v26 = 1 << -(char)__clz(v24 - 1);
      if (v24 >= 2) {
        unint64_t v24 = v26;
      }
    }
    if (*(void *)&prime <= v24) {
      int8x8_t prime = (int8x8_t)v24;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = *((void *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      id v33 = *(void **)a1;
      *(void *)a1 = 0;
      if (v33) {
        operator delete(v33);
      }
      unint64_t v7 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  size_t v18 = operator new(8 * *(void *)&prime);
  size_t v19 = *(void **)a1;
  *(void *)a1 = v18;
  if (v19) {
    operator delete(v19);
  }
  uint64_t v20 = 0;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v20++) = 0;
  while (*(void *)&prime != v20);
  unsigned __int16 v21 = (void *)*((void *)a1 + 2);
  if (v21)
  {
    unint64_t v22 = v21[1];
    uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
    v23.i16[0] = vaddlv_u8(v23);
    if (v23.u32[0] > 1uLL)
    {
      if (v22 >= *(void *)&prime) {
        v22 %= *(void *)&prime;
      }
    }
    else
    {
      v22 &= *(void *)&prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v22) = a1 + 4;
    uint64_t v27 = (void *)*v21;
    if (*v21)
    {
      do
      {
        unint64_t v28 = v27[1];
        if (v23.u32[0] > 1uLL)
        {
          if (v28 >= *(void *)&prime) {
            v28 %= *(void *)&prime;
          }
        }
        else
        {
          v28 &= *(void *)&prime - 1;
        }
        if (v28 != v22)
        {
          if (!*(void *)(*(void *)a1 + 8 * v28))
          {
            *(void *)(*(void *)a1 + 8 * v28) = v21;
            goto LABEL_56;
          }
          *unsigned __int16 v21 = *v27;
          *uint64_t v27 = **(void **)(*(void *)a1 + 8 * v28);
          **(void **)(*(void *)a1 + 8 * v28) = v27;
          uint64_t v27 = v21;
        }
        unint64_t v28 = v22;
LABEL_56:
        unsigned __int16 v21 = v27;
        uint64_t v27 = (void *)*v27;
        unint64_t v22 = v28;
      }
      while (v27);
    }
  }
  unint64_t v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v6) {
      v6 %= v7;
    }
  }
  else
  {
    unint64_t v6 = (v7 - 1) & v6;
  }
LABEL_64:
  uint64_t v29 = *(void **)a1;
  int v30 = *(void **)(*(void *)a1 + 8 * v6);
  if (v30)
  {
    void *v10 = *v30;
LABEL_72:
    void *v30 = v10;
    goto LABEL_73;
  }
  void *v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v29[v6] = a1 + 4;
  if (*v10)
  {
    unint64_t v31 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v31 >= v7) {
        v31 %= v7;
      }
    }
    else
    {
      v31 &= v7 - 1;
    }
    int v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_22B45C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_22B560(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22B7A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22BB0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22C9E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20,uint64_t a21,void *a22,void *a23,uint64_t a24,void *a25)
{
  _Unwind_Resume(a1);
}

void sub_22CD78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22CE84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22CF48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22DF04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,void *a24,uint64_t a25,void *a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54,uint64_t a55,void *a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  a68 = (uint64_t)&a44;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&a68);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a47);
  if (__p)
  {
    a54 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a56) {
    operator delete(a56);
  }

  _Unwind_Resume(a1);
}

void std::vector<DYMTLShaderProfilerProgramAddress>::reserve(void **a1, unint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v3 = ((unsigned char *)a1[1] - (unsigned char *)*a1) / 24;
    unint64_t v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(a2);
    id v5 = &v4[24 * v3];
    unint64_t v7 = &v4[24 * v6];
    id v9 = (char *)*a1;
    uint8x8_t v8 = (char *)a1[1];
    int v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        long long v11 = *(_OWORD *)(v8 - 24);
        *((void *)v10 - 1) = *((void *)v8 - 1);
        *(_OWORD *)(v10 - 24) = v11;
        v10 -= 24;
        v8 -= 24;
      }
      while (v8 != v9);
      uint8x8_t v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void sub_22E8B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void sub_22F04C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24)
{
  *(void *)(v25 - 136) = v25 - 112;
  std::vector<std::vector<ShaderBinaryInfo * {__strong}>>::__destroy_vector::operator()[abi:nn180100]((void ***)(v25 - 136));

  _Unwind_Resume(a1);
}

void std::vector<std::vector<ShaderBinaryInfo * {__strong}>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    unint64_t v4 = (void **)v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = (void **)v1[1];
      do
      {
        uint8x8_t v8 = (char *)*(v6 - 3);
        v6 -= 3;
        unint64_t v7 = v8;
        if (v8)
        {
          id v9 = (char *)*(v4 - 2);
          int v10 = v7;
          if (v9 != v7)
          {
            do
            {
              long long v11 = (void *)*((void *)v9 - 1);
              v9 -= 8;
            }
            while (v9 != v7);
            int v10 = *v6;
          }
          *(v4 - 2) = v7;
          operator delete(v10);
        }
        unint64_t v4 = v6;
      }
      while (v6 != v2);
      id v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_22F2F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22F4D8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_22F658(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22F838(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location, id a18, char a19)
{
}

void sub_22FE14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_22FF48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2304E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_230774(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_23089C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_23098C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_230B28(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location, id a16)
{
}

void sub_230CA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_231170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_231428(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_231570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  objc_destroyWeak(v15);
  objc_destroyWeak((id *)(v16 - 40));

  _Unwind_Resume(a1);
}

void sub_231680(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_231810(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_231E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_2331B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void **a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  a51 = (void **)&a57;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&a51);

  _Unwind_Resume(a1);
}

void sub_2336A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2337AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_2339C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id a16)
{
  _Unwind_Resume(a1);
}

void sub_233B28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_233CC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_2340A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *__p, uint64_t a8, char a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *__pa, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,char *a23,DebugInfo *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  a23 = &a29;
  std::vector<std::vector<ProfileEvent>>::__destroy_vector::operator()[abi:nn180100]((void ***)&a23);
  if (__pa) {
    operator delete(__pa);
  }
  DebugInfo::~DebugInfo((DebugInfo *)&a32);

  _Unwind_Resume(a1);
}

void std::vector<std::vector<DebugInfo::LineEntry *>>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<std::vector<ProfileEvent>>::__clear[abi:nn180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,PerFileCost>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,PerFileCost>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,PerFileCost>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,PerFileCost>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,PerFileCost>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::vector<DebugInfo::LineDisassemblyInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = (uint64_t *)*a1;
  if (*v2)
  {
    std::vector<DebugInfo::LineDisassemblyInfo>::__base_destruct_at_end[abi:nn180100]((uint64_t)v2, *v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<DebugInfo::LineEntry>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    id v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 80;
        std::allocator<DebugInfo::LineEntry>::destroy[abi:nn180100](v4);
      }
      while ((void *)v4 != v2);
      id v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void DebugInfo::~DebugInfo(DebugInfo *this)
{
  p_var0 = (void **)&this->var1.var0;
  std::vector<DebugInfo::LineDisassemblyInfo>::__destroy_vector::operator()[abi:nn180100](&p_var0);
  p_var0 = (void **)&this->var0.var0;
  std::vector<DebugInfo::LineEntry>::__destroy_vector::operator()[abi:nn180100](&p_var0);
}

void std::allocator<DebugInfo::LineEntry>::destroy[abi:nn180100](uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 56);
  std::vector<DebugInfo::BlockInfo>::__destroy_vector::operator()[abi:nn180100](&v3);
  uint64_t v3 = (void **)(a1 + 32);
  std::vector<DebugInfo::LineDisassemblyInfo>::__destroy_vector::operator()[abi:nn180100](&v3);
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void std::vector<DebugInfo::BlockInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    id v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 104;
        std::allocator<DebugInfo::BlockInfo>::destroy[abi:nn180100](v4);
      }
      while ((void *)v4 != v2);
      id v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<DebugInfo::BlockInfo>::destroy[abi:nn180100](uint64_t a1)
{
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    operator delete(v2);
  }
}

void std::vector<DebugInfo::LineDisassemblyInfo>::__base_destruct_at_end[abi:nn180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 40)
  {

    id v5 = *(void **)(i - 40);
  }
  *(void *)(a1 + 8) = a2;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,PerFileCost>,0>(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 72);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      uint64_t v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  id v5 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = *(void **)(a1 + 24);
  if (v6)
  {
    *(void *)(a1 + 32) = v6;
    operator delete(v6);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    unint64_t v7 = *(void **)a1;
    operator delete(v7);
  }
}

void sub_234BF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *__p, uint64_t a9, void *a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15, void *__pa, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,char *a25,DebugInfo *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a19);
  std::__hash_table<std::__hash_value_type<std::string,PerFileCost>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,PerFileCost>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,PerFileCost>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,PerFileCost>>>::~__hash_table((uint64_t)&a25);
  a25 = &a31;
  std::vector<std::vector<ProfileEvent>>::__destroy_vector::operator()[abi:nn180100]((void ***)&a25);
  if (__pa) {
    operator delete(__pa);
  }
  DebugInfo::~DebugInfo((DebugInfo *)&a34);

  _Unwind_Resume(a1);
}

void sub_236790(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *__p,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55)
{
  std::__tree<std::__value_type<unsigned int,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo>>>>::destroy(a55);
  _Unwind_Resume(a1);
}

void std::vector<DebugInfo::BlockInfo>::__assign_with_size[abi:nn180100]<DebugInfo::BlockInfo*,DebugInfo::BlockInfo*>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = *(void *)a1;
  if (0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) < a4)
  {
    std::vector<DebugInfo::BlockInfo>::__vdeallocate((void **)a1);
    if (a4 > 0x276276276276276) {
      abort();
    }
    unint64_t v9 = 0x9D89D89D89D89D8ALL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v9 <= a4) {
      unint64_t v9 = a4;
    }
    if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3)) >= 0x13B13B13B13B13BLL) {
      unint64_t v10 = 0x276276276276276;
    }
    else {
      unint64_t v10 = v9;
    }
    std::vector<DebugInfo::BlockInfo>::__vallocate[abi:nn180100]((void *)a1, v10);
    uint64_t v11 = a1;
    uint64_t v12 = a2;
    goto LABEL_11;
  }
  if (0x4EC4EC4EC4EC4EC5 * ((*(void *)(a1 + 8) - v8) >> 3) < a4)
  {
    uint64_t v13 = a2 + 8 * ((*(void *)(a1 + 8) - v8) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<DebugInfo::BlockInfo *,DebugInfo::BlockInfo *,DebugInfo::BlockInfo *>(a2, v13, v8);
    uint64_t v11 = a1;
    uint64_t v12 = v13;
LABEL_11:
    std::vector<DebugInfo::BlockInfo>::__construct_at_end<DebugInfo::BlockInfo*,DebugInfo::BlockInfo*>(v11, v12, a3);
    return;
  }
  uint64_t v14 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<DebugInfo::BlockInfo *,DebugInfo::BlockInfo *,DebugInfo::BlockInfo *>(a2, a3, v8);
  for (uint64_t i = *(void *)(a1 + 8); i != v14; std::allocator<DebugInfo::BlockInfo>::destroy[abi:nn180100](i))
    i -= 104;
  *(void *)(a1 + 8) = v14;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo>>(unint64_t a1)
{
  if (a1 >= 0x492492492492493) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(56 * a1);
}

void sub_237AF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::locale a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
}

uint64_t *std::__copy[abi:nn180100]<std::_ClassicAlgPolicy,-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo *,-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo *,-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo *>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  if (a1 != a2)
  {
    id v5 = a1;
    while (a3 == v5)
    {
LABEL_23:
      v5 += 6;
      a3 += 6;
      if (v5 == a2) {
        return a3;
      }
    }
    uint64_t v7 = *v5;
    uint64_t v6 = v5[1];
    unint64_t v8 = 0x6DB6DB6DB6DB6DB7 * ((v6 - *v5) >> 3);
    uint64_t v9 = a3[2];
    uint64_t v10 = *a3;
    if (0x6DB6DB6DB6DB6DB7 * ((v9 - *a3) >> 3) >= v8)
    {
      uint64_t v16 = a3[1];
      if (0x6DB6DB6DB6DB6DB7 * ((v16 - v10) >> 3) >= v8)
      {
        while (v7 != v6)
        {
          objc_storeStrong((id *)v10, *(id *)v7);
          objc_storeStrong((id *)(v10 + 8), *(id *)(v7 + 8));
          long long v20 = *(_OWORD *)(v7 + 16);
          long long v21 = *(_OWORD *)(v7 + 32);
          *(void *)(v10 + 48) = *(void *)(v7 + 48);
          *(_OWORD *)(v10 + 16) = v20;
          *(_OWORD *)(v10 + 32) = v21;
          v10 += 56;
          v7 += 56;
        }
        std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo>::__base_destruct_at_end[abi:nn180100]((uint64_t)a3, v10);
        goto LABEL_22;
      }
      uint64_t v17 = v7 + 8 * ((v16 - v10) >> 3);
      if (v16 != v10)
      {
        do
        {
          objc_storeStrong((id *)v10, *(id *)v7);
          objc_storeStrong((id *)(v10 + 8), *(id *)(v7 + 8));
          long long v18 = *(_OWORD *)(v7 + 16);
          long long v19 = *(_OWORD *)(v7 + 32);
          *(void *)(v10 + 48) = *(void *)(v7 + 48);
          *(_OWORD *)(v10 + 16) = v18;
          *(_OWORD *)(v10 + 32) = v19;
          v7 += 56;
          v10 += 56;
        }
        while (v7 != v17);
      }
      uint64_t v14 = a3;
      uint64_t v15 = v17;
    }
    else
    {
      if (v10)
      {
        std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo>::__base_destruct_at_end[abi:nn180100]((uint64_t)a3, *a3);
        operator delete((void *)*a3);
        uint64_t v9 = 0;
        *a3 = 0;
        a3[1] = 0;
        a3[2] = 0;
      }
      if (v8 > 0x492492492492492) {
        abort();
      }
      unint64_t v11 = 0x6DB6DB6DB6DB6DB7 * (v9 >> 3);
      uint64_t v12 = 2 * v11;
      if (2 * v11 <= v8) {
        uint64_t v12 = v8;
      }
      if (v11 >= 0x249249249249249) {
        unint64_t v13 = 0x492492492492492;
      }
      else {
        unint64_t v13 = v12;
      }
      std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo>::__vallocate[abi:nn180100](a3, v13);
      uint64_t v14 = a3;
      uint64_t v15 = v7;
    }
    std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo>::__construct_at_end<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo*,-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo*>(v14, v15, v6);
LABEL_22:
    std::vector<DebugInfo::BlockInfo>::__assign_with_size[abi:nn180100]<DebugInfo::BlockInfo*,DebugInfo::BlockInfo*>((uint64_t)(a3 + 3), v5[3], v5[4], 0x4EC4EC4EC4EC4EC5 * ((v5[4] - v5[3]) >> 3));
    goto LABEL_23;
  }
  return a3;
}

char *std::vector<DebugInfo::BlockInfo>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277) {
    abort();
  }
  CFStringRef result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<DebugInfo::BlockInfo>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[104 * v4];
  return result;
}

void std::vector<DebugInfo::BlockInfo>::__construct_at_end<DebugInfo::BlockInfo*,DebugInfo::BlockInfo*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a2 + v7;
      *(void *)(v4 + v7) = *(void *)(a2 + v7);
      uint64_t v9 = (const std::string::value_type **)(a2 + v7 + 8);
      if (*(char *)(a2 + v7 + 31) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)(v4 + v7 + 8), *v9, *(void *)(v8 + 16));
      }
      else
      {
        long long v10 = *(_OWORD *)v9;
        *(void *)(v4 + v7 + 24) = *(void *)(a2 + v7 + 24);
        *(_OWORD *)(v4 + v7 + 8) = v10;
      }
      unint64_t v11 = (const std::string::value_type **)(a2 + v7 + 32);
      if (*(char *)(v8 + 55) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)(v4 + v7 + 32), *v11, *(void *)(a2 + v7 + 40));
      }
      else
      {
        long long v12 = *(_OWORD *)v11;
        *(void *)(v4 + v7 + 48) = *(void *)(a2 + v7 + 48);
        *(_OWORD *)(v4 + v7 + 32) = v12;
      }
      unint64_t v13 = (const std::string::value_type **)(a2 + v7 + 56);
      if (*(char *)(v8 + 79) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)(v4 + v7 + 56), *v13, *(void *)(a2 + v7 + 64));
      }
      else
      {
        long long v14 = *(_OWORD *)v13;
        *(void *)(v4 + v7 + 72) = *(void *)(a2 + v7 + 72);
        *(_OWORD *)(v4 + v7 + 56) = v14;
      }
      uint64_t v15 = (std::string *)(v4 + v7 + 80);
      uint64_t v16 = (const std::string::value_type **)(a2 + v7 + 80);
      if (*(char *)(v8 + 103) < 0)
      {
        std::string::__init_copy_ctor_external(v15, *v16, *(void *)(a2 + v7 + 88));
      }
      else
      {
        long long v17 = *(_OWORD *)v16;
        *(void *)(v4 + v7 + 96) = *(void *)(a2 + v7 + 96);
        *(_OWORD *)&v15->__r_.__value_.__l.__data_ = v17;
      }
      v7 += 104;
    }
    while (v8 + 104 != a3);
    v4 += v7;
  }
  *(void *)(a1 + 8) = v4;
}

void sub_238384(_Unwind_Exception *exception_object)
{
  if (v6[79] < 0) {
    operator delete(*v4);
  }
  if (v6[55] < 0) {
    operator delete(*v3);
  }
  if (v6[31] < 0) {
    operator delete(*v2);
  }
  *(void *)(v1 + 8) = v5;
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<DebugInfo::BlockInfo>>(unint64_t a1)
{
  if (a1 >= 0x276276276276277) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(104 * a1);
}

void *std::ifstream::~ifstream(void *a1)
{
  std::filebuf::~filebuf();
  std::istream::~istream();
  std::ios::~ios();
  return a1;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<DebugInfo::BlockInfo *,DebugInfo::BlockInfo *,DebugInfo::BlockInfo *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      *(void *)a3 = *(void *)v5;
      std::string::operator=((std::string *)(a3 + 8), (const std::string *)(v5 + 8));
      std::string::operator=((std::string *)(a3 + 32), (const std::string *)(v5 + 32));
      std::string::operator=((std::string *)(a3 + 56), (const std::string *)(v5 + 56));
      std::string::operator=((std::string *)(a3 + 80), (const std::string *)(v5 + 80));
      a3 += 104;
      v5 += 104;
    }
    while (v5 != a2);
  }
  return a3;
}

void std::vector<DebugInfo::BlockInfo>::__vdeallocate(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 104;
        std::allocator<DebugInfo::BlockInfo>::destroy[abi:nn180100](v3);
      }
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_239284(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,PerFileCost>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,PerFileCost>,void *>>>>::reset[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<double>::resize(char **a1, unint64_t a2, void *a3)
{
  uint64_t v6 = *a1;
  uint64_t v5 = a1[1];
  unint64_t v7 = (v5 - *a1) >> 3;
  if (a2 <= v7)
  {
    if (a2 < v7) {
      a1[1] = &v6[8 * a2];
    }
  }
  else
  {
    uint64_t v9 = a1[2];
    if (a2 - v7 <= (v9 - v5) >> 3)
    {
      uint8x8_t v23 = &v5[8 * (a2 - v7)];
      uint64_t v24 = 8 * a2 - 8 * v7;
      do
      {
        *(void *)uint64_t v5 = *a3;
        v5 += 8;
        v24 -= 8;
      }
      while (v24);
      a1[1] = v23;
    }
    else
    {
      if (a2 >> 61) {
        abort();
      }
      unint64_t v10 = v9 - v6;
      unint64_t v11 = (v9 - v6) >> 2;
      if (v11 <= a2) {
        unint64_t v11 = a2;
      }
      if (v10 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v11;
      }
      unint64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v12);
      uint64_t v15 = &v13[8 * v7];
      uint64_t v16 = &v13[8 * a2];
      uint64_t v17 = 8 * a2 - 8 * v7;
      long long v18 = v15;
      do
      {
        *(void *)long long v18 = *a3;
        v18 += 8;
        v17 -= 8;
      }
      while (v17);
      long long v19 = &v13[8 * v14];
      long long v20 = *a1;
      for (uint64_t i = a1[1]; i != v20; i -= 8)
      {
        uint64_t v22 = *((void *)i - 1);
        *((void *)v15 - 1) = v22;
        v15 -= 8;
      }
      *a1 = v15;
      a1[1] = v16;
      a1[2] = v19;
      if (v20)
      {
        operator delete(v20);
      }
    }
  }
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,PerFileCost>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,PerFileCost>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,PerFileCost>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }
}

void sub_239AF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  *(void *)(v20 - 88) = &a19;
  std::vector<std::vector<ProfileEvent>>::__destroy_vector::operator()[abi:nn180100]((void ***)(v20 - 88));
  if (v19) {
    operator delete(v19);
  }
  _Unwind_Resume(a1);
}

void sub_23B120(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56,uint64_t a57,uint64_t a58,char a59,int a60,__int16 a61,uint64_t a62,char a63)
{
  std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>::reset[abi:nn180100]((uint64_t **)&a69);
  if (a56 < 0) {
    operator delete(__p);
  }
  lldb::SBCompileUnit::~SBCompileUnit((lldb::SBCompileUnit *)&a59);
  lldb::SBModule::~SBModule((lldb::SBModule *)&a61);
  lldb::SBFileSpec::~SBFileSpec((lldb::SBFileSpec *)&a63);
  lldb::SBTarget::~SBTarget((lldb::SBTarget *)&a65);
  lldb::SBDebugger::~SBDebugger((lldb::SBDebugger *)&a67);
  GTScopeFunction::~GTScopeFunction((GTScopeFunction *)&a72);

  a72 = a20;
  std::vector<DebugInfo::LineDisassemblyInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)&a72);
  a72 = a25;
  std::vector<DebugInfo::LineEntry>::__destroy_vector::operator()[abi:nn180100]((void ***)&a72);

  _Unwind_Resume(a1);
}

void MachOInfo::MachOInfo(MachOInfo *this, unsigned __int8 *a2)
{
  *((_OWORD *)this + 1) = 0u;
  *(_OWORD *)this = 0u;
  if (a2)
  {
    uint64_t v2 = a2 + 32;
    for (int i = *((_DWORD *)a2 + 4); i; --i)
    {
      if (*(_DWORD *)v2 == 25) {
        break;
      }
      v2 += *((unsigned int *)v2 + 1);
    }
    int v4 = *((_DWORD *)v2 + 16);
    if (v4)
    {
      uint64_t v5 = v2 + 88;
      do
      {
        BOOL v6 = *(_DWORD *)v5 == 1163157343 && *(_DWORD *)(v5 + 3) == 5527621;
        unint64_t v7 = (char *)this + 8;
        uint64_t v8 = this;
        if (v6
          || (*(void *)v5 == 0x454D5F5550475F5FLL ? (BOOL v9 = *(void *)(v5 + 7) == 0x41544144415445) : (BOOL v9 = 0),
              unint64_t v7 = (char *)this + 24,
              uint64_t v8 = (MachOInfo *)((char *)this + 16),
              v9))
        {
          *(void *)unint64_t v7 = *((unsigned int *)v5 + 6);
          *(void *)uint64_t v8 = *((unsigned int *)v5 + 8);
        }
        v5 += 80;
        --v4;
      }
      while (v4);
    }
  }
}

uint64_t std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::vector<DebugInfo::LineEntry>::resize(uint64_t a1, unint64_t a2)
{
  int v4 = *(char **)a1;
  uint64_t v3 = *(char **)(a1 + 8);
  unint64_t v5 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v3[-*(void *)a1] >> 4);
  unint64_t v6 = a2 - v5;
  if (a2 > v5)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    if (0xCCCCCCCCCCCCCCCDLL * ((v7 - (uint64_t)v3) >> 4) >= v6)
    {
      bzero(*(void **)(a1 + 8), 80 * ((80 * v6 - 80) / 0x50) + 80);
      *(void *)(a1 + 8) = &v3[80 * ((80 * v6 - 80) / 0x50) + 80];
      return;
    }
    if (a2 > 0x333333333333333) {
      abort();
    }
    unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - (uint64_t)v4) >> 4);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= a2) {
      uint64_t v9 = a2;
    }
    if (v8 >= 0x199999999999999) {
      unint64_t v10 = 0x333333333333333;
    }
    else {
      unint64_t v10 = v9;
    }
    if (v10 > 0x333333333333333) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v11 = 5 * v10;
    unint64_t v12 = (char *)operator new(80 * v10);
    unint64_t v13 = &v12[80 * v5];
    uint64_t v14 = &v12[16 * v11];
    size_t v15 = 80 * ((80 * v6 - 80) / 0x50) + 80;
    bzero(v13, v15);
    uint64_t v16 = &v13[v15];
    if (v3 == v4)
    {
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v16;
      *(void *)(a1 + 16) = v14;
      if (!v3) {
        return;
      }
    }
    else
    {
      uint64_t v17 = 0;
      do
      {
        long long v18 = &v13[v17];
        long long v19 = &v3[v17];
        long long v20 = *(_OWORD *)&v3[v17 - 80];
        *((void *)v18 - 8) = *(void *)&v3[v17 - 64];
        *((_OWORD *)v18 - 5) = v20;
        *((void *)v19 - 9) = 0;
        *((void *)v19 - 8) = 0;
        *((void *)v19 - 10) = 0;
        *((void *)v18 - 7) = *(void *)&v3[v17 - 56];
        *((void *)v18 - 4) = 0;
        *((_OWORD *)v18 - 3) = *(_OWORD *)&v3[v17 - 48];
        *((void *)v18 - 4) = *(void *)&v3[v17 - 32];
        *((void *)v19 - 6) = 0;
        *((void *)v19 - 5) = 0;
        *((void *)v19 - 4) = 0;
        *((void *)v18 - 1) = 0;
        *(_OWORD *)(v18 - 24) = *(_OWORD *)&v3[v17 - 24];
        *((void *)v18 - 1) = *(void *)&v3[v17 - 8];
        *((void *)v19 - 3) = 0;
        *((void *)v19 - 2) = 0;
        *((void *)v19 - 1) = 0;
        v17 -= 80;
      }
      while (&v3[v17] != v4);
      long long v21 = &v13[v17];
      uint64_t v22 = *(char **)a1;
      uint64_t v3 = *(char **)(a1 + 8);
      *(void *)a1 = v21;
      *(void *)(a1 + 8) = v16;
      *(void *)(a1 + 16) = v14;
      if (v3 != v22)
      {
        do
        {
          v3 -= 80;
          std::allocator<DebugInfo::LineEntry>::destroy[abi:nn180100]((uint64_t)v3);
        }
        while (v3 != v22);
        uint64_t v3 = v22;
      }
      if (!v3) {
        return;
      }
    }
    operator delete(v3);
    return;
  }
  if (a2 < v5)
  {
    uint8x8_t v23 = &v4[80 * a2];
    while (v3 != v23)
    {
      v3 -= 80;
      std::allocator<DebugInfo::LineEntry>::destroy[abi:nn180100]((uint64_t)v3);
    }
    *(void *)(a1 + 8) = v23;
  }
}

unint64_t std::vector<DebugInfo::BlockInfo>::__push_back_slow_path<DebugInfo::BlockInfo>(unint64_t *a1, uint64_t a2)
{
  uint64_t v2 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x276276276276276) {
    abort();
  }
  if (0x9D89D89D89D89D8ALL * ((uint64_t)(a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0x9D89D89D89D89D8ALL * ((uint64_t)(a1[2] - *a1) >> 3);
  }
  if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * ((uint64_t)(a1[2] - *a1) >> 3)) >= 0x13B13B13B13B13BLL) {
    unint64_t v6 = 0x276276276276276;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6) {
    unint64_t v6 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<DebugInfo::BlockInfo>>(v6);
  }
  else {
    uint64_t v7 = 0;
  }
  unint64_t v8 = v6 + 104 * v2;
  unint64_t v9 = v6 + 104 * v7;
  *(void *)unint64_t v8 = *(void *)a2;
  long long v10 = *(_OWORD *)(a2 + 8);
  *(void *)(v8 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(v8 + 8) = v10;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  long long v11 = *(_OWORD *)(a2 + 32);
  *(void *)(v8 + 48) = *(void *)(a2 + 48);
  *(_OWORD *)(v8 + 32) = v11;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 32) = 0;
  long long v12 = *(_OWORD *)(a2 + 56);
  *(void *)(v8 + 72) = *(void *)(a2 + 72);
  *(_OWORD *)(v8 + 56) = v12;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 56) = 0;
  long long v13 = *(_OWORD *)(a2 + 80);
  *(void *)(v8 + 96) = *(void *)(a2 + 96);
  *(_OWORD *)(v8 + 80) = v13;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  unint64_t v14 = v8 + 104;
  unint64_t v15 = *a1;
  unint64_t v16 = a1[1];
  if (v16 == *a1)
  {
    *a1 = v8;
    a1[1] = v14;
    a1[2] = v9;
  }
  else
  {
    do
    {
      uint64_t v17 = *(void *)(v16 - 104);
      v16 -= 104;
      *(void *)(v8 - 104) = v17;
      v8 -= 104;
      long long v18 = *(_OWORD *)(v16 + 8);
      *(void *)(v8 + 24) = *(void *)(v16 + 24);
      *(_OWORD *)(v8 + 8) = v18;
      *(void *)(v16 + 16) = 0;
      *(void *)(v16 + 24) = 0;
      *(void *)(v16 + 8) = 0;
      long long v19 = *(_OWORD *)(v16 + 32);
      *(void *)(v8 + 48) = *(void *)(v16 + 48);
      *(_OWORD *)(v8 + 32) = v19;
      *(void *)(v16 + 40) = 0;
      *(void *)(v16 + 48) = 0;
      *(void *)(v16 + 32) = 0;
      long long v20 = *(_OWORD *)(v16 + 56);
      *(void *)(v8 + 72) = *(void *)(v16 + 72);
      *(_OWORD *)(v8 + 56) = v20;
      *(void *)(v16 + 64) = 0;
      *(void *)(v16 + 72) = 0;
      *(void *)(v16 + 56) = 0;
      long long v21 = *(_OWORD *)(v16 + 80);
      *(void *)(v8 + 96) = *(void *)(v16 + 96);
      *(_OWORD *)(v8 + 80) = v21;
      *(void *)(v16 + 80) = 0;
      *(void *)(v16 + 88) = 0;
      *(void *)(v16 + 96) = 0;
    }
    while (v16 != v15);
    unint64_t v16 = *a1;
    uint64_t v22 = a1[1];
    *a1 = v8;
    a1[1] = v14;
    a1[2] = v9;
    while (v22 != v16)
    {
      v22 -= 104;
      std::allocator<DebugInfo::BlockInfo>::destroy[abi:nn180100](v22);
    }
  }
  if (v16) {
    operator delete((void *)v16);
  }
  return v14;
}

void constructFullPath(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  int v6 = *(unsigned __int8 *)(a2 + 23);
  if ((*(char *)(a2 + 23) & 0x80000000) == 0)
  {
    if (*(unsigned char *)(a2 + 23))
    {
      uint64_t v7 = (unsigned char *)a2;
      if (v6 != 1) {
        goto LABEL_10;
      }
      goto LABEL_8;
    }
LABEL_9:
    std::operator+<char>();
    *(std::string *)a1 = v18;
    return;
  }
  uint64_t v8 = *(void *)(a2 + 8);
  if (!v8) {
    goto LABEL_9;
  }
  if (v8 != 1) {
    goto LABEL_10;
  }
  uint64_t v7 = *(unsigned char **)a2;
LABEL_8:
  if (*v7 == 47) {
    goto LABEL_9;
  }
LABEL_10:
  if ((v6 & 0x80u) == 0) {
    size_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v9 = *(void *)(a2 + 8);
  }
  long long v10 = &v18;
  std::string::basic_string[abi:nn180100]((uint64_t)&v18, v9 + 1);
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    long long v10 = (std::string *)v18.__r_.__value_.__r.__words[0];
  }
  if (v9)
  {
    if (*(char *)(a2 + 23) >= 0) {
      long long v11 = (const void *)a2;
    }
    else {
      long long v11 = *(const void **)a2;
    }
    memmove(v10, v11, v9);
  }
  *(_WORD *)((char *)&v10->__r_.__value_.__l.__data_ + v9) = 47;
  int v12 = *(char *)(a3 + 23);
  if (v12 >= 0) {
    long long v13 = (const std::string::value_type *)a3;
  }
  else {
    long long v13 = *(const std::string::value_type **)a3;
  }
  if (v12 >= 0) {
    std::string::size_type v14 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    std::string::size_type v14 = *(void *)(a3 + 8);
  }
  unint64_t v15 = std::string::append(&v18, v13, v14);
  std::string::size_type size = v15->__r_.__value_.__l.__size_;
  *(void *)a1 = v15->__r_.__value_.__r.__words[0];
  *(void *)(a1 + 8) = size;
  *(void *)(a1 + 15) = *(std::string::size_type *)((char *)&v15->__r_.__value_.__r.__words[1] + 7);
  LOBYTE(size) = *((unsigned char *)&v15->__r_.__value_.__s + 23);
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  int v17 = SHIBYTE(v18.__r_.__value_.__r.__words[2]);
  *(unsigned char *)(a1 + 23) = size;
  if (v17 < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
}

void sub_23BCF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void DebugInfo::BlockInfo::~BlockInfo(void **this)
{
  if (*((char *)this + 103) < 0) {
    operator delete(this[10]);
  }
  if (*((char *)this + 79) < 0) {
    operator delete(this[7]);
  }
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

void std::vector<DebugInfo::LineDisassemblyInfo>::resize(void **a1, unint64_t a2, uint64_t a3)
{
  unint64_t v5 = (char *)*a1;
  int v6 = (char *)a1[1];
  unint64_t v7 = 0xCCCCCCCCCCCCCCCDLL * ((v6 - (unsigned char *)*a1) >> 3);
  unint64_t v8 = a2 - v7;
  if (a2 > v7)
  {
    long long v10 = a1[2];
    if (0xCCCCCCCCCCCCCCCDLL * ((v10 - v6) >> 3) >= v8)
    {
      uint64_t v26 = &v6[40 * v8];
      uint64_t v27 = (_OWORD *)(a3 + 16);
      do
      {
        *(void *)int v6 = *(id *)a3;
        *((void *)v6 + 1) = *(id *)(a3 + 8);
        uint64_t v28 = *(void *)(a3 + 32);
        *((_OWORD *)v6 + 1) = *v27;
        *((void *)v6 + 4) = v28;
        v6 += 40;
      }
      while (v6 != v26);
      a1[1] = v26;
      return;
    }
    if (a2 > 0x666666666666666) {
      abort();
    }
    unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((v10 - v5) >> 3);
    uint64_t v12 = 2 * v11;
    if (2 * v11 <= a2) {
      uint64_t v12 = a2;
    }
    if (v11 >= 0x333333333333333) {
      unint64_t v13 = 0x666666666666666;
    }
    else {
      unint64_t v13 = v12;
    }
    if (v13 > 0x666666666666666) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    std::string::size_type v14 = (char *)operator new(40 * v13);
    unint64_t v15 = &v14[40 * v7];
    unint64_t v16 = &v14[40 * a2];
    int v17 = v15;
    do
    {
      *(void *)int v17 = *(id *)a3;
      *((void *)v17 + 1) = *(id *)(a3 + 8);
      *((_OWORD *)v17 + 1) = *(_OWORD *)(a3 + 16);
      *((void *)v17 + 4) = *(void *)(a3 + 32);
      v17 += 40;
    }
    while (v17 != v16);
    std::string v18 = &v14[40 * v13];
    long long v19 = (char *)*a1;
    long long v20 = (char *)a1[1];
    if (v20 == *a1)
    {
      *a1 = v15;
      a1[1] = v16;
      a1[2] = v18;
      if (!v20) {
        return;
      }
    }
    else
    {
      do
      {
        long long v21 = *(_OWORD *)(v20 - 40);
        v20 -= 40;
        *(void *)long long v20 = 0;
        *((void *)v20 + 1) = 0;
        *(_OWORD *)(v15 - 40) = v21;
        v15 -= 40;
        long long v22 = *((_OWORD *)v20 + 1);
        *((void *)v15 + 4) = *((void *)v20 + 4);
        *((_OWORD *)v15 + 1) = v22;
      }
      while (v20 != v19);
      uint8x8_t v23 = (char *)*a1;
      long long v20 = (char *)a1[1];
      *a1 = v15;
      a1[1] = v16;
      a1[2] = v18;
      if (v20 != v23)
      {
        do
        {

          uint64_t v24 = (void *)*((void *)v20 - 5);
          v20 -= 40;
        }
        while (v20 != v23);
        long long v20 = v23;
      }
      if (!v20) {
        return;
      }
    }
    operator delete(v20);
    return;
  }
  if (a2 < v7)
  {
    uint64_t v25 = (uint64_t)&v5[40 * a2];
    std::vector<DebugInfo::LineDisassemblyInfo>::__base_destruct_at_end[abi:nn180100]((uint64_t)a1, v25);
  }
}

void std::vector<InstructionInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    int v4 = (void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 9) < 0) {
          operator delete(*(v4 - 4));
        }
        v4 -= 5;
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void GTScopeFunction::~GTScopeFunction(GTScopeFunction *this)
{
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
  }

  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](this);
}

void sub_23C0A4(_Unwind_Exception *a1)
{
  std::__function::__value_func<void ()(void)>::~__value_func[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void std::vector<DebugInfo::LineDisassemblyInfo>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<DebugInfo::LineDisassemblyInfo>::__base_destruct_at_end[abi:nn180100]((uint64_t)a1, *a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t std::string::basic_string[abi:nn180100](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (a2 > 0x16)
  {
    uint64_t v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17) {
      uint64_t v4 = a2 | 7;
    }
    uint64_t v5 = v4 + 1;
    int v6 = operator new(v4 + 1);
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 16) = v5 | 0x8000000000000000;
    *(void *)a1 = v6;
  }
  else
  {
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    *(unsigned char *)(a1 + 23) = a2;
  }
  return a1;
}

void std::__function::__func<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0,std::allocator<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  id v2 = +[NSFileManager defaultManager];
  [v2 removeItemAtURL:*(void *)(a1 + 8) error:0];
}

void sub_23C1D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void std::__function::__func<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0,std::allocator<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0>,void ()(void)>::destroy_deallocate(id *a1)
{
  operator delete(a1);
}

void std::__function::__func<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0,std::allocator<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
}

id std::__function::__func<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0,std::allocator<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = off_745688;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void *std::__function::__func<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0,std::allocator<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  id v2 = operator new(0x10uLL);
  *id v2 = off_745688;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

void std::__function::__func<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0,std::allocator<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  operator delete();
}

uint64_t std::__function::__func<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0,std::allocator<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  return a1;
}

void sub_23CE1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, void *a18, void *a19, void *a20,uint64_t a21,void *__p,void *a23,uint64_t a24,uint64_t a25,char *a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t *a32)
{
  a32 = (uint64_t *)&a26;
  std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100]((void ***)&a32);
  a26 = &a29;
  std::vector<objc_object  {objcproto7MTLHeap}* {__strong}>::__destroy_vector::operator()[abi:nn180100]((void ***)&a26);

  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_23D61C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_23D854(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_23D8C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_23DCC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_23DFEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_23E548(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_23E6E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_23E7FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_23EF20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *__p,uint64_t a47,uint64_t a48,char a49)
{
  std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table((uint64_t)&a35);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a41);
  if (__p) {
    operator delete(__p);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a49);

  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned int,std::vector<DYMTLShaderProfilerProgramAddress *>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<DYMTLShaderProfilerProgramAddress *>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<DYMTLShaderProfilerProgramAddress *>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<DYMTLShaderProfilerProgramAddress *>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    size_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      long long v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          long long v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  long long v10 = operator new(0x30uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  void v10[5] = 0;
  v10[3] = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  long long v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    long long v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_23F240(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,void *>>>::operator()[abi:nn180100](1, v1);
  _Unwind_Resume(a1);
}

void sub_23FA64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table((uint64_t)&a25);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a31);
  id v33 = *(void **)(v31 - 152);
  if (v33) {
    operator delete(v33);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v31 - 128);

  _Unwind_Resume(a1);
}

void sub_23FE2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, id a16)
{
  _Unwind_Resume(a1);
}

void sub_241110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void **a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56,uint64_t a57,uint64_t a58,char a59)
{
  std::unordered_map<unsigned long long,-[GTShaderProfilerHelper _calculatePerSampleActiveShaders:withShaderProfilerResult:forWorkloadInfo:]::EncoderRangeInfo>::~unordered_map[abi:nn180100]((uint64_t)&a51);
  a43 = (void **)&a56;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&a43);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a59);

  _Unwind_Resume(a1);
}

void *std::vector<std::vector<DYGPUTimelinePipelineStateInfo>>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    uint64_t v3 = 3 * a2;
    uint64_t v4 = 24 * a2;
    uint64_t v5 = (char *)operator new(24 * a2);
    *a1 = v5;
    a1[2] = &v5[8 * v3];
    size_t v6 = 24 * ((v4 - 24) / 0x18uLL) + 24;
    bzero(v5, v6);
    a1[1] = &v5[v6];
  }
  return a1;
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    size_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (int i = *v9; i; int i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  int i = operator new(0x20uLL);
  *int i = 0;
  i[1] = a2;
  i[2] = *a3;
  i[3] = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }
  uint64_t v18 = *(void *)a1;
  long long v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *int i = *v19;
LABEL_38:
    void *v19 = i;
    goto LABEL_39;
  }
  *int i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v20 = *(void *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    long long v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_24175C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,unsigned long long>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned long long>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned long long>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned long long>>>::find<unsigned int>(uint64_t a1, unint64_t a2, unsigned int a3)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a3;
    if (a3 >= a2) {
      unint64_t v4 = a3 % a2;
    }
  }
  else
  {
    unint64_t v4 = (a2 - 1) & a3;
  }
  uint64_t v5 = *(uint64_t ***)(a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (id result = *v5; result; id result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a3)
    {
      if (*((_DWORD *)result + 4) == a3) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= a2) {
          v7 %= a2;
        }
      }
      else
      {
        v7 &= a2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *,false>(uint64_t result, char *a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
LABEL_2:
  long long v10 = (int *)(a2 - 16);
  unint64_t v11 = (int *)(a2 - 32);
  float v12 = (int *)(a2 - 48);
  unint64_t j = (int *)v9;
  long long v154 = a2;
  while (1)
  {
    unint64_t v9 = (unint64_t)j;
    uint64_t v14 = a2 - (char *)j;
    uint64_t v15 = (a2 - (char *)j) >> 4;
    if (v5 || !v4)
    {
      switch(v15)
      {
        case 0:
        case 1:
          return result;
        case 2:
          id result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(v10, (_DWORD *)v9);
          if (result)
          {
            unsigned int v76 = *(_DWORD *)v9;
            *(_DWORD *)unint64_t v9 = *((_DWORD *)a2 - 4);
            *((_DWORD *)a2 - 4) = v76;
            int v77 = *(_DWORD *)(v9 + 4);
            *(_DWORD *)(v9 + 4) = *((_DWORD *)a2 - 3);
            *((_DWORD *)a2 - 3) = v77;
            int v78 = *(_DWORD *)(v9 + 8);
            *(_DWORD *)(v9 + 8) = *((_DWORD *)a2 - 2);
            *((_DWORD *)a2 - 2) = v78;
            int v79 = *(_DWORD *)(v9 + 12);
            *(_DWORD *)(v9 + 12) = *((_DWORD *)a2 - 1);
            *((_DWORD *)a2 - 1) = v79;
          }
          break;
        case 3:
          id result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>((int *)v9, (int *)(v9 + 16), v10);
          break;
        case 4:
          id result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>((int *)v9, (int *)(v9 + 16), (int *)(v9 + 32), v10);
          break;
        case 5:
          id result = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>((int *)v9, (int *)(v9 + 16), (int *)(v9 + 32), (int *)(v9 + 48), v10);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 383) {
      break;
    }
    if (!a3)
    {
      if ((char *)v9 != a2)
      {
        int64_t v97 = (unint64_t)(v15 - 2) >> 1;
        int64_t v152 = v97;
        do
        {
          int64_t v98 = v97;
          if (v152 >= v97)
          {
            uint64_t v99 = (2 * v97) | 1;
            __int8 v100 = (unsigned int *)(v9 + 16 * v99);
            if (2 * v97 + 2 < v15
              && std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>((_DWORD *)(v9 + 16 * v99), v100 + 4))
            {
              v100 += 4;
              uint64_t v99 = 2 * v98 + 2;
            }
            uint64_t v101 = (unsigned int *)(v9 + 16 * v98);
            id result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(v100, v101);
            a2 = v154;
            if ((result & 1) == 0)
            {
              uint64_t v103 = *v101;
              unsigned int v102 = v101[1];
              unsigned int v104 = v101[2];
              unsigned int v147 = v101[3];
              *uint64_t v101 = *v100;
              v101[1] = v100[1];
              v101[2] = v100[2];
              v101[3] = v100[3];
              if (v152 >= v99)
              {
                int64_t v150 = v98;
                unsigned int v148 = v102;
                while (1)
                {
                  id v105 = v100;
                  uint64_t v106 = 2 * v99;
                  uint64_t v99 = (2 * v99) | 1;
                  __int8 v100 = (unsigned int *)(v9 + 16 * v99);
                  uint64_t v107 = v106 + 2;
                  if (v106 + 2 < v15)
                  {
                    uint64_t v108 = v103;
                    id result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>((_DWORD *)(v9 + 16 * v99), v100 + 4);
                    uint64_t v103 = v108;
                    int64_t v98 = v150;
                    unsigned int v102 = v148;
                    if (result)
                    {
                      v100 += 4;
                      uint64_t v99 = v107;
                    }
                  }
                  unsigned int v109 = *v100;
                  if (*v100 < v103) {
                    break;
                  }
                  if (v103 >= v109)
                  {
                    unsigned int v110 = v100[1];
                    if (v110 < v102) {
                      break;
                    }
                    if (v102 >= v110)
                    {
                      unsigned int v111 = v100[2];
                      if (v111 < v104 || v104 >= v111 && v100[3] < v147) {
                        break;
                      }
                    }
                  }
                  *id v105 = v109;
                  v105[1] = v100[1];
                  v105[2] = v100[2];
                  v105[3] = v100[3];
                  if (v152 < v99) {
                    goto LABEL_185;
                  }
                }
                __int8 v100 = v105;
              }
LABEL_185:
              *__int8 v100 = v103;
              v100[1] = v102;
              v100[2] = v104;
              v100[3] = v147;
              a2 = v154;
            }
          }
          int64_t v97 = v98 - 1;
        }
        while (v98);
        uint64_t v112 = (unint64_t)v14 >> 4;
        do
        {
          unint64_t v113 = a2;
          uint64_t v114 = 0;
          unsigned int v153 = *(_DWORD *)v9;
          int v115 = *(_DWORD *)(v9 + 12);
          int v149 = *(_DWORD *)(v9 + 8);
          int v151 = *(_DWORD *)(v9 + 4);
          uint64_t v116 = v112 - 2;
          if (v112 < 2) {
            uint64_t v116 = v112 - 1;
          }
          uint64_t v117 = v116 >> 1;
          uint64_t v118 = (_DWORD *)v9;
          do
          {
            uint64_t v119 = (char *)&v118[4 * v114 + 4];
            uint64_t v120 = (2 * v114) | 1;
            uint64_t v121 = 2 * v114 + 2;
            if (v121 < v112)
            {
              id result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(&v118[4 * v114 + 4], &v118[4 * v114 + 8]);
              if (result)
              {
                v119 += 16;
                uint64_t v120 = v121;
              }
            }
            *uint64_t v118 = *(_DWORD *)v119;
            v118[1] = *((_DWORD *)v119 + 1);
            v118[2] = *((_DWORD *)v119 + 2);
            v118[3] = *((_DWORD *)v119 + 3);
            uint64_t v118 = v119;
            uint64_t v114 = v120;
          }
          while (v120 <= v117);
          if (v119 == v113 - 16)
          {
            *(_DWORD *)uint64_t v119 = v153;
            *((_DWORD *)v119 + 1) = v151;
            *((_DWORD *)v119 + 2) = v149;
            *((_DWORD *)v119 + 3) = v115;
            goto LABEL_212;
          }
          *(_DWORD *)uint64_t v119 = *((_DWORD *)v113 - 4);
          *((_DWORD *)v119 + 1) = *((_DWORD *)v113 - 3);
          *((_DWORD *)v119 + 2) = *((_DWORD *)v113 - 2);
          *((_DWORD *)v119 + 3) = *((_DWORD *)v113 - 1);
          *((_DWORD *)v113 - 4) = v153;
          *((_DWORD *)v113 - 3) = v151;
          *((_DWORD *)v113 - 2) = v149;
          *((_DWORD *)v113 - 1) = v115;
          uint64_t v122 = (uint64_t)&v119[-v9 + 16];
          if (v122 >= 17)
          {
            unint64_t v123 = (v122 >> 4) - 2;
            unint64_t v124 = v123 >> 1;
            uint64_t v125 = (unsigned int *)(v9 + 16 * (v123 >> 1));
            id result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(v125, v119);
            if (result)
            {
              unsigned int v126 = *(_DWORD *)v119;
              unsigned int v127 = *((_DWORD *)v119 + 1);
              unsigned int v128 = *((_DWORD *)v119 + 2);
              unsigned int v129 = *((_DWORD *)v119 + 3);
              *(_DWORD *)uint64_t v119 = *v125;
              *((_DWORD *)v119 + 1) = v125[1];
              *((_DWORD *)v119 + 2) = v125[2];
              *((_DWORD *)v119 + 3) = v125[3];
              if (v123 < 2) {
                goto LABEL_211;
              }
              while (1)
              {
                uint64_t v130 = v125;
                unint64_t v131 = v124 - 1;
                unint64_t v124 = (v124 - 1) >> 1;
                uint64_t v125 = (unsigned int *)(v9 + 16 * v124);
                unsigned int v132 = *v125;
                if (*v125 >= v126)
                {
                  if (v126 < v132
                    || (unsigned int v133 = v125[1], v133 >= v127)
                    && (v127 < v133 || (unsigned int v134 = v125[2], v134 >= v128) && (v128 < v134 || v125[3] >= v129)))
                  {
                    uint64_t v125 = v130;
LABEL_211:
                    *uint64_t v125 = v126;
                    v125[1] = v127;
                    v125[2] = v128;
                    v125[3] = v129;
                    break;
                  }
                }
                else
                {
                  unsigned int v133 = v125[1];
                }
                unsigned int *v130 = v132;
                v130[1] = v133;
                v130[2] = v125[2];
                v130[3] = v125[3];
                if (v131 <= 1) {
                  goto LABEL_211;
                }
              }
            }
          }
LABEL_212:
          a2 = v113 - 16;
        }
        while (v112-- > 2);
      }
      return result;
    }
    unint64_t v16 = (unint64_t)v15 >> 1;
    size_t v17 = (int *)(v9 + 16 * ((unint64_t)v15 >> 1));
    if ((unint64_t)v14 < 0x801)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>(v17, (int *)v9, v10);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>((int *)v9, v17, v10);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>((int *)(v9 + 16), v17 - 4, v11);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>((int *)(v9 + 32), (int *)(v9 + 16 + 16 * v16), v12);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>(v17 - 4, v17, (int *)(v9 + 16 + 16 * v16));
      long long v18 = *(_OWORD *)v9;
      *(_OWORD *)unint64_t v9 = *(_OWORD *)v17;
      *(_OWORD *)size_t v17 = v18;
    }
    --a3;
    a2 = v154;
    if ((a4 & 1) != 0
      || (id result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>((_DWORD *)(v9 - 16), (_DWORD *)v9), (result & 1) != 0))
    {
      unsigned int v19 = *(_DWORD *)v9;
      unsigned int v20 = *(_DWORD *)(v9 + 4);
      long long v21 = (char *)(v9 + 16);
      unsigned int v23 = *(_DWORD *)(v9 + 8);
      unsigned int v22 = *(_DWORD *)(v9 + 12);
      while (1)
      {
        unsigned int v24 = *(_DWORD *)v21;
        if (*(_DWORD *)v21 >= v19)
        {
          if (v19 < v24) {
            break;
          }
          unsigned int v25 = *((_DWORD *)v21 + 1);
          if (v25 >= v20)
          {
            if (v20 < v25) {
              break;
            }
            unsigned int v26 = *((_DWORD *)v21 + 2);
            if (v26 >= v23 && (v23 < v26 || *((_DWORD *)v21 + 3) >= v22)) {
              break;
            }
          }
        }
        v21 += 16;
      }
      if (v21 - 16 == (char *)v9)
      {
        int i = v154;
        if (v21 < v154)
        {
          unsigned int v32 = *v10;
          int i = (char *)v10;
          if (*v10 >= v19)
          {
            int i = (char *)v10;
            do
            {
              if (v19 >= v32)
              {
                unsigned int v33 = *((_DWORD *)i + 1);
                if (v33 < v20) {
                  break;
                }
                if (v20 >= v33)
                {
                  unsigned int v34 = *((_DWORD *)i + 2);
                  if (v34 < v23 || v23 >= v34 && *((_DWORD *)i + 3) < v22) {
                    break;
                  }
                }
              }
              if (v21 >= i) {
                break;
              }
              unsigned int v35 = *((_DWORD *)i - 4);
              i -= 16;
              unsigned int v32 = v35;
            }
            while (v35 >= v19);
          }
        }
      }
      else
      {
        unsigned int v27 = *v10;
        for (int i = (char *)v10; v27 >= v19; i -= 16)
        {
          if (v19 >= v27)
          {
            unsigned int v29 = *((_DWORD *)i + 1);
            if (v29 < v20) {
              break;
            }
            if (v20 >= v29)
            {
              unsigned int v30 = *((_DWORD *)i + 2);
              if (v30 < v23 || v23 >= v30 && *((_DWORD *)i + 3) < v22) {
                break;
              }
            }
          }
          unsigned int v31 = *((_DWORD *)i - 4);
          unsigned int v27 = v31;
        }
      }
      unint64_t j = (int *)v21;
      if (v21 < i)
      {
        unsigned int v36 = *(_DWORD *)i;
        unint64_t j = (int *)v21;
        long long v37 = (int *)i;
        do
        {
          *unint64_t j = v36;
          int *v37 = v24;
          int v38 = j[1];
          j[1] = v37[1];
          v37[1] = v38;
          int v39 = j[2];
          j[2] = v37[2];
          void v37[2] = v39;
          int v40 = j[3];
          j[3] = v37[3];
          v37[3] = v40;
          while (1)
          {
            do
            {
              unsigned int v41 = j[4];
              j += 4;
              unsigned int v24 = v41;
            }
            while (v41 < v19);
            if (v19 < v24) {
              break;
            }
            unsigned int v42 = j[1];
            if (v42 >= v20)
            {
              if (v20 < v42) {
                break;
              }
              unsigned int v43 = j[2];
              if (v43 >= v23 && (v23 < v43 || j[3] >= v22)) {
                break;
              }
            }
          }
          while (1)
          {
            unsigned int v44 = *(v37 - 4);
            v37 -= 4;
            unsigned int v36 = v44;
            if (v44 < v19) {
              break;
            }
            if (v19 >= v36)
            {
              unsigned int v45 = v37[1];
              if (v45 < v20) {
                break;
              }
              if (v20 >= v45)
              {
                unsigned int v46 = v37[2];
                if (v46 < v23 || v23 >= v46 && v37[3] < v22) {
                  break;
                }
              }
            }
          }
        }
        while (j < v37);
      }
      if (j - 4 != (int *)v9)
      {
        *(_DWORD *)unint64_t v9 = *(j - 4);
        *(_DWORD *)(v9 + 4) = *(j - 3);
        *(_DWORD *)(v9 + 8) = *(j - 2);
        *(_DWORD *)(v9 + 12) = *(j - 1);
      }
      *(j - 4) = v19;
      *(j - 3) = v20;
      *(j - 2) = v23;
      *(j - 1) = v22;
      if (v21 < i) {
        goto LABEL_65;
      }
      BOOL v47 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>((int *)v9, (char *)j - 16);
      id result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>(j, v154);
      if (result)
      {
        a2 = (char *)(j - 4);
        if (v47) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v47)
      {
LABEL_65:
        id result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *,false>(v9, j - 4, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      unsigned int v48 = *(_DWORD *)v9;
      unsigned int v49 = *(_DWORD *)(v9 + 4);
      unsigned int v50 = *(_DWORD *)(v9 + 8);
      unsigned int v51 = *(_DWORD *)(v9 + 12);
      unsigned int v52 = *v10;
      if (*(_DWORD *)v9 < *v10
        || v52 >= v48
        && ((unsigned int v74 = *((_DWORD *)v154 - 3), v49 < v74)
         || v74 >= v49 && ((unsigned int v75 = *((_DWORD *)v154 - 2), v50 < v75) || v75 >= v50 && v51 < *((_DWORD *)v154 - 1))))
      {
        unint64_t j = (int *)v9;
        while (1)
        {
          unsigned int v54 = j[4];
          j += 4;
          unsigned int v53 = v54;
          if (v48 < v54) {
            break;
          }
          if (v53 >= v48)
          {
            unsigned int v55 = j[1];
            if (v49 < v55) {
              break;
            }
            if (v55 >= v49)
            {
              unsigned int v56 = j[2];
              if (v50 < v56 || v56 >= v50 && v51 < j[3]) {
                break;
              }
            }
          }
        }
      }
      else
      {
        for (unint64_t j = (int *)(v9 + 16); j < (int *)v154; j += 4)
        {
          if (v48 < *j) {
            break;
          }
          if (*j >= v48)
          {
            unsigned int v72 = j[1];
            if (v49 < v72) {
              break;
            }
            if (v72 >= v49)
            {
              unsigned int v73 = j[2];
              if (v50 < v73 || v73 >= v50 && v51 < j[3]) {
                break;
              }
            }
          }
        }
      }
      uint64_t k = (int *)v154;
      if (j < (int *)v154)
      {
        for (uint64_t k = v10; ; k -= 4)
        {
          if (v48 >= v52)
          {
            if (v52 < v48) {
              break;
            }
            unsigned int v58 = k[1];
            if (v49 >= v58)
            {
              if (v58 < v49) {
                break;
              }
              unsigned int v59 = k[2];
              if (v50 >= v59 && (v59 < v50 || v51 >= k[3])) {
                break;
              }
            }
          }
          unsigned int v60 = *(k - 4);
          unsigned int v52 = v60;
        }
      }
      if (j < k)
      {
        unsigned int v61 = *j;
        unsigned int v62 = *k;
        do
        {
          *unint64_t j = v62;
          *uint64_t k = v61;
          int v63 = j[1];
          j[1] = k[1];
          k[1] = v63;
          int v64 = j[2];
          j[2] = k[2];
          k[2] = v64;
          int v65 = j[3];
          j[3] = k[3];
          k[3] = v65;
          while (1)
          {
            unsigned int v66 = j[4];
            j += 4;
            unsigned int v61 = v66;
            if (v48 < v66) {
              break;
            }
            if (v61 >= v48)
            {
              unsigned int v67 = j[1];
              if (v49 < v67) {
                break;
              }
              if (v67 >= v49)
              {
                unsigned int v68 = j[2];
                if (v50 < v68 || v68 >= v50 && v51 < j[3]) {
                  break;
                }
              }
            }
          }
          while (1)
          {
            do
            {
              unsigned int v69 = *(k - 4);
              k -= 4;
              unsigned int v62 = v69;
            }
            while (v48 < v69);
            if (v62 < v48) {
              break;
            }
            unsigned int v70 = k[1];
            if (v49 >= v70)
            {
              if (v70 < v49) {
                break;
              }
              unsigned int v71 = k[2];
              if (v50 >= v71 && (v71 < v50 || v51 >= k[3])) {
                break;
              }
            }
          }
        }
        while (j < k);
      }
      BOOL v4 = (unint64_t)(j - 4) >= v9;
      BOOL v5 = j - 4 == (int *)v9;
      if (j - 4 != (int *)v9)
      {
        *(_DWORD *)unint64_t v9 = *(j - 4);
        *(_DWORD *)(v9 + 4) = *(j - 3);
        *(_DWORD *)(v9 + 8) = *(j - 2);
        *(_DWORD *)(v9 + 12) = *(j - 1);
      }
      a4 = 0;
      *(j - 4) = v48;
      *(j - 3) = v49;
      *(j - 2) = v50;
      *(j - 1) = v51;
    }
  }
  long long v80 = (char *)(v9 + 16);
  BOOL v82 = (char *)v9 == a2 || v80 == a2;
  if ((a4 & 1) == 0)
  {
    if (!v82)
    {
      do
      {
        id v136 = v80;
        id result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(v80, (_DWORD *)v9);
        if (result)
        {
          unsigned int v137 = *(_DWORD *)v136;
          unsigned int v138 = *(_DWORD *)(v9 + 20);
          unsigned int v139 = *(_DWORD *)(v9 + 24);
          unsigned int v140 = *(_DWORD *)(v9 + 28);
          unsigned int v141 = *(_DWORD *)v9;
          while (1)
          {
            do
            {
              long long v142 = (_DWORD *)v9;
              unsigned int v143 = v141;
              unsigned int v144 = *(_DWORD *)(v9 - 16);
              v9 -= 16;
              unsigned int v141 = v144;
              *(_DWORD *)(v9 + 32) = v143;
              *(void *)(v9 + 36) = *(void *)(v9 + 20);
              *(_DWORD *)(v9 + 44) = *(_DWORD *)(v9 + 28);
            }
            while (v137 < v144);
            if (v141 < v137) {
              break;
            }
            unsigned int v145 = *(v142 - 3);
            if (v138 >= v145)
            {
              if (v145 < v138) {
                break;
              }
              unsigned int v146 = *(v142 - 2);
              if (v139 >= v146 && (v146 < v139 || v140 >= *(v142 - 1))) {
                break;
              }
            }
          }
          _DWORD *v142 = v137;
          v142[1] = v138;
          v142[2] = v139;
          v142[3] = v140;
        }
        long long v80 = v136 + 16;
        unint64_t v9 = (unint64_t)v136;
      }
      while (v136 + 16 != a2);
    }
    return result;
  }
  if (v82) {
    return result;
  }
  uint64_t v83 = 0;
  uint64_t v84 = (_DWORD *)v9;
  do
  {
    uint64_t v85 = v80;
    id result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(v80, v84);
    if (!result) {
      goto LABEL_161;
    }
    unsigned int v86 = v84[4];
    unsigned int v87 = v84[5];
    unsigned int v88 = v84[6];
    unsigned int v89 = v84[7];
    int v90 = v84[1];
    v84[4] = *v84;
    *((_DWORD *)v85 + 1) = v90;
    *((_DWORD *)v85 + 2) = v84[2];
    *((_DWORD *)v85 + 3) = v84[3];
    BOOL v91 = (_DWORD *)v9;
    if (v84 == (_DWORD *)v9) {
      goto LABEL_160;
    }
    uint64_t v92 = v83;
    while (1)
    {
      unsigned int v93 = *(_DWORD *)(v9 + v92 - 16);
      if (v86 < v93)
      {
        unsigned int v94 = *(_DWORD *)(v9 + v92 - 12);
        goto LABEL_157;
      }
      if (v93 < v86) {
        goto LABEL_159;
      }
      unsigned int v94 = *(_DWORD *)(v9 + v92 - 12);
      if (v87 >= v94)
      {
        if (v94 < v87) {
          goto LABEL_159;
        }
        unsigned int v95 = *(_DWORD *)(v9 + v92 - 8);
        if (v88 >= v95) {
          break;
        }
      }
LABEL_157:
      v84 -= 4;
      uint64_t v96 = v9 + v92;
      *(_DWORD *)uint64_t v96 = v93;
      *(_DWORD *)(v96 + 4) = v94;
      *(void *)(v96 + 8) = *(void *)(v9 + v92 - 8);
      v92 -= 16;
      if (!v92)
      {
        BOOL v91 = (_DWORD *)v9;
        goto LABEL_160;
      }
    }
    if (v95 >= v88)
    {
      BOOL v91 = (_DWORD *)(v9 + v92);
      if (v89 >= *(_DWORD *)(v9 + v92 - 4)) {
        goto LABEL_160;
      }
      goto LABEL_157;
    }
LABEL_159:
    BOOL v91 = v84;
LABEL_160:
    _DWORD *v91 = v86;
    v91[1] = v87;
    _OWORD v91[2] = v88;
    v91[3] = v89;
LABEL_161:
    long long v80 = v85 + 16;
    v83 += 16;
    uint64_t v84 = v85;
  }
  while (v85 + 16 != a2);
  return result;
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long &>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (int i = (void *)*v9; i; int i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  float v12 = operator new(0x18uLL);
  void *v12 = 0;
  v12[1] = a2;
  v12[2] = a3;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }
  uint64_t v19 = *(void *)a1;
  unsigned int v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    void *v12 = *v20;
LABEL_38:
    void *v20 = v12;
    goto LABEL_39;
  }
  void *v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v19 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    unint64_t v21 = *(void *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }
    else
    {
      v21 &= v7 - 1;
    }
    unsigned int v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
}

void sub_2426EC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

BOOL std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2) {
    return 1;
  }
  if (*a2 < *a1) {
    return 0;
  }
  unsigned int v2 = a1[1];
  unsigned int v3 = a2[1];
  if (v2 < v3) {
    return 1;
  }
  if (v3 < v2) {
    return 0;
  }
  unsigned int v4 = a1[2];
  unsigned int v5 = a2[2];
  if (v4 < v5) {
    return 1;
  }
  return v5 >= v4 && a1[3] < a2[3];
}

BOOL std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>(int *a1, int *a2, int *a3)
{
  BOOL v6 = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(a2, a1);
  BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(a3, a2);
  if (v6)
  {
    unint64_t v9 = a1 + 3;
    int v8 = *a1;
    if (result)
    {
      *a1 = *a3;
      *a3 = v8;
      int v10 = a1[1];
      a1[1] = a3[1];
      a3[1] = v10;
      int v11 = a1[2];
      a1[2] = a3[2];
    }
    else
    {
      *a1 = *a2;
      *a2 = v8;
      int v20 = a1[1];
      a1[1] = a2[1];
      a2[1] = v20;
      int v21 = a1[2];
      a1[2] = a2[2];
      a2[2] = v21;
      unint64_t v9 = a2 + 3;
      int v22 = a1[3];
      a1[3] = a2[3];
      a2[3] = v22;
      BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(a3, a2);
      if (!result) {
        return result;
      }
      int v23 = *a2;
      *a2 = *a3;
      *a3 = v23;
      int v24 = a2[1];
      a2[1] = a3[1];
      a3[1] = v24;
      int v11 = a2[2];
      a2[2] = a3[2];
    }
    a3[2] = v11;
    unint64_t v16 = a3 + 3;
    goto LABEL_10;
  }
  if (result)
  {
    int v12 = *a2;
    *a2 = *a3;
    *a3 = v12;
    int v13 = a2[1];
    a2[1] = a3[1];
    a3[1] = v13;
    int v14 = a2[2];
    a2[2] = a3[2];
    a3[2] = v14;
    unint64_t v16 = a2 + 3;
    int v15 = a2[3];
    a2[3] = a3[3];
    a3[3] = v15;
    BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(a2, a1);
    if (result)
    {
      int v17 = *a1;
      *a1 = *a2;
      *a2 = v17;
      int v18 = a1[1];
      a1[1] = a2[1];
      a2[1] = v18;
      int v19 = a1[2];
      a1[2] = a2[2];
      a2[2] = v19;
      unint64_t v9 = a1 + 3;
LABEL_10:
      int v25 = *v9;
      *unint64_t v9 = *v16;
      *unint64_t v16 = v25;
    }
  }
  return result;
}

BOOL std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>(int *a1, int *a2, int *a3, int *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>(a1, a2, a3);
  BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(a4, a3);
  if (result)
  {
    int v9 = *a3;
    *a3 = *a4;
    *a4 = v9;
    int v10 = a3[1];
    a3[1] = a4[1];
    a4[1] = v10;
    int v11 = a3[2];
    a3[2] = a4[2];
    a4[2] = v11;
    int v12 = a3[3];
    a3[3] = a4[3];
    a4[3] = v12;
    BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(a3, a2);
    if (result)
    {
      int v13 = *a2;
      *a2 = *a3;
      *a3 = v13;
      int v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      int v15 = a2[2];
      a2[2] = a3[2];
      a3[2] = v15;
      int v16 = a2[3];
      a2[3] = a3[3];
      a3[3] = v16;
      BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(a2, a1);
      if (result)
      {
        int v17 = *a1;
        *a1 = *a2;
        *a2 = v17;
        int v18 = a1[1];
        a1[1] = a2[1];
        a2[1] = v18;
        int v19 = a1[2];
        a1[2] = a2[2];
        a2[2] = v19;
        int v20 = a1[3];
        a1[3] = a2[3];
        a2[3] = v20;
      }
    }
  }
  return result;
}

BOOL std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>(int *a1, int *a2, int *a3, int *a4, int *a5)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>(a1, a2, a3, a4);
  BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(a5, a4);
  if (result)
  {
    int v11 = *a4;
    *a4 = *a5;
    *a5 = v11;
    int v12 = a4[1];
    a4[1] = a5[1];
    a5[1] = v12;
    int v13 = a4[2];
    a4[2] = a5[2];
    a5[2] = v13;
    int v14 = a4[3];
    a4[3] = a5[3];
    a5[3] = v14;
    BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(a4, a3);
    if (result)
    {
      int v15 = *a3;
      *a3 = *a4;
      *a4 = v15;
      int v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      int v17 = a3[2];
      a3[2] = a4[2];
      a4[2] = v17;
      int v18 = a3[3];
      a3[3] = a4[3];
      a4[3] = v18;
      BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(a3, a2);
      if (result)
      {
        int v19 = *a2;
        *a2 = *a3;
        *a3 = v19;
        int v20 = a2[1];
        a2[1] = a3[1];
        a3[1] = v20;
        int v21 = a2[2];
        a2[2] = a3[2];
        a3[2] = v21;
        int v22 = a2[3];
        a2[3] = a3[3];
        a3[3] = v22;
        BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(a2, a1);
        if (result)
        {
          int v23 = *a1;
          *a1 = *a2;
          *a2 = v23;
          int v24 = a1[1];
          a1[1] = a2[1];
          a2[1] = v24;
          int v25 = a1[2];
          a1[2] = a2[2];
          a2[2] = v25;
          int v26 = a1[3];
          a1[3] = a2[3];
          a2[3] = v26;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>(int *a1, char *a2)
{
  uint64_t v4 = (a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>((_DWORD *)a2 - 4, a1))
      {
        int v6 = *a1;
        *a1 = *((_DWORD *)a2 - 4);
        *((_DWORD *)a2 - 4) = v6;
        int v7 = a1[1];
        a1[1] = *((_DWORD *)a2 - 3);
        *((_DWORD *)a2 - 3) = v7;
        int v8 = a1[2];
        a1[2] = *((_DWORD *)a2 - 2);
        *((_DWORD *)a2 - 2) = v8;
        int v9 = a1[3];
        a1[3] = *((_DWORD *)a2 - 1);
        *((_DWORD *)a2 - 1) = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>(a1, a1 + 4, (int *)a2 - 4);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>(a1, a1 + 4, a1 + 8, (int *)a2 - 4);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>(a1, a1 + 4, a1 + 8, a1 + 12, (int *)a2 - 4);
      return 1;
    default:
      int v10 = a1 + 8;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>(a1, a1 + 4, a1 + 8);
      int v11 = a1 + 12;
      if (a1 + 12 == (int *)a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (2)
  {
    if (!std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>(v11, v10))goto LABEL_21; {
    unsigned int v14 = *v11;
    }
    unsigned int v15 = v11[1];
    unsigned int v16 = v11[2];
    unsigned int v17 = v11[3];
    *int v11 = *v10;
    v11[1] = v10[1];
    v11[2] = v10[2];
    unint64_t v11[3] = v10[3];
    int v18 = a1;
    if (v10 == a1) {
      goto LABEL_20;
    }
    uint64_t v19 = v12;
    while (1)
    {
      int v20 = (char *)a1 + v19;
      unsigned int v21 = *(int *)((char *)a1 + v19 + 16);
      if (v14 < v21)
      {
        unsigned int v22 = *((_DWORD *)v20 + 5);
        goto LABEL_17;
      }
      if (v21 < v14) {
        goto LABEL_19;
      }
      unsigned int v22 = *(int *)((char *)a1 + v19 + 20);
      if (v15 >= v22)
      {
        if (v22 < v15) {
          goto LABEL_19;
        }
        unsigned int v23 = *(int *)((char *)a1 + v19 + 24);
        if (v16 >= v23)
        {
          if (v23 < v16)
          {
LABEL_19:
            int v18 = v10;
            goto LABEL_20;
          }
          if (v17 >= *(int *)((char *)a1 + v19 + 28)) {
            break;
          }
        }
      }
LABEL_17:
      v10 -= 4;
      *((_DWORD *)v20 + 8) = v21;
      int v24 = (char *)a1 + v19;
      *((_DWORD *)v24 + 9) = v22;
      *((void *)v24 + 5) = *(void *)((char *)a1 + v19 + 24);
      v19 -= 16;
      if (v19 == -32)
      {
        int v18 = a1;
        goto LABEL_20;
      }
    }
    int v18 = (int *)((char *)a1 + v19 + 32);
LABEL_20:
    *int v18 = v14;
    v18[1] = v15;
    v18[2] = v16;
    v18[3] = v17;
    if (++v13 != 8)
    {
LABEL_21:
      int v10 = v11;
      v12 += 16;
      v11 += 4;
      if (v11 == (int *)a2) {
        return 1;
      }
      continue;
    }
    return v11 + 4 == (int *)a2;
  }
}

void sub_243418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void *BufferView<DYGPUTimelineEncoderTimelineInfo>::BufferView(void *a1, void *a2)
{
  id v3 = a2;
  *a1 = [v3 bytes];
  unint64_t v4 = (unint64_t)[v3 length];
  a1[1] = *a1 + 24 * (v4 / 0x18);
  a1[2] = v4 / 0x18;

  return a1;
}

void sub_2434D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_244074(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *__p)
{
  _Unwind_Resume(a1);
}

void *BufferView<unsigned long long>::BufferView(void *a1, void *a2)
{
  id v3 = a2;
  *a1 = [v3 bytes];
  unint64_t v4 = (unint64_t)[v3 length];
  a1[1] = *a1 + 8 * (v4 >> 3);
  a1[2] = v4 >> 3;

  return a1;
}

{
  id v3;
  unint64_t v4;

  id v3 = a2;
  *a1 = [v3 mutableBytes];
  unint64_t v4 = (unint64_t)[v3 length];
  a1[1] = *a1 + 8 * (v4 >> 3);
  a1[2] = v4 >> 3;

  return a1;
}

void sub_244300(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    int v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (int i = *v9; i; int i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  int i = operator new(0x20uLL);
  *int i = 0;
  i[1] = a2;
  i[2] = *a3;
  i[3] = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }
  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *int i = *v19;
LABEL_38:
    void *v19 = i;
    goto LABEL_39;
  }
  *int i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v20 = *(void *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_24450C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *BufferView<double>::BufferView(void *a1, void *a2)
{
  id v3 = a2;
  *a1 = [v3 bytes];
  unint64_t v4 = (unint64_t)[v3 length];
  a1[1] = *a1 + 8 * (v4 >> 3);
  a1[2] = v4 >> 3;

  return a1;
}

{
  id v3;
  unint64_t v4;

  id v3 = a2;
  *a1 = [v3 mutableBytes];
  unint64_t v4 = (unint64_t)[v3 length];
  a1[1] = *a1 + 8 * (v4 >> 3);
  a1[2] = v4 >> 3;

  return a1;
}

void sub_244574(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2454D4(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 - 144);

  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    int v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          int v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  int v10 = operator new(0x20uLL);
  void *v10 = 0;
  v10[1] = a2;
  v10[2] = *a3;
  *((_DWORD *)v10 + 6) = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }
  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_24589C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned int,unsigned long long>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned int,unsigned long long>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned int,unsigned long long>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned int,unsigned long long>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    int v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          int v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  int v10 = operator new(0x28uLL);
  void *v10 = 0;
  v10[1] = a2;
  v10[2] = *a3;
  *((_DWORD *)v10 + 6) = 0;
  v10[4] = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }
  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_245AB4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_245BE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_246758(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  a68 = (void **)&a45;
  std::vector<std::unordered_map<unsigned int,GTEncoderSampleIndexInfo>>::__destroy_vector::operator()[abi:nn180100](&a68);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a53);

  _Unwind_Resume(a1);
}

void sub_246AB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_246C34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_246D84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_246EA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_246FB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_247110(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, char a10)
{
  for (uint64_t i = 24; i != -8; i -= 8)
  _Unwind_Resume(a1);
}

void sub_2471A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_247200(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2473B4(_Unwind_Exception *a1)
{
  unint64_t v4 = v3;

  _Unwind_Resume(a1);
}

id ArrayFromDownloadRequests(uint64_t a1, int a2)
{
  int v2 = a2;
  id v4 = [objc_alloc((Class)NSMutableArray) initWithCapacity:a2];
  if (v2 >= 1)
  {
    do
    {
      unsigned int v5 = +[NSString stringWithUTF8String:*(void *)(a1 + 24)];
      [v4 addObject:v5];

      --v2;
    }
    while (v2);
  }
  id v6 = [v4 copy];

  return v6;
}

id ArrayFromActivities(void *a1, char a2)
{
  id v3 = a1;
  id v4 = objc_alloc((Class)NSMutableArray);
  id v5 = v3;
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = 0;
    uint8x8_t v8 = v5;
    do
    {
      uint64_t v9 = [v8 previousActivity];

      ++v7;
      uint8x8_t v8 = (void *)v9;
    }
    while (v9);
    id v10 = [v4 initWithCapacity:v7];
    do
    {
      if (a2)
      {
        unint64_t v11 = [v6 jsonObject];
        [v10 addObject:v11];
      }
      else
      {
        [v10 addObject:v6];
      }
      uint64_t v12 = [v6 previousActivity];

      id v6 = (void *)v12;
    }
    while (v12);
  }
  else
  {
    id v10 = [v4 initWithCapacity:0];
  }
  id v13 = v10;
  unint64_t v14 = (unint64_t)[v13 count];
  if (v14 >= 2)
  {
    uint64_t v15 = 0;
    unint64_t v16 = v14 >> 1;
    unint64_t v17 = v14 - 1;
    do
    {
      uint64_t v18 = v15 + 1;
      [v13 exchangeObjectAtIndex:withObjectAtIndex:];
      --v17;
      uint64_t v15 = v18;
    }
    while (v16 != v18);
  }

  id v19 = [v13 copy];

  return v19;
}

id BreadcrumbSummary(void *a1)
{
  uint64_t v1 = ArrayFromActivities(a1, 0);
  id v2 = objc_alloc_init((Class)NSMutableArray);
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v3 = v1;
  id v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v11;
    do
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v11 != v6) {
          objc_enumerationMutation(v3);
        }
        uint8x8_t v8 = [*(id *)(*((void *)&v10 + 1) + 8 * i) summary:v10];
        [v2 addObject:v8];
      }
      id v5 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v5);
  }

  return v2;
}

void GTPerfStateGroup::~GTPerfStateGroup(GTPerfStateGroup *this)
{
  id v2 = (const void *)*((void *)this + 2);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 2) = 0;
  }

  id v3 = (void *)*((void *)this + 14);
  if (v3)
  {
    *((void *)this + 15) = v3;
    operator delete(v3);
  }
  id v4 = (void *)*((void *)this + 10);
  if (v4)
  {
    *((void *)this + 11) = v4;
    operator delete(v4);
  }
  id v5 = (void *)*((void *)this + 6);
  if (v5)
  {
    *((void *)this + 7) = v5;
    operator delete(v5);
  }
}

void sub_24B7CC(_Unwind_Exception *a1)
{
  id v3 = *(void **)(v1 + 112);
  if (v3)
  {
    *(void *)(v1 + 120) = v3;
    operator delete(v3);
  }
  id v4 = *(void **)(v1 + 80);
  if (v4)
  {
    *(void *)(v1 + 88) = v4;
    operator delete(v4);
  }
  id v5 = *(void **)(v1 + 48);
  if (v5)
  {
    *(void *)(v1 + 56) = v5;
    operator delete(v5);
  }

  _Unwind_Resume(a1);
}

void sub_24BB70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_24BE50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN16GTPerfStateGroup32_GatherSampleDataPeriodicSamplesERK18mach_timebase_info_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v7 = v5;
  if (a3)
  {
    SamplesDelta = (const void *)IOReportCreateSamplesDelta();
    if (SamplesDelta)
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v7;
      IOReportGetChannelCount();
      IOReportIterate();
      CFRelease(SamplesDelta);
    }
  }
  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5;
  }
}

void sub_24BF2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

int ___ZN16GTPerfStateGroup32_GatherSampleDataPeriodicSamplesERK18mach_timebase_info_block_invoke_2(id a1, __CFDictionary *a2)
{
  int Format = IOReportChannelGetFormat();
  if (Format)
  {
    if (Format == 1)
    {
      id v3 = IOReportChannelGetChannelName();
      IOReportChannelGetChannelID();
      IOReportChannelGetUnit();
      id v4 = IOReportChannelGetUnitLabel();
      IOReportSimpleGetIntegerValue();
    }
    else
    {
      IOReportChannelGetUnit();
      IOReportChannelGetUnitLabel();
    }
  }
  return 16;
}

void sub_24BFF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN16GTPerfStateGroup29_GatherSampleDataSOCPerfStateERK18mach_timebase_info_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = v5;
  if (a3)
  {
    SamplesDelta = (const void *)IOReportCreateSamplesDelta();
    if (SamplesDelta)
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v6;
      v8[0] = 0;
      v8[1] = v8;
      void v8[2] = 0x2020000000;
      int v9 = 0;
      IOReportIterate();
      CFRelease(SamplesDelta);
      _Block_object_dispose(v8, 8);
    }
  }
  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5;
  }
}

void sub_24C11C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN16GTPerfStateGroup29_GatherSampleDataSOCPerfStateERK18mach_timebase_info_block_invoke_2(void *a1)
{
  id v2 = (void *)a1[5];
  if (IOReportChannelGetFormat() == 2)
  {
    IOReportStateGetCurrent();
    int Count = IOReportStateGetCount();
    if (Count >= 2)
    {
      int v4 = Count;
      for (int i = 1; i != v4; ++i)
      {
        uint64_t Residency = IOReportStateGetResidency();
        if (Residency)
        {
          uint64_t v7 = Residency;
          unint64_t v8 = (*(_DWORD *)(*(void *)(a1[4] + 8) + 24) << 23) | (i << 15) | 0x302u | (unint64_t)(IOReportStateGetInTransitions() << 32);
          uint64_t v9 = *(void *)(v2[6] + 8 * a1[6]);
          unint64_t v10 = v2[11];
          unint64_t v11 = v2[12];
          if (v10 >= v11)
          {
            uint64_t v13 = v2[10];
            unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v13) >> 3);
            unint64_t v15 = v14 + 1;
            if (v14 + 1 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v13) >> 3);
            if (2 * v16 > v15) {
              unint64_t v15 = 2 * v16;
            }
            if (v16 >= 0x555555555555555) {
              unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v17 = v15;
            }
            if (v17) {
              unint64_t v17 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v17);
            }
            else {
              uint64_t v18 = 0;
            }
            unint64_t v19 = v17 + 24 * v14;
            *(unsigned char *)(v19 + 4) = BYTE4(v8);
            *(_DWORD *)unint64_t v19 = v8;
            *(_WORD *)(v19 + 5) = 0;
            *(unsigned char *)(v19 + 7) = 0;
            *(void *)(v19 + 8) = v9;
            *(void *)(v19 + 16) = v7;
            unsigned int v21 = (char *)v2[10];
            unint64_t v20 = (char *)v2[11];
            unint64_t v22 = v19;
            if (v20 != v21)
            {
              do
              {
                long long v23 = *(_OWORD *)(v20 - 24);
                *(void *)(v22 - 8) = *((void *)v20 - 1);
                *(_OWORD *)(v22 - 24) = v23;
                v22 -= 24;
                v20 -= 24;
              }
              while (v20 != v21);
              unint64_t v20 = (char *)v2[10];
            }
            unint64_t v12 = v19 + 24;
            v2[10] = v22;
            v2[11] = v19 + 24;
            v2[12] = v17 + 24 * v18;
            if (v20) {
              operator delete(v20);
            }
          }
          else
          {
            *(_DWORD *)unint64_t v10 = (*(_DWORD *)(*(void *)(a1[4] + 8) + 24) << 23) | (i << 15) | 0x302;
            *(unsigned char *)(v10 + 4) = BYTE4(v8);
            *(_WORD *)(v10 + 5) = 0;
            *(unsigned char *)(v10 + 7) = 0;
            unint64_t v12 = v10 + 24;
            *(void *)(v10 + 8) = v9;
            *(void *)(v10 + 16) = v7;
          }
          v2[11] = v12;
        }
      }
    }
  }
  ++*(_DWORD *)(*(void *)(a1[4] + 8) + 24);
  return 16;
}

void ___ZN16GTPerfStateGroup26_GatherSampleDataPerfStateERK18mach_timebase_info_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = v5;
  if (a3)
  {
    SamplesDelta = (const void *)IOReportCreateSamplesDelta();
    if (SamplesDelta)
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v6;
      IOReportIterate();
      CFRelease(SamplesDelta);
    }
  }
  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5;
  }
}

void sub_24C418(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN16GTPerfStateGroup26_GatherSampleDataPerfStateERK18mach_timebase_info_block_invoke_2(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  int Format = IOReportChannelGetFormat();
  if (Format)
  {
    if (Format == 2)
    {
      unsigned __int8 Current = IOReportStateGetCurrent();
      int Count = IOReportStateGetCount();
      if (Count >= 1)
      {
        int v6 = Count;
        int v7 = 0;
        int v38 = Current << 23;
        while (1)
        {
          uint64_t Residency = IOReportStateGetResidency();
          if (Residency) {
            break;
          }
LABEL_40:
          if (++v7 == v6) {
            return 16;
          }
        }
        uint64_t v9 = Residency;
        unint64_t v10 = IOReportStateGetNameForIndex();
        unint64_t v11 = v10;
        if (v10)
        {
          if ((unint64_t)[v10 length] < 2
            || [v11 characterAtIndex:0] != 80)
          {
            goto LABEL_39;
          }
          unint64_t v12 = [v11 substringFromIndex:1];
          unsigned __int8 v13 = [v12 integerValue];

          int v14 = (v13 << 15) | v38 | 0x102;
          uint64_t v15 = *(void *)(v2[6] + 8 * *(void *)(a1 + 40));
          unint64_t v16 = v2[11];
          unint64_t v17 = v2[12];
          if (v16 >= v17)
          {
            uint64_t v18 = v2[10];
            unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v16 - v18) >> 3);
            unint64_t v20 = v19 + 1;
            if (v19 + 1 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v17 - v18) >> 3);
            if (2 * v21 > v20) {
              unint64_t v20 = 2 * v21;
            }
            if (v21 >= 0x555555555555555) {
              unint64_t v22 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v22 = v20;
            }
            if (v22) {
              unint64_t v22 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v22);
            }
            else {
              uint64_t v23 = 0;
            }
            unint64_t v30 = v22 + 24 * v19;
            *(unsigned char *)(v30 + 4) = 0;
            *(_DWORD *)unint64_t v30 = v14;
            *(_WORD *)(v30 + 5) = 0;
            *(unsigned char *)(v30 + 7) = 0;
            *(void *)(v30 + 8) = v15;
            *(void *)(v30 + 16) = v9;
            unsigned int v35 = (char *)v2[10];
            unsigned int v31 = (char *)v2[11];
            unint64_t v33 = v30;
            if (v31 == v35) {
              goto LABEL_36;
            }
            do
            {
              long long v36 = *(_OWORD *)(v31 - 24);
              *(void *)(v33 - 8) = *((void *)v31 - 1);
              *(_OWORD *)(v33 - 24) = v36;
              v33 -= 24;
              v31 -= 24;
            }
            while (v31 != v35);
LABEL_35:
            unsigned int v31 = (char *)v2[10];
LABEL_36:
            unint64_t v25 = v30 + 24;
            v2[10] = v33;
            v2[11] = v30 + 24;
            v2[12] = v22 + 24 * v23;
            if (v31) {
              operator delete(v31);
            }
            goto LABEL_38;
          }
        }
        else
        {
          int v14 = v38 | (v7 << 15) | 0x202;
          uint64_t v15 = *(void *)(v2[6] + 8 * *(void *)(a1 + 40));
          unint64_t v16 = v2[11];
          unint64_t v24 = v2[12];
          if (v16 >= v24)
          {
            uint64_t v26 = v2[10];
            unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v16 - v26) >> 3);
            unint64_t v28 = v27 + 1;
            if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - v26) >> 3);
            if (2 * v29 > v28) {
              unint64_t v28 = 2 * v29;
            }
            if (v29 >= 0x555555555555555) {
              unint64_t v22 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v22 = v28;
            }
            if (v22) {
              unint64_t v22 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<AccelerationStructureViewer::FilterToken>>(v22);
            }
            else {
              uint64_t v23 = 0;
            }
            unint64_t v30 = v22 + 24 * v27;
            *(unsigned char *)(v30 + 4) = 0;
            *(_DWORD *)unint64_t v30 = v14;
            *(_WORD *)(v30 + 5) = 0;
            *(unsigned char *)(v30 + 7) = 0;
            *(void *)(v30 + 8) = v15;
            *(void *)(v30 + 16) = v9;
            unsigned int v32 = (char *)v2[10];
            unsigned int v31 = (char *)v2[11];
            unint64_t v33 = v30;
            if (v31 == v32) {
              goto LABEL_36;
            }
            do
            {
              long long v34 = *(_OWORD *)(v31 - 24);
              *(void *)(v33 - 8) = *((void *)v31 - 1);
              *(_OWORD *)(v33 - 24) = v34;
              v33 -= 24;
              v31 -= 24;
            }
            while (v31 != v32);
            goto LABEL_35;
          }
        }
        *(unsigned char *)(v16 + 4) = 0;
        *(_DWORD *)unint64_t v16 = v14;
        *(_WORD *)(v16 + 5) = 0;
        *(unsigned char *)(v16 + 7) = 0;
        unint64_t v25 = v16 + 24;
        *(void *)(v16 + 8) = v15;
        *(void *)(v16 + 16) = v9;
LABEL_38:
        v2[11] = v25;
LABEL_39:

        goto LABEL_40;
      }
    }
    else
    {
      IOReportChannelGetUnit();
      IOReportChannelGetUnitLabel();
    }
  }
  return 16;
}

void sub_24C778(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN16GTPerfStateGroup20StartCollectingStatsEy_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t IntegerValue = IOReportSimpleGetIntegerValue();
  uint64_t v3 = IntegerValue;
  id v5 = (uint64_t *)v1[15];
  unint64_t v4 = v1[16];
  if ((unint64_t)v5 >= v4)
  {
    int v7 = (uint64_t *)v1[14];
    uint64_t v8 = v5 - v7;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61) {
      abort();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 2 > v9) {
      unint64_t v9 = v10 >> 2;
    }
    BOOL v11 = (unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v11) {
      unint64_t v12 = v9;
    }
    if (v12)
    {
      unint64_t v12 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v12);
      int v7 = (uint64_t *)v1[14];
      id v5 = (uint64_t *)v1[15];
    }
    else
    {
      uint64_t v13 = 0;
    }
    int v14 = (uint64_t *)(v12 + 8 * v8);
    unint64_t v15 = v12 + 8 * v13;
    uint64_t *v14 = v3;
    int v6 = v14 + 1;
    while (v5 != v7)
    {
      uint64_t v16 = *--v5;
      *--int v14 = v16;
    }
    v1[14] = v14;
    v1[15] = v6;
    v1[16] = v15;
    if (v7) {
      operator delete(v7);
    }
  }
  else
  {
    uint64_t *v5 = IntegerValue;
    int v6 = v5 + 1;
  }
  v1[15] = v6;
}

void ___ZN16GTPerfStateGroup20StartCollectingStatsEy_block_invoke_2(void *a1)
{
  uint64_t v1 = a1[5];
  uint64_t v2 = *(void *)(a1[4] + 8);
  unint64_t v3 = *(unsigned int *)(v2 + 24);
  *(_DWORD *)(v2 + 24) = v3 + 1;
  if (a1[6] > v3)
  {
    if ((*(_DWORD *)(v1 + 76) - 1) > 1)
    {
      if (IOReportUpdateSamples())
      {
        uint64_t v64 = 0;
        int v65 = &v64;
        uint64_t v66 = 0x2020000000;
        int v67 = 0;
        uint64_t v10 = mach_absolute_time();
        uint64_t v11 = v10;
        uint64_t v13 = *(char **)(v1 + 56);
        unint64_t v12 = *(void *)(v1 + 64);
        if ((unint64_t)v13 >= v12)
        {
          unint64_t v22 = *(char **)(v1 + 48);
          uint64_t v23 = (v13 - v22) >> 3;
          unint64_t v24 = v23 + 1;
          if ((unint64_t)(v23 + 1) >> 61) {
            abort();
          }
          uint64_t v25 = v12 - (void)v22;
          if (v25 >> 2 > v24) {
            unint64_t v24 = v25 >> 2;
          }
          BOOL v19 = (unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8;
          unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
          if (!v19) {
            unint64_t v26 = v24;
          }
          if (v26)
          {
            unint64_t v26 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v26);
            unint64_t v22 = *(char **)(v1 + 48);
            uint64_t v13 = *(char **)(v1 + 56);
          }
          else
          {
            uint64_t v27 = 0;
          }
          unsigned int v31 = (uint64_t *)(v26 + 8 * v23);
          unint64_t v32 = v26 + 8 * v27;
          *unsigned int v31 = v11;
          int v14 = v31 + 1;
          while (v13 != v22)
          {
            uint64_t v33 = *((void *)v13 - 1);
            v13 -= 8;
            *--unsigned int v31 = v33;
          }
          *(void *)(v1 + 48) = v31;
          *(void *)(v1 + 56) = v14;
          *(void *)(v1 + 64) = v32;
          if (v22) {
            operator delete(v22);
          }
        }
        else
        {
          *(void *)uint64_t v13 = v10;
          int v14 = v13 + 8;
        }
        *(void *)(v1 + 56) = v14;
        uint64_t v34 = *(void *)(v1 + 48);
        IOReportIterate();
        uint64_t v35 = ((uint64_t)v14 - v34) >> 3;
        long long v36 = v65;
        int v37 = *((_DWORD *)v65 + 6);
        int v38 = *(unsigned char **)(v1 + 112);
        int v39 = *(char **)(v1 + 120);
        unint64_t v40 = (v39 - v38) >> 3;
        if (v40 < v37)
        {
          unint64_t v46 = v37;
          BOOL v47 = (char *)(*(void *)(v1 + 48) + 8 * v35);
          uint64_t v48 = *(void *)(v1 + 128);
          id v63 = (id)v35;
          if (v37 <= (unint64_t)((v48 - (uint64_t)v38) >> 3))
          {
            unsigned int v54 = &v47[8 * v37];
            uint64_t v59 = (v39 - v38) >> 3;
            unsigned int v61 = &v47[8 * v40];
            if (v39 != v38)
            {
              memmove(v38, v47, v39 - v38);
              int v38 = *(unsigned char **)(v1 + 120);
              int v39 = v38;
            }
            unsigned int v55 = v38;
            if (v61 != v54)
            {
              unsigned int v56 = v61;
              uint64_t v57 = 8 * v46 - 8 * v59;
              unsigned int v55 = v39;
              do
              {
                uint64_t v58 = *(void *)v56;
                v56 += 8;
                *(void *)unsigned int v55 = v58;
                v55 += 8;
                v57 -= 8;
              }
              while (v57);
            }
            int64_t v53 = v55 - v38;
          }
          else
          {
            int v49 = *((_DWORD *)v65 + 6);
            unsigned int v60 = (void *)(v1 + 112);
            if (v38)
            {
              *(void *)(v1 + 120) = v38;
              operator delete(v38);
              uint64_t v48 = 0;
              *unsigned int v60 = 0;
              *(void *)(v1 + 120) = 0;
              *(void *)(v1 + 128) = 0;
            }
            if (v49 < 0) {
              abort();
            }
            uint64_t v50 = v48 >> 2;
            if (v48 >> 2 <= v46) {
              uint64_t v50 = v46;
            }
            if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v51 = v50;
            }
            std::vector<NSString * {__strong}>::__vallocate[abi:nn180100](v60, v51);
            int64_t v52 = 0;
            int v39 = *(char **)(v1 + 120);
            do
            {
              *(void *)&v39[v52] = *(void *)&v47[v52];
              v52 += 8;
            }
            while (8 * v46 != v52);
            int64_t v53 = v52;
          }
          uint64_t v35 = (uint64_t)v63;
          *(void *)(v1 + 120) = &v39[v53];
          long long v36 = v65;
          int v37 = *((_DWORD *)v65 + 6);
        }
        int v41 = v37 - 1;
        *((_DWORD *)v36 + 6) = v37 - 1;
        if (v37)
        {
          uint64_t v42 = *(void *)(v1 + 48);
          uint64_t v43 = *(void *)(v1 + 112);
          do
          {
            uint64_t v44 = v35 + v41;
            uint64_t v45 = *(void *)(v42 + 8 * v44);
            *(void *)(v42 + 8 * v44) = v45 - *(void *)(v43 + 8 * v41);
            *(void *)(v43 + 8 * *((int *)v65 + 6)) = v45;
            LODWORD(v45) = *((_DWORD *)v65 + 6);
            int v41 = v45 - 1;
            *((_DWORD *)v65 + 6) = v45 - 1;
          }
          while (v45);
        }
        _Block_object_dispose(&v64, 8);
      }
    }
    else
    {
      uint64_t Samples = IOReportCreateSamples();
      if (Samples)
      {
        id v62 = (id)Samples;
        uint64_t v5 = mach_absolute_time();
        uint64_t v6 = v5;
        uint64_t v8 = *(char **)(v1 + 56);
        unint64_t v7 = *(void *)(v1 + 64);
        if ((unint64_t)v8 >= v7)
        {
          unint64_t v15 = *(char **)(v1 + 48);
          uint64_t v16 = (v8 - v15) >> 3;
          unint64_t v17 = v16 + 1;
          if ((unint64_t)(v16 + 1) >> 61) {
            abort();
          }
          uint64_t v18 = v7 - (void)v15;
          if (v18 >> 2 > v17) {
            unint64_t v17 = v18 >> 2;
          }
          BOOL v19 = (unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8;
          unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
          if (!v19) {
            unint64_t v20 = v17;
          }
          if (v20)
          {
            unint64_t v20 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v20);
            unint64_t v15 = *(char **)(v1 + 48);
            uint64_t v8 = *(char **)(v1 + 56);
          }
          else
          {
            uint64_t v21 = 0;
          }
          unint64_t v28 = (uint64_t *)(v20 + 8 * v16);
          unint64_t v29 = v20 + 8 * v21;
          uint64_t *v28 = v6;
          unint64_t v9 = v28 + 1;
          while (v8 != v15)
          {
            uint64_t v30 = *((void *)v8 - 1);
            v8 -= 8;
            *--unint64_t v28 = v30;
          }
          *(void *)(v1 + 48) = v28;
          *(void *)(v1 + 56) = v9;
          *(void *)(v1 + 64) = v29;
          if (v15) {
            operator delete(v15);
          }
        }
        else
        {
          *(void *)uint64_t v8 = v5;
          unint64_t v9 = v8 + 8;
        }
        *(void *)(v1 + 56) = v9;
        [*(id *)(v1 + 40) addObject:v62];
      }
    }
  }
}

void sub_24CF70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Block_object_dispose((const void *)(v12 - 64), 8);
  _Unwind_Resume(a1);
}

void ___ZN16GTPerfStateGroup17AddPeriodicSampleEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  uint64_t IntegerValue = IOReportSimpleGetIntegerValue();
  uint64_t v4 = IntegerValue;
  uint64_t v6 = (uint64_t *)v2[7];
  unint64_t v5 = v2[8];
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = (uint64_t *)v2[6];
    uint64_t v9 = v6 - v8;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      abort();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    BOOL v12 = (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v12) {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      unint64_t v13 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<NSString * {__strong}>>(v13);
      uint64_t v8 = (uint64_t *)v2[6];
      uint64_t v6 = (uint64_t *)v2[7];
    }
    else
    {
      uint64_t v14 = 0;
    }
    unint64_t v15 = (uint64_t *)(v13 + 8 * v9);
    unint64_t v16 = v13 + 8 * v14;
    uint64_t *v15 = v4;
    unint64_t v7 = v15 + 1;
    while (v6 != v8)
    {
      uint64_t v17 = *--v6;
      *--unint64_t v15 = v17;
    }
    v2[6] = v15;
    v2[7] = v7;
    v2[8] = v16;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *uint64_t v6 = IntegerValue;
    unint64_t v7 = v6 + 1;
  }
  v2[7] = v7;
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

void sub_24D6FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::vector<GTPerfStateGroup>::__emplace_back_slow_path<NSString * {__strong},NSDictionary * {__strong},GTPerfStateGroup::eGTPerfStateGroup,GTPerfStateGroup::eGTPerfStateGroupType>(void *a1, void *a2, void *a3, int a4, int a5)
{
  unint64_t v5 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(a1[1] - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0x1AF286BCA1AF286) {
    abort();
  }
  if (0xD79435E50D79436 * ((uint64_t)(a1[2] - *a1) >> 3) > v6) {
    unint64_t v6 = 0xD79435E50D79436 * ((uint64_t)(a1[2] - *a1) >> 3);
  }
  if (0x86BCA1AF286BCA1BLL * ((uint64_t)(a1[2] - *a1) >> 3) >= 0xD79435E50D7943) {
    unint64_t v12 = 0x1AF286BCA1AF286;
  }
  else {
    unint64_t v12 = v6;
  }
  v19[4] = a1 + 2;
  if (v12)
  {
    if (v12 > 0x1AF286BCA1AF286) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v13 = (char *)operator new(152 * v12);
  }
  else
  {
    unint64_t v13 = 0;
  }
  uint64_t v14 = &v13[152 * v5];
  v19[0] = v13;
  v19[1] = v14;
  v19[3] = &v13[152 * v12];
  id v15 = a2;
  id v16 = a3;
  *(void *)uint64_t v14 = 0;
  *((void *)v14 + 1) = 0;
  *((void *)v14 + 3) = v15;
  *((void *)v14 + 4) = v16;
  *(_OWORD *)(v14 + 40) = 0u;
  *(_OWORD *)(v14 + 56) = 0u;
  *((_DWORD *)v14 + 18) = a4;
  *((_DWORD *)v14 + 19) = a5;
  *((void *)v14 + 11) = 0;
  *((void *)v14 + 12) = 0;
  *((void *)v14 + 10) = 0;
  *((_OWORD *)v14 + 7) = 0u;
  *((_OWORD *)v14 + 8) = 0u;
  *(void *)(v14 + 141) = 0;
  v19[2] = v14 + 152;
  std::vector<GTPerfStateGroup>::__swap_out_circular_buffer(a1, v19);
  uint64_t v17 = a1[1];
  std::__split_buffer<GTPerfStateGroup>::~__split_buffer((uint64_t)v19);
  return v17;
}

void sub_24D918(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<GTPerfStateGroup>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN16GTPerfStateGroup5SetupEP14__CFDictionary_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  unsigned int v31 = IOReportChannelGetGroup();
  if (([*(id *)(v3 + 24) isEqualToString:v31] & 1) == 0)
  {
    uint64_t v23 = 16;
    goto LABEL_48;
  }
  unint64_t v32 = IOReportChannelGetSubGroup();
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  obunint64_t j = [*(id *)(v3 + 32) allKeys];
  id v4 = [obj countByEnumeratingWithState:&v41 objects:v47 count:16];
  if (!v4)
  {
    uint64_t v23 = 16;
    goto LABEL_47;
  }
  uint64_t v5 = *(void *)v42;
  uint64_t v26 = v3;
  uint64_t v27 = a2;
  uint64_t v25 = *(void *)v42;
  while (2)
  {
    unint64_t v6 = 0;
    id v28 = v4;
    do
    {
      if (*(void *)v42 != v5) {
        objc_enumerationMutation(obj);
      }
      uint64_t v7 = *(void *)(*((void *)&v41 + 1) + 8 * (void)v6);
      if (objc_msgSend(v32, "hasPrefix:", v7, v25, v26, v27))
      {
        id v8 = [*(id *)(v3 + 32) objectForKeyedSubscript:v7];
        if (v8)
        {
          uint64_t v9 = IOReportChannelGetChannelName();
          int v10 = *(_DWORD *)(v3 + 76);
          if (v10)
          {
            if (v10 != 2)
            {
              if (v10 == 1 && ([v8 containsObject:v9] & 1) != 0)
              {
LABEL_45:

                uint64_t v23 = 0;
                goto LABEL_47;
              }
              goto LABEL_39;
            }
            long long v39 = 0u;
            long long v40 = 0u;
            long long v37 = 0u;
            long long v38 = 0u;
            unint64_t v29 = v8;
            id v8 = v8;
            id v14 = [v8 countByEnumeratingWithState:&v37 objects:v46 count:16];
            if (v14)
            {
              uint64_t v15 = *(void *)v38;
              do
              {
                for (int i = 0; i != v14; int i = (char *)i + 1)
                {
                  if (*(void *)v38 != v15) {
                    objc_enumerationMutation(v8);
                  }
                  uint64_t v17 = *(void *)(*((void *)&v37 + 1) + 8 * i);
                  if (([v9 containsString:@"_1_"] & 1) == 0)
                  {
                    BOOL v19 = [v9 rangeOfString:v17];
                    if (v19 != (unsigned char *)0x7FFFFFFFFFFFFFFFLL)
                    {
                      uint64_t v21 = [v9 rangeOfString:@"_" options:0 range:&v19[v18] length:[v9 length] - &v19[v18]];
                      if (v21 != (unsigned char *)0x7FFFFFFFFFFFFFFFLL)
                      {
                        unint64_t v22 = (char *)((unsigned char *)[v9 length] - &v21[v20]);
                        if (v22 == (char *)&dword_4)
                        {
                          if ([v9 characterAtIndex:[v9 length] - 4] == 86)goto LABEL_44; {
                        }
                          }
                        else if (v22 == (unsigned char *)&def_1C1270 + 2 {
                               && objc_msgSend(v9, "characterAtIndex:", (char *)objc_msgSend(v9, "length") - 2) == 70)
                        }
                        {
                          goto LABEL_44;
                        }
                      }
                    }
                  }
                }
                id v14 = [v8 countByEnumeratingWithState:&v37 objects:v46 count:16];
              }
              while (v14);
            }
          }
          else
          {
            long long v35 = 0u;
            long long v36 = 0u;
            long long v33 = 0u;
            long long v34 = 0u;
            unint64_t v29 = v8;
            id v8 = v8;
            id v11 = [v8 countByEnumeratingWithState:&v33 objects:v45 count:16];
            if (v11)
            {
              uint64_t v12 = *(void *)v34;
              while (2)
              {
                for (unint64_t j = 0; j != v11; unint64_t j = (char *)j + 1)
                {
                  if (*(void *)v34 != v12) {
                    objc_enumerationMutation(v8);
                  }
                  if ([v9 containsString:*(void *)(*((void *)&v33 + 1) + 8 * (void)j)])
                  {
LABEL_44:

                    goto LABEL_45;
                  }
                }
                id v11 = [v8 countByEnumeratingWithState:&v33 objects:v45 count:16];
                if (v11) {
                  continue;
                }
                break;
              }
            }
          }
          id v8 = v29;

          uint64_t v3 = v26;
          uint64_t v5 = v25;
          id v4 = v28;
LABEL_39:
        }
      }
      unint64_t v6 = (char *)v6 + 1;
    }
    while (v6 != v4);
    id v4 = [obj countByEnumeratingWithState:&v41 objects:v47 count:16];
    uint64_t v23 = 16;
    if (v4) {
      continue;
    }
    break;
  }
LABEL_47:

LABEL_48:
  return v23;
}

void sub_24DD0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN16GTPerfStateGroup27_FindSubscribedCounterNamesEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = IOReportChannelGetChannelName();
  id v4 = (char *)[v3 rangeOfString:@"_0_"];
  if (v4 != (char *)0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v6 = [v3 substringFromIndex:&v4[v5]];

    uint64_t v3 = (void *)v6;
  }
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  id v7 = *(id *)(a1 + 32);
  id v8 = [v7 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v8)
  {
    uint64_t v9 = *(void *)v17;
    while (2)
    {
      for (int i = 0; i != v8; int i = (char *)i + 1)
      {
        if (*(void *)v17 != v9) {
          objc_enumerationMutation(v7);
        }
        uint64_t v11 = *(void *)(*((void *)&v16 + 1) + 8 * i);
        if (objc_msgSend(v3, "hasSuffix:", v11, (void)v16))
        {
          uint64_t v12 = (char *)[v3 length];
          unint64_t v13 = [*(id *)(a1 + 32) objectForKeyedSubscript:v11];
          uint64_t v14 = [v3 stringByReplacingCharactersInRange:v12 - 4 withString:v13];

          uint64_t v3 = (void *)v14;
          goto LABEL_13;
        }
      }
      id v8 = [v7 countByEnumeratingWithState:&v16 objects:v20 count:16];
      if (v8) {
        continue;
      }
      break;
    }
  }
LABEL_13:

  [*(id *)(v2 + 136) addObject:v3];
  return 0;
}

void sub_24DF58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::vector<GTPerfStateGroup>::__swap_out_circular_buffer(void *result, void *a2)
{
  uint64_t v2 = result[1];
  uint64_t v3 = a2[1];
  uint64_t v28 = *result;
  if (v2 != *result)
  {
    uint64_t v26 = result;
    uint64_t v27 = a2;
    uint64_t v4 = 0;
    uint64_t v29 = result[1];
    do
    {
      uint64_t v5 = v3 + v4;
      *(void *)(v5 - 152) = *(id *)(v2 + v4 - 152);
      id v6 = *(id *)(v2 + v4 - 144);
      uint64_t v7 = *(void *)(v2 + v4 - 136);
      id v8 = *(void **)(v2 + v4 - 128);
      *(void *)(v5 - 144) = v6;
      *(void *)(v5 - 136) = v7;
      *(void *)(v5 - 128) = v8;
      *(void *)(v5 - 120) = *(id *)(v2 + v4 - 120);
      *(void *)(v5 - 112) = *(id *)(v2 + v4 - 112);
      std::vector<unsigned long long>::vector((void *)(v3 + v4 - 104), v2 + v4 - 104);
      uint64_t v9 = *(void *)(v2 + v4 - 80);
      *(void *)(v5 - 72) = 0;
      uint64_t v10 = v3 + v4 - 72;
      *(void *)(v5 - 80) = v9;
      *(void *)(v10 + 8) = 0;
      *(void *)(v10 + 16) = 0;
      uint64_t v12 = *(unsigned char **)(v2 + v4 - 72);
      uint64_t v11 = *(unsigned char **)(v2 + v4 - 64);
      int64_t v13 = v11 - v12;
      if (v11 != v12)
      {
        std::vector<AccelerationStructureViewer::FilterToken>::__vallocate[abi:nn180100]((void *)(v5 - 72), 0xAAAAAAAAAAAAAAABLL * (v13 >> 3));
        uint64_t v14 = *(char **)(v3 + v4 - 64);
        memmove(v14, v12, v13);
        *(void *)(v3 + v4 - 64) = &v14[8 * (v13 >> 3)];
        uint64_t v2 = v29;
      }
      uint64_t v15 = v3 + v4;
      uint64_t v16 = v2 + v4;
      uint64_t v17 = *(void *)(v2 + v4 - 48);
      *(void *)(v3 + v4 - 40) = 0;
      long long v18 = (void *)(v3 + v4 - 40);
      *(v18 - 1) = v17;
      v18[1] = 0;
      v18[2] = 0;
      uint64_t v20 = *(unsigned char **)(v2 + v4 - 40);
      long long v19 = *(unsigned char **)(v2 + v4 - 32);
      int64_t v21 = v19 - v20;
      if (v19 != v20)
      {
        std::vector<NSString * {__strong}>::__vallocate[abi:nn180100](v18, v21 >> 3);
        unint64_t v22 = *(char **)(v3 + v4 - 32);
        memmove(v22, v20, v21);
        *(void *)(v3 + v4 - 32) = &v22[8 * (v21 >> 3)];
        uint64_t v2 = v29;
      }
      *(void *)(v15 - 16) = *(id *)(v16 - 16);
      *(void *)(v15 - 8) = *(void *)(v16 - 8);
      v4 -= 152;
    }
    while (v2 + v4 != v28);
    v3 += v4;
    BOOL result = v26;
    a2 = v27;
  }
  a2[1] = v3;
  uint64_t v23 = *result;
  *BOOL result = v3;
  a2[1] = v23;
  uint64_t v24 = result[1];
  result[1] = a2[2];
  a2[2] = v24;
  uint64_t v25 = result[2];
  result[2] = a2[3];
  a2[3] = v25;
  *a2 = a2[1];
  return result;
}

void sub_24E16C(_Unwind_Exception *a1)
{
  uint64_t v5 = *v2;
  if (*v2)
  {
    *(void *)(v3 - 64) = v5;
    operator delete(v5);
  }
  id v6 = *v1;
  if (*v1)
  {
    *(void *)(v3 - 96) = v6;
    operator delete(v6);
  }

  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<GTPerfStateGroup>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 152;
    GTPerfStateGroup::~GTPerfStateGroup((GTPerfStateGroup *)(i - 152));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_24EAE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,void *a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,void *a61)
{
  if (a41) {
    operator delete(a41);
  }
  if (a44) {
    operator delete(a44);
  }
  if (a47) {
    operator delete(a47);
  }
  if (a50) {
    operator delete(a50);
  }
  if (a53) {
    operator delete(a53);
  }
  operator delete(a20);
  operator delete(a18);
  operator delete(a21);

  _Unwind_Resume(a1);
}

void sub_24ED58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_24EE80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_24EF20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_24EFF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTMTLReplayController_initializeArgumentBufferSupport(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v143 = a3;
  uint64_t v6 = GTMTLSMContext_getObject(**(void **)(a1 + 40), 1, *(void *)(a1 + 80))[5];
  if ((dword_77313C & 0x10000) != 0)
  {
    if ((GT_SUPPORT_0 & 0x80000) != 0) {
      uint64_t v7 = (*(_DWORD *)(a1 + 272) << 18) & 0x80000;
    }
    else {
      uint64_t v7 = 0;
    }
    GT_SUPPORT_0 = v7 | GT_SUPPORT_0 & 0xFFFFFFFFFFF7FFFFLL;
  }
  if (*(unsigned char *)(v6 + 110))
  {
    uint64_t v8 = 0x80000;
    if ((((*(unsigned char *)(v6 + 24) & 8) == 0) & (GT_SUPPORT_0 >> 19)) == 0) {
      uint64_t v8 = 0;
    }
    unint64_t v9 = v8 | GT_SUPPORT_0 & 0xFFFFFFFFFFF7FFFFLL;
  }
  else
  {
    unint64_t v9 = GT_SUPPORT_0 & 0xFFFFFFFFFFF7FFFFLL;
  }
  BOOL v20 = ((*(void *)(v6 + 32) >> 8) & 1 & (v9 >> 20)) == 0;
  uint64_t v10 = 0x100000;
  if (v20) {
    uint64_t v10 = 0;
  }
  GT_SUPPORT_0 = v10 | v9 & 0xFFFFFFFFFFEFFFFFLL;
  if ((v9 & 0x80000) != 0)
  {
    id v139 = v5;
    id v11 = v5;
    id v12 = v143;
    uint64_t v13 = *(void *)(a1 + 192);
    int v14 = *(_DWORD *)(v13 + 12);
    if (v14 >= 1)
    {
      int v15 = 0;
      int v16 = GT_SUPPORT_0;
      do
      {
        uint64_t v17 = *(void *)(v13 + 24);
        long long v18 = *(int **)(v17 + 8 * v15);
        int v19 = *v18;
        BOOL v20 = *v18 == 50 || v19 == 22;
        if (v20 || v19 == 16 && (v16 & 0x100000) == 0)
        {
          *(_DWORD *)(v13 + 12) = --v14;
          *(void *)(v17 + 8 * v15) = *(void *)(v17 + 8 * v14);
          *(void *)(*(void *)(v13 + 24) + 8 * v14) = v18;
        }
        else
        {
          ++v15;
        }
      }
      while (v15 < v14);
    }
    uint64_t v141 = a1;
    int64_t v21 = *(void **)(a1 + 40);
    id v23 = v11;
    unsigned int v144 = v21;
    uint64_t v24 = v21[10];
    if (*(int *)(v24 + 12) >= 1)
    {
      uint64_t v25 = 0;
      while (1)
      {
        uint64_t v26 = *(void *)(*(void *)(v24 + 24) + 8 * v25);
        uint64_t v27 = *(void **)(v26 + 48);
        uint64_t v28 = MakeMTLHeapDescriptor((uint64_t)v27);
        [v28 setPinnedGPUAddress:*v27];
        id v29 = [v28 size];
        id v30 = (id)*(unsigned int *)(v26 + 76);
        if (v29 >= v30) {
          id v30 = [v28 size];
        }
        [v28 setSize:v30];
        unsigned int v31 = (char *)[v28 type];
        if ((unint64_t)v31 < 2) {
          break;
        }
        if (v31 != (unsigned char *)&def_1C1270 + 2) {
          goto LABEL_34;
        }
LABEL_38:

        if (++v25 >= *(int *)(v24 + 12)) {
          goto LABEL_39;
        }
      }
      [v28 setType:1];
LABEL_34:
      id v32 = [v23 newHeapWithDescriptor:v28];
      if (v32) {
        [v12 setHeap:v32 forKey:*(void *)(v26 + 8)];
      }
      else {
        GTMTLReplay_handleError(101, (uint64_t)"Heap creation failed", "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_argumentBuffers.m", (uint64_t)"GTMTLReplayController_allocateBuffersAndHeaps", 177, 1);
      }

      goto LABEL_38;
    }
LABEL_39:
    newpool[0] = 0;
    apr_pool_create_ex(newpool, 0, 0, v22);
    int p = newpool[0];
    long long v33 = apr_hash_make(newpool[0]);
    uint64_t v34 = v144[1];
    id v35 = objc_alloc_init((Class)MTLBufferDescriptor);
    if (*(int *)(v34 + 12) >= 1)
    {
      uint64_t v36 = 0;
      do
      {
        uint64_t v37 = *(void *)(*(void *)(v34 + 24) + 8 * v36);
        if ((dword_77313C & 0x200000) != 0
          && *(void *)(v37 + 144)
          && (entry = find_entry((uint64_t)v33, (unsigned char *)(v37 + 112), 8uLL, 0), *entry)
          && (uint64_t v39 = *(void *)(*entry + 32)) != 0)
        {
          id v40 = [v12 bufferForKey:*(void *)(v39 + 8)];
        }
        else
        {
          id v40 = 0;
        }
        if (!*(void *)(v37 + 48))
        {
          if (v40
            || ([v35 setPinnedGPUAddress:*(void *)(v37 + 112)],
                [v35 setParentGPUAddress:*(void *)(v37 + 128)],
                [v35 setParentGPUSize:*(void *)(v37 + 136)],
                [v35 setResourceOptions:*(unsigned __int16 *)(v37 + 96)],
                [v35 setLength:*(void *)(v37 + 104)],
                (id v40 = [v23 newBufferWithDescriptor:v35]) != 0))
          {
            [v12 setBuffer:v40 forKey:*(void *)(v37 + 8)];
            if ((dword_77313C & 0x200000) != 0 && *(void *)(v37 + 144)) {
              apr_hash_set(v33, (const void *)(v37 + 112), 8, (const void *)v37);
            }
          }
          else
          {
            GTMTLReplay_handleError(101, (uint64_t)"Buffer creation failed", "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_argumentBuffers.m", (uint64_t)"GTMTLReplayController_allocateBuffersAndHeaps", 232, 1);
          }
        }

        ++v36;
      }
      while (v36 < *(int *)(v34 + 12));
    }
    apr_pool_destroy(p);
    uint64_t v41 = v144[9];
    if (*(int *)(v41 + 12) >= 1)
    {
      uint64_t v42 = 0;
      while (1)
      {
        uint64_t v43 = *(void *)(*(void *)(v41 + 24) + 8 * v42);
        if (*(void *)(v43 + 144)
          || *(void *)(v43 + 48)
          || (GT_SUPPORT_0 & 0x100000) != 0 && *(void *)(v43 + 152)
          || !*(void *)(v43 + 160))
        {
          goto LABEL_59;
        }
        [v35 setPinnedGPUAddress:];
        [v35 setParentGPUAddress:*(void *)(v43 + 168)];
        [v35 setParentGPUSize:*(void *)(v43 + 176)];
        [v35 setResourceOptions:*(unsigned __int16 *)(v43 + 96)];
        [v35 setLength:*(void *)(v43 + 192)];
        id v44 = [v23 newBufferWithDescriptor:v35];
        if (!v44) {
          break;
        }
        uint64_t v45 = v44;
        id v46 = [v23 newAccelerationStructureWithBuffer:v44 offset:*(void *)(v43 + 200)];

        if (!v46)
        {
          BOOL v47 = "Acceleration structure creation failed";
          uint64_t v48 = 287;
          goto LABEL_69;
        }
        [v12 setAccelerationStructure:v46 forKey:*(void *)(v43 + 8)];

LABEL_59:
        if (++v42 >= *(int *)(v41 + 12)) {
          goto LABEL_70;
        }
      }
      BOOL v47 = "Acceleration structure buffer creation failed";
      uint64_t v48 = 270;
LABEL_69:
      GTMTLReplay_handleError(101, (uint64_t)v47, "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_argumentBuffers.m", (uint64_t)"GTMTLReplayController_allocateBuffersAndHeaps", v48, 1);
      goto LABEL_59;
    }
LABEL_70:
    int v49 = *(_DWORD *)(v24 + 12);
    if (v49 >= 1)
    {
      for (uint64_t i = 0; i < v49; ++i)
      {
        uint64_t v51 = *(void *)(*(void *)(v24 + 24) + 8 * i);
        uint64_t v52 = *(void *)(v51 + 48);
        if (*(unsigned char *)(v52 + 19) == 2)
        {
          int64_t v53 = MakeMTLHeapDescriptor(v52);
          id v54 = [v53 size];
          id v55 = (id)*(unsigned int *)(v51 + 76);
          if (v54 >= v55) {
            id v55 = [v53 size];
          }
          [v53 setSize:v55];
          id v56 = [v23 newHeapWithDescriptor:v53];
          if (v56) {
            [v12 setHeap:v56 forKey:*(void *)(v51 + 8)];
          }
          else {
            GTMTLReplay_handleError(101, (uint64_t)"Sparse heap creation failed", "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_argumentBuffers.m", (uint64_t)"GTMTLReplayController_allocateBuffersAndHeaps", 309, 1);
          }

          int v49 = *(_DWORD *)(v24 + 12);
        }
      }
    }

    id v5 = v139;
    a1 = v141;
  }
  id v145 = v5;

  uint64_t v57 = *(uint64_t **)(a1 + 40);
  uint64_t v58 = initializeResourcePatchingTypes(v145, (unsigned char *)&def_1C1270 + 1);
  g_forcePatchingTypeReplaceMasuint64_t k = 0;
  uint64_t v60 = v58 & ~qword_773128;
  if (v60 && (*(unsigned char *)(a1 + 272) & 2) == 0) {
    uint64_t v60 = 0;
  }
  g_enableIndexedResourceType = v60;
  id v180 = 0;
  apr_pool_create_ex(&v180, 0, 0, v59);
  unsigned int v61 = v180;
  id v62 = apr_array_make(v180, 128, 8);
  id v63 = v62;
  char v64 = g_enableIndexedResourceType;
  if ((g_enableIndexedResourceType & 1) == 0)
  {
    if ((g_enableIndexedResourceType & 2) == 0) {
      goto LABEL_86;
    }
    goto LABEL_101;
  }
  v62->int nelts = 0;
  uint64_t v65 = v57[2];
  int v66 = *(_DWORD *)(v65 + 12);
  if (v66 >= 1)
  {
    uint64_t v67 = 0;
    while (1)
    {
      uint64_t v68 = *(void *)(*(void *)(v65 + 24) + 8 * v67);
      uint64_t v69 = *(void *)(v68 + 104);
      if (!v69) {
        break;
      }
      uint64_t v70 = *(void *)(v69 + 8);
      if (v70) {
        goto LABEL_95;
      }
LABEL_96:
      if (++v67 >= v66) {
        goto LABEL_100;
      }
    }
    uint64_t v70 = *(void *)(v68 + 176);
    if (!v70) {
      goto LABEL_96;
    }
LABEL_95:
    *(void *)apr_array_push(v63) = v70;
    int v66 = *(_DWORD *)(v65 + 12);
    goto LABEL_96;
  }
LABEL_100:
  ReserveResourceIndices(v145, (uint64_t)v63, 0);
  char v64 = g_enableIndexedResourceType;
  if ((g_enableIndexedResourceType & 2) == 0)
  {
LABEL_86:
    if ((v64 & 0x10) == 0) {
      goto LABEL_87;
    }
    goto LABEL_110;
  }
LABEL_101:
  v63->int nelts = 0;
  uint64_t v71 = v57[3];
  int v72 = *(_DWORD *)(v71 + 12);
  unsigned int v73 = v145;
  if (v72 >= 1)
  {
    for (uint64_t j = 0; j < v72; ++j)
    {
      uint64_t v75 = *(void *)(*(void *)(*(void *)(v71 + 24) + 8 * j) + 48);
      if (v75)
      {
        if (*(unsigned char *)(v75 + 62))
        {
          uint64_t v76 = *(void *)(v75 + 16);
          unsigned int v73 = v145;
          if (v76)
          {
            int v77 = apr_array_push(v63);
            unsigned int v73 = v145;
            *int v77 = v76;
            int v72 = *(_DWORD *)(v71 + 12);
          }
        }
        else
        {
          unsigned int v73 = v145;
        }
      }
    }
  }
  ReserveResourceIndices(v73, (uint64_t)v63, 1u);
  char v64 = g_enableIndexedResourceType;
  if ((g_enableIndexedResourceType & 0x10) == 0)
  {
LABEL_87:
    if ((v64 & 0x20) == 0) {
      goto LABEL_88;
    }
    goto LABEL_124;
  }
LABEL_110:
  v63->int nelts = 0;
  uint64_t v78 = v57[4];
  int v79 = *(_DWORD *)(v78 + 12);
  if (v79 >= 1)
  {
    for (uint64_t k = 0; k < v79; ++k)
    {
      uint64_t v81 = *(void *)(*(void *)(*(void *)(v78 + 24) + 8 * k) + 48);
      if (v81)
      {
        if (*(unsigned char *)(v81 + 1499))
        {
          uint64_t v82 = *(void *)(v81 + 1280);
          if (v82)
          {
            *(void *)apr_array_push(v63) = v82;
            int v79 = *(_DWORD *)(v78 + 12);
          }
        }
      }
    }
  }
  uint64_t v83 = v57[5];
  if (*(int *)(v83 + 12) >= 1)
  {
    uint64_t v84 = 0;
    do
    {
      uint64_t v85 = *(void *)(*(void *)(v83 + 24) + 8 * v84);
      long long v176 = 0u;
      long long v177 = 0u;
      long long v174 = 0u;
      long long v175 = 0u;
      long long v172 = 0u;
      long long v173 = 0u;
      long long v170 = 0u;
      long long v171 = 0u;
      long long v168 = 0u;
      long long v169 = 0u;
      long long v166 = 0u;
      long long v167 = 0u;
      long long v164 = 0u;
      long long v165 = 0u;
      long long v162 = 0u;
      long long v163 = 0u;
      long long v160 = 0u;
      long long v161 = 0u;
      long long v158 = 0u;
      long long v159 = 0u;
      long long v156 = 0u;
      long long v157 = 0u;
      long long v154 = 0u;
      long long v155 = 0u;
      long long v152 = 0u;
      long long v153 = 0u;
      long long v150 = 0u;
      long long v151 = 0u;
      long long v148 = 0u;
      long long v149 = 0u;
      *(_OWORD *)long long newpool = 0u;
      long long v147 = 0u;
      GTMTLSMComputePipelineState_computePipelineDescriptor(v57, v85, newpool, v61);
      if (v179)
      {
        uint64_t v86 = v178;
        if (v178) {
          *(void *)apr_array_push(v63) = v86;
        }
      }
      ++v84;
    }
    while (v84 < *(int *)(v83 + 12));
  }
  ReserveResourceIndices(v145, (uint64_t)v63, 4u);
  char v64 = g_enableIndexedResourceType;
  if ((g_enableIndexedResourceType & 0x20) == 0)
  {
LABEL_88:
    if ((v64 & 0x40) == 0) {
      goto LABEL_89;
    }
    goto LABEL_130;
  }
LABEL_124:
  v63->int nelts = 0;
  uint64_t v87 = v57[6];
  int v88 = *(_DWORD *)(v87 + 12);
  unsigned int v89 = v145;
  if (v88 >= 1)
  {
    for (uint64_t m = 0; m < v88; ++m)
    {
      uint64_t v91 = **(void **)(*(void *)(*(void *)(v87 + 24) + 8 * m) + 104);
      if (v91)
      {
        uint64_t v92 = apr_array_push(v63);
        unsigned int v89 = v145;
        void *v92 = v91;
        int v88 = *(_DWORD *)(v87 + 12);
      }
    }
  }
  ReserveResourceIndices(v89, (uint64_t)v63, 5u);
  char v64 = g_enableIndexedResourceType;
  if ((g_enableIndexedResourceType & 0x40) == 0)
  {
LABEL_89:
    if ((v64 & 0x80) == 0) {
      goto LABEL_142;
    }
    goto LABEL_136;
  }
LABEL_130:
  v63->int nelts = 0;
  uint64_t v93 = v57[7];
  int v94 = *(_DWORD *)(v93 + 12);
  unsigned int v95 = v145;
  if (v94 >= 1)
  {
    for (uint64_t n = 0; n < v94; ++n)
    {
      uint64_t v97 = *(void *)(*(void *)(*(void *)(*(void *)(v93 + 24) + 8 * n) + 104) + 8);
      if (v97)
      {
        int64_t v98 = apr_array_push(v63);
        unsigned int v95 = v145;
        void *v98 = v97;
        int v94 = *(_DWORD *)(v93 + 12);
      }
    }
  }
  ReserveResourceIndices(v95, (uint64_t)v63, 6u);
  if ((g_enableIndexedResourceType & 0x80) != 0)
  {
LABEL_136:
    v63->int nelts = 0;
    uint64_t v99 = v57[8];
    int v100 = *(_DWORD *)(v99 + 12);
    uint64_t v101 = v145;
    if (v100 >= 1)
    {
      for (iuint64_t i = 0; ii < v100; ++ii)
      {
        uint64_t v103 = **(void **)(*(void *)(*(void *)(v99 + 24) + 8 * ii) + 104);
        if (v103)
        {
          unsigned int v104 = apr_array_push(v63);
          uint64_t v101 = v145;
          void *v104 = v103;
          int v100 = *(_DWORD *)(v99 + 12);
        }
      }
    }
    ReserveResourceIndices(v101, (uint64_t)v63, 7u);
  }
LABEL_142:
  if ((GT_SUPPORT_0 & 0x100000) != 0 && (g_enableIndexedResourceType & 0x100) != 0)
  {
    v63->int nelts = 0;
    uint64_t v105 = v57[9];
    if (*(int *)(v105 + 12) >= 1)
    {
      uint64_t v106 = 0;
      do
      {
        uint64_t v107 = *(void *)(*(void *)(*(void *)(v105 + 24) + 8 * v106) + 152);
        *(void *)apr_array_push(v63) = v107;
        ++v106;
      }
      while (v106 < *(int *)(v105 + 12));
    }
    ReserveResourceIndices(v145, (uint64_t)v63, 8u);
  }
  apr_pool_destroy(v61);
  uint64_t v108 = (uint64_t (*)(void))MakeMTLTextureDescriptorWithResourceIndex;
  if ((g_enableIndexedResourceType & 1) == 0) {
    uint64_t v108 = (uint64_t (*)(void))MakeMTLTextureDescriptorWithoutResourceIndex;
  }
  MakeMTLTextureDescriptor = v108;
  unsigned int v109 = MakeMTLSamplerDescriptorWithResourceIndex;
  if ((g_enableIndexedResourceType & 2) == 0) {
    unsigned int v109 = MakeMTLSamplerDescriptorWithoutResourceIndex;
  }
  MakeMTLSamplerDescriptor = v109;
  unsigned int v110 = MakeMTLIndirectCommandBufferDescriptorWithResourceIndex;
  if ((g_enableIndexedResourceType & 0x20) == 0) {
    unsigned int v110 = MakeMTLIndirectCommandBufferDescriptorWithoutResourceIndex;
  }
  MakeMTLIndirectCommandBufferDescriptor = v110;
  unsigned int v111 = MakeMTLRenderPipelineDescriptorWithResourceIndex;
  if ((g_enableIndexedResourceType & 0x10) == 0) {
    unsigned int v111 = MakeMTLRenderPipelineDescriptorWithoutResourceIndex;
  }
  MakeMTLRenderPipelineDescriptor = (uint64_t (*)(void, void))v111;
  uint64_t v112 = MakeMTLMeshRenderPipelineDescriptorWithResourceIndex;
  if ((g_enableIndexedResourceType & 0x10) == 0) {
    uint64_t v112 = MakeMTLMeshRenderPipelineDescriptorWithoutResourceIndex;
  }
  MakeMTLMeshRenderPipelineDescriptor = (uint64_t (*)(void, void))v112;
  unint64_t v113 = MakeMTLComputePipelineDescriptorWithResourceIndex;
  if ((g_enableIndexedResourceType & 0x10) == 0) {
    unint64_t v113 = MakeMTLComputePipelineDescriptorWithoutResourceIndex;
  }
  MakeMTLComputePipelineDescriptor = (uint64_t (*)(void, void))v113;
  uint64_t v114 = (uint64_t (*)(void))MakeMTLVisibleFunctionTableDescriptorWithResourceIndex;
  if ((g_enableIndexedResourceType & 0x40) == 0) {
    uint64_t v114 = (uint64_t (*)(void))MakeMTLVisibleFunctionTableDescriptorWithoutResourceIndex;
  }
  MakeMTLVisibleFunctionTableDescriptor = v114;
  int v115 = MakeMTLIntersectionFunctionTableDescriptorWithResourceIndex;
  if ((g_enableIndexedResourceType & 0x80) == 0) {
    int v115 = MakeMTLIntersectionFunctionTableDescriptorWithoutResourceIndex;
  }
  MakeMTLIntersectionFunctionTableDescriptor = (uint64_t (*)(void))v115;

  if ((GT_SUPPORT_0 & 0x80000) != 0)
  {
    id v116 = v145;
    id v117 = v143;
    uint64_t v118 = *(void *)(a1 + 40);
    id v119 = v116;
    uint64_t v140 = v118;
    uint64_t v120 = *(void *)(v118 + 8);
    id v142 = objc_alloc_init((Class)MTLBufferDescriptor);
    if (*(int *)(v120 + 12) >= 1)
    {
      uint64_t v121 = 0;
      do
      {
        uint64_t v122 = *(void *)(*(void *)(v120 + 24) + 8 * v121);
        if (*(void *)(v122 + 48))
        {
          unint64_t v123 = [v117 heapForKey:];
          if (!v123) {
            GTMTLReplay_handleError(101, (uint64_t)"Buffer creationg failed: heap is nil", "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_argumentBuffers.m", (uint64_t)"GTMTLReplayController_allocateHeapAndBufferChildren", 336, 1);
          }
          id v124 = [v123 newBufferWithLength:*(void *)(v122 + 104) options:*(unsigned __int16 *)(v122 + 96) offset:*(unsigned int *)(v122 + 80)];

          if (v124)
          {
            [v117 setBuffer:v124 forKey:*(void *)(v122 + 8)];
          }
          else
          {
            GTMTLReplay_handleError(101, (uint64_t)"Buffer freation Failed", "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_argumentBuffers.m", (uint64_t)"GTMTLReplayController_allocateHeapAndBufferChildren", 351, 1);
          }
        }
        ++v121;
      }
      while (v121 < *(int *)(v120 + 12));
    }
    uint64_t v125 = *(void *)(v140 + 72);
    if (*(int *)(v125 + 12) >= 1)
    {
      for (juint64_t j = 0; jj < *(int *)(v125 + 12); ++jj)
      {
        uint64_t v127 = *(void *)(*(void *)(v125 + 24) + 8 * jj);
        if (*(void *)(v127 + 144))
        {
          uint64_t v128 = [v117 bufferForKey:];
          if (!v128)
          {
            unint64_t v135 = "Acceleration structure creation failed: buffer is nil";
            uint64_t v136 = 367;
LABEL_191:
            GTMTLReplay_handleError(101, (uint64_t)v135, "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_argumentBuffers.m", (uint64_t)"GTMTLReplayController_allocateHeapAndBufferChildren", v136, 1);
            continue;
          }
          unsigned int v129 = (void *)v128;
          uint64_t v130 = *(void *)(v127 + 200);
          if (*(void *)(v127 + 152)) {
            id v131 = [v119 newAccelerationStructureWithBuffer:v128 offset:v130 resourceIndex:];
          }
          else {
            id v131 = [v119 newAccelerationStructureWithBuffer:v128 offset:v130];
          }
        }
        else
        {
          if (!*(void *)(v127 + 48)) {
            continue;
          }
          unsigned int v132 = [v117 heapForKey:];
          if (!v132)
          {
            unint64_t v135 = "Accelertion structure creation failed: heap is nil";
            uint64_t v136 = 387;
            goto LABEL_191;
          }
          unsigned int v129 = v132;
          uint64_t v133 = *(void *)(v127 + 184);
          uint64_t v134 = *(unsigned int *)(v127 + 80);
          if (*(void *)(v127 + 152)) {
            id v131 = [v132 newAccelerationStructureWithSize:v133 offset:v134 resourceIndex:];
          }
          else {
            id v131 = [v132 newAccelerationStructureWithSize:v133 offset:v134];
          }
        }
        unsigned int v137 = v131;

        if (!v137)
        {
          unint64_t v135 = "Acceleration Structure Creation Failed";
          uint64_t v136 = 416;
          goto LABEL_191;
        }
        [v117 setAccelerationStructure:v137 forKey:*(void *)(v127 + 8)];
      }
    }
  }
}

uint64_t initializeResourcePatchingTypes(void *a1, char *a2)
{
  id v3 = a1;
  uint64_t v4 = DEVICEOBJECT(v3);
  char v5 = objc_opt_respondsToSelector();

  if (v5)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    do
    {
      if (v6 == 3)
      {
        if ((char *)(~(GT_SUPPORT_0 >> 18) & 2) == a2) {
          v7 |= 8uLL;
        }
      }
      else if ([v3 resourcePatchingTypeForResourceType:v6] == a2)
      {
        v7 |= 1 << v6;
      }
      ++v6;
    }
    while (v6 != 9);
  }
  else if (a2 == (unsigned char *)&def_1C1270 + 2)
  {
    uint64_t v7 = 511;
  }
  else
  {
    uint64_t v7 = 0;
  }

  return v7;
}

void ReserveResourceIndices(void *a1, uint64_t a2, unsigned int a3)
{
  id v5 = a1;
  size_t v6 = *(int *)(a2 + 12);
  if (v6)
  {
    int v14 = v5;
    qsort(*(void **)(a2 + 24), v6, *(int *)(a2 + 8), (int (__cdecl *)(const void *, const void *))CompareU64);
    uint64_t v7 = *(uint64_t **)(a2 + 24);
    uint64_t v8 = *v7;
    *(_DWORD *)(a2 + 12) = 1;
    if ((int)v6 >= 2)
    {
      uint64_t v9 = v6 - 1;
      uint64_t v10 = v7 + 1;
      int v11 = 1;
      do
      {
        uint64_t v13 = *v10++;
        uint64_t v12 = v13;
        if (v8 != v13)
        {
          v7[v11++] = v12;
          *(_DWORD *)(a2 + 12) = v11;
          uint64_t v8 = v12;
        }
        --v9;
      }
      while (v9);
    }
    [v14 reserveResourceIndicesForResourceType:a3 indices:indexCount:];
    id v5 = v14;
  }
  else
  {
    g_forcePatchingTypeReplaceMask |= 1 << a3;
    g_enableIndexedResourceType &= ~(1 << a3);
  }
}

uint64_t CompareU64(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 != *a2;
  }
}

uint64_t GetAliasStream2(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = a2;
  entry = find_entry(*(void *)(a1 + 24), &v7, 8uLL, 0);
  if (*entry
    && (uint64_t v4 = *(void *)(*entry + 32)) != 0
    && (unint64_t v5 = atomic_load((unint64_t *)(*(void *)(a1 + 16) + 72)), v5 < *(void *)(v4 + 24)))
  {
    return *(void *)(v4 + 8);
  }
  else
  {
    return 0;
  }
}

uint64_t *ConvertUniqueIdentifierResources(uint64_t *result, uint64_t a2)
{
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v3 = (uint64_t)result;
    uint64_t v4 = 0;
    uint64_t v5 = 8;
    do
    {
      uint64_t v6 = *(void *)(a2 + 24);
      BOOL result = (uint64_t *)GetAliasStream2(v3, *(void *)(v6 + v5));
      if (result) {
        uint64_t v7 = *result;
      }
      else {
        uint64_t v7 = 0;
      }
      *(void *)(v6 + v5) = v7;
      ++v4;
      v5 += 32;
    }
    while (v4 < *(int *)(a2 + 12));
  }
  return result;
}

uint64_t DYMTLIndirectArgumentBufferManager_cleanup(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 120);
  *(void *)(a1 + 120) = 0;

  return 0;
}

uint64_t GTTrackerIndirectArgumentBufferInfo_compare(void *a1, void *a2)
{
  unint64_t v2 = a1[2];
  unint64_t v3 = a2[2];
  BOOL v4 = v2 >= v3;
  if (v2 == v3 && (v5 = a1[3], v6 = a2[3], BOOL v4 = v5 >= v6, v5 == v6))
  {
    unint64_t v7 = a1[4];
    unint64_t v8 = a2[4];
    BOOL v4 = v7 >= v8;
    BOOL v9 = v7 != v8;
    if (v4) {
      return v9;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  else if (v4)
  {
    return 1;
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t DYMTLMutableBufferAncestor_compare(void *a1, void *a2)
{
  unint64_t v2 = a1[1];
  unint64_t v3 = a2[1];
  if (v2 == v3)
  {
    if (*a1 < *a2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return *a1 != *a2;
    }
  }
  else if (v2 < v3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 1;
  }
}

uint64_t DYMTLIndirectArgumentBufferManager_processCommandBuffer(uint64_t a1, uint64_t a2)
{
  if (!a2 || *(int *)(*(void *)(a2 + 104) + 12) < 1) {
    return 0;
  }
  id v122 = *(id *)(a1 + 8);
  BOOL v4 = [v122 defaultDevice];
  uint64_t v5 = initializeResourcePatchingTypes(v4, (unsigned char *)&def_1C1270 + 2);

  uint64_t v6 = qword_773128 | g_forcePatchingTypeReplaceMask;
  long long newpool = 0;
  apr_pool_create_ex(&newpool, 0, 0, v7);
  unint64_t v8 = newpool;
  BOOL v9 = apr_array_make(newpool, 4, 40);
  uint64_t v10 = v8;
  int v11 = v9;
  uint64_t v12 = (void *)*((void *)v10 + 5);
  uint64_t v120 = a1;
  int p = v10;
  if (v12)
  {
    *((void *)v10 + 5) = *v12;
  }
  else
  {
    uint64_t v12 = apr_palloc(v10, 0x20uLL);
    uint64_t v10 = p;
  }
  unint64_t v126 = v6 | v5;
  arr = v11;
  v12[1] = v11;
  v12[2] = DYMTLIABDecodingOp_cleanup;
  v12[3] = apr_pool_cleanup_null;
  void *v12 = *((void *)v10 + 4);
  *((void *)v10 + 4) = v12;
  if (*(int *)(*(void *)(a2 + 104) + 12) >= 1)
  {
    uint64_t v14 = 0;
    int8x16_t v133 = (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFFF8);
    int64x2_t v135 = vdupq_n_s64(7uLL);
    do
    {
      uint64_t v15 = *(void *)(*(void *)(a2 + 104) + 24);
      uint64_t v16 = v15 + 40 * v14;
      uint64_t v17 = [v122 functionForKey:*(void *)(v16 + 24)];
      long long v18 = DEVICEOBJECT(v17);

      uint64_t v19 = *(void *)(v16 + 32);
      id v162 = 0;
      id v20 = [v18 newArgumentEncoderWithBufferIndex:v19 reflection:&v162];
      id v21 = v162;
      id v22 = v162;
      long long v160 = 0u;
      long long v161 = 0u;
      long long v158 = 0u;
      long long v159 = 0u;
      long long v156 = 0u;
      long long v154 = 0u;
      long long v155 = 0u;
      long long v152 = 0u;
      long long v153 = 0u;
      long long v150 = 0u;
      long long v151 = 0u;
      long long v157 = 0x38uLL;
      TranslateGTMTLArgument(0, v22, &v150, 0);
      uint64_t v23 = 0;
      int64x2_t v24 = 0uLL;
      do
      {
        int64x2_t v24 = vaddq_s64((int64x2_t)vandq_s8((int8x16_t)vaddq_s64(*(int64x2_t *)((char *)&v150 + v23), v135), v133), v24);
        v23 += 16;
      }
      while (v23 != 192);
      uint64_t v25 = (char *)apr_palloc(p, vaddvq_s64(v24));
      for (uint64_t i = 0; i != 192; i += 8)
      {
        if (((*(void *)((char *)&v150 + i) + 7) & 0xFFFFFFFFFFFFFFF8) != 0) {
          uint64_t v27 = v25;
        }
        else {
          uint64_t v27 = 0;
        }
        v25 += (*(void *)((char *)&v150 + i) + 7) & 0xFFFFFFFFFFFFFFF8;
        *(void *)((char *)&v150 + i) = v27;
      }
      uint64_t v28 = v157;
      *(void *)&long long v157 = v157 + 56;
      TranslateGTMTLArgument(v28, v22, &v150, 1);
      if (*(unsigned __int8 *)(v28 + 16) > 1u) {
        goto LABEL_22;
      }
      id v29 = *(unsigned __int8 **)(v28 + 8);
      if (!v29) {
        goto LABEL_22;
      }
      int v30 = *v29;
      if (v30 == 1) {
        goto LABEL_23;
      }
      if (v30 == 60 && v29[22] == 1) {
        id v29 = (unsigned __int8 *)*((void *)v29 + 1);
      }
      else {
LABEL_22:
      }
        id v29 = 0;
LABEL_23:
      if (GTMTLStructType_requiresPatching((uint64_t)v29, v126))
      {
        unsigned int v31 = apr_array_push(arr);
        uint64_t v32 = (uint64_t)v31;
        *(_OWORD *)unsigned int v31 = *(_OWORD *)(v15 + 40 * v14);
        if (*(unsigned char *)(v28 + 16) || (long long v33 = *(unsigned char **)(v28 + 8)) == 0 || *v33 != 60) {
          long long v33 = 0;
        }
        *((void *)v31 + 2) = v33;
        objc_storeStrong((id *)v31 + 3, v20);
        objc_storeStrong((id *)(v32 + 32), v21);
        if ((dword_77313C & 0x40) == 0 && arr->nelts >= 2)
        {
          uint64_t v34 = 0;
          uint64_t v35 = 0;
          while (!DYMTLIABDecodingOp_isEqual((uint64_t)&arr->elts[v34], v32))
          {
            ++v35;
            v34 += 40;
            if (v35 >= arr->nelts - 1) {
              goto LABEL_37;
            }
          }
          int nelts = arr->nelts;
          if (nelts) {
            arr->int nelts = nelts - 1;
          }
        }
      }
LABEL_37:

      ++v14;
    }
    while (v14 < *(int *)(*(void *)(a2 + 104) + 12));
  }
  uint64_t v37 = arr;
  if (arr->nelts <= 0)
  {
    uint64_t v13 = 0;
  }
  else
  {
    unsigned int v38 = BYTE1(GT_SUPPORT_0) & 0x20;
    unsigned int v116 = (dword_77313C >> 22) & (v38 >> 5);
    if ((dword_77313C & 0x80) != 0)
    {
      uint64_t v40 = v120;
      uint64_t v39 = p;
      GTMTLIndirectResources_allResourcesByKey((uint64_t *)&v144, *(_DWORD ***)(*(void *)v120 + 40), *(void *)(*(void *)v120 + 80) + *(unsigned int *)(v120 + 22480), (dword_77313C >> 22) & (v38 >> 5), p);
      long long v152 = v146;
      long long v153 = v147;
      long long v154 = v148;
      *(void *)&long long v155 = v149;
      long long v150 = v144;
      long long v151 = v145;
    }
    else
    {
      uint64_t v39 = p;
      GTMTLIndirectResources_rehash((apr_hash_index_t *)&v144, a2 + 8, (dword_77313C >> 22) & (v38 >> 5), p);
      long long v152 = v146;
      long long v153 = v147;
      long long v154 = v148;
      *(void *)&long long v155 = v149;
      long long v150 = v144;
      long long v151 = v145;
      uint64_t v40 = v120;
    }
    *(void *)&long long v144 = v126;
    *((void *)&v144 + 1) = &v150;
    *(void *)&long long v145 = arr;
    uint64_t v41 = apr_array_make(v39, 8, 32);
    uint64_t v42 = *(void *)(v40 + 22496);
    id v131 = v41;
    *((void *)&v145 + 1) = v41;
    *(void *)&long long v146 = v42;
    id v118 = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:arr->nelts];
    id v115 = *(id *)(v40 + 24);
    uint64_t v43 = [*(id *)(v40 + 8) defaultCommandQueue];
    unint64_t v113 = InternalCommandBuffer(v43, @"AB_Patching");
    id v119 = v43;
    id v117 = InternalBlitCommandEncoder(v113, v43);
    [(id)g_activityLog enterArgumentBufferDownload];
    char v114 = 0;
    int v44 = 0;
    int v45 = arr->nelts;
    do
    {
      int v46 = v44;
      elts = v37->elts;
      uint64_t v48 = (v45 - v46);
      id v49 = v118;
      id v50 = v117;
      id v51 = *(id *)(v120 + 8);
      id v52 = *(id *)(v120 + 24);
      unint64_t v123 = v50;
      if ((int)v48 < 1)
      {
      }
      else
      {
        contexta = v52;
        uint64_t v136 = v51;
        char v53 = 0;
        int v127 = v46;
        id v54 = &elts[40 * v46];
        do
        {
          id v56 = +[NSNumber numberWithUnsignedLongLong:*(void *)v54];
          uint64_t v57 = [v49 objectForKeyedSubscript:v56];

          if (!v57)
          {
            uint64_t v58 = [v136 bufferForKey:*(void *)v54];
            if ([v58 storageMode])
            {
              id v59 = [v58 length];
              [contexta bufferWithLength:v59 alignment:[*((id *)v54 + 3) alignment]];
              uint64_t v60 = (GTMTLReplaySharedBufferRange *)objc_claimAutoreleasedReturnValue();
              unsigned int v61 = [(GTMTLReplaySharedBufferRange *)v60 heapBuffer];
              id v62 = [(GTMTLReplaySharedBufferRange *)v60 heapLocation];
              id v63 = [contexta blitCommandEncoder];
              [v63 copyFromBuffer:v58 sourceOffset:0 toBuffer:v61 destinationOffset:v62 size:v59];
              [v123 copyFromBuffer:v61 sourceOffset:v62 toBuffer:v58 destinationOffset:0 size:v59];

              char v53 = 1;
            }
            else
            {
              uint64_t v60 = [[GTMTLReplaySharedBufferRange alloc] initWithBuffer:v58];
            }
            char v64 = +[NSNumber numberWithUnsignedLongLong:*(void *)v54];
            [v49 setObject:v60 forKeyedSubscript:v64];
          }
          v54 += 40;
          --v48;
        }
        while (v48);

        int v46 = v127;
        uint64_t v37 = arr;
        if (v53)
        {
          [v115 commitCommandBuffer];
          char v114 = 1;
        }
      }
      [v119 finish];
      uint64_t v65 = v46;
      id v66 = v49;
      id contextb = v122;
      int v44 = v37->nelts;
      int v128 = v44;
      if (v116)
      {
        if (v44 > v46)
        {
          do
          {
            uint64_t v67 = v37->elts;
            uint64_t v68 = v65;
            uint64_t v69 = &v67[40 * v65];
            v131->int nelts = 0;
            uint64_t v70 = *((void *)v69 + 2);
            if (*(unsigned char *)(v70 + 22) == 1) {
              uint64_t v71 = *(void **)(v70 + 8);
            }
            else {
              uint64_t v71 = 0;
            }
            GTMTLStructType_fillArgumentIndicesRequiresPatching(v71, 0, 0, v131, v126);
            unint64_t v72 = *(unsigned int *)(*((void *)v69 + 2) + 16);
            unsigned int v73 = +[NSNumber numberWithUnsignedLongLong:*(void *)v69];
            unsigned int v74 = [v66 objectForKeyedSubscript:v73];

            uint64_t v75 = [v74 heapBuffer];
            uint64_t v76 = DEVICEOBJECT(v75);

            id v77 = [v74 heapLocation];
            id v78 = [v74 length];
            uint64_t v79 = *(void *)v69;
            unint64_t v80 = *(void *)&v67[40 * v68 + 8];
            if ((dword_77313C & 0x40) != 0)
            {
              uint64_t v87 = *(void **)&v67[40 * v68 + 32];
              *(void *)&long long v164 = *(void *)v69;
              *((void *)&v164 + 1) = v80;
              uint64_t v165 = 0;
              reencodeBufferDataTier2(&v144, contextb, v76, (uint64_t)v77 + v80, v76, (uint64_t)v77 + v80, &v164, v87);
            }
            else
            {
              unint64_t v81 = (unint64_t)v78;
              unint64_t v82 = v80 % v72;
              unint64_t v83 = v80 % v72 + v72;
              if (v83 <= (unint64_t)v78)
              {
                uint64_t v84 = (void **)&v67[40 * v68 + 32];
                do
                {
                  uint64_t v85 = (uint64_t)v77 + v82;
                  *(void *)&long long v164 = v79;
                  *((void *)&v164 + 1) = v82;
                  unint64_t v82 = v83;
                  uint64_t v86 = *v84;
                  uint64_t v165 = 0;
                  reencodeBufferDataTier2(&v144, contextb, v76, v85, v76, v85, &v164, v86);
                  unint64_t v83 = v82 + v72;
                }
                while (v82 + v72 <= v81);
              }
            }

            uint64_t v65 = v68 + 1;
            int v44 = v128;
            uint64_t v37 = arr;
          }
          while (v128 != v68 + 1);
        }
      }
      else if (v44 > v46)
      {
        uint64_t v125 = v66;
        do
        {
          unsigned int v89 = v37->elts;
          int v90 = &v89[40 * v65];
          v131->int nelts = 0;
          uint64_t v91 = *((void *)v90 + 2);
          id v124 = v88;
          if (*(unsigned char *)(v91 + 22) == 1) {
            uint64_t v92 = *(void **)(v91 + 8);
          }
          else {
            uint64_t v92 = 0;
          }
          GTMTLStructType_fillArgumentIndicesRequiresPatching(v92, 0, 0, v131, v126);
          uint64_t v130 = v65;
          id v93 = *(id *)&v89[40 * v65 + 24];
          unint64_t v94 = (unint64_t)[v93 encodedLength];
          unsigned int v95 = +[NSNumber numberWithUnsignedLongLong:*(void *)v90];
          uint64_t v134 = [v125 objectForKeyedSubscript:v95];

          uint64_t v96 = [v134 heapBuffer];
          uint64_t v97 = DEVICEOBJECT(v96);

          int64_t v98 = (char *)[v134 heapLocation];
          uint64_t v99 = (char *)[v134 length];
          uint64_t v138 = *(void *)v90;
          if ((dword_77313C & 0x40) != 0)
          {
            uint64_t v110 = *(void *)&v89[40 * v130 + 8];
            [v93 setArgumentBuffer:v97 offset:&v98[v110]];
            *(void *)&long long v164 = v138;
            *((void *)&v164 + 1) = v110;
            uint64_t v165 = 0;
            reencodeBufferData((uint64_t)&v144, contextb, v97, (uint64_t)&v98[v110], v93, &v164);
          }
          else
          {
            int v100 = v99;
            uint64_t v101 = [v97 device];
            unsigned __int8 v102 = [v101 supportsArgumentBuffersTier2];

            uint64_t v103 = [v93 layout];
            unsigned int v104 = [v103 hashValue];
            unsigned int v105 = [v103 hashOffset];
            unint64_t v106 = *(void *)&v89[40 * v130 + 8];
            unint64_t v107 = v106 % v94;
            uint64_t v108 = (char *)(v106 % v94 + v94);
            if (v108 <= v100)
            {
              unsigned int v132 = &v98[v105];
              do
              {
                unsigned int v109 = v108;
                if ((v102 & 1) != 0
                  || *(_DWORD *)&v132[v107 + (void)[objc_retainAutorelease(v97) contents]] == v104)
                {
                  [v93 setArgumentBuffer:v97 offset:&v98[v107]];
                  *(void *)&long long v164 = v138;
                  *((void *)&v164 + 1) = v107;
                  uint64_t v165 = 0;
                  reencodeBufferData((uint64_t)&v144, contextb, v97, (uint64_t)&v98[v107], v93, &v164);
                }
                uint64_t v108 = &v109[v94];
                unint64_t v107 = (unint64_t)v109;
              }
              while (&v109[v94] <= v100);
            }
          }
          [v93 setArgumentBuffer:0 offset:0];

          uint64_t v37 = arr;
          uint64_t v65 = v130 + 1;
          int v44 = v128;
          id v66 = v125;
        }
        while (v128 != v130 + 1);
      }

      int v45 = v37->nelts;
    }
    while (v44 < v45);
    [(id)g_activityLog leaveActivity];
    [v123 endEncoding];
    if (v114)
    {
      [(id)g_activityLog enterArgumentBufferUpload];
      [(id)g_activityLog logSharedCommandBuffer:v113];
      v142[0] = _NSConcreteStackBlock;
      v142[1] = 3221225472;
      v142[2] = __DYMTLIndirectArgumentBufferManager_processCommandBuffer_block_invoke;
      v142[3] = &unk_746210;
      id v143 = v66;
      [v113 addCompletedHandler:v142];
      GTMTLReplay_commitCommandBuffer(v113);

      [(id)g_activityLog leaveActivity];
    }

    uint64_t v13 = v114 & 1;
  }
  apr_pool_destroy(p);

  return v13;
}

void sub_250E74(_Unwind_Exception *a1)
{
}

BOOL GTMTLStructType_requiresPatching(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 16);
  if (v2)
  {
    uint64_t v4 = 0;
    uint64_t v5 = (unsigned __int8 *)(*(void *)(a1 + 8) + 24);
    BOOL v6 = 1;
    do
    {
      uint64_t v7 = *v5;
      if (v7 == 1)
      {
        if (GTMTLStructType_requiresPatching(*((void *)v5 - 2))) {
          return v6;
        }
      }
      else if (v7 == 2)
      {
        if (GTMTLArrayType_requiresPatching(*((void *)v5 - 2), a2)) {
          return v6;
        }
      }
      else if (GTMTLDataType_requiresPatching(v7, a2))
      {
        return v6;
      }
      BOOL v6 = ++v4 < v2;
      v5 += 32;
    }
    while (v2 != v4);
  }
  else
  {
    return 0;
  }
  return v6;
}

BOOL DYMTLIABDecodingOp_isEqual(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1 != *(void *)a2) {
    return 0;
  }
  id v4 = [*(id *)(a1 + 24) encodedLength];
  if (v4 != [*(id *)(a2 + 24) encodedLength]) {
    return 0;
  }
  unint64_t v5 = (unint64_t)[*(id *)(a1 + 24) alignment];
  if ((id)v5 != [*(id *)(a2 + 24) alignment] || *(void *)(a1 + 8) % v5 != *(void *)(a2 + 8) % v5) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(unsigned char *)(v6 + 22) == 1) {
    uint64_t v7 = *(void *)(v6 + 8);
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v9 = *(void *)(a2 + 16);
  if (*(unsigned char *)(v9 + 22) == 1) {
    uint64_t v10 = *(void *)(v9 + 8);
  }
  else {
    uint64_t v10 = 0;
  }

  return GTMTLStructType_isEqual(v7, v10);
}

void *GTMTLStructType_fillArgumentIndicesRequiresPatching(void *result, uint64_t a2, uint64_t a3, apr_array_header_t *a4, unint64_t a5)
{
  if (*((_DWORD *)result + 4))
  {
    unint64_t v8 = result;
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    do
    {
      uint64_t v11 = v8[1];
      uint64_t v12 = v11 + v9;
      uint64_t v13 = *(unsigned __int16 *)(v11 + v9 + 22) + a2;
      uint64_t v14 = *(unsigned int *)(v11 + v9 + 16) + a3;
      int v15 = *(unsigned __int8 *)(v11 + v9 + 24);
      if (v15 == 2)
      {
        BOOL result = (void *)GTMTLArrayType_fillArgumentIndicesRequiresPatching(*(void *)(v12 + 8), *(unsigned __int16 *)(v11 + v9 + 22) + a2, v14, a4, a5);
      }
      else if (v15 == 1)
      {
        BOOL result = (void *)GTMTLStructType_fillArgumentIndicesRequiresPatching(*(void *)(v11 + v9 + 8), *(unsigned __int16 *)(v11 + v9 + 22) + a2, v14, a4, a5);
      }
      else
      {
        BOOL result = (void *)GTMTLDataType_requiresPatching(*(unsigned __int8 *)(v11 + v9 + 24), a5);
        if (result)
        {
          if (v15 == 60) {
            uint64_t v16 = *(void *)(v11 + v9 + 8);
          }
          else {
            uint64_t v16 = 0;
          }
          BOOL result = apr_array_push(a4);
          uint64_t v17 = result;
          *BOOL result = *(unsigned __int8 *)(v12 + 24);
          result[1] = v13;
          result[2] = *(unsigned int *)(v12 + 16);
          if (v16)
          {
            BOOL result = (void *)GTMTLPointerType_requiresPatching(v16, a5);
            if (result) {
              uint64_t v18 = v16;
            }
            else {
              uint64_t v18 = 0;
            }
          }
          else
          {
            uint64_t v18 = 0;
          }
          void v17[3] = v18;
        }
      }
      ++v10;
      v9 += 32;
    }
    while (v10 < *((unsigned int *)v8 + 4));
  }
  return result;
}

void reencodeBufferDataTier2(void *a1, void *a2, void *a3, uint64_t a4, void *a5, uint64_t a6, long long *a7, void *a8)
{
  id v86 = a2;
  id v14 = a3;
  id v85 = a5;
  id v82 = a8;
  uint64_t v15 = a1[3];
  if (*(int *)(v15 + 12) >= 1)
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v83 = a4;
    do
    {
      uint64_t v18 = (uint64_t *)(*(void *)(v15 + 24) + v16);
      uint64_t v19 = *v18;
      uint64_t v20 = v18[2];
      *((void *)a7 + 2) = v18[1];
      if (v19 > 79)
      {
        if (v19 > 116)
        {
          if ((unint64_t)(v19 - 117) >= 2) {
            goto LABEL_77;
          }
          id v31 = *(id *)((char *)[v14 contents] + v20 + a4);
          uint64_t v43 = a1[4];
          long long v87 = *a7;
          uint64_t v88 = *((void *)a7 + 2);
          entry = find_entry(v43, &v87, 0x18uLL, 0);
          if (*entry)
          {
            uint64_t v45 = *(void *)(*entry + 32);
            if (v45)
            {
              if (*(id *)(v45 + 24) == v31) {
                goto LABEL_77;
              }
            }
          }
          uint64_t v35 = *(void *)(a1[1] + 64);
        }
        else
        {
          if (v19 == 80)
          {
            id v31 = *(id *)((char *)[v14 contents] + v20 + a4);
            uint64_t v62 = a1[4];
            long long v87 = *a7;
            uint64_t v88 = *((void *)a7 + 2);
            id v63 = find_entry(v62, &v87, 0x18uLL, 0);
            if (*v63)
            {
              uint64_t v64 = *(void *)(*v63 + 32);
              if (v64)
              {
                if (*(id *)(v64 + 24) == v31) {
                  goto LABEL_77;
                }
              }
            }
            uint64_t v65 = *(void *)(a1[1] + 40);
            *(void *)&long long v87 = v31;
            id v66 = find_entry(v65, &v87, 8uLL, 0);
            if (!*v66) {
              goto LABEL_77;
            }
            uint64_t v67 = *(void *)(*v66 + 32);
            if (!v67) {
              goto LABEL_77;
            }
            uint64_t v42 = [v86 indirectCommandBufferForKey:*(void *)(v67 + 8)];
            goto LABEL_73;
          }
          if (v19 == 115)
          {
            id v31 = *(id *)((char *)[v14 contents] + v20 + a4);
            uint64_t v68 = a1[4];
            long long v87 = *a7;
            uint64_t v88 = *((void *)a7 + 2);
            uint64_t v69 = find_entry(v68, &v87, 0x18uLL, 0);
            if (*v69)
            {
              uint64_t v70 = *(void *)(*v69 + 32);
              if (v70)
              {
                if (*(id *)(v70 + 24) == v31) {
                  goto LABEL_77;
                }
              }
            }
            uint64_t v71 = *(void *)(a1[1] + 48);
            *(void *)&long long v87 = v31;
            unint64_t v72 = find_entry(v71, &v87, 8uLL, 0);
            if (!*v72) {
              goto LABEL_77;
            }
            uint64_t v73 = *(void *)(*v72 + 32);
            if (!v73) {
              goto LABEL_77;
            }
            uint64_t v42 = [v86 visibleFunctionTableForKey:*(void *)(v73 + 8)];
            goto LABEL_73;
          }
          if (v19 != 116) {
            goto LABEL_77;
          }
          id v31 = *(id *)((char *)[v14 contents] + v20 + a4);
          uint64_t v32 = a1[4];
          long long v87 = *a7;
          uint64_t v88 = *((void *)a7 + 2);
          long long v33 = find_entry(v32, &v87, 0x18uLL, 0);
          if (*v33)
          {
            uint64_t v34 = *(void *)(*v33 + 32);
            if (v34)
            {
              if (*(id *)(v34 + 24) == v31) {
                goto LABEL_77;
              }
            }
          }
          uint64_t v35 = *(void *)(a1[1] + 56);
        }
        *(void *)&long long v87 = v31;
        int v46 = find_entry(v35, &v87, 8uLL, 0);
        if (!*v46) {
          goto LABEL_77;
        }
        uint64_t v47 = *(void *)(*v46 + 32);
        if (!v47) {
          goto LABEL_77;
        }
        uint64_t v42 = [v86 intersectionFunctionTableForKey:*(void *)(v47 + 8)];
      }
      else if (v19 <= 59)
      {
        if (v19 == 58)
        {
          id v31 = *(id *)((char *)[v14 contents] + v20 + a4);
          uint64_t v74 = a1[4];
          long long v87 = *a7;
          uint64_t v88 = *((void *)a7 + 2);
          uint64_t v75 = find_entry(v74, &v87, 0x18uLL, 0);
          if (*v75)
          {
            uint64_t v76 = *(void *)(*v75 + 32);
            if (v76)
            {
              if (*(id *)(v76 + 24) == v31) {
                goto LABEL_77;
              }
            }
          }
          uint64_t v77 = *(void *)(a1[1] + 8);
          *(void *)&long long v87 = v31;
          id v78 = find_entry(v77, &v87, 8uLL, 0);
          if (!*v78) {
            goto LABEL_77;
          }
          uint64_t v79 = *(void *)(*v78 + 32);
          if (!v79) {
            goto LABEL_77;
          }
          uint64_t v42 = [v86 textureForKey:*(void *)(v79 + 8)];
        }
        else
        {
          if (v19 != 59) {
            goto LABEL_77;
          }
          id v31 = *(id *)((char *)[v14 contents] + v20 + a4);
          uint64_t v36 = a1[4];
          long long v87 = *a7;
          uint64_t v88 = *((void *)a7 + 2);
          uint64_t v37 = find_entry(v36, &v87, 0x18uLL, 0);
          if (*v37)
          {
            uint64_t v38 = *(void *)(*v37 + 32);
            if (v38)
            {
              if (*(id *)(v38 + 24) == v31) {
                goto LABEL_77;
              }
            }
          }
          uint64_t v39 = *(void *)(a1[1] + 16);
          *(void *)&long long v87 = v31;
          uint64_t v40 = find_entry(v39, &v87, 8uLL, 0);
          if (!*v40) {
            goto LABEL_77;
          }
          uint64_t v41 = *(void *)(*v40 + 32);
          if (!v41) {
            goto LABEL_77;
          }
          uint64_t v42 = [v86 samplerStateForKey:*(void *)(v41 + 8)];
        }
      }
      else
      {
        if (v19 == 60)
        {
          unint64_t v21 = *(void *)((char *)[v14 contents] + v20 + a4);
          uint64_t v48 = a1[4];
          long long v87 = *a7;
          uint64_t v88 = *((void *)a7 + 2);
          id v49 = find_entry(v48, &v87, 0x18uLL, 0);
          if (*v49)
          {
            uint64_t v50 = *(void *)(*v49 + 32);
            if (v50)
            {
              if (*(void *)(v50 + 24) == v21) {
                goto LABEL_77;
              }
            }
          }
          id v51 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*(void *)a1[1] + 24), *(int *)(*(void *)a1[1] + 12), v21);
          if (!v51 || !v51[2]) {
            goto LABEL_77;
          }
          unint64_t v52 = v21 - *v51;
          char v53 = [v86 bufferForKey:];
          id v29 = DEVICEOBJECT(v53);

          int v30 = (char *)[v29 gpuAddress] + v52;
          goto LABEL_46;
        }
        if (v19 != 78)
        {
          if (v19 != 79) {
            goto LABEL_77;
          }
          if ((GT_SUPPORT_0 & 0x10) == 0) {
            goto LABEL_77;
          }
          unint64_t v21 = *(void *)((char *)[v14 contents] + v20 + a4);
          uint64_t v22 = a1[4];
          long long v87 = *a7;
          uint64_t v88 = *((void *)a7 + 2);
          uint64_t v23 = find_entry(v22, &v87, 0x18uLL, 0);
          if (*v23)
          {
            uint64_t v24 = *(void *)(*v23 + 32);
            if (v24)
            {
              if (*(void *)(v24 + 24) == v21) {
                goto LABEL_77;
              }
            }
          }
          uint64_t v25 = *(void *)(a1[1] + 32);
          *(void *)&long long v87 = v21;
          uint64_t v26 = find_entry(v25, &v87, 8uLL, 0);
          if (!*v26) {
            goto LABEL_77;
          }
          uint64_t v27 = *(void *)(*v26 + 32);
          if (!v27 || !*(void *)(v27 + 8)) {
            goto LABEL_77;
          }
          uint64_t v28 = [v86 computePipelineStateForKey:];
          id v29 = DEVICEOBJECT(v28);

          int v30 = (char *)[v29 gpuResourceID];
LABEL_46:
          *(void *)((char *)[v85 contents] + v20 + a6) = v30;
          if ((char *)v21 != v30)
          {
            id v54 = (apr_pool_t **)a1[4];
            long long v87 = *a7;
            uint64_t v88 = *((void *)a7 + 2);
            uint64_t v55 = (uint64_t)v30;
LABEL_75:
            StoreArgumentIndexReencoding(v54, (uint64_t)&v87, v55);
            goto LABEL_76;
          }
          goto LABEL_76;
        }
        id v31 = *(id *)((char *)[v14 contents] + v20 + a4);
        uint64_t v56 = a1[4];
        long long v87 = *a7;
        uint64_t v88 = *((void *)a7 + 2);
        uint64_t v57 = find_entry(v56, &v87, 0x18uLL, 0);
        if (*v57)
        {
          uint64_t v58 = *(void *)(*v57 + 32);
          if (v58)
          {
            if (*(id *)(v58 + 24) == v31) {
              goto LABEL_77;
            }
          }
        }
        uint64_t v59 = *(void *)(a1[1] + 24);
        *(void *)&long long v87 = v31;
        uint64_t v60 = find_entry(v59, &v87, 8uLL, 0);
        if (!*v60) {
          goto LABEL_77;
        }
        uint64_t v61 = *(void *)(*v60 + 32);
        if (!v61 || !*(void *)(v61 + 8)) {
          goto LABEL_77;
        }
        uint64_t v42 = [v86 renderPipelineStateForKey:];
      }
LABEL_73:
      unint64_t v80 = v42;
      id v29 = DEVICEOBJECT(v42);

      id v81 = [v29 gpuResourceID];
      *(void *)((char *)[v85 contents] + v20 + a6) = v81;
      if (v31 != v81)
      {
        id v54 = (apr_pool_t **)a1[4];
        long long v87 = *a7;
        uint64_t v88 = *((void *)a7 + 2);
        uint64_t v55 = (uint64_t)v81;
        goto LABEL_75;
      }
LABEL_76:

      a4 = v83;
LABEL_77:
      ++v17;
      uint64_t v15 = a1[3];
      v16 += 32;
    }
    while (v17 < *(int *)(v15 + 12));
  }
}

void reencodeBufferData(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5, long long *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v98 = a5;
  uint64_t v99 = [v98 layout];
  uint64_t v13 = *(void *)(a1 + 24);
  if (*(int *)(v13 + 12) >= 1)
  {
    uint64_t v14 = 0;
    id v96 = v11;
    id v97 = v12;
    uint64_t v95 = a4;
    do
    {
      uint64_t v15 = (uint64_t *)(*(void *)(v13 + 24) + 32 * v14);
      uint64_t v16 = *v15;
      uint64_t v17 = v15[1];
      uint64_t v18 = v15[3];
      *((void *)a6 + 2) = v17;
      if (v16 > 78)
      {
        switch(v16)
        {
          case 's':
            id v19 = [v99 uniqueIdentifierForVisibleFunctionTableAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
            uint64_t v28 = *(void *)(a1 + 32);
            long long v100 = *a6;
            uint64_t v101 = *((void *)a6 + 2);
            entry = find_entry(v28, &v100, 0x18uLL, 0);
            if (!*entry || (uint64_t v30 = *(void *)(*entry + 32)) == 0 || *(id *)(v30 + 24) != v19)
            {
              uint64_t v31 = *(void *)(*(void *)(a1 + 8) + 48);
              *(void *)&long long v100 = v19;
              uint64_t v32 = find_entry(v31, &v100, 8uLL, 0);
              if (*v32)
              {
                uint64_t v33 = *(void *)(*v32 + 32);
                if (v33)
                {
                  uint64_t v34 = [v11 visibleFunctionTableForKey:*(void *)(v33 + 8)];
                  uint64_t v27 = DEVICEOBJECT(v34);

                  [v98 setVisibleFunctionTable:v27 atIndex:v17];
                  goto LABEL_75;
                }
              }
            }
            goto LABEL_78;
          case 't':
            id v19 = [v99 uniqueIdentifierForIntersectionFunctionTableAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
            uint64_t v70 = *(void *)(a1 + 32);
            long long v100 = *a6;
            uint64_t v101 = *((void *)a6 + 2);
            uint64_t v71 = find_entry(v70, &v100, 0x18uLL, 0);
            if (!*v71 || (uint64_t v72 = *(void *)(*v71 + 32)) == 0 || *(id *)(v72 + 24) != v19)
            {
              uint64_t v73 = *(void *)(*(void *)(a1 + 8) + 56);
              *(void *)&long long v100 = v19;
              uint64_t v74 = find_entry(v73, &v100, 8uLL, 0);
              if (*v74)
              {
                uint64_t v75 = *(void *)(*v74 + 32);
                if (v75)
                {
                  uint64_t v76 = [v11 intersectionFunctionTableForKey:*(void *)(v75 + 8)];
                  uint64_t v27 = DEVICEOBJECT(v76);

                  [v98 setIntersectionFunctionTable:v27 atIndex:v17];
                  goto LABEL_75;
                }
              }
            }
            goto LABEL_78;
          case 'u':
            id v77 = [v99 uniqueIdentifierForPrimitiveAccelerationStructureAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
            goto LABEL_63;
          case 'v':
            id v77 = [v99 uniqueIdentifierForInstanceAccelerationStructureAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
LABEL_63:
            id v19 = v77;
            uint64_t v78 = *(void *)(a1 + 32);
            long long v100 = *a6;
            uint64_t v101 = *((void *)a6 + 2);
            uint64_t v79 = find_entry(v78, &v100, 0x18uLL, 0);
            if (*v79)
            {
              uint64_t v80 = *(void *)(*v79 + 32);
              if (v80)
              {
                if (*(id *)(v80 + 24) == v19) {
                  goto LABEL_78;
                }
              }
            }
            uint64_t v81 = *(void *)(*(void *)(a1 + 8) + 64);
            *(void *)&long long v100 = v19;
            id v82 = find_entry(v81, &v100, 8uLL, 0);
            if (!*v82) {
              goto LABEL_78;
            }
            uint64_t v83 = *(void *)(*v82 + 32);
            if (!v83) {
              goto LABEL_78;
            }
            uint64_t v84 = [v11 intersectionFunctionTableForKey:*(void *)(v83 + 8)];
            uint64_t v27 = DEVICEOBJECT(v84);

            [v98 setAccelerationStructure:v27 atIndex:v17];
            goto LABEL_75;
          default:
            if (v16 == 79)
            {
              if ((GT_SUPPORT_0 & 0x10) != 0)
              {
                id v19 = [v99 uniqueIdentifierForComputePipelineAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
                uint64_t v85 = *(void *)(a1 + 32);
                long long v100 = *a6;
                uint64_t v101 = *((void *)a6 + 2);
                id v86 = find_entry(v85, &v100, 0x18uLL, 0);
                if (!*v86 || (uint64_t v87 = *(void *)(*v86 + 32)) == 0 || *(id *)(v87 + 24) != v19)
                {
                  uint64_t v88 = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier(*(void *)(*(void *)(a1 + 8) + 32), (uint64_t)v19);
                  if (v88)
                  {
                    unsigned int v89 = [v11 computePipelineStateForKey:v88];
                    uint64_t v27 = DEVICEOBJECT(v89);

                    [v98 setComputePipelineState:v27 atIndex:v17];
                    goto LABEL_75;
                  }
                }
              }
            }
            else if (v16 == 80)
            {
              id v19 = [v99 uniqueIdentifierForIndirectCommandBufferAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
              uint64_t v40 = *(void *)(a1 + 32);
              long long v100 = *a6;
              uint64_t v101 = *((void *)a6 + 2);
              uint64_t v41 = find_entry(v40, &v100, 0x18uLL, 0);
              if (!*v41 || (uint64_t v42 = *(void *)(*v41 + 32)) == 0 || *(id *)(v42 + 24) != v19)
              {
                uint64_t v43 = *(void *)(*(void *)(a1 + 8) + 40);
                *(void *)&long long v100 = v19;
                int v44 = find_entry(v43, &v100, 8uLL, 0);
                if (*v44)
                {
                  uint64_t v45 = *(void *)(*v44 + 32);
                  if (v45)
                  {
                    int v46 = [v11 indirectCommandBufferForKey:*(void *)(v45 + 8)];
                    uint64_t v27 = DEVICEOBJECT(v46);

                    [v98 setIndirectCommandBuffer:v27 atIndex:v17];
                    goto LABEL_75;
                  }
                }
              }
            }
            break;
        }
        goto LABEL_78;
      }
      if (v16 > 59)
      {
        if (v16 == 60)
        {
          id v54 = (char *)[v99 virtualAddressForBufferAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
          uint64_t v55 = *(void *)(a1 + 32);
          long long v100 = *a6;
          uint64_t v101 = *((void *)a6 + 2);
          uint64_t v56 = find_entry(v55, &v100, 0x18uLL, 0);
          if (*v56)
          {
            uint64_t v57 = *(void *)(*v56 + 32);
            if (v57)
            {
              if (*(char **)(v57 + 24) == v54) {
                goto LABEL_78;
              }
            }
          }
          uint64_t v58 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(**(void **)(a1 + 8) + 24), *(int *)(**(void **)(a1 + 8) + 12), (unint64_t)v54);
          if (!v58) {
            goto LABEL_78;
          }
          uint64_t v59 = v58[2];
          if (!v59) {
            goto LABEL_78;
          }
          uint64_t v60 = &v54[-*v58];
          uint64_t v61 = [v11 bufferForKey:v59];
          uint64_t v27 = DEVICEOBJECT(v61);

          [v98 setBuffer:v27 offset:v60 atIndex:v17];
          uint64_t v62 = &v60[(void)[v27 gpuAddress]];
          if (v62 != v54)
          {
            id v63 = *(apr_pool_t ***)(a1 + 32);
            long long v100 = *a6;
            uint64_t v101 = *((void *)a6 + 2);
            StoreArgumentIndexReencoding(v63, (uint64_t)&v100, (uint64_t)v62);
          }
          id v11 = v96;
          if (!v18) {
            goto LABEL_80;
          }
          if ((GT_SUPPORT_0 & 0x2000) == 0) {
            goto LABEL_80;
          }
          uint64_t v64 = apr_array_push(*(apr_array_header_t **)(a1 + 16));
          *uint64_t v64 = v59;
          v64[1] = v60;
          v64[2] = v18;
          id v65 = [v98 newArgumentEncoderForBufferAtIndex:v17];
          id v66 = (void *)v64[3];
          v64[3] = v65;

          uint64_t v67 = *(void *)(a1 + 16);
          if (*(int *)(v67 + 12) >= 2)
          {
            uint64_t v68 = 0;
            uint64_t v69 = 0;
            a4 = v95;
            while (!DYMTLIABDecodingOp_isEqual(*(void *)(v67 + 24) + v68, (uint64_t)v64))
            {
              ++v69;
              uint64_t v67 = *(void *)(a1 + 16);
              v68 += 40;
              if (v69 >= *(int *)(v67 + 12) - 1)
              {
                id v11 = v96;
                goto LABEL_77;
              }
            }
            uint64_t v93 = *(void *)(a1 + 16);
            id v11 = v96;
            if (v93)
            {
              int v94 = *(_DWORD *)(v93 + 12);
              if (v94) {
                *(_DWORD *)(v93 + 12) = v94 - 1;
              }
            }
          }
          else
          {
LABEL_80:
            a4 = v95;
          }
          goto LABEL_77;
        }
        if (v16 != 78) {
          goto LABEL_78;
        }
        id v19 = [v99 uniqueIdentifierForRenderPipelineAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
        uint64_t v35 = *(void *)(a1 + 32);
        long long v100 = *a6;
        uint64_t v101 = *((void *)a6 + 2);
        uint64_t v36 = find_entry(v35, &v100, 0x18uLL, 0);
        if (*v36)
        {
          uint64_t v37 = *(void *)(*v36 + 32);
          if (v37)
          {
            if (*(id *)(v37 + 24) == v19) {
              goto LABEL_78;
            }
          }
        }
        uint64_t v38 = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier(*(void *)(*(void *)(a1 + 8) + 24), (uint64_t)v19);
        if (!v38) {
          goto LABEL_78;
        }
        uint64_t v39 = [v11 renderPipelineStateForKey:v38];
        uint64_t v27 = DEVICEOBJECT(v39);

        [v98 setRenderPipelineState:v27 atIndex:v17];
      }
      else if (v16 == 58)
      {
        id v19 = [v99 uniqueIdentifierForTextureAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
        uint64_t v47 = *(void *)(a1 + 32);
        long long v100 = *a6;
        uint64_t v101 = *((void *)a6 + 2);
        uint64_t v48 = find_entry(v47, &v100, 0x18uLL, 0);
        if (*v48)
        {
          uint64_t v49 = *(void *)(*v48 + 32);
          if (v49)
          {
            if (*(id *)(v49 + 24) == v19) {
              goto LABEL_78;
            }
          }
        }
        uint64_t v50 = *(void *)(*(void *)(a1 + 8) + 8);
        *(void *)&long long v100 = v19;
        id v51 = find_entry(v50, &v100, 8uLL, 0);
        if (!*v51) {
          goto LABEL_78;
        }
        uint64_t v52 = *(void *)(*v51 + 32);
        if (!v52) {
          goto LABEL_78;
        }
        char v53 = [v11 textureForKey:*(void *)(v52 + 8)];
        uint64_t v27 = DEVICEOBJECT(v53);

        [v98 setTexture:v27 atIndex:v17];
      }
      else
      {
        if (v16 != 59) {
          goto LABEL_78;
        }
        id v19 = [v99 uniqueIdentifierForSamplerAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
        uint64_t v20 = *(void *)(a1 + 32);
        long long v100 = *a6;
        uint64_t v101 = *((void *)a6 + 2);
        unint64_t v21 = find_entry(v20, &v100, 0x18uLL, 0);
        if (*v21)
        {
          uint64_t v22 = *(void *)(*v21 + 32);
          if (v22)
          {
            if (*(id *)(v22 + 24) == v19) {
              goto LABEL_78;
            }
          }
        }
        uint64_t v23 = *(void *)(*(void *)(a1 + 8) + 16);
        *(void *)&long long v100 = v19;
        uint64_t v24 = find_entry(v23, &v100, 8uLL, 0);
        if (!*v24) {
          goto LABEL_78;
        }
        uint64_t v25 = *(void *)(*v24 + 32);
        if (!v25) {
          goto LABEL_78;
        }
        uint64_t v26 = [v11 samplerStateForKey:*(void *)(v25 + 8)];
        uint64_t v27 = DEVICEOBJECT(v26);

        [v98 setSamplerState:v27 atIndex:v17];
      }
LABEL_75:
      id v90 = [v27 uniqueIdentifier];
      if (v19 != v90)
      {
        uint64_t v91 = (uint64_t)v90;
        uint64_t v92 = *(apr_pool_t ***)(a1 + 32);
        long long v100 = *a6;
        uint64_t v101 = *((void *)a6 + 2);
        StoreArgumentIndexReencoding(v92, (uint64_t)&v100, v91);
      }
LABEL_77:

      id v12 = v97;
LABEL_78:
      ++v14;
      uint64_t v13 = *(void *)(a1 + 24);
    }
    while (v14 < *(int *)(v13 + 12));
  }
}

void StoreArgumentIndexReencoding(apr_pool_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *find_entry((uint64_t)a1, (unsigned char *)a2, 0x18uLL, 0);
  if (!v6 || (uint64_t v7 = *(void **)(v6 + 32)) == 0)
  {
    uint64_t v7 = apr_palloc(*a1, 0x20uLL);
    uint64_t v8 = *(void *)(a2 + 16);
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
    v7[2] = v8;
    apr_hash_set((apr_hash_t *)a1, v7, 24, v7);
  }
  v7[3] = a3;
}

uint64_t GTMTLArrayType_fillArgumentIndicesRequiresPatching(uint64_t result, uint64_t a2, uint64_t a3, apr_array_header_t *a4, unint64_t a5)
{
  uint64_t v9 = result;
  uint64_t v10 = *(unsigned __int8 *)(result + 24);
  int v11 = *(unsigned __int16 *)(result + 20);
  uint64_t v12 = *(unsigned __int16 *)(result + 22);
  if (v10 == 1)
  {
    if (*(_WORD *)(result + 20))
    {
      do
      {
        if (*(unsigned char *)(v9 + 24) == 1) {
          uint64_t v14 = *(void *)(v9 + 8);
        }
        else {
          uint64_t v14 = 0;
        }
        BOOL result = GTMTLStructType_fillArgumentIndicesRequiresPatching(v14, a2, a3, a4, a5);
        a2 += v12;
        a3 += *(unsigned int *)(v9 + 16);
        --v11;
      }
      while (v11);
    }
  }
  else if (v10 == 2)
  {
    if (*(_WORD *)(result + 20))
    {
      do
      {
        if (*(unsigned char *)(v9 + 24) == 2) {
          uint64_t v13 = *(void *)(v9 + 8);
        }
        else {
          uint64_t v13 = 0;
        }
        BOOL result = GTMTLArrayType_fillArgumentIndicesRequiresPatching(v13, a2, a3, a4, a5);
        a2 += v12;
        a3 += *(unsigned int *)(v9 + 16);
        --v11;
      }
      while (v11);
    }
  }
  else
  {
    BOOL result = GTMTLDataType_requiresPatching(*(unsigned __int8 *)(result + 24), a5);
    if (result)
    {
      if (v10 == 60 && (uint64_t v15 = *(void *)(v9 + 8)) != 0)
      {
        BOOL result = GTMTLPointerType_requiresPatching(*(void *)(v9 + 8), a5);
        uint64_t v16 = result ? v15 : 0;
      }
      else
      {
        uint64_t v16 = 0;
      }
      for (; v11; --v11)
      {
        BOOL result = (uint64_t)apr_array_push(a4);
        *(void *)BOOL result = v10;
        *(void *)(result + 8) = a2;
        *(void *)(result + 16) = a3;
        *(void *)(result + 24) = v16;
        a2 += v12;
        a3 += *(unsigned int *)(v9 + 16);
      }
    }
  }
  return result;
}

uint64_t GTMTLDataType_requiresPatching(uint64_t a1, unint64_t a2)
{
  if (a1 > 79)
  {
    switch(a1)
    {
      case 's':
        uint64_t result = (a2 >> 6) & 1;
        break;
      case 't':
        uint64_t result = (a2 >> 7) & 1;
        break;
      case 'u':
      case 'v':
        uint64_t result = (a2 >> 8) & 1;
        break;
      default:
        if (a1 == 80) {
          uint64_t result = (a2 >> 5) & 1;
        }
        else {
          uint64_t result = 0;
        }
        break;
    }
  }
  else
  {
    unsigned int v2 = a2 & 1;
    uint64_t v3 = (a2 >> 1) & 1;
    uint64_t v4 = (a2 >> 3) & 1;
    if (a1 != 60) {
      LODWORD(v4) = 0;
    }
    if (a1 != 59) {
      LODWORD(v3) = v4;
    }
    if (a1 != 58) {
      unsigned int v2 = v3;
    }
    if (a1 <= 77) {
      return v2;
    }
    else {
      return (a2 >> 4) & 1;
    }
  }
  return result;
}

uint64_t GTMTLPointerType_requiresPatching(uint64_t a1, unint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 22);
  if (v2 == 2) {
    return GTMTLArrayType_requiresPatching(*(void *)(a1 + 8), a2);
  }
  if (v2 == 1) {
    return GTMTLStructType_requiresPatching(*(void *)(a1 + 8), a2);
  }
  return GTMTLDataType_requiresPatching(*(unsigned __int8 *)(a1 + 22), a2);
}

uint64_t GTMTLArrayType_requiresPatching(uint64_t a1, unint64_t a2)
{
  while (1)
  {
    int v2 = *(unsigned __int8 *)(a1 + 24);
    if (v2 != 2) {
      break;
    }
    a1 = *(void *)(a1 + 8);
  }
  if (v2 == 1) {
    return GTMTLStructType_requiresPatching(*(void *)(a1 + 8));
  }
  else {
    return GTMTLDataType_requiresPatching(*(unsigned __int8 *)(a1 + 24), a2);
  }
}

BOOL GTMTLStructType_isEqual(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 16);
  if (v2 == *(_DWORD *)(a2 + 16))
  {
    if (v2)
    {
      uint64_t v3 = 0;
      BOOL v4 = 0;
      uint64_t v5 = *(void *)(a1 + 8);
      uint64_t v6 = *(void *)(a2 + 8);
      do
      {
        uint64_t v7 = v5 + 32 * v3;
        uint64_t v8 = v6 + 32 * v3;
        if (*(_DWORD *)(v7 + 16) != *(_DWORD *)(v8 + 16)) {
          break;
        }
        int v9 = *(unsigned __int8 *)(v7 + 24);
        if (v9 != *(unsigned __int8 *)(v8 + 24)) {
          break;
        }
        if (v9 == 1)
        {
          if (!GTMTLStructType_isEqual(*(void *)(v5 + 32 * v3 + 8), *(void *)(v6 + 32 * v3 + 8))) {
            return v4;
          }
        }
        else if (v9 == 2)
        {
          uint64_t v10 = *(void *)(v5 + 32 * v3 + 8);
          uint64_t v11 = v6 + 32 * v3;
          while (1)
          {
            uint64_t v11 = *(void *)(v11 + 8);
            if (*(unsigned __int16 *)(v10 + 20) != *(unsigned __int16 *)(v11 + 20)) {
              return v4;
            }
            int v12 = *(unsigned __int8 *)(v10 + 24);
            if (v12 != *(unsigned __int8 *)(v11 + 24)) {
              return v4;
            }
            if (v12 != 2)
            {
              if (v12 != 1 || (GTMTLStructType_isEqual(*(void *)(v10 + 8), *(void *)(v11 + 8)) & 1) != 0) {
                break;
              }
              return v4;
            }
            uint64_t v10 = *(void *)(v10 + 8);
          }
        }
        BOOL v4 = ++v3 >= v2;
      }
      while (v3 != v2);
    }
    else
    {
      return 1;
    }
  }
  else
  {
    return 0;
  }
  return v4;
}

uint64_t DYMTLIABDecodingOp_cleanup(uint64_t a1)
{
  if (*(int *)(a1 + 16) >= 1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = 24;
    do
    {
      uint64_t v4 = *(void *)(a1 + 24);
      uint64_t v5 = *(void **)(v4 + v3);
      *(void *)(v4 + v3) = 0;

      ++v2;
      v3 += 40;
    }
    while (v2 < *(int *)(a1 + 16));
  }
  return 0;
}

char *DYMTLIndirectArgumentBufferManager_decodeArgumentBuffer()
{
  uint64_t v0 = __chkstk_darwin();
  uint64_t v2 = v1;
  unint64_t v233 = v3;
  uint64_t v4 = (id *)v0;
  uint64_t v5 = (unsigned int *)(v0 + 22480);
  id v225 = *(id *)(v0 + 8);
  uint64_t v6 = (uint64_t *)*v4;
  uint64_t v7 = *(void *)(v6[15] + 24)
     + (*GroupBuilder_getCommandBuffer(*(_DWORD *)(*((void *)*v4 + 14) + 12), *(void **)(*((void *)*v4 + 14) + 24), *v5) << 6);
  *(void *)__dst = *((void *)GTTraceFunc_argumentBytesWithMap((void *)v7, *(unsigned __int8 *)(v7 + 13), v6[2]) + 1);
  uint64_t v8 = *find_entry(v6[18], __dst, 8uLL, 0);
  BOOL v243 = v5;
  if (v8) {
    uint64_t v9 = *(void *)(v8 + 32);
  }
  else {
    uint64_t v9 = 0;
  }
  unint64_t v244 = v4;
  id v10 = v4[1];
  uint64_t v11 = apr_array_make(v2, *(_DWORD *)(*(void *)(v9 + 8) + 12), 24);
  *(void *)&long long v245 = v11;
  int v234 = apr_hash_make(v2);
  *((void *)&v245 + 1) = v234;
  *(void *)&long long v236 = apr_hash_make(v2);
  *((void *)&v236 + 1) = apr_hash_make(v2);
  long long v246 = v236;
  *(void *)&long long v237 = apr_hash_make(v2);
  *((void *)&v237 + 1) = apr_hash_make(v2);
  long long v247 = v237;
  *(void *)&long long v240 = apr_hash_make(v2);
  *((void *)&v240 + 1) = apr_hash_make(v2);
  long long v248 = v240;
  uint64_t v241 = apr_hash_make(v2);
  *(void *)&long long v249 = v241;
  *((void *)&v249 + 1) = apr_hash_make(v2);
  uint64_t v250 = 0;
  uint64_t v12 = *(void *)(v9 + 8);
  if (*(int *)(v12 + 12) >= 1)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    do
    {
      uint64_t v15 = (void *)(*(void *)(v12 + 24) + v13);
      uint64_t v16 = apr_array_push(v11);
      uint64_t v17 = [v10 bufferForKey:v15[2]];
      uint64_t v18 = DEVICEOBJECT(v17);

      *uint64_t v16 = [v18 gpuAddress];
      v16[1] = [v18 length];
      v16[2] = *v15;

      ++v14;
      uint64_t v12 = *(void *)(v9 + 8);
      v13 += 24;
    }
    while (v14 < *(int *)(v12 + 12));
  }
  qsort(v11->elts, v11->nelts, v11->elt_size, (int (__cdecl *)(const void *, const void *))GTMTLGPUAddressResource_compare);
  uint64_t v19 = *(void *)(v9 + 16);
  *(void *)(v19 + 24) = 0;
  *(void *)(v19 + 32) = 0;
  *(void *)(v19 + 16) = v19;
  *(_DWORD *)(v19 + 40) = 0;
  uint64_t v20 = apr_hash_next((apr_hash_index_t *)(v19 + 16));
  if (v20)
  {
    unint64_t v21 = v20;
    do
    {
      uint64_t v22 = *(void **)(*((void *)v21 + 1) + 32);
      uint64_t v23 = apr_palloc(v2, 0x20uLL);
      uint64_t v24 = [v10 textureForKey:v22[1]];
      uint64_t v25 = DEVICEOBJECT(v24);

      *uint64_t v23 = [v25 uniqueIdentifier];
      v23[1] = *v22;
      v23[2] = [v25 gpuResourceID];
      uint64_t v26 = v23 + 2;
      int v27 = *(unsigned __int8 *)(v9 + 88);
      if (v27 != 1) {
        uint64_t v26 = v23;
      }
      if (v27 == 2) {
        uint64_t v28 = v23 + 3;
      }
      else {
        uint64_t v28 = v26;
      }
      apr_hash_set(v234, v28, 8, v23);

      unint64_t v21 = apr_hash_next(v21);
    }
    while (v21);
  }
  uint64_t v29 = *(void *)(v9 + 24);
  *(void *)(v29 + 24) = 0;
  *(void *)(v29 + 32) = 0;
  *(void *)(v29 + 16) = v29;
  *(_DWORD *)(v29 + 40) = 0;
  uint64_t v30 = apr_hash_next((apr_hash_index_t *)(v29 + 16));
  if (v30)
  {
    uint64_t v31 = v30;
    do
    {
      uint64_t v32 = *(void **)(*((void *)v31 + 1) + 32);
      uint64_t v33 = apr_palloc(v2, 0x20uLL);
      uint64_t v34 = [v10 samplerStateForKey:v32[1]];
      uint64_t v35 = DEVICEOBJECT(v34);

      *uint64_t v33 = [v35 uniqueIdentifier];
      v33[1] = *v32;
      v33[2] = [v35 gpuResourceID];
      uint64_t v36 = v33 + 2;
      int v37 = *(unsigned __int8 *)(v9 + 88);
      if (v37 != 1) {
        uint64_t v36 = v33;
      }
      if (v37 == 2) {
        uint64_t v38 = v33 + 3;
      }
      else {
        uint64_t v38 = v36;
      }
      apr_hash_set((apr_hash_t *)v236, v38, 8, v33);

      uint64_t v31 = apr_hash_next(v31);
    }
    while (v31);
  }
  uint64_t v39 = *(void *)(v9 + 32);
  *(void *)(v39 + 24) = 0;
  *(void *)(v39 + 32) = 0;
  *(void *)(v39 + 16) = v39;
  *(_DWORD *)(v39 + 40) = 0;
  uint64_t v40 = apr_hash_next((apr_hash_index_t *)(v39 + 16));
  if (v40)
  {
    uint64_t v41 = v40;
    do
    {
      uint64_t v42 = *(void **)(*((void *)v41 + 1) + 32);
      uint64_t v43 = apr_palloc(v2, 0x20uLL);
      int v44 = [v10 renderPipelineStateForKey:v42[1]];
      uint64_t v45 = DEVICEOBJECT(v44);

      *uint64_t v43 = [v45 uniqueIdentifier];
      v43[1] = *v42;
      v43[2] = [v45 gpuResourceID];
      int v46 = v43 + 2;
      int v47 = *(unsigned __int8 *)(v9 + 88);
      if (v47 != 1) {
        int v46 = v43;
      }
      if (v47 == 2) {
        uint64_t v48 = v43 + 3;
      }
      else {
        uint64_t v48 = v46;
      }
      apr_hash_set(*((apr_hash_t **)&v236 + 1), v48, 8, v43);

      uint64_t v41 = apr_hash_next(v41);
    }
    while (v41);
  }
  uint64_t v49 = *(void *)(v9 + 40);
  *(void *)(v49 + 24) = 0;
  *(void *)(v49 + 32) = 0;
  *(void *)(v49 + 16) = v49;
  *(_DWORD *)(v49 + 40) = 0;
  uint64_t v50 = apr_hash_next((apr_hash_index_t *)(v49 + 16));
  if (v50)
  {
    id v51 = v50;
    do
    {
      uint64_t v52 = *(void **)(*((void *)v51 + 1) + 32);
      char v53 = apr_palloc(v2, 0x20uLL);
      id v54 = [v10 computePipelineStateForKey:v52[1]];
      uint64_t v55 = DEVICEOBJECT(v54);

      *char v53 = [v55 uniqueIdentifier];
      v53[1] = *v52;
      v53[2] = [v55 gpuResourceID];
      uint64_t v56 = v53 + 2;
      int v57 = *(unsigned __int8 *)(v9 + 88);
      if (v57 != 1) {
        uint64_t v56 = v53;
      }
      if (v57 == 2) {
        uint64_t v58 = v53 + 3;
      }
      else {
        uint64_t v58 = v56;
      }
      apr_hash_set((apr_hash_t *)v237, v58, 8, v53);

      id v51 = apr_hash_next(v51);
    }
    while (v51);
  }
  uint64_t v59 = *(void *)(v9 + 48);
  *(void *)(v59 + 24) = 0;
  *(void *)(v59 + 32) = 0;
  *(void *)(v59 + 16) = v59;
  *(_DWORD *)(v59 + 40) = 0;
  uint64_t v60 = apr_hash_next((apr_hash_index_t *)(v59 + 16));
  if (v60)
  {
    uint64_t v61 = v60;
    do
    {
      uint64_t v62 = *(void **)(*((void *)v61 + 1) + 32);
      id v63 = apr_palloc(v2, 0x20uLL);
      uint64_t v64 = [v10 indirectCommandBufferForKey:v62[1]];
      id v65 = DEVICEOBJECT(v64);

      *id v63 = [v65 uniqueIdentifier];
      v63[1] = *v62;
      v63[2] = [v65 gpuResourceID];
      id v66 = v63 + 2;
      int v67 = *(unsigned __int8 *)(v9 + 88);
      if (v67 != 1) {
        id v66 = v63;
      }
      if (v67 == 2) {
        uint64_t v68 = v63 + 3;
      }
      else {
        uint64_t v68 = v66;
      }
      apr_hash_set(*((apr_hash_t **)&v237 + 1), v68, 8, v63);

      uint64_t v61 = apr_hash_next(v61);
    }
    while (v61);
  }
  uint64_t v69 = *(void *)(v9 + 56);
  *(void *)(v69 + 24) = 0;
  *(void *)(v69 + 32) = 0;
  *(void *)(v69 + 16) = v69;
  *(_DWORD *)(v69 + 40) = 0;
  uint64_t v70 = apr_hash_next((apr_hash_index_t *)(v69 + 16));
  if (v70)
  {
    uint64_t v71 = v70;
    do
    {
      uint64_t v72 = *(void **)(*((void *)v71 + 1) + 32);
      uint64_t v73 = apr_palloc(v2, 0x20uLL);
      uint64_t v74 = [v10 visibleFunctionTableForKey:v72[1]];
      uint64_t v75 = DEVICEOBJECT(v74);

      void *v73 = [v75 uniqueIdentifier];
      v73[1] = *v72;
      v73[2] = [v75 gpuResourceID];
      uint64_t v76 = v73 + 2;
      int v77 = *(unsigned __int8 *)(v9 + 88);
      if (v77 != 1) {
        uint64_t v76 = v73;
      }
      if (v77 == 2) {
        uint64_t v78 = v73 + 3;
      }
      else {
        uint64_t v78 = v76;
      }
      apr_hash_set((apr_hash_t *)v240, v78, 8, v73);

      uint64_t v71 = apr_hash_next(v71);
    }
    while (v71);
  }
  uint64_t v79 = *(void *)(v9 + 64);
  *(void *)(v79 + 24) = 0;
  *(void *)(v79 + 32) = 0;
  *(void *)(v79 + 16) = v79;
  *(_DWORD *)(v79 + 40) = 0;
  uint64_t v80 = apr_hash_next((apr_hash_index_t *)(v79 + 16));
  if (v80)
  {
    uint64_t v81 = v80;
    do
    {
      id v82 = *(void **)(*((void *)v81 + 1) + 32);
      uint64_t v83 = apr_palloc(v2, 0x20uLL);
      uint64_t v84 = [v10 intersectionFunctionTableForKey:v82[1]];
      uint64_t v85 = DEVICEOBJECT(v84);

      *uint64_t v83 = [v85 uniqueIdentifier];
      v83[1] = *v82;
      v83[2] = [v85 gpuResourceID];
      id v86 = v83 + 2;
      int v87 = *(unsigned __int8 *)(v9 + 88);
      if (v87 != 1) {
        id v86 = v83;
      }
      if (v87 == 2) {
        uint64_t v88 = v83 + 3;
      }
      else {
        uint64_t v88 = v86;
      }
      apr_hash_set(*((apr_hash_t **)&v240 + 1), v88, 8, v83);

      uint64_t v81 = apr_hash_next(v81);
    }
    while (v81);
  }
  uint64_t v89 = *(void *)(v9 + 72);
  *(void *)(v89 + 24) = 0;
  *(void *)(v89 + 32) = 0;
  *(void *)(v89 + 16) = v89;
  *(_DWORD *)(v89 + 40) = 0;
  id v90 = apr_hash_next((apr_hash_index_t *)(v89 + 16));
  if (v90)
  {
    uint64_t v91 = v90;
    do
    {
      uint64_t v92 = *(void **)(*((void *)v91 + 1) + 32);
      uint64_t v93 = apr_palloc(v2, 0x20uLL);
      int v94 = [v10 accelerationStructureForKey:v92[1]];
      uint64_t v95 = DEVICEOBJECT(v94);

      *uint64_t v93 = [v95 uniqueIdentifier];
      v93[1] = *v92;
      v93[2] = [v95 gpuResourceID];
      id v96 = v93 + 2;
      int v97 = *(unsigned __int8 *)(v9 + 88);
      if (v97 != 1) {
        id v96 = v93;
      }
      if (v97 == 2) {
        id v98 = v93 + 3;
      }
      else {
        id v98 = v96;
      }
      apr_hash_set(v241, v98, 8, v93);

      uint64_t v91 = apr_hash_next(v91);
    }
    while (v91);
  }

  GTMTLIndirectResources_rehash((apr_hash_index_t *)__dst, (uint64_t)&v245, 1, v2);
  long long v247 = *(_OWORD *)&__dst[32];
  long long v248 = *(_OWORD *)&__dst[48];
  long long v249 = *(_OWORD *)&__dst[64];
  uint64_t v250 = *(void *)&__dst[80];
  long long v245 = *(_OWORD *)__dst;
  long long v246 = *(_OWORD *)&__dst[16];
  id v99 = *v244;
  if (*v243) {
    uint64_t v100 = *(void *)(*((void *)v99 + 15) + 24) + ((unint64_t)(*v243 - 1) << 6);
  }
  else {
    uint64_t v100 = 0;
  }
  *(_OWORD *)int p = 0u;
  memset(v256, 0, sizeof(v256));
  unsigned int v101 = *(_DWORD *)(v100 + 8);
  long long v255 = 0u;
  long long v254 = 0u;
  if (v101 >> 2 == 1073737833)
  {
    p[1] = *(apr_pool_t **)v244[19];
    GTMTLSMContext_indirectCommandBufferResources((uint64_t)&v256[7] + 8, *((_DWORD ***)v99 + 5), *(void *)v100, p[1]);
    GetExecuteCommandsInBufferArgs((uint64_t)&v254, v100, *((void *)v99 + 2));
    uint64_t Object = GTMTLSMContext_getObject(**((void **)v99 + 5), v254, *(void *)v100);
    GTMTLCreateIndirectCommandEncoder((uint64_t)v256 + 8, Object[13]);
    uint64_t v103 = (apr_pool_t *)(*((void *)&v255 + 1) + *(void *)&v256[7] * v243[1]);
    p[0] = v103;
  }
  else
  {
    uint64_t v103 = 0;
  }
  int v104 = *((_DWORD *)v244 + 2828);
  if (v104 == 28)
  {
    memcpy(__dst, v244 + 1421, 0x8D0uLL);
    if (*(_DWORD *)(v100 + 8) >> 2 == 1073737833)
    {
      GTMTLSMComputeCommandEncoder_loadIndirectCommand((uint64_t)__dst, (void *)v256 + 1, (uint64_t)v103, (uint64_t *)&v256[7] + 1);
      apr_pool_clear(p[1]);
    }
    unint64_t v113 = GTMTLSMContext_getObject(**((void **)v99 + 5), *(uint64_t *)&__dst[8], *(void *)v100);
    uint64_t v114 = v113[8];
    memset(v251, 0, 512);
    GTMTLSMComputePipelineState_computePipelineDescriptor(*((uint64_t **)v99 + 5), (uint64_t)v113, v251, v2);
    unint64_t v115 = v233 + 1346;
    if (*(_WORD *)(v114 + 94))
    {
      uint64_t v116 = 0;
      uint64_t v117 = *(void *)(v114 + 32);
      id v118 = (unsigned __int8 *)(v117 + 18);
      while (v115 != *v118 || *(v118 - 2) > 1u)
      {
        v118 += 56;
        if (*(unsigned __int16 *)(v114 + 94) == ++v116) {
          goto LABEL_101;
        }
      }
      uint64_t v136 = v117 + 56 * v116;
    }
    else
    {
LABEL_101:
      uint64_t v136 = 0;
    }
    uint64_t v120 = v252;
    unsigned int v129 = &__dst[8 * v115];
    uint64_t v121 = *((void *)v129 + 4);
    unint64_t v122 = *((void *)v129 + 35);
    goto LABEL_150;
  }
  if (v104 != 70)
  {
    uint64_t v136 = 0;
    uint64_t v120 = 0;
    uint64_t v121 = 0;
    unint64_t v122 = 0;
    goto LABEL_150;
  }
  memcpy(__dst, v244 + 1421, sizeof(__dst));
  if (*(_DWORD *)(v100 + 8) >> 2 == 1073737833)
  {
    GTMTLSMRenderCommandEncoder_loadIndirectCommand((uint64_t)__dst, (void *)v256 + 1, (uint64_t)v103, (uint64_t *)&v256[7] + 1);
    apr_pool_clear(p[1]);
  }
  unsigned int v105 = GTMTLSMContext_getObject(**((void **)v99 + 5), *(uint64_t *)&__dst[8544], *(void *)v100);
  uint64_t v106 = v105[7];
  if (v233 < 0xFFFFFFFFFFFFFBBELL)
  {
    if (v233 < 0xFFFFFFFFFFFFFB7ELL)
    {
      if (v233 < 0xFFFFFFFFFFFFFB3ELL)
      {
        if (v233 >= 0xFFFFFFFFFFFFFAFELL)
        {
          unint64_t v141 = v233 + 1282;
          uint64_t v142 = *(unsigned __int16 *)(v106 + 204);
          if (*(_WORD *)(v106 + 204))
          {
            uint64_t v143 = 0;
            uint64_t v144 = *(void *)(v106 + 40);
            long long v145 = (unsigned __int8 *)(v144 + 18);
            while (v141 != *v145 || *(v145 - 2) > 1u)
            {
              v145 += 56;
              if (v142 == ++v143) {
                goto LABEL_134;
              }
            }
            uint64_t v136 = v144 + 56 * v143;
          }
          else
          {
LABEL_134:
            uint64_t v136 = 0;
          }
          unsigned int v137 = (uint64_t *)(v105[9] + 368);
          long long v156 = &__dst[8 * v141];
          id v139 = (uint64_t *)(v156 + 3584);
          uint64_t v140 = (unint64_t *)(v156 + 3832);
          goto LABEL_149;
        }
        unint64_t v148 = v233 + 1346;
        uint64_t v149 = *(unsigned __int16 *)(v106 + 202);
        if (*(_WORD *)(v106 + 202))
        {
          uint64_t v150 = 0;
          uint64_t v151 = *(void *)(v106 + 56);
          long long v152 = (unsigned __int8 *)(v151 + 18);
          while (v148 != *v152 || *(v152 - 2) > 1u)
          {
            v152 += 56;
            if (v149 == ++v150) {
              goto LABEL_144;
            }
          }
          uint64_t v136 = v151 + 56 * v150;
        }
        else
        {
LABEL_144:
          uint64_t v136 = 0;
        }
        unsigned int v137 = (uint64_t *)(v105[8] + 120);
        long long v154 = &__dst[8 * v148];
        id v139 = (uint64_t *)(v154 + 6896);
        uint64_t v155 = 7144;
      }
      else
      {
        unint64_t v130 = v233 + 1218;
        uint64_t v131 = *(unsigned __int16 *)(v106 + 206);
        if (*(_WORD *)(v106 + 206))
        {
          uint64_t v132 = 0;
          uint64_t v133 = *(void *)(v106 + 48);
          uint64_t v134 = (unsigned __int8 *)(v133 + 18);
          while (v130 != *v134 || *(v134 - 2) > 1u)
          {
            v134 += 56;
            if (v131 == ++v132) {
              goto LABEL_123;
            }
          }
          uint64_t v136 = v133 + 56 * v132;
        }
        else
        {
LABEL_123:
          uint64_t v136 = 0;
        }
        unsigned int v137 = (uint64_t *)(v105[9] + 360);
        long long v154 = &__dst[8 * v130];
        id v139 = (uint64_t *)(v154 + 5240);
        uint64_t v155 = 5488;
      }
      uint64_t v140 = (unint64_t *)&v154[v155];
    }
    else
    {
      unint64_t v123 = v233 + 1154;
      uint64_t v124 = *(unsigned __int16 *)(v106 + 200);
      if (*(_WORD *)(v106 + 200))
      {
        uint64_t v125 = 0;
        uint64_t v126 = *(void *)(v106 + 32);
        int v127 = (unsigned __int8 *)(v126 + 18);
        while (v123 != *v127 || *(v127 - 2) > 1u)
        {
          v127 += 56;
          if (v124 == ++v125) {
            goto LABEL_112;
          }
        }
        uint64_t v136 = v126 + 56 * v125;
      }
      else
      {
LABEL_112:
        uint64_t v136 = 0;
      }
      unsigned int v137 = (uint64_t *)(v105[6] + 1176);
      long long v147 = &__dst[8 * v123];
      id v139 = (uint64_t *)(v147 + 1928);
      uint64_t v140 = (unint64_t *)(v147 + 2176);
    }
  }
  else
  {
    unint64_t v107 = v233 + 1090;
    uint64_t v108 = *(unsigned __int16 *)(v106 + 198);
    if (*(_WORD *)(v106 + 198))
    {
      uint64_t v109 = 0;
      uint64_t v110 = *(void *)(v106 + 24);
      unsigned int v111 = (unsigned __int8 *)(v110 + 18);
      while (v107 != *v111 || *(v111 - 2) > 1u)
      {
        v111 += 56;
        if (v108 == ++v109) {
          goto LABEL_90;
        }
      }
      uint64_t v136 = v110 + 56 * v109;
    }
    else
    {
LABEL_90:
      uint64_t v136 = 0;
    }
    unsigned int v137 = (uint64_t *)(v105[6] + 1296);
    uint64_t v138 = &__dst[8 * v107];
    id v139 = (uint64_t *)(v138 + 24);
    uint64_t v140 = (unint64_t *)(v138 + 272);
  }
LABEL_149:
  uint64_t v121 = *v139;
  uint64_t v120 = *v137;
  unint64_t v122 = *v140;
LABEL_150:
  long long v157 = [v225 functionForKey:v120];
  long long v158 = DEVICEOBJECT(v157);

  id v224 = v158;
  id v159 = [v158 newArgumentEncoderWithBufferIndex:*(unsigned __int8 *)(v136 + 18)];
  long long v160 = [v225 bufferForKey:v121];
  id v161 = [v160 length];
  id v162 = v244[3];
  long long v163 = [v162 bufferWithLength:v161 alignment:[v159 alignment]];
  long long v164 = [v162 blitCommandEncoder];
  uint64_t v165 = [v163 heapBuffer];
  unint64_t v239 = (unint64_t)v161;
  [v164 copyFromBuffer:v160 sourceOffset:0 toBuffer:v165 destinationOffset:[v163 heapLocation] size:v161];

  long long v166 = [v162 commandBuffer];
  long long v167 = +[NSString stringWithFormat:@"%@.%@", @"com.apple.gputools.replay", @"DecodeAB Blit"];
  [v166 setLabel:v167];

  [v162 commitCommandBuffer];
  [v166 waitUntilCompleted];
  long long v168 = [v163 heapBuffer];

  uint64_t v223 = v163;
  unint64_t v227 = (char *)[v163 heapLocation];

  long long v169 = apr_array_make(v2, 8, 32);
  if (*(unsigned __int8 *)(v136 + 16) > 1u) {
    goto LABEL_156;
  }
  long long v170 = *(unsigned __int8 **)(v136 + 8);
  if (!v170) {
    goto LABEL_156;
  }
  int v171 = *v170;
  if (v171 == 1) {
    goto LABEL_157;
  }
  if (v171 == 60 && v170[22] == 1) {
    long long v170 = (unsigned __int8 *)*((void *)v170 + 1);
  }
  else {
LABEL_156:
  }
    long long v170 = 0;
LABEL_157:
  GTMTLStructType_fillArgumentIndicesRequiresPatching(v170, 0, 0, v169, 0x1FFuLL);
  long long v222 = v168;
  DEVICEOBJECT(v168);
  id v172 = (id)objc_claimAutoreleasedReturnValue();
  id v173 = v159;
  unint64_t v174 = (unint64_t)[v173 encodedLength];
  long long v221 = v173;
  int v226 = [v173 layout];
  unint64_t v175 = v122 % v174;
  unint64_t v238 = v174;
  unint64_t v176 = (v239 - v122 % v174) / v174;
  uint64_t nelts = v169->nelts;
  uint64_t v178 = apr_array_make(v2, (int)nelts + (int)v176 + (int)v176 * (int)nelts + 2, 8);
  *(void *)apr_array_push(v178) = v176;
  *(void *)apr_array_push(v178) = nelts;
  if (v169->nelts >= 1)
  {
    uint64_t v179 = 0;
    uint64_t v180 = 8;
    do
    {
      uint64_t v181 = *(void *)&v169->elts[v180];
      *(void *)apr_array_push(v178) = v181;
      ++v179;
      v180 += 32;
    }
    while (v179 < v169->nelts);
  }
  unint64_t v182 = v175 + v238;
  if (v175 + v238 <= v239)
  {
    id v229 = v172;
    int v183 = v250;
    int v228 = v250;
    while (1)
    {
      unint64_t v184 = v182;
      *(void *)apr_array_push(v178) = v175;
      if (!v183) {
        break;
      }
      if (v183 == 1)
      {
        unint64_t v242 = v184;
        id v185 = v172;
        int v186 = v169->nelts;
        if (v186 >= 1)
        {
          uint64_t v187 = v185;
          uint64_t v188 = 0;
          uint64_t v189 = 0;
          uint64_t v190 = &v227[v175];
          uint64_t v191 = v245;
          while (1)
          {
            unint64_t v192 = &v169->elts[v188];
            uint64_t v193 = *(void *)v192;
            unint64_t v194 = *(void *)v192 - 58;
            if (v194 <= 0x3C) {
              break;
            }
LABEL_187:
            ++v189;
            v188 += 32;
            if (v189 >= v186) {
              goto LABEL_221;
            }
          }
          uint64_t v195 = *((void *)v192 + 2);
          if (((1 << v194) & 0x1E00000000700003) == 0)
          {
            if (*(void *)v192 != 60) {
              goto LABEL_187;
            }
            unint64_t v199 = *(void *)&v190[v195 + (void)[objc_retainAutorelease(v187) contents]];
            long long v202 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(v191 + 24), *(int *)(v191 + 12), v199);
            if (v202) {
              unint64_t v199 = v202[2] + v199 - *v202;
            }
            goto LABEL_186;
          }
          id v196 = [v187 contents];
          uint64_t v197 = 0;
          if (v193 > 0x72u)
          {
            if (v193 - 117 < 2)
            {
              uint64_t v198 = (uint64_t *)&v249;
              goto LABEL_182;
            }
            uint64_t v198 = (uint64_t *)&v248;
            if (v193 == 115) {
              goto LABEL_182;
            }
            uint64_t v198 = (uint64_t *)&v248 + 1;
            if (v193 == 116) {
              goto LABEL_182;
            }
          }
          else
          {
            if (v193 > 0x4Du)
            {
              uint64_t v198 = (uint64_t *)&v246 + 1;
              if (v193 != 78)
              {
                uint64_t v198 = (uint64_t *)&v247;
                if (v193 != 79)
                {
                  uint64_t v198 = (uint64_t *)&v247 + 1;
                  if (v193 != 80) {
                    goto LABEL_183;
                  }
                }
              }
LABEL_182:
              uint64_t v197 = *v198;
              goto LABEL_183;
            }
            uint64_t v198 = (uint64_t *)&v245 + 1;
            if (v193 == 58) {
              goto LABEL_182;
            }
            uint64_t v198 = (uint64_t *)&v246;
            if (v193 == 59) {
              goto LABEL_182;
            }
          }
LABEL_183:
          unint64_t v199 = *(void *)&v190[v195 + (void)v196];
          *(void *)__dst = v199;
          uint64_t v200 = *find_entry(v197, __dst, 8uLL, 0);
          if (v200)
          {
            uint64_t v201 = *(void *)(v200 + 32);
            if (v201) {
              unint64_t v199 = *(void *)(v201 + 8);
            }
          }
LABEL_186:
          *(void *)apr_array_push(v178) = v199;
          int v186 = v169->nelts;
          goto LABEL_187;
        }
        goto LABEL_221;
      }
LABEL_222:
      unint64_t v182 = v184 + v238;
      unint64_t v175 = v184;
      if (v184 + v238 > v239) {
        goto LABEL_223;
      }
    }
    unint64_t v242 = v184;
    id v203 = v172;
    id v204 = v226;
    int v205 = v169->nelts;
    if (v205 < 1)
    {
LABEL_220:

LABEL_221:
      id v172 = v229;

      int v183 = v228;
      unint64_t v184 = v242;
      goto LABEL_222;
    }
    uint64_t v206 = 0;
    uint64_t v207 = 0;
    long long v208 = &v227[v175];
    uint64_t v209 = v249;
    long long v231 = v248;
    long long v230 = v247;
    long long v235 = v246;
    long long v232 = v245;
    while (1)
    {
      long long v210 = (uint64_t *)&v169->elts[v206];
      uint64_t v212 = *v210;
      uint64_t v211 = v210[1];
      if (*v210 > 78) {
        break;
      }
      if (v212 > 59)
      {
        if (v212 == 60)
        {
          long long v213 = (char *)[v204 virtualAddressForBufferAtIndex:v211 inIndirectArgumentBuffer:v203 atOffset:v208];
          long long v215 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(v232 + 24), *(int *)(v232 + 12), (unint64_t)v213);
          if (v215) {
            long long v213 = &v213[v215[2] - *v215];
          }
          goto LABEL_218;
        }
        if (v212 == 78)
        {
          long long v213 = (char *)[v204 uniqueIdentifierForRenderPipelineAtIndex:v211 inIndirectArgumentBuffer:v203 atOffset:v208];
          *(void *)__dst = v213;
          uint64_t v214 = *((void *)&v235 + 1);
          goto LABEL_215;
        }
      }
      else
      {
        if (v212 == 58)
        {
          long long v213 = (char *)[v204 uniqueIdentifierForTextureAtIndex:v211 inIndirectArgumentBuffer:v203 atOffset:v208];
          *(void *)__dst = v213;
          uint64_t v214 = *((void *)&v232 + 1);
LABEL_215:
          uint64_t v217 = *find_entry(v214, __dst, 8uLL, 0);
          if (v217)
          {
            uint64_t v218 = *(void *)(v217 + 32);
            if (v218) {
              long long v213 = *(char **)(v218 + 8);
            }
          }
LABEL_218:
          *(void *)apr_array_push(v178) = v213;
          int v205 = v169->nelts;
          goto LABEL_219;
        }
        if (v212 == 59)
        {
          long long v213 = (char *)[v204 uniqueIdentifierForSamplerAtIndex:v211 inIndirectArgumentBuffer:v203 atOffset:v208];
          *(void *)__dst = v213;
          uint64_t v214 = v235;
          goto LABEL_215;
        }
      }
LABEL_219:
      ++v207;
      v206 += 32;
      if (v207 >= v205) {
        goto LABEL_220;
      }
    }
    switch(v212)
    {
      case 's':
        long long v213 = (char *)[v204 uniqueIdentifierForVisibleFunctionTableAtIndex:v211 inIndirectArgumentBuffer:v203 atOffset:v208];
        *(void *)__dst = v213;
        uint64_t v214 = v231;
        goto LABEL_215;
      case 't':
        long long v213 = (char *)[v204 uniqueIdentifierForIntersectionFunctionTableAtIndex:v211 inIndirectArgumentBuffer:v203 atOffset:v208];
        *(void *)__dst = v213;
        uint64_t v214 = *((void *)&v231 + 1);
        goto LABEL_215;
      case 'u':
        long long v216 = (char *)[v204 uniqueIdentifierForPrimitiveAccelerationStructureAtIndex:v211 inIndirectArgumentBuffer:v203 atOffset:v208];
        goto LABEL_213;
      case 'v':
        long long v216 = (char *)[v204 uniqueIdentifierForInstanceAccelerationStructureAtIndex:v211 inIndirectArgumentBuffer:v203 atOffset:v208];
LABEL_213:
        long long v213 = v216;
        *(void *)__dst = v216;
        uint64_t v214 = v209;
        goto LABEL_215;
      default:
        if (v212 == 79)
        {
          long long v213 = (char *)[v204 uniqueIdentifierForComputePipelineAtIndex:v211 inIndirectArgumentBuffer:v203 atOffset:v208];
          *(void *)__dst = v213;
          uint64_t v214 = v230;
        }
        else
        {
          if (v212 != 80) {
            goto LABEL_219;
          }
          long long v213 = (char *)[v204 uniqueIdentifierForIndirectCommandBufferAtIndex:v211 inIndirectArgumentBuffer:v203 atOffset:v208];
          *(void *)__dst = v213;
          uint64_t v214 = *((void *)&v230 + 1);
        }
        break;
    }
    goto LABEL_215;
  }
LABEL_223:
  elts = v178->elts;

  return elts;
}

id GTMTLReplayDefaults_logCommandBufferHandlers()
{
  uint64_t v0 = @"com.apple.gputools.replay.logCommandBufferHandlers";
  uint64_t v1 = +[NSUserDefaults standardUserDefaults];
  id v2 = [v1 BOOLForKey:@"com.apple.gputools.replay.logCommandBufferHandlers"];

  return v2;
}

void GTMTLReplayController_restoreRenderCommandEncoder(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7 = a3 + 10012;
  uint64_t v8 = a2 + 10012;
  id v9 = a1;
  id v10 = a4;
  id v35 = v9;
  uint64_t v11 = *(void *)(a3 + 8544);
  if (*(void *)(a2 + 8544) != v11 && v11 != 0)
  {
    uint64_t v13 = [v10 renderPipelineStateForKey:];
    [v35 setRenderPipelineState:v13];
  }
  if (*(unsigned __int8 *)(v8 + 1071) != *(unsigned __int8 *)(v7 + 1071)) {
    [v35 setTriangleFillMode:];
  }
  if (*(unsigned __int8 *)(v8 + 1070) != *(unsigned __int8 *)(v7 + 1070)) {
    [v35 setFrontFacingWinding:];
  }
  if (*(unsigned __int8 *)(v8 + 1068) != *(unsigned __int8 *)(v7 + 1068)) {
    [v35 setCullMode:];
  }
  if (*(void *)(a2 + 9848) != *(void *)(a3 + 9848))
  {
    uint64_t v14 = [v10 depthStencilStateForKey:];
    [v35 setDepthStencilState:v14];
  }
  if (*(float *)(a2 + 10000) != *(float *)(a3 + 10000)
    || *(float *)(a2 + 10004) != *(float *)(a3 + 10004)
    || *(float *)(a2 + 10008) != *(float *)(a3 + 10008))
  {
    [v35 setDepthBias:slopeScale:clamp:];
  }
  if (*(unsigned __int8 *)(v8 + 1069) != *(unsigned __int8 *)(v7 + 1069)) {
    [v35 setDepthClipMode:];
  }
  if (*(_DWORD *)(a2 + 10028) != *(_DWORD *)(a3 + 10028) || *(_DWORD *)(a2 + 10032) != *(_DWORD *)(a3 + 10032)) {
    [v35 setStencilFrontReferenceValue:backReferenceValue:];
  }
  uint64_t v15 = *(void *)(a3 + 8552);
  if (v15 != *(void *)(a2 + 8552) || memcmp((const void *)(a3 + 8560), (const void *)(a2 + 8560), 48 * v15)) {
    [v35 setViewports:a3 + 8560 count:v15];
  }
  uint64_t v16 = *(void *)(a3 + 9328);
  if (v16 != *(void *)(a2 + 9328) || memcmp((const void *)(a3 + 9336), (const void *)(a2 + 9336), 32 * v16)) {
    [v35 setScissorRects:a3 + 9336 count:v16];
  }
  if ((GT_SUPPORT_0 & 2) != 0)
  {
    if (*(unsigned __int8 *)(v8 + 1072) != *(unsigned __int8 *)(v7 + 1072)
      || *(_DWORD *)(a2 + 11068) != *(_DWORD *)(a3 + 11068))
    {
      [v35 setVertexAmplificationMode:value:];
    }
    if (*(_DWORD *)(a2 + 11072) != *(_DWORD *)(a3 + 11072) || *(void *)(a2 + 9856) != *(void *)(a3 + 9856)) {
      [v35 setVertexAmplificationCount:viewMappings:];
    }
  }
  if (*(void *)v8 != *(void *)v7 || *(void *)(v8 + 8) != *(void *)(v7 + 8))
  {
    LODWORD(v17) = *(_DWORD *)(a3 + 10012);
    LODWORD(v18) = *(_DWORD *)(a3 + 10016);
    LODWORD(v19) = *(_DWORD *)(a3 + 10020);
    LODWORD(v20) = *(_DWORD *)(a3 + 10024);
    [v35 setBlendColorRed:v17 green:v18 blue:v19 alpha:v20];
  }
  if (*(unsigned __int8 *)(v8 + 1073) != *(unsigned __int8 *)(v7 + 1073)
    || (uint64_t v22 = v35, *(_DWORD *)(a2 + 11076) != *(_DWORD *)(a3 + 11076)))
  {
    [v35 setVisibilityResultMode:offset:];
    uint64_t v22 = v35;
  }
  uint64_t v36 = a2 + 24;
  uint64_t v37 = a3 + 24;
  uint64_t v38 = 31;
  uint64_t v39 = a2 + 272;
  uint64_t v40 = a3 + 272;
  uint64_t v41 = 31;
  *(void *)&long long v42 = a2 + 520;
  *((void *)&v42 + 1) = a3 + 520;
  *(void *)&long long v43 = 31;
  *((void *)&v43 + 1) = a2 + 16;
  *(void *)&long long v44 = a3 + 16;
  *((void *)&v44 + 1) = 1;
  uint64_t v45 = a2 + 8;
  uint64_t v46 = a3 + 8;
  uint64_t v47 = 1;
  uint64_t v48 = a3 + 24;
  uint64_t v49 = a3 + 272;
  uint64_t v50 = a2 + 768;
  uint64_t v51 = a3 + 768;
  uint64_t v52 = 128;
  uint64_t v53 = a2 + 1792;
  uint64_t v54 = a3 + 1792;
  uint64_t v55 = 16;
  uint64_t v56 = a2 + 10036;
  uint64_t v57 = a2 + 10100;
  uint64_t v58 = a3 + 10036;
  uint64_t v59 = a3 + 10100;
  uint64_t v60 = 16;
  uint64_t v61 = "setVertexBuffer:offset:atIndex:";
  uint64_t v62 = "setVertexBuffer:offset:attributeStride:atIndex:";
  id v63 = "setVertexAccelerationStructure:atBufferIndex:";
  uint64_t v64 = "setVertexIntersectionFunctionTable:atBufferIndex:";
  id v65 = "setVertexVisibleFunctionTable:atBufferIndex:";
  id v66 = "setVertexBytes:length:atIndex:";
  int v67 = "setVertexBytes:length:attributeStride:atIndex:";
  uint64_t v68 = "setVertexTextures:withRange:";
  uint64_t v69 = "setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:";
  RestoreRenderStageResources(v22, &v36, v10);
  uint64_t v36 = a2 + 1928;
  uint64_t v37 = a3 + 1928;
  uint64_t v38 = 31;
  uint64_t v39 = a2 + 2176;
  uint64_t v40 = a3 + 2176;
  uint64_t v41 = 31;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  uint64_t v45 = a2 + 1920;
  uint64_t v46 = a3 + 1920;
  uint64_t v47 = 1;
  uint64_t v48 = a3 + 1928;
  uint64_t v49 = a3 + 2176;
  uint64_t v50 = a2 + 2424;
  uint64_t v51 = a3 + 2424;
  uint64_t v52 = 128;
  uint64_t v53 = a2 + 3448;
  uint64_t v54 = a3 + 3448;
  uint64_t v55 = 16;
  uint64_t v56 = a2 + 10164;
  uint64_t v57 = a2 + 10228;
  uint64_t v58 = a3 + 10164;
  uint64_t v59 = a3 + 10228;
  uint64_t v60 = 16;
  uint64_t v61 = "setFragmentBuffer:offset:atIndex:";
  uint64_t v62 = 0;
  id v63 = "setFragmentAccelerationStructure:atBufferIndex:";
  uint64_t v64 = "setFragmentIntersectionFunctionTable:atBufferIndex:";
  id v65 = "setFragmentVisibleFunctionTable:atBufferIndex:";
  id v66 = "setFragmentBytes:length:atIndex:";
  int v67 = 0;
  uint64_t v68 = "setFragmentTextures:withRange:";
  uint64_t v69 = "setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:";
  RestoreRenderStageResources(v35, &v36, v10);
  if (*(void *)(a2 + 9864) != *(void *)(a3 + 9864)
    || *(_DWORD *)(a2 + 10688) != *(_DWORD *)(a3 + 10688)
    || *(_DWORD *)(a2 + 10692) != *(_DWORD *)(a3 + 10692))
  {
    uint64_t v23 = [v10 bufferForKey:];
    [v35 setTessellationFactorBuffer:v23 offset:*(unsigned int *)(a3 + 10688) instanceStride:*(unsigned int *)(a3 + 10692)];
  }
  uint64_t v24 = v35;
  if (*(float *)(a2 + 10676) != *(float *)(a3 + 10676))
  {
    [v35 setTessellationFactorScale:];
    uint64_t v24 = v35;
  }
  uint64_t v36 = a2 + 3584;
  uint64_t v37 = a3 + 3584;
  uint64_t v38 = 31;
  uint64_t v39 = a2 + 3832;
  uint64_t v40 = a3 + 3832;
  uint64_t v41 = 31;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  uint64_t v45 = a2 + 3576;
  uint64_t v46 = a3 + 3576;
  uint64_t v47 = 1;
  uint64_t v48 = a3 + 3584;
  uint64_t v49 = a3 + 3832;
  uint64_t v50 = a2 + 4080;
  uint64_t v51 = a3 + 4080;
  uint64_t v52 = 128;
  uint64_t v53 = a2 + 5104;
  uint64_t v54 = a3 + 5104;
  uint64_t v55 = 16;
  uint64_t v56 = a2 + 10292;
  uint64_t v57 = a2 + 10356;
  uint64_t v58 = a3 + 10292;
  uint64_t v59 = a3 + 10356;
  uint64_t v60 = 16;
  uint64_t v61 = "setObjectBuffer:offset:atIndex:";
  uint64_t v62 = 0;
  id v63 = "setObjectAccelerationStructure:atBufferIndex:";
  uint64_t v64 = "setObjectIntersectionFunctionTable:atBufferIndex:";
  id v65 = "setObjectVisibleFunctionTable:atBufferIndex:";
  id v66 = "setObjectBytes:length:atIndex:";
  int v67 = 0;
  uint64_t v68 = "setObjectTextures:withRange:";
  uint64_t v69 = "setObjectSamplerStates:lodMinClamps:lodMaxClamps:withRange:";
  RestoreRenderStageResources(v24, &v36, v10);
  for (uint64_t i = 0; i != 31; ++i)
  {
    uint64_t v26 = *(unsigned int *)(a3 + 10944 + 4 * i);
    if (v26 != *(_DWORD *)(a2 + 10944 + 4 * i)) {
      [v35 setObjectThreadgroupMemoryLength:v26 atIndex:i];
    }
  }
  uint64_t v36 = a2 + 5240;
  uint64_t v37 = a3 + 5240;
  uint64_t v38 = 31;
  uint64_t v39 = a2 + 5488;
  uint64_t v40 = a3 + 5488;
  uint64_t v41 = 31;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  uint64_t v45 = a2 + 5232;
  uint64_t v46 = a3 + 5232;
  uint64_t v47 = 1;
  uint64_t v48 = a3 + 5240;
  uint64_t v49 = a3 + 5488;
  uint64_t v50 = a2 + 5736;
  uint64_t v51 = a3 + 5736;
  uint64_t v52 = 128;
  uint64_t v53 = a2 + 6760;
  uint64_t v54 = a3 + 6760;
  uint64_t v55 = 16;
  uint64_t v56 = a2 + 10420;
  uint64_t v57 = a2 + 10484;
  uint64_t v58 = a3 + 10420;
  uint64_t v59 = a3 + 10484;
  uint64_t v60 = 16;
  uint64_t v61 = "setMeshBuffer:offset:atIndex:";
  uint64_t v62 = 0;
  id v63 = "setMeshAccelerationStructure:atBufferIndex:";
  uint64_t v64 = "setMeshIntersectionFunctionTable:atBufferIndex:";
  id v65 = "setMeshVisibleFunctionTable:atBufferIndex:";
  id v66 = "setMeshBytes:length:atIndex:";
  int v67 = 0;
  uint64_t v68 = "setMeshTextures:withRange:";
  uint64_t v69 = "setMeshSamplerStates:lodMinClamps:lodMaxClamps:withRange:";
  RestoreRenderStageResources(v35, &v36, v10);
  if (GT_SUPPORT_0)
  {
    uint64_t v36 = a2 + 6896;
    uint64_t v37 = a3 + 6896;
    uint64_t v38 = 31;
    uint64_t v39 = a2 + 7144;
    uint64_t v40 = a3 + 7144;
    uint64_t v41 = 31;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    uint64_t v45 = a2 + 6888;
    uint64_t v46 = a3 + 6888;
    uint64_t v47 = 1;
    uint64_t v48 = a3 + 6896;
    uint64_t v49 = a3 + 7144;
    uint64_t v50 = a2 + 7392;
    uint64_t v51 = a3 + 7392;
    uint64_t v52 = 128;
    uint64_t v53 = a2 + 8416;
    uint64_t v54 = a3 + 8416;
    uint64_t v55 = 16;
    uint64_t v56 = a2 + 10548;
    uint64_t v57 = a2 + 10612;
    uint64_t v58 = a3 + 10548;
    uint64_t v59 = a3 + 10612;
    uint64_t v60 = 16;
    uint64_t v61 = "setTileBuffer:offset:atIndex:";
    uint64_t v62 = 0;
    id v63 = "setTileAccelerationStructure:atBufferIndex:";
    uint64_t v64 = "setTileIntersectionFunctionTable:atBufferIndex:";
    id v65 = "setTileVisibleFunctionTable:atBufferIndex:";
    id v66 = "setTileBytes:length:atIndex:";
    int v67 = 0;
    uint64_t v68 = "setTileTextures:withRange:";
    uint64_t v69 = "setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:";
    RestoreRenderStageResources(v35, &v36, v10);
    uint64_t v27 = 0;
    uint64_t v28 = (unsigned int *)(a3 + 10820);
    uint64_t v29 = (_DWORD *)(a2 + 10820);
    do
    {
      if (*(v29 - 31) != *(v28 - 31) || *v29 != (unint64_t)*v28) {
        [v35 setThreadgroupMemoryLength:offset:atIndex:];
      }
      ++v28;
      ++v27;
      ++v29;
    }
    while (v27 != 31);
  }
  uint64_t v30 = 0;
  uint64_t v31 = (void *)(a3 + 9936);
  uint64_t v32 = (void *)(a2 + 9936);
  uint64_t v33 = v35;
  do
  {
    if (*(v32 - 8) != *(v31 - 8))
    {
      [v33 setColorStoreAction:atIndex:];
      uint64_t v33 = v35;
    }
    if (*v32 != *v31)
    {
      [v33 setColorStoreActionOptions:atIndex:];
      uint64_t v33 = v35;
    }
    ++v31;
    ++v30;
    ++v32;
  }
  while (v30 != 8);
  if (*(unsigned __int8 *)(v8 + 1074) != *(unsigned __int8 *)(v7 + 1074))
  {
    [v33 setDepthStoreAction:];
    uint64_t v33 = v35;
  }
  if (*(unsigned __int8 *)(v8 + 1076) != *(unsigned __int8 *)(v7 + 1076))
  {
    [v33 setDepthStoreActionOptions:];
    uint64_t v33 = v35;
  }
  if (*(unsigned __int8 *)(v8 + 1075) != *(unsigned __int8 *)(v7 + 1075))
  {
    [v33 setStencilStoreAction:];
    uint64_t v33 = v35;
  }
  if (*(unsigned __int8 *)(v8 + 1077) != *(unsigned __int8 *)(v7 + 1077))
  {
    [v33 setStencilStoreActionOptions:];
    uint64_t v33 = v35;
  }
  if (*(float *)(a2 + 10680) != *(float *)(a3 + 10680))
  {
    [v33 setLineWidth:];
    uint64_t v33 = v35;
  }
  int v34 = *(unsigned __int8 *)(v7 + 1078);
  if (v34 != *(unsigned __int8 *)(v8 + 1078)) {
    [v33 setPrimitiveRestartEnabled:v34 != 0];
  }
}

void RestoreRenderStageResources(void *a1, uint64_t *a2, void *a3)
{
  id v5 = a1;
  id v6 = a3;
  unint64_t v7 = CompareObjectIdRange(*a2, a2[1], a2[2]);
  NSUInteger v9 = v8;
  NSUInteger v10 = CompareObjectIdRange(a2[3], a2[4], a2[5]);
  v12.NSUInteger length = v11;
  if (v9) {
    NSUInteger v13 = v7;
  }
  else {
    NSUInteger v13 = v10;
  }
  if (v11) {
    v12.locatiouint64_t n = v10;
  }
  else {
    v12.locatiouint64_t n = v13;
  }
  v69.locatiouint64_t n = v13;
  v69.NSUInteger length = v9;
  NSRange v14 = NSUnionRange(v69, v12);
  NSRange v67 = v14;
  if (!v14.length) {
    goto LABEL_39;
  }
  locatiouint64_t n = v14.location;
  NSUInteger length = v14.length;
  do
  {
    *(void *)&v68[0] = location;
    if (((*(void *)(a2[13] + ((location >> 3) & 0x1FFFFFFFFFFFFFF8)) >> location) & 1) == 0
      && *(void *)(a2[1] + 8 * location))
    {
      [v6 resourceForKey:];
      id v66 = (_OWORD *)objc_claimAutoreleasedReturnValue();
      if ([v66 conformsToProtocol:&OBJC_PROTOCOL___MTLBuffer])
      {
        NSUInteger v65 = 0;
        NSUInteger v65 = *(void *)(a2[4] + 8 * *(void *)&v68[0]);
        uint64_t v17 = a2[10];
        if (v17
          && ((*(void *)(v17 + ((*(void *)&v68[0] >> 3) & 0x1FFFFFFFFFFFFFF8)) >> SLOBYTE(v68[0])) & 1) != 0)
        {
          NSUInteger v64 = 0;
          NSUInteger v64 = *(void *)(a2[7] + 8 * *(void *)&v68[0]);
          double v18 = [v5 methodSignatureForSelector:a2[29]];
          double v19 = +[NSInvocation invocationWithMethodSignature:v18];

          [v19 setSelector:a2[29]];
          [v19 setTarget:v5];
          [v19 setArgument:&v66 atIndex:2];
          [v19 setArgument:&v65 atIndex:3];
          [v19 setArgument:&v64 atIndex:4];
          double v20 = v19;
          uint64_t v21 = 5;
        }
        else
        {
          uint64_t v25 = [v5 methodSignatureForSelector:a2[28]];
          double v19 = +[NSInvocation invocationWithMethodSignature:v25];

          [v19 setSelector:a2[28]];
          [v19 setTarget:v5];
          [v19 setArgument:&v66 atIndex:2];
          [v19 setArgument:&v65 atIndex:3];
          double v20 = v19;
          uint64_t v21 = 4;
        }
      }
      else
      {
        if ([v66 conformsToProtocol:&OBJC_PROTOCOL___MTLAccelerationStructure] && a2[30])
        {
          uint64_t v22 = [v5 methodSignatureForSelector:];
          double v19 = +[NSInvocation invocationWithMethodSignature:v22];

          uint64_t v23 = a2[30];
        }
        else if ([v66 conformsToProtocol:&OBJC_PROTOCOL___MTLIntersectionFunctionTable] {
               && a2[31])
        }
        {
          uint64_t v24 = [v5 methodSignatureForSelector:];
          double v19 = +[NSInvocation invocationWithMethodSignature:v24];

          uint64_t v23 = a2[31];
        }
        else
        {
          if (![v66 conformsToProtocol:&OBJC_PROTOCOL___MTLVisibleFunctionTable]
            || !a2[32])
          {
            goto LABEL_27;
          }
          uint64_t v26 = [v5 methodSignatureForSelector:];
          double v19 = +[NSInvocation invocationWithMethodSignature:v26];

          uint64_t v23 = a2[32];
        }
        [v19 setSelector:v23];
        [v19 setTarget:v5];
        [v19 setArgument:&v66 atIndex:2];
        double v20 = v19;
        uint64_t v21 = 3;
      }
      [v20 setArgument:v68 atIndex:v21];
      [v19 invoke];

LABEL_27:
    }
    ++location;
    --length;
  }
  while (length);
  if (a2[14])
  {
    unint64_t v27 = 0;
    do
    {
      int v28 = 0;
      int v29 = v27 << 6;
      do
      {
        unint64_t v30 = *(void *)(a2[13] + 8 * v27) >> v28;
        if (!v30) {
          break;
        }
        int v31 = v28 + __clz(__rbit64(v30));
        *(void *)&v68[0] = v31 + v29;
        uint64_t v32 = a2[10];
        if (v32
          && ((*(void *)(v32 + (((unint64_t)(v31 + v29) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v31
                                                                                                  + v29)) & 1) != 0)
        {
          uint64_t v33 = [v5 methodSignatureForSelector:a2[34]];
          int v34 = +[NSInvocation invocationWithMethodSignature:v33];

          [v34 setSelector:a2[34]];
          [v34 setTarget:v5];
          [v34 setArgument:a2[15] + 8 * *(void *)&v68[0] atIndex:2];
          [v34 setArgument:a2[16] + 8 * *(void *)&v68[0] atIndex:3];
          [v34 setArgument:a2[7] + 8 * *(void *)&v68[0] atIndex:4];
          id v35 = v34;
          uint64_t v36 = 5;
        }
        else
        {
          uint64_t v37 = [v5 methodSignatureForSelector:a2[33]];
          int v34 = +[NSInvocation invocationWithMethodSignature:v37];

          [v34 setSelector:a2[33]];
          [v34 setTarget:v5];
          [v34 setArgument:a2[15] + 8 * *(void *)&v68[0] atIndex:2];
          [v34 setArgument:a2[16] + 8 * *(void *)&v68[0] atIndex:3];
          id v35 = v34;
          uint64_t v36 = 4;
        }
        [v35 setArgument:v68 atIndex:v36];
        [v34 invoke];

        int v28 = v31 + 1;
      }
      while (v31 < 63);
      ++v27;
    }
    while (a2[14] > v27);
  }
LABEL_39:
  v67.locatiouint64_t n = CompareObjectIdRange(a2[17], a2[18], a2[19]);
  v67.NSUInteger length = v38;
  if (v38)
  {
    bzero(v68, 0x400uLL);
    unint64_t v39 = 0;
    do
    {
      uint64_t v40 = [v6 textureForKey:*(void *)(a2[18] + 8 * (v39 + v67.location))];
      uint64_t v41 = (void *)*((void *)v68 + v39);
      *((void *)v68 + v39) = v40;

      ++v39;
    }
    while (v39 < v67.length);
    id v66 = v68;
    long long v42 = [v5 methodSignatureForSelector:a2[35]];
    long long v43 = +[NSInvocation invocationWithMethodSignature:v42];

    [v43 setSelector:a2[35]];
    [v43 setTarget:v5];
    [v43 setArgument:&v66 atIndex:2];
    [v43 setArgument:&v67 atIndex:3];
    [v43 invoke];

    for (uint64_t i = 1016; i != -8; i -= 8)
  }
  NSUInteger v45 = CompareObjectIdRange(a2[20], a2[21], a2[22]);
  NSUInteger v47 = v46;
  v67.locatiouint64_t n = v45;
  v67.NSUInteger length = v46;
  NSUInteger v48 = CompareFloatRange(a2[23], a2[25], a2[27]);
  v50.NSUInteger length = v49;
  if (v47) {
    NSUInteger v51 = v45;
  }
  else {
    NSUInteger v51 = v48;
  }
  if (v49) {
    v50.locatiouint64_t n = v48;
  }
  else {
    v50.locatiouint64_t n = v51;
  }
  v70.locatiouint64_t n = v51;
  v70.NSUInteger length = v47;
  NSRange v52 = NSUnionRange(v70, v50);
  NSRange v67 = v52;
  NSUInteger v53 = CompareFloatRange(a2[24], a2[26], a2[27]);
  v55.NSUInteger length = v54;
  if (v52.length) {
    NSUInteger v56 = v52.location;
  }
  else {
    NSUInteger v56 = v53;
  }
  if (v54) {
    v55.locatiouint64_t n = v53;
  }
  else {
    v55.locatiouint64_t n = v56;
  }
  v71.locatiouint64_t n = v56;
  v71.NSUInteger length = v52.length;
  NSRange v67 = NSUnionRange(v71, v55);
  if (v67.length)
  {
    unint64_t v57 = 0;
    memset(v68, 0, 128);
    do
    {
      uint64_t v58 = [v6 samplerStateForKey:*(void *)(a2[21] + 8 * (v57 + v67.location))];
      uint64_t v59 = (void *)*((void *)v68 + v57);
      *((void *)v68 + v57) = v58;

      ++v57;
    }
    while (v57 < v67.length);
    uint64_t v60 = a2[26];
    NSUInteger v65 = a2[25] + 4 * v67.location;
    id v66 = v68;
    NSUInteger v64 = v60 + 4 * v67.location;
    uint64_t v61 = [v5 methodSignatureForSelector:a2[36]];
    uint64_t v62 = +[NSInvocation invocationWithMethodSignature:v61];

    [v62 setSelector:a2[36]];
    [v62 setTarget:v5];
    [v62 setArgument:&v66 atIndex:2];
    [v62 setArgument:&v65 atIndex:3];
    [v62 setArgument:&v64 atIndex:4];
    [v62 setArgument:&v67 atIndex:5];
    [v62 invoke];

    for (uint64_t j = 120; j != -8; j -= 8)
  }
}

unint64_t CompareObjectIdRange(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = 0;
  if (a3)
  {
    while (*(void *)(a1 + 8 * v3) == *(void *)(a2 + 8 * v3))
    {
      if (a3 == ++v3)
      {
        unint64_t v3 = a3;
        break;
      }
    }
  }
  if (v3 >= a3) {
    unint64_t v4 = a3;
  }
  else {
    unint64_t v4 = v3;
  }
  while (v3 < a3)
  {
    unint64_t v5 = a3 - 1;
    uint64_t v6 = *(void *)(a1 - 8 + 8 * a3);
    uint64_t v7 = *(void *)(a2 - 8 + 8 * a3--);
    if (v6 != v7)
    {
      unint64_t v4 = v5 + 1;
      break;
    }
  }
  if (v4 == v3) {
    return 0;
  }
  else {
    return v3;
  }
}

unint64_t CompareFloatRange(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = 0;
  if (a3)
  {
    while (*(float *)(a1 + 4 * v3) == *(float *)(a2 + 4 * v3))
    {
      if (a3 == ++v3)
      {
        unint64_t v3 = a3;
        break;
      }
    }
  }
  if (v3 >= a3) {
    unint64_t v4 = a3;
  }
  else {
    unint64_t v4 = v3;
  }
  while (v3 < a3)
  {
    unint64_t v5 = a3 - 1;
    float v6 = *(float *)(a1 - 4 + 4 * a3);
    float v7 = *(float *)(a2 - 4 + 4 * a3--);
    if (v6 != v7)
    {
      unint64_t v4 = v5 + 1;
      break;
    }
  }
  if (v4 == v3) {
    return 0;
  }
  else {
    return v3;
  }
}

void GTMTLReplayController_restoreDefaultRenderCommandEncoder()
{
  uint64_t v0 = __chkstk_darwin();
  uint64_t v2 = (uint64_t)v1;
  unint64_t v4 = v3;
  unint64_t v6 = v5;
  float v7 = (void *)v0;
  memset(v12, 0, 512);
  uint64_t v8 = *v1;
  id v10 = v9;
  id v11 = v7;
  GTMTLSMRenderCommandEncoder_init((uint64_t)v12, v8);
  uint64_t v13 = 1;
  double v14 = (double)v6;
  double v15 = (double)v4;
  uint64_t v16 = 0x3FF0000000000000;
  uint64_t v17 = 1;
  unint64_t v18 = v6;
  unint64_t v19 = v4;
  GTMTLReplayController_restoreRenderCommandEncoder(v11, (uint64_t)v12, v2, v10);
}

void GTMTLReplayController_restoreComputeCommandEncoder(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a1;
  id v8 = a4;
  id v9 = v8;
  uint64_t v10 = *(void *)(a3 + 8);
  if (*(void *)(a2 + 8) != v10 && v10 != 0)
  {
    NSRange v12 = [v8 computePipelineStateForKey:];
    [v7 setComputePipelineState:v12];
  }
  unint64_t v13 = CompareObjectIdRange(a2 + 32, a3 + 32, 0x1FuLL);
  NSUInteger v15 = v14;
  NSUInteger v16 = CompareObjectIdRange(a2 + 280, a3 + 280, 0x1FuLL);
  v18.NSUInteger length = v17;
  if (v15) {
    NSUInteger v19 = v13;
  }
  else {
    NSUInteger v19 = v16;
  }
  if (v17) {
    v18.locatiouint64_t n = v16;
  }
  else {
    v18.locatiouint64_t n = v19;
  }
  v69.locatiouint64_t n = v19;
  v69.NSUInteger length = v15;
  NSRange v20 = NSUnionRange(v69, v18);
  uint64_t v60 = a2;
  if (v20.length)
  {
    locatiouint64_t n = v20.location;
    NSUInteger length = v20.length;
    uint64_t v59 = a3 + 32;
    uint64_t v23 = (uint64_t *)(a3 + 8 * v20.location + 280);
    do
    {
      if ((*(void *)(a3 + 8 * (location >> 6) + 16) & (1 << location)) == 0 && *(v23 - 31) != 0)
      {
        uint64_t v25 = [v9 resourceForKey:];
        if ([v25 conformsToProtocol:&OBJC_PROTOCOL___MTLBuffer])
        {
          uint64_t v26 = *v23;
          if ((*(void *)(a3 + 8 * (location >> 6) + 24) & (1 << location)) != 0) {
            [v7 setBuffer:v25 offset:v26 attributeStride:v23[31] atIndex:location];
          }
          else {
            [v7 setBuffer:v25 offset:v26 atIndex:location];
          }
        }
        else if ([v25 conformsToProtocol:&OBJC_PROTOCOL___MTLAccelerationStructure])
        {
          [v7 setAccelerationStructure:v25 atBufferIndex:location];
        }
        else if ([v25 conformsToProtocol:&OBJC_PROTOCOL___MTLIntersectionFunctionTable])
        {
          [v7 setIntersectionFunctionTable:v25 atBufferIndex:location];
        }
        else if ([v25 conformsToProtocol:&OBJC_PROTOCOL___MTLVisibleFunctionTable])
        {
          [v7 setVisibleFunctionTable:v25 atBufferIndex:location];
        }
      }
      ++location;
      ++v23;
      --length;
    }
    while (length);
    int v27 = 0;
    a2 = v60;
    do
    {
      unint64_t v28 = *(void *)(a3 + 16) >> v27;
      if (!v28) {
        break;
      }
      int v29 = __clz(__rbit64(v28));
      unint64_t v30 = v27 + v29;
      if ((*(void *)(a3 + 8 * (v30 >> 6) + 24) >> (v27 + v29))) {
        [v7 setBytes:*(void *)(v59 + 8 * v30) length:*(void *)(a3 + 8 * v30 + 280) attributeStride:*(void *)(a3 + 8 * v30 + 528) atIndex:v30];
      }
      else {
        [v7 setBytes:*(void *)(v59 + 8 * v30) length:*(void *)(a3 + 8 * v30 + 280) atIndex:v30];
      }
      int v27 = v30 + 1;
    }
    while ((int)v30 < 63);
  }
  unint64_t v31 = CompareObjectIdRange(a2 + 776, a3 + 776, 0x80uLL);
  if (v32)
  {
    unint64_t v33 = v31;
    uint64_t v34 = v32;
    bzero(&v61, 0x400uLL);
    for (uint64_t i = 0; i != v34; ++i)
    {
      uint64_t v36 = [v9 textureForKey:*(void *)(a3 + 8 * v33 + 776 + 8 * i) v59];
      uint64_t v37 = (void *)*((void *)&v61 + i);
      *((void *)&v61 + i) = v36;
    }
    [v7 setTextures:&v61 withRange:v33, v34];
    for (uint64_t j = 1016; j != -8; j -= 8)
  }
  unint64_t v39 = CompareObjectIdRange(a2 + 1800, a3 + 1800, 0x10uLL);
  NSUInteger v41 = v40;
  NSUInteger v42 = CompareFloatRange(a2 + 2120, a3 + 2120, 0x10uLL);
  v44.NSUInteger length = v43;
  if (v41) {
    NSUInteger v45 = v39;
  }
  else {
    NSUInteger v45 = v42;
  }
  if (v43) {
    v44.locatiouint64_t n = v42;
  }
  else {
    v44.locatiouint64_t n = v45;
  }
  v70.locatiouint64_t n = v45;
  v70.NSUInteger length = v41;
  NSRange v46 = NSUnionRange(v70, v44);
  NSUInteger v47 = CompareFloatRange(a2 + 2184, a3 + 2184, 0x10uLL);
  v49.NSUInteger length = v48;
  if (v46.length) {
    NSUInteger v50 = v46.location;
  }
  else {
    NSUInteger v50 = v47;
  }
  if (v48) {
    v49.locatiouint64_t n = v47;
  }
  else {
    v49.locatiouint64_t n = v50;
  }
  v71.locatiouint64_t n = v50;
  v71.NSUInteger length = v46.length;
  NSRange v51 = NSUnionRange(v71, v49);
  if (v51.length)
  {
    uint64_t v52 = 0;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    long long v63 = 0u;
    long long v64 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    do
    {
      uint64_t v53 = [v9 samplerStateForKey:*(void *)(a3 + 8 * v51.location + 1800 + 8 * v52) v59];
      NSUInteger v54 = (void *)*((void *)&v61 + v52);
      *((void *)&v61 + v52) = v53;

      ++v52;
    }
    while (v51.length != v52);
    [v7 setSamplerStates:&v61 lodMinClamps:a3 + 2120 + 4 * v51.location lodMaxClamps:a3 + 2184 + 4 * v51.location withRange:v51.location v51.length];
    for (uint64_t k = 120; k != -8; k -= 8)

    a2 = v60;
  }
  for (uint64_t m = 0; m != 31; ++m)
  {
    if (*(_DWORD *)(a2 + 1984 + 4 * m) != *(_DWORD *)(a3 + 1984 + 4 * m)) {
      [v7 setThreadgroupMemoryLength:atIndex:];
    }
  }
  if ((GT_SUPPORT_0 & 0x200) != 0 && *(_DWORD *)(a3 + 2108) && *(_DWORD *)(a3 + 2112)) {
    [v7 setImageblockWidth:height:];
  }
  unint64_t v57 = (long long *)(a3 + 1928);
  if (memcmp((const void *)(a2 + 1928), v57, 0x30uLL))
  {
    long long v58 = v57[1];
    long long v61 = *v57;
    long long v62 = v58;
    long long v63 = v57[2];
    [v7 setStageInRegion:&v61];
  }
}