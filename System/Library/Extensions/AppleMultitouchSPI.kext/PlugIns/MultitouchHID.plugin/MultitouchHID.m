uint64_t MultitouchHIDClass::_setProperty(MultitouchHIDClass *this, void *a2, const __CFString *a3, const void *a4)
{
  return (*(uint64_t (**)(void, void *, const __CFString *))(**((void **)this + 1) + 88))(*((void *)this + 1), a2, a3);
}

uint64_t MultitouchHIDClass::setProperty(MultitouchHIDClass *this, const __CFString *a2, const void *a3)
{
  uint64_t result = *((void *)this + 6);
  if (result) {
    return (*(uint64_t (**)(uint64_t, const __CFString *, const void *))(*(void *)result + 568))(result, a2, a3);
  }
  return result;
}

void MTSimpleEventDispatcher::recordHIDEvent(uint64_t a1, uint64_t a2, int a3)
{
  if (a2 && a3 <= 5)
  {
    CFArrayRef Children = (const __CFArray *)IOHIDEventGetChildren();
    if (Children)
    {
      CFArrayRef v6 = Children;
      if (CFArrayGetCount(Children) >= 1)
      {
        CFIndex v7 = 0;
        uint64_t v8 = (a3 + 1);
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v6, v7);
          (*(void (**)(uint64_t, const void *, uint64_t))(*(void *)a1 + 56))(a1, ValueAtIndex, v8);
          ++v7;
        }
        while (v7 < CFArrayGetCount(v6));
      }
    }
    unsigned int Type = IOHIDEventGetType();
    if (Type <= 0x2A) {
      *(CFAbsoluteTime *)(a1 + 8 * Type + 80) = CFAbsoluteTimeGetCurrent();
    }
  }
}

void MTEmbeddedStats::resetTouchState(MTEmbeddedStats *this)
{
  uint64_t v1 = *(void *)this;
  v2 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v3 = *(NSObject **)(v1 + 8);
  v4[0] = MEMORY[0x263EF8330];
  v4[1] = 3321888768;
  v4[2] = ___ZN15MTEmbeddedStats15resetTouchStateEv_block_invoke;
  v4[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19MTEmbeddedStatsImplEE_e5_v8__0l;
  v4[4] = v1;
  v5 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_async(v3, v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

uint64_t MTHandStatistics::processHandState(MTHandStatistics *this, MTPathStates *a2, int a3, char a4)
{
  uint64_t v5 = *((void *)this + 1);
  *((void *)this + 1) = *((void *)a2 + 1);
  *((void *)this + 2) = v5;
  MTHandStatistics::clear(this, 1);
  if ((*((_DWORD *)this + 41) - 1000) <= 0xBB7)
  {
    int v6 = *((_DWORD *)a2 + 97);
    uint64_t v7 = *((void *)a2 + 35);
    BOOL v8 = *(unsigned char *)(v7 + 600 * v6 + 581) && *(unsigned char *)(v7 + 600 * v6 + 582) == 0;
    *((unsigned char *)this + 304) = v8;
    if (*((unsigned char *)this + 305))
    {
      if (*((unsigned __int8 *)this + 190) + *((unsigned __int8 *)this + 187) >= 4
        && *((unsigned __int8 *)this + 299) <= 2u)
      {
        *((void *)this + 32) = 0;
        *(_DWORD *)((char *)this + 214) = 0;
        *((_WORD *)this + 109) = 0;
      }
    }
  }
  *((_DWORD *)this + 40) = *((_DWORD *)a2 + 90);
  uint64_t v9 = *((void *)a2 + 44);
  if (v9) {
    LOBYTE(v9) = *(unsigned char *)(v9 + 3) != 0;
  }
  *((unsigned char *)this + 222) = v9;
  uint64_t v10 = 1;
  uint64_t v11 = 1181;
  do
  {
    uint64_t v12 = *((void *)a2 + 35);
    uint64_t v13 = v12 + v11;
    v14 = (_DWORD *)(v12 + v11 - 541);
    v15 = (unsigned int *)(v12 + v11 - 537);
    unsigned int v16 = *v15;
    if (v10 == *v14 && (int)v16 >= 1)
    {
      v18 = (float32x2_t *)(v13 - 581);
      unsigned int v19 = v16 - 3;
      (*(void (**)(MTHandStatistics *, uint64_t, BOOL, BOOL))(*(void *)this + 16))(this, v13 - 581, v16 < 7, v16 - 3 < 2);
      if (MTParserPath::isFingerOrRestingContact((MTParserPath *)(v13 - 581))
        || MTParserPath::isStylusContact((MTParserPath *)(v13 - 581)))
      {
        v20 = (unsigned char *)(v12 + v11);
        BOOL v36 = (*(_DWORD *)(v20 - 441) - 3) <= 1
           && MTParserPath::wasFingerOrRestingContact((MTParserPath *)(v13 - 581));
        uint64_t v35 = v13 - 365;
        BOOL v21 = v16 < 7;
        BOOL v22 = v19 < 2;
        BOOL v23 = (float)((float)(*(float *)(v20 - 45) * 3.0) + 6.0) >= *((float *)a2 + 76);
        BOOL v24 = MTParserPath::fingerLiftoffNearEdge(v18, *((const MTSurfaceDimensions **)a2 + 5), *((double *)a2 + 1) - *((double *)a2 + 2));
        if (*v15 == 7) {
          v27 = (unsigned int *)(v20 - 437);
        }
        else {
          v27 = (unsigned int *)(v20 - 533);
        }
        v25.n128_u32[0] = *(_DWORD *)(v20 - 489);
        v26.n128_u32[0] = *(_DWORD *)(v20 - 485);
        HIBYTE(v32) = a4;
        BYTE2(v32) = v24;
        BYTE1(v32) = v23;
        LOBYTE(v32) = *v20;
        (*(void (**)(MTHandStatistics *, void, void, uint64_t, BOOL, BOOL, BOOL, BOOL, __n128, __n128, float, int))(*(void *)this + 24))(this, *v14, *v27, v35, v21, v22, v36, *(double *)(v20 - 349) >= *(double *)(v20 - 357), v25, v26, *(float *)(v20 - 465), v32);
        int8x8_t v28 = (int8x8_t)vrev64_s32(*(int32x2_t *)(v20 - 301));
        *((_DWORD *)this + 56) &= HIDWORD(*(void *)(v20 - 301));
        int8x8_t v29 = *(int8x8_t *)((char *)this + 228);
        LODWORD(v30) = vorr_s8(v29, v28).u32[0];
        HIDWORD(v30) = vand_s8(v29, v28).i32[1];
        *(void *)((char *)this + 228) = v30;
        *((_DWORD *)this + 59) &= *(_DWORD *)(v20 - 293);
      }
      else
      {
        (*(void (**)(MTHandStatistics *, uint64_t, BOOL, BOOL))(*(void *)this + 40))(this, v13 - 581, v16 < 7, v19 < 2);
      }
    }
    ++v10;
    v11 += 600;
  }
  while (v10 != 32);
  (*(void (**)(MTHandStatistics *))(*(void *)this + 48))(this);
  *((_DWORD *)this + 77) = *((_DWORD *)a2 + 81);
  if (*((unsigned char *)this + 209)) {
    *((unsigned char *)this + 316) = 1;
  }
  if (!*((unsigned char *)this + 202) && !*((unsigned char *)this + 203)) {
    return 0;
  }
  *((_DWORD *)this + 43) = MTHandStatistics::makeCollectionEventMask(this, a3);
  return 1;
}

uint64_t MTPathStatesBasic::flushStuckContacts(MTPathStatesBasic *this)
{
  char v2 = 0;
  uint64_t v3 = 632;
  uint64_t v4 = 31;
  do
  {
    uint64_t v5 = *((void *)this + 35);
    if (MTContact_isActive())
    {
      double v6 = *((double *)this + 1);
      if (*(double *)(v5 + v3) != v6)
      {
        MTParserPath::flushLiftoffAt((MTParserPath *)(*((void *)this + 35) + v3 - 32), v6);
        char v2 = 1;
      }
    }
    v3 += 600;
    --v4;
  }
  while (v4);
  return v2 & 1;
}

void MTHandMotion::clear(MTHandMotion *this)
{
}

uint64_t MTSimpleHIDManager::cleanupBootloadPowerAssertion(MTSimpleHIDManager *this)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  char v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *((void *)this + 13);
    int v5 = 136315906;
    double v6 = "";
    __int16 v7 = 2080;
    BOOL v8 = "MTSimpleHIDManager::";
    __int16 v9 = 2080;
    uint64_t v10 = "cleanupBootloadPowerAssertion";
    __int16 v11 = 2048;
    uint64_t v12 = v3;
    _os_log_impl(&dword_2406FB000, v2, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s [generation: %llu]", (uint8_t *)&v5, 0x2Au);
  }
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 520))(this);
  return (*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)this + 504))(this);
}

uint64_t MTSimpleHIDManager::forwardNotificationEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 208))(a3, a1, a2);
}

uint64_t MTSimpleHIDManager::setPropertyInternal(uint64_t *a1, int a2, CFTypeRef cf, int a4)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  if (cf)
  {
    CFTypeID v8 = CFGetTypeID(cf);
    BOOL v9 = v8 == CFBooleanGetTypeID();
    CFTypeID v10 = CFGetTypeID(cf);
    BOOL v11 = v10 == CFNumberGetTypeID();
    CFTypeID v12 = CFGetTypeID(cf);
    BOOL v13 = v12 == CFDataGetTypeID();
    CFTypeID v14 = CFGetTypeID(cf);
    BOOL v15 = v14 == CFStringGetTypeID();
    CFTypeID v16 = CFGetTypeID(cf);
    BOOL v17 = v16 == CFArrayGetTypeID();
    CFTypeID v18 = CFGetTypeID(cf);
    BOOL v19 = v18 == CFDictionaryGetTypeID();
  }
  else
  {
    BOOL v17 = 0;
    BOOL v13 = 0;
    BOOL v9 = 0;
    BOOL v11 = 0;
    BOOL v15 = 0;
    BOOL v19 = 0;
  }
  uint64_t result = 0;
  switch(a2)
  {
    case 1:
    case 2:
      uint64_t result = 0;
      *(_DWORD *)valuePtr = 0;
      if (v11) {
        return CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, valuePtr) != 0;
      }
      return result;
    case 3:
      CFTypeID v21 = CFGetTypeID(cf);
      LODWORD(result) = v21 == CFArrayGetTypeID() && CFArrayGetCount((CFArrayRef)cf) > 0;
      return v9 | result;
    case 4:
      return v9 | result;
    case 5:
    case 25:
    case 70:
    case 74:
      return v9;
    case 6:
      CFTypeID v22 = CFGetTypeID(cf);
      return v22 == CFStringGetTypeID();
    case 7:
      if (!v9) {
        return 0;
      }
      _printHIDEvents = CFBooleanGetValue((CFBooleanRef)cf) != 0;
      return 1;
    case 9:
      uint64_t result = 0;
      LOWORD(v68) = 0;
      if (!v11) {
        return result;
      }
      uint64_t result = CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt16Type, &v68);
      if (!result) {
        return result;
      }
      *((_DWORD *)a1 + 33) = LOWORD(v68);
      uint64_t v23 = a1[14];
      if (v23)
      {
        (*(void (**)(uint64_t))(*(void *)v23 + 24))(v23);
      }
      else
      {
        uint64_t v51 = 16;
        if (!*((unsigned char *)a1 + 122)) {
          uint64_t v51 = 24;
        }
        if (LODWORD(a1[v51]) != 255 && !*((unsigned char *)a1 + 80))
        {
          (*(void (**)(uint64_t *))(*a1 + 440))(a1);
          uint64_t v52 = *a1;
          if (*((unsigned char *)a1 + 122)) {
            (*(void (**)(uint64_t *, void, void))(v52 + 432))(a1, *((unsigned __int16 *)a1 + 64), LOWORD(v68));
          }
          else {
            (*(void (**)(uint64_t *, void, void))(v52 + 464))(a1, *((unsigned __int16 *)a1 + 96), LOWORD(v68));
          }
        }
      }
      *(_OWORD *)valuePtr = xmmword_24074FB88;
      *(_OWORD *)&valuePtr[16] = unk_24074FB98;
      *(_OWORD *)v70 = xmmword_24074FBA8;
      *(_OWORD *)&v70[16] = unk_24074FBB8;
      (*(void (**)(unsigned char *__return_ptr, uint64_t *))(*a1 + 168))(valuePtr, a1);
      *(_DWORD *)valuePtr = LOWORD(v68);
      goto LABEL_124;
    case 10:
      uint64_t result = 0;
      LOWORD(v68) = 0;
      if (!v11) {
        return result;
      }
      uint64_t result = CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt16Type, &v68);
      if (!result) {
        return result;
      }
      *(_OWORD *)valuePtr = xmmword_24074FB88;
      *(_OWORD *)&valuePtr[16] = unk_24074FB98;
      *(_OWORD *)v70 = xmmword_24074FBA8;
      *(_OWORD *)&v70[16] = unk_24074FBB8;
      (*(void (**)(unsigned char *__return_ptr, uint64_t *))(*a1 + 168))(valuePtr, a1);
      *(_DWORD *)&valuePtr[4] = LOWORD(v68);
      goto LABEL_124;
    case 11:
      uint64_t result = 0;
      valuePtr[0] = 0;
      if (!v11) {
        return result;
      }
      uint64_t result = CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt8Type, valuePtr);
      if (!result) {
        return result;
      }
      *((unsigned char *)a1 + 136) = valuePtr[0];
      uint64_t v24 = 16;
      if (!*((unsigned char *)a1 + 122)) {
        uint64_t v24 = 24;
      }
      if (LODWORD(a1[v24]) != 255) {
        (*(void (**)(uint64_t *))(*a1 + 448))(a1);
      }
      return 1;
    case 12:
      double v68 = 0.0;
      if (!v11) {
        return 0;
      }
      uint64_t result = CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, &v68);
      if (!result) {
        return result;
      }
      *(_OWORD *)valuePtr = xmmword_24074FB88;
      *(_OWORD *)&valuePtr[16] = unk_24074FB98;
      *(_OWORD *)v70 = xmmword_24074FBA8;
      *(_OWORD *)&v70[16] = unk_24074FBB8;
      (*(void (**)(unsigned char *__return_ptr, uint64_t *))(*a1 + 168))(valuePtr, a1);
      float v25 = v68;
      *(float *)&valuePtr[12] = v25;
      goto LABEL_124;
    case 13:
      double v68 = 0.0;
      if (!v11) {
        return 0;
      }
      uint64_t result = CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, &v68);
      if (!result) {
        return result;
      }
      *(_OWORD *)valuePtr = xmmword_24074FB88;
      *(_OWORD *)&valuePtr[16] = unk_24074FB98;
      *(_OWORD *)v70 = xmmword_24074FBA8;
      *(_OWORD *)&v70[16] = unk_24074FBB8;
      (*(void (**)(unsigned char *__return_ptr, uint64_t *))(*a1 + 168))(valuePtr, a1);
      float v26 = v68;
      *(float *)&valuePtr[16] = v26;
      goto LABEL_124;
    case 14:
      double v68 = 0.0;
      if (!v11) {
        return 0;
      }
      uint64_t result = CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, &v68);
      if (!result) {
        return result;
      }
      *(_OWORD *)valuePtr = xmmword_24074FB88;
      *(_OWORD *)&valuePtr[16] = unk_24074FB98;
      *(_OWORD *)v70 = xmmword_24074FBA8;
      *(_OWORD *)&v70[16] = unk_24074FBB8;
      (*(void (**)(unsigned char *__return_ptr, uint64_t *))(*a1 + 168))(valuePtr, a1);
      float v27 = v68;
      *(float *)&valuePtr[20] = v27;
LABEL_124:
      (*(void (**)(uint64_t *, unsigned char *))(*a1 + 176))(a1, valuePtr);
      return 1;
    case 18:
      uint64_t result = 0;
      LOWORD(v68) = 0;
      if (!v11) {
        return result;
      }
      uint64_t result = CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt16Type, &v68);
      if (!result) {
        return result;
      }
      int v28 = *((_DWORD *)a1 + 32);
      int v29 = LOWORD(v68);
      *((_DWORD *)a1 + 32) = LOWORD(v68);
      if (v28 == 255 || v29 != 255)
      {
        if (v28 != 255 || v29 == 255) {
          (*(void (**)(uint64_t *))(*a1 + 432))(a1);
        }
        else {
          (*(void (**)(uint64_t *, uint64_t, void))(*a1 + 408))(a1, 2, 0);
        }
      }
      else
      {
        (*(void (**)(uint64_t *, void, void))(*a1 + 408))(a1, 0, 0);
      }
      v53 = MTLoggingPlugin();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
      {
        int v54 = *((_DWORD *)a1 + 32);
        *(_DWORD *)valuePtr = 136316162;
        *(void *)&valuePtr[4] = "";
        *(_WORD *)&valuePtr[12] = 2080;
        *(void *)&valuePtr[14] = "MTSimpleHIDManager::";
        *(_WORD *)&valuePtr[22] = 2080;
        *(void *)&valuePtr[24] = "setPropertyInternal";
        *(_WORD *)v70 = 1024;
        *(_DWORD *)&v70[2] = v28;
        *(_WORD *)&v70[6] = 1024;
        *(_DWORD *)&v70[8] = v54;
        _os_log_impl(&dword_2406FB000, v53, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s detection mode: %d->%d\n", valuePtr, 0x2Cu);
      }
      return 1;
    case 20:
      BOOL v30 = (CFTypeRef)*MEMORY[0x263EFFB40] == cf && v9;
      if (!v30 || *((_DWORD *)a1 + 32) == 255) {
        return 0;
      }
      v31 = MTLoggingPlugin();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)valuePtr = 136315650;
        *(void *)&valuePtr[4] = "";
        *(_WORD *)&valuePtr[12] = 2080;
        *(void *)&valuePtr[14] = "MTSimpleHIDManager::";
        *(_WORD *)&valuePtr[22] = 2080;
        *(void *)&valuePtr[24] = "setPropertyInternal";
        _os_log_impl(&dword_2406FB000, v31, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Resetting prox", valuePtr, 0x20u);
      }
      (*(void (**)(uint64_t *))(*a1 + 80))(a1);
      LODWORD(v68) = MTSwapInt32HostToDevice();
      (*(void (**)(uint64_t *))(*a1 + 80))(a1);
      int v32 = MTDeviceSetReport();
      if (!v32) {
        return 0;
      }
      int v33 = v32;
      v34 = MTLoggingPlugin();
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      *(_DWORD *)valuePtr = 136315906;
      *(void *)&valuePtr[4] = "[Error] ";
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = "MTSimpleHIDManager::";
      *(_WORD *)&valuePtr[22] = 2080;
      *(void *)&valuePtr[24] = "setPropertyInternal";
      *(_WORD *)v70 = 1024;
      *(_DWORD *)&v70[2] = v33;
      uint64_t v35 = "[HID] [MT] %s%s%s Error 0x%08X resetting prox";
      goto LABEL_90;
    case 21:
      if (!v9) {
        return 0;
      }
      char v36 = (CFTypeRef)*MEMORY[0x263EFFB40] == cf ? 8 : 9;
      LOBYTE(v68) = v36;
      (*(void (**)(uint64_t *))(*a1 + 80))(a1);
      int v37 = MTDeviceSetReport();
      if (!v37) {
        return 0;
      }
      int v38 = v37;
      v34 = MTLoggingPlugin();
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      *(_DWORD *)valuePtr = 136315906;
      *(void *)&valuePtr[4] = "[Error] ";
      *(_WORD *)&valuePtr[12] = 2080;
      *(void *)&valuePtr[14] = "MTSimpleHIDManager::";
      *(_WORD *)&valuePtr[22] = 2080;
      *(void *)&valuePtr[24] = "setPropertyInternal";
      *(_WORD *)v70 = 1024;
      *(_DWORD *)&v70[2] = v38;
      uint64_t v35 = "[HID] [MT] %s%s%s Error 0x%08x setting rHOST_EVENT_NOTIFICATION";
      goto LABEL_90;
    case 37:
      if (!v13) {
        return 0;
      }
      CFDataGetBytePtr((CFDataRef)cf);
      unint64_t Length = CFDataGetLength((CFDataRef)cf);
      if (Length > 1)
      {
        (*(void (**)(uint64_t *))(*a1 + 80))(a1);
        uint64_t result = MTDeviceSendExternalMessage();
        if (!result) {
          return result;
        }
        int v50 = result;
        v34 = MTLoggingPlugin();
        uint64_t result = os_log_type_enabled(v34, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        *(_DWORD *)valuePtr = 136315906;
        *(void *)&valuePtr[4] = "[Error] ";
        *(_WORD *)&valuePtr[12] = 2080;
        *(void *)&valuePtr[14] = "MTSimpleHIDManager::";
        *(_WORD *)&valuePtr[22] = 2080;
        *(void *)&valuePtr[24] = "setPropertyInternal";
        *(_WORD *)v70 = 1024;
        *(_DWORD *)&v70[2] = v50;
        uint64_t v35 = "[HID] [MT] %s%s%s Error 0x%08X sending external message";
LABEL_90:
        v41 = v34;
        uint32_t v42 = 38;
      }
      else
      {
        v40 = MTLoggingPlugin();
        uint64_t result = os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        *(_DWORD *)valuePtr = 136316162;
        *(void *)&valuePtr[4] = "[Error] ";
        *(_WORD *)&valuePtr[12] = 2080;
        *(void *)&valuePtr[14] = "MTSimpleHIDManager::";
        *(_WORD *)&valuePtr[22] = 2080;
        *(void *)&valuePtr[24] = "setPropertyInternal";
        *(_WORD *)v70 = 2048;
        *(void *)&v70[2] = Length;
        *(_WORD *)&v70[10] = 2048;
        *(void *)&v70[12] = 2;
        uint64_t v35 = "[HID] [MT] %s%s%s Message length (%ld) is smaller than message type size (%lu)";
        v41 = v40;
        uint32_t v42 = 52;
      }
      _os_log_impl(&dword_2406FB000, v41, OS_LOG_TYPE_ERROR, v35, valuePtr, v42);
      return 0;
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 46:
    case 47:
    case 49:
    case 51:
    case 54:
    case 55:
    case 56:
    case 57:
    case 60:
    case 61:
    case 62:
    case 63:
    case 66:
    case 67:
    case 69:
    case 81:
    case 84:
    case 85:
      return v11;
    case 43:
      uint64_t result = 0;
      LOWORD(v68) = 0;
      if (!v11) {
        return result;
      }
      uint64_t result = CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt16Type, &v68);
      if (!result) {
        return result;
      }
      int v43 = *((_DWORD *)a1 + 48);
      int v44 = LOBYTE(v68);
      *((_DWORD *)a1 + 48) = LOBYTE(v68);
      if (v43 == v44 && !a4) {
        return 1;
      }
      (*(void (**)(uint64_t *))(*a1 + 80))(a1);
      if (MTDeviceSupportsTapToWake()
        && ((*(void (**)(uint64_t *))(*a1 + 80))(a1), (MTDeviceUseContextualPower() & 1) == 0))
      {
        int v45 = *((_DWORD *)a1 + 48);
        if (v45 == 255)
        {
          int v46 = 254;
          goto LABEL_108;
        }
      }
      else
      {
        int v45 = *((_DWORD *)a1 + 48);
      }
      if (v45 != 252) {
        goto LABEL_109;
      }
      int v46 = 255;
LABEL_108:
      *((_DWORD *)a1 + 48) = v46;
LABEL_109:
      (*(void (**)(uint64_t *))(*a1 + 80))(a1);
      if (MTDeviceNeedsFirstPowerOffSuppressed() && (*((_DWORD *)a1 + 48) - 253) <= 2)
      {
        (*(void (**)(uint64_t *))(*a1 + 80))(a1);
        int PowerOffSuppressed = MTDeviceNotifyFirstPowerOffSuppressed();
        v56 = MTLoggingPlugin();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)valuePtr = 136315906;
          *(void *)&valuePtr[4] = "";
          *(_WORD *)&valuePtr[12] = 2080;
          *(void *)&valuePtr[14] = "MTSimpleHIDManager::";
          *(_WORD *)&valuePtr[22] = 2080;
          *(void *)&valuePtr[24] = "setPropertyInternal";
          *(_WORD *)v70 = 1024;
          *(_DWORD *)&v70[2] = PowerOffSuppressed;
          _os_log_impl(&dword_2406FB000, v56, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Suppressed first power off on boot - driver notified: 0x%x\n", valuePtr, 0x26u);
        }
        uint64_t result = 0;
        *((_DWORD *)a1 + 48) = v43;
      }
      else
      {
        unsigned int v57 = LOWORD(v68) & 0x100;
        uint64_t v58 = a1[14];
        if (v58)
        {
          (*(void (**)(uint64_t, void, BOOL))(*(void *)v58 + 16))(v58, *((unsigned int *)a1 + 48), v57 != 0);
        }
        else
        {
          (*(void (**)(uint64_t *))(*a1 + 80))(a1);
          int v59 = MTDevicePowerControlSupported();
          int v60 = *((_DWORD *)a1 + 48);
          if (v59)
          {
            if ((v60 - 253) >= 2)
            {
              if (v60 == 255)
              {
                (*(void (**)(uint64_t *, void, void))(*a1 + 408))(a1, 0, 0);
              }
              else
              {
                (*(void (**)(uint64_t *, uint64_t, BOOL))(*a1 + 416))(a1, 2, v57 != 0);
                if (v43 == 255 || *((unsigned char *)a1 + 80))
                {
                  v61 = MTLoggingPlugin();
                  if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
                  {
                    int v62 = *((_DWORD *)a1 + 48);
                    int v63 = *((_DWORD *)a1 + 33);
                    *(_DWORD *)valuePtr = 136316162;
                    *(void *)&valuePtr[4] = "";
                    *(_WORD *)&valuePtr[12] = 2080;
                    *(void *)&valuePtr[14] = "MTSimpleHIDManager::";
                    *(_WORD *)&valuePtr[22] = 2080;
                    *(void *)&valuePtr[24] = "setPropertyInternal";
                    *(_WORD *)v70 = 1024;
                    *(_DWORD *)&v70[2] = v62;
                    *(_WORD *)&v70[6] = 1024;
                    *(_DWORD *)&v70[8] = v63;
                    _os_log_impl(&dword_2406FB000, v61, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Skip sending touch mode %d, orientation %d. Device not on", valuePtr, 0x2Cu);
                  }
                }
                else
                {
                  (*(void (**)(uint64_t *, void, void))(*a1 + 464))(a1, *((unsigned __int16 *)a1 + 96), *((unsigned __int16 *)a1 + 66));
                }
              }
            }
            else
            {
              (*(void (**)(uint64_t *, void, void))(*a1 + 464))(a1, (unsigned __int16)*((_DWORD *)a1 + 48), *((unsigned __int16 *)a1 + 66));
              (*(void (**)(uint64_t *, uint64_t, BOOL))(*a1 + 416))(a1, 1, v57 != 0);
            }
          }
          else
          {
            (*(void (**)(uint64_t *, void, void))(*a1 + 464))(a1, (unsigned __int16)*((_DWORD *)a1 + 48), *((unsigned __int16 *)a1 + 66));
          }
          v64 = MTLoggingPlugin();
          if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
          {
            int v65 = *((_DWORD *)a1 + 48);
            *(_DWORD *)valuePtr = 136316418;
            *(void *)&valuePtr[4] = "";
            *(_WORD *)&valuePtr[12] = 2080;
            *(void *)&valuePtr[14] = "MTSimpleHIDManager::";
            *(_WORD *)&valuePtr[22] = 2080;
            *(void *)&valuePtr[24] = "setPropertyInternal";
            *(_WORD *)v70 = 1024;
            *(_DWORD *)&v70[2] = v43;
            *(_WORD *)&v70[6] = 1024;
            *(_DWORD *)&v70[8] = v65;
            *(_WORD *)&v70[12] = 1024;
            *(_DWORD *)&v70[14] = v57 >> 8;
            _os_log_impl(&dword_2406FB000, v64, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s touch mode: %d->%d fromButton=%d\n", valuePtr, 0x32u);
          }
        }
        if (*((_DWORD *)a1 + 39) == 4)
        {
          valuePtr[0] = *((_DWORD *)a1 + 48);
          mach_absolute_time();
          uint64_t VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
          if (VendorDefinedEvent)
          {
            v67 = (const void *)VendorDefinedEvent;
            (*(void (**)(uint64_t *, uint64_t, void))(*a1 + 136))(a1, VendorDefinedEvent, 0);
            CFRelease(v67);
          }
        }
        return 1;
      }
      return result;
    case 44:
    case 45:
    case 59:
    case 64:
    case 65:
    case 68:
    case 78:
      return v15;
    case 48:
    case 50:
    case 76:
      return v17;
    case 52:
    case 53:
      return v13;
    case 58:
      LODWORD(result) = v9;
      return v19 | result;
    case 71:
      return v19 | result;
    case 72:
      if (!v9) {
        return 0;
      }
      BOOL v47 = CFBooleanGetValue((CFBooleanRef)cf) != 0;
      (*(void (**)(uint64_t, BOOL))(*(void *)a1[4] + 72))(a1[4], v47);
      return 1;
    case 75:
      uint64_t result = 0;
      *(_DWORD *)valuePtr = 0;
      if (!v11) {
        return result;
      }
      int Value = CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, valuePtr);
      uint64_t result = 0;
      if (!Value || *(_DWORD *)valuePtr > 1u) {
        return result;
      }
      uint64_t v49 = a1[14];
      if (v49) {
        *(_DWORD *)(v49 + 32) = *(_DWORD *)valuePtr;
      }
      return 1;
    case 86:
      if (!v9) {
        return 0;
      }
      (*(void (**)(uint64_t *))(*a1 + 80))(a1);
      MTDeviceSetBinaryFiltersProperty();
      return 1;
    default:
      return result;
  }
}

void MTSimpleHIDManager::setFieldDetectionStatus(dispatch_object_t *this)
{
  if (*((_DWORD *)this + 41))
  {
    dispatch_retain(this[22]);
    dispatch_retain(this[23]);
    uint64_t v3 = this[22];
    char v2 = this[23];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 0x40000000;
    block[2] = ___ZN18MTSimpleHIDManager23setFieldDetectionStatusEv_block_invoke;
    block[3] = &__block_descriptor_tmp_272;
    block[4] = this;
    dispatch_group_async(v2, v3, block);
  }
}

uint64_t MTSimpleHIDManager::setPowerState(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  if (*(void *)(a1 + 112)) {
    MTSimpleHIDManager::setPowerState();
  }
  double v6 = MTLoggingPlugin();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 2) {
      __int16 v7 = "<UNKNOWN>";
    }
    else {
      __int16 v7 = off_2650D3550[a2];
    }
    int v11 = 136316418;
    CFTypeID v12 = "";
    __int16 v13 = 2080;
    CFTypeID v14 = "MTSimpleHIDManager::";
    __int16 v15 = 2080;
    CFTypeID v16 = "setPowerState";
    __int16 v17 = 1024;
    int v18 = a2;
    __int16 v19 = 2082;
    v20 = v7;
    __int16 v21 = 1024;
    int v22 = a3;
    _os_log_impl(&dword_2406FB000, v6, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s [powerState:%d(%{public}s), deferUntilBootload:%d]", (uint8_t *)&v11, 0x36u);
  }
  if (a3)
  {
    uint64_t v8 = 0;
    *(unsigned char *)(a1 + 80) = 1;
    *(_DWORD *)(a1 + 84) = a2;
  }
  else
  {
    *(unsigned char *)(a1 + 80) = 0;
    (*(void (**)(uint64_t))(*(void *)a1 + 80))(a1);
    uint64_t v8 = MTDevicePowerSetState();
    BOOL v9 = MTLoggingPlugin();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 136315906;
      CFTypeID v12 = "";
      __int16 v13 = 2080;
      CFTypeID v14 = "MTSimpleHIDManager::";
      __int16 v15 = 2080;
      CFTypeID v16 = "setPowerState";
      __int16 v17 = 1024;
      int v18 = v8;
      _os_log_impl(&dword_2406FB000, v9, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s MTDevicePowerSetState result: 0x%x", (uint8_t *)&v11, 0x26u);
    }
  }
  return v8;
}

uint64_t MTSimpleHIDManager::setOrientation(MTSimpleHIDManager *this)
{
  return MTDeviceSetReport();
}

uint64_t MTSimpleEmbeddedHIDManager::resetDevice(MTEmbeddedStatsImpl ****this)
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  MTParser::deviceWillReset(this[26]);
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v32 = 0u;
  long long v31 = 0u;
  long long v30 = 0u;
  long long v29 = 0u;
  long long v28 = 0u;
  long long v27 = 0u;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  long long v17 = 0u;
  __b[129] = 1;
  memset(__b, 170, 0x204uLL);
  ((void (*)(MTEmbeddedStatsImpl ****))(*this)[10])(this);
  unsigned int v2 = MTDeviceIssueDriverRequest();
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = __b[0];
  }
  uint64_t v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136316162;
    __int16 v7 = "";
    __int16 v8 = 2080;
    BOOL v9 = "";
    __int16 v10 = 2080;
    int v11 = "resetDevice";
    __int16 v12 = 1024;
    int v13 = v3;
    __int16 v14 = 1024;
    int v15 = __b[0];
    _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s [result:0x%08x, requestResult.status:0x%08x]", (uint8_t *)&v6, 0x2Cu);
  }
  return v3;
}

uint64_t MTSimpleHIDManager::setProperty(MTSimpleHIDManager *this, const __CFString *a2, const void *a3, uint64_t a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  if (MTSimpleHIDManager::propertyTypeFromString((uint64_t)a2, a2) == 18 && !*((unsigned char *)this + 122))
  {
    unsigned __int16 valuePtr = -21846;
    if (a3)
    {
      CFTypeID v12 = CFGetTypeID(a3);
      if (v12 == CFNumberGetTypeID())
      {
        uint64_t Value = CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt16Type, &valuePtr);
        if (Value)
        {
          int v14 = MTSimpleHIDManager::translateInputDetectionMode(Value, valuePtr);
          int v19 = v14;
          int v15 = MTLoggingPlugin();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136316162;
            long long v22 = "";
            __int16 v23 = 2080;
            long long v24 = "MTSimpleHIDManager::";
            __int16 v25 = 2080;
            long long v26 = "setProperty";
            __int16 v27 = 1024;
            int v28 = valuePtr;
            __int16 v29 = 1024;
            int v30 = v14;
            _os_log_impl(&dword_2406FB000, v15, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Converting input detection mode (%d) to touch mode (%d) because prox is absent", buf, 0x2Cu);
          }
          CFNumberRef v16 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt16Type, &v19);
          if (v16)
          {
            CFNumberRef v17 = v16;
            uint64_t v11 = (*(uint64_t (**)(MTSimpleHIDManager *, __CFString *, CFNumberRef, uint64_t))(*(void *)this + 392))(this, @"TouchDetectionMode", v16, a4);
            CFRelease(v17);
            return v11;
          }
          return 0;
        }
      }
    }
  }
  if (a3)
  {
    if (a2)
    {
      if (!a4)
      {
        BOOL v9 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), a2);
        if (v9)
        {
          if (CFEqual(v9, a3)) {
            return 0;
          }
        }
      }
    }
  }
  uint64_t v10 = MTSimpleHIDManager::propertyTypeFromString((uint64_t)a2, v8);
  if (!(*(unsigned int (**)(MTSimpleHIDManager *, uint64_t, const void *, uint64_t))(*(void *)this + 400))(this, v10, a3, a4))return 0; {
  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 5), a2, a3);
  }
  return 1;
}

uint64_t MTSimpleHIDManager::setProperty(CFDateFormatterRef *this, const __CFString *a2, const void *a3)
{
  if ((*((unsigned int (**)(CFDateFormatterRef *))*this + 59))(this))
  {
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 3, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    if (Mutable)
    {
      CFStringRef v8 = Mutable;
      if (this[9])
      {
        CFTimeZoneRef v9 = CFTimeZoneCopySystem();
        if (v9)
        {
          CFTimeZoneRef v10 = v9;
          CFDateFormatterSetProperty(this[9], (CFStringRef)*MEMORY[0x263EFFC10], v9);
          CFRelease(v10);
        }
        uint64_t v11 = this[9];
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        CFStringRef StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(v6, v11, Current);
        if (StringWithAbsoluteTime)
        {
          CFStringRef v14 = StringWithAbsoluteTime;
          CFDictionarySetValue(v8, @"set time", StringWithAbsoluteTime);
          CFDictionarySetValue(v8, @"key", a2);
          CFDictionarySetValue(v8, @"value", a3);
          CFArrayAppendValue(this[6], v8);
          while (CFArrayGetCount(this[6]) > *((unsigned __int16 *)this + 28))
            CFArrayRemoveValueAtIndex(this[6], 0);
          CFRelease(v14);
        }
      }
      CFRelease(v8);
    }
  }
  int v15 = (uint64_t (*)(CFDateFormatterRef *, const __CFString *, const void *, void))*((void *)*this + 49);

  return v15(this, a2, a3, 0);
}

uint64_t MTEmbeddedStatsImpl::updateOpenRows(MTEmbeddedStatsImpl *this)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  int OpenRows = MTDeviceGetOpenRows();
  if (OpenRows == -536870201)
  {
    MTDeviceGetDeviceID();
    __int16 v7 = MTLoggingPlugin();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      *(void *)CFStringRef v14 = 0;
      CFStringRef v8 = "Skipping open rows logging: not supported (deviceID 0x%llX)";
      CFTimeZoneRef v9 = v7;
      os_log_type_t v10 = OS_LOG_TYPE_DEBUG;
      uint32_t v11 = 12;
LABEL_10:
      _os_log_impl(&dword_2406FB000, v9, v10, v8, buf, v11);
    }
    return 0;
  }
  int v3 = OpenRows;
  if (OpenRows)
  {
    MTDeviceGetDeviceID();
    CFTypeID v12 = MTLoggingPlugin();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)CFStringRef v14 = v3;
      *(_WORD *)&v14[4] = 2048;
      *(void *)&v14[6] = 0;
      CFStringRef v8 = "Couldn't read open rows: error 0x%08X (deviceID 0x%llX)";
      CFTimeZoneRef v9 = v12;
      os_log_type_t v10 = OS_LOG_TYPE_ERROR;
      uint32_t v11 = 18;
      goto LABEL_10;
    }
    return 0;
  }
  MTDeviceGetDeviceID();
  uint64_t v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = *((void *)this + 262);
    *(_DWORD *)buf = 134218496;
    *(void *)CFStringRef v14 = 0;
    *(_WORD *)&v14[8] = 2048;
    *(void *)&v14[10] = v5;
    __int16 v15 = 2048;
    uint64_t v16 = 0;
    _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_DEBUG, "Open rows collected: current 0x%016llX, previous 0x%016llX (deviceID 0x%llX)", buf, 0x20u);
  }
  *((void *)this + 262) = *((void *)this + 262);
  return 1;
}

void MTSimpleEventDispatcher::dispatchEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  if (a2 && *(void *)(a1 + 24) && *(void *)(a1 + 16))
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 56))(a1);
    MTDeviceGetDeviceID();
    int Type = IOHIDEventGetType();
    CFArrayRef Children = (const __CFArray *)IOHIDEventGetChildren();
    if (Children) {
      CFIndex Count = CFArrayGetCount(Children);
    }
    else {
      CFIndex Count = 0;
    }
    if (Type == 11 && ((IOHIDEventGetIntegerValue() & 2) != 0 || (IOHIDEventGetIntegerValue() & 0x80) != 0))
    {
      MTDeviceGetDeviceID();
      CFTimeZoneRef v9 = MTLoggingPlugin();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134219520;
        uint64_t v17 = Count;
        __int16 v18 = 2048;
        Integeruint64_t Value = IOHIDEventGetIntegerValue();
        __int16 v20 = 2048;
        *(void *)long long v21 = IOHIDEventGetIntegerValue();
        *(_WORD *)&v21[8] = 1024;
        *(_DWORD *)&v21[10] = (IOHIDEventGetIntegerValue() >> 7) & 1;
        __int16 v22 = 1024;
        BOOL v23 = IOHIDEventGetIntegerValue() == 1;
        __int16 v24 = 1024;
        BOOL v25 = IOHIDEventGetIntegerValue() == 1;
        __int16 v26 = 2048;
        uint64_t v27 = 0;
        _os_log_impl(&dword_2406FB000, v9, OS_LOG_TYPE_DEFAULT, "Dispatching event with %ld children, _eventMask=0x%lx _childEventMask=0x%lx Cancel=%d Touching=%d inRange=%d (deviceID 0x%llX)", buf, 0x3Cu);
      }
    }
    uint64_t v10 = mach_continuous_time();
    uint64_t v11 = *(void *)(a1 + 32);
    uint64_t v12 = *(void *)(a1 + 40);
    int v13 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 24);
    uint64_t HIDService = MTSimpleHIDManager::getHIDService(*(MultitouchHIDClass ***)(a1 + 16));
    v13(v11, v12, HIDService, a2, a3);
    __int16 v15 = MTLoggingPlugin();
    if (os_signpost_enabled(v15))
    {
      *(_DWORD *)buf = 134349824;
      uint64_t v17 = v10;
      __int16 v18 = 2048;
      Integeruint64_t Value = 0;
      __int16 v20 = 1024;
      *(_DWORD *)long long v21 = Type;
      *(_WORD *)&v21[4] = 2048;
      *(void *)&v21[6] = Count;
      _os_signpost_emit_with_name_impl(&dword_2406FB000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Multitouch Event Dispatch", "%{public, signpost.description:begin_time}llu mtDeviceID=%llu eventType=%u children=%lu", buf, 0x26u);
    }
  }
}

uint64_t MultitouchHIDClass::_copyProperty(MultitouchHIDClass *this, void *a2, const __CFString *a3)
{
  return (*(uint64_t (**)(void, void *))(**((void **)this + 1) + 80))(*((void *)this + 1), a2);
}

uint64_t MTSimpleHIDManager::handleNotificationEvent(unsigned __int8 *a1, uint64_t a2, int a3)
{
  uint64_t v4 = 0;
  uint64_t v36 = *MEMORY[0x263EF8340];
  if (a3 <= 102)
  {
    if (a3 > 0x66)
    {
      switch(a3)
      {
        case 26:
          int v5 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)a1 + 344))(a1);
          if (a1[121] == v5) {
            return 1;
          }
          a1[121] = v5;
          if (!v5) {
            return 1;
          }
          goto LABEL_14;
        case 32:
          mach_absolute_time();
          uint64_t VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
          if (VendorDefinedEvent) {
            goto LABEL_47;
          }
          return 1;
        case 33:
          if (!a1[123]) {
            return 0;
          }
          uint64_t v4 = 1;
          __int16 v29 = (void *)MEMORY[0x263EFFB40];
          a1[124] = 1;
          (*(void (**)(unsigned __int8 *, __CFString *, void))(*(void *)a1 + 568))(a1, @"FilteredClientsAvailable", *v29);
          if (!a1[125])
          {
            a1[125] = 1;
            (*(void (**)(unsigned __int8 *))(*(void *)a1 + 80))(a1);
            MTRegisterFullFrameCallback();
          }
          return v4;
        case 34:
          if (!a1[123]) {
            return 0;
          }
          int v30 = (void *)MEMORY[0x263EFFB38];
          a1[124] = 0;
          (*(void (**)(unsigned __int8 *, __CFString *, void))(*(void *)a1 + 568))(a1, @"FilteredClientsAvailable", *v30);
          if (a1[125])
          {
            a1[125] = 0;
            (*(void (**)(unsigned __int8 *))(*(void *)a1 + 80))(a1);
            MTUnregisterFullFrameCallback();
          }
          break;
        default:
          return v4;
      }
      return 1;
    }
    switch(a3)
    {
      case 2:
LABEL_14:
        uint64_t v4 = 1;
        (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)a1 + 592))(a1, 1);
        return v4;
      case 3:
      case 4:
      case 7:
        return v4;
      case 5:
        (*(void (**)(unsigned __int8 *))(*(void *)a1 + 264))(a1);
        CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
        mach_absolute_time();
        uint64_t v9 = IOHIDEventCreateVendorDefinedEvent();
        if (v9)
        {
          uint64_t v10 = (const void *)v9;
          (*(void (**)(unsigned __int8 *, uint64_t, void))(*(void *)a1 + 136))(a1, v9, 0);
          CFRelease(v10);
        }
        (*(void (**)(unsigned __int8 *))(*(void *)a1 + 80))(a1);
        io_registry_entry_t Service = MTDeviceGetService();
        *(void *)buf = 0;
        CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(Service, @"QueryIOReporterOnBoot", v8, 0);
        if (CFProperty)
        {
          int v13 = CFProperty;
          CFTypeID v14 = CFGetTypeID(CFProperty);
          CFTypeID TypeID = CFBooleanGetTypeID();
          uint64_t v16 = (const void *)*MEMORY[0x263EFFB40];
          CFRelease(v13);
          if (v14 == TypeID && v13 == v16)
          {
            uint64_t v18 = IOReportCopyChannelsForDriver();
            if (v18)
            {
              int v19 = (const void *)v18;
              if (IOReportGetChannelCount()
                && (IOReportPrune() & 1) == 0
                && IOReportGetChannelCount())
              {
                Subscription = (const void *)IOReportCreateSubscription();
              }
              else
              {
                Subscription = 0;
              }
              CFRelease(v19);
              if (Subscription) {
                CFRelease(Subscription);
              }
            }
          }
        }
        return 1;
      case 6:
        long long v21 = MTLoggingPlugin();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = "";
          __int16 v32 = 2080;
          long long v33 = "MTSimpleHIDManager::";
          __int16 v34 = 2080;
          long long v35 = "handleNotificationEvent";
          _os_log_impl(&dword_2406FB000, v21, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s device killed", buf, 0x20u);
        }
        return 1;
      case 8:
        uint64_t v22 = 128;
        if (!a1[122]) {
          uint64_t v22 = 192;
        }
        if (*(_DWORD *)&a1[v22] != 255) {
          (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)a1 + 592))(a1, 1);
        }
        mach_absolute_time();
        uint64_t v4 = 1;
        uint64_t v23 = IOHIDEventCreateVendorDefinedEvent();
        if (!v23) {
          return v4;
        }
        __int16 v24 = (const void *)v23;
        (*(void (**)(unsigned __int8 *, uint64_t, void))(*(void *)a1 + 136))(a1, v23, 0);
        BOOL v25 = v24;
        break;
      default:
        JUMPOUT(0);
    }
LABEL_48:
    CFRelease(v25);
    return 1;
  }
  if (a3 > 331)
  {
    if (a3 == 332)
    {
      (*(void (**)(unsigned __int8 *))(*(void *)a1 + 272))(a1);
      return 1;
    }
    if (a3 == 333)
    {
      a1[127] = 1;
      CFAllocatorRef v6 = MTLoggingPlugin();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        *(void *)&uint8_t buf[4] = "";
        __int16 v32 = 2080;
        long long v33 = "MTSimpleHIDManager::";
        __int16 v34 = 2080;
        long long v35 = "handleNotificationEvent";
        __int16 v7 = "[HID] [MT] %s%s%s Sending Touch System Ready notification";
        goto LABEL_42;
      }
LABEL_43:
      mach_absolute_time();
      uint64_t VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
      if (!VendorDefinedEvent) {
        return 1;
      }
LABEL_47:
      uint64_t v27 = (const void *)VendorDefinedEvent;
      (*(void (**)(unsigned __int8 *, uint64_t, void))(*(void *)a1 + 136))(a1, VendorDefinedEvent, 0);
      BOOL v25 = v27;
      goto LABEL_48;
    }
  }
  else
  {
    if (a3 == 103)
    {
      (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)a1 + 592))(a1, 1);
      a1[127] = 0;
      CFAllocatorRef v6 = MTLoggingPlugin();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        *(void *)&uint8_t buf[4] = "";
        __int16 v32 = 2080;
        long long v33 = "MTSimpleHIDManager::";
        __int16 v34 = 2080;
        long long v35 = "handleNotificationEvent";
        __int16 v7 = "[HID] [MT] %s%s%s Touch System Ready = false";
        goto LABEL_42;
      }
      goto LABEL_43;
    }
    if (a3 == 104)
    {
      uint64_t v4 = 1;
      (*(void (**)(unsigned __int8 *, uint64_t))(*(void *)a1 + 592))(a1, 1);
      (*(void (**)(unsigned __int8 *))(*(void *)a1 + 80))(a1);
      if ((MTDeviceSupportsTouchReadyNotification() & 1) == 0)
      {
        a1[127] = 1;
        CFAllocatorRef v6 = MTLoggingPlugin();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = "";
          __int16 v32 = 2080;
          long long v33 = "MTSimpleHIDManager::";
          __int16 v34 = 2080;
          long long v35 = "handleNotificationEvent";
          __int16 v7 = "[HID] [MT] %s%s%s Sending Touch System Ready notification on UI Unlock";
LABEL_42:
          _os_log_impl(&dword_2406FB000, v6, OS_LOG_TYPE_DEFAULT, v7, buf, 0x20u);
          goto LABEL_43;
        }
        goto LABEL_43;
      }
    }
  }
  return v4;
}

uint64_t MTLoggingPlugin()
{
  if (MTLoggingPlugin_onceToken != -1) {
    dispatch_once(&MTLoggingPlugin_onceToken, &__block_literal_global_4);
  }
  return MTLoggingPlugin___logObj;
}

uint64_t MTSimpleHIDManager::shouldRecordProperty(MTSimpleHIDManager *this, const __CFString *a2)
{
  return 1;
}

uint64_t MTSimpleHIDManager::getMTDevice(MTSimpleHIDManager *this)
{
  return *((void *)this + 3);
}

uint64_t MTSimpleHIDManager::propertyTypeFromString(uint64_t this, const __CFString *a2)
{
  if (this)
  {
    CFStringRef v2 = (const __CFString *)this;
    if (CFStringCompare((CFStringRef)this, @"PrimaryUsagePage", 0))
    {
      if (CFStringCompare(v2, @"PrimaryUsage", 0))
      {
        if (CFStringCompare(v2, @"PrintHIDEvents", 0))
        {
          if (CFStringCompare(v2, @"GraphicsOrientation", 0))
          {
            if (CFStringCompare(v2, @"TouchHand", 0))
            {
              if (CFStringCompare(v2, @"WristState", 0))
              {
                if (CFStringCompare(v2, @"EllipseTipGain", 0))
                {
                  if (CFStringCompare(v2, @"FingerTipOffsetUpwards", 0))
                  {
                    if (CFStringCompare(v2, @"FingerTipOffsetLeftwards", 0))
                    {
                      if (CFStringCompare(v2, @"HysteresisRadiusPixels", 0))
                      {
                        if (CFStringCompare(v2, @"CrownFilterRect", 0))
                        {
                          if (CFStringCompare(v2, @"InputDetectionMode", 0))
                          {
                            if (CFStringCompare(v2, @"CriticalErrors", 0))
                            {
                              if (CFStringCompare(v2, @"QuantizationDPI", 0))
                              {
                                if (CFStringCompare(v2, @"ReceiverProximityReset", 0))
                                {
                                  if (CFStringCompare(v2, @"MuonEnabled", 0))
                                  {
                                    if (CFStringCompare(v2, @"NotificationCenterGestureMode", 0))
                                    {
                                      if (CFStringCompare(v2, @"NotificationCenterAltGestureMode", 0))
                                      {
                                        if (CFStringCompare(v2, @"DeviceUsagePairs", 0))
                                        {
                                          if (CFStringCompare(v2, @"Built-In", 0))
                                          {
                                            if (CFStringCompare(v2, @"DisplayIntegrated", 0))
                                            {
                                              if (CFStringCompare(v2, @"PhysicalDeviceUniqueID", 0))
                                              {
                                                if (CFStringCompare(v2, @"DeviceIsReady", 0))
                                                {
                                                  if (CFStringCompare(v2, @"MotionActivityInterested", 0))
                                                  {
                                                    if (CFStringCompare(v2, @"MotionActivityDispatch", 0))
                                                    {
                                                      if (CFStringCompare(v2, @"CopyAllProperties", 0))
                                                      {
                                                        if (CFStringCompare(v2, @"AppKitActuateWithID", 0))
                                                        {
                                                          if (CFStringCompare(v2, @"MTGestureConfiguration", 0))
                                                          {
                                                            if (CFStringCompare(v2, @"MTGestureConfigurationOverride", 0))
                                                            {
                                                              if (CFStringCompare(v2, @"ReloadActuations", 0))
                                                              {
                                                                if (CFStringCompare(v2, @"SendClickThresholdInfo", 0))
                                                                {
                                                                  if (CFStringCompare(v2, @"DisableClickWaveformAdaptation", 0))
                                                                  {
                                                                    if (CFStringCompare(v2, @"DisableForceThresholdAdaptation", 0))
                                                                    {
                                                                      if (CFStringCompare(v2, @"FlipLeftAndRightEdgeGestures", 0))
                                                                      {
                                                                        if (CFStringCompare(v2, @"ScrollMomentumDispatchRate", 0))
                                                                        {
                                                                          if (CFStringCompare(v2, @"ExternalMessage", 0))
                                                                          {
                                                                            if (CFStringCompare(v2, @"MaxDigitizerPressureValue", 0))
                                                                            {
                                                                              if (CFStringCompare(v2, @"MinDigitizerPressureValue", 0))
                                                                              {
                                                                                if (CFStringCompare(v2, @"AccurateMaxDigitizerPressureValue", 0))
                                                                                {
                                                                                  if (CFStringCompare(v2, @"ExtendedMaxDigitizerPressureValue", 0))
                                                                                  {
                                                                                    if (CFStringCompare(v2, @"DigitizerPressureDynamicRange", 0))
                                                                                    {
                                                                                      if (CFStringCompare(v2, @"TouchDetectionMode", 0))
                                                                                      {
                                                                                        if (CFStringCompare(v2, @"HIDScrollAccelerationType", 0))
                                                                                        {
                                                                                          if (CFStringCompare(v2, @"HIDPointerAccelerationType", 0))
                                                                                          {
                                                                                            if (CFStringCompare(v2, @"HIDAccelCurves", 0))
                                                                                            {
                                                                                              if (CFStringCompare(v2, @"HIDPointerReportRate", 0))
                                                                                              {
                                                                                                if (CFStringCompare(v2, @"HIDScrollAccelCurves", 0))
                                                                                                {
                                                                                                  if (CFStringCompare(v2, @"HIDScrollResolution", 0))
                                                                                                  {
                                                                                                    if (CFStringCompare(v2, @"HIDScrollAccelerationTable", 0))
                                                                                                    {
                                                                                                      if (CFStringCompare(v2, @"HIDPointerAccelerationTable", 0))
                                                                                                      {
                                                                                                        if (CFStringCompare(v2, @"HIDPointerResolution", 0))
                                                                                                        {
                                                                                                          if (CFStringCompare(v2, @"HIDPointerAccelerationTargetRateUs", 0))
                                                                                                          {
                                                                                                            if (CFStringCompare(v2, @"HIDTrackpadAcceleration", 0))
                                                                                                            {
                                                                                                              if (CFStringCompare(v2, @"HIDTrackpadScrollAcceleration", 0))
                                                                                                              {
                                                                                                                if (CFStringCompare(v2, @"HIDMouseScrollAcceleration", 0))
                                                                                                                {
                                                                                                                  if (CFStringCompare(v2, @"HIDDisallowRemappingOfPrimaryClick", 0))
                                                                                                                  {
                                                                                                                    if (CFStringCompare(v2, @"SupportsGestureScrolling", 0))
                                                                                                                    {
                                                                                                                      if (CFStringCompare(v2, @"MTEventSource", 0))
                                                                                                                      {
                                                                                                                        if (CFStringCompare(v2, @"Transport", 0))
                                                                                                                        {
                                                                                                                          if (CFStringCompare(v2, @"VendorID", 0))
                                                                                                                          {
                                                                                                                            if (CFStringCompare(v2, @"VendorIDSource", 0))
                                                                                                                            {
                                                                                                                              if (CFStringCompare(v2, @"ProductID", 0))
                                                                                                                              {
                                                                                                                                if (CFStringCompare(v2, @"VersionNumber", 0))
                                                                                                                                {
                                                                                                                                  if (CFStringCompare(v2, @"Manufacturer", 0))
                                                                                                                                  {
                                                                                                                                    if (CFStringCompare(v2, @"Product", 0))
                                                                                                                                    {
                                                                                                                                      if (CFStringCompare(v2, @"LocationID", 0))
                                                                                                                                      {
                                                                                                                                        if (CFStringCompare(v2, @"CountryCode", 0))
                                                                                                                                        {
                                                                                                                                          if (CFStringCompare(v2, @"SerialNumber", 0))
                                                                                                                                          {
                                                                                                                                            if (CFStringCompare(v2, @"ReportInterval", 0))
                                                                                                                                            {
                                                                                                                                              if (CFStringCompare(v2, @"DispatchAllHIDEvents", 0))
                                                                                                                                              {
                                                                                                                                                if (CFStringCompare(v2, @"ServicePluginDebug", 0))
                                                                                                                                                {
                                                                                                                                                  if (CFStringCompare(v2, @"FilteredClientsAvailable", 0))
                                                                                                                                                  {
                                                                                                                                                    if (CFStringCompare(v2, @"MTModeSwitcherDebugProfile", 0))
                                                                                                                                                    {
                                                                                                                                                      if (CFStringCompare(v2, @"SupportedGestures", 0))
                                                                                                                                                      {
                                                                                                                                                        if (CFStringCompare(v2, @"SurfaceDimensions", 0))
                                                                                                                                                        {
                                                                                                                                                          if (CFStringCompare(v2, @"DeviceTypeHint", 0))
                                                                                                                                                          {
                                                                                                                                                            if (CFStringCompare(v2, @"NeedsHostState", 0))
                                                                                                                                                            {
                                                                                                                                                              if (CFStringCompare(v2, @"HostStateNotification", 0))
                                                                                                                                                              {
                                                                                                                                                                if (CFStringCompare(v2, @"HIDPointerAccelerationMultiplier", 0))
                                                                                                                                                                {
                                                                                                                                                                  if (CFStringCompare(v2, @"DeviceOpenedByEventSystem", 0))
                                                                                                                                                                  {
                                                                                                                                                                    if (CFStringCompare(v2, @"MouseButtonMode", 0))
                                                                                                                                                                    {
                                                                                                                                                                      if (CFStringCompare(v2, @"HIDScrollReportRate", 0))
                                                                                                                                                                      {
                                                                                                                                                                        if (CFStringCompare(v2, @"MaxHoverHeight", 0))
                                                                                                                                                                        {
                                                                                                                                                                          if (CFStringCompare(v2, @"HoverDisabled", 0)) {
                                                                                                                                                                            return 0;
                                                                                                                                                                          }
                                                                                                                                                                          else {
                                                                                                                                                                            return 86;
                                                                                                                                                                          }
                                                                                                                                                                        }
                                                                                                                                                                        else
                                                                                                                                                                        {
                                                                                                                                                                          return 85;
                                                                                                                                                                        }
                                                                                                                                                                      }
                                                                                                                                                                      else
                                                                                                                                                                      {
                                                                                                                                                                        return 84;
                                                                                                                                                                      }
                                                                                                                                                                    }
                                                                                                                                                                    else
                                                                                                                                                                    {
                                                                                                                                                                      return 83;
                                                                                                                                                                    }
                                                                                                                                                                  }
                                                                                                                                                                  else
                                                                                                                                                                  {
                                                                                                                                                                    return 82;
                                                                                                                                                                  }
                                                                                                                                                                }
                                                                                                                                                                else
                                                                                                                                                                {
                                                                                                                                                                  return 81;
                                                                                                                                                                }
                                                                                                                                                              }
                                                                                                                                                              else
                                                                                                                                                              {
                                                                                                                                                                return 80;
                                                                                                                                                              }
                                                                                                                                                            }
                                                                                                                                                            else
                                                                                                                                                            {
                                                                                                                                                              return 79;
                                                                                                                                                            }
                                                                                                                                                          }
                                                                                                                                                          else
                                                                                                                                                          {
                                                                                                                                                            return 78;
                                                                                                                                                          }
                                                                                                                                                        }
                                                                                                                                                        else
                                                                                                                                                        {
                                                                                                                                                          return 77;
                                                                                                                                                        }
                                                                                                                                                      }
                                                                                                                                                      else
                                                                                                                                                      {
                                                                                                                                                        return 76;
                                                                                                                                                      }
                                                                                                                                                    }
                                                                                                                                                    else
                                                                                                                                                    {
                                                                                                                                                      return 75;
                                                                                                                                                    }
                                                                                                                                                  }
                                                                                                                                                  else
                                                                                                                                                  {
                                                                                                                                                    return 74;
                                                                                                                                                  }
                                                                                                                                                }
                                                                                                                                                else
                                                                                                                                                {
                                                                                                                                                  return 73;
                                                                                                                                                }
                                                                                                                                              }
                                                                                                                                              else
                                                                                                                                              {
                                                                                                                                                return 72;
                                                                                                                                              }
                                                                                                                                            }
                                                                                                                                            else
                                                                                                                                            {
                                                                                                                                              return 69;
                                                                                                                                            }
                                                                                                                                          }
                                                                                                                                          else
                                                                                                                                          {
                                                                                                                                            return 68;
                                                                                                                                          }
                                                                                                                                        }
                                                                                                                                        else
                                                                                                                                        {
                                                                                                                                          return 67;
                                                                                                                                        }
                                                                                                                                      }
                                                                                                                                      else
                                                                                                                                      {
                                                                                                                                        return 66;
                                                                                                                                      }
                                                                                                                                    }
                                                                                                                                    else
                                                                                                                                    {
                                                                                                                                      return 65;
                                                                                                                                    }
                                                                                                                                  }
                                                                                                                                  else
                                                                                                                                  {
                                                                                                                                    return 64;
                                                                                                                                  }
                                                                                                                                }
                                                                                                                                else
                                                                                                                                {
                                                                                                                                  return 63;
                                                                                                                                }
                                                                                                                              }
                                                                                                                              else
                                                                                                                              {
                                                                                                                                return 62;
                                                                                                                              }
                                                                                                                            }
                                                                                                                            else
                                                                                                                            {
                                                                                                                              return 61;
                                                                                                                            }
                                                                                                                          }
                                                                                                                          else
                                                                                                                          {
                                                                                                                            return 60;
                                                                                                                          }
                                                                                                                        }
                                                                                                                        else
                                                                                                                        {
                                                                                                                          return 59;
                                                                                                                        }
                                                                                                                      }
                                                                                                                      else
                                                                                                                      {
                                                                                                                        return 70;
                                                                                                                      }
                                                                                                                    }
                                                                                                                    else
                                                                                                                    {
                                                                                                                      return 58;
                                                                                                                    }
                                                                                                                  }
                                                                                                                  else
                                                                                                                  {
                                                                                                                    return 57;
                                                                                                                  }
                                                                                                                }
                                                                                                                else
                                                                                                                {
                                                                                                                  return 55;
                                                                                                                }
                                                                                                              }
                                                                                                              else
                                                                                                              {
                                                                                                                return 56;
                                                                                                              }
                                                                                                            }
                                                                                                            else
                                                                                                            {
                                                                                                              return 47;
                                                                                                            }
                                                                                                          }
                                                                                                          else
                                                                                                          {
                                                                                                            return 46;
                                                                                                          }
                                                                                                        }
                                                                                                        else
                                                                                                        {
                                                                                                          return 54;
                                                                                                        }
                                                                                                      }
                                                                                                      else
                                                                                                      {
                                                                                                        return 53;
                                                                                                      }
                                                                                                    }
                                                                                                    else
                                                                                                    {
                                                                                                      return 52;
                                                                                                    }
                                                                                                  }
                                                                                                  else
                                                                                                  {
                                                                                                    return 51;
                                                                                                  }
                                                                                                }
                                                                                                else
                                                                                                {
                                                                                                  return 50;
                                                                                                }
                                                                                              }
                                                                                              else
                                                                                              {
                                                                                                return 49;
                                                                                              }
                                                                                            }
                                                                                            else
                                                                                            {
                                                                                              return 48;
                                                                                            }
                                                                                          }
                                                                                          else
                                                                                          {
                                                                                            return 45;
                                                                                          }
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                          return 44;
                                                                                        }
                                                                                      }
                                                                                      else
                                                                                      {
                                                                                        return 43;
                                                                                      }
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                      return 42;
                                                                                    }
                                                                                  }
                                                                                  else
                                                                                  {
                                                                                    return 41;
                                                                                  }
                                                                                }
                                                                                else
                                                                                {
                                                                                  return 40;
                                                                                }
                                                                              }
                                                                              else
                                                                              {
                                                                                return 39;
                                                                              }
                                                                            }
                                                                            else
                                                                            {
                                                                              return 38;
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            return 37;
                                                                          }
                                                                        }
                                                                        else
                                                                        {
                                                                          return 17;
                                                                        }
                                                                      }
                                                                      else
                                                                      {
                                                                        return 34;
                                                                      }
                                                                    }
                                                                    else
                                                                    {
                                                                      return 33;
                                                                    }
                                                                  }
                                                                  else
                                                                  {
                                                                    return 32;
                                                                  }
                                                                }
                                                                else
                                                                {
                                                                  return 31;
                                                                }
                                                              }
                                                              else
                                                              {
                                                                return 30;
                                                              }
                                                            }
                                                            else
                                                            {
                                                              return 29;
                                                            }
                                                          }
                                                          else
                                                          {
                                                            return 28;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          return 27;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        return 26;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      return 36;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    return 35;
                                                  }
                                                }
                                                else
                                                {
                                                  return 25;
                                                }
                                              }
                                              else
                                              {
                                                return 6;
                                              }
                                            }
                                            else
                                            {
                                              return 5;
                                            }
                                          }
                                          else
                                          {
                                            return 4;
                                          }
                                        }
                                        else
                                        {
                                          return 3;
                                        }
                                      }
                                      else
                                      {
                                        return 23;
                                      }
                                    }
                                    else
                                    {
                                      return 22;
                                    }
                                  }
                                  else
                                  {
                                    return 21;
                                  }
                                }
                                else
                                {
                                  return 20;
                                }
                              }
                              else
                              {
                                return 19;
                              }
                            }
                            else
                            {
                              return 24;
                            }
                          }
                          else
                          {
                            return 18;
                          }
                        }
                        else
                        {
                          return 16;
                        }
                      }
                      else
                      {
                        return 15;
                      }
                    }
                    else
                    {
                      return 14;
                    }
                  }
                  else
                  {
                    return 13;
                  }
                }
                else
                {
                  return 12;
                }
              }
              else
              {
                return 11;
              }
            }
            else
            {
              return 10;
            }
          }
          else
          {
            return 9;
          }
        }
        else
        {
          return 7;
        }
      }
      else
      {
        return 2;
      }
    }
    else
    {
      return 1;
    }
  }
  return this;
}

uint64_t MTSimpleEmbeddedHIDManager::setPropertyInternal(uint64_t *a1, int a2, CFTypeRef cf, int a4)
{
  if (cf)
  {
    CFTypeID v8 = CFGetTypeID(cf);
    BOOL v9 = v8 == CFNumberGetTypeID();
  }
  else
  {
    BOOL v9 = 0;
  }
  if (a2 == 15)
  {
    double v15 = 0.0;
    if (v9 && CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, &v15))
    {
      float v13 = v15;
      *(float *)(*(void *)(a1[26] + 64) + 104) = v13;
      return 1;
    }
  }
  else if (a2 == 19)
  {
    int valuePtr = 0;
    if (v9)
    {
      if (CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, &valuePtr))
      {
        if ((*(uint64_t (**)(uint64_t *))(*a1 + 624))(a1))
        {
          uint64_t v10 = (MTParser *)(*(uint64_t (**)(uint64_t *))(*a1 + 624))(a1);
          LODWORD(v1MTHandMotion::clearHandMotion(this, 1) = valuePtr;
          double v12 = 25.4 / (double)v11;
          *(float *)&double v12 = v12;
          MTParser::updatePixelResolution_mm(v10, v12);
        }
        return 1;
      }
    }
  }
  return MTSimpleHIDManager::setPropertyInternal(a1, a2, cf, a4);
}

uint64_t MTSimpleEventDispatcher::handleEvent(void *a1, uint64_t a2, uint64_t a3)
{
  a1[7] = a2;
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 32))(a1);
  if (result) {
    uint64_t result = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*a1 + 40))(a1, a2, a3);
  }
  a1[7] = 0;
  return result;
}

void MTPathStates::clear(MTPathStates *this)
{
  if ((*((_DWORD *)this + 6) - 1000) <= 0xBB7)
  {
    *((_WORD *)this + 186) = 0;
    *((_DWORD *)this + 107) = 0;
    *((unsigned char *)this + 444) = 0;
    *((unsigned char *)this + 492) = 0;
    *((_DWORD *)this + 102) = 0;
    *(_OWORD *)((char *)this + 376) = 0u;
    *(_OWORD *)((char *)this + 392) = 0u;
    *((void *)this + 52) = 0;
    *((unsigned char *)this + 424) = 0;
    *((_OWORD *)this + 28) = 0u;
    *((_OWORD *)this + 29) = 0u;
    *((void *)this + 60) = 0;
    *((_DWORD *)this + 122) = 0;
    *((void *)this + 63) = 0;
    *((void *)this + 64) = 0;
    *((void *)this + 62) = 0x7FF0000000000000;
    MTRestZoneIntegrator::clear((float32x2_t *)this + 65);
  }
  *((_DWORD *)this + 92) = 0;
}

uint64_t MTPathStatesBasic::unpackContactFrame(double *a1, uint64_t a2, uint64_t a3, double a4)
{
  uint64_t v7 = *((void *)a1 + 1);
  a1[1] = a4;
  *((void *)a1 + 2) = v7;
  MTPathStatesBasic::clearExistingPathLiftoffsAndMasks((MTPathStatesBasic *)a1);
  if (a2) {
    MTPathStatesBasic::expandAndFilterPackedContacts((uint64_t)a1, a2, a3);
  }

  return MTPathStatesBasic::flushStuckContacts((MTPathStatesBasic *)a1);
}

uint64_t MTForceManagerLite::clearState(uint64_t this)
{
  *(unsigned char *)(this + MTHandMotion::clearHandMotion(this, 1) = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  return this;
}

uint64_t MTParser::clear(void *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v7 = a1[6];
  if (v7)
  {
    MTAbsoluteTimeGetCurrent();
    *(void *)(v7 + 40) = v8;
  }
  if (a2 && a3) {
    MTParser::handleContactFrame((uint64_t)a1, 0, 0, 0.0, a4, a2, a3, 0);
  }
  BOOL v9 = (MTHandStatistics *)a1[6];
  if (v9) {
    MTHandStatistics::clear(v9, 0);
  }
  uint64_t v10 = (MTHandMotion *)a1[7];
  if (v10) {
    MTHandMotion::clear(v10);
  }
  uint64_t v11 = a1[8];
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 16))(v11);
  }
  uint64_t v12 = a1[25];
  if (v12) {
    MTForceManagement::clearState(v12, 0);
  }
  uint64_t v13 = a1[27];
  if (v13) {
    MTForceManagerLite::clearState(v13);
  }
  CFTypeID v14 = (MTEmbeddedStats *)a1[28];
  if (v14) {
    MTEmbeddedStats::resetTouchState(v14);
  }
  uint64_t v15 = a1[9];
  if (v15)
  {
    uint64_t ChordTableForHand = MTGestureConfig::getChordTableForHand(v15, 1);
    if (ChordTableForHand) {
      (*(void (**)(uint64_t))(*(void *)ChordTableForHand + 16))(ChordTableForHand);
    }
  }

  return MTTapDragManager::clearState((uint64_t)(a1 + 10));
}

uint64_t MTSimpleHIDManager::setPowerStateWithReset(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  if (*(void *)(a1 + 112)) {
    MTSimpleHIDManager::setPowerStateWithReset();
  }
  CFAllocatorRef v6 = MTLoggingPlugin();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 2) {
      uint64_t v7 = "<UNKNOWN>";
    }
    else {
      uint64_t v7 = off_2650D3550[(int)a2];
    }
    *(_DWORD *)buf = 136316418;
    uint64_t v23 = "";
    __int16 v24 = 2080;
    BOOL v25 = "MTSimpleHIDManager::";
    __int16 v26 = 2080;
    uint64_t v27 = "setPowerStateWithReset";
    __int16 v28 = 1024;
    *(_DWORD *)__int16 v29 = a2;
    *(_WORD *)&v29[4] = 2082;
    *(void *)&v29[6] = v7;
    __int16 v30 = 1024;
    int v31 = a3;
    _os_log_impl(&dword_2406FB000, v6, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s [powerState:%d(%{public}s), triggeredFromButton:%d]", buf, 0x36u);
  }
  if (a2 != 1
    || ((*(void (**)(uint64_t))(*(void *)a1 + 80))(a1), MTDevicePowerGetState() | 0xAAAAAAAA))
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 80))(a1);
    double v10 = *(double *)(a1 + 64);
    if (MTDeviceShouldResetOnButton()) {
      BOOL v11 = a3 == 0;
    }
    else {
      BOOL v11 = 0;
    }
    if (v11
      || (a2 != 2
        ? (unsigned int ResetOnLockMs = MTDeviceGetResetOnLockMs())
        : (unsigned int ResetOnLockMs = MTDeviceGetResetOnUnlockMs()),
          (double v13 = (double)ResetOnLockMs / 1000.0, MTAbsoluteTimeGetCurrent(), v15 = v14 - v10, v13 > 0.0)
        ? (BOOL v16 = v15 <= v13)
        : (BOOL v16 = 1),
          v16))
    {
      uint64_t v17 = MTLoggingPlugin();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        uint64_t v23 = "";
        __int16 v24 = 2080;
        BOOL v25 = "MTSimpleHIDManager::";
        __int16 v26 = 2080;
        uint64_t v27 = "setPowerStateWithReset";
        _os_log_impl(&dword_2406FB000, v17, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Setting device power without reset", buf, 0x20u);
      }
      return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 408))(a1, a2, 0);
    }
    else
    {
      uint64_t v18 = MTLoggingPlugin();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        if (a2 > 2) {
          __int16 v20 = "<UNKNOWN>";
        }
        else {
          __int16 v20 = off_2650D3550[(int)a2];
        }
        *(_DWORD *)buf = 136315906;
        uint64_t v23 = "";
        __int16 v24 = 2080;
        BOOL v25 = "MTSimpleHIDManager::";
        __int16 v26 = 2080;
        uint64_t v27 = "setPowerStateWithReset";
        __int16 v28 = 2082;
        *(void *)__int16 v29 = v20;
        _os_log_impl(&dword_2406FB000, v18, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Resetting device before setting power state to %{public}s", buf, 0x2Au);
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 480))(a1, 30);
      MTAbsoluteTimeGetCurrent();
      *(void *)(a1 + 64) = v21;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 408))(a1, a2, 1);
      return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 424))(a1);
    }
  }
  else
  {
    uint64_t v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      uint64_t v23 = "";
      __int16 v24 = 2080;
      BOOL v25 = "MTSimpleHIDManager::";
      __int16 v26 = 2080;
      uint64_t v27 = "setPowerStateWithReset";
      _os_log_impl(&dword_2406FB000, v8, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Turning on and waiting for the device to be ready before going to sleep.", buf, 0x20u);
    }
    return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 408))(a1, 2, 0);
  }
}

uint64_t MTParser::deviceWillReset(MTEmbeddedStatsImpl ***this)
{
  return MTEmbeddedStats::deviceWillReset(this[28]);
}

uint64_t MTSimpleHIDManager::restoreDevicePropertiesToDevice(MTSimpleHIDManager *this)
{
  if (*((unsigned char *)this + 122)) {
    CFStringRef v2 = @"InputDetectionMode";
  }
  else {
    CFStringRef v2 = @"TouchDetectionMode";
  }
  int v3 = (const void *)(*(uint64_t (**)(MTSimpleHIDManager *, __CFString *))(*(void *)this + 560))(this, v2);
  (*(void (**)(MTSimpleHIDManager *, __CFString *, const void *, uint64_t))(*(void *)this + 392))(this, v2, v3, 1);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)(*(uint64_t (**)(MTSimpleHIDManager *, __CFString *))(*(void *)this + 560))(this, @"GraphicsOrientation");
  (*(void (**)(MTSimpleHIDManager *, __CFString *, const void *, uint64_t))(*(void *)this + 392))(this, @"GraphicsOrientation", v4, 1);
  if (v4) {
    CFRelease(v4);
  }
  int v5 = (const void *)(*(uint64_t (**)(MTSimpleHIDManager *, __CFString *))(*(void *)this + 560))(this, @"WristState");
  (*(void (**)(MTSimpleHIDManager *, __CFString *, const void *, uint64_t))(*(void *)this + 392))(this, @"WristState", v5, 1);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t result = (*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)this + 368))(this);
  if ((*((unsigned char *)this + 160) & 0x20) != 0)
  {
    uint64_t v7 = *(uint64_t (**)(MTSimpleHIDManager *))(*(void *)this + 352);
    return v7(this);
  }
  return result;
}

uint64_t MTSimpleHIDManager::setTouchMode(MTSimpleHIDManager *this, int a2, int a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  uint64_t v6 = MTDeviceSetTouchMode();
  uint64_t v7 = v6;
  if (v6 != -536870201 && v6 != 0)
  {
    (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
    MTDeviceGetDeviceID();
    double v10 = MTLoggingPlugin();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67110146;
      int v13 = a2;
      __int16 v14 = 1024;
      int v15 = a3;
      __int16 v16 = 2082;
      uint64_t v17 = mach_error_string(v7);
      __int16 v18 = 1024;
      int v19 = v7;
      __int16 v20 = 2048;
      uint64_t v21 = 0;
      _os_log_impl(&dword_2406FB000, v10, OS_LOG_TYPE_ERROR, "Error trying to set mode to 0x%x and orientation to 0x%x: %{public}s (0x%x) (deviceID 0x%llX)", buf, 0x28u);
    }
  }
  return v7;
}

uint64_t MTSimpleHIDManager::deviceDidBootload(MTSimpleHIDManager *this)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  MTDeviceGetDeviceID();
  CFStringRef v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    uint64_t v8 = 0;
    _os_log_impl(&dword_2406FB000, v2, OS_LOG_TYPE_DEFAULT, "device bootloaded (deviceID 0x%llX)", buf, 0xCu);
  }
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 488))(this);
  (*(void (**)(MTSimpleHIDManager *, uint64_t))(*(void *)this + 592))(this, 1);
  *((void *)this + 18) = 0;
  *((unsigned char *)this + 152) = 0;
  MTAbsoluteTimeGetCurrent();
  *((void *)this + 8) = v3;
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 304))(this);
  uint64_t v4 = *((void *)this + 14);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  }
  else if (*((unsigned char *)this + 80))
  {
    (*(void (**)(MTSimpleHIDManager *, void, void))(*(void *)this + 408))(this, *((unsigned int *)this + 21), 0);
  }
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  if ((MTDeviceDriverIsReady() & 1) == 0)
  {
    int v5 = MTLoggingPlugin();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      uint64_t v8 = "";
      __int16 v9 = 2080;
      double v10 = "MTSimpleHIDManager::";
      __int16 v11 = 2080;
      uint64_t v12 = "deviceDidBootload";
      _os_log_impl(&dword_2406FB000, v5, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Driver is still not ready", buf, 0x20u);
    }
  }
  uint64_t result = (*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)this + 328))(this);
  if ((result & 1) == 0)
  {
    (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
    uint64_t result = MTDeviceDriverIsReady();
    if (result) {
      return (*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)this + 320))(this);
    }
  }
  return result;
}

__n128 MTSimpleEmbeddedHIDManager::copyTipOffsetParameters@<Q0>(MTSimpleEmbeddedHIDManager *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(*((void *)this + 26) + 64);
  long long v3 = *(_OWORD *)(v2 + 196);
  *(_OWORD *)a2 = *(_OWORD *)(v2 + 180);
  *(_OWORD *)(a2 + 16) = v3;
  __n128 result = *(__n128 *)(v2 + 212);
  long long v5 = *(_OWORD *)(v2 + 228);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v5;
  return result;
}

MTInterferenceMonitor *MTSimpleEmbeddedHIDManager::deviceDidBootload(MTInterferenceMonitor **this)
{
  MTSimpleHIDManager::deviceDidBootload((MTSimpleHIDManager *)this);
  __n128 result = this[27];
  if (result)
  {
    return (MTInterferenceMonitor *)MTInterferenceMonitor::restoreStateToDevice(result);
  }
  return result;
}

CFDictionaryRef MTSimpleEmbeddedHIDManager::copyProperty(MTSimpleEmbeddedHIDManager *this, const __CFString *a2)
{
  if (MTSimpleHIDManager::propertyTypeFromString((uint64_t)a2, a2) == 15)
  {
    double valuePtr = *(float *)(*(void *)(*((void *)this + 26) + 64) + 104);
    return CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberDoubleType, &valuePtr);
  }
  else
  {
    return MTSimpleHIDManager::copyProperty((CFDictionaryRef *)this, a2);
  }
}

uint64_t MTSimpleHIDManager::dispatchEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  IOHIDEventGetIntegerValue();
  IOHIDEventGetIntegerValue();
  IOHIDEventGetIntegerValue();
  IOHIDEventGetIntegerValue();
  CFArrayRef Children = (const __CFArray *)IOHIDEventGetChildren();
  if (Children) {
    CFArrayGetCount(Children);
  }
  IOHIDEventGetIntegerValue();
  kdebug_trace();
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 120))(a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, a2, a3);

  return kdebug_trace();
}

void ___ZN15MTEmbeddedStats15resetTouchStateEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  bzero((void *)(v1 + 24), 0x800uLL);
  *(_WORD *)(v1 + 16) = 0;
}

void MTSimpleEmbeddedHIDManager::resetGestureParser(MTSimpleEmbeddedHIDManager *this, int a2, uint64_t a3, uint64_t a4)
{
  if (a2)
  {
    CFTypeRef v7 = 0;
    CFTypeRef cf = 0;
    long long v5 = (void *)*((void *)this + 26);
    if (v5)
    {
      MTParser::clear(v5, (uint64_t)&cf, (uint64_t *)&v7, a4);
      if (cf)
      {
        (*(void (**)(MTSimpleEmbeddedHIDManager *, CFTypeRef, void))(*(void *)this + 136))(this, cf, 0);
        CFRelease(cf);
      }
      if (v7)
      {
        (*(void (**)(MTSimpleEmbeddedHIDManager *, CFTypeRef, void))(*(void *)this + 136))(this, v7, 0);
        CFRelease(v7);
      }
    }
  }
  else
  {
    uint64_t v6 = (void *)*((void *)this + 26);
    if (v6)
    {
      MTParser::clear(v6, 0, 0, a4);
    }
  }
}

void MTParser::handleContactFrame(uint64_t a1, uint64_t a2, uint64_t a3, double a4, uint64_t a5, uint64_t a6, uint64_t *a7, double *a8)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  if (!a6 || !a7 || !*(void *)(a1 + 64) || !*(void *)(a1 + 56) || !*(void *)(a1 + 48))
  {
    MTDeviceGetDeviceID();
    int v19 = MTLoggingPlugin();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v21 = *(void *)(a1 + 56);
      uint64_t v20 = *(void *)(a1 + 64);
      uint64_t v22 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 134219264;
      uint64_t v47 = a6;
      __int16 v48 = 2048;
      uint64_t v49 = a7;
      __int16 v50 = 2048;
      uint64_t v51 = v20;
      __int16 v52 = 2048;
      uint64_t v53 = v21;
      __int16 v54 = 2048;
      uint64_t v55 = v22;
      __int16 v56 = 2048;
      uint64_t v57 = 0;
      _os_log_impl(&dword_2406FB000, v19, OS_LOG_TYPE_DEBUG, "[HID] Aborting handling : %p %p %p %p %p (deviceID 0x%llX)", buf, 0x3Eu);
    }
LABEL_12:
    double v23 = 0.0;
    if (!a8) {
      return;
    }
    goto LABEL_13;
  }
  uint64_t v15 = *(void *)(a1 + 72);
  if (v15)
  {
    char hasTriggeredFluidDock = 1;
    uint64_t ChordTableForHand = (MTChordCycling *)MTGestureConfig::getChordTableForHand(v15, 1);
    __int16 v18 = ChordTableForHand;
    if (*(int *)(a1 + 104) <= 2)
    {
      if (ChordTableForHand) {
        char hasTriggeredFluidDock = MTChordCycling::hasTriggeredFluidDock(ChordTableForHand);
      }
      else {
        char hasTriggeredFluidDock = 0;
      }
    }
  }
  else
  {
    __int16 v18 = 0;
    char hasTriggeredFluidDock = *(_DWORD *)(a1 + 104) > 2;
  }
  uint64_t v24 = *(void *)(a1 + 64);
  if ((*(_DWORD *)(a1 + 32) - 1000) <= 0xBB7)
  {
    if (v18)
    {
      *(_DWORD *)(v24 + 416) = MTChordTable::getMinThumbSpecificFingerCount(v18);
      uint64_t v25 = *(void *)(a1 + 64);
      *(unsigned char *)(v25 + 412) = MTChordTable::hasTwoFingerOrientationEvents(v18);
      uint64_t v26 = *(void *)(a1 + 64);
      CommittedFingerCFIndex Count = MTChordCycling::getCommittedFingerCount(v18);
      uint64_t v24 = *(void *)(a1 + 64);
    }
    else
    {
      CommittedFingerCFIndex Count = 0;
      *(_DWORD *)(v24 + 416) = 0;
      *(unsigned char *)(v24 + 412) = 1;
      uint64_t v26 = v24;
    }
    *(_DWORD *)(v26 + 420) = CommittedFingerCount;
  }
  uint64_t v28 = *(void *)(a1 + 48);
  if (v28) {
    LODWORD(v28) = (__PAIR64__(*(unsigned __int8 *)(v28 + 186), *(unsigned __int8 *)(v28 + 195))
  }
                  - *(unsigned __int8 *)(v28 + 186)) >> 32;
  *(_DWORD *)(v24 + 368) = v28;
  __int16 v29 = *(MTForceManagement **)(a1 + 200);
  if (v29)
  {
    BOOL isForceButtonActivated = MTForceManagement::isForceButtonActivated(v29);
    MTPathStates::updateDragDisplacements_mm((MTPathStates *)v24, isForceButtonActivated);
    uint64_t v31 = *(void *)(a1 + 200);
    if (v18) {
      char v32 = MTChordCycling::shouldBlockClicks(v18, *(const MTHandStatistics **)(a1 + 48), *(const MTHandMotion **)(a1 + 56)) ^ 1;
    }
    else {
      char v32 = 1;
    }
    *(unsigned char *)(v31 + 592) = v32;
    uint64_t v24 = *(void *)(a1 + 64);
  }
  int v33 = MTPathStatesBasic::unpackContactFrame((double *)v24, a2, a3, a4);
  if (a2) {
    int v34 = 0;
  }
  else {
    int v34 = v33;
  }
  if (!MTHandStatistics::processHandState(*(MTHandStatistics **)(a1 + 48), *(MTPathStates **)(a1 + 64), v34, hasTriggeredFluidDock))goto LABEL_51; {
  if (v18)
  }
    int ActiveDegreesOfFreedomMask = MTChordIntegrating::getActiveDegreesOfFreedomMask((MTChordCycling *)((char *)v18 + 408), *(const MTHandStatistics **)(a1 + 48), v18);
  else {
    int ActiveDegreesOfFreedomMask = 0;
  }
  uint64_t v36 = *(void *)(a1 + 48);
  int v37 = *(unsigned __int8 *)(v36 + 191);
  if ((*(unsigned char *)(v36 + 168) & 0x20) != 0)
  {
    v37 += *(unsigned __int8 *)(v36 + 193);
    int v38 = *(unsigned __int8 *)(v36 + 188) + *(unsigned __int8 *)(v36 + 186);
    int v39 = *(unsigned __int8 *)(v36 + 189) + *(unsigned __int8 *)(v36 + 187);
  }
  else
  {
    int v38 = *(unsigned __int8 *)(v36 + 186);
    int v39 = *(unsigned __int8 *)(v36 + 187);
  }
  float v40 = a4 - *(double *)(v36 + 56);
  MTHandMotion::processHandMotion(*(float32x2_t **)(a1 + 56), *(const MTPathStates **)(a1 + 64), v37, v38, v39, v40, ActiveDegreesOfFreedomMask, *(unsigned __int16 *)(v36 + 296));
  uint64_t HIDCollectionEventsForHand = MTParser::createHIDCollectionEventsForHand((MTParser *)a1, *(const MTPathStates **)(a1 + 64), *(const MTHandStatistics **)(a1 + 48), *(const MTHandMotion **)(a1 + 56), *(_DWORD *)(*(void *)(a1 + 56) + 140) | *(_DWORD *)(*(void *)(a1 + 48) + 172), a4);
  *a7 = HIDCollectionEventsForHand;
  if (*(void *)(a1 + 224))
  {
    MTEmbeddedStats::handlePaths(*(MTEmbeddedStats **)(a1 + 224), *(const MTPathStates **)(a1 + 64));
    uint64_t HIDCollectionEventsForHand = *a7;
  }
  if (v18 && HIDCollectionEventsForHand)
  {
    if (a2) {
      BOOL v42 = 0;
    }
    else {
      BOOL v42 = (int)a3 < 1;
    }
    char v43 = v42;
    MTParser::handleForceHIDEvents(a1, a7, v43);
    (*(void (**)(MTChordCycling *, void, void, uint64_t))(*(void *)v18 + 32))(v18, *(void *)(a1 + 48), *(void *)(a1 + 56), *a7);
    if (*(int *)(a1 + 104) >= 1
      && *(unsigned __int8 *)(*(void *)(a1 + 48) + 211)
       + *(unsigned __int8 *)(*(void *)(a1 + 48) + 186) <= *(unsigned __int8 *)(a1 + 128))
    {
      goto LABEL_60;
    }
LABEL_51:
    uint64_t HIDCollectionEventsForHand = *a7;
  }
  if (HIDCollectionEventsForHand)
  {
    if (MTDeviceSupportsForce())
    {
      long long v44 = *(MTForceManagerLite **)(a1 + 216);
      if (v44) {
        MTForceManagerLite::updatePaths(v44, *(const MTPathStates **)(a1 + 64));
      }
    }
  }
  if (!*(void *)(a1 + 72)) {
    goto LABEL_12;
  }
  if (*a7) {
    goto LABEL_12;
  }
  uint64_t v45 = *(void *)(a1 + 48);
  if (*(unsigned char *)(v45 + 186))
  {
    if (*(unsigned __int8 *)(v45 + 211) + *(unsigned __int8 *)(v45 + 186) > *(unsigned __int8 *)(a1 + 128)) {
      goto LABEL_12;
    }
  }
LABEL_60:
  if (a8)
  {
    double v23 = MTParser::autoReleaseTapAndAHalfDrag((MTParser *)a1, a7, a4);
LABEL_13:
    *a8 = v23;
  }
}

void MTHandMotion::clearHandMotion(MTHandMotion *this, int a2)
{
  char v2 = a2;
  if (a2)
  {
    *((_DWORD *)this + 6MTHandMotion::clearHandMotion(this, 1) = 0;
    *((_DWORD *)this + 62) = 0;
    *((_OWORD *)this + 10) = 0u;
    *((_OWORD *)this + 1MTHandMotion::clearHandMotion(this, 1) = 0u;
  }
  *((_DWORD *)this + 35) = 0;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_DWORD *)this + 60) = 0;
  *(_OWORD *)((char *)this + 284) = 0u;
  *(_OWORD *)((char *)this + 300) = 0u;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)((char *)this + 252) = _Q0;
  *((_DWORD *)this + 67) = 1065353216;
  __asm { FMOV            V0.2S, #1.0 }
  *((void *)this + 34) = _Q0;
  *((unsigned char *)this + 280) = 0;
  *((_DWORD *)this + 29) = 0;
  *((unsigned char *)this + 376) = 0;
  *((void *)this + 46) = 0;
  MTFingerToPathMap::clearFingerPathMappings(this);
  uint64_t v8 = MTLoggingPlugin();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
    MTHandMotion::clearHandMotion(v2, v8);
  }
}

uint64_t MTForceConfigGetTypeID()
{
  uint64_t result = __kMTForceConfigTypeID;
  if (!__kMTForceConfigTypeID)
  {
    pthread_once(&__forceConfigTypeInit, (void (*)(void))__MTForceConfigRegister);
    return __kMTForceConfigTypeID;
  }
  return result;
}

uint64_t __MTForceConfigRegister()
{
  uint64_t result = _CFRuntimeRegisterClass();
  __kMTForceConfigCFTypeID TypeID = result;
  return result;
}

uint64_t MTForceConfigCreate(int a1, int a2)
{
  if (!__kMTForceConfigTypeID) {
    pthread_once(&__forceConfigTypeInit, (void (*)(void))__MTForceConfigRegister);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v6 = Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 16) = 1;
    *(_DWORD *)(Instance + 20) = a2;
    *(_DWORD *)(Instance + 24) = a1;
    *(unsigned char *)(Instance + 28) = 0;
    *(void *)(Instance + 160) = 0;
    *(void *)(Instance + 168) = 0;
    _MTForceConfigGenerateDefaultParams(Instance, v5);
  }
  return v6;
}

double _MTForceConfigGenerateDefaultParams(uint64_t a1, __n128 a2)
{
  switch(*(_DWORD *)(a1 + 24))
  {
    case 1:
      *(unsigned char *)(a1 + 29) = 2;
      goto LABEL_5;
    case 2:
      *(unsigned char *)(a1 + 29) = 2;
      *(_OWORD *)(a1 + 32) = xmmword_24074EDD0;
      a2 = (__n128)xmmword_24074EDE0;
      goto LABEL_7;
    case 5:
    case 0x10:
      *(unsigned char *)(a1 + 29) = 3;
      *(_OWORD *)(a1 + 32) = xmmword_24074EDA0;
      *(void *)(a1 + 48) = 0x437F000043960000;
      *(_OWORD *)(a1 + 96) = xmmword_24074EDB0;
      a2.n128_u64[0] = 0x500000006;
      *(void *)(a1 + 112) = 0x500000006;
      return a2.n128_f64[0];
    case 0xA:
    case 0xC:
      *(_WORD *)(a1 + 28) = 513;
LABEL_5:
      *(_OWORD *)(a1 + 32) = xmmword_24074EDA0;
      a2 = (__n128)xmmword_24074EDB0;
LABEL_7:
      *(__n128 *)(a1 + 96) = a2;
      break;
    case 0xB:
      *(_WORD *)(a1 + 28) = 513;
      a2.n128_u64[0] = 0;
      *(_OWORD *)(a1 + 32) = xmmword_24074EDC0;
      *(void *)(a1 + 96) = 0;
      *(void *)(a1 + 104) = 0;
      break;
    case 0x11:
      *(unsigned char *)(a1 + 29) = 3;
      *(_OWORD *)(a1 + 32) = xmmword_24074EDA0;
      *(void *)(a1 + 48) = 0x437F000043960000;
      *(_OWORD *)(a1 + 96) = xmmword_24074EDB0;
      a2.n128_u64[0] = 0x500000006;
      *(void *)(a1 + 112) = 0x500000006;
      *(unsigned char *)(a1 + 169) = 1;
      break;
    default:
      return a2.n128_f64[0];
  }
  return a2.n128_f64[0];
}

uint64_t MTForceConfigGetBehavior(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t MTForceConfigGetNumStages(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 29);
}

uint64_t MTForceConfigIsContinuous(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 28);
}

uint64_t MTForceConfigSetIsContinuous(uint64_t result, char a2)
{
  *(unsigned char *)(result + 28) = a2;
  return result;
}

BOOL MTForceConfigSetActuationsForStage(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int v3 = *(unsigned __int8 *)(a1 + 29);
  if (v3 > a2) {
    *(void *)(a1 + 8 * a2 + 96) = a3;
  }
  return v3 > a2;
}

uint64_t MTForceConfigGetActuationsForStage(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 8 * a2 + 96);
}

uint64_t MTForceConfigShouldSkipActivationForStage(uint64_t a1, unsigned int a2)
{
  return *(unsigned __int8 *)(a1 + a2 + 160);
}

uint64_t MTForceConfigShouldSkipReleaseForStage(uint64_t a1, unsigned int a2)
{
  return *(unsigned __int8 *)(a1 + a2 + 168);
}

float MTForceConfigGetThresholdsForStage(uint64_t a1, unsigned int a2)
{
  return *(float *)(a1 + 8 * a2 + 32);
}

double __MTForceConfigInit(_OWORD *a1)
{
  if (a1)
  {
    double result = 0.0;
    a1[9] = 0u;
    a1[10] = 0u;
    a1[7] = 0u;
    a1[8] = 0u;
    a1[5] = 0u;
    a1[6] = 0u;
    a1[3] = 0u;
    a1[4] = 0u;
    a1[1] = 0u;
    a1[2] = 0u;
  }
  return result;
}

uint64_t MultitouchHIDClass::_probe(MultitouchHIDClass *this, void *a2, const __CFDictionary *a3, unsigned int a4, int *a5)
{
  return (*(uint64_t (**)(void, void *, const __CFDictionary *))(**((void **)this + 1) + 40))(*((void *)this + 1), a2, a3);
}

uint64_t MultitouchHIDClass::_start(MultitouchHIDClass *this, void *a2, const __CFDictionary *a3)
{
  return (*(uint64_t (**)(void, void *, const __CFDictionary *))(**((void **)this + 1) + 48))(*((void *)this + 1), a2, a3);
}

uint64_t MultitouchHIDClass::_stop(MultitouchHIDClass *this, void *a2)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 56))();
}

uint64_t MultitouchHIDClass::_open(MultitouchHIDClass *this, void *a2)
{
  return (*(uint64_t (**)(void, void *))(**((void **)this + 1) + 64))(*((void *)this + 1), a2);
}

uint64_t MultitouchHIDClass::_close(MultitouchHIDClass *this, void *a2)
{
  return (*(uint64_t (**)(void, void *))(**((void **)this + 1) + 72))(*((void *)this + 1), a2);
}

uint64_t MultitouchHIDClass::_setEventCallback(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 96))();
}

uint64_t MultitouchHIDClass::_scheduleWithDispatchQueue(MultitouchHIDClass *this, void *a2, dispatch_queue_s *a3)
{
  return (*(uint64_t (**)(void, void *))(**((void **)this + 1) + 104))(*((void *)this + 1), a2);
}

uint64_t MultitouchHIDClass::_unscheduleFromDispatchQueue(MultitouchHIDClass *this, void *a2, dispatch_queue_s *a3)
{
  return (*(uint64_t (**)(void, void *))(**((void **)this + 1) + 112))(*((void *)this + 1), a2);
}

uint64_t MultitouchHIDClass::_copyEvent(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 120))();
}

uint64_t MultitouchHIDClass::_setOutputEvent(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 128))();
}

void MultitouchHIDClass::MultitouchHIDClass(MultitouchHIDClass *this)
{
  MultitouchIOHIDIUnknown::MultitouchIOHIDIUnknown(this, &MultitouchHIDClass::sIOCFPlugInInterfaceV1);
  *(void *)uint64_t v1 = &unk_26F4D8E80;
  *(void *)(v1 + 32) = &MultitouchHIDClass::sIOHIDServiceInterface2;
  *(void *)(v1 + 40) = v1;
  *(_DWORD *)(v1 + 56) = 0;
  *(void *)(v1 + 48) = 0;
  *(void *)(v1 + 72) = 0;
  *(void *)(v1 + 80) = 0;
  *(void *)(v1 + 64) = 0;
}

{
  uint64_t v1;

  MultitouchIOHIDIUnknown::MultitouchIOHIDIUnknown(this, &MultitouchHIDClass::sIOCFPlugInInterfaceV1);
  *(void *)uint64_t v1 = &unk_26F4D8E80;
  *(void *)(v1 + 32) = &MultitouchHIDClass::sIOHIDServiceInterface2;
  *(void *)(v1 + 40) = v1;
  *(_DWORD *)(v1 + 56) = 0;
  *(void *)(v1 + 48) = 0;
  *(void *)(v1 + 72) = 0;
  *(void *)(v1 + 80) = 0;
  *(void *)(v1 + 64) = 0;
}

void MultitouchHIDClass::~MultitouchHIDClass(MultitouchHIDClass *this)
{
  *(void *)this = &unk_26F4D8E80;
  MultitouchHIDClass::stop(this);

  MultitouchIOHIDIUnknown::~MultitouchIOHIDIUnknown(this);
}

{
  uint64_t vars8;

  MultitouchHIDClass::~MultitouchHIDClass(this);

  JUMPOUT(0x2455F6CE0);
}

void __clang_call_terminate(void *a1)
{
}

uint64_t MultitouchHIDClass::getHIDService(MultitouchHIDClass *this)
{
  return (uint64_t)this + 32;
}

void MultitouchHIDClass::alloc(MultitouchHIDClass *this)
{
}

void sub_240701D54(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10A1C40B9A1DDB6);
  _Unwind_Resume(a1);
}

uint64_t MultitouchHIDClass::queryInterface(MultitouchHIDClass *this, CFUUIDBytes a2, void **a3)
{
  CFUUIDRef v5 = CFUUIDCreateFromUUIDBytes(0, a2);
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x263EFFB30];
  CFUUIDRef v7 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x263EFFB30], 0, 0, 0, 0, 0, 0, 0, 0, 0xC0u, 0, 0, 0, 0, 0, 0, 0x46u);
  if (CFEqual(v5, v7)
    || (CFUUIDRef v8 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu), CFEqual(v5, v8)))
  {
    __int16 v9 = (char *)this + 16;
    uint64_t v10 = *(void *)this;
LABEL_4:
    *a3 = v9;
    (*(void (**)(MultitouchHIDClass *))(v10 + 24))(this);
    goto LABEL_5;
  }
  CFUUIDRef v13 = CFUUIDGetConstantUUIDWithBytes(v6, 0x6Fu, 0xE2u, 0x2Au, 0xBFu, 0x68u, 0xB9u, 0x11u, 0xDBu, 0xA7u, 0x1Fu, 0, 0x16u, 0xCBu, 0xC1u, 0x10u, 0xF7u);
  if (CFEqual(v5, v13))
  {
    __int16 v9 = (char *)this + 32;
    uint64_t v10 = *(void *)this;
    goto LABEL_4;
  }
  *a3 = 0;
LABEL_5:
  if (*a3) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = 2147483652;
  }
  CFRelease(v5);
  return v11;
}

uint64_t MultitouchHIDClass::probe(MultitouchHIDClass *this, const __CFDictionary *a2, int a3, int *a4)
{
  if (a3) {
    return 0;
  }
  else {
    return 3758097090;
  }
}

uint64_t MultitouchHIDClass::start(MultitouchHIDClass *this, const __CFDictionary *a2)
{
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 10) = MTDeviceCreateFromService();
  MTDeviceEnableBinaryFilters();
  if (MTDeviceStart())
  {
    unsigned int v3 = (unsigned int *)*((void *)this + 6);
    if (v3)
    {
      MTSimpleHIDManager::release(v3);
      *((void *)this + 6) = 0;
    }
    uint64_t v4 = (const void *)*((void *)this + 10);
    if (v4)
    {
      CFRelease(v4);
      *((void *)this + 10) = 0;
    }
    io_object_t v5 = *((_DWORD *)this + 14);
    if (v5)
    {
      IOObjectRelease(v5);
      *((_DWORD *)this + 14) = 0;
    }
    return 3758097084;
  }
  Parserint Type = MTDeviceGetParserType();
  MTDeviceGetParserOptions();
  if (ParserType <= 999)
  {
    switch(ParserType)
    {
      case 1:
        MTSimpleEmbeddedHIDManager::createManager();
      case 2:
        MTSimpleEmbeddedHIDManagerV2::createManager();
      case 4:
        MTSimpleEmbeddedStylusHIDManager::createManager();
    }
  }
  else if (ParserType > 1999)
  {
    if (ParserType == 2000) {
      MTMouseHIDManager::createManager();
    }
    if (ParserType == 2001) {
      MTMouseEmbeddedHIDManager::createManager();
    }
  }
  else
  {
    if (ParserType == 1000) {
LABEL_25:
    }
      MTTrackpadHIDManager::createManager();
    if (ParserType == 1001) {
      MTTrackpadEmbeddedHIDManager::createManager();
    }
  }
  if ((ParserType - 3000) <= 0x3E7) {
    goto LABEL_25;
  }
  CFUUIDRef v8 = MTLoggingPlugin();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
    MultitouchHIDClass::start(ParserType, v8);
  }
  return 3758097084;
}

uint64_t MultitouchHIDClass::stop(MultitouchHIDClass *this)
{
  uint64_t v2 = *((void *)this + 6);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 536))(v2);
    MTSimpleHIDManager::release(*((unsigned int **)this + 6));
    *((void *)this + 6) = 0;
  }
  *((void *)this + 8) = 0;
  unsigned int v3 = *((void *)this + 9);
  if (v3)
  {
    dispatch_release(v3);
    *((void *)this + 9) = 0;
  }
  if (*((void *)this + 10))
  {
    MTDeviceStop();
    CFRelease(*((CFTypeRef *)this + 10));
    *((void *)this + 10) = 0;
  }
  io_object_t v4 = *((_DWORD *)this + 14);
  if (v4)
  {
    IOObjectRelease(v4);
    *((_DWORD *)this + 14) = 0;
  }
  return 0;
}

uint64_t MultitouchHIDClass::open(MultitouchHIDClass *this)
{
  uint64_t result = *((void *)this + 6);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 544))(result);
  }
  return result;
}

uint64_t MultitouchHIDClass::close(MultitouchHIDClass *this)
{
  uint64_t result = *((void *)this + 6);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 552))();
  }
  return result;
}

uint64_t MultitouchHIDClass::copyProperty(MultitouchHIDClass *this, const __CFString *a2)
{
  uint64_t result = *((void *)this + 6);
  if (result) {
    return (*(uint64_t (**)(uint64_t, const __CFString *))(*(void *)result + 560))(result, a2);
  }
  return result;
}

void *MultitouchHIDClass::setEventCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = *(void **)(a1 + 48);
  if (result) {
    return MTSimpleHIDManager::setEventCallback((uint64_t)result, a2, a3, a4);
  }
  return result;
}

uint64_t MultitouchHIDClass::scheduleWithDispatchQueue(uint64_t this, dispatch_queue_s *a2)
{
  if (*(void *)(this + 48))
  {
    uint64_t v3 = this;
    if (*(void *)(this + 80) && MTDeviceIsRunning() && !*(void *)(v3 + 72))
    {
      uint64_t MultitouchDispatchSource = MTDeviceCreateMultitouchDispatchSource();
      *(void *)(v3 + 64) = a2;
      *(void *)(v3 + 72) = MultitouchDispatchSource;
    }
    io_object_t v5 = *(uint64_t (**)(void))(**(void **)(v3 + 48) + 576);
    return v5();
  }
  return this;
}

void MultitouchHIDClass::unscheduleFromDispatchQueue(MultitouchHIDClass *this, dispatch_queue_s *a2)
{
  uint64_t v3 = *((void *)this + 6);
  if (v3)
  {
    (*(void (**)(uint64_t, dispatch_queue_s *))(*(void *)v3 + 584))(v3, a2);
    io_object_t v4 = *((void *)this + 9);
    if (v4)
    {
      dispatch_source_cancel(v4);
      dispatch_release(*((dispatch_object_t *)this + 9));
      *((void *)this + 9) = 0;
    }
    *((void *)this + 8) = 0;
  }
}

uint64_t MultitouchHIDClass::copyEvent(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 48);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 608))();
  }
  return result;
}

uint64_t MultitouchHIDClass::setOutputEvent(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 600))();
  }
  else {
    return 3758097112;
  }
}

uint64_t IOHIDPlugInFactory(uint64_t a1, const void *a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  CFUUIDRef v4 = CFUUIDGetConstantUUIDWithBytes(0, 5u, 0x16u, 0xB5u, 0x63u, 0xB1u, 0x5Bu, 0x11u, 0xDAu, 0x96u, 0xEBu, 0, 0x14u, 0x51u, 0x97u, 0x58u, 0xEFu);
  if (!CFEqual(a2, v4)) {
    return 0;
  }
  if (os_variant_allows_internal_security_policies())
  {
    io_object_t v5 = (const void *)IOHIDPreferencesCopyDomain();
    CFTypeRef v6 = (id)CFMakeCollectable(v5);
    if (v6)
    {
      CFUUIDRef v7 = (void *)v6;
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0 && [v7 count] == 2)
      {
        CFUUIDRef v8 = (void *)[v7 objectAtIndexedSubscript:0];
        objc_opt_class();
        __int16 v9 = 0;
        if ((objc_opt_isKindOfClass() & 1) == 0) {
          goto LABEL_20;
        }
        if (([v8 hasPrefix:@"/System/Library"] & 1) != 0
          || [v8 hasPrefix:@"/AppleInternal/Library"])
        {
          uint64_t v10 = (void *)[v7 objectAtIndexedSubscript:1];
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            uint64_t v11 = dlopen((const char *)[v8 UTF8String], 5);
            if (v11)
            {
              uint64_t v12 = (uint64_t (*)(uint64_t, const void *))dlsym(v11, (const char *)[v10 UTF8String]);
              if (v12)
              {
                __int16 v9 = v12;
                if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 138543362;
                  uint64_t v15 = v7;
                  _os_log_impl(&dword_2406FB000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "Using plugin override: %{public}@", buf, 0xCu);
                }
                goto LABEL_20;
              }
              if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
                IOHIDPlugInFactory_cold_2();
              }
            }
            else if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
            {
              IOHIDPlugInFactory_cold_1();
            }
          }
        }
      }
    }
  }
  __int16 v9 = 0;
LABEL_20:
  if (v9) {
    return v9(a1, a2);
  }
  else {
    return ((uint64_t (*)(uint64_t, const void *))MultitouchHIDClass::alloc)(a1, a2);
  }
}

void MultitouchIOHIDIUnknown::factoryAddRef(MultitouchIOHIDIUnknown *this)
{
  if (!MultitouchIOHIDIUnknown::factoryRefCount++)
  {
    CFUUIDRef v2 = CFUUIDGetConstantUUIDWithBytes(0, 0xCu, 0xB0u, 0xFBu, 0xB9u, 0x15u, 0xEAu, 0x11u, 0xDBu, 0xA9u, 0x3Cu, 0, 0x14u, 0x51u, 0xD4u, 0x71u, 0x83u);
    CFPlugInAddInstanceForFactory(v2);
  }
}

void MultitouchIOHIDIUnknown::factoryRelease(MultitouchIOHIDIUnknown *this)
{
  int v1 = MultitouchIOHIDIUnknown::factoryRefCount--;
  if (MultitouchIOHIDIUnknown::factoryRefCount)
  {
    if (v1 <= 0) {
      MultitouchIOHIDIUnknown::factoryRefCFIndex Count = 0;
    }
  }
  else
  {
    CFUUIDRef v2 = CFUUIDGetConstantUUIDWithBytes(0, 0xCu, 0xB0u, 0xFBu, 0xB9u, 0x15u, 0xEAu, 0x11u, 0xDBu, 0xA9u, 0x3Cu, 0, 0x14u, 0x51u, 0xD4u, 0x71u, 0x83u);
    CFPlugInRemoveInstanceForFactory(v2);
  }
}

void MultitouchIOHIDIUnknown::MultitouchIOHIDIUnknown(MultitouchIOHIDIUnknown *this, void *a2)
{
  *(void *)this = &unk_26F4D8F30;
  *((_DWORD *)this + 2) = 1;
  *((void *)this + 2) = a2;
  *((void *)this + 3) = this;
  MultitouchIOHIDIUnknown::factoryAddRef(this);
}

void MultitouchIOHIDIUnknown::~MultitouchIOHIDIUnknown(MultitouchIOHIDIUnknown *this)
{
  *(void *)this = &unk_26F4D8F30;
  MultitouchIOHIDIUnknown::factoryRelease(this);
}

uint64_t MultitouchIOHIDIUnknown::addRef(MultitouchIOHIDIUnknown *this)
{
  uint64_t v1 = (*((_DWORD *)this + 2) + 1);
  *((_DWORD *)this + 2) = v1;
  return v1;
}

uint64_t MultitouchIOHIDIUnknown::release(MultitouchIOHIDIUnknown *this)
{
  int v1 = *((_DWORD *)this + 2);
  uint64_t v2 = (v1 - 1);
  if (v1 == 1)
  {
    *((_DWORD *)this + 2) = 0;
    (*(void (**)(MultitouchIOHIDIUnknown *))(*(void *)this + 8))(this);
  }
  else
  {
    *((_DWORD *)this + 2) = v2;
  }
  return v2;
}

uint64_t MultitouchIOHIDIUnknown::genericQueryInterface(MultitouchIOHIDIUnknown *this, void *a2, CFUUIDBytes a3, void **a4)
{
  return (*(uint64_t (**)(void, void *, void, void))(**((void **)this + 1) + 16))(*((void *)this + 1), a2, *(void *)&a3.byte0, *(void *)&a3.byte8);
}

uint64_t MultitouchIOHIDIUnknown::genericAddRef(MultitouchIOHIDIUnknown *this, void *a2)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 24))();
}

uint64_t MultitouchIOHIDIUnknown::genericRelease(MultitouchIOHIDIUnknown *this, void *a2)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 32))();
}

uint64_t mt_PrintHIDEvent(uint64_t result, int a2)
{
  if (result)
  {
    uint64_t v3 = result;
    CFArrayRef Children = (const __CFArray *)IOHIDEventGetChildren();
    switch(IOHIDEventGetType())
    {
      case 1u:
        [@"\n" stringByPaddingToLength:a2 + 1 withString:@"\t" startingAtIndex:0];
        IOHIDEventGetVendorDefinedData();
        goto LABEL_157;
      case 2u:
        if (a2 >= 1)
        {
          int v5 = a2;
          do
          {
            putchar(9);
            --v5;
          }
          while (v5);
        }
        IOHIDEventGetIntegerValue();
        printf("Button Mask: 0x%08X\n");
        goto LABEL_157;
      case 3u:
        IOHIDEventGetIntegerValue();
        IOHIDEventGetIntegerValue();
        if (a2 >= 1)
        {
          int v80 = a2;
          do
          {
            putchar(9);
            --v80;
          }
          while (v80);
        }
        IOHIDEventGetIntegerValue();
        IOHIDEventGetIntegerValue();
        printf("Keyboard: (usagePage:0x%04X usage:0x%04X%s) %s %s\n");
        goto LABEL_157;
      case 4u:
        if (a2 >= 1)
        {
          int v6 = a2;
          do
          {
            putchar(9);
            --v6;
          }
          while (v6);
        }
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        printf("Translation: %fx, %fy");
        goto LABEL_44;
      case 5u:
        if (a2 >= 1)
        {
          int v7 = a2;
          do
          {
            putchar(9);
            --v7;
          }
          while (v7);
        }
        IOHIDEventGetFloatValue();
        printf("Rotation: %f");
        goto LABEL_44;
      case 6u:
        if (a2 >= 1)
        {
          int v8 = a2;
          do
          {
            putchar(9);
            --v8;
          }
          while (v8);
        }
        IOHIDEventGetFloatValue();
        double v10 = v9;
        IOHIDEventGetFloatValue();
        double v12 = v11;
        IOHIDEventGetFloatValue();
        double v14 = v13;
        Integeruint64_t Value = IOHIDEventGetIntegerValue();
        uint64_t v16 = " isPixels";
        if (!IntegerValue) {
          uint64_t v16 = "";
        }
        printf("Scroll: (%f, %f, %f) %s", v10, v12, v14, v16);
        mt_PrintEventPhase();
        char ScrollMomentum = IOHIDEventGetScrollMomentum();
        char v18 = ScrollMomentum;
        if (ScrollMomentum)
        {
          printf(" PhaseMomentumContinue");
          if ((v18 & 2) == 0)
          {
LABEL_24:
            if ((v18 & 0x10) == 0) {
              goto LABEL_25;
            }
            goto LABEL_128;
          }
        }
        else if ((ScrollMomentum & 2) == 0)
        {
          goto LABEL_24;
        }
        printf(" PhaseMomentumStart");
        if ((v18 & 0x10) == 0)
        {
LABEL_25:
          if ((v18 & 4) == 0) {
            goto LABEL_26;
          }
          goto LABEL_129;
        }
LABEL_128:
        printf(" PhaseMomentumInterrupted");
        if ((v18 & 4) == 0)
        {
LABEL_26:
          if ((v18 & 8) == 0) {
            goto LABEL_148;
          }
          goto LABEL_130;
        }
LABEL_129:
        printf(" PhaseMomentumEnd");
        if ((v18 & 8) == 0) {
          goto LABEL_148;
        }
LABEL_130:
        printf(" PhaseMomentumWillBegin");
LABEL_148:
        putchar(10);
        goto LABEL_157;
      case 7u:
        if (a2 >= 1)
        {
          int v19 = a2;
          do
          {
            putchar(9);
            --v19;
          }
          while (v19);
        }
        IOHIDEventGetFloatValue();
        printf("Scale Event: %f");
        goto LABEL_44;
      case 9u:
        if (a2 >= 1)
        {
          int v21 = a2;
          do
          {
            putchar(9);
            --v21;
          }
          while (v21);
        }
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        printf("Velocity: %f, %f\n");
        goto LABEL_157;
      case 0xAu:
        if (a2 >= 1)
        {
          int v22 = a2;
          do
          {
            putchar(9);
            --v22;
          }
          while (v22);
        }
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        printf("Orientation: %fr, %fa");
LABEL_44:
        if ((IOHIDEventGetEventFlags() & 1) == 0) {
          printf(" (Relative) ");
        }
        goto LABEL_147;
      case 0xBu:
        if (IOHIDEventGetIntegerValue())
        {
          mt_PrintDigitizerHandEvent(v3, a2);
        }
        else if (gPrintHIDShowPathEvents)
        {
          mt_PrintDigitizerPathEvent(v3, a2);
        }
        goto LABEL_157;
      case 0xCu:
        IOHIDEventGetFloatValue();
        if (a2 >= 1)
        {
          int v23 = a2;
          do
          {
            putchar(9);
            --v23;
          }
          while (v23);
        }
        printf("ALS Event (level: %f)\n");
        goto LABEL_157;
      case 0xDu:
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        if (a2 >= 1)
        {
          int v24 = a2;
          do
          {
            putchar(9);
            --v24;
          }
          while (v24);
        }
        printf("Accelerometer Event (X: %f  Y: %f  Z: %f)\n");
        goto LABEL_157;
      case 0xEu:
        __int16 v25 = IOHIDEventGetIntegerValue();
        if (a2 >= 1)
        {
          int v26 = a2;
          do
          {
            putchar(9);
            --v26;
          }
          while (v26);
        }
        printf("Proximity Event (");
        if ((v25 & 8) != 0)
        {
          printf(" Edge Stradding,");
          if ((v25 & 0x20) == 0)
          {
LABEL_61:
            if ((v25 & 0x10) == 0) {
              goto LABEL_62;
            }
            goto LABEL_133;
          }
        }
        else if ((v25 & 0x20) == 0)
        {
          goto LABEL_61;
        }
        printf(" Finger Touch,");
        if ((v25 & 0x10) == 0)
        {
LABEL_62:
          if ((v25 & 4) == 0) {
            goto LABEL_63;
          }
          goto LABEL_134;
        }
LABEL_133:
        printf(" Flat Finger Clasp,");
        if ((v25 & 4) == 0)
        {
LABEL_63:
          if ((v25 & 1) == 0) {
            goto LABEL_64;
          }
          goto LABEL_135;
        }
LABEL_134:
        printf(" Irregualar Objects,");
        if ((v25 & 1) == 0)
        {
LABEL_64:
          if ((v25 & 2) == 0) {
            goto LABEL_65;
          }
          goto LABEL_136;
        }
LABEL_135:
        printf(" Large Body Contact,");
        if ((v25 & 2) == 0)
        {
LABEL_65:
          if ((v25 & 0x40) == 0) {
            goto LABEL_66;
          }
          goto LABEL_137;
        }
LABEL_136:
        printf(" Large Body Farfield,");
        if ((v25 & 0x40) == 0)
        {
LABEL_66:
          if ((v25 & 0x80) == 0) {
            goto LABEL_67;
          }
          goto LABEL_138;
        }
LABEL_137:
        printf(" Receiver Proximity,");
        if ((v25 & 0x80) == 0)
        {
LABEL_67:
          if ((v25 & 0x100) == 0) {
            goto LABEL_68;
          }
          goto LABEL_139;
        }
LABEL_138:
        printf(" Small Objects Hovering,");
        if ((v25 & 0x100) == 0)
        {
LABEL_68:
          if ((v25 & 0x200) == 0) {
            goto LABEL_69;
          }
          goto LABEL_140;
        }
LABEL_139:
        printf(" Crude Receiver Proximity,");
        if ((v25 & 0x200) == 0)
        {
LABEL_69:
          if ((v25 & 0x400) == 0) {
            goto LABEL_71;
          }
          goto LABEL_70;
        }
LABEL_140:
        printf(" Receiver Proximity Monitoring,");
        if ((v25 & 0x400) != 0) {
LABEL_70:
        }
          printf(" Crude Receiver Proximity Monitoring,");
LABEL_71:
        uint64_t v27 = ")";
LABEL_85:
        puts(v27);
LABEL_157:
        if (Children && CFArrayGetCount(Children) >= 1)
        {
          CFIndex v81 = 0;
          unsigned int v82 = 1;
          do
          {
            ValueAtIndex = CFArrayGetValueAtIndex(Children, v81);
            mt_PrintHIDEvent(ValueAtIndex, (a2 + 1));
            CFIndex v81 = v82;
          }
          while (CFArrayGetCount(Children) > v82++);
        }
        uint64_t result = fflush((FILE *)*MEMORY[0x263EF8358]);
        break;
      case 0x10u:
        uint64_t v28 = IOHIDEventGetIntegerValue();
        IOHIDEventGetFloatValue();
        double v30 = v29;
        IOHIDEventGetFloatValue();
        double v32 = v31;
        IOHIDEventGetFloatValue();
        double v34 = v33;
        if (a2 >= 1)
        {
          int v35 = a2;
          do
          {
            putchar(9);
            --v35;
          }
          while (v35);
        }
        float v36 = v34;
        float v37 = v32;
        float v38 = v30;
        printf("Nav Swipe:");
        goto LABEL_144;
      case 0x11u:
        if (a2 >= 1)
        {
          int v39 = a2;
          do
          {
            putchar(9);
            --v39;
          }
          while (v39);
        }
        IOHIDEventGetFloatValue();
        double v41 = v40;
        IOHIDEventGetFloatValue();
        double v43 = v42;
        uint64_t v44 = IOHIDEventGetIntegerValue();
        printf("Mouse: %fx, %fy (buttonmask: 0x%08lX)", v41, v43, v44);
        if ((IOHIDEventGetEventFlags() & 1) == 0) {
          printf(" (Relative) ");
        }
        goto LABEL_148;
      case 0x16u:
        if (a2 >= 1)
        {
          int v45 = a2;
          do
          {
            putchar(9);
            --v45;
          }
          while (v45);
        }
        uint64_t v27 = "Zoom Toggle";
        goto LABEL_85;
      case 0x17u:
        uint64_t v28 = IOHIDEventGetIntegerValue();
        IOHIDEventGetFloatValue();
        double v47 = v46;
        IOHIDEventGetFloatValue();
        double v49 = v48;
        IOHIDEventGetFloatValue();
        double v51 = v50;
        if (a2 >= 1)
        {
          int v52 = a2;
          do
          {
            putchar(9);
            --v52;
          }
          while (v52);
        }
        float v36 = v51;
        float v37 = v49;
        float v38 = v47;
        printf("Dock Swipe:");
        goto LABEL_144;
      case 0x18u:
        unsigned __int16 v53 = IOHIDEventGetIntegerValue();
        __int16 v54 = IOHIDEventGetIntegerValue();
        if (a2 >= 1)
        {
          int v55 = a2;
          do
          {
            putchar(9);
            --v55;
          }
          while (v55);
        }
        printf("Symbolic Hot Key: %d", v53);
        if (v54)
        {
          printf(" (CGSHotKey)");
        }
        else if (v53 == 1)
        {
          printf(" (DictionaryApp)");
        }
        goto LABEL_147;
      case 0x1Bu:
        uint64_t v28 = IOHIDEventGetIntegerValue();
        IOHIDEventGetFloatValue();
        double v57 = v56;
        IOHIDEventGetFloatValue();
        double v59 = v58;
        IOHIDEventGetFloatValue();
        double v61 = v60;
        if (a2 >= 1)
        {
          int v62 = a2;
          do
          {
            putchar(9);
            --v62;
          }
          while (v62);
        }
        printf("Fluid Touch Gesture:");
        if (IOHIDEventGetType() == 27)
        {
          switch((unsigned __int16)IOHIDEventGetIntegerValue())
          {
            case 1u:
              printf(" NotifCntrPrimary");
              break;
            case 2u:
              printf(" NotifCntrSecondary");
              break;
            case 3u:
              printf(" DockPrimary");
              break;
            case 4u:
              printf(" DockSecondary");
              break;
            case 5u:
              printf(" NavPrimary");
              break;
            case 6u:
              printf(" NavSecondary");
              break;
            default:
              goto LABEL_142;
          }
        }
        else
        {
LABEL_142:
          printf(" Flavor=0x%08X");
        }
        float v36 = v61;
        float v37 = v59;
        float v38 = v57;
        goto LABEL_144;
      case 0x1Cu:
        uint64_t v28 = IOHIDEventGetIntegerValue();
        IOHIDEventGetFloatValue();
        double v64 = v63;
        IOHIDEventGetFloatValue();
        double v66 = v65;
        IOHIDEventGetFloatValue();
        double v68 = v67;
        if (a2 >= 1)
        {
          int v69 = a2;
          do
          {
            putchar(9);
            --v69;
          }
          while (v69);
        }
        float v36 = v68;
        float v37 = v66;
        float v38 = v64;
        printf("Boundary Scroll:");
LABEL_144:
        mt_PrintEventMotion();
        printf(" %+.2f%% (%+.2f%%, %+.2f%%)", (float)(v38 * 100.0), (float)(v37 * 100.0), (float)(v36 * 100.0));
        mt_PrintSwipeMask(v28);
        goto LABEL_147;
      case 0x20u:
        unsigned int v70 = IOHIDEventGetIntegerValue();
        IOHIDEventGetFloatValue();
        float v72 = v71;
        int v73 = IOHIDEventGetIntegerValue();
        IOHIDEventGetFloatValue();
        float v75 = v74;
        if (a2 >= 1)
        {
          int v76 = a2;
          do
          {
            putchar(9);
            --v76;
          }
          while (v76);
        }
        printf("Force Gesture: %+.2f%% (stage %u) lean=%.2f", (float)(v72 * 100.0), v73, v75);
        printf(" - ");
        if (v70 > 0x11) {
          printf("Some Behavior");
        }
        else {
          printf(off_2650D3380[v70]);
        }
        printf(" - ");
        goto LABEL_147;
      case 0x26u:
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        IOHIDEventGetIntegerValue();
        if (a2 >= 1)
        {
          int v77 = a2;
          do
          {
            putchar(9);
            --v77;
          }
          while (v77);
        }
        printf("Keyboard Brightness Event (current level: %f, target level: %f, ramp length: %llul)\n");
        goto LABEL_157;
      case 0x29u:
        IOHIDEventGetTimeStamp();
        if (!dword_268C8ED64) {
          mach_timebase_info((mach_timebase_info_t)&machAbsoluteTimeToTimeNano_sTimebaseInfo);
        }
        IOHIDEventGetIntegerValue();
        IOHIDEventGetIntegerValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetDoubleValue();
        if (a2 >= 1)
        {
          int v78 = a2;
          do
          {
            putchar(9);
            --v78;
          }
          while (v78);
        }
        printf("ForceStage Event: TS:%llu stage:%u transition:%s nextThresh:%0.2f pressedThresh:%0.2f releasedThresh:%0.2f force:%0.2f forceVel:%0.2f\n");
        goto LABEL_147;
      case 0x2Au:
        IOHIDEventGetTimeStamp();
        if (!dword_268C8ED64) {
          mach_timebase_info((mach_timebase_info_t)&machAbsoluteTimeToTimeNano_sTimebaseInfo);
        }
        IOHIDEventGetIntegerValue();
        IOHIDEventGetIntegerValue();
        IOHIDEventGetIntegerValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetIntegerValue();
        IOHIDEventGetDoubleValue();
        IOHIDEventGetDoubleValue();
        if (a2 >= 1)
        {
          int v79 = a2;
          do
          {
            putchar(9);
            --v79;
          }
          while (v79);
        }
        printf("TouchSensitiveButton Event: (usagePage:0x%04X usage:0x%04X) TS:%llu touch:%d pos:(%0.2f,%0.2f) posDelta:(%0.4f,%0.4f) mask:0x%x majorRadius:%0.2f minorRadius:%0.2f - ");
LABEL_147:
        mt_PrintEventPhase();
        goto LABEL_148;
      default:
        if (a2 >= 1)
        {
          int v20 = a2;
          do
          {
            putchar(9);
            --v20;
          }
          while (v20);
        }
        IOHIDEventGetType();
        printf("Other Event: 0x%08X\n");
        goto LABEL_157;
    }
  }
  return result;
}

uint64_t mt_PrintDigitizerHandEvent(uint64_t a1, int a2)
{
  Integeruint64_t Value = IOHIDEventGetIntegerValue();
  __int16 EventFlags = IOHIDEventGetEventFlags();
  if (IOHIDEventGetIntegerValue() == 1 && (IntegerValue & 1) != 0) {
    putchar(10);
  }
  if (a2 >= 1)
  {
    do
    {
      putchar(9);
      --a2;
    }
    while (a2);
  }
  IOHIDEventGetFloatValue();
  double v6 = v5;
  IOHIDEventGetFloatValue();
  double v8 = v7;
  IOHIDEventGetFloatValue();
  printf("Hand Event (%6.3fx, %6.3fy)  force=%3.0fg\tMask: 0x%08X", v6, v8, v9, IntegerValue);
  if (IOHIDEventGetIntegerValue() == 1) {
    printf(", InRange ");
  }
  else {
    printf(", OutOfRange ");
  }
  if (IOHIDEventGetIntegerValue() == 1) {
    printf(" Touching");
  }
  else {
    printf(" UnTouch");
  }
  if ((IntegerValue & 2) != 0)
  {
    printf("  dTouch");
    if ((IntegerValue & 4) == 0)
    {
LABEL_14:
      if ((IntegerValue & 0x40) == 0) {
        goto LABEL_15;
      }
      goto LABEL_46;
    }
  }
  else if ((IntegerValue & 4) == 0)
  {
    goto LABEL_14;
  }
  printf("  dPosition");
  if ((IntegerValue & 0x40) == 0)
  {
LABEL_15:
    if ((IntegerValue & 0x80) == 0) {
      goto LABEL_16;
    }
    goto LABEL_47;
  }
LABEL_46:
  printf(" dAttribute");
  if ((IntegerValue & 0x80) == 0)
  {
LABEL_16:
    if ((IntegerValue & 0x200) == 0) {
      goto LABEL_17;
    }
    goto LABEL_48;
  }
LABEL_47:
  printf("  Cancel");
  if ((IntegerValue & 0x200) == 0)
  {
LABEL_17:
    if ((IntegerValue & 0x400) == 0) {
      goto LABEL_18;
    }
    goto LABEL_49;
  }
LABEL_48:
  printf("  Resting");
  if ((IntegerValue & 0x400) == 0)
  {
LABEL_18:
    if ((IntegerValue & 0x800) == 0) {
      goto LABEL_19;
    }
    goto LABEL_50;
  }
LABEL_49:
  printf("  FromEdgeFlat");
  if ((IntegerValue & 0x800) == 0)
  {
LABEL_19:
    if ((IntegerValue & 0x4000) == 0) {
      goto LABEL_20;
    }
    goto LABEL_51;
  }
LABEL_50:
  printf("  FromEdgeTip");
  if ((IntegerValue & 0x4000) == 0)
  {
LABEL_20:
    if ((IntegerValue & 0x8000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_52;
  }
LABEL_51:
  printf("  EdgePressPending");
  if ((IntegerValue & 0x8000) == 0)
  {
LABEL_21:
    if ((IntegerValue & 0x1000) == 0) {
      goto LABEL_22;
    }
    goto LABEL_53;
  }
LABEL_52:
  printf("  EdgePressActive");
  if ((IntegerValue & 0x1000) == 0)
  {
LABEL_22:
    if ((IntegerValue & 0x2000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_54;
  }
LABEL_53:
  printf("  FromCorner");
  if ((IntegerValue & 0x2000) == 0)
  {
LABEL_23:
    if ((IntegerValue & 0x40000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
LABEL_54:
  printf("  SwipePending");
  if ((IntegerValue & 0x40000) != 0) {
LABEL_24:
  }
    printf("  SwipeLocked");
LABEL_25:
  if ((IntegerValue & 0xF000000) == 0) {
    goto LABEL_31;
  }
  if ((IntegerValue & 0x1000000) != 0)
  {
    printf("  SwipeUP");
    if ((IntegerValue & 0x2000000) == 0)
    {
LABEL_28:
      if ((IntegerValue & 0x4000000) == 0) {
        goto LABEL_29;
      }
      goto LABEL_61;
    }
  }
  else if ((IntegerValue & 0x2000000) == 0)
  {
    goto LABEL_28;
  }
  printf("  SwipeDOWN");
  if ((IntegerValue & 0x4000000) == 0)
  {
LABEL_29:
    if ((IntegerValue & 0x8000000) == 0) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
LABEL_61:
  printf("  SwipeLEFT");
  if ((IntegerValue & 0x8000000) != 0) {
LABEL_30:
  }
    printf("  SwipeRIGHT");
LABEL_31:
  if ((IntegerValue & 0x100) != 0) {
    printf("   GestureStarted");
  }
  if ((IntegerValue & 8) != 0) {
    printf("   GestureEnded");
  }
  int v10 = IOHIDEventGetIntegerValue();
  if (v10) {
    printf(" GenerationCount=%u", v10);
  }
  if ((EventFlags & 0x20) != 0)
  {
    printf(" (Interpolated)");
    if ((EventFlags & 0x800) == 0)
    {
LABEL_39:
      if ((EventFlags & 0x4000) == 0) {
        goto LABEL_41;
      }
      goto LABEL_40;
    }
  }
  else if ((EventFlags & 0x800) == 0)
  {
    goto LABEL_39;
  }
  printf(" (Extrapolated)");
  if ((EventFlags & 0x4000) != 0) {
LABEL_40:
  }
    printf(" (Low Confidence Estimation)");
LABEL_41:

  return putchar(10);
}

uint64_t mt_PrintDigitizerPathEvent(uint64_t a1, int a2)
{
  Integeruint64_t Value = IOHIDEventGetIntegerValue();
  __int16 EventFlags = IOHIDEventGetEventFlags();
  if (a2 >= 1)
  {
    int v6 = a2;
    do
    {
      putchar(9);
      --v6;
    }
    while (v6);
  }
  uint64_t v7 = IntegerValue;
  IOHIDEventGetIntegerValue();
  IOHIDEventGetIntegerValue();
  IOHIDEventGetFloatValue();
  IOHIDEventGetFloatValue();
  IOHIDEventGetFloatValue();
  IOHIDEventGetFloatValue();
  if (IntegerValue)
  {
    IOHIDEventGetIntegerValue();
    printf("Path#%d: F%d (%6.9fx,%6.9fy,) ZA=%5.3f ZD=%5.3f GC=%ld");
  }
  else
  {
    IOHIDEventGetFloatValue();
    IOHIDEventGetIntegerValue();
    printf("Path#%d: F%d (%6.9fx,%6.9fy,%6.9fz) ZA=%5.3f ZD=%5.3f GC=%ld");
  }
  int v8 = IOHIDEventGetIntegerValue();
  printf(" Mask=0x%08X", v8);
  if ((v8 & 2) != 0)
  {
    printf(" (%s", "dTouch");
    if ((v8 & 4) == 0)
    {
      if ((v8 & 0x40) != 0)
      {
LABEL_41:
        printf(", %s");
        goto LABEL_43;
      }
LABEL_25:
      if ((v8 & 0x20) != 0)
      {
LABEL_44:
        printf(", %s");
        goto LABEL_45;
      }
LABEL_26:
      if ((v8 & 0x80) != 0)
      {
LABEL_46:
        printf(", %s");
        goto LABEL_47;
      }
LABEL_27:
      if ((v8 & 0x200) != 0)
      {
LABEL_48:
        printf(", %s");
        goto LABEL_49;
      }
LABEL_28:
      if ((v8 & 0x400) != 0)
      {
LABEL_50:
        printf(", %s");
        goto LABEL_51;
      }
LABEL_29:
      if ((v8 & 0x800) != 0)
      {
LABEL_52:
        printf(", %s");
        goto LABEL_53;
      }
LABEL_30:
      if ((v8 & 0x4000) != 0)
      {
LABEL_54:
        printf(", %s");
        goto LABEL_55;
      }
LABEL_31:
      if ((v8 & 0x8000) != 0)
      {
LABEL_56:
        printf(", %s");
        goto LABEL_57;
      }
LABEL_32:
      if ((v8 & 0x1000) != 0)
      {
LABEL_58:
        printf(", %s");
        goto LABEL_59;
      }
LABEL_33:
      if ((v8 & 0x2000) != 0)
      {
LABEL_60:
        printf(", %s");
        goto LABEL_61;
      }
LABEL_34:
      if ((v8 & 0x40000) != 0)
      {
LABEL_62:
        printf(", %s");
        goto LABEL_63;
      }
LABEL_35:
      if ((v8 & 0x100) != 0)
      {
LABEL_64:
        printf(", %s");
        goto LABEL_65;
      }
LABEL_36:
      if ((v8 & 8) == 0) {
        goto LABEL_67;
      }
      goto LABEL_66;
    }
    printf(", %s");
LABEL_40:
    if ((v8 & 0x40) != 0) {
      goto LABEL_41;
    }
    goto LABEL_25;
  }
  if ((v8 & 4) != 0)
  {
    printf(" (%s");
    goto LABEL_40;
  }
  if ((v8 & 0x40) != 0)
  {
    printf(" (%s");
LABEL_43:
    if ((v8 & 0x20) != 0) {
      goto LABEL_44;
    }
    goto LABEL_26;
  }
  if ((v8 & 0x20) != 0)
  {
    printf(" (%s");
LABEL_45:
    if ((v8 & 0x80) != 0) {
      goto LABEL_46;
    }
    goto LABEL_27;
  }
  if ((v8 & 0x80) != 0)
  {
    printf(" (%s");
LABEL_47:
    if ((v8 & 0x200) != 0) {
      goto LABEL_48;
    }
    goto LABEL_28;
  }
  if ((v8 & 0x200) != 0)
  {
    printf(" (%s");
LABEL_49:
    if ((v8 & 0x400) != 0) {
      goto LABEL_50;
    }
    goto LABEL_29;
  }
  if ((v8 & 0x400) != 0)
  {
    printf(" (%s");
LABEL_51:
    if ((v8 & 0x800) != 0) {
      goto LABEL_52;
    }
    goto LABEL_30;
  }
  if ((v8 & 0x800) != 0)
  {
    printf(" (%s");
LABEL_53:
    if ((v8 & 0x4000) != 0) {
      goto LABEL_54;
    }
    goto LABEL_31;
  }
  if ((v8 & 0x4000) != 0)
  {
    printf(" (%s");
LABEL_55:
    if ((v8 & 0x8000) != 0) {
      goto LABEL_56;
    }
    goto LABEL_32;
  }
  if ((v8 & 0x8000) != 0)
  {
    printf(" (%s");
LABEL_57:
    if ((v8 & 0x1000) != 0) {
      goto LABEL_58;
    }
    goto LABEL_33;
  }
  if ((v8 & 0x1000) != 0)
  {
    printf(" (%s");
LABEL_59:
    if ((v8 & 0x2000) != 0) {
      goto LABEL_60;
    }
    goto LABEL_34;
  }
  if ((v8 & 0x2000) != 0)
  {
    printf(" (%s");
LABEL_61:
    if ((v8 & 0x40000) != 0) {
      goto LABEL_62;
    }
    goto LABEL_35;
  }
  if ((v8 & 0x40000) != 0)
  {
    printf(" (%s");
LABEL_63:
    if ((v8 & 0x100) != 0) {
      goto LABEL_64;
    }
    goto LABEL_36;
  }
  if ((v8 & 0x100) != 0)
  {
    printf(" (%s");
LABEL_65:
    if ((v8 & 8) == 0) {
      goto LABEL_67;
    }
LABEL_66:
    printf(", %s");
    goto LABEL_67;
  }
  if ((v8 & 8) == 0) {
    goto LABEL_68;
  }
  printf(" (%s");
LABEL_67:
  putchar(41);
LABEL_68:
  if ((IOHIDEventGetPhase() & 0x80) != 0) {
    printf(" MayBegin");
  }
  if (IOHIDEventGetIntegerValue() == 1) {
    printf(" InRange");
  }
  else {
    printf(" OutOfRange");
  }
  if (IOHIDEventGetIntegerValue() == 1) {
    printf(" Touching");
  }
  else {
    printf(" UnTouch");
  }
  if ((EventFlags & 0x20) != 0)
  {
    printf(" Interpolated");
    if ((EventFlags & 0x800) == 0)
    {
LABEL_78:
      if ((EventFlags & 0x4000) == 0) {
        goto LABEL_80;
      }
      goto LABEL_79;
    }
  }
  else if ((EventFlags & 0x800) == 0)
  {
    goto LABEL_78;
  }
  printf(" Extrapolated");
  if ((EventFlags & 0x4000) != 0) {
LABEL_79:
  }
    printf(" Low Confidence Estimation");
LABEL_80:
  if (!IOHIDEventIsAbsolute()) {
    printf(" Relative");
  }
  putchar(10);
  if (a2 >= 1)
  {
    do
    {
      putchar(9);
      --a2;
    }
    while (a2);
  }
  if (v7)
  {
    IOHIDEventGetFloatValue();
    double v10 = v9;
    IOHIDEventGetFloatValue();
    double v12 = v11;
    IOHIDEventGetFloatValue();
    double v14 = v13;
    IOHIDEventGetFloatValue();
    double v16 = v15;
    IOHIDEventGetFloatValue();
    return printf("\tangle=%6.3f minorRadius=%5.4f  majorRadius=%5.4f radiusAccuracy=%5.4f force=%3.0fg\n", v10, v12, v14, v16, v17);
  }
  else
  {
    IOHIDEventGetFloatValue();
    float v20 = v19 * 180.0 / 3.14159265;
    IOHIDEventGetFloatValue();
    float v22 = v21 * 180.0 / 3.14159265;
    IOHIDEventGetFloatValue();
    float v24 = v23 * 180.0 / 3.14159265;
    IOHIDEventGetFloatValue();
    float v26 = v25;
    putchar(9);
    printf("altitude=%.1f", v20);
    mt_PrintStylusMask(a1, 0x8000);
    printf(" azimuth=%.1f", v22);
    mt_PrintStylusMask(a1, 0x10000);
    printf(" roll=%.1f", v24);
    mt_PrintStylusMask(a1, 0x800000);
    printf(" pressure=%.1fg", v26);
    mt_PrintStylusMask(a1, 1024);
    return putchar(10);
  }
}

uint64_t mt_PrintEventPhase()
{
  uint64_t result = IOHIDEventGetPhase();
  char v1 = result;
  if ((result & 0x80) != 0)
  {
    uint64_t result = printf(" PhaseMayBegin");
    if ((v1 & 1) == 0)
    {
LABEL_3:
      if ((v1 & 2) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((result & 1) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = printf(" PhaseBegan");
  if ((v1 & 2) == 0)
  {
LABEL_4:
    if ((v1 & 4) == 0) {
      goto LABEL_5;
    }
LABEL_10:
    uint64_t result = printf(" PhaseEnded");
    if ((v1 & 8) == 0) {
      return result;
    }
    goto LABEL_11;
  }
LABEL_9:
  uint64_t result = printf(" PhaseChanged");
  if ((v1 & 4) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if ((v1 & 8) == 0) {
    return result;
  }
LABEL_11:

  return printf(" PhaseCancelled");
}

uint64_t mt_PrintRawHIDEvent(uint64_t result)
{
  if (result)
  {
    if (IOHIDEventGetType() == 11 && IOHIDEventGetIntegerValue() != 3)
    {
      unint64_t TimeStamp = IOHIDEventGetTimeStamp();
      unsigned int v2 = dword_268C8ED64;
      if (!dword_268C8ED64)
      {
        mach_timebase_info((mach_timebase_info_t)&machAbsoluteTimeToTimeNano_sTimebaseInfo);
        unsigned int v2 = dword_268C8ED64;
      }
      unint64_t v37 = TimeStamp / v2 * machAbsoluteTimeToTimeNano_sTimebaseInfo / 0x3E8;
      IOHIDEventGetFloatValue();
      *(float *)&double v3 = v3;
      float v36 = *(float *)&v3;
      IOHIDEventGetFloatValue();
      *(float *)&double v4 = v4;
      float v35 = *(float *)&v4;
      IOHIDEventGetFloatValue();
      *(float *)&double v5 = v5;
      float v34 = *(float *)&v5;
      IOHIDEventGetFloatValue();
      float v7 = v6;
      IOHIDEventGetFloatValue();
      float v9 = v8;
      IOHIDEventGetFloatValue();
      float v11 = v10;
      IOHIDEventGetFloatValue();
      float v13 = v12;
      IOHIDEventGetFloatValue();
      float v15 = v14;
      IOHIDEventGetFloatValue();
      float v17 = v16;
      IOHIDEventGetFloatValue();
      float v19 = v18;
      IOHIDEventGetFloatValue();
      float v21 = v20;
      Integeruint64_t Value = IOHIDEventGetIntegerValue();
      char v23 = IOHIDEventGetIntegerValue();
      char v24 = IOHIDEventGetIntegerValue();
      int v25 = IOHIDEventGetIntegerValue();
      char v26 = IOHIDEventGetIntegerValue();
      char v27 = IOHIDEventGetIntegerValue();
      int v28 = IOHIDEventGetIntegerValue();
      int v29 = IOHIDEventGetIntegerValue();
      int v30 = IOHIDEventGetIntegerValue();
      printf("path,%llu,%d,%d,%d,%d,%f,%f,%d,%d,0x%X,%f,%f,%d,%d,%f,%f,%f,%f,%f,%f,%f\n", v37, v30, IntegerValue, v23, v24, v36, v35, v26, v27, v25, v34, v7, v28, v29, v9, v11, v13, v15,
        v17,
        v19,
        v21);
    }
    uint64_t result = IOHIDEventGetChildren();
    if (result)
    {
      CFArrayRef v31 = (const __CFArray *)result;
      uint64_t result = CFArrayGetCount((CFArrayRef)result);
      if (result >= 1)
      {
        for (CFIndex i = 0; i < result; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v31, i);
          mt_PrintRawHIDEvent(ValueAtIndex);
          uint64_t result = CFArrayGetCount(v31);
        }
      }
    }
  }
  return result;
}

uint64_t mt_PrintStylusMask(uint64_t a1, int a2)
{
  Integeruint64_t Value = IOHIDEventGetIntegerValue();
  int v4 = IOHIDEventGetIntegerValue();
  uint64_t result = IOHIDEventGetIntegerValue();
  if ((result & a2) != 0)
  {
    printf(" (%s", "estimated");
    if ((IntegerValue & a2) != 0) {
      printf(", %s");
    }
    goto LABEL_6;
  }
  if ((IntegerValue & a2) != 0)
  {
    printf(" (%s");
LABEL_6:
    if ((v4 & a2) != 0) {
      printf(", %s");
    }
    goto LABEL_8;
  }
  if ((v4 & a2) == 0) {
    return result;
  }
  printf(" (%s");
LABEL_8:

  return putchar(41);
}

uint64_t mt_PrintEventMotion()
{
  if (IOHIDEventGetType() == 16
    || IOHIDEventGetType() == 23
    || IOHIDEventGetType() == 27
    || IOHIDEventGetType() == 28)
  {
    Integeruint64_t Value = (unsigned __int16)IOHIDEventGetIntegerValue();
    switch(IntegerValue)
    {
      case 1:
        char v1 = " Horiz";
        break;
      case 2:
        char v1 = " Vert";
        break;
      case 3:
        char v1 = " Scale";
        break;
      case 4:
        char v1 = " Rotate";
        break;
      case 5:
        char v1 = " Tap";
        break;
      case 6:
        char v1 = " DoubleTap";
        break;
      case 7:
        char v1 = " FromLeftEdge";
        break;
      case 8:
        char v1 = " OffLeftEdge";
        break;
      case 9:
        char v1 = " FromRightEdge";
        break;
      case 10:
        char v1 = " OffRightEdge";
        break;
      case 11:
        char v1 = " FromTopEdge";
        break;
      case 12:
        char v1 = " OffTopEdge";
        break;
      case 13:
        char v1 = " FromBottomEdge";
        break;
      case 14:
        char v1 = " OffBottomEdge";
        break;
      default:
        return printf(" Motion=0x%08X", IntegerValue);
    }
    return printf(v1);
  }
  else
  {
    Integeruint64_t Value = 0;
    return printf(" Motion=0x%08X", IntegerValue);
  }
}

uint64_t mt_PrintSwipeMask(uint64_t result)
{
  char v1 = result;
  if (result)
  {
    uint64_t result = printf(" [SwipeUp]");
    if ((v1 & 2) == 0)
    {
LABEL_3:
      if ((v1 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_12;
    }
  }
  else if ((result & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t result = printf(" [SwipeDown]");
  if ((v1 & 4) == 0)
  {
LABEL_4:
    if ((v1 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t result = printf(" [SwipeLeft]");
  if ((v1 & 8) == 0)
  {
LABEL_5:
    if ((v1 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_14;
  }
LABEL_13:
  uint64_t result = printf(" [SwipeRight]");
  if ((v1 & 0x10) == 0)
  {
LABEL_6:
    if ((v1 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_15;
  }
LABEL_14:
  uint64_t result = printf(" [ScaleExpand]");
  if ((v1 & 0x20) == 0)
  {
LABEL_7:
    if ((v1 & 0x40) == 0) {
      goto LABEL_8;
    }
LABEL_16:
    uint64_t result = printf(" [RotateCW]");
    if ((v1 & 0x80) == 0) {
      return result;
    }
    goto LABEL_17;
  }
LABEL_15:
  uint64_t result = printf(" [ScaleContract]");
  if ((v1 & 0x40) != 0) {
    goto LABEL_16;
  }
LABEL_8:
  if ((v1 & 0x80) == 0) {
    return result;
  }
LABEL_17:

  return printf(" [RotateCCW]");
}

double mt_MachAbsoluteTimeToSeconds(unint64_t a1)
{
  if (dword_268C8ED54)
  {
    double v2 = *(double *)&mt_MachAbsoluteTimeToSeconds_timebaseFraction;
  }
  else
  {
    mach_timebase_info((mach_timebase_info_t)&mt_MachAbsoluteTimeToSeconds_sTimebaseInfo);
    LODWORD(v3) = mt_MachAbsoluteTimeToSeconds_sTimebaseInfo;
    LODWORD(v4) = dword_268C8ED54;
    double v2 = (double)v3 * 0.000000001 / (double)v4;
    mt_MachAbsoluteTimeToSeconds_timebaseFraction = *(void *)&v2;
  }
  return v2 * (double)a1;
}

float invertRadiusSmoothing(int8x16_t a1, float a2, int8x16_t a3, int8x16_t a4)
{
  if (a2 != 0.0)
  {
    *(float *)a4.i32 = (float)(*(float *)a1.i32 - a2) / a2;
    float v4 = fabsf(*(float *)a4.i32);
    double v5 = v4;
    if (*(float *)a3.i32 * 0.125 <= v4)
    {
      *(double *)a3.i64 = (float)(*(float *)a3.i32 + 1.0);
      if (*(double *)a3.i64 * 0.0625 <= v5)
      {
        if (*(double *)a3.i64 * 0.125 > v5)
        {
          *(float *)a1.i32 = (*(float *)a4.i32 / (*(double *)a3.i64 * 0.5) + 1.0) * a2;
          return *(float *)a1.i32;
        }
        a3.i32[0] = 0.25;
        if (v4 >= 0.25) {
          return *(float *)a1.i32;
        }
        a1.i64[0] = 0x8000000080000000;
        a1.i64[1] = 0x8000000080000000;
        *(float *)a1.i32 = *(float *)vbslq_s8(a1, a3, a4).i32 + 1.0;
      }
      else
      {
        a1.i32[0] = 0.125;
        v6.i64[0] = 0x8000000080000000;
        v6.i64[1] = 0x8000000080000000;
        *(float *)a1.i32 = *(float *)vbslq_s8(v6, a1, a4).i32 + 1.0;
      }
    }
    else
    {
      *(float *)a1.i32 = (float)(*(float *)a4.i32 / *(float *)a3.i32) + 1.0;
    }
    *(float *)a1.i32 = *(float *)a1.i32 * a2;
  }
  return *(float *)a1.i32;
}

float mthm_ComputeFingerEllipseTipOffset_mm(int *a1, uint64_t a2, float32x2_t *a3, float *a4, int8x16_t a5, double a6, int8x16_t a7, int8x16_t a8)
{
  if (a1[1]) {
    int v11 = -1;
  }
  else {
    int v11 = 1;
  }
  if (!*((unsigned char *)a1 + 44) || a3[5].f32[0] == 0.0 && a3[5].f32[1] == 0.0)
  {
    float v13 = a3[7].f32[1];
    float v14 = a3[8].f32[0];
    float v15 = a3[7].f32[0];
  }
  else
  {
    a5.i32[0] = a3[7].i32[1];
    __int32 v16 = a1[12];
    a7.i32[0] = v16;
    float v13 = invertRadiusSmoothing(a5, a4[15], a7, a8);
    v17.i32[0] = a3[8].i32[0];
    v18.i32[0] = v16;
    float v14 = invertRadiusSmoothing(v17, a4[16], v18, v19);
    v20.i32[0] = a3[7].i32[0];
    v21.i32[0] = v16;
    float v15 = invertRadiusSmoothing(v20, a4[14], v21, v22);
  }
  int v23 = *a1;
  float v24 = (float)v11;
  float v25 = 0.0;
  switch(*a1)
  {
    case 0:
      goto LABEL_25;
    case 1:
      float v25 = -(float)(*((float *)a1 + 5) * v24);
      goto LABEL_19;
    case 2:
      float v15 = v15 + 3.14159265;
      float v25 = *((float *)a1 + 5) * v24;
      goto LABEL_19;
    case 3:
      if (v15 < 1.57079633)
      {
        float v26 = v15 + 3.14159265;
        float v15 = v26;
      }
      float v25 = -*((float *)a1 + 4);
      goto LABEL_19;
    case 4:
      if (v15 > 1.57079633)
      {
        float v27 = v15 + 3.14159265;
        float v15 = v27;
      }
      float v25 = *((float *)a1 + 4);
      goto LABEL_19;
    default:
      float v25 = 0.0;
LABEL_19:
      float v28 = *((float *)a1 + 8);
      if (v14 > v28) {
        float v28 = v14;
      }
      float v29 = *((float *)a1 + 6) + v28;
      if (v13 > v29)
      {
        float v30 = v13 - v29;
        if (v30 > *((float *)a1 + 7)) {
          float v30 = *((float *)a1 + 7);
        }
        float v31 = *((float *)a1 + 3) * v30;
        float v25 = v25 + (float)(v31 * __sincosf_stret(v15).__cosval);
      }
LABEL_25:
      int v32 = *((unsigned __int8 *)a1 + 40);
      __asm { FMOV            V1.2S, #1.0 }
      float32x2_t v38 = vminnm_f32(vmaxnm_f32(a3[4], 0), _D1);
      float v39 = MTSurfaceDimensions::convertSurfaceFractionToMillimeters(a2, vminnm_f32(v38, vsub_f32(_D1, v38)).f32[0]);
      float v40 = *((float *)a1 + 15);
      if ((v23 - 1) > 1)
      {
        float v41 = 1.0;
        float v42 = *((float *)a1 + 14);
        if (v42 != 0.0) {
          float v41 = fmin((float)(v39 / v42), 1.0);
        }
      }
      else
      {
        float v41 = 1.0;
        if (v40 != 0.0) {
          float v41 = fmin((float)(v39 / v40), 1.0);
        }
      }
      float v43 = fabsf(v25);
      if (v32) {
        float v43 = v25;
      }
      return v43 * v41;
  }
}

void mthm_ComputeFingerEllipseTipOffsetFromPressure_mm(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(float *)(a3 + 60) > (float)(*(float *)(a1 + 24) + *(float *)(a1 + 32))) {
    __sincosf_stret(*(float *)(a3 + 56));
  }
}

void MTSimpleEmbeddedStylusHIDManager::createManager()
{
}

void sub_2407055E4(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10A1C40E945ADD8);
  _Unwind_Resume(a1);
}

uint64_t MTSimpleEmbeddedStylusHIDManager::wasScheduledOnDispatchQueue(MTSimpleEmbeddedStylusHIDManager *this, NSObject *a2)
{
  float v4 = (IONotificationPort **)*((void *)this + 25);
  if (v4) {
    MTSLGLogger::registerControlInterface(v4, a2);
  }

  return MTSimpleHIDManager::wasScheduledOnDispatchQueue(this, a2);
}

void MTSimpleEmbeddedStylusHIDManager::wasUnscheduledFromDispatchQueue(NSObject **this, dispatch_queue_s *a2)
{
  MTSimpleHIDManager::wasUnscheduledFromDispatchQueue(this, a2);
  unint64_t v3 = (MTSLGLogger *)this[25];
  if (v3)
  {
    MTSLGLogger::unregisterControlInterface(v3);
  }
}

uint64_t MTSimpleEmbeddedStylusHIDManager::setDeviceUsages(MTSimpleEmbeddedStylusHIDManager *this)
{
  int v14 = 32;
  int valuePtr = 13;
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 2, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  CFNumberRef v4 = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
  if (v4)
  {
    CFNumberRef v5 = v4;
    (*(void (**)(MTSimpleEmbeddedStylusHIDManager *, __CFString *, CFNumberRef))(*(void *)this + 568))(this, @"PrimaryUsagePage", v4);
    if (Mutable) {
      CFDictionaryAddValue(Mutable, @"DeviceUsagePage", v5);
    }
    CFRelease(v5);
  }
  CFNumberRef v6 = CFNumberCreate(v2, kCFNumberSInt32Type, &v14);
  if (v6)
  {
    CFNumberRef v7 = v6;
    (*(void (**)(MTSimpleEmbeddedStylusHIDManager *, __CFString *, CFNumberRef))(*(void *)this + 568))(this, @"PrimaryUsage", v6);
    if (Mutable) {
      CFDictionaryAddValue(Mutable, @"DeviceUsage", v7);
    }
    CFRelease(v7);
  }
  double v8 = CFArrayCreateMutable(v2, 2, MEMORY[0x263EFFF70]);
  if (v8)
  {
    float v9 = v8;
    if (Mutable) {
      CFArrayAppendValue(v8, Mutable);
    }
    (*(void (**)(MTSimpleEmbeddedStylusHIDManager *, __CFString *, __CFArray *))(*(void *)this + 568))(this, @"DeviceUsagePairs", v9);
    CFRelease(v9);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  (*(void (**)(MTSimpleEmbeddedStylusHIDManager *))(*(void *)this + 80))(this);
  int IsBuiltIn = MTDeviceIsBuiltIn();
  uint64_t v11 = *MEMORY[0x263EFFB40];
  if (IsBuiltIn) {
    uint64_t v12 = *MEMORY[0x263EFFB40];
  }
  else {
    uint64_t v12 = *MEMORY[0x263EFFB38];
  }
  (*(void (**)(MTSimpleEmbeddedStylusHIDManager *, __CFString *, uint64_t))(*(void *)this + 568))(this, @"Built-In", v12);
  return (*(uint64_t (**)(MTSimpleEmbeddedStylusHIDManager *, __CFString *, uint64_t))(*(void *)this + 568))(this, @"DisplayIntegrated", v11);
}

uint64_t MTSimpleEmbeddedStylusHIDManager::setPluginDefaultProperties(MTSimpleEmbeddedStylusHIDManager *this)
{
  MTSimpleEmbeddedHIDManager::setPluginDefaultProperties(this);
  (*(void (**)(MTSimpleEmbeddedStylusHIDManager *))(*(void *)this + 80))(this);
  int valuePtr = MTDeviceGetMaxHoverHeightValue();
  CFNumberRef v2 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt32Type, &valuePtr);
  if (v2)
  {
    CFNumberRef v3 = v2;
    (*(void (**)(MTSimpleEmbeddedStylusHIDManager *, __CFString *, CFNumberRef))(*(void *)this + 568))(this, @"MaxHoverHeight", v2);
    CFRelease(v3);
  }
  return (*(uint64_t (**)(MTSimpleEmbeddedStylusHIDManager *, __CFString *, void))(*(void *)this + 568))(this, @"HoverDisabled", *MEMORY[0x263EFFB38]);
}

const char *MTSimpleEmbeddedStylusHIDManager::getName(MTSimpleEmbeddedStylusHIDManager *this)
{
  return "MTSimpleEmbeddedStylusHIDManager";
}

void MTSimpleEmbeddedStylusHIDManager::createEventDispatcher(MTSimpleEmbeddedStylusHIDManager *this)
{
}

uint64_t MTSimpleEmbeddedStylusHIDManager::setInputDetectionModeForOrientation(MTSimpleEmbeddedStylusHIDManager *this)
{
  return 0;
}

uint64_t MTSimpleEmbeddedStylusHIDManager::setTouchMode(MTSimpleEmbeddedStylusHIDManager *this)
{
  return 0;
}

void MTSimpleEmbeddedStylusHIDManager::sendHighNoiseEnvironmentDetection(MTSimpleEmbeddedStylusHIDManager *this, int a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  (*(void (**)(MTSimpleEmbeddedStylusHIDManager *))(*(void *)this + 80))(this);
  MTDeviceGetDeviceID();
  CFNumberRef v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFNumberRef v5 = "exited";
    if (a2) {
      CFNumberRef v5 = "entered";
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = v5;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = 0;
    _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_DEFAULT, "Sending high-noise environment %{public}s (deviceID 0x%llX)", buf, 0x16u);
  }
  *(void *)&buf[8] = 0;
  *(void *)&buf[1] = 0;
  buf[0] = a2;
  mach_absolute_time();
  uint64_t VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
  if (VendorDefinedEvent)
  {
    CFNumberRef v7 = (const void *)VendorDefinedEvent;
    (*(void (**)(MTSimpleEmbeddedStylusHIDManager *, uint64_t, void))(*(void *)this + 136))(this, VendorDefinedEvent, 0);
    CFRelease(v7);
  }
}

void MTSimpleEmbeddedStylusHIDManager::~MTSimpleEmbeddedStylusHIDManager(MTSimpleEmbeddedStylusHIDManager *this)
{
  MTSimpleHIDManager::~MTSimpleHIDManager(this);

  JUMPOUT(0x2455F6CE0);
}

uint64_t MTSimpleEmbeddedStylusHIDManager::setPowerState()
{
  return 0;
}

uint64_t MTSimpleEmbeddedStylusHIDManager::setPowerStateWithReset()
{
  return 0;
}

MTFingerToPathMap *MTHandMotion::MTHandMotion(MTFingerToPathMap *a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6)
{
  MTFingerToPathMap::MTFingerToPathMap(a1, 1);
  *(void *)uint64_t v12 = &unk_26F4D9218;
  *(void *)(v12 + 120) = a2;
  *(_DWORD *)(v12 + 128) = a3;
  *(_DWORD *)(v12 + 132) = a4;
  *(_DWORD *)(v12 + 380) = a5;
  *(void *)(v12 + 384) = a6;
  MTParameterFactory::initMotionExtractionParams(v12 + 144);
  MTHandMotion::clearHandMotion(a1, 1);
  return a1;
}

void sub_240705DB8(_Unwind_Exception *a1)
{
  MTFingerToPathMap::~MTFingerToPathMap(v1);
  _Unwind_Resume(a1);
}

void MTHandMotion::~MTHandMotion(MTHandMotion *this)
{
  MTFingerToPathMap::~MTFingerToPathMap(this);

  JUMPOUT(0x2455F6CE0);
}

uint64_t MTHandMotion::printExtractedMotion(uint64_t a1, int a2, int a3, uint64_t a4)
{
  printf("%s %dM/%d fingers, %d<-->%d\n", *(const char **)(a1 + 384), a3, a2, *(_DWORD *)(a1 + 80), *(_DWORD *)(a1 + 88));
  for (uint64_t i = 3; i != 8; ++i)
  {
    int v7 = *(_DWORD *)(a1 + 4 * i);
    if (v7) {
      printf("\tF%d %5.2fx %5.2fy %5.2fvx %5.2fvy\n", i - 2, *(float *)(a4 + 96 * v7 + 32), *(float *)(a4 + 96 * v7 + 36), *(float *)(a4 + 96 * v7 + 40), *(float *)(a4 + 96 * v7 + 44));
    }
  }
  return printf("\t%4.2fdx %4.2fdy %4.2fds %4.2fdr | %5.3f/%5.3fvx %5.3f/%5.3fvy %5.3f/%5.3fvs %5.3f/%5.3fvr\n", *(float *)(a1 + 192), *(float *)(a1 + 196), *(float *)(a1 + 200), *(float *)(a1 + 204), *(float *)(a1 + 284), *(float *)(a1 + 208), *(float *)(a1 + 288), *(float *)(a1 + 212), *(float *)(a1 + 292), *(float *)(a1 + 216), *(float *)(a1 + 296), *(float *)(a1 + 220));
}

uint64_t MTHandMotion::outermostFingersAreWidelySeparated(MTHandMotion *this, unsigned int a2)
{
  float v2 = *((float *)this + 90);
  float v3 = 0.0;
  if (v2 > 40.0)
  {
    float v3 = 1.0;
    if (v2 < 50.0) {
      float v3 = (float)(v2 + -40.0) / 10.0;
    }
  }
  if ((float)(v3 * *((float *)this + 93)) > 0.9) {
    return 1;
  }
  if (v3 >= 1.0) {
    return a2;
  }
  return 0;
}

float MTHandMotion::scalingFromDotProduct(float a1, float a2, float a3, float a4, float a5, float a6)
{
  return (float)((float)(a2 * a6) + (float)(a5 * a1)) - (float)((float)(a2 * a4) + (float)(a3 * a1));
}

float MTHandMotion::rotationFromVectorProduct(float a1, float a2, float a3, float a4, float a5, float a6)
{
  return (float)((float)(a5 * a2) - (float)(a6 * a1)) - (float)((float)(a3 * a2) - (float)(a4 * a1));
}

float MTHandMotion::computeSeparation_mm(float *a1, uint64_t a2, uint64_t a3)
{
  float v3 = *(float *)(a3 + 68);
  float v4 = *(float *)(a3 + 72);
  float v5 = *(float *)(a2 + 68);
  float v6 = *(float *)(a2 + 72);
  float v7 = v4 - v6;
  float v8 = vabds_f32(v4, v6);
  a1[88] = v8;
  if (v8 > a1[89]) {
    a1[89] = v8;
  }
  float v9 = v3 - v5;
  a1[87] = sqrtf((float)(v7 * v7) + (float)(v9 * v9));
  float result = sqrtf((float)((float)(v7 * 0.5) * (float)(v7 * 0.5)) + (float)(v9 * v9));
  a1[90] = result;
  return result;
}

float MTHandMotion::computeSeparationVector(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v3 = *(float *)(a3 + 32) - *(float *)(a2 + 32);
  atan2f(-(float)(*(float *)(a3 + 36) - *(float *)(a2 + 36)), v3);
  return v3;
}

float MTHandMotion::computeInnerOuterSpeedSymmetry(uint64_t a1, float *a2, float *a3)
{
  float v3 = a2[134];
  float v4 = a2[132];
  float v5 = a2[133];
  float v6 = sqrtf((float)(v4 * v4) + (float)(v5 * v5));
  float v7 = 1.0;
  if (v6 > 0.0)
  {
    float v8 = a3[132];
    float v9 = a3[133];
    float v10 = sqrtf((float)(v8 * v8) + (float)(v9 * v9));
    if (v10 > 0.0) {
      float v7 = (float)((float)(v5 * v9) + (float)(v4 * v8)) / (float)(v6 * v10);
    }
  }
  float result = 0.0;
  if (v3 > 20.0)
  {
    float v12 = -1.0;
    if (v7 >= 0.0) {
      float v12 = 1.0;
    }
    BOOL v13 = v7 <= 0.5;
    float v14 = 1.5;
    if (v13) {
      float v14 = v12;
    }
    return (float)(sqrtf(v3 * a3[134]) / (float)((float)((float)(v3 + a3[134]) * 0.5) + 1.0)) * v14;
  }
  return result;
}

void MTHandMotion::extractHandMotion(MTHandMotion *this, const MTPathStates *a2, const MTParserPath *a3, const MTParserPath *a4, int a5)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (*((double *)a2 + 1) - *((double *)a2 + 2) == 0.0)
  {
    float v10 = MTLoggingPlugin();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = *((void *)a2 + 1);
      MTAbsoluteTimeGetCurrent();
      *(_DWORD *)buf = 136316162;
      unint64_t v37 = "[Error] ";
      __int16 v38 = 2080;
      float v39 = "";
      __int16 v40 = 2080;
      float v41 = "extractHandMotion";
      __int16 v42 = 2048;
      uint64_t v43 = v11;
      __int16 v44 = 2048;
      uint64_t v45 = v12;
      _os_log_impl(&dword_2406FB000, v10, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Frame interval is zero! currentTimestamp = %g, currentHostTimestamp = %g", buf, 0x34u);
    }
  }
  float32x2_t v13 = *(float32x2_t *)((char *)a3 + 432);
  int v14 = *((_DWORD *)a3 + 91);
  float32x2_t v15 = *(float32x2_t *)((char *)a4 + 432);
  int v16 = *((_DWORD *)a4 + 91);
  *(void *)((char *)this + 348) = 0;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_DWORD *)this + 9MTHandMotion::clearHandMotion(this, 1) = *((_DWORD *)this + 90);
  *((_DWORD *)this + 90) = 0;
  int v17 = *((_DWORD *)a3 + 10);
  if (v17)
  {
    *((float32x2_t *)this + 26) = vadd_f32(*(float32x2_t *)((char *)a3 + 500), 0);
    *((float32x2_t *)this + 2MTHandMotion::clearHandMotion(this, 1) = vadd_f32(v13, *(float32x2_t *)((char *)a3 + 56));
    if (a5)
    {
      if (*((_DWORD *)a3 + 34) && (v14 & 4) != 0)
      {
        *((float *)this + 48) = *((float *)a3 + 112) + 0.0;
        *((float *)this + 49) = *((float *)a3 + 113) + 0.0;
      }
    }
  }
  int v18 = *((_DWORD *)a4 + 10);
  if (v17 == v18 || !v18)
  {
    *((void *)this + 22) = 0;
    return;
  }
  float v19 = *((float *)a4 + 14) - *((float *)a3 + 14);
  float v20 = *((float *)a4 + 15) - *((float *)a3 + 15);
  float v21 = sqrtf((float)(v20 * v20) + (float)(v19 * v19));
  float v22 = atan2f(-v20, v19);
  float v23 = *((float *)a3 + 125);
  float v24 = *((float *)a3 + 126);
  float32x2_t v35 = *(float32x2_t *)((char *)a4 + 500);
  MTHandMotion::computeSeparation_mm((float *)this, (uint64_t)a3 + 24, (uint64_t)a4 + 24);
  *((float *)this + 44) = v21;
  *((float *)this + 45) = v22;
  *((float32x2_t *)this + 2MTHandMotion::clearHandMotion(this, 1) = vmul_f32(vadd_f32(*(float32x2_t *)((char *)this + 168), vadd_f32(v15, *(float32x2_t *)((char *)a4 + 56))), (float32x2_t)0x3F0000003F000000);
  v26.n128_u64[0] = (unint64_t)vmul_f32(vadd_f32(v35, *(float32x2_t *)((char *)this + 208)), (float32x2_t)0x3F0000003F000000);
  *((void *)this + 26) = v26.n128_u64[0];
  unsigned int v27 = *((_DWORD *)this + 22);
  if (*((_DWORD *)this + 20) == 1)
  {
    if (v27 != 1) {
      goto LABEL_17;
    }
  }
  else if (v27 != 1)
  {
    goto LABEL_21;
  }
  unsigned int v27 = *((_DWORD *)this + 20);
LABEL_17:
  if (v27 > 0xF) {
    int v28 = 0;
  }
  else {
    int v28 = *((_DWORD *)this + v27 + 2);
  }
  *((unsigned char *)this + 280) = MTHandMotion::computeInnerOuterSpeedSymmetry(v25, (float *)(*((void *)a2 + 35) + 600 * *((int *)this + 3)), (float *)(*((void *)a2 + 35) + 600 * v28)) > 0.85;
LABEL_21:
  if (v21 > 0.0)
  {
    v26.n128_f32[0] = v20 / v21;
    *((float *)this + 54) = vmlas_n_f32(vmuls_lane_f32(v20 / v21, v35, 1), v19 / v21, v35.f32[0])
                          - (float)((float)(v24 * (float)(v20 / v21)) + (float)(v23 * (float)(v19 / v21)));
    *((float *)this + 55) = vmlas_n_f32(-(float)(v35.f32[1] * (float)(v19 / v21)), v20 / v21, v35.f32[0])
                          - (float)((float)(v23 * (float)(v20 / v21)) - (float)(v24 * (float)(v19 / v21)));
    if (a5 && *((_DWORD *)a4 + 34) && *((_DWORD *)a3 + 34) && ((v14 | v16) & 4) != 0)
    {
      float v29 = *((float *)a3 + 38) - *((float *)a4 + 38);
      float v30 = *((float *)a3 + 39) - *((float *)a4 + 39);
      float v31 = sqrtf((float)(v30 * v30) + (float)(v29 * v29));
      float v32 = *((float *)a3 + 112);
      float v33 = *((float *)a3 + 113);
      float32x2_t v34 = *(float32x2_t *)((char *)a4 + 448);
      *((float32x2_t *)this + 24) = vmul_f32(vadd_f32(v34, *(float32x2_t *)((char *)this + 192)), (float32x2_t)0x3F0000003F000000);
      v26.n128_f32[0] = vmlas_n_f32(-(float)(v34.f32[1] * (float)(v19 / v21)), v26.n128_f32[0], v34.f32[0])
                      - (float)((float)(v32 * v26.n128_f32[0]) - (float)(v33 * (float)(v19 / v21)));
      *((float *)this + 50) = v21 - v31;
      *((float *)this + 5MTHandMotion::clearHandMotion(this, 1) = v26.n128_f32[0];
    }
    if ((*((_DWORD *)a3 + 11) - 3) <= 1
      && (*((_DWORD *)a3 + 35) - 3) <= 1
      && MTParserPath::isFingerContact(a3)
      && *((unsigned __int8 *)this + 101) >= 3u)
    {
      MTHandMotion::combineCentralFingerScaleRotate((uint64_t)this, a2, a3);
    }
    if (*((unsigned char *)this + 138)
      || *((_DWORD *)this + 20) != 1 && *((_DWORD *)this + 22) != 1 && *((unsigned char *)this + 139)
      || *((unsigned __int8 *)this + 101) > 2u
      || *((unsigned char *)this + 376))
    {
      MTHandMotion::extractFastestFingerTranslation((BOOL)this, a2, v26);
    }
  }
}

uint64_t MTHandMotion::combineCentralFingerScaleRotate(uint64_t this, const MTPathStates *a2, const MTParserPath *a3)
{
  int v3 = *(_DWORD *)(this + 80) + 1;
  if (v3 < *(_DWORD *)(this + 88))
  {
    uint64_t v6 = this;
    int v7 = 0;
    float v8 = *((float *)a3 + 125);
    float v9 = *((float *)a3 + 126);
    float v10 = 0.0;
    float v11 = 0.0;
    do
    {
      if (v3 <= 0xF)
      {
        unsigned int v12 = *(_DWORD *)(v6 + 4 * v3 + 8);
        if ((int)v12 >= 1)
        {
          uint64_t v13 = *((void *)a2 + 35);
          this = v13 + 600 * v12;
          if ((*(_DWORD *)(this + 44) - 3) <= 1
            && (*(_DWORD *)(v13 + 600 * v12 + 140) - 3) <= 1)
          {
            this = MTParserPath::isFingerContact((MTParserPath *)this);
            if (this)
            {
              int v14 = (float *)(v13 + 600 * v12);
              float v15 = v14[14] - *((float *)a3 + 14);
              float v16 = v14[15] - *((float *)a3 + 15);
              float v17 = v14[38] - *((float *)a3 + 38);
              float v18 = sqrtf((float)(v16 * v16) + (float)(v15 * v15));
              float v10 = v10
                  + (float)(v18
                          - sqrtf((float)((float)(v14[39] - *((float *)a3 + 39)) * (float)(v14[39] - *((float *)a3 + 39)))+ (float)(v17 * v17)));
              float v11 = v11
                  + (float)((float)((float)(v14[126] * (float)(v16 / v18)) + (float)(v14[125] * (float)(v15 / v18)))
                          - (float)((float)(v9 * (float)(v16 / v18)) + (float)(v8 * (float)(v15 / v18))));
              ++v7;
            }
          }
        }
      }
      ++v3;
    }
    while (v3 < *(_DWORD *)(v6 + 88));
    if (v7 > 0)
    {
      float v19 = v10 / (float)v7;
      float v20 = v11 / (float)v7;
      float v21 = *(float *)(v6 + 200);
      if (fabsf(v19) > fabsf(v21)) {
        *(float *)(v6 + 200) = (float)(v19 + v21) * 0.5;
      }
      float v22 = *(float *)(v6 + 216);
      if (fabsf(v20) > fabsf(v22)) {
        *(float *)(v6 + 216) = (float)(v20 + v22) * 0.5;
      }
    }
  }
  return this;
}

BOOL MTHandMotion::extractFastestFingerTranslation(BOOL this, const MTPathStates *a2, __n128 a3)
{
  uint64_t v4 = this;
  uint64_t v5 = 0;
  uint64_t v6 = this + 12;
  float32x2_t v7 = 0;
  a3.n128_u64[0] = 0;
  __n128 v17 = a3;
  float32x2_t v8 = 0;
  do
  {
    unsigned int v9 = *(_DWORD *)(v6 + v5);
    if ((int)v9 >= 1)
    {
      uint64_t v10 = *((void *)a2 + 35);
      if ((*(_DWORD *)(v10 + 600 * v9 + 44) - 3) <= 1)
      {
        this = MTParserPath::isFingerContact((MTParserPath *)(v10 + 600 * v9));
        if (this)
        {
          uint64_t v11 = v10 + 600 * v9;
          float v12 = *(float *)(v11 + 536) + 0.5;
          int v13 = *(_DWORD *)(v4 + 128);
          if (v13 >= 1000 && v5 == 16 && v13 <= 0x7CF)
          {
            float v14 = (float)(v12 * 0.5) * 0.5;
            if (*(unsigned __int8 *)(v4 + 101) > 4u) {
              float v12 = v12 * 0.5;
            }
            else {
              float v14 = *(float *)(v11 + 536) + 0.5;
            }
          }
          else
          {
            float v14 = *(float *)(v11 + 536) + 0.5;
          }
          __n128 v15 = v17;
          v15.n128_f32[0] = v17.n128_f32[0] + v12;
          __n128 v17 = v15;
          float32x2_t v7 = vmla_n_f32(v7, *(float32x2_t *)(v11 + 448), v14);
          float32x2_t v8 = vmla_n_f32(v8, *(float32x2_t *)(v11 + 500), v14);
        }
      }
    }
    v5 += 4;
  }
  while (v5 != 20);
  if (v17.n128_f32[0] > 0.0)
  {
    float32x2_t v16 = (float32x2_t)vdup_lane_s32((int32x2_t)v17.n128_u64[0], 0);
    float32x2_t v7 = vdiv_f32(v7, v16);
    float32x2_t v8 = vdiv_f32(v8, v16);
  }
  *(float32x2_t *)(v4 + 192) = v7;
  *(float32x2_t *)(v4 + 208) = v8;
  return this;
}

float MTHandMotion::getSpeedSymmetry(MTHandMotion *this, float a2, int a3)
{
  switch(a3)
  {
    case 1:
      float v4 = *((float *)this + 68);
      goto LABEL_9;
    case 2:
      float v4 = *((float *)this + 67);
      goto LABEL_9;
    case 4:
      float v4 = *((float *)this + 66);
      goto LABEL_9;
    case 7:
      return 1.0 - powf(*((float *)this + 65), a2);
    default:
      if ((*((_DWORD *)this + 32) - 1000) > 0x3E7) {
        float v4 = *((float *)this + 64);
      }
      else {
        float v4 = *((float *)this + 65);
      }
LABEL_9:
      return powf(v4, a2);
  }
}

uint64_t MTHandMotion::fastest1FingerMask(MTHandMotion *this, const MTPathStates *a2, float *a3)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  float32x2_t v7 = (char *)this + 12;
  do
  {
    unsigned int v8 = *(_DWORD *)&v7[4 * v5];
    if ((int)v8 >= 1)
    {
      uint64_t v9 = *((void *)a2 + 35);
      if ((*(_DWORD *)(v9 + 600 * v8 + 44) - 3) <= 1
        && MTParserPath::isFingerContact((MTParserPath *)(v9 + 600 * v8))
        && !*(unsigned char *)(v9 + 600 * v8 + 581))
      {
        float v10 = *(float *)(v9 + 600 * v8 + 536);
        if (v10 > *a3)
        {
          uint64_t v6 = (1 << v5);
          *a3 = v10;
        }
      }
    }
    ++v5;
  }
  while (v5 != 5);
  return v6;
}

uint64_t MTHandMotion::fastest2FpairMask(MTHandMotion *this, const MTPathStates *a2)
{
  uint64_t v3 = 0;
  float v4 = (char *)this + 16;
  float v5 = 0.0;
  float v6 = 0.0;
  float v7 = 0.0;
  do
  {
    unsigned int v8 = *(_DWORD *)&v4[4 * v3];
    if ((int)v8 >= 1)
    {
      uint64_t v9 = *((void *)a2 + 35);
      if ((*(_DWORD *)(v9 + 600 * v8 + 44) - 3) <= 1)
      {
        MTParserPath::isFingerContact((MTParserPath *)(v9 + 600 * v8));
        switch((int)v3)
        {
          case 0:
            float v7 = v7 + *(float *)(v9 + 600 * v8 + 536);
            break;
          case 1:
            float v10 = *(float *)(v9 + 600 * v8 + 536);
            float v7 = v7 + v10;
            goto LABEL_8;
          case 2:
            float v10 = *(float *)(v9 + 600 * v8 + 536);
            float v5 = v5 + v10;
LABEL_8:
            float v6 = v6 + v10;
            break;
          case 3:
            float v5 = v5 + *(float *)(v9 + 600 * v8 + 536);
            break;
          default:
            break;
        }
      }
    }
    ++v3;
  }
  while (v3 != 4);
  if (v5 <= v6 || v5 <= v7) {
    unsigned int v12 = 6;
  }
  else {
    unsigned int v12 = 24;
  }
  if (v6 <= v5 || v6 <= v7) {
    return v12;
  }
  else {
    return 12;
  }
}

void MTHandMotion::computeSpeedSymmetry(MTHandMotion *this, const MTPathStates *a2, unsigned int a3, float a4, float a5)
{
  uint64_t v9 = 0;
  float v10 = (char *)this + 12;
  float v11 = 0.0;
  float v12 = 0.0;
  float v13 = 1.0;
  do
  {
    unsigned int v14 = *(_DWORD *)&v10[4 * v9];
    if ((int)v14 >= 1)
    {
      uint64_t v15 = *((void *)a2 + 35);
      uint64_t v16 = v15 + 600 * v14;
      if ((*(_DWORD *)(v16 + 44) - 3) <= 1)
      {
        float v17 = *(float *)(v16 + 536);
        if (MTParserPath::isFingerContact((MTParserPath *)(v15 + 600 * v14)))
        {
          float v18 = v17 + 1.0;
          if ((a3 >> v9))
          {
            float v13 = v13 * v18;
            float v12 = v12 + v18;
            float v11 = v11 + 1.0;
          }
          else if (a4 > 0.0 && !*(unsigned char *)(v15 + 600 * v14 + 581) && v18 <= a4)
          {
            float v13 = v13 * powf(1.0 - (float)(v18 / a4), a5);
          }
        }
      }
    }
    ++v9;
  }
  while (v9 != 5);
  if (v11 > 0.0) {
    pow(v13, 1.0 / v11);
  }
}

void MTHandMotion::computeSpeedSymmetries(MTHandMotion *this, const MTPathStates *a2, unsigned int a3)
{
  MTHandMotion::computeSpeedSymmetry(this, a2, 0x1Fu, 0.0, 1.0);
  *((_DWORD *)this + 64) = v6;
  MTHandMotion::computeSpeedSymmetry(this, a2, a3, 0.0, 1.0);
  *((_DWORD *)this + 65) = v7;
  float v14 = 0.0;
  unsigned __int16 v8 = MTHandMotion::fastest1FingerMask(this, a2, &v14);
  float v9 = v14;
  MTHandMotion::computeSpeedSymmetry(this, a2, v8, v14, 1.0);
  *((_DWORD *)this + 68) = v10;
  unsigned __int16 v11 = MTHandMotion::fastest2FpairMask(this, a2);
  MTHandMotion::computeSpeedSymmetry(this, a2, v11, v9, 2.0);
  *((_DWORD *)this + 67) = v12;
  MTHandMotion::computeSpeedSymmetry(this, a2, 0x1Eu, v9, 2.0);
  *((_DWORD *)this + 66) = v13;
}

void MTHandMotion::computeThreeFingerWithThumbSpeedSymmetry(MTHandMotion *this, const MTPathStates *a2)
{
  *((float *)this + 69) = MTPathStates::get_3F_IncludingThumbSpeedSymmetry(a2);
}

float MTHandMotion::computeTrackpadDominanceWeights(MTHandMotion *this, float *a2, float *a3)
{
  if (!*((unsigned char *)this + 138)
    && ((float result = *((float *)this + 87), *((_DWORD *)this + 20) == 1)
     || *((_DWORD *)this + 22) == 1
     || !*((unsigned char *)this + 139))
    && (unsigned int v4 = *((unsigned __int8 *)this + 101), v4 <= 2))
  {
    *a2 = 0.45;
    *a3 = 0.45;
  }
  else
  {
    float result = *((float *)this + 90);
    unsigned int v4 = *((unsigned __int8 *)this + 101);
    *a2 = 0.45;
    *a3 = 0.45;
    if (v4 == 5) {
      goto LABEL_7;
    }
  }
  if (*((_DWORD *)this + 20) != 1 && *((_DWORD *)this + 22) != 1)
  {
    if (v4 >= 3)
    {
      int v5 = 1036831949;
      goto LABEL_17;
    }
    if (result <= 55.0)
    {
      if (result <= 35.0)
      {
LABEL_23:
        float result = *((float *)this + 58);
        if (result < 0.0)
        {
          float v7 = *((float *)this + 57);
          if (v7 > 0.0)
          {
            float v8 = fabsf(*((float *)this + 56)) + fabsf(*((float *)this + 59));
            float result = v7 - result;
            if (result > 0.0 && v8 < result)
            {
              float result = *a2 / (float)(2.0 - (float)((float)(v8 / result) * (float)(v8 / result)));
              *a2 = result;
            }
          }
        }
        return result;
      }
      float v6 = (float)((float)(result + -35.0) / 20.0) + 0.45;
    }
    else
    {
      float v6 = 1.45;
    }
    *a2 = v6;
    *a3 = v6;
    goto LABEL_23;
  }
  if (v4 < 4)
  {
    int v5 = 1075629261;
    goto LABEL_17;
  }
  if (!*((unsigned char *)this + 280))
  {
LABEL_7:
    int v5 = 1069128090;
LABEL_17:
    *(_DWORD *)a2 = v5;
    *(_DWORD *)a3 = v5;
  }
  return result;
}

uint64_t MTHandMotion::computeMouseDominanceWeights(uint64_t this, float *a2, float *a3)
{
  *a2 = 1.1;
  *a3 = 1.2;
  if (*(_DWORD *)(this + 80) == 1 || *(_DWORD *)(this + 88) == 1)
  {
    *a2 = 1.4;
    *a3 = 1.6;
  }
  return this;
}

void MTHandMotion::clipMotionToDominantAxes(float32x2_t *this, double a2, int a3)
{
  float v6 = 1.0 - exp(-a2 / this[18].f32[0]);
  if (this[17].i8[2]
    || this[10].i32[0] != 1 && this[11].i32[0] != 1 && this[17].i8[3]
    || (float v7 = 1.0, this[12].u8[5] >= 3u))
  {
    float v7 = this[32].f32[0];
  }
  double v8 = 1.0 - v6;
  float32x2_t v9 = this[26];
  float32x2_t v10 = this[27];
  float64x2_t v11 = vmlaq_n_f64(vcvtq_f64_f32(vmul_n_f32(v9, v6)), vcvtq_f64_f32(this[28]), v8);
  this[31].i32[1] = 1065353216;
  float32x2_t v12 = vcvt_f32_f64(vmlaq_n_f64(vcvtq_f64_f32(vmul_n_f32(vmul_n_f32(v10, v7), v6)), vcvtq_f64_f32(this[29]), v8));
  this[28] = vcvt_f32_f64(v11);
  this[29] = v12;
  float v13 = (float)(sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v9, v9).i32[1]), v9.f32[0], v9.f32[0])) * v6)
      + v8 * this[30].f32[0];
  this[30].f32[0] = v13;
  unsigned int v36 = 1065353216;
  unsigned int v37 = 1065353216;
  unsigned int v14 = this[16].i32[0] - 2000;
  if (v14 > 0x3E7)
  {
    MTHandMotion::computeTrackpadDominanceWeights((MTHandMotion *)this, (float *)&v37, (float *)&v36);
    float32x2_t v15 = (float32x2_t)__PAIR64__(v36, v37);
  }
  else if (this[10].i32[0] == 1 || this[11].i32[0] == 1)
  {
    float32x2_t v15 = (float32x2_t)0x3FCCCCCD3FB33333;
  }
  else
  {
    float32x2_t v15 = (float32x2_t)0x3F99999A3F8CCCCDLL;
  }
  float32x2_t v16 = vmul_f32(vabs_f32(v12), v15);
  if (v16.f32[0] <= v16.f32[1]) {
    float v17 = v16.f32[1];
  }
  else {
    float v17 = v16.f32[0];
  }
  float v18 = (float *)&this[35] + 1;
  *(_OWORD *)&this[35].i32[1] = *(_OWORD *)this[28].f32;
  if (!a3)
  {
    if (this[47].i8[0]) {
      a3 = 3;
    }
    else {
      a3 = 0;
    }
  }
  if (v17 < v13)
  {
    if (v13 > 0.0) {
      this[31].f32[1] = v17 / v13;
    }
    if (this[19].i8[1]) {
      *(float32x2_t *)((char *)&this[36] + 4) = 0;
    }
    if (!this[19].i8[0]) {
      goto LABEL_49;
    }
    if ((a3 & 4) == 0) {
      this[25].i32[0] = 0;
    }
    if ((a3 & 8) != 0) {
      goto LABEL_49;
    }
LABEL_43:
    this[25].i32[1] = 0;
    goto LABEL_49;
  }
  if (v17 > 0.0) {
    this[31].f32[1] = v13 / v17;
  }
  int v19 = this[19].u8[1];
  if (this[19].i8[1]) {
    *(float32x2_t *)((char *)&this[35] + 4) = 0;
  }
  int v20 = this[19].u8[0];
  if ((a3 & 3) == 0 && this[19].i8[0]) {
    this[24] = 0;
  }
  if (a3) {
    int v21 = 1;
  }
  else {
    int v21 = 2;
  }
  if (v16.f32[0] <= (float)(v16.f32[1] * (float)v21))
  {
    if (v16.f32[1] > (float)(v16.f32[0] * (float)v21))
    {
      if (v19) {
        this[36].i32[1] = 0;
      }
      if (v20) {
        this[25].i32[0] = 0;
      }
    }
  }
  else
  {
    if (v19) {
      this[37].i32[0] = 0;
    }
    if (v20) {
      goto LABEL_43;
    }
  }
LABEL_49:
  float v22 = *v18;
  float v23 = fabsf(*v18);
  if (v14 <= 0x3E7)
  {
    float v24 = fabsf(this[36].f32[0]);
    if (v23 <= (float)(v24 * 2.4751))
    {
      if (v24 > (float)(v23 * 2.4751)) {
        this[24].i32[0] = 0;
      }
    }
    else
    {
      this[24].i32[1] = 0;
    }
    float v25 = fabsf(this[24].f32[0]);
    float v26 = fabsf(this[24].f32[1]);
    if (v25 <= (float)(v26 * 2.4751))
    {
      if (v26 > (float)(v25 * 2.4751)) {
        this[24].i32[0] = 0;
      }
    }
    else
    {
      this[24].i32[1] = 0;
    }
  }
  float v27 = this[18].f32[1];
  float v28 = 0.0;
  BOOL v29 = v23 < v27;
  float v30 = 0.0;
  if (!v29)
  {
    if (v22 <= 0.0) {
      float v30 = v22 + v27;
    }
    else {
      float v30 = v22 - v27;
    }
  }
  this[35].f32[1] = v30;
  float v31 = this[36].f32[0];
  if (fabsf(v31) >= v27)
  {
    if (v31 <= 0.0) {
      float v28 = v27 + v31;
    }
    else {
      float v28 = v31 - v27;
    }
  }
  this[36].f32[0] = v28;
  float v32 = this[36].f32[1];
  double v33 = 0.0;
  float v34 = 0.0;
  if (fabsf(v32) >= v27)
  {
    if (v32 <= 0.0) {
      float v34 = v27 + v32;
    }
    else {
      float v34 = v32 - v27;
    }
  }
  this[36].f32[1] = v34;
  float v35 = this[37].f32[0];
  if (fabsf(v35) >= v27)
  {
    if (v35 <= 0.0) {
      *(float *)&double v33 = v27 + v35;
    }
    else {
      *(float *)&double v33 = v35 - v27;
    }
  }
  this[37].i32[0] = LODWORD(v33);
  MTHandMotion::convertPixelDeltasTo_mm_s((MTHandMotion *)this, a2, v33);

  MTHandMotion::convertPixelVelocitiesTo_mm_s((MTHandMotion *)this);
}

void MTHandMotion::convertPixelDeltasTo_mm_s(MTHandMotion *this, double a2, double a3)
{
  double v3 = a2;
  LODWORD(a2) = *((_DWORD *)this + 48);
  LODWORD(a3) = *((_DWORD *)this + 49);
  MTSurfaceDimensions::convertPixelDeltasToMillimetersPerSecond(a2, a3, v3);
  *((_DWORD *)this + 79) = v5;
  *((_DWORD *)this + 80) = v6;
  *((float *)this + 8MTHandMotion::clearHandMotion(this, 1) = MTSurfaceDimensions::convertPixelDeltaToMillimetersPerSecond(*((MTSurfaceDimensions **)this + 15), *((float *)this + 50), v3);
  *((float *)this + 82) = MTSurfaceDimensions::convertPixelDeltaToMillimetersPerSecond(*((MTSurfaceDimensions **)this + 15), *((float *)this + 51), v3);
}

void MTHandMotion::convertPixelVelocitiesTo_mm_s(MTHandMotion *this)
{
  *((float *)this + 83) = MTSurfaceDimensions::convertPixelVelocityToMillimetersPerSecond(*((MTSurfaceDimensions **)this + 15), *((float *)this + 52));
  *((float *)this + 84) = MTSurfaceDimensions::convertPixelVelocityToMillimetersPerSecond(*((MTSurfaceDimensions **)this + 15), *((float *)this + 53));
  *((float *)this + 85) = MTSurfaceDimensions::convertPixelVelocityToMillimetersPerSecond(*((MTSurfaceDimensions **)this + 15), *((float *)this + 54));
  *((float *)this + 86) = MTSurfaceDimensions::convertPixelVelocityToMillimetersPerSecond(*((MTSurfaceDimensions **)this + 15), *((float *)this + 55));
}

float32x2_t MTHandMotion::updateFastestFingerSpeed(uint64_t a1, uint64_t a2)
{
  double v4 = *(double *)(a2 + 8) - *(double *)(a2 + 16);
  float v5 = 0.0;
  if (v4 <= 0.025) {
    float v5 = *(float *)(a1 + 368);
  }
  float v6 = *(float *)(a2 + 304);
  long double v7 = v4 / 0.00800000038;
  float v8 = pow(dbl_24074EEF0[v6 > v5], v4 / 0.00800000038);
  *(float *)(a1 + 368) = (float)(v6 * (float)(1.0 - v8)) + (float)(v8 * v5);
  long double v17 = exp2(-v7);
  LODWORD(v18) = *(void *)(a2 + 316);
  long double v9 = pow(0.949999988, v7);
  v10.f64[0] = v17;
  v10.f64[1] = v9;
  float32x2_t result = vcvt_f32_f64(v10);
  __asm { FMOV            V2.2S, #1.0 }
  *(float32x2_t *)(a1 + 244) = vmla_f32(vmul_n_f32(vsub_f32(_D2, result), v18), *(float32x2_t *)(a1 + 244), result);
  return result;
}

uint64_t MTHandMotion::makeCollectionEventMask(uint64_t a1, uint64_t a2)
{
  float v2 = (_DWORD *)(*(void *)(a2 + 280) + 644);
  uint64_t v3 = 31;
  do
  {
    int v4 = v2[80];
    if ((*v2 - 5) < 0xFFFFFFFE || (v2[80] & 4) == 0)
    {
      if ((v4 & 0x2000) == 0) {
        goto LABEL_8;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 140) |= 4u;
      if ((v4 & 0x2000) == 0)
      {
LABEL_8:
        if ((v4 & 0x800) == 0) {
          goto LABEL_9;
        }
        goto LABEL_13;
      }
    }
    *(_DWORD *)(a1 + 140) |= 0x2000u;
    if ((v4 & 0x800) == 0)
    {
LABEL_9:
      if ((v4 & 0x40000) == 0) {
        goto LABEL_16;
      }
      goto LABEL_14;
    }
LABEL_13:
    *(_DWORD *)(a1 + 140) |= 0x800u;
    if ((v4 & 0x40000) == 0) {
      goto LABEL_16;
    }
LABEL_14:
    int v6 = v4 & 0x6000000 | v4 & 0x8000000 | *(_DWORD *)(a1 + 140) | 0x40000;
    *(_DWORD *)(a1 + 140) = v6;
    if ((v4 & 0x1000000) != 0) {
      *(_DWORD *)(a1 + 140) = v6 | 0x1000000;
    }
LABEL_16:
    if ((v4 & 0x40) != 0)
    {
      *(_DWORD *)(a1 + 140) |= 0x40u;
      if ((v4 & 0x4000) == 0)
      {
LABEL_18:
        if ((v4 & 0x8000) == 0) {
          goto LABEL_20;
        }
LABEL_19:
        *(_DWORD *)(a1 + 140) |= 0x8000u;
        goto LABEL_20;
      }
    }
    else if ((v4 & 0x4000) == 0)
    {
      goto LABEL_18;
    }
    *(_DWORD *)(a1 + 140) |= 0x4000u;
    if ((v4 & 0x8000) != 0) {
      goto LABEL_19;
    }
LABEL_20:
    v2 += 150;
    --v3;
  }
  while (v3);
  return *(unsigned int *)(a1 + 140);
}

uint64_t MTHandMotion::processHandMotion(float32x2_t *this, const MTPathStates *a2, int a3, int a4, int a5, float a6, int a7, unsigned int a8)
{
  if ((this[16].i32[0] - 1000) <= 0xBB7)
  {
    float v15 = MTPathStates::restingTranslationCertainty(a2);
    this[46].f32[1] = v15;
    if (!a7)
    {
      int v16 = *((unsigned __int8 *)a2 + 444);
      if (*((_DWORD *)a2 + 96) - v16 == 2)
      {
        float v17 = this[45].f32[0];
        float v18 = 0.0;
        if (v17 > 40.0)
        {
          float v18 = 1.0;
          if (v17 < 50.0) {
            float v18 = (float)(v17 + -40.0) / 10.0;
          }
        }
        float v19 = v15 * v18;
        BOOL v21 = v18 >= 1.0 && v16 != 0;
        if (v19 > 0.9) {
          BOOL v21 = 1;
        }
      }
      else
      {
        BOOL v21 = 0;
      }
      this[47].i8[0] = v21;
    }
  }
  MTFingerToPathMap::updateFingerPathMappings((uint64_t)this, a2);
  if (a3 < 1)
  {
    MTHandMotion::clearHandMotion((MTHandMotion *)this, 0);
    uint64_t CollectionEventMask = 0;
    this[44].i32[1] = 0;
  }
  else
  {
    this[17].i32[1] = 0;
    MTHandMotion::updateFastestFingerSpeed((uint64_t)this, (uint64_t)a2);
    MTHandMotion::computeSpeedSymmetries((MTHandMotion *)this, a2, a8);
    this[34].f32[1] = MTPathStates::get_3F_IncludingThumbSpeedSymmetry(a2);
    if (a4 > a5)
    {
      this[28] = 0;
      this[29] = 0;
    }
    if (a4)
    {
      uint64_t InnermostTouchingPath = MTFingerToPathMap::getInnermostTouchingPath((MTFingerToPathMap *)this, a2);
      OutermostTouchingPath = (const MTParserPath *)MTFingerToPathMap::getOutermostTouchingPath((MTFingerToPathMap *)this, a2);
      float v24 = (MTHandMotion *)this;
      float v25 = a2;
      float v26 = (const MTParserPath *)InnermostTouchingPath;
      int v27 = 1;
    }
    else
    {
      uint64_t InnermostInRangePath = MTFingerToPathMap::getInnermostInRangePath((MTFingerToPathMap *)this, a2);
      OutermostTouchingPath = (const MTParserPath *)MTFingerToPathMap::getOutermostInRangePath((MTFingerToPathMap *)this, a2);
      float v24 = (MTHandMotion *)this;
      float v25 = a2;
      float v26 = (const MTParserPath *)InnermostInRangePath;
      int v27 = 0;
    }
    MTHandMotion::extractHandMotion(v24, v25, v26, OutermostTouchingPath, v27);
    MTHandMotion::clipMotionToDominantAxes(this, *((double *)a2 + 1) - *((double *)a2 + 2), a7);
    if (this[24].f32[0] != 0.0 || this[24].f32[1] != 0.0 || this[25].f32[0] != 0.0 || this[25].f32[1] != 0.0) {
      this[20] = *(float32x2_t *)((char *)a2 + 8);
    }
    uint64_t CollectionEventMask = MTHandMotion::makeCollectionEventMask((uint64_t)this, (uint64_t)a2);
    this[17].i32[1] = CollectionEventMask;
  }
  MTPathStatesBasic::calculateCentroidOfPaths((uint64_t)a2, this + 23, v28);
  return CollectionEventMask;
}

uint64_t MTHandMotion::storeFeedbackFromMouse(uint64_t result, float a2, float a3)
{
  *(float *)(result + 108) = a2;
  *(float *)(result + 112) = a3;
  return result;
}

float MTHandMotion::getMouseMotionFeedback(MTHandMotion *this, int a2)
{
  if (a2 == 1)
  {
    float v2 = *((float *)this + 27);
    float v3 = *((float *)this + 28) * 0.8;
    float v4 = 0.7;
    return v3 + (float)(v2 * v4);
  }
  if (!a2)
  {
    float v2 = *((float *)this + 27);
    float v3 = *((float *)this + 28) * 0.7;
    float v4 = 0.8;
    return v3 + (float)(v2 * v4);
  }
  return hypotf(*((float *)this + 27), *((float *)this + 28));
}

uint64_t MTHandMotion::storeFeedbackFromButton(uint64_t this, float a2)
{
  *(float *)(this + 116) = a2;
  return this;
}

float MTHandMotion::getButtonMotionFeedback(MTHandMotion *this)
{
  return *((float *)this + 29);
}

uint64_t MTHandStatistics::MTHandStatistics(uint64_t a1, int a2, uint64_t a3, int a4, int a5)
{
  *(void *)a1 = &unk_26F4D9250;
  *(_DWORD *)(a1 + 24) = a2;
  *(_DWORD *)(a1 + 164) = a4;
  *(_DWORD *)(a1 + 168) = a5;
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = 0;
  MTHandStatistics::clear((MTHandStatistics *)a1, 0);
  return a1;
}

{
  *(void *)a1 = &unk_26F4D9250;
  *(_DWORD *)(a1 + 24) = a2;
  *(_DWORD *)(a1 + 164) = a4;
  *(_DWORD *)(a1 + 168) = a5;
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = 0;
  MTHandStatistics::clear((MTHandStatistics *)a1, 0);
  return a1;
}

double MTHandStatistics::clear(MTHandStatistics *this, int a2)
{
  if (a2)
  {
    *((unsigned char *)this + 203) = *((unsigned char *)this + 202);
    *((_WORD *)this + 77) = *((_WORD *)this + 76);
    *((_WORD *)this + 79) = *((_WORD *)this + 78);
    *((unsigned char *)this + 192) = *((unsigned char *)this + 191);
    *((unsigned char *)this + 187) = *((unsigned char *)this + 186);
    *((unsigned char *)this + 194) = *((unsigned char *)this + 193);
    *((unsigned char *)this + 189) = *((unsigned char *)this + 188);
    char v2 = *((unsigned char *)this + 298);
    *((unsigned char *)this + 299) = v2;
    *((unsigned char *)this + 303) = v2;
    *((unsigned char *)this + 190) = *((unsigned char *)this + 211);
    *((_DWORD *)this + 78) = *((_DWORD *)this + 77);
    uint64_t v3 = *((void *)this + 33);
    char v4 = *((unsigned char *)this + 316);
  }
  else
  {
    char v4 = 0;
    *(_WORD *)((char *)this + 305) = 0;
    *((_DWORD *)this + 5MTHandMotion::clearHandMotion(this, 1) = 0;
    *((unsigned char *)this + 203) = 0;
    *((unsigned char *)this + 192) = 0;
    *((unsigned char *)this + 187) = 0;
    *((unsigned char *)this + 194) = 0;
    *(_WORD *)((char *)this + 189) = 0;
    *((_WORD *)this + 77) = 0;
    *((_WORD *)this + 79) = 0;
    *((unsigned char *)this + 299) = 0;
    *((unsigned char *)this + 303) = 0;
    *((_DWORD *)this + 78) = 0;
    *((_OWORD *)this + 3) = 0u;
    *((_OWORD *)this + 4) = 0u;
    *((_OWORD *)this + 5) = 0u;
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = 0u;
    *((_OWORD *)this + 8) = 0u;
    *((void *)this + 18) = 0;
    *((_WORD *)this + 92) = 0;
    *((void *)this + 22) = 0;
    *(_DWORD *)((char *)this + 197) = 0;
    *(void *)((char *)this + 212) = 0;
    *((void *)this + 32) = 0;
    *((void *)this + 33) = 0;
    uint64_t v3 = 0;
    *((void *)this + 35) = 0;
    *((void *)this + 36) = 0;
  }
  *((void *)this + 34) = v3;
  *((unsigned char *)this + 317) = v4;
  *(_WORD *)((char *)this + 20MTHandMotion::clearHandMotion(this, 1) = 0;
  *((unsigned char *)this + 19MTHandMotion::clearHandMotion(this, 1) = 0;
  *((unsigned char *)this + 186) = 0;
  *((unsigned char *)this + 193) = 0;
  *((unsigned char *)this + 188) = 0;
  *((_DWORD *)this + 77) = 0;
  *(_WORD *)((char *)this + 195) = 0;
  *((_WORD *)this + 76) = 0;
  *((_WORD *)this + 78) = 0;
  *((_WORD *)this + 110) = 0;
  *((unsigned char *)this + 222) = 0;
  *(void *)&double result = 0xFFFFFFFFLL;
  *((_OWORD *)this + 14) = xmmword_24074EF10;
  *((_DWORD *)this + 40) = 0;
  *((_DWORD *)this + 52) = 0;
  *((_DWORD *)this + 43) = 0;
  *((_WORD *)this + 148) = 0;
  *((_WORD *)this + 150) = 0;
  *((unsigned char *)this + 298) = 0;
  *((unsigned char *)this + 302) = 0;
  *((unsigned char *)this + 304) = 0;
  *((unsigned char *)this + 316) = 0;
  return result;
}

void MTHandStatistics::~MTHandStatistics(MTHandStatistics *this)
{
  *(void *)this = &unk_26F4D9250;
  MTHandStatistics::clear(this, 0);
}

{
  *(void *)this = &unk_26F4D9250;
  MTHandStatistics::clear(this, 0);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26F4D9250;
  MTHandStatistics::clear(this, 0);

  JUMPOUT(0x2455F6CE0);
}

uint64_t MTHandStatistics::clearConsecutiveCounts(uint64_t this)
{
  *(_DWORD *)(this + 214) = 0;
  *(_WORD *)(this + 218) = 0;
  return this;
}

uint64_t MTHandStatistics::rollBackSubsetBoundary(uint64_t this)
{
  *(void *)(this + 256) = 0;
  *(_DWORD *)(this + 214) = 0;
  *(_WORD *)(this + 218) = 0;
  return this;
}

uint64_t MTHandStatistics::updateCumulativeMaxStats(uint64_t this)
{
  if (*(_DWORD *)(this + 224) == -1) {
    *(_DWORD *)(this + 224) = 0;
  }
  if (*(_DWORD *)(this + 232) == -1) {
    *(_DWORD *)(this + 232) = 0;
  }
  if (*(_DWORD *)(this + 236) == -1) {
    *(_DWORD *)(this + 236) = 0;
  }
  unsigned int v1 = *(unsigned __int8 *)(this + 186);
  if (*(unsigned char *)(this + 186))
  {
    if (v1 > *(unsigned __int8 *)(this + 197)) {
      *(unsigned char *)(this + 197) = v1;
    }
    unsigned int v2 = *(unsigned __int8 *)(this + 195);
    if (v2 > *(unsigned __int8 *)(this + 198)) {
      *(unsigned char *)(this + 198) = v2;
    }
    if (v1 >= 2)
    {
      uint64_t v3 = *(void *)(this + 8);
      *(void *)(this + 112) = v3;
      if (v1 == 5) {
        *(void *)(this + 120) = v3;
      }
    }
  }
  unsigned int v4 = *(unsigned __int8 *)(this + 191);
  if (*(unsigned char *)(this + 191))
  {
    if (v4 > *(unsigned __int8 *)(this + 199)) {
      *(unsigned char *)(this + 199) = v4;
    }
  }
  else if (!*(unsigned char *)(this + 192))
  {
    *(unsigned char *)(this + 197) = 0;
    *(_DWORD *)(this + 204) = 0;
    *(unsigned char *)(this + 200) = *(unsigned char *)(this + 199);
    *(unsigned char *)(this + 199) = 0;
    *(void *)(this + 64) = 0;
  }
  if (!*(unsigned char *)(this + 195)) {
    *(unsigned char *)(this + 198) = 0;
  }
  if (*(unsigned __int8 *)(this + 298) != *(unsigned __int8 *)(this + 299)) {
    *(void *)(this + 280) = *(void *)(this + 8);
  }
  double v5 = *(double *)(this + 272);
  if (*(double *)(this + 264) < v5) {
    *(double *)(this + 264) = v5;
  }
  if (*(_WORD *)(this + 214) == 2 && *(_WORD *)(this + 220) == 7)
  {
    *(void *)(this + 256) = 0;
    *(_DWORD *)(this + 214) = 0;
    *(_WORD *)(this + 218) = 0;
  }
  return this;
}

uint64_t MTHandStatistics::updateStatsWithPath(uint64_t this, const MTParserPath *a2, int a3, int a4)
{
  uint64_t v6 = this;
  if (a3)
  {
    ++*(unsigned char *)(this + 202);
    if (MTParserPath::isEdgeContact(a2)) {
      ++*(unsigned char *)(v6 + 208);
    }
    if (MTParserPath::isUnidentifiedContact(a2)) {
      ++*(unsigned char *)(v6 + 209);
    }
    this = MTParserPath::wasFingerContact(a2);
    if (this)
    {
      this = MTParserPath::isPalmContact(a2);
      if (this) {
        ++*(unsigned char *)(v6 + 210);
      }
    }
  }
  if (a4)
  {
    if (*((_DWORD *)a2 + 11) == 7) {
      long double v7 = (char *)a2 + 144;
    }
    else {
      long double v7 = (char *)a2 + 48;
    }
    *(_WORD *)(v6 + 220) |= 1 << (*(_DWORD *)v7 - 1);
  }
  return this;
}

uint64_t MTHandStatistics::updateStatsWithFingerPath(uint64_t result, int a2, int a3, uint64_t a4, int a5, int a6, int a7, int a8, float a9, float a10, float a11, char a12, char a13, char a14)
{
  if (a5 && (a12 & 1) == 0)
  {
    ++*(unsigned char *)(result + 191);
    *(_WORD *)(result + 152) |= 1 << (a3 - 1);
    if (a3 != 1) {
      ++*(unsigned char *)(result + 196);
    }
    if (*(double *)(result + 64) == 0.0) {
      *(void *)(result + 64) = *(void *)a4;
    }
  }
  if (a6)
  {
    if (a12)
    {
      ++*(unsigned char *)(result + 211);
      if (a3 == 1) {
        *(void *)(result + 104) = *(void *)(a4 + 16);
      }
    }
    else
    {
      ++*(unsigned char *)(result + 186);
      if (*(float *)(result + 204) < a11) {
        *(float *)(result + 204) = a11;
      }
      if (a3 != 1)
      {
        ++*(unsigned char *)(result + 195);
        double v17 = *(double *)(a4 + 16);
        if (v17 > *(double *)(result + 96)) {
          *(double *)(result + 96) = v17;
        }
      }
    }
    if ((a7 & 1) != 0
      || (*(void *)(result + 88) = *(void *)(result + 80),
          uint64_t v18 = *(void *)(a4 + 16),
          *(void *)(result + 72) = *(void *)a4,
          *(void *)(result + 80) = v18,
          *(_DWORD *)(result + 176) = a2,
          *(unsigned char *)(result + 187)))
    {
      if (a12) {
        return result;
      }
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 32))(result);
    }
    *(void *)(result + 56) = v18;
    if ((a12 & 1) == 0) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 32))(result);
    }
  }
  else
  {
    if (a7)
    {
      *(_WORD *)(result + 218) = 0;
      double v14 = *(double *)(result + 128);
      if (v14 < *(double *)(result + 80)) {
        *(_DWORD *)(result + 214) = 0;
      }
      double v15 = *(double *)(a4 + 40);
      if (v14 < v15)
      {
        *(double *)(result + 128) = v15;
        *(_DWORD *)(result + 180) = a2;
        *(unsigned char *)(result + 184) = a3 == 1;
        *(unsigned char *)(result + 185) = a14;
        *(void *)(result + 240) = *(void *)(result + 248);
        *(float *)(result + 248) = a9;
        *(float *)(result + 252) = a10;
      }
      ++*(_WORD *)(result + 216);
      if (a3 != 1 || *(unsigned char *)(result + 187) == 5) {
        ++*(_WORD *)(result + 214);
      }
    }
    if (a8)
    {
      double v16 = *(double *)(a4 + 48);
      if (*(double *)(result + 136) < v16) {
        *(double *)(result + 136) = v16;
      }
    }
  }
  return result;
}

uint64_t MTHandStatistics::updateSubsetStatsWithFingerPath(uint64_t result, uint64_t a2, char a3, uint64_t a4, char a5, int a6, char a7)
{
  if ((a5 & 1) == 0)
  {
    __int16 v7 = *(_WORD *)(result + 218);
    if (!v7) {
      *(_WORD *)(result + 212) = *(unsigned __int8 *)(result + 190) + *(unsigned __int8 *)(result + 187);
    }
    *(_WORD *)(result + 218) = v7 + 1;
  }
  double v8 = *(double *)(a4 + 16);
  double v9 = *(double *)(result + 128);
  if (v8 > v9 && v8 < v9 + 0.02)
  {
    signed int v11 = 0;
    *(_DWORD *)(result + 214) = 0;
    *(_WORD *)(result + 218) = 0;
  }
  else
  {
    signed int v11 = *(unsigned __int16 *)(result + 218);
  }
  float32x2_t v12 = (signed int *)&MTHandStatistics::kMinClutchingSubsetSizeFrom4F;
  unsigned int v13 = v11 + *(unsigned __int16 *)(result + 212);
  if (v13 != 4) {
    float32x2_t v12 = (signed int *)&MTHandStatistics::kMinClutchingSubsetSizeFrom5F;
  }
  if (v8 <= v9
    || *(double *)(result + 256) >= v9
    || *(unsigned char *)(result + 299)
    && !*(unsigned char *)(result + 304)
    && ((v14 = *v12, v15 = *(unsigned __int16 *)(result + 214), v14 <= (int)v15) ? (BOOL v16 = v14 <= v11) : (BOOL v16 = 0),
        v16 ? (BOOL v17 = v13 >= 4) : (BOOL v17 = 0),
        !v17 || (a7 & 1) != 0 || v15 <= 1 && *(unsigned char *)(result + 185)))
  {
    double v9 = *(double *)(result + 256);
    if ((*(_DWORD *)(result + 164) - 2000) <= 0x3E7 && v8 - v9 > 0.5)
    {
      double v9 = *(double *)(a4 + 8);
      *(double *)(result + 256) = v9;
    }
  }
  else
  {
    *(double *)(result + 256) = v9;
    *(unsigned char *)(result + 304) = 1;
  }
  if (v8 >= v9 || (*(_DWORD *)(result + 164) - 1000) <= 0x3E7)
  {
    ++*(unsigned char *)(result + 298);
    int v19 = 1 << (a3 - 1);
    *(_WORD *)(result + 296) |= v19;
    double v20 = *(double *)(result + 264);
    double v21 = *(double *)(a4 + 16);
    BOOL v22 = v20 <= v9 || v21 < v20;
    if (v22 || *(unsigned char *)(result + 304))
    {
      *(double *)(result + 264) = v21;
      *(unsigned char *)(result + 304) = 0;
    }
    if (a6)
    {
      ++*(unsigned char *)(result + 302);
      *(_WORD *)(result + 300) |= v19;
    }
  }
  return result;
}

uint64_t MTHandStatistics::updateStatsWithNonFingerPath(uint64_t result, _DWORD *a2, int a3, int a4)
{
  int v4 = a2[11];
  double v5 = a2 + 36;
  if (v4 != 7) {
    double v5 = a2 + 12;
  }
  int v6 = *v5;
  if (v6 != 15)
  {
    if (v4 == 1)
    {
      ++*(unsigned char *)(result + 201);
      if (!a3)
      {
LABEL_6:
        if (!a4) {
          return result;
        }
        goto LABEL_7;
      }
    }
    else if (!a3)
    {
      goto LABEL_6;
    }
    ++*(unsigned char *)(result + 193);
    *(_WORD *)(result + 156) |= 1 << (v6 - 1);
    if (!a4) {
      return result;
    }
LABEL_7:
    ++*(unsigned char *)(result + 188);
  }
  return result;
}

uint64_t MTHandStatistics::makeCollectionEventMask(MTHandStatistics *this, int a2)
{
  int v2 = *((_DWORD *)this + 42);
  BOOL v3 = (v2 & 0x10) == 0 || *((unsigned __int8 *)this + 193) > *((unsigned __int8 *)this + 194);
  if (!*((unsigned char *)this + 186))
  {
    if (!*((unsigned char *)this + 187)) {
      goto LABEL_6;
    }
LABEL_9:
    unsigned int v4 = 2;
    if ((v2 & 0x20) != 0) {
      goto LABEL_21;
    }
    goto LABEL_10;
  }
  if (!*((unsigned char *)this + 187)) {
    goto LABEL_9;
  }
LABEL_6:
  if ((v2 & 0x20) != 0)
  {
    if (*((unsigned char *)this + 189) && !*((unsigned char *)this + 188)) {
      unsigned int v4 = 2;
    }
    else {
      unsigned int v4 = 0;
    }
    goto LABEL_21;
  }
  unsigned int v4 = 0;
LABEL_10:
  if (!*((unsigned char *)this + 191) && *((unsigned char *)this + 192))
  {
    int v5 = v3 ? v4 | 0x80 : v4;
    if (*((unsigned __int8 *)this + 209) + *((unsigned __int8 *)this + 208) < *((unsigned __int8 *)this
                                                                                             + 202))
      unsigned int v4 = v5;
  }
LABEL_21:
  LODWORD(v6) = v4 | 0x80;
  if (a2) {
    uint64_t v6 = v6;
  }
  else {
    uint64_t v6 = v4;
  }
  int v7 = *((unsigned __int16 *)this + 76);
  int v8 = *((unsigned __int16 *)this + 77);
  if (*((_WORD *)this + 76))
  {
    if (!*((_WORD *)this + 77)) {
      goto LABEL_30;
    }
    if ((v2 & 0x20) == 0)
    {
      if (v7 == v8) {
        return v6;
      }
      return v6 | 0x20;
    }
  }
  else
  {
    if (*((_WORD *)this + 77)) {
      goto LABEL_30;
    }
    if ((v2 & 0x20) == 0) {
      return v6;
    }
    int v8 = 0;
  }
  if (*((_WORD *)this + 79))
  {
    if (*((_WORD *)this + 78)) {
      goto LABEL_31;
    }
  }
  else if (!*((_WORD *)this + 78))
  {
    goto LABEL_31;
  }
LABEL_30:
  uint64_t v6 = v6 | 1;
LABEL_31:
  if (v7 != v8 || (v2 & 0x20) != 0 && *((unsigned __int16 *)this + 78) != *((unsigned __int16 *)this + 79)) {
    return v6 | 0x20;
  }
  return v6;
}

void MTParser::MTParser(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5)
{
  *(void *)a1 = &unk_26F4D92D0;
  *(_DWORD *)(a1 + 8) = 1;
  *(void *)(a1 + 24) = a2;
  *(_DWORD *)(a1 + 32) = a3;
  *(_DWORD *)(a1 + 36) = a4;
  *(void *)(a1 + 40) = a5;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  MTDragManagerEventQueue::MTDragManagerEventQueue((MTDragManagerEventQueue *)(a1 + 80));
  *(void *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  int v7 = *(const void **)(a1 + 24);
  if (v7) {
    CFRetain(v7);
  }
  if (*(void *)(a1 + 40))
  {
    MTDeviceIsBuiltIn();
    operator new();
  }
  *(void *)(a1 + 16) = 0;
  uint64_t v8 = MTEmbeddedStats::create(a2);
  std::shared_ptr<MTEmbeddedStats>::reset[abi:ne180100]<MTEmbeddedStats,void>(a1 + 224, v8);
}

void sub_240708478(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v2, 0x1020C405EDD67E7);
  unsigned int v4 = *(std::__shared_weak_count **)(v1 + 232);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  _Unwind_Resume(a1);
}

void std::shared_ptr<MTEmbeddedStats>::reset[abi:ne180100]<MTEmbeddedStats,void>(uint64_t a1, uint64_t a2)
{
  std::shared_ptr<MTEmbeddedStats>::shared_ptr[abi:ne180100]<MTEmbeddedStats,void>(&v2, a2);
}

void MTParser::~MTParser(MTParser *this)
{
  *(void *)this = &unk_26F4D92D0;
  uint64_t v2 = *((void *)this + 9);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    *((void *)this + 9) = 0;
  }
  BOOL v3 = (const void *)*((void *)this + 3);
  if (v3)
  {
    CFRelease(v3);
    *((void *)this + 3) = 0;
  }
  unsigned int v4 = (const void *)*((void *)this + 2);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 2) = 0;
  }
  uint64_t v5 = *((void *)this + 6);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 7);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *((void *)this + 8);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = *((void *)this + 5);
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  double v9 = (MTForceManagement *)*((void *)this + 25);
  if (v9)
  {
    MTForceManagement::~MTForceManagement(v9);
    MEMORY[0x2455F6CE0]();
  }
  float64x2_t v10 = (MTActuatorManagement *)*((void *)this + 26);
  if (v10)
  {
    MTActuatorManagement::~MTActuatorManagement(v10);
    MEMORY[0x2455F6CE0]();
  }
  uint64_t v11 = *((void *)this + 27);
  if (v11) {
    MEMORY[0x2455F6CE0](v11, 0x1020C40774E108FLL);
  }
  float32x2_t v12 = (std::__shared_weak_count *)*((void *)this + 29);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
}

{
  uint64_t vars8;

  MTParser::~MTParser(this);

  JUMPOUT(0x2455F6CE0);
}

uint64_t MTParser::retain(uint64_t this)
{
  if (!atomic_load((unsigned int *)(this + 8))) {
    MTParser::retain();
  }
  atomic_fetch_add((atomic_uint *volatile)(this + 8), 1u);
  return this;
}

unsigned int *MTParser::release(unsigned int *this)
{
  if (!atomic_load(this + 2)) {
    MTParser::release();
  }
  if (atomic_fetch_add((atomic_uint *volatile)this + 2, 0xFFFFFFFF) == 1)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)this + 8);
    return (unsigned int *)v2();
  }
  return this;
}

void MTParser::createParserForMTDevice(uint64_t a1, unsigned int a2)
{
  if (a2 >= 0x3E8) {
    operator new();
  }
  if (a2 != 4)
  {
    if (a2 == 2) {
      operator new();
    }
    operator new();
  }
  operator new();
}

void sub_240708A0C(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x1081C4003DAF236);
  _Unwind_Resume(a1);
}

void MTParser::createMotionAxisChildEvents(uint64_t a1, uint64_t a2, float *a3)
{
  if (a3[48] != 0.0 || a3[49] != 0.0)
  {
    uint64_t TranslationEvent = IOHIDEventCreateTranslationEvent();
    if (TranslationEvent)
    {
      uint64_t v5 = (const void *)TranslationEvent;
      IOHIDEventAppendEvent();
      CFRelease(v5);
    }
  }
  if (a3[71] != 0.0 || a3[72] != 0.0)
  {
    uint64_t VelocityEvent = IOHIDEventCreateVelocityEvent();
    if (VelocityEvent)
    {
      uint64_t v7 = (const void *)VelocityEvent;
      IOHIDEventAppendEvent();
      CFRelease(v7);
    }
  }
  if (a3[50] != 0.0 || a3[51] != 0.0)
  {
    uint64_t PolarOrientationEvent = IOHIDEventCreatePolarOrientationEvent();
    if (PolarOrientationEvent)
    {
      double v9 = (const void *)PolarOrientationEvent;
      IOHIDEventAppendEvent();
      CFRelease(v9);
    }
    uint64_t v10 = IOHIDEventCreatePolarOrientationEvent();
    if (v10)
    {
      uint64_t v11 = (const void *)v10;
      IOHIDEventAppendEvent();
      CFRelease(v11);
    }
  }
}

void MTParser::createDigitizerChildEventForPath(uint64_t a1, int a2, MTParserPath *this, uint64_t a4, char a5, int a6)
{
  uint64_t v8 = *(void *)(a1 + 64);
  if (v8 && *(unsigned char *)(v8 + 144))
  {
    float v9 = *((float *)this + 109);
    float v10 = *((float *)this + 108);
  }
  else
  {
    float v10 = 0.0;
    float v9 = 0.0;
  }
  if ((*((_DWORD *)this + 11) - 3) < 2) {
    int v11 = a6 ^ 1;
  }
  else {
    int v11 = 0;
  }
  uint64_t v12 = *(void *)(a1 + 40);
  MTParserPath::getQuantizedMinorRadius_mm(this);
  MTSurfaceDimensions::convertMillimetersToSurfaceFraction(v12, 0.0);
  uint64_t v13 = *(void *)(a1 + 40);
  MTParserPath::getQuantizedMajorRadius_mm(this);
  MTSurfaceDimensions::convertMillimetersToSurfaceFraction(v13, 0.0);
  float v14 = v10 + *((float *)this + 100);
  float v15 = v9 + *((float *)this + 101);
  MTSurfaceDimensions::convertPixelsToSurfaceFraction(*(void *)(a1 + 40), v14);
  MTDeviceGetExtendedMaxDigitizerPressureValue();
  int isStylusContact = MTParserPath::isStylusContact(this);
  MTDeviceNotifyWorkInterval();
  if (isStylusContact)
  {
    _H0 = *((_WORD *)this + 55);
    __asm { FCVT            D2, H0 }
    DigitizerStylusEventWithPolarOrientation = (const void *)IOHIDEventCreateDigitizerStylusEventWithPolarOrientation();
    IOHIDEventSetFloatValue();
    IOHIDEventSetFloatValue();
    IOHIDEventSetFloatValue();
    IOHIDEventSetFloatValue();
    IOHIDEventSetIntegerValue();
    IOHIDEventSetIntegerValue();
    IOHIDEventSetIntegerValue();
    if ((*((_WORD *)this + 54) & 0x2000) != 0) {
      IOHIDEventSetIntegerValue();
    }
    if (*((unsigned char *)this + 488))
    {
      uint64_t VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
      if (VendorDefinedEvent)
      {
        float v25 = (const void *)VendorDefinedEvent;
        IOHIDEventAppendEvent();
        CFRelease(v25);
      }
    }
  }
  else
  {
    MTContact_getEllipseOrientationDegrees();
    DigitizerStylusEventWithPolarOrientation = (const void *)IOHIDEventCreateDigitizerFingerEventWithQuality();
    IOHIDEventSetIntegerValue();
  }
  if (DigitizerStylusEventWithPolarOrientation)
  {
    uint64_t v26 = *(void *)(a1 + 40);
    MTParserPath::getQuantizedRadiusAccuracy_mm(this);
    MTSurfaceDimensions::convertMillimetersToSurfaceFraction(v26, 0.0);
    IOHIDEventSetFloatValue();
    IOHIDEventGetPhase();
    __int16 v27 = *((_WORD *)this + 54);
    if ((v27 & 0x4000) != 0) {
      IOHIDEventSetPhase();
    }
    if (!v11) {
      goto LABEL_34;
    }
    if (MTDeviceShouldDispatchNormalizedVelocity())
    {
      MTSurfaceDimensions::convertPixelsToSurfaceFraction(*(void *)(a1 + 40), *((float *)this + 16));
    }
    else if (*(_DWORD *)(a1 + 32) != 1001)
    {
LABEL_24:
      if (MTDeviceShouldDispatchRelativeCoordinates())
      {
        if ((a5 & 4) != 0)
        {
          uint64_t v30 = *(void *)(a1 + 64);
          float v31 = 0.0;
          if (v30)
          {
            float v32 = 0.0;
            if (*(unsigned char *)(v30 + 144))
            {
              float v32 = *((float *)this + 110);
              float v31 = *((float *)this + 111);
            }
          }
          else
          {
            float v32 = 0.0;
          }
          float v33 = v31 + *((float *)this + 103);
          float v34 = v14 - (float)(v32 + *((float *)this + 102));
          float v35 = v15 - v33;
          MTSurfaceDimensions::convertPixelDeltaToMillimeters(*(MTSurfaceDimensions **)(a1 + 40), v34, 0);
          MTSurfaceDimensions::convertPixelDeltaToMillimeters(*(MTSurfaceDimensions **)(a1 + 40), v35, 1);
        }
        MTContact_getEllipseOrientationDegrees();
        DigitizerFingerEventWithQuality = (const void *)IOHIDEventCreateDigitizerFingerEventWithQuality();
        IOHIDEventGetEventFlags();
        IOHIDEventSetEventFlags();
        IOHIDEventSetFloatValue();
        if ((v27 & 0x4000) != 0) {
          IOHIDEventSetPhase();
        }
        IOHIDEventSetIntegerValue();
        IOHIDEventAppendEvent();
        CFRelease(DigitizerFingerEventWithQuality);
      }
LABEL_34:
      IOHIDEventAppendEvent();
      CFRelease(DigitizerStylusEventWithPolarOrientation);
      return;
    }
    uint64_t VelocityEvent = IOHIDEventCreateVelocityEvent();
    if (VelocityEvent)
    {
      BOOL v29 = (const void *)VelocityEvent;
      IOHIDEventAppendEvent();
      CFRelease(v29);
    }
    goto LABEL_24;
  }
}

void MTParser::createDigitizerPathChildEvents(uint64_t a1, int a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = 964;
  uint64_t v8 = 31;
  unsigned int v38 = *(_DWORD *)(a1 + 36);
  do
  {
    float v9 = (int *)(*(void *)(a3 + 280) + v7);
    int v10 = *(v9 - 79);
    if ((*(v9 - 81) - 32) >= 0xFFFFFFE1 && v10 != 15)
    {
      uint64_t v12 = (MTParserPath *)(v9 - 91);
      int v13 = *v9;
      unsigned int v14 = v10 - 1;
      BOOL v15 = v10 != 0;
      unsigned int v16 = *(v9 - 55) - 1;
      unsigned int v17 = *(v9 - 80) - 5;
      int v18 = *(v9 - 56) - 5;
      int v20 = (v38 >> 5) & 1;
      if (v14 > 4) {
        int v20 = 1;
      }
      BOOL v29 = __CFADD__(v18, 2);
      BOOL v19 = v14 > 4;
      int v21 = v19 & (a4 >> 7);
      if (v29) {
        int v22 = v19 & (a4 >> 7);
      }
      else {
        int v22 = 1;
      }
      if (v16 > 4) {
        int v22 = 1;
      }
      if (v14 < 5) {
        int v22 = 1;
      }
      if (v22) {
        int v23 = v21;
      }
      else {
        int v23 = v15;
      }
      if (v23) {
        char v24 = v13 | 0x83;
      }
      else {
        char v24 = v13;
      }
      if (v16 < 5) {
        int v25 = 1;
      }
      else {
        int v25 = v20;
      }
      if (v17 < 0xFFFFFFFE) {
        int v25 = 1;
      }
      if (v25) {
        char v26 = v24;
      }
      else {
        char v26 = v24 | 3;
      }
      int isStylusContact = MTParserPath::isStylusContact(v12);
      int v28 = MTParserPath::wasStylusContact(v12);
      if (v17 >= 0xFFFFFFFE)
      {
        if (v14 < 5) {
          char v31 = 1;
        }
        else {
          char v31 = isStylusContact;
        }
        if (v31)
        {
LABEL_53:
          MTParser::createDigitizerChildEventForPath(a1, a2, v12, a6, v26, v23);
          goto LABEL_54;
        }
      }
      else
      {
        BOOL v29 = v14 >= 5 && v16 >= 5;
        if (v29) {
          int v30 = isStylusContact;
        }
        else {
          int v30 = 1;
        }
        if ((v30 | v28)) {
          goto LABEL_53;
        }
      }
      if ((v38 & 0x20) != 0) {
        goto LABEL_53;
      }
      BOOL v32 = (a4 & 0x80) != 0 && v17 >= 0xFFFFFFFE;
      BOOL v33 = v32 && v14 >= 5;
      char v34 = v33 ? isStylusContact : 1;
      if ((((v34 & 1) == 0) | v23) == 1) {
        goto LABEL_53;
      }
    }
LABEL_54:
    v7 += 600;
    --v8;
  }
  while (v8);
}

uint64_t MTParser::createHIDCollectionEventsForHand(MTParser *this, const MTPathStates *a2, const MTHandStatistics *a3, const MTHandMotion *a4, unsigned int a5, double a6)
{
  uint64_t v11 = mach_absolute_time();
  MTDeviceGetDeviceTimestampOffset();
  if ((*((_DWORD *)a3 + 42) & 0x20) != 0)
  {
    if (*((unsigned __int16 *)a3 + 78) | *((unsigned __int16 *)a3 + 76)
      || *((unsigned __int16 *)a3 + 79) | *((unsigned __int16 *)a3 + 77))
    {
      goto LABEL_9;
    }
  }
  else if (*((_WORD *)a3 + 76) || *((_WORD *)a3 + 77))
  {
    goto LABEL_9;
  }
  if (!*((unsigned char *)a3 + 202)) {
    return 0;
  }
LABEL_9:
  MTSurfaceDimensions::convertPixelsToSurfaceFraction(*((void *)this + 5), *((float *)a4 + 46));
  uint64_t DigitizerEvent = IOHIDEventCreateDigitizerEvent();
  if (DigitizerEvent)
  {
    MTParser::createDigitizerPathChildEvents((uint64_t)this, DigitizerEvent, (uint64_t)a2, a5, v13, v11);
    CFArrayRef Children = (const __CFArray *)IOHIDEventGetChildren();
    if (Children)
    {
      CFArrayRef v15 = Children;
      if (CFArrayGetCount(Children) >= 1)
      {
        uint64_t v16 = 0;
        while (!CFArrayGetValueAtIndex(v15, 0) || IOHIDEventGetType() != 11)
        {
          if (++v16 >= CFArrayGetCount(v15)) {
            return DigitizerEvent;
          }
        }
        IOHIDEventGetIntegerValue();
        IOHIDEventSetIntegerValue();
      }
    }
  }
  return DigitizerEvent;
}

void MTParser::handleForceHIDEvents(uint64_t a1, uint64_t *a2, char a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (a2 && (uint64_t v5 = *(const MTPathStates **)(a1 + 64)) != 0)
  {
    uint64_t v6 = *(void *)(a1 + 200);
    if (v6)
    {
      uint64_t v8 = *(CFDictionaryRef **)(a1 + 208);
      if (v8)
      {
        if (MTForceManagement::actuateForceAndHIDEvents(v6, v5, v8, *a2, a3))
        {
          uint64_t v9 = *(void *)(a1 + 48);
          if (v9)
          {
            MTAbsoluteTimeGetCurrent();
            *(void *)(v9 + 48) = v10;
          }
          BOOL isForceButtonActivated = MTForceManagement::isForceButtonActivated(*(MTForceManagement **)(a1 + 200));
          MTParser::setDivingButtonState((MTParser *)a1, isForceButtonActivated);
          uint64_t v12 = *a2;
          MTDragManagerEventQueue::forceButtonChange(a1 + 80, v12);
        }
      }
    }
  }
  else
  {
    MTDeviceGetDeviceID();
    uint64_t v13 = MTLoggingPlugin();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v14 = *(void *)(a1 + 64);
      *(_DWORD *)buf = 134218496;
      uint64_t v16 = a2;
      __int16 v17 = 2048;
      uint64_t v18 = v14;
      __int16 v19 = 2048;
      uint64_t v20 = 0;
      _os_log_impl(&dword_2406FB000, v13, OS_LOG_TYPE_DEBUG, "[HID] Skipping : No base event or path states : %p %p (deviceID 0x%llX)", buf, 0x20u);
    }
  }
}

uint64_t MTParser::setDivingButtonState(MTParser *this, int a2)
{
  uint64_t result = *((void *)this + 8);
  if (result) {
    uint64_t result = MTPathStates::setDivingButtonState(result, a2);
  }
  uint64_t v5 = *((void *)this + 6);
  if (v5)
  {
    if (*(unsigned __int8 *)(v5 + 305) != a2) {
      *(void *)(v5 + 288) = *(void *)(v5 + 8);
    }
    *(unsigned char *)(v5 + 305) = a2;
  }
  return result;
}

uint64_t MTParser::createEmptyHIDCollectionEvent(MTParser *this)
{
  return IOHIDEventCreateDigitizerEvent();
}

double MTParser::autoReleaseTapAndAHalfDrag(MTParser *a1, void *a2, double a3)
{
  double v3 = 0.0;
  if (a2)
  {
    if (*((void *)a1 + 9))
    {
      uint64_t EmptyHIDCollectionEvent = *((void *)a1 + 2);
      if (EmptyHIDCollectionEvent
        || (uint64_t EmptyHIDCollectionEvent = MTParser::createEmptyHIDCollectionEvent(a1),
            (*((void *)a1 + 2) = EmptyHIDCollectionEvent) != 0))
      {
        uint64_t v8 = *((void *)a1 + 6);
        if (v8)
        {
          int v9 = MTDragManagerEventQueue::serviceEventQueue((uint64_t)a1 + 80, EmptyHIDCollectionEvent, *((void *)a1 + 9), *(unsigned __int8 *)(v8 + 211) + *(unsigned __int8 *)(v8 + 186), a3);
          if (IOHIDEventGetChildren())
          {
            uint64_t v10 = *((void *)a1 + 7);
            if (v10)
            {
              MTSurfaceDimensions::convertPixelsToSurfaceFraction(*((void *)a1 + 5), *(float *)(v10 + 184));
              IOHIDEventSetFloatValue();
              IOHIDEventSetFloatValue();
            }
            mach_absolute_time();
            IOHIDEventSetTimeStamp();
            *a2 = *((void *)a1 + 2);
            *((void *)a1 + 2) = 0;
          }
          uint64_t ChordTableForHand = MTGestureConfig::getChordTableForHand(*((void *)a1 + 9), 1);
          if (ChordTableForHand) {
            int v12 = v9;
          }
          else {
            int v12 = 0;
          }
          if (v12 == 1) {
            return *(float *)(ChordTableForHand + 372);
          }
        }
      }
    }
  }
  return v3;
}

float MTParser::updateSurfaceDimensions(MTParser *this)
{
  if (MTDeviceGetSensorSurfaceDimensions())
  {
    float v3 = 75.0;
    float v4 = 50.0;
  }
  else
  {
    float v4 = (float)0x1B4E81Bu;
    float v3 = (float)0x1B4E81Bu;
  }
  uint64_t v5 = (float *)*((void *)this + 5);
  if (v5) {
    float result = MTSurfaceDimensions::updateScreenBounds_mm(v5, 0.0, 0.0, v4, v3);
  }
  uint64_t v6 = (MTPathStates *)*((void *)this + 8);
  if (v6) {
    return MTPathStates::updateSurfaceDimensions(v6);
  }
  return result;
}

uint64_t MTParser::processForceHIDEvents(uint64_t a1, const MTPathStates *a2)
{
  uint64_t v2 = *(MTForceManagerLite **)(a1 + 216);
  if (v2) {
    MTForceManagerLite::updatePaths(v2, a2);
  }
  return 1;
}

uint64_t MTParser::getNonRestingFingerCount(MTParser *this, int a2)
{
  uint64_t v2 = *((void *)this + 6);
  if (!v2) {
    return 0;
  }
  unsigned int v3 = *(unsigned __int8 *)(v2 + 186);
  if (a2)
  {
    if (v3 <= *(unsigned __int8 *)(v2 + 195)) {
      int v4 = 0;
    }
    else {
      int v4 = -1;
    }
  }
  else
  {
    int v4 = 0;
  }
  return v4 + v3;
}

void MTParser::handleFrameHeader(uint64_t a1, _OWORD *a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 224);
  if (v2) {
    MTEmbeddedStats::handleFrameHeader(v2, a2);
  }
}

uint64_t MTParser::systemForceResponseEnabledChanged(MTParser *this)
{
  uint64_t result = *((void *)this + 3);
  if (result)
  {
    uint64_t v3 = *((void *)this + 25);
    if (v3)
    {
      uint64_t result = MTDeviceGetSystemForceResponseEnabled();
      *(unsigned char *)(v3 + 594) = result;
    }
  }
  return result;
}

uint64_t MTParser::setHostClickControlEnabled(uint64_t this, char a2)
{
  if (*(void *)(this + 24))
  {
    this = *(void *)(this + 200);
    if (this)
    {
      int v2 = *(unsigned __int8 *)(this + 595);
      *(unsigned char *)(this + 595) = a2;
      if (v2)
      {
        if ((a2 & 1) == 0) {
          return MTForceManagement::clearState(this, 1);
        }
      }
    }
  }
  return this;
}

BOOL MTParser::getHostClickControlEnabled(MTParser *this)
{
  return *((void *)this + 3) && (uint64_t v1 = *((void *)this + 25)) != 0 && *(unsigned char *)(v1 + 595) != 0;
}

uint64_t MTParser::alwaysGenerateNotificationCenterGestures(MTParser *this, int a2)
{
  uint64_t result = *((void *)this + 9);
  if (result)
  {
    uint64_t result = MTGestureConfig::getChordTableForHand(result, 1);
    if (result)
    {
      if (a2) {
        int v4 = 32;
      }
      else {
        int v4 = 128;
      }
      *(_DWORD *)(result + 24) = *(_DWORD *)(result + 24) & 0xFFFFFF5F | v4;
    }
  }
  return result;
}

uint64_t MTParser::alwaysGenerateNotificationCenterAltGestures(MTParser *this, int a2)
{
  uint64_t result = *((void *)this + 9);
  if (result)
  {
    uint64_t result = MTGestureConfig::getChordTableForHand(result, 1);
    if (result)
    {
      if (a2) {
        int v4 = 256;
      }
      else {
        int v4 = 128;
      }
      *(_DWORD *)(result + 24) = *(_DWORD *)(result + 24) & 0xFFFFFE7F | v4;
    }
  }
  return result;
}

float MTParser::updatePixelResolution_mm(MTParser *this, double a2)
{
  uint64_t v3 = (float32x2_t *)*((void *)this + 5);
  if (v3) {
    LODWORD(a2) = MTSurfaceDimensions::updatePixelResolution_mm(v3, *(float32x2_t *)&a2, *(float32_t *)&a2).u32[0];
  }
  int v4 = (MTPathStates *)*((void *)this + 8);
  if (v4)
  {
    *(float *)&a2 = MTPathStates::updateResolutionDependentParams(v4);
  }
  return *(float *)&a2;
}

uint64_t MTParser::feedbackMomentumTimerStatus(uint64_t a1, int a2, char a3)
{
  uint64_t result = *(void *)(a1 + 72);
  if (result)
  {
    uint64_t result = MTGestureConfig::getChordTableForHand(result, 1);
    if (result)
    {
      *(_DWORD *)(result + 1276) = a2;
      *(unsigned char *)(result + 1272) = a3;
    }
  }
  return result;
}

void MTForceManagement::~MTForceManagement(MTForceManagement *this)
{
  MTForceClickHistory::~MTForceClickHistory((MTForceManagement *)((char *)this + 512));
  uint64_t v7 = (void **)((char *)this + 464);
  std::vector<MTForceThresholding>::__destroy_vector::operator()[abi:ne180100](&v7);
  uint64_t v7 = (void **)((char *)this + 264);
  std::vector<std::vector<MTForceBehavior>>::__destroy_vector::operator()[abi:ne180100](&v7);
  int v2 = (void *)*((void *)this + 19);
  if (v2)
  {
    *((void *)this + 20) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 16);
  if (v3)
  {
    *((void *)this + 17) = v3;
    operator delete(v3);
  }
  int v4 = (void *)*((void *)this + 13);
  if (v4)
  {
    *((void *)this + 14) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 10);
  if (v5)
  {
    *((void *)this + 1MTHandMotion::clearHandMotion(this, 1) = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 7);
  if (v6)
  {
    *((void *)this + 8) = v6;
    operator delete(v6);
  }
}

void std::vector<MTForceThresholding>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = (void (***)(void))**a1;
  if (v2)
  {
    int v4 = (void (***)(void))v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 59;
      uint64_t v7 = v4 - 59;
      do
      {
        (**v7)(v7);
        v6 -= 59;
        BOOL v8 = v7 == v2;
        v7 -= 59;
      }
      while (!v8);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::vector<MTForceBehavior>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = (void **)**a1;
  if (v2)
  {
    int v4 = (void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        std::vector<MTForceBehavior>::__destroy_vector::operator()[abi:ne180100](&v6);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<MTForceBehavior>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = **a1;
  if (v2)
  {
    int v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 18;
        std::allocator<MTForceBehavior>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<MTForceBehavior>::destroy[abi:ne180100](uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)a2[15];
  if (v3)
  {
    a2[16] = v3;
    operator delete(v3);
  }
  int v4 = (void *)a2[12];
  if (v4)
  {
    a2[13] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)a2[9];
  if (v5)
  {
    a2[10] = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)a2[6];
  if (v6)
  {
    a2[7] = v6;
    operator delete(v6);
  }
  uint64_t v7 = (void *)a2[3];
  if (v7)
  {
    a2[4] = v7;
    operator delete(v7);
  }
}

void std::__shared_weak_count::__release_shared[abi:ne180100](std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

void std::shared_ptr<MTEmbeddedStats>::shared_ptr[abi:ne180100]<MTEmbeddedStats,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_24070A0A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    std::default_delete<MTEmbeddedStats>::operator()[abi:ne180100]((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<MTEmbeddedStats *,std::shared_ptr<MTEmbeddedStats>::__shared_ptr_default_delete<MTEmbeddedStats,MTEmbeddedStats>,std::allocator<MTEmbeddedStats>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x2455F6CE0);
}

void std::__shared_ptr_pointer<MTEmbeddedStats *,std::shared_ptr<MTEmbeddedStats>::__shared_ptr_default_delete<MTEmbeddedStats,MTEmbeddedStats>,std::allocator<MTEmbeddedStats>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<MTEmbeddedStats *,std::shared_ptr<MTEmbeddedStats>::__shared_ptr_default_delete<MTEmbeddedStats,MTEmbeddedStats>,std::allocator<MTEmbeddedStats>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::default_delete<MTEmbeddedStats>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    int v2 = *(std::__shared_weak_count **)(a2 + 8);
    if (v2) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v2);
    }
    JUMPOUT(0x2455F6CE0);
  }
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2 == v3) {
    return 1;
  }
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3)) {
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0;
}

MTPathStates *MTPathStates::MTPathStates(MTPathStates *a1, uint64_t a2, unsigned int a3, unsigned int a4, char a5, int a6)
{
  uint64_t v7 = MTPathStatesBasic::MTPathStatesBasic((uint64_t)a1, a2, a3, a4, a5, a6);
  *(void *)uint64_t v7 = &unk_26F4D9378;
  MTRestZoneIntegrator::MTRestZoneIntegrator(v7 + 520, *(void *)(v7 + 40), *(unsigned int *)(v7 + 24), *(unsigned int *)(v7 + 28));
  (*(void (**)(MTPathStates *))(*(void *)a1 + 16))(a1);
  (*(void (**)(MTPathStates *))(*(void *)a1 + 24))(a1);
  MTPathStates::updateSurfaceDimensions(a1);
  *((void *)a1 + 44) = 0;
  return a1;
}

void sub_24070A2B4(_Unwind_Exception *a1)
{
  MTPathStatesBasic::~MTPathStatesBasic(v1);
  _Unwind_Resume(a1);
}

float MTPathStates::updateSurfaceDimensions(MTPathStates *this)
{
  if ((*((_DWORD *)this + 6) - 1000) <= 0xBB7)
  {
    unsigned __int8 v10 = 0;
    AppIntegeruint64_t Value = MTPreferencesGetAppIntegerValue(@"ThumbZoneHeight", @"com.apple.MultitouchSupport", &v10);
    unsigned __int8 v9 = 0;
    uint64_t v3 = MTPreferencesGetAppIntegerValue(@"ThumbZoneHeightRatio", @"com.apple.MultitouchSupport", &v9);
    MTSurfaceDimensions::convertSurfaceFractionToMillimeters(*((void *)this + 5), 0.0);
    *((float *)this + 110) = v4;
    if (v9)
    {
      float v5 = (double)v3 / 100.0;
    }
    else
    {
      float v5 = v4 / 76.0;
      float v6 = sqrtf(v4 / 76.0);
      if (v5 < 1.0) {
        float v5 = v6;
      }
    }
    *((float *)this + 109) = v5;
    float v7 = v5 * 12.0;
    if (v10) {
      float v7 = (float)AppIntegerValue;
    }
    *((float *)this + 108) = v7;
  }
  return MTParameterFactory::updatePathFilterParamsWithNewSurfaceDimensions((uint64_t)this + 48, *((void *)this + 5));
}

void MTPathStates::~MTPathStates(MTPathStates *this)
{
  *(void *)this = &unk_26F4D9378;
  *((void *)this + 44) = 0;
  MTRestZoneIntegrator::~MTRestZoneIntegrator((MTPathStates *)((char *)this + 520));

  MTPathStatesBasic::~MTPathStatesBasic(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26F4D9378;
  *((void *)this + 44) = 0;
  MTRestZoneIntegrator::~MTRestZoneIntegrator((MTPathStates *)((char *)this + 520));

  MTPathStatesBasic::~MTPathStatesBasic(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26F4D9378;
  *((void *)this + 44) = 0;
  MTRestZoneIntegrator::~MTRestZoneIntegrator((MTPathStates *)((char *)this + 520));
  MTPathStatesBasic::~MTPathStatesBasic(this);

  JUMPOUT(0x2455F6CE0);
}

double MTPathStates::initializeParams(MTPathStates *this)
{
  MTPathStatesBasic::initializeParams(this);

  return MTParameterFactory::initForceFilterParams((_OWORD *)this + 21);
}

float MTPathStates::updateResolutionDependentParams(MTPathStates *this)
{
  return MTParameterFactory::updatePathFilterParamsWithNewSurfaceDimensions((uint64_t)this + 48, *((void *)this + 5));
}

uint64_t MTPathStates::setDivingButtonState(uint64_t this, int a2)
{
  if (*(unsigned __int8 *)(this + 372) != a2)
  {
    *(void *)(this + 400) = *(void *)(this + 8);
    *(_DWORD *)(this + 408) = *(_DWORD *)(this + 388);
    *(unsigned char *)(this + 424) = 0;
  }
  *(unsigned char *)(this + 372) = a2;
  return this;
}

float MTPathStates::getThumbRestingZoneAdaptiveBase(MTPathStates *this)
{
  return *((float *)this + 108);
}

float MTPathStates::getThumbRestingOrPolarZoneHeight(MTPathStates *this)
{
  return *((float *)this + 109) * 1.8 * *((float *)this + 108);
}

float MTPathStates::getMaxThumbRestingHeight(MTPathStates *this)
{
  return *((float *)this + 110) * flt_24074F088[*((unsigned char *)this + 373) == 0];
}

float MTPathStates::restingTranslationCertainty(MTPathStates *this)
{
  if (*((unsigned char *)this + 372)) {
    return 1.0;
  }
  else {
    return MTRestZoneIntegrator::translationDominance((MTPathStates *)((char *)this + 520), *((unsigned char *)this + 444) == 0);
  }
}

BOOL MTPathStates::isContactOnDivingButton(uint64_t a1, uint64_t a2, double a3)
{
  float v5 = a3;
  if (v5 == 0.0)
  {
    double v7 = 0.0;
  }
  else
  {
    float v6 = fabsf(v5);
    double v7 = 1.0;
    if (v6 < 0.2) {
      double v7 = (float)(v6 / 0.2);
    }
  }
  float v8 = *(float *)(a1 + 432);
  float v9 = *(float *)(a2 + 60);
  float v10 = 0.0;
  if (v9 > 8.0)
  {
    float v10 = 1.0;
    if (v9 < 18.0) {
      float v10 = (float)(v9 + -8.0) / 10.0;
    }
  }
  float v11 = pow(v7, 0.75);
  float v12 = (float)(v8 + v11) + (float)((float)(v11 + 6.0) * v10);
  MTSurfaceDimensions::convertSurfaceFractionToMillimeters(*(void *)(a1 + 40), *(float *)(a2 + 32));
  return v13 < v12;
}

uint64_t MTPathStates::countFingersOnDivingButton(MTPathStates *this)
{
  *((_DWORD *)this + 96) = 0;
  uint64_t v2 = 644;
  uint64_t v3 = 31;
  do
  {
    uint64_t v4 = *((void *)this + 35);
    if ((*(_DWORD *)(v4 + v2) - 3) <= 1
      && MTParserPath::isFingerOrRestingContact((MTParserPath *)(v4 + v2 - 44)))
    {
      ++*((_DWORD *)this + 96);
    }
    v2 += 600;
    --v3;
  }
  while (v3);
  int v5 = 0;
  float v6 = 1000.0;
  uint64_t v7 = 1;
  uint64_t v8 = 984;
  float v9 = 1000.0;
  do
  {
    uint64_t v10 = *((void *)this + 35);
    BOOL v11 = *((void *)this + 44)
       && MTParserPath::isValidClickSource((MTParserPath *)(v10 + v8 - 384))
       && v7 == *(_DWORD *)(*((void *)this + 44) + 256);
    float v12 = (_DWORD *)(v10 + v8 - 340);
    if ((*v12 - 3) > 1) {
      goto LABEL_26;
    }
    if (!MTParserPath::isFingerOrRestingContact((MTParserPath *)(v10 + v8 - 384)))
    {
      if (!MTParserPath::isEdgeContact((MTParserPath *)(v10 + v8 - 384))) {
        goto LABEL_26;
      }
      int v13 = *((int *)this + 96) < 2 || v11;
      if (v13 != 1) {
        goto LABEL_26;
      }
    }
    float v14 = *(float *)(v10 + v8 - 288);
    CFArrayRef v15 = (_DWORD *)(v10 + v8 - 336);
    if (*v12 == 7) {
      CFArrayRef v15 = (_DWORD *)(v10 + v8 - 240);
    }
    if (*v15 != 1) {
      float v14 = v14 + *(float *)(v10 + v8);
    }
    if (v14 < v9)
    {
      float v16 = v14;
      int v5 = v3;
      LODWORD(v3) = v7;
      goto LABEL_27;
    }
    if (v14 < v6)
    {
      float v16 = v9;
      float v9 = v14;
      int v5 = v7;
    }
    else
    {
LABEL_26:
      float v16 = v9;
      float v9 = v6;
    }
LABEL_27:
    ++v7;
    v8 += 600;
    float v6 = v9;
    float v9 = v16;
  }
  while (v7 != 32);
  *((_DWORD *)this + 97) = v3;
  *((void *)this + 47) = 0;
  if (v3)
  {
    double v17 = *((double *)this + 1);
    uint64_t v18 = *((void *)this + 35);
    double v19 = v17;
    if ((*(_DWORD *)(v18 + 600 * (int)v3 + 44) - 3) <= 1) {
      double v19 = *(double *)(v18 + 600 * (int)v3 + 232);
    }
    if (v5 && (*(_DWORD *)(v18 + 600 * v5 + 44) - 3) <= 1) {
      double v17 = *(double *)(v18 + 600 * v5 + 232);
    }
    if (MTPathStates::isContactOnDivingButton((uint64_t)this, v18 + 600 * (int)v3 + 24, v17 - v19))
    {
      ++*((_DWORD *)this + 94);
      if (MTParserPath::isEdgeContact((MTParserPath *)(v18 + 600 * (int)v3))) {
        ++*((_DWORD *)this + 95);
      }
    }
    if (v5)
    {
      int v20 = *((_DWORD *)this + 94);
      if (v20 >= 1)
      {
        uint64_t v21 = *((void *)this + 35);
        int32x2_t v22 = vcgt_f32((float32x2_t)0x4198000041F00000, vabd_f32(*(float32x2_t *)(v18 + 600 * (int)v3 + 92), *(float32x2_t *)(v21 + 600 * v5 + 92)));
        if (v22.i32[1] & v22.i32[0])
        {
          *((_DWORD *)this + 94) = v20 + 1;
          if (MTParserPath::isEdgeContact((MTParserPath *)(v21 + 600 * v5))) {
            ++*((_DWORD *)this + 95);
          }
        }
      }
    }
    *((unsigned char *)this + 373) = 0;
    int v23 = (float *)(v18 + 600 * (int)v3 + 96);
    uint64_t v24 = 696;
    uint64_t v25 = 1;
    while (1)
    {
      if (v3 == v25) {
        goto LABEL_48;
      }
      char v26 = (float *)(*((void *)this + 35) + v24);
      if ((*((_DWORD *)v26 - 13) - 3) > 1) {
        goto LABEL_48;
      }
      __int16 v27 = (MTParserPath *)(v26 - 24);
      float v28 = *v26;
      float v29 = *v23;
      if (!MTParserPath::isPalmContact((MTParserPath *)(v26 - 24))) {
        break;
      }
      if (v28 < v29) {
        goto LABEL_47;
      }
LABEL_48:
      ++v25;
      v24 += 600;
      if (v25 == 32) {
        return *((unsigned int *)this + 94);
      }
    }
    if (!MTParserPath::isEdgeContact(v27) || v28 >= v29) {
      goto LABEL_48;
    }
LABEL_47:
    *((unsigned char *)this + 373) = 1;
    goto LABEL_48;
  }
  return 0;
}

uint64_t MTPathStates::updateDivingBoardDisplacements(uint64_t this)
{
  uint64_t v1 = this;
  *(void *)(this + 392) = 0;
  uint64_t v2 = 1;
  uint64_t v3 = 832;
  do
  {
    uint64_t v4 = *(void *)(v1 + 280);
    if ((*(_DWORD *)(v4 + v3 - 188) - 3) <= 1)
    {
      this = MTParserPath::isFingerContact((MTParserPath *)(v4 + v3 - 232));
      if (this)
      {
        if (v2 != *(_DWORD *)(v1 + 388))
        {
          double v5 = *(double *)(v4 + v3);
          double v6 = *(double *)(v1 + 392);
          if (v6 == 0.0 || v5 < v6) {
            *(double *)(v1 + 392) = v5;
          }
        }
      }
    }
    ++v2;
    v3 += 600;
  }
  while (v2 != 32);
  return this;
}

void MTPathStates::checkForRestingThumb(MTPathStates *this)
{
  int v2 = *((unsigned __int8 *)this + 444);
  *((unsigned char *)this + 444) = 0;
  MTPathStates::updateDivingBoardDisplacements((uint64_t)this);
  MTRestZoneIntegrator::integrateRestingZoneMotion((float32x2_t *)this + 65, this, *((_DWORD *)this + 96));
  unsigned int v3 = *((_DWORD *)this + 97);
  if ((int)v3 < 1) {
    return;
  }
  uint64_t v4 = *((void *)this + 35);
  uint64_t v5 = v4 + 600 * v3;
  double v6 = *(double *)(v5 + 232);
  int v7 = *(_DWORD *)(v5 + 44);
  uint64_t v8 = (int *)(v5 + 144);
  float v9 = (int *)(v5 + 48);
  if (v7 == 7) {
    float v9 = v8;
  }
  int v10 = *v9;
  double v11 = *((double *)this + 49);
  BOOL v12 = v11 > 0.0;
  float v13 = v11 - v6;
  float v14 = fabsf(v13);
  if (v11 <= 0.0) {
    float v14 = 0.0;
  }
  *((float *)this + 190) = v14;
  int v15 = *((_DWORD *)this + 104);
  if (v15 >= 1 && v10 == 1)
  {
    *((unsigned char *)this + 764) = *((_DWORD *)this + 96) >= v15;
  }
  else
  {
    *((unsigned char *)this + 764) = 0;
    if (v11 > 0.0 && v10 != 1)
    {
      char v17 = 0;
      BOOL v18 = 0;
      BOOL v12 = *((_DWORD *)this + 96) < 3;
      goto LABEL_23;
    }
    if (v10 != 1)
    {
      char v17 = 0;
      BOOL v18 = 0;
      goto LABEL_23;
    }
  }
  if (!*((unsigned char *)this + 412) && *((_DWORD *)this + 96) == 2)
  {
    char v16 = v11 <= 0.0;
    char v17 = 1;
LABEL_31:
    BOOL v22 = v12;
    goto LABEL_32;
  }
  if (MTRestZoneIntegrator::shouldDoBiPolarIntegration((MTPathStates *)((char *)this + 520), v2 == 0))
  {
    BOOL v18 = 0;
  }
  else
  {
    MTSurfaceDimensions::convertPixelsToMillimeters(*((void *)this + 5), *(float *)(v4 + 600 * v3 + 56));
    BOOL v18 = v20 < (float)(*((float *)this + 110) * flt_24074F088[*((unsigned char *)this + 373) == 0]);
  }
  char v17 = 1;
LABEL_23:
  char v16 = !v12;
  if (!v12 || v18) {
    goto LABEL_31;
  }
  char v16 = 0;
  BOOL v22 = *((_DWORD *)this + 94) == 1 && v10 != 1;
LABEL_32:
  if (*((unsigned char *)this + 372)) {
    BOOL v23 = v12;
  }
  else {
    BOOL v23 = 0;
  }
  if (*((unsigned char *)this + 424))
  {
    double v24 = *((double *)this + 1);
  }
  else
  {
    double v24 = *((double *)this + 1);
    if (v24 - *((double *)this + 50) < 0.1)
    {
      if (*((unsigned char *)this + 372)) {
        char v17 = 1;
      }
      if ((v17 & 1) == 0) {
        *(unsigned char *)(v4 + 600 * v3 + 584) = 0;
      }
      *((unsigned char *)this + 424) = 1;
    }
  }
  double v25 = *((double *)this + 49);
  if (v6 > v25) {
    double v25 = v6;
  }
  if (v24 - v25 == 0.0)
  {
    uint64_t v26 = v4 + 600 * v3;
    MTSurfaceDimensions::convertPixelsToMillimeters(*((void *)this + 5), *(float *)(v26 + 56));
    *(unsigned char *)(v26 + 585) = v27 > (float)(*((float *)this + 110) * flt_24074F088[*((unsigned char *)this + 373) == 0]);
  }
  if (v22 && MTRestZoneIntegrator::isLockedOnTranslate((MTPathStates *)((char *)this + 520)))
  {
    if (*(unsigned char *)(v4 + 600 * v3 + 585)) {
      char v28 = v23;
    }
    else {
      char v28 = 1;
    }
    if ((v28 & 1) == 0) {
      goto LABEL_58;
    }
    goto LABEL_55;
  }
  if (v23) {
LABEL_55:
  }
    *(unsigned char *)(v4 + 600 * v3 + 584) = 1;
  if (v22 && !*(unsigned char *)(v4 + 600 * v3 + 585)) {
    goto LABEL_65;
  }
LABEL_58:
  if (*((unsigned char *)this + 372))
  {
    if (!v12) {
      return;
    }
    goto LABEL_65;
  }
  if (*(unsigned char *)(v4 + 600 * v3 + 584)) {
    char v29 = v16;
  }
  else {
    char v29 = 1;
  }
  if ((v29 & 1) == 0)
  {
LABEL_65:
    if (*((int *)this + 96) < 5 || *((int *)this + 104) <= 0) {
      *((unsigned char *)this + 444) = 1;
    }
  }
}

uint64_t MTPathStates::fixupCurledUnderThumbIdentity(MTPathStates *this)
{
  uint64_t v1 = 0;
  int v2 = 0;
  int v3 = 0;
  int v4 = 0;
  int v5 = 0;
  char v6 = 0;
  int v7 = 0;
  uint64_t v8 = *((void *)this + 35);
  float v9 = (float *)(v8 + 96);
  do
  {
    uint64_t result = (*((_DWORD *)v9 - 13) - 1);
    if (result <= 5)
    {
      uint64_t result = *((unsigned int *)v9 - 12);
      if ((result - 1) <= 4)
      {
        if (!v2 || *(v9 - 1) < *(float *)(v8 + 600 * v2 + 92)) {
          int v2 = v1;
        }
        if (!v3 || *(v9 - 1) > *(float *)(v8 + 600 * v3 + 92)) {
          int v3 = v1;
        }
        if (v4)
        {
          if (*v9 >= *(float *)(v8 + 600 * v4 + 96))
          {
            if (!v5 || *v9 < *(float *)(v8 + 600 * v5 + 96)) {
              int v5 = v1;
            }
            goto LABEL_18;
          }
          int v5 = v4;
        }
        else
        {
          int v5 = 0;
        }
        int v4 = v1;
LABEL_18:
        ++v7;
        uint64_t result = result == 1;
        v6 |= result;
      }
    }
    v9 += 150;
    ++v1;
  }
  while (v1 != 32);
  if (v4)
  {
    float v11 = *(float *)(v8 + 600 * v3 + 92) - *(float *)(v8 + 600 * v2 + 92);
    if (v11 > 19.0)
    {
      uint64_t v12 = v8 + 600 * v4;
      if (v4 == v2 || v4 == v3)
      {
        if (!((*(unsigned char *)(v12 + 583) == 0) | v6 & 1))
        {
          int v15 = (_DWORD *)(v8 + 600 * v4 + 48);
          goto LABEL_38;
        }
      }
      else
      {
        float v13 = (float)(v11 / (float)(v7 - 1)) + -7.0;
        if (v13 < 2.0) {
          float v13 = 2.0;
        }
        if (v13 > 16.0) {
          float v13 = 16.0;
        }
        if (*(unsigned char *)(v12 + 583) || *(float *)(v8 + 600 * v4 + 96) < (float)(*(float *)(v8 + 600 * v5 + 96) - v13))
        {
          *(unsigned char *)(v12 + 583) = 1;
          uint64_t v14 = v8 + 600 * v4;
          int v17 = *(_DWORD *)(v14 + 48);
          int v15 = (_DWORD *)(v14 + 48);
          int v16 = v17;
          if (v17 != 1)
          {
            uint64_t v18 = v8 + 600 * v2;
            int v21 = *(_DWORD *)(v18 + 48);
            double v19 = (_DWORD *)(v18 + 48);
            int v20 = v21;
            if ((v6 & 1) == 0 || v20 == 1 || *(_DWORD *)(v8 + 600 * v3 + 48) == 1)
            {
              uint64_t v22 = v8 + 600 * v3;
              int v24 = *(_DWORD *)(v22 + 48);
              BOOL v23 = (_DWORD *)(v22 + 48);
              if (v20 >= v24) {
                *BOOL v23 = v16;
              }
              else {
                *double v19 = v16;
              }
LABEL_38:
              _DWORD *v15 = 1;
            }
          }
        }
      }
    }
  }
  for (uint64_t i = 0; i != 32; ++i)
  {
    if ((*(_DWORD *)(v8 + 44) - 1) <= 5 && v4 != i)
    {
      int v26 = *(_DWORD *)(v8 + 48);
      if (v26 >= 1 && v26 <= 5) {
        *(unsigned char *)(v8 + 583) = 0;
      }
    }
    v8 += 600;
  }
  return result;
}

uint64_t MTPathStates::checkForFingersInZones(MTPathStates *this)
{
  uint64_t result = MTPathStatesBasic::checkForFingersInZones((uint64_t)this);
  if ((*((_DWORD *)this + 6) - 1000) <= 0xBB7 && *((int *)this + 94) >= 1) {
    *((_DWORD *)this + 81) |= 0x10000u;
  }
  return result;
}

double MTPathStates::forwardFirmwareDistributedForces(MTPathStates *this, float a2)
{
  int v3 = 0;
  int v4 = (float *)*((void *)this + 35);
  *((void *)this + 45) = 0;
  int v5 = (float *)((char *)this + 336);
  uint64_t v6 = -31;
  uint64_t v7 = 896;
  do
  {
    uint64_t v8 = *((void *)this + 35);
    float v9 = (MTForceFilter *)(v8 + v7);
    if ((*(_DWORD *)(v8 + v7 - 252) - 1) > 5)
    {
      MTForceFilter::clear(v9);
    }
    else
    {
      float v10 = *((float *)v9 - 55);
      *((float *)this + 90) = v10 + *((float *)this + 90);
      if (MTParserPath::isValidClickSource((MTForceFilter *)((char *)v9 - 296))) {
        *((float *)this + 9MTHandMotion::clearHandMotion(this, 1) = v10 + *((float *)this + 91);
      }
      uint64_t v11 = v8 + v7;
      float v12 = hypotf(*(float *)(v11 - 196), *(float *)(v11 - 192));
      MTForceFilter::updateForceFilter(v11, v5, v10, v12, *((double *)this + 1) - *((double *)this + 2));
      ++v3;
    }
    v7 += 600;
  }
  while (!__CFADD__(v6++, 1));
  if (v3 <= 0)
  {
    return MTForceFilter::clear((MTForceFilter *)(v4 + 74));
  }
  else
  {
    float v14 = *((float *)this + 91);
    float v15 = hypotf(v4[25], v4[26]);
    double v16 = *((double *)this + 1) - *((double *)this + 2);
    MTForceFilter::updateForceFilter((uint64_t)(v4 + 74), v5, v14, v15, v16);
  }
  return result;
}

BOOL MTPathStates::hasFastestLowpassPeakFingerSpeed(MTPathStates *this, int a2)
{
  int v4 = 0;
  float v5 = 0.0;
  uint64_t v6 = -31;
  uint64_t v7 = 932;
  do
  {
    uint64_t v8 = *((void *)this + 35);
    if (MTParserPath::isFingerContact((MTParserPath *)(v8 + v7 - 332))
      && (*(_DWORD *)(v8 + v7 - 288) - 3) <= 1
      && *(float *)(v8 + v7) > v5)
    {
      int v4 = v6 + 32;
      float v5 = *(float *)(v8 + v7);
    }
    v7 += 600;
  }
  while (!__CFADD__(v6++, 1));
  return v4 == a2;
}

float MTPathStates::sumOfLowpassPeakFingerSpeeds(MTPathStates *this)
{
  float v2 = 0.0;
  uint64_t v3 = 932;
  uint64_t v4 = 31;
  do
  {
    uint64_t v5 = *((void *)this + 35);
    if (MTParserPath::isFingerContact((MTParserPath *)(v5 + v3 - 332))
      && (*(_DWORD *)(v5 + v3 - 288) - 3) <= 1)
    {
      float v2 = v2 + *(float *)(v5 + v3);
    }
    v3 += 600;
    --v4;
  }
  while (v4);
  return v2;
}

float MTPathStates::getPrePixelatedPositionFromPostPixelatedPosition(MTPathStates *this, int a2)
{
  memcpy(__dst, &unk_24074F0E0, 0x128uLL);
  uint64_t v4 = *((void *)this + 35);
  __dst[0] = &unk_26F4D93E8;
  uint64_t v5 = v4 + 600 * a2;
  memcpy(&__dst[1], (const void *)(v5 + 8), 0x11CuLL);
  __dst[37] = &unk_26F4DB4E0;
  long long v7 = *(_OWORD *)(v5 + 320);
  long long v6 = *(_OWORD *)(v5 + 336);
  long long v28 = *(_OWORD *)(v5 + 304);
  long long v29 = v7;
  long long v30 = v6;
  long long v8 = *(_OWORD *)(v5 + 400);
  long long v9 = *(_OWORD *)(v5 + 352);
  long long v10 = *(_OWORD *)(v5 + 368);
  long long v33 = *(_OWORD *)(v5 + 384);
  long long v34 = v8;
  long long v31 = v9;
  long long v32 = v10;
  long long v11 = *(_OWORD *)(v5 + 464);
  long long v13 = *(_OWORD *)(v5 + 416);
  long long v12 = *(_OWORD *)(v5 + 432);
  long long v37 = *(_OWORD *)(v5 + 448);
  long long v38 = v11;
  long long v35 = v13;
  long long v36 = v12;
  long long v14 = *(_OWORD *)(v5 + 528);
  long long v16 = *(_OWORD *)(v5 + 480);
  long long v15 = *(_OWORD *)(v5 + 496);
  long long v41 = *(_OWORD *)(v5 + 512);
  long long v42 = v14;
  long long v39 = v16;
  long long v40 = v15;
  long long v18 = *(_OWORD *)(v5 + 560);
  long long v17 = *(_OWORD *)(v5 + 576);
  long long v19 = *(_OWORD *)(v5 + 544);
  uint64_t v46 = *(void *)(v5 + 592);
  long long v44 = v18;
  long long v45 = v17;
  long long v43 = v19;
  uint64_t v20 = *((void *)this + 5);
  int v24 = &unk_26F4D9B50;
  long long v21 = *(_OWORD *)(v20 + 24);
  long long v25 = *(_OWORD *)(v20 + 8);
  long long v26 = v21;
  float v22 = MTSurfaceDimensions::convertPixelsToSurfaceFraction((uint64_t)&v24, *(float *)&__dst[7]);
  MTSurfaceDimensions::~MTSurfaceDimensions((MTSurfaceDimensions *)&v24);
  MTParserPath::~MTParserPath((MTParserPath *)__dst);
  return v22;
}

void sub_24070B458(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
}

uint64_t MTPathStates::getMaxDisplacement_mm(uint64_t this)
{
  uint64_t v1 = (float *)(*(void *)(this + 280) + 952);
  float v2 = 0.0;
  uint64_t v3 = 31;
  do
  {
    if (*v1 > v2) {
      float v2 = *v1;
    }
    v1 += 150;
    --v3;
  }
  while (v3);
  return this;
}

void MTPathStates::updateDragDisplacements_mm(MTPathStates *this, int a2)
{
  uint64_t v4 = (char *)this + 48;
  uint64_t v5 = 952;
  uint64_t v6 = 31;
  do
  {
    long long v7 = (float *)(*((void *)this + 35) + v5);
    long long v8 = *((_OWORD *)v4 + 7);
    v14[6] = *((_OWORD *)v4 + 6);
    v14[7] = v8;
    int v15 = *((_DWORD *)v4 + 32);
    long long v9 = *((_OWORD *)v4 + 3);
    v14[2] = *((_OWORD *)v4 + 2);
    v14[3] = v9;
    long long v10 = *((_OWORD *)v4 + 5);
    v14[4] = *((_OWORD *)v4 + 4);
    v14[5] = v10;
    long long v11 = *((_OWORD *)v4 + 1);
    v14[0] = *(_OWORD *)v4;
    v14[1] = v11;
    float updated = MTParserPath::updateHysteresisDragCenter_mm(v7 - 88, (uint64_t)v14);
    float v13 = 0.0;
    if (a2) {
      float v13 = updated + *v7;
    }
    *long long v7 = v13;
    v5 += 600;
    --v6;
  }
  while (v6);
}

uint64_t MTPathStates::tasksPrePixelatedPositions(MTPathStates *this, float a2)
{
  uint64_t v3 = *((void *)this + 44);
  if (v3 && *(unsigned char *)(v3 + 595))
  {
    MTPathStates::forwardFirmwareDistributedForces(this, a2);
    MTForceManagement::analyzeAndManageStrongestForces(*((MTForceManagement **)this + 44), this);
  }
  if ((*((_DWORD *)this + 6) - 1000) <= 0xBB7 && (*((unsigned char *)this + 28) & 2) != 0)
  {
    MTPathStates::checkForRestingThumbFromPalmRestingHand(this);
    MTPathStates::checkForLonelyHighRestingThumb(this);
    MTPathStates::fixupCurledUnderThumbIdentity(this);
    MTPathStates::countFingersOnDivingButton(this);
  }

  return MTPathStatesBasic::tasksPrePixelatedPositions(this);
}

void MTPathStates::checkForRestingThumbFromPalmRestingHand(MTPathStates *this)
{
  *((void *)this + 60) = *((void *)this + 59);
  float v2 = (unsigned int *)((char *)this + 448);
  *((unsigned char *)this + 492) = 0;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 3MTHandMotion::clearHandMotion(this, 1) = xmmword_24074F0C0;
  uint64_t v3 = -31;
  uint64_t v4 = 1186;
  do
  {
    uint64_t v5 = *((void *)this + 35);
    uint64_t v6 = v5 + v4;
    if (*(_DWORD *)(v5 + v4 - 542))
    {
      long long v7 = (MTParserPath *)(v6 - 586);
      int v8 = *(_DWORD *)(v6 - 534);
      if (v8 == -1)
      {
        if (MTParserPath::isPalmContact(v7))
        {
          ++*((_DWORD *)this + 116);
        }
        else if (MTParserPath::isThumbContact(v7))
        {
          unsigned int *v2 = v3 + 32;
        }
        else if (*(unsigned char *)(v5 + v4))
        {
          *((_DWORD *)this + 114) = v3 + 32;
        }
        else if (MTParserPath::isFingerContact(v7))
        {
          ++*((_DWORD *)this + 118);
        }
      }
      else if (v8 == 1)
      {
        if (MTParserPath::isPalmContact(v7))
        {
          ++*((_DWORD *)this + 117);
        }
        else if (MTParserPath::isThumbContact(v7))
        {
          *((_DWORD *)this + 113) = v3 + 32;
        }
        else if (*(unsigned char *)(v5 + v4))
        {
          *((_DWORD *)this + 115) = v3 + 32;
        }
        else if (MTParserPath::isFingerContact(v7))
        {
          ++*((_DWORD *)this + 119);
        }
      }
    }
    v4 += 600;
  }
  while (!__CFADD__(v3++, 1));
  int v10 = *((_DWORD *)this + 119);
  if (v10 + *((_DWORD *)this + 118) >= 1)
  {
    uint64_t v11 = 856;
    uint64_t v12 = 31;
    do
    {
      uint64_t v13 = *((void *)this + 35);
      if (*(_DWORD *)(v13 + v11 - 212) && MTParserPath::isFingerContact((MTParserPath *)(v13 + v11 - 256)))
      {
        double v14 = *(double *)(v13 + v11 - 24);
        double v15 = fmin(*((double *)this + 62), v14);
        double v16 = fmax(*((double *)this + 63), v14);
        *((double *)this + 62) = v15;
        *((double *)this + 63) = v16;
        *((double *)this + 64) = fmax(*((double *)this + 64), *(double *)(v13 + v11));
      }
      v11 += 600;
      --v12;
    }
    while (v12);
    if (*((_DWORD *)this + 113) || *v2) {
      *((unsigned char *)this + 492) = *((double *)this + 63) - *((double *)this + 62) < *(double *)&qword_268C8EC58;
    }
    int v10 = *((_DWORD *)this + 119);
  }
  if (!v10 && !*((_DWORD *)this + 118) && (*((int *)this + 120) >= 1 || *((int *)this + 121) > 0))
  {
    uint64_t v17 = 644;
    uint64_t v18 = 31;
    do
    {
      uint64_t v19 = *((void *)this + 35);
      if (*(_DWORD *)(v19 + v17)) {
        MTParserPath::clearPathSpeedSymmetries((MTParserPath *)(v19 + v17 - 44));
      }
      v17 += 600;
      --v18;
    }
    while (v18);
    *((_DWORD *)this + 122) = 0;
  }
  int v20 = *((_DWORD *)this + 114);
  if ((v20 || *((_DWORD *)this + 115))
    && *((_DWORD *)this + 119) + *((_DWORD *)this + 118) >= 2
    && *((unsigned char *)this + 492)
    && (v20 && !*((_DWORD *)this + 116) || (int v20 = *((_DWORD *)this + 115)) != 0 && !*((_DWORD *)this + 117))
    && v20 >= 1)
  {
    uint64_t v21 = *((void *)this + 35);
    if (*(_DWORD *)(v21 + 600 * v20 + 44))
    {
      float v22 = (MTParserPath *)(v21 + 600 * v20);
      *((unsigned char *)v22 + 586) = 0;
      MTParserPath::clearPathSpeedSymmetries(v22);
    }
  }
  unsigned int v23 = *((_DWORD *)this + 113);
  unsigned int v24 = v23;
  if (!v23) {
    goto LABEL_68;
  }
  int v25 = *((_DWORD *)this + 117);
  if (v25 < 1 || *((_DWORD *)this + 119)) {
    goto LABEL_68;
  }
  if (*((int *)this + 118) <= 0 && !*v2) {
    return;
  }
  int v26 = *((_DWORD *)this + 116);
  if (v25 > v26)
  {
    uint64_t v27 = *((void *)this + 35);
    goto LABEL_62;
  }
  if (v25 != v26)
  {
LABEL_68:
    unsigned int v28 = *v2;
    goto LABEL_69;
  }
  uint64_t v27 = *((void *)this + 35);
  unsigned int v28 = *((_DWORD *)this + 112);
  if (*(float *)(v27 + 600 * (int)v23 + 96) > *(float *)(v27 + 600 * (int)v28 + 96))
  {
LABEL_62:
    unint64_t v29 = 0;
    long long v30 = (BOOL *)(v27 + 1186);
    uint64x2_t v31 = (uint64x2_t)vdupq_n_s64(0x1FuLL);
    do
    {
      uint64x2_t v32 = (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v29), (int8x16_t)xmmword_24074F0D0);
      if (vmovn_s64((int64x2_t)vcgtq_u64(v31, v32)).u8[0]) {
        *long long v30 = v23 - 1 == v29;
      }
      if (vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x1FuLL), v32)).i32[1]) {
        v30[600] = v23 - 2 == v29;
      }
      v29 += 2;
      v30 += 1200;
    }
    while (v29 != 32);
    goto LABEL_68;
  }
LABEL_69:
  if (v28)
  {
    int v33 = *((_DWORD *)this + 116);
    if (v33 >= 1 && !*((_DWORD *)this + 118) && (v23 || *((int *)this + 119) >= 1))
    {
      int v34 = *((_DWORD *)this + 117);
      if (v33 <= v34)
      {
        if (v33 != v34) {
          return;
        }
        uint64_t v35 = *((void *)this + 35);
        if (*(float *)(v35 + 600 * (int)v28 + 96) <= *(float *)(v35 + 600 * (int)v24 + 96)) {
          return;
        }
      }
      else
      {
        uint64_t v35 = *((void *)this + 35);
      }
      unint64_t v36 = 0;
      uint64_t v37 = v28 - 2;
      uint64_t v38 = v28 - 1;
      long long v39 = (BOOL *)(v35 + 1186);
      uint64x2_t v40 = (uint64x2_t)vdupq_n_s64(0x1FuLL);
      do
      {
        uint64x2_t v41 = (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v36), (int8x16_t)xmmword_24074F0D0);
        if (vmovn_s64((int64x2_t)vcgtq_u64(v40, v41)).u8[0]) {
          *long long v39 = v38 == v36;
        }
        if (vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x1FuLL), v41)).i32[1]) {
          v39[600] = v37 == v36;
        }
        v36 += 2;
        v39 += 1200;
      }
      while (v36 != 32);
    }
  }
}

void MTPathStates::checkForLonelyHighRestingThumb(MTPathStates *this)
{
  unsigned int v1 = *((_DWORD *)this + 112);
  if (v1 && !*((_DWORD *)this + 116) && *((_DWORD *)this + 119) + *((_DWORD *)this + 118) == 1
    || (unsigned int v1 = *((_DWORD *)this + 113)) != 0
    && !*((_DWORD *)this + 117)
    && *((_DWORD *)this + 118) + *((_DWORD *)this + 119) == 1)
  {
    MTPathStates::assignLonelyHighRestingThumb(this, v1);
  }
}

void MTPathStates::tasksFilterAndPixelatePositions(uint64_t *a1, uint64_t a2, int a3, int8x16_t a4, double a5, int8x16_t a6, int8x16_t a7)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (a3 >= 1)
  {
    uint64_t v8 = (uint64_t)(a1 + 6);
    uint64_t v9 = (uint64_t)a1 + 180;
    int v10 = (unsigned int *)(a2 + 16);
    uint64_t v11 = a3;
    a4.i64[0] = 67109120;
    do
    {
      unsigned int v13 = *v10;
      v10 += 24;
      unint64_t v12 = v13;
      if ((v13 & 0x80000000) != 0 || (uint64_t v14 = a1[35], 0x2FC962FC962FC963 * ((a1[36] - v14) >> 3) <= v12))
      {
        double v15 = MTLoggingPlugin();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          int v17 = v12;
          _os_log_error_impl(&dword_2406FB000, v15, OS_LOG_TYPE_ERROR, "Invalid path_id %d, dropping contact", buf, 8u);
        }
      }
      else
      {
        MTParserPath::filterContactForScreenUI(v14 + 600 * v12, (uint64_t)a1, a1[5], v8, v9, a4, a5, a6, a7);
      }
      --v11;
    }
    while (v11);
  }
}

void MTPathStates::assignLonelyHighRestingThumb(MTPathStates *this, unsigned int a2)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  uint64_t v5 = *((void *)this + 35);
  double v6 = *(double *)(v5 + 600 * (int)a2 + 232);
  long long v7 = MTLoggingPlugin();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    double v8 = *((double *)this + 1);
    double v9 = v8 - v6;
    double v10 = *(float *)(v5 + 600 * (int)a2 + 396);
    if (*((unsigned char *)this + 492)) {
      uint64_t v11 = "Yes";
    }
    else {
      uint64_t v11 = "No";
    }
    double v12 = v8 - *((double *)this + 64);
    int v19 = 136317698;
    int v20 = "[Debug] ";
    __int16 v21 = 2080;
    float v22 = "";
    __int16 v23 = 2080;
    unsigned int v24 = "assignLonelyHighRestingThumb";
    __int16 v25 = 1024;
    unsigned int v26 = a2;
    __int16 v27 = 2048;
    double v28 = v9;
    __int16 v29 = 2048;
    uint64_t v30 = qword_268C8EC50;
    __int16 v31 = 2048;
    double v32 = v10;
    __int16 v33 = 2048;
    uint64_t v34 = 0x4000000000000000;
    __int16 v35 = 2080;
    unint64_t v36 = v11;
    __int16 v37 = 2048;
    double v38 = v12;
    __int16 v39 = 2048;
    uint64_t v40 = qword_268C8EC58;
    _os_log_impl(&dword_2406FB000, v7, OS_LOG_TYPE_DEBUG, "[HID] [MT] %s%s%s [MTZoom] Thumb path P%d: Touch duration = %.3f sec (> %.3f sec for RT), Discounted distance = %.3f mm (< %.3f mm for RT), Thumb touched down with finger = %s (No for RT) , Time since last finger liftoff = %.3f sec (> %.3f sec for RT)", (uint8_t *)&v19, 0x6Cu);
  }
  double v13 = *((double *)this + 1);
  if (*(double *)&qword_268C8EC50 < v13 - v6
    && *(float *)(v5 + 600 * (int)a2 + 396) < 2.0
    && !*((unsigned char *)this + 492)
    && v13 - *((double *)this + 64) > *(double *)&qword_268C8EC58)
  {
    uint64_t v14 = MTLoggingPlugin();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      int v19 = 136315906;
      int v20 = "[Debug] ";
      __int16 v21 = 2080;
      float v22 = "";
      __int16 v23 = 2080;
      unsigned int v24 = "assignLonelyHighRestingThumb";
      __int16 v25 = 1024;
      unsigned int v26 = a2;
      _os_log_impl(&dword_2406FB000, v14, OS_LOG_TYPE_DEBUG, "[HID] [MT] %s%s%s [MTZoom] Marking thumb path P%d as resting thumb", (uint8_t *)&v19, 0x26u);
    }
    unint64_t v15 = 0;
    double v16 = (BOOL *)(*((void *)this + 35) + 1186);
    uint64x2_t v17 = (uint64x2_t)vdupq_n_s64(0x1FuLL);
    do
    {
      uint64x2_t v18 = (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v15), (int8x16_t)xmmword_24074F0D0);
      if (vmovn_s64((int64x2_t)vcgtq_u64(v17, v18)).u8[0]) {
        *double v16 = a2 - 1 == v15;
      }
      if (vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x1FuLL), v18)).i32[1]) {
        v16[600] = a2 - 2 == v15;
      }
      v15 += 2;
      v16 += 1200;
    }
    while (v15 != 32);
  }
}

uint64_t MTPathStates::setRestingThumbFromPalmRestingHand(uint64_t this, unsigned int a2)
{
  unint64_t v2 = 0;
  uint64_t v3 = (BOOL *)(*(void *)(this + 280) + 1186);
  uint64x2_t v4 = (uint64x2_t)vdupq_n_s64(0x1FuLL);
  do
  {
    uint64x2_t v5 = (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v2), (int8x16_t)xmmword_24074F0D0);
    if (vmovn_s64((int64x2_t)vcgtq_u64(v4, v5)).u8[0]) {
      BOOL *v3 = a2 - 1 == v2;
    }
    if (vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x1FuLL), v5)).i32[1]) {
      v3[600] = a2 - 2 == v2;
    }
    v2 += 2;
    v3 += 1200;
  }
  while (v2 != 32);
  return this;
}

uint64_t MTPathStates::tasksPostPixelatedPositions(MTPathStates *this)
{
  if ((*((_DWORD *)this + 6) - 1000) <= 0xBB7)
  {
    if ((*((unsigned char *)this + 28) & 2) != 0) {
      MTPathStates::checkForRestingThumb(this);
    }
    uint64_t v2 = *((void *)this + 35) + 644;
    for (uint64_t i = 1; i != 32; ++i)
    {
      if (*(_DWORD *)v2)
      {
        if (*((unsigned char *)this + 444) && i == *((_DWORD *)this + 97))
        {
          *(unsigned char *)(v2 + 538) = *(unsigned char *)(v2 + 537);
          *(unsigned char *)(v2 + 537) = 1;
        }
        else
        {
          *(unsigned char *)(v2 + 538) = *(unsigned char *)(v2 + 537);
          *(unsigned char *)(v2 + 537) = 0;
        }
      }
      v2 += 600;
    }
    if (!*((_DWORD *)this + 119) && !*((_DWORD *)this + 118) || !*((_DWORD *)this + 117) && !*((_DWORD *)this + 116))
    {
      MTPathStates::updateHRTDiscountedDisplacement_mm(this);
      MTPathStates::breakOutOfRestingThumbForLargeDiscountedDisplacement(this);
    }
    MTPathStates::updateSpeedSymmetriesOfAllPaths(this);
    MTPathStates::breakOutOfRestingThumbBasedOnSymmetry((uint64_t)this);
    uint64_t v4 = 644;
    uint64_t v5 = 31;
    do
    {
      uint64_t v6 = *((void *)this + 35);
      if (*(_DWORD *)(v6 + v4)) {
        MTParserPath::rejectRestingThumbFromRestingHand(v6 + v4 - 44);
      }
      v4 += 600;
      --v5;
    }
    while (v5);
  }

  return MTPathStatesBasic::tasksPostPixelatedPositions(this);
}

float MTPathStates::updateHRTDiscountedDisplacement_mm(MTPathStates *this)
{
  if ((*((_DWORD *)this + 6) - 1000) <= 0xBB7)
  {
    float result = fmax((float)((float)(MTPathStates::getHighRestingThumbDisplacement(this).f32[0] + *((float *)this + 122))+ -0.14), 0.0);
    *((float *)this + 122) = result;
  }
  return result;
}

double MTPathStates::breakOutOfRestingThumbForLargeDiscountedDisplacement(MTPathStates *this)
{
  int v2 = *((_DWORD *)this + 114);
  if (v2 || (int v2 = *((_DWORD *)this + 115)) != 0)
  {
    uint64_t v3 = *((void *)this + 35);
    uint64_t v4 = (MTParserPath *)(v3 + 600 * v2);
    if (!*((_DWORD *)v4 + 11) || (LODWORD(result) = *((_DWORD *)this + 122), *(float *)&result > 8.0))
    {
      *(unsigned char *)(v3 + 600 * v2 + 586) = 0;
      return MTParserPath::clearPathSpeedSymmetries(v4);
    }
  }
  return result;
}

void MTPathStates::updateSpeedSymmetriesOfAllPaths(MTPathStates *this)
{
  uint64_t v2 = 1;
  uint64_t v3 = 672;
  do
  {
    uint64_t v4 = *((void *)this + 35);
    uint64_t v5 = (float *)(v4 + v3);
    if (v2 == *(_DWORD *)(v4 + v3 - 32) && *v5 > 0.0)
    {
      uint64_t v6 = (MTParserPath *)(v5 - 18);
      if ((MTParserPath::isFingerOrRestingContact((MTParserPath *)(v5 - 18))
         || MTParserPath::isThumbAlongEdgeContact(v6))
        && (*(_DWORD *)(v4 + v3 - 28) - 3) <= 1)
      {
        MTPathStates::computePathAndFingerSpeedSymmetries(this, v2);
      }
    }
    uint64_t v7 = *((void *)this + 35) + v3;
    if ((*(_DWORD *)(v7 - 28) - 3) >= 2) {
      MTParserPath::clearPathSpeedSymmetries((MTParserPath *)(v7 - 72));
    }
    ++v2;
    v3 += 600;
  }
  while (v2 != 32);
}

uint64_t MTPathStates::breakOutOfRestingThumbBasedOnSymmetry(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 280) + 644;
  uint64_t v2 = 31;
  do
  {
    if (*(_DWORD *)v1)
    {
      if (*(unsigned char *)(v1 + 537))
      {
        float v3 = *(float *)(v1 + 544);
        if (v3 < *(float *)(v1 + 548)) {
          float v3 = *(float *)(v1 + 548);
        }
        if (v3 > 0.765 && !*(unsigned char *)(this + 372))
        {
          *(unsigned char *)(v1 + 538) = *(unsigned char *)(v1 + 537);
          *(unsigned char *)(v1 + 537) = 0;
        }
      }
      if (*(unsigned char *)(v1 + 542))
      {
        if (*(float *)(v1 + 552) > 0.87) {
          *(unsigned char *)(v1 + 542) = 0;
        }
      }
    }
    v1 += 600;
    --v2;
  }
  while (v2);
  return this;
}

void MTPathStates::computePathAndFingerSpeedSymmetries(MTPathStates *this, int a2)
{
  unint64_t v73 = 0;
  *(void *)double v74 = 0;
  double v71 = 0;
  float v72 = 0;
  float v4 = 0.0;
  uint64_t v5 = 1;
  __p = 0;
  int v69 = 0;
  unint64_t v70 = 0;
  do
  {
    uint64_t v6 = *((void *)this + 35);
    uint64_t v7 = v6 + 600 * v5;
    int v9 = *(_DWORD *)(v7 + 40);
    double v8 = (_DWORD *)(v7 + 40);
    if (v5 == v9
      && *(float *)(v6 + 600 * v5 + 72) > 0.0
      && (MTParserPath::isFingerOrRestingContact((MTParserPath *)(v6 + 600 * v5))
       || MTParserPath::isThumbAlongEdgeContact((MTParserPath *)(v6 + 600 * v5)))
      && (*(_DWORD *)(v6 + 600 * v5 + 44) - 3) <= 1)
    {
      if (*v8 == a2)
      {
        uint64_t v10 = v6 + 600 * v5;
        float v4 = *(float *)(v10 + 536);
        *(void *)double v74 = *(void *)(v10 + 528);
      }
      else
      {
        uint64_t v11 = v6 + 600 * v5;
        uint64_t v12 = *(void *)(v11 + 528);
        int v13 = *(_DWORD *)(v11 + 536);
        uint64_t v14 = v72;
        if ((unint64_t)v72 >= v73)
        {
          double v16 = v71;
          int64_t v17 = ((char *)v72 - (char *)v71) >> 3;
          unint64_t v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 61) {
            std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v19 = v73 - (void)v71;
          if ((uint64_t)(v73 - (void)v71) >> 2 > v18) {
            unint64_t v18 = v19 >> 2;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (v20)
          {
            __int16 v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTPoint>>((uint64_t)&v73, v20);
            double v16 = v71;
            uint64_t v14 = v72;
          }
          else
          {
            __int16 v21 = 0;
          }
          float v22 = (float *)&v21[8 * v17];
          *(void *)float v22 = v12;
          unint64_t v15 = v22 + 2;
          if (v14 != v16)
          {
            do
            {
              uint64_t v23 = *((void *)v14 - 1);
              v14 -= 2;
              *((void *)v22 - MTHandMotion::clearHandMotion(this, 1) = v23;
              v22 -= 2;
            }
            while (v14 != v16);
            double v16 = v71;
          }
          double v71 = v22;
          float v72 = v15;
          unint64_t v73 = (unint64_t)&v21[8 * v20];
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *(void *)float v72 = v12;
          unint64_t v15 = v14 + 2;
        }
        float v72 = v15;
        unsigned int v24 = v69;
        if ((unint64_t)v69 >= v70)
        {
          unsigned int v26 = (float *)__p;
          int64_t v27 = ((char *)v69 - (unsigned char *)__p) >> 2;
          unint64_t v28 = v27 + 1;
          if ((unint64_t)(v27 + 1) >> 62) {
            std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v29 = v70 - (void)__p;
          if ((uint64_t)(v70 - (void)__p) >> 1 > v28) {
            unint64_t v28 = v29 >> 1;
          }
          if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v30 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v30 = v28;
          }
          if (v30)
          {
            __int16 v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v70, v30);
            unsigned int v26 = (float *)__p;
            unsigned int v24 = v69;
          }
          else
          {
            __int16 v31 = 0;
          }
          double v32 = (float *)&v31[4 * v27];
          *(_DWORD *)double v32 = v13;
          __int16 v25 = v32 + 1;
          while (v24 != v26)
          {
            int v33 = *((_DWORD *)v24-- - 1);
            *((_DWORD *)v32-- - MTHandMotion::clearHandMotion(this, 1) = v33;
          }
          __p = v32;
          int v69 = v25;
          unint64_t v70 = (unint64_t)&v31[4 * v30];
          if (v26) {
            operator delete(v26);
          }
        }
        else
        {
          *(_DWORD *)int v69 = v13;
          __int16 v25 = v24 + 1;
        }
        int v69 = v25;
      }
    }
    ++v5;
  }
  while (v5 != 32);
  unint64_t v34 = 126 - 2 * __clz(((char *)v69 - (unsigned char *)__p) >> 2);
  if (v69 == __p) {
    uint64_t v35 = 0;
  }
  else {
    uint64_t v35 = v34;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::greater<float> &,float *,false>((float *)__p, v69, (uint64_t)&__src, v35, 1);
  unint64_t v36 = 126 - 2 * __clz(((char *)v72 - (char *)v71) >> 3);
  if (v72 == v71) {
    uint64_t v37 = 0;
  }
  else {
    uint64_t v37 = v36;
  }
  std::__introsort<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *,false>((uint64_t)v71, v72, (uint64_t)&__src, v37, 1);
  __src = 0;
  double v66 = 0;
  uint64_t v67 = 0;
  std::vector<MTPoint>::__init_with_size[abi:ne180100]<MTPoint*,MTPoint*>(&__src, v71, (uint64_t)v72, ((char *)v72 - (char *)v71) >> 3);
  std::vector<MTPoint>::insert((uint64_t)&__src, (char *)__src, v74);
  double v60 = 0;
  uint64_t v61 = 0;
  double v59 = 0;
  std::vector<MTPoint>::__init_with_size[abi:ne180100]<MTPoint*,MTPoint*>(&v59, __src, (uint64_t)v66, (v66 - (unsigned char *)__src) >> 3);
  MTPathStates::getCosineThetas((float **)&v59, &v62);
  double v38 = v62;
  uint64_t v39 = v63;
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  int v62 = 0;
  if (v59)
  {
    double v60 = v59;
    operator delete(v59);
  }
  float v40 = 0.0;
  float v41 = 0.0;
  if (v4 > 10.0)
  {
    double v56 = 0;
    double v57 = 0;
    uint64_t v58 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v56, __p, (uint64_t)v69, ((char *)v69 - (unsigned char *)__p) >> 2);
    unsigned __int16 v53 = 0;
    __int16 v54 = 0;
    uint64_t v55 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v53, v38, v39, (v39 - (uint64_t)v38) >> 2);
    long long v42 = v56;
    if (v57 != v56)
    {
      float v43 = sqrtf(v4 * *(float *)v56);
      float v44 = 1.0;
      if (v54 != v53) {
        float v44 = *(float *)v53;
      }
      float v40 = (float)(v43 / (float)((float)((float)(v4 + *(float *)v56) * 0.5) + 1.0)) * v44;
    }
    if (v53)
    {
      __int16 v54 = v53;
      operator delete(v53);
      long long v42 = v56;
    }
    if (v42)
    {
      double v57 = v42;
      operator delete(v42);
    }
    double v50 = 0;
    double v51 = 0;
    uint64_t v52 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v50, __p, (uint64_t)v69, ((char *)v69 - (unsigned char *)__p) >> 2);
    double v47 = 0;
    double v48 = 0;
    uint64_t v49 = 0;
    long long v45 = std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v47, v38, v39, (v39 - (uint64_t)v38) >> 2);
    MTPathStates::compute_3F_path_speed_symmetry(v4, (uint64_t)v45, &v50);
    float v41 = v46;
    if (v47)
    {
      double v48 = v47;
      operator delete(v47);
    }
    if (v50)
    {
      double v51 = v50;
      operator delete(v50);
    }
  }
  MTParserPath::setPathSpeedSymmetries((float *)(*((void *)this + 35) + 600 * a2), v40, v41);
  if (__src)
  {
    double v66 = __src;
    operator delete(__src);
  }
  if (v38) {
    operator delete(v38);
  }
  if (__p)
  {
    int v69 = (float *)__p;
    operator delete(__p);
  }
  if (v71)
  {
    float v72 = v71;
    operator delete(v71);
  }
}

void sub_24070C70C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32)
{
  if (__p) {
    operator delete(__p);
  }
  if (a28) {
    operator delete(a28);
  }
  if (v32) {
    operator delete(v32);
  }
  if (a31) {
    operator delete(a31);
  }
  uint64_t v35 = *(void **)(v33 - 152);
  if (v35)
  {
    *(void *)(v33 - 144) = v35;
    operator delete(v35);
  }
  _Unwind_Resume(exception_object);
}

float32x2_t MTPathStates::getHighRestingThumbDisplacement(MTPathStates *this)
{
  int v1 = *((_DWORD *)this + 114);
  if (v1 || (int v1 = *((_DWORD *)this + 115)) != 0)
  {
    uint64_t v2 = *((void *)this + 35) + 600 * (int)(float)v1;
    float32x2_t v3 = vsub_f32(*(float32x2_t *)(v2 + 92), *(float32x2_t *)(v2 + 188));
    float32x2_t result = vmul_f32(v3, v3);
    result.f32[0] = sqrtf(vaddv_f32(result));
  }
  else
  {
    return 0;
  }
  return result;
}

char *std::vector<MTPoint>::insert(uint64_t a1, char *__src, char *a3)
{
  float32x2_t v3 = a3;
  float v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    int v13 = *(char **)a1;
    *(_OWORD *)__p = 0u;
    long long v27 = 0u;
    unint64_t v14 = ((v6 - v13) >> 3) + 1;
    if (v14 >> 61) {
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v28 = a1 + 16;
    if (v18) {
      uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTPoint>>(a1 + 16, v18);
    }
    else {
      uint64_t v19 = 0;
    }
    unint64_t v20 = &v19[8 * v16];
    __p[0] = v19;
    __p[1] = v20;
    *(void *)&long long v27 = v20;
    *((void *)&v27 + MTHandMotion::clearHandMotion(this, 1) = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        uint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTPoint>>(v8, v22);
        unint64_t v20 = &v23[8 * (v22 >> 2)];
        __p[0] = v23;
        __p[1] = v20;
        *((void *)&v27 + MTHandMotion::clearHandMotion(this, 1) = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        __p[1] = v20;
      }
    }
    *(void *)unint64_t v20 = *(void *)v3;
    *(void *)&long long v27 = v20 + 8;
    float v4 = std::vector<MTPoint>::__swap_out_circular_buffer((void **)a1, (uint64_t)__p, v4);
    if ((void *)v27 != __p[1]) {
      *(void *)&long long v27 = v27 + (((unint64_t)__p[1] - v27 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
    if (__p[0]) {
      operator delete(__p[0]);
    }
  }
  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }
  else
  {
    int v9 = __src + 8;
    uint64_t v10 = v6 - 8;
    uint64_t v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)float v4 = *(void *)v3;
  }
  return v4;
}

void sub_24070CA1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MTPathStates::getCosineThetas(float **a1@<X1>, float **a2@<X8>)
{
  a2[2] = 0;
  uint64_t v2 = a2 + 2;
  *a2 = 0;
  a2[1] = 0;
  float32x2_t v3 = *a1;
  float v4 = a1[1];
  if (*a1 != v4)
  {
    unint64_t v7 = 0;
    do
    {
      uint64_t v8 = v3;
      v3 += 2;
      if (v3 == v4)
      {
        uint64_t v16 = v7;
      }
      else
      {
        float v4 = v3;
        do
        {
          float v9 = *v8;
          float v10 = v8[1];
          float v11 = sqrtf((float)(v9 * v9) + (float)(v10 * v10));
          float v12 = 1.0;
          if (v11 > 0.0)
          {
            float v13 = *v4;
            float v14 = v4[1];
            float v15 = sqrtf((float)(v13 * v13) + (float)(v14 * v14));
            if (v15 > 0.0) {
              float v12 = (float)((float)(v10 * v14) + (float)(v9 * v13)) / (float)(v11 * v15);
            }
          }
          if ((unint64_t)v7 >= *v2)
          {
            uint64_t v17 = *a2;
            uint64_t v18 = v7 - *a2;
            unint64_t v19 = v18 + 1;
            if ((unint64_t)(v18 + 1) >> 62) {
              std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v20 = *v2 - (void)v17;
            if (v20 >> 1 > v19) {
              unint64_t v19 = v20 >> 1;
            }
            if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v21 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v21 = v19;
            }
            if (v21)
            {
              unint64_t v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v2, v21);
              uint64_t v17 = *a2;
              unint64_t v7 = a2[1];
            }
            else
            {
              unint64_t v22 = 0;
            }
            uint64_t v23 = (float *)&v22[4 * v18];
            *uint64_t v23 = v12;
            uint64_t v16 = v23 + 1;
            while (v7 != v17)
            {
              int v24 = *((_DWORD *)v7-- - 1);
              *((_DWORD *)v23-- - MTHandMotion::clearHandMotion(this, 1) = v24;
            }
            *a2 = v23;
            a2[1] = v16;
            a2[2] = (float *)&v22[4 * v21];
            if (v17) {
              operator delete(v17);
            }
          }
          else
          {
            *unint64_t v7 = v12;
            uint64_t v16 = v7 + 1;
          }
          a2[1] = v16;
          v4 += 2;
          unint64_t v7 = v16;
        }
        while (v4 != a1[1]);
      }
      unint64_t v7 = v16;
    }
    while (v3 != v4);
  }
}

void sub_24070CBF4(_Unwind_Exception *exception_object)
{
  float32x2_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double MTPathStates::compute_2F_path_speed_symmetry(float a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  float v4 = *(float **)a3;
  if (*(void *)(a3 + 8) == *(void *)a3) {
    return 0.0;
  }
  float v5 = sqrtf(*v4 * a1);
  float v6 = (float)(*v4 + a1) * 0.5;
  float v7 = 1.0;
  if (*(void *)(a4 + 8) != *(void *)a4) {
    float v7 = **(float **)a4;
  }
  *(float *)&double result = (float)(v5 / (float)(v6 + 1.0)) * v7;
  return result;
}

void MTPathStates::compute_3F_path_speed_symmetry(float a1, uint64_t a2, void *a3)
{
  if (a3[1] - *a3 >= 5uLL) {
    cbrtf((float)(*(float *)*a3 * a1) * *(float *)(*a3 + 4));
  }
}

float MTPathStates::get_3F_IncludingThumbSpeedSymmetry(MTPathStates *this)
{
  uint64_t v2 = 1;
  for (uint64_t i = 1192; ; i += 600)
  {
    uint64_t v4 = *((void *)this + 35);
    if (v2 == *(_DWORD *)(v4 + i - 552)
      && *(float *)(v4 + i - 520) > 0.0
      && MTParserPath::isThumbContact((MTParserPath *)(v4 + i - 592))
      && (*(_DWORD *)(v4 + i - 548) - 3) <= 1)
    {
      break;
    }
    if (++v2 == 32) {
      return 0.0;
    }
  }
  return *(float *)(v4 + i);
}

void std::vector<MTPoint>::__throw_length_error[abi:ne180100]()
{
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_2650D32B0, MEMORY[0x263F8C060]);
}

void sub_24070CE08(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  double result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C388] + 16);
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<MTPoint>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(8 * a2);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x263F8C208], MEMORY[0x263F8C090]);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(4 * a2);
}

float *std::__introsort<std::_ClassicAlgPolicy,std::greater<float> &,float *,false>(float *result, float *a2, uint64_t a3, uint64_t a4, char a5)
{
  float v10 = result;
LABEL_2:
  float v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    float v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = a2 - v11;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          float v22 = *(a2 - 1);
          float v23 = *v11;
          if (v22 > *v11)
          {
            *float v11 = v22;
            *(a2 - MTHandMotion::clearHandMotion(this, 1) = v23;
          }
          break;
        case 3uLL:
          float v24 = v11[1];
          float v25 = *(a2 - 1);
          if (v24 <= v25) {
            int v26 = *((_DWORD *)a2 - 1);
          }
          else {
            int v26 = *((_DWORD *)v11 + 1);
          }
          if (v24 > v25) {
            float v24 = *(a2 - 1);
          }
          *(a2 - MTHandMotion::clearHandMotion(this, 1) = v24;
          *((_DWORD *)v11 + MTHandMotion::clearHandMotion(this, 1) = v26;
          float v27 = *(a2 - 1);
          if (v27 <= *v11) {
            float v28 = *v11;
          }
          else {
            float v28 = *(a2 - 1);
          }
          if (v27 > *v11) {
            float v27 = *v11;
          }
          *(a2 - MTHandMotion::clearHandMotion(this, 1) = v27;
          int v30 = *(_DWORD *)v11;
          float v29 = v11[1];
          if (v28 <= v29)
          {
            int v30 = *((_DWORD *)v11 + 1);
            float v29 = v28;
          }
          *(_DWORD *)float v11 = v30;
          v11[1] = v29;
          break;
        case 4uLL:
          float v32 = v11[1];
          float v31 = v11[2];
          if (*v11 <= v31) {
            int v33 = *((_DWORD *)v11 + 2);
          }
          else {
            int v33 = *(_DWORD *)v11;
          }
          if (*v11 <= v31) {
            float v31 = *v11;
          }
          v11[2] = v31;
          *(_DWORD *)float v11 = v33;
          float v34 = *(a2 - 1);
          if (v32 <= v34) {
            float v35 = *(a2 - 1);
          }
          else {
            float v35 = v32;
          }
          if (v32 <= v34) {
            float v34 = v32;
          }
          *(a2 - MTHandMotion::clearHandMotion(this, 1) = v34;
          float v36 = *v11;
          if (*v11 <= v35) {
            float v37 = v35;
          }
          else {
            float v37 = *v11;
          }
          if (*v11 > v35) {
            float v36 = v35;
          }
          *float v11 = v37;
          v11[1] = v36;
          float v38 = v11[2];
          float v39 = *(a2 - 1);
          if (v38 <= v39) {
            float v40 = *(a2 - 1);
          }
          else {
            float v40 = v11[2];
          }
          if (v38 > v39) {
            float v38 = *(a2 - 1);
          }
          *(a2 - MTHandMotion::clearHandMotion(this, 1) = v38;
          float v41 = v11[1];
          if (v41 <= v40) {
            float v42 = v40;
          }
          else {
            float v42 = v11[1];
          }
          if (v41 > v40) {
            float v41 = v40;
          }
          v11[1] = v42;
          v11[2] = v41;
          break;
        case 5uLL:
          int v43 = *(_DWORD *)v11;
          float v44 = v11[1];
          if (*v11 <= v44) {
            int v45 = *((_DWORD *)v11 + 1);
          }
          else {
            int v45 = *(_DWORD *)v11;
          }
          if (*v11 > v44) {
            int v43 = *((_DWORD *)v11 + 1);
          }
          *(_DWORD *)float v11 = v45;
          *((_DWORD *)v11 + MTHandMotion::clearHandMotion(this, 1) = v43;
          float v46 = v11[3];
          float v47 = *(a2 - 1);
          if (v46 <= v47) {
            int v48 = *((_DWORD *)a2 - 1);
          }
          else {
            int v48 = *((_DWORD *)v11 + 3);
          }
          if (v46 > v47) {
            float v46 = *(a2 - 1);
          }
          *(a2 - MTHandMotion::clearHandMotion(this, 1) = v46;
          *((_DWORD *)v11 + 3) = v48;
          float v49 = *(a2 - 1);
          float v50 = v11[2];
          if (v49 <= v50) {
            float v51 = v11[2];
          }
          else {
            float v51 = *(a2 - 1);
          }
          if (v49 > v50) {
            float v49 = v11[2];
          }
          *(a2 - MTHandMotion::clearHandMotion(this, 1) = v49;
          int v53 = *((_DWORD *)v11 + 2);
          float v52 = v11[3];
          float v54 = v11[1];
          if (v51 <= v52)
          {
            int v53 = *((_DWORD *)v11 + 3);
            float v52 = v51;
          }
          *((_DWORD *)v11 + 2) = v53;
          v11[3] = v52;
          float v55 = *(a2 - 1);
          if (v54 <= v55) {
            float v56 = *(a2 - 1);
          }
          else {
            float v56 = v54;
          }
          if (v54 <= v55) {
            float v55 = v54;
          }
          *(a2 - MTHandMotion::clearHandMotion(this, 1) = v55;
          int v57 = *(_DWORD *)v11;
          float v59 = v11[2];
          float v58 = v11[3];
          if (v58 <= *v11) {
            float v60 = *v11;
          }
          else {
            float v60 = v11[3];
          }
          if (v58 > *v11) {
            float v58 = *v11;
          }
          if (v60 <= v59)
          {
            int v57 = *((_DWORD *)v11 + 2);
            float v59 = v60;
          }
          if (v58 <= v56) {
            float v61 = v56;
          }
          else {
            float v61 = v58;
          }
          if (v58 > v56) {
            float v58 = v56;
          }
          if (v61 <= v59) {
            float v56 = v59;
          }
          *(_DWORD *)float v11 = v57;
          v11[1] = v56;
          if (v61 <= v59) {
            float v62 = v61;
          }
          else {
            float v62 = v59;
          }
          v11[2] = v62;
          v11[3] = v58;
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 95) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *,float *>(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    uint64_t v17 = &v11[v15 >> 1];
    if ((unint64_t)v14 >= 0x201)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(v11, &v11[v15 >> 1], a2 - 1);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(v11 + 1, v17 - 1, a2 - 2);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(v11 + 2, &v11[v16 + 1], a2 - 3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(v17 - 1, v17, &v11[v16 + 1]);
      float v18 = *v11;
      *float v11 = *v17;
      *uint64_t v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(&v11[v15 >> 1], v11, a2 - 1);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (*(v11 - 1) <= *v11)
    {
      double result = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,float *,std::greater<float> &>(v11, a2);
      float v11 = result;
      goto LABEL_19;
    }
LABEL_14:
    unint64_t v19 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,float *,std::greater<float> &>(v11, a2);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(v11, v19);
    float v11 = v19 + 1;
    double result = (float *)std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(v19 + 1, a2);
    if (result)
    {
      a4 = -v13;
      a2 = v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      double result = (float *)std::__introsort<std::_ClassicAlgPolicy,std::greater<float> &,float *,false>(v10, v19, a3, -v13, a5 & 1);
      float v11 = v19 + 1;
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  uint64_t v63 = v11 + 1;
  BOOL v65 = v11 == a2 || v63 == a2;
  if (a5)
  {
    if (!v65)
    {
      uint64_t v66 = 0;
      uint64_t v67 = v11;
      do
      {
        float v69 = *v67;
        float v68 = v67[1];
        uint64_t v67 = v63;
        if (v68 > v69)
        {
          uint64_t v70 = v66;
          while (1)
          {
            *(float *)((char *)v11 + v70 + 4) = v69;
            if (!v70) {
              break;
            }
            float v69 = *(float *)((char *)v11 + v70 - 4);
            v70 -= 4;
            if (v68 <= v69)
            {
              double v71 = (float *)((char *)v11 + v70 + 4);
              goto LABEL_119;
            }
          }
          double v71 = v11;
LABEL_119:
          *double v71 = v68;
        }
        uint64_t v63 = v67 + 1;
        v66 += 4;
      }
      while (v67 + 1 != a2);
    }
  }
  else if (!v65)
  {
    do
    {
      float v73 = *v10;
      float v72 = v10[1];
      float v10 = v63;
      if (v72 > v73)
      {
        double v74 = v63;
        do
        {
          *double v74 = v73;
          float v73 = *(v74 - 2);
          --v74;
        }
        while (v72 > v73);
        *double v74 = v72;
      }
      ++v63;
    }
    while (v10 + 1 != a2);
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(float *a1, float *a2, float *a3)
{
  float v3 = *a2;
  float v4 = *a1;
  float v5 = *a3;
  if (*a2 > *a1)
  {
    if (v5 > v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 <= v4) {
      return 1;
    }
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 > v3)
  {
    *a2 = v5;
    *a3 = v3;
    float v6 = *a1;
    if (*a2 <= *a1) {
      return 1;
    }
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

float *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,float *,std::greater<float> &>(float *a1, float *a2)
{
  float v2 = *a1;
  if (*a1 <= *(a2 - 1))
  {
    float v5 = a1 + 1;
    do
    {
      float v3 = v5;
      if (v5 >= a2) {
        break;
      }
      ++v5;
    }
    while (v2 <= *v3);
  }
  else
  {
    float v3 = a1;
    do
    {
      float v4 = v3[1];
      ++v3;
    }
    while (v2 <= v4);
  }
  if (v3 < a2)
  {
    do
      float v6 = *--a2;
    while (v2 > v6);
  }
  if (v3 < a2)
  {
    float v7 = *v3;
    float v8 = *a2;
    do
    {
      float *v3 = v8;
      *a2 = v7;
      do
      {
        float v9 = v3[1];
        ++v3;
        float v7 = v9;
      }
      while (v2 <= v9);
      do
      {
        float v10 = *--a2;
        float v8 = v10;
      }
      while (v2 > v10);
    }
    while (v3 < a2);
  }
  if (v3 - 1 != a1) {
    *a1 = *(v3 - 1);
  }
  *(v3 - MTHandMotion::clearHandMotion(this, 1) = v2;
  return v3;
}

float *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,float *,std::greater<float> &>(float *a1, float *a2)
{
  uint64_t v2 = 0;
  float v3 = *a1;
  do
    float v4 = a1[++v2];
  while (v4 > v3);
  float v5 = &a1[v2];
  float v6 = &a1[v2 - 1];
  if (v2 == 1)
  {
    do
    {
      if (v5 >= a2) {
        break;
      }
      float v8 = *--a2;
    }
    while (v8 <= v3);
  }
  else
  {
    do
      float v7 = *--a2;
    while (v7 <= v3);
  }
  if (v5 < a2)
  {
    float v9 = *a2;
    float v10 = a2;
    unint64_t v11 = (unint64_t)v5;
    do
    {
      *(float *)unint64_t v11 = v9;
      *float v10 = v4;
      do
      {
        float v12 = *(float *)(v11 + 4);
        v11 += 4;
        float v4 = v12;
      }
      while (v12 > v3);
      do
      {
        float v13 = *--v10;
        float v9 = v13;
      }
      while (v13 <= v3);
    }
    while (v11 < (unint64_t)v10);
    float v6 = (float *)(v11 - 4);
  }
  if (v6 != a1) {
    *a1 = *v6;
  }
  *float v6 = v3;
  return v6;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(float *a1, float *a2)
{
  BOOL v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      float v3 = *(a2 - 1);
      float v4 = *a1;
      if (v3 > *a1)
      {
        *a1 = v3;
        *(a2 - MTHandMotion::clearHandMotion(this, 1) = v4;
      }
      break;
    case 3:
      float v20 = a1[1];
      float v21 = *(a2 - 1);
      if (v20 <= v21) {
        int v22 = *((_DWORD *)a2 - 1);
      }
      else {
        int v22 = *((_DWORD *)a1 + 1);
      }
      if (v20 > v21) {
        float v20 = *(a2 - 1);
      }
      *(a2 - MTHandMotion::clearHandMotion(this, 1) = v20;
      *((_DWORD *)a1 + MTHandMotion::clearHandMotion(this, 1) = v22;
      float v23 = *(a2 - 1);
      if (v23 <= *a1) {
        float v24 = *a1;
      }
      else {
        float v24 = *(a2 - 1);
      }
      if (v23 > *a1) {
        float v23 = *a1;
      }
      *(a2 - MTHandMotion::clearHandMotion(this, 1) = v23;
      float v26 = *a1;
      float v25 = a1[1];
      if (v24 <= v25)
      {
        float v26 = a1[1];
        float v25 = v24;
      }
      *a1 = v26;
      a1[1] = v25;
      break;
    case 4:
      float v48 = a1[1];
      float v47 = a1[2];
      if (*a1 <= v47) {
        float v49 = a1[2];
      }
      else {
        float v49 = *a1;
      }
      if (*a1 <= v47) {
        float v47 = *a1;
      }
      a1[2] = v47;
      *a1 = v49;
      float v50 = *(a2 - 1);
      if (v48 <= v50) {
        float v51 = *(a2 - 1);
      }
      else {
        float v51 = v48;
      }
      if (v48 <= v50) {
        float v50 = v48;
      }
      *(a2 - MTHandMotion::clearHandMotion(this, 1) = v50;
      float v52 = *a1;
      if (*a1 <= v51) {
        float v53 = v51;
      }
      else {
        float v53 = *a1;
      }
      if (*a1 > v51) {
        float v52 = v51;
      }
      *a1 = v53;
      a1[1] = v52;
      float v54 = a1[2];
      float v55 = *(a2 - 1);
      if (v54 <= v55) {
        float v56 = *(a2 - 1);
      }
      else {
        float v56 = a1[2];
      }
      if (v54 > v55) {
        float v54 = *(a2 - 1);
      }
      *(a2 - MTHandMotion::clearHandMotion(this, 1) = v54;
      float v57 = a1[1];
      if (v57 <= v56) {
        float v58 = v56;
      }
      else {
        float v58 = a1[1];
      }
      if (v57 > v56) {
        float v57 = v56;
      }
      a1[1] = v58;
      a1[2] = v57;
      break;
    case 5:
      float v27 = *a1;
      float v28 = a1[1];
      if (*a1 <= v28) {
        float v29 = a1[1];
      }
      else {
        float v29 = *a1;
      }
      if (*a1 > v28) {
        float v27 = a1[1];
      }
      *a1 = v29;
      a1[1] = v27;
      float v30 = a1[3];
      float v31 = *(a2 - 1);
      if (v30 <= v31) {
        int v32 = *((_DWORD *)a2 - 1);
      }
      else {
        int v32 = *((_DWORD *)a1 + 3);
      }
      if (v30 > v31) {
        float v30 = *(a2 - 1);
      }
      *(a2 - MTHandMotion::clearHandMotion(this, 1) = v30;
      *((_DWORD *)a1 + 3) = v32;
      float v33 = *(a2 - 1);
      float v34 = a1[2];
      if (v33 <= v34) {
        float v35 = a1[2];
      }
      else {
        float v35 = *(a2 - 1);
      }
      if (v33 > v34) {
        float v33 = a1[2];
      }
      *(a2 - MTHandMotion::clearHandMotion(this, 1) = v33;
      int v37 = *((_DWORD *)a1 + 2);
      float v36 = a1[3];
      float v38 = a1[1];
      if (v35 <= v36)
      {
        int v37 = *((_DWORD *)a1 + 3);
        float v36 = v35;
      }
      *((_DWORD *)a1 + 2) = v37;
      a1[3] = v36;
      float v39 = *(a2 - 1);
      if (v38 <= v39) {
        float v40 = *(a2 - 1);
      }
      else {
        float v40 = v38;
      }
      if (v38 <= v39) {
        float v39 = v38;
      }
      *(a2 - MTHandMotion::clearHandMotion(this, 1) = v39;
      float v41 = *a1;
      float v43 = a1[2];
      float v42 = a1[3];
      if (v42 <= *a1) {
        float v44 = *a1;
      }
      else {
        float v44 = a1[3];
      }
      if (v42 > *a1) {
        float v42 = *a1;
      }
      if (v44 <= v43)
      {
        float v41 = a1[2];
        float v43 = v44;
      }
      if (v42 <= v40) {
        float v45 = v40;
      }
      else {
        float v45 = v42;
      }
      if (v42 > v40) {
        float v42 = v40;
      }
      if (v45 <= v43) {
        float v40 = v43;
      }
      *a1 = v41;
      a1[1] = v40;
      if (v45 <= v43) {
        float v46 = v45;
      }
      else {
        float v46 = v43;
      }
      a1[2] = v46;
      a1[3] = v42;
      break;
    default:
      float v5 = a1 + 2;
      float v6 = a1[2];
      float v8 = *a1;
      float v7 = a1[1];
      if (v7 <= v6) {
        float v9 = a1[2];
      }
      else {
        float v9 = a1[1];
      }
      if (v7 <= v6) {
        float v6 = a1[1];
      }
      if (v6 <= v8) {
        float v10 = *a1;
      }
      else {
        float v10 = v6;
      }
      if (v6 > v8) {
        float v6 = *a1;
      }
      float *v5 = v6;
      if (v10 <= v9) {
        float v11 = v9;
      }
      else {
        float v11 = v8;
      }
      if (v10 > v9) {
        float v10 = v9;
      }
      *a1 = v11;
      a1[1] = v10;
      float v12 = a1 + 3;
      if (a1 + 3 == a2)
      {
LABEL_29:
        BOOL v2 = 1;
      }
      else
      {
        int v13 = 0;
        uint64_t v14 = 12;
        while (1)
        {
          float v15 = *v12;
          float v16 = *v5;
          if (*v12 > *v5)
          {
            uint64_t v17 = v14;
            while (1)
            {
              *(float *)((char *)a1 + v17) = v16;
              uint64_t v18 = v17 - 4;
              if (v17 == 4) {
                break;
              }
              float v16 = *(float *)((char *)a1 + v17 - 8);
              v17 -= 4;
              if (v15 <= v16)
              {
                unint64_t v19 = (float *)((char *)a1 + v18);
                goto LABEL_27;
              }
            }
            unint64_t v19 = a1;
LABEL_27:
            *unint64_t v19 = v15;
            if (++v13 == 8) {
              break;
            }
          }
          float v5 = v12;
          v14 += 4;
          if (++v12 == a2) {
            goto LABEL_29;
          }
        }
        BOOL v2 = v12 + 1 == a2;
      }
      break;
  }
  return v2;
}

float *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *,float *>(float *a1, float *a2, float *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    float v6 = a2;
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 5)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      float v12 = &a1[v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    int v13 = v6;
    if (v6 != a3)
    {
      uint64_t v14 = v6;
      do
      {
        float v15 = *v14;
        if (*v14 > *a1)
        {
          float *v14 = *a1;
          *a1 = v15;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      int v13 = a3;
    }
    if (v8 >= 5)
    {
      uint64_t v16 = (unint64_t)v8 >> 2;
      do
      {
        uint64_t v17 = 0;
        float v18 = *a1;
        unint64_t v19 = a1;
        do
        {
          float v20 = v19;
          v19 += v17 + 1;
          uint64_t v21 = 2 * v17;
          uint64_t v17 = (2 * v17) | 1;
          uint64_t v22 = v21 + 2;
          if (v22 < v16 && *v19 > v19[1])
          {
            ++v19;
            uint64_t v17 = v22;
          }
          float *v20 = *v19;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v19 == --v6)
        {
          *unint64_t v19 = v18;
        }
        else
        {
          *unint64_t v19 = *v6;
          *float v6 = v18;
          uint64_t v23 = (char *)v19 - (char *)a1 + 4;
          if (v23 >= 5)
          {
            unint64_t v24 = (((unint64_t)v23 >> 2) - 2) >> 1;
            float v25 = &a1[v24];
            float v26 = *v25;
            float v27 = *v19;
            if (*v25 > *v19)
            {
              do
              {
                float v28 = v25;
                *unint64_t v19 = v26;
                if (!v24) {
                  break;
                }
                unint64_t v24 = (v24 - 1) >> 1;
                float v25 = &a1[v24];
                float v26 = *v25;
                unint64_t v19 = v28;
              }
              while (*v25 > v27);
              *float v28 = v27;
            }
          }
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<float> &,float *>(uint64_t result, uint64_t a2, uint64_t a3, float *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 2)
    {
      uint64_t v6 = v4 >> 1;
      uint64_t v7 = (v4 >> 1) + 1;
      uint64_t v8 = (float *)(result + 4 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 < a3 && *v8 > v8[1])
      {
        ++v8;
        uint64_t v7 = v9;
      }
      float v10 = *v8;
      float v11 = *a4;
      if (*v8 <= *a4)
      {
        do
        {
          float v12 = v8;
          *a4 = v10;
          if (v5 < v7) {
            break;
          }
          uint64_t v13 = 2 * v7;
          uint64_t v7 = (2 * v7) | 1;
          uint64_t v8 = (float *)(result + 4 * v7);
          uint64_t v14 = v13 + 2;
          if (v14 < a3 && *v8 > v8[1])
          {
            ++v8;
            uint64_t v7 = v14;
          }
          float v10 = *v8;
          a4 = v12;
        }
        while (*v8 <= v11);
        *float v12 = v11;
      }
    }
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *,false>(uint64_t result, float *a2, uint64_t a3, uint64_t a4, char a5)
{
  float v10 = (float *)result;
LABEL_2:
  float v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    float v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = ((char *)a2 - (char *)v11) >> 3;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          float v22 = *v11;
          float v23 = v11[1];
          if (sqrtf((float)(*(a2 - 1) * *(a2 - 1)) + (float)(*(a2 - 2) * *(a2 - 2))) > sqrtf((float)(v23 * v23)+ (float)(v22 * v22)))
          {
            *(void *)float v11 = *((void *)a2 - 1);
            *(a2 - 2) = v22;
            *(a2 - MTHandMotion::clearHandMotion(this, 1) = v23;
          }
          break;
        case 3uLL:
          double result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v11, v11 + 2, a2 - 2);
          break;
        case 4uLL:
          double result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v11, v11 + 2, v11 + 4, (uint64_t)(a2 - 2));
          break;
        case 5uLL:
          double result = std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v11, v11 + 2, v11 + 4, v11 + 6, (uint64_t)(a2 - 2));
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 191) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *,MTPoint *>(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    uint64_t v17 = &v11[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x401)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v11, &v11[2 * (v15 >> 1)], a2 - 2);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v11 + 2, v17 - 2, a2 - 4);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v11 + 4, &v11[2 * v16 + 2], a2 - 6);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v17 - 2, v17, &v11[2 * v16 + 2]);
      uint64_t v18 = *(void *)v11;
      *(void *)float v11 = *(void *)v17;
      *(void *)uint64_t v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(&v11[2 * (v15 >> 1)], v11, a2 - 2);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (sqrtf((float)(*(v11 - 1) * *(v11 - 1)) + (float)(*(v11 - 2) * *(v11 - 2))) <= sqrtf((float)(v11[1] * v11[1])+ (float)(*v11 * *v11)))
    {
      double result = (uint64_t)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,MTPoint *,MTPointVelocityGreaterThan &>(v11, (unint64_t)a2);
      float v11 = (float *)result;
      goto LABEL_19;
    }
LABEL_14:
    unint64_t v19 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,MTPoint *,MTPointVelocityGreaterThan &>(v11, (unint64_t)a2);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v11, v19);
    float v11 = v19 + 2;
    double result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v19 + 2, a2);
    if (result)
    {
      a4 = -v13;
      a2 = v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      double result = std::__introsort<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *,false>(v10, v19, a3, -v13, a5 & 1);
      float v11 = v19 + 2;
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return (uint64_t)std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v11, a2);
  }
  else
  {
    return (uint64_t)std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(v11, a2);
  }
}

float *std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(float *result, float *a2)
{
  if (result != a2)
  {
    BOOL v2 = result + 2;
    if (result + 2 != a2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = result;
      do
      {
        float v5 = v4[2];
        float v6 = v4[3];
        float v7 = *v4;
        float v8 = v4[1];
        uint64_t v4 = v2;
        float v9 = sqrtf((float)(v6 * v6) + (float)(v5 * v5));
        if (v9 > sqrtf((float)(v8 * v8) + (float)(v7 * v7)))
        {
          uint64_t v10 = v3;
          while (1)
          {
            *(void *)((char *)result + v10 + 8) = *(void *)((char *)result + v10);
            if (!v10) {
              break;
            }
            float v11 = sqrtf((float)(*(float *)((char *)result + v10 - 4) * *(float *)((char *)result + v10 - 4))+ (float)(*(float *)((char *)result + v10 - 8) * *(float *)((char *)result + v10 - 8)));
            v10 -= 8;
            if (v9 <= v11)
            {
              uint64_t v12 = (float *)((char *)result + v10 + 8);
              goto LABEL_10;
            }
          }
          uint64_t v12 = result;
LABEL_10:
          *uint64_t v12 = v5;
          v12[1] = v6;
        }
        BOOL v2 = v4 + 2;
        v3 += 8;
      }
      while (v4 + 2 != a2);
    }
  }
  return result;
}

float *std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(float *result, float *a2)
{
  if (result != a2)
  {
    while (result + 2 != a2)
    {
      float v3 = result[2];
      float v4 = result[3];
      float v5 = *result;
      float v6 = result[1];
      BOOL v2 = result + 2;
      result += 2;
      float v7 = sqrtf((float)(v4 * v4) + (float)(v3 * v3));
      if (v7 > sqrtf((float)(v6 * v6) + (float)(v5 * v5)))
      {
        do
        {
          float v8 = v2;
          uint64_t v9 = *((void *)v2 - 1);
          v2 -= 2;
          *(void *)float v8 = v9;
        }
        while (v7 > sqrtf((float)(*(v8 - 3) * *(v8 - 3)) + (float)(*(v8 - 4) * *(v8 - 4))));
        float *v2 = v3;
        v2[1] = v4;
      }
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(float *a1, float *a2, float *a3)
{
  float v3 = *a2;
  float v4 = a2[1];
  float v5 = sqrtf((float)(v4 * v4) + (float)(v3 * v3));
  float v7 = *a1;
  float v6 = a1[1];
  float v8 = sqrtf((float)(v6 * v6) + (float)(v7 * v7));
  float v9 = sqrtf((float)(a3[1] * a3[1]) + (float)(*a3 * *a3));
  if (v5 > v8)
  {
    if (v9 > v5)
    {
      *(void *)a1 = *(void *)a3;
      *a3 = v7;
      a3[1] = v6;
      return 1;
    }
    *(void *)a1 = *(void *)a2;
    *a2 = v7;
    a2[1] = v6;
    if (sqrtf((float)(a3[1] * a3[1]) + (float)(*a3 * *a3)) <= v8) {
      return 1;
    }
    *(void *)a2 = *(void *)a3;
    *a3 = v7;
    a3[1] = v6;
    return 2;
  }
  if (v9 > v5)
  {
    *(void *)a2 = *(void *)a3;
    *a3 = v3;
    a3[1] = v4;
    float v10 = *a1;
    float v11 = a1[1];
    if (sqrtf((float)(a2[1] * a2[1]) + (float)(*a2 * *a2)) <= sqrtf((float)(v11 * v11) + (float)(v10 * v10))) {
      return 1;
    }
    *(void *)a1 = *(void *)a2;
    *a2 = v10;
    a2[1] = v11;
    return 2;
  }
  return 0;
}

float *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,MTPoint *,MTPointVelocityGreaterThan &>(float *a1, unint64_t a2)
{
  float v2 = *a1;
  float v3 = a1[1];
  float v4 = sqrtf((float)(v3 * v3) + (float)(*a1 * *a1));
  if (v4 <= sqrtf((float)(*(float *)(a2 - 4) * *(float *)(a2 - 4)) + (float)(*(float *)(a2 - 8) * *(float *)(a2 - 8))))
  {
    float v8 = a1 + 2;
    do
    {
      float v5 = v8;
      if ((unint64_t)v8 >= a2) {
        break;
      }
      float v9 = sqrtf((float)(v8[1] * v8[1]) + (float)(*v8 * *v8));
      v8 += 2;
    }
    while (v4 <= v9);
  }
  else
  {
    float v5 = a1;
    do
    {
      float v6 = v5[2];
      float v7 = v5[3];
      v5 += 2;
    }
    while (v4 <= sqrtf((float)(v7 * v7) + (float)(v6 * v6)));
  }
  if ((unint64_t)v5 < a2)
  {
    do
    {
      float v10 = *(float *)(a2 - 8);
      float v11 = *(float *)(a2 - 4);
      a2 -= 8;
    }
    while (v4 > sqrtf((float)(v11 * v11) + (float)(v10 * v10)));
  }
  if ((unint64_t)v5 < a2)
  {
    float v12 = *v5;
    do
    {
      int v13 = *((_DWORD *)v5 + 1);
      *(void *)float v5 = *(void *)a2;
      *(float *)a2 = v12;
      *(_DWORD *)(a2 + 4) = v13;
      do
      {
        float v12 = v5[2];
        float v14 = v5[3];
        v5 += 2;
      }
      while (v4 <= sqrtf((float)(v14 * v14) + (float)(v12 * v12)));
      do
      {
        float v15 = *(float *)(a2 - 8);
        float v16 = *(float *)(a2 - 4);
        a2 -= 8;
      }
      while (v4 > sqrtf((float)(v16 * v16) + (float)(v15 * v15)));
    }
    while ((unint64_t)v5 < a2);
  }
  if (v5 - 2 != a1) {
    *(void *)a1 = *((void *)v5 - 1);
  }
  *(v5 - 2) = v2;
  *(v5 - MTHandMotion::clearHandMotion(this, 1) = v3;
  return v5;
}

float *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,MTPoint *,MTPointVelocityGreaterThan &>(float *a1, unint64_t a2)
{
  uint64_t v2 = 0;
  float v3 = *a1;
  float v4 = a1[1];
  float v5 = sqrtf((float)(v4 * v4) + (float)(*a1 * *a1));
  do
  {
    float v6 = a1[v2 + 2];
    float v7 = sqrtf((float)(a1[v2 + 3] * a1[v2 + 3]) + (float)(v6 * v6));
    v2 += 2;
  }
  while (v7 > v5);
  float v8 = &a1[v2];
  if (v2 == 2)
  {
    do
    {
      if ((unint64_t)v8 >= a2) {
        break;
      }
      float v11 = *(float *)(a2 - 8);
      float v12 = *(float *)(a2 - 4);
      a2 -= 8;
    }
    while (sqrtf((float)(v12 * v12) + (float)(v11 * v11)) <= v5);
  }
  else
  {
    do
    {
      float v9 = *(float *)(a2 - 8);
      float v10 = *(float *)(a2 - 4);
      a2 -= 8;
    }
    while (sqrtf((float)(v10 * v10) + (float)(v9 * v9)) <= v5);
  }
  if ((unint64_t)v8 >= a2)
  {
    float v14 = &a1[v2];
  }
  else
  {
    unint64_t v13 = a2;
    float v14 = v8;
    do
    {
      int v15 = *((_DWORD *)v14 + 1);
      *(void *)float v14 = *(void *)v13;
      *(float *)unint64_t v13 = v6;
      *(_DWORD *)(v13 + 4) = v15;
      do
      {
        float v6 = v14[2];
        float v16 = v14[3];
        v14 += 2;
      }
      while (sqrtf((float)(v16 * v16) + (float)(v6 * v6)) > v5);
      do
      {
        float v17 = *(float *)(v13 - 8);
        float v18 = *(float *)(v13 - 4);
        v13 -= 8;
      }
      while (sqrtf((float)(v18 * v18) + (float)(v17 * v17)) <= v5);
    }
    while ((unint64_t)v14 < v13);
  }
  if (v14 - 2 != a1) {
    *(void *)a1 = *((void *)v14 - 1);
  }
  *(v14 - 2) = v3;
  *(v14 - MTHandMotion::clearHandMotion(this, 1) = v4;
  return v14 - 2;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(float *a1, float *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      float v6 = *a1;
      float v7 = a1[1];
      if (sqrtf((float)(*(a2 - 1) * *(a2 - 1)) + (float)(*(a2 - 2) * *(a2 - 2))) > sqrtf((float)(v7 * v7)+ (float)(v6 * v6)))
      {
        *(void *)a1 = *((void *)a2 - 1);
        *(a2 - 2) = v6;
        *(a2 - MTHandMotion::clearHandMotion(this, 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(a1, a1 + 2, a1 + 4, (uint64_t)(a2 - 2));
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(a1, a1 + 2, a1 + 4, a1 + 6, (uint64_t)(a2 - 2));
      return 1;
    default:
      float v8 = a1 + 4;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(a1, a1 + 2, a1 + 4);
      float v9 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    float v12 = *v9;
    float v13 = v9[1];
    float v14 = sqrtf((float)(v13 * v13) + (float)(v12 * v12));
    if (v14 > sqrtf((float)(v8[1] * v8[1]) + (float)(*v8 * *v8)))
    {
      uint64_t v15 = v10;
      while (1)
      {
        *(void *)((char *)a1 + v15 + 24) = *(void *)((char *)a1 + v15 + 16);
        if (v15 == -16) {
          break;
        }
        float v16 = sqrtf((float)(*(float *)((char *)a1 + v15 + 12) * *(float *)((char *)a1 + v15 + 12))+ (float)(*(float *)((char *)a1 + v15 + 8) * *(float *)((char *)a1 + v15 + 8)));
        v15 -= 8;
        if (v14 <= v16)
        {
          float v17 = (float *)((char *)a1 + v15 + 24);
          goto LABEL_12;
        }
      }
      float v17 = a1;
LABEL_12:
      *float v17 = v12;
      v17[1] = v13;
      if (++v11 == 8) {
        return v9 + 2 == a2;
      }
    }
    float v8 = v9;
    v10 += 8;
    v9 += 2;
    if (v9 == a2) {
      return 1;
    }
  }
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(float *a1, float *a2, float *a3, uint64_t a4)
{
  uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(a1, a2, a3);
  float v9 = *a3;
  float v10 = a3[1];
  if (sqrtf((float)(*(float *)(a4 + 4) * *(float *)(a4 + 4)) + (float)(*(float *)a4 * *(float *)a4)) > sqrtf((float)(v10 * v10) + (float)(v9 * v9)))
  {
    *(void *)a3 = *(void *)a4;
    *(float *)a4 = v9;
    *(float *)(a4 + 4) = v10;
    float v11 = *a2;
    float v12 = a2[1];
    if (sqrtf((float)(a3[1] * a3[1]) + (float)(*a3 * *a3)) > sqrtf((float)(v12 * v12) + (float)(v11 * v11)))
    {
      *(void *)a2 = *(void *)a3;
      *a3 = v11;
      a3[1] = v12;
      float v13 = *a1;
      float v14 = a1[1];
      if (sqrtf((float)(a2[1] * a2[1]) + (float)(*a2 * *a2)) > sqrtf((float)(v14 * v14) + (float)(v13 * v13)))
      {
        *(void *)a1 = *(void *)a2;
        *a2 = v13;
        a2[1] = v14;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(float *a1, float *a2, float *a3, float *a4, uint64_t a5)
{
  uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(a1, a2, a3, (uint64_t)a4);
  float v11 = *a4;
  float v12 = a4[1];
  if (sqrtf((float)(*(float *)(a5 + 4) * *(float *)(a5 + 4)) + (float)(*(float *)a5 * *(float *)a5)) > sqrtf((float)(v12 * v12) + (float)(v11 * v11)))
  {
    *(void *)a4 = *(void *)a5;
    *(float *)a5 = v11;
    *(float *)(a5 + 4) = v12;
    float v13 = *a3;
    float v14 = a3[1];
    if (sqrtf((float)(a4[1] * a4[1]) + (float)(*a4 * *a4)) > sqrtf((float)(v14 * v14) + (float)(v13 * v13)))
    {
      *(void *)a3 = *(void *)a4;
      *a4 = v13;
      a4[1] = v14;
      float v15 = *a2;
      float v16 = a2[1];
      if (sqrtf((float)(a3[1] * a3[1]) + (float)(*a3 * *a3)) > sqrtf((float)(v16 * v16) + (float)(v15 * v15)))
      {
        *(void *)a2 = *(void *)a3;
        *a3 = v15;
        a3[1] = v16;
        float v17 = *a1;
        float v18 = a1[1];
        if (sqrtf((float)(a2[1] * a2[1]) + (float)(*a2 * *a2)) > sqrtf((float)(v18 * v18) + (float)(v17 * v17)))
        {
          *(void *)a1 = *(void *)a2;
          *a2 = v17;
          a2[1] = v18;
        }
      }
    }
  }
  return result;
}

float *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *,MTPoint *>(float *a1, float *a2, float *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = ((char *)a2 - (char *)a1) >> 3;
    if ((char *)a2 - (char *)a1 >= 9)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      float v12 = &a1[2 * v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>((uint64_t)a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }
      while (v11);
    }
    float v13 = a2;
    if (a2 != a3)
    {
      float v14 = a2;
      do
      {
        float v15 = *v14;
        float v16 = v14[1];
        if (sqrtf((float)(v16 * v16) + (float)(v15 * v15)) > sqrtf((float)(a1[1] * a1[1]) + (float)(*a1 * *a1)))
        {
          *(void *)float v14 = *(void *)a1;
          *a1 = v15;
          a1[1] = v16;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>((uint64_t)a1, a4, v9, a1);
        }
        v14 += 2;
      }
      while (v14 != a3);
      float v13 = a3;
    }
    if (v8 >= 9)
    {
      uint64_t v17 = (unint64_t)v8 >> 3;
      float v18 = a2 - 2;
      do
      {
        float v20 = *a1;
        int v19 = *((_DWORD *)a1 + 1);
        BOOL v21 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(a1, a4, v17);
        if (v18 == v21)
        {
          *BOOL v21 = v20;
          *((_DWORD *)v21 + MTHandMotion::clearHandMotion(this, 1) = v19;
        }
        else
        {
          *(void *)BOOL v21 = *(void *)v18;
          float *v18 = v20;
          *((_DWORD *)v18 + MTHandMotion::clearHandMotion(this, 1) = v19;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>((uint64_t)a1, (uint64_t)(v21 + 2), a4, ((char *)(v21 + 2) - (char *)a1) >> 3);
        }
        v18 -= 2;
      }
      while (v17-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(uint64_t result, uint64_t a2, uint64_t a3, float *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v6 = v4 >> 2;
      uint64_t v7 = (v4 >> 2) + 1;
      uint64_t v8 = (float *)(result + 8 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 < a3
        && sqrtf((float)(v8[1] * v8[1]) + (float)(*v8 * *v8)) > sqrtf((float)(v8[3] * v8[3]) + (float)(v8[2] * v8[2])))
      {
        v8 += 2;
        uint64_t v7 = v9;
      }
      float v10 = *a4;
      float v11 = a4[1];
      float v12 = sqrtf((float)(v11 * v11) + (float)(v10 * v10));
      if (sqrtf((float)(v8[1] * v8[1]) + (float)(*v8 * *v8)) <= v12)
      {
        do
        {
          float v13 = v8;
          *(void *)a4 = *(void *)v8;
          if (v5 < v7) {
            break;
          }
          uint64_t v14 = 2 * v7;
          uint64_t v7 = (2 * v7) | 1;
          uint64_t v8 = (float *)(result + 8 * v7);
          uint64_t v15 = v14 + 2;
          if (v15 < a3
            && sqrtf((float)(v8[1] * v8[1]) + (float)(*v8 * *v8)) > sqrtf((float)(v8[3] * v8[3]) + (float)(v8[2] * v8[2])))
          {
            v8 += 2;
            uint64_t v7 = v15;
          }
          a4 = v13;
        }
        while (sqrtf((float)(v8[1] * v8[1]) + (float)(*v8 * *v8)) <= v12);
        *float v13 = v10;
        v13[1] = v11;
      }
    }
  }
  return result;
}

float *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(float *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3 - 2;
  if (a3 < 2) {
    uint64_t v4 = a3 - 1;
  }
  uint64_t v5 = v4 >> 1;
  do
  {
    uint64_t v6 = result;
    result += 2 * v3 + 2;
    uint64_t v7 = 2 * v3;
    uint64_t v3 = (2 * v3) | 1;
    uint64_t v8 = v7 + 2;
    if (v8 < a3
      && sqrtf((float)(result[1] * result[1]) + (float)(*result * *result)) > sqrtf((float)(result[3] * result[3])+ (float)(result[2] * result[2])))
    {
      result += 2;
      uint64_t v3 = v8;
    }
    *(void *)uint64_t v6 = *(void *)result;
  }
  while (v3 <= v5);
  return result;
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,MTPointVelocityGreaterThan &,MTPoint *>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    unint64_t v4 = (unint64_t)(a4 - 2) >> 1;
    uint64_t v5 = (float *)(result + 8 * v4);
    float v7 = *(float *)(a2 - 8);
    float v8 = *(float *)(a2 - 4);
    uint64_t v6 = (float *)(a2 - 8);
    float v9 = sqrtf((float)(v8 * v8) + (float)(v7 * v7));
    if (sqrtf((float)(v5[1] * v5[1]) + (float)(*v5 * *v5)) > v9)
    {
      do
      {
        float v10 = v5;
        *(void *)uint64_t v6 = *(void *)v5;
        if (!v4) {
          break;
        }
        unint64_t v4 = (v4 - 1) >> 1;
        uint64_t v5 = (float *)(result + 8 * v4);
        uint64_t v6 = v10;
      }
      while (sqrtf((float)(v5[1] * v5[1]) + (float)(*v5 * *v5)) > v9);
      *float v10 = v7;
      v10[1] = v8;
    }
  }
  return result;
}

void *std::vector<MTPoint>::__init_with_size[abi:ne180100]<MTPoint*,MTPoint*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<MTPoint>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_24070EA8C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<MTPoint>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTPoint>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

char *std::vector<MTPoint>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(char **)(a2 + 8);
  uint64_t v6 = (char *)*a1;
  uint64_t v7 = v5;
  if (*a1 != __src)
  {
    size_t v8 = __src;
    uint64_t v7 = *(char **)(a2 + 8);
    do
    {
      uint64_t v9 = *((void *)v8 - 1);
      v8 -= 8;
      *((void *)v7 - MTHandMotion::clearHandMotion(this, 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  float v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    uint64_t v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  float v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  uint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void *std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_24070EC14(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<float>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

uint64_t MTParserPath::MTParserPath(uint64_t a1, int a2, int a3, uint64_t a4)
{
  *(void *)a1 = &unk_26F4D93E8;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = a3;
  *(void *)(a1 + 16) = a4;
  MTForceFilter::MTForceFilter((MTForceFilter *)(a1 + 296));
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  MTForceFilter::clear(v5);
  *(void *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 588) = 0;
  *(void *)(a1 + 592) = 0;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 560) = 0u;
  *(void *)(a1 + 574) = 0;
  *(_DWORD *)(a1 + 583) = 0;
  *(int32x2_t *)(a1 + 480) = vdup_n_s32(0x7FC00000u);
  return a1;
}

void sub_24070ED44(_Unwind_Exception *a1)
{
  MTForceFilter::~MTForceFilter(v1);
  _Unwind_Resume(a1);
}

int32x2_t MTParserPath::clear(MTParserPath *this)
{
  *(_OWORD *)((char *)this + 24) = 0u;
  uint64_t v1 = (char *)this + 24;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  MTForceFilter::clear((MTParserPath *)((char *)this + 296));
  *((void *)v1 + 32) = 0;
  *((_DWORD *)v1 + 66) = 0;
  *((_DWORD *)v1 + 14MTHandMotion::clearHandMotion(this, 1) = 0;
  *((void *)v1 + 7MTHandMotion::clearHandMotion(this, 1) = 0;
  *(_OWORD *)(v1 + 328) = 0u;
  *(_OWORD *)(v1 + 344) = 0u;
  *(_OWORD *)(v1 + 360) = 0u;
  *(_OWORD *)(v1 + 376) = 0u;
  *(_OWORD *)(v1 + 392) = 0u;
  *(_OWORD *)(v1 + 408) = 0u;
  *(_OWORD *)(v1 + 424) = 0u;
  *(_OWORD *)(v1 + 440) = 0u;
  *(_OWORD *)(v1 + 488) = 0u;
  *(_OWORD *)(v1 + 504) = 0u;
  *(_OWORD *)(v1 + 520) = 0u;
  *(_OWORD *)(v1 + 536) = 0u;
  *(void *)(v1 + 550) = 0;
  *(_DWORD *)(v1 + 559) = 0;
  int32x2_t result = vdup_n_s32(0x7FC00000u);
  *((int32x2_t *)v1 + 57) = result;
  return result;
}

void MTParserPath::~MTParserPath(MTParserPath *this)
{
  *(void *)this = &unk_26F4D93E8;
  MTForceFilter::~MTForceFilter((MTParserPath *)((char *)this + 296));
}

{
  *(void *)this = &unk_26F4D93E8;
  MTForceFilter::~MTForceFilter((MTParserPath *)((char *)this + 296));
}

{
  uint64_t vars8;

  *(void *)this = &unk_26F4D93E8;
  MTForceFilter::~MTForceFilter((MTParserPath *)((char *)this + 296));

  JUMPOUT(0x2455F6CE0);
}

double MTParserPath::clearTimestamps(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  return result;
}

uint64_t MTParserPath::updateCurPrevContactsWith(MTParserPath *this, long long *a2, uint64_t a3, float *a4, double a5)
{
  *(_OWORD *)((char *)this + 152) = *(_OWORD *)((char *)this + 56);
  *(_OWORD *)((char *)this + 168) = *(_OWORD *)((char *)this + 72);
  *(_OWORD *)((char *)this + 184) = *(_OWORD *)((char *)this + 88);
  *(_OWORD *)((char *)this + 200) = *(_OWORD *)((char *)this + 104);
  *(_OWORD *)((char *)this + 120) = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + 136) = *(_OWORD *)((char *)this + 40);
  long long v9 = *a2;
  *(_OWORD *)((char *)this + 40) = a2[1];
  *(_OWORD *)((char *)this + 24) = v9;
  long long v10 = a2[4];
  long long v11 = a2[5];
  long long v12 = a2[3];
  *(_OWORD *)((char *)this + 56) = a2[2];
  *(_OWORD *)((char *)this + 104) = v11;
  *(_OWORD *)((char *)this + 88) = v10;
  *(_OWORD *)((char *)this + 72) = v12;
  if ((*((_DWORD *)this + 2) - 1000) <= 0xBB7)
  {
    if (!*((_DWORD *)this + 35))
    {
      uint64_t v13 = *(void *)((char *)this + 92);
      *(void *)((char *)this + 388) = v13;
      *((void *)this + 47) = v13;
    }
    int v14 = *((_DWORD *)this + 12);
    if ((v14 - 2) > 3)
    {
      if (v14 != 13 && *((unsigned char *)this + 586)) {
        *((_DWORD *)this + 12) = 14;
      }
    }
    else
    {
      *((unsigned char *)this + 586) = 0;
    }
  }
  if ((*((_DWORD *)this + 11) - 1) <= 2) {
    *(void *)((char *)this + 356) = *(void *)((char *)this + 92);
  }
  MTParserPath::updatePathStageTimestamps((uint64_t)this, a5);
  MTParserPath::updateTotalDiscountedDistance((uint64_t)this, v15);

  return MTParserPath::updateZonesAndEdges((uint64_t)this, a3, a4, a5);
}

uint64_t MTParserPath::rejectRestingThumbFromRestingHand(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 48);
  if ((v1 - 2) > 3)
  {
    if (v1 != 13 && *(unsigned char *)(this + 586) != 0) {
      *(_DWORD *)(this + 48) = 14;
    }
  }
  else
  {
    *(unsigned char *)(this + 586) = 0;
  }
  return this;
}

uint64_t MTParserPath::updatePathStageTimestamps(uint64_t this, double a2)
{
  int v2 = *(_DWORD *)(this + 44);
  if (v2 == 1)
  {
    *(double *)(this + 216) = a2;
LABEL_14:
    *(double *)(this + 224) = a2;
    goto LABEL_15;
  }
  int v3 = *(_DWORD *)(this + 140);
  if (v3 == 7 || v3 == 0) {
    *(double *)(this + 216) = a2;
  }
  if (v3) {
    BOOL v5 = v2 < v3;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    goto LABEL_14;
  }
LABEL_15:
  int v6 = *(_DWORD *)(this + 140);
  if (v2 == 2)
  {
    if (v6 == 2) {
      return this;
    }
    uint64_t v7 = (double *)(this + 240);
    goto LABEL_30;
  }
  if (v6 == 2) {
    *(double *)(this + 248) = a2;
  }
  unsigned int v8 = v6 - 6;
  if ((v2 - 3) <= 2 && v8 <= 0xFFFFFFFC) {
    *(double *)(this + 232) = a2;
  }
  if (v2 >= 5)
  {
    if (*(double *)(this + 232) >= *(double *)(this + 256)) {
      *(double *)(this + 256) = a2;
    }
    if (v2 == 7)
    {
      uint64_t v7 = (double *)(this + 264);
LABEL_30:
      *uint64_t v7 = a2;
    }
  }
  return this;
}

uint64_t MTParserPath::updateTotalDiscountedDistance(uint64_t this, double a2)
{
  if ((*(_DWORD *)(this + 8) - 1000) <= 0xBB7)
  {
    if ((*(_DWORD *)(this + 140) - 3) > 1 || (*(_DWORD *)(this + 44) - 3) > 1)
    {
      *(_DWORD *)(this + 396) = 0;
    }
    else
    {
      float32x2_t v2 = vsub_f32(*(float32x2_t *)(this + 92), *(float32x2_t *)(this + 188));
      float v3 = sqrtf(vaddv_f32(vmul_f32(v2, v2)));
      if (v3 > 0.14) {
        *(float *)(this + 396) = (float)(v3 + -0.14) + *(float *)(this + 396);
      }
    }
  }
  return this;
}

uint64_t MTParserPath::updateZonesAndEdges(uint64_t a1, uint64_t a2, float *a3, double a4)
{
  float v8 = MTSurfaceDimensions::convertSurfaceFractionToMillimeters(a2, 1.0);
  float v10 = v9;
  float v11 = MTSurfaceDimensions::convertSurfaceFractionToMillimeters(a2, *(float *)(a1 + 56));
  float v13 = v12;
  uint64_t result = MTParserPath::computeZonesAndEdgesMask(v11, v12, v8, v10, v14, a3);
  *(_DWORD *)(a1 + 280) = result;
  if (*(double *)(a1 + 256) == a4) {
    *(_DWORD *)(a1 + 288) = result;
  }
  int v16 = *(_DWORD *)(a1 + 44);
  if ((v16 - 1) <= 2)
  {
    if (v16 == 1 || (*(_DWORD *)(a1 + 140) - 1) >= 6)
    {
      *(_DWORD *)(a1 + 284) = result;
    }
    else
    {
      *(_DWORD *)(a1 + 284) |= result;
      float v17 = v11 + (float)(v11 - MTSurfaceDimensions::convertPixelsToMillimeters(a2, *(float *)(a1 + 152))) * -2.5;
      float v19 = v13 + (float)(v13 - v18) * -2.5;
      uint64_t result = MTParserPath::computeZonesAndEdgesMask(v17, v19, v8, v10, v20, a3);
      *(_DWORD *)(a1 + 284) |= result;
    }
  }
  return result;
}

uint64_t MTParserPath::computeZonesAndEdgesMask(float a1, float a2, float a3, float a4, uint64_t a5, float *a6)
{
  double v8 = a6[1];
  float v35 = a6[2];
  float v36 = a6[3];
  float v38 = a6[4];
  float v39 = a6[7];
  float v37 = a6[5];
  float v40 = a6[6];
  float v34 = a4 - a2;
  long double v9 = (float)(a4 - a2);
  long double v10 = a2;
  float v11 = a3 - a1;
  long double v12 = (float)(a3 - a1);
  double v33 = hypot(a2, a1);
  double v13 = hypot(v10, v12);
  double v14 = hypot(v9, a1);
  double v15 = hypot(v9, v12);
  BOOL v16 = v33 > v8;
  BOOL v17 = v13 > v8;
  if (a2 > v35)
  {
    BOOL v16 = 1;
    BOOL v17 = 1;
  }
  BOOL v18 = v14 > v8;
  BOOL v19 = v15 > v8;
  if (v34 > v35)
  {
    BOOL v18 = 1;
    BOOL v19 = 1;
  }
  if (v11 > v36)
  {
    BOOL v17 = 1;
    BOOL v19 = 1;
  }
  if (a1 > v36) {
    BOOL v16 = 1;
  }
  unsigned int v20 = !v16;
  if (a1 > v36) {
    BOOL v18 = 1;
  }
  if (!v17) {
    v20 |= 2u;
  }
  if (!v18) {
    v20 |= 4u;
  }
  if (!v19) {
    v20 |= 8u;
  }
  if (a1 < v37) {
    v20 |= 0x10u;
  }
  if (v11 < v37) {
    v20 |= 0x20u;
  }
  if (a2 < v38) {
    v20 |= 0x40u;
  }
  if (v34 < v38) {
    v20 |= 0x80u;
  }
  if (a1 < v39) {
    v20 |= 0x1000u;
  }
  if (v11 < v39) {
    v20 |= 0x2000u;
  }
  if (a2 < v40) {
    v20 |= 0x4000u;
  }
  if (v34 < v40) {
    v20 |= 0x8000u;
  }
  if (v33 < v8 && (v20 & 0x50) != 0) {
    v20 |= 0x100u;
  }
  if (v13 < v8 && (v20 & 0x60) != 0) {
    v20 |= 0x200u;
  }
  if (v14 < v8 && (v20 & 0x90) != 0) {
    v20 |= 0x400u;
  }
  if (v15 < v8 && (v20 & 0xA0) != 0) {
    v20 |= 0x800u;
  }
  float v25 = a4 / 3.0;
  BOOL v26 = v11 <= (float)(a3 / 3.0) || a1 <= (float)(a3 / 3.0);
  int v27 = v20 | 0x20000;
  if (v26) {
    int v27 = v20;
  }
  if (v34 > v25 && a2 > v25) {
    unsigned int v20 = v27;
  }
  float v29 = a4 * 0.25;
  BOOL v30 = v11 <= (float)(a3 * 0.25) || a1 <= (float)(a3 * 0.25);
  unsigned int v31 = v20 | 0x40000;
  if (v30) {
    unsigned int v31 = v20;
  }
  if (a2 <= v29) {
    unsigned int v31 = v20;
  }
  if (v34 > v29) {
    return v31;
  }
  else {
    return v20;
  }
}

float MTParserPath::getAverageVelocity_mm_s(MTParserPath *this)
{
  float v1 = *((float *)this + 29) * *((float *)this + 29);
  float v2 = 0.5;
  float v3 = v1 * 0.5;
  if (v1 > 1.0) {
    float v3 = 0.5;
  }
  float v4 = *((float *)this + 53) * *((float *)this + 53);
  if (v4 <= 1.0) {
    float v2 = v4 * 0.5;
  }
  return (float)(*((float *)this + 49) * v2) + (float)(v3 * *((float *)this + 25));
}

float MTParserPath::getDisplacement_mm(MTParserPath *this)
{
  return *((float *)this + 23) - *((float *)this + 94);
}

float MTParserPath::updateHysteresisDragCenter_mm(float *a1, uint64_t a2)
{
  float v2 = a1[89];
  float v3 = a1[90];
  float v4 = a1[23];
  float v5 = *(float *)(a2 + 56);
  if ((float)(v4 - v2) <= v5)
  {
    if ((float)(v4 - v2) >= (float)-v5)
    {
      float v9 = a1[89];
      goto LABEL_10;
    }
    float v6 = (float)(int)(float)(v4 + v5);
    float v7 = -1.0;
  }
  else
  {
    float v6 = (float)(int)(float)(v4 - v5);
    float v7 = 1.0;
  }
  float v8 = v6 + v7;
  if (a1[47] == v6) {
    float v9 = v8;
  }
  else {
    float v9 = v6;
  }
  a1[89] = v9;
  float v5 = *(float *)(a2 + 56);
LABEL_10:
  float v10 = a1[24];
  if ((float)(v10 - v3) <= v5)
  {
    float v13 = v3;
    if ((float)(v10 - v3) >= (float)-v5) {
      return sqrtf((float)((float)(v3 - v13) * (float)(v3 - v13)) + (float)((float)(v2 - v9) * (float)(v2 - v9)));
    }
    float v11 = (float)(int)(float)(v10 + v5);
    float v12 = -1.0;
  }
  else
  {
    float v11 = (float)(int)(float)(v10 - v5);
    float v12 = 1.0;
  }
  float v13 = v11 + v12;
  if (a1[48] != v11) {
    float v13 = v11;
  }
  a1[90] = v13;
  return sqrtf((float)((float)(v3 - v13) * (float)(v3 - v13)) + (float)((float)(v2 - v9) * (float)(v2 - v9)));
}

uint64_t MTParserPath::applyMinimumIncrementHysteresis(MTParserPath *this, float a2, float *a3, float a4, float a5)
{
  float v5 = a2 - *a3;
  if (v5 <= a5)
  {
    if (v5 >= (float)-a5) {
      return 0;
    }
    float v6 = (float)(int)(float)(a2 + a5);
    float v7 = -1.0;
  }
  else
  {
    float v6 = (float)(int)(float)(a2 - a5);
    float v7 = 1.0;
  }
  float v8 = v6 + v7;
  if (v6 == a4) {
    float v6 = v8;
  }
  *a3 = v6;
  return 1;
}

BOOL MTParserPath::wasFingerOrRestingContact(MTParserPath *this)
{
  return (*((_DWORD *)this + 36) - 1) < 5;
}

float MTParserPath::getQuantizedMinorRadius_mm(MTParserPath *this)
{
  uint64_t v1 = 548;
  if (*((float *)this + 141) == 0.0) {
    uint64_t v1 = 88;
  }
  return *(float *)((char *)this + v1);
}

float MTParserPath::getQuantizedMajorRadius_mm(MTParserPath *this)
{
  uint64_t v1 = 552;
  if (*((float *)this + 141) == 0.0) {
    uint64_t v1 = 84;
  }
  return *(float *)((char *)this + v1);
}

float MTParserPath::getQuantizedRadiusAccuracy_mm(MTParserPath *this)
{
  return *((float *)this + 141);
}

BOOL MTParserPath::wasFingerContact(MTParserPath *this)
{
  return ((*((_DWORD *)this + 2) - 1000) > 0xBB7 || !*((unsigned char *)this + 582))
      && (*((_DWORD *)this + 36) - 1) < 5;
}

BOOL MTParserPath::isFingerOrRestingContact(MTParserPath *this)
{
  uint64_t v1 = 48;
  if (*((_DWORD *)this + 11) == 7) {
    uint64_t v1 = 144;
  }
  return (*(_DWORD *)((char *)this + v1) - 1) < 5;
}

BOOL MTParserPath::isThumbAlongEdgeContact(MTParserPath *this)
{
  uint64_t v1 = 48;
  if (*((_DWORD *)this + 11) == 7) {
    uint64_t v1 = 144;
  }
  return *(_DWORD *)((char *)this + v1) == 14;
}

uint64_t MTParserPath::isStylusContact(MTParserPath *this)
{
  return (*((unsigned __int16 *)this + 54) >> 12) & 1;
}

uint64_t MTParserPath::wasStylusContact(MTParserPath *this)
{
  return (*((unsigned __int16 *)this + 102) >> 12) & 1;
}

BOOL MTParserPath::isThumbContact(MTParserPath *this)
{
  uint64_t v1 = 48;
  if (*((_DWORD *)this + 11) == 7) {
    uint64_t v1 = 144;
  }
  return *(_DWORD *)((char *)this + v1) == 1;
}

BOOL MTParserPath::isFingerContact(MTParserPath *this)
{
  if ((*((_DWORD *)this + 2) - 1000) <= 0xBB7 && *((unsigned char *)this + 581)) {
    return 0;
  }
  uint64_t v2 = 48;
  if (*((_DWORD *)this + 11) == 7) {
    uint64_t v2 = 144;
  }
  return (*(_DWORD *)((char *)this + v2) - 1) < 5;
}

BOOL MTParserPath::isPalmContact(MTParserPath *this)
{
  uint64_t v1 = 48;
  if (*((_DWORD *)this + 11) == 7) {
    uint64_t v1 = 144;
  }
  return (*(_DWORD *)((char *)this + v1) - 6) < 6;
}

BOOL MTParserPath::isPalmHeelContact(MTParserPath *this)
{
  uint64_t v1 = 48;
  if (*((_DWORD *)this + 11) == 7) {
    uint64_t v1 = 144;
  }
  return (*(_DWORD *)((unsigned char *)this + v1) & 0xFFFFFFFE) == 6;
}

BOOL MTParserPath::isEdgeContact(MTParserPath *this)
{
  uint64_t v1 = 48;
  if (*((_DWORD *)this + 11) == 7) {
    uint64_t v1 = 144;
  }
  return (*(_DWORD *)((char *)this + v1) - 12) < 3;
}

BOOL MTParserPath::isEdgeContactTyping(MTParserPath *this)
{
  uint64_t v1 = 48;
  if (*((_DWORD *)this + 11) == 7) {
    uint64_t v1 = 144;
  }
  return *(_DWORD *)((char *)this + v1) == 13;
}

BOOL MTParserPath::isBottomOrTopContact(MTParserPath *this)
{
  return (*((unsigned char *)this + 281) & 0xC0) != 0;
}

BOOL MTParserPath::isSideContact(MTParserPath *this)
{
  return (*((unsigned char *)this + 281) & 0x30) != 0;
}

uint64_t MTParserPath::isBottomContact(MTParserPath *this)
{
  return (*((unsigned __int8 *)this + 281) >> 6) & 1;
}

BOOL MTParserPath::isUnidentifiedContact(MTParserPath *this)
{
  uint64_t v1 = 48;
  if (*((_DWORD *)this + 11) == 7) {
    uint64_t v1 = 144;
  }
  return *(_DWORD *)((char *)this + v1) == 0;
}

BOOL MTParserPath::isValidForceSource(MTParserPath *this)
{
  return (*((_DWORD *)this + 11) - 1) < 6;
}

uint64_t MTParserPath::isValidEdgeStraddleClick(MTParserPath *this)
{
  unsigned int v1 = *((_DWORD *)this + 70);
  BOOL v2 = (v1 & 0x3000) == 0;
  if ((v1 & 0xC000) != 0) {
    BOOL v2 = 1;
  }
  uint64_t v3 = 48;
  if (*((_DWORD *)this + 11) == 7) {
    uint64_t v3 = 144;
  }
  int v4 = *(_DWORD *)((char *)this + v3);
  if (v4 == 13)
  {
    int v5 = (v1 >> 14) & 1;
    return v2 & v5;
  }
  if ((v4 - 12) <= 2)
  {
    int v5 = 1;
    return v2 & v5;
  }
  return 0;
}

uint64_t MTParserPath::isValidClickSource(MTParserPath *this)
{
  int v1 = *((_DWORD *)this + 11);
  uint64_t v2 = 48;
  if (v1 == 7) {
    uint64_t v2 = 144;
  }
  int v3 = *(_DWORD *)((char *)this + v2);
  if ((v3 - 1) < 5 || v3 == 14) {
    return (v1 - 3) < 2;
  }
  uint64_t result = MTParserPath::isValidEdgeStraddleClick(this);
  if (result) {
    return (v1 - 3) < 2;
  }
  return result;
}

BOOL MTParserPath::fingerLiftoffNearEdge(float32x2_t *this, const MTSurfaceDimensions *a2, double a3)
{
  if ((this[5].i32[1] - 3) < 2
    || (this[17].i32[1] - 3) > 1
    || (this[1].i32[0] - 1000) <= 0xBB7 && this[72].i8[6]
    || (this[18].i32[0] - 1) > 4)
  {
    return 0;
  }
  float v3 = (float)(this[67].f32[0] * 3.0) * a3 + 1.2;
  float32x2_t v4 = vcvt_f32_f64(vmlaq_n_f64(vcvtq_f64_f32(this[19]), vcvtq_f64_f32(this[20]), a3));
  return MTSurfaceDimensions::minDistanceToEdge_mm((float *)a2, 1, 1, v4.f32[0], v4.f32[1]) < v3;
}

uint64_t MTParserPath::flushLiftoffAt(MTParserPath *this, double a2)
{
  *(_OWORD *)((char *)this + 152) = *(_OWORD *)((char *)this + 56);
  *(_OWORD *)((char *)this + 168) = *(_OWORD *)((char *)this + 72);
  *(_OWORD *)((char *)this + 184) = *(_OWORD *)((char *)this + 88);
  *(_OWORD *)((char *)this + 200) = *(_OWORD *)((char *)this + 104);
  *(_OWORD *)((char *)this + 120) = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)((char *)this + 136) = *(_OWORD *)((char *)this + 40);
  *((double *)this + 4) = a2;
  *((_DWORD *)this + 1MTHandMotion::clearHandMotion(this, 1) = 7;
  *((void *)this + 14) = 0;
  *((_WORD *)this + 54) = 0;
  *((void *)this + 9) = 0;
  MTParserPath::updatePathStageTimestamps((uint64_t)this, a2);
  MTParserPath::updateTotalDiscountedDistance((uint64_t)this, v3);

  return MTParserPath::constructPathChangeEventMask(this);
}

uint64_t MTParserPath::constructPathChangeEventMask(MTParserPath *this)
{
  float v2 = *((float *)this + 18);
  if (v2 > 0.0)
  {
    int v3 = *((_DWORD *)this + 11);
    if (v3 == 1) {
      goto LABEL_13;
    }
    if (*((float *)this + 42) == 0.0) {
      goto LABEL_7;
    }
  }
  if (v2 == 0.0 && (*((_DWORD *)this + 11) == 7 || *((float *)this + 42) > 0.0))
  {
LABEL_7:
    int v3 = 1;
  }
  else
  {
    int v3 = *((_DWORD *)this + 12);
    if (v3)
    {
      if (v3 == *((_DWORD *)this + 36) && *((_DWORD *)this + 13) == *((_DWORD *)this + 37)) {
        int v3 = 0;
      }
      else {
        int v3 = 32;
      }
    }
  }
LABEL_13:
  unsigned int v4 = *((unsigned __int16 *)this + 54);
  unsigned int v5 = v3 & 0xFFFFD7FF | ((*((_WORD *)this + 54) & 1) << 11) & 0xDFFF | (((v4 >> 1) & 1) << 13);
  if ((v4 & 0x100) != 0) {
    int v6 = 134479872;
  }
  else {
    int v6 = 0x40000;
  }
  unsigned int v7 = v6 & 0xF8FFFFFF | ((((unsigned __int16)(v4 & 0x400) >> 10) & 1) << 25) & 0xFAFFFFFF | ((((unsigned __int16)(v4 & 0x200) >> 9) & 1) << 26) | ((((unsigned __int16)(v4 & 0x800) >> 11) & 1) << 24) | v5;
  if ((v4 & 4) != 0) {
    unsigned int v5 = v7;
  }
  int v8 = v5 | (v4 << 8) & 0xC000;
  int v9 = *((_DWORD *)this + 11);
  if (v9 < 3)
  {
    if (v9 == 2 && *((_DWORD *)this + 35) == 4) {
      v8 |= 2u;
    }
  }
  else
  {
    int v10 = *((_DWORD *)this + 35);
    if (v10 < 3)
    {
      v8 |= 2u;
      if ((v9 - 3) > 1) {
        goto LABEL_32;
      }
      goto LABEL_30;
    }
    if (v9 < 5)
    {
LABEL_30:
      if (v10 > 4) {
        v8 |= 2u;
      }
      goto LABEL_32;
    }
    if (v10 < 5) {
      v8 |= 2u;
    }
  }
LABEL_32:
  if ((*((unsigned char *)this + 368) || *((unsigned char *)this + 369))
    && (*((float *)this + 102) != *((float *)this + 100) || *((float *)this + 103) != *((float *)this + 101)))
  {
    v8 |= 4u;
    *((void *)this + 34) = *((void *)this + 4);
  }
  if (*((unsigned char *)this + 371) && *((float *)this + 19) != *((float *)this + 43)) {
    v8 |= 0x40u;
  }
  if ((*((_DWORD *)this + 2) - 1000) <= 0xBB7 && *((unsigned char *)this + 581)) {
    v8 |= 0x200u;
  }
  uint64_t FlagsEventMaskBits = MTParserPath::generateFlagsEventMaskBits((uint64_t)this, (uint64_t)this + 24);
  int v12 = FlagsEventMaskBits;
  if (FlagsEventMaskBits == MTParserPath::generateFlagsEventMaskBits(FlagsEventMaskBits, (uint64_t)this + 120))uint64_t result = v12 | v8; {
  else
  }
    uint64_t result = v12 | v8 | 0x40u;
  *((_DWORD *)this + 9MTHandMotion::clearHandMotion(this, 1) = result;
  return result;
}

void MTParserPath::detectSustainedHoverAtEdge(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v5 = MTSurfaceDimensions::convertMillimetersToSurfaceFraction(a3, 4.0);
  uint64_t v6 = 248;
  if (*(_DWORD *)(a1 + 44) == 2) {
    uint64_t v6 = 32;
  }
  double v7 = *(double *)(a1 + v6);
  float v8 = *(float *)(a1 + 56);
  float v9 = *(float *)(a1 + 84);
  float v10 = *(float *)(a2 + 40);
  BOOL v11 = v9 > v10 && (float)((float)(v9 - v10) / (float)(*(float *)(a2 + 44) - v10)) > 0.5;
  double v12 = v7 - *(double *)(a1 + 240);
  double v13 = v8;
  double v14 = fabs(v8);
  double v15 = fabs(v13 + -1.0);
  if (v14 < v15) {
    double v15 = v14;
  }
  float v16 = v15;
  BOOL v17 = v5 > v16;
  if (v12 <= 2.0) {
    BOOL v17 = 0;
  }
  *(unsigned char *)(a1 + 580) |= v17 && v11;
}

void MTParserPath::computeDebounceTimeInstability(uint64_t a1, uint64_t a2, double a3)
{
  float v5 = a3;
  if (v5 <= 0.0)
  {
    float v8 = 1.0;
    float v7 = 0.2;
  }
  else
  {
    float v6 = *(float *)(a2 + 84);
    float v7 = 0.0;
    float v8 = 0.0;
    if (v6 > v5) {
      float v8 = (float)(v6 - v5) / v6;
    }
    float v9 = *(float *)(a2 + 88);
    if (v9 > v5) {
      float v7 = (float)((float)(v9 - v5) / v9) * 0.2;
    }
  }
  float v10 = *(MTSLGLogger **)(a1 + 16);
  if (v10)
  {
    if (MTSLGLogger::isSLGEnabled(v10))
    {
      CFStringRef v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::computeDebounceTimeInstability] time_in_range = %.2f early_strong_debounce = %.2f late_weak_debounce = %.2f", *(void *)&a3, v8, v7);
      MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v11);
      CFRelease(v11);
    }
  }
}

float MTParserPath::computeZSignalInstability(uint64_t a1, uint64_t a2, float *a3, int a4, double a5)
{
  float v10 = *(float *)(a1 + 72);
  float v11 = *(float *)(a1 + 168);
  if (v10 <= v11) {
    float v12 = *(float *)(a1 + 168);
  }
  else {
    float v12 = *(float *)(a1 + 72);
  }
  double v13 = *(MTSLGLogger **)(a1 + 16);
  if (v13 && MTSLGLogger::isSLGEnabled(v13))
  {
    CFStringRef v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::computeZSignalInstability] cur_proximityZsignal_total = %.2f prev_proximityZsignal_total = %.2f max_denom_zarea = %.2f", v10, v11, v12);
    MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v14);
    CFRelease(v14);
  }
  float v15 = 1.0;
  if (v12 > 0.0)
  {
    float v16 = v10 - v11;
    float v17 = fabsf((float)(v16 * 100.0) / v12);
    if (a4) {
      float v18 = a3[4];
    }
    else {
      float v18 = 1.0;
    }
    float v19 = v18 * a3[2];
    float v20 = 0.0;
    if (v17 > v19)
    {
      float v21 = v18 * a3[3];
      float v20 = 1.0;
      if (v17 < v21) {
        float v20 = (float)(v17 - v19) / (float)(v21 - v19);
      }
    }
    double v22 = v20;
    float v23 = pow(v20, 1.5);
    unint64_t v24 = *(MTSLGLogger **)(a1 + 16);
    if (v24 && MTSLGLogger::isSLGEnabled(v24))
    {
      CFStringRef v25 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::computeZSignalInstability] delta_zarea = %.2f percent_delta_zarea = %.2f slid_stabilization_factor = %.2f linear_zinstability = %.2f squared_zinstability = %.2f", v16, v17, v18, *(void *)&v22, v23);
      MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v25);
      CFRelease(v25);
    }
    if (a4)
    {
      if (v10 < *(float *)(a1 + 572))
      {
        BOOL v26 = *(MTSLGLogger **)(a1 + 16);
        float v23 = 0.0;
        if (v26)
        {
          if (MTSLGLogger::isSLGEnabled(v26))
          {
            CFStringRef v27 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::computeZSignalInstability] already sliding but current ZArea %.2f is below long term average %.2f SET squared_zinstability = 0", v10, *(float *)(a1 + 572));
            MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v27);
            CFRelease(v27);
          }
        }
      }
    }
    float v28 = a5;
    float v29 = 0.0;
    if (v28 < 0.5) {
      float v29 = (float)(0.5 - v28) + (float)(0.5 - v28);
    }
    if (v28 > 0.0) {
      float v30 = v29;
    }
    else {
      float v30 = 1.0;
    }
    float v31 = (float)((float)(a3[7] + -1.0) * v30) + 1.0;
    float32x2_t v32 = vabd_f32(*(float32x2_t *)(a1 + 84), *(float32x2_t *)(a1 + 180));
    float v33 = v32.f32[1];
    float v67 = v32.f32[0];
    if (v32.f32[0] <= v32.f32[1]) {
      v32.f32[0] = v32.f32[1];
    }
    float v34 = v31 * a3[5];
    double v35 = 0.0;
    if (v32.f32[0] > v34) {
      double v35 = (float)((float)(v32.f32[0] - v34) / (float)((float)(v31 * a3[6]) - v34));
    }
    float v36 = pow(v35, 1.5);
    float v37 = *(float *)(a1 + 568);
    double v38 = 0.25;
    if (v37 >= v36)
    {
      if (v10 < *(float *)(a1 + 572)) {
        double v38 = 0.5;
      }
      else {
        double v38 = 0.75;
      }
    }
    float v39 = pow(v38, (*(double *)(a2 + 8) - *(double *)(a2 + 16)) / 0.00800000038);
    *(float *)(a1 + 568) = (float)((float)(1.0 - v39) * v36) + (float)(v39 * v37);
    float v40 = *(MTSLGLogger **)(a1 + 16);
    if (v40 && MTSLGLogger::isSLGEnabled(v40))
    {
      CFStringRef v41 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::computeZSignalInstability] time_stabilization_factor = %.2f delta_major_radius_mm = %.2f delta_minor_radius_mm = %.2f radius_instability = %.2f squared_radius_instability = %.2f radius_instability_alpha = %.2f", v31, v67, v33, *(void *)&v35, v36, *(void *)&v38);
      MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v41);
      CFRelease(v41);
    }
    float v42 = *(float *)(a1 + 84);
    float v43 = a3[10];
    float v44 = 0.0;
    float v45 = 0.0;
    if (v42 > v43) {
      float v45 = (float)(v42 - v43) / (float)(a3[11] - v43);
    }
    float v46 = *(float *)(a1 + 88);
    float v47 = a3[8];
    if (v46 > v47) {
      float v44 = (float)(v46 - v47) / (float)(a3[9] - v47);
    }
    float v48 = *(float *)(a1 + 568);
    MTContact_getEllipseEccentricity();
    float v50 = a3[12];
    float v51 = 0.0;
    if (v49 > v50) {
      float v51 = (float)(v49 - v50) / (float)(a3[13] - v50);
    }
    float v52 = *(MTSLGLogger **)(a1 + 16);
    if (v52 && MTSLGLogger::isSLGEnabled(v52))
    {
      CFStringRef v53 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::computeZSignalInstability] major_radius_too_big = %.2f minor_radius_too_big = %.2f eccentricity_too_big = %.2f", v45, v44, v51);
      MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v53);
      CFRelease(v53);
    }
    float v54 = *(float *)(a1 + 576);
    float v55 = a3[9];
    float v56 = 0.0;
    if (v54 > v55) {
      float v56 = (float)(v54 - v55) / (float)((float)(a3[11] + 0.5) - v55);
    }
    if (v48 <= v51) {
      float v57 = v51;
    }
    else {
      float v57 = v48;
    }
    if (v44 <= v45) {
      float v58 = v45;
    }
    else {
      float v58 = v44;
    }
    if (v57 <= v58) {
      float v59 = v58;
    }
    else {
      float v59 = v57;
    }
    float v60 = *(MTSLGLogger **)(a1 + 16);
    if (v60)
    {
      if (MTSLGLogger::isSLGEnabled(v60))
      {
        CFStringRef v61 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::computeZSignalInstability] ellipse_instability = %.2f", v59);
        MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v61);
        CFRelease(v61);
      }
      float v62 = *(MTSLGLogger **)(a1 + 16);
      if (v59 <= v56) {
        float v59 = v56;
      }
      if (v62)
      {
        if (MTSLGLogger::isSLGEnabled(v62))
        {
          CFStringRef v63 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::computeZSignalInstability K39] ellipse_instability = %.2f", v59);
          MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v63);
          CFRelease(v63);
        }
        uint64_t v64 = *(MTSLGLogger **)(a1 + 16);
        if (v23 <= v59) {
          float v15 = v59;
        }
        else {
          float v15 = v23;
        }
        if (v64 && MTSLGLogger::isSLGEnabled(v64))
        {
          CFStringRef v65 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::computeZSignalInstability] shape_instability = %.2f", v15);
          MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v65);
          CFRelease(v65);
        }
        return v15;
      }
    }
    else if (v59 <= v56)
    {
      float v59 = v56;
    }
    if (v23 <= v59) {
      return v59;
    }
    else {
      return v23;
    }
  }
  return v15;
}

void MTParserPath::bypassUpToHysteresisOfMotion(MTParserPath *this, float a2, float *a3, float a4)
{
  float v4 = *a3;
  float v5 = a2 - *a3;
  if (v5 <= a4)
  {
    if (v5 < (float)-a4) {
      a2 = v4 - a4;
    }
  }
  else
  {
    a2 = v4 + a4;
  }
  *a3 = a2;
}

void MTParserPath::pullHysteresisCenterHidingUnstablePixelDeltasXY(float a1, float a2, float a3, float a4, uint64_t a5, float *a6, float *a7)
{
  float v7 = a6[1];
  float v8 = (float)(v7 * a3) * *a6;
  float v9 = (float)(v7 * a4) * *a6;
  float v10 = a7[1];
  float v11 = a1 - *a7;
  if (v11 < (float)-v8) {
    a1 = *a7 - v8;
  }
  if (v11 > v8) {
    a1 = *a7 + v8;
  }
  *a7 = a1;
  if ((float)(a2 - v10) <= v9)
  {
    if ((float)(a2 - v10) < (float)-v9) {
      a2 = v10 - v9;
    }
  }
  else
  {
    a2 = v9 + v10;
  }
  a7[1] = a2;
}

void MTParserPath::pullHysteresisCenterCancelingEllipseTipMotion(float *a1, uint64_t a2, float *a3, MTSurfaceDimensions *this, float a5, int8x16_t a6, int8x16_t a7, float a8, int8x16_t a9, float a10)
{
  float v15 = *a3;
  *(float *)a7.i32 = *(float *)a7.i32 - *(float *)a9.i32;
  *(float *)v10.i32 = a8 - a10;
  if (*(unsigned char *)(a2 + 43))
  {
    *(float *)a7.i32 = *(float *)a7.i32 + a1[118];
    *(float *)v10.i32 = *(float *)v10.i32 + a1[119];
  }
  float v16 = a3[1];
  *(float *)a9.i32 = a5 - v15;
  int v17 = *(unsigned __int8 *)(a2 + 40);
  float v18 = fabsf(*(float *)a7.i32);
  if (!*(unsigned char *)(a2 + 40) || (float)(*(float *)a9.i32 * *(float *)a7.i32) < 0.0)
  {
    if (*(float *)a9.i32 <= v18)
    {
      if (*(float *)a9.i32 >= (float)-v18)
      {
        *a3 = a5;
        *(float *)a9.i32 = v18 - fabsf(*(float *)a9.i32);
        v20.i64[0] = 0x8000000080000000;
        v20.i64[1] = 0x8000000080000000;
        a9.i32[0] = vbslq_s8(v20, a9, a7).u32[0];
        goto LABEL_11;
      }
      float v19 = v15 - v18;
    }
    else
    {
      float v19 = v15 + v18;
    }
    *a3 = v19;
    a9.i32[0] = 0;
LABEL_11:
    a1[118] = *(float *)a9.i32;
  }
  float v21 = *(float *)a6.i32 - v16;
  int v22 = *(unsigned __int8 *)(a2 + 41);
  float v23 = fabsf(*(float *)v10.i32);
  if (*(unsigned char *)(a2 + 41) && (float)(v21 * *(float *)v10.i32) >= 0.0)
  {
    if (v21 != 0.0)
    {
      float v24 = *(float *)(a2 + 36);
      if (v24 >= (float)(*(float *)v10.i32 / v21)) {
        float v24 = *(float *)v10.i32 / v21;
      }
      a3[1] = v16 - (float)(v21 * v24);
    }
  }
  else
  {
    if (v21 <= v23)
    {
      if (v21 >= (float)-v23)
      {
        a3[1] = *(float *)a6.i32;
        *(float *)a6.i32 = v23 - fabsf(v21);
        v26.i64[0] = 0x8000000080000000;
        v26.i64[1] = 0x8000000080000000;
        *((_DWORD *)a1 + 119) = vbslq_s8(v26, a6, v10).u32[0];
        goto LABEL_24;
      }
      float v25 = v16 - v23;
    }
    else
    {
      float v25 = v16 + v23;
    }
    a3[1] = v25;
    a1[119] = 0.0;
  }
LABEL_24:
  float v27 = a1[24];
  float v28 = a1[98];
  if (!v17 || (float)(*(float *)a7.i32 * (float)(a1[23] - a1[97])) < 0.0)
  {
    __int32 v38 = v10.i32[0];
    float v29 = MTSurfaceDimensions::convertPixelDeltaToMillimeters(this, v18, 0);
    v10.i32[0] = v38;
    float v30 = a1[23];
    float v31 = a1[97];
    float v32 = v30 - v31;
    if ((float)(v30 - v31) < (float)-v29) {
      float v30 = v31 - v29;
    }
    float v33 = v29 + v31;
    if (v32 > v29) {
      float v34 = v33;
    }
    else {
      float v34 = v30;
    }
    a1[97] = v34;
    int v22 = *(unsigned __int8 *)(a2 + 41);
  }
  if (!v22 || (float)(*(float *)v10.i32 * (float)(v27 - v28)) < 0.0)
  {
    float v35 = MTSurfaceDimensions::convertPixelDeltaToMillimeters(this, v23, 1);
    float v36 = a1[24];
    float v37 = a1[98];
    if ((float)(v36 - v37) <= v35)
    {
      if ((float)(v36 - v37) < (float)-v35) {
        float v36 = v37 - v35;
      }
    }
    else
    {
      float v36 = v35 + v37;
    }
    a1[98] = v36;
  }
}

float MTParserPath::pullHysteresisCenterCancelingEllipseTipMotionFromPressure(uint64_t a1, double a2, float a3, double a4, float a5, double a6, float a7, uint64_t a8, uint64_t a9)
{
  float v9 = *(float *)(a9 + 4);
  float v10 = a3 - v9;
  float v11 = vabds_f32(a5, a7);
  if ((float)(a5 - a7) < 0.0 && v10 > 0.0 || (float)(a5 - a7) > 0.0 && v10 < 0.0)
  {
    if (v11 <= *(float *)(a1 + 524)) {
      float v11 = *(float *)(a1 + 524);
    }
    if (v10 <= v11)
    {
      if (v10 >= (float)-v11)
      {
        *(float *)(a9 + 4) = a3;
        goto LABEL_13;
      }
      float v12 = -2.0;
    }
    else
    {
      float v12 = 2.0;
    }
    *(float *)(a9 + 4) = v9 + (float)(v11 * v12);
    MTParserPath::pullHysteresisCenterCancelingEllipseTipMotionFromPressure(MTHMFingerTipOffsetParameters const&,MTPoint,MTPoint&,MTPoint,MTPoint,MTSurfaceDimensions)::alpha = 1065353216;
  }
LABEL_13:
  float result = (float)(v11
                 * *(float *)&MTParserPath::pullHysteresisCenterCancelingEllipseTipMotionFromPressure(MTHMFingerTipOffsetParameters const&,MTPoint,MTPoint&,MTPoint,MTPoint,MTSurfaceDimensions)::alpha)
         + (1.0
          - *(float *)&MTParserPath::pullHysteresisCenterCancelingEllipseTipMotionFromPressure(MTHMFingerTipOffsetParameters const&,MTPoint,MTPoint&,MTPoint,MTPoint,MTSurfaceDimensions)::alpha)
         * *(float *)(a1 + 524);
  *(float *)(a1 + 524) = result;
  return result;
}

uint64_t MTParserPath::applyAbsolutePixelHysteresis(float a1, float a2, float a3, float a4, float a5, uint64_t a6, float *a7)
{
  float v7 = a1 - *a7;
  float v8 = -a5;
  if (v7 <= a5)
  {
    if (v7 >= v8)
    {
      int v12 = 0;
      goto LABEL_9;
    }
    float v9 = (float)(int)(float)(a1 + a5);
    float v10 = -1.0;
  }
  else
  {
    float v9 = (float)(int)(float)(a1 - a5);
    float v10 = 1.0;
  }
  float v11 = v9 + v10;
  if (a3 == v9) {
    float v9 = v11;
  }
  *a7 = v9;
  int v12 = 1;
LABEL_9:
  float v13 = a2 - a7[1];
  if (v13 <= a5)
  {
    if (v13 >= v8)
    {
      int v17 = 0;
      return v12 | v17;
    }
    float v14 = (float)(int)(float)(a2 + a5);
    float v15 = -1.0;
  }
  else
  {
    float v14 = (float)(int)(float)(a2 - a5);
    float v15 = 1.0;
  }
  float v16 = v14 + v15;
  if (a4 == v14) {
    float v14 = v16;
  }
  a7[1] = v14;
  int v17 = 1;
  return v12 | v17;
}

uint64_t MTParserPath::applyAbsoluteForceHysteresis(float a1, float a2, uint64_t a3, float *a4, float *a5)
{
  float v5 = a5[30];
  float v6 = 0.0;
  if (v5 < a1)
  {
    float v7 = a5[31];
    float v6 = 1.0;
    if (v7 > a1) {
      float v6 = (float)(a1 - v5) / (float)(v7 - v5);
    }
  }
  float v8 = a5[28] + (float)((float)(a5[29] - a5[28]) * v6);
  float v9 = a1 - *a4;
  if (v9 <= v8)
  {
    if (v9 >= (float)-v8) {
      return 0;
    }
    float v10 = (float)(int)(float)(v8 + a1);
    float v11 = -1.0;
  }
  else
  {
    float v10 = (float)(int)(float)(a1 - v8);
    float v11 = 1.0;
  }
  float v12 = v10 + v11;
  if (v10 == a2) {
    float v10 = v12;
  }
  *a4 = v10;
  return 1;
}

void MTParserPath::updateAngularHysteresisCenter(MTParserPath *this, float *a2, float a3, float a4)
{
  if (a4 >= 0.0)
  {
    double v6 = a4;
    double v7 = a3;
    double v8 = fmod(a3 - *(float *)this + 3.14159265, 6.28318531);
    if (v8 < 0.0) {
      double v8 = v8 + 6.28318531;
    }
    float v9 = v8 + -3.14159265;
    if (v9 <= a4)
    {
      if (v9 >= (float)-a4) {
        return;
      }
      double v10 = v7 + v6;
    }
    else
    {
      double v10 = v7 - v6;
    }
    double v11 = fmod(v10 + 3.14159265, 6.28318531);
    if (v11 < 0.0) {
      double v11 = v11 + 6.28318531;
    }
    a3 = v11 + -3.14159265;
  }
  *(float *)this = a3;
}

float32_t MTParserPath::weakenDampedVelocity(float32x2_t *this, float a2)
{
  this[66] = vmul_n_f32(this[66], a2);
  float32_t result = this[67].f32[0] * a2;
  this[67].f32[0] = result;
  return result;
}

void MTParserPath::updateDampedVelocity(uint64_t a1, uint64_t a2, uint64_t a3, float a4)
{
  float v5 = *(float *)(a1 + 508);
  float v6 = *(float *)(a3 + 72);
  double v7 = *(double *)(a2 + 8) - *(double *)(a2 + 16);
  if (v7 > 0.025 || *(unsigned char *)(a3 + 101) && (*(_DWORD *)(a1 + 44) - 1) <= 2)
  {
    float v8 = *(float *)(a1 + 528) * 0.0;
    float v9 = *(float *)(a1 + 532) * 0.0;
  }
  else
  {
    float v8 = *(float *)(a1 + 528);
    if (*(_DWORD *)(a2 + 320))
    {
      float v8 = v8 * 0.5;
      float v9 = *(float *)(a1 + 532) * 0.5;
    }
    else
    {
      float v9 = *(float *)(a1 + 532);
    }
  }
  float v10 = v5 * a4;
  if (v10 >= v6) {
    float v11 = v10 - v6;
  }
  else {
    float v11 = 0.0;
  }
  float v12 = v11 / v5;
  if (v5 <= 0.0) {
    float v13 = 0.0;
  }
  else {
    float v13 = v12;
  }
  float v14 = exp2(v7 / -0.00800000038);
  float v15 = *(float *)(a1 + 104);
  float v16 = (float)((float)(1.0 - v14) * (float)(v13 * *(float *)(a1 + 100))) + (float)(v14 * v8);
  *(float *)(a1 + 528) = v16;
  float v17 = (float)((float)(1.0 - v14) * (float)(v13 * v15)) + (float)(v14 * v9);
  *(float *)(a1 + 532) = v17;
  *(float *)(a1 + 536) = hypotf(v16, v17);
}

float MTParserPath::computeDivingButtonChangeInstability(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v3 = *(double *)(a2 + 8) - *(double *)(a2 + 400);
  float result = 1.0;
  if (v3 > 0.0)
  {
    float v5 = *(float *)(a3 + 88);
    float result = 0.0;
    if (v5 > v3) {
      float result = (float)(v5 - v3) / v5;
    }
  }
  int v6 = *(_DWORD *)(a1 + 40);
  if (*(unsigned char *)(a3 + 99))
  {
    int v7 = *(_DWORD *)(a2 + 408);
    BOOL v8 = v6 == v7;
    if (*(_DWORD *)(a2 + 384) == 1) {
      BOOL v8 = 0;
    }
    int v9 = *(unsigned __int8 *)(a2 + 372);
    if (v6 != v7) {
      BOOL v8 = 1;
    }
    BOOL v14 = v9 == 0;
    BOOL v10 = v9 == 0;
    uint64_t v11 = *(void *)(a2 + 352);
    double v12 = 0.5;
    double v13 = 0.25;
    if (!v14)
    {
      double v13 = 0.5;
      double v12 = 1.0;
    }
    BOOL v14 = v11 == 0;
    if (v11) {
      int v15 = v8;
    }
    else {
      int v15 = 1;
    }
    float v16 = v13 * result;
    if (!v14) {
      BOOL v8 = 1;
    }
    if (!v15) {
      float result = v16;
    }
    float v17 = v12 * result;
    if (!v8) {
      float result = v17;
    }
    if (v6 != v7) {
      return dbl_24074F3D0[v10] * result;
    }
  }
  else if (v6 != *(_DWORD *)(a2 + 388))
  {
    return result * 0.15;
  }
  return result;
}

void MTParserPath::isStuckOnDivingRegion(MTParserPath *this, const MTPathStates *a2)
{
  if (*((_DWORD *)this + 10) == *((_DWORD *)a2 + 97)
    && *((_DWORD *)a2 + 94) == 1
    && !(*((_DWORD *)a2 + 96) - 1 + *((_DWORD *)a2 + 95)))
  {
    if (((int v4 = *((_DWORD *)this + 12), !*((_DWORD *)a2 + 104)) || *((int *)a2 + 105) <= 2)
      && (*((unsigned char *)a2 + 28) & 0x80) == 0
      || v4 == 1)
    {
      float v5 = *((float *)this + 23) - *((float *)this + 97);
      float v6 = (float)(*((float *)this + 24) - *((float *)this + 98))
         * (float)(*((float *)this + 24) - *((float *)this + 98));
      MTSurfaceDimensions::convertSurfaceFractionToMillimeters(*((void *)a2 + 5), *((float *)this + 14));
      float v8 = v7;
      float ThumbRestingOrPolarZoneHeight = MTPathStates::getThumbRestingOrPolarZoneHeight(a2);
      float v10 = 1.0;
      if (v8 > 0.0)
      {
        float v10 = 0.0;
        if (v8 < ThumbRestingOrPolarZoneHeight) {
          float v10 = (float)(ThumbRestingOrPolarZoneHeight - v8) / ThumbRestingOrPolarZoneHeight;
        }
      }
      float v11 = 0.0;
      if (v4 == 1) {
        float v11 = 1.0;
      }
      float v12 = v10 * v11;
      float v13 = *((float *)this + 21);
      if (v13 <= 8.0)
      {
        if (v12 <= 0.0) {
          float v12 = 0.0;
        }
      }
      else if (v13 >= 13.0)
      {
        if (v12 <= 1.0) {
          float v12 = 1.0;
        }
      }
      else
      {
        float v14 = (float)(v13 + -8.0) / 5.0;
        if (v12 <= v14) {
          float v12 = v14;
        }
      }
      float v15 = (float)(v10 * 6.0) * v12;
      float v16 = v15 + 0.2;
      if (!*((unsigned char *)a2 + 372)) {
        float v16 = v15;
      }
      if (v16 > 0.0 && (float)(v6 + (float)(v5 * v5)) < (float)(v16 * v16)) {
        pow((float)(v16 * 0.5), 1.5);
      }
    }
  }
}

float *MTParserPath::setPathSpeedSymmetries(float *this, float a2, float a3)
{
  this[147] = a2;
  this[148] = a3;
  float v3 = fabsf(a2);
  if (v3 < a3) {
    float v3 = a3;
  }
  if (v3 < this[149]) {
    float v3 = this[149];
  }
  this[149] = v3;
  return this;
}

double MTParserPath::clearPathSpeedSymmetries(MTParserPath *this)
{
  *((_DWORD *)this + 147) = 0;
  double result = 0.0;
  *((void *)this + 74) = 0;
  return result;
}

float MTParserPath::measureInstability(uint64_t a1, uint64_t a2, uint64_t a3, float *a4)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  double v8 = *(double *)(a1 + 32) - *(double *)(a1 + 224);
  if ((*(_DWORD *)(a1 + 8) - 1000) >= 0xBB8)
  {
    double v15 = (*(double *)(a2 + 8) - *(double *)(a2 + 16)) / 0.00800000038;
    float v11 = 0.0;
  }
  else
  {
    float32x2_t v45 = *(float32x2_t *)(a1 + 92);
    float v9 = hypotf(v45.f32[0] - *(float *)(a1 + 376), v45.f32[1] - *(float *)(a1 + 380));
    if (v9 > *(float *)(a1 + 384)) {
      *(float *)(a1 + 384) = v9;
    }
    float v10 = *(float *)(a1 + 84);
    float v11 = 0.0;
    float v12 = (float)(v10 + -8.0) * 0.125;
    if (v10 >= 16.0) {
      float v12 = 1.0;
    }
    if (v10 > 8.0) {
      float v13 = v12;
    }
    else {
      float v13 = 0.0;
    }
    float v14 = v13 * -0.1 + 0.9;
    double v15 = (*(double *)(a2 + 8) - *(double *)(a2 + 16)) / 0.00800000038;
    float v16 = pow(v14, v15);
    *(float32x2_t *)(a1 + 388) = vmla_n_f32(vmul_n_f32(v45, 1.0 - v16), *(float32x2_t *)(a1 + 388), v16);
    if ((*(unsigned char *)(a2 + 28) & 2) != 0) {
      float v11 = MTParserPath::computeDivingButtonChangeInstability(a1, a2, a3);
    }
  }
  float v17 = dbl_24074F3E0[v8 > *(float *)(a3 + 92)];
  double v18 = v17;
  float v19 = pow(v17, v15);
  *(float *)(a1 + 572) = (float)(*(float *)(a1 + 72) * (float)(1.0 - v19)) + (float)(v19 * *(float *)(a1 + 572));
  int8x16_t v20 = *(MTSLGLogger **)(a1 + 16);
  if (v20 && MTSLGLogger::isSLGEnabled(v20))
  {
    CFStringRef v21 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::measureInstability] zarea_alpha = %.2f _longTermZarea = %.2f", *(void *)&v18, *(float *)(a1 + 572));
    MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v21);
    CFRelease(v21);
  }
  float v22 = pow(0.949999988, (*(double *)(a2 + 8) - *(double *)(a2 + 16)) / 0.00800000038);
  *(float *)(a1 + 576) = (float)(*(float *)(a1 + 84) * (float)(1.0 - v22)) + (float)(v22 * *(float *)(a1 + 576));
  float v23 = *(MTSLGLogger **)(a1 + 16);
  if (v23 && MTSLGLogger::isSLGEnabled(v23))
  {
    CFStringRef v24 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::measureInstability K39 filtering] _longTermMajorEllipseRadius = %.2f", *(float *)(a1 + 576));
    MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v24);
    CFRelease(v24);
  }
  float v25 = MTParserPath::computeZSignalInstability(a1, a2, (float *)a3, *(unsigned __int8 *)(a1 + 368), v8);
  float v26 = 0.0;
  float v27 = 0.0;
  if (!*(unsigned char *)(a1 + 368))
  {
    MTParserPath::computeDebounceTimeInstability(a1, a3, v8);
    float v27 = v28;
    float v29 = MTLoggingPlugin();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
    {
      int v44 = *(_DWORD *)(a1 + 40);
      *(_DWORD *)buf = 67109888;
      int v47 = v44;
      __int16 v48 = 2048;
      double v49 = v25;
      __int16 v50 = 2048;
      double v51 = v27;
      __int16 v52 = 2048;
      double v53 = v8;
      _os_log_debug_impl(&dword_2406FB000, v29, OS_LOG_TYPE_DEBUG, "\tDHML:  P%d Wating for slide, ZInstability=%f, TimeInstability=%f (from dtstart=%lfs)", buf, 0x26u);
    }
  }
  float v30 = 0.0;
  if ((*(_DWORD *)(a1 + 8) - 1000) <= 0xBB7)
  {
    if ((*(unsigned char *)(a2 + 28) & 2) != 0 && !*(unsigned char *)(a1 + 370))
    {
      MTParserPath::isStuckOnDivingRegion((MTParserPath *)a1, (const MTPathStates *)a2);
      float v26 = v31;
    }
    if ((*(_DWORD *)(a2 + 24) - 1000) <= 0x3E7)
    {
      uint64_t v32 = 48;
      if (*(_DWORD *)(a1 + 44) == 7) {
        uint64_t v32 = 144;
      }
      if ((*(_DWORD *)(a1 + v32) | 4) == 5 && *(int *)(a2 + 384) >= 5 && !*(unsigned char *)(a1 + 368))
      {
        int v33 = MTPathStatesBasic::numFingerSlidWhileEngaged((MTPathStatesBasic *)a2);
        float v30 = v33 >= 3 ? 0.0 : 0.3;
        if (v33 < 3) {
          float v11 = v11 + v11;
        }
      }
    }
    if (*(unsigned char *)(a3 + 100)
      && !*(unsigned char *)(a1 + 368)
      && *(int *)(a2 + 384) >= 5
      && (int)MTPathStatesBasic::numFingerSlidWhileEngaged((MTPathStatesBasic *)a2) >= 3)
    {
      float v25 = v25 * 0.5;
      float v27 = v27 * 0.5;
    }
  }
  if (a4)
  {
    if (v25 <= v30) {
      float v34 = v30;
    }
    else {
      float v34 = v25;
    }
    if (v27 <= v11) {
      float v35 = v11;
    }
    else {
      float v35 = v27;
    }
    if (v34 <= v35) {
      float v34 = v35;
    }
    *a4 = v34;
  }
  float v36 = *(MTSLGLogger **)(a1 + 16);
  if (v36 && MTSLGLogger::isSLGEnabled(v36))
  {
    CFStringRef v37 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::measureInstability INSTABILITY] instability_ contactZShape = %.2f divingButtonZone = %.2f restingHand = %.2f touchTimeDebounce = %.2f buttonTimeDebounce = %.2f ", v25, v26, v30, v27, v11);
    MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v37);
    CFRelease(v37);
  }
  if (v25 <= v26) {
    float v38 = v26;
  }
  else {
    float v38 = v25;
  }
  if (v38 < v30) {
    float v38 = v30;
  }
  if (v27 <= v11) {
    float v39 = v11;
  }
  else {
    float v39 = v27;
  }
  if (v38 <= v39) {
    float v40 = v39;
  }
  else {
    float v40 = v38;
  }
  CFStringRef v41 = *(MTSLGLogger **)(a1 + 16);
  if (v41 && MTSLGLogger::isSLGEnabled(v41))
  {
    CFStringRef v42 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::measureInstability] total instability = %.2f", v40);
    MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v42);
    CFRelease(v42);
  }
  return v40;
}

void MTParserPath::filterContactForScreenUI(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int8x16_t a6, double a7, int8x16_t a8, int8x16_t a9)
{
  uint64_t v14 = a1 + 24;
  float v15 = mthm_ComputeFingerEllipseTipOffset_mm((int *)a5, a3, (float32x2_t *)(a1 + 24), (float *)(a1 + 120), a6, a7, a8, a9);
  *(float *)&uint64_t v16 = MTSurfaceDimensions::convertMillimetersToPixels(a3, v15);
  v83.i64[0] = v16;
  float v84 = v17;
  if (*(unsigned char *)(a5 + 52))
  {
    mthm_ComputeFingerEllipseTipOffsetFromPressure_mm(a5, a3, v14);
    float v19 = MTSurfaceDimensions::convertMillimetersToPixels(a3, v18);
    float v21 = v20;
  }
  else
  {
    float v21 = 0.0;
    float v19 = 0.0;
  }
  float v22 = MTSurfaceDimensions::convertSurfaceFractionToPixels(a3, *(float *)(a1 + 56));
  float v24 = v23;
  v91[0] = 0.0;
  int v25 = *(_DWORD *)(a1 + 44);
  unsigned int v82 = (_DWORD *)(a1 + 44);
  BOOL v26 = v25 < 3
     || !*(_DWORD *)(a1 + 140)
     || v25 >= 5 && *(unsigned char *)(a1 + 368)
     || v25 == 3 && *(unsigned char *)(a4 + 101) != 0;
  if (*(unsigned char *)(a4 + 98))
  {
    MTParserPath::detectSustainedHoverAtEdge(a1, a4, a3);
    BOOL v26 = (*(unsigned __int8 *)(a1 + 580) | v26) != 0;
  }
  *(void *)(a1 + 556) = *(void *)(a1 + 548);
  MTParserPath::correctAndQuantizeRadius(a1, a4);
  if (!*(unsigned char *)(a4 + 80))
  {
    uint64_t v30 = a2;
    goto LABEL_15;
  }
  uint64_t v30 = a2;
  if (*(float *)(a1 + 64) != 0.0)
  {
LABEL_15:
    BOOL v31 = 0;
    goto LABEL_16;
  }
  BOOL v31 = *(float *)(a1 + 68) == 0.0;
LABEL_16:
  float v32 = *(float *)(a4 + 76);
  if (v32 <= 0.0 || (!*(unsigned char *)(a1 + 368) ? (int v33 = 1) : (int v33 = v26), ((v33 | v31) & 1) != 0))
  {
    BOOL v34 = 0;
  }
  else
  {
    double v28 = *(double *)(a1 + 272);
    BOOL v34 = *(double *)(a1 + 32) - v28 > v32;
  }
  if (!v26 && !v31 && !v34)
  {
    if (*(unsigned char *)(a4 + 97))
    {
      v29.i32[0] = *(_DWORD *)(a1 + 464);
      float v35 = *(float *)(a1 + 468);
      v88 = &unk_26F4D9B50;
      long long v37 = *(_OWORD *)(a3 + 24);
      int8x16_t v89 = *(int8x16_t *)(a3 + 8);
      int8x16_t v36 = v89;
      long long v90 = v37;
      *(float *)v36.i32 = v24;
      MTParserPath::pullHysteresisCenterCancelingEllipseTipMotion((float *)a1, a5, (float *)(a1 + 416), (MTSurfaceDimensions *)&v88, v22, v36, v83, v84, v29, v35);
      MTSurfaceDimensions::~MTSurfaceDimensions((MTSurfaceDimensions *)&v88);
    }
    if (*(unsigned char *)(a5 + 52))
    {
      v29.i32[0] = *(_DWORD *)(a1 + 512);
      float v38 = *(float *)(a1 + 516);
      v85 = &unk_26F4D9B50;
      long long v86 = *(_OWORD *)(a3 + 8);
      long long v87 = *(_OWORD *)(a3 + 24);
      *(float *)&double v28 = v19;
      MTParserPath::pullHysteresisCenterCancelingEllipseTipMotionFromPressure(a1, COERCE_DOUBLE(__PAIR64__(DWORD1(v87), LODWORD(v22))), v24, v28, v21, *(double *)v29.i64, v38, v27, a1 + 416);
      MTSurfaceDimensions::~MTSurfaceDimensions((MTSurfaceDimensions *)&v85);
    }
    float v40 = MTParserPath::measureInstability(a1, v30, a4, v91);
    CFStringRef v41 = *(MTSLGLogger **)(a1 + 16);
    if (v41)
    {
      float v43 = *(float *)a4;
      float v42 = *(float *)(a4 + 4);
      CFStringRef v41 = (MTSLGLogger *)MTSLGLogger::isSLGEnabled(v41);
      if (v41)
      {
        CFStringRef v44 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::filterContactForScreenUI INSTABILITY] pixel_instability (equivalent) = %.2f pixel_deltas2hide = %.2f cur_position = (%.2f, %.2f)  _hysteresisCenter = (%.2f, %.2f)", v40, (float)((float)(v40 * v42) * v43), v22, v24, *(float *)(a1 + 416), *(float *)(a1 + 420));
        MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v44);
        CFRelease(v44);
      }
    }
    if (*(_DWORD *)a5 != 1 || !*(unsigned char *)(a4 + 128)) {
      goto LABEL_54;
    }
    *(float *)&double v39 = v22;
    float v45 = MTSurfaceDimensions::distanceToTopEdge_mm(a3, v39, v24);
    CFStringRef v41 = *(MTSLGLogger **)(a1 + 16);
    if (v41)
    {
      CFStringRef v41 = (MTSLGLogger *)MTSLGLogger::isSLGEnabled(v41);
      if (v41)
      {
        CFStringRef v46 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::filterContactForScreenUI] distance to bottom edge = %.2f\n", v45);
        MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v46);
        CFRelease(v46);
      }
    }
    if (v45 < 5.0)
    {
      int v47 = (float *)(a1 + 416);
      MTParserPath::pullHysteresisCenterHidingUnstablePixelDeltasXY(v22, v24, v40, v40 / 5.0, (uint64_t)v41, (float *)a4, (float *)(a1 + 416));
      __int16 v48 = *(MTSLGLogger **)(a1 + 16);
      if (!v48)
      {
        float v54 = *(float *)(a1 + 416);
        float v55 = *(float *)(a1 + 420);
LABEL_82:
        char v62 = MTParserPath::applyAbsolutePixelHysteresis(v22, v24, *(float *)(a1 + 152), *(float *)(a1 + 156), *(float *)(a4 + 56), (uint64_t)v48, v47);
        CFStringRef v63 = *(MTSLGLogger **)(a1 + 16);
        if (v63)
        {
          CFStringRef v63 = (MTSLGLogger *)MTSLGLogger::isSLGEnabled(v63);
          if (v63)
          {
            CFStringRef v64 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::filterContactForScreenUI] after applying absolute pixel hysteresis:  cur_position = (%.2f, %.2f) _previousContact = (%.2f, %.2f) _hysteresisCenter = (%.2f, %.2f)", v22, v24, *(float *)(a1 + 152), *(float *)(a1 + 156), *(float *)(a1 + 416), *(float *)(a1 + 420));
            MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v64);
            CFRelease(v64);
          }
        }
        char v65 = *(unsigned char *)(a1 + 368) | v62;
        *(unsigned char *)(a1 + 368) = v65;
        if (*(unsigned char *)(a1 + 581)) {
          char v66 = 0;
        }
        else {
          char v66 = *(unsigned char *)(a1 + 370) | v62;
        }
        *(unsigned char *)(a1 + 370) = v66;
        *(unsigned char *)(a1 + 369) = v65;
        MTParserPath::pullHysteresisCenterHidingUnstablePixelDeltasXY(v22, v24, v91[0], v91[0], (uint64_t)v63, (float *)a4, (float *)(a1 + 424));
        uint64_t v60 = MTParserPath::applyAbsolutePixelHysteresis(v22, v24, *(float *)(a1 + 152), *(float *)(a1 + 156), *(float *)(a4 + 56), v67, (float *)(a1 + 424));
        *(unsigned char *)(a1 + 369) |= v60;
        if (*(unsigned char *)(a5 + 42))
        {
          uint64_t v68 = *(void *)(a1 + 432);
          *(void *)(a1 + 440) = v68;
          float v69 = (float)(int)*(float *)&v68;
          float v70 = (float)(int)*((float *)&v68 + 1);
          MTParserPath::pullHysteresisCenterHidingUnstablePixelDeltasXY(*(float *)v83.i32, v84, v40, v40, v60, (float *)a4, (float *)(a1 + 432));
          uint64_t v60 = MTParserPath::applyAbsolutePixelHysteresis(*(float *)v83.i32, v84, v69, v70, *(float *)(a4 + 56), v71, (float *)(a1 + 432));
        }
        float v72 = *(float *)(a1 + 416);
        *(float *)(a1 + 448) = v72 - v54;
        float v73 = *(float *)(a1 + 420);
        *(float *)(a1 + 452) = v73 - v55;
        *(float *)(a1 + 456) = (float)(v72 - v54) + *(float *)(a1 + 456);
        *(float *)(a1 + 460) = (float)(v73 - v55) + *(float *)(a1 + 460);
        if (*(unsigned char *)(a1 + 368) || *(unsigned char *)(a1 + 369))
        {
          *(void *)(a1 + 408) = *(void *)(a1 + 400);
          *(float *)(a1 + 400) = (float)(int)v72;
          *(float *)(a1 + 404) = (float)(int)v73;
        }
        goto LABEL_93;
      }
      if (MTSLGLogger::isSLGEnabled(v48))
      {
        CFStringRef v49 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::pullHysteresisCenterHidingUnstablePixelDeltas] reduce pixel hysteresis instability to %.2f %.2f for unstable within %.2fmm of bottom edge\n", v40, (float)(v40 / 5.0), 0x4014000000000000);
        MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v49);
        CFRelease(v49);
      }
    }
    else
    {
LABEL_54:
      MTParserPath::pullHysteresisCenterHidingUnstablePixelDeltasXY(v22, v24, v40, v40, (uint64_t)v41, (float *)a4, (float *)(a1 + 416));
    }
    __int16 v48 = *(MTSLGLogger **)(a1 + 16);
    int v47 = (float *)(a1 + 416);
    float v54 = *(float *)(a1 + 416);
    float v55 = *(float *)(a1 + 420);
    if (v48)
    {
      __int16 v48 = (MTSLGLogger *)MTSLGLogger::isSLGEnabled(v48);
      if (v48)
      {
        CFStringRef v56 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"[Hysteresis debugging MTParserPath::filterContactForScreenUI] pulled_hysteresis_center = (%.2f, %.2f)", *(float *)(a1 + 416), *(float *)(a1 + 420));
        MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v56);
        CFRelease(v56);
      }
    }
    goto LABEL_82;
  }
  __int16 v50 = *(MTSLGLogger **)(a1 + 16);
  if (v50 && MTSLGLogger::isSLGEnabled(v50))
  {
    CFStringRef v51 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"Hysteresis debugging [MTParserPath::filterContactForScreenUI] reset_from_stage = %1d reset_from_zero_velocity = %1d, reset_from_pause = %1d\n", v26, v31, v34);
    MTSLGLogger::logString(*(MTSLGLogger **)(a1 + 16), v51);
    CFRelease(v51);
  }
  *(float *)(a1 + 416) = v22;
  *(float *)(a1 + 420) = v24;
  *(float *)(a1 + 424) = v22;
  *(float *)(a1 + 428) = v24;
  *(void *)(a1 + 408) = *(void *)(a1 + 400);
  *(float *)(a1 + 400) = (float)(int)v22;
  *(float *)(a1 + 404) = (float)(int)v24;
  if (*(unsigned char *)(a5 + 42))
  {
    *(void *)(a1 + 440) = *(void *)(a1 + 432);
    *(_DWORD *)(a1 + 432) = v83.i32[0];
    *(float *)(a1 + 436) = v84;
  }
  *(void *)(a1 + 448) = 0;
  *(void *)(a1 + 456) = 0;
  *(_DWORD *)(a1 + 572) = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 576) = *(_DWORD *)(a1 + 84);
  unsigned int v52 = *(_DWORD *)(a1 + 8) - 1000;
  if (v52 <= 0xBB7)
  {
    uint64_t v53 = *(void *)(a1 + 92);
    *(void *)(a1 + 388) = v53;
    *(void *)(a1 + 376) = v53;
  }
  if (!*(unsigned char *)(a5 + 43))
  {
LABEL_51:
    if (v26) {
      goto LABEL_52;
    }
    goto LABEL_65;
  }
  if (v26 || v31)
  {
    *(void *)(a1 + 472) = 0;
    *(void *)(a1 + 520) = 0;
    goto LABEL_51;
  }
  *(float32x2_t *)(a1 + 472) = vadd_f32(*(float32x2_t *)(a1 + 472), vsub_f32((float32x2_t)__PAIR64__(LODWORD(v84), v83.u32[0]), *(float32x2_t *)(a1 + 464)));
  if (v26)
  {
LABEL_52:
    *(_WORD *)(a1 + 368) = 0;
    *(unsigned char *)(a1 + 370) = 0;
    if (v52 <= 0xBB7)
    {
      *(_DWORD *)(a1 + 384) = 0;
      *(_WORD *)(a1 + 584) = 0;
    }
LABEL_74:
    *(unsigned char *)(a1 + 58MTHandMotion::clearHandMotion(this, 1) = 0;
    goto LABEL_75;
  }
LABEL_65:
  if (v34)
  {
    if (v52 > 0xBB7)
    {
      *(_WORD *)(a1 + 368) = 0;
      *(unsigned char *)(a1 + 370) = 0;
    }
    else
    {
      uint64_t v58 = 48;
      if (*(_DWORD *)(a1 + 44) == 7) {
        uint64_t v58 = 144;
      }
      if (*(_DWORD *)(a1 + v58) == 1 && *(int *)(v30 + 420) >= 2 && *(int *)(v30 + 384) > 1) {
        goto LABEL_75;
      }
      *(_WORD *)(a1 + 368) = 0;
      *(unsigned char *)(a1 + 370) = 0;
      *(_DWORD *)(a1 + 384) = 0;
    }
    goto LABEL_74;
  }
LABEL_75:
  if (*(int *)(a1 + 48) <= 5 && *(int *)(a1 + 144) < 6)
  {
    CFStringRef v61 = MTLoggingPlugin();
    uint64_t v60 = os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG);
    float v40 = 0.0;
    if (v60) {
      MTParserPath::filterContactForScreenUI(a1, (uint64_t)v82, v61);
    }
  }
  else
  {
    float v59 = MTLoggingPlugin();
    uint64_t v60 = os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG);
    float v40 = 0.0;
    if (v60) {
      MTParserPath::filterContactForScreenUI(a1, (int *)(a1 + 48), v59);
    }
  }
LABEL_93:
  *(unsigned char *)(a1 + 37MTHandMotion::clearHandMotion(this, 1) = MTParserPath::applyAbsoluteForceHysteresis(*(float *)(a1 + 76), *(float *)(a1 + 172), v60, (float *)(a1 + 372), (float *)a4);
  *(float *)(a1 + 76) = (float)(int)*(float *)(a1 + 372);
  *(_DWORD *)(a1 + 464) = v83.i32[0];
  *(float *)(a1 + 468) = v84;
  if (*(unsigned char *)(a5 + 52))
  {
    *(float *)(a1 + 512) = v19;
    *(float *)(a1 + 516) = v21;
  }
  *(float32x2_t *)(a1 + 56) = vcvt_f32_s32(vcvt_s32_f32(*(float32x2_t *)(a1 + 416)));
  *(float *)(a1 + 64) = MTSurfaceDimensions::convertSurfaceFractionVelocityToPixelsPerSecond(a3, *(float *)(a1 + 64));
  *(_DWORD *)(a1 + 68) = v74;
  *(void *)(a1 + 500) = *(void *)(a1 + 64);
  *(float *)(a1 + 508) = hypotf(*(float *)(a1 + 100), *(float *)(a1 + 104));
  if (*(unsigned char *)(a4 + 101) && (*v82 - 1) <= 2)
  {
    *(void *)(a1 + 500) = 0;
    *(_DWORD *)(a1 + 508) = 0;
  }
  float v75 = 1.0 - v40;
  if ((float)(1.0 - v40) < 0.0) {
    float v75 = 0.0;
  }
  MTParserPath::updateDampedVelocity(a1, v30, a4, v75);
  *(unsigned char *)(a1 + 488) = 0;
  float v77 = *(float *)(a1 + 112);
  *(float *)(a1 + 492) = v77;
  *(_DWORD *)(a1 + 496) = *(_DWORD *)(a1 + 80);
  float v78 = *(float *)(a4 + 64);
  if (v78 >= 0.0)
  {
    float v79 = v78 * 0.0174532925;
    MTParserPath::updateAngularHysteresisCenter((MTParserPath *)(a1 + 480), v76, v77, v79);
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 480);
    *(unsigned char *)(a1 + 488) = 1;
  }
  float v80 = *(float *)(a4 + 68);
  if (v80 >= 0.0)
  {
    float v81 = v80 * 0.0174532925;
    MTParserPath::updateAngularHysteresisCenter((MTParserPath *)(a1 + 484), v76, *(float *)(a1 + 80), v81);
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(a1 + 484);
    *(unsigned char *)(a1 + 488) = 1;
  }
}

void sub_240711D94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void MTParserPath::correctAndQuantizeRadius(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 102))
  {
    unsigned int v3 = *(_DWORD *)(a1 + 44) - 1;
    if (v3 <= 5 && (*(_DWORD *)(a1 + 140) - 1) >= 6)
    {
      _D1 = (float32x2_t)vrev64_s32(*(int32x2_t *)(a1 + 84));
    }
    else
    {
      __asm { FMOV            V2.2D, #0.5 }
      int8x16_t v9 = (int8x16_t)vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)(a1 + 84)), _Q2);
      _D1 = vcvt_f32_f64(vmlaq_f64((float64x2_t)vextq_s8(v9, v9, 8uLL), _Q2, vcvtq_f64_f32(*(float32x2_t *)(a1 + 540))));
    }
    *(float32x2_t *)(a1 + 540) = _D1;
    float v12 = 0.0;
    float v13 = 0.0;
    if (v3 <= 3)
    {
      _S0 = *(float *)(a2 + 104);
      __asm { FMLA            S3, S0, V1.S[1]; float }
      float v16 = fmaxf(_S3, 2.0);
      float v17 = vmlas_n_f32(*(float *)(a2 + 108), _S0, _D1.f32[0]);
      float v12 = _QuantizedRadius(fmaxf(v17, 2.0), *(float *)(a1 + 556), v17, _S3);
      float v13 = _QuantizedRadius(v16, *(float *)(a1 + 560), v18, v19);
    }
    *(float *)(a1 + 548) = v12;
    *(float *)(a1 + 552) = v13;
    float v11 = 1.0;
  }
  else
  {
    float v11 = 0.0;
  }
  *(float *)(a1 + 564) = v11;
}

float _QuantizedRadius(float a1, float a2, float a3, float a4)
{
  if (a1 == 0.0) {
    return 0.0;
  }
  if (a1 >= 2.0) {
    float v6 = a1;
  }
  else {
    float v6 = 2.0;
  }
  int v7 = (int)(float)((float)(v6 + -2.0) * 0.5);
  double v8 = fmodf(v6 + -2.0, 2.0);
  if (v6 <= a2 || v8 <= 1.334)
  {
    BOOL v10 = v6 < a2;
    if (v8 <= 0.666) {
      BOOL v10 = 0;
    }
    int v9 = v10 + v7;
  }
  else
  {
    int v9 = v7 + 1;
  }
  return (float)((float)v9 * 2.0) + 2.0;
}

BOOL MTParserPath::stableAndMoved(MTParserPath *this)
{
  if (!*((unsigned char *)this + 368) && !*((unsigned char *)this + 369)) {
    return 0;
  }
  if (*((float *)this + 102) == *((float *)this + 100)) {
    return *((float *)this + 103) != *((float *)this + 101);
  }
  return 1;
}

uint64_t MTParserPath::generateFlagsEventMaskBits(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int16 *)(a2 + 84);
  unsigned int v3 = v2 & 0xFE7;
  if ((v2 & 0x100) != 0) {
    int v4 = 134479872;
  }
  else {
    int v4 = 0x40000;
  }
  if (v3 >= 0x800) {
    int v5 = (v3 << 15) & 0x2000000 | ((((unsigned __int16)(v2 & 0xFE7) >> 9) & 1) << 26) | v4 | (v2 << 12) & 0x2000 | ((v2 & 1) << 11) | 0x1000000;
  }
  else {
    int v5 = (v3 << 15) & 0x2000000 | ((((unsigned __int16)(v2 & 0xFE7) >> 9) & 1) << 26) | v4 | (v2 << 12) & 0x2000 | ((v2 & 1) << 11);
  }
  if ((v2 & 4) == 0) {
    int v5 = (v2 << 12) & 0x2000 | ((v2 & 1) << 11);
  }
  return v5 | (v2 << 8) & 0xC000u;
}

uint64_t MTInputDeviceManagement::MTInputDeviceManagement(uint64_t result, uint64_t a2)
{
  *(void *)double result = &unk_26F4D9418;
  *(void *)(result + 8) = a2;
  *(void *)(result + 16) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(void *)(result + 40) = 0;
  return result;
}

{
  *(void *)double result = &unk_26F4D9418;
  *(void *)(result + 8) = a2;
  *(void *)(result + 16) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(void *)(result + 40) = 0;
  return result;
}

void MTInputDeviceManagement::~MTInputDeviceManagement(MTInputDeviceManagement *this)
{
}

void MTInputDeviceManagement::scheduleOnDispatchQueue(MTInputDeviceManagement *this, NSObject *a2)
{
  kern_return_t v17;
  NSObject *v18;
  uint64_t v19;
  void *v20;
  int v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  kern_return_t v28;
  __int16 v29;
  uint64_t v30;
  __CFString *v31;
  CFTypeRef v32;
  void v33[2];
  void v34[3];

  v34[2] = *MEMORY[0x263EF8340];
  io_registry_entry_t Service = MTDeviceGetService();
  if (!Service)
  {
    uint64_t v14 = MTLoggingPlugin();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return;
    }
    float v21 = 136315650;
    float v22 = "[Error] ";
    float v23 = 2080;
    float v24 = "";
    int v25 = 2080;
    BOOL v26 = "scheduleOnDispatchQueue";
    float v15 = "[HID] [MT] %s%s%s Could not get service";
    goto LABEL_13;
  }
  CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(Service, @"SerialNumber", (CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  if (!CFProperty) {
    goto LABEL_11;
  }
  float v6 = CFProperty;
  CFTypeID v7 = CFGetTypeID(CFProperty);
  if (v7 != CFStringGetTypeID())
  {
    CFRelease(v6);
    goto LABEL_11;
  }
  CFTypeRef v8 = (id)CFMakeCollectable(v6);
  if (!v8)
  {
LABEL_11:
    uint64_t v14 = MTLoggingPlugin();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return;
    }
    float v21 = 136315650;
    float v22 = "[Error] ";
    float v23 = 2080;
    float v24 = "";
    int v25 = 2080;
    BOOL v26 = "scheduleOnDispatchQueue";
    float v15 = "[HID] [MT] %s%s%s Could not get serial number key (cannot match AMD and DM)";
    goto LABEL_13;
  }
  float v32 = v8;
  v33[0] = @"IOPropertyMatch";
  BOOL v31 = @"SerialNumber";
  uint64_t v9 = [NSDictionary dictionaryWithObjects:&v32 forKeys:&v31 count:1];
  v33[1] = @"IONameMatch";
  v34[0] = v9;
  v34[1] = @"AppleDeviceManagementHIDEventService";
  BOOL v10 = (const void *)[NSDictionary dictionaryWithObjects:v34 forKeys:v33 count:2];
  IONotificationPortRef v11 = IONotificationPortCreate(0);
  *((void *)this + 2) = v11;
  if (!v11)
  {
    uint64_t v14 = MTLoggingPlugin();
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      return;
    }
    float v21 = 136315650;
    float v22 = "[Error] ";
    float v23 = 2080;
    float v24 = "";
    int v25 = 2080;
    BOOL v26 = "scheduleOnDispatchQueue";
    float v15 = "[HID] [MT] %s%s%s Could not create notification port";
LABEL_13:
    _os_log_impl(&dword_2406FB000, v14, OS_LOG_TYPE_ERROR, v15, (uint8_t *)&v21, 0x20u);
    return;
  }
  float v12 = v11;
  if (v10) {
    CFDictionaryRef v13 = (const __CFDictionary *)CFRetain(v10);
  }
  else {
    CFDictionaryRef v13 = 0;
  }
  float v16 = (unsigned int *)((char *)this + 24);
  float v17 = IOServiceAddMatchingNotification(v12, "IOServiceFirstMatch", v13, (IOServiceMatchingCallback)MTInputDeviceManagement::DeviceManagerMatchedCallback, this, (io_iterator_t *)this + 6);
  if (v17 || (float v20 = (void *)*v16, !v20))
  {
    float v18 = MTLoggingPlugin();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      float v19 = *v16;
      float v21 = 136316162;
      float v22 = "[Error] ";
      float v23 = 2080;
      float v24 = "";
      int v25 = 2080;
      BOOL v26 = "scheduleOnDispatchQueue";
      uint64_t v27 = 1024;
      double v28 = v17;
      int8x16_t v29 = 2048;
      uint64_t v30 = v19;
      _os_log_impl(&dword_2406FB000, v18, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Could not create notification port: 0x%08x (deviceIterator: 0x%08jx)", (uint8_t *)&v21, 0x30u);
    }
    IONotificationPortDestroy(*((IONotificationPortRef *)this + 2));
    *((void *)this + 2) = 0;
  }
  else
  {
    MTInputDeviceManagement::DeviceManagerMatchedCallback(this, v20);
    IONotificationPortSetDispatchQueue(*((IONotificationPortRef *)this + 2), a2);
  }
}

void MTInputDeviceManagement::DeviceManagerMatchedCallback(MTInputDeviceManagement *this, void *a2)
{
  io_iterator_t v2 = a2;
  uint64_t v16 = *MEMORY[0x263EF8340];
  int v4 = (void *)MEMORY[0x2455F7150]();
  if (IOIteratorIsValid(v2))
  {
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    do
    {
      io_registry_entry_t v6 = IOIteratorNext(v2);
      if (!v6) {
        break;
      }
      io_object_t v7 = v6;
      CFMutableDictionaryRef properties = 0;
      if (IORegistryEntryCreateCFProperties(v6, &properties, v5, 0) || !properties)
      {
        CFTypeRef v8 = MTLoggingPlugin();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          IONotificationPortRef v11 = "[Error] ";
          __int16 v12 = 2080;
          CFDictionaryRef v13 = "";
          __int16 v14 = 2080;
          float v15 = "DeviceManagerMatchedCallback";
          _os_log_impl(&dword_2406FB000, v8, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Could not retrieve the service properties", buf, 0x20u);
        }
      }
      else
      {
        MTInputDeviceManagement::publishService(this, properties);
        CFRelease(properties);
      }
      IOObjectRelease(v7);
    }
    while (IOIteratorIsValid(v2));
  }
}

void MTInputDeviceManagement::unscheduleFromDispatchQueue(MTInputDeviceManagement *this, dispatch_queue_t queue)
{
  dispatch_assert_queue_not_V2(queue);
  if (*((void *)this + 5)) {
    MTInputDeviceManagement::unpublishService(this);
  }
  io_object_t v3 = *((_DWORD *)this + 6);
  if (v3)
  {
    IOObjectRelease(v3);
    *((_DWORD *)this + 6) = 0;
  }
  int v4 = (IONotificationPort *)*((void *)this + 2);
  if (v4)
  {
    IONotificationPortDestroy(v4);
    *((void *)this + 2) = 0;
  }
}

void MTInputDeviceManagement::unpublishService(MTInputDeviceManagement *this)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  io_iterator_t v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *((void *)this + 5);
    int v4 = 136315906;
    CFAllocatorRef v5 = "";
    __int16 v6 = 2080;
    io_object_t v7 = "";
    __int16 v8 = 2080;
    uint64_t v9 = "unpublishService";
    __int16 v10 = 2114;
    uint64_t v11 = v3;
    _os_log_impl(&dword_2406FB000, v2, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Unpublishing device with connection UUID %{public}@", (uint8_t *)&v4, 0x2Au);
  }
  objc_msgSend((id)objc_msgSend(MEMORY[0x263F340D8], "sharedClient"), "destroyConnectionWithUUID:", *((void *)this + 5));
  CFRelease(*((CFTypeRef *)this + 5));
  *((void *)this + 5) = 0;
}

void MTInputDeviceManagement::publishService(MTInputDeviceManagement *this, __CFDictionary *a2)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  if (*((void *)this + 5)) {
    MTInputDeviceManagement::unpublishService(this);
  }
  int v4 = (void *)[(__CFDictionary *)a2 objectForKeyedSubscript:@"MTFW Version"];
  if (!v4 || ![v4 intValue])
  {
    *(_DWORD *)buf = 0;
    MTDeviceGetVersion();
    -[__CFDictionary setObject:forKeyedSubscript:](a2, "setObject:forKeyedSubscript:", [NSNumber numberWithInt:0], @"MTFW Version");
  }
  uint64_t v5 = [(__CFDictionary *)a2 objectForKeyedSubscript:@"SerialNumber"];
  if (!v5)
  {
    __int16 v10 = MTLoggingPlugin();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315650;
    float v45 = "[Error] ";
    __int16 v46 = 2080;
    int v47 = "";
    __int16 v48 = 2080;
    CFStringRef v49 = "publishService";
    uint64_t v11 = "[HID] [MT] %s%s%s Could not get a service identifier";
LABEL_27:
    _os_log_impl(&dword_2406FB000, v10, OS_LOG_TYPE_ERROR, v11, buf, 0x20u);
    return;
  }
  uint64_t v6 = v5;
  io_object_t v7 = (void *)[(__CFDictionary *)a2 objectForKeyedSubscript:@"Transport"];
  if ([v7 isEqualToString:@"AID"])
  {
    uint64_t v8 = 7;
    uint64_t v9 = 3;
  }
  else if ([v7 isEqualToString:@"USB"])
  {
    uint64_t v8 = 0;
    uint64_t v9 = 6;
  }
  else
  {
    int v12 = [v7 isEqualToString:@"Bluetooth"];
    if (v12) {
      uint64_t v9 = 2;
    }
    else {
      uint64_t v9 = 11;
    }
    if (v12) {
      uint64_t v8 = 2;
    }
    else {
      uint64_t v8 = 17;
    }
  }
  uint64_t v13 = objc_msgSend((id)objc_msgSend(MEMORY[0x263F340D8], "sharedClient"), "createConnectionWithType:andIdentifier:", v9, v6);
  if (!v13)
  {
    __int16 v10 = MTLoggingPlugin();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315650;
    float v45 = "[Error] ";
    __int16 v46 = 2080;
    int v47 = "";
    __int16 v48 = 2080;
    CFStringRef v49 = "publishService";
    uint64_t v11 = "[HID] [MT] %s%s%s Could not create CoreAccessories connection";
    goto LABEL_27;
  }
  __int16 v14 = (const void *)v13;
  uint64_t v15 = objc_msgSend((id)objc_msgSend(MEMORY[0x263F340D8], "sharedClient"), "createEndpointWithTransportType:andProtocol:andIdentifier:andDataOutHandler:forConnectionWithUUID:publishConnection:", v8, 1, 0, 0, v13, 0);
  if (!v15)
  {
    __int16 v10 = MTLoggingPlugin();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315650;
    float v45 = "[Error] ";
    __int16 v46 = 2080;
    int v47 = "";
    __int16 v48 = 2080;
    CFStringRef v49 = "publishService";
    uint64_t v11 = "[HID] [MT] %s%s%s Could not create CoreAccessories endpoint";
    goto LABEL_27;
  }
  uint64_t v36 = v15;
  if ([(__CFDictionary *)a2 objectForKeyedSubscript:@"SerialNumber"]) {
    float v35 = (__CFString *)[(__CFDictionary *)a2 objectForKeyedSubscript:@"SerialNumber"];
  }
  else {
    float v35 = &stru_26F4DBE18;
  }
  if ([(__CFDictionary *)a2 objectForKeyedSubscript:@"Product"]) {
    BOOL v34 = (__CFString *)[(__CFDictionary *)a2 objectForKeyedSubscript:@"Product"];
  }
  else {
    BOOL v34 = &stru_26F4DBE18;
  }
  if ([(__CFDictionary *)a2 objectForKeyedSubscript:@"Manufacturer"]) {
    int v33 = (__CFString *)[(__CFDictionary *)a2 objectForKeyedSubscript:@"Manufacturer"];
  }
  else {
    int v33 = @"Apple Inc.";
  }
  long long v37 = this;
  uint64_t v16 = (void *)[(__CFDictionary *)a2 objectForKeyedSubscript:@"HardwareID"];
  uint64_t v31 = v6;
  if (v16) {
    float v32 = (__CFString *)objc_msgSend(NSString, "stringWithFormat:", @"%04X", objc_msgSend(v16, "unsignedIntegerValue"));
  }
  else {
    float v32 = &stru_26F4DBE18;
  }
  float v17 = (void *)[MEMORY[0x263F089D8] stringWithCapacity:20];
  long long v38 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  uint64_t v18 = [&unk_26F4E1838 countByEnumeratingWithState:&v38 objects:buf count:16];
  if (v18)
  {
    uint64_t v19 = v18;
    uint64_t v20 = *(void *)v39;
    do
    {
      for (uint64_t i = 0; i != v19; ++i)
      {
        if (*(void *)v39 != v20) {
          objc_enumerationMutation(&unk_26F4E1838);
        }
        uint64_t v22 = [(__CFDictionary *)a2 objectForKeyedSubscript:*(void *)(*((void *)&v38 + 1) + 8 * i)];
        if (v22)
        {
          float v23 = (void *)v22;
          if ([v17 length]) {
            [v17 appendString:@"."];
          }
          [v17 appendString:objc_msgSend(NSString, "stringWithFormat:", @"%04X", objc_msgSend(v23, "unsignedIntegerValue"))];
        }
      }
      uint64_t v19 = [&unk_26F4E1838 countByEnumeratingWithState:&v38 objects:buf count:16];
    }
    while (v19);
  }
  uint64_t v24 = *MEMORY[0x263F34110];
  uint64_t v25 = *MEMORY[0x263F34100];
  v42[0] = *MEMORY[0x263F34110];
  v42[1] = v25;
  v43[0] = v34;
  v43[1] = v33;
  uint64_t v26 = *MEMORY[0x263F340F0];
  v42[2] = *MEMORY[0x263F34130];
  v42[3] = v26;
  v43[2] = v35;
  v43[3] = v17;
  uint64_t v27 = *MEMORY[0x263F34108];
  v42[4] = *MEMORY[0x263F340F8];
  v42[5] = v27;
  v43[4] = v32;
  v43[5] = &stru_26F4DBE18;
  double v28 = (void *)[NSDictionary dictionaryWithObjects:v43 forKeys:v42 count:6];
  objc_msgSend((id)objc_msgSend(MEMORY[0x263F340D8], "sharedClient"), "setAccessoryInfo:forEndpointWithUUID:", v28, v36);
  int8x16_t v29 = MTLoggingPlugin();
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v30 = [v28 objectForKeyedSubscript:v24];
    *(_DWORD *)buf = 136316418;
    float v45 = "";
    __int16 v46 = 2080;
    int v47 = "";
    __int16 v48 = 2080;
    CFStringRef v49 = "publishService";
    __int16 v50 = 2114;
    uint64_t v51 = v31;
    __int16 v52 = 2114;
    uint64_t v53 = v30;
    __int16 v54 = 2114;
    float v55 = v14;
    _os_log_impl(&dword_2406FB000, v29, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Publishing device %{public}@ (%{public}@) with connection UUID %{public}@", buf, 0x3Eu);
  }
  objc_msgSend((id)objc_msgSend(MEMORY[0x263F340D8], "sharedClient"), "publishConnectionWithUUID:", v14);
  *((void *)v37 + 5) = CFRetain(v14);
}

unint64_t MTChordTable::areChordFingersContiguous(MTChordTable *this)
{
  return (0xD101D1DFuLL >> (this & 0x1F)) & 1;
}

uint64_t MTChordTable::MTChordTable(uint64_t a1, int a2, uint64_t a3)
{
  *(void *)a1 = &unk_26F4D9448;
  *(_DWORD *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = 8654537;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_OWORD *)(a1 + 60) = 0u;
  *(_OWORD *)(a1 + 76) = 0u;
  *(_OWORD *)(a1 + 92) = 0u;
  *(_OWORD *)(a1 + 108) = 0u;
  *(_OWORD *)(a1 + 124) = 0u;
  *(_OWORD *)(a1 + 140) = 0u;
  *(_OWORD *)(a1 + 156) = 0u;
  *(_OWORD *)(a1 + 172) = 0u;
  *(_OWORD *)(a1 + 188) = 0u;
  *(_OWORD *)(a1 + 204) = 0u;
  *(_OWORD *)(a1 + 220) = 0u;
  *(_OWORD *)(a1 + 236) = 0u;
  *(_OWORD *)(a1 + 252) = 0u;
  *(_DWORD *)(a1 + 364) = 0;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 268) = 0u;
  *(_OWORD *)(a1 + 284) = 0u;
  *(_OWORD *)(a1 + 300) = 0u;
  *(_OWORD *)(a1 + 316) = 0u;
  *(_OWORD *)(a1 + 332) = 0u;
  *(_OWORD *)(a1 + 348) = 0u;
  MTChordTable::clearAllChordsInTable((MTChordTable *)a1);
  return a1;
}

void sub_240712DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  for (uint64_t i = 344; i != 8; i -= 24)
  {
    a10 = (void **)(v10 + i);
    std::vector<MTChordGestureSet>::__destroy_vector::operator()[abi:ne180100](&a10);
  }
  _Unwind_Resume(a1);
}

void MTChordTable::clearAllChordsInTable(MTChordTable *this)
{
  (*(void (**)(MTChordTable *))(*(void *)this + 16))(this);
  for (uint64_t i = 0; i != 14; ++i)
  {
    uint64_t v3 = (char *)this + 24 * i;
    uint64_t v6 = *((void *)v3 + 5);
    uint64_t v5 = v3 + 40;
    uint64_t v4 = v6;
    uint64_t v7 = *(v5 - 1);
    if (v6 != v7)
    {
      do
      {
        v4 -= 240;
        std::allocator<MTChordGestureSet>::destroy[abi:ne180100]((uint64_t)this + 24 * i + 48, v4);
      }
      while (v4 != v7);
    }
    void *v5 = v7;
  }
}

void MTChordTable::~MTChordTable(MTChordTable *this)
{
  *(void *)this = &unk_26F4D9448;
  for (uint64_t i = 344; i != 8; i -= 24)
  {
    uint64_t v3 = (void **)((char *)this + i);
    std::vector<MTChordGestureSet>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
}

{
  uint64_t i;
  void **v3;

  *(void *)this = &unk_26F4D9448;
  for (uint64_t i = 344; i != 8; i -= 24)
  {
    uint64_t v3 = (void **)((char *)this + i);
    std::vector<MTChordGestureSet>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
}

{
  uint64_t i;
  void **v3;

  *(void *)this = &unk_26F4D9448;
  for (uint64_t i = 344; i != 8; i -= 24)
  {
    uint64_t v3 = (void **)((char *)this + i);
    std::vector<MTChordGestureSet>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  MEMORY[0x2455F6CE0](this, 0x10B1C40610187EELL);
}

uint64_t MTChordTable::getFingerMaskForLookup(MTChordTable *this, MTHandStatistics *a2)
{
  int v2 = *((_DWORD *)this + 7);
  uint64_t v3 = (char *)a2 + 296;
  if (v2 == 2) {
    uint64_t v3 = (char *)a2 + 220;
  }
  if (v2 == 1) {
    uint64_t v4 = (unsigned __int16 *)((char *)a2 + 300);
  }
  else {
    uint64_t v4 = (unsigned __int16 *)v3;
  }
  return *v4;
}

uint64_t MTChordTable::fingerComboToChordSpecifier(MTChordTable *this, char a2)
{
  if ((a2 & 0x1F) == 0) {
    return 0;
  }
  v2.i64[0] = 0x100000001;
  v2.i64[1] = 0x100000001;
  unsigned int v3 = vaddvq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(a2), (uint32x4_t)xmmword_24074F430), v2));
  if (a2) {
    return v3 + 5;
  }
  else {
    return v3;
  }
}

char *MTChordTable::getChordVectForCombo(MTChordTable *this, char a2)
{
  if ((a2 & 0x1F) == 0) {
    return (char *)this + 32;
  }
  v2.i64[0] = 0x100000001;
  v2.i64[1] = 0x100000001;
  int v3 = vaddvq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(a2), (uint32x4_t)xmmword_24074F430), v2));
  unsigned int v4 = v3 + 5;
  if ((a2 & 1) == 0) {
    unsigned int v4 = v3;
  }
  if (!v4) {
    return (char *)this + 32;
  }
  uint64_t v5 = (char *)this + 24 * v4;
  uint64_t v7 = *((void *)v5 + 4);
  uint64_t v8 = *((void *)v5 + 5);
  uint64_t v6 = v5 + 32;
  uint64_t v9 = v8 - v7;
  if (!v9)
  {
LABEL_10:
    if (v4 - 5 <= 4)
    {
      uint64_t v15 = (char *)this + 24 * v4 - 96;
      uint64_t v16 = *((void *)v15 + 4);
      uint64_t v17 = *((void *)v15 + 5);
      uint64_t v6 = v15 + 32;
      uint64_t v18 = v17 - v16;
      if (v18)
      {
        uint64_t v19 = 0;
        unint64_t v20 = 0xEEEEEEEEEEEEEEEFLL * (v18 >> 4);
        unsigned int v21 = 1;
        while (1)
        {
          int v22 = *(_DWORD *)(v16 + 240 * v19 + 232);
          if (!v22 || (*((_DWORD *)this + 6) & v22) != 0) {
            break;
          }
          uint64_t v19 = v21;
          BOOL v14 = v20 > v21++;
          if (!v14) {
            return (char *)this + 32;
          }
        }
        return v6;
      }
    }
    return (char *)this + 32;
  }
  uint64_t v10 = 0;
  unint64_t v11 = 0xEEEEEEEEEEEEEEEFLL * (v9 >> 4);
  unsigned int v12 = 1;
  while (1)
  {
    int v13 = *(_DWORD *)(v7 + 240 * v10 + 232);
    if (!v13 || (*((_DWORD *)this + 6) & v13) != 0) {
      return v6;
    }
    uint64_t v10 = v12;
    BOOL v14 = v11 > v12++;
    if (!v14) {
      goto LABEL_10;
    }
  }
}

uint64_t MTChordTable::hasTwoFingerOrientationEvents(MTChordTable *this)
{
  uint64_t v2 = *((void *)this + 10);
  uint64_t v1 = *((void *)this + 11);
  if (v1 == v2) {
    return 0;
  }
  uint64_t v4 = 0;
  unsigned int v5 = 1;
  while (1)
  {
    uint64_t v6 = (MTChordGestureSet *)(v2 + 240 * v4);
    int v7 = *((_DWORD *)v6 + 58);
    if (v7 && (*((_DWORD *)this + 6) & v7) == 0) {
      goto LABEL_7;
    }
    if (MTChordGestureSet::hasEnabledOrientationEvents(v6, this)) {
      return 1;
    }
    uint64_t v2 = *((void *)this + 10);
    uint64_t v1 = *((void *)this + 11);
LABEL_7:
    uint64_t v4 = v5;
    if (0xEEEEEEEEEEEEEEEFLL * ((v1 - v2) >> 4) <= v5++) {
      return 0;
    }
  }
}

uint64_t MTChordTable::getMinThumbSpecificFingerCount(MTChordTable *this)
{
  uint64_t v2 = 6;
  while (1)
  {
    int v3 = (char *)this + 24 * v2;
    uint64_t v6 = *((void *)v3 + 4);
    unsigned int v5 = (uint64_t *)(v3 + 32);
    uint64_t v4 = v6;
    uint64_t v7 = v5[1];
    if (v7 != v6) {
      break;
    }
LABEL_9:
    if (++v2 == 10) {
      return 0;
    }
  }
  uint64_t v8 = 0;
  unsigned int v9 = 1;
  while (1)
  {
    uint64_t v10 = (MTChordGestureSet *)(v4 + 240 * v8);
    int v11 = *((_DWORD *)v10 + 58);
    if (v11 && (*((_DWORD *)this + 6) & v11) == 0) {
      goto LABEL_8;
    }
    if (!MTChordGestureSet::isEmpty(v10)) {
      return (v2 - 4);
    }
    uint64_t v7 = v5[1];
    uint64_t v4 = *v5;
LABEL_8:
    uint64_t v8 = v9;
    if (0xEEEEEEEEEEEEEEEFLL * ((v7 - v4) >> 4) <= v9++) {
      goto LABEL_9;
    }
  }
}

uint64_t MTChordTable::findMatchingChord(MTChordTable *this, char a2, int a3)
{
  ChordVectForCombo = MTChordTable::getChordVectForCombo(this, a2);
  uint64_t v6 = *(void *)ChordVectForCombo;
  uint64_t v7 = *((void *)ChordVectForCombo + 1);
  uint64_t result = 0;
  uint64_t v9 = v7 - v6;
  if (v9)
  {
    unint64_t v10 = 0xEEEEEEEEEEEEEEEFLL * (v9 >> 4);
    float v11 = 3.4028e38;
    uint64_t v12 = 1;
    do
    {
      if (*(void *)(v6 + 160) == *(void *)(v6 + 168)) {
        int v13 = (*(unsigned __int16 *)(v6 + 120) >> 6) & 1;
      }
      else {
        int v13 = 0;
      }
      int v14 = *(_DWORD *)(v6 + 232);
      if (v14) {
        BOOL v15 = (*((_DWORD *)this + 6) & v14) != 0;
      }
      else {
        BOOL v15 = 1;
      }
      int v16 = !v15 | v13 ^ a3;
      if (v11 <= 0.0) {
        uint64_t v17 = result;
      }
      else {
        uint64_t v17 = v6;
      }
      if (v11 <= 0.0) {
        float v18 = v11;
      }
      else {
        float v18 = 0.0;
      }
      if (!v16)
      {
        uint64_t result = v17;
        float v11 = v18;
      }
      v6 += 240;
    }
    while (v10 > v12++);
  }
  return result;
}

MTChordGestureSet *MTChordTable::copyChordIntoTable(MTChordTable *this, MTChordGestureSet *a2)
{
  unsigned int v2 = *((_DWORD *)a2 + 56);
  uint64_t v3 = *((void *)this + 2);
  *((_DWORD *)a2 + 5MTHandMotion::clearHandMotion(this, 1) = *((_DWORD *)this + 2);
  *((void *)a2 + 26) = v3;
  if (v2 <= 0xD)
  {
    uint64_t v4 = (char *)this + 24 * v2;
    uint64_t v6 = (MTChordGestureSet *)*((void *)v4 + 5);
    unint64_t v5 = *((void *)v4 + 6);
    uint64_t v7 = (uint64_t *)(v4 + 40);
    if ((unint64_t)v6 >= v5)
    {
      uint64_t v8 = std::vector<MTChordGestureSet>::__push_back_slow_path<MTChordGestureSet const&>((uint64_t *)this + 3 * v2 + 4, a2);
    }
    else
    {
      MTChordGestureSet::MTChordGestureSet(v6, a2);
      uint64_t v8 = (uint64_t)v6 + 240;
      *uint64_t v7 = (uint64_t)v6 + 240;
    }
    *uint64_t v7 = v8;
    return (MTChordGestureSet *)(v8 - 240);
  }
  return a2;
}

void sub_2407133F4(_Unwind_Exception *a1)
{
  void *v2 = v1;
  _Unwind_Resume(a1);
}

void std::vector<MTChordGestureSet>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  unsigned int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 240;
        std::allocator<MTChordGestureSet>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<MTChordGestureSet>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v8 = (void **)(a2 + 160);
  std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100](&v8);
  uint64_t v3 = *(void **)(a2 + 128);
  if (v3)
  {
    *(void *)(a2 + 136) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a2 + 96);
  if (v4)
  {
    *(void *)(a2 + 104) = v4;
    operator delete(v4);
  }
  unint64_t v5 = *(void **)(a2 + 64);
  if (v5)
  {
    *(void *)(a2 + 72) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *(void **)(a2 + 32);
  if (v6)
  {
    *(void *)(a2 + 40) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v7;
    operator delete(v7);
  }
}

void std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  unsigned int v2 = *a1;
  if (*v2)
  {
    std::vector<MTSlideGesture>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<MTSlideGesture>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void **)(v4 - 160);
      v4 -= 160;
      unint64_t v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 152) = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

uint64_t std::vector<MTChordGestureSet>::__push_back_slow_path<MTChordGestureSet const&>(uint64_t *a1, const MTChordGestureSet *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x111111111111111) {
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xEEEEEEEEEEEEEEEFLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x88888888888888) {
    unint64_t v9 = 0x111111111111111;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTChordGestureSet>>(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  int v13 = v10;
  int v14 = (MTChordGestureSet *)&v10[240 * v4];
  int v16 = &v10[240 * v9];
  MTChordGestureSet::MTChordGestureSet(v14, a2);
  BOOL v15 = (char *)v14 + 240;
  std::vector<MTChordGestureSet>::__swap_out_circular_buffer(a1, &v13);
  uint64_t v11 = a1[1];
  std::__split_buffer<MTChordGestureSet>::~__split_buffer(&v13);
  return v11;
}

void sub_2407136C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

uint64_t std::vector<MTChordGestureSet>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MTChordGestureSet>,std::reverse_iterator<MTChordGestureSet*>,std::reverse_iterator<MTChordGestureSet*>,std::reverse_iterator<MTChordGestureSet*>>((uint64_t)(a1 + 2), a1[1], (const MTChordGestureSet *)a1[1], *a1, (const MTChordGestureSet *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<MTChordGestureSet>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x111111111111112) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(240 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MTChordGestureSet>,std::reverse_iterator<MTChordGestureSet*>,std::reverse_iterator<MTChordGestureSet*>,std::reverse_iterator<MTChordGestureSet*>>(uint64_t a1, uint64_t a2, const MTChordGestureSet *a3, uint64_t a4, const MTChordGestureSet *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + MTHandMotion::clearHandMotion(this, 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  unint64_t v13 = 0xAAAAAAAAAAAAAA00;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    unint64_t v9 = a3;
    do
    {
      unint64_t v9 = (const MTChordGestureSet *)((char *)v9 - 240);
      MTChordGestureSet::MTChordGestureSet((MTChordGestureSet *)(v7 - 240), v9);
      uint64_t v7 = *((void *)&v15 + 1) - 240;
      *((void *)&v15 + 1) -= 240;
    }
    while (v9 != a5);
    uint64_t v10 = v15;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTChordGestureSet>,std::reverse_iterator<MTChordGestureSet*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

void sub_240713844(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTChordGestureSet>,std::reverse_iterator<MTChordGestureSet*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<MTChordGestureSet>,std::reverse_iterator<MTChordGestureSet*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<MTChordGestureSet>,std::reverse_iterator<MTChordGestureSet*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator<MTChordGestureSet>::destroy[abi:ne180100](v3, v1);
      v1 += 240;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<MTChordGestureSet>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<MTChordGestureSet>::clear[abi:ne180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 240;
    std::allocator<MTChordGestureSet>::destroy[abi:ne180100](v4, i - 240);
  }
}

BOOL MTChordCycling::slideGestureOngoing(MTChordCycling *this, double a2)
{
  return *((_DWORD *)this + 158) && *((unsigned char *)this + 672) && *((unsigned char *)this + 675) == 0;
}

BOOL MTGestureConfig::slideOrDragOngoing(MTGestureConfig *this, double a2, int a3)
{
  uint64_t v6 = *((void *)this + 7);
  if (v6 && ((*(uint64_t (**)(uint64_t, double))(*(void *)v6 + 40))(v6, a2) & 1) != 0) {
    return 1;
  }
  uint64_t v8 = (MTTapDragManager *)*((void *)this + 9);

  return MTTapDragManager::shouldSustainDrag(v8, a2, a3);
}

MTChordGestureSet *MTGestureConfig::copyChordIntoHandTable(uint64_t a1, int a2, MTChordGestureSet *a3)
{
  if (a2 == 1 && (uint64_t v3 = *(MTChordTable **)(a1 + 56)) != 0) {
    return MTChordTable::copyChordIntoTable(v3, a3);
  }
  else {
    return a3;
  }
}

uint64_t MTGestureConfig::getChordTableForHand(uint64_t a1, int a2)
{
  if (a2 == 1) {
    return *(void *)(a1 + 56);
  }
  else {
    return 0;
  }
}

void MTGestureConfig::~MTGestureConfig(MTGestureConfig *this)
{
  *(void *)this = &unk_26F4D9488;
  uint64_t v2 = (MTChordTable *)*((void *)this + 7);
  if (v2)
  {
    MTChordTable::clearAllChordsInTable(v2);
    uint64_t v3 = *((void *)this + 7);
    if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
      *((void *)this + 7) = 0;
    }
  }
  uint64_t v4 = *((void *)this + 8);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    *((void *)this + 8) = 0;
  }
  std::__tree<std::__value_type<std::string,std::vector<MTActionEvent>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<MTActionEvent>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<MTActionEvent>>>>::destroy((uint64_t)this + 32, *((void **)this + 5));
  std::__tree<std::__value_type<std::string,MTGestureMotionParams>,std::__map_value_compare<std::string,std::__value_type<std::string,MTGestureMotionParams>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MTGestureMotionParams>>>::destroy((uint64_t)this + 8, *((char **)this + 2));
}

{
  uint64_t vars8;

  MTGestureConfig::~MTGestureConfig(this);

  JUMPOUT(0x2455F6CE0);
}

void MTGestureConfig::clearAllChords(MTGestureConfig *this)
{
  uint64_t v1 = (MTChordTable *)*((void *)this + 7);
  if (v1) {
    MTChordTable::clearAllChordsInTable(v1);
  }
}

void MTGestureConfig::MTGestureConfig(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  a1[2] = 0;
  a1[1] = a1 + 2;
  *a1 = &unk_26F4D9488;
  a1[3] = 0;
  a1[5] = 0;
  a1[4] = a1 + 5;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = a5;
  mtgp_InitUSBKeyNames();
  if ((a2 - 1000) <= 0x3E7) {
    operator new();
  }
  if ((a2 - 2000) <= 0x3E7) {
    operator new();
  }
  operator new();
}

void sub_240713CC4(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v3, 0x10B1C406AFB875BLL);
  std::__tree<std::__value_type<std::string,std::vector<MTActionEvent>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<MTActionEvent>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<MTActionEvent>>>>::destroy(v2, *v5);
  std::__tree<std::__value_type<std::string,MTGestureMotionParams>,std::__map_value_compare<std::string,std::__value_type<std::string,MTGestureMotionParams>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MTGestureMotionParams>>>::destroy(v1, *v4);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::string,MTGestureMotionParams>,std::__map_value_compare<std::string,std::__value_type<std::string,MTGestureMotionParams>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MTGestureMotionParams>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,MTGestureMotionParams>,std::__map_value_compare<std::string,std::__value_type<std::string,MTGestureMotionParams>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MTGestureMotionParams>>>::destroy(a1, *(void *)a2);
    std::__tree<std::__value_type<std::string,MTGestureMotionParams>,std::__map_value_compare<std::string,std::__value_type<std::string,MTGestureMotionParams>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,MTGestureMotionParams>>>::destroy(a1, *((void *)a2 + 1));
    if (a2[55] < 0) {
      operator delete(*((void **)a2 + 4));
    }
    operator delete(a2);
  }
}

void std::__tree<std::__value_type<std::string,std::vector<MTActionEvent>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<MTActionEvent>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<MTActionEvent>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::vector<MTActionEvent>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<MTActionEvent>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<MTActionEvent>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,std::vector<MTActionEvent>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<MTActionEvent>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<MTActionEvent>>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<MTActionEvent>>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<MTActionEvent>>,0>(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

double mtgp_InitUSBKeyNames()
{
  gUSBKeyNames = @"NULL";
  unk_268C8ED80 = @"ErrorRollOver";
  qword_268C8ED88 = @"POSTFail";
  unk_268C8ED90 = @"ErrorUndefined";
  qword_268C8ED98 = @"A";
  unk_268C8EDA0 = @"B";
  qword_268C8EDA8 = @"C";
  unk_268C8EDB0 = @"D";
  qword_268C8EDB8 = @"E";
  unk_268C8EDC0 = @"F";
  qword_268C8EDC8 = @"G";
  unk_268C8EDD0 = @"H";
  qword_268C8EDD8 = @"I";
  unk_268C8EDE0 = @"J";
  qword_268C8EDE8 = @"K";
  unk_268C8EDF0 = @"L";
  qword_268C8EDF8 = @"M";
  unk_268C8EE00 = @"N";
  qword_268C8EE08 = @"O";
  unk_268C8EE10 = @"P";
  qword_268C8EE18 = @"Q";
  unk_268C8EE20 = @"R";
  qword_268C8EE28 = @"S";
  unk_268C8EE30 = @"T";
  qword_268C8EE38 = @"U";
  unk_268C8EE40 = @"V";
  qword_268C8EE48 = @"W";
  unk_268C8EE50 = @"X";
  qword_268C8EE58 = @"Y";
  unk_268C8EE60 = @"Z";
  qword_268C8EE68 = @"1";
  unk_268C8EE70 = @"2";
  qword_268C8EE78 = @"3";
  unk_268C8EE80 = @"4";
  qword_268C8EE88 = @"5";
  unk_268C8EE90 = @"6";
  qword_268C8EE98 = @"7";
  unk_268C8EEA0 = @"8";
  qword_268C8EEA8 = @"9";
  unk_268C8EEB0 = @"0";
  qword_268C8EEB8 = @"Enter";
  unk_268C8EEC0 = @"Escape";
  qword_268C8EEC8 = @"BackSpace";
  unk_268C8EED0 = @"Tab";
  qword_268C8EED8 = @"Space";
  unk_268C8EEE0 = @"-";
  qword_268C8EEE8 = @"=";
  unk_268C8EEF0 = @"[";
  qword_268C8EEF8 = @"]";
  unk_268C8EF00 = @"\\"";
  qword_268C8EF08 = @"#";
  unk_268C8EF10 = @";";
  qword_268C8EF18 = @"'";
  qword_268C8EF28 = @",";
  unk_268C8EF30 = @".";
  qword_268C8EF38 = @"/";
  unk_268C8EF40 = @"CapsLock";
  qword_268C8EF48 = @"F1";
  unk_268C8EF50 = @"F2";
  qword_268C8EF58 = @"F3";
  unk_268C8EF60 = @"F4";
  qword_268C8EF68 = @"F5";
  unk_268C8EF70 = @"F6";
  qword_268C8EF78 = @"F7";
  qword_268C8EF80 = @"F8";
  qword_268C8EF88 = @"F9";
  qword_268C8EF90 = @"F10";
  qword_268C8EF98 = @"F11";
  qword_268C8EFA0 = @"F12";
  qword_268C8EFA8 = @"PrintScreen";
  qword_268C8EFB0 = @"ScrollLock";
  qword_268C8EFB8 = @"Pause";
  qword_268C8EFC0 = @"Insert";
  qword_268C8EFC8 = @"Home";
  qword_268C8EFD0 = @"PageUp";
  qword_268C8EFD8 = @"Delete";
  qword_268C8EFE0 = @"End";
  qword_268C8EFE8 = @"PageDown";
  qword_268C8EFF0 = @"Right";
  qword_268C8EFF8 = @"Left";
  qword_268C8F000 = @"Down";
  qword_268C8F008 = @"Up";
  qword_268C8F010 = @"NumLock";
  qword_268C8F018 = @"Numpad/";
  qword_268C8F020 = @"Numpad*";
  qword_268C8F028 = @"Numpad-";
  qword_268C8F030 = @"Numpad+";
  qword_268C8F038 = @"NumpadEnter";
  qword_268C8F040 = @"Numpad1";
  qword_268C8F048 = @"Numpad2";
  qword_268C8F050 = @"Numpad3";
  qword_268C8F058 = @"Numpad4";
  qword_268C8F060 = @"Numpad5";
  qword_268C8F068 = @"Numpad6";
  qword_268C8F070 = @"Numpad7";
  qword_268C8F078 = @"Numpad8";
  qword_268C8F080 = @"Numpad9";
  qword_268C8F088 = @"Numpad0";
  qword_268C8F090 = @"Numpad.";
  qword_268C8F098 = @"NonUS\\|";
  qword_268C8F0A0 = @"Application";
  qword_268C8F0A8 = @"Power";
  qword_268C8F0B0 = @"Keypad=";
  qword_268C8F0B8 = @"F13";
  qword_268C8F0C0 = @"F14";
  qword_268C8F0C8 = @"F15";
  qword_268C8F0D0 = @"F16";
  qword_268C8F0D8 = @"F17";
  qword_268C8F0E0 = @"F18";
  qword_268C8F0E8 = @"F19";
  qword_268C8F0F0 = @"F20";
  qword_268C8F0F8 = @"F21";
  qword_268C8F100 = @"F22";
  qword_268C8F108 = @"F23";
  qword_268C8F110 = @"F24";
  qword_268C8F118 = @"Execute";
  qword_268C8F120 = @"Help";
  qword_268C8F128 = @"Menu";
  qword_268C8F130 = @"Select";
  qword_268C8F138 = @"Stop";
  qword_268C8F140 = @"Again";
  qword_268C8F148 = @"Undo";
  qword_268C8F150 = @"Cut";
  qword_268C8F158 = @"Copy";
  qword_268C8F160 = @"Paste";
  qword_268C8F168 = @"Find";
  qword_268C8F170 = @"Mute";
  qword_268C8F178 = @"VolumeUp";
  qword_268C8F180 = @"VolumeDown";
  qword_268C8F188 = @"LockingCapsLock";
  qword_268C8F190 = @"LockingNumLock";
  qword_268C8F198 = @"LockingScrollLock";
  qword_268C8F1A0 = @"Keypad,";
  qword_268C8F1A8 = @"Keypad=";
  qword_268C8F1B0 = @"International1";
  qword_268C8F1B8 = @"International2";
  qword_268C8F1C0 = @"International3";
  qword_268C8F1C8 = @"International4";
  qword_268C8F1D0 = @"International5";
  qword_268C8F1D8 = @"International6";
  qword_268C8F1E0 = @"International7";
  qword_268C8F1E8 = @"International8";
  qword_268C8F1F0 = @"International9";
  qword_268C8F1F8 = @"LANG1";
  qword_268C8F200 = @"LANG2";
  qword_268C8F208 = @"LANG3";
  qword_268C8F210 = @"LANG4";
  qword_268C8F218 = @"LANG5";
  qword_268C8F220 = @"LANG6";
  qword_268C8F228 = @"LANG7";
  qword_268C8F230 = @"LANG8";
  qword_268C8F238 = @"LANG9";
  qword_268C8F240 = @"AlternateErase";
  qword_268C8F248 = @"SysReq_Attention";
  qword_268C8F250 = @"Cancel";
  qword_268C8F258 = @"Clear";
  qword_268C8F260 = @"Prior";
  qword_268C8F268 = @"Return";
  qword_268C8F270 = @"Separator";
  qword_268C8F278 = @"Out";
  qword_268C8F280 = @"Oper";
  qword_268C8F288 = @"Clear_Again";
  qword_268C8F290 = @"CrSel_Props";
  qword_268C8F298 = @"ExSel";
  qword_268C8F470 = 0;
  double result = 0.0;
  xmmword_268C8F450 = 0u;
  unk_268C8F460 = 0u;
  xmmword_268C8F430 = 0u;
  unk_268C8F440 = 0u;
  xmmword_268C8F410 = 0u;
  unk_268C8F420 = 0u;
  xmmword_268C8F3F0 = 0u;
  unk_268C8F400 = 0u;
  xmmword_268C8F3D0 = 0u;
  unk_268C8F3E0 = 0u;
  xmmword_268C8F3B0 = 0u;
  unk_268C8F3C0 = 0u;
  xmmword_268C8F390 = 0u;
  unk_268C8F3A0 = 0u;
  xmmword_268C8F370 = 0u;
  unk_268C8F380 = 0u;
  xmmword_268C8F350 = 0u;
  unk_268C8F360 = 0u;
  xmmword_268C8F330 = 0u;
  unk_268C8F340 = 0u;
  xmmword_268C8F310 = 0u;
  unk_268C8F320 = 0u;
  xmmword_268C8F2F0 = 0u;
  unk_268C8F300 = 0u;
  xmmword_268C8F2D0 = 0u;
  unk_268C8F2E0 = 0u;
  xmmword_268C8F2B0 = 0u;
  unk_268C8F2C0 = 0u;
  xmmword_268C8F2A0 = 0u;
  qword_268C8F478 = @"LeftCtrl";
  qword_268C8F480 = @"LeftShift";
  qword_268C8F488 = @"LeftAlt";
  qword_268C8F490 = @"LeftGUI";
  qword_268C8F498 = @"RightCtrl";
  qword_268C8F4A0 = @"RightShift";
  qword_268C8F4A8 = @"RightAlt";
  qword_268C8F4B0 = @"RightGUI";
  xmmword_268C8F4B8 = 0u;
  xmmword_268C8F4C8 = 0u;
  xmmword_268C8F4D8 = 0u;
  xmmword_268C8F4E8 = 0u;
  xmmword_268C8F4F8 = 0u;
  xmmword_268C8F508 = 0u;
  xmmword_268C8F518 = 0u;
  xmmword_268C8F528 = 0u;
  xmmword_268C8F538 = 0u;
  xmmword_268C8F548 = 0u;
  xmmword_268C8F558 = 0u;
  xmmword_268C8F568 = 0u;
  return result;
}

uint64_t MTAppendGestureStartedToCollectionEvent()
{
  return 0;
}

uint64_t MTAppendGestureEndedToCollectionEvent()
{
  return 0;
}

uint64_t MTAppendChordMotionCodeToCollectionEvent()
{
  return 0;
}

uint64_t MTAppendAbsoluteMouseEvent()
{
  return 0;
}

uint64_t MTAppendRelativeMouseEvent()
{
  mach_absolute_time();
  uint64_t MouseEvent = IOHIDEventCreateMouseEvent();
  if (MouseEvent)
  {
    uint64_t v1 = (const void *)MouseEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendMouseButtonEvent()
{
  mach_absolute_time();
  uint64_t ButtonEvent = IOHIDEventCreateButtonEvent();
  if (ButtonEvent)
  {
    uint64_t v1 = (const void *)ButtonEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendVelocityEvent()
{
  mach_absolute_time();
  uint64_t VelocityEvent = IOHIDEventCreateVelocityEvent();
  if (VelocityEvent)
  {
    uint64_t v1 = (const void *)VelocityEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendTranslationEvent(uint64_t a1, int a2)
{
  mach_absolute_time();
  uint64_t TranslationEvent = IOHIDEventCreateTranslationEvent();
  uint64_t v4 = (const void *)TranslationEvent;
  if (a2 <= 15)
  {
    if (a2 != 2)
    {
      if (a2 == 8)
      {
        if (!TranslationEvent) {
          return 0;
        }
        goto LABEL_15;
      }
LABEL_10:
      if (!TranslationEvent) {
        return 0;
      }
      goto LABEL_15;
    }
    if (!TranslationEvent) {
      return 0;
    }
    goto LABEL_15;
  }
  if (a2 != 16)
  {
    if (a2 == 32)
    {
      if (!TranslationEvent) {
        return 0;
      }
      goto LABEL_15;
    }
    goto LABEL_10;
  }
  if (TranslationEvent)
  {
LABEL_15:
    IOHIDEventSetPhase();
    IOHIDEventAppendEvent();
    CFRelease(v4);
  }
  return 0;
}

uint64_t MTAppendFluidSwipeEvent(double a1, float a2, uint64_t a3, int a4)
{
  switch(a4)
  {
    case 27:
      mach_absolute_time();
      uint64_t FluidTouchGestureEvent = IOHIDEventCreateFluidTouchGestureEvent();
      break;
    case 23:
      mach_absolute_time();
      uint64_t FluidTouchGestureEvent = IOHIDEventCreateDockSwipeEvent();
      break;
    case 16:
      mach_absolute_time();
      uint64_t FluidTouchGestureEvent = IOHIDEventCreateNavigationSwipeEvent();
      break;
    default:
      return 0;
  }
  uint64_t v6 = (const void *)FluidTouchGestureEvent;
  if (FluidTouchGestureEvent)
  {
    IOHIDEventSetPhase();
    if (a2 != 0.0) {
      MTAppendVelocityEvent();
    }
    IOHIDEventAppendEvent();
    CFRelease(v6);
  }
  return 0;
}

uint64_t MTAppendSwipeEvent()
{
  mach_absolute_time();
  uint64_t SwipeEvent = IOHIDEventCreateSwipeEvent();
  if (SwipeEvent)
  {
    uint64_t v1 = (const void *)SwipeEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendForceGestureEvent()
{
  if (!IOHIDEventGetIntegerValue()) {
    return 3758097090;
  }
  mach_absolute_time();
  uint64_t result = IOHIDEventCreateForceEvent();
  if (result)
  {
    uint64_t v1 = (const void *)result;
    IOHIDEventSetPhase();
    IOHIDEventAppendEvent();
    CFRelease(v1);
    return 0;
  }
  return result;
}

uint64_t MTAppendKeyboardEvent()
{
  mach_absolute_time();
  uint64_t KeyboardEvent = IOHIDEventCreateKeyboardEvent();
  if (KeyboardEvent)
  {
    uint64_t v1 = (const void *)KeyboardEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendKeystrokeEvent()
{
  return 0;
}

uint64_t MTAppendModifierKeyEvent(uint64_t a1, char a2)
{
  if ((a2 & 2) != 0)
  {
    MTAppendKeyboardEvent();
    if ((a2 & 1) == 0)
    {
LABEL_3:
      if ((a2 & 4) == 0) {
        goto LABEL_4;
      }
LABEL_9:
      MTAppendKeyboardEvent();
      if ((a2 & 8) == 0) {
        return 0;
      }
      goto LABEL_5;
    }
  }
  else if ((a2 & 1) == 0)
  {
    goto LABEL_3;
  }
  MTAppendKeyboardEvent();
  if ((a2 & 4) != 0) {
    goto LABEL_9;
  }
LABEL_4:
  if ((a2 & 8) != 0) {
LABEL_5:
  }
    MTAppendKeyboardEvent();
  return 0;
}

uint64_t MTAppendZoomToggleEvent()
{
  mach_absolute_time();
  uint64_t ZoomToggleEvent = IOHIDEventCreateZoomToggleEvent();
  if (ZoomToggleEvent)
  {
    uint64_t v1 = (const void *)ZoomToggleEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendShowDefinitionEvent()
{
  mach_absolute_time();
  uint64_t SymbolicHotKeyEvent = IOHIDEventCreateSymbolicHotKeyEvent();
  if (SymbolicHotKeyEvent)
  {
    uint64_t v1 = (const void *)SymbolicHotKeyEvent;
    IOHIDEventSetPhase();
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendBoundaryScrollEvent()
{
  mach_absolute_time();
  uint64_t BoundaryScrollEvent = IOHIDEventCreateBoundaryScrollEvent();
  if (BoundaryScrollEvent)
  {
    uint64_t v1 = (const void *)BoundaryScrollEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendScrollEvent()
{
  mach_absolute_time();
  uint64_t ScrollEvent = IOHIDEventCreateScrollEvent();
  if (ScrollEvent)
  {
    uint64_t v1 = (const void *)ScrollEvent;
    IOHIDEventSetPhase();
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendMomentumEnableEvent()
{
  mach_absolute_time();
  uint64_t VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
  if (VendorDefinedEvent)
  {
    uint64_t v1 = (const void *)VendorDefinedEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  return 0;
}

uint64_t MTAppendOrientationEvent()
{
  mach_absolute_time();
  uint64_t PolarOrientationEvent = IOHIDEventCreatePolarOrientationEvent();
  if (PolarOrientationEvent)
  {
    uint64_t v1 = (const void *)PolarOrientationEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
  mach_absolute_time();
  uint64_t v2 = IOHIDEventCreatePolarOrientationEvent();
  if (v2)
  {
    uint64_t v3 = (const void *)v2;
    IOHIDEventSetPhase();
    IOHIDEventAppendEvent();
    CFRelease(v3);
  }
  return 0;
}

uint64_t MTAppendOrientationEventWithTranslation(uint64_t a1, int a2)
{
  mach_absolute_time();
  uint64_t PolarOrientationEvent = IOHIDEventCreatePolarOrientationEvent();
  if (PolarOrientationEvent)
  {
    uint64_t v4 = (const void *)PolarOrientationEvent;
    IOHIDEventAppendEvent();
    CFRelease(v4);
  }
  mach_absolute_time();
  uint64_t v5 = IOHIDEventCreatePolarOrientationEvent();
  if (v5)
  {
    uint64_t v6 = (const void *)v5;
    IOHIDEventSetPhase();
    MTAppendTranslationEvent((uint64_t)v6, a2);
    IOHIDEventAppendEvent();
    CFRelease(v6);
  }
  return 0;
}

uint64_t MTAppendZoomRotateTranslateEvent(double a1, double a2, float a3, uint64_t a4, int a5, int a6, int a7, int a8, int a9)
{
  if (a3 <= 0.0)
  {
    BOOL v9 = a5 == 16 || a5 == 32;
    goto LABEL_13;
  }
  BOOL v9 = a5 == 16 || a5 == 32;
  if ((float)((float)a7 / a3) == 0.0)
  {
LABEL_13:
    if (MTAppendZoomRotateTranslateEvent_rotate_in_progress) {
      int v10 = v9;
    }
    else {
      int v10 = 0;
    }
    if (!a6) {
      goto LABEL_7;
    }
    goto LABEL_17;
  }
  int v10 = 1;
  if (!a6)
  {
LABEL_7:
    if (MTAppendZoomRotateTranslateEvent_zoom_in_progress) {
      int v11 = v9;
    }
    else {
      int v11 = 0;
    }
    goto LABEL_18;
  }
LABEL_17:
  int v11 = 1;
LABEL_18:
  if (a9 | a8)
  {
    int v12 = 1;
  }
  else if (MTAppendZoomRotateTranslateEvent_translate_in_progress)
  {
    int v12 = v9;
  }
  else
  {
    int v12 = 0;
  }
  if (v10)
  {
    mach_absolute_time();
    uint64_t RotationEvent = IOHIDEventCreateRotationEvent();
    if (RotationEvent)
    {
      long long v14 = (const void *)RotationEvent;
      IOHIDEventSetPhase();
      IOHIDEventAppendEvent();
      CFRelease(v14);
      MTAppendZoomRotateTranslateEvent_rotate_in_progress = !v9;
    }
  }
  if (v11)
  {
    mach_absolute_time();
    uint64_t ScaleEvent = IOHIDEventCreateScaleEvent();
    if (ScaleEvent)
    {
      int v16 = (const void *)ScaleEvent;
      IOHIDEventSetPhase();
      IOHIDEventAppendEvent();
      CFRelease(v16);
      MTAppendZoomRotateTranslateEvent_zoom_in_progress = !v9;
    }
  }
  if (v12)
  {
    mach_absolute_time();
    uint64_t TranslationEvent = IOHIDEventCreateTranslationEvent();
    if (TranslationEvent)
    {
      float v18 = (const void *)TranslationEvent;
      IOHIDEventSetPhase();
      IOHIDEventAppendEvent();
      CFRelease(v18);
      MTAppendZoomRotateTranslateEvent_translate_in_progress = !v9;
    }
  }
  return 0;
}

float MTHIDGetFullScalePixelDistance()
{
  return 500.0;
}

void MTSimpleEmbeddedHIDManagerV2::createManager()
{
}

void sub_2407158C8(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10A1C40E945ADD8);
  _Unwind_Resume(a1);
}

void MTSimpleEmbeddedHIDManagerV2::setDeviceDefaultProperties(MTSimpleEmbeddedHIDManagerV2 *this)
{
  (*(void (**)(MTSimpleEmbeddedHIDManagerV2 *))(*(void *)this + 80))(this);
  io_registry_entry_t Service = MTDeviceGetService();
  if (Service)
  {
    CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(Service, @"PhysicalDeviceUniqueID", (CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
    if (CFProperty)
    {
      uint64_t v4 = CFProperty;
      CFTypeID v5 = CFGetTypeID(CFProperty);
      if (v5 == CFStringGetTypeID()) {
        (*(void (**)(MTSimpleEmbeddedHIDManagerV2 *, __CFString *, const void *))(*(void *)this + 568))(this, @"PhysicalDeviceUniqueID", v4);
      }
      CFRelease(v4);
    }
  }

  MTSimpleHIDManager::setDeviceDefaultProperties(this);
}

uint64_t MTSimpleEmbeddedHIDManagerV2::setPowerState()
{
  return 0;
}

uint64_t MTSimpleEmbeddedHIDManagerV2::setInputDetectionModeForOrientation(MTSimpleEmbeddedHIDManagerV2 *this)
{
  return 0;
}

uint64_t MTSimpleEmbeddedHIDManagerV2::setTouchMode(MTSimpleEmbeddedHIDManagerV2 *this)
{
  return 0;
}

uint64_t MTSimpleEmbeddedHIDManagerV2::setOrientation(MTSimpleEmbeddedHIDManagerV2 *this)
{
  return 0;
}

const char *MTSimpleEmbeddedHIDManagerV2::getName(MTSimpleEmbeddedHIDManagerV2 *this)
{
  return "MTSimpleEmbeddedHIDManagerV2";
}

void MTSimpleEmbeddedHIDManagerV2::~MTSimpleEmbeddedHIDManagerV2(MTSimpleEmbeddedHIDManagerV2 *this)
{
  MTSimpleHIDManager::~MTSimpleHIDManager(this);

  JUMPOUT(0x2455F6CE0);
}

uint64_t MTSimpleEmbeddedHIDManagerV2::setPowerStateWithReset()
{
  return 0;
}

void MTActionEvent::MTActionEvent(MTActionEvent *this)
{
  *(void *)this = 0;
}

{
  *(void *)this = 0;
}

void MTActionEvent::MTActionEvent(MTActionEvent *this, __int16 a2, int a3, __int16 a4)
{
  *(_WORD *)this = a2;
  *((_WORD *)this + MTHandMotion::clearHandMotion(this, 1) = a4;
  *((_DWORD *)this + MTHandMotion::clearHandMotion(this, 1) = a3;
}

{
  *(_WORD *)this = a2;
  *((_WORD *)this + MTHandMotion::clearHandMotion(this, 1) = a4;
  *((_DWORD *)this + MTHandMotion::clearHandMotion(this, 1) = a3;
}

void MTActionEvent::MTActionEvent(MTActionEvent *this, const MTActionEvent *a2)
{
  *(_DWORD *)this = *(_DWORD *)a2;
  *((_DWORD *)this + MTHandMotion::clearHandMotion(this, 1) = *((_DWORD *)a2 + 1);
}

{
  *(_DWORD *)this = *(_DWORD *)a2;
  *((_DWORD *)this + MTHandMotion::clearHandMotion(this, 1) = *((_DWORD *)a2 + 1);
}

_DWORD *MTActionEvent::operator=(_DWORD *result, _DWORD *a2)
{
  if (result != a2)
  {
    *uint64_t result = *a2;
    result[1] = a2[1];
  }
  return result;
}

uint64_t MTActionEvent::getModifierMaskFromKeyCode(MTActionEvent *this)
{
  if ((*((_WORD *)this + 1) & 0xFFF8) == 0xE0) {
    return (1 << *((_WORD *)this + 1));
  }
  else {
    return 0;
  }
}

uint64_t MTActionEvent::deriveGestureStartedType(MTActionEvent *this)
{
  if ((*(_WORD *)this & 0xFFFE) == 0x46) {
    return 33;
  }
  else {
    return 0;
  }
}

uint64_t MTActionEvent::deriveGestureEndedType(MTActionEvent *this)
{
  return 32 * ((*(_WORD *)this & 0xFFFE) == 70);
}

uint64_t MTActionEvent::deriveFluidIOHIDEventType(MTActionEvent *this)
{
  int v1 = *(unsigned __int16 *)this;
  if ((v1 - 36) < 3) {
    return dword_24074F4DC[(__int16)(v1 - 36)];
  }
  if (v1 == 39) {
    return 27;
  }
  return 0;
}

uint64_t MTActionEvent::deriveFlavorForFluidIOHIDEventType(MTActionEvent *this)
{
  int v1 = *(unsigned __int16 *)this;
  unsigned int v2 = v1 - 37;
  if (v1 == 36) {
    char v3 = 5;
  }
  else {
    char v3 = 0;
  }
  if (v2 < 3) {
    char v3 = 0x200010003uLL >> (16 * v2);
  }
  return v3 & 7;
}

void MTDragManagerEventQueue::MTDragManagerEventQueue(MTDragManagerEventQueue *this)
{
  MTTapDragManager::MTTapDragManager(this);
  *(void *)uint64_t v1 = &unk_26F4D9760;
  *(void *)(v1 + 104) = 0;
  *(_DWORD *)(v1 + 112) = 0;
}

{
  uint64_t v1;

  MTTapDragManager::MTTapDragManager(this);
  *(void *)uint64_t v1 = &unk_26F4D9760;
  *(void *)(v1 + 104) = 0;
  *(_DWORD *)(v1 + 112) = 0;
}

uint64_t MTDragManagerEventQueue::dispatchModifierUpdates(uint64_t result, uint64_t a2, int a3, int a4, unsigned int a5, int a6)
{
  if (a5 <= 0xF)
  {
    unsigned int v7 = a5;
    uint64_t v11 = result;
    do
    {
      int v12 = 1 << v7;
      if (((1 << v7) & a3) != 0)
      {
        if (a4) {
          int v13 = *(_DWORD *)(v11 + 108) & ~v12;
        }
        else {
          int v13 = *(_DWORD *)(v11 + 108) | v12;
        }
        *(_DWORD *)(v11 + 108) = v13;
        if (v7 > 7) {
          uint64_t result = MTAppendMouseButtonEvent();
        }
        else {
          uint64_t result = MTAppendModifierKeyEvent(a2, v12);
        }
      }
      v7 += a6;
    }
    while (v7 < 0x10);
  }
  return result;
}

uint64_t MTDragManagerEventQueue::autoInsertModifierEvents(uint64_t result, uint64_t a2, unsigned __int16 *a3, int a4)
{
  uint64_t v5 = result;
  if (!a3)
  {
    int v10 = (_DWORD *)(result + 104);
    int v8 = *(_DWORD *)(result + 112);
    if (!((unsigned __int16)v8 | *(_WORD *)(result + 104))) {
      return result;
    }
    int v11 = 0;
    int v12 = (v8 | *(_DWORD *)(result + 104)) & ~a4;
    goto LABEL_15;
  }
  int v6 = *((_DWORD *)a3 + 1);
  int v7 = *a3;
  if ((v7 - 129) <= 1)
  {
    int v8 = 0;
    int v9 = 1 << a3[1];
    if ((a3[1] & 0xFFF8) != 0xE0) {
      int v9 = 0;
    }
    if (v7 != 130) {
      goto LABEL_12;
    }
LABEL_10:
    int v13 = 0;
    int v14 = *(_DWORD *)(result + 112);
    int v15 = *(_DWORD *)(result + 108) & ~v9;
    *(_DWORD *)(result + 108) = v15;
    int v8 = v14 & ~v9;
    int v16 = ~v15;
    int v12 = v6;
    goto LABEL_13;
  }
  int v9 = 0;
  if (v7 == 66) {
    goto LABEL_10;
  }
  int v8 = *((_DWORD *)a3 + 1);
LABEL_12:
  int v17 = *(_DWORD *)(result + 112);
  int v18 = *(_DWORD *)(result + 108) | v9;
  *(_DWORD *)(result + 108) = v18;
  int v16 = ~v18;
  int v13 = v6 & ~v18;
  int v12 = v17 & ~(v9 | v6);
LABEL_13:
  int v11 = v16 & a4 | v13;
  if (!v9)
  {
    int v10 = (_DWORD *)(result + 104);
    v12 |= *(_DWORD *)(result + 104) & ~(v6 | a4);
LABEL_15:
    *int v10 = a4;
  }
  *(_DWORD *)(result + 112) = v8 & ~v12;
  if ((_WORD)v12) {
    uint64_t result = MTDragManagerEventQueue::dispatchModifierUpdates(result, a2, v12, 1, 0xFu, -1);
  }
  if ((_WORD)v11)
  {
    return MTDragManagerEventQueue::dispatchModifierUpdates(v5, a2, v11, 0, 0, 1);
  }
  return result;
}

uint64_t MTDragManagerEventQueue::dispatchFluid(uint64_t a1, unsigned __int16 *a2, uint64_t a3, float a4, float a5)
{
  int v10 = *(MTForceManagement **)(a1 + 16);
  if (!v10 || !MTForceManagement::whichForceButtonActivated(v10)) {
    MTDragManagerEventQueue::autoInsertModifierEvents(a1, a3, a2, 0);
  }
  int v12 = 27;
  int v13 = 16;
  switch(*a2)
  {
    case '$':
      goto LABEL_7;
    case '%':
      int v12 = 23;
      break;
    case '&':
    case '\'':
      break;
    default:
      int v13 = 0;
LABEL_7:
      int v12 = v13;
      break;
  }
  *(float *)&double v11 = a4;

  return MTAppendFluidSwipeEvent(v11, a5, a3, v12);
}

uint64_t MTDragManagerEventQueue::dispatch(MTTapDragManager *a1, unsigned __int16 *a2, uint64_t a3, int a4, int *a5, float *a6)
{
  int v12 = MTTapDragManager::dragHandModifiers(a1);
  MTAppendChordMotionCodeToCollectionEvent();
  uint64_t result = MTDragManagerEventQueue::autoInsertModifierEvents((uint64_t)a1, a3, a2, v12);
  int v16 = *a2;
  if (v16 == 32)
  {
    return MTAppendGestureEndedToCollectionEvent();
  }
  if (v16 == 33)
  {
    return MTAppendGestureStartedToCollectionEvent();
  }
  if ((v16 - 35) <= 4)
  {
    int v17 = 27;
    int v18 = 16;
    switch(*a2)
    {
      case '$':
        goto LABEL_24;
      case '%':
        int v17 = 23;
        break;
      case '&':
      case '\'':
        break;
      default:
        int v18 = 0;
LABEL_24:
        int v17 = v18;
        break;
    }
    return MTAppendFluidSwipeEvent(0.0, 0.0, a3, v17);
  }
  if ((v16 & 0x80) != 0)
  {
    switch(*a2)
    {
      case 0x81u:
      case 0x82u:
        uint64_t result = MTAppendKeyboardEvent();
        break;
      case 0x85u:
        uint64_t result = MTAppendSwipeEvent();
        break;
      case 0x86u:
        return result;
      case 0x8Cu:
        uint64_t result = MTAppendShowDefinitionEvent();
        break;
      default:
        uint64_t result = MTAppendKeystrokeEvent();
        break;
    }
    return result;
  }
  if ((v16 & 0x40) == 0 || (v16 - 65) < 2) {
    return result;
  }
  switch(v16)
  {
    case 'I':
      return MTAppendZoomToggleEvent();
    case 'H':
      unsigned __int16 v27 = a2[1];
      int v28 = *((_DWORD *)a1 + 27);
      unsigned __int16 v26 = 66;
      MTDragManagerEventQueue::autoInsertModifierEvents((uint64_t)a1, a3, &v26, v12);
      unsigned __int16 v26 = 65;
      MTDragManagerEventQueue::autoInsertModifierEvents((uint64_t)a1, a3, &v26, v12);
      unsigned __int16 v26 = 66;
      return MTDragManagerEventQueue::autoInsertModifierEvents((uint64_t)a1, a3, &v26, v12);
    case 'C':
      unsigned __int16 v27 = a2[1];
      int v28 = *((_DWORD *)a1 + 27);
      unsigned __int16 v26 = 66;
      return MTDragManagerEventQueue::autoInsertModifierEvents((uint64_t)a1, a3, &v26, v12);
  }
  if ((~v16 & 0x44) != 0) {
    return result;
  }
  if (!a5)
  {
    if (!a4) {
      return result;
    }
    if (v16 == 71)
    {
      *(float *)&double v14 = *a6;
      *(float *)&double v15 = a6[1];
      float v23 = a6[2];
      uint64_t v24 = a3;
      int v25 = a4;
      int v19 = 0;
      int v20 = 0;
      int v21 = 0;
      int v22 = 0;
      goto LABEL_62;
    }
    if (v16 != 70) {
      return result;
    }
    goto LABEL_52;
  }
  switch(v16)
  {
    case 'F':
LABEL_52:
      return MTAppendScrollEvent();
    case 'N':
      return MTAppendBoundaryScrollEvent();
    case 'G':
      int v19 = a5[2];
      int v20 = a5[3];
      int v21 = *a5;
      int v22 = a5[1];
      *(float *)&double v14 = *a6;
      *(float *)&double v15 = a6[1];
      float v23 = a6[2];
      uint64_t v24 = a3;
      int v25 = a4;
LABEL_62:
      return MTAppendZoomRotateTranslateEvent(v14, v15, v23, v24, v25, v19, v20, v21, v22);
    default:
      return MTAppendRelativeMouseEvent();
  }
}

uint64_t MTGesture::dispatchEvents(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  uint64_t v9 = *a1;
  if (a1[1] == *a1) {
    return 0;
  }
  uint64_t result = 0;
  unsigned int v20 = 0;
  do
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, double))(*(void *)a2 + 24))(a2, v9 + 8 * result, a3, a4, a5, a6, a7, a8, a9);
    uint64_t v9 = *a1;
    uint64_t result = ++v20;
  }
  while (v20 < (unint64_t)((a1[1] - *a1) >> 3));
  return result;
}

uint64_t MTDragManagerEventQueue::enableAutoReleaseOfMultiFingerDrag(uint64_t this)
{
  if (*(unsigned char *)(this + 109)) {
    *(_DWORD *)(this + 104) |= 0x100u;
  }
  return this;
}

uint64_t MTDragManagerEventQueue::forceButtonChange(uint64_t a1, uint64_t a2)
{
  int v4 = MTTapDragManager::dragHandModifiers((MTTapDragManager *)a1);
  uint64_t v6 = 0;
  MTDragManagerEventQueue::autoInsertModifierEvents(a1, a2, (unsigned __int16 *)&v6, v4);
  uint64_t result = (**(uint64_t (***)(uint64_t))a1)(a1);
  if (result)
  {
    if (*(int *)(a1 + 24) >= 2) {
      *(unsigned char *)(a1 + 9) = 1;
    }
  }
  return result;
}

uint64_t MTDragManagerEventQueue::ready2autoReleaseModifiers(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 112) | *(_DWORD *)(a1 + 104)) {
    return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a3) ^ 1;
  }
  else {
    return 0;
  }
}

uint64_t MTDragManagerEventQueue::serviceEventQueue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  if (*(_DWORD *)(a1 + 24) == 1) {
    return MTTapDragManager::sendWaitingClickAtHalfTimeout(a1, a2, a4, a5) ^ 1;
  }
  if (*(_DWORD *)(a1 + 108)
    && *(_DWORD *)(a1 + 112) | *(_DWORD *)(a1 + 104)
    && ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3, a4) & 1) == 0)
  {
    MTDragManagerEventQueue::autoInsertModifierEvents(a1, a2, 0, 0);
    if (((**(uint64_t (***)(uint64_t))a1)(a1) & 1) == 0) {
      MTTapDragManager::clearCycle(a1);
    }
  }
  return *(_DWORD *)(a1 + 108) != 0;
}

uint64_t MTDragManagerEventQueue::startMomentum(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)(a1 + 1268) = a3;
  *(unsigned char *)(a1 + 1264) = 1;
  return MTAppendMomentumEnableEvent();
}

uint64_t MTDragManagerEventQueue::stopMomentum(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)(a1 + 1268) = a3;
  *(unsigned char *)(a1 + 1264) = 0;
  return MTAppendMomentumEnableEvent();
}

uint64_t MTDragManagerEventQueue::isButton1Pending(MTDragManagerEventQueue *this)
{
  return *((unsigned char *)this + 109) & 1;
}

uint64_t MTDragManagerEventQueue::getLastModifiersFromHand(MTDragManagerEventQueue *this)
{
  return *((unsigned int *)this + 26);
}

void MTTrackpadEmbeddedHIDManager::createManager()
{
}

void sub_2407168B0(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10A1C40397AE834);
  _Unwind_Resume(a1);
}

uint64_t MTTrackpadEmbeddedHIDManager::initialize(MTModeSwitcher *a1, uint64_t a2, CFTypeRef cf, int a4, int a5)
{
  *((unsigned char *)a1 + 354) = 0;
  *((_WORD *)a1 + 176) = 0;
  *((_DWORD *)a1 + 89) = 0;
  return MTTrackpadHIDManager::initialize(a1, a2, cf, a4, a5);
}

void MTTrackpadEmbeddedHIDManager::finalize(MTTrackpadEmbeddedHIDManager *this)
{
  unsigned int v2 = (unsigned int *)*((void *)this + 45);
  if (v2)
  {
    MTPowerLogger::release(v2);
    *((void *)this + 45) = 0;
  }

  MTTrackpadHIDManager::finalize(this);
}

void MTTrackpadEmbeddedHIDManager::createEventDispatcher(MTTrackpadEmbeddedHIDManager *this)
{
}

const void *MTTrackpadEmbeddedHIDManager::setDeviceAccelerationData(MTTrackpadEmbeddedHIDManager *this, CFDictionaryRef theDict)
{
  uint64_t Value = CFDictionaryGetValue(theDict, @"HIDPointerAccelerationMultiplier");
  if (Value) {
    (*(void (**)(MTTrackpadEmbeddedHIDManager *, __CFString *, const void *))(*(void *)this + 568))(this, @"HIDPointerAccelerationMultiplier", Value);
  }

  return MTTrackpadHIDManager::setDeviceAccelerationData(this, theDict);
}

void MTTrackpadEmbeddedHIDManager::setPluginDefaultProperties(MTTrackpadEmbeddedHIDManager *this)
{
  MTTrackpadHIDManager::setPluginDefaultProperties(this);
  if ((*(uint64_t (**)(MTTrackpadEmbeddedHIDManager *))(*(void *)this + 80))(this))
  {
    io_registry_entry_t Service = MTDeviceGetService();
    if (Service)
    {
      CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(Service, @"NeedsHostState", (CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
      if (CFProperty)
      {
        int v4 = CFProperty;
        CFTypeID v5 = CFGetTypeID(CFProperty);
        if (v5 == CFBooleanGetTypeID())
        {
          (*(void (**)(MTTrackpadEmbeddedHIDManager *, __CFString *, const void *))(*(void *)this + 568))(this, @"NeedsHostState", v4);
          if (v4 == (const void *)*MEMORY[0x263EFFB40]) {
            operator new();
          }
        }
        CFRelease(v4);
      }
    }
  }
}

void sub_240716B80(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10E1C4071CB0F12);
  _Unwind_Resume(a1);
}

uint64_t MTTrackpadEmbeddedHIDManager::getUserPrefs(uint64_t a1, void *a2)
{
  *a2 = &MTTrackpadEmbeddedHIDManager::getUserPrefs(mt_UserPreference const**)::prefs;
  return 6;
}

uint64_t MTTrackpadEmbeddedHIDManager::setDeviceDefaultProperties(MTTrackpadEmbeddedHIDManager *this)
{
  if ((*((unsigned char *)this + 160) & 0x20) != 0) {
    (*(void (**)(MTTrackpadEmbeddedHIDManager *))(*(void *)this + 352))(this);
  }
  *((unsigned char *)this + 126) = 1;
  unsigned int v2 = *(uint64_t (**)(MTTrackpadEmbeddedHIDManager *))(*(void *)this + 744);

  return v2(this);
}

CFDictionaryRef MTTrackpadEmbeddedHIDManager::copyProperty(CFDictionaryRef *this, const __CFString *a2)
{
  char v3 = MTTrackpadEmbeddedHIDManager::renameUserFacingKeys((MTTrackpadEmbeddedHIDManager *)this, a2);
  uint64_t v10 = 0;
  uint64_t v4 = (*((uint64_t (**)(CFDictionaryRef *, uint64_t *))*this + 105))(this, &v10);
  if (!v4) {
    return MTTrackpadHIDManager::copyProperty((MTTrackpadHIDManager *)this, v3);
  }
  uint64_t v5 = v4;
  for (uint64_t i = 0; ; i += 16)
  {
    if (CFEqual(v3, *(CFStringRef *)(v10 + i)))
    {
      uint64_t Value = CFDictionaryGetValue(this[43], v3);
      if (Value) {
        break;
      }
    }
    if (!--v5) {
      return MTTrackpadHIDManager::copyProperty((MTTrackpadHIDManager *)this, v3);
    }
  }
  int v8 = Value;
  CFRetain(Value);
  return (CFDictionaryRef)v8;
}

__CFString *MTTrackpadEmbeddedHIDManager::renameUserFacingKeys(MTTrackpadEmbeddedHIDManager *this, CFStringRef theString1)
{
  if (CFEqual(theString1, @"TapToClickEnabled")) {
    return @"Clicking";
  }
  if (CFEqual(theString1, @"TwoFingersSecondaryClickEnabled")) {
    return @"TrackpadRightClick";
  }
  if (CFEqual(theString1, @"DoubleTapToDragEnabled")) {
    return @"Dragging";
  }
  if (CFEqual(theString1, @"DragLockEnabled")) {
    return @"DragLock";
  }
  if (CFStringCompare(theString1, @"PrimaryTrackpadCanBeDisabled", 0)) {
    return (__CFString *)theString1;
  }
  return @"USBMouseStopsTrackpad";
}

uint64_t MTTrackpadEmbeddedHIDManager::setProperty(MTTrackpadEmbeddedHIDManager *this, const __CFString *a2, const void *a3)
{
  uint64_t v5 = MTTrackpadEmbeddedHIDManager::renameUserFacingKeys(this, a2);

  return MTTrackpadHIDManager::setProperty((CFTypeRef *)this, v5, a3);
}

uint64_t MTTrackpadEmbeddedHIDManager::setPropertyInternal(uint64_t a1, int a2, CFTypeRef cf, int a4)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  if (a2 > 78)
  {
    switch(a2)
    {
      case 'O':
        if (!cf) {
          return 0;
        }
        CFTypeID v8 = CFGetTypeID(cf);
        if (v8 != CFBooleanGetTypeID()) {
          goto LABEL_23;
        }
        return 1;
      case 'P':
        if (!cf) {
          return 0;
        }
LABEL_23:
        CFTypeID v14 = CFGetTypeID(cf);
        if (v14 != CFDictionaryGetTypeID()) {
          return 0;
        }
        int v15 = *(unsigned __int8 *)(a1 + 353);
        uint64_t Value = CFDictionaryGetValue((CFDictionaryRef)cf, @"DigitizerSurfaceCovered");
        BOOL v19 = Value
           && (int v17 = Value, v18 = CFGetTypeID(Value), v18 == CFBooleanGetTypeID())
           && v17 == (const void *)*MEMORY[0x263EFFB40];
        *(unsigned char *)(a1 + 353) = v19;
        int v20 = *(unsigned __int8 *)(a1 + 354);
        int v21 = CFDictionaryGetValue((CFDictionaryRef)cf, @"ScreenOn");
        BOOL v24 = !v21
           || (int v22 = v21, v23 = CFGetTypeID(v21), v23 != CFBooleanGetTypeID())
           || v22 != (const void *)*MEMORY[0x263EFFB40];
        *(unsigned char *)(a1 + 354) = v24;
        int v25 = *(_DWORD *)(a1 + 356);
        LOWORD(v29) = 0;
        CFNumberRef v26 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"DeviceOrientation");
        if (v26)
        {
          CFNumberRef v27 = v26;
          CFTypeID v28 = CFGetTypeID(v26);
          if (v28 == CFNumberGetTypeID())
          {
            if (CFNumberGetValue(v27, kCFNumberSInt16Type, &v29)) {
              *(_DWORD *)(a1 + 356) = (unsigned __int16)v29;
            }
          }
        }
        if (v15 == *(unsigned __int8 *)(a1 + 353)
          && v20 == *(unsigned __int8 *)(a1 + 354)
          && v25 == *(_DWORD *)(a1 + 356)
          && (a4 & 1) == 0
          && *(unsigned char *)(a1 + 352))
        {
          return 1;
        }
        if (MTTrackpadEmbeddedHIDManager::setHostState((MTTrackpadEmbeddedHIDManager *)a1))
        {
          uint64_t result = 0;
          *(unsigned char *)(a1 + 353) = v15;
          *(unsigned char *)(a1 + 354) = v20;
          *(_DWORD *)(a1 + 356) = v25;
        }
        else
        {
          uint64_t result = 1;
          *(unsigned char *)(a1 + 352) = 1;
        }
        return result;
      case 'Q':
        if (!cf) {
          goto LABEL_17;
        }
        CFTypeID v11 = CFGetTypeID(cf);
        if (v11 == CFNumberGetTypeID()) {
          return 1;
        }
        goto LABEL_15;
      case 'R':
        if (!cf) {
          goto LABEL_17;
        }
LABEL_15:
        CFTypeID v12 = CFGetTypeID(cf);
        if (v12 == CFBooleanGetTypeID())
        {
          (*(void (**)(uint64_t))(*(void *)a1 + 80))(a1);
          io_registry_entry_t Service = MTDeviceGetService();
          IORegistryEntrySetCFProperty(Service, @"DeviceOpenedByEventSystem", cf);
        }
        goto LABEL_17;
      default:
        goto LABEL_17;
    }
  }
  switch(a2)
  {
    case 9:
      uint64_t v9 = MTLoggingPlugin();
      uint64_t result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      break;
    case 18:
      uint64_t v9 = MTLoggingPlugin();
      uint64_t result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      break;
    case 43:
      uint64_t v9 = MTLoggingPlugin();
      uint64_t result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      break;
    default:
LABEL_17:
      return MTTrackpadHIDManager::setPropertyInternal((MTSimpleHIDManager *)a1, a2, cf, a4);
  }
  int v29 = 136315650;
  uint64_t v30 = "[Error] ";
  __int16 v31 = 2080;
  float v32 = "MTTrackpadEmbeddedHIDManager::";
  __int16 v33 = 2080;
  BOOL v34 = "setPropertyInternal";
  _os_log_impl(&dword_2406FB000, v9, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unsupported", (uint8_t *)&v29, 0x20u);
  return 0;
}

uint64_t MTTrackpadEmbeddedHIDManager::setHostState(MTTrackpadEmbeddedHIDManager *this)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  int v2 = *((unsigned __int8 *)this + 353);
  int v3 = *((unsigned __int8 *)this + 354);
  int v4 = *((_DWORD *)this + 89);
  uint64_t v5 = MTLoggingPlugin();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136316674;
    CFTypeID v12 = "";
    __int16 v13 = 2080;
    CFTypeID v14 = "MTTrackpadEmbeddedHIDManager::";
    __int16 v15 = 2080;
    int v16 = "setHostState";
    __int16 v17 = 1024;
    int v18 = 0;
    __int16 v19 = 1024;
    int v20 = v2;
    __int16 v21 = 1024;
    int v22 = v3;
    __int16 v23 = 1024;
    int v24 = v4;
    _os_log_impl(&dword_2406FB000, v5, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Host state - graphics orientation: %u, cover closed: %u, display off: %u, device orientation: %u", buf, 0x38u);
  }
  (*(void (**)(MTTrackpadEmbeddedHIDManager *))(*(void *)this + 80))(this);
  uint64_t v6 = MTDeviceSetReport();
  if (v6)
  {
    int v7 = MTLoggingPlugin();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      CFTypeID v12 = "[Error] ";
      __int16 v13 = 2080;
      CFTypeID v14 = "MTTrackpadEmbeddedHIDManager::";
      __int16 v15 = 2080;
      int v16 = "setHostState";
      __int16 v17 = 1024;
      int v18 = v6;
      _os_log_impl(&dword_2406FB000, v7, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Error 0x%08X setting host state", buf, 0x26u);
    }
  }
  else
  {
    CFTypeID v8 = (MTPowerLogger *)*((void *)this + 45);
    if (v8)
    {
      if (*((unsigned char *)this + 353))
      {
        int v9 = 3;
      }
      else if (*((unsigned char *)this + 354))
      {
        int v9 = 2;
      }
      else
      {
        int v9 = 1;
      }
      MTPowerLogger::transitionTo(v8, v9);
    }
  }
  return v6;
}

uint64_t MTTrackpadEmbeddedHIDManager::setOrientation(MTTrackpadEmbeddedHIDManager *this)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v1 = MTLoggingPlugin();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315650;
    int v4 = "[Error] ";
    __int16 v5 = 2080;
    uint64_t v6 = "MTTrackpadEmbeddedHIDManager::";
    __int16 v7 = 2080;
    CFTypeID v8 = "setOrientation";
    _os_log_impl(&dword_2406FB000, v1, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unsupported", (uint8_t *)&v3, 0x20u);
  }
  return 3758097095;
}

uint64_t MTTrackpadEmbeddedHIDManager::setPowerState()
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  v0 = MTLoggingPlugin();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
  {
    int v2 = 136315650;
    int v3 = "[Error] ";
    __int16 v4 = 2080;
    __int16 v5 = "MTTrackpadEmbeddedHIDManager::";
    __int16 v6 = 2080;
    __int16 v7 = "setPowerState";
    _os_log_impl(&dword_2406FB000, v0, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unsupported", (uint8_t *)&v2, 0x20u);
  }
  return 3758097095;
}

uint64_t MTTrackpadEmbeddedHIDManager::setPowerStateWithReset()
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  v0 = MTLoggingPlugin();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
  {
    int v2 = 136315650;
    int v3 = "[Error] ";
    __int16 v4 = 2080;
    __int16 v5 = "MTTrackpadEmbeddedHIDManager::";
    __int16 v6 = 2080;
    __int16 v7 = "setPowerStateWithReset";
    _os_log_impl(&dword_2406FB000, v0, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unsupported", (uint8_t *)&v2, 0x20u);
  }
  return 3758097095;
}

void MTTrackpadEmbeddedHIDManager::wasScheduledOnDispatchQueue(MTTrackpadEmbeddedHIDManager *this, NSObject *a2)
{
  __int16 v4 = (MTPowerLogger *)*((void *)this + 45);
  if (v4) {
    MTPowerLogger::scheduleOnDispatchQueue(v4, a2);
  }

  MTTrackpadHIDManager::wasScheduledOnDispatchQueue((MTInputDeviceManagement **)this, a2);
}

void MTTrackpadEmbeddedHIDManager::wasUnscheduledFromDispatchQueue(io_object_t *this, dispatch_queue_s *a2)
{
  MTTrackpadHIDManager::wasUnscheduledFromDispatchQueue(this, a2);
  __int16 v4 = (dispatch_object_t *)*((void *)this + 45);
  if (v4)
  {
    MTPowerLogger::unscheduleFromDispatchQueue(v4, a2);
  }
}

uint64_t MTTrackpadEmbeddedHIDManager::handleContactFrame(MTTrackpadHIDManager *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  CFTypeID v12 = (MTPowerLogger *)*((void *)this + 45);
  if (v12 && !*((unsigned char *)this + 354))
  {
    if (a4) {
      MTPowerLogger::transitionTo(v12, 0);
    }
    else {
      MTPowerLogger::transitionToDelayed((uint64_t)v12, 1, 0x77359400uLL);
    }
  }

  return MTTrackpadHIDManager::handleContactFrame(this, a6, a2, a3, a4, a5);
}

void MTTrackpadEmbeddedHIDManager::~MTTrackpadEmbeddedHIDManager(MTTrackpadEmbeddedHIDManager *this)
{
  MTSimpleHIDManager::~MTSimpleHIDManager(this);

  JUMPOUT(0x2455F6CE0);
}

void MTSlideGesture::MTSlideGesture(MTSlideGesture *this)
{
  *((void *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + MTHandMotion::clearHandMotion(this, 1) = 0u;
  *((_DWORD *)this + 10) = 1065353216;
  *(void *)((char *)this + 44) = 0;
  *(void *)((char *)this + 60) = 0;
  *(void *)((char *)this + 52) = 0;
  *((unsigned char *)this + 68) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_DWORD *)this + 34) = 0;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
}

{
  *((void *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + MTHandMotion::clearHandMotion(this, 1) = 0u;
  *((_DWORD *)this + 10) = 1065353216;
  *(void *)((char *)this + 44) = 0;
  *(void *)((char *)this + 60) = 0;
  *(void *)((char *)this + 52) = 0;
  *((unsigned char *)this + 68) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_DWORD *)this + 34) = 0;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
}

double MTSlideGesture::clearIntegrationState(MTSlideGesture *this)
{
  *((unsigned char *)this + 68) = 0;
  *((void *)this + 18) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_DWORD *)this + 30) = 0;
  return result;
}

uint64_t MTSlideGesture::MTSlideGesture(uint64_t a1, int a2, int a3, long long *a4, uint64_t *a5, float a6, float a7)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::vector<MTActionEvent>::__init_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>((void *)a1, *a5, a5[1], (a5[1] - *a5) >> 3);
  *(_DWORD *)(a1 + 24) = 16;
  *(_DWORD *)(a1 + 28) = a3;
  *(_DWORD *)(a1 + 32) = a2;
  long long v13 = *a4;
  *(_OWORD *)(a1 + 52) = a4[1];
  *(_OWORD *)(a1 + 36) = v13;
  *(float *)(a1 + 152) = a6;
  *(float *)(a1 + 156) = a7;
  *(unsigned char *)(a1 + 68) = 0;
  *(void *)(a1 + 144) = 0;
  if ((a2 & 0x1000000) != 0) {
    int v14 = -1;
  }
  else {
    int v14 = 1;
  }
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_DWORD *)(a1 + 136) = 0;
  if ((a2 & 3) != 0 || a7 > 0.0) {
    *(float *)(a1 + 124) = (float)v14;
  }
  if ((a2 & 0xC) != 0 || a7 > 0.0) {
    *(float *)(a1 + 128) = (float)v14;
  }
  if ((a2 & 0x30) != 0) {
    *(float *)(a1 + 132) = (float)v14;
  }
  if ((a2 & 0xC0) != 0) {
    *(float *)(a1 + 136) = (float)v14;
  }
  return a1;
}

{
  return MTSlideGesture::MTSlideGesture(a1, a2, a3, a4, a5, a6, a7);
}

void MTSlideGesture::MTSlideGesture(MTSlideGesture *this, const MTSlideGesture *a2)
{
  *(void *)this = 0;
  *((void *)this + MTHandMotion::clearHandMotion(this, 1) = 0;
  *((void *)this + 2) = 0;
  std::vector<MTActionEvent>::__init_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>(this, *(void *)a2, *((void *)a2 + 1), (uint64_t)(*((void *)a2 + 1) - *(void *)a2) >> 3);
  *((_DWORD *)this + 6) = *((_DWORD *)a2 + 6);
  *((_DWORD *)this + 7) = *((_DWORD *)a2 + 7);
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  long long v4 = *(_OWORD *)((char *)a2 + 36);
  *(_OWORD *)((char *)this + 52) = *(_OWORD *)((char *)a2 + 52);
  *(_OWORD *)((char *)this + 36) = v4;
  *((void *)this + 19) = *((void *)a2 + 19);
  if (this != a2) {
    std::vector<MTActionEvent>::__assign_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>(this, *(_DWORD **)a2, *((_DWORD **)a2 + 1), (uint64_t)(*((void *)a2 + 1) - *(void *)a2) >> 3);
  }
  *((unsigned char *)this + 68) = 0;
  *((void *)this + 18) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_DWORD *)this + 30) = 0;
  for (uint64_t i = 124; i != 140; i += 4)
    *(_DWORD *)((char *)this + i) = *(_DWORD *)((char *)a2 + i);
}

void sub_240717B1C(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MTSlideGesture::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    MTGesture::operator=(a1, a2);
    uint64_t v4 = 0;
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
    long long v5 = *(_OWORD *)(a2 + 36);
    *(_OWORD *)(a1 + 52) = *(_OWORD *)(a2 + 52);
    *(_OWORD *)(a1 + 36) = v5;
    *(void *)(a1 + 152) = *(void *)(a2 + 152);
    *(unsigned char *)(a1 + 68) = 0;
    *(void *)(a1 + 144) = 0;
    *(_OWORD *)(a1 + 72) = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_DWORD *)(a1 + 120) = 0;
    do
    {
      *(_DWORD *)(a1 + 124 + v4) = *(_DWORD *)(a2 + 124 + v4);
      v4 += 4;
    }
    while (v4 != 16);
  }
  return a1;
}

uint64_t MTGesture::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    std::vector<MTActionEvent>::__assign_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>((void *)a1, *(_DWORD **)a2, *(_DWORD **)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  }
  return a1;
}

uint64_t MTSlideGesture::getDegreesOfFreedomMask(uint64_t this)
{
  uint64_t v1 = this;
  unint64_t v2 = 0;
  LODWORD(this) = 0;
  do
  {
    float v3 = *(float *)(v1 + 4 * v2 + 124);
    if (v3 == 0.0)
    {
      if (*(void *)v1 == *(void *)(v1 + 8)
        || **(_WORD **)v1 != 71
        || v2 > 1
        || (float v3 = 1.0, *(double *)(v1 + 144) <= 0.0))
      {
        float v3 = 0.0;
      }
    }
    int v4 = 1 << v2;
    if (v3 == 0.0) {
      int v4 = 0;
    }
    this = v4 | this;
    ++v2;
  }
  while (v2 != 4);
  return this;
}

double MTSlideGesture::relativeSensitivity(MTSlideGesture *this, unsigned int a2)
{
  LODWORD(result) = *((_DWORD *)this + (int)a2 + 31);
  if (*(float *)&result == 0.0)
  {
    if (*(void *)this == *((void *)this + 1)) {
      return 0.0;
    }
    if (**(_WORD **)this != 71) {
      return 0.0;
    }
    if (a2 > 1) {
      return 0.0;
    }
    LODWORD(result) = 1.0;
    if (*((double *)this + 18) <= 0.0) {
      return 0.0;
    }
  }
  return result;
}

uint64_t MTSlideGesture::sendSlideKeys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, double a8)
{
  int v14 = *(unsigned __int8 *)(a6 + 264);
  long long v22 = *(_OWORD *)(a3 + 168);
  MTChordIntegrating::sendSlidePreamble(a6, a2, a3, a4, a5, a1, 8u, a8);
  double v15 = *(double *)(a2 + 8);
  *(double *)(a1 + 144) = v15;
  int v16 = *(_DWORD *)(a1 + 32);
  if ((v16 & 0x23000) != 0)
  {
    if ((v16 & 0x20000) != 0)
    {
      int v18 = *(_DWORD *)(a6 + 280);
      if (v18 < 0)
      {
        __int16 v19 = *(const MTActionEvent **)a1;
        if (*(void *)a1 != *(void *)(a1 + 8) && *(_WORD *)v19 == 129)
        {
          unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
          MTActionEvent::MTActionEvent((MTActionEvent *)&v21, v19);
          LOWORD(v2MTHandMotion::clearHandMotion(this, 1) = 130;
          *(_DWORD *)(a6 + 280) = -*(_DWORD *)(a6 + 280);
          (*(void (**)(uint64_t, unint64_t *, uint64_t, void, void, long long *, void, void, double))(*(void *)a4 + 24))(a4, &v21, a5, 0, 0, &v22, *(unsigned __int8 *)(a1 + 32), *(unsigned int *)(a6 + 224), *(double *)(a2 + 8));
          return 1;
        }
        *(unsigned char *)(a6 + 267) = 1;
      }
      *(_DWORD *)(a6 + 280) = -v18;
      goto LABEL_21;
    }
    if ((v16 & 0x2000) != 0)
    {
      if (*(_DWORD *)(a6 + 284) != v16) {
        goto LABEL_21;
      }
      return 0;
    }
  }
  else
  {
    if (v14) {
      BOOL v17 = 1;
    }
    else {
      BOOL v17 = (*(_DWORD *)(a1 + 32) & 0x4000) == 0;
    }
    if (v17 || v15 - *(double *)(a6 + 240) >= *(double *)&qword_268C8ECC8)
    {
      *(_DWORD *)(a6 + 284) = *(_DWORD *)(a1 + 32);
      if (a7 >= 1)
      {
        a7 = (unsigned __int16)a7;
        goto LABEL_22;
      }
      return 0;
    }
  }
  *(unsigned char *)(a6 + 267) = 1;
LABEL_21:
  *(_DWORD *)(a6 + 284) = v16;
  a7 = 1;
  do
  {
LABEL_22:
    uint64_t result = MTGesture::dispatchEvents((uint64_t *)a1, a4, a5, 0, 0, (uint64_t)&v22, *(unsigned __int8 *)(a1 + 32), *(unsigned int *)(a6 + 224), *(double *)(a2 + 8));
    --a7;
  }
  while (a7);
  return result;
}

uint64_t MTSlideGesture::sendSlideMickeys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int32x4_t *a7, double a8)
{
  if (MTChordIntegrating::sendSlidePreamble(a6, a2, a3, a4, a5, a1, 8u, a8)) {
    uint64_t v15 = 2;
  }
  else {
    uint64_t v15 = 8;
  }
  long long v18 = *(_OWORD *)(a3 + 168);
  MTChordIntegrating::updateMomentumMickeys(a6, a7, (double *)a2);
  double v16 = *(double *)(a2 + 8);
  *(double *)(a1 + 144) = v16;
  return MTGesture::dispatchEvents((uint64_t *)a1, a4, a5, v15, (uint64_t)a7, (uint64_t)&v18, *(unsigned __int8 *)(a1 + 32), *(unsigned int *)(a6 + 224), v16);
}

float MTSlideGesture::cumulativeMotionMagnitude(MTSlideGesture *this)
{
  if (*(void *)this != *((void *)this + 1)
    && ((**(_WORD **)this & 0x80) != 0 || (int v1 = **(unsigned __int16 **)this, (v1 - 35) < 5) || v1 == 67))
  {
    return fabsf(*((float *)this + 22));
  }
  else
  {
    return (float)(hypotf(*((float *)this + 24), *((float *)this + 25)) + fabsf(*((float *)this + 26)))
         + fabsf(*((float *)this + 27));
  }
}

uint64_t MTSlideGesture::decayAxisIntegrator(uint64_t result, uint64_t a2, float *a3, double a4, float a5)
{
  float v5 = *(float *)(result + 52);
  if (!*(unsigned char *)(a2 + 264)) {
    float v5 = v5 * 1.7;
  }
  float v6 = a5 * 0.00282;
  float v7 = a4 * 0.3;
  if (v6 >= v7) {
    float v7 = v6;
  }
  float v8 = (float)(v7 + 1.0) * v5;
  if (v8 > 0.0)
  {
    float v9 = *a3;
    if (*a3 <= v8)
    {
      float v10 = 0.0;
      if (v9 < (float)-v8) {
        float v10 = v8 + v9;
      }
    }
    else
    {
      float v10 = v9 - v8;
    }
    *a3 = v10;
  }
  return result;
}

float MTSlideGesture::inactivityExtraCommitMultiplier(MTSlideGesture *this, double a2, double *a3)
{
  double v3 = fmin(sqrt(a2), 5.0);
  *a3 = v3;
  return 7.50000048 / (v3 + 7.50000048);
}

uint64_t MTSlideGesture::squelchCommitMultiplierForDirectionReversals(uint64_t this, int a2, float *a3, float *a4)
{
  float v4 = *a3;
  uint64_t v5 = this + 4 * a2;
  float v7 = *(float *)(v5 + 96);
  float v6 = (_DWORD *)(v5 + 96);
  float v8 = v7;
  if ((float)(*a3 * v7) < 0.0)
  {
    if (fabsf(v4) <= fabsf(v8))
    {
      *a4 = 1.0;
    }
    else
    {
      *a3 = v4 + v8;
      *float v6 = 0;
    }
  }
  return this;
}

uint64_t MTSlideGesture::integrateAxisMotion(uint64_t result, uint64_t a2, MTHandMotion *this, uint64_t a4, uint64_t a5, int a6, double a7, float a8)
{
  double v8 = a7;
  uint64_t v10 = result;
  int v11 = *((_DWORD *)this + 32);
  uint64_t v12 = result + 4 * a6;
  if (!*(unsigned char *)(a5 + 264))
  {
    if (v11 < 2000 || v11 > 0xBB7)
    {
      float v14 = *(float *)(result + 40);
    }
    else
    {
      if (*(double *)(a2 + 8) - *(double *)(a2 + 56) > a7) {
        goto LABEL_17;
      }
      double v8 = fmin(sqrt(a7), 5.0);
      float v13 = 7.50000048 / (v8 + 7.50000048);
      float v14 = *(float *)(result + 40) * v13;
      float v15 = *(float *)(v12 + 96);
      if ((float)(v15 * a8) < 0.0)
      {
        if (fabsf(a8) <= fabsf(v15))
        {
          float v14 = 1.0;
        }
        else
        {
          a8 = v15 + a8;
          *(_DWORD *)(v12 + 96) = 0;
        }
      }
    }
    if (*(unsigned char *)(a4 + 28))
    {
      if (*(int *)(a4 + 24) >= 3 && *(_DWORD *)(a5 + 216) == 1)
      {
        double v16 = *(void **)(a5 + 160);
        if (*(void *)(a5 + 168) - (void)v16 == 160 && *v16 != v16[1] && *(_WORD *)*v16 == 68) {
          float v14 = v14 * 0.06;
        }
      }
    }
    a8 = a8
       * (float)(v14
               * (float)((float)((float)(*((float *)this + 63) * -1.4) + 1.0)
                       * (float)((float)(*((float *)this + 63) * -1.4) + 1.0)));
  }
LABEL_17:
  float v17 = *((float *)this + 93);
  if (!*(unsigned char *)(a2 + 211)) {
    float v17 = 1.0;
  }
  float v19 = *(float *)(v12 + 96);
  long long v18 = (float *)(v12 + 96);
  float *v18 = v19 + (float)(a8 * v17);
  if ((v11 - 2000) <= 0x3E7)
  {
    float MouseMotionFeedback = MTHandMotion::getMouseMotionFeedback(this, a6);
    return MTSlideGesture::decayAxisIntegrator(v10, a5, v18, v8, MouseMotionFeedback);
  }
  return result;
}

float MTSlideGesture::decayRecentDisplacement(MTSlideGesture *this, const MTHandStatistics *a2)
{
  float v3 = pow(0.939999998, (*((double *)a2 + 1) - *((double *)a2 + 2)) / 0.00800000038);
  float result = *((float *)this + 28) * v3;
  *((float *)this + 28) = result;
  return result;
}

float MTSlideGesture::recordCommittedDisplacement(MTSlideGesture *this, float a2)
{
  float result = fabsf(a2) + *((float *)this + 28);
  *((float *)this + 28) = result;
  return result;
}

uint64_t MTSlideGesture::thresholdAxisMotion(MTSlideGesture *this, const MTHandStatistics *a2, const MTHandMotion *a3, int a4)
{
  float v4 = *((float *)this + 9);
  uint64_t v5 = (float *)((char *)this + 4 * a4);
  float v6 = v5[24];
  uint64_t v7 = (int)(float)(v6 / v4);
  float v8 = v4 * (float)(int)v7;
  v5[24] = v6 - v8;
  *((float *)this + 28) = *((float *)this + 28) + fabsf(v8);
  return v7;
}

void MTSlideGesture::suppressVelocityFromMouseFeeback(MTSlideGesture *this, int a2, const MTHandMotion *a3, float a4)
{
}

float MTSlideGesture::accelerateAxisMotion(MTSlideGesture *this, int a2, const MTHandStatistics *a3, const MTHandMotion *a4, float a5, int a6)
{
  switch(a2)
  {
    case 0:
      int v11 = (float *)((char *)a4 + 316);
      goto LABEL_7;
    case 1:
      int v11 = (float *)((char *)a4 + 320);
      goto LABEL_7;
    case 2:
      int v11 = (float *)((char *)a4 + 324);
      goto LABEL_7;
    case 3:
      int v11 = (float *)((char *)a4 + 328);
LABEL_7:
      float v12 = *v11;
      break;
    default:
      float v12 = 0.0;
      break;
  }
  float v13 = *((float *)this + a2 + 31);
  if (v13 == 0.0)
  {
    if (*(void *)this == *((void *)this + 1)
      || **(_WORD **)this != 71
      || a2 > 1
      || (float v13 = 1.0, *((double *)this + 18) <= 0.0))
    {
      float v13 = 0.0;
    }
  }
  float v14 = (float)(v12 * v13) * a5;
  if ((*((_DWORD *)a4 + 32) - 2000) <= 0x3E7) {
    MTSlideGesture::suppressVelocityFromMouseFeeback(this, a2, a4, v14);
  }
  float v15 = 0.0;
  if (v14 != 0.0)
  {
    float v15 = (*((double *)a3 + 1) - *((double *)a3 + 2)) * v14;
    if (a6)
    {
      if (a2 > 1) {
        float v16 = fabsf(v14);
      }
      else {
        float v16 = sqrtf((float)(*((float *)a4 + 84) * *((float *)a4 + 84)) + (float)(*((float *)a4 + 83)
      }
                                                                               * *((float *)a4 + 83)));
      float v17 = *((float *)this + 11);
      float v18 = 1.0;
      if (v17 < v16 && v17 > 0.0)
      {
        float v19 = *((float *)this + 12);
        if (v19 > 0.0) {
          float v18 = powf(v16 / v17, v19);
        }
      }
      return v18 * v15;
    }
  }
  return v15;
}

float MTSlideGesture::increasingSigmoidFromTdiff(MTSlideGesture *this, double a2, double a3, int a4)
{
  float v4 = 0.0;
  if (a2 != 0.0)
  {
    float v4 = 1.0;
    if (a3 != 0.0)
    {
      float v5 = a3;
      float v6 = a2;
      if (a4 >= 2)
      {
        int v7 = a4 - 1;
        do
        {
          float v5 = v5 * a3;
          float v6 = v6 * a2;
          --v7;
        }
        while (v7);
      }
      float v8 = v6 / (float)(v6 + v5);
      float v4 = 1.0;
      if (v8 <= 1.0)
      {
        float v4 = v8;
        if (v8 < 0.0) {
          return 0.0;
        }
      }
    }
  }
  return v4;
}

BOOL MTSlideGesture::canOverrideLockOn(MTSlideGesture *this, const MTSlideGesture *a2)
{
  unsigned int v3 = (*((_DWORD *)a2 + 8) >> 9) & 7;
  float v4 = *((float *)a2 + 28);
  if ((float)(v4 + MTSlideGesture::cumulativeMotionMagnitude(a2)) >= 3.0 || v3 == 0) {
    return 0;
  }
  if (*(void *)this == *((void *)this + 1) || **(_WORD **)this != 133) {
    return v3 < ((*((_DWORD *)this + 8) >> 9) & 7u);
  }
  return 1;
}

BOOL MTSlideGesture::canPunishSomeMoving(MTSlideGesture *this, uint64_t a2, uint64_t a3)
{
  if ((*((_DWORD *)this + 8) & 0x8000E00) == 0) {
    return 0;
  }
  if (!*(unsigned char *)(a3 + 264)) {
    return 1;
  }
  float v4 = *(MTSlideGesture **)(a3 + 272);
  if (!v4) {
    return 1;
  }
  if (*(double *)(a2 + 8) - *(double *)(a3 + 256) < *(double *)&qword_268C8EC48) {
    return 1;
  }
  if (v4 == this)
  {
    float v7 = *((float *)this + 28);
    if ((float)(v7 + MTSlideGesture::cumulativeMotionMagnitude(this)) < 3.0
      && (*(_DWORD *)(a3 + 216) < 4u || *(void *)this == *((void *)this + 1) || **(_WORD **)this != 70))
    {
      return 1;
    }
  }

  return MTSlideGesture::canOverrideLockOn(this, v4);
}

float MTSlideGesture::someMovingMultiplier(MTSlideGesture *this, uint64_t a2, MTHandMotion *a3, uint64_t a4)
{
  unsigned int v8 = *((_DWORD *)this + 8);
  float SpeedSymmetry = 0.0;
  if ((v8 & 0x100) == 0 || *((unsigned char *)a3 + 376))
  {
    uint64_t v10 = *(_WORD **)this;
    int v11 = (_WORD *)*((void *)this + 1);
    if (*(_WORD **)this == v11
      || ((*v10 & 0xFFFE) == 0x46 ? (BOOL v12 = *(unsigned char *)(a2 + 305) == 0) : (BOOL v12 = 1),
          v12 || *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) < 4))
    {
      BOOL canPunishSomeMoving = MTSlideGesture::canPunishSomeMoving(this, a2, a4);
      float SpeedSymmetry = 1.0;
      if (canPunishSomeMoving)
      {
        if ((v8 & 0x8000000) != 0)
        {
          float v14 = 0.8;
          if (v10 != v11 && *(_DWORD *)(a4 + 216) == 2) {
            float v14 = flt_24074F548[(unsigned __int16)(*v10 - 35) < 5u];
          }
          float SpeedSymmetry = MTHandMotion::getSpeedSymmetry(a3, v14, 0);
          unsigned int v8 = *((_DWORD *)this + 8);
        }
        if ((v8 & 0xE00) != 0)
        {
          float v15 = 0.9;
          if (*(_DWORD *)(a4 + 216) == 3) {
            float v15 = 2.0;
          }
          float v16 = MTHandMotion::getSpeedSymmetry(a3, v15, (v8 >> 9) & 7);
          if (SpeedSymmetry < v16 || SpeedSymmetry == 1.0) {
            float SpeedSymmetry = v16;
          }
          unsigned int v8 = *((_DWORD *)this + 8);
        }
        if ((v8 & 0xE00) == 0x800 && *(unsigned char *)(a2 + 186) == 5) {
          return SpeedSymmetry
        }
               * MTSlideGesture::increasingSigmoidFromTdiff((MTSlideGesture *)canPunishSomeMoving, *(double *)(a2 + 8) - *(double *)(a2 + 80) - (*(double *)(a2 + 8) - *(double *)(a2 + 56)), *(double *)&qword_268C8EC38, 2);
      }
    }
  }
  return SpeedSymmetry;
}

float MTSlideGesture::integrateManipulativeGesture(uint64_t a1, unsigned __int8 *a2, MTHandMotion *a3, uint64_t a4, uint64_t a5, double a6, float a7)
{
  float v14 = MTSlideGesture::someMovingMultiplier((MTSlideGesture *)a1, (uint64_t)a2, a3, a5);
  for (unint64_t i = 0; i != 4; ++i)
  {
    if (*(float *)(a1 + 4 * i + 124) != 0.0
      || *(void *)a1 != *(void *)(a1 + 8) && **(_WORD **)a1 == 71 && i <= 1 && *(double *)(a1 + 144) > 0.0)
    {
      if (*(unsigned char *)(a5 + 264)) {
        int v16 = (*(unsigned char *)(a1 + 34) & 0x80) == 0 || a2[302] <= (a2[186] >> 1);
      }
      else {
        int v16 = 0;
      }
      float v17 = MTSlideGesture::accelerateAxisMotion((MTSlideGesture *)a1, i, (const MTHandStatistics *)a2, a3, a7, v16);
      MTSlideGesture::integrateAxisMotion(a1, (uint64_t)a2, a3, a4, a5, i, a6, v14 * v17);
    }
  }
  float v18 = *(float *)(a1 + 112);
  return v18 + MTSlideGesture::cumulativeMotionMagnitude((MTSlideGesture *)a1);
}

uint64_t MTSlideGesture::fireManipulativeGesture(uint64_t result, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, double a7)
{
  unsigned int v8 = (MTSlideGesture *)result;
  uint64_t v9 = 0;
  int v10 = 0;
  v17.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v17.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  float v11 = *(float *)(result + 36);
  do
  {
    float v12 = *(float *)(result + v9 * 4 + 96);
    int v13 = (int)(float)(v12 / v11);
    float v14 = v11 * (float)v13;
    *(float *)(result + v9 * 4 + 96) = v12 - v14;
    *(float *)(result + 112) = *(float *)(result + 112) + fabsf(v14);
    v17.i32[v9] = v13;
    if (v13 >= 0) {
      int v15 = (int)(float)(v12 / v11);
    }
    else {
      int v15 = -v13;
    }
    v10 += v15;
    ++v9;
  }
  while (v9 != 4);
  if ((*(unsigned char *)(result + 35) & 2) == 0
    || *(unsigned char *)(a6 + 264)
    || (*(_DWORD *)(a3 + 128) - 2000) <= 0x3E7 && a2[298] < a2[186]
    || (int32x2_t v16 = vabs_s32(*(int32x2_t *)v17.i8),
        (vcgt_u32((uint32x2_t)v16, (uint32x2_t)vdup_lane_s32(v16, 1)).u8[0] & 1) == 0))
  {
    if (*(void *)result == *(void *)(result + 8) || **(_WORD **)result != 68 || !a2[222])
    {
      if (v10)
      {
        float result = MTSlideGesture::sendSlideMickeys(result, (uint64_t)a2, a3, a4, a5, a6, &v17, a7);
        if ((int)result >= 1)
        {
          float result = MTChordIntegrating::resetMostIntegrators(a6, v8);
          *(_DWORD *)(a6 + 288) += v10;
        }
      }
    }
  }
  return result;
}

float MTSlideGesture::integrateFluidGesture(MTSlideGesture *this, const MTHandStatistics *a2, const MTHandMotion *a3, MTChordIntegrating *a4, float a5)
{
  float v10 = MTSlideGesture::someMovingMultiplier(this, (uint64_t)a2, a3, (uint64_t)a4);
  *((_DWORD *)this + 20) = 0;
  if (*((float *)this + 39) <= 0.0)
  {
    float v13 = 0.0;
    for (uint64_t i = 33; i != 35; ++i)
    {
      if (*((float *)this + i) != 0.0)
      {
        float v16 = MTSlideGesture::accelerateAxisMotion(this, i - 31, a2, a3, a5, 0);
        float v17 = MTSlideGesture::accelerateAxisMotion(this, i - 31, a2, a3, a5, 1);
        float v13 = *((float *)this + 20) + (float)(v16 * v10);
        *((float *)this + 20) = v13;
        *((float *)this + 22) = *((float *)this + 22) + (float)(v17 * v10);
      }
    }
  }
  else
  {
    MTSlideGesture::integrateMotionWithinArc(this, a2, a3, a5, 0);
    float v12 = v11;
    MTSlideGesture::integrateMotionWithinArc(this, a2, a3, a5, 1);
    float v13 = *((float *)this + 20) + (float)(v12 * v10);
    *((float *)this + 20) = v13;
    *((float *)this + 22) = *((float *)this + 22) + (float)(v14 * v10);
  }
  *((float *)this + 23) = v13 + *((float *)this + 23);
  if (!*((unsigned char *)a4 + 264))
  {
    float MouseMotionFeedback = MTHandMotion::getMouseMotionFeedback(a3, 0);
    MTSlideGesture::decayAxisIntegrator((uint64_t)this, (uint64_t)a4, (float *)this + 23, 0.0, MouseMotionFeedback);
    float v19 = MTHandMotion::getMouseMotionFeedback(a3, 0);
    MTSlideGesture::decayAxisIntegrator((uint64_t)this, (uint64_t)a4, (float *)this + 22, 0.0, v19);
  }
  for (unint64_t j = 0; j != 4; ++j)
  {
    unint64_t v21 = (float *)((char *)this + 4 * j);
    if (v21[31] != 0.0
      || *(void *)this != *((void *)this + 1) && **(_WORD **)this == 71 && j <= 1 && *((double *)this + 18) > 0.0)
    {
      v21[24] = v10 * MTSlideGesture::accelerateAxisMotion(this, j, a2, a3, a5, 0);
    }
  }
  float v22 = *((float *)this + 21);
  float v23 = *((float *)this + 23);
  BOOL v24 = (float)(v22 * v23) < 0.0;
  float v25 = fabsf(v23);
  float v26 = fabsf(v22);
  if (v24 || v25 > v26) {
    *((float *)this + 2MTHandMotion::clearHandMotion(this, 1) = v23;
  }
  float v28 = (float)(*((float *)this + 20) / *((float *)this + 15)) / (*((double *)a2 + 1) - *((double *)a2 + 2));
  MTChordIntegrating::momentumFilterAlpha(a4, a2, fabsf(*((float *)this + 30)) < fabsf(v28));
  *((float *)this + 30) = (float)((float)(1.0 - v29) * v28) + (float)(v29 * *((float *)this + 30));
  float v30 = *((float *)this + 28);
  return v30 + MTSlideGesture::cumulativeMotionMagnitude(this);
}

void MTSlideGesture::integrateMotionWithinArc(MTSlideGesture *this, const MTHandStatistics *a2, const MTHandMotion *a3, float a4, int a5)
{
  float v9 = *((float *)this + 31);
  if (v9 == 0.0)
  {
    if (*(void *)this == *((void *)this + 1) || **(_WORD **)this != 71 || (float v9 = 1.0, *((double *)this + 18) <= 0.0)) {
      float v9 = 0.0;
    }
  }
  float v10 = *((float *)a3 + 79) * v9;
  float v11 = *((float *)this + 32);
  if (v11 == 0.0)
  {
    if (*(void *)this == *((void *)this + 1)
      || **(_WORD **)this != 71
      || (float v11 = 1.0, *((double *)this + 18) <= 0.0))
    {
      float v11 = 0.0;
    }
  }
  float v12 = (float)(*((float *)a3 + 80) * v11) * a4;
  float v13 = sqrtf((float)(*((float *)a3 + 84) * *((float *)a3 + 84)) + (float)(*((float *)a3 + 83) * *((float *)a3 + 83)));
  if ((*((_DWORD *)a3 + 32) - 2000) <= 0x3E7)
  {
    MTSlideGesture::suppressVelocityFromMouseFeeback(this, 0, a3, v10 * a4);
    MTSlideGesture::suppressVelocityFromMouseFeeback(v14, 0, a3, v12);
  }
  if (v13 != 0.0)
  {
    float v15 = atan2f(-*((float *)a3 + 84), *((float *)a3 + 83)) + (float)(a4 + -1.0) * 1.57079633;
    if (a5)
    {
      float v16 = *((float *)this + 11);
      if (v16 < v13 && v16 > 0.0)
      {
        float v17 = *((float *)this + 12);
        if (v17 > 0.0) {
          powf(v13 / v16, v17);
        }
      }
    }
    float v18 = *((float *)this + 38);
    float v19 = *((float *)this + 39);
    float v20 = cosf(v15 - v18);
    float v21 = cosf(v19 * 0.5);
    if (v20 > v21 || v20 < (float)-v21) {
      __sincosf_stret(v18);
    }
  }
}

uint64_t MTSlideGesture::updateFluidPeak(uint64_t this)
{
  float v1 = *(float *)(this + 84);
  float v2 = *(float *)(this + 92);
  BOOL v3 = (float)(v1 * v2) < 0.0;
  float v4 = fabsf(v2);
  float v5 = fabsf(v1);
  if (v3 || v4 > v5) {
    *(float *)(this + 84) = v2;
  }
  return this;
}

float MTSlideGesture::updateFluidMomentum(MTSlideGesture *this, const MTHandStatistics *a2, MTChordIntegrating *a3, float a4)
{
  MTChordIntegrating::momentumFilterAlpha(a3, a2, fabsf(*((float *)this + 30)) < fabsf(a4));
  float result = (float)((float)(1.0 - v6) * a4) + (float)(v6 * *((float *)this + 30));
  *((float *)this + 30) = result;
  return result;
}

uint64_t MTSlideGesture::cumulativeSwipeToDiscreteDelta(MTSlideGesture *this)
{
  int v1 = *((_DWORD *)this + 18);
  if (!v1)
  {
    *((_DWORD *)this + 19) = 0;
    float v7 = *((float *)this + 22);
    float v8 = *((float *)this + 9);
    if (v7 <= v8)
    {
      if (v7 >= (float)-v8) {
        return 0;
      }
      uint64_t v5 = 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v5 = 1;
    }
    *((_DWORD *)this + 18) = v5;
    return v5;
  }
  float v2 = *((float *)this + 19);
  float v3 = *((float *)this + 22);
  float v4 = *((float *)this + 9);
  if (v1 < 1)
  {
    if (v2 >= (float)(v3 + v4)) {
      float v2 = v3 + v4;
    }
    *((float *)this + 19) = v2;
    if (v3 > v2)
    {
      uint64_t v5 = 1;
      *((_DWORD *)this + 18) = 1;
      float v6 = v3 - v4;
      goto LABEL_13;
    }
    return 0;
  }
  if (v2 <= (float)(v3 - v4)) {
    float v2 = v3 - v4;
  }
  *((float *)this + 19) = v2;
  if (v3 >= v2) {
    return 0;
  }
  uint64_t v5 = 0xFFFFFFFFLL;
  *((_DWORD *)this + 18) = -1;
  float v6 = v3 + v4;
LABEL_13:
  *((float *)this + 19) = v6;
  return v5;
}

float MTSlideGesture::peakSwipePercentage(MTSlideGesture *this)
{
  return *((float *)this + 21) / *((float *)this + 15);
}

float MTSlideGesture::fluidSwipePercentage(MTSlideGesture *this)
{
  return *((float *)this + 23) / *((float *)this + 15);
}

float MTSlideGesture::fluidMomentumPercentage_s(MTSlideGesture *this, int a2)
{
  float result = 0.0;
  if (a2) {
    return *((float *)this + 30);
  }
  return result;
}

uint64_t MTSlideGesture::hasSufficientFluidMomentum(MTSlideGesture *this, const MTHandStatistics *a2, int a3)
{
  float v3 = *((float *)this + 15);
  float v4 = *(_WORD **)this;
  uint64_t v5 = (_WORD *)*((void *)this + 1);
  float v6 = 1.0;
  float v7 = 0.8;
  float v8 = *((float *)this + 23) / v3;
  if (*(_WORD **)this != v5 && (*v4 & 0xFFFE) == 0x26)
  {
    float v9 = 0.0;
    if (a3) {
      float v9 = *((float *)this + 30);
    }
    float v6 = 0.25;
    if ((float)(v8 * v9) >= 0.0) {
      float v6 = 1.0;
    }
    float v7 = 0.6;
  }
  float v10 = 0.0;
  if (a3) {
    float v10 = *((float *)this + 30);
  }
  BOOL v11 = v4 != v5 && (*v4 & 0xFFFE) == 38;
  float v12 = v8 + (float)((float)(v6 * *((float *)this + 16)) * v10);
  float v13 = fabsf(v12);
  float v14 = v7 * fabsf(*((float *)this + 21) / v3);
  int v15 = !v11;
  if (*((unsigned __int8 *)this + 32) - 1 > 1) {
    int v15 = 1;
  }
  BOOL v16 = (float)(v8 * v12) > 0.0 && v13 > 0.5;
  if (v13 < v14) {
    BOOL v16 = 0;
  }
  if (v12 >= 0.0) {
    int v15 = 1;
  }
  return v16 & v15;
}

float MTSlideGesture::fluidDOFPercentageDeltas(MTSlideGesture *this)
{
  return *((float *)this + 24) / *((float *)this + 15);
}

uint64_t MTSlideGesture::fireFluidGesture(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, MTChordIntegrating *this, double a7)
{
  uint64_t v13 = result;
  int v14 = *((unsigned __int8 *)this + 264);
  if (!*((unsigned char *)this + 264) || !*(unsigned char *)(result + 68))
  {
    float v15 = fabsf(*(float *)(result + 92));
    if (v15 <= *(float *)(result + 56)) {
      return result;
    }
    *(float *)(result + 112) = v15 + *(float *)(result + 112);
    *(_DWORD *)(result + 92) = *(_DWORD *)(result + 80);
    if (!v14) {
      MTChordIntegrating::resetMostIntegrators((uint64_t)this, (MTSlideGesture *)result);
    }
  }
  float result = MTChordIntegrating::sendSlidePreamble((uint64_t)this, a2, a3, a4, a5, v13, 8u, a7);
  if (*(float *)(v13 + 80) != 0.0)
  {
    float v16 = *(float *)(v13 + 92);
    float v17 = *(float *)(v13 + 60);
    MTSlideGesture::cumulativeSwipeToDiscreteDelta((MTSlideGesture *)v13);
    *((_DWORD *)this + 7MTHandMotion::clearHandMotion(this, 1) = *(unsigned __int8 *)(v13 + 32);
    *(void *)(v13 + 144) = *(void *)(a2 + 8);
    if (*(void *)(v13 + 8) == *(void *)v13) {
      std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
    }
    float v18 = (const float *)(v13 + 60);
    vld1q_dup_f32(v18);
    float result = (*(uint64_t (**)(uint64_t, float, double))(*(void *)a4 + 32))(a4, v16 / v17, 0.0);
    *(unsigned char *)(v13 + 68) = 1;
  }
  return result;
}

float MTSlideGesture::integrateCommandGesture(uint64_t a1, const MTHandStatistics *a2, MTHandMotion *a3, uint64_t a4, float a5)
{
  float v10 = MTSlideGesture::someMovingMultiplier((MTSlideGesture *)a1, (uint64_t)a2, a3, a4);
  if (*(float *)(a1 + 156) <= 0.0)
  {
    for (unint64_t i = 0; i != 4; ++i)
    {
      if (*(float *)(a1 + 4 * i + 124) != 0.0
        || *(void *)a1 != *(void *)(a1 + 8) && **(_WORD **)a1 == 71 && i <= 1 && *(double *)(a1 + 144) > 0.0)
      {
        *(float *)(a1 + 88) = *(float *)(a1 + 88)
                            + (float)(MTSlideGesture::accelerateAxisMotion((MTSlideGesture *)a1, i, a2, a3, a5, 1) * v10);
      }
    }
  }
  else
  {
    MTSlideGesture::integrateMotionWithinArc((MTSlideGesture *)a1, a2, a3, a5, 1);
    *(float *)(a1 + 88) = *(float *)(a1 + 88) + (float)(v11 * v10);
  }
  if ((*((_DWORD *)a3 + 32) - 2000) <= 0x3E7)
  {
    float MouseMotionFeedback = MTHandMotion::getMouseMotionFeedback(a3, 0);
    MTSlideGesture::decayAxisIntegrator(a1, a4, (float *)(a1 + 88), 0.0, MouseMotionFeedback);
  }
  if (*(float *)(a1 + 88) < 0.0) {
    *(_DWORD *)(a1 + 88) = 0;
  }
  float v13 = *(float *)(a1 + 112);
  return v13 + MTSlideGesture::cumulativeMotionMagnitude((MTSlideGesture *)a1);
}

uint64_t MTSlideGesture::fireCommandGesture(uint64_t result, MTHandStatistics *a2, MTHandMotion *a3, uint64_t a4, uint64_t a5, MTChordIntegrating *this, double a7)
{
  float v8 = *(float *)(result + 36);
  float v9 = *(float *)(result + 88);
  int v10 = (int)(float)(v9 / v8);
  if (v10 >= 1)
  {
    float v16 = (float *)result;
    if (*((unsigned char *)this + 264))
    {
      if ((*(unsigned char *)(result + 33) & 0x40) != 0)
      {
        float result = MTChordIntegrating::waitForFastShotVerification(this, a2, a3);
        float v9 = v16[22];
        if (result)
        {
          if (v9 > 30.0) {
            v16[22] = 30.0;
          }
          return result;
        }
      }
    }
    else
    {
      int v10 = 1;
    }
    v16[22] = v9 - (float)((float)v10 * v8);
    v16[28] = fabsf(v8 * (float)v10) + v16[28];
    float result = MTSlideGesture::sendSlideKeys((uint64_t)v16, (uint64_t)a2, (uint64_t)a3, a4, a5, (uint64_t)this, (__int16)v10, a7);
    if ((int)result >= 1)
    {
      return MTChordIntegrating::resetMostIntegrators((uint64_t)this, (MTSlideGesture *)v16);
    }
  }
  return result;
}

BOOL MTSlideGesture::isLockedOutByTriggeredSlide(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v5 = *(const MTSlideGesture **)(a3 + 272);
  if (!v5) {
    return 0;
  }
  unsigned int v6 = *((_DWORD *)v5 + 8);
  if ((v6 & 0x1000) != 0) {
    return 1;
  }
  if (v5 == (const MTSlideGesture *)a1) {
    return 0;
  }
  if ((v6 & 0x2000) != 0 && (*(unsigned char *)(a1 + 33) & 0x20) == 0) {
    return 1;
  }
  if ((v6 & 0x8000) == 0
    && ((v6 & 0x40000) == 0 || *(unsigned char *)(a3 + 265))
    && ((v6 & 0x20000) == 0 || (*(_DWORD *)(a3 + 280) & 0x80000000) == 0))
  {
    return (v6 & 0x10000) != 0
        && *(_DWORD *)(a1 + 32) >> ((*(_DWORD *)(a1 + 32) & 0x55) == 0) != *((_DWORD *)v5 + 8) >> ((*((_DWORD *)v5 + 8) & 0x55) == 0);
  }
  if (a4) {
    return 1;
  }
  if (MTSlideGesture::canOverrideLockOn((MTSlideGesture *)a1, v5)) {
    return 0;
  }
  BOOL result = 1;
  if ((v6 & 0x8000000) == 0 && ((v6 >> 9) & 7) - 1 <= 2) {
    return *(double *)(a2 + 8) - *(double *)(a3 + 256) >= *(double *)&qword_268C8EC48;
  }
  return result;
}

uint64_t MTSlideGesture::isActiveEdgeSlide(unsigned __int16 **a1, uint64_t a2, uint64_t a3)
{
  int v3 = *((_DWORD *)a1 + 8);
  if ((v3 & 0x200000) == 0) {
    return 0;
  }
  BOOL v4 = (a1[4] & 3) == 0;
  unsigned int v5 = *(_DWORD *)(a2 + 228);
  if ((v3 & 3) == 0) {
    unsigned int v5 = *(_DWORD *)(a2 + 224);
  }
  double v6 = *(double *)(a2 + 8) - *(double *)(a3 + 248);
  if (v6 <= *(double *)&qword_268C8EC50) {
    BOOL v4 = 0;
  }
  if (*a1 == a1[1]) {
    return 1;
  }
  int v7 = v3 & (v5 >> 4) & 0xF;
  int v8 = **a1;
  BOOL v9 = v6 > *(double *)&qword_268C8EC30 || v7 == 0;
  BOOL v10 = v9;
  if ((v8 != 78 || !v10)
    && (!(v3 & (*(_DWORD *)(a2 + 224) >> 12) & 2 | v7) ? (char v11 = 1) : (char v11 = v4),
        (v8 & 0xFFFE) == 0x26 ? (BOOL v12 = *(void *)(a3 + 272) == (void)a1) : (BOOL v12 = 1),
        v12 || (v11 & 1) == 0))
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

uint64_t MTSlideGesture::isBlocked(unsigned __int16 **a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  int v8 = *((_DWORD *)a1 + 8);
  if (*(unsigned char *)(a2 + 316))
  {
    unsigned int v9 = *(unsigned __int8 *)(a2 + 186);
    if (*(unsigned char *)(a2 + 317)) {
      BOOL v10 = 0;
    }
    else {
      BOOL v10 = v9 > 1;
    }
    if (v10) {
      return 1;
    }
  }
  else
  {
    unsigned int v9 = *(unsigned __int8 *)(a2 + 186);
  }
  if (*a1 == a1[1]) {
    return 1;
  }
  int v11 = **a1;
  if (!**a1 || *((float *)a1 + 9) == 0.0 || (v8 & 0x100000) != 0 && !*(unsigned char *)(a4 + 264)) {
    return 1;
  }
  if ((v8 & 0x4000000) != 0 && *(double *)(a2 + 8) - *(double *)(a4 + 248) >= *(double *)&qword_268C8EC40) {
    return 1;
  }
  if ((v8 & 0x200000) != 0)
  {
    if (MTSlideGesture::isActiveEdgeSlide(a1, a2, a4)) {
      goto LABEL_45;
    }
    return 1;
  }
  if (v11 == 70)
  {
    if (!*(unsigned char *)(a4 + 264)
      && *(_DWORD *)(a4 + 216) == 2
      && ((*(unsigned char *)(a2 + 224) & 0xC0) != 0
       || *(unsigned char *)(a3 + 136) && (*(unsigned char *)(a2 + 228) & 0x20) != 0
       || *(unsigned char *)(a3 + 137) && (*(unsigned char *)(a2 + 228) & 0x10) != 0)
      && *(double *)(a2 + 8) - *(double *)(a4 + 248) < *(double *)&qword_268C8EC30)
    {
      return 1;
    }
  }
  else if (v11 == 68 {
         && !*(unsigned char *)(a4 + 264)
  }
         && *(_DWORD *)(a4 + 216) == 1
         && *(double *)(a2 + 8) - *(double *)(a4 + 248) < *(double *)&qword_268C8EC28)
  {
    if ((a5 & 1) != 0 || (v8 & 3) == 0)
    {
      if (*(unsigned char *)(a3 + 136) && (*(unsigned char *)(a2 + 224) & 0x20) != 0
        || *(unsigned char *)(a3 + 137) && (*(unsigned char *)(a2 + 224) & 0x10) != 0)
      {
        return 1;
      }
    }
    else if (*(unsigned char *)(a3 + 136) && (*(unsigned char *)(a2 + 229) & 0x20) != 0 {
           || *(unsigned char *)(a3 + 137) && (*(unsigned char *)(a2 + 229) & 0x10) != 0)
    }
    {
      return 1;
    }
  }
LABEL_45:
  if (*(unsigned char *)(a4 + 267)
    || (*(_WORD *)(a4 + 228) & 0x1000) != 0 && *(double *)(a2 + 8) - *(double *)(a2 + 128) < *(double *)&qword_268C8EC38
    || MTSlideGesture::isLockedOutByTriggeredSlide((uint64_t)a1, a2, a4, 0))
  {
    return 1;
  }
  BOOL v15 = *(unsigned __int16 ***)(a4 + 272) != a1 && v8 < 0;
  float v13 = (double)v9 * 25.0;
  return *(float *)(a2 + 160) < v13 && v15;
}

float MTSlideGesture::integrateGesture(MTSlideGesture *this, const MTHandStatistics *a2, const MTHandMotion *a3, const MTDragManagerEventQueue *a4, MTChordIntegrating *a5, double a6)
{
  float v12 = pow(0.939999998, (*((double *)a2 + 1) - *((double *)a2 + 2)) / 0.00800000038);
  *((float *)this + 28) = *((float *)this + 28) * v12;
  if (*(void *)this == *((void *)this + 1)) {
    goto LABEL_13;
  }
  int v13 = **(unsigned __int16 **)this;
  if (v13 == 67 || (v13 & 0x80) != 0)
  {
    float v15 = (float)*((int *)a5 + 70);
    return MTSlideGesture::integrateCommandGesture((uint64_t)this, a2, a3, (uint64_t)a5, v15);
  }
  if ((v13 - 35) > 4)
  {
LABEL_13:
    float v18 = (float)*((int *)a5 + 70);
    return MTSlideGesture::integrateManipulativeGesture((uint64_t)this, (unsigned __int8 *)a2, a3, (uint64_t)a4, (uint64_t)a5, a6, v18);
  }
  else
  {
    float v17 = (float)*((int *)a5 + 70);
    return MTSlideGesture::integrateFluidGesture(this, a2, a3, a5, v17);
  }
}

uint64_t MTSlideGesture::fireGesture(uint64_t result, MTHandStatistics *a2, MTHandMotion *a3, uint64_t a4, uint64_t a5, MTChordIntegrating *this, double a7)
{
  if (*(void *)result == *(void *)(result + 8)) {
    return MTSlideGesture::fireManipulativeGesture(result, (unsigned __int8 *)a2, (uint64_t)a3, a4, a5, (uint64_t)this, a7);
  }
  int v7 = **(unsigned __int16 **)result;
  if (v7 == 67 || (v7 & 0x80) != 0) {
    return MTSlideGesture::fireCommandGesture(result, a2, a3, a4, a5, this, a7);
  }
  if ((v7 - 35) > 4) {
    return MTSlideGesture::fireManipulativeGesture(result, (unsigned __int8 *)a2, (uint64_t)a3, a4, a5, (uint64_t)this, a7);
  }
  else {
    return MTSlideGesture::fireFluidGesture(result, (uint64_t)a2, (uint64_t)a3, a4, a5, this, a7);
  }
}

void std::vector<MTActionEvent>::__init_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<MTPoint>::__vallocate[abi:ne180100](a1, a4);
    uint64_t v7 = a1[1];
    if (a2 != a3)
    {
      uint64_t v8 = 0;
      do
      {
        MTActionEvent::MTActionEvent((MTActionEvent *)(v7 + v8), (const MTActionEvent *)(a2 + v8));
        v8 += 8;
      }
      while (a2 + v8 != a3);
      v7 += v8;
    }
    a1[1] = v7;
  }
}

void sub_240719C48(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]()
{
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_2650D32B8, MEMORY[0x263F8C068]);
}

void sub_240719CD0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  BOOL result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C390] + 16);
  return result;
}

void std::vector<MTActionEvent>::__assign_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>(void *a1, _DWORD *a2, _DWORD *a3, unint64_t a4)
{
  double v6 = a2;
  uint64_t v8 = a1[2];
  unsigned int v9 = (_DWORD *)*a1;
  if (a4 > (v8 - *a1) >> 3)
  {
    if (v9)
    {
      a1[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 61) {
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<MTPoint>::__vallocate[abi:ne180100](a1, v11);
    int v13 = (_DWORD *)a1[1];
    float v12 = (void **)(a1 + 1);
    unsigned int v9 = v13;
    int v14 = (char *)v13;
    if (v6 != a3)
    {
      uint64_t v15 = 0;
      do
      {
        MTActionEvent::MTActionEvent((MTActionEvent *)&v9[v15], (const MTActionEvent *)&v6[v15]);
        v15 += 2;
      }
      while (&v6[v15] != a3);
      int v14 = (char *)&v9[v15];
    }
LABEL_23:
    int64_t v21 = v14 - (char *)v9;
    goto LABEL_28;
  }
  float v12 = (void **)(a1 + 1);
  float v16 = (unsigned char *)a1[1];
  unint64_t v17 = (v16 - (unsigned char *)v9) >> 3;
  if (v17 < a4)
  {
    float v18 = &a2[2 * v17];
    if (v16 != (unsigned char *)v9)
    {
      uint64_t v19 = 8 * v17;
      do
      {
        MTActionEvent::operator=(v9, v6);
        v6 += 2;
        v9 += 2;
        v19 -= 8;
      }
      while (v19);
      unsigned int v9 = *v12;
    }
    int v14 = (char *)v9;
    if (v18 != a3)
    {
      uint64_t v20 = 0;
      do
      {
        MTActionEvent::MTActionEvent((MTActionEvent *)&v9[v20], (const MTActionEvent *)&v18[v20]);
        v20 += 2;
      }
      while (&v18[v20] != a3);
      int v14 = (char *)&v9[v20];
    }
    goto LABEL_23;
  }
  float v22 = (char *)*a1;
  if (a2 != a3)
  {
    float v23 = (char *)*a1;
    do
    {
      MTActionEvent::operator=(v23, v6);
      v6 += 2;
      v23 += 8;
      v22 += 8;
    }
    while (v6 != a3);
  }
  int64_t v21 = v22 - (char *)v9;
LABEL_28:
  *float v12 = (char *)v9 + v21;
}

void sub_240719EA8(_Unwind_Exception *a1)
{
  *uint64_t v1 = v2;
  _Unwind_Resume(a1);
}

float MTSurfaceDimensions::MTSurfaceDimensions(uint64_t a1, float result, float a3, float a4, float a5, float a6, float a7)
{
  *(void *)a1 = &unk_26F4D9B50;
  *(float *)(a1 + 8) = result;
  *(float *)(a1 + 12) = a3;
  *(float *)(a1 + 16) = a4;
  *(float *)(a1 + 20) = a5;
  *(float *)(a1 + 32) = a6;
  *(float *)(a1 + 36) = a7;
  if (a6 > 0.0 && a7 > 0.0)
  {
    BOOL result = a4 / a6;
    *(float *)(a1 + 24) = a4 / a6;
    *(float *)(a1 + 28) = a5 / a7;
  }
  return result;
}

{
  *(void *)a1 = &unk_26F4D9B50;
  *(float *)(a1 + 8) = result;
  *(float *)(a1 + 12) = a3;
  *(float *)(a1 + 16) = a4;
  *(float *)(a1 + 20) = a5;
  *(float *)(a1 + 32) = a6;
  *(float *)(a1 + 36) = a7;
  if (a6 > 0.0 && a7 > 0.0)
  {
    BOOL result = a4 / a6;
    *(float *)(a1 + 24) = a4 / a6;
    *(float *)(a1 + 28) = a5 / a7;
  }
  return result;
}

float32x2_t MTSurfaceDimensions::deriveScreenPixelsFromResolution(float32x2_t *a1, float32x2_t result, float32_t a3)
{
  if (result.f32[0] > 0.0 && a3 > 0.0)
  {
    result.f32[1] = a3;
    BOOL result = vdiv_f32(a1[2], result);
    a1[3] = result;
  }
  return result;
}

void MTSurfaceDimensions::~MTSurfaceDimensions(MTSurfaceDimensions *this)
{
}

float32x2_t MTSurfaceDimensions::updatePixelResolution_mm(float32x2_t *a1, float32x2_t result, float32_t a3)
{
  a1[4].i32[0] = result.i32[0];
  a1[4].f32[1] = a3;
  if (result.f32[0] > 0.0 && a3 > 0.0)
  {
    result.f32[1] = a3;
    BOOL result = vdiv_f32(a1[2], result);
    a1[3] = result;
  }
  return result;
}

float MTSurfaceDimensions::updateScreenBounds_mm(float *a1, float a2, float a3, float a4, float a5)
{
  a1[2] = a2;
  a1[3] = a3;
  a1[4] = a4;
  a1[5] = a5;
  float result = a1[8];
  if (result > 0.0)
  {
    float v6 = a1[9];
    if (v6 > 0.0)
    {
      float result = a4 / result;
      a1[6] = result;
      a1[7] = a5 / v6;
    }
  }
  return result;
}

float MTSurfaceDimensions::minDistanceToEdge_mm(float *a1, int a2, int a3, float a4, float a5)
{
  float v7 = a1[4];
  float v6 = a1[5];
  if (v7 <= v6) {
    float result = a1[5];
  }
  else {
    float result = a1[4];
  }
  if (!a2)
  {
    if (!a3) {
      return result;
    }
    goto LABEL_12;
  }
  float v9 = a4 / a1[6];
  float v10 = (1.0 - v9) * v7;
  if (result > v10) {
    float result = (1.0 - v9) * v7;
  }
  float v11 = v7 * v9;
  if (v11 < result) {
    float result = v11;
  }
  if (a3)
  {
LABEL_12:
    float v12 = a5 / a1[7];
    if ((float)(v6 * v12) < result) {
      float result = v6 * v12;
    }
    float v13 = (1.0 - v12) * v6;
    if (result > v13) {
      return v13;
    }
  }
  return result;
}

float MTSurfaceDimensions::convertPixelsToSurfaceFraction(uint64_t a1, float a2)
{
  return a2 / *(float *)(a1 + 24);
}

float MTSurfaceDimensions::distanceToTopEdge_mm(uint64_t a1, double a2, float a3)
{
  return (1.0 - (float)(a3 / *(float *)(a1 + 28))) * *(float *)(a1 + 20);
}

float MTSurfaceDimensions::distanceToBottomEdge_mm(uint64_t a1, double a2, float a3)
{
  return (float)(a3 / *(float *)(a1 + 28)) * *(float *)(a1 + 20);
}

float MTSurfaceDimensions::distanceToRightEdge_mm(uint64_t a1, float a2)
{
  return (1.0 - (float)(a2 / *(float *)(a1 + 24))) * *(float *)(a1 + 16);
}

float MTSurfaceDimensions::distanceToLeftEdge_mm(uint64_t a1, float a2)
{
  return (float)(a2 / *(float *)(a1 + 24)) * *(float *)(a1 + 16);
}

float MTSurfaceDimensions::convertPixelDeltaToMillimeters(MTSurfaceDimensions *this, float a2, int a3)
{
  uint64_t v3 = 32;
  if (a3) {
    uint64_t v3 = 36;
  }
  return *(float *)((char *)this + v3) * a2;
}

float MTSurfaceDimensions::convertPixelVelocityToMillimetersPerSecond(MTSurfaceDimensions *this, float a2)
{
  return (float)((float)(*((float *)this + 8) + *((float *)this + 9)) * a2) * 0.5;
}

float MTSurfaceDimensions::convertPixelDeltaToMillimetersPerSecond(MTSurfaceDimensions *this, float a2, double a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (a3 != 0.0) {
    return (float)((float)(*((float *)this + 8) + *((float *)this + 9)) * a2) / (a3 + a3);
  }
  unsigned int v5 = MTLoggingPlugin();
  float v4 = 0.0;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    int v7 = 136315906;
    uint64_t v8 = "[Error] ";
    __int16 v9 = 2080;
    float v10 = "";
    __int16 v11 = 2080;
    float v12 = "convertPixelDeltaToMillimetersPerSecond";
    __int16 v13 = 2048;
    double v14 = a3;
    _os_log_impl(&dword_2406FB000, v5, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected frame interval %g, setting velocity to 0.0", (uint8_t *)&v7, 0x2Au);
  }
  return v4;
}

void MTSurfaceDimensions::convertPixelDeltasToMillimetersPerSecond(double a1, double a2, double a3)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (a3 == 0.0)
  {
    float v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315906;
      float v6 = "[Error] ";
      __int16 v7 = 2080;
      uint64_t v8 = "";
      __int16 v9 = 2080;
      float v10 = "convertPixelDeltasToMillimetersPerSecond";
      __int16 v11 = 2048;
      double v12 = a3;
      _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected frame interval %g, setting velocity to 0.0", (uint8_t *)&v5, 0x2Au);
    }
  }
}

float MTSurfaceDimensions::convertPixelsToMillimeters(uint64_t a1, float a2)
{
  return a2 * *(float *)(a1 + 32);
}

float MTSurfaceDimensions::convertMillimetersToPixels(uint64_t a1, float a2)
{
  return a2 * (float)(*(float *)(a1 + 24) / *(float *)(a1 + 16));
}

float MTSurfaceDimensions::convertMillimetersToSurfaceFraction(uint64_t a1, float a2)
{
  return a2 / *(float *)(a1 + 16);
}

float MTSurfaceDimensions::convertSurfaceFractionToPixels(uint64_t a1, float a2)
{
  return a2 * *(float *)(a1 + 24);
}

float MTSurfaceDimensions::convertSurfaceFractionToMillimeters(uint64_t a1, float a2)
{
  return a2 * *(float *)(a1 + 16);
}

float MTSurfaceDimensions::convertSurfaceFractionVelocityToPixelsPerSecond(uint64_t a1, float a2)
{
  return a2 * *(float *)(a1 + 24);
}

void MTMouseEmbeddedHIDManager::createManager()
{
}

void sub_24071A498(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10A1C40899DFB1ALL);
  _Unwind_Resume(a1);
}

void MTMouseEmbeddedHIDManager::createEventDispatcher(MTMouseEmbeddedHIDManager *this)
{
}

uint64_t MTMouseEmbeddedHIDManager::getUserPrefs(uint64_t a1, void *a2)
{
  *a2 = 0;
  return 0;
}

uint64_t MTMouseEmbeddedHIDManager::setDeviceDefaultProperties(MTMouseEmbeddedHIDManager *this)
{
  if ((*((unsigned char *)this + 160) & 0x20) != 0) {
    (*(void (**)(MTMouseEmbeddedHIDManager *))(*(void *)this + 352))(this);
  }
  *((unsigned char *)this + 126) = 1;
  uint64_t v2 = *(uint64_t (**)(MTMouseEmbeddedHIDManager *))(*(void *)this + 744);

  return v2(this);
}

const void *MTMouseEmbeddedHIDManager::setDeviceAccelerationData(MTMouseEmbeddedHIDManager *this, CFDictionaryRef theDict)
{
  uint64_t Value = CFDictionaryGetValue(theDict, @"HIDPointerAccelerationMultiplier");
  if (Value) {
    (*(void (**)(MTMouseEmbeddedHIDManager *, __CFString *, const void *))(*(void *)this + 568))(this, @"HIDPointerAccelerationMultiplier", Value);
  }

  return MTTrackpadHIDManager::setDeviceAccelerationData(this, theDict);
}

uint64_t MTMouseEmbeddedHIDManager::setPropertyInternal(MTSimpleHIDManager *a1, int a2, const __CFString *cf, int a4)
{
  kern_return_t v13;
  NSObject *v14;
  uint64_t result;
  int v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  kern_return_t v23;
  uint64_t v24;
  uint64_t vars8;

  BOOL v24 = *MEMORY[0x263EF8340];
  if (a2 == 83)
  {
    if (!cf) {
      goto LABEL_15;
    }
  }
  else
  {
    if (a2 != 81 || !cf) {
      goto LABEL_15;
    }
    CFTypeID v8 = CFGetTypeID(cf);
    if (v8 == CFNumberGetTypeID()) {
      return 1;
    }
  }
  CFTypeID v9 = CFGetTypeID(cf);
  if (v9 != CFStringGetTypeID()
    || CFStringCompare(cf, @"TwoButton", 0)
    && CFStringCompare(cf, @"TwoButtonSwapped", 0)
    && CFStringCompare(cf, @"OneButton", 0)
    || (CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 1, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90])) == 0)
  {
LABEL_15:
    return MTTrackpadHIDManager::setPropertyInternal(a1, a2, cf, a4);
  }
  __int16 v11 = Mutable;
  CFDictionarySetValue(Mutable, @"MouseButtonMode", cf);
  (*(void (**)(MTSimpleHIDManager *))(*(void *)a1 + 80))(a1);
  io_registry_entry_t Service = MTDeviceGetService();
  uint64_t v13 = IORegistryEntrySetCFProperty(Service, @"MouseUserPreferences", v11);
  CFRelease(v11);
  if (!v13) {
    return 1;
  }
  double v14 = MTLoggingPlugin();
  float result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  if (result)
  {
    float v16 = 136315906;
    unint64_t v17 = "[Error] ";
    float v18 = 2080;
    uint64_t v19 = "";
    uint64_t v20 = 2080;
    int64_t v21 = "setPropertyInternal";
    float v22 = 1024;
    float v23 = v13;
    _os_log_impl(&dword_2406FB000, v14, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Could not set mouse user preferences on the driver 0x%08X", (uint8_t *)&v16, 0x26u);
    return 0;
  }
  return result;
}

void MTMouseEmbeddedHIDManager::~MTMouseEmbeddedHIDManager(MTMouseEmbeddedHIDManager *this)
{
  MTSimpleHIDManager::~MTSimpleHIDManager(this);

  JUMPOUT(0x2455F6CE0);
}

void MTSLGLogger::MTSLGLogger(MTSLGLogger *this)
{
  *(void *)this = 0;
  *((void *)this + MTHandMotion::clearHandMotion(this, 1) = 0;
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
}

{
  *(void *)this = 0;
  *((void *)this + MTHandMotion::clearHandMotion(this, 1) = 0;
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
}

void MTSLGLogger::~MTSLGLogger(MTSLGLogger *this)
{
  if (*(void *)this) {
    dlclose(*(void **)this);
  }
}

void MTSLGLogger::unregisterControlInterface(MTSLGLogger *this)
{
  io_object_t v2 = *((_DWORD *)this + 6);
  if (v2)
  {
    IOObjectRelease(v2);
    *((_DWORD *)this + 6) = 0;
  }
  uint64_t v3 = (IONotificationPort *)*((void *)this + 2);
  if (v3)
  {
    IONotificationPortDestroy(v3);
    *((void *)this + 2) = 0;
  }
  MTSLGLogger::removeControlService(this);
  *((void *)this + MTHandMotion::clearHandMotion(this, 1) = 0;
}

uint64_t MTSLGLogger::createLogger(MTSLGLogger *this)
{
  if (MGGetBoolAnswer()) {
    operator new();
  }
  return 0;
}

uint64_t MTSLGLogger::prepare(MTSLGLogger *this)
{
  uint64_t result = (uint64_t)dlopen((const char *)[@"/System/Library/PrivateFrameworks/StudyLog.framework/StudyLog" UTF8String], 1);
  *(void *)this = result;
  if (result)
  {
    if (MTSLGLogger::prepare(void)::onceToken != -1) {
      dispatch_once(&MTSLGLogger::prepare(void)::onceToken, &__block_literal_global);
    }
    if (SLGLogClass)
    {
      uint64_t v3 = MTLoggingPlugin();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)float v4 = 0;
        _os_log_impl(&dword_2406FB000, v3, OS_LOG_TYPE_DEFAULT, "StudyLog logger: prepared", v4, 2u);
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void MTSLGLogger::registerControlInterface(IONotificationPort **this, NSObject *a2)
{
  kern_return_t v9;
  NSObject *v10;
  NSObject *v11;
  uint8_t v12[16];

  float v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)double v12 = 0;
    _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_DEFAULT, "StudyLog logger: register for control interface", v12, 2u);
  }
  MTSLGLogger::unregisterControlInterface((MTSLGLogger *)this);
  this[1] = (IONotificationPort *)a2;
  int v5 = IONotificationPortCreate(0);
  this[2] = v5;
  if (v5)
  {
    IONotificationPortSetDispatchQueue(v5, a2);
    float v6 = this[2];
    CFDictionaryRef v7 = IOServiceNameMatching("AppleMultitouchDevice");
    CFTypeID v8 = (io_iterator_t *)(this + 3);
    CFTypeID v9 = IOServiceAddMatchingNotification(v6, "IOServiceFirstMatch", v7, (IOServiceMatchingCallback)MTSLGLoggerControlServiceMatchedCallback, this, (io_iterator_t *)this + 6);
    if (v9 || !*v8)
    {
      float v10 = MTLoggingPlugin();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        MTSLGLogger::registerControlInterface((unsigned int *)this + 6, v9, v10);
      }
      IONotificationPortDestroy(this[2]);
      this[2] = 0;
    }
    else
    {
      MTSLGLoggerControlServiceMatchedCallback((MTSLGLogger *)this, *v8);
    }
  }
  else
  {
    __int16 v11 = MTLoggingPlugin();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      MTSLGLogger::registerControlInterface();
    }
  }
}

uint64_t MTSLGLoggerControlServiceMatchedCallback(MTSLGLogger *a1, io_iterator_t iterator)
{
  uint64_t result = IOIteratorIsValid(iterator);
  if (result)
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    do
    {
      uint64_t result = IOIteratorNext(iterator);
      if (!result) {
        break;
      }
      io_object_t v5 = result;
      CFArrayRef CFProperty = (const __CFArray *)IORegistryEntryCreateCFProperty(result, @"DeviceUsagePairs", v4, 0);
      if (CFProperty)
      {
        CFArrayRef v7 = CFProperty;
        if (CFArrayGetCount(CFProperty) < 1)
        {
LABEL_12:
          CFRelease(v7);
        }
        else
        {
          CFIndex v8 = 0;
          while (1)
          {
            CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, v8);
            CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"DeviceUsagePage");
            CFNumberRef v11 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"DeviceUsage");
            uint64_t valuePtr = 0;
            CFNumberGetValue(Value, kCFNumberSInt32Type, (char *)&valuePtr + 4);
            CFNumberGetValue(v11, kCFNumberSInt32Type, &valuePtr);
            if (HIDWORD(valuePtr) == 13 && valuePtr == 0) {
              break;
            }
            if (++v8 >= CFArrayGetCount(v7)) {
              goto LABEL_12;
            }
          }
          CFRelease(v7);
          MTSLGLogger::addControlService(a1);
        }
      }
      IOObjectRelease(v5);
      uint64_t result = IOIteratorIsValid(iterator);
    }
    while (result);
  }
  return result;
}

void MTSLGLogger::removeControlService(MTSLGLogger *this)
{
  if (*((void *)this + 4))
  {
    MTDeviceStop();
    MTDeviceRelease();
    *((void *)this + 4) = 0;
  }
  io_object_t v2 = *((void *)this + 5);
  if (v2)
  {
    dispatch_source_cancel(v2);
    *((void *)this + 5) = 0;
  }
}

void MTSLGLogger::addControlService(MTSLGLogger *this)
{
  io_object_t v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFNumberRef v11 = 0;
    _os_log_impl(&dword_2406FB000, v2, OS_LOG_TYPE_DEFAULT, "StudyLog logger: control interface service appeared", v11, 2u);
  }
  MTSLGLogger::removeControlService(this);
  uint64_t v3 = MTDeviceCreateFromService();
  *((void *)this + 4) = v3;
  if (!v3)
  {
    float v6 = MTLoggingPlugin();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      MTSLGLogger::addControlService();
    }
    goto LABEL_16;
  }
  int v4 = MTDeviceStart();
  if (v4)
  {
    int v7 = v4;
    CFIndex v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      MTSLGLogger::addControlService(v7, v8);
    }
    goto LABEL_16;
  }
  uint64_t MultitouchDispatchSource = MTDeviceCreateMultitouchDispatchSource();
  *((void *)this + 5) = MultitouchDispatchSource;
  if (!MultitouchDispatchSource)
  {
    CFTypeID v9 = MTLoggingPlugin();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      MTSLGLogger::addControlService();
    }
    goto LABEL_16;
  }
  if ((MTRegisterProcessedFrameCallback() & 1) == 0)
  {
    float v10 = MTLoggingPlugin();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      MTSLGLogger::addControlService();
    }
LABEL_16:
    MTSLGLogger::removeControlService(this);
  }
}

void MTSLGLoggerProcessedFrameCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a2 + 3128))
  {
    unint64_t v5 = 0;
    uint64_t v6 = a2 + 3136;
    do
    {
      MTSLGLogger::logImages(a3, *(void *)(v6 + 8 * v5) + 40, *(void *)(v6 + 8 * v5));
      ++v5;
    }
    while (v5 < *(unsigned int *)(a2 + 3128));
  }
}

void *MTSLGLogger::isSLGEnabled(MTSLGLogger *this)
{
  SEL v1 = NSSelectorFromString(&cfstr_Sharedinstance.isa);
  SEL v2 = NSSelectorFromString(&cfstr_Isenabled.isa);
  uint64_t result = (void *)[(id)SLGLogClass performSelector:v1];
  if (result) {
    return (void *)([result performSelector:v2] != 0);
  }
  return result;
}

MTSLGLogger *MTSLGLogger::logString(MTSLGLogger *this, const __CFString *a2)
{
  SEL v3 = NSSelectorFromString(&cfstr_Sharedinstance.isa);
  uint64_t result = (MTSLGLogger *)NSSelectorFromString(&cfstr_Log.isa);
  if (a2)
  {
    if (SLGLogClass)
    {
      unint64_t v5 = result;
      uint64_t result = (MTSLGLogger *)MTSLGLogger::isSLGEnabled(result);
      if (result)
      {
        uint64_t v6 = (void *)[(id)SLGLogClass performSelector:v3];
        return (MTSLGLogger *)[v6 performSelector:v5 withObject:a2];
      }
    }
  }
  return result;
}

void MTSLGLogger::logPaths(uint64_t a1, uint64_t a2, unsigned int a3)
{
  SEL v5 = NSSelectorFromString(&cfstr_Sharedinstance.isa);
  uint64_t v6 = (MTSLGLogger *)NSSelectorFromString(&cfstr_Log.isa);
  if (a3)
  {
    if (a2)
    {
      if (SLGLogClass)
      {
        int v7 = v6;
        if (MTSLGLogger::isSLGEnabled(v6))
        {
          CFIndex v8 = (void *)MEMORY[0x2455F7150]();
          PathsDescriptor = MTSLGLogger::createPathsDescriptor((uint64_t)v8, a2, a3);
          if (PathsDescriptor)
          {
            float v10 = PathsDescriptor;
            objc_msgSend((id)objc_msgSend((id)SLGLogClass, "performSelector:", v5), "performSelector:withObject:", v7, PathsDescriptor);
            CFRelease(v10);
          }
        }
      }
    }
  }
}

void *MTSLGLogger::createPathsDescriptor(uint64_t a1, uint64_t a2, unsigned int a3)
{
  SEL v3 = 0;
  v26[22] = *MEMORY[0x263EF8340];
  if (a3 && a2 && SLGLogClass)
  {
    SEL v3 = objc_opt_new();
    uint64_t v6 = 0;
    do
    {
      v25[0] = @"frame_number";
      v26[0] = [NSNumber numberWithLong:*(void *)(a2 + v6)];
      v25[1] = @"device_timestamp";
      double v7 = *(double *)(a2 + v6 + 8);
      *(float *)&double v7 = v7;
      v26[1] = [MEMORY[0x263F087B0] numberWithFloat:v7];
      v25[2] = @"path_id";
      v26[2] = [NSNumber numberWithInt:*(unsigned int *)(a2 + v6 + 16)];
      v25[3] = @"path_stage";
      v26[3] = [NSNumber numberWithUnsignedInt:*(unsigned int *)(a2 + v6 + 20)];
      v25[4] = @"finger_id";
      v26[4] = [NSNumber numberWithUnsignedInt:*(unsigned int *)(a2 + v6 + 24)];
      v25[5] = @"hand_id";
      v26[5] = [NSNumber numberWithInt:*(unsigned int *)(a2 + v6 + 28)];
      v25[6] = @"position_x";
      LODWORD(v8) = *(_DWORD *)(a2 + v6 + 32);
      v26[6] = [MEMORY[0x263F087B0] numberWithFloat:v8];
      v25[7] = @"position_y";
      LODWORD(v9) = *(_DWORD *)(a2 + v6 + 36);
      v26[7] = [MEMORY[0x263F087B0] numberWithFloat:v9];
      v25[8] = @"velocity_x";
      LODWORD(v10) = *(_DWORD *)(a2 + v6 + 40);
      v26[8] = [MEMORY[0x263F087B0] numberWithFloat:v10];
      v25[9] = @"velocity_y";
      LODWORD(v1MTHandMotion::clearHandMotion(this, 1) = *(_DWORD *)(a2 + v6 + 44);
      v26[9] = [MEMORY[0x263F087B0] numberWithFloat:v11];
      v25[10] = @"proximity";
      LODWORD(v12) = *(_DWORD *)(a2 + v6 + 48);
      v26[10] = [MEMORY[0x263F087B0] numberWithFloat:v12];
      v25[11] = @"force";
      LODWORD(v13) = *(_DWORD *)(a2 + v6 + 52);
      v26[11] = [MEMORY[0x263F087B0] numberWithFloat:v13];
      v25[12] = @"orientation";
      LODWORD(v14) = *(_DWORD *)(a2 + v6 + 56);
      v26[12] = [MEMORY[0x263F087B0] numberWithFloat:v14];
      v25[13] = @"major_radius_mm";
      LODWORD(v15) = *(_DWORD *)(a2 + v6 + 60);
      v26[13] = [MEMORY[0x263F087B0] numberWithFloat:v15];
      v25[14] = @"minor_radius_mm";
      LODWORD(v16) = *(_DWORD *)(a2 + v6 + 64);
      v26[14] = [MEMORY[0x263F087B0] numberWithFloat:v16];
      v25[15] = @"position_mm_x";
      LODWORD(v17) = *(_DWORD *)(a2 + v6 + 68);
      v26[15] = [MEMORY[0x263F087B0] numberWithFloat:v17];
      v25[16] = @"position_mm_y";
      LODWORD(v18) = *(_DWORD *)(a2 + v6 + 72);
      v26[16] = [MEMORY[0x263F087B0] numberWithFloat:v18];
      v25[17] = @"velocity_mm_s_x";
      LODWORD(v19) = *(_DWORD *)(a2 + v6 + 76);
      v26[17] = [MEMORY[0x263F087B0] numberWithFloat:v19];
      v25[18] = @"velocity_mm_s_y";
      LODWORD(v20) = *(_DWORD *)(a2 + v6 + 80);
      v26[18] = [MEMORY[0x263F087B0] numberWithFloat:v20];
      v25[19] = @"path_flags";
      v26[19] = objc_msgSend(NSString, "stringWithFormat:", @"0x%x", *(unsigned __int16 *)(a2 + v6 + 84));
      v25[20] = @"tilt";
      LODWORD(v2MTHandMotion::clearHandMotion(this, 1) = *(_DWORD *)(a2 + v6 + 88);
      v26[20] = [MEMORY[0x263F087B0] numberWithFloat:v21];
      v25[21] = @"zdensity";
      LODWORD(v22) = *(_DWORD *)(a2 + v6 + 92);
      v26[21] = [MEMORY[0x263F087B0] numberWithFloat:v22];
      uint64_t v23 = [NSDictionary dictionaryWithObjects:v26 forKeys:v25 count:22];
      [v3 setObject:v23, objc_msgSend(NSString, "stringWithFormat:", @"path%d", *(unsigned int *)(a2 + v6 + 16)) forKey];
      v6 += 96;
    }
    while (96 * a3 != v6);
  }
  return v3;
}

void MTSLGLogger::logImages(uint64_t a1, uint64_t a2, uint64_t a3)
{
  SEL v5 = NSSelectorFromString(&cfstr_Sharedinstance.isa);
  uint64_t v6 = (MTSLGLogger *)NSSelectorFromString(&cfstr_Log.isa);
  if (a3)
  {
    if (a2)
    {
      if (SLGLogClass)
      {
        double v7 = v6;
        if (MTSLGLogger::isSLGEnabled(v6))
        {
          double v8 = (void *)MEMORY[0x2455F7150]();
          uint64_t ImageDictionary = MTSLGLogger::createImageDictionary((uint64_t)v8, a2, a3);
          if (ImageDictionary) {
            objc_msgSend((id)objc_msgSend((id)SLGLogClass, "performSelector:", v5), "performSelector:withObject:", v7, ImageDictionary);
          }
        }
      }
    }
  }
}

uint64_t MTSLGLogger::createImageDictionary(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v8[11] = *MEMORY[0x263EF8340];
  uint64_t result = [MEMORY[0x263EFF8F8] dataWithBytesNoCopy:a2 length:2 * *(__int16 *)(a3 + 16) * (uint64_t)*(__int16 *)(a3 + 18) freeWhenDone:0];
  if (result)
  {
    SEL v5 = (void *)result;
    v7[0] = @"frame_number";
    v8[0] = [NSNumber numberWithLong:*(void *)a3];
    v7[1] = @"device_timestamp";
    double v6 = *(double *)(a3 + 8);
    *(float *)&double v6 = v6;
    v8[1] = [MEMORY[0x263F087B0] numberWithFloat:v6];
    v7[2] = @"width";
    v8[2] = [NSNumber numberWithShort:*(__int16 *)(a3 + 16)];
    v7[3] = @"height";
    v8[3] = [NSNumber numberWithShort:*(__int16 *)(a3 + 18)];
    v7[4] = @"image_region_mask";
    v8[4] = [NSNumber numberWithUnsignedInt:*(unsigned int *)(a3 + 20)];
    v7[5] = @"processing_step_mask";
    v8[5] = [NSNumber numberWithUnsignedInt:*(unsigned int *)(a3 + 24)];
    v7[6] = @"valid_pixel_ceiling";
    v8[6] = [NSNumber numberWithInt:*(unsigned int *)(a3 + 28)];
    v7[7] = @"valid_pixel_floor";
    v8[7] = [NSNumber numberWithInt:*(unsigned int *)(a3 + 32)];
    v7[8] = @"fullscale_range";
    v8[8] = [NSNumber numberWithUnsignedShort:*(unsigned __int16 *)(a3 + 36)];
    v7[9] = @"row0_at_bottom";
    v8[9] = [MEMORY[0x263F087B0] numberWithBool:*(unsigned __int8 *)(a3 + 38)];
    v7[10] = @"image";
    v8[10] = [v5 base64EncodedStringWithOptions:0];
    return [NSDictionary dictionaryWithObjects:v8 forKeys:v7 count:11];
  }
  return result;
}

Class ___ZN11MTSLGLogger7prepareEv_block_invoke()
{
  Class result = NSClassFromString(&cfstr_Slglog.isa);
  SLGLogClass = (uint64_t)result;
  return result;
}

void OUTLINED_FUNCTION_0_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void MTPListGestureConfig::MTPListGestureConfig(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
}

{
  MTGestureConfig::MTGestureConfig(a1, a2, a3, a4, a5);
}

void MTPListGestureConfig::~MTPListGestureConfig(MTPListGestureConfig *this)
{
  *(void *)this = &unk_26F4D9F70;
  SEL v2 = (const void *)*((void *)this + 10);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 10) = 0;
  }
  SEL v3 = (const void *)*((void *)this + 11);
  if (v3)
  {
    CFRelease(v3);
    *((void *)this + 1MTHandMotion::clearHandMotion(this, 1) = 0;
  }
  int v4 = (const void *)*((void *)this + 12);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 12) = 0;
  }
  SEL v5 = (const void *)*((void *)this + 13);
  if (v5)
  {
    CFRelease(v5);
    *((void *)this + 13) = 0;
  }
  double v6 = (const void *)*((void *)this + 14);
  if (v6)
  {
    CFRelease(v6);
    *((void *)this + 14) = 0;
  }

  MTGestureConfig::~MTGestureConfig(this);
}

{
  uint64_t vars8;

  MTPListGestureConfig::~MTPListGestureConfig(this);

  JUMPOUT(0x2455F6CE0);
}

void MTPListGestureConfig::setParseErrorString(MTPListGestureConfig *this, CFStringRef theString)
{
  CFStringRef v3 = (const __CFString *)*((void *)this + 14);
  if (v3 != theString)
  {
    if (v3) {
      CFRelease(v3);
    }
    *((void *)this + 14) = theString;
    if (theString)
    {
      CStringPtr = CFStringGetCStringPtr(theString, 0);
      printf("%s", CStringPtr);
    }
  }
}

CFComparisonResult MTPListGestureConfig::eventTypeCFStringToCode(MTPListGestureConfig *this, CFStringRef theString1)
{
  if (!theString1) {
    return 0;
  }
  if (CFStringCompare(theString1, @"Mouse Point", 1uLL) == kCFCompareEqualTo) {
    return 68;
  }
  if (CFStringCompare(theString1, @"Mouse Down", 1uLL) == kCFCompareEqualTo) {
    return 65;
  }
  if (CFStringCompare(theString1, @"Mouse Up", 1uLL) == kCFCompareEqualTo) {
    return 66;
  }
  if (CFStringCompare(theString1, @"Mouse Click", 1uLL) == kCFCompareEqualTo) {
    return 67;
  }
  if (CFStringCompare(theString1, @"Mouse Double Click", 1uLL) == kCFCompareEqualTo) {
    return 72;
  }
  if (CFStringCompare(theString1, @"Mouse Drag", 1uLL) == kCFCompareEqualTo) {
    return 69;
  }
  if (CFStringCompare(theString1, @"Scroll", 1uLL) == kCFCompareEqualTo) {
    return 70;
  }
  if (CFStringCompare(theString1, @"Scroll To Edge", 1uLL) == kCFCompareEqualTo) {
    return 78;
  }
  if (CFStringCompare(theString1, @"Orientation", 1uLL) == kCFCompareEqualTo) {
    return 71;
  }
  if (CFStringCompare(theString1, @"Zoom Toggle", 1uLL) == kCFCompareEqualTo) {
    return 73;
  }
  if (CFStringCompare(theString1, @"Key Down", 1uLL) == kCFCompareEqualTo) {
    return 129;
  }
  if (CFStringCompare(theString1, @"Key Up", 1uLL) == kCFCompareEqualTo) {
    return 130;
  }
  if (CFStringCompare(theString1, @"Key Stroke", 1uLL) == kCFCompareEqualTo) {
    return 128;
  }
  if (CFStringCompare(theString1, @"Swipe", 1uLL) == kCFCompareEqualTo) {
    return 133;
  }
  if (CFStringCompare(theString1, @"Fluid Navigation", 1uLL) == kCFCompareEqualTo) {
    return 36;
  }
  if (CFStringCompare(theString1, @"Fluid Dock", 1uLL) == kCFCompareEqualTo) {
    return 37;
  }
  if (CFStringCompare(theString1, @"Fluid Notification", 1uLL) == kCFCompareEqualTo) {
    return 38;
  }
  if (CFStringCompare(theString1, @"Fluid Notification Alt", 1uLL) == kCFCompareEqualTo) {
    return 39;
  }
  if (CFStringCompare(theString1, @"Show Definition", 1uLL) == kCFCompareEqualTo) {
    return 140;
  }
  if (CFStringCompare(theString1, @"Key Consumer App", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(theString1, @"Symbolic Hotkey", 1uLL) == kCFCompareEqualTo)
  {
    return 134;
  }
  if (CFStringCompare(theString1, @"System", 1uLL) == kCFCompareEqualTo) {
    return 135;
  }
  if (CFStringCompare(theString1, @"Gesture Ended", 1uLL) == kCFCompareEqualTo) {
    return 32;
  }
  if (CFStringCompare(theString1, @"Gesture Started", 1uLL) == kCFCompareEqualTo) {
    return 33;
  }
  CFComparisonResult result = CFStringCompare(theString1, @"Window Move", 1uLL);
  if (result)
  {
    CFStringCompare(theString1, @"Window Size", 1uLL);
    return 0;
  }
  return result;
}

uint64_t MTPListGestureConfig::keyCodeCFStringToCode(MTPListGestureConfig *this, CFStringRef theString1)
{
  uint64_t v3 = 0;
  while (1)
  {
    CFStringRef v4 = (const __CFString *)gUSBKeyNames[v3];
    if (v4)
    {
      if (CFStringCompare(theString1, v4, 1uLL) == kCFCompareEqualTo) {
        break;
      }
    }
    if (++v3 == 256)
    {
      LOWORD(v3) = 0;
      return (unsigned __int16)v3;
    }
  }
  return (unsigned __int16)v3;
}

uint64_t MTPListGestureConfig::modifiersCFStringToMask(MTPListGestureConfig *this, const __CFString *cf)
{
  if (!cf) {
    return 0;
  }
  CFTypeID v3 = CFGetTypeID(cf);
  if (v3 != CFStringGetTypeID()) {
    return 0;
  }
  if (CFStringFind(cf, @"Shift", 1uLL).location == -1) {
    unsigned int v4 = 0;
  }
  else {
    unsigned int v4 = 34;
  }
  if (CFStringFind(cf, @"Cmd", 1uLL).location != -1) {
    v4 |= 0x88u;
  }
  if (CFStringFind(cf, @"Alt", 1uLL).location != -1) {
    v4 |= 0x44u;
  }
  if (CFStringFind(cf, @"Ctrl", 1uLL).location != -1) {
    v4 |= 0x11u;
  }
  if (CFStringFind(cf, @"Button1", 1uLL).location != -1) {
    v4 |= 0x100u;
  }
  if (CFStringFind(cf, @"Button2", 1uLL).location != -1) {
    v4 |= 0x200u;
  }
  if (CFStringFind(cf, @"Button3", 1uLL).location != -1) {
    v4 |= 0x400u;
  }
  if (CFStringFind(cf, @"Button4", 1uLL).location != -1) {
    v4 |= 0x800u;
  }
  if (CFStringFind(cf, @"Button5", 1uLL).location != -1) {
    v4 |= 0x1000u;
  }
  if (CFStringFind(cf, @"Button6", 1uLL).location != -1) {
    v4 |= 0x2000u;
  }
  if (CFStringFind(cf, @"Button7", 1uLL).location == -1) {
    return v4;
  }
  else {
    return v4 | 0x4000;
  }
}

void MTPListGestureConfig::parseCreateActionEvent(MTPListGestureConfig *a1, const __CFDictionary *cf, uint64_t a3)
{
  if (cf && (CFTypeID v6 = CFGetTypeID(cf), v6 == CFDictionaryGetTypeID()))
  {
    __int16 v31 = 0;
    int valuePtr = 0;
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(cf, @"EventType");
    if (Value
      && (CFStringRef v8 = Value,
          CFTypeID v9 = CFGetTypeID(Value),
          double v10 = (MTPListGestureConfig *)CFStringGetTypeID(),
          (MTPListGestureConfig *)v9 == v10))
    {
      int v11 = MTPListGestureConfig::eventTypeCFStringToCode(v10, v8);
      if (v11)
      {
        __int16 v12 = v11;
        CFStringRef v13 = (const __CFString *)CFDictionaryGetValue(cf, @"Modifiers");
        if (!v13) {
          goto LABEL_19;
        }
        CFStringRef v14 = v13;
        CFTypeID v15 = CFGetTypeID(v13);
        CFTypeID TypeID = (MTPListGestureConfig *)CFStringGetTypeID();
        if ((MTPListGestureConfig *)v15 == TypeID)
        {
          int v17 = MTPListGestureConfig::modifiersCFStringToMask(TypeID, v14);
          int valuePtr = v17;
        }
        else
        {
          CFTypeID v19 = CFGetTypeID(v14);
          if (v19 != CFNumberGetTypeID())
          {
LABEL_18:
            CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ Modifier '%@' not recognized\n", @"ERROR in PListGestureParser:", v14);
            MTPListGestureConfig::setParseErrorString(a1, v20);
LABEL_19:
            CFStringRef v21 = (const __CFString *)CFDictionaryGetValue(cf, @"KeyCode");
            if (v21)
            {
              CFStringRef v22 = v21;
              CFTypeID v23 = CFGetTypeID(v21);
              BOOL v24 = (MTPListGestureConfig *)CFStringGetTypeID();
              if ((MTPListGestureConfig *)v23 == v24)
              {
                __int16 v25 = MTPListGestureConfig::keyCodeCFStringToCode(v24, v22);
                __int16 v31 = v25;
LABEL_25:
                unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
                MTActionEvent::MTActionEvent((MTActionEvent *)&v29, v12, valuePtr, v25);
                unint64_t v27 = *(void *)(a3 + 8);
                if (v27 >= *(void *)(a3 + 16))
                {
                  uint64_t v28 = std::vector<MTActionEvent>::__push_back_slow_path<MTActionEvent const&>(a3, (const MTActionEvent *)&v29);
                }
                else
                {
                  MTActionEvent::MTActionEvent(*(MTActionEvent **)(a3 + 8), (const MTActionEvent *)&v29);
                  uint64_t v28 = v27 + 8;
                  *(void *)(a3 + 8) = v27 + 8;
                }
                *(void *)(a3 + 8) = v28;
                return;
              }
              CFTypeID v26 = CFGetTypeID(v22);
              if (v26 == CFNumberGetTypeID())
              {
                CFNumberGetValue((CFNumberRef)v22, kCFNumberSInt16Type, &v31);
                __int16 v25 = v31;
                goto LABEL_25;
              }
            }
            __int16 v25 = 0;
            goto LABEL_25;
          }
          CFNumberGetValue((CFNumberRef)v14, kCFNumberSInt32Type, &valuePtr);
          int v17 = valuePtr;
        }
        if (v17) {
          goto LABEL_19;
        }
        goto LABEL_18;
      }
      CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ Unknown or unsupported %@ '%@'\n", @"ERROR in PListGestureParser:", @"EventType", v8);
    }
    else
    {
      CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ Action Event missing '%@' key\n", @"ERROR in PListGestureParser:", @"EventType");
    }
  }
  else
  {
    CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ Action Event not a CFDictionary\n", @"ERROR in PListGestureParser:");
  }

  MTPListGestureConfig::setParseErrorString(a1, v18);
}

void sub_24071C204(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void MTPListGestureConfig::lookupOrParseActionEvents(CFDictionaryRef *a1, CFDictionaryRef theDict, void *a3)
{
  a3[1] = *a3;
  CFStringRef Value = CFDictionaryGetValue(theDict, @"Action");
  if (Value)
  {
    CFTypeID v6 = Value;
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 == CFStringGetTypeID())
    {
      CFArrayRef v8 = (const __CFArray *)CFDictionaryGetValue(a1[13], v6);
      if (v8 && (CFArrayRef v9 = v8, v10 = CFGetTypeID(v8), v10 == CFArrayGetTypeID()))
      {
        CFIndex Count = CFArrayGetCount(v9);
        if (Count >= 1)
        {
          CFIndex v12 = Count;
          for (CFIndex i = 0; i != v12; ++i)
          {
            CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v9, i);
            MTPListGestureConfig::parseCreateActionEvent((MTPListGestureConfig *)a1, ValueAtIndex, (uint64_t)a3);
          }
        }
      }
      else
      {
        CFStringRef v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ Action '%@' has no event array\n", @"ERROR in PListGestureParser:", v6);
        MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)a1, v15);
      }
    }
  }
}

uint64_t MTPListGestureConfig::parseGestureMotionCode(MTPListGestureConfig *this, CFDictionaryRef theDict)
{
  if (!theDict
    || (CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"Motion")) == 0
    || (v4 = Value, CFTypeID v5 = CFGetTypeID(Value), v5 != CFStringGetTypeID()))
  {
    CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ Gesture's '%@' key missing\n", @"ERROR in PListGestureParser:", @"Motion");
LABEL_32:
    MTPListGestureConfig::setParseErrorString(this, v7);
    return 0;
  }
  if (CFStringCompare(v4, @"Tap", 1uLL) == kCFCompareEqualTo) {
    return 12288;
  }
  if (CFStringCompare(v4, @"DroppedFingerTap", 1uLL) == kCFCompareEqualTo) {
    return 24576;
  }
  if (CFStringCompare(v4, @"DoubleTap", 1uLL) == kCFCompareEqualTo) {
    return 28672;
  }
  if (CFStringCompare(v4, @"Hold", 1uLL) == kCFCompareEqualTo) {
    return 4096;
  }
  if (CFStringCompare(v4, @"Lift", 1uLL) == kCFCompareEqualTo) {
    return 0x2000;
  }
  if (CFStringCompare(v4, @"Translate", 1uLL) == kCFCompareEqualTo) {
    return 15;
  }
  if (CFStringCompare(v4, @"Horizontal", 1uLL) == kCFCompareEqualTo) {
    return 3;
  }
  if (CFStringCompare(v4, @"Vertical", 1uLL) == kCFCompareEqualTo) {
    return 12;
  }
  if (CFStringCompare(v4, @"Down", 1uLL) == kCFCompareEqualTo) {
    return 8;
  }
  if (CFStringCompare(v4, @"Up", 1uLL) == kCFCompareEqualTo) {
    return 4;
  }
  if (CFStringCompare(v4, @"Left", 1uLL) == kCFCompareEqualTo) {
    return 2;
  }
  uint64_t v6 = 1;
  if (CFStringCompare(v4, @"Right", 1uLL))
  {
    if (CFStringCompare(v4, @"LowerLeft", 1uLL) == kCFCompareEqualTo) {
      return 10;
    }
    if (CFStringCompare(v4, @"LowerRight", 1uLL) == kCFCompareEqualTo) {
      return 9;
    }
    if (CFStringCompare(v4, @"UpperLeft", 1uLL) == kCFCompareEqualTo) {
      return 6;
    }
    if (CFStringCompare(v4, @"UpperRight", 1uLL) == kCFCompareEqualTo) {
      return 5;
    }
    if (CFStringCompare(v4, @"Scale", 1uLL) == kCFCompareEqualTo) {
      return 48;
    }
    if (CFStringCompare(v4, @"Expand", 1uLL) == kCFCompareEqualTo) {
      return 16;
    }
    if (CFStringCompare(v4, @"Contract", 1uLL) == kCFCompareEqualTo) {
      return 32;
    }
    if (CFStringCompare(v4, @"Rotate", 1uLL) == kCFCompareEqualTo) {
      return 192;
    }
    if (CFStringCompare(v4, @"RotateLeft", 1uLL) == kCFCompareEqualTo) {
      return 64;
    }
    if (CFStringCompare(v4, @"RotateRight", 1uLL) == kCFCompareEqualTo) {
      return 128;
    }
    if (CFStringCompare(v4, @"Scale+Rotate", 1uLL) == kCFCompareEqualTo) {
      return 240;
    }
    if (CFStringCompare(v4, @"Translate+Scale", 1uLL) == kCFCompareEqualTo) {
      return 63;
    }
    if (CFStringCompare(v4, @"Translate+Rotate", 1uLL) == kCFCompareEqualTo) {
      return 207;
    }
    if (CFStringCompare(v4, @"Translate+Scale+Rotate", 1uLL) == kCFCompareEqualTo) {
      return 255;
    }
    CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ Unrecognized gesture %@ '%@'\n", @"ERROR in PListGestureParser:", @"Motion", v4);
    goto LABEL_32;
  }
  return v6;
}

uint64_t MTPListGestureConfig::parseFloatValue(MTPListGestureConfig *this, CFDictionaryRef theDict, const __CFString *key, float *a4, const __CFString *a5)
{
  uint64_t result = (uint64_t)CFDictionaryGetValue(theDict, key);
  if (result)
  {
    CFNumberRef v10 = (const __CFNumber *)result;
    CFTypeID v11 = CFGetTypeID((CFTypeRef)result);
    if (v11 == CFNumberGetTypeID())
    {
      if (CFNumberGetValue(v10, kCFNumberFloat32Type, a4)) {
        return 1;
      }
      CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ Corrupt %@ value in %@\n", @"ERROR in PListGestureParser:", key, a5);
    }
    else
    {
      CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ %@ value should be a number in %@\n", @"ERROR in PListGestureParser:", key, a5);
    }
    MTPListGestureConfig::setParseErrorString(this, v12);
    return 0;
  }
  return result;
}

MTPListGestureConfig *MTPListGestureConfig::parseMotionSensitivity(MTPListGestureConfig *result, const __CFDictionary *a2, uint64_t a3)
{
  if (a2)
  {
    CFTypeID v5 = result;
    uint64_t v22 = 0;
    float v21 = 0.0635;
    float v19 = 1.0;
    float v20 = 400.0;
    if (MTPListGestureConfig::parseFloatValue(result, a2, @"Resolution_dpi", &v20, @"Motion Sensitivity"))
    {
      if (v20 != 0.0)
      {
        float v6 = 25.4 / v20;
        float v21 = v6;
      }
    }
    else if ((MTPListGestureConfig::parseFloatValue(v5, a2, @"Resolution_mm", &v21, @"Motion Sensitivity") & 1) == 0)
    {
      puts("Missing resolution_dpi/mm key!");
      CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ Missing %@ value for Motion Sensitivity\n", @"ERROR in PListGestureParser:", @"Resolution_mm");
      MTPListGestureConfig::setParseErrorString(v5, v7);
    }
    MTPListGestureConfig::parseFloatValue(v5, a2, @"CommitMultiplier", &v19, @"Motion Sensitivity");
    MTPListGestureConfig::parseFloatValue(v5, a2, @"CommitMultiplier", &v19, @"Motion Sensitivity");
    MTPListGestureConfig::parseFloatValue(v5, a2, @"AccelPower", (float *)&v22 + 1, @"Motion Sensitivity");
    MTPListGestureConfig::parseFloatValue(v5, a2, @"AccelThresh", (float *)&v22, @"Motion Sensitivity");
    float v8 = v21;
    int v9 = v22;
    float v10 = v19;
    int v11 = HIDWORD(v22);
    float v18 = 0.0;
    int v12 = 0;
    if (MTPListGestureConfig::parseFloatValue(v5, a2, @"FrameDecay_mm", &v18, @"Motion Sensitivity"))float v13 = v18; {
    else
    }
      float v13 = 0.0;
    uint64_t v17 = 0;
    float v16 = 0.01;
    uint64_t result = (MTPListGestureConfig *)MTPListGestureConfig::parseFloatValue(v5, a2, @"FluidAnimationStartThreshold_mm", (float *)&v17 + 1, @"Motion Sensitivity");
    if (result
      && (uint64_t result = (MTPListGestureConfig *)MTPListGestureConfig::parseFloatValue(v5, a2, @"FluidSwipeCompleteThreshold_mm", (float *)&v17, @"Motion Sensitivity"), result))
    {
      uint64_t result = (MTPListGestureConfig *)MTPListGestureConfig::parseFloatValue(v5, a2, @"FluidSwipeInertiaTime_s", &v16, @"Motion Sensitivity");
      int v14 = 0;
      float v15 = 0.0;
      if (result)
      {
        int v12 = HIDWORD(v17);
        int v14 = v17;
        float v15 = v16;
      }
    }
    else
    {
      int v14 = 0;
      float v15 = 0.0;
    }
    *(float *)a3 = v8;
    *(float *)(a3 + 4) = v10;
    *(_DWORD *)(a3 + 8) = v9;
    *(_DWORD *)(a3 + 12) = v11;
    *(float *)(a3 + 16) = v13;
    *(_DWORD *)(a3 + 20) = v12;
    *(_DWORD *)(a3 + 24) = v14;
    *(float *)(a3 + 28) = v15;
  }
  return result;
}

uint64_t MTPListGestureConfig::extractMotionSensitivity(CFDictionaryRef *a1, CFDictionaryRef theDict, void *a3)
{
  *a3 = 0x3F80000000000000;
  a3[2] = 0;
  a3[3] = 0;
  a3[1] = 0;
  uint64_t result = (uint64_t)CFDictionaryGetValue(theDict, @"Sensitivity");
  if (result)
  {
    float v6 = (const void *)result;
    CFTypeID v7 = CFGetTypeID((CFTypeRef)result);
    if (v7 == CFStringGetTypeID())
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a1[12], v6);
      if (Value)
      {
        CFDictionaryRef v9 = Value;
        CFTypeID v10 = CFGetTypeID(Value);
        if (v10 == CFDictionaryGetTypeID())
        {
          int v11 = (MTPListGestureConfig *)a1;
          CFDictionaryRef v12 = v9;
LABEL_8:
          MTPListGestureConfig::parseMotionSensitivity(v11, v12, (uint64_t)a3);
          return 1;
        }
      }
      CFStringRef v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ Motion Sensitivity dictionary '%@' not found in library\n", @"ERROR in PListGestureParser:", v6);
      MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)a1, v14);
    }
    else
    {
      CFTypeID v13 = CFGetTypeID(v6);
      if (v13 == CFDictionaryGetTypeID())
      {
        int v11 = (MTPListGestureConfig *)a1;
        CFDictionaryRef v12 = (const __CFDictionary *)v6;
        goto LABEL_8;
      }
    }
    return 0;
  }
  return result;
}

uint64_t MTPListGestureConfig::extractGestureCategory(MTPListGestureConfig *this, CFDictionaryRef theDict)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"Category");
  if (!Value) {
    return 0;
  }
  CFStringRef v4 = Value;
  CFTypeID v5 = CFGetTypeID(Value);
  if (v5 != CFStringGetTypeID()) {
    return 0;
  }
  uint64_t v6 = 1;
  if (CFStringCompare(v4, @"OneFingerPoint", 1uLL))
  {
    if (CFStringCompare(v4, @"FiveFingerPoint", 1uLL) == kCFCompareEqualTo) {
      return 2;
    }
    if (CFStringCompare(v4, @"TwoFingerDrag", 1uLL) == kCFCompareEqualTo) {
      return 4;
    }
    if (CFStringCompare(v4, @"AlreadyMouse", 1uLL) == kCFCompareEqualTo) {
      return 16;
    }
    if (CFStringCompare(v4, @"ScrollPan", 1uLL) == kCFCompareEqualTo) {
      return 64;
    }
    if (CFStringCompare(v4, @"TwoFingerScroll", 1uLL) == kCFCompareEqualTo) {
      return 128;
    }
    if (CFStringCompare(v4, @"TwoFingerNotificationCenter", 1uLL) == kCFCompareEqualTo) {
      return 32;
    }
    if (CFStringCompare(v4, @"TwoFingerNotificationCenterAlt", 1uLL) == kCFCompareEqualTo) {
      return 256;
    }
    CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ Gesture Category '%@' not supported\n", @"ERROR in PListGestureParser:", v4);
    MTPListGestureConfig::setParseErrorString(this, v7);
    return 0;
  }
  return v6;
}

void MTPListGestureConfig::parseGesture(CFDictionaryRef *a1, const __CFDictionary *a2, void **a3, long long *a4)
{
  if (a2)
  {
    float v70 = 0;
    uint64_t v71 = 0;
    uint64_t v72 = 0;
    MTPListGestureConfig::lookupOrParseActionEvents(a1, a2, &v70);
    unsigned int v8 = MTPListGestureConfig::parseGestureMotionCode((MTPListGestureConfig *)a1, a2);
    switch((unsigned __int16)(v8 >> 12) | (unsigned __int16)(16 * v8))
    {
      case 0:
        break;
      case 1:
        CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"Trigger");
        CFStringRef v10 = Value;
        if (Value && (CFTypeID v11 = CFGetTypeID(Value), v11 == CFStringGetTypeID()))
        {
          CFIndex location = CFStringFind(v10, @"BeginSlide", 1uLL).location;
          CFIndex v13 = CFStringFind(v10, @"MayBegin", 1uLL).location;
          CFIndex v14 = CFStringFind(v10, @"TimeHeld", 1uLL).location;
          if (location == -1) {
            __int16 v15 = 1;
          }
          else {
            __int16 v15 = 9;
          }
          if (v13 != -1) {
            v15 |= 0x100u;
          }
          if (v14 != -1) {
            v15 |= 4u;
          }
        }
        else
        {
          __int16 v15 = 1;
        }
        *((_WORD *)a3 + 60) = v15;
        CFNumberRef v42 = (const __CFNumber *)CFDictionaryGetValue(a2, @"HoldTime");
        CFNumberRef v43 = v42;
        if (v42 && (CFTypeID v44 = CFGetTypeID(v42), v44 == CFNumberGetTypeID()))
        {
          LOWORD(valuePtr[0]) = 0;
          CFNumberGetValue(v43, kCFNumberSInt16Type, valuePtr);
          __int16 v45 = valuePtr[0];
        }
        else
        {
          __int16 v45 = 350;
        }
        *((_WORD *)a3 + 6MTHandMotion::clearHandMotion(this, 1) = v45;
        __int16 v46 = a3 + 12;
        if (a3 + 12 != (void **)&v70) {
          goto LABEL_83;
        }
        break;
      case 2:
        *((_WORD *)a3 + 76) = 2;
        CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(a2, @"StopTime");
        CFNumberRef v18 = v17;
        if (v17 && (CFTypeID v19 = CFGetTypeID(v17), v19 == CFNumberGetTypeID()))
        {
          LOWORD(valuePtr[0]) = 0;
          CFNumberGetValue(v18, kCFNumberSInt16Type, valuePtr);
          __int16 v20 = valuePtr[0];
        }
        else
        {
          __int16 v20 = 200;
        }
        *((_WORD *)a3 + 77) = v20;
        __int16 v46 = a3 + 16;
        if (a3 + 16 != (void **)&v70) {
LABEL_83:
        }
          std::vector<MTActionEvent>::__assign_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>(v46, v70, v71, (v71 - v70) >> 3);
        break;
      case 3:
        *((_WORD *)a3 + 12) = 3;
        if (&v70 != (char **)a3) {
          goto LABEL_76;
        }
        break;
      case 6:
        *((_WORD *)a3 + 28) = 3;
        long long v41 = a3 + 4;
        goto LABEL_75;
      case 7:
        *((_WORD *)a3 + 44) = 3;
        long long v41 = a3 + 8;
LABEL_75:
        a3 = v41;
        if (v41 != (void **)&v70) {
LABEL_76:
        }
          std::vector<MTActionEvent>::__assign_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>(a3, v70, v71, (v71 - v70) >> 3);
        break;
      default:
        int v21 = v8;
        if (v8 == 128 || v8 == 32) {
          int v21 = v8 | 0x1000000;
        }
        char v22 = v8 - 1;
        float v23 = 0.0;
        float v24 = 0.0;
        if ((v8 - 1) <= 0xBu)
        {
          float v23 = flt_24074F678[v22];
          float v24 = flt_24074F6A8[v22];
        }
        CFStringRef v25 = (const __CFString *)CFDictionaryGetValue(a2, @"Trigger");
        CFStringRef v26 = v25;
        if (v25)
        {
          CFTypeID v27 = CFGetTypeID(v25);
          if (v27 == CFStringGetTypeID())
          {
            CFIndex v66 = CFStringFind(v26, @"OnceOnly", 1uLL).location;
            CFIndex v65 = CFStringFind(v26, @"OncePerDirection", 1uLL).location;
            CFIndex v64 = CFStringFind(v26, @"OnceIfQuick", 1uLL).location;
            CFIndex v63 = CFStringFind(v26, @"OnlyIfQuick", 1uLL).location;
            CFIndex v62 = CFStringFind(v26, @"OnlyFromEdge", 1uLL).location;
            CFIndex v61 = CFStringFind(v26, @"IfWidelySeparatedFingers", 1uLL).location;
            CFIndex v60 = CFStringFind(v26, @"OnlyIfAllMoving", 1uLL).location;
            CFIndex v59 = CFStringFind(v26, @"OnlyIfFourMoving", 1uLL).location;
            CFIndex v58 = CFStringFind(v26, @"OnlyIfSomeMoving", 1uLL).location;
            CFIndex v57 = CFStringFind(v26, @"OnlyIfTwoMoving", 1uLL).location;
            CFIndex v56 = CFStringFind(v26, @"OnlyIfOneMoving", 1uLL).location;
            CFIndex v55 = CFStringFind(v26, @"RequiresForce", 1uLL).location;
            CFIndex v54 = CFStringFind(v26, @"WaitForQuick", 1uLL).location;
            CFIndex v28 = CFStringFind(v26, @"ToggleAlongAxis", 1uLL).location;
            CFIndex v29 = CFStringFind(v26, @"Momentum", 1uLL).location;
            CFIndex v30 = CFStringFind(v26, @"LowCommitSensitivity", 1uLL).location;
            CFIndex v31 = CFStringFind(v26, @"AccelOnlyIfSomeResting", 1uLL).location;
            CFIndex v32 = CFStringFind(v26, @"Repetitive", 1uLL).location;
            unsigned int v33 = v21 | 0x1000;
            if (v66 == -1) {
              unsigned int v33 = v21;
            }
            if (v65 != -1) {
              v33 |= 0x2000u;
            }
            if (v64 != -1) {
              v33 |= 0x4000u;
            }
            if (v63 != -1) {
              v33 |= 0x4000000u;
            }
            if (v62 != -1) {
              v33 |= 0x200000u;
            }
            if (v61 != -1) {
              v33 |= 0x100u;
            }
            if (v60 != -1) {
              v33 |= 0x8000000u;
            }
            if (v59 != -1) {
              unsigned int v33 = v33 & 0xFFFFF1FF | 0x800;
            }
            if (v58 != -1) {
              v33 |= 0xE00u;
            }
            unsigned int v34 = v33 & 0xFFFFF1FF;
            if (v57 != -1) {
              unsigned int v33 = v33 & 0xFFFFF1FF | 0x400;
            }
            int v35 = v34 | 0x200;
            if (v56 != -1) {
              unsigned int v33 = v35;
            }
            if (v55 != -1) {
              v33 |= 0x80000000;
            }
            if (v54 != -1) {
              v33 |= 0x2000000u;
            }
            if (v28 != -1) {
              v33 |= 0x20000u;
            }
            if (v29 != -1) {
              v33 |= 0x400000u;
            }
            if (v30 != -1) {
              v33 |= 0x80000u;
            }
            if (v31 == -1) {
              int v21 = v33;
            }
            else {
              int v21 = v33 | 0x800000;
            }
            if (v32 == -1 && !v21)
            {
              CFStringRef v36 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ Unknown Retriggering Option '%@'\n", @"ERROR in PListGestureParser:", v26);
              MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)a1, v36);
              int v21 = 0;
            }
          }
        }
        CFStringRef v37 = (const __CFString *)CFDictionaryGetValue(a2, @"Locking");
        CFStringRef v38 = v37;
        if (v37)
        {
          CFTypeID v39 = CFGetTypeID(v37);
          if (v39 == CFStringGetTypeID())
          {
            if (CFStringCompare(v38, @"LockOnAxis", 1uLL))
            {
              if (CFStringCompare(v38, @"LockOnFirst", 1uLL))
              {
                if (CFStringCompare(v38, @"LockOnFirstUntilPause", 1uLL))
                {
                  if (CFStringCompare(v38, @"LockOnThrow", 1uLL))
                  {
                    if (CFStringCompare(v38, @"LockNever", 1uLL))
                    {
                      CFStringRef v40 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ Unknown Trigger Stick Option '%@'\n", @"ERROR in PListGestureParser:", v38);
                      MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)a1, v40);
                    }
                  }
                  else
                  {
                    v21 |= 0x400000u;
                  }
                }
                else
                {
                  v21 |= 0x40000u;
                }
              }
              else
              {
                v21 |= 0x8000u;
              }
            }
            else
            {
              v21 |= 0x10000u;
            }
          }
        }
        long long v47 = a4[1];
        long long v68 = *a4;
        long long v69 = v47;
        if ((MTPListGestureConfig::extractMotionSensitivity(a1, a2, &v68) & 1) == 0)
        {
          long long v48 = a4[1];
          long long v68 = *a4;
          long long v69 = v48;
        }
        if (*(float *)&v68 == 0.0)
        {
          __int16 v52 = CFDictionaryGetValue(a2, @"Action");
          CFStringRef v53 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ No motion %@ for %@ gesture\n", @"ERROR in PListGestureParser:", @"Sensitivity", v52);
          MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)a1, v53);
        }
        else
        {
          int GestureCategory = MTPListGestureConfig::extractGestureCategory((MTPListGestureConfig *)a1, a2);
          valuePtr[8] = xmmword_24074F640;
          valuePtr[9] = unk_24074F650;
          valuePtr[2] = xmmword_24074F5E0;
          valuePtr[3] = unk_24074F5F0;
          valuePtr[4] = xmmword_24074F600;
          memset(&valuePtr[5], 255, 48);
          memset(valuePtr, 170, 32);
          MTSlideGesture::MTSlideGesture((uint64_t)valuePtr, v21, GestureCategory, &v68, (uint64_t *)&v70, v24, v23);
          __int16 v50 = (char *)a3[21];
          if (v50 >= a3[22])
          {
            uint64_t v51 = std::vector<MTSlideGesture>::__push_back_slow_path<MTSlideGesture const&>((uint64_t *)a3 + 20, (const MTSlideGesture *)valuePtr);
          }
          else
          {
            MTSlideGesture::MTSlideGesture((MTSlideGesture *)a3[21], (const MTSlideGesture *)valuePtr);
            uint64_t v51 = (uint64_t)(v50 + 160);
            a3[21] = v50 + 160;
          }
          a3[21] = (void *)v51;
          if (*(void *)&valuePtr[0])
          {
            *((void *)&valuePtr[0] + MTHandMotion::clearHandMotion(this, 1) = *(void *)&valuePtr[0];
            operator delete(*(void **)&valuePtr[0]);
          }
        }
        break;
    }
    if (v70)
    {
      uint64_t v71 = v70;
      operator delete(v70);
    }
  }
  else
  {
    CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ NULL chord or gesture dictionary\n", @"ERROR in PListGestureParser:");
    MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)a1, v16);
  }
}

void sub_24071D600(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  if (__p) {
    operator delete(__p);
  }
  CFIndex v28 = *(void **)(v26 - 128);
  if (v28)
  {
    *(void *)(v26 - 120) = v28;
    operator delete(v28);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MTPListGestureConfig::extractChordTransitions(MTPListGestureConfig *this, CFDictionaryRef theDict)
{
  if (theDict)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"Transitions");
    if (Value && (CFStringRef v3 = Value, v4 = CFGetTypeID(Value), v4 == CFStringGetTypeID()))
    {
      __int16 v5 = CFStringFind(v3, @"MultiFingerDrag", 1uLL).location != -1;
      if (CFStringFind(v3, @"FromFewerIfPause", 1uLL).location == -1) {
        __int16 v6 = v5 << 8;
      }
      else {
        __int16 v6 = ((v5 & 1) << 8) | 4;
      }
      if (CFStringFind(v3, @"ToFewerAfterSlightDelay", 1uLL).location != -1) {
        v6 |= 0x90u;
      }
      if (CFStringFind(v3, @"FromMoreWithSlightIntegrationDelay", 1uLL).location != -1) {
        v6 |= 0x1001u;
      }
      if (CFStringFind(v3, @"ToMoreFingers", 1uLL).location != -1) {
        v6 |= 0x20u;
      }
      if (CFStringFind(v3, @"ToMoreIfPause", 1uLL).location != -1) {
        v6 |= 0x40u;
      }
      unsigned __int16 v7 = v6 | (CFStringFind(v3, @"FromMoreFingers", 1uLL).location != -1);
      if (CFStringFind(v3, @"FromPausedPoint", 1uLL).location != -1) {
        v7 |= 0x800u;
      }
      if (CFStringFind(v3, @"FromRestingPoint", 1uLL).location != -1) {
        v7 |= 8u;
      }
      if (CFStringFind(v3, @"IsRestingPoint", 1uLL).location != -1) {
        v7 |= 0x80u;
      }
      if (CFStringFind(v3, @"ToFewerFingers", 1uLL).location != -1) {
        v7 |= 0x10u;
      }
      CFIndex location = CFStringFind(v3, @"FromFewerFingers", 1uLL).location;
      unsigned __int16 v9 = v7 | 2;
      if (location == -1) {
        return v7;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 0;
  }
  return v9;
}

void MTPListGestureConfig::parseGestureSet(CFDictionaryRef *this, const __CFString *a2, const __CFDictionary *cf, MTChordGestureSet *a4)
{
  if (cf && (CFTypeID v8 = CFGetTypeID(cf), v8 == CFDictionaryGetTypeID()))
  {
    long long v19 = 0x3F80000000000000uLL;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    MTPListGestureConfig::extractMotionSensitivity(this, cf, &v19);
    int GestureCategory = (MTPListGestureConfig *)MTPListGestureConfig::extractGestureCategory((MTPListGestureConfig *)this, cf);
    if (GestureCategory) {
      *((_DWORD *)a4 + 58) = GestureCategory;
    }
    *((_WORD *)a4 + 114) |= MTPListGestureConfig::extractChordTransitions(GestureCategory, cf);
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(cf, @"Gestures");
    if (Value)
    {
      CFArrayRef v12 = Value;
      CFTypeID v13 = CFGetTypeID(Value);
      if (v13 == CFArrayGetTypeID())
      {
        CFIndex Count = CFArrayGetCount(v12);
        if (Count >= 1)
        {
          CFIndex v15 = Count;
          for (CFIndex i = 0; i != v15; ++i)
          {
            CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v12, i);
            MTPListGestureConfig::parseGesture(this, ValueAtIndex, (void **)a4, &v19);
          }
        }
        return;
      }
    }
    CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ No %@ array for gesture set '%@'\n", v11, @"ERROR in PListGestureParser:", @"Gestures", a2);
  }
  else
  {
    CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ No dictionary for gesture set '%@'\n", a4, @"ERROR in PListGestureParser:", a2);
  }

  MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)this, v18);
}

uint64_t MTPListGestureConfig::parseChordSpecifier(MTPListGestureConfig *this, CFStringRef theString1)
{
  if (CFStringCompare(theString1, @"Pengrip", 1uLL) == kCFCompareEqualTo) {
    return 10;
  }
  if (CFStringCompare(theString1, @"Fist", 1uLL) == kCFCompareEqualTo) {
    return 12;
  }
  if (CFStringCompare(theString1, @"Palm", 1uLL) == kCFCompareEqualTo) {
    return 13;
  }
  uint64_t v3 = 1;
  if (CFStringCompare(theString1, @"1 Finger", 1uLL))
  {
    if (CFStringCompare(theString1, @"2 Fingers", 1uLL))
    {
      if (CFStringCompare(theString1, @"3 Fingers", 1uLL))
      {
        if (CFStringCompare(theString1, @"4 Fingers", 1uLL))
        {
          if (CFStringCompare(theString1, @"Thumb", 1uLL))
          {
            if (CFStringCompare(theString1, @"1 Finger + Thumb", 1uLL))
            {
              if (CFStringCompare(theString1, @"2 Fingers + Thumb", 1uLL))
              {
                if (CFStringCompare(theString1, @"3 Fingers + Thumb", 1uLL))
                {
                  if (CFStringCompare(theString1, @"4 Fingers + Thumb", 1uLL)) {
                    return 0;
                  }
                  else {
                    return 9;
                  }
                }
                else
                {
                  return 8;
                }
              }
              else
              {
                return 7;
              }
            }
            else
            {
              return 6;
            }
          }
          else
          {
            return 5;
          }
        }
        else
        {
          return 4;
        }
      }
      else
      {
        return 3;
      }
    }
    else
    {
      return 2;
    }
  }
  return v3;
}

uint64_t MTPListGestureConfig::parseHandIdentity(MTPListGestureConfig *this, const __CFString *a2)
{
  return 1;
}

void MTPListGestureConfig::parseChordGestureSetAndCopyIntoTable(CFDictionaryRef *this, CFTypeRef cf, const __CFString *a3)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (a3)
    {
      if (v6 == TypeID)
      {
        CFTypeID v8 = CFGetTypeID(a3);
        if (v8 == CFStringGetTypeID())
        {
          CFStringRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"Chord");
          if (Value && (CFStringRef v10 = Value, v11 = CFGetTypeID(Value), v11 == CFStringGetTypeID()))
          {
            int GestureCategory = (MTPListGestureConfig *)MTPListGestureConfig::extractGestureCategory((MTPListGestureConfig *)this, (CFDictionaryRef)cf);
            uint64_t v13 = MTPListGestureConfig::parseChordSpecifier(GestureCategory, v10);
            if (v13)
            {
              uint64_t v14 = v13;
              *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
              *((void *)&v15 + MTHandMotion::clearHandMotion(this, 1) = 0xAAAAAAAAAAAAAAAALL;
              v38[3] = v15;
              v38[4] = v15;
              v38[1] = v15;
              v38[2] = v15;
              long long v37 = v15;
              v38[0] = v15;
              long long __p = v15;
              *(_OWORD *)unsigned int v34 = v15;
              long long v35 = v15;
              *(_OWORD *)CFIndex v32 = v15;
              long long v33 = v15;
              *(_OWORD *)CFIndex v30 = v15;
              long long v31 = v15;
              *(_OWORD *)CFIndex v28 = v15;
              long long v29 = v15;
              CStringPtr = CFStringGetCStringPtr(v10, 0);
              MTChordGestureSet::MTChordGestureSet(v28, v14, 0, GestureCategory, CStringPtr);
              CFNumberRef v17 = MTGestureConfig::copyChordIntoHandTable((uint64_t)this, 1, (MTChordGestureSet *)v28);
              CFStringRef v18 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"Gesture Set");
              CFStringRef v19 = v18;
              if (v18 && (CFTypeID v20 = CFGetTypeID(v18), v20 == CFStringGetTypeID()))
              {
                CFDictionaryRef v21 = (const __CFDictionary *)CFDictionaryGetValue(this[11], v19);
                CFDictionaryRef v22 = v21;
                if (v21 && (CFTypeID v23 = CFGetTypeID(v21), v23 == CFDictionaryGetTypeID()))
                {
                  MTPListGestureConfig::parseGestureSet(this, v19, v22, v17);
                }
                else
                {
                  CFStringRef v26 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ No dictionary for '%@' Gesture Set\n", @"ERROR in PListGestureParser:", v19);
                  MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)this, v26);
                }
              }
              else
              {
                CFStringRef v25 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ No Gesture Set for '%@' Chord\n", @"ERROR in PListGestureParser:", v10);
                MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)this, v25);
              }
              CFTypeID v27 = (void **)v38;
              std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100](&v27);
              if ((void)__p)
              {
                *((void *)&__p + MTHandMotion::clearHandMotion(this, 1) = __p;
                operator delete((void *)__p);
              }
              if (v34[0])
              {
                v34[1] = v34[0];
                operator delete(v34[0]);
              }
              if (v32[0])
              {
                v32[1] = v32[0];
                operator delete(v32[0]);
              }
              if (v30[0])
              {
                v30[1] = v30[0];
                operator delete(v30[0]);
              }
              if (v28[0])
              {
                v28[1] = v28[0];
                operator delete(v28[0]);
              }
            }
          }
          else
          {
            CFStringRef v24 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ Chord Dictionary Missing '%@' Key\n", @"ERROR in PListGestureParser:", @"Chord");
            MTPListGestureConfig::setParseErrorString((MTPListGestureConfig *)this, v24);
          }
        }
      }
    }
  }
}

void sub_24071DF2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  MTChordGestureSet::~MTChordGestureSet((MTChordGestureSet *)va);
  _Unwind_Resume(a1);
}

void MTChordGestureSet::~MTChordGestureSet(MTChordGestureSet *this)
{
  unsigned __int16 v7 = (void **)((char *)this + 160);
  std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100](&v7);
  uint64_t v2 = (void *)*((void *)this + 16);
  if (v2)
  {
    *((void *)this + 17) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 12);
  if (v3)
  {
    *((void *)this + 13) = v3;
    operator delete(v3);
  }
  CFTypeID v4 = (void *)*((void *)this + 8);
  if (v4)
  {
    *((void *)this + 9) = v4;
    operator delete(v4);
  }
  __int16 v5 = (void *)*((void *)this + 4);
  if (v5)
  {
    *((void *)this + 5) = v5;
    operator delete(v5);
  }
  CFTypeID v6 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + MTHandMotion::clearHandMotion(this, 1) = v6;
    operator delete(v6);
  }
}

void MTPListGestureConfig::parseChordMappingsForHand(MTPListGestureConfig *this, const __CFString *cf, const __CFDictionary *a3)
{
  if (!cf
    || (CFTypeID v6 = CFGetTypeID(cf), v6 != CFStringGetTypeID())
    || CFStringCompare(cf, @"Right", 1uLL) && CFStringCompare(cf, @"Any", 1uLL))
  {
    CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ '%@' Hand not recognized or supported\n", @"ERROR in PListGestureParser:", cf);
LABEL_6:
    MTPListGestureConfig::setParseErrorString(this, v7);
    return;
  }
  if (!a3 || (CFTypeID v8 = CFGetTypeID(a3), v8 != CFDictionaryGetTypeID()))
  {
    CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ Missing chord dictionary for '%@' Hand\n", @"ERROR in PListGestureParser:", cf);
    goto LABEL_6;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a3, @"Chords");
  if (Value && (CFArrayRef v10 = Value, v11 = CFGetTypeID(Value), v11 == CFArrayGetTypeID()))
  {
    CFIndex Count = CFArrayGetCount(v10);
    if (Count >= 1)
    {
      CFIndex v13 = Count;
      for (CFIndex i = 0; i != v13; ++i)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v10, i);
        MTPListGestureConfig::parseChordGestureSetAndCopyIntoTable((CFDictionaryRef *)this, ValueAtIndex, cf);
      }
    }
  }
  else
  {
    CFStringRef v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, @"%@ Could not find '%@' array for '%@' Hand\n", @"ERROR in PListGestureParser:", @"Chords", cf);
    MTPListGestureConfig::setParseErrorString(this, v16);
  }
  CFStringRef v17 = (const __CFString *)CFDictionaryGetValue(a3, @"LookupBySubset");
  if (v17)
  {
    CFStringRef v18 = v17;
    CFTypeID v19 = CFGetTypeID(v17);
    if (v19 == CFStringGetTypeID())
    {
      uint64_t ChordTableForHand = MTGestureConfig::getChordTableForHand((uint64_t)this, 1);
      if (ChordTableForHand)
      {
        uint64_t v21 = ChordTableForHand;
        if (CFStringCompare(v18, @"SyncedFingers", 1uLL) == kCFCompareEqualTo) {
          *(_DWORD *)(v21 + 28) = 0;
        }
        if (CFStringCompare(v18, @"TouchingFingers", 1uLL) == kCFCompareEqualTo) {
          *(_DWORD *)(v21 + 28) = 2;
        }
        if (CFStringCompare(v18, @"MovingFingers", 1uLL) == kCFCompareEqualTo) {
          *(_DWORD *)(v21 + 28) = 1;
        }
      }
    }
  }
}

void MTPListGestureConfig::parseChordMappingPreferences(MTPListGestureConfig *this, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFDictionaryGetTypeID())
    {
      CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)cf);
      CFTypeID v6 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
      CFStringRef v7 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
      CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, v6, v7);
      if (Count >= 1)
      {
        CFTypeID v8 = v6;
        unsigned __int16 v9 = (const __CFDictionary **)v7;
        do
        {
          CFStringRef v11 = (const __CFString *)*v8++;
          CFStringRef v10 = v11;
          CFDictionaryRef v12 = *v9++;
          MTPListGestureConfig::parseChordMappingsForHand(this, v10, v12);
          --Count;
        }
        while (Count);
      }
      free(v6);
      free(v7);
    }
  }
}

void MTPListGestureConfig::setChordMappingsDictionary(MTPListGestureConfig *this, CFTypeRef cf)
{
  CFTypeRef v3 = (CFTypeRef)*((void *)this + 10);
  if (v3 != cf)
  {
    if (v3)
    {
      CFRelease(v3);
      *((void *)this + 10) = 0;
    }
    if (cf)
    {
      *((void *)this + 10) = cf;
      CFRetain(cf);
    }
  }
}

void MTPListGestureConfig::setGestureSetsDictionary(MTPListGestureConfig *this, CFTypeRef cf)
{
  CFTypeRef v3 = (CFTypeRef)*((void *)this + 11);
  if (v3 != cf)
  {
    if (v3)
    {
      CFRelease(v3);
      *((void *)this + 1MTHandMotion::clearHandMotion(this, 1) = 0;
    }
    if (cf)
    {
      *((void *)this + 1MTHandMotion::clearHandMotion(this, 1) = cf;
      CFRetain(cf);
    }
  }
}

void MTPListGestureConfig::setMotionSensitivitiesDictionary(MTPListGestureConfig *this, CFTypeRef cf)
{
  CFTypeRef v3 = (CFTypeRef)*((void *)this + 12);
  if (v3 != cf)
  {
    if (v3)
    {
      CFRelease(v3);
      *((void *)this + 12) = 0;
    }
    if (cf)
    {
      *((void *)this + 12) = cf;
      CFRetain(cf);
    }
  }
}

void MTPListGestureConfig::setActionEventsDictionary(MTPListGestureConfig *this, CFTypeRef cf)
{
  CFTypeRef v3 = (CFTypeRef)*((void *)this + 13);
  if (v3 != cf)
  {
    if (v3)
    {
      CFRelease(v3);
      *((void *)this + 13) = 0;
    }
    if (cf)
    {
      *((void *)this + 13) = cf;
      CFRetain(cf);
    }
  }
}

BOOL MTPListGestureConfig::parseCreateGestureConfig(MTPListGestureConfig *this, const __CFString **a2)
{
  CFTypeID v4 = (const void *)*((void *)this + 14);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 14) = 0;
  }
  __int16 v5 = (const void *)*((void *)this + 10);
  if (!v5 || (CFTypeID v6 = CFGetTypeID(v5), v6 != CFDictionaryGetTypeID()))
  {
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    uint64_t v14 = "PListGestureParser ABORT: Chord Mappings dictionary missing\n";
LABEL_16:
    CFStringRef v15 = CFStringCreateWithCString(v13, v14, 0);
    MTPListGestureConfig::setParseErrorString(this, v15);
    goto LABEL_17;
  }
  CFStringRef v7 = (const void *)*((void *)this + 13);
  if (!v7 || (CFTypeID v8 = CFGetTypeID(v7), v8 != CFDictionaryGetTypeID()))
  {
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    uint64_t v14 = "PListGestureParser ABORT: Action Events dictionary missing\n";
    goto LABEL_16;
  }
  unsigned __int16 v9 = (const void *)*((void *)this + 12);
  if (!v9 || (CFTypeID v10 = CFGetTypeID(v9), v10 != CFDictionaryGetTypeID()))
  {
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    uint64_t v14 = "PListGestureParser ABORT: Motion Sensitivities dictionary missing\n";
    goto LABEL_16;
  }
  CFStringRef v11 = (const void *)*((void *)this + 11);
  if (!v11 || (CFTypeID v12 = CFGetTypeID(v11), v12 != CFDictionaryGetTypeID()))
  {
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    uint64_t v14 = "PListGestureParser ABORT: Gesture Sets dictionary missing\n";
    goto LABEL_16;
  }
  MTPListGestureConfig::parseChordMappingPreferences(this, *((CFTypeRef *)this + 10));
LABEL_17:
  CFStringRef v16 = (const __CFString *)*((void *)this + 14);
  if (a2 && v16)
  {
    *a2 = v16;
    *((void *)this + 14) = 0;
  }
  return v16 == 0;
}

void MTPListGestureConfig::releaseParsedDictionaries(MTPListGestureConfig *this)
{
  uint64_t v2 = (const void *)*((void *)this + 10);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 10) = 0;
  }
  CFTypeRef v3 = (const void *)*((void *)this + 11);
  if (v3)
  {
    CFRelease(v3);
    *((void *)this + 1MTHandMotion::clearHandMotion(this, 1) = 0;
  }
  CFTypeID v4 = (const void *)*((void *)this + 13);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 13) = 0;
  }
  __int16 v5 = (const void *)*((void *)this + 12);
  if (v5)
  {
    CFRelease(v5);
    *((void *)this + 12) = 0;
  }
}

void MTPListGestureConfig::addActionEventToDictionary(MTPListGestureConfig *this, __CFDictionary *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6)
{
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  CFAllocatorRef v13 = CFDictionaryCreateMutable(v11, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  CFDictionaryAddValue(v13, @"EventType", a3);
  if (a4) {
    CFDictionaryAddValue(v13, @"Modifiers", a4);
  }
  if (a5) {
    CFDictionaryAddValue(v13, @"KeyCode", a5);
  }
  CFArrayAppendValue(Mutable, v13);
  CFDictionaryAddValue(this, a2, Mutable);
  CFRelease(Mutable);

  CFRelease(v13);
}

void MTPListGestureConfig::addGestureToArray(MTPListGestureConfig *this, __CFArray *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6, const __CFString *a7, const __CFString *a8, const void *a9)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  CFDictionaryAddValue(Mutable, @"Action", a2);
  CFDictionaryAddValue(Mutable, @"Motion", a3);
  if (a4) {
    CFDictionaryAddValue(Mutable, @"Sensitivity", a4);
  }
  if (a5) {
    CFDictionaryAddValue(Mutable, @"Trigger", a5);
  }
  if (a6) {
    CFDictionaryAddValue(Mutable, @"Locking", a6);
  }
  if (a7 && a8) {
    CFDictionaryAddValue(Mutable, a7, a8);
  }
  CFArrayAppendValue(this, Mutable);

  CFRelease(Mutable);
}

void MTPListGestureConfig::addChordMappingToArray(MTPListGestureConfig *this, __CFArray *a2, const __CFString *a3, const __CFString *a4)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 2, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  CFDictionaryAddValue(Mutable, @"Chord", a2);
  CFDictionaryAddValue(Mutable, @"Gesture Set", a3);
  CFArrayAppendValue(this, Mutable);

  CFRelease(Mutable);
}

uint64_t std::vector<MTActionEvent>::__push_back_slow_path<MTActionEvent const&>(uint64_t a1, const MTActionEvent *a2)
{
  CFTypeRef v3 = *(const MTActionEvent **)a1;
  uint64_t v4 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 61) {
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = a1 + 16;
  uint64_t v8 = *(void *)(a1 + 16) - (void)v3;
  if (v8 >> 2 > v5) {
    unint64_t v5 = v8 >> 2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v16 = a1 + 16;
  if (v9) {
    CFTypeID v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTPoint>>(v7, v9);
  }
  else {
    CFTypeID v10 = 0;
  }
  __p[0] = v10;
  __p[1] = &v10[8 * v4];
  CFStringRef v15 = &v10[8 * v9];
  MTActionEvent::MTActionEvent((MTActionEvent *)__p[1], a2);
  uint64_t v14 = (char *)__p[1] + 8;
  std::vector<MTActionEvent>::__swap_out_circular_buffer((const MTActionEvent **)a1, __p);
  uint64_t v11 = *(void *)(a1 + 8);
  if (v14 != __p[1]) {
    v14 += ((char *)__p[1] - (char *)v14 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  if (__p[0]) {
    operator delete(__p[0]);
  }
  return v11;
}

void sub_24071EA48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<MTActionEvent>::__swap_out_circular_buffer(const MTActionEvent **a1, void *a2)
{
  unint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  CFTypeID v6 = (const MTActionEvent *)a2[1];
  while (v4 != v5)
  {
    uint64_t v4 = (const MTActionEvent *)((char *)v4 - 8);
    MTActionEvent::MTActionEvent((const MTActionEvent *)((char *)v6 - 8), v4);
  }
  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = (const MTActionEvent *)a2[2];
  a2[2] = v8;
  unint64_t v9 = a1[2];
  a1[2] = (const MTActionEvent *)a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

uint64_t std::vector<MTSlideGesture>::__push_back_slow_path<MTSlideGesture const&>(uint64_t *a1, const MTSlideGesture *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 5);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x199999999999999) {
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 5);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0xCCCCCCCCCCCCCCLL) {
    unint64_t v9 = 0x199999999999999;
  }
  else {
    unint64_t v9 = v5;
  }
  CFStringRef v17 = a1 + 2;
  if (v9) {
    CFTypeID v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTSlideGesture>>(v7, v9);
  }
  else {
    CFTypeID v10 = 0;
  }
  CFAllocatorRef v13 = v10;
  uint64_t v14 = (MTSlideGesture *)&v10[160 * v4];
  uint64_t v16 = &v10[160 * v9];
  MTSlideGesture::MTSlideGesture(v14, a2);
  CFStringRef v15 = (char *)v14 + 160;
  std::vector<MTSlideGesture>::__swap_out_circular_buffer(a1, &v13);
  uint64_t v11 = a1[1];
  std::__split_buffer<MTSlideGesture>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_24071EC04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::vector<MTSlideGesture>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MTSlideGesture>,std::reverse_iterator<MTSlideGesture*>,std::reverse_iterator<MTSlideGesture*>,std::reverse_iterator<MTSlideGesture*>>((uint64_t)(a1 + 2), a1[1], (const MTSlideGesture *)a1[1], *a1, (const MTSlideGesture *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<MTSlideGesture>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x19999999999999ALL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(160 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MTSlideGesture>,std::reverse_iterator<MTSlideGesture*>,std::reverse_iterator<MTSlideGesture*>,std::reverse_iterator<MTSlideGesture*>>(uint64_t a1, uint64_t a2, const MTSlideGesture *a3, uint64_t a4, const MTSlideGesture *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + MTHandMotion::clearHandMotion(this, 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  unint64_t v13 = 0xAAAAAAAAAAAAAA00;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    unint64_t v9 = a3;
    do
    {
      unint64_t v9 = (const MTSlideGesture *)((char *)v9 - 160);
      MTSlideGesture::MTSlideGesture((MTSlideGesture *)(v7 - 160), v9);
      uint64_t v7 = *((void *)&v15 + 1) - 160;
      *((void *)&v15 + 1) -= 160;
    }
    while (v9 != a5);
    uint64_t v10 = v15;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,std::reverse_iterator<MTSlideGesture*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

void sub_24071ED84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,std::reverse_iterator<MTSlideGesture*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,std::reverse_iterator<MTSlideGesture*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,std::reverse_iterator<MTSlideGesture*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)v1;
    if (*(void *)v1)
    {
      *(void *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 160;
  }
}

uint64_t std::__split_buffer<MTSlideGesture>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<MTSlideGesture>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    uint64_t v5 = *(void **)(v2 - 160);
    *(void *)(a1 + 16) = v2 - 160;
    if (v5)
    {
      *(void *)(v2 - 152) = v5;
      operator delete(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 160;
    }
  }
}

void MTChordGestureSet::MTChordGestureSet(MTChordGestureSet *this)
{
  *((_DWORD *)this + 58) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + MTHandMotion::clearHandMotion(this, 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *(_OWORD *)((char *)this + 169) = 0u;
  *(void *)((char *)this + 204) = 0;
  *(void *)((char *)this + 220) = 0;
  *(void *)((char *)this + 212) = 0;
  *((_WORD *)this + 114) = 0;
}

{
  *((_DWORD *)this + 58) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + MTHandMotion::clearHandMotion(this, 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *(_OWORD *)((char *)this + 169) = 0u;
  *(void *)((char *)this + 204) = 0;
  *(void *)((char *)this + 220) = 0;
  *(void *)((char *)this + 212) = 0;
  *((_WORD *)this + 114) = 0;
}

uint64_t MTChordGestureSet::MTChordGestureSet(uint64_t a1, signed int a2, __int16 a3, int a4, char *__src)
{
  *(_DWORD *)(a1 + 204) = 0;
  *(void *)(a1 + 208) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 224) = a2;
  *(_WORD *)(a1 + 228) = a3;
  *(_DWORD *)(a1 + 232) = a4;
  if ((a2 - 1) <= 3)
  {
    *(_DWORD *)(a1 + 216) = a2;
    *(_DWORD *)(a1 + 220) = a2;
    goto LABEL_9;
  }
  if (a2 <= 9)
  {
    int32x2_t v6 = vadd_s32(vdup_n_s32(a2), (int32x2_t)0xFFFFFFFBFFFFFFFCLL);
LABEL_7:
    *(int32x2_t *)(a1 + 216) = v6;
    goto LABEL_9;
  }
  if (a2 <= 0xD)
  {
    int32x2_t v6 = (int32x2_t)0x400000005;
    goto LABEL_7;
  }
  *(void *)(a1 + 216) = 0;
LABEL_9:
  uint64_t v7 = (char *)(a1 + 184);
  if (__src) {
    strncpy(v7, __src, 0x13uLL);
  }
  else {
    *uint64_t v7 = 0;
  }
  return a1;
}

void MTChordGestureSet::MTChordGestureSet(MTChordGestureSet *this, const MTChordGestureSet *a2)
{
  *(void *)this = 0;
  *((void *)this + MTHandMotion::clearHandMotion(this, 1) = 0;
  *((void *)this + 2) = 0;
  std::vector<MTActionEvent>::__init_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>(this, *(void *)a2, *((void *)a2 + 1), (uint64_t)(*((void *)a2 + 1) - *(void *)a2) >> 3);
  int v4 = *((_DWORD *)a2 + 6);
  int v5 = *((_DWORD *)a2 + 7);
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 6) = v4;
  *((_DWORD *)this + 7) = v5;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  std::vector<MTActionEvent>::__init_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>((void *)this + 4, *((void *)a2 + 4), *((void *)a2 + 5), (uint64_t)(*((void *)a2 + 5) - *((void *)a2 + 4)) >> 3);
  int v6 = *((_DWORD *)a2 + 14);
  int v7 = *((_DWORD *)a2 + 15);
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 14) = v6;
  *((_DWORD *)this + 15) = v7;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  std::vector<MTActionEvent>::__init_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>((void *)this + 8, *((void *)a2 + 8), *((void *)a2 + 9), (uint64_t)(*((void *)a2 + 9) - *((void *)a2 + 8)) >> 3);
  int v8 = *((_DWORD *)a2 + 22);
  int v9 = *((_DWORD *)a2 + 23);
  *((void *)this + 12) = 0;
  *((_DWORD *)this + 22) = v8;
  *((_DWORD *)this + 23) = v9;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  std::vector<MTActionEvent>::__init_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>((void *)this + 12, *((void *)a2 + 12), *((void *)a2 + 13), (uint64_t)(*((void *)a2 + 13) - *((void *)a2 + 12)) >> 3);
  int v10 = *((_DWORD *)a2 + 30);
  int v11 = *((_DWORD *)a2 + 31);
  *((void *)this + 16) = 0;
  *((_DWORD *)this + 30) = v10;
  *((_DWORD *)this + 3MTHandMotion::clearHandMotion(this, 1) = v11;
  *((void *)this + 17) = 0;
  *((void *)this + 18) = 0;
  std::vector<MTActionEvent>::__init_with_size[abi:ne180100]<MTActionEvent*,MTActionEvent*>((void *)this + 16, *((void *)a2 + 16), *((void *)a2 + 17), (uint64_t)(*((void *)a2 + 17) - *((void *)a2 + 16)) >> 3);
  *((_DWORD *)this + 38) = *((_DWORD *)a2 + 38);
  *((_DWORD *)this + 39) = *((_DWORD *)a2 + 39);
  *((void *)this + 20) = 0;
  *((void *)this + 2MTHandMotion::clearHandMotion(this, 1) = 0;
  *((void *)this + 22) = 0;
  *((_DWORD *)this + 5MTHandMotion::clearHandMotion(this, 1) = *((_DWORD *)a2 + 51);
  *((void *)this + 26) = *((void *)a2 + 26);
  *((void *)this + 27) = *((void *)a2 + 27);
  *((_DWORD *)this + 56) = *((_DWORD *)a2 + 56);
  *((_WORD *)this + 114) = *((_WORD *)a2 + 114);
  *((_DWORD *)this + 58) = *((_DWORD *)a2 + 58);
  if (this != a2) {
    std::vector<MTSlideGesture>::__assign_with_size[abi:ne180100]<MTSlideGesture*,MTSlideGesture*>((uint64_t)this + 160, *((MTSlideGesture **)a2 + 20), *((MTSlideGesture **)a2 + 21), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)a2 + 21) - *((void *)a2 + 20)) >> 5));
  }
  strncpy((char *)this + 184, (const char *)a2 + 184, 0x13uLL);
}

void sub_24071F168(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  int v8 = *v6;
  if (*v6)
  {
    *(void *)(v2 + 136) = v8;
    operator delete(v8);
  }
  int v9 = *v5;
  if (*v5)
  {
    *(void *)(v2 + 104) = v9;
    operator delete(v9);
  }
  int v10 = *v4;
  if (*v4)
  {
    *(void *)(v2 + 72) = v10;
    operator delete(v10);
  }
  int v11 = *v3;
  if (*v3)
  {
    *(void *)(v2 + 40) = v11;
    operator delete(v11);
  }
  CFTypeID v12 = *(void **)v2;
  if (*(void *)v2)
  {
    *(void *)(v2 + 8) = v12;
    operator delete(v12);
  }
  _Unwind_Resume(a1);
}

uint64_t MTChordGestureSet::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    *(_DWORD *)(a1 + 204) = *(_DWORD *)(a2 + 204);
    *(void *)(a1 + 208) = *(void *)(a2 + 208);
    *(void *)(a1 + 216) = *(void *)(a2 + 216);
    *(_DWORD *)(a1 + 224) = *(_DWORD *)(a2 + 224);
    *(_WORD *)(a1 + 228) = *(_WORD *)(a2 + 228);
    *(_DWORD *)(a1 + 232) = *(_DWORD *)(a2 + 232);
    strncpy((char *)(a1 + 184), (const char *)(a2 + 184), 0x13uLL);
    MTGesture::operator=(a1, a2);
    MTGesture::operator=(a1 + 32, a2 + 32);
    MTGesture::operator=(a1 + 64, a2 + 64);
    MTGesture::operator=(a1 + 96, a2 + 96);
    MTGesture::operator=(a1 + 128, a2 + 128);
    std::vector<MTSlideGesture>::__assign_with_size[abi:ne180100]<MTSlideGesture*,MTSlideGesture*>(a1 + 160, *(MTSlideGesture **)(a2 + 160), *(MTSlideGesture **)(a2 + 168), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 168) - *(void *)(a2 + 160)) >> 5));
  }
  return a1;
}

uint64_t MTChordGestureSet::chordGestureSetEquals(MTChordGestureSet *this, const MTChordGestureSet *a2)
{
  if (!MTGesture::gestureEquals((uint64_t *)this, (uint64_t *)a2)
    || !MTGesture::gestureEquals((uint64_t *)this + 4, (uint64_t *)a2 + 4)
    || !MTGesture::gestureEquals((uint64_t *)this + 8, (uint64_t *)a2 + 8)
    || !MTGesture::gestureEquals((uint64_t *)this + 12, (uint64_t *)a2 + 12)
    || !MTGesture::gestureEquals((uint64_t *)this + 16, (uint64_t *)a2 + 16))
  {
    return 0;
  }

  return MTChordGestureSet::chordSlidesEqual(this, a2);
}

uint64_t MTGesture::gestureEquals(uint64_t *a1, uint64_t *a2)
{
  if (*((unsigned __int16 *)a1 + 12) != *((unsigned __int16 *)a2 + 12)) {
    return 0;
  }
  if (*((unsigned __int16 *)a1 + 13) != *((unsigned __int16 *)a2 + 13)) {
    return 0;
  }
  if (*((_DWORD *)a1 + 7) != *((_DWORD *)a2 + 7)) {
    return 0;
  }
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  unint64_t v4 = (v3 - *a1) >> 3;
  uint64_t v5 = *a2;
  if (v4 != (a2[1] - *a2) >> 3) {
    return 0;
  }
  if (v3 != v2)
  {
    uint64_t v6 = 0;
    unsigned int v7 = 1;
    uint64_t result = 1;
    while (*(unsigned __int16 *)(v2 + 8 * v6) == *(unsigned __int16 *)(v5 + 8 * v6))
    {
      uint64_t v9 = v2 + 8 * v6;
      uint64_t v10 = v5 + 8 * v6;
      if (*(unsigned __int16 *)(v9 + 2) != *(unsigned __int16 *)(v10 + 2)
        || *(_DWORD *)(v9 + 4) != *(_DWORD *)(v10 + 4))
      {
        break;
      }
      uint64_t v6 = v7;
      if (v4 <= v7++) {
        return result;
      }
    }
    return 0;
  }
  return 1;
}

uint64_t MTChordGestureSet::chordSlidesEqual(MTChordGestureSet *this, const MTChordGestureSet *a2)
{
  uint64_t v2 = *((void *)this + 20);
  uint64_t v3 = *((void *)this + 21);
  if (v3 - v2 != *((void *)a2 + 21) - *((void *)a2 + 20)) {
    return 0;
  }
  if (v3 == v2) {
    return 1;
  }
  uint64_t v6 = 0;
  unsigned int v7 = 1;
  do
  {
    uint64_t result = MTSlideGesture::slideEquals((MTSlideGesture *)(v2 + 160 * v6), (const MTSlideGesture *)(*((void *)a2 + 20) + 160 * v6));
    if ((result & 1) == 0) {
      break;
    }
    uint64_t v6 = v7;
    uint64_t v2 = *((void *)this + 20);
  }
  while (0xCCCCCCCCCCCCCCCDLL * ((*((void *)this + 21) - v2) >> 5) > v7++);
  return result;
}

uint64_t MTSlideGesture::slideEquals(MTSlideGesture *this, const MTSlideGesture *a2)
{
  uint64_t result = MTGesture::gestureEquals((uint64_t *)this, (uint64_t *)a2);
  if (result) {
    return *((_DWORD *)this + 8) == *((_DWORD *)a2 + 8)
  }
        && *((float *)this + 38) == *((float *)a2 + 38)
        && *((float *)this + 39) == *((float *)a2 + 39)
        && *((float *)this + 9) == *((float *)a2 + 9)
        && *((float *)this + 10) == *((float *)a2 + 10)
        && *((float *)this + 13) == *((float *)a2 + 13)
        && *((float *)this + 11) == *((float *)a2 + 11)
        && *((float *)this + 12) == *((float *)a2 + 12)
        && *((float *)this + 14) == *((float *)a2 + 14)
        && *((float *)this + 15) == *((float *)a2 + 15)
        && *((float *)this + 16) == *((float *)a2 + 16);
  return result;
}

BOOL MTChordGestureSet::isEmpty(MTChordGestureSet *this)
{
  uint64_t v1 = *((void *)this + 20);
  uint64_t v2 = *((void *)this + 21) - v1;
  if (v2)
  {
    uint64_t v3 = 0;
    unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * (v2 >> 5);
    unsigned int v5 = 1;
    do
    {
      uint64_t v6 = v1 + 160 * v3;
      if (*(void *)v6 != *(void *)(v6 + 8))
      {
        if (**(_WORD **)v6) {
          return 0;
        }
      }
      uint64_t v3 = v5;
    }
    while (v4 > v5++);
  }
  if (*(void *)this != *((void *)this + 1) && **(_WORD **)this) {
    return 0;
  }
  int v8 = (_WORD *)*((void *)this + 4);
  if (v8 != *((_WORD **)this + 5))
  {
    if (*v8) {
      return 0;
    }
  }
  uint64_t v9 = (_WORD *)*((void *)this + 8);
  if (v9 != *((_WORD **)this + 9))
  {
    if (*v9) {
      return 0;
    }
  }
  uint64_t v10 = (_WORD *)*((void *)this + 12);
  if (v10 != *((_WORD **)this + 13))
  {
    if (*v10) {
      return 0;
    }
  }
  CFTypeID v12 = (unsigned __int16 *)*((void *)this + 16);
  return v12 == *((unsigned __int16 **)this + 17) || *v12 == 0;
}

uint64_t MTChordGestureSet::hasEnabledOrientationEvents(MTChordGestureSet *this, const MTChordTable *a2)
{
  uint64_t v2 = *((void *)this + 20);
  uint64_t v3 = *((void *)this + 21) - v2;
  if (!v3) {
    return 0;
  }
  uint64_t v4 = 0;
  unint64_t v5 = 0xCCCCCCCCCCCCCCCDLL * (v3 >> 5);
  for (unsigned int i = 1; ; ++i)
  {
    uint64_t v7 = v2 + 160 * v4;
    int v8 = *(_DWORD *)(v7 + 28);
    BOOL v9 = v8 && (*((_DWORD *)a2 + 6) & v8) == 0;
    if (!v9 && *(void *)v7 != *(void *)(v7 + 8) && **(_WORD **)v7 == 71) {
      break;
    }
    uint64_t v4 = i;
    if (v5 <= i) {
      return 0;
    }
  }
  return 1;
}

uint64_t MTChordGestureSet::hasEnabledFluidNavigation(MTChordGestureSet *this, const MTChordTable *a2)
{
  uint64_t v2 = *((void *)this + 20);
  uint64_t v3 = *((void *)this + 21) - v2;
  if (!v3) {
    return 0;
  }
  uint64_t v4 = 0;
  unint64_t v5 = 0xCCCCCCCCCCCCCCCDLL * (v3 >> 5);
  for (unsigned int i = 1; ; ++i)
  {
    uint64_t v7 = v2 + 160 * v4;
    int v8 = *(_DWORD *)(v7 + 28);
    BOOL v9 = v8 && (*((_DWORD *)a2 + 6) & v8) == 0;
    if (!v9 && *(void *)v7 != *(void *)(v7 + 8) && **(_WORD **)v7 == 36) {
      break;
    }
    uint64_t v4 = i;
    if (v5 <= i) {
      return 0;
    }
  }
  return 1;
}

uint64_t MTChordGestureSet::hasEnabledFluidDock(MTChordGestureSet *this, const MTChordTable *a2)
{
  uint64_t v2 = *((void *)this + 20);
  uint64_t v3 = *((void *)this + 21) - v2;
  if (!v3) {
    return 0;
  }
  uint64_t v4 = 0;
  unint64_t v5 = 0xCCCCCCCCCCCCCCCDLL * (v3 >> 5);
  for (unsigned int i = 1; ; ++i)
  {
    uint64_t v7 = v2 + 160 * v4;
    int v8 = *(_DWORD *)(v7 + 28);
    BOOL v9 = v8 && (*((_DWORD *)a2 + 6) & v8) == 0;
    if (!v9 && *(void *)v7 != *(void *)(v7 + 8) && **(_WORD **)v7 == 37) {
      break;
    }
    uint64_t v4 = i;
    if (v5 <= i) {
      return 0;
    }
  }
  return 1;
}

uint64_t MTChordGestureSet::hasActiveEdgeSlide(MTChordGestureSet *this, const MTHandStatistics *a2, const MTChordCycling *a3)
{
  v26[31] = *MEMORY[0x263EF8340];
  int v6 = *((_DWORD *)this + 58);
  if (v6 && (*((_DWORD *)a3 + 6) & v6) == 0) {
    return 0;
  }
  uint64_t v8 = *((void *)this + 20);
  uint64_t v7 = *((void *)this + 21);
  if (v7 == v8) {
    return 0;
  }
  uint64_t v9 = 0;
  unsigned int v10 = 1;
  while (1)
  {
    uint64_t v11 = v8 + 160 * v9;
    int v12 = *(_DWORD *)(v11 + 28);
    if (v12 && (*((_DWORD *)a3 + 6) & v12) == 0) {
      goto LABEL_19;
    }
    MTChordIntegrating::MTChordIntegrating((MTChordIntegrating *)v17, this);
    char isActiveEdgeSlide = MTSlideGesture::isActiveEdgeSlide((unsigned __int16 **)v11, (uint64_t)a2, (uint64_t)v17);
    uint64_t v16 = (void **)v26;
    std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100](&v16);
    if (__p)
    {
      CFStringRef v25 = __p;
      operator delete(__p);
    }
    if (v22)
    {
      CFTypeID v23 = v22;
      operator delete(v22);
    }
    if (v20)
    {
      uint64_t v21 = v20;
      operator delete(v20);
    }
    if (v18)
    {
      CFTypeID v19 = v18;
      operator delete(v18);
    }
    if (v17[0])
    {
      v17[1] = v17[0];
      operator delete(v17[0]);
    }
    if (isActiveEdgeSlide) {
      return 1;
    }
    uint64_t v8 = *((void *)this + 20);
    uint64_t v7 = *((void *)this + 21);
LABEL_19:
    uint64_t v9 = v10;
    if (0xCCCCCCCCCCCCCCCDLL * ((v7 - v8) >> 5) <= v10++) {
      return 0;
    }
  }
}

void sub_24071F95C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  MTChordGestureSet::~MTChordGestureSet((MTChordGestureSet *)va);
  _Unwind_Resume(a1);
}

BOOL MTChordGestureSet::chk4MinChordMotion(MTChordGestureSet *this, const MTHandMotion *a2)
{
  BOOL result = 1;
  if (*((float *)a2 + 48) == 0.0 && *((float *)a2 + 49) == 0.0 && *((float *)a2 + 50) == 0.0) {
    return *((float *)a2 + 51) != 0.0;
  }
  return result;
}

BOOL MTChordGestureSet::chk4ChordPause(MTChordGestureSet *this, const MTHandStatistics *a2, const MTHandMotion *a3, double a4, double a5, float a6)
{
  double v6 = *(double *)&qword_268C8EC50;
  LOWORD(a6) = *((_WORD *)this + 77);
  float v7 = (float)LODWORD(a6) * 0.001;
  if (v7 != 0.0) {
    double v6 = v7;
  }
  return v6 < a4 || *((double *)a2 + 1) - *((double *)a3 + 20) > v6;
}

BOOL MTChordGestureSet::chk4ChordTimein(MTChordGestureSet *this, const MTHandStatistics *a2)
{
  if (*((unsigned __int8 *)a2 + 196) > *((unsigned __int8 *)a2 + 195)) {
    return 0;
  }
  if ((*((_WORD *)this + 60) & 4) == 0) {
    return 0;
  }
  int v2 = *((unsigned __int8 *)a2 + 186);
  if (v2 != *((unsigned __int8 *)a2 + 197)) {
    return 0;
  }
  if (*((_DWORD *)this + 54) != v2) {
    return 0;
  }
  double v3 = *((double *)a2 + 10);
  if ((*((_WORD *)this + 114) & 0x100) == 0 && v3 - *((double *)a2 + 33) > *(double *)&gTimingPrefs) {
    return 0;
  }
  HIWORD(v5) = WORD1(qword_268C8EC50);
  double v6 = *(double *)&qword_268C8EC50 + *(double *)&gTimingPrefs;
  LOWORD(v5) = *((_WORD *)this + 61);
  float v7 = (float)v5 * 0.001;
  if (v7 != 0.0) {
    double v6 = v7;
  }
  if (v3 <= *((double *)a2 + 16)) {
    double v3 = *((double *)a2 + 16);
  }
  return *((double *)a2 + 1) - v3 >= v6;
}

uint64_t MTChordGestureSet::isChordReadyToIntegrate(MTChordGestureSet *this, const MTHandStatistics *a2, float32x4_t *a3)
{
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(a3[12])))) & 1) != 0
    || MTChordGestureSet::chk4ChordTimein(this, a2))
  {
    return 1;
  }
  else
  {
    return HIBYTE(*((unsigned __int16 *)this + 60)) & 1;
  }
}

void std::vector<MTSlideGesture>::__assign_with_size[abi:ne180100]<MTSlideGesture*,MTSlideGesture*>(uint64_t a1, MTSlideGesture *a2, MTSlideGesture *a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  uint64_t v9 = *(void *)a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 5) < a4)
  {
    std::vector<MTSlideGesture>::__vdeallocate((uint64_t *)a1);
    if (a4 > 0x199999999999999) {
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x999999999999999ALL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 5);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 5) >= 0xCCCCCCCCCCCCCCLL) {
      unint64_t v11 = 0x199999999999999;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<MTSlideGesture>::__vallocate[abi:ne180100]((void *)a1, v11);
    int v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<MTSlideGesture>,MTSlideGesture*,MTSlideGesture*,MTSlideGesture*>(v8, a2, a3, *(MTSlideGesture **)(a1 + 8));
    goto LABEL_11;
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((*(void *)(a1 + 8) - v9) >> 5) < a4)
  {
    unint64_t v13 = (MTSlideGesture *)((char *)a2 + 32 * ((*(void *)(a1 + 8) - v9) >> 5));
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,MTSlideGesture *,MTSlideGesture *,MTSlideGesture *,0>((uint64_t)a2, (uint64_t)v13, v9);
    int v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<MTSlideGesture>,MTSlideGesture*,MTSlideGesture*,MTSlideGesture*>(v8, v13, a3, *(MTSlideGesture **)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v12;
    return;
  }
  std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,MTSlideGesture *,MTSlideGesture *,MTSlideGesture *,0>((uint64_t)a2, (uint64_t)a3, v9);
  uint64_t v15 = v14;
  uint64_t v16 = *(void *)(a1 + 8);
  if (v16 != v14)
  {
    uint64_t v17 = *(void *)(a1 + 8);
    do
    {
      CFTypeID v19 = *(void **)(v17 - 160);
      v17 -= 160;
      CFStringRef v18 = v19;
      if (v19)
      {
        *(void *)(v16 - 152) = v18;
        operator delete(v18);
      }
      uint64_t v16 = v17;
    }
    while (v17 != v15);
  }
  *(void *)(a1 + 8) = v15;
}

void sub_24071FC68(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_24071FC70(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<MTSlideGesture>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<MTSlideGesture>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *std::vector<MTSlideGesture>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x19999999999999ALL) {
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  }
  BOOL result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTSlideGesture>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[160 * v4];
  return result;
}

MTSlideGesture *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<MTSlideGesture>,MTSlideGesture*,MTSlideGesture*,MTSlideGesture*>(uint64_t a1, MTSlideGesture *a2, MTSlideGesture *a3, MTSlideGesture *this)
{
  uint64_t v4 = this;
  unint64_t v10 = this;
  unint64_t v11 = this;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  unint64_t v9 = 0xAAAAAAAAAAAAAA00;
  if (a2 != a3)
  {
    double v6 = a2;
    do
    {
      MTSlideGesture::MTSlideGesture(v4, v6);
      double v6 = (const MTSlideGesture *)((char *)v6 + 160);
      uint64_t v4 = (MTSlideGesture *)((char *)v11 + 160);
      unint64_t v11 = (MTSlideGesture *)((char *)v11 + 160);
    }
    while (v6 != a3);
  }
  LOBYTE(v9) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,MTSlideGesture*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_24071FD9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,MTSlideGesture*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,MTSlideGesture*>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<MTSlideGesture>,MTSlideGesture*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  if (v1 != v2)
  {
    uint64_t v3 = **(void **)(a1 + 16);
    do
    {
      unsigned int v5 = *(void **)(v3 - 160);
      v3 -= 160;
      uint64_t v4 = v5;
      if (v5)
      {
        *(void *)(v1 - 152) = v4;
        operator delete(v4);
      }
      uint64_t v1 = v3;
    }
    while (v3 != v2);
  }
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,MTSlideGesture *,MTSlideGesture *,MTSlideGesture *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      MTSlideGesture::operator=(a3, v4);
      v4 += 160;
      a3 += 160;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

void MTChordIntegrating::MTChordIntegrating(MTChordIntegrating *this)
{
  MTChordGestureSet::MTChordGestureSet(this);
  MTChordIntegrating::clearIntegrationState(v1);
}

void sub_24071FEC4(_Unwind_Exception *a1)
{
  MTChordGestureSet::~MTChordGestureSet(v1);
  _Unwind_Resume(a1);
}

uint64_t MTChordIntegrating::clearIntegrationState(MTChordIntegrating *this)
{
  *((void *)this + 34) = 0;
  *((void *)this + 3MTHandMotion::clearHandMotion(this, 1) = 0;
  *((void *)this + 32) = 0;
  *((void *)this + 30) = 0;
  *((_DWORD *)this + 66) = 0;
  *((_DWORD *)this + 70) = 1;
  *(_OWORD *)((char *)this + 284) = 0u;
  *(_OWORD *)((char *)this + 300) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  uint64_t v2 = *((void *)this + 20);
  if (*((void *)this + 21) != v2)
  {
    uint64_t v3 = 0;
    unsigned int v4 = 1;
    do
    {
      MTSlideGesture::clearIntegrationState((MTSlideGesture *)(v2 + 160 * v3));
      uint64_t v3 = v4;
      uint64_t v2 = *((void *)this + 20);
    }
    while (0xCCCCCCCCCCCCCCCDLL * ((*((void *)this + 21) - v2) >> 5) > v4++);
  }
  *((_DWORD *)this + 98) = 0;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *((void *)this + 50) = 0;

  return MTChordIntegrating::resetMostIntegrators((uint64_t)this, 0);
}

void MTChordIntegrating::MTChordIntegrating(MTChordIntegrating *this, const MTChordGestureSet *a2)
{
  MTChordGestureSet::MTChordGestureSet(this, a2);
  MTChordIntegrating::clearIntegrationState(v2);
}

void sub_24071FFD4(_Unwind_Exception *a1)
{
  MTChordGestureSet::~MTChordGestureSet(v1);
  _Unwind_Resume(a1);
}

MTChordIntegrating *MTChordIntegrating::operator=(MTChordIntegrating *a1, uint64_t a2)
{
  if (a1 != (MTChordIntegrating *)a2)
  {
    MTChordGestureSet::operator=((uint64_t)a1, a2);
    MTChordIntegrating::clearIntegrationState(a1);
  }
  return a1;
}

void MTChordIntegrating::nullify(void **this)
{
  v12[10] = *MEMORY[0x263EF8340];
  MTChordGestureSet::MTChordGestureSet((MTChordGestureSet *)v3);
  if (v3 != this)
  {
    MTChordGestureSet::operator=((uint64_t)this, (uint64_t)v3);
    MTChordIntegrating::clearIntegrationState((MTChordIntegrating *)this);
  }
  uint64_t v2 = (void **)v12;
  std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100](&v2);
  if (__p)
  {
    unint64_t v11 = __p;
    operator delete(__p);
  }
  if (v8)
  {
    unint64_t v9 = v8;
    operator delete(v8);
  }
  if (v6)
  {
    float v7 = v6;
    operator delete(v6);
  }
  if (v4)
  {
    unsigned int v5 = v4;
    operator delete(v4);
  }
  if (v3[0])
  {
    v3[1] = v3[0];
    operator delete(v3[0]);
  }
}

void sub_240720110(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

BOOL MTChordIntegrating::hasChordStabilized(MTChordIntegrating *this, const MTHandStatistics *a2, const MTHandMotion *a3)
{
  if (*((unsigned char *)this + 264)) {
    return 1;
  }
  unsigned int v3 = *((unsigned __int8 *)a2 + 186);
  if (v3 == 5) {
    return 1;
  }
  BOOL v5 = *((unsigned __int8 *)a2 + 196) <= *((unsigned __int8 *)a2 + 195) && *((unsigned char *)a2 + 201) == 0;
  return v5
      && ((*((_WORD *)this + 114) & 0x100) == 0
       || sqrtf((float)(*((float *)a3 + 84) * *((float *)a3 + 84)) + (float)(*((float *)a3 + 83) * *((float *)a3 + 83))) <= 100.0)
      && *((double *)a2 + 1) - *((double *)a2 + 10) >= (double)v3 * 0.0100000007
      || *((double *)a2 + 1) - *((double *)a2 + 10) >= (double)v3 * 0.0200000014;
}

uint64_t MTChordIntegrating::getActiveDegreesOfFreedomMask(MTChordIntegrating *this, const MTHandStatistics *a2, const MTChordCycling *a3)
{
  if (!*((unsigned char *)this + 264)) {
    return 0;
  }
  uint64_t v4 = *((void *)this + 20);
  if (*((void *)this + 21) == v4) {
    return 0;
  }
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  unsigned int v9 = 1;
  do
  {
    uint64_t v10 = v4 + 160 * v7;
    int v11 = *(_DWORD *)(v10 + 28);
    if ((!v11 || (*((_DWORD *)a3 + 6) & v11) != 0)
      && !MTSlideGesture::isLockedOutByTriggeredSlide(v10, (uint64_t)a2, (uint64_t)this, 1))
    {
      uint64_t v8 = MTSlideGesture::getDegreesOfFreedomMask(v10) | v8;
    }
    uint64_t v7 = v9;
    uint64_t v4 = *((void *)this + 20);
  }
  while (0xCCCCCCCCCCCCCCCDLL * ((*((void *)this + 21) - v4) >> 5) > v9++);
  return v8;
}

double MTChordIntegrating::beginChordIntegration(double *a1, uint64_t a2)
{
  MTChordIntegrating::clearIntegrationState((MTChordIntegrating *)a1);
  double result = *(double *)(a2 + 80);
  a1[30] = result;
  return result;
}

void MTChordIntegrating::endChordIntegration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(_DWORD *)(a1 + 224))
  {
    if (*(unsigned char *)(a1 + 264))
    {
      MTChordIntegrating::sendLiftSlideEvents(a1, a2, a3, a3 + 168, a4, a5);
    }
    else if (*(unsigned char *)(a1 + 266))
    {
      if (*(void *)(a1 + 104) == *(void *)(a1 + 96)) {
        std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
      }
      (*(void (**)(void, void, uint64_t, uint64_t, void, uint64_t, uint64_t, double))(**(void **)(a5 + 392)
                                                                                                 + 24))(*(void *)(a5 + 392), *(void *)(a1 + 96), a4, 32, 0, a3 + 168, 0x2000, *(double *)(a2 + 8));
      *(unsigned char *)(a1 + 266) = 0;
    }
    MTChordIntegrating::clearIntegrationState((MTChordIntegrating *)a1);
    MTChordIntegrating::nullify((void **)a1);
  }
}

void MTChordIntegrating::sendLiftSlideEvents(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!*(unsigned char *)(a1 + 264)) {
    return;
  }
  int v11 = *(_DWORD *)(a1 + 216);
  if (v11 < 2)
  {
    char v16 = 0;
  }
  else
  {
    int v12 = *(_WORD **)(a1 + 96);
    if (v12 == *(_WORD **)(a1 + 104)
      || *v12 != 65
      || (unint64_t v13 = *(void **)(a1 + 160), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 168) - (void)v13) >> 5) > 2)
      || *v13 == v13[1]
      || *(_WORD *)*v13 != 69
      || ((uint64_t v14 = *(void *)(a1 + 272)) == 0 ? (v15 = 0.0) : (v15 = *(double *)(v14 + 144)),
          *(double *)(a2 + 8) - v15 >= *(double *)&qword_268C8EC70))
    {
      char v16 = 0;
    }
    else
    {
      MTDragManagerEventQueue::stopMomentum(a6, a5, 4);
      MTTapDragManager::sustainMultiFingerDrag(*(void *)(a6 + 392), a2);
      if (!*(unsigned char *)(a1 + 264)) {
        return;
      }
      char v16 = 1;
    }
    int v11 = *(_DWORD *)(a1 + 216);
  }
  if (v11 == 1 && *(void *)a1 != *(void *)(a1 + 8) && **(_WORD **)a1 == 65)
  {
    if (*(unsigned char *)(a2 + 186))
    {
      unsigned int v17 = *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186);
      if (v17 >= *(unsigned __int8 *)(a2 + 190) + *(unsigned __int8 *)(a2 + 187)) {
        goto LABEL_28;
      }
      uint64_t v18 = *(void *)(a6 + 392);
      if (v17 > *(unsigned __int8 *)(v18 + 48)) {
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v18 = *(void *)(a6 + 392);
    }
    double v19 = *(double *)(a2 + 8);
    if (*(int *)(v18 + 24) <= 1) {
      double v19 = 0.0;
    }
    *(double *)(v18 + 80) = v19;
  }
LABEL_28:
  if ((v16 & 1) == 0)
  {
    uint64_t v20 = *(void *)(a1 + 272);
    if (v20)
    {
      uint64_t v21 = *(MTActionEvent **)v20;
      if (*(void *)v20 == *(void *)(v20 + 8)) {
        std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
      }
      if (*(unsigned __int16 *)v21 - 35 > 4)
      {
        int v22 = MTActionEvent::deriveGestureEndedType(v21);
        if (v22)
        {
          __int16 v23 = v22;
          CFStringRef v24 = *(void **)(a1 + 272);
          if (*v24 != v24[1] && (*(_WORD *)*v24 & 0xFFFE) == 0x46) {
            (*(void (**)(void, double))(**(void **)(a6 + 392) + 24))(*(void *)(a6 + 392), *(double *)(a2 + 8));
          }
          unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
          MTActionEvent::MTActionEvent((MTActionEvent *)&v26, v23, 0, 0);
          (*(void (**)(void, unint64_t *, uint64_t, void, void, uint64_t, uint64_t, void, double))(**(void **)(a6 + 392) + 24))(*(void *)(a6 + 392), &v26, a5, 0, 0, a4, 0x2000, *(unsigned int *)(a1 + 224), *(double *)(a2 + 8));
        }
      }
      else
      {
        MTChordIntegrating::possiblyStartFluidMomentum((void *)a1, (const MTHandStatistics *)a2, a5, a6);
      }
    }
    if (*(_WORD *)(a1 + 152))
    {
      CFStringRef v25 = *(_WORD **)(a1 + 128);
      if (v25 != *(_WORD **)(a1 + 136))
      {
        if (*v25) {
          MTGesture::dispatchEvents((uint64_t *)(a1 + 128), *(void *)(a6 + 392), a5, 16, 0, a4, 0x2000, *(unsigned int *)(a1 + 224), *(double *)(a2 + 8));
        }
      }
    }
  }
}

uint64_t MTChordIntegrating::possiblyStartFluidMomentum(void *a1, const MTHandStatistics *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a1[20];
  uint64_t v4 = a1[21];
  if (v4 == v5)
  {
    char v9 = 0;
  }
  else
  {
    uint64_t v8 = 0;
    char v9 = 0;
    unsigned int v10 = 1;
    do
    {
      int v11 = (uint64_t *)(v5 + 160 * v8);
      if (*((unsigned char *)v11 + 68))
      {
        float v12 = MTSlideGesture::fluidSwipePercentage((MTSlideGesture *)(v5 + 160 * v8));
        int hasSufficientFluidMomentum = MTSlideGesture::hasSufficientFluidMomentum((MTSlideGesture *)(v5 + 160 * v8), a2, v11 == (uint64_t *)a1[34]);
        uint64_t v14 = *v11;
        if (v11[1] == *v11) {
          std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
        }
        uint64_t v15 = *(void *)(a4 + 392);
        if (hasSufficientFluidMomentum) {
          uint64_t v16 = 16;
        }
        else {
          uint64_t v16 = 32;
        }
        float v17 = MTSlideGesture::fluidMomentumPercentage_s((MTSlideGesture *)(v5 + 160 * v8), v11 == (uint64_t *)a1[34]);
        v25[0] = MTSlideGesture::fluidDOFPercentageDeltas((MTSlideGesture *)(v5 + 160 * v8));
        v25[1] = v18;
        v25[2] = v19;
        v25[3] = v20;
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, _DWORD *, void, float, float))(*(void *)v15 + 32))(v15, v14, a3, v16, 0, v25, *(unsigned __int8 *)(v5 + 160 * v8 + 32), v12, v17);
        uint64_t v5 = a1[20];
        uint64_t v4 = a1[21];
        char v9 = 1;
      }
      uint64_t v8 = v10;
    }
    while (0xCCCCCCCCCCCCCCCDLL * ((v4 - v5) >> 5) > v10++);
  }
  return v9 & 1;
}

uint64_t MTChordIntegrating::commit2Chord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int16 a6, double a7)
{
  *(unsigned char *)(a1 + 264) = 1;
  *(void *)(a1 + 256) = *(void *)(a2 + 8);
  long long v18 = *(_OWORD *)(a3 + 168);
  int v12 = *(_DWORD *)(a1 + 216);
  if (v12 != 1)
  {
    if (v12 >= 2)
    {
      unint64_t v13 = *(_WORD **)(a1 + 96);
      if (v13 != *(_WORD **)(a1 + 104) && *v13 == 65)
      {
        uint64_t v14 = *(void **)(a1 + 160);
        if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 168) - (void)v14) >> 5) <= 2
          && *v14 != v14[1]
          && *(_WORD *)*v14 == 69)
        {
          *(unsigned char *)(a4 + 28) = 1;
          goto LABEL_5;
        }
      }
    }
LABEL_13:
    MTTapDragManager::sendPendingMultiFingerTap(a4, a5, a2, a3, 0, a7);
    MTTapDragManager::clearCycle(a4);
    goto LABEL_14;
  }
  if (*(void *)a1 == *(void *)(a1 + 8) || **(_WORD **)a1 != 65) {
    goto LABEL_13;
  }
  if (*(_DWORD *)(a4 + 24) == 2) {
LABEL_5:
  }
    MTTapDragManager::setCycleState(a4, 3);
LABEL_14:
  uint64_t result = *(void *)(a1 + 272);
  if (!result) {
    goto LABEL_23;
  }
  if (*(unsigned char *)(a1 + 266))
  {
    if (*(void *)(result + 8) == *(void *)result) {
      goto LABEL_28;
    }
    if (**(_WORD **)result != 70)
    {
      if (*(void *)(a1 + 104) == *(void *)(a1 + 96)) {
        goto LABEL_28;
      }
      (*(void (**)(uint64_t, double))(*(void *)a4 + 24))(a4, *(double *)(a2 + 8));
      *(unsigned char *)(a1 + 266) = 0;
      uint64_t result = *(void *)(a1 + 272);
    }
  }
  if (*(void *)(result + 8) == *(void *)result) {
LABEL_28:
  }
    std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
  uint64_t result = MTActionEvent::deriveGestureStartedType(*(MTActionEvent **)result);
  if (result)
  {
    unint64_t v17 = 0xAAAAAAAAAAAAAAAALL;
    MTActionEvent::MTActionEvent((MTActionEvent *)&v17, result, 0, 0);
    uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, uint64_t, void, long long *, uint64_t, void, double))(*(void *)a4 + 24))(a4, &v17, a5, 2, 0, &v18, 4096, *(unsigned int *)(a1 + 224), *(double *)(a2 + 8));
  }
LABEL_23:
  if ((*(_WORD *)(a1 + 120) & a6) != 0)
  {
    uint64_t v16 = *(_WORD **)(a1 + 96);
    if (v16 != *(_WORD **)(a1 + 104))
    {
      if (*v16) {
        return MTGesture::dispatchEvents((uint64_t *)(a1 + 96), a4, a5, 2, 0, (uint64_t)&v18, 4096, *(unsigned int *)(a1 + 224), *(double *)(a2 + 8));
      }
    }
  }
  return result;
}

uint64_t MTChordIntegrating::sendSlidePreamble(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int16 a7, double a8)
{
  long long v26 = *(_OWORD *)(a3 + 168);
  ++*(_DWORD *)(a1 + 300);
  unsigned int v13 = *(unsigned __int8 *)(a2 + 186);
  *(_DWORD *)(a1 + 292) = v13;
  unsigned int v14 = *(_DWORD *)(a1 + 296);
  if (!v14
    || (v14 < v13 ? (BOOL v15 = *(double *)(a2 + 8) - *(double *)(a2 + 80) <= *(double *)&qword_268C8EC28) : (BOOL v15 = 1),
        v15 ? (BOOL v16 = v13 > 1) : (BOOL v16 = 0),
        !v16))
  {
    *(_DWORD *)(a1 + 296) = v13;
  }
  if (!*(unsigned char *)(a1 + 264))
  {
    *(void *)(a1 + 272) = a6;
    MTChordIntegrating::commit2Chord(a1, a2, a3, a4, a5, a7, a8);
    uint64_t result = 1;
    if (!a6) {
      return result;
    }
    goto LABEL_34;
  }
  uint64_t v17 = *(void *)(a1 + 272);
  if (v17 == a6) {
    goto LABEL_17;
  }
  uint64_t result = 0;
  if (a6 && v17)
  {
    if (*(void *)(v17 + 8) == *(void *)v17) {
      std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
    }
    int v19 = MTActionEvent::deriveGestureStartedType(*(MTActionEvent **)v17);
    if (*(void *)(a6 + 8) != *(void *)a6)
    {
      if (v19 == MTActionEvent::deriveGestureStartedType(*(MTActionEvent **)a6))
      {
LABEL_17:
        uint64_t result = 0;
        goto LABEL_31;
      }
      uint64_t v20 = *(void *)(a1 + 272);
      if (*(void *)(v20 + 8) != *(void *)v20)
      {
        if (MTActionEvent::deriveGestureEndedType(*(MTActionEvent **)v20))
        {
          unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
          uint64_t v21 = *(void *)(a1 + 272);
          if (*(void *)(v21 + 8) == *(void *)v21) {
            goto LABEL_37;
          }
          __int16 v22 = MTActionEvent::deriveGestureEndedType(*(MTActionEvent **)v21);
          MTActionEvent::MTActionEvent((MTActionEvent *)&v25, v22, 0, 0);
          (*(void (**)(uint64_t, unint64_t *, uint64_t, uint64_t, void, long long *, uint64_t, void, double))(*(void *)a4 + 24))(a4, &v25, a5, 16, 0, &v26, 0x2000, *(unsigned int *)(a1 + 224), *(double *)(a2 + 8));
          __int16 v23 = *(void **)(a1 + 272);
          if (*v23 != v23[1] && (*(_WORD *)*v23 & 0xFFFE) == 0x46) {
            (*(void (**)(uint64_t, double))(*(void *)a4 + 24))(a4, *(double *)(a2 + 8));
          }
        }
        if (*(void *)(a6 + 8) != *(void *)a6)
        {
          if (!MTActionEvent::deriveGestureStartedType(*(MTActionEvent **)a6))
          {
LABEL_30:
            uint64_t result = 1;
            goto LABEL_31;
          }
          unint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
          if (*(void *)(a6 + 8) != *(void *)a6)
          {
            __int16 v24 = MTActionEvent::deriveGestureStartedType(*(MTActionEvent **)a6);
            MTActionEvent::MTActionEvent((MTActionEvent *)&v25, v24, 0, 0);
            (*(void (**)(uint64_t, unint64_t *, uint64_t, uint64_t, void, long long *, uint64_t, void, double))(*(void *)a4 + 24))(a4, &v25, a5, 2, 0, &v26, 0x2000, *(unsigned int *)(a1 + 224), *(double *)(a2 + 8));
            goto LABEL_30;
          }
        }
      }
    }
LABEL_37:
    std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
  }
LABEL_31:
  if (*(void *)(a1 + 272) != a6)
  {
    *(_DWORD *)(a1 + 392) = 0;
    *(_OWORD *)(a1 + 360) = 0u;
    *(_OWORD *)(a1 + 376) = 0u;
    *(_OWORD *)(a1 + 328) = 0u;
    *(_OWORD *)(a1 + 344) = 0u;
    *(_OWORD *)(a1 + 312) = 0u;
  }
  *(void *)(a1 + 272) = a6;
  if (a6)
  {
LABEL_34:
    if (*(unsigned char *)(a1 + 265)) {
      *(unsigned char *)(a1 + 265) = 0;
    }
  }
  return result;
}

double MTChordIntegrating::clearMomentumFilters(MTChordIntegrating *this)
{
  *((_DWORD *)this + 98) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  return result;
}

uint64_t MTChordIntegrating::resetMostIntegrators(uint64_t this, MTSlideGesture *a2)
{
  uint64_t v3 = *(void *)(this + 160);
  uint64_t v2 = *(void *)(this + 168);
  if (v2 != v3)
  {
    uint64_t v4 = 0;
    unsigned int v5 = 1;
    do
    {
      if ((MTSlideGesture *)(v3 + 160 * v4) != a2)
      {
        uint64_t v6 = v3 + 160 * v4;
        *(_DWORD *)(v6 + 120) = 0;
        *(_OWORD *)(v6 + 80) = 0uLL;
        *(_OWORD *)(v6 + 96) = 0uLL;
        uint64_t v3 = *(void *)(this + 160);
        uint64_t v2 = *(void *)(this + 168);
      }
      uint64_t v4 = v5;
    }
    while (0xCCCCCCCCCCCCCCCDLL * ((v2 - v3) >> 5) > v5++);
  }
  return this;
}

BOOL MTChordIntegrating::momentumHistoryTimedOut(MTChordIntegrating *this, double a2)
{
  uint64_t v2 = *((void *)this + 34);
  return !v2 || a2 - *(double *)(v2 + 144) > 0.100000001;
}

void MTChordIntegrating::momentumFilterAlpha(MTChordIntegrating *this, const MTHandStatistics *a2, int a3)
{
  double v3 = (*((double *)a2 + 1) - *((double *)a2 + 2)) / 0.00800000038;
  if (a3)
  {
    exp2(v3 * -2.0);
    pow(0.800000012, v3);
  }
  else
  {
    pow(0.850000024, v3);
  }
}

float MTChordIntegrating::filteredMomentumSquared(MTChordIntegrating *this)
{
  return (float)(*((float *)this + 91) * *((float *)this + 91)) + (float)(*((float *)this + 90) * *((float *)this + 90));
}

double MTChordIntegrating::decayMomentumFilters(MTChordIntegrating *this, const MTHandStatistics *a2)
{
  uint64_t v2 = *((void *)this + 34);
  if (v2)
  {
    double result = *((double *)a2 + 1);
    if (result != *(double *)(v2 + 144))
    {
      int32x4_t v4 = 0uLL;
      *(void *)&double result = MTChordIntegrating::updateMomentumMickeys((uint64_t)this, &v4, (double *)a2).u64[0];
    }
  }
  return result;
}

float32x4_t MTChordIntegrating::updateMomentumMickeys(uint64_t a1, int32x4_t *a2, double *a3)
{
  uint64_t v6 = (float32x4_t *)(a1 + 360);
  uint64_t v7 = *(void *)(a1 + 272);
  if (v7 && a3[1] - *(double *)(v7 + 144) <= 0.100000001)
  {
    float v11 = *(float *)(a1 + 392);
    float v10 = *(float *)(a1 + 376);
    float v9 = *(float *)(a1 + 380);
    float v8 = *(float *)(a1 + 360);
    float v26 = *(float *)(a1 + 364);
  }
  else
  {
    *(_DWORD *)(a1 + 392) = 0;
    *(_OWORD *)(a1 + 360) = 0u;
    *(_OWORD *)(a1 + 376) = 0u;
    *(_OWORD *)(a1 + 328) = 0u;
    *(_OWORD *)(a1 + 344) = 0u;
    *(_OWORD *)(a1 + 312) = 0u;
    float v26 = 0.0;
    float v8 = 0.0;
    float v9 = 0.0;
    float v10 = 0.0;
    float v11 = 0.0;
  }
  *(int32x4_t *)(a1 + 328) = *a2;
  float v12 = hypot((double)a2->i32[0], (double)a2->i32[1]);
  long double v13 = (a3[1] - a3[2]) / 0.00800000038;
  float v14 = pow(dbl_24074F740[v11 < (float)(v12 + v12)], v13);
  *(float *)(a1 + 392) = (float)((float)(1.0 - v14) * v12) + (float)(v14 * v11);
  float v15 = hypotf(v10, v9);
  float v16 = pow(dbl_24074F750[v15 < (float)(v12 + v12)], v13);
  float v25 = v16;
  float v24 = 1.0 - v16;
  BOOL v17 = hypotf(v8, v26) < v12;
  MTChordIntegrating::momentumFilterAlpha(v18, (const MTHandStatistics *)a3, v17);
  float32x4_t v20 = vcvtq_f32_s32(*a2);
  float32x4_t v21 = vmlaq_n_f32(vmulq_n_f32(v20, 1.0 - v19), *v6, v19);
  float32x4_t result = (float32x4_t)vbicq_s8((int8x16_t)v21, (int8x16_t)vcltzq_f32(vmulq_f32(v21, v20)));
  float32x4_t v23 = vmlaq_n_f32(vmulq_n_f32(v20, v24), v6[1], v25);
  *uint64_t v6 = result;
  v6[1] = v23;
  return result;
}

BOOL MTChordIntegrating::significantMomentumMickeys(MTChordIntegrating *this, float a2)
{
  return (float)((float)(*((float *)this + 91) * *((float *)this + 91))
               + (float)(*((float *)this + 90) * *((float *)this + 90))) >= (float)(a2 * a2);
}

uint64_t MTChordIntegrating::switchingVerticalToHorizontal(int32x2_t *this, float a2, int a3)
{
  if (a3) {
    *(_OWORD *)this[43].i8 = *(_OWORD *)this[41].i8;
  }
  int v3 = this[43].i32[0];
  if (v3 < 0) {
    int v3 = -v3;
  }
  int v4 = this[43].i32[1];
  if (v4 < 0) {
    int v4 = -v4;
  }
  if (v3 >= (2 * v4))
  {
    unsigned __int8 v6 = 0;
  }
  else
  {
    int32x2_t v5 = vabs_s32(this[41]);
    unsigned __int8 v6 = vcgt_u32((uint32x2_t)v5, (uint32x2_t)vdup_lane_s32(v5, 1)).u8[0];
  }
  return v6 & 1;
}

uint64_t MTChordIntegrating::markMomentumPause(MTChordIntegrating *this, const MTHandStatistics *a2)
{
  MTChordIntegrating::markMomentumPause(this, a2, 3.0, (double *)this + 40);

  return MTChordIntegrating::markMomentumPause(this, a2, 3.5, (double *)this + 39);
}

uint64_t MTChordIntegrating::markMomentumPause(MTChordIntegrating *this, const MTHandStatistics *a2, float a3, double *a4)
{
  float v6 = *((float *)this + 98) * a3;
  if (v6 >= 1.0) {
    float v7 = v6;
  }
  else {
    float v7 = 1.0;
  }
  if ((float)((float)(*((float *)this + 91) * *((float *)this + 91))
             + (float)(*((float *)this + 90) * *((float *)this + 90))) <= v7)
    goto LABEL_10;
  int v9 = *((_DWORD *)this + 82);
  int v10 = *((_DWORD *)this + 83);
  float v11 = hypot((double)v9, (double)v10);
  float v12 = *((float *)this + 94);
  float v13 = *((float *)this + 95);
  float v14 = hypotf(v12, v13);
  uint64_t result = 0;
  BOOL v16 = (float)(v11 * v11) <= v7 || (float)(v14 * v14) <= v7;
  if (!v16 && (float)((float)((float)(v13 * (float)v10) + (float)(v12 * (float)v9)) / (float)(v14 * v11)) < -0.5)
  {
LABEL_10:
    *a4 = *((double *)a2 + 1);
    return 1;
  }
  return result;
}

BOOL MTChordIntegrating::recentMomentumPause(MTChordIntegrating *this, const MTHandStatistics *a2, int a3)
{
  uint64_t v3 = 312;
  if (a3) {
    uint64_t v3 = 320;
  }
  double v4 = *((double *)a2 + 1) - *(double *)((char *)this + v3);
  int32x2_t v5 = &qword_268C8EC28;
  if (a3) {
    int32x2_t v5 = &qword_268C8EC30;
  }
  return v4 < *(double *)v5;
}

uint64_t MTChordIntegrating::possiblyStartMomentum(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!*(unsigned char *)(a1 + 264)) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 272);
  if (!v5) {
    return 0;
  }
  if ((*(unsigned char *)(v5 + 34) & 0x40) == 0) {
    return 0;
  }
  float v6 = *(_WORD **)v5;
  if (*(void *)v5 == *(void *)(v5 + 8)) {
    return 0;
  }
  int v10 = (unsigned __int16)*v6;
  if (v10 == 69)
  {
    unsigned int v13 = *(unsigned __int8 *)(a2 + 186);
    unsigned int v14 = *(unsigned __int8 *)(a2 + 211) + v13;
    if (v14
      && (float)((float)(*(float *)(a1 + 364) * *(float *)(a1 + 364))
               + (float)(*(float *)(a1 + 360) * *(float *)(a1 + 360))) >= 25.0)
    {
      if (v14 != 1 || v13 <= *(unsigned __int8 *)(a2 + 195))
      {
        MTDragManagerEventQueue::startMomentum(a4, a3, 4);
        goto LABEL_36;
      }
      MTDragManagerEventQueue::stopMomentum(a4, a3, 4);
      return 0;
    }
    goto LABEL_11;
  }
  if (v10 != 70
    || (float v11 = *(float *)(a1 + 360), v12 = *(float *)(a1 + 364), (float)((float)(v12 * v12) + (float)(v11 * v11)) < 25.0))
  {
LABEL_11:
    if (*v6 == 68
      && *(double *)(a2 + 8) - *(double *)(a4 + 1240) > *(double *)&qword_268C8EC50
      && (float)((float)(*(float *)(a1 + 364) * *(float *)(a1 + 364))
               + (float)(*(float *)(a1 + 360) * *(float *)(a1 + 360))) >= 64.0)
    {
      MTDragManagerEventQueue::startMomentum(a4, a3, 2);
LABEL_36:
      MTAppendRelativeMouseEvent();
      return 1;
    }
    return 0;
  }
  int v15 = (int)(float)-v11;
  int v16 = (int)(float)-v12;
  if (v15 >= 0) {
    unsigned int v17 = (int)(float)-v11;
  }
  else {
    unsigned int v17 = -v15;
  }
  float v18 = (float)v17;
  if (v16 >= 0) {
    unsigned int v19 = v16;
  }
  else {
    unsigned int v19 = -v16;
  }
  if ((float)((float)v19 * 3.0) >= v18)
  {
    if ((float)(v18 * 3.0) < (float)v19) {
      int v15 = 0;
    }
  }
  else
  {
    int v16 = 0;
  }
  if ((float)((float)((float)v16 * (float)v16) + (float)((float)v15 * (float)v15)) < 25.0
    || *(double *)(a2 + 8) - *(double *)(a1 + 400) <= 0.05)
  {
    return 1;
  }
  uint64_t v20 = 1;
  MTAppendMomentumEnableEvent();
  MTAppendScrollEvent();
  if (*(unsigned char *)(a4 + 1264)) {
    MTDragManagerEventQueue::stopMomentum(a4, a3, 1);
  }
  *(void *)(a1 + 400) = *(void *)(a2 + 8);
  *(_DWORD *)(a4 + 1268) = 1;
  *(unsigned char *)(a4 + 1264) = 1;
  return v20;
}

uint64_t MTChordIntegrating::clearMickeysSinceLastTouchdown(uint64_t this)
{
  *(_DWORD *)(this + 288) = 0;
  uint64_t v1 = *(void *)(this + 160);
  uint64_t v2 = *(void *)(this + 168) - v1;
  if (v2)
  {
    unint64_t v3 = 0xCCCCCCCCCCCCCCCDLL * (v2 >> 5);
    double v4 = (_DWORD *)(v1 + 112);
    unsigned int v5 = 1;
    do
    {
      *double v4 = 0;
      v4 += 40;
    }
    while (v3 > v5++);
  }
  return this;
}

BOOL MTChordIntegrating::waitForFastShotVerification(MTChordIntegrating *this, const MTHandStatistics *a2, const MTHandMotion *a3)
{
  if (*((_DWORD *)this + 75) != 1) {
    return 0;
  }
  double v3 = *((double *)a2 + 1) - *((double *)a2 + 7);
  if (v3 < 0.135000005) {
    return 1;
  }
  if (v3 >= 0.230000004) {
    return 0;
  }
  if (!*((unsigned char *)a2 + 186)) {
    return 1;
  }
  return *((unsigned __int8 *)a2 + 191) > *((unsigned __int8 *)a2 + 186);
}

uint64_t MTChordIntegrating::continueChordIntegration(MTChordGestureSet *this, MTHandStatistics *a2, const MTHandMotion *a3, uint64_t a4, uint64_t a5, double a6, double a7, float a8)
{
  uint64_t v12 = *((void *)this + 34);
  if (v12) {
    double v13 = *(double *)(v12 + 144);
  }
  else {
    double v13 = 0.0;
  }
  uint64_t result = MTChordGestureSet::chk4ChordPause(this, a2, a3, *((double *)a2 + 1) - v13, v13, a8);
  if (result)
  {
    double v15 = *((double *)a2 + 1);
    if (*((unsigned char *)this + 265))
    {
      double v16 = *((double *)this + 38);
    }
    else
    {
      *((double *)this + 38) = v15;
      double v16 = v15;
    }
    *((unsigned char *)this + 265) = 1;
    if (v15 - v16 > 0.120000005) {
      *((unsigned char *)this + 267) = 0;
    }
  }
  int v17 = *((_DWORD *)this + 58);
  if (v17 && (*(_DWORD *)(a5 + 24) & v17) == 0) {
    goto LABEL_83;
  }
  double v18 = *((double *)a2 + 1);
  double v19 = *(double *)(a5 + 1240);
  if ((*((_WORD *)this + 60) & 0x100) != 0 && !*((unsigned char *)this + 266) && !*((unsigned char *)this + 264))
  {
    uint64_t result = *(void *)(a5 + 392);
    if ((!*(unsigned char *)(result + 28) || *(int *)(result + 24) <= 2)
      && v18 - *((double *)this + 31) > *(double *)&qword_268C8EC38)
    {
      if (*((void *)this + 13) == *((void *)this + 12)) {
        std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, double))(*(void *)result + 24))(result, *((double *)a2 + 1));
      *((unsigned char *)this + 266) = 1;
    }
  }
  double v20 = v18 - v19;
  if (!*((unsigned char *)this + 264))
  {
    uint64_t result = MTChordIntegrating::hasChordStabilized(this, a2, a3);
    if (result)
    {
      uint64_t result = MTChordGestureSet::chk4ChordTimein(this, a2);
      if (result) {
        uint64_t result = MTChordIntegrating::sendSlidePreamble((uint64_t)this, (uint64_t)a2, (uint64_t)a3, *(void *)(a5 + 392), a4, 0, 4u, v20);
      }
    }
  }
  uint64_t v21 = *((void *)this + 20);
  if (*((void *)this + 21) == v21) {
    goto LABEL_83;
  }
  uint64_t v52 = a4;
  uint64_t v53 = 0;
  uint64_t v22 = 0;
  CFIndex v55 = 0;
  uint64_t v23 = 0;
  CFIndex v57 = 0;
  int v56 = 0;
  int v24 = 0;
  float v25 = 0.0;
  unsigned int v26 = 1;
  CFTypeID v27 = a3;
  do
  {
    CFIndex v28 = (unsigned __int16 **)(v21 + 160 * v22);
    int v29 = *((_DWORD *)v28 + 7);
    if (!v29 || (*(_DWORD *)(a5 + 24) & v29) != 0)
    {
      CFIndex v30 = v27;
      if (MTSlideGesture::isBlocked((unsigned __int16 **)(v21 + 160 * v22), (uint64_t)a2, (uint64_t)v27, (uint64_t)this, *(unsigned char *)(a5 + 400)))
      {
        CFTypeID v27 = v30;
        goto LABEL_40;
      }
      float v31 = MTSlideGesture::integrateGesture((MTSlideGesture *)(v21 + 160 * v22), a2, v30, *(const MTDragManagerEventQueue **)(a5 + 392), this, *((double *)a2 + 1) - *(double *)(a5 + 1232));
      BOOL canPunishSomeMoving = MTSlideGesture::canPunishSomeMoving((MTSlideGesture *)(v21 + 160 * v22), (uint64_t)a2, (uint64_t)this);
      BOOL v33 = v31 < v25;
      if (v31 >= v25) {
        float v25 = v31;
      }
      unsigned int v34 = v57;
      if (!v33) {
        unsigned int v34 = (unsigned __int16 **)(v21 + 160 * v22);
      }
      CFIndex v57 = v34;
      if (*v28 == v28[1] || **v28 - 35 > 4)
      {
        uint64_t v37 = v23;
        CFTypeID v27 = a3;
        CFIndex v28 = (unsigned __int16 **)v55;
      }
      else
      {
        CFTypeID v27 = a3;
        if (!v53 || (uint64_t v35 = v53, fabsf(*(float *)(v21 + 160 * v22 + 80)) > fabsf(*(float *)(v53 + 80)))) {
          uint64_t v35 = v21 + 160 * v22;
        }
        uint64_t v53 = v35;
        if (v23)
        {
          float v36 = fabsf(*(float *)(v21 + 160 * v22 + 92));
          if (v36 <= fabsf(*(float *)(v23 + 92)))
          {
            int v38 = v56;
            if (v55 && v36 <= fabsf(v55[23]))
            {
              uint64_t v37 = v23;
              CFIndex v28 = (unsigned __int16 **)v55;
            }
            else
            {
              uint64_t v37 = v23;
            }
            goto LABEL_39;
          }
          uint64_t v37 = v21 + 160 * v22;
          CFIndex v28 = (unsigned __int16 **)v23;
        }
        else
        {
          uint64_t v37 = v21 + 160 * v22;
          CFIndex v28 = 0;
        }
      }
      int v38 = v56;
LABEL_39:
      int v56 = v38 + canPunishSomeMoving;
      ++v24;
      uint64_t v23 = v37;
      CFIndex v55 = (float *)v28;
    }
LABEL_40:
    uint64_t v22 = v26;
    uint64_t v21 = *((void *)this + 20);
    uint64_t v39 = *((void *)this + 21);
    BOOL v40 = 0xCCCCCCCCCCCCCCCDLL * ((v39 - v21) >> 5) > v26++;
  }
  while (v40);
  BOOL v41 = 0;
  if (v23)
  {
    int v42 = v24;
    if (v53 == v23) {
      BOOL v41 = !v55 || (float)(fabsf(*(float *)(v23 + 92)) - *(float *)(v23 + 56)) > fabsf(v55[23]);
    }
  }
  else
  {
    int v42 = v24;
  }
  uint64_t result = MTChordIntegrating::hasChordStabilized(this, a2, v27);
  if (!result || v42 < 1) {
    goto LABEL_83;
  }
  uint64_t result = *((void *)this + 34);
  if (!v23 || result) {
    goto LABEL_66;
  }
  if (v57 == (unsigned __int16 **)v23) {
    goto LABEL_62;
  }
  if (!v57) {
    goto LABEL_76;
  }
  if (*v57 == v57[1] || **v57 - 35 > 4)
  {
LABEL_66:
    if (v42 >= 2 && v56 >= 1 && v57)
    {
      if (v25 <= 0.2 && *((double *)a2 + 1) - *((double *)this + 31) <= *(double *)&qword_268C8EC40) {
        goto LABEL_83;
      }
      uint64_t v43 = *(void *)(a5 + 392);
      uint64_t result = (uint64_t)v57;
LABEL_70:
      uint64_t result = MTSlideGesture::fireGesture(result, a2, a3, v43, v52, this, v20);
      goto LABEL_83;
    }
    if (result && *(void *)result != *(void *)(result + 8) && **(unsigned __int16 **)result - 35 <= 4)
    {
      uint64_t v43 = *(void *)(a5 + 392);
      if (v53) {
        uint64_t result = v53;
      }
      goto LABEL_70;
    }
LABEL_76:
    if (v39 != v21)
    {
      uint64_t v44 = 0;
      unsigned int v45 = 1;
      do
      {
        uint64_t v46 = v21 + 160 * v44;
        int v47 = *(_DWORD *)(v46 + 28);
        if (!v47 || (*(_DWORD *)(a5 + 24) & v47) != 0)
        {
          uint64_t result = MTSlideGesture::isBlocked((unsigned __int16 **)v46, (uint64_t)a2, (uint64_t)a3, (uint64_t)this, *(unsigned char *)(a5 + 400));
          if ((result & 1) == 0) {
            uint64_t result = MTSlideGesture::fireGesture(v46, a2, a3, *(void *)(a5 + 392), v52, this, v20);
          }
        }
        uint64_t v44 = v45;
        uint64_t v21 = *((void *)this + 20);
        BOOL v40 = 0xCCCCCCCCCCCCCCCDLL * ((*((void *)this + 21) - v21) >> 5) > v45++;
      }
      while (v40);
    }
    goto LABEL_83;
  }
LABEL_62:
  if (v41)
  {
    uint64_t v43 = *(void *)(a5 + 392);
    uint64_t result = v23;
    goto LABEL_70;
  }
LABEL_83:
  double v48 = *((double *)a2 + 1);
  uint64_t v49 = *((void *)this + 34);
  if (v49)
  {
    double v50 = *(double *)(v49 + 144);
    if (v48 - v50 < v48 - *(double *)(a5 + 1232))
    {
      *(double *)(a5 + 1232) = v50;
      uint64_t v51 = *(_WORD **)v49;
      if (*(void *)v49 != *(void *)(v49 + 8))
      {
        if ((*v51 & 0xFFFE) == 0x46) {
          *(double *)(a5 + 1240) = v50;
        }
        if ((unsigned __int16)*v51 - 35 <= 4) {
          *(double *)(a5 + 1248) = v50;
        }
      }
    }
  }
  else if (v48 < v48 - *(double *)(a5 + 1232))
  {
    *(void *)(a5 + 1232) = 0;
  }
  return result;
}

void MTSimpleEventDispatcher::MTSimpleEventDispatcher(MTSimpleEventDispatcher *this)
{
  *(void *)this = &unk_26F4D9FB0;
  atomic_store(1u, (unsigned int *)this + 2);
}

{
  *(void *)this = &unk_26F4D9FB0;
  atomic_store(1u, (unsigned int *)this + 2);
}

void MTSimpleEventDispatcher::createDispatcher()
{
}

void MTSimpleEventDispatcher::initialize(uint64_t a1, MTSimpleHIDManager *this, const void *a3)
{
  *(void *)(a1 + 16) = this;
  MTSimpleHIDManager::retain((uint64_t)this);
  *(void *)(a1 + 48) = CFRetain(a3);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 424) = MTPreferencesGetAppBooleanValue(@"DispatchAllHIDEvents", @"com.apple.MultitouchSupport", 0);
  *(unsigned char *)(a1 + 64) = 0;
  io_registry_entry_t Service = MTDeviceGetService();
  CFBooleanRef CFProperty = (const __CFBoolean *)IORegistryEntryCreateCFProperty(Service, @"MTHIDDevice", (CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  if (CFProperty)
  {
    CFBooleanRef v7 = CFProperty;
    CFTypeID v8 = CFGetTypeID(CFProperty);
    if (v8 == CFBooleanGetTypeID()) {
      *(unsigned char *)(a1 + 64) = CFBooleanGetValue(v7) != 0;
    }
    CFRelease(v7);
  }
  *(void *)(a1 + 72) = 0;
}

uint64_t MTSimpleEventDispatcher::getMTDevice(MTSimpleEventDispatcher *this)
{
  return *((void *)this + 6);
}

uint64_t MTSimpleEventDispatcher::getOwner(MTSimpleEventDispatcher *this)
{
  return *((void *)this + 2);
}

void MTSimpleEventDispatcher::~MTSimpleEventDispatcher(MTSimpleEventDispatcher *this)
{
}

unsigned int *MTSimpleEventDispatcher::finalize(MTSimpleEventDispatcher *this)
{
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  uint64_t v2 = *((void *)this + 9);
  if (v2)
  {
    dispatch_release(v2);
    *((void *)this + 9) = 0;
  }
  double v3 = (const void *)*((void *)this + 6);
  if (v3)
  {
    CFRelease(v3);
    *((void *)this + 6) = 0;
  }
  uint64_t result = MTSimpleHIDManager::release(*((unsigned int **)this + 2));
  *((void *)this + 2) = 0;
  return result;
}

uint64_t MTSimpleEventDispatcher::retain(uint64_t this)
{
  if (!atomic_load((unsigned int *)(this + 8))) {
    MTSimpleEventDispatcher::retain();
  }
  atomic_fetch_add((atomic_uint *volatile)(this + 8), 1u);
  return this;
}

unsigned int *MTSimpleEventDispatcher::release(unsigned int *this)
{
  if (!atomic_load(this + 2)) {
    MTSimpleEventDispatcher::release();
  }
  if (atomic_fetch_add((atomic_uint *volatile)this + 2, 0xFFFFFFFF) == 1)
  {
    uint64_t v2 = (uint64_t)this;
    (*(void (**)(unsigned int *))(*(void *)this + 24))(this);
    double v3 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 8);
    return (unsigned int *)v3(v2);
  }
  return this;
}

uint64_t MTSimpleEventDispatcher::setDispatchAllHIDEvents(uint64_t this, char a2)
{
  *(unsigned char *)(this + 424) = a2;
  return this;
}

uint64_t MTSimpleEventDispatcher::shouldDispatchAllHIDEvents(MTSimpleEventDispatcher *this)
{
  return *((unsigned __int8 *)this + 424);
}

void MTSimpleEventDispatcher::setHIDDispatchQueue(MTSimpleEventDispatcher *this, dispatch_object_t object)
{
  if (object) {
    dispatch_retain(object);
  }
  double v4 = *((void *)this + 9);
  if (v4) {
    dispatch_release(v4);
  }
  *((void *)this + 9) = object;
}

uint64_t MTSimpleEventDispatcher::getHIDDispatchQueue(MTSimpleEventDispatcher *this)
{
  return *((void *)this + 9);
}

void *MTSimpleEventDispatcher::setEventCallback(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  result[3] = a2;
  result[4] = a3;
  result[5] = a4;
  return result;
}

uint64_t MTSimpleEventDispatcher::shouldDispatchEvent()
{
  return 1;
}

__CFDictionary *MTSimpleEventDispatcher::copyDebugData(MTSimpleEventDispatcher *this)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 43, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (Mutable)
  {
    CFDateFormatterRef v4 = CFDateFormatterCreate(v2, 0, kCFDateFormatterShortStyle, kCFDateFormatterFullStyle);
    if (v4)
    {
      unsigned int v5 = v4;
      CFTimeZoneRef v6 = CFTimeZoneCopySystem();
      if (v6)
      {
        CFTimeZoneRef v7 = v6;
        CFDateFormatterSetProperty(v5, (CFStringRef)*MEMORY[0x263EFFC10], v6);
        CFRelease(v7);
      }
      uint64_t v8 = 0;
      int v9 = (char *)this + 80;
      do
      {
        double v10 = *(double *)&v9[8 * v8];
        if (v10 > 0.0)
        {
          CFStringRef StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(v2, v5, v10);
          if (StringWithAbsoluteTime)
          {
            CFStringRef v12 = StringWithAbsoluteTime;
            Name = (const void *)IOHIDEventTypeGetName();
            CFDictionarySetValue(Mutable, Name, v12);
            CFRelease(v12);
          }
        }
        ++v8;
      }
      while (v8 != 43);
      CFRelease(v5);
    }
  }
  return Mutable;
}

uint64_t MTSimpleEmbeddedEventDispatcher::markEventDispatchAllMode(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return IOHIDEventSetIntegerValue();
  }
  return result;
}

void MTSimpleEmbeddedEventDispatcher::createDispatcher()
{
}

uint64_t MTSimpleEmbeddedEventDispatcher::shouldDispatchEvent(unsigned char *a1, uint64_t a2)
{
  if ((IOHIDEventGetIntegerValue() & 0xF0FB17FFLL) != 0
    || (IOHIDEventGetIntegerValue() & 1) != 0
    || (IOHIDEventGetIntegerValue() & 2) != 0
    || IOHIDEventConformsTo()
    || IOHIDEventConformsTo())
  {
    return 1;
  }
  uint64_t v4 = 1;
  if (!IOHIDEventConformsTo())
  {
    if (a1[424]) {
      (*(void (**)(unsigned char *, uint64_t))(*(void *)a1 + 112))(a1, a2);
    }
    else {
      return 0;
    }
  }
  return v4;
}

void MTSimpleEmbeddedStylusEventDispatcher::createDispatcher()
{
}

uint64_t MTSimpleEmbeddedStylusEventDispatcher::shouldDispatchEvent()
{
  return 1;
}

void MTSimpleEmbeddedEventDispatcher::~MTSimpleEmbeddedEventDispatcher(MTSimpleEmbeddedEventDispatcher *this)
{
}

void MTSimpleEmbeddedStylusEventDispatcher::~MTSimpleEmbeddedStylusEventDispatcher(MTSimpleEmbeddedStylusEventDispatcher *this)
{
}

uint64_t MTPreferencesGetAppIntegerValue(const __CFString *a1, const __CFString *a2, unsigned __int8 *a3)
{
  uint64_t valuePtr = 0;
  if (a3) {
    *a3 = 0;
  }
  uint64_t v4 = 0;
  if (a1 && a2)
  {
    CFStringRef v5 = (const __CFString *)IOHIDPreferencesCopyDomain();
    if (v5)
    {
      CFStringRef v6 = v5;
      CFTypeID v7 = CFGetTypeID(v5);
      if (v7 == CFStringGetTypeID())
      {
        Intunsigned __int8 Value = CFStringGetIntValue(v6);
        uint64_t valuePtr = IntValue;
        unsigned __int8 Value = IntValue != 0;
        if (!a3) {
          goto LABEL_14;
        }
      }
      else if (v7 == CFNumberGetTypeID() && !CFNumberIsFloatType((CFNumberRef)v6))
      {
        unsigned __int8 Value = CFNumberGetValue((CFNumberRef)v6, kCFNumberCFIndexType, &valuePtr);
        if (!a3) {
          goto LABEL_14;
        }
      }
      else
      {
        unsigned __int8 Value = 0;
        if (!a3)
        {
LABEL_14:
          CFRelease(v6);
          return valuePtr;
        }
      }
      *a3 = Value;
      goto LABEL_14;
    }
    return 0;
  }
  return v4;
}

BOOL MTPreferencesGetAppBooleanValue(const __CFString *a1, const __CFString *a2, unsigned __int8 *a3)
{
  if (a3) {
    *a3 = 0;
  }
  BOOL v4 = 0;
  if (a1 && a2)
  {
    CFStringRef v5 = (const __CFString *)IOHIDPreferencesCopyDomain();
    if (v5)
    {
      CFStringRef v6 = v5;
      CFTypeID v7 = CFGetTypeID(v5);
      if (v7 == CFStringGetTypeID())
      {
        BOOL v4 = 1;
        if (CFStringCompare(v6, @"true", 1uLL) == kCFCompareEqualTo) {
          goto LABEL_19;
        }
        Boolean Value = 1;
        if (CFStringCompare(v6, @"YES", 1uLL) == kCFCompareEqualTo)
        {
          BOOL v4 = 1;
          if (!a3) {
            goto LABEL_23;
          }
          goto LABEL_22;
        }
        if (CFStringCompare(v6, @"false", 1uLL) == kCFCompareEqualTo
          || CFStringCompare(v6, @"NO", 1uLL) == kCFCompareEqualTo)
        {
          BOOL v4 = 0;
          goto LABEL_19;
        }
      }
      else if (v7 == CFNumberGetTypeID())
      {
        if (!CFNumberIsFloatType((CFNumberRef)v6))
        {
          int valuePtr = -1431655766;
          Boolean Value = CFNumberGetValue((CFNumberRef)v6, kCFNumberIntType, &valuePtr);
          BOOL v4 = valuePtr != 0;
          if (!a3) {
            goto LABEL_23;
          }
          goto LABEL_22;
        }
      }
      else if (v7 == CFBooleanGetTypeID())
      {
        BOOL v4 = v6 == (const __CFString *)*MEMORY[0x263EFFB40];
LABEL_19:
        Boolean Value = 1;
        if (!a3) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }
      BOOL v4 = 0;
      Boolean Value = 0;
      if (!a3)
      {
LABEL_23:
        CFRelease(v6);
        return v4;
      }
LABEL_22:
      *a3 = Value;
      goto LABEL_23;
    }
    return 0;
  }
  return v4;
}

void MTTrackpadEventDispatcher::createDispatcher()
{
}

void sub_240722680(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10A1C4052F3E7C6);
  _Unwind_Resume(a1);
}

void MTTrackpadEventDispatcher::initialize(uint64_t a1, MTSimpleHIDManager *a2, const void *a3)
{
  *(_DWORD *)(a1 + 428) = 0;
  *(unsigned char *)(a1 + 432) = 0;
  *(_DWORD *)(a1 + 436) = 0;
  *(unsigned char *)(a1 + 440) = 0;
  *(unsigned char *)(a1 + 512) = 0;
  *(_DWORD *)(a1 + 516) = 0;
  *(void *)(a1 + 520) = 0;
  *(unsigned char *)(a1 + 532) = 0;
  *(_DWORD *)(a1 + 536) = 1114636288;
  *(void *)(a1 + 448) = 0;
  *(unsigned char *)(a1 + 540) = 1;
  *(unsigned char *)(a1 + 54MTHandMotion::clearHandMotion(this, 1) = MTPreferencesGetAppBooleanValue(@"NoPointing", @"com.apple.MultitouchSupport", 0);
  *(_DWORD *)(a1 + 456) = 6;
  *(_DWORD *)(a1 + 528) = 0;

  MTSimpleEventDispatcher::initialize(a1, a2, a3);
}

uint64_t MTTrackpadEventDispatcher::handleEvent(dispatch_object_t *a1, uint64_t a2, uint64_t a3)
{
  a1[7] = (dispatch_object_t)a2;
  if (IOHIDEventGetType() != 11 || IOHIDEventGetIntegerValue() != 1)
  {
LABEL_44:
    uint64_t result = ((uint64_t (*)(dispatch_object_t *, uint64_t))(*a1)[4].isa)(a1, a2);
    if (result) {
      uint64_t result = ((uint64_t (*)(dispatch_object_t *, uint64_t, uint64_t))(*a1)[5].isa)(a1, a2, a3);
    }
    goto LABEL_46;
  }
  uint64_t Event = IOHIDEventGetEvent();
  uint64_t v7 = IOHIDEventGetEvent();
  uint64_t v46 = IOHIDEventGetEvent();
  uint64_t v45 = IOHIDEventGetEvent();
  uint64_t v44 = IOHIDEventGetEvent();
  uint64_t v43 = IOHIDEventGetEvent();
  uint64_t v42 = IOHIDEventGetEvent();
  uint64_t v41 = IOHIDEventGetEvent();
  uint64_t v40 = IOHIDEventGetEvent();
  uint64_t v39 = IOHIDEventGetEvent();
  int v8 = IOHIDEventConformsTo();
  int v37 = IOHIDEventConformsTo();
  int v38 = v8;
  int v36 = IOHIDEventConformsTo();
  ((void (*)(dispatch_object_t *))(*a1)[14].isa)(a1);
  char v9 = MTTrackpadEventDispatcher::checkForMomentumCancellation(a1);
  if (v8 | v37) {
    char v10 = v9;
  }
  else {
    char v10 = 1;
  }
  float v47 = NAN;
  if (Event)
  {
    IOHIDEventGetFloatValue();
    double v12 = v11;
    IOHIDEventGetFloatValue();
    double v14 = v13;
    IntegerBoolean Value = IOHIDEventGetIntegerValue();
    if ((MTTrackpadEventDispatcher::checkForMomentumInitiation((uint64_t)a1, a2, &v47) & 1) == 0
      && !*((unsigned char *)a1 + 541))
    {
      float v16 = v12;
      float v17 = v14;
      uint64_t v18 = (int)v16;
      uint64_t v19 = (int)v17;
      uint64_t v20 = mach_absolute_time();
      ((void (*)(dispatch_object_t *, uint64_t, uint64_t, uint64_t, uint64_t, void))(*a1)[19].isa)(a1, v18, v19, IntegerValue, v20, 0);
    }
  }
  if (v7)
  {
    IOHIDEventGetFloatValue();
    float v22 = v21;
    IOHIDEventGetFloatValue();
    float v24 = v23;
    IOHIDEventGetFloatValue();
    float v26 = v25;
    unsigned int v27 = MTTrackpadEventDispatcher::checkForMomentumInitiation((uint64_t)a1, a2, &v47);
    ((void (*)(dispatch_object_t *, void, void, void, void, void, void, float))(*a1)[18].isa)(a1, (int)v22, (int)v24, (int)v26, 0, 0, 0, v47);
    if (v27)
    {
      if ((*((_DWORD *)a1 + 132) - 1) <= 2) {
        ((void (*)(dispatch_object_t *, void, void, void, uint64_t, void, void, float))(*a1)[18].isa)(a1, 0, 0, 0, 1, 0, 0, 60.0);
      }
      goto LABEL_15;
    }
    if (!*((unsigned char *)a1 + 540)) {
LABEL_15:
    }
      IOHIDEventRemoveEvent();
  }
  if ((v10 & 1) == 0)
  {
    CFArrayRef Children = (const __CFArray *)IOHIDEventGetChildren();
    if (Children)
    {
      CFArrayRef v29 = Children;
      CFIndex Count = CFArrayGetCount(Children);
      if (Count >= 1)
      {
        CFIndex v31 = Count;
        CFIndex v32 = 0;
        while (1)
        {
          CFArrayGetValueAtIndex(v29, v32);
          if (IOHIDEventGetType() == 2) {
            break;
          }
          if (IOHIDEventGetType() == 3)
          {
            IOHIDEventGetIntegerValue();
            IOHIDEventGetIntegerValue();
            MTSimpleEventDispatcher::getMTDevice((MTSimpleEventDispatcher *)a1);
            MTDeviceDispatchKeyboardEvent();
            goto LABEL_24;
          }
LABEL_25:
          if (v31 == ++v32) {
            goto LABEL_26;
          }
        }
        uint64_t v33 = IOHIDEventGetIntegerValue();
        uint64_t v34 = mach_absolute_time();
        ((void (*)(dispatch_object_t *, void, void, uint64_t, uint64_t, void))(*a1)[19].isa)(a1, 0, 0, v33, v34, 0);
LABEL_24:
        usleep(0x1770u);
        goto LABEL_25;
      }
    }
  }
LABEL_26:
  if (v7) {
    goto LABEL_44;
  }
  if (Event) {
    goto LABEL_44;
  }
  if (*((unsigned char *)a1 + 424)) {
    goto LABEL_44;
  }
  if (v46) {
    goto LABEL_44;
  }
  if (v45) {
    goto LABEL_44;
  }
  if (v44) {
    goto LABEL_44;
  }
  if (v43) {
    goto LABEL_44;
  }
  if (v42) {
    goto LABEL_44;
  }
  if (v41) {
    goto LABEL_44;
  }
  if (v40) {
    goto LABEL_44;
  }
  if (v39) {
    goto LABEL_44;
  }
  if (v38) {
    goto LABEL_44;
  }
  if (v37) {
    goto LABEL_44;
  }
  if (v36) {
    goto LABEL_44;
  }
  if (IOHIDEventGetIntegerValue()) {
    goto LABEL_44;
  }
  if (IOHIDEventGetIntegerValue()) {
    goto LABEL_44;
  }
  if ((IOHIDEventGetIntegerValue() & 2) != 0) {
    goto LABEL_44;
  }
  uint64_t result = IOHIDEventConformsTo();
  if (result) {
    goto LABEL_44;
  }
LABEL_46:
  a1[7] = 0;
  return result;
}

uint64_t MTTrackpadEventDispatcher::checkForMomentumCancellation(dispatch_object_t *a1)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  MomentumEnableuint64_t Event = getMomentumEnableEvent();
  if (!a1[56]) {
    return 0;
  }
  if (MomentumEnableEvent)
  {
    *(void *)buf = 0;
    IOHIDEventGetVendorDefinedData();
  }
  if (!IOHIDEventConformsTo()
    && !IOHIDEventConformsTo()
    && !IOHIDEventConformsTo())
  {
    return 0;
  }
  if (!IOHIDEventConformsTo())
  {
    uint64_t v18 = 1;
    MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer((MTTrackpadEventDispatcher *)a1, 1);
    return v18;
  }
  context = (int *)dispatch_get_context(a1[56]);
  if (!context) {
    return 0;
  }
  uint64_t v4 = (uint64_t)context;
  uint64_t v5 = context[8];
  if (IOHIDEventGetIntegerValue() != v5 || *(_DWORD *)v4 == 1) {
    return 0;
  }
  unint64_t v6 = *(void *)(v4 + 72);
  uint64_t v7 = *(void *)(v4 + 48);
  float v8 = 0.0;
  float v9 = 0.0;
  if (v6 < (*(void *)(v4 + 56) - v7) >> 2) {
    float v9 = (float)*(int *)(v7 + 4 * v6);
  }
  unint64_t v10 = *(void *)(v4 + 112);
  uint64_t v11 = *(void *)(v4 + 88);
  if (v10 < (*(void *)(v4 + 96) - v11) >> 2) {
    float v8 = (float)*(int *)(v11 + 4 * v10);
  }
  float v12 = hypotf(v9, v8);
  float v13 = v9 + (double)IOHIDEventGetIntegerValue() * 0.25;
  float v14 = v8 + (double)IOHIDEventGetIntegerValue() * 0.25;
  float v15 = hypotf(v13, v14);
  if (v12 > 0.0 && v15 > v12)
  {
    float v16 = v12 / v15;
    float v13 = v16 * v13;
    float v14 = v16 * v14;
  }
  *(float *)(v4 + 24) = v13;
  *(float *)(v4 + 28) = v14;
  MTTrackpadEventDispatcher::generateMomentumDeltas((uint64_t)a1, v4);
  float v17 = MTLoggingPlugin();
  uint64_t v18 = 0;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136316162;
    *(void *)&uint8_t buf[4] = "";
    __int16 v21 = 2080;
    float v22 = "";
    __int16 v23 = 2080;
    float v24 = "checkForMomentumCancellation";
    __int16 v25 = 2048;
    double v26 = v13;
    __int16 v27 = 2048;
    double v28 = v14;
    _os_log_impl(&dword_2406FB000, v17, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Adjusted point/drag momentum %4.1fx %4.1fy\n", buf, 0x34u);
    return 0;
  }
  return v18;
}

const void *MTTrackpadEventDispatcher::checkForMomentumInitiation(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result = getMomentumEnableEvent();
  *a3 = 1114636288;
  if (result)
  {
    IOHIDEventGetVendorDefinedData();
    return 0;
  }
  return result;
}

BOOL MTTrackpadEventDispatcher::isStdScrollInProgress(MTTrackpadEventDispatcher *this, int a2)
{
  return (a2 - 1) < 3;
}

uint64_t MTTrackpadEventDispatcher::handleParserDisabled(uint64_t this)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(this + 516) == 1)
  {
    uint64_t v1 = this;
    CFAllocatorRef v2 = MTLoggingPlugin();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      int v4 = 136315650;
      uint64_t v5 = "[Debug] ";
      __int16 v6 = 2080;
      uint64_t v7 = "";
      __int16 v8 = 2080;
      float v9 = "handleParserDisabled";
      _os_log_impl(&dword_2406FB000, v2, OS_LOG_TYPE_DEBUG, "[HID] [MT] %s%s%s Trackpad has been disabled with button down. Dispatching button up event", (uint8_t *)&v4, 0x20u);
    }
    uint64_t v3 = mach_absolute_time();
    return (*(uint64_t (**)(uint64_t, void, void, void, uint64_t, void))(*(void *)v1 + 152))(v1, 0, 0, 0, v3, 0);
  }
  return this;
}

_DWORD *MTTrackpadEventDispatcher::updateFingerStats(MTTrackpadEventDispatcher *this)
{
  uint64_t result = (_DWORD *)MTSimpleEventDispatcher::getOwner(this);
  if (result)
  {
    uint64_t result = (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(void *)result + 864))(result);
    if (result)
    {
      uint64_t v3 = result;
      uint64_t v4 = *((void *)result + 6);
      if (v4) {
        LODWORD(v4) = *(double *)(v4 + 8) - *((double *)result + 19) == 0.0;
      }
      if ((int)result[26] > 1) {
        uint64_t v5 = 1;
      }
      else {
        uint64_t v5 = v4;
      }
      if (!*((_DWORD *)this + 129))
      {
        NonRestingFingerCFIndex Count = MTParser::getNonRestingFingerCount((MTParser *)result, (result[9] >> 1) & 1);
        int v7 = (*(uint64_t (**)(MTTrackpadEventDispatcher *))(*(void *)this + 168))(this);
        uint64_t v8 = v3[6];
        if (v8) {
          int v9 = *(_DWORD *)(v8 + 308);
        }
        else {
          int v9 = 0;
        }
        int v10 = *((_DWORD *)this + 109);
        uint64_t v11 = v3[8];
        if (v11)
        {
          uint64_t v12 = v3[25];
          if (v12)
          {
            int v13 = *(_DWORD *)(v12 + 256);
            if (v13 >= 1)
            {
              memcpy(__dst, &unk_24074F870, 0x128uLL);
              uint64_t v14 = *(void *)(v11 + 280);
              __dst[0] = &unk_26F4D93E8;
              uint64_t v15 = v14 + 600 * v13;
              memcpy(&__dst[1], (const void *)(v15 + 8), 0x11CuLL);
              __dst[37] = &unk_26F4DB4E0;
              long long v17 = *(_OWORD *)(v15 + 320);
              long long v16 = *(_OWORD *)(v15 + 336);
              long long v32 = *(_OWORD *)(v15 + 304);
              long long v33 = v17;
              long long v34 = v16;
              long long v18 = *(_OWORD *)(v15 + 400);
              long long v19 = *(_OWORD *)(v15 + 352);
              long long v20 = *(_OWORD *)(v15 + 368);
              long long v37 = *(_OWORD *)(v15 + 384);
              long long v38 = v18;
              long long v36 = v20;
              long long v35 = v19;
              long long v21 = *(_OWORD *)(v15 + 448);
              long long v23 = *(_OWORD *)(v15 + 416);
              long long v22 = *(_OWORD *)(v15 + 432);
              long long v42 = *(_OWORD *)(v15 + 464);
              long long v41 = v21;
              long long v39 = v23;
              long long v40 = v22;
              long long v24 = *(_OWORD *)(v15 + 512);
              long long v26 = *(_OWORD *)(v15 + 480);
              long long v25 = *(_OWORD *)(v15 + 496);
              long long v46 = *(_OWORD *)(v15 + 528);
              long long v45 = v24;
              long long v43 = v26;
              long long v44 = v25;
              long long v28 = *(_OWORD *)(v15 + 560);
              long long v27 = *(_OWORD *)(v15 + 576);
              long long v29 = *(_OWORD *)(v15 + 544);
              uint64_t v50 = *(void *)(v15 + 592);
              long long v49 = v27;
              long long v47 = v29;
              long long v48 = v28;
              int v9 = __dst[35];
              MTParserPath::~MTParserPath((MTParserPath *)__dst);
            }
          }
        }
        int v30 = (*(uint64_t (**)(MTTrackpadEventDispatcher *))(*(void *)this + 176))(this);
        (*(void (**)(MTTrackpadEventDispatcher *, uint64_t))(*(void *)this + 120))(this, NonRestingFingerCount);
        (*(void (**)(MTTrackpadEventDispatcher *, BOOL))(*(void *)this + 128))(this, (v9 & v10) != 0);
        if (v7 != (*(unsigned int (**)(MTTrackpadEventDispatcher *))(*(void *)this + 168))(this)) {
          return (_DWORD *)(*(uint64_t (**)(MTTrackpadEventDispatcher *, uint64_t))(*(void *)this + 136))(this, v5);
        }
        uint64_t result = (_DWORD *)(*(uint64_t (**)(MTTrackpadEventDispatcher *))(*(void *)this + 176))(this);
        if ((v30 ^ result | v5) == 1) {
          return (_DWORD *)(*(uint64_t (**)(MTTrackpadEventDispatcher *, uint64_t))(*(void *)this + 136))(this, v5);
        }
      }
    }
  }
  return result;
}

uint64_t MTTrackpadEventDispatcher::updateClickState(uint64_t this, char a2)
{
  CFAllocatorRef v2 = (_DWORD *)this;
  if (*(unsigned char *)(this + 432))
  {
    *(unsigned char *)(this + 512) = 0;
    if (a2) {
      return this;
    }
    uint64_t v3 = (unsigned char *)(this + 512);
    this = (*(uint64_t (**)(uint64_t))(*(void *)this + 168))(this);
    if (this == 2) {
      unsigned char *v3 = 1;
    }
  }
  else
  {
    if (!*(_DWORD *)(this + 436)) {
      return this;
    }
    *(unsigned char *)(this + 512) = 0;
    if (a2) {
      return this;
    }
    uint64_t v3 = (unsigned char *)(this + 512);
  }
  if (v2[109])
  {
    this = (*(uint64_t (**)(_DWORD *))(*(void *)v2 + 176))(v2);
    if (this) {
      unsigned char *v3 = 1;
    }
  }
  return this;
}

uint64_t MTTrackpadEventDispatcher::getHIDPhaseFromScrollPhase(MTTrackpadEventDispatcher *this, unsigned int a2)
{
  if (a2 > 9) {
    return 0;
  }
  else {
    return gScrollPhaseToHIDPhase[a2];
  }
}

uint64_t MTTrackpadEventDispatcher::getNextScrollPhase(MTTrackpadEventDispatcher *this, unsigned int a2, int a3)
{
  if (a2 > 9) {
    return 0;
  }
  else {
    return gNextScrollPhaseForPhase[2 * a2 + a3];
  }
}

void MTTrackpadEventDispatcher::setScrollMomentumDispatchRate(MTTrackpadEventDispatcher *this, float a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  int v4 = 1114636288;
  if (a2 >= 60.0 && (int v4 = 1140457472, a2 <= 500.0)) {
    *((float *)this + 134) = a2;
  }
  else {
    *((_DWORD *)this + 134) = v4;
  }
  uint64_t v5 = MTLoggingPlugin();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    double v6 = *((float *)this + 134);
    int v7 = 136316162;
    uint64_t v8 = "";
    __int16 v9 = 2080;
    int v10 = "";
    __int16 v11 = 2080;
    uint64_t v12 = "setScrollMomentumDispatchRate";
    __int16 v13 = 2048;
    double v14 = a2;
    __int16 v15 = 2048;
    double v16 = v6;
    _os_log_impl(&dword_2406FB000, v5, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Requested value %f -> set value %f", (uint8_t *)&v7, 0x34u);
  }
}

float *MTTrackpadEventDispatcher::dispatchMomentumScrollStartStopEvent(float *this, char a2, uint64_t a3)
{
  if ((a2 & 1) == 0) {
    return (float *)(*(uint64_t (**)(float *, void, void, void, void, uint64_t, uint64_t, float))(*(void *)this + 144))(this, 0, 0, 0, 0, 1, a3, this[134]);
  }
  return this;
}

void MTTrackpadEventDispatcher::dispatchPointingEvent(MTTrackpadEventDispatcher *this, int a2, int a3, int a4, unint64_t a5, int a6)
{
  int v7 = a3 | a2;
  if (a6)
  {
    if (!v7 && *((_DWORD *)this + 131) == a4) {
      return;
    }
    *((_DWORD *)this + 13MTHandMotion::clearHandMotion(this, 1) = a4;
    int v8 = a4;
    a4 = *((_DWORD *)this + 130);
  }
  else
  {
    if (!v7 && *((_DWORD *)this + 130) == a4) {
      return;
    }
    *((_DWORD *)this + 130) = a4;
    int v8 = *((_DWORD *)this + 131);
  }
  int v9 = v8 | a4;
  if ((v9 & 1) == 0 || *((unsigned char *)this + 512) == 0) {
    unsigned int v11 = v9;
  }
  else {
    unsigned int v11 = v9 & 0xFFFFFFFC | 2;
  }
  RelativePointeruint64_t Event = IOHIDEventCreateRelativePointerEvent();
  if (RelativePointerEvent)
  {
    __int16 v13 = (const void *)RelativePointerEvent;
    (*(void (**)(MTTrackpadEventDispatcher *, uint64_t, void))(*(void *)this + 40))(this, RelativePointerEvent, 0);
    CFRelease(v13);
  }
  *((_DWORD *)this + 129) = v11;
}

void MTTrackpadEventDispatcher::dispatchScrollEvent(MTTrackpadEventDispatcher *this, int a2, int a3, int a4, int a5, int a6, float a7, int a8)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  float valuePtr = a7;
  if (!*((unsigned char *)this + 540)) {
    return;
  }
  if (!a6)
  {
    uint64_t v13 = *((unsigned int *)this + 132);
    if (v13 >= 0xA)
    {
      unsigned int v14 = 0;
      *((_DWORD *)this + 132) = 0;
    }
    else
    {
      unsigned int v14 = gNextScrollPhaseForPhase[2 * v13 + ((a3 | a2 | a4) != 0)];
      *((_DWORD *)this + 132) = v14;
      if (v14 > 9) {
        return;
      }
    }
    int v15 = gScrollPhaseToHIDPhase[v14];
LABEL_12:
    if (!v15) {
      return;
    }
    goto LABEL_23;
  }
  if (!*((unsigned char *)this + 532)) {
    return;
  }
  uint64_t v11 = *((unsigned int *)this + 114);
  if (v11 >= 0xA)
  {
    unsigned int v12 = 0;
    *((_DWORD *)this + 114) = 0;
  }
  else
  {
    unsigned int v12 = gNextScrollPhaseForPhase[2 * v11 + ((a3 | a2 | a4) != 0)];
    *((_DWORD *)this + 114) = v12;
    if (v12 > 9) {
      return;
    }
  }
  int v15 = gScrollPhaseToHIDPhase[v12];
  BOOL v16 = v12 == 9 || v12 == 4;
  if (!v16 || !a8) {
    goto LABEL_12;
  }
  uint64_t v17 = MTLoggingPlugin();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315650;
    long long v25 = "";
    __int16 v26 = 2080;
    long long v27 = "";
    __int16 v28 = 2080;
    long long v29 = "dispatchScrollEvent";
    _os_log_impl(&dword_2406FB000, v17, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Momentum interrupted", buf, 0x20u);
  }
LABEL_23:
  CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  mach_absolute_time();
  uint64_t ScrollEvent = IOHIDEventCreateScrollEvent();
  if (ScrollEvent)
  {
    long long v20 = (const void *)ScrollEvent;
    if (a6)
    {
      IOHIDEventSetScrollMomentum();
      CFNumberRef v21 = CFNumberCreate(v18, kCFNumberFloatType, &valuePtr);
      if (v21)
      {
        CFNumberRef v22 = v21;
        _IOHIDEventSetAttachment();
        CFRelease(v22);
      }
    }
    else
    {
      IOHIDEventSetPhase();
      if (*((unsigned char *)this + 532) && a5 && *((_DWORD *)this + 132) == 4) {
        IOHIDEventSetScrollMomentum();
      }
    }
    (*(void (**)(MTTrackpadEventDispatcher *, const void *, void))(*(void *)this + 40))(this, v20, 0);
    CFRelease(v20);
  }
}

void MTTrackpadEventDispatcher::recordHIDEvent(uint64_t **a1, uint64_t a2, int a3)
{
  if (a2 && a3 <= 5)
  {
    CFArrayRef Children = (const __CFArray *)IOHIDEventGetChildren();
    if (Children)
    {
      CFArrayRef v6 = Children;
      if (CFArrayGetCount(Children) >= 1)
      {
        CFIndex v7 = 0;
        uint64_t v8 = (a3 + 1);
        do
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v6, v7);
          ((void (*)(uint64_t **, const void *, uint64_t))(*a1)[7])(a1, ValueAtIndex, v8);
          ++v7;
        }
        while (v7 < CFArrayGetCount(v6));
      }
    }
    int Type = IOHIDEventGetType();
    unsigned int v27 = Type;
    int Phase = IOHIDEventGetPhase();
    if Type <= 0x2A && (!Phase || (Phase) && Type <= 0x1C)
    {
      if (((1 << Type) & 0x4003F2) != 0)
      {
        unsigned int v12 = a1 + 58;
        __int16 v28 = &v27;
        uint64_t v13 = std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v12, &v27, (uint64_t)&std::piecewise_construct, &v28);
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        int v15 = (CFAbsoluteTime *)operator new(0x18uLL);
        v15[2] = Current;
        BOOL v16 = v13[5];
        v13 += 5;
        *(void *)int v15 = v16;
        *((void *)v15 + MTHandMotion::clearHandMotion(this, 1) = v13;
        v16[1] = (uint64_t)v15;
        *uint64_t v13 = (uint64_t *)v15;
        v13[2] = (uint64_t *)((char *)v13[2] + 1);
        __int16 v28 = &v27;
        if ((unint64_t)std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v12, &v27, (uint64_t)&std::piecewise_construct, &v28)[7] >= 0x65)
        {
          do
          {
            __int16 v28 = &v27;
            uint64_t v17 = std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v12, &v27, (uint64_t)&std::piecewise_construct, &v28);
            CFAllocatorRef v18 = v17[6];
            uint64_t v19 = *v18;
            *(void *)(v19 + 8) = v18[1];
            *(void *)v18[1] = v19;
            v17[7] = (uint64_t *)((char *)v17[7] - 1);
            operator delete(v18);
            __int16 v28 = &v27;
          }
          while ((unint64_t)std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v12, &v27, (uint64_t)&std::piecewise_construct, &v28)[7] > 0x64);
        }
      }
      else if (((1 << Type) & 0x18810000) != 0)
      {
        IntegerBoolean Value = 0;
        CFAbsoluteTime v21 = CFAbsoluteTimeGetCurrent();
        if (Type > 26 || Type == 16 || Type == 23) {
          IntegerBoolean Value = IOHIDEventGetIntegerValue();
        }
        CFNumberRef v22 = operator new(0x20uLL);
        v22[4] = Type;
        *((_WORD *)v22 + 10) = IntegerValue;
        *((_WORD *)v22 + 1MTHandMotion::clearHandMotion(this, 1) = 0;
        *((CFAbsoluteTime *)v22 + 3) = v21;
        long long v23 = a1[61];
        *(void *)CFNumberRef v22 = v23;
        *((void *)v22 + MTHandMotion::clearHandMotion(this, 1) = a1 + 61;
        v23[1] = (uint64_t)v22;
        a1[61] = (uint64_t *)v22;
        unint64_t v24 = (unint64_t)a1[63] + 1;
        a1[63] = (uint64_t *)v24;
        if (v24 >= 0x3E9)
        {
          do
          {
            long long v25 = a1[62];
            uint64_t v26 = *v25;
            *(void *)(v26 + 8) = v25[1];
            *(void *)v25[1] = v26;
            a1[63] = (uint64_t *)(v24 - 1);
            operator delete(v25);
            unint64_t v24 = (unint64_t)a1[63];
          }
          while (v24 > 0x3E8);
        }
      }
    }
  }
}

uint64_t MTTrackpadEventDispatcher::shouldRecordAsGesture(MTTrackpadEventDispatcher *this, unsigned int a2)
{
  return (a2 < 0x1D) & (0x18810000u >> a2);
}

uint64_t MTTrackpadEventDispatcher::shouldRecord(MTTrackpadEventDispatcher *this, unsigned int a2)
{
  return (a2 < 0x17) & (0x4003F2u >> a2);
}

__CFDictionary *MTTrackpadEventDispatcher::copyDebugData(MTTrackpadEventDispatcher *this)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 43, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (theDict)
  {
    CFDateFormatterRef v3 = CFDateFormatterCreate(v2, 0, kCFDateFormatterShortStyle, kCFDateFormatterFullStyle);
    if (v3)
    {
      int v4 = v3;
      CFTimeZoneRef v5 = CFTimeZoneCopySystem();
      if (v5)
      {
        CFTimeZoneRef v6 = v5;
        CFDateFormatterSetProperty(v4, (CFStringRef)*MEMORY[0x263EFFC10], v5);
        CFRelease(v6);
      }
      CFIndex v7 = (char *)*((void *)this + 58);
      uint64_t v30 = this;
      uint64_t v8 = (char *)this + 472;
      if (v7 != (char *)this + 472)
      {
        int v9 = (const CFArrayCallBacks *)MEMORY[0x263EFFF70];
        do
        {
          *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v10 + MTHandMotion::clearHandMotion(this, 1) = 0xAAAAAAAAAAAAAAAALL;
          v33[0] = v10;
          v33[1] = v10;
          LODWORD(v33[0]) = *((_DWORD *)v7 + 8);
          std::list<double>::list((void *)v33 + 1, (uint64_t)(v7 + 40));
          memset(v32, 170, sizeof(v32));
          std::list<double>::list(v32, (uint64_t)v33 + 8);
          CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v2, 100, v9);
          if (Mutable) {
            BOOL v12 = v32[2] == 0;
          }
          else {
            BOOL v12 = 1;
          }
          if (!v12)
          {
            uint64_t v13 = v8;
            for (uint64_t i = v32[1]; (void *)i != v32; uint64_t i = *(void *)(i + 8))
            {
              CFStringRef StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(v2, v4, *(CFAbsoluteTime *)(i + 16));
              if (StringWithAbsoluteTime)
              {
                CFArrayAppendValue(Mutable, StringWithAbsoluteTime);
                CFRelease(StringWithAbsoluteTime);
              }
            }
            Name = (const void *)IOHIDEventTypeGetName();
            uint64_t v8 = v13;
            int v9 = (const CFArrayCallBacks *)MEMORY[0x263EFFF70];
            CFDictionarySetValue(theDict, Name, Mutable);
            CFRelease(Mutable);
          }
          std::__list_imp<double>::clear(v32);
          std::__list_imp<double>::clear((void *)v33 + 1);
          uint64_t v17 = (char *)*((void *)v7 + 1);
          if (v17)
          {
            do
            {
              CFAllocatorRef v18 = v17;
              uint64_t v17 = *(char **)v17;
            }
            while (v17);
          }
          else
          {
            do
            {
              CFAllocatorRef v18 = (char *)*((void *)v7 + 2);
              BOOL v12 = *(void *)v18 == (void)v7;
              CFIndex v7 = v18;
            }
            while (!v12);
          }
          CFIndex v7 = v18;
        }
        while (v18 != v8);
      }
      CFMutableArrayRef v19 = CFArrayCreateMutable(v2, 1000, MEMORY[0x263EFFF70]);
      if (v19)
      {
        long long v20 = v19;
        CFAbsoluteTime v21 = (char *)this + 488;
        uint64_t v22 = *((void *)v30 + 62);
        if ((MTTrackpadEventDispatcher *)v22 != (MTTrackpadEventDispatcher *)((char *)v30 + 488))
        {
          do
          {
            uint64_t v23 = *(unsigned __int16 *)(v22 + 20);
            CFStringRef v24 = CFDateFormatterCreateStringWithAbsoluteTime(v2, v4, *(CFAbsoluteTime *)(v22 + 24));
            if (v24)
            {
              CFStringRef v25 = v24;
              uint64_t v26 = IOHIDEventTypeGetName();
              CFStringRef v27 = CFStringCreateWithFormat(v2, 0, @"%@ (%u) @ %@", v26, v23, v25);
              if (v27)
              {
                CFStringRef v28 = v27;
                CFArrayAppendValue(v20, v27);
                CFRelease(v28);
              }
              CFRelease(v25);
            }
            uint64_t v22 = *(void *)(v22 + 8);
          }
          while ((char *)v22 != v21);
        }
        CFDictionarySetValue(theDict, @"Gesture events", v20);
        CFRelease(v20);
      }
      CFRelease(v4);
    }
  }
  return theDict;
}

void sub_2407240F4(_Unwind_Exception *a1)
{
  std::__list_imp<double>::clear(v1);
  _Unwind_Resume(a1);
}

float MTTrackpadEventDispatcher::momentumDecayRateAlpha(int a1, float a2, float a3, float a4)
{
  if (a1 == 2)
  {
    if (a4 <= 0.0)
    {
      double v16 = a4 / 0.00800000038;
      double v15 = 0.85;
      return pow(v15, v16);
    }
    float v12 = hypotf(a2, a3) / a4;
    double v9 = 1.0;
    if (v12 > 0.0)
    {
      double v9 = 0.0;
      if (v12 < 500.0) {
        double v9 = (float)((float)(500.0 - v12) / 500.0);
      }
    }
    double v10 = 0.95;
    double v11 = -0.1;
  }
  else if (a1 == 4)
  {
    if (a4 <= 0.0)
    {
      double v16 = a4 / 0.00800000038;
      double v15 = 0.9;
      return pow(v15, v16);
    }
    float v5 = hypotf(a2, a3) / a4;
    float v6 = 0.0;
    if (v5 > 2000.0)
    {
      float v6 = 1.0;
      if (v5 < 3000.0) {
        float v6 = (float)(v5 + -2000.0) / 1000.0;
      }
    }
    float v7 = 1.0;
    if (v5 > 0.0)
    {
      float v7 = 0.0;
      if (v5 < 250.0) {
        float v7 = (float)(250.0 - v5) / 250.0;
      }
    }
    if (v6 >= v7) {
      float v8 = v6;
    }
    else {
      float v8 = v7;
    }
    double v9 = v8;
    double v10 = 0.98;
    double v11 = -0.08;
  }
  else
  {
    if (a4 <= 0.0)
    {
      double v16 = a4 / 0.00800000038;
      double v15 = 0.975;
      return pow(v15, v16);
    }
    float v13 = hypotf(a2, a3) / a4;
    double v9 = 1.0;
    if (v13 > 0.0)
    {
      double v9 = 0.0;
      if (v13 < 250.0) {
        double v9 = (float)((float)(250.0 - v13) / 250.0);
      }
    }
    double v10 = 0.975;
    double v11 = -0.065;
  }
  float v14 = v10 + v9 * v11;
  double v15 = v14;
  double v16 = a4 / 0.00800000038;
  return pow(v15, v16);
}

uint64_t MTTrackpadEventDispatcher::startMomentumTimerForEvent()
{
  uint64_t Event = IOHIDEventGetEvent();
  uint64_t result = IOHIDEventGetEvent();
  if (Event | result) {
    operator new();
  }
  return result;
}

void MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(MTTrackpadEventDispatcher *this, uint64_t a2)
{
  CFAllocatorRef v2 = *((void *)this + 56);
  if (v2)
  {
    context = dispatch_get_context(*((dispatch_object_t *)this + 56));
    if (context)
    {
      float v6 = context;
      uint64_t Owner = MTSimpleEventDispatcher::getOwner(this);
      if (Owner)
      {
        uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)Owner + 864))(Owner);
        if (v8) {
          MTParser::feedbackMomentumTimerStatus(v8, *(_DWORD *)v6, 0);
        }
      }
      if (*(_DWORD *)v6 == 1) {
        (*(void (**)(MTTrackpadEventDispatcher *, void, void, void, void, uint64_t, uint64_t, float))(*(void *)this + 144))(this, 0, 0, 0, 0, 1, a2, *((float *)this + 134));
      }
      double v9 = (unsigned int *)*((void *)v6 + 5);
      double v10 = (void *)*((void *)v6 + 21);
      if (v10)
      {
        *((void *)v6 + 22) = v10;
        operator delete(v10);
      }
      double v11 = (void *)*((void *)v6 + 16);
      if (v11)
      {
        *((void *)v6 + 17) = v11;
        operator delete(v11);
      }
      float v12 = (void *)*((void *)v6 + 11);
      if (v12)
      {
        *((void *)v6 + 12) = v12;
        operator delete(v12);
      }
      float v13 = (void *)*((void *)v6 + 6);
      if (v13)
      {
        *((void *)v6 + 7) = v13;
        operator delete(v13);
      }
      MEMORY[0x2455F6CE0](v6, 0x1030C40A19E2114);
      CFAllocatorRef v2 = *((void *)this + 56);
    }
    else
    {
      double v9 = 0;
    }
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 56));
    *((void *)this + 56) = 0;
    if (v9)
    {
      MTSimpleEventDispatcher::release(v9);
    }
  }
}

void MTTrackpadEventDispatcher::generateMomentumDeltas(uint64_t a1, uint64_t a2)
{
  int v3 = a1;
  MTTrackpadEventDispatcher::generateFrameIntervalMomentumDeltas(a1, (unsigned int *)a2);
  if (*(unsigned char *)(a2 + 208))
  {
    std::__wrap_iter<int *>::iterator_type v4 = MTTrackpadEventDispatcher::smoothTails(v3, (std::vector<int> *)(a2 + 48), (std::vector<int> *)(a2 + 88), *(_DWORD *)(a2 + 236));
    MTTrackpadEventDispatcher::interpolateFrameIntervalMomentumDeltas((uint64_t)v4, (float *)(a2 + 48), a2 + 128);
    MTTrackpadEventDispatcher::interpolateFrameIntervalMomentumDeltas(v5, (float *)(a2 + 88), a2 + 168);
    int v6 = *(_DWORD *)(a2 + 236);
    if (v6) {
      unsigned int v7 = (float)(roundf((float)(*(float *)(a2 + 80) / *(float *)(a2 + 160)) * (float)(v6 + 1))
    }
                               + -1.0);
    else {
      unsigned int v7 = 0;
    }
    std::__wrap_iter<int *>::iterator_type v8 = MTTrackpadEventDispatcher::smoothTails(v3, (std::vector<int> *)(a2 + 128), (std::vector<int> *)(a2 + 168), v7);
    MTTrackpadEventDispatcher::smoothBody((uint64_t)v8, (int **)(a2 + 128));
    MTTrackpadEventDispatcher::smoothBody(v9, (int **)(a2 + 168));
  }
}

void ___ZN25MTTrackpadEventDispatcher26startMomentumTimerForEventEP12__IOHIDEvent17MTMomentumSubTypeRf_block_invoke(uint64_t a1, dispatch_source_s *a2)
{
}

void MTTrackpadEventDispatcher::momentumCallbackFunction(NSObject *this, dispatch_source_s *a2)
{
  context = (unsigned int *)dispatch_get_context(this);
  if (context)
  {
    std::__wrap_iter<int *>::iterator_type v4 = context;
    if (*((unsigned char *)context + 208))
    {
      unint64_t v5 = *((void *)context + 19);
      unint64_t v6 = v5 + 1;
      uint64_t v7 = *((void *)context + 16);
      uint64_t v8 = *((void *)context + 17) - v7;
      if (v5 >= v8 >> 2) {
        uint64_t v9 = 0;
      }
      else {
        uint64_t v9 = *(unsigned int *)(v7 + 4 * v5);
      }
      float v13 = *((float *)context + 40);
      unint64_t v14 = v8 >> 2;
      if (v6 <= v5) {
        unint64_t v15 = *((void *)context + 19);
      }
      else {
        unint64_t v15 = v5 + 1;
      }
      *((void *)context + 19) = v15;
      unint64_t v16 = *((void *)context + 24);
      uint64_t v17 = *((void *)context + 21);
      unint64_t v18 = (*((void *)context + 22) - v17) >> 2;
      if (v16 >= v18) {
        uint64_t v19 = 0;
      }
      else {
        uint64_t v19 = *(unsigned int *)(v17 + 4 * v16);
      }
      if (v16 + 1 >= v16) {
        ++v16;
      }
      *((void *)context + 24) = v16;
      BOOL v20 = v15 >= v14 && v16 >= v18;
      BOOL v21 = v20;
      if (!v20 && *((unsigned char *)context + 210))
      {
        if ((float)(v13 * (float)(v5 + 2)) >= *((float *)context + 56))
        {
          float v22 = (float)v6;
          *((_WORD *)context + 104) = 256;
          uint64_t v23 = *((void *)context + 27);
          *((void *)context + 9) = v23;
          *((void *)context + 14) = v23;
          float v24 = *((float *)context + 20);
          float v25 = (float)(v24 * (float)(unint64_t)(v23 + 1)) - (float)(v13 * v22);
          *((float *)context + 57) = v25 / v24;
          *((float *)context + 58) = v25;
          dispatch_time_t v26 = dispatch_walltime(0, (uint64_t)(float)(v25 * 1000000000.0));
          dispatch_source_set_timer(this, v26, (unint64_t)(float)(*((float *)v4 + 20) * 1000000000.0), 0);
        }
        BOOL v21 = 0;
      }
    }
    else
    {
      unint64_t v10 = *((void *)context + 9);
      uint64_t v11 = *((void *)context + 6);
      uint64_t v12 = *((void *)context + 7) - v11;
      if (v10 >= v12 >> 2) {
        uint64_t v9 = 0;
      }
      else {
        uint64_t v9 = *(unsigned int *)(v11 + 4 * v10);
      }
      unint64_t v27 = v12 >> 2;
      if (v10 + 1 >= v10) {
        ++v10;
      }
      *((void *)context + 9) = v10;
      unint64_t v28 = *((void *)context + 14);
      uint64_t v29 = *((void *)context + 11);
      unint64_t v30 = (*((void *)context + 12) - v29) >> 2;
      if (v28 >= v30) {
        uint64_t v19 = 0;
      }
      else {
        uint64_t v19 = *(unsigned int *)(v29 + 4 * v28);
      }
      if (v28 + 1 >= v28) {
        ++v28;
      }
      *((void *)context + 14) = v28;
      BOOL v21 = v10 >= v27 && v28 >= v30;
      if (*((unsigned char *)context + 209))
      {
        float v32 = *((float *)context + 57);
        float v13 = *((float *)context + 58);
        LODWORD(v9) = llroundf(v32 * (float)(int)v9);
        LODWORD(v19) = llroundf(v32 * (float)(int)v19);
        *((unsigned char *)context + 209) = 0;
      }
      else
      {
        float v13 = *((float *)context + 20);
      }
    }
    if (v9 | v19) {
      int v33 = 1;
    }
    else {
      int v33 = v21;
    }
    if (*v4 == 1)
    {
      if (v33) {
        (*(void (**)(void, uint64_t, uint64_t, void, void, uint64_t, void, float))(**((void **)v4 + 5)
      }
                                                                                                 + 144))(*((void *)v4 + 5), v9, v19, 0, 0, 1, 0, 1.0 / v13);
    }
    else if (v33)
    {
      uint64_t v34 = *((void *)v4 + 5);
      uint64_t v35 = v4[8];
      uint64_t v36 = mach_absolute_time();
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v34 + 152))(v34, v9, v19, v35, v36, 0);
    }
    if (v21)
    {
      long long v37 = (MTTrackpadEventDispatcher *)*((void *)v4 + 5);
      MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(v37, 0);
    }
  }
}

void MTTrackpadEventDispatcher::wasUnscheduledFromDispatchQueue(MTTrackpadEventDispatcher *this, dispatch_queue_s *a2)
{
}

uint64_t MTTrackpadEventDispatcher::generateFrameIntervalMomentumDeltas(uint64_t a1, unsigned int *a2)
{
  int v3 = (void **)(a2 + 12);
  *((void *)a2 + 7) = *((void *)a2 + 6);
  *((void *)a2 + 9) = 0;
  std::__wrap_iter<int *>::iterator_type v4 = (void **)(a2 + 22);
  *((void *)a2 + 12) = *((void *)a2 + 11);
  *((void *)a2 + 14) = 0;
  float v5 = *((float *)a2 + 20);
  float v6 = *((float *)a2 + 6);
  float v7 = *((float *)a2 + 7);
  double v8 = *((double *)a2 + 1);
  uint64_t v61 = (uint64_t)(a2 + 16);
  uint64_t v9 = (uint64_t)(a2 + 26);
  LODWORD(result) = *a2;
  float v11 = 0.0;
  float v12 = 0.0;
  do
  {
    float v13 = MTTrackpadEventDispatcher::momentumDecayRateAlpha(result, v6, v7, v5);
    float v6 = v6 * v13;
    float v7 = v7 * v13;
    float v14 = *((float *)a2 + 4);
    float v15 = v6 * v14;
    float v16 = v7 * v14;
    if (*((unsigned char *)a2 + 208) && !*((unsigned char *)a2 + 210))
    {
      float v17 = fabsf(v16 / v5);
      if (fabsf(v15 / v5) <= 320.0 && v17 <= 320.0)
      {
        uint64_t v58 = *((void *)a2 + 6);
        uint64_t v57 = *((void *)a2 + 7);
        *((unsigned char *)a2 + 210) = 1;
        uint64_t v60 = v57 - v58;
        BOOL v59 = v60 == 0;
        v60 >>= 2;
        *((void *)a2 + 27) = v60;
        *((float *)a2 + 56) = *((float *)a2 + 20) * (float)(unint64_t)(v60 + 1);
        if (v59) {
          *((unsigned char *)a2 + 208) = 0;
        }
      }
    }
    unsigned int v19 = llroundf(v15);
    unsigned int v20 = llroundf(v16);
    float v21 = fabsf(v15);
    float v22 = fabsf(v16);
    float v23 = v12 + v15;
    float v24 = v11 + v16;
    int v25 = (int)v23;
    int v26 = (int)v24;
    BOOL v27 = v21 < 1.0 && v22 < 1.0;
    float v28 = v23 - (float)(int)v23;
    float v29 = v24 - (float)(int)v24;
    if (v27) {
      unsigned int v30 = v25;
    }
    else {
      unsigned int v30 = v19;
    }
    if (v27) {
      unsigned int v31 = v26;
    }
    else {
      unsigned int v31 = v20;
    }
    if (v27) {
      float v12 = v28;
    }
    if (v27) {
      float v11 = v29;
    }
    if (v8 <= 0.0)
    {
      BOOL v33 = 1;
    }
    else
    {
      float v32 = *((float *)a2 + 5);
      BOOL v33 = v21 < v32 && v22 < v32;
    }
    uint64_t v35 = (char *)*((void *)a2 + 7);
    unint64_t v34 = *((void *)a2 + 8);
    if ((unint64_t)v35 >= v34)
    {
      long long v37 = (char *)*v3;
      uint64_t v38 = (v35 - (unsigned char *)*v3) >> 2;
      unint64_t v39 = v38 + 1;
      if ((unint64_t)(v38 + 1) >> 62) {
        std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v40 = v34 - (void)v37;
      if (v40 >> 1 > v39) {
        unint64_t v39 = v40 >> 1;
      }
      if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v41 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v41 = v39;
      }
      if (v41)
      {
        long long v42 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v61, v41);
        long long v37 = (char *)*((void *)a2 + 6);
        uint64_t v35 = (char *)*((void *)a2 + 7);
      }
      else
      {
        long long v42 = 0;
      }
      long long v43 = (unsigned int *)&v42[4 * v38];
      *long long v43 = v30;
      uint64_t v36 = v43 + 1;
      while (v35 != v37)
      {
        unsigned int v44 = *((_DWORD *)v35 - 1);
        v35 -= 4;
        *--long long v43 = v44;
      }
      *((void *)a2 + 6) = v43;
      *((void *)a2 + 7) = v36;
      *((void *)a2 + 8) = &v42[4 * v41];
      if (v37) {
        operator delete(v37);
      }
    }
    else
    {
      *(_DWORD *)uint64_t v35 = v30;
      uint64_t v36 = v35 + 4;
    }
    *((void *)a2 + 7) = v36;
    long long v46 = (char *)*((void *)a2 + 12);
    unint64_t v45 = *((void *)a2 + 13);
    if ((unint64_t)v46 >= v45)
    {
      long long v48 = (char *)*v4;
      uint64_t v49 = (v46 - (unsigned char *)*v4) >> 2;
      unint64_t v50 = v49 + 1;
      if ((unint64_t)(v49 + 1) >> 62) {
        std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v51 = v45 - (void)v48;
      if (v51 >> 1 > v50) {
        unint64_t v50 = v51 >> 1;
      }
      if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v52 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v52 = v50;
      }
      if (v52)
      {
        uint64_t v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v9, v52);
        long long v48 = (char *)*((void *)a2 + 11);
        long long v46 = (char *)*((void *)a2 + 12);
      }
      else
      {
        uint64_t v53 = 0;
      }
      CFIndex v54 = (unsigned int *)&v53[4 * v49];
      *CFIndex v54 = v31;
      long long v47 = v54 + 1;
      while (v46 != v48)
      {
        unsigned int v55 = *((_DWORD *)v46 - 1);
        v46 -= 4;
        *--CFIndex v54 = v55;
      }
      *((void *)a2 + 1MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v54;
      *((void *)a2 + 12) = v47;
      *((void *)a2 + 13) = &v53[4 * v52];
      if (v48) {
        operator delete(v48);
      }
    }
    else
    {
      *(_DWORD *)long long v46 = v31;
      long long v47 = v46 + 4;
    }
    *((void *)a2 + 12) = v47;
    uint64_t result = *a2;
    double v56 = 0.0;
    if (result == 1) {
      double v56 = v5;
    }
    double v8 = v8 - v56;
  }
  while (!v33);
  return result;
}

void MTTrackpadEventDispatcher::smoothBody(uint64_t a1, int **a2)
{
  if (a2)
  {
    int v3 = *a2;
    std::__wrap_iter<int *>::iterator_type v4 = a2[1];
    if (v4 != *a2)
    {
      if (*v3)
      {
        float v5 = wmemchr(*a2, 0, v4 - *a2);
        if (v5) {
          float v6 = v5;
        }
        else {
          float v6 = v4;
        }
        if (**a2 < 1)
        {
          std::__sort<std::__less<int,int> &,int *>();
        }
        else
        {
          unint64_t v7 = 126 - 2 * __clz(v6 - v3);
          if (v6 == v3) {
            uint64_t v8 = 0;
          }
          else {
            uint64_t v8 = v7;
          }
          std::__introsort<std::_ClassicAlgPolicy,std::greater<int> &,int *,false>(v3, v6, (uint64_t)&v9, v8, 1);
        }
      }
    }
  }
}

std::__wrap_iter<int *>::iterator_type MTTrackpadEventDispatcher::smoothTails(int a1, std::vector<int> *a2, std::vector<int> *a3, unsigned int a4)
{
  int v7 = MTTrackpadEventDispatcher::forceCurveTailToMonotonicallyDecrease(a1, a2, a4);
  int v8 = MTTrackpadEventDispatcher::forceCurveTailToMonotonicallyDecrease(v7, a3, a4);

  return MTTrackpadEventDispatcher::equalizeCurveLengths(v8, a2, a3);
}

std::__wrap_iter<int *>::iterator_type MTTrackpadEventDispatcher::forceCurveTailToMonotonicallyDecrease(int a1, std::vector<int> *this, unsigned int a3)
{
  if (this)
  {
    std::vector<int>::pointer begin = this->__begin_;
    end = this->__end_;
    if (end == this->__begin_)
    {
      unsigned int v8 = 0;
      int v10 = -1;
      std::vector<int>::pointer begin = this->__end_;
    }
    else
    {
      unint64_t v7 = 0;
      unsigned int v8 = 0;
      unsigned int v9 = 0;
      int v10 = -1;
      do
      {
        v11.__i_ = &begin[v7];
        if (*v11.__i_)
        {
          if (v8 <= v9) {
            unsigned int v8 = v9;
          }
          std::vector<int>::size_type v12 = v8 - v9;
          std::vector<int>::value_type __x = 0;
          std::__wrap_iter<int *>::iterator_type result = std::vector<int>::insert(this, v11, v12, &__x).__i_;
          unsigned int v9 = 0;
          v7 += v12;
          std::vector<int>::pointer begin = this->__begin_;
          end = this->__end_;
          int v10 = v7;
        }
        else
        {
          ++v9;
        }
        ++v7;
      }
      while (v7 < end - begin);
    }
    uint64_t v14 = v10;
    float v15 = &begin[v10 + 1];
    if (v15 != end) {
      this->__end_ = v15;
    }
    if (v10 != -1 && v8 < a3)
    {
      v16.__i_ = &this->__begin_[v10 + 1];
      std::vector<int>::value_type v20 = 0;
      std::vector<int>::insert(this, v16, a3, &v20);
      v17.__i_ = &this->__begin_[v14 + 1 + a3];
      if (*this->__begin_ < 1) {
        std::vector<int>::value_type v18 = -1;
      }
      else {
        std::vector<int>::value_type v18 = 1;
      }
      std::vector<int>::value_type v19 = v18;
      return std::vector<int>::insert(this, v17, &v19).__i_;
    }
  }
  return result;
}

std::__wrap_iter<int *>::iterator_type MTTrackpadEventDispatcher::equalizeCurveLengths(int a1, std::vector<int> *this, std::vector<int> *a3)
{
  if (this && a3)
  {
    end = this->__end_;
    uint64_t v5 = (char *)end - (char *)this->__begin_;
    if (v5 >> 2 <= (unint64_t)(a3->__end_ - a3->__begin_)) {
      uint64_t v6 = a3->__end_ - a3->__begin_;
    }
    else {
      uint64_t v6 = v5 >> 2;
    }
    std::vector<int>::value_type __x = 0;
    v8.__i_ = end;
    std::vector<int>::insert(this, v8, v6 - (v5 >> 2), &__x);
    v9.__i_ = a3->__end_;
    std::vector<int>::size_type v10 = v6 - (v9.__i_ - a3->__begin_);
    std::vector<int>::value_type v12 = 0;
    return std::vector<int>::insert(a3, v9, v10, &v12).__i_;
  }
  return result;
}

std::vector<int>::iterator std::vector<int>::insert(std::vector<int> *this, std::vector<int>::const_iterator __position, std::vector<int>::size_type __n, std::vector<int>::const_reference __x)
{
  uint64_t i = (int *)__position.__i_;
  if (__n)
  {
    uint64_t v5 = (int *)__x;
    value = this->__end_cap_.__value_;
    p_end_cap = &this->__end_cap_;
    std::vector<int>::const_iterator v9 = value;
    std::vector<int>::const_iterator v11 = p_end_cap[-1].__value_;
    if (__n <= value - v11)
    {
      uint64_t v18 = (char *)v11 - (char *)__position.__i_;
      if (__n <= v11 - __position.__i_)
      {
        float v21 = p_end_cap[-1].__value_;
        std::vector<int>::size_type v20 = __n;
      }
      else
      {
        unint64_t v19 = 0;
        std::vector<int>::size_type v20 = v18 >> 2;
        float v21 = (int *)&v11[__n - (v18 >> 2)];
        do
        {
          v11[v19 / 4] = *__x;
          v19 += 4;
        }
        while (4 * __n - 4 * v20 != v19);
        this->__end_ = v21;
        if (v11 == __position.__i_) {
          return (std::vector<int>::iterator)i;
        }
      }
      float v22 = &__position.__i_[__n];
      float v23 = &v21[-__n];
      float v24 = v21;
      if (v23 < v11)
      {
        float v24 = v21;
        do
        {
          int v25 = *v23++;
          *v24++ = v25;
        }
        while (v23 < v11);
      }
      this->__end_ = v24;
      if (v21 != v22) {
        memmove(&v21[-(v21 - v22)], __position.__i_, (char *)v21 - (char *)v22);
      }
      if (i <= v5)
      {
        if (this->__end_ <= v5) {
          std::vector<int>::size_type v26 = 0;
        }
        else {
          std::vector<int>::size_type v26 = __n;
        }
        v5 += v26;
      }
      BOOL v27 = i;
      do
      {
        *v27++ = *v5;
        --v20;
      }
      while (v20);
    }
    else
    {
      std::vector<int>::pointer begin = this->__begin_;
      memset(&__p, 0, 32);
      unint64_t v13 = __n + v11 - begin;
      if (v13 >> 62) {
        std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v14 = __position.__i_ - begin;
      uint64_t v15 = (char *)v9 - (char *)begin;
      if (v15 >> 1 > v13) {
        unint64_t v13 = v15 >> 1;
      }
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v16 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v13;
      }
      __p.__end_cap_.__value_ = (std::allocator<int> *)p_end_cap;
      if (v16) {
        std::vector<int>::const_iterator v17 = (int *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, v16);
      }
      else {
        std::vector<int>::const_iterator v17 = 0;
      }
      float v28 = &v17[v14];
      __p.__first_ = v17;
      __p.__begin_ = v28;
      __p.__end_cap_.__value_ = &v17[v16];
      std::vector<int>::size_type v29 = 4 * __n;
      unsigned int v30 = &v28[__n];
      do
      {
        *v28++ = *v5;
        v29 -= 4;
      }
      while (v29);
      __p.__end_ = v30;
      uint64_t i = std::vector<int>::__swap_out_circular_buffer(this, &__p, i);
      if (__p.__end_ != __p.__begin_) {
        __p.__end_ = (std::__split_buffer<int>::pointer)((char *)__p.__end_
      }
                                                       + (((char *)__p.__begin_ - (char *)__p.__end_ + 3) & 0xFFFFFFFFFFFFFFFCLL));
      if (__p.__first_) {
        operator delete(__p.__first_);
      }
    }
  }
  return (std::vector<int>::iterator)i;
}

void sub_2407255B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

std::vector<int>::iterator std::vector<int>::insert(std::vector<int> *this, std::vector<int>::const_iterator __position, std::vector<int>::value_type *__x)
{
  uint64_t i = (int *)__position.__i_;
  end = this->__end_;
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  std::vector<int>::const_iterator v8 = value;
  if (end >= value)
  {
    std::vector<int>::pointer begin = this->__begin_;
    memset(&__p, 0, 32);
    unint64_t v15 = end - begin + 1;
    if (v15 >> 62) {
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v16 = __position.__i_ - begin;
    uint64_t v17 = (char *)v8 - (char *)begin;
    if (v17 >> 1 > v15) {
      unint64_t v15 = v17 >> 1;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v15;
    }
    __p.__end_cap_.__value_ = (std::allocator<int> *)p_end_cap;
    if (v18) {
      unint64_t v19 = (int *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, v18);
    }
    else {
      unint64_t v19 = 0;
    }
    __p.__first_ = v19;
    __p.__begin_ = &v19[v16];
    __p.__end_ = __p.__begin_;
    __p.__end_cap_.__value_ = &v19[v18];
    std::__split_buffer<int>::push_back(&__p, __x);
    uint64_t i = std::vector<int>::__swap_out_circular_buffer(this, &__p, i);
    if (__p.__end_ != __p.__begin_) {
      __p.__end_ = (std::__split_buffer<int>::pointer)((char *)__p.__end_
    }
                                                     + (((char *)__p.__begin_ - (char *)__p.__end_ + 3) & 0xFFFFFFFFFFFFFFFCLL));
    if (__p.__first_) {
      operator delete(__p.__first_);
    }
  }
  else if (__position.__i_ == end)
  {
    *__position.__i_ = *__x;
    this->__end_ = (std::vector<int>::pointer)(__position.__i_ + 1);
  }
  else
  {
    std::__wrap_iter<const int *>::iterator_type v10 = __position.__i_ + 1;
    std::vector<int>::const_iterator v11 = end - 1;
    std::vector<int>::value_type v12 = (int *)end;
    while (v11 < end)
    {
      int v13 = *v11++;
      *v12++ = v13;
    }
    this->__end_ = v12;
    if (end != v10) {
      memmove((void *)&end[-(end - v10)], __position.__i_, (char *)end - (char *)v10);
    }
    *uint64_t i = *__x;
  }
  return (std::vector<int>::iterator)i;
}

void sub_24072575C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MTTrackpadEventDispatcher::interpolateFrameIntervalMomentumDeltas(uint64_t a1, float *a2, uint64_t a3)
{
  int v3 = *(unsigned int **)a3;
  *(void *)(a3 + 8) = *(void *)a3;
  *(void *)(a3 + 24) = 0;
  float v4 = a2[8];
  float v5 = *(float *)(a3 + 32);
  unint64_t v6 = (uint64_t)(*((void *)a2 + 1) - *(void *)a2) >> 2;
  unsigned int v7 = (float)((float)(v4 * (float)v6) / v5);
  if (v7)
  {
    int v10 = 0;
    float v11 = v5 / v4;
    std::vector<int>::value_type v12 = (void *)(a3 + 16);
    float v13 = 0.0;
    do
    {
      float v32 = NAN;
      float v14 = modff((float)((float)v10 / (float)((float)v7 + -1.0)) * (float)(v6 - 1), &v32);
      unint64_t v15 = v32;
      uint64_t v16 = *(void *)a2;
      unint64_t v17 = (uint64_t)(*((void *)a2 + 1) - *(void *)a2) >> 2;
      if (v17 <= v15) {
LABEL_26:
      }
        std::vector<MTActionEvent>::__throw_out_of_range[abi:ne180100]();
      unint64_t v18 = (v15 + 1);
      int v19 = *(_DWORD *)(v16 + 4 * v15);
      if (v6 <= v18)
      {
        int v20 = 0;
      }
      else
      {
        if (v17 <= v18) {
          goto LABEL_26;
        }
        int v20 = *(_DWORD *)(v16 + 4 * v18);
      }
      float v21 = v13 + (float)(v11 * (float)((float)(v14 * (float)v20) + (float)((float)v19 * (float)(1.0 - v14))));
      unsigned int v22 = llroundf(v21);
      if ((unint64_t)v3 >= *v12)
      {
        float v24 = *(unsigned int **)a3;
        uint64_t v25 = ((uint64_t)v3 - *(void *)a3) >> 2;
        unint64_t v26 = v25 + 1;
        if ((unint64_t)(v25 + 1) >> 62) {
          std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v27 = *v12 - (void)v24;
        if (v27 >> 1 > v26) {
          unint64_t v26 = v27 >> 1;
        }
        if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v28 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v28 = v26;
        }
        if (v28)
        {
          std::vector<int>::size_type v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v12, v28);
          float v24 = *(unsigned int **)a3;
          int v3 = *(unsigned int **)(a3 + 8);
        }
        else
        {
          std::vector<int>::size_type v29 = 0;
        }
        unsigned int v30 = (unsigned int *)&v29[4 * v25];
        *unsigned int v30 = v22;
        float v23 = v30 + 1;
        while (v3 != v24)
        {
          unsigned int v31 = *--v3;
          *--unsigned int v30 = v31;
        }
        *(void *)a3 = v30;
        *(void *)(a3 + 8) = v23;
        *(void *)(a3 + 16) = &v29[4 * v28];
        if (v24) {
          operator delete(v24);
        }
      }
      else
      {
        unsigned int *v3 = v22;
        float v23 = v3 + 1;
      }
      float v13 = v21 - (float)(int)roundf(v21);
      *(void *)(a3 + 8) = v23;
      ++v10;
      int v3 = v23;
    }
    while (v10 != v7);
  }
}

const void *getMomentumEnableEvent()
{
  if (!IOHIDEventConformsTo()) {
    return 0;
  }
  CFArrayRef Children = (const __CFArray *)IOHIDEventGetChildren();
  if (!Children) {
    return 0;
  }
  CFArrayRef v1 = Children;
  CFIndex Count = CFArrayGetCount(Children);
  if (Count < 1) {
    return 0;
  }
  CFIndex v3 = Count;
  CFIndex v4 = 0;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v1, v4);
    if (IOHIDEventGetType() == 1
      && IOHIDEventGetIntegerValue() == 65280
      && IOHIDEventGetIntegerValue() == 1)
    {
      break;
    }
    if (v3 == ++v4) {
      return 0;
    }
  }
  return ValueAtIndex;
}

void MTTrackpadEventDispatcher::~MTTrackpadEventDispatcher(MTTrackpadEventDispatcher *this)
{
  *(void *)this = &unk_26F4DA178;
  std::__list_imp<double>::clear((void *)this + 61);
  std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy((uint64_t)this + 464, *((void **)this + 59));

  MTSimpleEventDispatcher::~MTSimpleEventDispatcher(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26F4DA178;
  std::__list_imp<double>::clear((void *)this + 61);
  std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy((uint64_t)this + 464, *((void **)this + 59));
  MTSimpleEventDispatcher::~MTSimpleEventDispatcher(this);

  JUMPOUT(0x2455F6CE0);
}

uint64_t MTTrackpadEventDispatcher::setActivePathCount(uint64_t this, int a2)
{
  *(_DWORD *)(this + 428) = a2;
  return this;
}

uint64_t MTTrackpadEventDispatcher::setSecondaryClickRegionIsActive(uint64_t this, int a2)
{
  *(unsigned char *)(this + 440) = a2 != 0;
  return this;
}

uint64_t MTTrackpadEventDispatcher::getSecondaryClickEnabled(MTTrackpadEventDispatcher *this)
{
  return *((unsigned __int8 *)this + 432);
}

uint64_t MTTrackpadEventDispatcher::getActivePathCount(MTTrackpadEventDispatcher *this)
{
  return *((unsigned int *)this + 107);
}

uint64_t MTTrackpadEventDispatcher::secondaryClickRegionIsActive(MTTrackpadEventDispatcher *this)
{
  return *((unsigned __int8 *)this + 440);
}

void *std::__list_imp<double>::clear(void *result)
{
  if (result[2])
  {
    CFArrayRef v1 = result;
    std::__wrap_iter<int *>::iterator_type result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        CFIndex v4 = (void *)result[1];
        operator delete(result);
        std::__wrap_iter<int *>::iterator_type result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

void std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy(a1, a2[1]);
    std::__list_imp<double>::clear(a2 + 5);
    operator delete(a2);
  }
}

uint64_t **std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unsigned int v7 = a1 + 1;
  unint64_t v6 = a1[1];
  std::vector<int>::const_iterator v8 = a1 + 1;
  std::vector<int>::const_iterator v9 = a1 + 1;
  if (v6)
  {
    unsigned int v10 = *a2;
    while (1)
    {
      while (1)
      {
        std::vector<int>::const_iterator v9 = (uint64_t **)v6;
        unsigned int v11 = *((_DWORD *)v6 + 8);
        if (v10 >= v11) {
          break;
        }
        unint64_t v6 = *v9;
        std::vector<int>::const_iterator v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v11 >= v10) {
        break;
      }
      unint64_t v6 = v9[1];
      if (!v6)
      {
        std::vector<int>::const_iterator v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
    std::vector<int>::value_type v12 = operator new(0x40uLL);
    v14[1] = v7;
    v12[8] = **a4;
    *((void *)v12 + 5) = v12 + 10;
    *((void *)v12 + 6) = v12 + 10;
    *((void *)v12 + 7) = 0;
    LOBYTE(v15) = 1;
    std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::__insert_node_at(a1, (uint64_t)v9, v8, (uint64_t *)v12);
    v14[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,std::list<double>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,std::list<double>>,void *>>>>::reset[abi:ne180100]((uint64_t)v14, 0);
    return (uint64_t **)v12;
  }
  return v9;
}

uint64_t *std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  float v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  std::__wrap_iter<int *>::iterator_type result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      CFIndex v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (int v8 = *(unsigned __int8 *)(v7 + 24), v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            std::vector<int>::const_iterator v9 = (uint64_t **)a2[2];
          }
          else
          {
            std::vector<int>::const_iterator v9 = (uint64_t **)v2[1];
            unsigned int v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *std::vector<int>::const_iterator v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          uint64_t *v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (int v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          uint64_t *v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        uint64_t *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      unsigned char *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,std::list<double>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,std::list<double>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__list_imp<double>::clear(v2 + 5);
    }
    operator delete(v2);
  }
}

void *std::list<double>::list(void *a1, uint64_t a2)
{
  *a1 = a1;
  a1[1] = a1;
  a1[2] = 0;
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 != a2)
  {
    uint64_t v5 = 1;
    int v6 = a1;
    do
    {
      uint64_t v7 = operator new(0x18uLL);
      v7[2] = *(void *)(v3 + 16);
      *uint64_t v7 = v6;
      v7[1] = a1;
      v6[1] = v7;
      *a1 = v7;
      a1[2] = v5;
      uint64_t v3 = *(void *)(v3 + 8);
      ++v5;
      int v6 = v7;
    }
    while (v3 != a2);
  }
  return a1;
}

void sub_240725FF4(_Unwind_Exception *a1)
{
  std::__list_imp<double>::clear(v1);
  _Unwind_Resume(a1);
}

int *std::__introsort<std::_ClassicAlgPolicy,std::greater<int> &,int *,false>(int *result, int *a2, uint64_t a3, uint64_t a4, char a5)
{
  unsigned int v10 = result;
LABEL_2:
  uint64_t v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    unsigned int v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = a2 - v11;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          int v22 = *(a2 - 1);
          int v23 = *v11;
          if (v22 > *v11)
          {
            *uint64_t v11 = v22;
            *(a2 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v23;
          }
          break;
        case 3uLL:
          int v24 = v11[1];
          int v25 = *(a2 - 1);
          if (v24 <= v25) {
            int v26 = *(a2 - 1);
          }
          else {
            int v26 = v11[1];
          }
          if (v24 >= v25) {
            int v24 = *(a2 - 1);
          }
          *(a2 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v24;
          v11[1] = v26;
          int v27 = *(a2 - 1);
          if (v27 <= *v11) {
            int v28 = *v11;
          }
          else {
            int v28 = *(a2 - 1);
          }
          if (v27 >= *v11) {
            int v27 = *v11;
          }
          *(a2 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v27;
          int v30 = *v11;
          int v29 = v11[1];
          if (v28 <= v29) {
            int v30 = v11[1];
          }
          if (v28 < v29) {
            int v29 = v28;
          }
          *uint64_t v11 = v30;
          v11[1] = v29;
          break;
        case 4uLL:
          int v32 = v11[1];
          int v31 = v11[2];
          if (*v11 <= v31) {
            int v33 = v11[2];
          }
          else {
            int v33 = *v11;
          }
          if (*v11 < v31) {
            int v31 = *v11;
          }
          v11[2] = v31;
          *uint64_t v11 = v33;
          int v34 = *(a2 - 1);
          if (v32 <= v34) {
            int v35 = *(a2 - 1);
          }
          else {
            int v35 = v32;
          }
          if (v32 < v34) {
            int v34 = v32;
          }
          *(a2 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v34;
          int v36 = *v11;
          if (*v11 <= v35) {
            int v37 = v35;
          }
          else {
            int v37 = *v11;
          }
          if (v36 >= v35) {
            int v36 = v35;
          }
          *uint64_t v11 = v37;
          v11[1] = v36;
          int v38 = v11[2];
          int v39 = *(a2 - 1);
          if (v38 <= v39) {
            int v40 = *(a2 - 1);
          }
          else {
            int v40 = v11[2];
          }
          if (v38 >= v39) {
            int v38 = *(a2 - 1);
          }
          *(a2 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v38;
          int v41 = v11[1];
          if (v41 <= v40) {
            int v42 = v40;
          }
          else {
            int v42 = v11[1];
          }
          if (v41 >= v40) {
            int v41 = v40;
          }
          v11[1] = v42;
          v11[2] = v41;
          break;
        case 5uLL:
          int v43 = *v11;
          int v44 = v11[1];
          if (*v11 <= v44) {
            int v45 = v11[1];
          }
          else {
            int v45 = *v11;
          }
          if (v43 >= v44) {
            int v43 = v11[1];
          }
          *uint64_t v11 = v45;
          v11[1] = v43;
          int v46 = v11[3];
          int v47 = *(a2 - 1);
          if (v46 <= v47) {
            int v48 = *(a2 - 1);
          }
          else {
            int v48 = v11[3];
          }
          if (v46 >= v47) {
            int v46 = *(a2 - 1);
          }
          *(a2 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v46;
          v11[3] = v48;
          int v49 = *(a2 - 1);
          int v50 = v11[2];
          if (v49 <= v50) {
            int v51 = v11[2];
          }
          else {
            int v51 = *(a2 - 1);
          }
          if (v49 >= v50) {
            int v49 = v11[2];
          }
          *(a2 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v49;
          int v53 = v11[2];
          int v52 = v11[3];
          int v54 = v11[1];
          if (v51 <= v52) {
            int v53 = v11[3];
          }
          if (v51 < v52) {
            int v52 = v51;
          }
          v11[2] = v53;
          v11[3] = v52;
          int v55 = *(a2 - 1);
          if (v54 <= v55) {
            int v56 = *(a2 - 1);
          }
          else {
            int v56 = v54;
          }
          if (v54 < v55) {
            int v55 = v54;
          }
          *(a2 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v55;
          int v57 = *v11;
          int v59 = v11[2];
          int v58 = v11[3];
          if (v58 <= *v11) {
            int v60 = *v11;
          }
          else {
            int v60 = v11[3];
          }
          if (v58 >= v57) {
            int v58 = *v11;
          }
          if (v60 <= v59) {
            int v57 = v11[2];
          }
          if (v60 < v59) {
            int v59 = v60;
          }
          if (v58 <= v56) {
            int v61 = v56;
          }
          else {
            int v61 = v58;
          }
          if (v58 >= v56) {
            int v58 = v56;
          }
          if (v61 <= v59) {
            int v56 = v59;
          }
          *uint64_t v11 = v57;
          v11[1] = v56;
          if (v61 >= v59) {
            int v62 = v59;
          }
          else {
            int v62 = v61;
          }
          v11[2] = v62;
          v11[3] = v58;
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 95) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *,int *>(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = &v11[v15 >> 1];
    if ((unint64_t)v14 >= 0x201)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v11, &v11[v15 >> 1], a2 - 1);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v11 + 1, v17 - 1, a2 - 2);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v11 + 2, &v11[v16 + 1], a2 - 3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v17 - 1, v17, &v11[v16 + 1]);
      int v18 = *v11;
      *uint64_t v11 = *v17;
      *unint64_t v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(&v11[v15 >> 1], v11, a2 - 1);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (*(v11 - 1) <= *v11)
    {
      std::__wrap_iter<int *>::iterator_type result = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,int *,std::greater<int> &>(v11, a2);
      uint64_t v11 = result;
      goto LABEL_19;
    }
LABEL_14:
    int v19 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,int *,std::greater<int> &>(v11, a2);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v11, v19);
    uint64_t v11 = v19 + 1;
    std::__wrap_iter<int *>::iterator_type result = (int *)std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(v19 + 1, a2);
    if (result)
    {
      a4 = -v13;
      a2 = v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      std::__wrap_iter<int *>::iterator_type result = (int *)std::__introsort<std::_ClassicAlgPolicy,std::greater<int> &,int *,false>(v10, v19, a3, -v13, a5 & 1);
      uint64_t v11 = v19 + 1;
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  CFIndex v63 = v11 + 1;
  BOOL v65 = v11 == a2 || v63 == a2;
  if (a5)
  {
    if (!v65)
    {
      uint64_t v66 = 0;
      uint64_t v67 = v11;
      do
      {
        int v69 = *v67;
        int v68 = v67[1];
        uint64_t v67 = v63;
        if (v68 > v69)
        {
          uint64_t v70 = v66;
          while (1)
          {
            *(int *)((char *)v11 + v70 + 4) = v69;
            if (!v70) {
              break;
            }
            int v69 = *(int *)((char *)v11 + v70 - 4);
            v70 -= 4;
            if (v68 <= v69)
            {
              uint64_t v71 = (int *)((char *)v11 + v70 + 4);
              goto LABEL_125;
            }
          }
          uint64_t v71 = v11;
LABEL_125:
          *uint64_t v71 = v68;
        }
        CFIndex v63 = v67 + 1;
        v66 += 4;
      }
      while (v67 + 1 != a2);
    }
  }
  else if (!v65)
  {
    do
    {
      int v73 = *v10;
      int v72 = v10[1];
      unsigned int v10 = v63;
      if (v72 > v73)
      {
        do
        {
          *CFIndex v63 = v73;
          int v73 = *(v63 - 2);
          --v63;
        }
        while (v72 > v73);
        *CFIndex v63 = v72;
      }
      CFIndex v63 = v10 + 1;
    }
    while (v10 + 1 != a2);
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(int *a1, int *a2, int *a3)
{
  int v3 = *a2;
  int v4 = *a1;
  int v5 = *a3;
  if (*a2 > *a1)
  {
    if (v5 > v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 <= v4) {
      return 1;
    }
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 > v3)
  {
    *a2 = v5;
    *a3 = v3;
    int v6 = *a1;
    if (*a2 <= *a1) {
      return 1;
    }
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

int *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,int *,std::greater<int> &>(int *a1, int *a2)
{
  int v2 = *a1;
  if (*a1 <= *(a2 - 1))
  {
    int v5 = a1 + 1;
    do
    {
      int v3 = v5;
      if (v5 >= a2) {
        break;
      }
      ++v5;
    }
    while (v2 <= *v3);
  }
  else
  {
    int v3 = a1;
    do
    {
      int v4 = v3[1];
      ++v3;
    }
    while (v2 <= v4);
  }
  if (v3 < a2)
  {
    do
      int v6 = *--a2;
    while (v2 > v6);
  }
  if (v3 < a2)
  {
    int v7 = *v3;
    int v8 = *a2;
    do
    {
      int *v3 = v8;
      *a2 = v7;
      do
      {
        int v9 = v3[1];
        ++v3;
        int v7 = v9;
      }
      while (v2 <= v9);
      do
      {
        int v10 = *--a2;
        int v8 = v10;
      }
      while (v2 > v10);
    }
    while (v3 < a2);
  }
  if (v3 - 1 != a1) {
    *a1 = *(v3 - 1);
  }
  *(v3 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v2;
  return v3;
}

int *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,int *,std::greater<int> &>(int *a1, int *a2)
{
  uint64_t v2 = 0;
  int v3 = *a1;
  do
    int v4 = a1[++v2];
  while (v4 > v3);
  int v5 = &a1[v2];
  int v6 = &a1[v2 - 1];
  if (v2 == 1)
  {
    do
    {
      if (v5 >= a2) {
        break;
      }
      int v8 = *--a2;
    }
    while (v8 <= v3);
  }
  else
  {
    do
      int v7 = *--a2;
    while (v7 <= v3);
  }
  if (v5 < a2)
  {
    int v9 = *a2;
    int v10 = a2;
    uint64_t v11 = v5;
    do
    {
      *uint64_t v11 = v9;
      *int v10 = v4;
      do
      {
        int v12 = v11[1];
        ++v11;
        int v4 = v12;
      }
      while (v12 > v3);
      do
      {
        int v13 = *--v10;
        int v9 = v13;
      }
      while (v13 <= v3);
    }
    while (v11 < v10);
    int v6 = v11 - 1;
  }
  if (v6 != a1) {
    *a1 = *v6;
  }
  *int v6 = v3;
  return v6;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(_DWORD *a1, int *a2)
{
  uint64_t v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      int v3 = *(a2 - 1);
      int v4 = *a1;
      if (v3 > *a1)
      {
        *a1 = v3;
        *(a2 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v4;
      }
      return 1;
    case 3:
      int v20 = a1[1];
      int v21 = *(a2 - 1);
      if (v20 <= v21) {
        int v22 = *(a2 - 1);
      }
      else {
        int v22 = a1[1];
      }
      if (v20 >= v21) {
        int v20 = *(a2 - 1);
      }
      *(a2 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v20;
      a1[1] = v22;
      int v23 = *(a2 - 1);
      if (v23 <= *a1) {
        int v24 = *a1;
      }
      else {
        int v24 = *(a2 - 1);
      }
      if (v23 >= *a1) {
        int v23 = *a1;
      }
      *(a2 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v23;
      int v26 = *a1;
      int v25 = a1[1];
      if (v24 <= v25) {
        int v26 = a1[1];
      }
      if (v24 < v25) {
        int v25 = v24;
      }
      *a1 = v26;
      a1[1] = v25;
      return 1;
    case 4:
      int v48 = a1[1];
      int v47 = a1[2];
      if (*a1 <= v47) {
        int v49 = a1[2];
      }
      else {
        int v49 = *a1;
      }
      if (*a1 < v47) {
        int v47 = *a1;
      }
      a1[2] = v47;
      *a1 = v49;
      int v50 = *(a2 - 1);
      if (v48 <= v50) {
        int v51 = *(a2 - 1);
      }
      else {
        int v51 = v48;
      }
      if (v48 < v50) {
        int v50 = v48;
      }
      *(a2 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v50;
      int v52 = *a1;
      if (*a1 <= v51) {
        int v53 = v51;
      }
      else {
        int v53 = *a1;
      }
      if (v52 >= v51) {
        int v52 = v51;
      }
      *a1 = v53;
      a1[1] = v52;
      int v54 = a1[2];
      int v55 = *(a2 - 1);
      if (v54 <= v55) {
        int v56 = *(a2 - 1);
      }
      else {
        int v56 = a1[2];
      }
      if (v54 >= v55) {
        int v54 = *(a2 - 1);
      }
      *(a2 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v54;
      int v57 = a1[1];
      if (v57 <= v56) {
        int v58 = v56;
      }
      else {
        int v58 = a1[1];
      }
      if (v57 >= v56) {
        int v57 = v56;
      }
      a1[1] = v58;
      a1[2] = v57;
      return 1;
    case 5:
      int v27 = *a1;
      int v28 = a1[1];
      if (*a1 <= v28) {
        int v29 = a1[1];
      }
      else {
        int v29 = *a1;
      }
      if (v27 >= v28) {
        int v27 = a1[1];
      }
      *a1 = v29;
      a1[1] = v27;
      int v30 = a1[3];
      int v31 = *(a2 - 1);
      if (v30 <= v31) {
        int v32 = *(a2 - 1);
      }
      else {
        int v32 = a1[3];
      }
      if (v30 >= v31) {
        int v30 = *(a2 - 1);
      }
      *(a2 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v30;
      a1[3] = v32;
      int v33 = *(a2 - 1);
      int v34 = a1[2];
      if (v33 <= v34) {
        int v35 = a1[2];
      }
      else {
        int v35 = *(a2 - 1);
      }
      if (v33 >= v34) {
        int v33 = a1[2];
      }
      *(a2 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v33;
      int v37 = a1[2];
      int v36 = a1[3];
      int v38 = a1[1];
      if (v35 <= v36) {
        int v37 = a1[3];
      }
      if (v35 < v36) {
        int v36 = v35;
      }
      a1[2] = v37;
      a1[3] = v36;
      int v39 = *(a2 - 1);
      if (v38 <= v39) {
        int v40 = *(a2 - 1);
      }
      else {
        int v40 = v38;
      }
      if (v38 < v39) {
        int v39 = v38;
      }
      *(a2 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v39;
      int v41 = *a1;
      int v43 = a1[2];
      int v42 = a1[3];
      if (v42 <= *a1) {
        int v44 = *a1;
      }
      else {
        int v44 = a1[3];
      }
      if (v42 >= v41) {
        int v42 = *a1;
      }
      if (v44 <= v43) {
        int v41 = a1[2];
      }
      if (v44 < v43) {
        int v43 = v44;
      }
      if (v42 <= v40) {
        int v45 = v40;
      }
      else {
        int v45 = v42;
      }
      if (v42 >= v40) {
        int v42 = v40;
      }
      if (v45 <= v43) {
        int v40 = v43;
      }
      *a1 = v41;
      a1[1] = v40;
      if (v45 >= v43) {
        int v46 = v43;
      }
      else {
        int v46 = v45;
      }
      a1[2] = v46;
      a1[3] = v42;
      return 1;
    default:
      int v6 = a1 + 2;
      int v5 = a1[2];
      int v8 = *a1;
      int v7 = a1[1];
      if (v7 <= v5) {
        int v9 = a1[2];
      }
      else {
        int v9 = a1[1];
      }
      if (v7 < v5) {
        int v5 = a1[1];
      }
      if (v5 <= v8) {
        int v10 = *a1;
      }
      else {
        int v10 = v5;
      }
      if (v5 >= v8) {
        int v5 = *a1;
      }
      *int v6 = v5;
      if (v10 <= v9) {
        int v11 = v9;
      }
      else {
        int v11 = v8;
      }
      if (v10 >= v9) {
        int v10 = v9;
      }
      *a1 = v11;
      a1[1] = v10;
      int v12 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v13 = 0;
      uint64_t v14 = 12;
      break;
  }
  while (1)
  {
    int v15 = *v12;
    int v16 = *v6;
    if (*v12 > v16)
    {
      uint64_t v17 = v14;
      while (1)
      {
        *(_DWORD *)((char *)a1 + v17) = v16;
        uint64_t v18 = v17 - 4;
        if (v17 == 4) {
          break;
        }
        int v16 = *(_DWORD *)((char *)a1 + v17 - 8);
        v17 -= 4;
        if (v15 <= v16)
        {
          int v19 = (_DWORD *)((char *)a1 + v18);
          goto LABEL_27;
        }
      }
      int v19 = a1;
LABEL_27:
      *int v19 = v15;
      if (++v13 == 8) {
        return v12 + 1 == a2;
      }
    }
    int v6 = v12;
    v14 += 4;
    if (++v12 == a2) {
      return 1;
    }
  }
}

int *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *,int *>(int *a1, int *a2, int *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    int v6 = a2;
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 5)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      int v12 = &a1[v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    int v13 = v6;
    if (v6 != a3)
    {
      uint64_t v14 = v6;
      do
      {
        int v15 = *v14;
        if (*v14 > *a1)
        {
          int *v14 = *a1;
          *a1 = v15;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      int v13 = a3;
    }
    if (v8 >= 5)
    {
      uint64_t v16 = (unint64_t)v8 >> 2;
      do
      {
        uint64_t v17 = 0;
        int v18 = *a1;
        int v19 = a1;
        do
        {
          int v20 = &v19[v17 + 1];
          uint64_t v21 = (2 * v17) | 1;
          uint64_t v17 = 2 * v17 + 2;
          if (v17 >= v16)
          {
            int v22 = *v20;
            uint64_t v17 = v21;
          }
          else
          {
            int v22 = *v20;
            int v23 = v20[1];
            if (*v20 >= v23) {
              int v22 = v20[1];
            }
            if (*v20 <= v23) {
              uint64_t v17 = v21;
            }
            else {
              ++v20;
            }
          }
          *int v19 = v22;
          int v19 = v20;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v20 == --v6)
        {
          int *v20 = v18;
        }
        else
        {
          int *v20 = *v6;
          *int v6 = v18;
          uint64_t v24 = (char *)v20 - (char *)a1 + 4;
          if (v24 >= 5)
          {
            unint64_t v25 = (((unint64_t)v24 >> 2) - 2) >> 1;
            int v26 = &a1[v25];
            int v27 = *v26;
            int v28 = *v20;
            if (*v26 > *v20)
            {
              do
              {
                int v29 = v26;
                int *v20 = v27;
                if (!v25) {
                  break;
                }
                unint64_t v25 = (v25 - 1) >> 1;
                int v26 = &a1[v25];
                int v27 = *v26;
                int v20 = v29;
              }
              while (*v26 > v28);
              *int v29 = v28;
            }
          }
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<int> &,int *>(uint64_t result, uint64_t a2, uint64_t a3, int *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 2)
    {
      uint64_t v6 = v4 >> 1;
      uint64_t v7 = (v4 >> 1) + 1;
      uint64_t v8 = (int *)(result + 4 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 >= a3)
      {
        int v10 = *v8;
      }
      else
      {
        int v10 = *v8;
        int v11 = v8[1];
        if (*v8 >= v11) {
          int v10 = v8[1];
        }
        if (*v8 > v11)
        {
          ++v8;
          uint64_t v7 = v9;
        }
      }
      int v12 = *a4;
      if (v10 <= *a4)
      {
        do
        {
          int v13 = v8;
          *a4 = v10;
          if (v5 < v7) {
            break;
          }
          uint64_t v14 = (2 * v7) | 1;
          uint64_t v8 = (int *)(result + 4 * v14);
          uint64_t v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            int v10 = *v8;
            uint64_t v7 = v14;
          }
          else
          {
            int v10 = *v8;
            int v15 = v8[1];
            if (*v8 >= v15) {
              int v10 = v8[1];
            }
            if (*v8 <= v15) {
              uint64_t v7 = v14;
            }
            else {
              ++v8;
            }
          }
          a4 = v13;
        }
        while (v10 <= v12);
        *int v13 = v12;
      }
    }
  }
  return result;
}

std::vector<int>::pointer std::vector<int>::__swap_out_circular_buffer(std::vector<int> *this, std::__split_buffer<int> *__v, std::vector<int>::pointer __p)
{
  std::vector<int>::pointer begin = __v->__begin_;
  std::vector<int>::pointer v6 = this->__begin_;
  uint64_t v7 = begin;
  if (this->__begin_ != __p)
  {
    std::vector<int>::pointer v8 = __p;
    uint64_t v7 = __v->__begin_;
    do
    {
      int v9 = *--v8;
      *--uint64_t v7 = v9;
    }
    while (v8 != v6);
  }
  __v->__begin_ = v7;
  end = this->__end_;
  std::__split_buffer<int>::pointer v11 = __v->__end_;
  int64_t v12 = (char *)end - (char *)__p;
  if (end != __p)
  {
    memmove(__v->__end_, __p, (char *)end - (char *)__p);
    uint64_t v7 = __v->__begin_;
  }
  __v->__end_ = (std::__split_buffer<int>::pointer)((char *)v11 + v12);
  int v13 = this->__begin_;
  this->__begin_ = v7;
  __v->__begin_ = v13;
  uint64_t v14 = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = v14;
  value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
  return begin;
}

void std::__split_buffer<int>::push_back(std::__split_buffer<int> *this, std::__split_buffer<int>::value_type *__x)
{
  std::__split_buffer<int>::pointer end = this->__end_;
  if (end == this->__end_cap_.__value_)
  {
    std::__split_buffer<int>::pointer begin = this->__begin_;
    uint64_t v6 = (char *)begin - (char *)this->__first_;
    if (begin <= this->__first_)
    {
      if (end == this->__first_) {
        unint64_t v16 = 1;
      }
      else {
        unint64_t v16 = ((char *)end - (char *)this->__first_) >> 1;
      }
      uint64_t v17 = (int *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)this->__end_cap_.__value_, v16);
      int v19 = (int *)((char *)v17 + (v16 & 0xFFFFFFFFFFFFFFFCLL));
      std::__split_buffer<int>::pointer v20 = this->__begin_;
      std::__split_buffer<int>::pointer end = v19;
      uint64_t v21 = (char *)this->__end_ - (char *)v20;
      if (v21)
      {
        std::__split_buffer<int>::pointer end = (int *)((char *)v19 + (v21 & 0xFFFFFFFFFFFFFFFCLL));
        uint64_t v22 = 4 * (v21 >> 2);
        int v23 = (int *)((char *)v17 + (v16 & 0xFFFFFFFFFFFFFFFCLL));
        do
        {
          int v24 = *v20++;
          *v23++ = v24;
          v22 -= 4;
        }
        while (v22);
      }
      std::__split_buffer<int>::pointer first = this->__first_;
      this->__first_ = v17;
      this->__begin_ = v19;
      this->__end_ = end;
      this->__end_cap_.__value_ = &v17[v18];
      if (first)
      {
        operator delete(first);
        std::__split_buffer<int>::pointer end = this->__end_;
      }
    }
    else
    {
      uint64_t v7 = v6 >> 2;
      BOOL v8 = v6 >> 2 < -1;
      uint64_t v9 = (v6 >> 2) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      int v13 = &begin[-v12];
      int64_t v14 = (char *)end - (char *)begin;
      if (end != begin)
      {
        memmove(&begin[-v12], begin, (char *)end - (char *)begin);
        std::__split_buffer<int>::pointer end = this->__begin_;
      }
      int v15 = &end[v11];
      std::__split_buffer<int>::pointer end = (int *)((char *)v13 + v14);
      this->__begin_ = v15;
    }
  }
  int *end = *__x;
  this->__end_ = end + 1;
}

void MTMouseEventDispatcher::createDispatcher()
{
}

void sub_240726E70(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10A1C4052F3E7C6);
  _Unwind_Resume(a1);
}

BOOL MTMouseEventDispatcher::shouldDispatchEvent(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 424)
    || (IOHIDEventGetIntegerValue() & 0x100) != 0
    || (IOHIDEventGetIntegerValue() & 8) != 0
    || IOHIDEventConformsTo()
    || IOHIDEventConformsTo()
    || IOHIDEventConformsTo()
    || IOHIDEventConformsTo()
    || IOHIDEventConformsTo()
    || IOHIDEventConformsTo())
  {
    return 1;
  }
  uint64_t v1 = 1;
  if (!IOHIDEventConformsTo()) {
    return IOHIDEventConformsTo() != 0;
  }
  return v1;
}

void MTMouseEventDispatcher::dispatchEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    if (!*(unsigned char *)(a1 + 424))
    {
      CFArrayRef Children = (const __CFArray *)IOHIDEventGetChildren();
      if (Children)
      {
        CFArrayRef v7 = Children;
        CFIndex Count = CFArrayGetCount(Children);
        if (Count >= 1)
        {
          unint64_t v9 = Count + 1;
          do
          {
            CFArrayGetValueAtIndex(v7, v9 - 2);
            if (!IOHIDEventConformsTo()
              && !IOHIDEventConformsTo()
              && !IOHIDEventConformsTo()
              && !IOHIDEventConformsTo()
              && !IOHIDEventConformsTo()
              && !IOHIDEventConformsTo()
              && !IOHIDEventConformsTo()
              && !IOHIDEventConformsTo())
            {
              IOHIDEventRemoveEvent();
            }
            --v9;
          }
          while (v9 > 1);
        }
      }
    }
  }

  MTSimpleEventDispatcher::dispatchEvent(a1, a2, a3);
}

void MTMouseEventDispatcher::~MTMouseEventDispatcher(MTMouseEventDispatcher *this)
{
  *(void *)this = &unk_26F4DA178;
  std::__list_imp<double>::clear((void *)this + 61);
  std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy((uint64_t)this + 464, *((void **)this + 59));

  MTSimpleEventDispatcher::~MTSimpleEventDispatcher(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26F4DA178;
  std::__list_imp<double>::clear((void *)this + 61);
  std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy((uint64_t)this + 464, *((void **)this + 59));
  MTSimpleEventDispatcher::~MTSimpleEventDispatcher(this);

  JUMPOUT(0x2455F6CE0);
}

void MTSimpleHIDManager::MTSimpleHIDManager(MTSimpleHIDManager *this)
{
  *(void *)this = &unk_26F4DA348;
  *((void *)this + 8) = 0;
  *((unsigned char *)this + 80) = 0;
  *((_DWORD *)this + 2MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = 1;
  *((_DWORD *)this + 22) = 0;
  *(_WORD *)((char *)this + 123) = 0;
  *((unsigned char *)this + 125) = 0;
  atomic_store(1u, (unsigned int *)this + 2);
  *((_WORD *)this + 28) = 100;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
}

uint64_t MTSimpleHIDManager::initialize(MTModeSwitcher *a1, uint64_t a2, CFTypeRef cf, int a4, int a5)
{
  *((void *)a1 + 2) = a2;
  *((_DWORD *)a1 + 39) = a4;
  *((_DWORD *)a1 + 40) = a5;
  *((void *)a1 + 3) = CFRetain(cf);
  *((void *)a1 + 4) = 0;
  *((void *)a1 + 2MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = 0;
  *((void *)a1 + 22) = dispatch_queue_create("com.apple.MultitouchSupport.control-requests", 0);
  *((void *)a1 + 23) = dispatch_group_create();
  (*(void (**)(MTModeSwitcher *))(*(void *)a1 + 104))(a1);
  _printHIDEvents = 0;
  *((_DWORD *)a1 + 48) = 255;
  *((void *)a1 + 16) = 255;
  *((unsigned char *)a1 + 136) = 0;
  *((_DWORD *)a1 + 4MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = 0;
  *((unsigned char *)a1 + 126) = 0;
  *((unsigned char *)a1 + 12MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = (*(uint64_t (**)(MTModeSwitcher *))(*(void *)a1 + 344))(a1);
  *((unsigned char *)a1 + 12MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = (*(uint64_t (**)(MTModeSwitcher *))(*(void *)a1 + 344))(a1);
  *((void *)a1 + 18) = 0;
  *((unsigned char *)a1 + 152) = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  *((void *)a1 + 5) = Mutable;
  *((void *)a1 + 25) = MTSLGLogger::createLogger(Mutable);
  *((void *)a1 + 6) = CFArrayCreateMutable(v6, *((unsigned __int16 *)a1 + 28), MEMORY[0x263EFFF70]);
  *((void *)a1 + 9) = CFDateFormatterCreate(v6, 0, kCFDateFormatterShortStyle, kCFDateFormatterFullStyle);
  *((void *)a1 + 14) = MTModeSwitcher::createModeSwitcher(a1, v8);
  unint64_t v9 = *(uint64_t (**)(MTModeSwitcher *, uint64_t))(*(void *)a1 + 336);

  return v9(a1, 1);
}

uint64_t MTSimpleHIDManager::start(MTSimpleHIDManager *this)
{
  return 1;
}

uint64_t MTSimpleHIDManager::stop(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 56))(this);
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 96))(this);
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 72))(this);
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 56))(this);
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 160))(this);
  uint64_t v2 = *(uint64_t (**)(MTSimpleHIDManager *))(*(void *)this + 112);

  return v2(this);
}

void MTSimpleHIDManager::finalize(MTSimpleHIDManager *this)
{
  uint64_t v2 = *((void *)this + 14);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *((void *)this + 14) = 0;
  int v3 = (MTSLGLogger *)*((void *)this + 25);
  if (v3)
  {
    MTSLGLogger::~MTSLGLogger(v3);
    MEMORY[0x2455F6CE0]();
  }
  dispatch_group_wait(*((dispatch_group_t *)this + 23), 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(*((dispatch_object_t *)this + 23));
  *((void *)this + 23) = 0;
  dispatch_release(*((dispatch_object_t *)this + 22));
  *((void *)this + 22) = 0;
  uint64_t v4 = (const void *)*((void *)this + 3);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 3) = 0;
  }
  int64_t v5 = (const void *)*((void *)this + 5);
  if (v5)
  {
    CFRelease(v5);
    *((void *)this + 5) = 0;
  }
  CFAllocatorRef v6 = *((void *)this + 21);
  if (v6)
  {
    dispatch_release(v6);
    *((void *)this + 2MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = 0;
  }
  CFArrayRef v7 = (const void *)*((void *)this + 6);
  if (v7)
  {
    CFRelease(v7);
    *((void *)this + 6) = 0;
  }
  BOOL v8 = (const void *)*((void *)this + 9);
  if (v8)
  {
    CFRelease(v8);
    *((void *)this + 9) = 0;
  }
  *((void *)this + 2) = 0;
}

uint64_t MTSimpleHIDManager::openManager(MTSimpleHIDManager *this)
{
  return 1;
}

uint64_t MTSimpleHIDManager::closeManager(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *, uint64_t))(*(void *)this + 592))(this, 1);
  uint64_t v2 = *(uint64_t (**)(MTSimpleHIDManager *))(*(void *)this + 40);

  return v2(this);
}

uint64_t MTSimpleHIDManager::retain(uint64_t this)
{
  if (!atomic_load((unsigned int *)(this + 8))) {
    MTSimpleHIDManager::retain();
  }
  atomic_fetch_add((atomic_uint *volatile)(this + 8), 1u);
  return this;
}

unsigned int *MTSimpleHIDManager::release(unsigned int *this)
{
  if (!atomic_load(this + 2)) {
    MTSimpleHIDManager::release();
  }
  if (atomic_fetch_add((atomic_uint *volatile)this + 2, 0xFFFFFFFF) == 1)
  {
    uint64_t v2 = (uint64_t)this;
    (*(void (**)(unsigned int *))(*(void *)this + 24))(this);
    int v3 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 8);
    return (unsigned int *)v3(v2);
  }
  return this;
}

uint64_t MTSimpleHIDManager::wasScheduledOnDispatchQueue(MTSimpleHIDManager *this, dispatch_object_t object)
{
  if (object) {
    dispatch_retain(object);
  }
  uint64_t v4 = *((void *)this + 21);
  if (v4) {
    dispatch_release(v4);
  }
  *((void *)this + 2MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = object;
  int64_t v5 = *(uint64_t (**)(void))(**((void **)this + 4) + 88);

  return v5();
}

uint64_t MTSimpleHIDManager::wasUnscheduledFromDispatchQueue(NSObject **this, dispatch_queue_s *a2)
{
  ((void (*)(NSObject **))(*this)[61].isa)(this);
  uint64_t v4 = this[21];
  if (v4)
  {
    dispatch_release(v4);
    this[21] = 0;
  }
  (*((void (**)(NSObject *, dispatch_queue_s *))this[4]->isa + 8))(this[4], a2);
  int64_t v5 = (uint64_t (*)(void))*((void *)this[4]->isa + 11);

  return v5();
}

uint64_t MTSimpleHIDManager::getHIDDispatchQueue(MTSimpleHIDManager *this)
{
  return *((void *)this + 21);
}

uint64_t MTSimpleHIDManager::registerDeviceNotifications(MTSimpleHIDManager *this)
{
  uint64_t v2 = (*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);

  return MEMORY[0x270F4C810](v2, MTSimpleHIDManager::forwardNotificationEvent, this);
}

uint64_t MTSimpleHIDManager::unregisterDeviceNotifications(MTSimpleHIDManager *this)
{
  uint64_t v1 = (*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);

  return MEMORY[0x270F4C870](v1, MTSimpleHIDManager::forwardNotificationEvent);
}

uint64_t MTSimpleHIDManager::registerExternalMessages(MTSimpleHIDManager *this)
{
  uint64_t v2 = (*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);

  return MEMORY[0x270F4C7E0](v2, MTSimpleHIDManager::forwardExternalMessage, this);
}

uint64_t MTSimpleHIDManager::forwardExternalMessage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a5 + 216))(a5, a1, a2, a3, a4);
}

uint64_t MTSimpleHIDManager::unregisterExternalMessages(MTSimpleHIDManager *this)
{
  uint64_t v2 = (*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);

  return MEMORY[0x270F4C848](v2, MTSimpleHIDManager::forwardExternalMessage, this);
}

uint64_t MTSimpleHIDManager::registerDeviceDataCallbacks(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  MTRegisterContactFrameCallbackWithRefcon();
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  MTDeviceSetInputDetectionCallbackTriggerMask();
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  MTRegisterInputDetectionCallback();
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  uint64_t result = MTRegisterFrameHeaderCallback();
  if (*((void *)this + 25))
  {
    uint64_t v3 = (*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
    return MEMORY[0x270F4C800](v3, MTSimpleHIDManager::forwardImageEntry, 2147483646, 2, this);
  }
  return result;
}

uint64_t MTSimpleHIDManager::forwardContactFrame(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a5 + 184))(a5, a1, a2, a3, a4);
}

uint64_t MTSimpleHIDManager::forwardInputDetectionState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a5 + 200))(a5, a1, a2, a3, a4);
}

uint64_t MTSimpleHIDManager::forwardFrameHeader(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 224))(a3, a1, a2);
}

uint64_t MTSimpleHIDManager::forwardImageEntry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a4 + 232))(a4, a1, a2, a3);
}

uint64_t MTSimpleHIDManager::unregisterDeviceDataCallbacks(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  MTUnregisterContactFrameCallback();
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  uint64_t result = MTUnregisterInputDetectionCallback();
  if (*((void *)this + 25))
  {
    (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
    uint64_t result = MTUnregisterImageCallback();
  }
  if (*((unsigned char *)this + 125))
  {
    *((unsigned char *)this + 125) = 0;
    (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
    return MTUnregisterFullFrameCallback();
  }
  return result;
}

uint64_t MTSimpleHIDManager::forwardFullFrame(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a4 + 240))(a4, a1, a2, a3);
}

void MTSimpleHIDManager::registerSystemCallbacks(MTSimpleHIDManager *this)
{
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver(DarwinNotifyCenter, this, (CFNotificationCallback)MTSimpleHIDManager::fieldOnNotificationCenterCallback, @"com.apple.stockholm.field.on", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  uint64_t v3 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver(v3, this, (CFNotificationCallback)MTSimpleHIDManager::fieldOffNotificationCenterCallback, @"com.apple.stockholm.field.off", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  uint64_t v4 = CFNotificationCenterGetDarwinNotifyCenter();

  CFNotificationCenterAddObserver(v4, this, (CFNotificationCallback)MTSimpleHIDManager::fieldOffNotificationCenterCallback, @"com.apple.stockholm.field.suspended", 0, CFNotificationSuspensionBehaviorDeliverImmediately);
}

uint64_t MTSimpleHIDManager::fieldOnNotificationCenterCallback(MTSimpleHIDManager *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  return (*(uint64_t (**)(__CFNotificationCenter *, uint64_t))(*(void *)a2 + 456))(a2, 1);
}

uint64_t MTSimpleHIDManager::fieldOffNotificationCenterCallback(MTSimpleHIDManager *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  return (*(uint64_t (**)(__CFNotificationCenter *, uint64_t))(*(void *)a2 + 456))(a2, 2);
}

void MTSimpleHIDManager::unregisterSystemCallbacks(MTSimpleHIDManager *this)
{
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver(DarwinNotifyCenter, this, @"com.apple.stockholm.field.on", 0);
  uint64_t v3 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver(v3, this, @"com.apple.stockholm.field.off", 0);
  uint64_t v4 = CFNotificationCenterGetDarwinNotifyCenter();

  CFNotificationCenterRemoveObserver(v4, this, @"com.apple.stockholm.field.suspended", 0);
}

void MTSimpleHIDManager::createEventDispatcher(MTSimpleHIDManager *this)
{
}

uint64_t MTSimpleHIDManager::destroyEventDispatcher(MTSimpleHIDManager *this)
{
  return (*(uint64_t (**)(MTSimpleHIDManager *, void))(*(void *)this + 128))(this, 0);
}

uint64_t MTSimpleHIDManager::getEventDispatcher(MTSimpleHIDManager *this)
{
  return *((void *)this + 4);
}

unsigned int *MTSimpleHIDManager::setEventDispatcher(MTSimpleHIDManager *this, MTSimpleEventDispatcher *a2)
{
  uint64_t result = (unsigned int *)*((void *)this + 4);
  if (result) {
    BOOL v5 = result == (unsigned int *)a2;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5) {
    uint64_t result = MTSimpleEventDispatcher::release(result);
  }
  *((void *)this + 4) = a2;
  if (a2)
  {
    return (unsigned int *)MTSimpleEventDispatcher::retain((uint64_t)a2);
  }
  return result;
}

void MTSimpleHIDManager::issueWakeEvent(MTSimpleHIDManager *this)
{
  mach_absolute_time();
  uint64_t KeyboardEvent = (const void *)IOHIDEventCreateKeyboardEvent();
  (*(void (**)(MTSimpleHIDManager *, const void *, void))(*(void *)this + 136))(this, KeyboardEvent, 0);
  CFRelease(KeyboardEvent);
  mach_absolute_time();
  uint64_t v3 = (const void *)IOHIDEventCreateKeyboardEvent();
  (*(void (**)(MTSimpleHIDManager *, const void *, void))(*(void *)this + 136))(this, v3, 0);

  CFRelease(v3);
}

uint64_t MTSimpleHIDManager::initializeGestureParser(MTSimpleHIDManager *this)
{
  return (*(uint64_t (**)(MTSimpleHIDManager *, void))(*(void *)this + 592))(this, 0);
}

uint64_t MTSimpleHIDManager::setPluginDefaultProperties(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 312))(this);
  uint64_t v2 = *MEMORY[0x263EFFB38];
  if (_printHIDEvents) {
    uint64_t v3 = *MEMORY[0x263EFFB40];
  }
  else {
    uint64_t v3 = *MEMORY[0x263EFFB38];
  }
  (*(void (**)(MTSimpleHIDManager *, __CFString *, uint64_t))(*(void *)this + 568))(this, @"PrintHIDEvents", v3);
  uint64_t v4 = *(uint64_t (**)(MTSimpleHIDManager *, __CFString *, uint64_t))(*(void *)this + 568);

  return v4(this, @"MotionActivityInterested", v2);
}

void MTSimpleHIDManager::setDeviceDefaultProperties(MTSimpleHIDManager *this)
{
  if (*((unsigned char *)this + 122))
  {
    __int16 valuePtr = 0;
    CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt16Type, &valuePtr);
    if (!v3) {
      goto LABEL_7;
    }
    CFNumberRef v4 = v3;
    (*(void (**)(MTSimpleHIDManager *, __CFString *, CFNumberRef))(*(void *)this + 568))(this, @"InputDetectionMode", v3);
  }
  else
  {
    __int16 v12 = 0;
    CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt16Type, &v12);
    if (!v5) {
      goto LABEL_7;
    }
    CFNumberRef v4 = v5;
    (*(void (**)(MTSimpleHIDManager *, __CFString *, CFNumberRef))(*(void *)this + 568))(this, @"TouchDetectionMode", v5);
  }
  CFRelease(v4);
LABEL_7:
  __int16 v11 = 1;
  CFNumberRef v6 = CFNumberCreate(v2, kCFNumberSInt16Type, &v11);
  if (v6)
  {
    CFNumberRef v7 = v6;
    (*(void (**)(MTSimpleHIDManager *, __CFString *, CFNumberRef))(*(void *)this + 568))(this, @"GraphicsOrientation", v6);
    CFRelease(v7);
  }
  char v10 = 0;
  CFNumberRef v8 = CFNumberCreate(v2, kCFNumberSInt8Type, &v10);
  if (v8)
  {
    CFNumberRef v9 = v8;
    (*(void (**)(MTSimpleHIDManager *, __CFString *, CFNumberRef))(*(void *)this + 568))(this, @"WristState", v8);
    CFRelease(v9);
  }
  if ((*((unsigned char *)this + 160) & 0x20) != 0) {
    (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 352))(this);
  }
  *((unsigned char *)this + 126) = 1;
}

uint64_t MTSimpleHIDManager::devicePropertiesBecameAvailable(MTSimpleHIDManager *this)
{
  CFNumberRef v2 = (CFNumberRef)(*(uint64_t (**)(MTSimpleHIDManager *, __CFString *))(*(void *)this + 560))(this, @"InputDetectionMode");
  if (*((unsigned char *)this + 122)) {
    BOOL v3 = v2 == 0;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3)
  {
    if (!v2) {
      return (*(uint64_t (**)(MTSimpleHIDManager *, uint64_t))(*(void *)this + 336))(this, 1);
    }
    goto LABEL_9;
  }
  __int16 valuePtr = 0;
  CFNumberRef v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt16Type, &valuePtr);
  if (v4)
  {
    CFNumberRef v5 = v4;
    (*(void (**)(MTSimpleHIDManager *, __CFString *, CFNumberRef))(*(void *)this + 568))(this, @"InputDetectionMode", v4);
    CFNumberRef v2 = v5;
LABEL_9:
    CFRelease(v2);
  }
  return (*(uint64_t (**)(MTSimpleHIDManager *, uint64_t))(*(void *)this + 336))(this, 1);
}

uint64_t MTSimpleHIDManager::setDeviceUsages(MTSimpleHIDManager *this)
{
  unsigned int v2 = *((_DWORD *)this + 39);
  BOOL v4 = v2 < 0x3E8 || v2 - 3000 < 0x3E8;
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  int IsBuiltIn = MTDeviceIsBuiltIn();
  int valuePtr = 13;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 2, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  CFNumberRef v8 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
  if (v8)
  {
    CFNumberRef v9 = v8;
    (*(void (**)(MTSimpleHIDManager *, __CFString *, CFNumberRef))(*(void *)this + 568))(this, @"PrimaryUsagePage", v8);
    if (Mutable) {
      CFDictionaryAddValue(Mutable, @"DeviceUsagePage", v9);
    }
    CFRelease(v9);
  }
  int valuePtr = 12;
  CFNumberRef v10 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
  if (v10)
  {
    CFNumberRef v11 = v10;
    (*(void (**)(MTSimpleHIDManager *, __CFString *, CFNumberRef))(*(void *)this + 568))(this, @"PrimaryUsage", v10);
    if (Mutable) {
      CFDictionaryAddValue(Mutable, @"DeviceUsage", v11);
    }
    CFRelease(v11);
  }
  if (v4)
  {
    __int16 v12 = CFDictionaryCreateMutable(v6, 2, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    int valuePtr = 13;
    CFNumberRef v13 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
    if (v13)
    {
      CFNumberRef v14 = v13;
      if (v12) {
        CFDictionaryAddValue(v12, @"DeviceUsagePage", v13);
      }
      CFRelease(v14);
    }
    if (IsBuiltIn) {
      int v15 = 4;
    }
    else {
      int v15 = 5;
    }
    int valuePtr = v15;
    CFNumberRef v16 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
    if (v16)
    {
      CFNumberRef v17 = v16;
      if (v12) {
        CFDictionaryAddValue(v12, @"DeviceUsage", v16);
      }
      (*(void (**)(MTSimpleHIDManager *, __CFString *, CFNumberRef))(*(void *)this + 568))(this, @"PrimaryUsage", v17);
      CFRelease(v17);
    }
  }
  else
  {
    __int16 v12 = 0;
  }
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  if (MTDeviceGetSensorRegionOfType())
  {
    uint64_t v18 = 0;
  }
  else
  {
    *((unsigned char *)this + 122) = 1;
    uint64_t v18 = CFDictionaryCreateMutable(v6, 2, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    if (v18)
    {
      int valuePtr = 65280;
      CFNumberRef v19 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
      if (v19)
      {
        CFNumberRef v20 = v19;
        CFDictionaryAddValue(v18, @"DeviceUsagePage", v19);
        CFRelease(v20);
      }
      int valuePtr = 8;
      CFNumberRef v21 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
      if (v21)
      {
        CFNumberRef v22 = v21;
        CFDictionaryAddValue(v18, @"DeviceUsage", v21);
        CFRelease(v22);
      }
    }
  }
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  if (MTDeviceSupportsForce())
  {
    int v23 = CFDictionaryCreateMutable(v6, 2, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    if (v23)
    {
      int valuePtr = 65280;
      CFNumberRef v24 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
      if (v24)
      {
        CFNumberRef v25 = v24;
        CFDictionaryAddValue(v23, @"DeviceUsagePage", v24);
        CFRelease(v25);
      }
      int valuePtr = 19;
      CFNumberRef v26 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
      if (v26)
      {
        CFNumberRef v27 = v26;
        CFDictionaryAddValue(v23, @"DeviceUsage", v26);
        CFRelease(v27);
      }
    }
  }
  else
  {
    int v23 = 0;
  }
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  MTDeviceGetFamilyID();
  int v28 = CFArrayCreateMutable(v6, 2, MEMORY[0x263EFFF70]);
  if (v28)
  {
    int v29 = v28;
    if (Mutable) {
      CFArrayAppendValue(v28, Mutable);
    }
    if (v12) {
      CFArrayAppendValue(v29, v12);
    }
    if (v18) {
      CFArrayAppendValue(v29, v18);
    }
    if (v23) {
      CFArrayAppendValue(v29, v23);
    }
    (*(void (**)(MTSimpleHIDManager *, __CFString *, __CFArray *))(*(void *)this + 568))(this, @"DeviceUsagePairs", v29);
    CFRelease(v29);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v12) {
    CFRelease(v12);
  }
  if (v18) {
    CFRelease(v18);
  }
  if (v23) {
    CFRelease(v23);
  }
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  int v30 = MTDeviceIsBuiltIn();
  uint64_t v31 = *MEMORY[0x263EFFB40];
  uint64_t v32 = *MEMORY[0x263EFFB38];
  if (v30) {
    uint64_t v33 = *MEMORY[0x263EFFB40];
  }
  else {
    uint64_t v33 = *MEMORY[0x263EFFB38];
  }
  (*(void (**)(MTSimpleHIDManager *, __CFString *, uint64_t))(*(void *)this + 568))(this, @"Built-In", v33);
  if ((v4 & IsBuiltIn) != 0) {
    uint64_t v34 = v31;
  }
  else {
    uint64_t v34 = v32;
  }
  return (*(uint64_t (**)(MTSimpleHIDManager *, __CFString *, uint64_t))(*(void *)this + 568))(this, @"DisplayIntegrated", v34);
}

void MTSimpleHIDManager::enableReportingOfAllInputs(dispatch_object_t *this)
{
  dispatch_retain(this[22]);
  dispatch_retain(this[23]);
  BOOL v3 = this[22];
  unsigned int v2 = this[23];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 0x40000000;
  block[2] = ___ZN18MTSimpleHIDManager26enableReportingOfAllInputsEv_block_invoke;
  block[3] = &__block_descriptor_tmp_0;
  block[4] = this;
  dispatch_group_async(v2, v3, block);
}

void ___ZN18MTSimpleHIDManager26enableReportingOfAllInputsEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(NSObject ***)(a1 + 32);
  ((void (*)(NSObject **))(*v1)[45].isa)(v1);
  dispatch_release(v1[23]);
  unsigned int v2 = v1[22];

  dispatch_release(v2);
}

void MTSimpleHIDManager::_enableReportingOfAllInputs(MTSimpleHIDManager *this)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  int Report = MTDeviceGetReport();
  if (Report)
  {
    int v3 = Report;
    BOOL v4 = MTLoggingPlugin();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315906;
    __int16 v12 = "[Error] ";
    __int16 v13 = 2080;
    CFNumberRef v14 = "MTSimpleHIDManager::";
    __int16 v15 = 2080;
    CFNumberRef v16 = "_enableReportingOfAllInputs";
    __int16 v17 = 1024;
    int v18 = v3;
    CFNumberRef v5 = "[HID] [MT] %s%s%s Error 0x%08X getting detection options";
    CFAllocatorRef v6 = v4;
    uint32_t v7 = 38;
    goto LABEL_7;
  }
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  int v8 = MTDeviceSetReport();
  if (v8)
  {
    int v9 = v8;
    CFNumberRef v10 = MTLoggingPlugin();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      __int16 v12 = "[Error] ";
      __int16 v13 = 2080;
      CFNumberRef v14 = "MTSimpleHIDManager::";
      __int16 v15 = 2080;
      CFNumberRef v16 = "_enableReportingOfAllInputs";
      __int16 v17 = 1024;
      int v18 = v9;
      __int16 v19 = 1024;
      int v20 = 9;
      CFNumberRef v5 = "[HID] [MT] %s%s%s Error 0x%08X setting detection options to 0x%02X";
      CFAllocatorRef v6 = v10;
      uint32_t v7 = 44;
LABEL_7:
      _os_log_impl(&dword_2406FB000, v6, OS_LOG_TYPE_ERROR, v5, buf, v7);
    }
  }
}

void ___ZN18MTSimpleHIDManager23setFieldDetectionStatusEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(NSObject ***)(a1 + 32);
  ((void (*)(NSObject **))(*v1)[47].isa)(v1);
  dispatch_release(v1[23]);
  unsigned int v2 = v1[22];

  dispatch_release(v2);
}

uint64_t MTSimpleHIDManager::_setFieldDetectionStatus(MTSimpleHIDManager *this)
{
  return MTDeviceSetReport();
}

uint64_t MTSimpleHIDManager::deviceIsReady(MTSimpleHIDManager *this)
{
  return *((unsigned __int8 *)this + 120);
}

uint64_t MTSimpleHIDManager::setDeviceIsReady(MTSimpleHIDManager *this, int a2)
{
  *((unsigned char *)this + 120) = a2;
  unsigned int v2 = (void *)MEMORY[0x263EFFB40];
  if (!a2) {
    unsigned int v2 = (void *)MEMORY[0x263EFFB38];
  }
  return (*(uint64_t (**)(MTSimpleHIDManager *, __CFString *, void))(*(void *)this + 568))(this, @"DeviceIsReady", *v2);
}

BOOL MTSimpleHIDManager::checkForParserDisabled(MTSimpleHIDManager *this)
{
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  if (!MTDeviceGetService()) {
    return 0;
  }
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);
  io_registry_entry_t Service = MTDeviceGetService();
  CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(Service, @"ParserDisabled", (CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  BOOL v4 = CFProperty == (CFTypeRef)*MEMORY[0x263EFFB40];
  if (CFProperty) {
    CFRelease(CFProperty);
  }
  return v4;
}

BOOL MTSimpleHIDManager::propertyIsPublishedOnDriver(uint64_t a1, int a2)
{
  return a2 == 16 || (a2 - 59) < 0xB;
}

CFDictionaryRef MTSimpleHIDManager::copyProperty(CFDictionaryRef *this, const __CFString *a2)
{
  uint64_t v4 = MTSimpleHIDManager::propertyTypeFromString((uint64_t)a2, a2);
  uint64_t v5 = v4;
  if ((int)v4 <= 25)
  {
    if (v4 == 13)
    {
      (*((void (**)(double *__return_ptr, CFDictionaryRef *))*this + 21))(v36, this);
      float v15 = v37;
    }
    else
    {
      if (v4 != 14)
      {
        if (v4 == 24)
        {
          LODWORD(v36[0]) = 0;
          (*((void (**)(CFDictionaryRef *))*this + 10))(this);
          if (!MTDeviceGetCriticalErrors())
          {
            CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
            CFNumberType v7 = kCFNumberSInt32Type;
            goto LABEL_15;
          }
        }
LABEL_17:
        CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
        CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], this[5]);
        Boolean Value = (__CFDictionary *)CFDictionaryGetValue(Copy, a2);
        if (Value)
        {
          CFTypeRef CFProperty = Value;
          CFRetain(Value);
        }
        else
        {
          (*((void (**)(CFDictionaryRef *))*this + 10))(this);
          io_registry_entry_t Service = MTDeviceGetService();
          CFTypeRef CFProperty = (__CFDictionary *)IORegistryEntryCreateCFProperty(Service, a2, v18, 0);
          if (CFProperty)
          {
            if ((*((unsigned int (**)(CFDictionaryRef *, uint64_t))*this + 48))(this, v5)) {
              (*((void (**)(CFDictionaryRef *, const __CFString *, void, uint64_t))*this + 49))(this, a2, 0, 1);
            }
          }
        }
        CFDictionaryRef v21 = Copy;
        goto LABEL_20;
      }
      (*((void (**)(double *__return_ptr, CFDictionaryRef *))*this + 21))(v36, this);
      float v15 = v38;
    }
    v36[0] = v15;
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFNumberType v7 = kCFNumberDoubleType;
LABEL_15:
    CFNumberRef v16 = CFNumberCreate(v6, v7, v36);
    if (v16)
    {
      CFNumberRef v17 = v16;
      CFDictionarySetValue(this[5], a2, v16);
      CFRelease(v17);
    }
    goto LABEL_17;
  }
  if (v4 != 26)
  {
    if (v4 == 73)
    {
      CFAllocatorRef v26 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 3, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
      if (!Mutable) {
        goto LABEL_17;
      }
      CFTypeRef CFProperty = Mutable;
      CFDictionarySetValue(Mutable, @"Service properties", this[5]);
      CFArrayRef v28 = CFArrayCreateCopy(v26, this[6]);
      if (v28)
      {
        CFArrayRef v29 = v28;
        CFDictionarySetValue(CFProperty, @"Recent set properties", v28);
        CFRelease(v29);
      }
      int v30 = (const void *)(*(uint64_t (**)(CFDictionaryRef))(*(void *)this[4] + 104))(this[4]);
      if (v30)
      {
        uint64_t v31 = v30;
        CFDictionarySetValue(CFProperty, @"Event dispatch", v30);
        CFRelease(v31);
      }
      LODWORD(v36[0]) = 0;
      (*((void (**)(CFDictionaryRef *))*this + 10))(this);
      if (MTDeviceGetCriticalErrors()) {
        return CFProperty;
      }
      CFNumberRef v32 = CFNumberCreate(v26, kCFNumberSInt32Type, v36);
      if (!v32) {
        return CFProperty;
      }
      CFNumberRef v13 = v32;
      CFNumberRef v14 = @"Critical errors";
    }
    else
    {
      if (v4 != 77) {
        goto LABEL_17;
      }
      int v35 = 0;
      LODWORD(v36[0]) = 0;
      (*((void (**)(CFDictionaryRef *))*this + 10))(this);
      if (MTDeviceGetSensorSurfaceDimensions()) {
        goto LABEL_17;
      }
      CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      CFTypeRef CFProperty = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
      LODWORD(v10) = LODWORD(v36[0]);
      unsigned int valuePtr = vcvtd_n_s64_f64((double)v10 / 100.0, 0x10uLL);
      CFNumberRef v11 = CFNumberCreate(v8, kCFNumberSInt32Type, &valuePtr);
      CFDictionarySetValue(CFProperty, @"Width", v11);
      CFRelease(v11);
      LODWORD(v12) = v35;
      unsigned int v33 = vcvtd_n_s64_f64((double)v12 / 100.0, 0x10uLL);
      CFNumberRef v13 = CFNumberCreate(v8, kCFNumberSInt32Type, &v33);
      CFNumberRef v14 = @"Height";
    }
    CFDictionarySetValue(CFProperty, v14, v13);
    CFDictionaryRef v21 = v13;
LABEL_20:
    CFRelease(v21);
    return CFProperty;
  }
  CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef v25 = this[5];

  return CFDictionaryCreateCopy(v24, v25);
}

uint64_t MTSimpleHIDManager::translateInputDetectionMode(uint64_t a1, unsigned int a2)
{
  if (a2 <= 6)
  {
    if (((1 << a2) & 9) != 0) {
      return 0;
    }
    if (((1 << a2) & 0x12) != 0) {
      return 2;
    }
    if (((1 << a2) & 0x60) != 0) {
      return 1;
    }
  }
  if (a2 == 254) {
    unsigned int v3 = 254;
  }
  else {
    unsigned int v3 = 255;
  }
  if (a2 == 253) {
    return 253;
  }
  else {
    return v3;
  }
}

BOOL MTSimpleHIDManager::touchPowered(MTSimpleHIDManager *this)
{
  uint64_t v1 = 128;
  if (!*((unsigned char *)this + 122)) {
    uint64_t v1 = 192;
  }
  return *(_DWORD *)((char *)this + v1) != 255;
}

uint64_t MTSimpleHIDManager::resetDevice(MTSimpleHIDManager *this)
{
  return 3758097095;
}

const char *MTSimpleHIDManager::powerStateToStr(unsigned int a1)
{
  if (a1 > 2) {
    return "<UNKNOWN>";
  }
  else {
    return off_2650D3550[a1];
  }
}

uint64_t MTSimpleHIDManager::setupBootloadPowerAssertion(MTSimpleHIDManager *this, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315650;
    int v9 = "";
    __int16 v10 = 2080;
    CFNumberRef v11 = "MTSimpleHIDManager::";
    __int16 v12 = 2080;
    CFNumberRef v13 = "setupBootloadPowerAssertion";
    _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s ", (uint8_t *)&v8, 0x20u);
  }
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 488))(this);
  uint64_t v5 = MTLoggingPlugin();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *((void *)this + 13) + 1;
    *((void *)this + 13) = v6;
    int v8 = 136315906;
    int v9 = "";
    __int16 v10 = 2080;
    CFNumberRef v11 = "MTSimpleHIDManager::";
    __int16 v12 = 2080;
    CFNumberRef v13 = "setupBootloadPowerAssertion";
    __int16 v14 = 2048;
    uint64_t v15 = v6;
    _os_log_impl(&dword_2406FB000, v5, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s [generation: %llu]", (uint8_t *)&v8, 0x2Au);
  }
  (*(void (**)(MTSimpleHIDManager *))(*(void *)this + 496))(this);
  return (*(uint64_t (**)(MTSimpleHIDManager *, uint64_t, void))(*(void *)this + 512))(this, a2, *((void *)this + 13));
}

void MTSimpleHIDManager::takeBootloadPowerAssertion(IOPMAssertionID *this)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v1 = (int *)(this + 22);
  IOReturn v2 = IOPMAssertionCreateWithName(@"PreventUserIdleSystemSleep", 0xFFu, @"MT.bootload", this + 22);
  unsigned int v3 = MTLoggingPlugin();
  uint64_t v4 = v3;
  if (v2)
  {
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v5 = *v1;
    int v11 = 136316162;
    __int16 v12 = "[Error] ";
    __int16 v13 = 2080;
    __int16 v14 = "MTSimpleHIDManager::";
    __int16 v15 = 2080;
    uint64_t v16 = "takeBootloadPowerAssertion";
    __int16 v17 = 1024;
    int v18 = v5;
    __int16 v19 = 1024;
    IOReturn v20 = v2;
    uint64_t v6 = "[HID] [MT] %s%s%s Failed to take power assertion %u: 0x%08x";
    CFNumberType v7 = v4;
    os_log_type_t v8 = OS_LOG_TYPE_ERROR;
    uint32_t v9 = 44;
  }
  else
  {
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v10 = *v1;
    int v11 = 136315906;
    __int16 v12 = "";
    __int16 v13 = 2080;
    __int16 v14 = "MTSimpleHIDManager::";
    __int16 v15 = 2080;
    uint64_t v16 = "takeBootloadPowerAssertion";
    __int16 v17 = 1024;
    int v18 = v10;
    uint64_t v6 = "[HID] [MT] %s%s%s Took power assertion %u";
    CFNumberType v7 = v4;
    os_log_type_t v8 = OS_LOG_TYPE_DEFAULT;
    uint32_t v9 = 38;
  }
  _os_log_impl(&dword_2406FB000, v7, v8, v6, (uint8_t *)&v11, v9);
}

void MTSimpleHIDManager::releaseBootloadPowerAssertion(MTSimpleHIDManager *this)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  IOPMAssertionID v2 = *((_DWORD *)this + 22);
  if (v2)
  {
    IOReturn v3 = IOPMAssertionRelease(v2);
    uint64_t v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *((_DWORD *)this + 22);
      int v6 = 136316162;
      CFNumberType v7 = "";
      __int16 v8 = 2080;
      uint32_t v9 = "MTSimpleHIDManager::";
      __int16 v10 = 2080;
      int v11 = "releaseBootloadPowerAssertion";
      __int16 v12 = 1024;
      int v13 = v5;
      __int16 v14 = 1024;
      IOReturn v15 = v3;
      _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Released power assertion %u: 0x%08x", (uint8_t *)&v6, 0x2Cu);
    }
    *((_DWORD *)this + 22) = 0;
  }
}

void MTSimpleHIDManager::startBootloadPowerAssertionTimer(dispatch_queue_t *this, unsigned int a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  dispatch_source_t v6 = dispatch_source_create(MEMORY[0x263EF8400], 0, 0, this[21]);
  this[12] = v6;
  if (v6)
  {
    CFNumberType v7 = v6;
    dispatch_time_t v8 = dispatch_time(0, (uint64_t)((double)a2 * 1000000000.0));
    dispatch_source_set_timer(v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0);
    uint32_t v9 = this[12];
    v11[0] = MEMORY[0x263EF8330];
    v11[1] = 0x40000000;
    v11[2] = ___ZN18MTSimpleHIDManager32startBootloadPowerAssertionTimerEjy_block_invoke;
    v11[3] = &__block_descriptor_tmp_318;
    v11[4] = this;
    v11[5] = a3;
    dispatch_source_set_event_handler(v9, v11);
    dispatch_resume(this[12]);
    __int16 v10 = MTLoggingPlugin();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      int v13 = "";
      __int16 v14 = 2080;
      IOReturn v15 = "MTSimpleHIDManager::";
      __int16 v16 = 2080;
      __int16 v17 = "startBootloadPowerAssertionTimer";
      __int16 v18 = 1024;
      unsigned int v19 = a2;
      _os_log_impl(&dword_2406FB000, v10, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Started bootload power assertion timer (%us)", buf, 0x26u);
    }
  }
}

void ___ZN18MTSimpleHIDManager32startBootloadPowerAssertionTimerEjy_block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  IOPMAssertionID v2 = *(void **)(a1 + 32);
  IOReturn v3 = MTLoggingPlugin();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = v2[13];
    int v7 = 136316162;
    dispatch_time_t v8 = "[Error] ";
    __int16 v9 = 2080;
    __int16 v10 = "MTSimpleHIDManager::";
    __int16 v11 = 2080;
    __int16 v12 = "startBootloadPowerAssertionTimer_block_invoke";
    __int16 v13 = 2048;
    uint64_t v14 = v4;
    __int16 v15 = 2048;
    uint64_t v16 = v5;
    _os_log_impl(&dword_2406FB000, v3, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Bootload timer expired [generation = %llu, _bootloadPowerAssertion.generation = %llu]", (uint8_t *)&v7, 0x34u);
  }
  if (*(void *)(a1 + 40) == v2[13])
  {
    (*(void (**)(void *))(*v2 + 488))(v2);
    uint64_t v6 = v2[14];
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
    }
  }
}

void MTSimpleHIDManager::cancelBootloadPowerAssertionTimer(dispatch_source_t *this)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (this[12])
  {
    IOPMAssertionID v2 = MTLoggingPlugin();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = 136315650;
      uint64_t v4 = "";
      __int16 v5 = 2080;
      uint64_t v6 = "MTSimpleHIDManager::";
      __int16 v7 = 2080;
      dispatch_time_t v8 = "cancelBootloadPowerAssertionTimer";
      _os_log_impl(&dword_2406FB000, v2, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Cancelling bootload power assertion timer", (uint8_t *)&v3, 0x20u);
    }
    dispatch_source_cancel(this[12]);
    dispatch_release(this[12]);
    this[12] = 0;
  }
}

_DWORD *MTSimpleHIDManager::updateFieldDetectStatus(_DWORD *result, int a2)
{
  if (result[41] != a2)
  {
    result[41] = a2;
    return (_DWORD *)(*(uint64_t (**)(void))(*(void *)result + 368))();
  }
  return result;
}

uint64_t MTSimpleHIDManager::setWristState(MTSimpleHIDManager *this)
{
  return 0;
}

uint64_t MTSimpleHIDManager::setInputDetectionModeForOrientation(MTSimpleHIDManager *this, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)this + 80))(this);

  return MEMORY[0x270F4C720](v5, a2, a3);
}

const char *MTSimpleHIDManager::getName(MTSimpleHIDManager *this)
{
  return "MTSimpleHIDManager";
}

uint64_t MTSimpleHIDManager::getHIDService(MultitouchHIDClass **this)
{
  return MultitouchHIDClass::getHIDService(this[2]);
}

void *MTSimpleHIDManager::setEventCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = *(void **)(a1 + 32);
  if (result) {
    return MTSimpleEventDispatcher::setEventCallback(result, a2, a3, a4);
  }
  return result;
}

double MTSimpleHIDManager::getSurfacePixelDimensions(MTSimpleHIDManager *this)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v1 = MTLoggingPlugin();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315650;
    uint64_t v4 = "[Error] ";
    __int16 v5 = 2080;
    uint64_t v6 = "MTSimpleHIDManager::";
    __int16 v7 = 2080;
    dispatch_time_t v8 = "getSurfacePixelDimensions";
    _os_log_impl(&dword_2406FB000, v1, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s using getSurfacePixelDimensions()", (uint8_t *)&v3, 0x20u);
  }
  return 320.0;
}

double MTSimpleHIDManager::getSurfaceBounds_mm(MTSimpleHIDManager *this)
{
  return 0.0;
}

uint64_t MTSimpleHIDManager::handleFullFrame(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(result + 124)) {
    return MEMORY[0x270F4C6B0](a2, a3, a4);
  }
  return result;
}

uint64_t MTSimpleHIDManager::handleContactFrameEntry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, double a7)
{
  kdebug_trace();
  uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __n128))(*(void *)a1 + 192);
  v15.n128_f64[0] = a7;

  return v14(a1, a2, a3, a4, a5, a6, v15);
}

uint64_t MTSimpleHIDManager::handleInputDetectionState(unsigned char *a1, uint64_t a2, unsigned int a3, int a4, int a5)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  if (a1[122])
  {
    int v9 = a3 & 0x41 | (((a3 >> 5) & 1) << 8) | (a3 >> 2) & 0x200;
    mach_absolute_time();
    Proximtyuint64_t Event = IOHIDEventCreateProximtyEvent();
    if (ProximtyEvent)
    {
      __int16 v11 = (const void *)ProximtyEvent;
      (*(void (**)(unsigned char *, uint64_t, void))(*(void *)a1 + 136))(a1, ProximtyEvent, 0);
      __int16 v12 = MTLoggingPlugin();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        int v14 = 136316674;
        __n128 v15 = "";
        __int16 v16 = 2080;
        uint64_t v17 = "MTSimpleHIDManager::";
        __int16 v18 = 2080;
        unsigned int v19 = "handleInputDetectionState";
        __int16 v20 = 1024;
        int v21 = v9;
        __int16 v22 = 1024;
        unsigned int v23 = a3;
        __int16 v24 = 1024;
        int v25 = a4;
        __int16 v26 = 1024;
        int v27 = a5;
        _os_log_impl(&dword_2406FB000, v12, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Dispatching proximity event [0x%X] - detected inputs %u, receiver value %d, farfield value %d", (uint8_t *)&v14, 0x38u);
      }
      CFRelease(v11);
    }
  }
  return 1;
}

uint64_t MTSimpleHIDManager::handleExternalMessage(uint64_t a1, CFTypeRef cf, const void *a3, __int16 a4, unsigned int a5)
{
  if ((a4 & 0xFFFE) == 0x1000)
  {
    CFRetain(cf);
    global_queue = dispatch_get_global_queue(0, 0);
    block[0] = MEMORY[0x263EF8330];
    block[1] = 0x40000000;
    block[2] = ___ZN18MTSimpleHIDManager21handleExternalMessageEP10__MTDevicePhtj_block_invoke;
    block[3] = &__block_descriptor_tmp_320;
    block[4] = cf;
    dispatch_async(global_queue, block);
    return 0;
  }
  else
  {
    uint64_t result = (uint64_t)malloc_type_malloc(a5 + 2, 0xF8AE8F29uLL);
    if (result)
    {
      __int16 v12 = (void *)result;
      *(_WORD *)uint64_t result = a4;
      memcpy((void *)(result + 2), a3, a5);
      mach_absolute_time();
      uint64_t VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
      if (VendorDefinedEvent)
      {
        int v14 = (const void *)VendorDefinedEvent;
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 136))(a1, VendorDefinedEvent, 0);
        CFRelease(v14);
      }
      free(v12);
      return 1;
    }
  }
  return result;
}

void ___ZN18MTSimpleHIDManager21handleExternalMessageEP10__MTDevicePhtj_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  int updated = MTDeviceUpdateDynamicCalibration();
  if (updated)
  {
    int v3 = updated;
    uint64_t v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 136315906;
      uint64_t v6 = "";
      __int16 v7 = 2080;
      dispatch_time_t v8 = "MTSimpleHIDManager::";
      __int16 v9 = 2080;
      __int16 v10 = "handleExternalMessage_block_invoke";
      __int16 v11 = 1024;
      int v12 = v3;
      _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s MTDeviceUpdateDynamicCalibration failed with error code 0x%X", (uint8_t *)&v5, 0x26u);
    }
  }
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

uint64_t MTSimpleHIDManager::handleFrameHeader()
{
  return 0;
}

uint64_t MTSimpleHIDManager::fieldSuspendedNotificationCenterCallback(MTSimpleHIDManager *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  return (*(uint64_t (**)(__CFNotificationCenter *, uint64_t))(*(void *)a2 + 456))(a2, 3);
}

uint64_t MTSimpleHIDManager::setOutputEvent(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t MTSimpleHIDManager::copyEvent(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t result = 0;
  uint64_t v19 = *MEMORY[0x263EF8340];
  if (a2 == 1 && a3)
  {
    IntegerBoolean Value = IOHIDEventGetIntegerValue();
    int v6 = IOHIDEventGetIntegerValue();
    if (IntegerValue != 65376) {
      return 0;
    }
    int v7 = v6;
    dispatch_time_t v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 136316162;
      __int16 v10 = "";
      __int16 v11 = 2080;
      int v12 = "MTSimpleHIDManager::";
      __int16 v13 = 2080;
      int v14 = "copyEvent";
      __int16 v15 = 1024;
      int v16 = 65376;
      __int16 v17 = 1024;
      int v18 = v7;
      _os_log_impl(&dword_2406FB000, v8, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s copyEvent requested for usagePage: %u, usage: %u", (uint8_t *)&v9, 0x2Cu);
    }
    if (v7 == 9)
    {
      LOBYTE(v9) = *(unsigned char *)(a1 + 127);
      mach_absolute_time();
      return IOHIDEventCreateVendorDefinedEvent();
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL MTSimpleHIDManager::touchFramesAllowed(MTSimpleHIDManager *this)
{
  uint64_t v1 = 128;
  if (!*((unsigned char *)this + 122)) {
    uint64_t v1 = 192;
  }
  return (*(_DWORD *)((char *)this + v1) - 256) < 0xFFFFFFFD;
}

uint64_t ___ZL23queryIOReporterChannelsj_block_invoke()
{
  return ~(IOReportChannelGetCategories() >> 4) & 0x10;
}

void MTTrackpadHIDManager::createManager()
{
}

void sub_24072AD10(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10A1C40E75266F5);
  _Unwind_Resume(a1);
}

uint64_t MTTrackpadHIDManager::initialize(MTModeSwitcher *a1, uint64_t a2, CFTypeRef cf, int a4, int a5)
{
  *((void *)a1 + 42) = 0;
  *((_WORD *)a1 + 104) = 0;
  *((unsigned char *)a1 + 210) = 0;
  *((void *)a1 + 35) = 0;
  if ((a4 - 1000) <= 0x3E7)
  {
    uint64_t v10 = (*(uint64_t (**)(MTModeSwitcher *))(*(void *)a1 + 848))(a1);
    (*(void (**)(MTModeSwitcher *, CFTypeRef, uint64_t))(*(void *)a1 + 856))(a1, cf, v10);
  }
  *((_DWORD *)a1 + 72) = 0;
  *((void *)a1 + 37) = 0;
  *((_DWORD *)a1 + 76) = 0;
  *((void *)a1 + 39) = 0;
  *((void *)a1 + 40) = 0;
  if (a4 == 2001 || a4 == 1001) {
    operator new();
  }

  return MTSimpleHIDManager::initialize(a1, a2, cf, a4, a5);
}

void sub_24072AE64(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10E1C406FE0ECE6);
  _Unwind_Resume(a1);
}

void MTTrackpadHIDManager::finalize(MTTrackpadHIDManager *this)
{
  uint64_t v2 = *((void *)this + 41);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    *((void *)this + 4MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = 0;
  }

  MTSimpleHIDManager::finalize(this);
}

void MTTrackpadHIDManager::setDeviceUsages(MTTrackpadHIDManager *this)
{
  MTSimpleHIDManager::setDeviceUsages(this);
  uint64_t v2 = (MTTrackpadHIDManager *)(*(uint64_t (**)(MTTrackpadHIDManager *, __CFString *))(*(void *)this + 560))(this, @"DeviceUsagePairs");
  if (v2)
  {
    int v3 = v2;
    MTTrackpadHIDManager::appendDeviceUsagePairs(v2, (__CFArray *)0xFF00, 1);
    MTTrackpadHIDManager::appendDeviceUsagePairs(v3, (__CFArray *)0xFF00, 12);
    MTTrackpadHIDManager::appendDeviceUsagePairs(v3, (__CFArray *)1, 1);
    MTTrackpadHIDManager::appendDeviceUsagePairs(v3, (__CFArray *)1, 2);
    MTTrackpadHIDManager::appendDeviceUsagePairs(v3, (__CFArray *)0xD, 5);
    MTSimpleHIDManager::setProperty(this, @"DeviceUsagePairs", v3, 1);
    CFRelease(v3);
  }
}

void MTTrackpadHIDManager::appendDeviceUsagePairs(MTTrackpadHIDManager *this, __CFArray *a2, int a3)
{
  int v11 = a3;
  int valuePtr = (int)a2;
  if (this)
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 2, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    CFNumberRef v6 = CFNumberCreate(v4, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v7 = CFNumberCreate(v4, kCFNumberSInt32Type, &v11);
    CFNumberRef v8 = v7;
    if (v6) {
      BOOL v9 = v7 == 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9 || Mutable == 0)
    {
      if (!v6)
      {
        if (!v7) {
          goto LABEL_13;
        }
        goto LABEL_12;
      }
    }
    else
    {
      CFDictionaryAddValue(Mutable, @"DeviceUsagePage", v6);
      CFDictionaryAddValue(Mutable, @"DeviceUsage", v8);
      CFArrayAppendValue(this, Mutable);
    }
    CFRelease(v6);
    if (!v8)
    {
LABEL_13:
      if (Mutable) {
        CFRelease(Mutable);
      }
      return;
    }
LABEL_12:
    CFRelease(v8);
    goto LABEL_13;
  }
}

uint64_t MTTrackpadHIDManager::stop(MTTrackpadHIDManager *this)
{
  uint64_t v2 = (const void *)*((void *)this + 43);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 43) = 0;
  }
  MTTrackpadHIDManager::unregisterForPowerNotifications((io_object_t *)this);
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 816))(this);

  return MTSimpleHIDManager::stop(this);
}

uint64_t MTTrackpadHIDManager::unregisterForPowerNotifications(io_object_t *this)
{
  uint64_t result = MTSimpleHIDManager::getHIDDispatchQueue((MTSimpleHIDManager *)this);
  if (result)
  {
    if (this[76])
    {
      IODeregisterForSystemPower(this + 76);
      this[76] = 0;
    }
    int v3 = (IONotificationPort *)*((void *)this + 37);
    if (v3)
    {
      IONotificationPortDestroy(v3);
      *((void *)this + 37) = 0;
    }
    uint64_t result = this[72];
    if (result)
    {
      uint64_t result = IOServiceClose(result);
      this[72] = 0;
    }
  }
  return result;
}

uint64_t MTTrackpadHIDManager::dispatchRelativePointerEvent(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 120))(a1);
  if (result)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)result + 152);
    return v2();
  }
  return result;
}

uint64_t MTTrackpadHIDManager::forwardRelativePointerData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a6 + 616))(a6, a1, a2, a3, a4, a5);
}

uint64_t MTTrackpadHIDManager::registerDeviceDataCallbacks(MTTrackpadHIDManager *this)
{
  MTSimpleHIDManager::registerDeviceDataCallbacks(this);
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
  MTRegisterRelativePointerCallback();
  uint64_t v2 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);

  return MEMORY[0x270F4C7D0](v2, MTTrackpadHIDManager::forwardButtonState, this);
}

uint64_t MTTrackpadHIDManager::forwardButtonState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a4 + 760))(a4, a1, a2, a3);
}

uint64_t MTTrackpadHIDManager::unregisterDeviceDataCallbacks(MTTrackpadHIDManager *this)
{
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
  MTUnregisterButtonStateCallback();

  return MTSimpleHIDManager::unregisterDeviceDataCallbacks(this);
}

void MTTrackpadHIDManager::createEventDispatcher(MTTrackpadHIDManager *this)
{
}

void MTTrackpadHIDManager::createGestureParser(MTTrackpadHIDManager *this)
{
  uint64_t v2 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
  MTParser::createParserForMTDevice(v2, *((_DWORD *)this + 39));
}

uint64_t MTTrackpadHIDManager::initializeGestureParser(MTTrackpadHIDManager *this)
{
  *((unsigned char *)this + 208) = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 648))(this);
  uint64_t v2 = *(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 672);

  return v2(this);
}

unsigned int *MTTrackpadHIDManager::destroyGestureParser(unsigned int **this)
{
  MTTrackpadHIDManager::cancelOutstandingTapAndAHalfCallbackTimer((MTTrackpadHIDManager *)this);
  (*((void (**)(unsigned int **))*this + 10))(this);
  MTDeviceSetPickButtonShouldSendSecondaryClick();
  uint64_t result = this[42];
  if (result)
  {
    uint64_t result = MTParser::release(result);
    this[42] = 0;
  }
  return result;
}

void MTTrackpadHIDManager::cancelOutstandingTapAndAHalfCallbackTimer(MTTrackpadHIDManager *this)
{
  uint64_t v1 = *((void *)this + 35);
  if (v1)
  {
    context = dispatch_get_context(*((dispatch_object_t *)this + 35));
    if (context)
    {
      free(context);
      uint64_t v1 = *((void *)this + 35);
    }
    dispatch_source_cancel(v1);
    dispatch_release(*((dispatch_object_t *)this + 35));
    *((void *)this + 35) = 0;
  }
}

uint64_t MTTrackpadHIDManager::getGestureParser(MTTrackpadHIDManager *this)
{
  return *((void *)this + 42);
}

__n128 MTTrackpadHIDManager::copyTipOffsetParameters@<Q0>(MTTrackpadHIDManager *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(*((void *)this + 42) + 64);
  long long v3 = *(_OWORD *)(v2 + 196);
  *(_OWORD *)a2 = *(_OWORD *)(v2 + 180);
  *(_OWORD *)(a2 + 16) = v3;
  __n128 result = *(__n128 *)(v2 + 212);
  long long v5 = *(_OWORD *)(v2 + 228);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v5;
  return result;
}

__n128 MTTrackpadHIDManager::setTipOffsetParameters(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 336) + 64);
  __n128 result = *(__n128 *)a2;
  long long v4 = *(_OWORD *)(a2 + 16);
  long long v5 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v2 + 228) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v2 + 212) = v5;
  *(_OWORD *)(v2 + 196) = v4;
  *(__n128 *)(v2 + 180) = result;
  return result;
}

MTParser *MTTrackpadHIDManager::resetGestureParser(MTTrackpadHIDManager *this, int a2, uint64_t a3, uint64_t a4)
{
  if (a2)
  {
    CFTypeRef v11 = 0;
    CFTypeRef cf = 0;
    uint64_t v5 = *((void *)this + 42);
    if (v5)
    {
      int v7 = (**(uint64_t (***)(void))(v5 + 80))();
      uint64_t v8 = *((void *)this + 42);
      if (v7) {
        *(unsigned char *)(v8 + 89) = 1;
      }
      MTParser::clear((void *)v8, (uint64_t)&cf, (uint64_t *)&v11, v6);
      if (cf)
      {
        (*(void (**)(MTTrackpadHIDManager *, CFTypeRef, void))(*(void *)this + 136))(this, cf, 0);
        CFRelease(cf);
      }
      if (v11)
      {
        (*(void (**)(MTTrackpadHIDManager *, CFTypeRef, void))(*(void *)this + 136))(this, v11, 0);
        CFRelease(v11);
      }
    }
  }
  else
  {
    BOOL v9 = (void *)*((void *)this + 42);
    if (v9) {
      MTParser::clear(v9, 0, 0, a4);
    }
  }
  __n128 result = (MTParser *)*((void *)this + 42);
  if (result)
  {
    if ((*((unsigned char *)this + 160) & 2) != 0) {
      return (MTParser *)MTParser::setDivingButtonState(result, 0);
    }
  }
  return result;
}

uint64_t MTTrackpadHIDManager::cancelCurrentTapAndAHalfDrag(MTTrackpadHIDManager *this)
{
  uint64_t result = *((void *)this + 42);
  if (result)
  {
    uint64_t result = (**(uint64_t (***)(void))(result + 80))();
    if (result) {
      *(unsigned char *)(*((void *)this + 42) + 89) = 1;
    }
  }
  return result;
}

uint64_t MTTrackpadHIDManager::startNotificationCenterMonitoring(dispatch_object_t *this, int a2)
{
  ((void (*)(dispatch_object_t *))(*this)[102].isa)(this);
  HIDDispatchQueue = MTSimpleHIDManager::getHIDDispatchQueue((MTSimpleHIDManager *)this);
  dispatch_source_t v5 = dispatch_source_create(MEMORY[0x263EF83E0], a2, 0x80000000uLL, HIDDispatchQueue);
  this[39] = v5;
  if (v5)
  {
    MTSimpleHIDManager::retain((uint64_t)this);
    uint64_t v6 = this[39];
    handler[0] = MEMORY[0x263EF8330];
    handler[1] = 0x40000000;
    handler[2] = ___ZN20MTTrackpadHIDManager33startNotificationCenterMonitoringEi_block_invoke;
    handler[3] = &__block_descriptor_tmp_1;
    handler[4] = this;
    dispatch_source_set_event_handler(v6, handler);
    int v7 = this[39];
    v10[0] = MEMORY[0x263EF8330];
    v10[1] = 0x40000000;
    v10[2] = ___ZN20MTTrackpadHIDManager33startNotificationCenterMonitoringEi_block_invoke_4;
    v10[3] = &__block_descriptor_tmp_5;
    v10[4] = this;
    dispatch_source_set_cancel_handler(v7, v10);
    dispatch_resume(this[39]);
  }
  uint64_t result = ((uint64_t (*)(dispatch_object_t *))(*this)[108].isa)(this);
  if (result)
  {
    BOOL v9 = (MTParser *)((uint64_t (*)(dispatch_object_t *))(*this)[108].isa)(this);
    return MTParser::alwaysGenerateNotificationCenterGestures(v9, *((unsigned __int8 *)this + 242));
  }
  return result;
}

uint64_t ___ZN20MTTrackpadHIDManager33startNotificationCenterMonitoringEi_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315650;
    dispatch_source_t v5 = "";
    __int16 v6 = 2080;
    int v7 = "MTTrackpadHIDManager::";
    __int16 v8 = 2080;
    BOOL v9 = "startNotificationCenterMonitoring_block_invoke";
    _os_log_impl(&dword_2406FB000, v2, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s NotificationCenter process died.", (uint8_t *)&v4, 0x20u);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 800))(v1);
}

unsigned int *___ZN20MTTrackpadHIDManager33startNotificationCenterMonitoringEi_block_invoke_4(uint64_t a1)
{
  return MTSimpleHIDManager::release(*(unsigned int **)(a1 + 32));
}

uint64_t MTTrackpadHIDManager::startNotificationCenterAltMonitoring(dispatch_object_t *this, int a2)
{
  ((void (*)(dispatch_object_t *))(*this)[103].isa)(this);
  HIDDispatchQueue = MTSimpleHIDManager::getHIDDispatchQueue((MTSimpleHIDManager *)this);
  dispatch_source_t v5 = dispatch_source_create(MEMORY[0x263EF83E0], a2, 0x80000000uLL, HIDDispatchQueue);
  this[40] = v5;
  if (v5)
  {
    MTSimpleHIDManager::retain((uint64_t)this);
    __int16 v6 = this[40];
    handler[0] = MEMORY[0x263EF8330];
    handler[1] = 0x40000000;
    handler[2] = ___ZN20MTTrackpadHIDManager36startNotificationCenterAltMonitoringEi_block_invoke;
    handler[3] = &__block_descriptor_tmp_6;
    handler[4] = this;
    dispatch_source_set_event_handler(v6, handler);
    int v7 = this[40];
    v10[0] = MEMORY[0x263EF8330];
    v10[1] = 0x40000000;
    v10[2] = ___ZN20MTTrackpadHIDManager36startNotificationCenterAltMonitoringEi_block_invoke_7;
    v10[3] = &__block_descriptor_tmp_8;
    v10[4] = this;
    dispatch_source_set_cancel_handler(v7, v10);
    dispatch_resume(this[40]);
  }
  uint64_t result = ((uint64_t (*)(dispatch_object_t *))(*this)[108].isa)(this);
  if (result)
  {
    BOOL v9 = (MTParser *)((uint64_t (*)(dispatch_object_t *))(*this)[108].isa)(this);
    return MTParser::alwaysGenerateNotificationCenterAltGestures(v9, *((unsigned __int8 *)this + 242));
  }
  return result;
}

uint64_t ___ZN20MTTrackpadHIDManager36startNotificationCenterAltMonitoringEi_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315650;
    dispatch_source_t v5 = "";
    __int16 v6 = 2080;
    int v7 = "MTTrackpadHIDManager::";
    __int16 v8 = 2080;
    BOOL v9 = "startNotificationCenterAltMonitoring_block_invoke";
    _os_log_impl(&dword_2406FB000, v2, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s NotificationCenterAlt process died.", (uint8_t *)&v4, 0x20u);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 808))(v1);
}

unsigned int *___ZN20MTTrackpadHIDManager36startNotificationCenterAltMonitoringEi_block_invoke_7(uint64_t a1)
{
  return MTSimpleHIDManager::release(*(unsigned int **)(a1 + 32));
}

uint64_t MTTrackpadHIDManager::stopNotificationCenterMonitoring(MTTrackpadHIDManager *this)
{
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 816))(this);
  uint64_t result = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 864))(this);
  if (result)
  {
    long long v3 = (MTParser *)(*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 864))(this);
    return MTParser::alwaysGenerateNotificationCenterGestures(v3, 0);
  }
  return result;
}

uint64_t MTTrackpadHIDManager::stopNotificationCenterAltMonitoring(MTTrackpadHIDManager *this)
{
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 824))(this);
  uint64_t result = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 864))(this);
  if (result)
  {
    long long v3 = (MTParser *)(*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 864))(this);
    return MTParser::alwaysGenerateNotificationCenterGestures(v3, 0);
  }
  return result;
}

void MTTrackpadHIDManager::cancelNotificationCenterSource(MTTrackpadHIDManager *this)
{
  uint64_t v2 = *((void *)this + 39);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 39));
    *((void *)this + 39) = 0;
  }
}

void MTTrackpadHIDManager::cancelNotificationCenterAltSource(MTTrackpadHIDManager *this)
{
  uint64_t v2 = *((void *)this + 40);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 40));
    *((void *)this + 40) = 0;
  }
}

uint64_t MTTrackpadHIDManager::getForceSourceForBehavior(MTTrackpadHIDManager *this, unsigned int a2)
{
  uint64_t v3 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this);
  if (a2 > 0x11) {
    return 0;
  }
  if (((1 << a2) & 0x31C22) != 0) {
    return 34;
  }
  if (a2 != 2) {
    return 0;
  }
  if (*(unsigned char *)(v3 + 6)) {
    return 134;
  }
  return 0;
}

uint64_t MTTrackpadHIDManager::getUserPrefs(uint64_t a1, void *a2)
{
  *a2 = &MTTrackpadHIDManager::getUserPrefs(mt_UserPreference const**)::prefs;
  return 32;
}

unint64_t MTTrackpadHIDManager::isUserPref(MTTrackpadHIDManager *this, const __CFString *a2, BOOL *a3)
{
  if (a3) {
    *a3 = 0;
  }
  if (!a2) {
    return 0;
  }
  uint64_t v10 = 0;
  unint64_t result = (*(uint64_t (**)(MTTrackpadHIDManager *, CFStringRef **))(*(void *)this + 840))(this, &v10);
  if (!result) {
    return result;
  }
  unint64_t v6 = result;
  unint64_t v7 = 0;
  if (CFStringCompare(a2, *v10, 0))
  {
    uint64_t v8 = 2;
    while (v6 - 1 != v7)
    {
      CFComparisonResult v9 = CFStringCompare(a2, v10[v8], 0);
      v8 += 2;
      ++v7;
      if (v9 == kCFCompareEqualTo)
      {
        unint64_t result = v6 > v7;
        if (a3) {
          goto LABEL_13;
        }
        return result;
      }
    }
    return 0;
  }
  unint64_t result = 1;
  if (a3) {
LABEL_13:
  }
    *a3 = (BOOL)v10[2 * v7 + 1];
  return result;
}

BOOL MTTrackpadHIDManager::shouldRecordProperty(MTTrackpadHIDManager *this, const __CFString *a2)
{
  return (MTTrackpadHIDManager::isUserPref(this, a2, 0) & 1) != 0
      || MTSimpleHIDManager::propertyTypeFromString((uint64_t)a2, v3) == 17;
}

uint64_t MTTrackpadHIDManager::setProperty(CFTypeRef *this, const __CFString *a2, const void *a3)
{
  kern_return_t v7;
  kern_return_t v8;
  NSObject *v9;
  BOOL v11;
  uint8_t buf[4];
  kern_return_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  int v16 = *MEMORY[0x263EF8340];
  CFTypeRef v11 = 0;
  if (MTTrackpadHIDManager::isUserPref((MTTrackpadHIDManager *)this, a2, &v11))
  {
    (*((void (**)(CFTypeRef *, const __CFString *, const void *))*this + 85))(this, a2, a3);
    (*((void (**)(CFTypeRef *))*this + 84))(this);
    if (v11)
    {
      (*((void (**)(CFTypeRef *))*this + 10))(this);
      io_registry_entry_t Service = MTDeviceGetService();
      unint64_t v7 = IORegistryEntrySetCFProperty(Service, @"TrackpadUserPreferences", this[43]);
      if (v7)
      {
        uint64_t v8 = v7;
        (*((void (**)(CFTypeRef *))*this + 10))(this);
        MTDeviceGetDeviceID();
        CFComparisonResult v9 = MTLoggingPlugin();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109376;
          __int16 v13 = v8;
          int v14 = 2048;
          __int16 v15 = 0;
          _os_log_impl(&dword_2406FB000, v9, OS_LOG_TYPE_ERROR, "Could not set trackpad user preferences on the driver 0x%08X (deviceID 0x%llX)", buf, 0x12u);
        }
      }
    }
  }
  return MTSimpleHIDManager::setProperty((CFDateFormatterRef *)this, a2, a3);
}

uint64_t MTTrackpadHIDManager::setPropertyInternal(MTSimpleHIDManager *a1, int a2, CFTypeRef cf, int a4)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  if (cf)
  {
    CFTypeID v8 = CFGetTypeID(cf);
    BOOL v9 = v8 == CFDictionaryGetTypeID();
  }
  else
  {
    BOOL v9 = 0;
  }
  HIDDispatchQueue = MTSimpleHIDManager::getHIDDispatchQueue(a1);
  switch(a2)
  {
    case 22:
      if (!v9) {
        goto LABEL_98;
      }
      Boolean Value = CFDictionaryGetValue((CFDictionaryRef)cf, @"AlwaysGenerateNotificationCenterGesture");
      CFNumberRef v12 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"ClientPID");
      if (!Value) {
        goto LABEL_98;
      }
      CFNumberRef v13 = v12;
      CFTypeID v14 = CFGetTypeID(Value);
      if (v14 == CFBooleanGetTypeID()
        && (Value == (const void *)*MEMORY[0x263EFFB40] ? (BOOL v15 = v13 == 0) : (BOOL v15 = 1),
            !v15 && (CFTypeID v16 = CFGetTypeID(v13), v16 == CFNumberGetTypeID())))
      {
        *(_DWORD *)int valuePtr = -1431655766;
        CFNumberGetValue(v13, kCFNumberSInt32Type, valuePtr);
        if (!HIDDispatchQueue) {
          return 0;
        }
        MTSimpleHIDManager::retain((uint64_t)a1);
        v71[0] = MEMORY[0x263EF8330];
        v71[1] = 0x40000000;
        v71[2] = ___ZN20MTTrackpadHIDManager19setPropertyInternalE18_MTHIDPropertyTypePKvb_block_invoke;
        v71[3] = &__block_descriptor_tmp_114;
        v71[4] = a1;
        int v72 = *(_DWORD *)valuePtr;
        __int16 v17 = v71;
      }
      else
      {
        CFTypeID v55 = CFGetTypeID(Value);
        if (v55 != CFBooleanGetTypeID() || Value != (const void *)*MEMORY[0x263EFFB38]) {
          goto LABEL_98;
        }
        if (!HIDDispatchQueue) {
          return 0;
        }
        MTSimpleHIDManager::retain((uint64_t)a1);
        v70[0] = MEMORY[0x263EF8330];
        v70[1] = 0x40000000;
        v70[2] = ___ZN20MTTrackpadHIDManager19setPropertyInternalE18_MTHIDPropertyTypePKvb_block_invoke_2;
        v70[3] = &__block_descriptor_tmp_115;
        v70[4] = a1;
        __int16 v17 = v70;
      }
      goto LABEL_89;
    case 23:
      if (!v9) {
        goto LABEL_98;
      }
      int v25 = CFDictionaryGetValue((CFDictionaryRef)cf, @"AlwaysGenerateNotificationCenterAltGesture");
      __int16 v26 = CFDictionaryGetValue((CFDictionaryRef)cf, @"ClientPID");
      if (!v25) {
        goto LABEL_98;
      }
      int v27 = v26;
      CFTypeID v28 = CFGetTypeID(v25);
      if (v28 == CFBooleanGetTypeID() && v25 == (const void *)*MEMORY[0x263EFFB40] && v27 != 0)
      {
        CFTypeID v30 = CFGetTypeID(v27);
        if (v30 == CFNumberGetTypeID())
        {
          *(_DWORD *)int valuePtr = -1431655766;
          CFNumberGetValue((CFNumberRef)v27, kCFNumberSInt32Type, valuePtr);
          if (!HIDDispatchQueue) {
            return 0;
          }
          MTSimpleHIDManager::retain((uint64_t)a1);
          v68[0] = MEMORY[0x263EF8330];
          v68[1] = 0x40000000;
          v68[2] = ___ZN20MTTrackpadHIDManager19setPropertyInternalE18_MTHIDPropertyTypePKvb_block_invoke_3;
          v68[3] = &__block_descriptor_tmp_119;
          v68[4] = a1;
          int v69 = *(_DWORD *)valuePtr;
          __int16 v17 = v68;
LABEL_89:
          dispatch_async(HIDDispatchQueue, v17);
          return 0;
        }
      }
      CFTypeID v56 = CFGetTypeID(v25);
      if (v56 == CFBooleanGetTypeID() && v25 == (const void *)*MEMORY[0x263EFFB38])
      {
        if (!HIDDispatchQueue) {
          return 0;
        }
        MTSimpleHIDManager::retain((uint64_t)a1);
        block[0] = MEMORY[0x263EF8330];
        block[1] = 0x40000000;
        block[2] = ___ZN20MTTrackpadHIDManager19setPropertyInternalE18_MTHIDPropertyTypePKvb_block_invoke_4;
        block[3] = &__block_descriptor_tmp_120;
        block[4] = a1;
        __int16 v17 = block;
        goto LABEL_89;
      }
LABEL_98:
      return MTSimpleHIDManager::setPropertyInternal((uint64_t *)a1, a2, cf, a4);
    case 27:
      if (cf)
      {
        CFTypeID v18 = CFGetTypeID(cf);
        *(_DWORD *)int valuePtr = 0;
        if (v18 == CFNumberGetTypeID())
        {
          if ((*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)a1 + 864))(a1))
          {
            if (CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, valuePtr))
            {
              uint64_t v19 = *(CFDictionaryRef **)((*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)a1 + 864))(a1)
                                        + 208);
              if (v19)
              {
                int v20 = *(_DWORD *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)a1 + 848))(a1) + 60);
                int v21 = *(unsigned __int8 *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)a1 + 848))(a1)
                                         + 64);
                if (*(void *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)a1 + 864))(a1) + 48))
                {
                  BOOL v22 = v21 != 0;
                  BOOL v23 = v20 == 0;
                  BOOL v24 = !*(unsigned char *)(*(void *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)a1 + 864))(a1)
                                              + 48)
                                  + 186)
                     || v23;
                  if (!v22 && !v24) {
                    MTActuatorManagement::actuateWaveformID(v19, *(int *)valuePtr, 1.0, 1.0);
                  }
                }
              }
            }
          }
        }
      }
      return 0;
    case 30:
      uint64_t result = *(void *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)a1 + 864))(a1) + 208);
      if (!result) {
        return result;
      }
      MTActuatorManagement::reloadActuations((MTActuatorManagement *)result);
      return 0;
    default:
      if ((a2 & 0xFFFFFFFE) != 0x1C)
      {
        switch(a2)
        {
          case 31:
            (*(void (**)(MTSimpleHIDManager *))(*(void *)a1 + 80))(a1);
            uint64_t result = MTDeviceSupportsForce();
            if (!result) {
              return result;
            }
            uint64_t v54 = *(void *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)a1 + 864))(a1) + 200);
            *(unsigned char *)(v54 + 216) = CFBooleanGetValue((CFBooleanRef)cf) != 0;
            return 1;
          case 32:
            (*(void (**)(MTSimpleHIDManager *))(*(void *)a1 + 80))(a1);
            uint64_t result = MTDeviceSupportsForce();
            if (!result) {
              return result;
            }
            int v61 = *(MTForceManagement **)((*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)a1 + 864))(a1)
                                        + 200);
            char v62 = CFBooleanGetValue((CFBooleanRef)cf) != 0;
            MTForceManagement::setDisableClickWaveformAdaptation(v61, v62);
            return 1;
          case 33:
            (*(void (**)(MTSimpleHIDManager *))(*(void *)a1 + 80))(a1);
            uint64_t result = MTDeviceSupportsForce();
            if (!result) {
              return result;
            }
            uint64_t v59 = *(void *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)a1 + 864))(a1) + 200);
            char v60 = CFBooleanGetValue((CFBooleanRef)cf) != 0;
            MTForceManagement::setDisableForceThresholdAdaptation(v59, v60);
            return 1;
          case 34:
            if (cf)
            {
              CFTypeID v63 = CFGetTypeID(cf);
              if (v63 == CFBooleanGetTypeID())
              {
                *((unsigned char *)a1 + 209) = *MEMORY[0x263EFFB40] == (void)cf;
                (*(void (**)(MTSimpleHIDManager *))(*(void *)a1 + 672))(a1);
              }
            }
            return 0;
          default:
            if (a2 != 17) {
              goto LABEL_98;
            }
            if (cf)
            {
              CFTypeID v57 = CFGetTypeID(cf);
              float v66 = 0.0;
              if (v57 == CFNumberGetTypeID()
                && CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, &v66)
                && (*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)a1 + 120))(a1))
              {
                int v58 = (MTTrackpadEventDispatcher *)(*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)a1 + 120))(a1);
                MTTrackpadEventDispatcher::setScrollMomentumDispatchRate(v58, v66);
                return 1;
              }
            }
            else
            {
              float v66 = 0.0;
            }
            CFIndex v64 = MTLoggingPlugin();
            uint64_t result = os_log_type_enabled(v64, OS_LOG_TYPE_ERROR);
            if (!result) {
              return result;
            }
            *(_DWORD *)int valuePtr = 136315650;
            *(void *)&valuePtr[4] = "[Error] ";
            *(_WORD *)&valuePtr[12] = 2080;
            *(void *)&valuePtr[14] = "MTTrackpadHIDManager::";
            *(_WORD *)&valuePtr[22] = 2080;
            *(void *)&valuePtr[24] = "setPropertyInternal";
            _os_log_impl(&dword_2406FB000, v64, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Could not perform set property on Scroll Momentum Dispatch Rate", valuePtr, 0x20u);
            break;
        }
        return 0;
      }
      (*(void (**)(MTSimpleHIDManager *))(*(void *)a1 + 80))(a1);
      int v32 = MTDeviceSupportsForce();
      uint64_t result = 0;
      if (cf)
      {
        if (v32)
        {
          uint64_t result = (*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)a1 + 864))(a1);
          if (result)
          {
            if (!*(unsigned char *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)a1 + 848))(a1) + 64))
            {
              CFTypeID v33 = CFGetTypeID(cf);
              if (v33 == CFDictionaryGetTypeID())
              {
                uint64_t v34 = *(void *)((*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)a1 + 864))(a1) + 200);
                float v66 = 0.0;
                CFNumberRef v35 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"Version");
                if (v35)
                {
                  CFNumberRef v36 = v35;
                  CFTypeID v37 = CFGetTypeID(v35);
                  if (v37 == CFNumberGetTypeID())
                  {
                    if (CFNumberGetValue(v36, kCFNumberSInt32Type, &v66))
                    {
                      if (LODWORD(v66) == 1)
                      {
                        CFArrayRef v38 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)cf, @"Behaviors");
                        CFArrayRef v39 = v38;
                        if (v38)
                        {
                          CFTypeID v40 = CFGetTypeID(v38);
                          if (v40 == CFArrayGetTypeID())
                          {
                            CFIndex Count = CFArrayGetCount(v39);
                            if (a2 == 28) {
                              MTForceBehaviorConfiguration::clearNonDefaultBehaviors((MTForceBehaviorConfiguration *)(v34 + 264));
                            }
                            if (Count >= 1)
                            {
                              CFIndex v42 = 0;
                              while (1)
                              {
                                CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v39, v42);
                                CFDictionaryRef v44 = ValueAtIndex;
                                if (!ValueAtIndex) {
                                  goto LABEL_68;
                                }
                                CFTypeID v45 = CFGetTypeID(ValueAtIndex);
                                if (v45 != CFDictionaryGetTypeID()) {
                                  goto LABEL_68;
                                }
                                CFNumberRef v46 = (const __CFNumber *)CFDictionaryGetValue(v44, @"BehaviorID");
                                CFNumberRef v47 = v46;
                                int v65 = -1431655766;
                                if (!v46) {
                                  goto LABEL_68;
                                }
                                CFTypeID v48 = CFGetTypeID(v46);
                                if (v48 != CFNumberGetTypeID() || !CFNumberGetValue(v47, kCFNumberSInt32Type, &v65)) {
                                  goto LABEL_68;
                                }
                                int v49 = (const void *)MTForceConfigCreate(v65, 0);
                                unsigned int Behavior = MTForceConfigGetBehavior((uint64_t)v49);
                                uint64_t v51 = (*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)a1 + 848))(a1);
                                if (Behavior > 0x11) {
                                  goto LABEL_76;
                                }
                                if (((1 << Behavior) & 0x31C22) == 0) {
                                  break;
                                }
                                int v52 = 34;
                                if (v49) {
                                  goto LABEL_62;
                                }
LABEL_68:
                                if (Count == ++v42) {
                                  return 0;
                                }
                              }
                              if (Behavior == 2)
                              {
                                if (*(unsigned char *)(v51 + 6)) {
                                  int v52 = 134;
                                }
                                else {
                                  int v52 = 0;
                                }
                                if (!v49) {
                                  goto LABEL_68;
                                }
LABEL_62:
                                if (v52)
                                {
                                  *(void *)&long long v53 = 0xAAAAAAAAAAAAAAAALL;
                                  *((void *)&v53 + MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = 0xAAAAAAAAAAAAAAAALL;
                                  long long v79 = v53;
                                  long long v80 = v53;
                                  long long v77 = v53;
                                  long long v78 = v53;
                                  long long v75 = v53;
                                  long long v76 = v53;
                                  *(_OWORD *)&valuePtr[16] = v53;
                                  long long v74 = v53;
                                  *(_OWORD *)int valuePtr = v53;
                                  forceBehaviorFromForceConfig((uint64_t)v49, v52, (uint64_t)valuePtr);
                                  if (a2 == 28) {
                                    MTForceBehaviorConfiguration::pushBehavior((MTForceBehaviorConfiguration *)(v34 + 264), (const MTForceBehavior *)valuePtr);
                                  }
                                  else {
                                    MTForceManagement::setOverrideBehavior((MTForceManagement *)v34, (const MTForceBehavior *)valuePtr);
                                  }
                                  MTForceBehavior::~MTForceBehavior((MTForceBehavior *)valuePtr);
                                }
                              }
                              else
                              {
LABEL_76:
                                if (!v49) {
                                  goto LABEL_68;
                                }
                              }
                              CFRelease(v49);
                              goto LABEL_68;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            return 0;
          }
        }
      }
      return result;
  }
}

void sub_24072CFC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

unsigned int *___ZN20MTTrackpadHIDManager19setPropertyInternalE18_MTHIDPropertyTypePKvb_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 32);
  (*(void (**)(unsigned int *, void))(*(void *)v1 + 784))(v1, *(unsigned int *)(a1 + 40));

  return MTSimpleHIDManager::release(v1);
}

unsigned int *___ZN20MTTrackpadHIDManager19setPropertyInternalE18_MTHIDPropertyTypePKvb_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 32);
  (*(void (**)(unsigned int *))(*(void *)v1 + 800))(v1);

  return MTSimpleHIDManager::release(v1);
}

unsigned int *___ZN20MTTrackpadHIDManager19setPropertyInternalE18_MTHIDPropertyTypePKvb_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 32);
  (*(void (**)(unsigned int *, void))(*(void *)v1 + 792))(v1, *(unsigned int *)(a1 + 40));

  return MTSimpleHIDManager::release(v1);
}

unsigned int *___ZN20MTTrackpadHIDManager19setPropertyInternalE18_MTHIDPropertyTypePKvb_block_invoke_4(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 32);
  (*(void (**)(unsigned int *))(*(void *)v1 + 808))(v1);

  return MTSimpleHIDManager::release(v1);
}

void forceBehaviorFromForceConfig(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  int Behavior = MTForceConfigGetBehavior(a1);
  int NumStages = MTForceConfigGetNumStages(a1);
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)a3 = v8;
  *(_OWORD *)(a3 + 16) = v8;
  *(_OWORD *)(a3 + 32) = v8;
  *(_OWORD *)(a3 + 48) = v8;
  *(_OWORD *)(a3 + 64) = v8;
  *(_OWORD *)(a3 + 80) = v8;
  *(_OWORD *)(a3 + 96) = v8;
  *(_OWORD *)(a3 + 112) = v8;
  *(_OWORD *)(a3 + 128) = v8;
  MTForceBehavior::MTForceBehavior((MTForceBehavior *)a3);
  *(unsigned char *)(a3 + 12) = MTForceConfigIsContinuous(a1);
  *(_DWORD *)a3 = Behavior;
  *(_DWORD *)(a3 + 4) = a2;
  if (NumStages)
  {
    for (int i = 0; i != NumStages; ++i)
    {
      float ThresholdsForStage = MTForceConfigGetThresholdsForStage(a1, i);
      float v12 = v11;
      uint64_t ActuationsForStage = MTForceConfigGetActuationsForStage(a1, i);
      MTForceBehavior::addStage((MTForceBehavior *)a3, i, ActuationsForStage, ThresholdsForStage, v12);
      if (MTForceConfigShouldSkipActivationForStage(a1, i)) {
        MTForceBehavior::addSkippedActivationStage((void *)a3, i);
      }
      if (MTForceConfigShouldSkipReleaseForStage(a1, i)) {
        MTForceBehavior::addSkippedReleaseStage((void *)a3, i);
      }
    }
  }
}

void sub_24072D2B4(_Unwind_Exception *a1)
{
  MTForceBehavior::~MTForceBehavior(v1);
  _Unwind_Resume(a1);
}

void MTForceBehavior::~MTForceBehavior(MTForceBehavior *this)
{
  uint64_t v2 = (void *)*((void *)this + 15);
  if (v2)
  {
    *((void *)this + 16) = v2;
    operator delete(v2);
  }
  CFStringRef v3 = (void *)*((void *)this + 12);
  if (v3)
  {
    *((void *)this + 13) = v3;
    operator delete(v3);
  }
  int v4 = (void *)*((void *)this + 9);
  if (v4)
  {
    *((void *)this + 10) = v4;
    operator delete(v4);
  }
  dispatch_source_t v5 = (void *)*((void *)this + 6);
  if (v5)
  {
    *((void *)this + 7) = v5;
    operator delete(v5);
  }
  unint64_t v6 = (void *)*((void *)this + 3);
  if (v6)
  {
    *((void *)this + 4) = v6;
    operator delete(v6);
  }
}

const char *MTTrackpadHIDManager::getName(MTTrackpadHIDManager *this)
{
  return "MTTrackpadHIDManager";
}

uint64_t MTTrackpadHIDManager::handleContactFrame(MTTrackpadHIDManager *this, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (*((double *)this + 18) == a2 && *((unsigned __int8 *)this + 152) == a6)
  {
    printf("%s: ignoring duplicate frame #%qu @ %f\n", "MTTrackpadHIDManager", a6, a2);
    return 0;
  }
  if (*((unsigned char *)this + 121)) {
    return 0;
  }
  *((double *)this + 18) = a2;
  *((unsigned char *)this + 152) = a6;
  MTTrackpadHIDManager::cancelOutstandingTapAndAHalfCallbackTimer(this);
  CFTypeRef v14 = 0;
  CFTypeRef cf = 0;
  double v13 = 0.0;
  kdebug_trace();
  uint64_t v12 = *((void *)this + 42);
  if (v12 && !*((unsigned char *)this + 208)) {
    MTParser::handleContactFrame(v12, a4, a5, a2, a6, (uint64_t)&cf, (uint64_t *)&v14, &v13);
  }
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 656))(this);
  if (v13 > 0.0) {
    MTTrackpadHIDManager::scheduleTapAndAHalfCallbackTimer((dispatch_object_t *)this, a2, v13);
  }
  if (cf)
  {
    (*(void (**)(MTTrackpadHIDManager *, CFTypeRef, void))(*(void *)this + 136))(this, cf, 0);
    CFRelease(cf);
  }
  if (v14)
  {
    (*(void (**)(MTTrackpadHIDManager *, CFTypeRef, void))(*(void *)this + 136))(this, v14, 0);
    CFRelease(v14);
  }
  kdebug_trace();
  return 1;
}

void MTTrackpadHIDManager::scheduleTapAndAHalfCallbackTimer(dispatch_object_t *this, double a2, double a3)
{
  MTTrackpadHIDManager::cancelOutstandingTapAndAHalfCallbackTimer((MTTrackpadHIDManager *)this);
  unint64_t v6 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
  *unint64_t v6 = a2;
  v6[1] = a3;
  *((void *)v6 + 2) = this;
  HIDDispatchQueue = MTSimpleHIDManager::getHIDDispatchQueue((MTSimpleHIDManager *)this);
  dispatch_source_t v8 = dispatch_source_create(MEMORY[0x263EF8400], 0, 0, HIDDispatchQueue);
  this[35] = v8;
  if (v8)
  {
    BOOL v9 = v8;
    dispatch_time_t v10 = dispatch_time(0, (uint64_t)(v6[1] * 1000000000.0));
    dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_set_context(this[35], v6);
    float v11 = this[35];
    handler[0] = MEMORY[0x263EF8330];
    handler[1] = 0x40000000;
    handler[2] = ___ZN20MTTrackpadHIDManager32scheduleTapAndAHalfCallbackTimerEdd_block_invoke;
    handler[3] = &__block_descriptor_tmp_134;
    handler[4] = this;
    dispatch_source_set_event_handler(v11, handler);
    dispatch_resume(this[35]);
  }
}

uint64_t MTTrackpadHIDManager::handleInputDetectionState()
{
  return 0;
}

uint64_t MTTrackpadHIDManager::handleNotificationEvent(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = 1;
  switch(a3)
  {
    case 5:
      (*(void (**)(uint64_t))(*(void *)a1 + 264))(a1);
      dispatch_source_t v5 = *(MTActuatorManagement **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 864))(a1) + 208);
      if (v5) {
        MTActuatorManagement::reclaimHostClickControl(v5);
      }
      goto LABEL_42;
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 14:
    case 15:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
      goto LABEL_10;
    case 12:
      goto LABEL_42;
    case 13:
      int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 648))(a1);
      if (*(unsigned __int8 *)(a1 + 208) == v8) {
        goto LABEL_42;
      }
      *(unsigned char *)(a1 + 208) = v8;
      (*(void (**)(uint64_t))(*(void *)a1 + 672))(a1);
      if (!*(unsigned char *)(a1 + 208)) {
        goto LABEL_42;
      }
      goto LABEL_30;
    case 16:
      uint64_t v9 = *(void *)(a1 + 336);
      if (v9)
      {
        uint64_t v10 = *(void *)(v9 + 48);
        if (v10)
        {
          MTAbsoluteTimeGetCurrent();
          *(void *)(v10 + 48) = v11;
          uint64_t v9 = *(void *)(a1 + 336);
        }
        if (*(int *)(v9 + 104) >= 2 && (**(unsigned int (***)(void))(v9 + 80))()) {
          *(unsigned char *)(*(void *)(a1 + 336) + 89) = 1;
        }
      }
      if (!(*(uint64_t (**)(uint64_t))(*(void *)a1 + 120))(a1)) {
        goto LABEL_9;
      }
      uint64_t v12 = (MTTrackpadEventDispatcher *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 120))(a1);
      if (!*((void *)v12 + 56)) {
        goto LABEL_9;
      }
      uint64_t v4 = 1;
      MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(v12, 1);
      goto LABEL_42;
    case 17:
      uint64_t v13 = *(void *)(a1 + 336);
      if (!v13) {
        goto LABEL_42;
      }
      uint64_t v14 = *(void *)(v13 + 48);
      if (v14)
      {
        MTAbsoluteTimeGetCurrent();
        *(void *)(v14 + 48) = v15;
      }
      goto LABEL_9;
    case 18:
      goto LABEL_7;
    case 19:
      goto LABEL_6;
    case 26:
      int v16 = *(unsigned __int8 *)(a1 + 121);
      uint64_t v4 = MTSimpleHIDManager::handleNotificationEvent((unsigned __int8 *)a1, a2, 26);
      int v17 = *(unsigned __int8 *)(a1 + 121);
      if (v17 != v16 && v17 != 0)
      {
LABEL_30:
        uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 120))(a1);
        if (v19) {
          (*(void (**)(uint64_t))(*(void *)v19 + 184))(v19);
        }
      }
      goto LABEL_42;
    case 27:
      uint64_t v20 = *(void *)(a1 + 336);
      if (v20)
      {
        int v21 = *(MTActuatorManagement **)(v20 + 208);
        if (v21) {
          MTActuatorManagement::systemActuationsEnabledChanged(v21);
        }
      }
      goto LABEL_42;
    case 28:
      BOOL v22 = *(MTParser **)(a1 + 336);
      if (v22) {
        MTParser::systemForceResponseEnabledChanged(v22);
      }
      goto LABEL_42;
    case 29:
      uint64_t v23 = *(void *)(a1 + 336);
      if (!v23) {
        goto LABEL_42;
      }
      char v24 = 1;
      goto LABEL_41;
    case 30:
      uint64_t v23 = *(void *)(a1 + 336);
      if (!v23) {
        goto LABEL_42;
      }
      char v24 = 0;
LABEL_41:
      MTParser::setHostClickControlEnabled(v23, v24);
      goto LABEL_42;
    default:
      if (a3 == 118)
      {
LABEL_7:
        *(_DWORD *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 848))(a1) + 40) = 0;
      }
      else
      {
        if (a3 != 119)
        {
LABEL_10:
          uint64_t v4 = MTSimpleHIDManager::handleNotificationEvent((unsigned __int8 *)a1, a2, a3);
          goto LABEL_42;
        }
LABEL_6:
        *(_DWORD *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 848))(a1) + 40) = 2;
      }
      (*(void (**)(uint64_t))(*(void *)a1 + 712))(a1);
      uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 80))(a1);
      uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 848))(a1);
      SaveSurfaceOrientationForDevice(v6, *(_DWORD *)(v7 + 40), 0);
LABEL_9:
      uint64_t v4 = 1;
LABEL_42:
      (*(void (**)(uint64_t))(*(void *)a1 + 656))(a1);
      return v4;
  }
}

void SaveSurfaceOrientationForDevice(uint64_t a1, int a2, int a3)
{
  if (!a1) {
    return;
  }
  IOHIDPreferencesSynchronize();
  int valuePtr = a2;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFNumberRef v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt32Type, &valuePtr);
  SavedNameForDevice = (const void *)mt_CreateSavedNameForDevice();
  CFDictionaryRef v8 = (const __CFDictionary *)IOHIDPreferencesCopy();
  if (v8)
  {
    CFDictionaryRef v9 = v8;
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(v5, 0, v8);
    CFRelease(v9);
LABEL_7:
    BOOL v11 = v6 != 0;
    if (v6) {
      BOOL v12 = SavedNameForDevice == 0;
    }
    else {
      BOOL v12 = 1;
    }
    if (!v12 && MutableCopy != 0)
    {
      CFTypeID v14 = CFGetTypeID(MutableCopy);
      if (v14 == CFDictionaryGetTypeID())
      {
        if (a3) {
          CFDictionaryRemoveValue(MutableCopy, SavedNameForDevice);
        }
        else {
          CFDictionarySetValue(MutableCopy, SavedNameForDevice, v6);
        }
        IOHIDPreferencesSet();
        IOHIDPreferencesSynchronize();
      }
      CFRelease(MutableCopy);
      CFRelease(SavedNameForDevice);
LABEL_27:
      CFRelease(v6);
      return;
    }
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
    goto LABEL_17;
  }
  if (!a3)
  {
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutable(v5, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    goto LABEL_7;
  }
  BOOL v11 = v6 != 0;
LABEL_17:
  if (SavedNameForDevice) {
    CFRelease(SavedNameForDevice);
  }
  if (v11) {
    goto LABEL_27;
  }
}

void MTTrackpadHIDManager::wasScheduledOnDispatchQueue(MTInputDeviceManagement **this, NSObject *a2)
{
  uint64_t v4 = *(MTActuatorManagement **)((*((uint64_t (**)(MTInputDeviceManagement **))*this + 108))(this) + 208);
  if (v4) {
    MTActuatorManagement::scheduleOnDispatchQueue(v4, a2);
  }
  CFAllocatorRef v5 = this[41];
  if (v5) {
    MTInputDeviceManagement::scheduleOnDispatchQueue(v5, a2);
  }
  MTSimpleHIDManager::wasScheduledOnDispatchQueue((MTSimpleHIDManager *)this, a2);

  MTTrackpadHIDManager::registerForPowerNotifications((MTTrackpadHIDManager *)this);
}

void MTTrackpadHIDManager::registerForPowerNotifications(MTTrackpadHIDManager *this)
{
  if (MTSimpleHIDManager::getHIDDispatchQueue(this))
  {
    io_connect_t v2 = IORegisterForSystemPower(this, (IONotificationPortRef *)this + 37, (IOServiceInterestCallback)MTTrackpadHIDManager::handlePowerNotification, (io_object_t *)this + 76);
    *((_DWORD *)this + 72) = v2;
    if (v2)
    {
      CFStringRef v3 = (IONotificationPort *)*((void *)this + 37);
      HIDDispatchQueue = MTSimpleHIDManager::getHIDDispatchQueue(this);
      IONotificationPortSetDispatchQueue(v3, HIDDispatchQueue);
    }
    else
    {
      puts("MultitouchHID::registerForSleepWakeNotifications() - IORegisterForSystemPower failed");
    }
  }
}

void MTTrackpadHIDManager::wasUnscheduledFromDispatchQueue(io_object_t *this, dispatch_queue_s *a2)
{
  MTTrackpadHIDManager::unregisterForPowerNotifications(this);
  MTSimpleHIDManager::wasUnscheduledFromDispatchQueue((NSObject **)this, a2);
  uint64_t v4 = (MTInputDeviceManagement *)*((void *)this + 41);
  if (v4) {
    MTInputDeviceManagement::unscheduleFromDispatchQueue(v4, (dispatch_queue_t)a2);
  }
  CFAllocatorRef v5 = *(MTActuatorManagement **)((*(uint64_t (**)(io_object_t *))(*(void *)this + 864))(this) + 208);
  if (v5)
  {
    MTActuatorManagement::unscheduleFromDispatchQueue(v5, (dispatch_queue_t)a2);
  }
}

void MTTrackpadHIDManager::handlePowerNotification(MTTrackpadHIDManager *this, void *a2, int a3, intptr_t notificationID, void *a5)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  if (this)
  {
    if (a3 != -536870288)
    {
      if (a3 != -536870272) {
        return;
      }
      uint64_t v7 = *((void *)this + 42);
      if (v7 && (**(unsigned int (***)(void))(v7 + 80))()) {
        *(unsigned char *)(*((void *)this + 42) + 89) = 1;
      }
    }
    IOReturn v8 = IOAllowPowerChange(*((_DWORD *)this + 72), notificationID);
    if (v8)
    {
      mach_error_t v9 = v8;
      uint64_t v10 = MTLoggingPlugin();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        int v11 = 136315906;
        BOOL v12 = "[Error] ";
        __int16 v13 = 2080;
        CFTypeID v14 = "MTTrackpadHIDManager::";
        __int16 v15 = 2080;
        int v16 = "handlePowerNotification";
        __int16 v17 = 2082;
        CFTypeID v18 = mach_error_string(v9);
        _os_log_impl(&dword_2406FB000, v10, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s IOAllowPowerChange failed with return %{public}s", (uint8_t *)&v11, 0x2Au);
      }
    }
  }
}

void ___ZN20MTTrackpadHIDManager32scheduleTapAndAHalfCallbackTimerEdd_block_invoke(uint64_t a1, dispatch_source_s *a2)
{
}

void MTTrackpadHIDManager::_tapAndAHalfTimerCallbackFunction(NSObject *this, dispatch_source_s *a2)
{
  context = dispatch_get_context(this);
  if (context)
  {
    CFStringRef v3 = (MTParser **)*((void *)context + 2);
    if (v3)
    {
      double v5 = *(double *)context;
      double v4 = *((double *)context + 1);
      MTTrackpadHIDManager::cancelOutstandingTapAndAHalfCallbackTimer(*((MTTrackpadHIDManager **)context + 2));
      CFTypeRef cf = 0;
      double v6 = v4 + v5;
      double v7 = MTParser::autoReleaseTapAndAHalfDrag(v3[42], &cf, v6);
      if (cf)
      {
        (*((void (**)(MTParser **, CFTypeRef, void))*v3 + 17))(v3, cf, 0);
        CFRelease(cf);
      }
      if (v7 > 0.0) {
        MTTrackpadHIDManager::scheduleTapAndAHalfCallbackTimer((MTTrackpadHIDManager *)v3, v6, v7);
      }
    }
  }
}

uint64_t MTTrackpadHIDManager::checkForDisablers(MTTrackpadHIDManager *this)
{
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
  if (!MTDeviceGetService()) {
    return 0;
  }
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
  io_registry_entry_t Service = MTDeviceGetService();
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(Service, @"DisablingMouseAttached", (CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
  io_registry_entry_t v5 = MTDeviceGetService();
  CFTypeRef v6 = IORegistryEntryCreateCFProperty(v5, @"DisablingMouseKeysEnabled", v3, 0);
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
  io_registry_entry_t v7 = MTDeviceGetService();
  CFTypeRef v8 = IORegistryEntryCreateCFProperty(v7, @"DisablerPresent", v3, 0);
  if (CFProperty
    && (CFTypeID v9 = CFGetTypeID(CFProperty), v9 == CFBooleanGetTypeID())
    && CFBooleanGetValue((CFBooleanRef)CFProperty)
    || v6 && (CFTypeID v10 = CFGetTypeID(v6), v10 == CFBooleanGetTypeID()) && CFBooleanGetValue((CFBooleanRef)v6)
    || v8 && (CFTypeID v11 = CFGetTypeID(v8), v11 == CFBooleanGetTypeID()) && CFBooleanGetValue((CFBooleanRef)v8))
  {
    uint64_t v12 = 1;
    if (!CFProperty) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  uint64_t v12 = 0;
  if (CFProperty) {
LABEL_15:
  }
    CFRelease(CFProperty);
LABEL_16:
  if (v6) {
    CFRelease(v6);
  }
  if (v8) {
    CFRelease(v8);
  }
  return v12;
}

BOOL mthid_CFGetBoolValueWithDefault(const void *a1, uint64_t a2)
{
  int valuePtr = 0;
  if (a1)
  {
    CFTypeID v3 = CFGetTypeID(a1);
    if (v3 == CFBooleanGetTypeID() && CFBooleanGetValue((CFBooleanRef)a1))
    {
      return 1;
    }
    else
    {
      CFTypeID v4 = CFGetTypeID(a1);
      return v4 == CFNumberGetTypeID()
          && CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, &valuePtr)
          && valuePtr != 0;
    }
  }
  return a2;
}

uint64_t mthid_CFGetUInt32ValueWithDefault(const void *a1, uint64_t a2)
{
  unsigned int valuePtr = 0;
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFNumberGetTypeID())
    {
      if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, &valuePtr) == 1) {
        return valuePtr;
      }
      else {
        return a2;
      }
    }
  }
  return a2;
}

BOOL mthid_CFDictionaryGetBoolValue(const __CFDictionary *a1, const __CFString *a2)
{
  return mthid_CFDictionaryGetBoolValueWithDefault(a1, a2, 0);
}

BOOL mthid_CFDictionaryGetBoolValueWithDefault(const __CFDictionary *a1, const __CFString *a2, uint64_t a3)
{
  if (!a1 || !a2) {
    return a3;
  }
  Boolean Value = CFDictionaryGetValue(a1, a2);

  return mthid_CFGetBoolValueWithDefault(Value, a3);
}

uint64_t mthid_CFDictionaryGetInt32Property(const __CFDictionary *a1, const __CFString *a2)
{
  return mthid_CFDictionaryGetInt32PropertyWithDefault(a1, a2, 0);
}

uint64_t mthid_CFDictionaryGetInt32PropertyWithDefault(const __CFDictionary *a1, const __CFString *a2, uint64_t a3)
{
  if (!a1 || !a2) {
    return a3;
  }
  Boolean Value = CFDictionaryGetValue(a1, a2);

  return mthid_CFGetUInt32ValueWithDefault(Value, a3);
}

unsigned char *MTTrackpadHIDManager::handlePendingConfigUpdate(unsigned char *this)
{
  if (this[210])
  {
    uint64_t v1 = this;
    this = (unsigned char *)(*(uint64_t (**)(unsigned char *))(*(void *)this + 664))(this);
    if (this)
    {
      io_connect_t v2 = *(uint64_t (**)(unsigned char *))(*(void *)v1 + 672);
      return (unsigned char *)v2(v1);
    }
  }
  return this;
}

BOOL MTTrackpadHIDManager::shouldUpdateHIDManagerConfig(MTTrackpadHIDManager *this)
{
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
  return !MTDeviceSupportsForce()
      || (uint64_t v2 = *((void *)this + 42)) == 0
      || (CFTypeID v3 = *(MTForceManagement **)(v2 + 200)) == 0
      || !MTForceManagement::isForceButtonActivated(v3);
}

void MTTrackpadHIDManager::updateHIDManagerConfig(MTTrackpadHIDManager *this)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if ((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 664))(this))
  {
    (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
    if (MTDeviceGetService())
    {
      uint64_t v2 = *((void *)this + 42);
      if (v2)
      {
        if (*(void *)(v2 + 72))
        {
          *((unsigned char *)this + 210) = 0;
          (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
          MTDeviceGetDeviceID();
          CFTypeID v3 = MTLoggingPlugin();
          if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 134217984;
            uint64_t v6 = 0;
            _os_log_impl(&dword_2406FB000, v3, OS_LOG_TYPE_DEBUG, "HID Manager updating config (deviceID 0x%llX)", buf, 0xCu);
          }
          (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 696))(this);
          (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 704))(this);
          (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 712))(this);
          (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 800))(this);
        }
      }
    }
  }
  else
  {
    (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
    MTDeviceGetDeviceID();
    CFTypeID v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v6 = 0;
      _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_DEBUG, "HID Manager has pending config update (deviceID 0x%llX)", buf, 0xCu);
    }
    *((unsigned char *)this + 210) = 1;
  }
}

void MTTrackpadHIDManager::determineSurfaceOrientationSettings(MTTrackpadHIDManager *this)
{
  if ((*((unsigned char *)this + 160) & 8) != 0)
  {
    uint64_t v2 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this);
    if (!(*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this))
    {
      *(_DWORD *)(v2 + 44) = 0;
      goto LABEL_19;
    }
    IOHIDPreferencesSynchronize();
    CFNumberRef v3 = (const __CFNumber *)IOHIDPreferencesCopy();
    int valuePtr = 0;
    AppBooleanint Value = MTPreferencesGetAppBooleanValue(@"ForceAutoOrientation", @"com.apple.MultitouchSupport", 0);
    if (v3 && (CFTypeID v5 = CFGetTypeID(v3), v5 == CFNumberGetTypeID()))
    {
      int Value = CFNumberGetValue(v3, kCFNumberSInt32Type, &valuePtr);
      if (valuePtr == 1 && Value != 0 || AppBooleanValue)
      {
        int v9 = 1;
        goto LABEL_15;
      }
    }
    else if (AppBooleanValue)
    {
      int v9 = 1;
      if (!v3) {
        goto LABEL_16;
      }
      goto LABEL_15;
    }
    int v9 = 0;
    if (!v3)
    {
LABEL_16:
      *(_DWORD *)(v2 + 44) = v9;
      if (v9)
      {
LABEL_20:
        if (!(*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this))
        {
          LODWORD(v15) = 0;
          goto LABEL_42;
        }
        IOHIDPreferencesSynchronize();
        SavedNameForDevice = (const void *)mt_CreateSavedNameForDevice();
        CFDictionaryRef v12 = (const __CFDictionary *)IOHIDPreferencesCopy();
        CFDictionaryRef v13 = v12;
        if (SavedNameForDevice) {
          BOOL v14 = v12 == 0;
        }
        else {
          BOOL v14 = 1;
        }
        if (v14)
        {
          LODWORD(v15) = 0;
          if (!v12)
          {
            if (!SavedNameForDevice) {
              goto LABEL_42;
            }
            goto LABEL_41;
          }
          goto LABEL_40;
        }
        CFTypeID v16 = CFGetTypeID(v12);
        if (v16 != CFDictionaryGetTypeID()) {
          goto LABEL_39;
        }
        CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(v13, SavedNameForDevice);
        CFNumberRef v15 = v17;
        int v20 = 0;
        if (!v17) {
          goto LABEL_40;
        }
        CFTypeID v18 = CFGetTypeID(v17);
        if (v18 == CFNumberGetTypeID() && CFNumberGetValue(v15, kCFNumberSInt32Type, &v20))
        {
          if ((v20 & 0xFFFFFFFD) != 0) {
            LODWORD(v15) = 0;
          }
          else {
            LODWORD(v15) = v20;
          }
        }
        else
        {
LABEL_39:
          LODWORD(v15) = 0;
        }
LABEL_40:
        CFRelease(v13);
        if (SavedNameForDevice) {
LABEL_41:
        }
          CFRelease(SavedNameForDevice);
LABEL_42:
        *(_DWORD *)(v2 + 40) = v15;
        return;
      }
LABEL_19:
      uint64_t v10 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
      SaveSurfaceOrientationForDevice(v10, 0, 1);
      goto LABEL_20;
    }
LABEL_15:
    CFRelease(v3);
    goto LABEL_16;
  }
}

const __CFDictionary *MTTrackpadHIDManager::setPreferenceDefaults(const __CFDictionary *result, uint64_t a2)
{
  if (a2)
  {
    CFDictionaryRef v2 = result;
    CFMutableDictionaryRef properties = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
    io_registry_entry_t Service = MTDeviceGetService();
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    if (IORegistryEntryCreateCFProperties(Service, &properties, (CFAllocatorRef)*MEMORY[0x263EFFB08], 0)) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = properties == 0;
    }
    if (!v5)
    {
      int Value = CFDictionaryGetValue(properties, @"TrackpadUserPreferences");
      if (Value || (int Value = CFDictionaryGetValue(properties, @"MultitouchPreferences")) != 0)
      {
        CFTypeID v7 = CFGetTypeID(Value);
        if (v7 == CFDictionaryGetTypeID())
        {
          CFTypeRef v8 = (const void *)*((void *)v2 + 43);
          if (v8) {
            CFRelease(v8);
          }
          *((void *)v2 + 43) = CFDictionaryCreateMutableCopy(v4, 0, (CFDictionaryRef)Value);
        }
      }
      CFRelease(properties);
    }
    uint64_t result = (const __CFDictionary *)*((void *)v2 + 43);
    if (result)
    {
      int v9 = CFDictionaryGetValue(result, @"USBMouseStopsTrackpad");
      BOOL v10 = mthid_CFGetBoolValueWithDefault(v9, 0);
      uint64_t result = (const __CFDictionary *)*((void *)v2 + 43);
      if (result)
      {
        CFTypeID v11 = CFDictionaryGetValue(result, @"MouseKeysStopsTrackpad");
        uint64_t result = (const __CFDictionary *)mthid_CFGetBoolValueWithDefault(v11, 0);
      }
      if ((v10 | result) == 1)
      {
        io_registry_entry_t v12 = MTDeviceGetService();
        return (const __CFDictionary *)IORegistryEntrySetCFProperty(v12, @"TrackpadUserPreferences", *((CFTypeRef *)v2 + 43));
      }
    }
  }
  return result;
}

void MTTrackpadHIDManager::updatePreferences(MTTrackpadHIDManager *this, const __CFString *a2, const void *a3)
{
  if (a3 && a2)
  {
    CFNumberRef v3 = (__CFDictionary *)*((void *)this + 43);
    if (v3) {
      CFDictionarySetValue(v3, a2, a3);
    }
  }
}

BOOL MTTrackpadHIDManager::determineHIDManagerSettings(MTTrackpadHIDManager *this)
{
  uint64_t v2 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this);
  CFDictionaryRef v3 = (const __CFDictionary *)*((void *)this + 43);
  if (v3)
  {
    int Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 43), @"TrackpadBasicMode");
    BOOL v5 = mthid_CFGetBoolValueWithDefault(Value, 0);
    *(_OWORD *)uint64_t v2 = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    *(_OWORD *)(v2 + 32) = 0u;
    *(_OWORD *)(v2 + 48) = 0u;
    *(_DWORD *)(v2 + 64) = 0;
    *(unsigned char *)uint64_t v2 = 1;
    if (v5)
    {
      *(_WORD *)(v2 + 12) = 257;
      uint64_t v6 = CFDictionaryGetValue(v3, @"TrackpadScroll");
      BOOL v7 = mthid_CFGetBoolValueWithDefault(v6, 0);
      BOOL v8 = 0;
      if (v7)
      {
        int v9 = CFDictionaryGetValue(v3, @"TrackpadHorizScroll");
        BOOL v8 = mthid_CFGetBoolValueWithDefault(v9, 0);
      }
      *(unsigned char *)(v2 + 14) = v8;
      *(unsigned char *)(v2 + 34) = v8;
    }
    else
    {
      CFTypeID v11 = CFDictionaryGetValue(v3, @"Clicking");
      BOOL v12 = mthid_CFGetBoolValueWithDefault(v11, 0);
      BOOL v13 = 0;
      *(unsigned char *)(v2 + MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v12;
      *(unsigned char *)(v2 + 37) = v12;
      if (v12)
      {
        BOOL v14 = CFDictionaryGetValue(v3, @"Dragging");
        BOOL v13 = mthid_CFGetBoolValueWithDefault(v14, 0);
      }
      *(unsigned char *)(v2 + 2) = v13;
      int v15 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 720))(this);
      if (v15)
      {
        CFTypeID v16 = CFDictionaryGetValue(v3, @"TrackpadThreeFingerDrag");
        LOBYTE(v15) = mthid_CFGetBoolValueWithDefault(v16, 0);
      }
      *(unsigned char *)(v2 + 5) = v15;
      CFNumberRef v17 = CFDictionaryGetValue(v3, @"DragLock");
      BOOL v18 = mthid_CFGetBoolValueWithDefault(v17, 0);
      BOOL v19 = 0;
      if (v18)
      {
        if (*(unsigned char *)(v2 + 2)) {
          BOOL v19 = 1;
        }
        else {
          BOOL v19 = *(unsigned char *)(v2 + 5) != 0;
        }
      }
      *(unsigned char *)(v2 + 3) = v19;
      int v20 = CFDictionaryGetValue(v3, @"TrackpadTwoFingerFromRightEdgeSwipeGesture");
      *(unsigned char *)(v2 + 30) = mthid_CFGetUInt32ValueWithDefault(v20, 3) == 3;
      int v21 = CFDictionaryGetValue(v3, @"TrackpadRightClick");
      *(unsigned char *)(v2 + 6) = mthid_CFGetBoolValueWithDefault(v21, 0);
      *(unsigned char *)(v2 + 3MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = *((unsigned char *)this + 209);
      int v22 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 728))(this);
      int v23 = 0;
      if (v22)
      {
        char v24 = CFDictionaryGetValue(v3, @"TrackpadCornerSecondaryClick");
        int v23 = mthid_CFGetUInt32ValueWithDefault(v24, 0);
      }
      *(_DWORD *)(v2 + 8) = v23;
      *(_WORD *)(v2 + 12) = 257;
      int v25 = CFDictionaryGetValue(v3, @"TrackpadScroll");
      BOOL v26 = mthid_CFGetBoolValueWithDefault(v25, 0);
      BOOL v27 = 0;
      if (v26)
      {
        CFTypeID v28 = CFDictionaryGetValue(v3, @"TrackpadHorizScroll");
        BOOL v27 = mthid_CFGetBoolValueWithDefault(v28, 0);
      }
      *(unsigned char *)(v2 + 14) = v27;
      CFArrayRef v29 = CFDictionaryGetValue(v3, @"TrackpadMomentumScroll");
      *(unsigned char *)(v2 + 32) = mthid_CFGetBoolValueWithDefault(v29, 0);
      CFTypeID v30 = CFDictionaryGetValue(v3, @"TrackpadPinch");
      *(unsigned char *)(v2 + 16) = mthid_CFGetBoolValueWithDefault(v30, 0);
      uint64_t v31 = CFDictionaryGetValue(v3, @"TrackpadRotate");
      *(unsigned char *)(v2 + 17) = mthid_CFGetBoolValueWithDefault(v31, 0);
      int v32 = CFDictionaryGetValue(v3, @"TrackpadTwoFingerDoubleTapGesture");
      *(unsigned char *)(v2 + 18) = mthid_CFGetUInt32ValueWithDefault(v32, 0) == 1;
      CFTypeID v33 = CFDictionaryGetValue(v3, @"TrackpadThreeFingerTapGesture");
      *(unsigned char *)(v2 + 19) = mthid_CFGetUInt32ValueWithDefault(v33, 2) == 2;
      uint64_t v34 = CFDictionaryGetValue(v3, @"HIDScrollZoomModifierMask");
      *(unsigned char *)(v2 + 35) = mthid_CFGetUInt32ValueWithDefault(v34, 0) != 0;
      (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 736))(this);
      CFNumberRef v35 = CFDictionaryGetValue(v3, @"TrackpadThreeFingerHorizSwipeGesture");
      *(unsigned char *)(v2 + 2MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = mthid_CFGetUInt32ValueWithDefault(v35, 0) == 1;
      CFNumberRef v36 = CFDictionaryGetValue(v3, @"TrackpadThreeFingerVertSwipeGesture");
      *(unsigned char *)(v2 + 20) = mthid_CFGetUInt32ValueWithDefault(v36, 0) == 1;
      CFTypeID v37 = CFDictionaryGetValue(v3, @"TrackpadThreeFingerHorizSwipeGesture");
      *(unsigned char *)(v2 + 25) = mthid_CFGetUInt32ValueWithDefault(v37, 0) == 2;
      CFArrayRef v38 = CFDictionaryGetValue(v3, @"TrackpadThreeFingerVertSwipeGesture");
      *(unsigned char *)(v2 + 24) = mthid_CFGetUInt32ValueWithDefault(v38, 0) == 2;
      CFArrayRef v39 = CFDictionaryGetValue(v3, @"TrackpadFourFingerHorizSwipeGesture");
      *(unsigned char *)(v2 + 23) = mthid_CFGetUInt32ValueWithDefault(v39, 0) == 1;
      CFTypeID v40 = CFDictionaryGetValue(v3, @"TrackpadFourFingerVertSwipeGesture");
      *(unsigned char *)(v2 + 22) = mthid_CFGetUInt32ValueWithDefault(v40, 0) == 1;
      int v41 = CFDictionaryGetValue(v3, @"TrackpadFourFingerHorizSwipeGesture");
      *(unsigned char *)(v2 + 27) = mthid_CFGetUInt32ValueWithDefault(v41, 0) == 2;
      CFIndex v42 = CFDictionaryGetValue(v3, @"TrackpadFourFingerVertSwipeGesture");
      *(unsigned char *)(v2 + 26) = mthid_CFGetUInt32ValueWithDefault(v42, 0) == 2;
      int v43 = CFDictionaryGetValue(v3, @"TrackpadFourFingerPinchGesture");
      *(unsigned char *)(v2 + 28) = mthid_CFGetUInt32ValueWithDefault(v43, 0) == 2;
      CFDictionaryRef v44 = CFDictionaryGetValue(v3, @"TrackpadFiveFingerPinchGesture");
      int v45 = mthid_CFGetUInt32ValueWithDefault(v44, 0);
      char v46 = 0;
      *(unsigned char *)(v2 + 29) = v45 == 2;
      if (*((_DWORD *)this + 39) != 1001) {
        char v46 = *(unsigned char *)(v2 + 14);
      }
      *(unsigned char *)(v2 + 34) = v46;
      CFNumberRef v47 = CFDictionaryGetValue(v3, @"FirstClickThreshold");
      *(_DWORD *)(v2 + 48) = mthid_CFGetUInt32ValueWithDefault(v47, 1);
      CFTypeID v48 = CFDictionaryGetValue(v3, @"SecondClickThreshold");
      *(_DWORD *)(v2 + 52) = mthid_CFGetUInt32ValueWithDefault(v48, 1);
      int v49 = CFDictionaryGetValue(v3, @"ActuationStrength");
      *(_DWORD *)(v2 + 56) = mthid_CFGetUInt32ValueWithDefault(v49, 1);
      int v50 = CFDictionaryGetValue(v3, @"ActuateDetents");
      *(_DWORD *)(v2 + 60) = mthid_CFGetUInt32ValueWithDefault(v50, 1);
      uint64_t v51 = CFDictionaryGetValue(v3, @"ForceSuppressed");
      *(unsigned char *)(v2 + 64) = mthid_CFGetBoolValueWithDefault(v51, 0);
    }
  }
  else
  {
    uint64_t v10 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
    (*(void (**)(MTTrackpadHIDManager *, uint64_t, uint64_t))(*(void *)this + 856))(this, v10, v2);
  }
  AppBooleanint Value = 1;
  if ((*((unsigned char *)this + 160) & 4) == 0) {
    AppBooleanint Value = MTPreferencesGetAppBooleanValue(@"ScrollMomentum", @"com.apple.MultitouchSupport", 0);
  }
  *(unsigned char *)(v2 + 33) = AppBooleanValue;
  *(unsigned char *)(v2 + 15) = 1;
  *(unsigned char *)(v2 + 4) = MTPreferencesGetAppBooleanValue(@"PointerInertia", @"com.apple.MultitouchSupport", 0);
  BOOL result = MTPreferencesGetAppBooleanValue(@"SymmetricZoom", @"com.apple.MultitouchSupport", 0);
  *(unsigned char *)(v2 + 36) = result;
  return result;
}

void MTTrackpadHIDManager::createPointClickTapDragCombo(MTTrackpadHIDManager *this, __CFDictionary *a2, const __CFString *a3, int a4, int a5, int a6, int a7, int a8)
{
  CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  CFMutableDictionaryRef v18 = CFDictionaryCreateMutable(v16, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (Mutable) {
    BOOL v19 = v18 == 0;
  }
  else {
    BOOL v19 = 1;
  }
  if (v19) {
    return;
  }
  int v20 = v18;
  if (*(unsigned char *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this) + 4)) {
    CFStringRef v21 = @"Momentum AccelOnlyIfSomeResting";
  }
  else {
    CFStringRef v21 = @"AccelOnlyIfSomeResting";
  }
  if (a6)
  {
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Point", @"Translate", @"Resting Accel Tracking", v21, 0, 0, 0, v26);
    int v22 = @"Primary Down";
LABEL_14:
    CFStringRef v23 = @"Tap";
    char v24 = Mutable;
    CFStringRef v25 = 0;
    CFStringRef v21 = 0;
LABEL_15:
    MTPListGestureConfig::addGestureToArray(v24, (__CFArray *)v22, v23, v25, v21, 0, 0, 0, v26);
    goto LABEL_16;
  }
  if (a5)
  {
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Point", @"Translate", @"Resting Accel Tracking", v21, 0, 0, 0, v26);
    int v22 = @"Click";
    goto LABEL_14;
  }
  if (a4)
  {
    int v22 = @"Point";
    CFStringRef v23 = @"Translate";
    CFStringRef v25 = @"Resting Accel Tracking";
    char v24 = Mutable;
    goto LABEL_15;
  }
LABEL_16:
  if (a7)
  {
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Click", @"DroppedFingerTap", 0, 0, 0, 0, 0, v26);
    if (!a8) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  if (a8) {
LABEL_18:
  }
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Zoom Toggle", @"DoubleTap", 0, 0, 0, 0, 0, v26);
LABEL_19:
  CFDictionaryAddValue(v20, @"Gestures", Mutable);
  CFDictionaryAddValue(v20, @"Transitions", @"ToMoreIfPause FromRestingPoint FromMoreFingers FromMoreWithSlightIntegrationDelay");
  CFDictionaryAddValue(a2, a3, v20);
  CFRelease(Mutable);

  CFRelease(v20);
}

void MTTrackpadHIDManager::createScrollZoomCombo(MTTrackpadHIDManager *this, __CFDictionary *a2, const __CFString *a3)
{
  uint64_t v6 = (unsigned char *)(*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this);
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  CFMutableDictionaryRef v9 = CFDictionaryCreateMutable(v7, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (Mutable) {
    BOOL v10 = v9 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10) {
    return;
  }
  CFTypeID v11 = v9;
  if (v6[15] && v6[14] || v6[35])
  {
    CFStringRef v12 = @"IfWidelySeparatedFingers AccelOnlyIfSomeResting";
  }
  else
  {
    CFStringRef v12 = @"IfWidelySeparatedFingers AccelOnlyIfSomeResting";
    if (!v6[16] && !v6[17]) {
      CFStringRef v12 = @"AccelOnlyIfSomeResting";
    }
  }
  MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Point", @"Translate", @"Resting Accel Tracking", v12, @"LockOnFirst", 0, 0, v19);
  int v13 = v6[12];
  if (v6[13])
  {
    if (*(unsigned char *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this) + 33)) {
      CFStringRef v14 = @"Momentum";
    }
    else {
      CFStringRef v14 = @"Repetitive";
    }
    if (v13) {
      CFStringRef v15 = @"Translate";
    }
    else {
      CFStringRef v15 = @"Horizontal";
    }
LABEL_27:
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Scroll", v15, @"Scrolling", v14, @"LockOnFirst", @"Category", @"TwoFingerScroll", v20);
    goto LABEL_28;
  }
  if (v6[12])
  {
    if (*(unsigned char *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this) + 33)) {
      CFStringRef v14 = @"Momentum";
    }
    else {
      CFStringRef v14 = @"Repetitive";
    }
    CFStringRef v15 = @"Vertical";
    goto LABEL_27;
  }
LABEL_28:
  if (v6[13] || v6[12]) {
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Scroll", @"Hold", 0, @"MayBegin", 0, @"Category", @"TwoFingerScroll", v20);
  }
  if (*(unsigned char *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this) + 30))
  {
    if (v6[31]) {
      CFStringRef v16 = @"Right";
    }
    else {
      CFStringRef v16 = @"Left";
    }
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Fluid Notification", v16, @"Edge Swipe", @"OnlyIfAllMoving OnlyFromEdge", @"LockOnFirstUntilPause", @"Category", @"TwoFingerScroll", v20);
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Fluid Notification", @"Horizontal", @"Edge Swipe", @"OnlyIfAllMoving", @"LockOnFirstUntilPause", @"Category", @"TwoFingerNotificationCenter", v21);
    if (*(unsigned char *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this) + 33)) {
      CFStringRef v17 = @"Momentum";
    }
    else {
      CFStringRef v17 = @"Repetitive";
    }
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Scroll", @"Vertical", @"Scrolling", v17, @"LockOnFirst", @"Category", @"TwoFingerNotificationCenter", v22);
  }
  if (v6[1] && v6[6]) {
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Secondary Click", @"Tap", 0, 0, 0, 0, 0, v20);
  }
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
  MTDeviceSetPickButtonShouldSendSecondaryClick();
  if (v6[16])
  {
    if (v6[17]) {
      CFStringRef v18 = @"Scale+Rotate";
    }
    else {
      CFStringRef v18 = @"Scale";
    }
    goto LABEL_48;
  }
  if (v6[17])
  {
    CFStringRef v18 = @"Rotate";
LABEL_48:
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Orientation", v18, @"Zooming", @"Repetitive", @"LockOnFirst", 0, 0, v20);
  }
  if (v6[18]) {
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Zoom Toggle", @"DoubleTap", 0, 0, 0, 0, 0, v20);
  }
  if (v6[37]) {
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Click", @"DroppedFingerTap", 0, 0, 0, 0, 0, v20);
  }
  CFDictionaryAddValue(v11, @"Gestures", Mutable);
  CFDictionaryAddValue(v11, @"Transitions", @"ToMoreIfPause ToFewerAfterSlightDelay FromRestingPoint FromFewerFingers FromMoreFingers FromMoreWithSlightIntegrationDelay");
  CFDictionarySetValue(a2, a3, v11);
  CFRelease(Mutable);

  CFRelease(v11);
}

void MTTrackpadHIDManager::createRestingSwipeOrDockCombo(_DWORD *a1, __CFDictionary *a2, const void *a3, int a4, int a5, int a6, int a7, int a8, unsigned __int8 a9, unsigned __int8 a10, unsigned __int8 a11, unsigned __int8 a12, unsigned __int8 a13, char a14)
{
  CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  CFMutableDictionaryRef v18 = CFDictionaryCreateMutable(v16, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (Mutable) {
    BOOL v19 = v18 == 0;
  }
  else {
    BOOL v19 = 1;
  }
  if (v19) {
    return;
  }
  theDict = v18;
  if (a5) {
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Click", @"DroppedFingerTap", 0, 0, 0, 0, 0, v34);
  }
  int v20 = a1;
  int v21 = a8;
  if (a1[39] != 1001)
  {
    if (*(unsigned char *)((*(uint64_t (**)(_DWORD *))(*(void *)a1 + 848))(a1) + 4)) {
      CFStringRef v22 = @"Momentum OnlyIfOneMoving AccelOnlyIfSomeResting";
    }
    else {
      CFStringRef v22 = @"OnlyIfOneMoving AccelOnlyIfSomeResting";
    }
    MutableCFDictionaryRef Copy = CFStringCreateMutableCopy(v16, 256, v22);
    CFStringRef v24 = MutableCopy;
    if ((a8 & 1) == 0 && (a9 & 1) == 0 && (a10 & 1) == 0 && (a11 & 1) == 0 && (a12 & 1) == 0 && (a6 & 1) == 0) {
      CFStringAppend(MutableCopy, @" OnlyIfAllMoving");
    }
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Point", @"Translate", @"Resting Accel Tracking", v24, @"LockOnFirst", 0, 0, v34);
    CFRelease(v24);
    int v20 = a1;
  }
  if ((a6 & 1) != 0 || a7)
  {
    if (*(unsigned char *)((*(uint64_t (**)(_DWORD *))(*(void *)v20 + 848))(v20) + 33)) {
      CFStringRef v25 = @"Momentum";
    }
    else {
      CFStringRef v25 = @"Repetitive";
    }
    BOOL v26 = CFStringCreateMutableCopy(v16, 256, v25);
    BOOL v27 = v26;
    int v28 = a10 | a11 | a9;
    if (a7)
    {
      CFStringAppend(v26, @" OnlyIfTwoMoving");
      if (((v28 | a6 ^ 1) & 1) == 0)
      {
        if (a4 == 5) {
          CFStringRef v29 = @" OnlyIfFourMoving";
        }
        else {
          CFStringRef v29 = @" OnlyIfAllMoving";
        }
        goto LABEL_33;
      }
    }
    else if (v28)
    {
      CFStringRef v29 = @" OnlyIfSomeMoving";
LABEL_33:
      CFStringAppend(v27, v29);
    }
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Scroll", @"Translate", @"Scrolling", v27, @"LockOnFirst", 0, 0, v34);
    CFRelease(v27);
    int v21 = a8;
  }
  if (a4 == 5) {
    CFStringRef v30 = @" OnlyIfFourMoving";
  }
  else {
    CFStringRef v30 = @" OnlyIfAllMoving";
  }
  if (v21 && !a10)
  {
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Fluid Navigation", @"Horizontal", @"Swipe", v30, @"LockOnFirstUntilPause", 0, 0, v34);
    int v31 = a13;
    int v32 = a12;
    if (!a9 || (a11 & 1) != 0) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }
  int v31 = a13;
  int v32 = a12;
  if (a9 && (a11 & 1) == 0)
  {
LABEL_45:
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Fluid Navigation", @"Vertical", @"Swipe", v30, @"LockOnFirstUntilPause", 0, 0, v34);
LABEL_46:
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Fluid Navigation", @"Tap", 0, 0, 0, 0, 0, v34);
  }
  if (a10)
  {
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Fluid Dock", @"Horizontal", @"Swipe", v30, @"LockOnFirstUntilPause", 0, 0, v34);
    if (!a11)
    {
LABEL_49:
      if (!v32) {
        goto LABEL_50;
      }
      goto LABEL_54;
    }
  }
  else if (!a11)
  {
    goto LABEL_49;
  }
  MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Fluid Dock", @"Vertical", @"Swipe", v30, @"LockOnFirstUntilPause", 0, 0, v34);
  if (!v32)
  {
LABEL_50:
    if (a10) {
      goto LABEL_56;
    }
    goto LABEL_55;
  }
LABEL_54:
  MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Fluid Dock", @"Scale", @"Polar Swipe", @" OnlyIfAllMoving", @"LockOnFirstUntilPause", 0, 0, v34);
  MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Fluid Dock", @"Rotate", @"Polar Swipe", @" OnlyIfAllMoving", @"LockOnFirstUntilPause", 0, 0, v35);
  if (a10)
  {
LABEL_56:
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Fluid Dock", @"Tap", 0, 0, 0, 0, 0, v34);
    goto LABEL_57;
  }
LABEL_55:
  if (a11) {
    goto LABEL_56;
  }
LABEL_57:
  if (v31) {
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Zoom Toggle", @"DoubleTap", 0, 0, 0, 0, 0, v34);
  }
  if (a14) {
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Show Definition", @"Tap", 0, 0, 0, 0, 0, v34);
  }
  if (a4 == 5)
  {
    CFTypeID v33 = @"IsRestingPoint";
  }
  else if ((a4 - 1) > 3)
  {
    CFTypeID v33 = @"ToMoreFingers FromFewerFingers ToFewerFingers FromMoreFingers FromMoreWithSlightIntegrationDelay";
  }
  else
  {
    CFTypeID v33 = off_2650D38B0[a4 - 1];
  }
  CFDictionaryAddValue(theDict, @"Transitions", v33);
  CFDictionaryAddValue(theDict, @"Gestures", Mutable);
  CFDictionaryAddValue(a2, a3, theDict);
  CFRelease(Mutable);

  CFRelease(theDict);
}

void MTTrackpadHIDManager::activateHIDManagerSettings(MTTrackpadHIDManager *this)
{
  uint64_t v2 = (const void *)(*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 624))(this);
  CFDictionaryRef v3 = (__CFDictionary *)(*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 632))(this);
  CFTypeRef cf = (CFTypeRef)(*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 640))(this);
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  BOOL v5 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  uint64_t v6 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  BOOL v8 = CFDictionaryCreateMutable(v4, 2, v5, v6);
  CFMutableDictionaryRef v9 = CFArrayCreateMutable(v4, 0, MEMORY[0x263EFFF70]);
  BOOL v10 = (unsigned __int8 *)(*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this);
  MTTrackpadHIDManager::createPointClickTapDragCombo(this, v3, @"1F Point, Click & Drag", *v10, v10[1], v10[2], v10[37], v10[16]);
  MTPListGestureConfig::addChordMappingToArray(v9, (__CFArray *)@"1 Finger", @"1F Point, Click & Drag", v11);
  if (*((_WORD *)v10 + 6) || v10[16] || v10[17] || v10[15] && v10[14] || v10[1] && v10[6])
  {
    CFStringRef v12 = @"Scroll, Zoom & Rotate, Secondary Click";
    MTTrackpadHIDManager::createScrollZoomCombo(this, v3, @"Scroll, Zoom & Rotate, Secondary Click");
  }
  else
  {
    CFStringRef v12 = @"Resting 2F Point";
    MTTrackpadHIDManager::createRestingSwipeOrDockCombo(this, v3, @"Resting 2F Point", 1, v10[37], 0, 0, 0, 0, 0, 0, 0, v10[18], 0);
  }
  MTPListGestureConfig::addChordMappingToArray(v9, (__CFArray *)@"2 Fingers", v12, v13);
  if (v10[5])
  {
    CFStringRef v15 = @"Drag & Click";
    goto LABEL_30;
  }
  if (v10[24] || v10[25]) {
    int v16 = 3;
  }
  else {
    int v16 = 0;
  }
  int v17 = v10[20];
  if (!v10[34])
  {
    int v18 = 0;
LABEL_28:
    int v19 = 0;
    goto LABEL_29;
  }
  if (!v10[20])
  {
    if (v10[21])
    {
      int v18 = 0;
    }
    else
    {
      if (v10[24]) {
        BOOL v20 = 1;
      }
      else {
        BOOL v20 = v10[25] != 0;
      }
      int v18 = !v20;
    }
    if (!v10[21])
    {
      if (v10[24]) {
        BOOL v49 = 1;
      }
      else {
        BOOL v49 = v10[25] != 0;
      }
      int v17 = 0;
      int v19 = !v49;
      goto LABEL_29;
    }
    int v17 = 0;
    goto LABEL_28;
  }
  int v18 = 0;
  int v19 = 0;
  int v17 = 1;
LABEL_29:
  CFStringRef v15 = @"Resting 3F Swipe";
  MTTrackpadHIDManager::createRestingSwipeOrDockCombo(this, v3, @"Resting 3F Swipe", v16, v10[37] != 0, v18, v19, v10[21], v17 != 0, v10[25], v10[24] != 0, 0, 0, v10[19]);
LABEL_30:
  MTPListGestureConfig::addChordMappingToArray(v9, (__CFArray *)@"3 Fingers", v15, v14);
  int v21 = v10[27];
  if (!v10[26])
  {
    int v22 = 1;
    if (!v10[27]) {
      goto LABEL_34;
    }
    int v21 = 1;
  }
  int v22 = 3;
LABEL_34:
  MTTrackpadHIDManager::createRestingSwipeOrDockCombo(this, v3, @"Resting 4F Dock Operations", v22, v10[37], v10[34], v10[34], v10[23], v10[22], v21 != 0, v10[26] != 0, v10[28], 0, 0);
  MTPListGestureConfig::addChordMappingToArray(v9, (__CFArray *)@"4 Fingers", @"Resting 4F Dock Operations", v23);
  MTTrackpadHIDManager::createRestingSwipeOrDockCombo(this, v3, @"Resting T4F Dock Operations", v22, v10[37], v10[34], v10[34], v10[23], v10[22], v10[27], v10[26], v10[29], 0, 0);
  MTPListGestureConfig::addChordMappingToArray(v9, (__CFArray *)@"4 Fingers + Thumb", @"Resting T4F Dock Operations", v24);
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 744))(this);
  CFDictionaryAddValue(v8, @"Chords", v9);
  CFDictionaryAddValue(Mutable, @"Right", v8);
  char v62 = 0;
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
  if (MTDeviceSupportsForce()) {
    *(unsigned char *)(*(void *)(*((void *)this + 42) + 200) + 597) = 1;
  }
  (*(void (**)(MTTrackpadHIDManager *, uint64_t))(*(void *)this + 592))(this, 1);
  MTParser::clear(*((void **)this + 42), 0, 0, v25);
  MTGestureConfig::clearAllChords(*(MTGestureConfig **)(*((void *)this + 42) + 72));
  MTPListGestureConfig::setMotionSensitivitiesDictionary(*(MTPListGestureConfig **)(*((void *)this + 42) + 72), v2);
  MTPListGestureConfig::setGestureSetsDictionary(*(MTPListGestureConfig **)(*((void *)this + 42) + 72), v3);
  MTPListGestureConfig::setActionEventsDictionary(*(MTPListGestureConfig **)(*((void *)this + 42) + 72), cf);
  MTPListGestureConfig::setChordMappingsDictionary(*(MTPListGestureConfig **)(*((void *)this + 42) + 72), Mutable);
  MTPListGestureConfig::parseCreateGestureConfig(*(MTPListGestureConfig **)(*((void *)this + 42) + 72), (const __CFString **)&v62);
  uint64_t v26 = *((void *)this + 42);
  BOOL v27 = *(unsigned char **)(v26 + 56);
  unsigned __int8 v28 = v10[30];
  if (v28)
  {
    unsigned __int8 v28 = v10[31] != 0;
    char v29 = v10[31] ^ 1;
  }
  else
  {
    char v29 = 0;
  }
  v27[136] = v29;
  v27[137] = v28;
  v27[138] = 0;
  v27[139] = v10[36];
  char v30 = *(unsigned char *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this) + 2);
  if (v30) {
    char v30 = *(unsigned char *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this) + 3) != 0;
  }
  *(unsigned char *)(v26 + 88) = v30;
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
  if (MTDeviceSupportsForce())
  {
    int v50 = Mutable;
    uint64_t v51 = v2;
    if (*((_DWORD *)v10 + 12) >= 3u) {
      unsigned int v31 = 1;
    }
    else {
      unsigned int v31 = *((_DWORD *)v10 + 12);
    }
    if (*((_DWORD *)v10 + 13) >= 3u) {
      int v32 = 1;
    }
    else {
      int v32 = *((_DWORD *)v10 + 13);
    }
    MTForceBehaviorConfiguration::clearBehaviors((MTForceBehaviorConfiguration *)(*(void *)(*((void *)this + 42)
                                                                                            + 200)
                                                                                + 264));
    if (v10[64]) {
      int v33 = 1;
    }
    else {
      int v33 = 5;
    }
    uint64_t v34 = MTForceConfigCreate(v33, 0);
    if (v34)
    {
      CFNumberRef v35 = (const void *)v34;
      *(void *)&long long v36 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v36 + MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)std::__split_buffer<int> __p = v36;
      long long v61 = v36;
      long long v58 = v36;
      *(_OWORD *)uint64_t v59 = v36;
      *(_OWORD *)CFTypeID v56 = v36;
      *(_OWORD *)CFTypeID v57 = v36;
      *(_OWORD *)uint64_t v54 = v36;
      long long v55 = v36;
      long long v53 = v36;
      forceBehaviorFromForceConfig(v34, 34, (uint64_t)&v53);
      MTForceBehaviorConfiguration::addDefaultBehavior((MTForceBehaviorConfiguration *)(*(void *)(*((void *)this + 42) + 200) + 264), (const MTForceBehavior *)&v53);
      CFRelease(v35);
      if (__p[1])
      {
        *(void **)&long long v61 = __p[1];
        operator delete(__p[1]);
      }
      if (v59[0])
      {
        v59[1] = v59[0];
        operator delete(v59[0]);
      }
      if (v57[1])
      {
        *(void **)&long long v58 = v57[1];
        operator delete(v57[1]);
      }
      if (v56[0])
      {
        v56[1] = v56[0];
        operator delete(v56[0]);
      }
      if (v54[1])
      {
        *(void **)&long long v55 = v54[1];
        operator delete(v54[1]);
      }
    }
    int v37 = *(unsigned __int8 *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this) + 6);
    uint64_t v38 = MTForceConfigCreate(2, 0);
    if (v38)
    {
      CFArrayRef v39 = (const void *)v38;
      if (v37)
      {
        *(void *)&long long v40 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v40 + MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)std::__split_buffer<int> __p = v40;
        long long v61 = v40;
        long long v58 = v40;
        *(_OWORD *)uint64_t v59 = v40;
        *(_OWORD *)CFTypeID v56 = v40;
        *(_OWORD *)CFTypeID v57 = v40;
        *(_OWORD *)uint64_t v54 = v40;
        long long v55 = v40;
        long long v53 = v40;
        forceBehaviorFromForceConfig(v38, 134, (uint64_t)&v53);
        MTForceBehaviorConfiguration::addDefaultBehavior((MTForceBehaviorConfiguration *)(*(void *)(*((void *)this + 42) + 200) + 264), (const MTForceBehavior *)&v53);
        if (__p[1])
        {
          *(void **)&long long v61 = __p[1];
          operator delete(__p[1]);
        }
        if (v59[0])
        {
          v59[1] = v59[0];
          operator delete(v59[0]);
        }
        if (v57[1])
        {
          *(void **)&long long v58 = v57[1];
          operator delete(v57[1]);
        }
        if (v56[0])
        {
          v56[1] = v56[0];
          operator delete(v56[0]);
        }
        if (v54[1])
        {
          *(void **)&long long v55 = v54[1];
          operator delete(v54[1]);
        }
      }
      CFRelease(v39);
    }
    LOBYTE(v53) = -86;
    (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
    BOOL v41 = (MTDeviceSupportsSilentClick() || (_BYTE)v53) && *((_DWORD *)v10 + 14) == 0;
    uint64_t v42 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 864))(this);
    MTForceManagement::setFirstStageClickPreference(*(void *)(v42 + 200), v31);
    uint64_t v43 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 864))(this);
    MTForceManagement::setSecondStageClickPreference(*(void *)(v43 + 200), v32);
    *(unsigned char *)(*(void *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 864))(this) + 200)
             + 593) = v41;
    *(unsigned char *)(*(void *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 864))(this) + 200)
             + 596) = v10[64];
    *(unsigned char *)(*(void *)(*((void *)this + 42) + 200) + 597) = 0;
    CFDictionaryRef v44 = *(MTActuatorManagement **)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 864))(this)
                                   + 208);
    uint64_t v45 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 864))(this);
    MTActuatorManagement::setFirmwareClicks(v44, v31, *(unsigned __int8 *)(*(void *)(v45 + 200) + 593));
    CFMutableDictionaryRef Mutable = v50;
    uint64_t v2 = v51;
  }
  if (v10[15]) {
    char v46 = (void *)MEMORY[0x263EFFB40];
  }
  else {
    char v46 = (void *)MEMORY[0x263EFFB38];
  }
  (*(void (**)(MTTrackpadHIDManager *, __CFString *, void))(*(void *)this + 568))(this, @"SupportsGestureScrolling", *v46);
  (*(void (**)(MTTrackpadHIDManager *, __CFString *, __CFString *))(*(void *)this + 568))(this, @"DeviceTypeHint", @"Trackpad");
  CFNumberRef v47 = CFArrayCreateMutable(v4, 0, MEMORY[0x263EFFF70]);
  CFTypeID v48 = v47;
  if (v10[15]) {
    CFArrayAppendValue(v47, @"Scroll");
  }
  if (v10[16]) {
    CFArrayAppendValue(v48, @"Scale");
  }
  if (v10[17]) {
    CFArrayAppendValue(v48, @"Rotate");
  }
  CFArrayAppendValue(v48, @"Translate");
  CFArrayAppendValue(v48, @"TapToClick");
  CFArrayAppendValue(v48, @"TwoFingersSecondaryClick");
  CFArrayAppendValue(v48, @"DragLock");
  CFArrayAppendValue(v48, @"DoubleTapToDrag");
  (*(void (**)(MTTrackpadHIDManager *, __CFString *, __CFArray *))(*(void *)this + 568))(this, @"SupportedGestures", v48);
  CFRelease(v48);
  if (v62)
  {
    CFShow(v62);
    CFRelease(v62);
    char v62 = 0;
  }
  CFRelease(v2);
  CFRelease(v3);
  CFRelease(cf);
  CFRelease(v9);
  CFRelease(v8);
  CFRelease(Mutable);
}

void sub_240730DCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  MTForceBehavior::~MTForceBehavior((MTForceBehavior *)va);
  _Unwind_Resume(a1);
}

uint64_t MTTrackpadHIDManager::updateEventDispatcherSettings(MTTrackpadHIDManager *this)
{
  uint64_t result = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 120))(this);
  if (result)
  {
    unsigned int v3 = *(_DWORD *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this) + 8);
    int v4 = *(_DWORD *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this) + 40);
    unsigned int v5 = v3 & 0xFFFFFFFA | 4;
    if ((v3 & 1) == 0) {
      unsigned int v5 = v3;
    }
    if ((v3 & 2) != 0) {
      unsigned int v5 = v5 & 0xFFFFFFF5 | 8;
    }
    if (v4 == 2) {
      unsigned int v6 = v5;
    }
    else {
      unsigned int v6 = v3;
    }
    uint64_t v7 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 120))(this);
    *(unsigned char *)(v7 + 432) = *(unsigned char *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this)
                                    + 6);
    *(_DWORD *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 120))(this) + 436) = v6;
    uint64_t v8 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 120))(this);
    char v9 = *(unsigned char *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this) + 33);
    if (v9) {
      char v9 = *(unsigned char *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this) + 32) != 0;
    }
    *(unsigned char *)(v8 + 532) = v9;
    uint64_t v10 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 120))(this);
    uint64_t result = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this);
    char v11 = *(unsigned char *)(result + 15);
    if (v11)
    {
      uint64_t result = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this);
      char v11 = *(unsigned char *)(result + 14) != 0;
    }
    *(unsigned char *)(v10 + 540) = v11;
  }
  return result;
}

BOOL MTTrackpadHIDManager::hwSupports3FDrag(MTTrackpadHIDManager *this)
{
  if ((*((unsigned char *)this + 160) & 2) != 0) {
    return 1;
  }
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
  io_registry_entry_t Service = MTDeviceGetService();
  CFBooleanRef CFProperty = (const __CFBoolean *)IORegistryEntryCreateCFProperty(Service, @"TrackpadThreeFingerDrag", (CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  if (!CFProperty) {
    return 0;
  }
  CFBooleanRef v3 = CFProperty;
  CFTypeID v4 = CFGetTypeID(CFProperty);
  BOOL v5 = v4 == CFBooleanGetTypeID() && CFBooleanGetValue(v3) != 0;
  CFRelease(v3);
  return v5;
}

BOOL MTTrackpadHIDManager::hwSupportsSecondaryClickCorners(MTTrackpadHIDManager *this)
{
  if ((*((unsigned char *)this + 160) & 2) != 0) {
    return 1;
  }
  (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
  io_registry_entry_t Service = MTDeviceGetService();
  CFBooleanRef CFProperty = (const __CFBoolean *)IORegistryEntryCreateCFProperty(Service, @"TrackpadSecondaryClickCorners", (CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  if (!CFProperty) {
    return 0;
  }
  CFBooleanRef v3 = CFProperty;
  CFTypeID v4 = CFGetTypeID(CFProperty);
  BOOL v5 = v4 == CFBooleanGetTypeID() && CFBooleanGetValue(v3) != 0;
  CFRelease(v3);
  return v5;
}

uint64_t MTTrackpadHIDManager::getTrackpadSettings(MTTrackpadHIDManager *this)
{
  return (uint64_t)this + 212;
}

uint64_t MTTrackpadHIDManager::initDefaultTrackpadSettings(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    *(_DWORD *)(a3 + 64) = 0;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 688))(result);
    *(unsigned char *)a3 = 1;
    *(void *)(a3 + 12) = 0x101010101010101;
    *(_DWORD *)(a3 + 24) = 16843009;
    *(_DWORD *)(a3 + 27) = 16843009;
    *(_WORD *)(a3 + 3MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = 256;
  }
  return result;
}

uint64_t MTTrackpadHIDManager::setPluginDefaultProperties(MTTrackpadHIDManager *this)
{
  MTSimpleHIDManager::setPluginDefaultProperties(this);
  if ((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this))
  {
    io_registry_entry_t Service = MTDeviceGetService();
    if (Service)
    {
      CFMutableDictionaryRef properties = 0;
      if (IORegistryEntryCreateCFProperties(Service, &properties, (CFAllocatorRef)*MEMORY[0x263EFFB08], 0)) {
        BOOL v3 = 1;
      }
      else {
        BOOL v3 = properties == 0;
      }
      if (!v3)
      {
        (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 832))(this);
        CFRelease(properties);
      }
    }
  }
  return (*(uint64_t (**)(MTTrackpadHIDManager *, __CFString *, void))(*(void *)this + 568))(this, @"MTEventSource", *MEMORY[0x263EFFB40]);
}

const void *MTTrackpadHIDManager::setDeviceAccelerationData(MTTrackpadHIDManager *this, CFDictionaryRef theDict)
{
  int Value = CFDictionaryGetValue(theDict, @"HIDScrollAccelerationType");
  if (Value) {
    (*(void (**)(MTTrackpadHIDManager *, __CFString *, const void *))(*(void *)this + 568))(this, @"HIDScrollAccelerationType", Value);
  }
  BOOL v5 = CFDictionaryGetValue(theDict, @"HIDPointerAccelerationType");
  if (v5) {
    (*(void (**)(MTTrackpadHIDManager *, __CFString *, const void *))(*(void *)this + 568))(this, @"HIDPointerAccelerationType", v5);
  }
  unsigned int v6 = CFDictionaryGetValue(theDict, @"HIDAccelCurves");
  if (v6) {
    (*(void (**)(MTTrackpadHIDManager *, __CFString *, const void *))(*(void *)this + 568))(this, @"HIDAccelCurves", v6);
  }
  uint64_t v7 = CFDictionaryGetValue(theDict, @"HIDScrollAccelCurves");
  if (v7) {
    (*(void (**)(MTTrackpadHIDManager *, __CFString *, const void *))(*(void *)this + 568))(this, @"HIDScrollAccelCurves", v7);
  }
  CFNumberRef v8 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"HIDPointerReportRate");
  if (v8)
  {
    CFNumberRef v9 = v8;
    unint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(v8, kCFNumberIntType, &valuePtr);
    (*(void (**)(MTTrackpadHIDManager *, __CFString *, const __CFNumber *))(*(void *)this + 568))(this, @"HIDPointerReportRate", v9);
  }
  uint64_t v10 = CFDictionaryGetValue(theDict, @"HIDScrollResolution");
  if (v10) {
    (*(void (**)(MTTrackpadHIDManager *, __CFString *, const void *))(*(void *)this + 568))(this, @"HIDScrollResolution", v10);
  }
  char v11 = CFDictionaryGetValue(theDict, @"HIDScrollAccelerationTable");
  if (v11) {
    (*(void (**)(MTTrackpadHIDManager *, __CFString *, const void *))(*(void *)this + 568))(this, @"HIDScrollAccelerationTable", v11);
  }
  CFStringRef v12 = CFDictionaryGetValue(theDict, @"HIDPointerAccelerationTable");
  if (v12) {
    (*(void (**)(MTTrackpadHIDManager *, __CFString *, const void *))(*(void *)this + 568))(this, @"HIDPointerAccelerationTable", v12);
  }
  CFStringRef v13 = CFDictionaryGetValue(theDict, @"HIDDisallowRemappingOfPrimaryClick");
  if (v13) {
    (*(void (**)(MTTrackpadHIDManager *, __CFString *, const void *))(*(void *)this + 568))(this, @"HIDDisallowRemappingOfPrimaryClick", v13);
  }
  uint64_t result = CFDictionaryGetValue(theDict, @"HIDPointerResolution");
  if (result) {
    return (const void *)(*(uint64_t (**)(MTTrackpadHIDManager *, __CFString *, const void *))(*(void *)this + 568))(this, @"HIDPointerResolution", result);
  }
  return result;
}

uint64_t MTTrackpadHIDManager::setDeviceDefaultProperties(MTTrackpadHIDManager *this)
{
  MTSimpleHIDManager::setDeviceDefaultProperties(this);
  uint64_t v2 = *(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 744);

  return v2(this);
}

uint64_t MTTrackpadHIDManager::restoreDevicePropertiesToDevice(MTTrackpadHIDManager *this)
{
  MTSimpleHIDManager::restoreDevicePropertiesToDevice(this);
  uint64_t v2 = *(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 744);

  return v2(this);
}

void MTTrackpadHIDManager::activateDeviceSurfaceOrientation(dispatch_object_t *this)
{
  if (((_BYTE)this[20] & 8) != 0)
  {
    v7[0] = 0;
    v7[1] = v7;
    v7[2] = 0x2000000000;
    int v8 = -1431655766;
    int v8 = *(_DWORD *)(((uint64_t (*)(dispatch_object_t *))(*this)[106].isa)(this) + 40);
    v5[0] = 0;
    v5[1] = v5;
    v5[2] = 0x2000000000;
    int v6 = -1431655766;
    int v6 = *(_DWORD *)(((uint64_t (*)(dispatch_object_t *))(*this)[106].isa)(this) + 44);
    dispatch_retain(this[22]);
    dispatch_retain(this[23]);
    BOOL v3 = this[22];
    uint64_t v2 = this[23];
    block[0] = MEMORY[0x263EF8330];
    block[1] = 0x40000000;
    block[2] = ___ZN20MTTrackpadHIDManager32activateDeviceSurfaceOrientationEv_block_invoke;
    block[3] = &unk_2650D3890;
    void block[5] = v5;
    block[6] = this;
    block[4] = v7;
    dispatch_group_async(v2, v3, block);
    _Block_object_dispose(v5, 8);
    _Block_object_dispose(v7, 8);
  }
}

void sub_240731958(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void ___ZN20MTTrackpadHIDManager32activateDeviceSurfaceOrientationEv_block_invoke(void *a1)
{
  uint64_t v1 = (NSObject **)a1[6];
  ((void (*)(NSObject **, void, void))(*v1)[94].isa)(v1, *(unsigned int *)(*(void *)(a1[4] + 8) + 24), *(unsigned int *)(*(void *)(a1[5] + 8) + 24));
  dispatch_release(v1[23]);
  uint64_t v2 = v1[22];

  dispatch_release(v2);
}

void MTTrackpadHIDManager::_activateDeviceSurfaceOrientation(uint64_t a1, int a2, int a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  (*(void (**)(uint64_t))(*(void *)a1 + 80))(a1);
  int v6 = MTDeviceSetSurfaceOrientation();
  if (v6)
  {
    int v7 = v6;
    int v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v12 = 136316162;
      CFStringRef v13 = "[Error] ";
      __int16 v14 = 2080;
      CFStringRef v15 = "MTTrackpadHIDManager::";
      __int16 v16 = 2080;
      int v17 = "_activateDeviceSurfaceOrientation";
      __int16 v18 = 1024;
      int v19 = a2;
      __int16 v20 = 1024;
      int v21 = v7;
      _os_log_impl(&dword_2406FB000, v8, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s setting surface orientation to %d returned 0x%08X", (uint8_t *)&v12, 0x2Cu);
    }
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 80))(a1);
  int v9 = MTDeviceSetSurfaceOrientationMode();
  if (v9)
  {
    int v10 = v9;
    char v11 = MTLoggingPlugin();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = 136316162;
      CFStringRef v13 = "[Error] ";
      __int16 v14 = 2080;
      CFStringRef v15 = "MTTrackpadHIDManager::";
      __int16 v16 = 2080;
      int v17 = "_activateDeviceSurfaceOrientation";
      __int16 v18 = 1024;
      int v19 = a3;
      __int16 v20 = 1024;
      int v21 = v10;
      _os_log_impl(&dword_2406FB000, v11, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s setting surface orientation mode to %d returned 0x%08X", (uint8_t *)&v12, 0x2Cu);
    }
  }
}

uint64_t MTTrackpadHIDManager::handleButtonState(uint64_t a1, uint64_t a2, int a3)
{
  CFTypeID v4 = *(MTParser **)(a1 + 336);
  if (v4 && (*(unsigned char *)(a1 + 160) & 2) != 0) {
    MTParser::setDivingButtonState(v4, a3 != 0);
  }
  return 1;
}

uint64_t MTTrackpadHIDManager::forwardScreenSaverLaunchedNotification(MTTrackpadHIDManager *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  return (*(uint64_t (**)(__CFNotificationCenter *, MTTrackpadHIDManager *, __CFNotificationCenter *, void *, const __CFString *, const void *))(*(void *)a2 + 768))(a2, this, a2, a3, a4, a5);
}

uint64_t MTTrackpadHIDManager::handleScreenSaverLaunchedNotification(MTTrackpadHIDManager *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  uint64_t v7 = *((void *)this + 42);
  if (v7 && (**(unsigned int (***)(void))(v7 + 80))()) {
    *(unsigned char *)(*((void *)this + 42) + 89) = 1;
  }
  return 1;
}

uint64_t MTTrackpadHIDManager::forwardSurfaceOrientationChangedNotification(MTTrackpadHIDManager *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  return (*(uint64_t (**)(__CFNotificationCenter *, MTTrackpadHIDManager *, __CFNotificationCenter *, void *, const __CFString *, const void *))(*(void *)a2 + 776))(a2, this, a2, a3, a4, a5);
}

uint64_t MTTrackpadHIDManager::handleSurfaceOrientationChangedNotification(MTTrackpadHIDManager *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  return 1;
}

__CFDictionary *MTTrackpadHIDManager::createDefaultMotionSensitivitiesDictionary(MTTrackpadHIDManager *this)
{
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  uint64_t v2 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  BOOL v3 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v72 = 1094713344;
  int valuePtr = 1137180672;
  int v71 = 1031127695;
  CFNumberRef v5 = CFNumberCreate(v1, kCFNumberFloat32Type, &valuePtr);
  CFNumberRef v6 = CFNumberCreate(v1, kCFNumberFloat32Type, &v72);
  CFNumberRef v7 = CFNumberCreate(v1, kCFNumberFloat32Type, &v71);
  int v8 = CFDictionaryCreateMutable(v1, 0, v2, v3);
  int v9 = v8;
  if (v5) {
    BOOL v10 = v8 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    if (!v5)
    {
      if (!v6) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }
  }
  else
  {
    CFDictionaryRemoveAllValues(v8);
    CFDictionaryAddValue(v9, @"Resolution_dpi", v5);
    CFDictionaryAddValue(v9, @"AccelThresh", v6);
    CFDictionaryAddValue(v9, @"AccelPower", v7);
    CFDictionaryAddValue(Mutable, @"Resting Accel Tracking", v9);
  }
  CFRelease(v5);
  if (v6) {
LABEL_8:
  }
    CFRelease(v6);
LABEL_9:
  if (v7) {
    CFRelease(v7);
  }
  if (v9) {
    CFRelease(v9);
  }
  int v71 = 0;
  CFNumberRef v11 = CFNumberCreate(v1, kCFNumberFloat32Type, &valuePtr);
  CFNumberRef v12 = CFNumberCreate(v1, kCFNumberFloat32Type, &v72);
  CFNumberRef v13 = CFNumberCreate(v1, kCFNumberFloat32Type, &v71);
  __int16 v14 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  CFStringRef v15 = v14;
  if (v11 && v14)
  {
    CFDictionaryRemoveAllValues(v14);
    CFDictionaryAddValue(v15, @"Resolution_dpi", v11);
    CFDictionaryAddValue(v15, @"AccelThresh", v12);
    CFDictionaryAddValue(v15, @"AccelPower", v13);
    CFDictionaryAddValue(Mutable, @"Tracking", v15);
  }
  else if (!v11)
  {
    goto LABEL_20;
  }
  CFRelease(v11);
LABEL_20:
  if (v12) {
    CFRelease(v12);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (v15) {
    CFRelease(v15);
  }
  int v70 = valuePtr;
  int v69 = 1045220557;
  CFNumberRef v16 = CFNumberCreate(v1, kCFNumberFloat32Type, &v70);
  CFNumberRef v17 = CFNumberCreate(v1, kCFNumberFloat32Type, &v72);
  CFNumberRef v18 = CFNumberCreate(v1, kCFNumberFloat32Type, &v71);
  CFNumberRef v19 = CFNumberCreate(v1, kCFNumberFloat32Type, &v69);
  __int16 v20 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v21 = v20;
  if (v16 && v20)
  {
    CFDictionaryRemoveAllValues(v20);
    CFDictionaryAddValue(v21, @"Resolution_dpi", v16);
    CFDictionaryAddValue(v21, @"AccelThresh", v17);
    CFDictionaryAddValue(v21, @"AccelPower", v18);
    CFDictionaryAddValue(v21, @"CommitMultiplier", v19);
    CFDictionaryAddValue(Mutable, @"Scrolling", v21);
  }
  else if (!v16)
  {
    goto LABEL_31;
  }
  CFRelease(v16);
LABEL_31:
  if (v17) {
    CFRelease(v17);
  }
  if (v18) {
    CFRelease(v18);
  }
  if (v19) {
    CFRelease(v19);
  }
  if (v21) {
    CFRelease(v21);
  }
  int v68 = v70;
  int v69 = 1032268546;
  CFNumberRef v22 = CFNumberCreate(v1, kCFNumberFloat32Type, &v68);
  CFNumberRef v23 = CFNumberCreate(v1, kCFNumberFloat32Type, &v69);
  CFStringRef v24 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  uint64_t v25 = v24;
  if (v22 && v24)
  {
    CFDictionaryRemoveAllValues(v24);
    CFDictionaryAddValue(v25, @"Resolution_dpi", v22);
    CFDictionaryAddValue(v25, @"CommitMultiplier", v23);
    CFDictionaryAddValue(v25, @"Acceleration", @"System");
    CFDictionaryAddValue(Mutable, @"Zooming", v25);
  }
  else if (!v22)
  {
    goto LABEL_44;
  }
  CFRelease(v22);
LABEL_44:
  if (v23) {
    CFRelease(v23);
  }
  if (v25) {
    CFRelease(v25);
  }
  int v67 = 1077936128;
  int v71 = 1036831949;
  int v72 = 1097859072;
  CFNumberRef v26 = CFNumberCreate(v1, kCFNumberFloat32Type, &v67);
  CFNumberRef v27 = CFNumberCreate(v1, kCFNumberFloat32Type, &v72);
  CFNumberRef v28 = CFNumberCreate(v1, kCFNumberFloat32Type, &v71);
  char v29 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  char v30 = v29;
  if (v26 && v27 && v28 && v29)
  {
    CFDictionaryRemoveAllValues(v29);
    CFDictionaryAddValue(v30, @"Resolution_mm", v26);
    CFDictionaryAddValue(v30, @"AccelThresh", v27);
    CFDictionaryAddValue(v30, @"AccelPower", v28);
    CFDictionaryAddValue(Mutable, @"Command", v30);
  }
  else if (!v26)
  {
    goto LABEL_55;
  }
  CFRelease(v26);
LABEL_55:
  if (v27) {
    CFRelease(v27);
  }
  if (v28) {
    CFRelease(v28);
  }
  if (v30) {
    CFRelease(v30);
  }
  int v71 = 1045220557;
  int v72 = 1097859072;
  int v66 = 0x40000000;
  int v67 = 1086324736;
  int v64 = 1056964608;
  int v65 = 1115815936;
  CFNumberRef v31 = CFNumberCreate(v1, kCFNumberFloat32Type, &v67);
  CFNumberRef v32 = CFNumberCreate(v1, kCFNumberFloat32Type, &v72);
  CFNumberRef v33 = CFNumberCreate(v1, kCFNumberFloat32Type, &v71);
  CFNumberRef v34 = CFNumberCreate(v1, kCFNumberFloat32Type, &v66);
  CFNumberRef v35 = CFNumberCreate(v1, kCFNumberFloat32Type, &v65);
  CFNumberRef v36 = CFNumberCreate(v1, kCFNumberFloat32Type, &v64);
  int v37 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  uint64_t v38 = v37;
  if (v31 && v32 && v33 && v34 && v35 && v36)
  {
    CFDictionaryRemoveAllValues(v37);
    CFDictionaryAddValue(v38, @"Resolution_mm", v31);
    CFDictionaryAddValue(v38, @"AccelThresh", v32);
    CFDictionaryAddValue(v38, @"AccelPower", v33);
    CFDictionaryAddValue(v38, @"FluidAnimationStartThreshold_mm", v34);
    CFDictionaryAddValue(v38, @"FluidSwipeCompleteThreshold_mm", v35);
    CFDictionaryAddValue(v38, @"FluidSwipeInertiaTime_s", v36);
    CFDictionaryAddValue(Mutable, @"Swipe", v38);
  }
  else if (!v31)
  {
    goto LABEL_70;
  }
  CFRelease(v31);
LABEL_70:
  if (v32) {
    CFRelease(v32);
  }
  if (v33) {
    CFRelease(v33);
  }
  if (v34) {
    CFRelease(v34);
  }
  if (v35) {
    CFRelease(v35);
  }
  if (v36) {
    CFRelease(v36);
  }
  if (v38) {
    CFRelease(v38);
  }
  int v71 = 1045220557;
  int v72 = 1097859072;
  int v66 = 1077936128;
  int v67 = 1090519040;
  int v64 = 1056964608;
  int v65 = 1107296256;
  CFNumberRef v39 = CFNumberCreate(v1, kCFNumberFloat32Type, &v67);
  CFNumberRef v40 = CFNumberCreate(v1, kCFNumberFloat32Type, &v72);
  CFNumberRef v41 = CFNumberCreate(v1, kCFNumberFloat32Type, &v71);
  CFNumberRef v42 = CFNumberCreate(v1, kCFNumberFloat32Type, &v66);
  CFNumberRef v43 = CFNumberCreate(v1, kCFNumberFloat32Type, &v65);
  CFNumberRef v44 = CFNumberCreate(v1, kCFNumberFloat32Type, &v64);
  uint64_t v45 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  char v46 = v45;
  if (v39 && v40 && v41 && v42 && v43 && v44)
  {
    CFDictionaryRemoveAllValues(v45);
    CFDictionaryAddValue(v46, @"Resolution_mm", v39);
    CFDictionaryAddValue(v46, @"AccelThresh", v40);
    CFDictionaryAddValue(v46, @"AccelPower", v41);
    CFDictionaryAddValue(v46, @"FluidAnimationStartThreshold_mm", v42);
    CFDictionaryAddValue(v46, @"FluidSwipeCompleteThreshold_mm", v43);
    CFDictionaryAddValue(v46, @"FluidSwipeInertiaTime_s", v44);
    CFDictionaryAddValue(Mutable, @"Polar Swipe", v46);
  }
  else if (!v39)
  {
    goto LABEL_91;
  }
  CFRelease(v39);
LABEL_91:
  if (v40) {
    CFRelease(v40);
  }
  if (v41) {
    CFRelease(v41);
  }
  if (v42) {
    CFRelease(v42);
  }
  if (v43) {
    CFRelease(v43);
  }
  if (v44) {
    CFRelease(v44);
  }
  if (v46) {
    CFRelease(v46);
  }
  int v71 = 1045220557;
  int v72 = 1097859072;
  int v66 = 0x40000000;
  int v67 = 1077936128;
  int v64 = 1050253722;
  int v65 = 1106247680;
  CFNumberRef v47 = CFNumberCreate(v1, kCFNumberFloat32Type, &v67);
  CFNumberRef v48 = CFNumberCreate(v1, kCFNumberFloat32Type, &v72);
  CFNumberRef v49 = CFNumberCreate(v1, kCFNumberFloat32Type, &v71);
  CFNumberRef v50 = CFNumberCreate(v1, kCFNumberFloat32Type, &v66);
  CFNumberRef v51 = CFNumberCreate(v1, kCFNumberFloat32Type, &v65);
  CFNumberRef v52 = CFNumberCreate(v1, kCFNumberFloat32Type, &v64);
  long long v53 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  uint64_t v54 = v53;
  if (v47 && v48 && v49 && v50 && v51 && v52)
  {
    CFDictionaryRemoveAllValues(v53);
    CFDictionaryAddValue(v54, @"Resolution_mm", v47);
    CFDictionaryAddValue(v54, @"AccelThresh", v48);
    CFDictionaryAddValue(v54, @"AccelPower", v49);
    CFDictionaryAddValue(v54, @"FluidAnimationStartThreshold_mm", v50);
    CFDictionaryAddValue(v54, @"FluidSwipeCompleteThreshold_mm", v51);
    CFDictionaryAddValue(v54, @"FluidSwipeInertiaTime_s", v52);
    CFDictionaryAddValue(Mutable, @"Edge Swipe", v54);
  }
  else if (!v47)
  {
    goto LABEL_112;
  }
  CFRelease(v47);
LABEL_112:
  if (v48) {
    CFRelease(v48);
  }
  if (v49) {
    CFRelease(v49);
  }
  if (v50) {
    CFRelease(v50);
  }
  if (v51) {
    CFRelease(v51);
  }
  if (v52) {
    CFRelease(v52);
  }
  if (v54) {
    CFRelease(v54);
  }
  int v66 = 1077936128;
  int v67 = 1077936128;
  int v71 = 1045220557;
  int v72 = 1097859072;
  int v64 = 1050253722;
  int v65 = 1106247680;
  CFNumberRef v55 = CFNumberCreate(v1, kCFNumberFloat32Type, &v67);
  CFNumberRef v56 = CFNumberCreate(v1, kCFNumberFloat32Type, &v72);
  CFNumberRef v57 = CFNumberCreate(v1, kCFNumberFloat32Type, &v71);
  CFNumberRef v58 = CFNumberCreate(v1, kCFNumberFloat32Type, &v66);
  CFNumberRef v59 = CFNumberCreate(v1, kCFNumberFloat32Type, &v65);
  CFNumberRef v60 = CFNumberCreate(v1, kCFNumberFloat32Type, &v64);
  long long v61 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  char v62 = v61;
  if (v55 && v56 && v57 && v58 && v59 && v60)
  {
    CFDictionaryRemoveAllValues(v61);
    CFDictionaryAddValue(v62, @"Resolution_mm", v55);
    CFDictionaryAddValue(v62, @"AccelThresh", v56);
    CFDictionaryAddValue(v62, @"AccelPower", v57);
    CFDictionaryAddValue(v62, @"FluidAnimationStartThreshold_mm", v58);
    CFDictionaryAddValue(v62, @"FluidSwipeCompleteThreshold_mm", v59);
    CFDictionaryAddValue(v62, @"FluidSwipeInertiaTime_s", v60);
    CFDictionaryAddValue(Mutable, @"Edge Scroll", v62);
  }
  else if (!v55)
  {
    goto LABEL_133;
  }
  CFRelease(v55);
LABEL_133:
  if (v56) {
    CFRelease(v56);
  }
  if (v57) {
    CFRelease(v57);
  }
  if (v58) {
    CFRelease(v58);
  }
  if (v59) {
    CFRelease(v59);
  }
  if (v60) {
    CFRelease(v60);
  }
  if (v62) {
    CFRelease(v62);
  }
  return Mutable;
}

CFDictionaryRef MTTrackpadHIDManager::copyProperty(MTTrackpadHIDManager *this, const __CFString *a2)
{
  int v4 = MTSimpleHIDManager::propertyTypeFromString((uint64_t)a2, a2);
  if (v4 == 17)
  {
    uint64_t v14 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 120))(this);
    if (v14)
    {
      int v19 = *(_DWORD *)(v14 + 536);
      return CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberFloatType, &v19);
    }
  }
  else if (v4 == 73)
  {
    CFDictionaryRef v5 = MTSimpleHIDManager::copyProperty((CFDictionaryRef *)this, a2);
    if (!v5) {
      return 0;
    }
    CFDictionaryRef v6 = v5;
    CFTypeID v7 = CFGetTypeID(v5);
    if (v7 != CFDictionaryGetTypeID()) {
      return v6;
    }
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFIndex Count = CFDictionaryGetCount(v6);
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(v8, Count + 1, v6);
    CFDictionarySetValue(MutableCopy, @"Trackpad HID pref", *((const void **)this + 43));
    if (*((void *)this + 42))
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v8, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
      BOOL HostClickControlEnabled = MTParser::getHostClickControlEnabled(*((MTParser **)this + 42));
      CFNumberRef v13 = (const void **)MEMORY[0x263EFFB40];
      if (!HostClickControlEnabled) {
        CFNumberRef v13 = (const void **)MEMORY[0x263EFFB38];
      }
      CFDictionarySetValue(Mutable, @"Parser", *v13);
      char valuePtr = -86;
      v20[1] = -1431655766;
      (*(void (**)(MTTrackpadHIDManager *))(*(void *)this + 80))(this);
      MTDeviceGetMTActuator();
      MTActuatorGetReport();
      CFDictionarySetValue(MutableCopy, @"Host Click Mode", Mutable);
      CFRelease(Mutable);
    }
    uint64_t v16 = (*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 120))(this);
    if (v16)
    {
      v20[0] = *(_DWORD *)(v16 + 536);
      CFNumberRef v17 = CFNumberCreate(v8, kCFNumberFloatType, v20);
      if (v17)
      {
        CFNumberRef v18 = v17;
        CFDictionarySetValue(MutableCopy, @"Scroll Momentum Dispatch Rate", v17);
        CFRelease(v18);
      }
    }
    CFRelease(v6);
    return MutableCopy;
  }

  return MTSimpleHIDManager::copyProperty((CFDictionaryRef *)this, a2);
}

MTPListGestureConfig *MTTrackpadHIDManager::createDefaultActionEventsDictionary(MTTrackpadHIDManager *this)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Point", @"Mouse Point", 0, 0, v2);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Drag", @"Mouse Drag", @"Button1", 0, v3);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Click", @"Mouse Click", @"Button1", 0, v4);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Double Click", @"Mouse Double Click", @"Button1", 0, v5);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Primary Down", @"Mouse Down", @"Button1", 0, v6);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Primary Up", @"Mouse Up", @"Button1", 0, v7);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Secondary Click", @"Mouse Click", @"Button2", 0, v8);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Scroll", @"Scroll", 0, 0, v9);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Scroll To Edge", @"Scroll To Edge", 0, 0, v10);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Orientation", @"Orientation", 0, 0, v11);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Zoom Toggle", @"Zoom Toggle", 0, 0, v12);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Gesture Started", @"Gesture Started", 0, 0, v13);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Gesture Ended", @"Gesture Ended", 0, 0, v14);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Fluid Navigation", @"Fluid Navigation", 0, 0, v15);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Fluid Notification", @"Fluid Notification", 0, 0, v16);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Fluid Notification Alt", @"Fluid Notification Alt", 0, 0, v17);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Fluid Dock", @"Fluid Dock", 0, 0, v18);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Show Definition", @"Show Definition", 0, 0, v19);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Swipe Left", @"Swipe", 0, 0, v20);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Swipe Right", @"Swipe", 0, 0, v21);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Swipe Up", @"Swipe", 0, 0, v22);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Swipe Down", @"Swipe", 0, 0, v23);
  return Mutable;
}

__CFDictionary *MTTrackpadHIDManager::createDefaultGestureSetsDictionary(MTTrackpadHIDManager *this)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFStringRef v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  CFStringRef v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  CFMutableArrayRef v6 = CFArrayCreateMutable(v2, 0, MEMORY[0x263EFFF70]);
  CFStringRef v7 = CFDictionaryCreateMutable(v2, 0, v3, v4);
  if (v6) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    CFStringRef v9 = v7;
    CFDictionaryAddValue(v7, @"Gestures", v6);
    CFDictionaryAddValue(v9, @"Transitions", @"ToMoreFingers FromFewerFingers FromMoreFingers");
    CFDictionaryAddValue(Mutable, @"None", v9);
    CFRelease(v6);
    CFRelease(v9);
  }
  CFStringRef v10 = CFArrayCreateMutable(v2, 0, MEMORY[0x263EFFF70]);
  CFMutableDictionaryRef v11 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (v10) {
    BOOL v12 = v11 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12)
  {
    CFStringRef v13 = v11;
    MTPListGestureConfig::addGestureToArray(v10, (__CFArray *)@"Point", @"Translate", @"Tracking", @"Repetitive", 0, 0, 0, v42);
    CFDictionaryAddValue(v13, @"Gestures", v10);
    CFDictionaryAddValue(v13, @"Transitions", @"ToMoreFingers FromMoreFingers FromMoreWithSlightIntegrationDelay AccelOnlyIfSomeResting");
    CFDictionaryAddValue(Mutable, @"Point", v13);
    CFRelease(v10);
    CFRelease(v13);
  }
  CFStringRef v14 = CFArrayCreateMutable(v2, 0, MEMORY[0x263EFFF70]);
  CFMutableDictionaryRef v15 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (v14) {
    BOOL v16 = v15 == 0;
  }
  else {
    BOOL v16 = 1;
  }
  if (!v16)
  {
    CFStringRef v17 = v15;
    MTPListGestureConfig::addGestureToArray(v14, (__CFArray *)@"Point", @"Translate", @"Tracking", @"Repetitive", 0, 0, 0, v42);
    MTPListGestureConfig::addGestureToArray(v14, (__CFArray *)@"Click", @"Tap", 0, 0, 0, 0, 0, v43);
    CFDictionaryAddValue(v17, @"Gestures", v14);
    CFDictionaryAddValue(v17, @"Transitions", @"ToMoreFingers FromMoreFingers FromMoreWithSlightIntegrationDelay AccelOnlyIfSomeResting");
    CFDictionaryAddValue(Mutable, @"Point & Click", v17);
    CFRelease(v14);
    CFRelease(v17);
  }
  CFStringRef v18 = CFArrayCreateMutable(v2, 0, MEMORY[0x263EFFF70]);
  CFMutableDictionaryRef v19 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (v18) {
    BOOL v20 = v19 == 0;
  }
  else {
    BOOL v20 = 1;
  }
  if (!v20)
  {
    CFStringRef v21 = v19;
    MTPListGestureConfig::addGestureToArray(v18, (__CFArray *)@"Point", @"Translate", @"Tracking", @"Repetitive", 0, 0, 0, v42);
    MTPListGestureConfig::addGestureToArray(v18, (__CFArray *)@"Primary Down", @"Tap", 0, 0, 0, 0, 0, v44);
    CFDictionaryAddValue(v21, @"Gestures", v18);
    CFDictionaryAddValue(v21, @"Transitions", @"ToMoreFingers FromMoreFingers FromMoreWithSlightIntegrationDelay");
    CFDictionaryAddValue(Mutable, @"Point, Click & Drag", v21);
    CFRelease(v18);
    CFRelease(v21);
  }
  CFStringRef v22 = CFArrayCreateMutable(v2, 0, MEMORY[0x263EFFF70]);
  CFMutableDictionaryRef v23 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (v22)
  {
    CFStringRef v24 = v23;
    if (v23)
    {
      if (*(unsigned char *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this) + 1))
      {
        if (!*(unsigned char *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this) + 19)) {
          MTPListGestureConfig::addGestureToArray(v22, (__CFArray *)@"Click", @"Tap", 0, 0, 0, 0, 0, v42);
        }
        MTPListGestureConfig::addGestureToArray(v22, (__CFArray *)@"Click", @"DroppedFingerTap", 0, 0, 0, 0, 0, v42);
      }
      if (*(unsigned char *)((*(uint64_t (**)(MTTrackpadHIDManager *))(*(void *)this + 848))(this) + 19)) {
        MTPListGestureConfig::addGestureToArray(v22, (__CFArray *)@"Show Definition", @"Tap", 0, 0, 0, 0, 0, v42);
      }
      int valuePtr = 1138819072;
      CFStringRef v25 = (const __CFString *)CFNumberCreate(v2, kCFNumberFloat32Type, &valuePtr);
      MTPListGestureConfig::addGestureToArray(v22, (__CFArray *)@"Primary Down", @"Hold", 0, @"TimeHeld BeginSlide", 0, @"HoldTime", v25, v42);
      CFRelease(v25);
      MTPListGestureConfig::addGestureToArray(v22, (__CFArray *)@"Drag", @"Translate", @"Scrolling", @"Momentum", 0, 0, 0, v45);
      MTPListGestureConfig::addGestureToArray(v22, (__CFArray *)@"Primary Up", @"Lift", 0, 0, 0, 0, 0, v46);
      CFDictionaryAddValue(v24, @"Gestures", v22);
      CFDictionaryAddValue(v24, @"Transitions", @"ToFewerFingers FromFewerIfPause MultiFingerDrag ");
      CFDictionaryAddValue(Mutable, @"Drag & Click", v24);
      CFRelease(v22);
      CFRelease(v24);
    }
  }
  CFNumberRef v26 = CFArrayCreateMutable(v2, 0, MEMORY[0x263EFFF70]);
  CFMutableDictionaryRef v27 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (v26)
  {
    CFNumberRef v28 = v27;
    if (v27)
    {
      MTPListGestureConfig::addGestureToArray(v26, (__CFArray *)@"Scroll", @"Translate", @"Scrolling", @"Repetitive", 0, 0, 0, v42);
      CFDictionaryAddValue(v28, @"Gestures", v26);
      CFDictionaryAddValue(v28, @"Transitions", @"ToFewerFingers FromFewerIfPause");
      CFDictionaryAddValue(Mutable, @"Scroll", v28);
      CFRelease(v26);
      CFRelease(v28);
    }
  }
  char v29 = CFArrayCreateMutable(v2, 0, MEMORY[0x263EFFF70]);
  CFMutableDictionaryRef v30 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (v29)
  {
    CFNumberRef v31 = v30;
    if (v30)
    {
      MTPListGestureConfig::addGestureToArray(v29, (__CFArray *)@"Scroll", @"Translate", @"Scrolling", @"Repetitive", 0, 0, 0, v42);
      MTPListGestureConfig::addGestureToArray(v29, (__CFArray *)@"Secondary Click", @"Tap", 0, 0, 0, 0, 0, v47);
      CFDictionaryAddValue(v31, @"Gestures", v29);
      CFDictionaryAddValue(v31, @"Transitions", @"ToFewerFingers FromFewerIfPause");
      CFDictionaryAddValue(Mutable, @"Scroll & Secondary Click", v31);
      CFRelease(v29);
      CFRelease(v31);
    }
  }
  CFNumberRef v32 = CFArrayCreateMutable(v2, 0, MEMORY[0x263EFFF70]);
  CFMutableDictionaryRef v33 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (v32)
  {
    CFNumberRef v34 = v33;
    if (v33)
    {
      MTPListGestureConfig::addGestureToArray(v32, (__CFArray *)@"Scroll", @"Translate", @"Scrolling", @"Repetitive", @"LockOnFirst", 0, 0, v42);
      MTPListGestureConfig::addGestureToArray(v32, (__CFArray *)@"Orientation", @"Scale+Rotate", @"Zooming", @"Repetitive", @"LockOnFirst", 0, 0, v48);
      CFDictionaryAddValue(v34, @"Gestures", v32);
      CFDictionaryAddValue(v34, @"Transitions", @"ToFewerFingers FromFewerIfPause");
      CFDictionaryAddValue(Mutable, @"Scroll, Zoom & Rotate", v34);
      CFRelease(v32);
      CFRelease(v34);
    }
  }
  CFNumberRef v35 = CFArrayCreateMutable(v2, 0, MEMORY[0x263EFFF70]);
  CFMutableDictionaryRef v36 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (v35)
  {
    int v37 = v36;
    if (v36)
    {
      MTPListGestureConfig::addGestureToArray(v35, (__CFArray *)@"Orientation", @"Scale+Rotate", @"Zooming", @"Repetitive", 0, 0, 0, v42);
      CFDictionaryAddValue(v37, @"Gestures", v35);
      CFDictionaryAddValue(v37, @"Transitions", @"ToFewerFingers FromFewerFingers");
      CFDictionaryAddValue(Mutable, @"Zoom & Rotate", v37);
      CFRelease(v35);
      CFRelease(v37);
    }
  }
  uint64_t v38 = CFArrayCreateMutable(v2, 0, MEMORY[0x263EFFF70]);
  CFMutableDictionaryRef v39 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (v38)
  {
    CFNumberRef v40 = v39;
    if (v39)
    {
      MTPListGestureConfig::addGestureToArray(v38, (__CFArray *)@"Swipe Left", @"Left", @"Swipe", @"OncePerDirection OnlyIfAllMoving", 0, 0, 0, v42);
      MTPListGestureConfig::addGestureToArray(v38, (__CFArray *)@"Swipe Right", @"Right", @"Swipe", @"OncePerDirection OnlyIfAllMoving", 0, 0, 0, v49);
      MTPListGestureConfig::addGestureToArray(v38, (__CFArray *)@"Swipe Up", @"Up", @"Swipe", @"OncePerDirection OnlyIfAllMoving", 0, 0, 0, v50);
      MTPListGestureConfig::addGestureToArray(v38, (__CFArray *)@"Swipe Down", @"Down", @"Swipe", @"OncePerDirection OnlyIfAllMoving", 0, 0, 0, v51);
      CFDictionaryAddValue(v40, @"Transitions", @"FromMoreFingers ToMoreFingers ToFewerAfterSlightDelay FromFewerFingers FromMoreWithSlightIntegrationDelay");
      CFDictionaryAddValue(v40, @"Gestures", v38);
      CFDictionaryAddValue(Mutable, @"Swipes", v40);
      CFRelease(v38);
      CFRelease(v40);
    }
  }
  return Mutable;
}

void MTTrackpadHIDManager::~MTTrackpadHIDManager(MTTrackpadHIDManager *this)
{
  MTSimpleHIDManager::~MTSimpleHIDManager(this);

  JUMPOUT(0x2455F6CE0);
}

void MTForceBehavior::addSkippedActivationStage(void *a1, int a2)
{
  uint64_t v4 = (uint64_t)(a1 + 8);
  unint64_t v5 = a1[8];
  CFMutableArrayRef v6 = (char *)a1[7];
  if ((unint64_t)v6 >= v5)
  {
    BOOL v8 = (char *)a1[6];
    uint64_t v9 = (v6 - v8) >> 2;
    if ((unint64_t)(v9 + 1) >> 62) {
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = v5 - (void)v8;
    unint64_t v11 = (uint64_t)(v5 - (void)v8) >> 1;
    if (v11 <= v9 + 1) {
      unint64_t v11 = v9 + 1;
    }
    if (v10 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v12)
    {
      CFStringRef v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v12);
      BOOL v8 = (char *)a1[6];
      CFMutableArrayRef v6 = (char *)a1[7];
    }
    else
    {
      CFStringRef v13 = 0;
    }
    CFStringRef v14 = &v13[4 * v9];
    CFMutableDictionaryRef v15 = &v13[4 * v12];
    *(_DWORD *)CFStringRef v14 = a2;
    CFStringRef v7 = v14 + 4;
    while (v6 != v8)
    {
      int v16 = *((_DWORD *)v6 - 1);
      v6 -= 4;
      *((_DWORD *)v14 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v16;
      v14 -= 4;
    }
    a1[6] = v14;
    a1[7] = v7;
    a1[8] = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *(_DWORD *)CFMutableArrayRef v6 = a2;
    CFStringRef v7 = v6 + 4;
  }
  a1[7] = v7;
}

void MTForceBehavior::addSkippedReleaseStage(void *a1, int a2)
{
  uint64_t v4 = (uint64_t)(a1 + 11);
  unint64_t v5 = a1[11];
  CFMutableArrayRef v6 = (char *)a1[10];
  if ((unint64_t)v6 >= v5)
  {
    BOOL v8 = (char *)a1[9];
    uint64_t v9 = (v6 - v8) >> 2;
    if ((unint64_t)(v9 + 1) >> 62) {
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = v5 - (void)v8;
    unint64_t v11 = (uint64_t)(v5 - (void)v8) >> 1;
    if (v11 <= v9 + 1) {
      unint64_t v11 = v9 + 1;
    }
    if (v10 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v12)
    {
      CFStringRef v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v12);
      BOOL v8 = (char *)a1[9];
      CFMutableArrayRef v6 = (char *)a1[10];
    }
    else
    {
      CFStringRef v13 = 0;
    }
    CFStringRef v14 = &v13[4 * v9];
    CFMutableDictionaryRef v15 = &v13[4 * v12];
    *(_DWORD *)CFStringRef v14 = a2;
    CFStringRef v7 = v14 + 4;
    while (v6 != v8)
    {
      int v16 = *((_DWORD *)v6 - 1);
      v6 -= 4;
      *((_DWORD *)v14 - MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v16;
      v14 -= 4;
    }
    a1[9] = v14;
    a1[10] = v7;
    a1[11] = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *(_DWORD *)CFMutableArrayRef v6 = a2;
    CFStringRef v7 = v6 + 4;
  }
  a1[10] = v7;
}

void MTMouseEmbeddedEventDispatcher::createDispatcher()
{
}

void sub_240733DBC(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10A1C4052F3E7C6);
  _Unwind_Resume(a1);
}

void MTMouseEmbeddedEventDispatcher::dispatchPointingEvent(MTMouseEmbeddedEventDispatcher *this, int a2, int a3, int a4, unint64_t a5, char a6)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  if (a6)
  {
    if (*((unsigned char *)this + 512)) {
      BOOL v11 = (a4 & 1) == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (v11) {
      unsigned int v12 = a4;
    }
    else {
      unsigned int v12 = a4 & 0xFFFFFFFC | 2;
    }
    if (v12 != *((_DWORD *)this + 129))
    {
      CFStringRef v13 = MTLoggingPlugin();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        int v15 = 136315906;
        int v16 = "";
        __int16 v17 = 2080;
        CFStringRef v18 = "MTMouseEmbeddedEventDispatcher::";
        __int16 v19 = 2080;
        BOOL v20 = "dispatchPointingEvent";
        __int16 v21 = 1024;
        unsigned int v22 = v12;
        _os_log_impl(&dword_2406FB000, v13, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Dispatching Pointer event from FW with button 0x%08x", (uint8_t *)&v15, 0x26u);
      }
    }
    MTTrackpadEventDispatcher::dispatchPointingEvent(this, a2, a3, a4, a5, 1);
  }
  else
  {
    CFStringRef v14 = MTLoggingPlugin();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      int v15 = 136315650;
      int v16 = "[Error] ";
      __int16 v17 = 2080;
      CFStringRef v18 = "MTMouseEmbeddedEventDispatcher::";
      __int16 v19 = 2080;
      BOOL v20 = "dispatchPointingEvent";
      _os_log_impl(&dword_2406FB000, v14, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected request to dispatch a Pointer event. Ignoring.", (uint8_t *)&v15, 0x20u);
    }
  }
}

uint64_t MTMouseEmbeddedEventDispatcher::shouldDispatchPointerEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  CFArrayRef Children = (const __CFArray *)IOHIDEventGetChildren();
  if (Children) {
    CFIndex Count = CFArrayGetCount(Children);
  }
  else {
    CFIndex Count = 0;
  }
  if ((IOHIDEventGetIntegerValue() & 2) != 0
    || (IOHIDEventGetIntegerValue() & 0x80) != 0
    || a4 && (IOHIDEventGetPhase() & 0xD) != 0)
  {
    BOOL v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v9 = (IOHIDEventGetIntegerValue() >> 7) & 1;
      BOOL v10 = IOHIDEventGetIntegerValue() == 1;
      int v15 = 136316930;
      int v16 = "";
      BOOL v11 = IOHIDEventGetIntegerValue() == 1;
      __int16 v17 = 2080;
      CFStringRef v18 = "MTMouseEmbeddedEventDispatcher::";
      __int16 v19 = 2080;
      BOOL v20 = "shouldDispatchPointerEvent";
      __int16 v21 = 2048;
      unsigned int v12 = "no";
      CFIndex v22 = Count;
      if (a4) {
        unsigned int v12 = "yes";
      }
      __int16 v23 = 1024;
      unsigned int v24 = v9;
      __int16 v25 = 1024;
      BOOL v26 = v10;
      __int16 v27 = 1024;
      BOOL v28 = v11;
      __int16 v29 = 2082;
      CFMutableDictionaryRef v30 = v12;
      _os_log_impl(&dword_2406FB000, v8, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Dispatching Pointer event with digitizer (%lu contacts, cancel=%d, touching=%d, inrange=%d), scroll? %{public}s", (uint8_t *)&v15, 0x46u);
    }
  }
  BOOL v13 = IOHIDEventGetIntegerValue()
     || (IOHIDEventGetIntegerValue() & 2) != 0
     || (a4 | IOHIDEventGetIntegerValue() & 1) != 0;
  return *(unsigned char *)(a1 + 424) || v13;
}

void MTMouseEmbeddedEventDispatcher::handleEvent(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  if (IOHIDEventGetType() != 11)
  {
    BOOL v28 = MTLoggingPlugin();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      CFNumberRef v32 = "[Error] ";
      __int16 v33 = 2080;
      CFNumberRef v34 = "MTMouseEmbeddedEventDispatcher::";
      __int16 v35 = 2080;
      CFMutableDictionaryRef v36 = "handleEvent";
      __int16 v37 = 1024;
      LODWORD(v38) = IOHIDEventGetType();
      _os_log_impl(&dword_2406FB000, v28, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected event type: %u Eating it.", buf, 0x26u);
    }
  }
  uint64_t Children = IOHIDEventGetChildren();
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  if (Children)
  {
    CFArrayRef v8 = (const __CFArray *)IOHIDEventGetChildren();
    CFArrayRef Copy = CFArrayCreateCopy(v7, v8);
    CFIndex Count = CFArrayGetCount(Copy);
  }
  else
  {
    CFArrayRef Copy = 0;
    CFIndex Count = 0;
  }
  mach_absolute_time();
  RelativePointeruint64_t Event = IOHIDEventCreateRelativePointerEvent();
  if (RelativePointerEvent)
  {
    unsigned int v12 = (const void *)RelativePointerEvent;
    uint64_t v30 = a1;
    unsigned int v29 = a3;
    if (Count >= 1)
    {
      CFIndex v13 = 0;
      CFStringRef v14 = 0;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(Copy, v13);
        int Type = IOHIDEventGetType();
        if (Type != 11) {
          break;
        }
LABEL_24:
        if (Count == ++v13) {
          goto LABEL_29;
        }
      }
      if (Type == 6)
      {
        if (v14)
        {
          __int16 v17 = MTLoggingPlugin();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315650;
            CFNumberRef v32 = "[Debug] ";
            __int16 v33 = 2080;
            CFNumberRef v34 = "MTMouseEmbeddedEventDispatcher::";
            __int16 v35 = 2080;
            CFMutableDictionaryRef v36 = "handleEvent";
            _os_log_impl(&dword_2406FB000, v17, OS_LOG_TYPE_DEBUG, "[HID] [MT] %s%s%s Multiple scroll events. Merging.", buf, 0x20u);
          }
          IOHIDEventGetFloatValue();
          IOHIDEventGetFloatValue();
          IOHIDEventSetFloatValue();
          IOHIDEventGetFloatValue();
          IOHIDEventGetFloatValue();
          IOHIDEventSetFloatValue();
          IOHIDEventGetFloatValue();
          IOHIDEventGetFloatValue();
          IOHIDEventSetFloatValue();
          IOHIDEventGetPhase();
          IOHIDEventSetPhase();
        }
        else
        {
          CFStringRef v14 = (const void *)IOHIDEventCreateCopy();
          IOHIDEventAppendEvent();
        }
        goto LABEL_23;
      }
      if (IOHIDEventGetType() == 1)
      {
        Integerint Value = IOHIDEventGetIntegerValue();
        uint64_t v19 = IOHIDEventGetIntegerValue();
        BOOL v20 = MTLoggingPlugin();
        __int16 v21 = v20;
        if (IntegerValue != 65280 || v19 != 1)
        {
          if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
            goto LABEL_23;
          }
          *(_DWORD *)buf = 136316162;
          CFNumberRef v32 = "[Error] ";
          __int16 v33 = 2080;
          CFNumberRef v34 = "MTMouseEmbeddedEventDispatcher::";
          __int16 v35 = 2080;
          CFMutableDictionaryRef v36 = "handleEvent";
          __int16 v37 = 2048;
          uint64_t v38 = IntegerValue;
          __int16 v39 = 2048;
          uint64_t v40 = v19;
          CFIndex v22 = v21;
          os_log_type_t v23 = OS_LOG_TYPE_ERROR;
          unsigned int v24 = "[HID] [MT] %s%s%s Unexpected vendor-defined child event with usage page %lu and usage %lu. Eating it";
          uint32_t v25 = 52;
          goto LABEL_21;
        }
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315650;
          CFNumberRef v32 = "[Debug] ";
          __int16 v33 = 2080;
          CFNumberRef v34 = "MTMouseEmbeddedEventDispatcher::";
          __int16 v35 = 2080;
          CFMutableDictionaryRef v36 = "handleEvent";
          CFIndex v22 = v21;
          os_log_type_t v23 = OS_LOG_TYPE_DEBUG;
          unsigned int v24 = "[HID] [MT] %s%s%s Vendor-defined Momentum event. Ignoring.";
          uint32_t v25 = 32;
LABEL_21:
          _os_log_impl(&dword_2406FB000, v22, v23, v24, buf, v25);
        }
      }
      else
      {
        BOOL v26 = MTLoggingPlugin();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          CFNumberRef v32 = "[Error] ";
          __int16 v33 = 2080;
          CFNumberRef v34 = "MTMouseEmbeddedEventDispatcher::";
          __int16 v35 = 2080;
          CFMutableDictionaryRef v36 = "handleEvent";
          __int16 v37 = 2114;
          uint64_t v38 = (uint64_t)ValueAtIndex;
          CFIndex v22 = v26;
          os_log_type_t v23 = OS_LOG_TYPE_ERROR;
          unsigned int v24 = "[HID] [MT] %s%s%s Unexpected child event: %{public}@. Eating it";
          uint32_t v25 = 42;
          goto LABEL_21;
        }
      }
LABEL_23:
      IOHIDEventRemoveEvent();
      goto LABEL_24;
    }
    CFStringRef v14 = 0;
LABEL_29:
    IOHIDEventAppendEvent();
    if (MTMouseEmbeddedEventDispatcher::shouldDispatchPointerEvent(v30, v27, a2, (uint64_t)v14)) {
      MTSimpleEventDispatcher::dispatchEvent(v30, (uint64_t)v12, v29);
    }
    CFRelease(v12);
    if (Copy) {
      goto LABEL_32;
    }
  }
  else
  {
    CFStringRef v14 = 0;
    if (Copy) {
LABEL_32:
    }
      CFRelease(Copy);
  }
  if (v14) {
    CFRelease(v14);
  }
}

void MTMouseEmbeddedEventDispatcher::~MTMouseEmbeddedEventDispatcher(MTMouseEmbeddedEventDispatcher *this)
{
  *(void *)this = &unk_26F4DA178;
  std::__list_imp<double>::clear((void *)this + 61);
  std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy((uint64_t)this + 464, *((void **)this + 59));

  MTSimpleEventDispatcher::~MTSimpleEventDispatcher(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26F4DA178;
  std::__list_imp<double>::clear((void *)this + 61);
  std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy((uint64_t)this + 464, *((void **)this + 59));
  MTSimpleEventDispatcher::~MTSimpleEventDispatcher(this);

  JUMPOUT(0x2455F6CE0);
}

void MTTelemetryAnalyticsReporter::MTTelemetryAnalyticsReporter(MTTelemetryAnalyticsReporter *this)
{
  *(void *)this = 0;
  *((unsigned char *)this + 8) = 0;
}

{
  *(void *)this = 0;
  *((unsigned char *)this + 8) = 0;
}

void MTTelemetryAnalyticsReporter::~MTTelemetryAnalyticsReporter(MTTelemetryAnalyticsReporter *this)
{
}

{
  MTTelemetryAnalyticsReporter::stop(this);
}

uint64_t MTTelemetryAnalyticsReporter::stop(MTTelemetryAnalyticsReporter *this)
{
  CFAllocatorRef v2 = *(const void **)this;
  if (v2)
  {
    if (*((unsigned char *)this + 8))
    {
      if (MTUnregisterFullFrameCallback()) {
        uint64_t v3 = 0;
      }
      else {
        uint64_t v3 = 3758097084;
      }
      CFAllocatorRef v2 = *(const void **)this;
    }
    else
    {
      uint64_t v3 = 0;
    }
    CFRelease(v2);
    *(void *)this = 0;
  }
  else
  {
    uint64_t v3 = 0;
  }
  *((unsigned char *)this + 8) = 0;
  return v3;
}

uint64_t MTTelemetryAnalyticsReporter::start(uint64_t a1, CFTypeRef cf)
{
  if (*(unsigned char *)(a1 + 8)) {
    return 0;
  }
  uint64_t v2 = 3758097086;
  if (!cf) {
    return 3758097090;
  }
  *(void *)a1 = CFRetain(cf);
  if (MTRegisterFullFrameCallback())
  {
    uint64_t v2 = 0;
    *(unsigned char *)(a1 + 8) = 1;
  }
  return v2;
}

uint64_t MTTelemetryAnalyticsReporter::processTelemetryReport(uint64_t result, unsigned __int8 *a2, int a3)
{
  v13[2] = *MEMORY[0x263EF8340];
  if (result)
  {
    if (a2)
    {
      int v5 = *a2;
      uint64_t result = MTDeviceGetSATelemetryReportID();
      if (a3 == 17 && v5 == result && a2[15])
      {
        if (a2[12])
        {
          [NSString stringWithFormat:@"%@.%@", @"com.apple.multitouch", @"baseline.inversion"];
          v12[0] = @"Lockscreen_Status";
          uint64_t v6 = [NSNumber numberWithBool:a2[11]];
          v12[1] = @"Touch_Frequency";
          v13[0] = v6;
          v13[1] = [NSNumber numberWithUnsignedChar:a2[9]];
          [NSDictionary dictionaryWithObjects:v13 forKeys:v12 count:2];
          uint64_t result = AnalyticsSendEventLazy();
        }
        if (a2[13])
        {
          [NSString stringWithFormat:@"%@.%@", @"com.apple.multitouch", @"baseline.adaptation"];
          v10[0] = @"AdaptationInterval";
          v11[0] = [NSNumber numberWithInt:*(unsigned int *)(a2 + 1)];
          v10[1] = @"FreqDuringAdaptation";
          v11[1] = [NSNumber numberWithUnsignedChar:a2[9]];
          v10[2] = @"Lockscreen_Status";
          v11[2] = [NSNumber numberWithBool:a2[11]];
          v10[3] = @"TimeSinceLastAdapt";
          v11[3] = [NSNumber numberWithInt:*(unsigned int *)(a2 + 5)];
          v10[4] = @"Touching";
          v11[4] = [NSNumber numberWithBool:a2[10]];
          [NSDictionary dictionaryWithObjects:v11 forKeys:v10 count:5];
          uint64_t result = AnalyticsSendEventLazy();
        }
        if (a2[14])
        {
          [NSString stringWithFormat:@"%@.%@", @"com.apple.multitouch", @"dtn.allcolumnscovered"];
          v8[0] = @"Lockscreen_Status";
          uint64_t v7 = [NSNumber numberWithBool:a2[11]];
          v8[1] = @"Touch_Frequency";
          v9[0] = v7;
          v9[1] = [NSNumber numberWithUnsignedChar:a2[9]];
          [NSDictionary dictionaryWithObjects:v9 forKeys:v8 count:2];
          return AnalyticsSendEventLazy();
        }
      }
    }
  }
  return result;
}

uint64_t ___ZL18sendAnalyticsEventP8NSStringP12NSDictionaryIS0_P8NSObjectE_block_invoke(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

const char *MTMouseHIDManager::getName(MTMouseHIDManager *this)
{
  return "MTMouseHIDManager";
}

void MTMouseHIDManager::createManager()
{
}

void sub_240734DA0(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10A1C40899DFB1ALL);
  _Unwind_Resume(a1);
}

uint64_t MTMouseHIDManager::initialize(MTModeSwitcher *a1, uint64_t a2, const void *a3, int a4, int a5)
{
  *(void *)((char *)a1 + 364) = 0;
  MTAbsoluteTimeGetCurrent();
  *((void *)a1 + 47) = v10;
  *((_DWORD *)a1 + 96) = 0;
  MTAbsoluteTimeGetCurrent();
  *((void *)a1 + 49) = v11;
  uint64_t v12 = (*(uint64_t (**)(MTModeSwitcher *))(*(void *)a1 + 880))(a1);
  (*(void (**)(MTModeSwitcher *, const void *, uint64_t))(*(void *)a1 + 888))(a1, a3, v12);

  return MTTrackpadHIDManager::initialize(a1, a2, a3, a4, a5);
}

uint64_t MTMouseHIDManager::registerDeviceDataCallbacks(MTMouseHIDManager *this)
{
  MTTrackpadHIDManager::registerDeviceDataCallbacks(this);
  (*(void (**)(MTMouseHIDManager *))(*(void *)this + 80))(this);
  MTRegisterTrackingCallback();
  uint64_t v2 = (*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 80))(this);

  return MEMORY[0x270F4C7F0](v2, MTMouseHIDManager::forwardFrameProcessingEntryExit, this);
}

uint64_t MTMouseHIDManager::forwardTrackingDataForMotionFilter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a5 + 896))(a5, a1, a2, a3, a4);
}

uint64_t MTMouseHIDManager::forwardFrameProcessingEntryExit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a5 + 904))(a5, a1, a2, a3, a4);
}

uint64_t MTMouseHIDManager::unregisterDeviceDataCallbacks(MTMouseHIDManager *this)
{
  (*(void (**)(MTMouseHIDManager *))(*(void *)this + 80))(this);
  MTUnregisterFrameProcessingEntryExitCallback();
  (*(void (**)(MTMouseHIDManager *))(*(void *)this + 80))(this);
  MTUnregisterTrackingCallback();

  return MTTrackpadHIDManager::unregisterDeviceDataCallbacks(this);
}

void MTMouseHIDManager::createEventDispatcher(MTMouseHIDManager *this)
{
}

void MTMouseHIDManager::setDeviceUsages(MTMouseHIDManager *this)
{
  MTTrackpadHIDManager::setDeviceUsages(this);
  CFArrayRef v2 = (const __CFArray *)(*(uint64_t (**)(MTMouseHIDManager *, __CFString *))(*(void *)this + 560))(this, @"DeviceUsagePairs");
  if (v2)
  {
    CFArrayRef v3 = v2;
    if (CFArrayGetCount(v2) >= 1)
    {
      CFIndex v4 = 0;
      CFIndex v5 = -1;
      do
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v3, v4);
        if (ValueAtIndex)
        {
          CFDictionaryRef v7 = ValueAtIndex;
          int v12 = -1431655766;
          int valuePtr = -1431655766;
          CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"DeviceUsagePage");
          CFNumberRef v9 = (const __CFNumber *)CFDictionaryGetValue(v7, @"DeviceUsage");
          if (Value)
          {
            CFNumberRef v10 = v9;
            if (v9)
            {
              CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
              CFNumberGetValue(v10, kCFNumberSInt32Type, &v12);
              if (v12 == 12 && valuePtr == 65280) {
                CFIndex v5 = v4;
              }
            }
          }
        }
        ++v4;
      }
      while (v4 < CFArrayGetCount(v3));
      if ((v5 & 0x8000000000000000) == 0) {
        CFArrayRemoveValueAtIndex(v3, v5);
      }
    }
    MTTrackpadHIDManager::setProperty(this, @"DeviceUsagePairs", v3, 1);
    CFRelease(v3);
  }
}

uint64_t MTMouseHIDManager::getUserPrefs(uint64_t a1, void *a2)
{
  *a2 = &MTMouseHIDManager::getUserPrefs(mt_UserPreference const**)::prefs;
  return 6;
}

uint64_t MTMouseHIDManager::determineHIDManagerSettings(MTMouseHIDManager *this)
{
  uint64_t v2 = (*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 880))(this);
  CFDictionaryRef v3 = (const __CFDictionary *)*((void *)this + 43);
  if (v3 && (CFTypeID v4 = CFGetTypeID(*((CFTypeRef *)this + 43)), v4 == CFDictionaryGetTypeID()))
  {
    *(_WORD *)(v2 + 8) = 0;
    *(void *)uint64_t v2 = 0;
    *(unsigned char *)uint64_t v2 = mthid_CFDictionaryGetBoolValue(v3, @"MouseHorizontalScroll");
    *(unsigned char *)(v2 + MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = mthid_CFDictionaryGetBoolValue(v3, @"MouseVerticalScroll");
    *(unsigned char *)(v2 + 3) = mthid_CFDictionaryGetInt32Property(v3, @"MouseTwoFingerHorizSwipeGesture") == 1;
    *(unsigned char *)(v2 + 4) = mthid_CFDictionaryGetInt32Property(v3, @"MouseTwoFingerHorizSwipeGesture") == 2;
    *(_WORD *)(v2 + 5) = mthid_CFDictionaryGetInt32Property(v3, @"MouseOneFingerDoubleTapGesture") == 1;
    *(unsigned char *)(v2 + 7) = mthid_CFDictionaryGetInt32Property(v3, @"MouseTwoFingerDoubleTapGesture") == 3;
    uint64_t result = mthid_CFDictionaryGetBoolValue(v3, @"MouseMomentumScroll");
    *(unsigned char *)(v2 + 9) = result;
    if (*(unsigned char *)(v2 + 4))
    {
      uint64_t result = MTPreferencesGetAppBooleanValue(@"EnableMouseNavSwipes", @"com.apple.MultitouchSupport", 0);
      if (result) {
        *(_WORD *)(v2 + 3) = 1;
      }
    }
  }
  else
  {
    uint64_t v6 = (*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 80))(this);
    uint64_t result = (*(uint64_t (**)(MTMouseHIDManager *, uint64_t, uint64_t))(*(void *)this + 888))(this, v6, v2);
  }
  BOOL v7 = 1;
  if ((*((unsigned char *)this + 160) & 4) == 0)
  {
    uint64_t result = MTPreferencesGetAppBooleanValue(@"ScrollMomentum", @"com.apple.MultitouchSupport", 0);
    BOOL v7 = result == 1;
  }
  *(unsigned char *)(v2 + 8) = v7;
  *(unsigned char *)(v2 + 2) = 1;
  return result;
}

void MTMouseHIDManager::activateHIDManagerSettings(MTMouseHIDManager *this)
{
  __int16 v21 = (const void *)(*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 624))(this);
  uint64_t v2 = (const void *)(*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 632))(this);
  BOOL v20 = (const void *)(*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 640))(this);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFTypeID v4 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  CFIndex v5 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  BOOL v7 = CFDictionaryCreateMutable(v3, 2, v4, v5);
  CFArrayRef v8 = CFArrayCreateMutable(v3, 0, MEMORY[0x263EFFF70]);
  CFNumberRef v9 = (unsigned __int8 *)(*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 880))(this);
  __int16 v17 = 0;
  (*(void (**)(MTMouseHIDManager *, const void *, __CFString *, void, void, void, void, void, __int16))(*(void *)this + 872))(this, v2, @"One Finger", *v9, v9[1], v9[5], 0, 0, v17);
  LOWORD(v18) = *(_WORD *)(v9 + 3);
  (*(void (**)(MTMouseHIDManager *, const void *, __CFString *, void, void, void, void, void, int))(*(void *)this + 872))(this, v2, @"Two Fingers", *v9, v9[1], 0, 0, v9[7], v18);
  LOWORD(v19) = 0;
  (*(void (**)(MTMouseHIDManager *, const void *, __CFString *, void, void, void, void, void, int))(*(void *)this + 872))(this, v2, @"Three Fingers", *v9, v9[1], 0, v9[6], 0, v19);
  CFDictionaryAddValue(v7, @"LookupBySubset", @"TouchingFingers");
  MTPListGestureConfig::addChordMappingToArray(v8, (__CFArray *)@"1 Finger", @"One Finger", v10);
  MTPListGestureConfig::addChordMappingToArray(v8, (__CFArray *)@"2 Fingers", @"Two Fingers", v11);
  MTPListGestureConfig::addChordMappingToArray(v8, (__CFArray *)@"3 Fingers", @"Three Fingers", v12);
  CFDictionaryAddValue(v7, @"Chords", v8);
  CFDictionaryAddValue(Mutable, @"Right", v7);
  obunint64_t j = 0;
  (*(void (**)(MTMouseHIDManager *, uint64_t))(*(void *)this + 592))(this, 1);
  MTParser::clear(*((void **)this + 42), 0, 0, v13);
  MTGestureConfig::clearAllChords(*(MTGestureConfig **)(*((void *)this + 42) + 72));
  MTPListGestureConfig::setMotionSensitivitiesDictionary(*(MTPListGestureConfig **)(*((void *)this + 42) + 72), v21);
  MTPListGestureConfig::setGestureSetsDictionary(*(MTPListGestureConfig **)(*((void *)this + 42) + 72), v2);
  MTPListGestureConfig::setActionEventsDictionary(*(MTPListGestureConfig **)(*((void *)this + 42) + 72), v20);
  MTPListGestureConfig::setChordMappingsDictionary(*(MTPListGestureConfig **)(*((void *)this + 42) + 72), Mutable);
  MTPListGestureConfig::parseCreateGestureConfig(*(MTPListGestureConfig **)(*((void *)this + 42) + 72), (const __CFString **)&obj);
  *(_WORD *)(*(void *)(*((void *)this + 42) + 56) + 138) = 1;
  if (obj)
  {
    CFShow(obj);
    CFRelease(obj);
    obunint64_t j = 0;
  }
  if (v9[2]) {
    CFStringRef v14 = (void *)MEMORY[0x263EFFB40];
  }
  else {
    CFStringRef v14 = (void *)MEMORY[0x263EFFB38];
  }
  (*(void (**)(MTMouseHIDManager *, __CFString *, void))(*(void *)this + 568))(this, @"SupportsGestureScrolling", *v14);
  (*(void (**)(MTMouseHIDManager *, __CFString *, __CFString *))(*(void *)this + 568))(this, @"DeviceTypeHint", @"Mouse");
  int v15 = CFArrayCreateMutable(v3, 0, MEMORY[0x263EFFF70]);
  int v16 = v15;
  if (v9[2]) {
    CFArrayAppendValue(v15, @"Scroll");
  }
  (*(void (**)(MTMouseHIDManager *, __CFString *, __CFArray *))(*(void *)this + 568))(this, @"SupportedGestures", v16);
  CFRelease(v16);
  CFRelease(v21);
  CFRelease(v2);
  CFRelease(v20);
  CFRelease(v8);
  CFRelease(v7);
  CFRelease(Mutable);
}

uint64_t MTMouseHIDManager::updateEventDispatcherSettings(MTMouseHIDManager *this)
{
  uint64_t result = (*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 120))(this);
  if (result)
  {
    *(unsigned char *)((*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 120))(this) + 432) = 0;
    *(_DWORD *)((*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 120))(this) + 436) = 0;
    uint64_t v3 = (*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 120))(this);
    uint64_t result = (*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 880))(this);
    char v4 = *(unsigned char *)(result + 8);
    if (v4)
    {
      uint64_t result = (*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 880))(this);
      char v4 = *(unsigned char *)(result + 9) != 0;
    }
    *(unsigned char *)(v3 + 532) = v4;
  }
  return result;
}

void MTMouseHIDManager::getTrackpadSettings(MTMouseHIDManager *this)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v4 = 136315906;
    CFIndex v5 = "[Error] ";
    __int16 v6 = 2080;
    BOOL v7 = "MTMouseHIDManager::";
    __int16 v8 = 2080;
    CFNumberRef v9 = "getTrackpadSettings";
    __int16 v10 = 2048;
    CFStringRef v11 = this;
    _os_log_impl(&dword_2406FB000, v2, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s (%p): Error: invalid use of getTrackpadSettings()", (uint8_t *)&v4, 0x2Au);
  }
  exception = __cxa_allocate_exception(8uLL);
  void *exception = this;
}

uint64_t MTMouseHIDManager::getMouseSettings(MTMouseHIDManager *this)
{
  return (uint64_t)this + 352;
}

double MTMouseHIDManager::initDefaultMouseSettings(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    *(_WORD *)(a3 + 8) = 0;
    *(void *)a3 = 0;
    (*(void (**)(uint64_t))(*(void *)a1 + 688))(a1);
    *(void *)&double result = 65793;
    *(_DWORD *)a3 = 65793;
    *(_DWORD *)(a3 + 4) = 16843009;
    *(_WORD *)(a3 + 8) = 257;
  }
  return result;
}

__CFDictionary *MTMouseHIDManager::createDefaultMotionSensitivitiesDictionary(MTMouseHIDManager *this)
{
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  uint64_t v2 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  uint64_t v3 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v37 = 1035489772;
  int valuePtr = 1140457472;
  int v36 = 971419597;
  int v34 = 0;
  int v35 = 1097859072;
  CFNumberRef v5 = CFNumberCreate(v1, kCFNumberFloat32Type, &valuePtr);
  CFNumberRef v6 = CFNumberCreate(v1, kCFNumberFloat32Type, &v35);
  CFNumberRef v7 = CFNumberCreate(v1, kCFNumberFloat32Type, &v34);
  CFNumberRef v8 = CFNumberCreate(v1, kCFNumberFloat32Type, &v36);
  CFNumberRef v9 = CFNumberCreate(v1, kCFNumberFloat32Type, &v37);
  __int16 v10 = CFDictionaryCreateMutable(v1, 0, v2, v3);
  CFStringRef v11 = v10;
  if (v5) {
    BOOL v12 = v10 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12)
  {
    if (!v5)
    {
      if (!v6) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }
  }
  else
  {
    CFDictionaryRemoveAllValues(v10);
    CFDictionaryAddValue(v11, @"Resolution_dpi", v5);
    CFDictionaryAddValue(v11, @"AccelThresh", v6);
    CFDictionaryAddValue(v11, @"AccelPower", v7);
    CFDictionaryAddValue(v11, @"FrameDecay_mm", v8);
    CFDictionaryAddValue(v11, @"CommitMultiplier", v9);
    CFDictionaryAddValue(Mutable, @"Mouse Scrolling", v11);
  }
  CFRelease(v5);
  if (v6) {
LABEL_8:
  }
    CFRelease(v6);
LABEL_9:
  if (v7) {
    CFRelease(v7);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v11) {
    CFRelease(v11);
  }
  int v35 = 1097859072;
  int v33 = 1087373312;
  int v34 = 1039516303;
  int v32 = 1079194419;
  int v30 = 1056964608;
  int v31 = 1106247680;
  CFNumberRef v13 = CFNumberCreate(v1, kCFNumberFloat32Type, &v33);
  CFNumberRef v14 = CFNumberCreate(v1, kCFNumberFloat32Type, &v35);
  CFNumberRef v15 = CFNumberCreate(v1, kCFNumberFloat32Type, &v34);
  CFNumberRef v16 = CFNumberCreate(v1, kCFNumberFloat32Type, &v32);
  CFNumberRef v17 = CFNumberCreate(v1, kCFNumberFloat32Type, &v31);
  CFNumberRef v18 = CFNumberCreate(v1, kCFNumberFloat32Type, &v30);
  int v19 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  BOOL v20 = v19;
  if (v13 && v14 && v15)
  {
    CFDictionaryRemoveAllValues(v19);
    CFDictionaryAddValue(v20, @"Resolution_mm", v13);
    CFDictionaryAddValue(v20, @"AccelThresh", v14);
    CFDictionaryAddValue(v20, @"AccelPower", v15);
    CFDictionaryAddValue(v20, @"FluidAnimationStartThreshold_mm", v16);
    CFDictionaryAddValue(v20, @"FluidSwipeCompleteThreshold_mm", v17);
    CFDictionaryAddValue(v20, @"FluidSwipeInertiaTime_s", v18);
    CFDictionaryAddValue(Mutable, @"Mouse Vertical Swipe", v20);
  }
  else if (!v13)
  {
    goto LABEL_25;
  }
  CFRelease(v13);
LABEL_25:
  if (v14) {
    CFRelease(v14);
  }
  if (v15) {
    CFRelease(v15);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v18) {
    CFRelease(v18);
  }
  if (v20) {
    CFRelease(v20);
  }
  int v35 = 1097859072;
  int v33 = 1083179008;
  int v34 = 1041865114;
  CFNumberRef v21 = CFNumberCreate(v1, kCFNumberFloat32Type, &v33);
  CFNumberRef v22 = CFNumberCreate(v1, kCFNumberFloat32Type, &v35);
  CFNumberRef v23 = CFNumberCreate(v1, kCFNumberFloat32Type, &v34);
  CFNumberRef v24 = CFNumberCreate(v1, kCFNumberFloat32Type, &v32);
  CFNumberRef v25 = CFNumberCreate(v1, kCFNumberFloat32Type, &v31);
  CFNumberRef v26 = CFNumberCreate(v1, kCFNumberFloat32Type, &v30);
  uint64_t v27 = CFDictionaryCreateMutable(v1, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  BOOL v28 = v27;
  if (v21 && v22 && v23 && v24 && v25 && v26)
  {
    CFDictionaryRemoveAllValues(v27);
    CFDictionaryAddValue(v28, @"Resolution_mm", v21);
    CFDictionaryAddValue(v28, @"AccelThresh", v22);
    CFDictionaryAddValue(v28, @"AccelPower", v23);
    CFDictionaryAddValue(v28, @"FluidAnimationStartThreshold_mm", v24);
    CFDictionaryAddValue(v28, @"FluidSwipeCompleteThreshold_mm", v25);
    CFDictionaryAddValue(v28, @"FluidSwipeInertiaTime_s", v26);
    CFDictionaryAddValue(Mutable, @"Mouse Horizontal Swipe", v28);
  }
  else if (!v21)
  {
    goto LABEL_46;
  }
  CFRelease(v21);
LABEL_46:
  if (v22) {
    CFRelease(v22);
  }
  if (v23) {
    CFRelease(v23);
  }
  if (v24) {
    CFRelease(v24);
  }
  if (v25) {
    CFRelease(v25);
  }
  if (v26) {
    CFRelease(v26);
  }
  if (v28) {
    CFRelease(v28);
  }
  return Mutable;
}

MTPListGestureConfig *MTMouseHIDManager::createDefaultActionEventsDictionary(MTMouseHIDManager *this)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Secondary Click", @"Mouse Click", @"Button2", 0, v2);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Scroll", @"Scroll", 0, 0, v3);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Scroll To Edge", @"Scroll To Edge", 0, 0, v4);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Orientation", @"Orientation", 0, 0, v5);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Zoom Toggle", @"Zoom Toggle", 0, 0, v6);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Show Definition", @"Show Definition", 0, 0, v7);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Fluid Navigation", @"Fluid Navigation", 0, 0, v8);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Fluid Dock", @"Fluid Dock", 0, 0, v9);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Fluid Notification", @"Fluid Notification", 0, 0, v10);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Fluid Notification Alt", @"Fluid Notification Alt", 0, 0, v11);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Swipe Left", @"Swipe", 0, 0, v12);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Swipe Right", @"Swipe", 0, 0, v13);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Swipe Up", @"Swipe", 0, 0, v14);
  MTPListGestureConfig::addActionEventToDictionary(Mutable, (__CFDictionary *)@"Swipe Down", @"Swipe", 0, 0, v15);
  return Mutable;
}

void MTMouseHIDManager::createMouseScrollSwipeTapCombo(MTMouseHIDManager *this, __CFDictionary *a2, const __CFString *a3, int a4, int a5, int a6, int a7, int a8, BOOL a9, BOOL a10)
{
  CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  CFMutableDictionaryRef v18 = CFDictionaryCreateMutable(v16, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int v19 = v18;
  if (Mutable) {
    BOOL v20 = v18 == 0;
  }
  else {
    BOOL v20 = 1;
  }
  if (!v20)
  {
    CFStringRef v30 = a3;
    int v21 = a4 | a5;
    BOOL v22 = a9 || a10;
    if (v22) {
      CFNumberRef v23 = @"WaitForQuick Momentum";
    }
    else {
      CFNumberRef v23 = @"Momentum";
    }
    CFNumberRef v24 = @"OncePerDirection";
    if (v21) {
      CFNumberRef v24 = @"OncePerDirection OnlyIfAllMoving";
    }
    BOOL v28 = v23;
    unsigned int v29 = v24;
    if (a6)
    {
      MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Zoom Toggle", @"DoubleTap", 0, 0, 0, 0, 0, v23);
      if (!a7)
      {
LABEL_18:
        if (!a8) {
          goto LABEL_19;
        }
        goto LABEL_37;
      }
    }
    else if (!a7)
    {
      goto LABEL_18;
    }
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Show Definition", @"DoubleTap", 0, 0, 0, 0, 0, v28);
    if (!a8)
    {
LABEL_19:
      if (a5)
      {
LABEL_20:
        if ((a4 & a5) != 0) {
          CFStringRef v25 = @"Translate";
        }
        else {
          CFStringRef v25 = @"Vertical";
        }
        MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Scroll", v25, @"Mouse Scrolling", v28, @"LockOnFirst", 0, 0, v28);
      }
LABEL_24:
      if (v22)
      {
        if (a10) {
          CFNumberRef v26 = @"Fluid Dock";
        }
        else {
          CFNumberRef v26 = @"Fluid Navigation";
        }
        MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)v26, @"Horizontal", @"Mouse Horizontal Swipe", v29, 0, 0, 0, v28);
      }
      if (v21 | !v22) {
        uint64_t v27 = @"ToMoreFingers ToFewerFingers FromFewerFingers FromMoreFingers";
      }
      else {
        uint64_t v27 = @"ToMoreFingers";
      }
      CFDictionaryAddValue(v19, @"Transitions", v27);
      CFDictionaryAddValue(v19, @"Gestures", Mutable);
      CFDictionaryAddValue(a2, v30, v19);
LABEL_33:
      CFRelease(Mutable);
      if (!v19) {
        return;
      }
      goto LABEL_8;
    }
LABEL_37:
    MTPListGestureConfig::addGestureToArray(Mutable, (__CFArray *)@"Fluid Dock", @"DoubleTap", 0, 0, 0, 0, 0, v28);
    if (a5) {
      goto LABEL_20;
    }
    goto LABEL_24;
  }
  if (Mutable) {
    goto LABEL_33;
  }
  if (!v18) {
    return;
  }
LABEL_8:

  CFRelease(v19);
}

CFMutableDictionaryRef MTMouseHIDManager::createDefaultGestureSetsDictionary(MTMouseHIDManager *this)
{
  return CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
}

uint64_t MTMouseHIDManager::updateMouseMotionFilter(MTMouseHIDManager *this, float a2, float a3, int a4)
{
  uint64_t result = MTAbsoluteTimeGetCurrent();
  double v8 = v7 - *((double *)this + 47);
  if (!a4 || v8 >= 0.0329999998)
  {
    float32x2_t v9 = vabs_f32((float32x2_t)__PAIR64__(LODWORD(a3), LODWORD(a2)));
    float32x2_t v25 = *(float32x2_t *)((char *)this + 364);
    double v10 = v8 / 0.00800000038;
    if (vaddv_f32(v25) <= 5.0) {
      long double v11 = 0.870000005;
    }
    else {
      long double v11 = 0.699999988;
    }
    long double v12 = pow(v11, v10);
    *(float *)&long double v12 = v12;
    int32x2_t v23 = *(int32x2_t *)&v12;
    long double v13 = pow(0.200000003, v10);
    *(float *)&long double v13 = v13;
    float32x2_t v14 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v9, v25), (int8x8_t)vdup_lane_s32(*(int32x2_t *)&v13, 0), (int8x8_t)vdup_lane_s32(v23, 0));
    __asm { FMOV            V1.2S, #1.0 }
    *(float32x2_t *)((char *)this + 364) = vmla_f32(vmul_f32(v9, vsub_f32(_D1, v14)), v25, v14);
    if ((*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 864))(this))
    {
      if (*(void *)((*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 864))(this) + 56))
      {
        uint64_t v20 = (*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 864))(this);
        MTHandMotion::storeFeedbackFromMouse(*(void *)(v20 + 56), *((float *)this + 91), *((float *)this + 92));
      }
    }
    uint64_t result = MTAbsoluteTimeGetCurrent();
    *((void *)this + 47) = v21;
  }
  return result;
}

uint64_t MTMouseHIDManager::tickleMouseMotionFilter(MTMouseHIDManager *this)
{
  MTMouseHIDManager::updateMouseMotionFilter(this, 0.0, 0.0, 1);

  return MTMouseHIDManager::updateButtonMotionFilter(this, 0.0, 0);
}

uint64_t MTMouseHIDManager::updateButtonMotionFilter(MTMouseHIDManager *this, float a2, int a3)
{
  MTAbsoluteTimeGetCurrent();
  if (a3)
  {
    *((float *)this + 96) = a2;
  }
  else
  {
    float v7 = pow(0.699999988, (v6 - *((double *)this + 49)) / 0.0112500004);
    *((float *)this + 96) = (float)((float)(1.0 - v7) * a2) + (float)(v7 * *((float *)this + 96));
  }
  if ((*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 864))(this)
    && *(void *)((*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 864))(this) + 56))
  {
    uint64_t v8 = (*(uint64_t (**)(MTMouseHIDManager *))(*(void *)this + 864))(this);
    MTHandMotion::storeFeedbackFromButton(*(void *)(v8 + 56), *((float *)this + 96));
  }
  uint64_t result = MTAbsoluteTimeGetCurrent();
  *((void *)this + 49) = v10;
  return result;
}

uint64_t MTMouseHIDManager::handleTrackingDataForMotionFilter(uint64_t a1, uint64_t a2, int a3, int a4, unsigned int a5)
{
  if (a5 && a5 != 400)
  {
    float v5 = 400.0 / (double)a5;
    a3 = (int)(float)((float)a3 * v5);
    a4 = (int)(float)((float)a4 * v5);
  }
  (*(void (**)(uint64_t, void, float, float))(*(void *)a1 + 912))(a1, 0, (float)a3, (float)a4);
  return 1;
}

uint64_t MTMouseHIDManager::handleButtonState(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (a3 != a4) {
    (*(void (**)(uint64_t, uint64_t, float))(*(void *)a1 + 920))(a1, 1, 1.0);
  }
  return 1;
}

uint64_t MTMouseHIDManager::handleFrameProcessingEntryExit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (a5) {
    (*(void (**)(uint64_t))(*(void *)a1 + 928))(a1);
  }
  return 1;
}

void MTMouseHIDManager::~MTMouseHIDManager(MTMouseHIDManager *this)
{
  MTSimpleHIDManager::~MTSimpleHIDManager(this);

  JUMPOUT(0x2455F6CE0);
}

uint64_t MTParameterFactory::initFingerTipOffsetParams(uint64_t result, int a2, char a3, int a4)
{
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)uint64_t result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  if ((a2 - 2000) > 0x3E7)
  {
    if ((a2 - 1000) <= 0x3E7)
    {
      *(_DWORD *)uint64_t result = 1;
      *(_DWORD *)(result + 8) = 1077936128;
      float v5 = (_DWORD *)(result + 36);
      if (a3 < 0 || a4)
      {
        *(_OWORD *)(result + 12) = xmmword_24074FCE0;
        *(void *)(result + 28) = 0x4108000041200000;
        _DWORD *v5 = 0;
        *(_DWORD *)(result + 39) = 0;
        *(_WORD *)(result + 43) = 257;
        int v6 = 1053609165;
      }
      else
      {
        *(_OWORD *)(result + 12) = xmmword_24074FCD0;
        *(void *)(result + 28) = 0x40E0000041F00000;
        _DWORD *v5 = 0;
        *(_DWORD *)(result + 39) = 0;
        *(_WORD *)(result + 43) = 257;
        int v6 = 1057132380;
      }
      *(_DWORD *)(result + 48) = v6;
      goto LABEL_16;
    }
    if (a2 == 4)
    {
      *(_DWORD *)uint64_t result = 1;
      long long v7 = xmmword_24074FCA0;
    }
    else
    {
      if (a2 == 2)
      {
        *(_DWORD *)uint64_t result = 1;
        *(_OWORD *)(result + 8) = xmmword_24074FCA0;
        *(_OWORD *)(result + 24) = xmmword_24074FCB0;
        *(_DWORD *)(result + 40) = 65793;
        *(unsigned char *)(result + 44) = 0;
        *(unsigned char *)(result + 52) = 1;
        return result;
      }
      *(_DWORD *)uint64_t result = 1;
      long long v7 = xmmword_24074FCC0;
    }
    *(_OWORD *)(result + 8) = v7;
    long long v4 = xmmword_24074FCB0;
  }
  else
  {
    *(_DWORD *)uint64_t result = 1;
    *(_OWORD *)(result + 8) = xmmword_24074FCF0;
    long long v4 = xmmword_24074FD00;
  }
  *(_OWORD *)(result + 24) = v4;
  *(_DWORD *)(result + 40) = 65793;
  *(unsigned char *)(result + 44) = 0;
LABEL_16:
  *(unsigned char *)(result + 52) = 0;
  return result;
}

double MTParameterFactory::initForceFilterParams(_OWORD *a1)
{
  double result = 0.125000028;
  *a1 = xmmword_24074FD10;
  return result;
}

double MTParameterFactory::initForceThresholdQualifiers(uint64_t a1)
{
  *(void *)a1 = 0x3F4000003F000000;
  *(_OWORD *)(a1 + 12) = xmmword_24074FD20;
  *(_OWORD *)(a1 + 28) = xmmword_24074FD30;
  *(_OWORD *)(a1 + 44) = xmmword_24074FD40;
  *(_OWORD *)(a1 + 60) = xmmword_24074FD50;
  *(_OWORD *)(a1 + 76) = xmmword_24074FD60;
  *(_OWORD *)(a1 + 92) = xmmword_24074FD70;
  *(_OWORD *)(a1 + 108) = xmmword_24074FD80;
  double result = 2.85924567e20;
  *(void *)(a1 + 124) = 0x442F00003E19999ALL;
  *(_DWORD *)(a1 + 132) = 1148846080;
  return result;
}

double MTParameterFactory::initForceActuationQualifiers(uint64_t a1)
{
  *(unsigned char *)(a1 + 28) = 1;
  *(_OWORD *)a1 = xmmword_24074FD90;
  double result = 5.23869072e-11;
  *(void *)(a1 + 16) = 0x3DCCCCCD3F333333;
  *(_DWORD *)(a1 + 24) = 1065353216;
  return result;
}

double MTParameterFactory::initBasicForceActuationQualifiers(uint64_t a1)
{
  *(unsigned char *)(a1 + 28) = 0;
  *(_OWORD *)a1 = xmmword_24074FDA0;
  *(void *)&double result = 1065353216;
  *(void *)(a1 + 16) = 1065353216;
  *(_DWORD *)(a1 + 24) = 1065353216;
  return result;
}

void MTParameterFactory::initPathFilterParams(uint64_t a1, unsigned int a2, __int16 a3, int a4, uint64_t a5, unsigned int a6)
{
  unsigned int v6 = a6;
  char v8 = a3;
  uint64_t v25 = *MEMORY[0x263EF8340];
  *(unsigned char *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 80) = 1;
  *(unsigned char *)(a1 + 102) = 0;
  *(_OWORD *)(a1 + 112) = xmmword_24074FDB0;
  *(_OWORD *)(a1 + 64) = xmmword_24074FDC0;
  if (a2 <= 0x3E7)
  {
    float v10 = 0.8;
    if ((a3 & 0x100) != 0) {
      float v10 = 0.5;
    }
    *(float *)(a1 + 4) = v10;
    *(void *)(a1 + 56) = 0x3EA28F5C40000000;
    *(unsigned char *)(a1 + 96) = 1;
    *(_WORD *)(a1 + 80) = 256;
    *(unsigned char *)(a1 + 102) = 1;
    *(_OWORD *)(a1 + 112) = xmmword_24074FE00;
    if (a2 == 4)
    {
      *(_OWORD *)(a1 + 56) = xmmword_24074FE10;
      *(_DWORD *)(a1 + 4) = 0;
    }
    goto LABEL_8;
  }
  *(unsigned char *)(a1 + 8MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = 1;
  *(_DWORD *)(a1 + 4) = 1061997773;
  if (a2 - 3000 <= 0x3E7)
  {
    *(void *)(a1 + 56) = 0x3EA28F5C40000000;
    *(unsigned char *)(a1 + 96) = 1;
    *(unsigned char *)(a1 + 80) = 0;
    *(unsigned char *)(a1 + 102) = 1;
LABEL_8:
    BOOL v11 = a2 - 3000 < 0xFFFFFC18;
    unsigned int v12 = a2 - 2000;
    goto LABEL_9;
  }
  float v14 = 2.66;
  if (!a4) {
    float v14 = 2.0;
  }
  float v15 = 0.127;
  if (a4) {
    float v15 = 0.16891;
  }
  *(float *)(a1 + 56) = v14;
  *(float *)(a1 + 60) = v15;
  unsigned int v12 = a2 - 2000;
  if (a2 - 2000 < 0x3E8)
  {
    char v13 = 0;
    *(_DWORD *)(a1 + 60) = 1045435305;
    *(_DWORD *)(a1 + 72) = 0x40000000;
    *(_OWORD *)(a1 + 4) = xmmword_24074FDD0;
    *(_OWORD *)(a1 + 20) = xmmword_24074FDE0;
    *(_OWORD *)(a1 + 36) = xmmword_24074FDF0;
    *(void *)(a1 + 52) = 0x4080000040266666;
    *(_DWORD *)(a1 + 92) = 1032000111;
    *(_WORD *)(a1 + 97) = 257;
    *(void *)(a1 + 84) = 0x3D75C2903CA3D70BLL;
    goto LABEL_20;
  }
  BOOL v11 = 1;
LABEL_9:
  *(_OWORD *)(a1 + 8) = xmmword_24074FE20;
  *(_OWORD *)(a1 + 24) = xmmword_24074FE30;
  *(_OWORD *)(a1 + 40) = xmmword_24074FE40;
  *(void *)(a1 + 84) = 0x3E9FBE773D449BA6;
  *(_DWORD *)(a1 + 92) = 1032000111;
  *(unsigned char *)(a1 + 98) = 0;
  if (v12 > 0xFFFFFC17)
  {
    *(_DWORD *)(a1 + 76) = 1036831949;
    *(unsigned char *)(a1 + 97) = v11 & a4 ^ 1;
    char v13 = 1;
  }
  else if (v11)
  {
    char v13 = 0;
    *(unsigned char *)(a1 + 97) = 0;
  }
  else
  {
    char v13 = 0;
    *(unsigned char *)(a1 + 97) = 1;
  }
LABEL_20:
  *(unsigned char *)(a1 + 99) = v13;
  *(unsigned char *)(a1 + 100) = v13;
  *(unsigned char *)(a1 + 10MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v13;
  if (a6 >= 5)
  {
    CFAllocatorRef v16 = MTLoggingPlugin();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      int v17 = 136315906;
      CFMutableDictionaryRef v18 = "[Error] ";
      __int16 v19 = 2080;
      uint64_t v20 = "MTParameterFactory::";
      __int16 v21 = 2080;
      BOOL v22 = "_InitRadiusCorrectionParams";
      __int16 v23 = 1024;
      unsigned int v24 = v6;
      _os_log_impl(&dword_2406FB000, v16, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s invalid size ID (%u)", (uint8_t *)&v17, 0x26u);
    }
    unsigned int v6 = 0;
  }
  *(void *)(a1 + 104) = qword_24074FEFC[v6];
  MTParameterFactory::updatePathFilterParamsWithNewSurfaceDimensions(a1, a5);
  *(unsigned char *)(a1 + 128) = (v8 & 0x40) != 0;
}

float MTParameterFactory::updatePathFilterParamsWithNewSurfaceDimensions(uint64_t a1, uint64_t a2)
{
  float v3 = fabsf(MTSurfaceDimensions::convertMillimetersToPixels(a2, 1.0));
  *(float *)a1 = v3;
  if (*(unsigned char *)(a1 + 81))
  {
    float result = v3 * *(float *)(a1 + 60);
    *(float *)(a1 + 56) = result;
  }
  else
  {
    float result = *(float *)(a1 + 56) / v3;
    *(float *)(a1 + 60) = result;
  }
  return result;
}

double MTParameterFactory::initRestZoneBalanceParameters(uint64_t a1)
{
  *(_OWORD *)a1 = xmmword_24074FE50;
  *(_OWORD *)(a1 + 16) = xmmword_24074FE60;
  double result = 5.23869071e-11;
  *(_OWORD *)(a1 + 32) = xmmword_24074FE70;
  *(_DWORD *)(a1 + 48) = -1082130432;
  return result;
}

double MTParameterFactory::initMotionExtractionParams(uint64_t a1)
{
  double result = 512.000116;
  *(void *)a1 = 0x408000003CF5C290;
  *(_WORD *)(a1 + 8) = 257;
  return result;
}

uint64_t MTParameterFactory::initChordCyclingParams(uint64_t result, int a2)
{
  *(void *)double result = 0x3CCCCCCD3F19999ALL;
  BOOL v2 = (a2 - 2000) < 0x3E8;
  float v3 = 10.0;
  *(unsigned char *)(result + 8) = v2;
  if ((a2 - 2000) < 0x3E8) {
    float v3 = 4.0;
  }
  *(unsigned char *)(result + 16) = v2;
  *(float *)(result + 12) = v3;
  return result;
}

double MTParameterFactory::initTouchZoneParams(uint64_t a1, int a2, uint64_t a3, int a4)
{
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if ((a2 - 1000) <= 0x3E7)
  {
    *(unsigned char *)a1 = 1;
    float v5 = 3.0;
    if (a4) {
      float v5 = 0.5;
    }
    float v6 = 18.0;
    if (a4) {
      float v6 = 6.0;
    }
    *(float *)(a1 + 20) = v5;
    *(float *)(a1 + 28) = v6;
    double result = 375809602.0;
    *(_OWORD *)(a1 + 4) = xmmword_24074FE80;
    *(_DWORD *)(a1 + 24) = 1094713344;
  }
  return result;
}

void MTTrackpadEmbeddedEventDispatcher::createDispatcher()
{
}

void sub_24073729C(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10A1C40A9B27C98);
  _Unwind_Resume(a1);
}

void MTTrackpadEmbeddedEventDispatcher::initialize(uint64_t a1, MTSimpleHIDManager *a2, const void *a3)
{
  *(void *)(a1 + 552) = MTABCLogger::createLogger();

  MTTrackpadEventDispatcher::initialize(a1, a2, a3);
}

MTABCLogger *MTTrackpadEmbeddedEventDispatcher::finalize(MTTrackpadEmbeddedEventDispatcher *this)
{
  MTTrackpadEventDispatcher::finalize(this);
  BOOL v2 = (id *)*((void *)this + 70);
  if (v2)
  {
    MTABCLogger::endSession(*((void *)this + 69), v2, 0);
    *((void *)this + 70) = 0;
  }
  double result = (MTABCLogger *)*((void *)this + 69);
  if (result)
  {
    MTABCLogger::~MTABCLogger(result);
    double result = (MTABCLogger *)MEMORY[0x2455F6CE0]();
  }
  *((void *)this + 69) = 0;
  return result;
}

void MTTrackpadEmbeddedEventDispatcher::dispatchScrollEvent(MTTrackpadEmbeddedEventDispatcher *this, float a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  BOOL v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 136315650;
    long long v4 = "[Error] ";
    __int16 v5 = 2080;
    float v6 = "MTTrackpadEmbeddedEventDispatcher::";
    __int16 v7 = 2080;
    char v8 = "dispatchScrollEvent";
    _os_log_impl(&dword_2406FB000, v2, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected request to dispatch a Scroll event. Ignoring.", (uint8_t *)&v3, 0x20u);
  }
}

void MTTrackpadEmbeddedEventDispatcher::dispatchPointingEvent(MTTrackpadEmbeddedEventDispatcher *this, int a2, int a3, int a4, unint64_t a5, char a6)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  if ((a6 & 1) == 0)
  {
    char v13 = MTLoggingPlugin();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315650;
    unsigned int v24 = "[Error] ";
    __int16 v25 = 2080;
    CFNumberRef v26 = "MTTrackpadEmbeddedEventDispatcher::";
    __int16 v27 = 2080;
    BOOL v28 = "dispatchPointingEvent";
    float v10 = "[HID] [MT] %s%s%s Unexpected request to dispatch a Pointer event. Ignoring.";
    BOOL v11 = v13;
    uint32_t v12 = 32;
    goto LABEL_8;
  }
  int v7 = a3 | a2;
  if (!(a3 | a2) && *((_DWORD *)this + 131) == a4)
  {
    char v8 = MTLoggingPlugin();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v9 = *((_DWORD *)this + 131);
    *(_DWORD *)buf = 136315906;
    unsigned int v24 = "[Error] ";
    __int16 v25 = 2080;
    CFNumberRef v26 = "MTTrackpadEmbeddedEventDispatcher::";
    __int16 v27 = 2080;
    BOOL v28 = "dispatchPointingEvent";
    __int16 v29 = 1024;
    *(_DWORD *)CFStringRef v30 = v9;
    float v10 = "[HID] [MT] %s%s%s No change in device button state(%u). Ignoring.";
    BOOL v11 = v8;
    uint32_t v12 = 38;
LABEL_8:
    _os_log_impl(&dword_2406FB000, v11, OS_LOG_TYPE_ERROR, v10, buf, v12);
    return;
  }
  *((_DWORD *)this + 13MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = a4;
  int v14 = *((_DWORD *)this + 130) | a4;
  *((_DWORD *)this + 136) = v14;
  if (*((unsigned char *)this + 512)) {
    BOOL v15 = (v14 & 1) == 0;
  }
  else {
    BOOL v15 = 1;
  }
  if (!v15) {
    *((_DWORD *)this + 136) = v14 & 0xFFFFFFFC | 2;
  }
  RelativePointeruint64_t Event = IOHIDEventCreateRelativePointerEvent();
  if (RelativePointerEvent)
  {
    int v17 = (const void *)RelativePointerEvent;
    memset(__str, 170, 11);
    if (*((_DWORD *)this + 136) == *((_DWORD *)this + 129)) {
      strcpy(__str, "no");
    }
    else {
      snprintf(__str, 0xBuLL, "0x%08x", *((_DWORD *)this + 136));
    }
    __int16 v21 = MTLoggingPlugin();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v24 = "";
      BOOL v22 = "yes";
      *(_DWORD *)buf = 136316162;
      CFNumberRef v26 = "MTTrackpadEmbeddedEventDispatcher::";
      __int16 v25 = 2080;
      __int16 v27 = 2080;
      BOOL v28 = "dispatchPointingEvent";
      if (!v7) {
        BOOL v22 = "no";
      }
      __int16 v29 = 2082;
      *(void *)CFStringRef v30 = v22;
      *(_WORD *)&v30[8] = 2082;
      int v31 = __str;
      _os_log_impl(&dword_2406FB000, v21, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Dispatching Pointer event (displacement? %{public}s) from FW (button? %{public}s)", buf, 0x34u);
    }
    (*(void (**)(MTTrackpadEmbeddedEventDispatcher *, const void *, void))(*(void *)this + 40))(this, v17, 0);
    CFRelease(v17);
  }
  else
  {
    CFMutableDictionaryRef v18 = MTLoggingPlugin();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      int v19 = *((_DWORD *)this + 136);
      int v20 = *((_DWORD *)this + 129);
      *(_DWORD *)buf = 136316162;
      unsigned int v24 = "[Error] ";
      __int16 v25 = 2080;
      CFNumberRef v26 = "MTTrackpadEmbeddedEventDispatcher::";
      __int16 v27 = 2080;
      BOOL v28 = "dispatchPointingEvent";
      __int16 v29 = 1024;
      *(_DWORD *)CFStringRef v30 = v19;
      *(_WORD *)&v30[4] = 1024;
      *(_DWORD *)&v30[6] = v20;
      _os_log_impl(&dword_2406FB000, v18, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Failed to create relative pointer event with combined button state(%u) and previous button state(%u)", buf, 0x2Cu);
    }
  }
  *((_DWORD *)this + 129) = *((_DWORD *)this + 136);
}

uint64_t MTTrackpadEmbeddedEventDispatcher::shouldDispatchPointerEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  IOHIDEventGetFloatValue();
  float v15 = v14;
  IOHIDEventGetFloatValue();
  *(float *)&double v16 = v16;
  int v17 = *(float *)&v16 != 0.0 || v15 != 0.0;
  CFArrayRef Children = (const __CFArray *)IOHIDEventGetChildren();
  if (Children) {
    CFIndex Count = CFArrayGetCount(Children);
  }
  else {
    CFIndex Count = 0;
  }
  if ((IOHIDEventGetIntegerValue() & 2) != 0
    || (char v20 = IOHIDEventGetIntegerValue(), a4)
    || v20 < 0
    || a5 && (IOHIDEventGetPhase() & 0xD) != 0
    || a6 && (IOHIDEventGetPhase() & 0xD) != 0
    || a7 && (IOHIDEventGetPhase() & 0xD) != 0
    || a8 && (IOHIDEventGetPhase() & 0xD) != 0)
  {
    memset(__str, 170, 11);
    if (a4)
    {
      IntegerCFNumberRef Value = IOHIDEventGetIntegerValue();
      snprintf(__str, 0xBuLL, "0x%08x", IntegerValue);
    }
    else
    {
      strcpy(__str, "no");
    }
    BOOL v22 = MTLoggingPlugin();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      if (v17) {
        __int16 v23 = "yes";
      }
      else {
        __int16 v23 = "no";
      }
      uint64_t v33 = v23;
      uint64_t v35 = a1;
      unsigned int v24 = (IOHIDEventGetIntegerValue() >> 7) & 1;
      int v34 = v17;
      BOOL v25 = IOHIDEventGetIntegerValue() == 1;
      *(_DWORD *)buf = 136318210;
      uint64_t v38 = "";
      BOOL v26 = IOHIDEventGetIntegerValue() == 1;
      __int16 v39 = 2080;
      uint64_t v40 = "MTTrackpadEmbeddedEventDispatcher::";
      if (a5) {
        __int16 v27 = "yes";
      }
      else {
        __int16 v27 = "no";
      }
      __int16 v41 = 2080;
      CFNumberRef v42 = "shouldDispatchPointerEvent";
      __int16 v43 = 2082;
      if (a6) {
        BOOL v28 = "yes";
      }
      else {
        BOOL v28 = "no";
      }
      CFNumberRef v44 = v33;
      if (a7) {
        __int16 v29 = "yes";
      }
      else {
        __int16 v29 = "no";
      }
      __int16 v45 = 2048;
      if (a8) {
        CFStringRef v30 = "yes";
      }
      else {
        CFStringRef v30 = "no";
      }
      CFIndex v46 = Count;
      __int16 v47 = 1024;
      unsigned int v48 = v24;
      a1 = v35;
      __int16 v49 = 1024;
      BOOL v50 = v25;
      int v17 = v34;
      __int16 v51 = 1024;
      BOOL v52 = v26;
      __int16 v53 = 2082;
      uint64_t v54 = __str;
      __int16 v55 = 2082;
      CFNumberRef v56 = v27;
      __int16 v57 = 2082;
      CFNumberRef v58 = v28;
      __int16 v59 = 2082;
      CFNumberRef v60 = v29;
      __int16 v61 = 2082;
      char v62 = v30;
      _os_log_impl(&dword_2406FB000, v22, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Dispatching Pointer event (displacement? %{public}s) with digitizer (%lu contacts, cancel=%d, touching=%d, inrange=%d), button? %{public}s, scroll? %{public}s, scale? %{public}s, rotate? %{public}s, translate? %{public}s", buf, 0x78u);
    }
  }
  if (IOHIDEventGetIntegerValue() || (IOHIDEventGetIntegerValue() & 2) != 0 || (IOHIDEventGetIntegerValue() & 1) != 0)
  {
    unsigned int v31 = 1;
  }
  else if (a4 | a5 | a6 | a7 | a8)
  {
    unsigned int v31 = 1;
  }
  else
  {
    unsigned int v31 = v17;
  }
  if (*(void *)(a1 + 552)) {
    MTTrackpadEmbeddedEventDispatcher::sanityCheck(a1, a3, a5, a6, a7, a8, v17);
  }
  if (*(unsigned char *)(a1 + 424)) {
    return 1;
  }
  else {
    return v31;
  }
}

void MTTrackpadEmbeddedEventDispatcher::sanityCheck(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  int v12 = *(unsigned __int8 *)(a1 + 569);
  BOOL v13 = *(unsigned char *)(a1 + 569) != 0;
  if (a3)
  {
    char Phase = IOHIDEventGetPhase();
    BOOL v16 = (Phase & 0xC) == 0 && v12 != 0;
    BOOL v13 = (Phase & 1) != 0 || v16;
  }
  *(unsigned char *)(a1 + 569) = v13;
  int v17 = *(unsigned __int8 *)(a1 + 570);
  BOOL v18 = *(unsigned char *)(a1 + 570) != 0;
  if (a4)
  {
    char v19 = IOHIDEventGetPhase();
    BOOL v21 = (v19 & 0xC) == 0 && v17 != 0;
    BOOL v18 = (v19 & 1) != 0 || v21;
  }
  *(unsigned char *)(a1 + 570) = v18;
  int v22 = *(unsigned __int8 *)(a1 + 571);
  BOOL v23 = *(unsigned char *)(a1 + 571) != 0;
  if (a5)
  {
    char v24 = IOHIDEventGetPhase();
    BOOL v26 = (v24 & 0xC) == 0 && v22 != 0;
    BOOL v23 = (v24 & 1) != 0 || v26;
  }
  *(unsigned char *)(a1 + 57MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v23;
  int v27 = *(unsigned __int8 *)(a1 + 572);
  BOOL v28 = *(unsigned char *)(a1 + 572) != 0;
  if (a6)
  {
    char v29 = IOHIDEventGetPhase();
    BOOL v31 = (v29 & 0xC) == 0 && v27 != 0;
    BOOL v28 = (v29 & 1) != 0 || v31;
  }
  *(unsigned char *)(a1 + 572) = v28;
  if (*(unsigned char *)(a1 + 570))
  {
    int v32 = 1;
  }
  else if (*(unsigned char *)(a1 + 571))
  {
    int v32 = 1;
  }
  else
  {
    int v32 = v28;
  }
  CFArrayRef Children = (const __CFArray *)IOHIDEventGetChildren();
  if (Children && (CFArrayRef v34 = Children, CFArrayGetCount(Children) >= 1))
  {
    CFIndex v35 = 0;
    unsigned int v36 = 0;
    do
    {
      CFArrayGetValueAtIndex(v34, v35);
      if (IOHIDEventGetIntegerValue() == 1) {
        ++v36;
      }
      ++v35;
    }
    while (v35 < CFArrayGetCount(v34));
    if (v36 >= 2)
    {
      if (!*(void *)(a1 + 560)) {
        MTABCLogger::startSession(*(MTABCLogger **)(a1 + 552), "ipados_trackpad_orientation_gesture", 60.0);
      }
      unsigned int v36 = 1;
    }
  }
  else
  {
    unsigned int v36 = 0;
  }
  char v37 = v32 ^ 1;
  if (!*(unsigned char *)(a1 + 569)) {
    char v37 = 1;
  }
  if ((v37 & 1) == 0)
  {
    uint64_t v38 = MTLoggingPlugin();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      __int16 v39 = "yes";
      if (*(unsigned char *)(a1 + 570)) {
        uint64_t v40 = "yes";
      }
      else {
        uint64_t v40 = "no";
      }
      int v41 = *(unsigned __int8 *)(a1 + 571);
      __int16 v59 = "[Error] ";
      __int16 v61 = "MTTrackpadEmbeddedEventDispatcher::";
      int v42 = *(unsigned __int8 *)(a1 + 572);
      if (v41) {
        __int16 v43 = "yes";
      }
      else {
        __int16 v43 = "no";
      }
      int v58 = 136316418;
      __int16 v60 = 2080;
      if (!v42) {
        __int16 v39 = "no";
      }
      __int16 v62 = 2080;
      CFTypeID v63 = "sanityCheck";
      __int16 v64 = 2082;
      int v65 = v40;
      __int16 v66 = 2082;
      int v67 = v43;
      __int16 v68 = 2082;
      int v69 = v39;
      _os_log_impl(&dword_2406FB000, v38, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Attempting to scroll at the same time we scale %{public}s / rotate %{public}s / translate %{public}s", (uint8_t *)&v58, 0x3Eu);
    }
    *(unsigned char *)(a1 + 568) = 1;
  }
  if ((v32 & a7) == 1)
  {
    CFNumberRef v44 = MTLoggingPlugin();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      __int16 v45 = "yes";
      if (*(unsigned char *)(a1 + 570)) {
        CFIndex v46 = "yes";
      }
      else {
        CFIndex v46 = "no";
      }
      int v47 = *(unsigned __int8 *)(a1 + 571);
      __int16 v59 = "[Error] ";
      __int16 v61 = "MTTrackpadEmbeddedEventDispatcher::";
      int v48 = *(unsigned __int8 *)(a1 + 572);
      if (v47) {
        __int16 v49 = "yes";
      }
      else {
        __int16 v49 = "no";
      }
      int v58 = 136316418;
      __int16 v60 = 2080;
      if (!v48) {
        __int16 v45 = "no";
      }
      __int16 v62 = 2080;
      CFTypeID v63 = "sanityCheck";
      __int16 v64 = 2082;
      int v65 = v46;
      __int16 v66 = 2082;
      int v67 = v49;
      __int16 v68 = 2082;
      int v69 = v45;
      _os_log_impl(&dword_2406FB000, v44, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Active pointer at the same time we scale %{public}s / rotate %{public}s / translate %{public}s (stuck orientation gesture?)", (uint8_t *)&v58, 0x3Eu);
    }
    *(unsigned char *)(a1 + 568) = 1;
  }
  if (!v36)
  {
    BOOL v50 = *(id **)(a1 + 560);
    if (v50)
    {
      if (v32)
      {
        __int16 v51 = MTLoggingPlugin();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
        {
          BOOL v52 = "yes";
          if (*(unsigned char *)(a1 + 570)) {
            __int16 v53 = "yes";
          }
          else {
            __int16 v53 = "no";
          }
          int v54 = *(unsigned __int8 *)(a1 + 571);
          __int16 v59 = "[Error] ";
          __int16 v61 = "MTTrackpadEmbeddedEventDispatcher::";
          int v55 = *(unsigned __int8 *)(a1 + 572);
          if (v54) {
            CFNumberRef v56 = "yes";
          }
          else {
            CFNumberRef v56 = "no";
          }
          int v58 = 136316418;
          __int16 v60 = 2080;
          if (!v55) {
            BOOL v52 = "no";
          }
          __int16 v62 = 2080;
          CFTypeID v63 = "sanityCheck";
          __int16 v64 = 2082;
          int v65 = v53;
          __int16 v66 = 2082;
          int v67 = v56;
          __int16 v68 = 2082;
          int v69 = v52;
          _os_log_impl(&dword_2406FB000, v51, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s No contacts but we are still trying to scale %{public}s / rotate %{public}s / translate %{public}s (stuck orientation gesture?)", (uint8_t *)&v58, 0x3Eu);
        }
        BOOL v57 = 1;
        *(unsigned char *)(a1 + 568) = 1;
        BOOL v50 = *(id **)(a1 + 560);
      }
      else
      {
        BOOL v57 = *(unsigned char *)(a1 + 568) != 0;
      }
      MTABCLogger::endSession(*(void *)(a1 + 552), v50, v57);
      *(void *)(a1 + 560) = 0;
      *(unsigned char *)(a1 + 568) = 0;
    }
  }
}

void MTTrackpadEmbeddedEventDispatcher::dispatchEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if (IOHIDEventGetType() == 17)
  {
    CFArrayRef Children = (const __CFArray *)IOHIDEventGetChildren();
    if (!Children || !CFArrayGetCount(Children))
    {
      int v7 = MTLoggingPlugin();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = 136315650;
        float v10 = "";
        __int16 v11 = 2080;
        int v12 = "MTTrackpadEmbeddedEventDispatcher::";
        __int16 v13 = 2080;
        double v14 = "dispatchEvent";
        _os_log_impl(&dword_2406FB000, v7, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Dispatching standalone Pointer event", (uint8_t *)&v9, 0x20u);
      }
    }
    MTSimpleEventDispatcher::dispatchEvent(a1, a2, a3);
  }
  else
  {
    char v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v9 = 136315906;
      float v10 = "[Error] ";
      __int16 v11 = 2080;
      int v12 = "MTTrackpadEmbeddedEventDispatcher::";
      __int16 v13 = 2080;
      double v14 = "dispatchEvent";
      __int16 v15 = 1024;
      int Type = IOHIDEventGetType();
      _os_log_impl(&dword_2406FB000, v8, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected standalone event type: %u. Eating it", (uint8_t *)&v9, 0x26u);
    }
  }
}

void MTTrackpadEmbeddedEventDispatcher::handleEvent(unsigned int *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v108 = *MEMORY[0x263EF8340];
  if (IOHIDEventGetType() == 11)
  {
    if (IOHIDEventGetIntegerValue() == 1) {
      goto LABEL_3;
    }
    int8x16_t v89 = MTLoggingPlugin();
    if (!os_log_type_enabled(v89, OS_LOG_TYPE_ERROR)) {
      goto LABEL_3;
    }
    *(_DWORD *)buf = 136315650;
    v99 = "[Error] ";
    __int16 v100 = 2080;
    v101 = "MTTrackpadEmbeddedEventDispatcher::";
    __int16 v102 = 2080;
    v103 = "handleEvent";
    long long v86 = "[HID] [MT] %s%s%s Unexpected digitizer event. Eating it.";
    long long v87 = v89;
    uint32_t v88 = 32;
  }
  else
  {
    v85 = MTLoggingPlugin();
    if (!os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)) {
      goto LABEL_3;
    }
    *(_DWORD *)buf = 136315906;
    v99 = "[Error] ";
    __int16 v100 = 2080;
    v101 = "MTTrackpadEmbeddedEventDispatcher::";
    __int16 v102 = 2080;
    v103 = "handleEvent";
    __int16 v104 = 1024;
    LODWORD(v105) = IOHIDEventGetType();
    long long v86 = "[HID] [MT] %s%s%s Unexpected event type: %u Eating it.";
    long long v87 = v85;
    uint32_t v88 = 38;
  }
  _os_log_impl(&dword_2406FB000, v87, OS_LOG_TYPE_ERROR, v86, buf, v88);
LABEL_3:
  (*(void (**)(unsigned int *))(*(void *)a1 + 112))(a1);
  uint64_t Children = IOHIDEventGetChildren();
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  if (Children)
  {
    CFArrayRef v8 = (const __CFArray *)IOHIDEventGetChildren();
    CFArrayRef Copy = CFArrayCreateCopy(v7, v8);
    CFIndex Count = CFArrayGetCount(Copy);
  }
  else
  {
    CFArrayRef Copy = 0;
    CFIndex Count = 0;
  }
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v7, 0, MEMORY[0x263EFFF70]);
  mach_absolute_time();
  RelativePointeruint64_t Event = IOHIDEventCreateRelativePointerEvent();
  __int16 v13 = (const void *)RelativePointerEvent;
  if (Mutable) {
    BOOL v14 = RelativePointerEvent == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14)
  {
    BOOL v16 = 0;
    long long v76 = 0;
    long long v77 = 0;
    long long v79 = 0;
    long long v78 = 0;
  }
  else
  {
    unsigned int v91 = a3;
    v96 = (const void *)RelativePointerEvent;
    if (Count >= 1)
    {
      CFIndex v15 = 0;
      uint64_t v92 = 0;
      uint64_t v93 = 0;
      uint64_t v94 = 0;
      uint64_t v95 = 0;
      BOOL v16 = 0;
      char v97 = 0;
      while (1)
      {
        CFArrayGetValueAtIndex(Copy, v15);
        if (IOHIDEventGetType() != 11) {
          break;
        }
LABEL_62:
        if (Count == ++v15) {
          goto LABEL_106;
        }
      }
      if (IOHIDEventGetType() == 17)
      {
        if (*((unsigned char *)a1 + 541)) {
          goto LABEL_59;
        }
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        if ((v97 & 1) == 0)
        {
          IOHIDEventSetFloatValue();
          IOHIDEventSetFloatValue();
          char v97 = 1;
          goto LABEL_59;
        }
        uint64_t v33 = v16;
        __int16 v62 = MTLoggingPlugin();
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v99 = "[Error] ";
          __int16 v100 = 2080;
          v101 = "MTTrackpadEmbeddedEventDispatcher::";
          __int16 v102 = 2080;
          v103 = "handleEvent";
          _os_log_impl(&dword_2406FB000, v62, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected multiple pointer events. Eating it.", buf, 0x20u);
        }
        char v97 = 1;
        goto LABEL_75;
      }
      if (IOHIDEventGetType() == 2)
      {
        IntegerCFNumberRef Value = IOHIDEventGetIntegerValue();
        a1[130] = IntegerValue;
        int v18 = a1[131] | IntegerValue;
        a1[136] = v18;
        if (*((unsigned char *)a1 + 512) && (v18 & 1) != 0) {
          a1[136] = v18 & 0xFFFFFFFC | 2;
        }
        if (v16)
        {
          char v19 = v16;
          mach_absolute_time();
          char v20 = (const void *)IOHIDEventCreateRelativePointerEvent();
          if (v20)
          {
            BOOL v21 = v20;
            CFArrayAppendValue(Mutable, v20);
            CFRelease(v21);
          }
          BOOL v16 = v19;
          __int16 v13 = v96;
        }
        else
        {
          IOHIDEventSetFloatValue();
          mach_absolute_time();
          IOHIDEventGetEventFlags();
          uint64_t ButtonEvent = IOHIDEventCreateButtonEvent();
          BOOL v16 = (const void *)ButtonEvent;
          if (!ButtonEvent
            || (int8x8_t v38 = (int8x8_t)a1[136], v38.i32[0])
            && (uint8x8_t v39 = (uint8x8_t)vcnt_s8(v38), v39.i16[0] = vaddlv_u8(v39), v39.i32[0] > 1u))
          {
            long long v78 = (const void *)v92;
            long long v79 = (const void *)v93;
            long long v77 = (const void *)v94;
            long long v76 = (const void *)v95;
            goto LABEL_114;
          }
          uint64_t v40 = (const void *)ButtonEvent;
          IOHIDEventSetIntegerValue();
          BOOL v16 = v40;
          IOHIDEventSetIntegerValue();
          IOHIDEventAppendEvent();
        }
        a1[129] = a1[136];
        goto LABEL_59;
      }
      if (IOHIDEventGetType() == 6)
      {
        if (!*((unsigned char *)a1 + 540)) {
          goto LABEL_59;
        }
        IOHIDEventGetFloatValue();
        float v23 = v22;
        IOHIDEventGetFloatValue();
        float v25 = v24;
        IOHIDEventGetFloatValue();
        BOOL v28 = v23 != 0.0;
        if (v25 != 0.0) {
          BOOL v28 = 1;
        }
        float v27 = v26;
        int v29 = v27 != 0.0 || v28;
        NextScrollchar Phase = MTTrackpadEventDispatcher::getNextScrollPhase((MTTrackpadEventDispatcher *)a1, a1[132], v29);
        a1[132] = NextScrollPhase;
        if (!(unsigned __int16)MTTrackpadEventDispatcher::getHIDPhaseFromScrollPhase((MTTrackpadEventDispatcher *)a1, NextScrollPhase))goto LABEL_59; {
        long long v90 = v16;
        }
        if (v95)
        {
          BOOL v31 = MTLoggingPlugin();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315650;
            v99 = "[Debug] ";
            __int16 v100 = 2080;
            v101 = "MTTrackpadEmbeddedEventDispatcher::";
            __int16 v102 = 2080;
            v103 = "handleEvent";
            _os_log_impl(&dword_2406FB000, v31, OS_LOG_TYPE_DEBUG, "[HID] [MT] %s%s%s Multiple scroll events. Merging.", buf, 0x20u);
          }
          uint64_t v32 = v95;
          IOHIDEventGetFloatValue();
          IOHIDEventSetFloatValue();
          IOHIDEventGetFloatValue();
          IOHIDEventSetFloatValue();
          IOHIDEventGetFloatValue();
          IOHIDEventSetFloatValue();
        }
        else
        {
          mach_absolute_time();
          IOHIDEventGetEventFlags();
          uint64_t ScrollEvent = IOHIDEventCreateScrollEvent();
          if (!ScrollEvent)
          {
            long long v76 = 0;
            long long v78 = (const void *)v92;
            long long v79 = (const void *)v93;
            long long v77 = (const void *)v94;
            goto LABEL_114;
          }
          uint64_t v32 = ScrollEvent;
          IOHIDEventAppendEvent();
        }
        uint64_t v95 = v32;
        IOHIDEventSetPhase();
        goto LABEL_58;
      }
      if (IOHIDEventGetType() == 7)
      {
        uint64_t v33 = v16;
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        IOHIDEventGetPhase();
        if (!v94)
        {
          mach_absolute_time();
          IOHIDEventGetEventFlags();
          uint64_t ScaleEvent = IOHIDEventCreateScaleEvent();
          if (!ScaleEvent)
          {
            long long v77 = 0;
            long long v78 = (const void *)v92;
            long long v79 = (const void *)v93;
            goto LABEL_112;
          }
          uint64_t v35 = ScaleEvent;
          IOHIDEventSetPhase();
          unsigned int v36 = v96;
          uint64_t v94 = v35;
LABEL_54:
          IOHIDEventAppendEvent();
          BOOL v16 = v33;
          __int16 v13 = v36;
          goto LABEL_59;
        }
        CFTypeID v63 = MTLoggingPlugin();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v99 = "[Error] ";
          __int16 v100 = 2080;
          v101 = "MTTrackpadEmbeddedEventDispatcher::";
          __int16 v102 = 2080;
          v103 = "handleEvent";
          BOOL v52 = v63;
          os_log_type_t v53 = OS_LOG_TYPE_ERROR;
          int v54 = "[HID] [MT] %s%s%s Unexpected multiple scale events. Eating the latest.";
          goto LABEL_73;
        }
        goto LABEL_75;
      }
      if (IOHIDEventGetType() == 5)
      {
        uint64_t v33 = v16;
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        IOHIDEventGetPhase();
        if (!v93)
        {
          mach_absolute_time();
          IOHIDEventGetEventFlags();
          uint64_t RotationEvent = IOHIDEventCreateRotationEvent();
          if (!RotationEvent)
          {
            long long v79 = 0;
            long long v78 = (const void *)v92;
            goto LABEL_142;
          }
          uint64_t v42 = RotationEvent;
          IOHIDEventSetPhase();
          unsigned int v36 = v96;
          uint64_t v93 = v42;
          goto LABEL_54;
        }
        __int16 v64 = MTLoggingPlugin();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v99 = "[Error] ";
          __int16 v100 = 2080;
          v101 = "MTTrackpadEmbeddedEventDispatcher::";
          __int16 v102 = 2080;
          v103 = "handleEvent";
          BOOL v52 = v64;
          os_log_type_t v53 = OS_LOG_TYPE_ERROR;
          int v54 = "[HID] [MT] %s%s%s Unexpected multiple rotate events. Eating the latest.";
          goto LABEL_73;
        }
        goto LABEL_75;
      }
      if (IOHIDEventGetType() == 4)
      {
        uint64_t v33 = v16;
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        IOHIDEventGetFloatValue();
        IOHIDEventGetPhase();
        if (!v92)
        {
          mach_absolute_time();
          IOHIDEventGetEventFlags();
          uint64_t TranslationEvent = IOHIDEventCreateTranslationEvent();
          if (!TranslationEvent)
          {
            long long v78 = 0;
            long long v79 = (const void *)v93;
LABEL_142:
            long long v77 = (const void *)v94;
LABEL_112:
            long long v76 = (const void *)v95;
            goto LABEL_113;
          }
          uint64_t v44 = TranslationEvent;
          IOHIDEventSetPhase();
          unsigned int v36 = v96;
          uint64_t v92 = v44;
          goto LABEL_54;
        }
        int v65 = MTLoggingPlugin();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v99 = "[Error] ";
          __int16 v100 = 2080;
          v101 = "MTTrackpadEmbeddedEventDispatcher::";
          __int16 v102 = 2080;
          v103 = "handleEvent";
          BOOL v52 = v65;
          os_log_type_t v53 = OS_LOG_TYPE_ERROR;
          int v54 = "[HID] [MT] %s%s%s Unexpected multiple translate events. Eating the latest.";
          goto LABEL_73;
        }
        goto LABEL_75;
      }
      if (IOHIDEventGetType() != 1)
      {
        uint64_t v33 = v16;
        if (IOHIDEventGetType() != 32)
        {
          if (IOHIDEventGetType() == 3)
          {
            int v72 = MTLoggingPlugin();
            if (!os_log_type_enabled(v72, OS_LOG_TYPE_ERROR)) {
              goto LABEL_75;
            }
            uint64_t v73 = IOHIDEventGetIntegerValue();
            *(_DWORD *)buf = 136315906;
            v99 = "[Error] ";
            __int16 v100 = 2080;
            v101 = "MTTrackpadEmbeddedEventDispatcher::";
            __int16 v102 = 2080;
            v103 = "handleEvent";
            __int16 v104 = 2048;
            uint64_t v105 = v73;
            BOOL v52 = v72;
            os_log_type_t v53 = OS_LOG_TYPE_ERROR;
            int v54 = "[HID] [MT] %s%s%s Unexpected keyboard child event with usage %lu. Eating it";
          }
          else
          {
            int Type = IOHIDEventGetType();
            BOOL v57 = MTLoggingPlugin();
            BOOL v58 = os_log_type_enabled(v57, OS_LOG_TYPE_ERROR);
            if (Type != 24)
            {
              BOOL v16 = v33;
              if (v58)
              {
                int v59 = IOHIDEventGetType();
                *(_DWORD *)buf = 136315906;
                v99 = "[Error] ";
                __int16 v100 = 2080;
                v101 = "MTTrackpadEmbeddedEventDispatcher::";
                __int16 v102 = 2080;
                v103 = "handleEvent";
                __int16 v104 = 1024;
                LODWORD(v105) = v59;
                _os_log_impl(&dword_2406FB000, v57, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected child event type: %u. Eating it", buf, 0x26u);
              }
              goto LABEL_80;
            }
            if (!v58) {
              goto LABEL_75;
            }
            uint64_t v74 = IOHIDEventGetIntegerValue();
            *(_DWORD *)buf = 136315906;
            v99 = "[Error] ";
            __int16 v100 = 2080;
            v101 = "MTTrackpadEmbeddedEventDispatcher::";
            __int16 v102 = 2080;
            v103 = "handleEvent";
            __int16 v104 = 2048;
            uint64_t v105 = v74;
            BOOL v52 = v57;
            os_log_type_t v53 = OS_LOG_TYPE_ERROR;
            int v54 = "[HID] [MT] %s%s%s Unexpected hotkey child event with value %lu. Eating it";
          }
          uint32_t v55 = 42;
          goto LABEL_74;
        }
        __int16 v51 = MTLoggingPlugin();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315650;
          v99 = "[Debug] ";
          __int16 v100 = 2080;
          v101 = "MTTrackpadEmbeddedEventDispatcher::";
          __int16 v102 = 2080;
          v103 = "handleEvent";
          BOOL v52 = v51;
          os_log_type_t v53 = OS_LOG_TYPE_DEBUG;
          int v54 = "[HID] [MT] %s%s%s Force event. Ignoring.";
LABEL_73:
          uint32_t v55 = 32;
LABEL_74:
          _os_log_impl(&dword_2406FB000, v52, v53, v54, buf, v55);
        }
LABEL_75:
        BOOL v16 = v33;
LABEL_80:
        __int16 v13 = v96;
LABEL_59:
        if (IOHIDEventGetChildren())
        {
          CFArrayRef v46 = (const __CFArray *)IOHIDEventGetChildren();
          if (CFArrayGetCount(v46) >= 1)
          {
            __int16 v60 = MTLoggingPlugin();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
            {
              int v61 = IOHIDEventGetType();
              *(_DWORD *)buf = 136315906;
              v99 = "[Error] ";
              __int16 v100 = 2080;
              v101 = "MTTrackpadEmbeddedEventDispatcher::";
              __int16 v102 = 2080;
              v103 = "handleEvent";
              __int16 v104 = 1024;
              LODWORD(v105) = v61;
              _os_log_impl(&dword_2406FB000, v60, OS_LOG_TYPE_ERROR, "[HID] [MT] %s%s%s Unexpected grandchild events inside event type: %u. Eating them", buf, 0x26u);
            }
          }
        }
        IOHIDEventRemoveEvent();
        goto LABEL_62;
      }
      long long v90 = v16;
      uint64_t v47 = IOHIDEventGetIntegerValue();
      uint64_t v48 = IOHIDEventGetIntegerValue();
      uint64_t v49 = v48;
      if (v47 == 65280 && v48 == 17)
      {
        BOOL v50 = MTLoggingPlugin();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315650;
          v99 = "[Debug] ";
          __int16 v100 = 2080;
          v101 = "MTTrackpadEmbeddedEventDispatcher::";
          __int16 v102 = 2080;
          v103 = "handleEvent";
          _os_log_impl(&dword_2406FB000, v50, OS_LOG_TYPE_DEBUG, "[HID] [MT] %s%s%s Vendor-defined Force event. Appending!", buf, 0x20u);
        }
        IOHIDEventAppendEvent();
LABEL_58:
        BOOL v16 = v90;
        goto LABEL_59;
      }
      __int16 v66 = MTLoggingPlugin();
      int v67 = v66;
      if (v47 == 65280 && v49 == 1)
      {
        if (!os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
        {
LABEL_97:
          BOOL v16 = v90;
          goto LABEL_80;
        }
        *(_DWORD *)buf = 136315650;
        v99 = "[Debug] ";
        __int16 v100 = 2080;
        v101 = "MTTrackpadEmbeddedEventDispatcher::";
        __int16 v102 = 2080;
        v103 = "handleEvent";
        __int16 v68 = v67;
        os_log_type_t v69 = OS_LOG_TYPE_DEBUG;
        uint64_t v70 = "[HID] [MT] %s%s%s Vendor-defined Momentum event. Ignoring.";
        uint32_t v71 = 32;
      }
      else
      {
        if (!os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
          goto LABEL_97;
        }
        *(_DWORD *)buf = 136316162;
        v99 = "[Error] ";
        __int16 v100 = 2080;
        v101 = "MTTrackpadEmbeddedEventDispatcher::";
        __int16 v102 = 2080;
        v103 = "handleEvent";
        __int16 v104 = 2048;
        uint64_t v105 = v47;
        __int16 v106 = 2048;
        uint64_t v107 = v49;
        __int16 v68 = v67;
        os_log_type_t v69 = OS_LOG_TYPE_ERROR;
        uint64_t v70 = "[HID] [MT] %s%s%s Unexpected vendor-defined child event with usage page %lu and usage %lu. Eating it";
        uint32_t v71 = 52;
      }
      _os_log_impl(&dword_2406FB000, v68, v69, v70, buf, v71);
      goto LABEL_97;
    }
    BOOL v16 = 0;
    uint64_t v94 = 0;
    uint64_t v95 = 0;
    uint64_t v92 = 0;
    uint64_t v93 = 0;
LABEL_106:
    IOHIDEventAppendEvent();
    uint64_t v75 = a2;
    long long v77 = (const void *)v94;
    long long v76 = (const void *)v95;
    long long v78 = (const void *)v92;
    long long v79 = (const void *)v93;
    if (MTTrackpadEmbeddedEventDispatcher::shouldDispatchPointerEvent((uint64_t)a1, (uint64_t)v13, v75, (uint64_t)v16, v95, v94, v93, v92))
    {
      long long v80 = v13;
      uint64_t v33 = v16;
      (*(void (**)(unsigned int *, const void *, void))(*(void *)a1 + 40))(a1, v80, v91);
      CFIndex v81 = CFArrayGetCount(Mutable);
      if (v81 >= 1)
      {
        CFIndex v82 = v81;
        for (CFIndex i = 0; i != v82; ++i)
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(Mutable, i);
          if (ValueAtIndex) {
            (*(void (**)(unsigned int *, const void *, void))(*(void *)a1 + 40))(a1, ValueAtIndex, v91);
          }
        }
        goto LABEL_112;
      }
LABEL_113:
      BOOL v16 = v33;
      __int16 v13 = v96;
    }
  }
LABEL_114:
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (Copy) {
    CFRelease(Copy);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v76) {
    CFRelease(v76);
  }
  if (v77) {
    CFRelease(v77);
  }
  if (v79) {
    CFRelease(v79);
  }
  if (v78) {
    CFRelease(v78);
  }
}

void MTTrackpadEmbeddedEventDispatcher::~MTTrackpadEmbeddedEventDispatcher(MTTrackpadEmbeddedEventDispatcher *this)
{
  *(void *)this = &unk_26F4DA178;
  std::__list_imp<double>::clear((void *)this + 61);
  std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy((uint64_t)this + 464, *((void **)this + 59));

  MTSimpleEventDispatcher::~MTSimpleEventDispatcher(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26F4DA178;
  std::__list_imp<double>::clear((void *)this + 61);
  std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::destroy((uint64_t)this + 464, *((void **)this + 59));
  MTSimpleEventDispatcher::~MTSimpleEventDispatcher(this);

  JUMPOUT(0x2455F6CE0);
}

uint64_t MTModeSwitcher::createModeSwitcher(MTModeSwitcher *this, MTSimpleHIDManager *a2)
{
  uint64_t v2 = (*(uint64_t (**)(MTModeSwitcher *, MTSimpleHIDManager *))(*(void *)this + 80))(this, a2);
  if (v2)
  {
    if (MTDeviceGetMultipleFirmwaresConfig())
    {
      if (MTDeviceGetParserType() == 4) {
        operator new();
      }
      operator new();
    }
    return 0;
  }
  return v2;
}

void sub_2407395D0(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10A1C4054FFC65BLL);
  _Unwind_Resume(a1);
}

void MTNoOpModeSwitcher::MTNoOpModeSwitcher(MTNoOpModeSwitcher *this, MTSimpleHIDManager *a2)
{
  *((void *)this + 2) = 255;
  *((unsigned char *)this + 24) = 0;
  *(void *)((char *)this + 28) = 255;
  *(void *)this = &unk_26F4DAF80;
  *((void *)this + MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = a2;
}

{
  *((void *)this + 2) = 255;
  *((unsigned char *)this + 24) = 0;
  *(void *)((char *)this + 28) = 255;
  *(void *)this = &unk_26F4DAF80;
  *((void *)this + MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = a2;
}

void MTMultipleFirmwaresModeSwitcher::MTMultipleFirmwaresModeSwitcher(MTMultipleFirmwaresModeSwitcher *this, MTSimpleHIDManager *a2)
{
  *((void *)this + 2) = 255;
  *((unsigned char *)this + 24) = 0;
  *(void *)((char *)this + 28) = 255;
  *(void *)this = &unk_26F4DAFC0;
  *((void *)this + MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = a2;
  operator new();
}

{
  *((void *)this + 2) = 255;
  *((unsigned char *)this + 24) = 0;
  *(void *)((char *)this + 28) = 255;
  *(void *)this = &unk_26F4DAFC0;
  *((void *)this + MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = a2;
  operator new();
}

uint64_t MTMultipleFirmwaresModeSwitcher::init(MTMultipleFirmwaresModeSwitcher *this, const __CFDictionary *a2)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  (*(void (**)(void))(**((void **)this + 1) + 80))(*((void *)this + 1));
  *(void *)(*((void *)this + 5) + 8) = [(__CFDictionary *)a2 objectForKeyedSubscript:@"BootloaderProperty"];
  *(void *)(*((void *)this + 5) + 16) = [(__CFDictionary *)a2 objectForKeyedSubscript:@"ActivePayload"];
  uint64_t v4 = [(__CFDictionary *)a2 objectForKeyedSubscript:@"TTWPayload"];
  __int16 v5 = (void *)*((void *)this + 5);
  void v5[3] = v4;
  if (v5[1])
  {
    if (v5[2] && v4 != 0)
    {
      char v9 = MTDevicePowerControlSupported();
      if (v9)
      {
        *(_DWORD *)((char *)&v26 + 3) = -1431655766;
        LODWORD(v26) = -1431655766;
        if (MTDeviceGetSensorRegionOfType())
        {
          float v10 = objc_msgSend(MEMORY[0x263F56718], "getDeviceInServiceTree:", MTDeviceGetService(), v26);
          if (v10)
          {
            uint64_t v11 = [v10 getBootLoader];
            uint64_t v12 = *((void *)this + 5);
            *(void *)uint64_t v12 = v11;
            if (v11)
            {
              id v13 = *(id *)(v12 + 8);
              id v14 = *(id *)(*((void *)this + 5) + 16);
              id v15 = *(id *)(*((void *)this + 5) + 24);
              id v16 = **((id **)this + 5);
              MTDeviceGetDeviceID();
              uint64_t v17 = MTLoggingPlugin();
              if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
              {
                int v18 = (void *)*((void *)this + 5);
                CFDictionaryRef v19 = (const __CFDictionary *)v18[1];
                uint64_t v20 = v18[2];
                uint64_t v21 = v18[3];
                *(_DWORD *)buf = 138544130;
                CFDictionaryRef v28 = v19;
                __int16 v29 = 2114;
                uint64_t v30 = v20;
                __int16 v31 = 2114;
                uint64_t v32 = v21;
                __int16 v33 = 2048;
                uint64_t v34 = 0;
                _os_log_impl(&dword_2406FB000, v17, OS_LOG_TYPE_DEFAULT, "Device using a FW binary switcher %{public}@ (active: %{public}@, ttw: %{public}@) (deviceID 0x%llX)", buf, 0x2Au);
              }
              return 0;
            }
            MTDeviceGetDeviceID();
            double v24 = MTLoggingPlugin();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134217984;
              CFDictionaryRef v28 = 0;
              float v25 = "Device doesn't have an AHTBootloader (deviceID 0x%llX)";
              goto LABEL_27;
            }
          }
          else
          {
            MTDeviceGetDeviceID();
            double v24 = MTLoggingPlugin();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134217984;
              CFDictionaryRef v28 = 0;
              float v25 = "Device doesn't have AHTDevice (deviceID 0x%llX)";
LABEL_27:
              _os_log_impl(&dword_2406FB000, v24, OS_LOG_TYPE_ERROR, v25, buf, 0xCu);
            }
          }
          return 3758097136;
        }
        MTDeviceGetDeviceID();
        double v22 = MTLoggingPlugin();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134217984;
          CFDictionaryRef v28 = 0;
          float v23 = "We don't support multiple firmwares in prox integrated devices (deviceID 0x%llX)";
          goto LABEL_21;
        }
      }
      else
      {
        MTDeviceGetDeviceID();
        double v22 = MTLoggingPlugin();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134217984;
          CFDictionaryRef v28 = 0;
          float v23 = "We don't support multiple firmwares in non-power-controlled devices (deviceID 0x%llX)";
LABEL_21:
          _os_log_impl(&dword_2406FB000, v22, OS_LOG_TYPE_ERROR, v23, buf, 0xCu);
        }
      }
      return 3758097095;
    }
  }
  MTDeviceGetDeviceID();
  CFAllocatorRef v7 = MTLoggingPlugin();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138543618;
    CFDictionaryRef v28 = a2;
    __int16 v29 = 2048;
    uint64_t v30 = 0;
    _os_log_impl(&dword_2406FB000, v7, OS_LOG_TYPE_ERROR, "Missing parts of the config: %{public}@ (deviceID 0x%llX)", buf, 0x16u);
  }
  return 3758097090;
}

void MTModeSwitcher::MTModeSwitcher(MTModeSwitcher *this, MTSimpleHIDManager *a2)
{
  *(void *)this = &unk_26F4DAF40;
  *((void *)this + MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = a2;
  *((void *)this + 2) = 255;
  *((unsigned char *)this + 24) = 0;
  *(void *)((char *)this + 28) = 255;
}

void MTModeSwitcher::transitionGraphicsOrientationTo(uint64_t a1, unsigned int a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 24) || *(_DWORD *)(a1 + 16) == 255)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
    MTDeviceGetDeviceID();
    uint64_t v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (a2 > 4) {
        __int16 v5 = "Unknown";
      }
      else {
        __int16 v5 = off_2650D3958[a2];
      }
      float v6 = "booting";
      if (!*(unsigned char *)(a1 + 24)) {
        float v6 = "off";
      }
      *(_DWORD *)buf = 136446722;
      id v13 = v5;
      __int16 v14 = 2082;
      id v15 = v6;
      __int16 v16 = 2048;
      uint64_t v17 = 0;
      _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_DEFAULT, "Setting orientation to %{public}s deferred (device %{public}s) (deviceID 0x%llX)", buf, 0x20u);
    }
    goto LABEL_10;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
  MTDeviceGetDeviceID();
  CFAllocatorRef v7 = MTLoggingPlugin();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(int *)(a1 + 20);
    if (v8 > 4) {
      char v9 = "Unknown";
    }
    else {
      char v9 = off_2650D3958[v8];
    }
    if (a2 > 4) {
      float v10 = "Unknown";
    }
    else {
      float v10 = off_2650D3958[a2];
    }
    *(_DWORD *)buf = 136446722;
    id v13 = v9;
    __int16 v14 = 2082;
    id v15 = v10;
    __int16 v16 = 2048;
    uint64_t v17 = 0;
    _os_log_impl(&dword_2406FB000, v7, OS_LOG_TYPE_DEFAULT, "Graphics orientation transitioning from %{public}s to %{public}s (deviceID 0x%llX)", buf, 0x20u);
  }
  if (*(_DWORD *)(a1 + 20) != a2)
  {
    MTModeSwitcher::setGraphicsOrientation(a1, a2);
    MTModeSwitcher::setTouchDetectionMode(a1, *(_DWORD *)(a1 + 16), a2);
LABEL_10:
    *(_DWORD *)(a1 + 20) = a2;
    return;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
  MTDeviceGetDeviceID();
  uint64_t v11 = MTLoggingPlugin();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134217984;
    id v13 = 0;
    _os_log_impl(&dword_2406FB000, v11, OS_LOG_TYPE_ERROR, "Unexpected: new orientation == old orientation (rebooting firmware?) (deviceID 0x%llX)", buf, 0xCu);
  }
}

uint64_t MTModeSwitcher::getMTDevice(MTModeSwitcher *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 80))();
}

const char *MTModeSwitcher::orientationToText(uint64_t a1, unsigned int a2)
{
  if (a2 > 4) {
    return "Unknown";
  }
  else {
    return off_2650D3958[a2];
  }
}

void MTModeSwitcher::setGraphicsOrientation(uint64_t a1, unsigned int a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
  MTDeviceGetDeviceID();
  uint64_t v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 4) {
      __int16 v5 = "Unknown";
    }
    else {
      __int16 v5 = off_2650D3958[a2];
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v12 = v5;
    __int16 v13 = 2048;
    __int16 v14 = 0;
    _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_DEFAULT, "Setting graphics orientation %{public}s (deviceID 0x%llX)", buf, 0x16u);
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
  mach_error_t v6 = MTDeviceSetReport();
  if (v6)
  {
    mach_error_t v7 = v6;
    (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
    MTDeviceGetDeviceID();
    uint64_t v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      if (a2 > 4) {
        char v9 = "Unknown";
      }
      else {
        char v9 = off_2650D3958[a2];
      }
      float v10 = mach_error_string(v7);
      *(_DWORD *)buf = 136446722;
      uint64_t v12 = v9;
      __int16 v13 = 2082;
      __int16 v14 = v10;
      __int16 v15 = 2048;
      uint64_t v16 = 0;
      _os_log_impl(&dword_2406FB000, v8, OS_LOG_TYPE_ERROR, "Error trying to set graphics orientation %{public}s: %{public}s (deviceID 0x%llX)", buf, 0x20u);
    }
  }
}

void MTModeSwitcher::setTouchDetectionMode(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
  MTDeviceGetDeviceID();
  mach_error_t v6 = MTLoggingPlugin();
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    uint64_t v8 = MTModeSwitcher::modeToText(v7, a2);
    if (a3 > 4) {
      char v9 = "Unknown";
    }
    else {
      char v9 = off_2650D3958[a3];
    }
    *(_DWORD *)buf = 136446978;
    uint64_t v18 = v8;
    __int16 v19 = 1024;
    int v20 = a2;
    __int16 v21 = 2082;
    double v22 = v9;
    __int16 v23 = 2048;
    double v24 = 0;
    _os_log_impl(&dword_2406FB000, v6, OS_LOG_TYPE_DEFAULT, "Setting touch detection mode to %{public}s (0x%x) and orientation to %{public}s (deviceID 0x%llX)", buf, 0x26u);
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
  mach_error_t v10 = MTDeviceSetTouchMode();
  if (v10)
  {
    mach_error_t v11 = v10;
    (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
    MTDeviceGetDeviceID();
    uint64_t v12 = MTLoggingPlugin();
    BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    if (v13)
    {
      __int16 v14 = MTModeSwitcher::modeToText(v13, a2);
      if (a3 > 4) {
        __int16 v15 = "Unknown";
      }
      else {
        __int16 v15 = off_2650D3958[a3];
      }
      uint64_t v16 = mach_error_string(v11);
      *(_DWORD *)buf = 136447234;
      uint64_t v18 = v14;
      __int16 v19 = 1024;
      int v20 = a2;
      __int16 v21 = 2082;
      double v22 = v15;
      __int16 v23 = 2082;
      double v24 = v16;
      __int16 v25 = 2048;
      uint64_t v26 = 0;
      _os_log_impl(&dword_2406FB000, v12, OS_LOG_TYPE_ERROR, "Error trying to set mode to %{public}s (0x%x) and orientation to %{public}s: %{public}s (deviceID 0x%llX)", buf, 0x30u);
    }
  }
}

void MTModeSwitcher::deviceDidBootload(MTModeSwitcher *this)
{
  *(void *)&v14[13] = *MEMORY[0x263EF8340];
  (*(void (**)(void))(**((void **)this + 1) + 80))(*((void *)this + 1));
  MTDeviceGetDeviceID();
  uint64_t v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)this + 24)) {
      int v3 = "expected";
    }
    else {
      int v3 = "unexpected";
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v12 = v3;
    __int16 v13 = 2048;
    *(void *)__int16 v14 = 0;
    _os_log_impl(&dword_2406FB000, v2, OS_LOG_TYPE_DEFAULT, "Device booted (%{public}s): setting touch detection mode, orientation and power (deviceID 0x%llX)", buf, 0x16u);
  }
  if (*((_DWORD *)this + 8) == 1)
  {
    (*(void (**)(void))(**((void **)this + 1) + 80))(*((void *)this + 1));
    MTDeviceGetDeviceID();
    uint64_t v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v12 = 0;
      _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_DEFAULT, "Debug mode forced to Always ON (deviceID 0x%llX)", buf, 0xCu);
    }
    *((_DWORD *)this + 7) = 0;
  }
  int v5 = *((_DWORD *)this + 4);
  if (!*((unsigned char *)this + 24)) {
    *((_DWORD *)this + 7) = v5;
  }
  *((unsigned char *)this + 24) = 0;
  if (v5 == 254) {
    unsigned int v6 = 1;
  }
  else {
    unsigned int v6 = 2 * (v5 != 255);
  }
  MTModeSwitcher::setGraphicsOrientation((uint64_t)this, *((_DWORD *)this + 5));
  MTModeSwitcher::setTouchDetectionMode((uint64_t)this, *((_DWORD *)this + 4), *((_DWORD *)this + 5));
  MTModeSwitcher::setDevicePowerState((uint64_t)this, v6);
  if (*((_DWORD *)this + 7) != *((_DWORD *)this + 4))
  {
    (*(void (**)(void))(**((void **)this + 1) + 80))(*((void *)this + 1));
    MTDeviceGetDeviceID();
    BOOL v7 = MTLoggingPlugin();
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v8)
    {
      int v9 = *((_DWORD *)this + 7);
      mach_error_t v10 = MTModeSwitcher::modeToText(v8, v9);
      *(_DWORD *)buf = 136446722;
      uint64_t v12 = v10;
      __int16 v13 = 1024;
      *(_DWORD *)__int16 v14 = v9;
      void v14[2] = 2048;
      *(void *)&v14[3] = 0;
      _os_log_impl(&dword_2406FB000, v7, OS_LOG_TYPE_DEFAULT, "Pending transition after boot. Going to %{public}s (0x%x) (deviceID 0x%llX)", buf, 0x1Cu);
    }
    (*(void (**)(MTModeSwitcher *, void, void))(*(void *)this + 16))(this, *((unsigned int *)this + 7), 0);
  }
}

void MTModeSwitcher::setDevicePowerState(uint64_t a1, unsigned int a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
  MTDeviceGetDeviceID();
  uint64_t v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 2) {
      int v5 = "Unknown";
    }
    else {
      int v5 = off_2650D3980[a2];
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v12 = v5;
    __int16 v13 = 2048;
    __int16 v14 = 0;
    _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_DEFAULT, "Setting power state to %{public}s (deviceID 0x%llX)", buf, 0x16u);
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
  mach_error_t v6 = MTDevicePowerSetState();
  if (v6)
  {
    mach_error_t v7 = v6;
    (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
    MTDeviceGetDeviceID();
    BOOL v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      if (a2 > 2) {
        int v9 = "Unknown";
      }
      else {
        int v9 = off_2650D3980[a2];
      }
      mach_error_t v10 = mach_error_string(v7);
      *(_DWORD *)buf = 136446722;
      uint64_t v12 = v9;
      __int16 v13 = 2082;
      __int16 v14 = v10;
      __int16 v15 = 2048;
      uint64_t v16 = 0;
      _os_log_impl(&dword_2406FB000, v8, OS_LOG_TYPE_ERROR, "Error trying to set power state to %{public}s: %{public}s (deviceID 0x%llX)", buf, 0x20u);
    }
  }
}

const char *MTModeSwitcher::modeToText(uint64_t a1, int a2)
{
  if (a2 <= 251)
  {
    if (a2)
    {
      if (a2 == 1)
      {
        return "PocketTouchesExpected";
      }
      else if (a2 == 2)
      {
        return "FaceExpected";
      }
      else
      {
        return "Unknown";
      }
    }
    else
    {
      return "On";
    }
  }
  else
  {
    switch(a2)
    {
      case 252:
        double result = "LowPersistence";
        break;
      case 253:
        double result = "WakeOnTouch";
        break;
      case 254:
        double result = "WakeOnTouchAndCoverGesture";
        break;
      case 255:
        double result = "Off";
        break;
      default:
        return "Unknown";
    }
  }
  return result;
}

uint64_t MTModeSwitcher::bootloadTimerExpired(MTModeSwitcher *this)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  *((unsigned char *)this + 24) = 0;
  (*(void (**)(void))(**((void **)this + 1) + 80))(*((void *)this + 1));
  MTDeviceGetDeviceID();
  uint64_t v2 = MTLoggingPlugin();
  BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    int v4 = *((_DWORD *)this + 7);
    *(_DWORD *)buf = 136446722;
    mach_error_t v7 = MTModeSwitcher::modeToText(v3, v4);
    __int16 v8 = 1024;
    int v9 = v4;
    __int16 v10 = 2048;
    uint64_t v11 = 0;
    _os_log_impl(&dword_2406FB000, v2, OS_LOG_TYPE_DEFAULT, "Device never bootloaded. Try to recover by going to %{public}s (0x%x) (deviceID 0x%llX)", buf, 0x1Cu);
  }
  return (*(uint64_t (**)(MTModeSwitcher *, void, void))(*(void *)this + 16))(this, *((unsigned int *)this + 7), 0);
}

void MTModeSwitcher::resetFirmware(uint64_t a1, int a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 8) + 480))(*(void *)(a1 + 8), 30);
  mach_error_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 424))();
  if (v4)
  {
    mach_error_t v5 = v4;
    (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
    MTDeviceGetDeviceID();
    mach_error_t v6 = MTLoggingPlugin();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v8 = mach_error_string(v5);
      __int16 v9 = 2048;
      uint64_t v10 = 0;
      _os_log_impl(&dword_2406FB000, v6, OS_LOG_TYPE_ERROR, "Error trying to reset device: %{public}s (deviceID 0x%llX)", buf, 0x16u);
    }
  }
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = a2;
}

uint64_t MTModeSwitcher::setupBootloadPowerAssertion(MTModeSwitcher *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 480))();
}

uint64_t MTModeSwitcher::resetDevice(MTModeSwitcher *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 424))();
}

void MTModeSwitcher::bootFirmware(uint64_t a1, int a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
  if (MTDevicePowerGetState() | 0xAAAAAAAA)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
    MTDeviceGetDeviceID();
    mach_error_t v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v6 = 0;
      _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_ERROR, "Trying to boot a device in an unknown/unexpected state (deviceID 0x%llX)", buf, 0xCu);
    }
    MTModeSwitcher::resetFirmware(a1, a2);
  }
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 8) + 480))(*(void *)(a1 + 8), 30);
  MTModeSwitcher::setDevicePowerState(a1, 2u);
  *(unsigned char *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = a2;
}

const char *MTModeSwitcher::powerStateToText(uint64_t a1, unsigned int a2)
{
  if (a2 > 2) {
    return "Unknown";
  }
  else {
    return off_2650D3980[a2];
  }
}

uint64_t MTNoOpModeSwitcher::transitionTouchDetectionModeTo(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16) = a2;
  return result;
}

uint64_t MTNoOpModeSwitcher::transitionGraphicsOrientationTo(uint64_t result, int a2)
{
  *(_DWORD *)(result + 20) = a2;
  return result;
}

uint64_t MTNoOpModeSwitcher::deviceDidBootload(uint64_t this)
{
  *(unsigned char *)(this + 24) = 0;
  return this;
}

uint64_t MTNoOpModeSwitcher::bootloadTimerExpired(uint64_t this)
{
  *(unsigned char *)(this + 24) = 0;
  return this;
}

void MTMultipleFirmwaresModeSwitcher::~MTMultipleFirmwaresModeSwitcher(MTMultipleFirmwaresModeSwitcher *this)
{
  *(void *)this = &unk_26F4DAFC0;
  uint64_t v2 = (id *)*((void *)this + 5);
  if (v2)
  {

    uint64_t v3 = *((void *)this + 5);
    if (v3) {
      MEMORY[0x2455F6CE0](v3, 0x80C4018A671A6);
    }
    *((void *)this + 5) = 0;
  }
}

{
  uint64_t vars8;

  MTMultipleFirmwaresModeSwitcher::~MTMultipleFirmwaresModeSwitcher(this);

  JUMPOUT(0x2455F6CE0);
}

void MTMultipleFirmwaresModeSwitcher::transitionTouchDetectionModeTo(uint64_t a1, int a2)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 32) == 1)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
    MTDeviceGetDeviceID();
    mach_error_t v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v26 = 0;
      _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_DEFAULT, "Debug mode forced to Always ON (deviceID 0x%llX)", buf, 0xCu);
    }
    a2 = 0;
  }
  if (*(unsigned char *)(a1 + 24))
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
    MTDeviceGetDeviceID();
    mach_error_t v5 = MTLoggingPlugin();
    BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      uint64_t v7 = MTModeSwitcher::modeToText(v6, a2);
      *(_DWORD *)buf = 136446722;
      uint64_t v26 = v7;
      __int16 v27 = 1024;
      int v28 = a2;
      __int16 v29 = 2048;
      uint64_t v30 = 0;
      _os_log_impl(&dword_2406FB000, v5, OS_LOG_TYPE_DEFAULT, "Touch detection mode to %{public}s (0x%x) deferred (device booting) (deviceID 0x%llX)", buf, 0x1Cu);
    }
    *(_DWORD *)(a1 + 28) = a2;
    return;
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
  MTDeviceGetDeviceID();
  __int16 v8 = MTLoggingPlugin();
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    int v10 = *(_DWORD *)(a1 + 16);
    uint64_t v11 = MTModeSwitcher::modeToText(v9, v10);
    uint64_t v12 = MTModeSwitcher::modeToText((uint64_t)v11, a2);
    *(_DWORD *)buf = 136447234;
    uint64_t v26 = v11;
    __int16 v27 = 1024;
    int v28 = v10;
    __int16 v29 = 2082;
    uint64_t v30 = v12;
    __int16 v31 = 1024;
    int v32 = a2;
    __int16 v33 = 2048;
    uint64_t v34 = 0;
    _os_log_impl(&dword_2406FB000, v8, OS_LOG_TYPE_DEFAULT, "Touch detection mode transitioning from %{public}s (0x%x) to %{public}s (0x%x) (deviceID 0x%llX)", buf, 0x2Cu);
  }
  unsigned int v13 = *(_DWORD *)(a1 + 16);
  if (a2 == v13)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
    MTDeviceGetDeviceID();
    __int16 v14 = MTLoggingPlugin();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v26 = 0;
      _os_log_impl(&dword_2406FB000, v14, OS_LOG_TYPE_ERROR, "Unexpected: new mode == old mode (rebooting firmware?) (deviceID 0x%llX)", buf, 0xCu);
    }
    return;
  }
  if (!*(unsigned char *)(a1 + 48))
  {
    if (a2 > 253)
    {
      if (a2 != 254)
      {
        if (a2 == 255)
        {
          if (v13 < 2 || v13 == 254) {
            MTModeSwitcher::setDevicePowerState(a1, 0);
          }
          a2 = 255;
          goto LABEL_50;
        }
        goto LABEL_40;
      }
      if (v13 < 2)
      {
        a2 = 254;
        uint64_t v16 = a1;
        int v17 = 1;
        int v18 = 254;
LABEL_39:
        MTMultipleFirmwaresModeSwitcher::switchFirmware(v16, v17, v18);
LABEL_50:
        *(_DWORD *)(a1 + 16) = a2;
        return;
      }
      if (v13 != 255)
      {
        a2 = 254;
        goto LABEL_50;
      }
      uint64_t v20 = a1;
      int v21 = 254;
    }
    else
    {
      if (a2)
      {
        if (a2 == 1)
        {
          if (v13 - 254 >= 2)
          {
            a2 = 1;
            if (!v13) {
              MTModeSwitcher::setTouchDetectionMode(a1, 1, *(_DWORD *)(a1 + 20));
            }
            goto LABEL_50;
          }
          a2 = 1;
          uint64_t v16 = a1;
          int v17 = 0;
          int v18 = 1;
          goto LABEL_39;
        }
LABEL_40:
        (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
        MTDeviceGetDeviceID();
        double v22 = MTLoggingPlugin();
        BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
        if (v23)
        {
          double v24 = MTModeSwitcher::modeToText(v23, a2);
          *(_DWORD *)buf = 136446722;
          uint64_t v26 = v24;
          __int16 v27 = 1024;
          int v28 = a2;
          __int16 v29 = 2048;
          uint64_t v30 = 0;
          _os_log_impl(&dword_2406FB000, v22, OS_LOG_TYPE_ERROR, "Unexpected transition to %{public}s (0x%x) (deviceID 0x%llX)", buf, 0x1Cu);
        }
        goto LABEL_50;
      }
      if (v13 - 254 >= 2)
      {
        if (v13 == 1) {
          MTModeSwitcher::setTouchDetectionMode(a1, 0, *(_DWORD *)(a1 + 20));
        }
        goto LABEL_49;
      }
      uint64_t v20 = a1;
      int v21 = 0;
    }
    MTMultipleFirmwaresModeSwitcher::switchFirmware(v20, 0, v21);
LABEL_49:
    a2 = 0;
    goto LABEL_50;
  }
  if (a2 || v13 != 255)
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
    MTDeviceGetDeviceID();
    __int16 v19 = MTLoggingPlugin();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v26 = 0;
      _os_log_impl(&dword_2406FB000, v19, OS_LOG_TYPE_ERROR, "Unexpected first boot (deviceID 0x%llX)", buf, 0xCu);
    }
  }
  else
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
    MTDeviceGetDeviceID();
    __int16 v15 = MTLoggingPlugin();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v26 = 0;
      _os_log_impl(&dword_2406FB000, v15, OS_LOG_TYPE_DEFAULT, "First boot: setting power to On (deviceID 0x%llX)", buf, 0xCu);
    }
    MTModeSwitcher::setDevicePowerState(a1, 2u);
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(unsigned char *)(a1 + 48) = 0;
}

void MTMultipleFirmwaresModeSwitcher::switchFirmware(uint64_t a1, int a2, int a3)
{
  v21[2] = *MEMORY[0x263EF8340];
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 8) + 480))(*(void *)(a1 + 8), 30);
  if (a2)
  {
    if (a2 == 1)
    {
      uint64_t v6 = *(void *)(a1 + 40);
      uint64_t v7 = *(const char **)(v6 + 24);
    }
    else
    {
      uint64_t v7 = 0;
      uint64_t v6 = *(void *)(a1 + 40);
    }
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = *(const char **)(v6 + 16);
  }
  uint64_t v15 = 0;
  if ([*(id *)v6 updateProperty:*(void *)(v6 + 8) property:v7 options:0 error:&v15])
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
    MTDeviceGetDeviceID();
    __int16 v8 = MTLoggingPlugin();
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    if (v9)
    {
      int v10 = "Unknown";
      if (a2 == 1) {
        int v10 = "WakeOnTouch";
      }
      if (a2) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = "Active";
      }
      uint64_t v12 = MTModeSwitcher::modeToText(v9, a3);
      *(_DWORD *)buf = 136446978;
      int v17 = v11;
      __int16 v18 = 2082;
      __int16 v19 = v12;
      __int16 v20 = 1024;
      LODWORD(v21[0]) = a3;
      WORD2(v21[0]) = 2048;
      *(void *)((char *)v21 + 6) = 0;
      _os_log_impl(&dword_2406FB000, v8, OS_LOG_TYPE_DEFAULT, "FW switched to %{public}s with mode %{public}s (0x%x) (deviceID 0x%llX)", buf, 0x26u);
    }
    *(unsigned char *)(a1 + 24) = 1;
    *(_DWORD *)(a1 + 28) = a3;
  }
  else
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
    MTDeviceGetDeviceID();
    unsigned int v13 = MTLoggingPlugin();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      __int16 v14 = *(const char **)(*(void *)(a1 + 40) + 8);
      *(_DWORD *)buf = 138543874;
      int v17 = v14;
      __int16 v18 = 2114;
      __int16 v19 = v7;
      __int16 v20 = 2048;
      v21[0] = 0;
      _os_log_impl(&dword_2406FB000, v13, OS_LOG_TYPE_ERROR, "Error updating %{public}@ to %{public}@ (deviceID 0x%llX)", buf, 0x20u);
    }
  }
}

const char *MTMultipleFirmwaresModeSwitcher::firmwareBinaryToText(uint64_t a1, int a2)
{
  uint64_t v2 = "Unknown";
  if (a2 == 1) {
    uint64_t v2 = "WakeOnTouch";
  }
  if (a2) {
    return v2;
  }
  else {
    return "Active";
  }
}

void MTNoOpModeSwitcher::~MTNoOpModeSwitcher(MTNoOpModeSwitcher *this)
{
}

void *MTChordCyclingTrackpad::MTChordCyclingTrackpad(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5, int a6)
{
  double result = (void *)MTChordCycling::MTChordCycling(a1, a2, a3, a4, a5, a6);
  *double result = &unk_26F4DB040;
  return result;
}

{
  void *result;

  double result = (void *)MTChordCycling::MTChordCycling(a1, a2, a3, a4, a5, a6);
  *double result = &unk_26F4DB040;
  return result;
}

uint64_t MTChordCyclingTrackpad::chk4newTapChord(MTChordCyclingTrackpad *this, MTHandStatistics *a2, const MTHandMotion *a3, MTChordGestureSet *a4)
{
  if (a4
    && *((double *)a2 + 10) > *((double *)a2 + 16)
    && (*(unsigned int (**)(MTChordCyclingTrackpad *, MTHandStatistics *))(*(void *)this + 48))(this, a2))
  {
    int v8 = *((_DWORD *)this + 260);
    unsigned int v9 = *((_DWORD *)a4 + 54);
    if ((!v8 || (v9 >= *((_DWORD *)this + 258) || v9 < *((unsigned __int8 *)a2 + 186)) && *((_DWORD *)a4 + 56) != v8)
      && (v9 != 2 || *((_DWORD *)a4 + 55) != 2 || *((unsigned char *)a2 + 195) != 1))
    {
      (*(void (**)(MTChordCyclingTrackpad *, MTHandStatistics *, const MTHandMotion *, MTChordGestureSet *))(*(void *)this + 72))(this, a2, a3, a4);
    }
  }
  int v10 = *(uint64_t (**)(MTChordCyclingTrackpad *, MTHandStatistics *, const MTHandMotion *))(*(void *)this + 80);

  return v10(this, a2, a3);
}

void MTChordCyclingTrackpad::handleChordTaps(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  if (a1[260]
    && (*(unsigned int (**)(_DWORD *))(*(void *)a1 + 48))(a1)
    && ((a6 & 1) != 0
     || a1[258] < 2u
     || (*(unsigned int (**)(_DWORD *, uint64_t))(*(void *)a1 + 56))(a1, a2)))
  {
    if ((*(unsigned int (**)(_DWORD *, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 96))(a1, a2, a3, a6))
    {
      int v12 = a1[262];
      if (!v12 || (a1[6] & v12) != 0)
      {
        int v13 = a1[259];
        if ((a6 & 1) != 0 || v13 < 2)
        {
          if (v13 == 1)
          {
            uint64_t v16 = (_WORD *)*((void *)a1 + 110);
            if (v16 != *((_WORD **)a1 + 111)
              && *v16
              && vabdd_f64(*(double *)(a2 + 96), *(double *)(a2 + 104)) < *(double *)&qword_268C8ECA8
              && *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) <= 1
              && (a6 & 1) == 0)
            {
              (*(void (**)(_DWORD *, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 104))(a1, a2, a3 + 168, a4);
              goto LABEL_47;
            }
          }
          if (a6 && *(double *)(a2 + 80) - *(double *)(a2 + 88) <= 0.09) {
            return;
          }
        }
        else
        {
          __int16 v14 = (_WORD *)*((void *)a1 + 110);
          uint64_t v15 = (_WORD *)*((void *)a1 + 111);
          if (v14 != v15 && *v14) {
            goto LABEL_13;
          }
          int v17 = (_WORD *)*((void *)a1 + 102);
          if (v17 != *((_WORD **)a1 + 103) && *v17)
          {
            if (v14 != v15 && *v14)
            {
LABEL_13:
              (*(void (**)(_DWORD *, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 112))(a1, a2, a3 + 168, a4);
              goto LABEL_49;
            }
            uint64_t v18 = *((void *)a1 + 49);
            if (*(unsigned char *)(v18 + 28) && *(int *)(v18 + 24) >= 3)
            {
              MTTapDragManager::handleTapsForMultiFingerDrag(*((void *)a1 + 49), a2, a3, a4);
              goto LABEL_49;
            }
            goto LABEL_46;
          }
        }
        uint64_t v19 = *((void *)a1 + 102);
        if (v19 == *((void *)a1 + 103)
          || !*(_WORD *)v19
          || a6 && (a5 & 1) == 0 && (*(unsigned char *)(v19 + 5) & 1) == 0)
        {
          if (!a6
            || (__int16 v20 = (_WORD *)*((void *)a1 + 106), v20 == *((_WORD **)a1 + 107))
            || !*v20
            || v12 && (a1[6] & v12) == 0)
          {
LABEL_49:
            MTChordIntegrating::nullify((void **)a1 + 102);
            return;
          }
          MTGesture::dispatchEvents((uint64_t *)a1 + 106, *((void *)a1 + 49), a4, 0, 0, a3 + 168, 24576, a1[260], *(double *)(a2 + 8));
          uint64_t v21 = *((void *)a1 + 49);
          *(void *)(v21 + 72) = *(void *)(a2 + 8);
          LOBYTE(v22) = 1;
LABEL_48:
          *(unsigned char *)(v21 + 49) = v22;
          goto LABEL_49;
        }
        uint64_t v23 = *((void *)a1 + 49);
        if (a1[258] != 1 || *(_WORD *)v19 != 65)
        {
          MTTapDragManager::clearCycle(v23);
          uint64_t v18 = *((void *)a1 + 49);
LABEL_46:
          MTGesture::dispatchEvents((uint64_t *)a1 + 102, v18, a4, 0, 0, a3 + 168, 12288, a1[260], *(double *)(a2 + 8));
          goto LABEL_47;
        }
        MTTapDragManager::handleTapsForDrag(v23, a2, a3, a4);
LABEL_47:
        uint64_t v21 = *((void *)a1 + 49);
        int v22 = a1[258];
        *(void *)(v21 + 72) = *(void *)(a2 + 8);
        goto LABEL_48;
      }
    }
  }
}

uint64_t MTChordCyclingTrackpad::possiblyStopChordMomentum(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  MTChordCycling::possiblyStopChordMomentum(a1, a2, a3, a4);
  uint64_t v8 = *(void *)(a1 + 392);
  double v9 = *(double *)(a2 + 8) - *(double *)(a1 + 1240);

  return MTTapDragManager::chk4dragCycling(v8, a2, a3, a4, v9);
}

void MTChordCyclingTrackpad::chk4chordCycling(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4)
{
  if (*(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) > *(unsigned __int8 *)(a2 + 190)
                                                                                     + *(unsigned __int8 *)(a2 + 187)
    && *(_DWORD *)(a1 + 632))
  {
    MTChordIntegrating::clearMickeysSinceLastTouchdown(a1 + 408);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 136))(a1, a2, a4);
  if (*(unsigned char *)(a2 + 210))
  {
    int v8 = *(_DWORD *)(a1 + 632);
    if (v8 && *(_DWORD *)(a1 + 624) == 1 || *(_DWORD *)(a1 + 1040) && *(_DWORD *)(a1 + 1032) == 1) {
      *(void *)(*(void *)(a1 + 392) + 80) = *(void *)(a2 + 8);
    }
    if (v8)
    {
      double v9 = *(void **)(a1 + 680);
      if (v9)
      {
        if (*v9 != v9[1] && *(_WORD *)*v9 == 37 && *(unsigned char *)(a1 + 672))
        {
          unsigned int v10 = *(unsigned __int8 *)(a2 + 186);
          if ((*(unsigned char *)(a2 + 168) & 0x20) != 0) {
            v10 += *(unsigned __int8 *)(a2 + 188);
          }
          if (v10 >= *(unsigned __int8 *)(a2 + 187) && v10 > 2) {
            return;
          }
        }
      }
    }
  }
  if (!*(unsigned char *)(a2 + 298) && (*(unsigned char *)(a2 + 186) != 1 || *(unsigned char *)(a2 + 195) == 0))
  {
LABEL_25:
    (*(void (**)(uint64_t, uint64_t, float32x4_t *, uint64_t))(*(void *)a1 + 88))(a1, a2, a3, a4);
    int v12 = *(void (**)(uint64_t, uint64_t, float32x4_t *, uint64_t))(*(void *)a1 + 144);
    v12(a1, a2, a3, a4);
    return;
  }
  uint64_t v13 = *(void *)(a1 + 392);
  if (*(unsigned char *)(v13 + 28))
  {
    int v14 = *(unsigned __int8 *)(a2 + 186);
    int v15 = *(unsigned __int8 *)(a2 + 187);
    if (*(int *)(v13 + 24) >= 3)
    {
      int v16 = *(unsigned __int8 *)(a2 + 211);
      int v17 = *(unsigned __int8 *)(a2 + 190);
      unsigned int v18 = v17 + v15;
      goto LABEL_34;
    }
  }
  else
  {
    int v14 = *(unsigned __int8 *)(a2 + 186);
    int v15 = *(unsigned __int8 *)(a2 + 187);
  }
  int v16 = *(unsigned __int8 *)(a2 + 211);
  int v17 = *(unsigned __int8 *)(a2 + 190);
  unsigned int v18 = v17 + v15;
  if (v16 + v14 < v18 && v16 + v14 <= *(unsigned __int8 *)(v13 + 48))
  {
    (*(void (**)(uint64_t, uint64_t, float32x4_t *, uint64_t))(*(void *)a1 + 88))(a1, a2, a3, a4);
    goto LABEL_45;
  }
LABEL_34:
  unsigned int v19 = v16 + v14;
  if (v19 >= v18 || !*(_DWORD *)(a1 + 1040)) {
    goto LABEL_45;
  }
  if (v19 != 1 || (v20 = 0, uint64_t v21 = 1, !v17) && *(unsigned char *)(a2 + 195))
  {
    if ((*(_WORD *)(a1 + 1044) & 0x100) == 0)
    {
      int v22 = *(_WORD **)(a1 + 848);
      if (v22 == *(_WORD **)(a1 + 856) || !*v22) {
        goto LABEL_45;
      }
    }
    uint64_t v21 = 0;
    uint64_t v20 = 1;
  }
  (*(void (**)(uint64_t, uint64_t, float32x4_t *, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120))(a1, a2, a3, a4, v21, v20);
LABEL_45:
  (*(void (**)(uint64_t, uint64_t, float32x4_t *, uint64_t))(*(void *)a1 + 144))(a1, a2, a3, a4);
  char v23 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 24))(a1, a2);
  uint64_t MatchingChord = MTChordTable::findMatchingChord((MTChordTable *)a1, v23, 0);
  (*(void (**)(uint64_t, uint64_t, float32x4_t *, uint64_t))(*(void *)a1 + 128))(a1, a2, a3, MatchingChord);
  float v25 = a3[17].f32[1];
  if (MatchingChord && (*(_WORD *)(MatchingChord + 228) & 0x100) != 0)
  {
    if ((*(_WORD *)(a2 + 296) & 1) != 0 && v25 <= 0.765) {
      return;
    }
    if (*(_DWORD *)(MatchingChord + 220) < *(unsigned __int8 *)(a2 + 198)
      && *(unsigned __int8 *)(a2 + 186) == *(unsigned __int8 *)(a2 + 298))
    {
      if (!*(_DWORD *)(a1 + 632)
        || *(unsigned char *)(a1 + 672)
        || *(double *)(a2 + 8) - *(double *)(a2 + 56) <= *(double *)&qword_268C8EC28)
      {
        return;
      }
      uint64_t v33 = a1 + 408;
      goto LABEL_103;
    }
  }
  if ((*(_WORD *)(a1 + 636) & 0x100) != 0 && !*(unsigned char *)(a1 + 672) && (*(_WORD *)(a2 + 296) & 1) != 0 && v25 <= 0.765)
  {
    uint64_t v33 = a1 + 408;
LABEL_103:
    MTChordIntegrating::endChordIntegration(v33, a2, (uint64_t)a3, a4, a1);
    return;
  }
  if (!*(_DWORD *)(a1 + 632))
  {
    if (!MatchingChord
      || !MTChordGestureSet::isChordReadyToIntegrate((MTChordGestureSet *)MatchingChord, (const MTHandStatistics *)a2, a3))
    {
      return;
    }
    goto LABEL_154;
  }
  MTChordIntegrating::markMomentumPause((MTChordIntegrating *)(a1 + 408), (const MTHandStatistics *)a2);
  if (*(double *)(a2 + 8) - *(double *)(a2 + 288) <= *(double *)(a2 + 8) - *(double *)(a2 + 16)
    && MatchingChord
    && *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) >= 4)
  {
    uint64_t v34 = *(unsigned __int16 ***)(a1 + 680);
    if (!v34 || *v34 == v34[1] || **v34 - 35 >= 5) {
      goto LABEL_154;
    }
  }
  else if (!MatchingChord)
  {
    return;
  }
  if (*(_DWORD *)(MatchingChord + 224) == *(_DWORD *)(a1 + 632)
    && (MTChordGestureSet::chordGestureSetEquals((MTChordGestureSet *)MatchingChord, (const MTChordGestureSet *)(a1 + 408)) & 1) != 0)
  {
    return;
  }
  uint64_t v26 = *(void *)(a1 + 392);
  if (*(int *)(v26 + 24) >= 2)
  {
    if ((**(unsigned int (***)(uint64_t))v26)(v26))
    {
      uint64_t v27 = *(void *)(a1 + 392);
      if (!*(unsigned char *)(v27 + 28) || *(int *)(v27 + 24) < 3) {
        return;
      }
    }
  }
  int v28 = *(_DWORD *)(MatchingChord + 216);
  unsigned int v29 = *(_DWORD *)(a1 + 624);
  if (v28 < v29)
  {
    uint64_t v30 = *(MTSlideGesture **)(a1 + 680);
    if (v30)
    {
      if (*(void *)v30 == *((void *)v30 + 1) || (**(_WORD **)v30 & 0xFFFE) != 0x26) {
        goto LABEL_65;
      }
      if (!MTSlideGesture::isFluidFullyTriggered(v30)) {
        goto LABEL_66;
      }
      uint64_t v30 = *(MTSlideGesture **)(a1 + 680);
      if (v30)
      {
LABEL_65:
        if (*(void *)v30 == *((void *)v30 + 1) || (**(_WORD **)v30 & 0xFFFE) != 0x26) {
          goto LABEL_68;
        }
LABEL_66:
        if (*(unsigned char *)(a2 + 298)
          && *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) >= *(unsigned __int8 *)(a2 + 190)
                                                                                            + *(unsigned __int8 *)(a2 + 187))
        {
          goto LABEL_68;
        }
        goto LABEL_25;
      }
    }
LABEL_68:
    if (*(unsigned char *)(a1 + 672)
      && ((*(_WORD *)(a1 + 636) & 0x80) == 0
       || (MTChordIntegrating::hasPartiallyTriggeredFluidNotificationOrNotificationAlt((MTChordIntegrating *)(a1 + 408)) & 1) != 0
       || ((*(_WORD *)(MatchingChord + 228) & 8) == 0 || *(unsigned char *)(a2 + 211))
       && *(_DWORD *)(MatchingChord + 216) >= (int)*(unsigned __int8 *)(a2 + 186)))
    {
      if ((*(_WORD *)(a1 + 636) & 0x10) == 0) {
        return;
      }
      if ((*(_WORD *)(MatchingChord + 228) & 1) == 0) {
        return;
      }
      __int16 v31 = *(void **)(a1 + 680);
      if (v31)
      {
        if (*v31 != v31[1] && *(_WORD *)*v31 == 37)
        {
          unsigned int v32 = *(unsigned __int8 *)(a2 + 186);
          if (v32 <= *(unsigned __int8 *)(a2 + 195) || *(unsigned __int8 *)(a2 + 211) + v32 != 1) {
            return;
          }
        }
      }
      if (MTChordIntegrating::hasPartiallyTriggeredFluidNotificationOrNotificationAlt((MTChordIntegrating *)(a1 + 408))) {
        return;
      }
      if ((*(_WORD *)(a1 + 636) & 0x80) == 0)
      {
        if ((*(_WORD *)(a1 + 636) & 0x100) != 0)
        {
          if (*(_DWORD *)(MatchingChord + 216) != 1
            || *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) != 1
            || *(unsigned char *)(a1 + 1264) && *(_DWORD *)(a1 + 1268) == 4)
          {
            return;
          }
        }
        else if (*(double *)(a2 + 8) - *(double *)(a2 + 128) <= *(double *)&gTimingPrefs * 0.5)
        {
          return;
        }
      }
    }
LABEL_154:
    uint64_t v49 = *(void (**)(uint64_t, uint64_t, float32x4_t *, uint64_t, uint64_t))(*(void *)a1 + 64);
    v49(a1, a2, a3, a4, MatchingChord);
    return;
  }
  int v36 = *(_DWORD *)(a1 + 704) <= v29 + 1 || v28 < *(unsigned __int8 *)(a2 + 186);
  BOOL v37 = MTChordIntegrating::recentMomentumPause((MTChordIntegrating *)(a1 + 408), (const MTHandStatistics *)a2, HIBYTE(*(unsigned __int16 *)(MatchingChord + 228)) & 1);
  if (*(_DWORD *)(MatchingChord + 216) < 3u) {
    int hasEnabledFluidNavigation = 0;
  }
  else {
    int hasEnabledFluidNavigation = MTChordGestureSet::hasEnabledFluidNavigation((MTChordGestureSet *)MatchingChord, (const MTChordTable *)a1);
  }
  if (!v36) {
    goto LABEL_140;
  }
  if ((*(_WORD *)(MatchingChord + 228) & 0x100) != 0
    && (uint8x8_t v39 = *(void **)(a1 + 680)) != 0
    && *v39 != v39[1]
    && (*(_WORD *)*v39 & 0xFFFE) == 0x46
    || (double v40 = *(double *)(a2 + 8), v41 = v40 - *(double *)(a2 + 280), v41 >= *(double *)&qword_268C8EC28))
  {
    int v36 = 0;
    goto LABEL_140;
  }
  if ((hasEnabledFluidNavigation & 1) == 0)
  {
    double v44 = v40 - *(double *)(a2 + 80);
    int v36 = v44 > 0.0;
    char v45 = v44 <= 0.0 || v37;
    if (v45) {
      goto LABEL_140;
    }
    if (a3[12].f32[2] == 0.0)
    {
      int v36 = a3[12].f32[3] != 0.0;
      goto LABEL_140;
    }
LABEL_139:
    int v36 = 1;
    goto LABEL_140;
  }
  char v42 = a3[12].f32[2] != 0.0 || v37;
  if (v42) {
    goto LABEL_139;
  }
  float v43 = a3[12].f32[3];
  int v36 = v43 != 0.0;
  if (v43 == 0.0 && ((hasEnabledFluidNavigation ^ 1) & 1) == 0) {
    int v36 = MTChordIntegrating::switchingVerticalToHorizontal((int32x2_t *)(a1 + 408), 20.0, v41 == 0.0);
  }
LABEL_140:
  if (!*(unsigned char *)(a1 + 672)) {
    goto LABEL_154;
  }
  if (*(double *)(a2 + 8) - *(double *)(a2 + 264) < *(double *)&qword_268C8EC28)
  {
    if ((*(_WORD *)(MatchingChord + 228) & 0x100) == 0
      && !MTChordGestureSet::hasEnabledFluidDock((MTChordGestureSet *)MatchingChord, (const MTChordTable *)a1))
    {
      goto LABEL_154;
    }
    if (*(_DWORD *)(MatchingChord + 216) != 3) {
      goto LABEL_154;
    }
    CFArrayRef v46 = *(void **)(a1 + 680);
    if (!v46 || *v46 == v46[1] || (*(_WORD *)*v46 & 0xFFFE) != 0x46) {
      goto LABEL_154;
    }
  }
  __int16 v47 = *(_WORD *)(a1 + 636);
  if ((v47 & 0x20) != 0
    || (v47 & 0x40) != 0
    && ((v36 & 1) != 0
     || MTChordGestureSet::hasActiveEdgeSlide((MTChordGestureSet *)MatchingChord, (const MTHandStatistics *)a2, (const MTChordCycling *)a1)))
  {
    unsigned int v48 = *(unsigned __int16 *)(MatchingChord + 228);
    if ((v48 & 2) != 0) {
      goto LABEL_154;
    }
    if (v36 & (v48 >> 2)) {
      goto LABEL_154;
    }
    if ((v36 & (v48 >> 11)) == 1)
    {
      BOOL v50 = *(void **)(a1 + 680);
      if (v50)
      {
        if (*v50 != v50[1] && *(_WORD *)*v50 == 68 && *(_DWORD *)(a1 + 624) == 1) {
          goto LABEL_154;
        }
      }
    }
  }
}

MTSlideGesture *MTChordIntegrating::hasPartiallyTriggeredFluidNotificationOrNotificationAlt(MTChordIntegrating *this)
{
  double result = (MTSlideGesture *)*((void *)this + 34);
  if (result)
  {
    if (*(void *)result == *((void *)result + 1) || (**(_WORD **)result & 0xFFFE) != 0x26) {
      return 0;
    }
    else {
      return (MTSlideGesture *)!MTSlideGesture::isFluidFullyTriggered(result);
    }
  }
  return result;
}

void MTChordCyclingTrackpad::~MTChordCyclingTrackpad(MTChordCyclingTrackpad *this)
{
  MTChordCycling::~MTChordCycling(this);

  JUMPOUT(0x2455F6CE0);
}

BOOL MTSlideGesture::isFluidFullyTriggered(MTSlideGesture *this)
{
  if (*(void *)this == *((void *)this + 1) || **(unsigned __int16 **)this - 35 > 4) {
    return 0;
  }
  if (MTSlideGesture::fluidSwipePercentage(this) <= 1.0) {
    return MTSlideGesture::fluidSwipePercentage(this) < -1.0;
  }
  return 1;
}

void MTChordCycling::~MTChordCycling(MTChordCycling *this)
{
  *(void *)this = &unk_26F4DB108;
  int v12 = (void **)((char *)this + 976);
  std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100](&v12);
  uint64_t v2 = (void *)*((void *)this + 118);
  if (v2)
  {
    *((void *)this + 119) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 114);
  if (v3)
  {
    *((void *)this + 115) = v3;
    operator delete(v3);
  }
  mach_error_t v4 = (void *)*((void *)this + 110);
  if (v4)
  {
    *((void *)this + 11MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = v4;
    operator delete(v4);
  }
  mach_error_t v5 = (void *)*((void *)this + 106);
  if (v5)
  {
    *((void *)this + 107) = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 102);
  if (v6)
  {
    *((void *)this + 103) = v6;
    operator delete(v6);
  }
  int v12 = (void **)((char *)this + 568);
  std::vector<MTSlideGesture>::__destroy_vector::operator()[abi:ne180100](&v12);
  uint64_t v7 = (void *)*((void *)this + 67);
  if (v7)
  {
    *((void *)this + 68) = v7;
    operator delete(v7);
  }
  int v8 = (void *)*((void *)this + 63);
  if (v8)
  {
    *((void *)this + 64) = v8;
    operator delete(v8);
  }
  double v9 = (void *)*((void *)this + 59);
  if (v9)
  {
    *((void *)this + 60) = v9;
    operator delete(v9);
  }
  unsigned int v10 = (void *)*((void *)this + 55);
  if (v10)
  {
    *((void *)this + 56) = v10;
    operator delete(v10);
  }
  uint64_t v11 = (void *)*((void *)this + 51);
  if (v11)
  {
    *((void *)this + 52) = v11;
    operator delete(v11);
  }
  MTChordTable::~MTChordTable(this);
}

{
  uint64_t vars8;

  MTChordCycling::~MTChordCycling(this);

  JUMPOUT(0x2455F6CE0);
}

uint64_t MTChordCycling::MTChordCycling(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5, int a6)
{
  uint64_t v10 = MTChordTable::MTChordTable(a1, a2, a3);
  *(void *)uint64_t v10 = &unk_26F4DB108;
  *(void *)(v10 + 392) = a4;
  *(unsigned char *)(v10 + 400) = a5;
  MTChordIntegrating::MTChordIntegrating((MTChordIntegrating *)(v10 + 408));
  MTChordIntegrating::MTChordIntegrating((MTChordIntegrating *)(a1 + 816));
  MTParameterFactory::initChordCyclingParams(a1 + 368, a6);
  MTParameterFactory::initGestureTimingParams(a1 + 388);
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  return a1;
}

void sub_24073C87C(_Unwind_Exception *a1)
{
  MTChordGestureSet::~MTChordGestureSet(v2);
  MTChordTable::~MTChordTable(v1);
  _Unwind_Resume(a1);
}

uint64_t MTChordCycling::clearChordCyclingState(MTChordCycling *this)
{
  MTChordIntegrating::nullify((void **)this + 51);
  MTChordIntegrating::nullify((void **)this + 102);
  *((void *)this + 157) = 0;
  *(_OWORD *)((char *)this + 1224) = 0u;
  *(_OWORD *)((char *)this + 1240) = 0u;
  MTTapDragManager::clearState(*((void *)this + 49));

  return MTChordTable::clearChordCyclingState(this);
}

uint64_t MTChordCycling::getCommittedFingerCount(MTChordCycling *this)
{
  if (*((unsigned char *)this + 672)) {
    return *((unsigned int *)this + 156);
  }
  else {
    return 0;
  }
}

BOOL MTChordCycling::hasTriggeredFluidDock(MTChordCycling *this)
{
  return *((unsigned char *)this + 672)
      && (uint64_t v1 = (unsigned __int16 **)*((void *)this + 85)) != 0
      && *v1 != v1[1]
      && **v1 == 37;
}

double MTChordCycling::selectSlideChord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v8 = (MTChordIntegrating *)(a1 + 408);
  MTChordIntegrating::endChordIntegration(a1 + 408, a2, a3, a4, a1);
  if (a5)
  {
    MTChordIntegrating::operator=(v8, a5);
    *(void *)(a1 + 1224) = *(void *)(a2 + 8);
    MTChordIntegrating::beginChordIntegration((double *)v8, a2);
    double result = *(double *)(a2 + 8);
    *(double *)(a1 + 656) = result;
  }
  return result;
}

double MTChordCycling::selectTapChord(MTChordCycling *this, const MTHandStatistics *a2, const MTHandMotion *a3, MTChordGestureSet *a4)
{
  if (a4)
  {
    *((void *)this + 153) = *((void *)a2 + 1);
    MTChordIntegrating::operator=((MTChordCycling *)((char *)this + 816), (uint64_t)a4);
    double result = *((double *)a2 + 1);
    *((double *)this + 133) = result;
  }
  return result;
}

void MTChordCycling::handleChordLiftoff(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a1 + 1040))
  {
    uint64_t v8 = *(void *)(a1 + 392);
    BOOL v9 = *(int *)(v8 + 24) >= 2 && *(unsigned __int8 *)(v8 + 48) > 1u
      || *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) == 1;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, BOOL, void))(*(void *)a1 + 120))(a1, a2, a3, a4, v9, 0);
    MTChordIntegrating::endChordIntegration(a1 + 816, a2, a3, a4, a1);
  }
  if (*(_DWORD *)(a1 + 632))
  {
    MTChordIntegrating::endChordIntegration(a1 + 408, a2, a3, a4, a1);
  }
}

BOOL MTChordCycling::touchdownSinceTapOrExcessMotion(MTChordCycling *this, const MTHandStatistics *a2)
{
  double v2 = *((double *)a2 + 10);
  double v3 = *((double *)a2 + 1);
  double v4 = v3 - v2;
  uint64_t v5 = *((void *)this + 49);
  double v6 = v3 - *(double *)(v5 + 72);
  double v7 = v3 - *(double *)(v5 + 80);
  if (v6 < v7) {
    double v7 = v6;
  }
  return v4 < v7 && v2 > *((double *)this + 157);
}

BOOL MTChordCycling::subsetSinceTapOrExcessMotion(MTChordCycling *this, const MTHandStatistics *a2)
{
  double v2 = *((double *)a2 + 33);
  double v3 = *((double *)a2 + 1);
  double v4 = v3 - v2;
  uint64_t v5 = *((void *)this + 49);
  double v6 = v3 - *(double *)(v5 + 72);
  double v7 = v3 - *(double *)(v5 + 80);
  if (v6 < v7) {
    double v7 = v6;
  }
  return v4 < v7 && v2 > *((double *)this + 157);
}

void MTChordCycling::chk4excessTapMotion(MTChordCycling *this, const MTHandStatistics *a2, const MTHandMotion *a3)
{
  if (*((_DWORD *)this + 260) && *((_DWORD *)this + 158) && *((unsigned char *)this + 672))
  {
    double v3 = (unsigned __int16 **)*((void *)this + 85);
    if (v3 && *v3 != v3[1])
    {
      if ((**v3 & 0x80) != 0) {
        goto LABEL_20;
      }
      unsigned int v4 = **v3 - 35;
      BOOL v5 = v4 > 0x2B;
      uint64_t v6 = (1 << v4) & 0x8010000001FLL;
      if (!v5 && v6 != 0) {
        goto LABEL_20;
      }
    }
    int v8 = dword_268C8EC88 >= 0 ? dword_268C8EC88 : dword_268C8EC88 + 1;
    int v9 = v8 >> 1;
    int v10 = *((unsigned __int8 *)a2 + 186) >= 2u ? v9 : dword_268C8EC88;
    if (*((_DWORD *)this + 174) >= v10)
    {
LABEL_20:
      *((void *)this + 157) = *((void *)a2 + 1);
      MTChordIntegrating::nullify((void **)this + 102);
    }
  }
}

uint64_t MTChordCycling::chk4newTapChord(MTChordCycling *this, MTHandStatistics *a2, const MTHandMotion *a3, MTChordGestureSet *a4)
{
  if (a4
    && *((double *)a2 + 10) > *((double *)a2 + 16)
    && (*(unsigned int (**)(MTChordCycling *, MTHandStatistics *))(*(void *)this + 48))(this, a2))
  {
    int v8 = *((_DWORD *)this + 260);
    if (!v8
      || ((unsigned int v9 = *((_DWORD *)a4 + 54), v9 >= *((_DWORD *)this + 258)) || v9 < *((unsigned __int8 *)a2 + 186))
      && *((_DWORD *)a4 + 56) != v8)
    {
      (*(void (**)(MTChordCycling *, MTHandStatistics *, const MTHandMotion *, MTChordGestureSet *))(*(void *)this + 72))(this, a2, a3, a4);
    }
  }
  int v10 = *(uint64_t (**)(MTChordCycling *, MTHandStatistics *, const MTHandMotion *))(*(void *)this + 80);

  return v10(this, a2, a3);
}

BOOL MTChordCycling::tapHasValidTimingAndStrength(MTChordCycling *this, const MTHandStatistics *a2, const MTHandMotion *a3, char a4)
{
  if (*((float *)a2 + 51) <= *((float *)this + 92)) {
    return 0;
  }
  double v5 = *((double *)a2 + 10);
  double v6 = *((double *)a2 + 1);
  if (v6 - v5 >= *(double *)&qword_268C8EC50
    || v5 - *((double *)a2 + 9) >= *(double *)&qword_268C8EC50 * 0.5
    || (a4 & 1) == 0 && v6 - *((double *)a2 + 33) >= *(double *)&qword_268C8EC50)
  {
    return 0;
  }
  if (*((unsigned char *)a2 + 186) && *((unsigned char *)a2 + 185)) {
    return 0;
  }
  if (v6 - v5 <= *(double *)&qword_268C8EC58 && *((unsigned char *)this + 400)) {
    return 0;
  }
  MTAbsoluteTimeGetCurrent();
  if (v9 - *((double *)a2 + 5) < *(double *)&qword_268C8EC50) {
    return 0;
  }
  MTAbsoluteTimeGetCurrent();
  if (v10 - *((double *)a2 + 6) < *(double *)&qword_268C8EC50) {
    return 0;
  }
  if (*((_DWORD *)this + 158))
  {
    if (*((_DWORD *)this + 173)) {
      return 0;
    }
    uint64_t v11 = (void *)*((void *)this + 85);
    if (v11)
    {
      if (*v11 != v11[1] && *(_WORD *)*v11 == 70) {
        return 0;
      }
    }
  }
  return (*((_DWORD *)a2 + 44) == *((_DWORD *)a2 + 45) || *((unsigned __int16 *)a2 + 108) >= 2u)
      && (!(*((unsigned __int8 *)a2 + 211) + *((unsigned __int8 *)a2 + 186)) || !*((unsigned char *)a2 + 184))
      && *((float *)a3 + 61) <= *(float *)&dword_268C8ECD0;
}

void MTChordCycling::processDoubleTap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 392);
  double v5 = *(double *)(a2 + 8);
  double v6 = *(double *)(v4 + 72);
  double v7 = v5 - v6;
  if (v5 - v6 < *(double *)&qword_268C8EC80 && v6 > *(double *)(v4 + 88))
  {
    int v9 = *(unsigned __int8 *)(v4 + 49);
    if (*(_DWORD *)(a1 + 1032) == v9
      && (hypotf(*(float *)(a2 + 248) - *(float *)(a2 + 240), *(float *)(a2 + 252) - *(float *)(a2 + 244)) < *(float *)(a1 + 380)
       || vabdd_f64(*(double *)(a2 + 96), *(double *)(a2 + 104)) < *(double *)&qword_268C8ECA8)
      && (!*(unsigned char *)(a1 + 376) || v7 >= v5 - *(double *)(a2 + 136)))
    {
      if (!*(unsigned char *)(a1 + 384)
        || (v9 == *(unsigned __int8 *)(a2 + 199) ? (BOOL v13 = v9 == *(unsigned __int8 *)(a2 + 200)) : (BOOL v13 = 0), v13))
      {
        MTGesture::dispatchEvents((uint64_t *)(a1 + 880), v4, a4, 0, 0, a3, 28672, *(unsigned int *)(a1 + 1040), v5);
        uint64_t v14 = *(void *)(a1 + 392);
        *(void *)(v14 + 88) = *(void *)(a2 + 8);
        MTTapDragManager::clearCycle(v14);
      }
    }
  }
}

void MTChordCycling::processMultiFingerDoubleTap(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 392);
  double v7 = *(double *)(a2 + 8);
  double v8 = *(double *)(v6 + 72);
  if (v7 - v8 < *(double *)&qword_268C8EC80
    && v8 > *(double *)(v6 + 88)
    && (int v9 = *(unsigned __int8 *)(v6 + 49), *(_DWORD *)(a1 + 1032) == v9)
    && (!*(unsigned char *)(a1 + 376) || v7 - v8 >= v7 - *(double *)(a2 + 136))
    && (!*(unsigned char *)(a1 + 384)
     || (v9 == *(unsigned __int8 *)(a2 + 199) ? (BOOL v10 = v9 == *(unsigned __int8 *)(a2 + 200)) : (BOOL v10 = 0), v10)))
  {
    MTGesture::dispatchEvents((uint64_t *)(a1 + 880), v6, a4, 0, 0, (uint64_t)a3, 28672, *(unsigned int *)(a1 + 1040), v7);
    uint64_t v14 = *(void *)(a1 + 392);
    *(void *)(v14 + 88) = *(void *)(a2 + 8);
    MTTapDragManager::clearCycle(v14);
  }
  else if (*(int *)(a1 + 1036) >= 2)
  {
    uint64_t v11 = *(void *)(a1 + 816);
    if (v11 != *(void *)(a1 + 824))
    {
      if (*(_WORD *)v11)
      {
        int v12 = *(_WORD **)(a1 + 880);
        if (v12 != *(_WORD **)(a1 + 888))
        {
          if (*v12)
          {
            if (*(_WORD *)v11 == 67)
            {
              int v13 = *(_DWORD *)(v11 + 4);
              if (v13 == 1024 || v13 == 512) {
                MTTapDragManager::queueMultiFingerTapWaitingForDouble(*(void *)(a1 + 392), a2, a3, a4, v13);
              }
            }
          }
        }
      }
    }
  }
  uint64_t v15 = *(void *)(a1 + 392);
  int v16 = *(_DWORD *)(a1 + 1032);
  *(void *)(v15 + 72) = *(void *)(a2 + 8);
  *(unsigned char *)(v15 + 49) = v16;

  MTChordIntegrating::nullify((void **)(a1 + 816));
}

void MTChordCycling::handleChordTaps(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!*(_DWORD *)(a1 + 1040)) {
    return;
  }
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 48))(a1)) {
    return;
  }
  if (!(*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 96))(a1, a2, a3, a6)) {
    return;
  }
  int v11 = *(_DWORD *)(a1 + 1048);
  if (v11)
  {
    if ((*(_DWORD *)(a1 + 24) & v11) == 0) {
      return;
    }
  }
  int v12 = *(_WORD **)(a1 + 816);
  if (v12 == *(_WORD **)(a1 + 824)) {
    goto LABEL_11;
  }
  int v13 = 0;
  if (!*v12 || (a6 & 1) != 0) {
    goto LABEL_12;
  }
  if (*(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186))
  {
LABEL_11:
    int v13 = 0;
  }
  else
  {
    MTGesture::dispatchEvents((uint64_t *)(a1 + 816), *(void *)(a1 + 392), a4, 0, 0, a3 + 168, 12288, *(unsigned int *)(a1 + 1040), *(double *)(a2 + 8));
    int v13 = 1;
  }
LABEL_12:
  if (*(_DWORD *)(a1 + 1036) == 1)
  {
    uint64_t v14 = *(_WORD **)(a1 + 880);
    if (v14 != *(_WORD **)(a1 + 888)
      && *v14
      && (a6 & 1) == 0
      && *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) <= 1)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 104))(a1, a2, a3 + 168, a4);
      int v13 = 1;
    }
  }
  if (a6 && *(double *)(a2 + 80) - *(double *)(a2 + 88) <= 0.09
    || *(int *)(a1 + 1036) < 2
    || (uint64_t v15 = *(_WORD **)(a1 + 880), v15 == *(_WORD **)(a1 + 888))
    || !*v15
    || *(float *)(a3 + 356) >= 21.0
    || (double v16 = *(double *)(a2 + 8),
        double v17 = v16 - *(double *)(a2 + 64),
        v17 >= *(double *)&qword_268C8EC50 + *(double *)&qword_268C8ECB0)
    || (double v18 = v16 - *(double *)(a2 + 56), v17 - v18 >= *(double *)&qword_268C8ECB0)
    || v18 - (v16 - *(double *)(a2 + 80)) >= *(double *)&qword_268C8ECB0)
  {
    if (!v13) {
      return;
    }
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 112))(a1, a2, a3 + 168, a4);
  }
  if (*(_DWORD *)(a1 + 1040))
  {
    uint64_t v19 = *(void *)(a1 + 392);
    int v20 = *(_DWORD *)(a1 + 1032);
    *(void *)(v19 + 72) = *(void *)(a2 + 8);
    *(unsigned char *)(v19 + 49) = v20;
    MTChordIntegrating::nullify((void **)(a1 + 816));
  }
}

uint64_t MTChordCycling::possiblyStartChordMomentum(uint64_t result, unsigned __int8 *a2, uint64_t a3)
{
  if (a2[211] + a2[186] < a2[190] + a2[187])
  {
    if (*(_DWORD *)(result + 632)) {
      return MTChordIntegrating::possiblyStartMomentum(result + 408, (uint64_t)a2, a3, result);
    }
  }
  return result;
}

uint64_t MTChordCycling::possiblyStopChordMomentum(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(result + 1264)
    && *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) > *(unsigned __int8 *)(a2 + 190)
                                                                                     + *(unsigned __int8 *)(a2 + 187))
  {
    int v4 = *(_DWORD *)(result + 1268);
    if (*(_DWORD *)(result + 1276) == v4)
    {
      if (*(unsigned char *)(result + 1272)) {
        *(void *)(*(void *)(result + 392) + 80) = *(void *)(a2 + 8);
      }
    }
    return MTDragManagerEventQueue::stopMomentum(result, a4, v4);
  }
  return result;
}

uint64_t MTChordCycling::chk4chordCycling(_DWORD *a1, uint64_t a2, float32x4_t *a3, uint64_t a4)
{
  if (*(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) > *(unsigned __int8 *)(a2 + 190)
                                                                                     + *(unsigned __int8 *)(a2 + 187)
    && a1[158])
  {
    MTChordIntegrating::clearMickeysSinceLastTouchdown((uint64_t)(a1 + 102));
  }
  (*(void (**)(_DWORD *, uint64_t, float32x4_t *, uint64_t))(*(void *)a1 + 144))(a1, a2, a3, a4);
  (*(void (**)(_DWORD *, uint64_t, uint64_t))(*(void *)a1 + 136))(a1, a2, a4);
  uint64_t v8 = *(void *)a1;
  if (!(*(unsigned __int8 *)(a2 + 298) | *(unsigned __int8 *)(a2 + 186)))
  {
    int v9 = *(uint64_t (**)(_DWORD *, uint64_t, float32x4_t *, uint64_t))(v8 + 88);
    return v9(a1, a2, a3, a4);
  }
  char v11 = (*(uint64_t (**)(_DWORD *, uint64_t))(v8 + 24))(a1, a2);
  uint64_t MatchingChord = MTChordTable::findMatchingChord((MTChordTable *)a1, v11, 0);
  uint64_t result = (*(uint64_t (**)(_DWORD *, uint64_t, float32x4_t *, uint64_t))(*(void *)a1 + 128))(a1, a2, a3, MatchingChord);
  int v13 = a1[158];
  if (v13)
  {
    if (!MatchingChord) {
      return result;
    }
    if (*(_DWORD *)(MatchingChord + 224) == v13)
    {
      uint64_t result = MTChordGestureSet::chordGestureSetEquals((MTChordGestureSet *)MatchingChord, (const MTChordGestureSet *)(a1 + 102));
      if (result) {
        return result;
      }
    }
    if (*(_DWORD *)(MatchingChord + 216) >= a1[156])
    {
      if (*((unsigned char *)a1 + 672)
        && ((a1[159] & 0x20) == 0
         || ((*(_WORD *)(MatchingChord + 228) & 2) == 0
          || (*(_DWORD *)(a2 + 164) - 3000) >= 0xFFFFFC18
          && a1[7] != 2
          && *(unsigned __int8 *)(a2 + 298) != *(unsigned __int8 *)(a2 + 302))
         && *(double *)(a2 + 8) - *(double *)(a2 + 56) >= 0.09))
      {
        return result;
      }
    }
    else if (*((unsigned char *)a1 + 672) || (*(_DWORD *)(a2 + 164) - 3000) >= 0xFFFFFC18 && a1[7] != 2)
    {
      __int16 v14 = *((_WORD *)a1 + 318);
      if ((v14 & 0x10) == 0
        || (*(_WORD *)(MatchingChord + 228) & 1) == 0
        || (v14 & 0x80) == 0 && *(double *)(a2 + 8) - *(double *)(a2 + 128) <= *(double *)&gTimingPrefs * 0.5)
      {
        return result;
      }
      uint64_t v15 = (unsigned __int16 **)*((void *)a1 + 85);
      if (v15)
      {
        if (*v15 != v15[1] && **v15 - 35 < 5) {
          return result;
        }
      }
    }
  }
  else
  {
    if (!MatchingChord) {
      return result;
    }
    uint64_t result = MTChordGestureSet::isChordReadyToIntegrate((MTChordGestureSet *)MatchingChord, (const MTHandStatistics *)a2, a3);
    if (!result) {
      return result;
    }
  }
  double v16 = *(uint64_t (**)(_DWORD *, uint64_t, float32x4_t *, uint64_t, uint64_t))(*(void *)a1 + 64);

  return v16(a1, a2, a3, a4, MatchingChord);
}

double MTChordCycling::parseHandGesturesCreateHIDEvents(_DWORD *a1, MTHandStatistics *a2, const MTHandMotion *a3, uint64_t a4)
{
  (*(void (**)(_DWORD *))(*(void *)a1 + 152))(a1);
  if (a1[158])
  {
    MTChordIntegrating::continueChordIntegration((MTChordGestureSet *)(a1 + 102), a2, a3, a4, (uint64_t)a1, result, v9, v10);
    return MTChordIntegrating::decayMomentumFilters((MTChordIntegrating *)(a1 + 102), a2);
  }
  return result;
}

uint64_t MTChordCycling::shouldBlockClicks(MTChordCycling *this, const MTHandStatistics *a2, const MTHandMotion *a3)
{
  float v3 = *((float *)a3 + 62);
  double v4 = 0.0;
  if (v3 > 1.0)
  {
    double v4 = 0.5;
    if (v3 < 100.0) {
      double v4 = (float)((float)(v3 + -1.0) / 99.0) * 0.5;
    }
  }
  double v5 = *((double *)a2 + 1);
  int v6 = *((_DWORD *)this + 158);
  if (!v6) {
    goto LABEL_12;
  }
  double v7 = (unsigned __int16 **)*((void *)this + 85);
  if (!v7)
  {
    int v6 = 0;
    goto LABEL_13;
  }
  int v6 = *v7 != v7[1] && **v7 == 69;
  if (*v7 == v7[1]) {
LABEL_12:
  }
    LODWORD(v7) = 0;
  else {
    LODWORD(v7) = **v7 == 71;
  }
LABEL_13:
  unsigned int v8 = v6 | v7;
  if (v5 - *((double *)this + 155) <= v4) {
    unsigned int v8 = 1;
  }
  if (v5 - *((double *)this + 156) <= v4) {
    return 1;
  }
  else {
    return v8;
  }
}

void MTTapDragManager::MTTapDragManager(MTTapDragManager *this)
{
  *(void *)this = &unk_26F4DB1D0;
  *((unsigned char *)this + 8) = 0;
  *(_WORD *)((char *)this + 9) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((_WORD *)this + 24) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 1MTTrackpadEventDispatcher::cancelOutstandingMomentumTimer(this, 1) = 0;
  *((void *)this + 9) = 0;
  *(void *)((char *)this + 20) = 0;
  *(void *)((char *)this + 12) = 0;
  *((unsigned char *)this + 28) = 0;
}

uint64_t MTTapDragManager::clearState(uint64_t this)
{
  *(unsigned char *)(this + 28) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_WORD *)(this + 9) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = 0;
  *(_WORD *)(this + 48) = 0;
  *(void *)(this + 80) = 0;
  *(void *)(this + 88) = 0;
  *(void *)(this + 72) = 0;
  return this;
}

uint64_t MTTapDragManager::setCycleState(uint64_t result, int a2)
{
  *(_DWORD *)(result + 24) = a2;
  return result;
}

uint64_t MTTapDragManager::clearCycle(uint64_t this)
{
  *(unsigned char *)(this + 28) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(unsigned char *)(this + 48) = 0;
  *(_WORD *)(this + 9) = 0;
  return this;
}

uint64_t MTTapDragManager::dragHandModifiers(MTTapDragManager *this)
{
  int v2 = *((_DWORD *)this + 6);
  if (v2 >= 2 && (v2 == 2 || *((unsigned char *)this + 28) == 0)) {
    return 256;
  }
  uint64_t result = *((void *)this + 2);
  if (!result) {
    return result;
  }
  if (MTForceManagement::whichForceButtonActivated((MTForceManagement *)result) == 1) {
    return 256;
  }
  uint64_t result = *((void *)this + 2);
  if (result)
  {
    if (MTForceManagement::whichForceButtonActivated((MTForceManagement *)result) == 2)
    {
      return 512;
    }
    else
    {
      uint64_t result = *((void *)this + 2);
      if (result) {
        return (MTForceManagement::whichForceButtonActivated((MTForceManagement *)result) == 4) << 10;
      }
    }
  }
  return result;
}

BOOL MTTapDragManager::shouldReleaseTapDragDueToPause(MTTapDragManager *this, double a2)
{
  int v2 = *((_DWORD *)this + 6);
  if (v2 < 2) {
    return 0;
  }
  if (v2 <= 3) {
    return a2 - *((double *)this + 4) < *(double *)&gTimingPrefs;
  }
  return 1;
}

BOOL MTTapDragManager::halfTapDragTimedOut(MTTapDragManager *this, double a2)
{
  int v4 = *((unsigned __int8 *)this + 28);
  uint64_t v5 = qword_268C8EC68;
  uint64_t v6 = qword_268C8EC78;
  if (((*(uint64_t (**)(MTTapDragManager *))(*(void *)this + 16))(this) & 0x100) == 0) {
    return 1;
  }
  if (v4) {
    double v8 = *(double *)&v6;
  }
  else {
    double v8 = *(double *)&v5;
  }
  double v9 = a2 - *((double *)this + 9);
  if (v9 >= a2 - *((double *)this + 10)) {
    double v9 = a2 - *((double *)this + 10);
  }
  return v9 > v8;
}

BOOL MTTapDragManager::shouldSustainDrag(MTTapDragManager *this, double a2, int a3)
{
  if (*((unsigned char *)this + 9)) {
    return 0;
  }
  if (a3 - *((unsigned __int8 *)this + 48) > 0) {
    return 1;
  }
  int v6 = *((_DWORD *)this + 6);
  if (v6 < 2) {
    return !MTTapDragManager::halfTapDragTimedOut(this, a2);
  }
  if (v6 > 3 || a2 - *((double *)this + 4) < *(double *)&gTimingPrefs) {
    return 0;
  }
  return v6 >= 3
      && *((unsigned char *)this + 8)
      && ((**(uint64_t (***)(MTTapDragManager *))this)(this) & 1) != 0
      || !MTTapDragManager::halfTapDragTimedOut(this, a2);
}

uint64_t MTTapDragManager::sendWaitingClickAtHalfTimeout(uint64_t a1, uint64_t a2, int a3, double a4)
{
  if (!*(unsigned char *)(a1 + 9))
  {
    double v8 = a4 - *(double *)(a1 + 72);
    if (*(unsigned char *)(a1 + 10))
    {
      if (v8 >= *(double *)&qword_268C8EC80 + *(double *)&qword_268C8EC58 * -2.0 && *(unsigned __int8 *)(a1 + 48) == a3)
      {
        unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
        MTActionEvent::MTActionEvent((MTActionEvent *)&v10, 67, *(_DWORD *)(a1 + 12), 0);
        uint64_t v5 = 1;
        (*(void (**)(uint64_t, unint64_t *, uint64_t, void, void, uint64_t, uint64_t, uint64_t, double))(*(void *)a1 + 24))(a1, &v10, a2, 0, 0, a1 + 52, 12288, 1, a4);
        *(double *)(a1 + 88) = a4;
        *(unsigned char *)(a1 + 28) = 0;
        *(_DWORD *)(a1 + 12) = 0;
        *(_DWORD *)(a1 + 24) = 0;
        *(void *)(a1 + 32) = 0;
        *(unsigned char *)(a1 + 48) = 0;
        goto LABEL_3;
      }
    }
    else if (v8 >= *(double *)&qword_268C8EC60)
    {
      if (*(unsigned __int8 *)(a1 + 48) == a3)
      {
        unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
        MTActionEvent::MTActionEvent((MTActionEvent *)&v10, 67, 256, 0);
        (*(void (**)(uint64_t, unint64_t *, uint64_t, void, void, uint64_t, uint64_t, uint64_t, double))(*(void *)a1 + 24))(a1, &v10, a2, 0, 0, a1 + 52, 12288, 1, a4);
      }
      goto LABEL_2;
    }
    return 0;
  }
LABEL_2:
  *(unsigned char *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  uint64_t v5 = 1;
LABEL_3:
  *(_WORD *)(a1 + 9) = 0;
  return v5;
}

uint64_t MTTapDragManager::sendPendingMultiFingerTap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, double a6)
{
  double v8 = *(double *)(a3 + 8);
  if (*(int *)(a1 + 24) <= 1)
  {
    BOOL v11 = *(double *)&qword_268C8ECE0 > a6 || *(unsigned __int8 *)(a3 + 195) > 1u;
    if (v11 || *(float *)(a4 + 248) > *(float *)&dword_268C8ECD0)
    {
      uint64_t v10 = 0;
LABEL_15:
      *(unsigned char *)(a1 + 28) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 24) = 0;
      *(void *)(a1 + 32) = 0;
      *(unsigned char *)(a1 + 48) = 0;
      goto LABEL_16;
    }
  }
  if (*(unsigned char *)(a1 + 10))
  {
    double v9 = v8 - *(double *)(a1 + 72);
    if (v9 > *(double *)&qword_268C8EC80 + *(double *)&qword_268C8EC58 * 2.0)
    {
      *(unsigned char *)(a1 + 28) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 24) = 0;
      *(void *)(a1 + 32) = 0;
      *(unsigned char *)(a1 + 48) = 0;
      uint64_t v10 = 1;
LABEL_16:
      *(_WORD *)(a1 + 9) = 0;
      return v10;
    }
    if (!a5 || v9 > *(double *)&qword_268C8EC80)
    {
      unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
      MTActionEvent::MTActionEvent((MTActionEvent *)&v13, 67, *(_DWORD *)(a1 + 12), 0);
      uint64_t v10 = 1;
      (*(void (**)(uint64_t, unint64_t *, uint64_t, void, void, uint64_t, uint64_t, uint64_t, double))(*(void *)a1 + 24))(a1, &v13, a2, 0, 0, a1 + 52, 12288, 1, v8);
      *(double *)(a1 + 88) = v8;
      goto LABEL_15;
    }
  }
  return 0;
}

double MTTapDragManager::queueTapWaitingForHalf(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  *(_DWORD *)(a1 + 24) = 1;
  *(_OWORD *)(a1 + 52) = *a3;
  double result = *(double *)(a2 + 8);
  *(double *)(a1 + 40) = result;
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 211) + *(unsigned char *)(a2 + 186);
  return result;
}

double MTTapDragManager::queueMultiFingerTapWaitingForDouble(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, int a5)
{
  *(_DWORD *)(a1 + 24) = 1;
  *(_OWORD *)(a1 + 52) = *a3;
  double result = *(double *)(a2 + 8);
  *(double *)(a1 + 40) = result;
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 211) + *(unsigned char *)(a2 + 186);
  *(unsigned char *)(a1 + 10) = 1;
  *(_DWORD *)(a1 + 12) = a5;
  return result;
}

uint64_t MTTapDragManager::queueButtonClickEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 9) = 0;
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  MTActionEvent::MTActionEvent((MTActionEvent *)&v9, 67, 256, 0);
  return (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, void, void, uint64_t, uint64_t, uint64_t, double))(*(void *)a1 + 24))(a1, &v9, a4, 0, 0, a3, 12288, 1, *(double *)(a2 + 8));
}

double MTTapDragManager::queueButtonPressEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_DWORD *)(a1 + 24) = 2;
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  MTActionEvent::MTActionEvent((MTActionEvent *)&v9, 65, 256, 0);
  (*(void (**)(uint64_t, unint64_t *, uint64_t, void, void, uint64_t, uint64_t, uint64_t, double))(*(void *)a1 + 24))(a1, &v9, a4, 0, 0, a3, 12288, 1, *(double *)(a2 + 8));
  double result = *(double *)(a2 + 8);
  *(double *)(a1 + 40) = result;
  return result;
}

uint64_t MTTapDragManager::queueButtonReleaseEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  MTActionEvent::MTActionEvent((MTActionEvent *)&v9, 66, 256, 0);
  *(unsigned char *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 9) = 0;
  return (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, void, void, uint64_t, uint64_t, uint64_t, double))(*(void *)a1 + 24))(a1, &v9, a4, 0, 0, a3, 12288, 1, *(double *)(a2 + 8));
}

double MTTapDragManager::handleTapsForDrag(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  long long v9 = *(_OWORD *)(a3 + 168);
  int v7 = *(_DWORD *)(a1 + 24);
  if (v7 < 2)
  {
    if (*(double *)(a2 + 8) - *(double *)(a1 + 72) >= *(double *)&qword_268C8EC50)
    {
      *(_DWORD *)(a1 + 24) = 1;
      *(_OWORD *)(a1 + 52) = v9;
      *(void *)(a1 + 40) = *(void *)(a2 + 8);
      *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 211) + *(unsigned char *)(a2 + 186);
      goto LABEL_7;
    }
  }
  else
  {
    MTTapDragManager::queueButtonReleaseEvent(a1, a2, (uint64_t)&v9, a4);
    if (v7 != 2) {
      goto LABEL_7;
    }
  }
  MTTapDragManager::queueButtonClickEvent(a1, a2, (uint64_t)&v9, a4);
LABEL_7:
  double result = *(double *)(a2 + 8);
  *(double *)(a1 + 72) = result;
  *(unsigned char *)(a1 + 49) = 1;
  return result;
}

uint64_t MTTapDragManager::handleImmediateTapDragRelease(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = result;
  if (*(int *)(result + 24) >= 2)
  {
    double result = (**(uint64_t (***)(uint64_t))result)(result);
    if (result)
    {
      if (*(unsigned char *)(v4 + 9)) {
        double result = MTTapDragManager::queueButtonReleaseEvent(v4, a2, a3 + 168, a4);
      }
    }
  }
  *(unsigned char *)(v4 + 9) = 0;
  return result;
}

uint64_t MTTapDragManager::chk4dragCycling(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  MTTapDragManager::sendPendingMultiFingerTap(a1, a4, a2, a3, 1, a5);
  int v9 = *(_DWORD *)(a1 + 24);
  if (v9 == 1)
  {
    unsigned int v10 = *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186);
    if (v10 <= *(unsigned __int8 *)(a2 + 190) + *(unsigned __int8 *)(a2 + 187)
      || v10 <= *(unsigned __int8 *)(a1 + 48)
      || *(unsigned char *)(a1 + 10))
    {
      MTTapDragManager::sendWaitingClickAtHalfTimeout(a1, a4, v10, *(double *)(a2 + 8));
    }
    else
    {
      MTTapDragManager::queueButtonPressEvent(a1, a2, a3 + 168, a4);
    }
    goto LABEL_20;
  }
  if (v9 >= 2 && (**(unsigned int (***)(uint64_t))a1)(a1))
  {
    if (!*(unsigned char *)(a1 + 48) && *(unsigned __int8 *)(a2 + 211) + *(unsigned __int8 *)(a2 + 186) == 2) {
      *(unsigned char *)(a1 + 48) = 1;
    }
    double v11 = *(double *)(a2 + 8);
    double v12 = v11 - *(double *)(a2 + 80);
    double v13 = v11 - *(double *)(a2 + 128);
    if (v12 < v13 || v13 == 0.0)
    {
      if (v12 <= *(double *)&qword_268C8EC70 || v11 - *(double *)(a3 + 160) <= *(double *)&qword_268C8EC70)
      {
        if (*(int *)(a1 + 24) < 4) {
          goto LABEL_20;
        }
        int v14 = 3;
      }
      else
      {
        *(double *)(a1 + 32) = v11;
        int v14 = 4;
      }
      *(_DWORD *)(a1 + 24) = v14;
    }
  }
LABEL_20:

  return MTTapDragManager::handleImmediateTapDragRelease(a1, a2, a3, a4);
}

double MTTapDragManager::sustainMultiFingerDrag(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 28) = 1;
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 211) + *(unsigned char *)(a2 + 186);
  *(_DWORD *)(a1 + 24) = 3;
  (*(void (**)(uint64_t))(*(void *)a1 + 8))(a1);
  double result = *(double *)(a2 + 8);
  *(double *)(a1 + 40) = result;
  *(double *)(a1 + 80) = result;
  return result;
}

uint64_t MTTapDragManager::handleTapsForMultiFingerDrag(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(int *)(result + 24) >= 3) {
    return MTTapDragManager::queueButtonReleaseEvent(result, a2, a3 + 168, a4);
  }
  return result;
}

void MTSimpleEmbeddedHIDManager::createManager()
{
}

void sub_24073E670(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10A1C40E945ADD8);
  _Unwind_Resume(a1);
}

void MTSimpleEmbeddedHIDManager::initialize(MTModeSwitcher *a1, uint64_t a2, const void *a3, int a4, int a5)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  *((void *)a1 + 26) = 0;
  *((void *)a1 + 27) = 0;
  MTSimpleHIDManager::initialize(a1, a2, a3, a4, a5);
  uint64_t IsReady = MTDeviceDriverIsReady();
  (*(void (**)(MTModeSwitcher *, uint64_t))(*(void *)a1 + 336))(a1, IsReady);
  (*(void (**)(MTModeSwitcher *))(*(void *)a1 + 80))(a1);
  if ((MTDeviceSupportsWirelessChargingNotification() & 1) != 0
    || ((*(void (**)(MTModeSwitcher *))(*(void *)a1 + 80))(a1),
        MTDeviceSupportsUSBChargingNotification()))
  {
    if ((MTDeviceHasExpectedVersion() & 1) == 0)
    {
      MTDeviceGetVersion();
      double v11 = MTLoggingPlugin();
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 136315906;
      double v17 = "";
      __int16 v18 = 2080;
      uint64_t v19 = "";
      __int16 v20 = 2080;
      uint64_t v21 = "initialize";
      __int16 v22 = 2048;
      uint64_t v23 = 0;
      unsigned int v10 = "[HID] [MT] %s%s%s Firmware version 0x%04jX is unexpected. Disabling interference monitor.";
      double v12 = v11;
      os_log_type_t v13 = OS_LOG_TYPE_DEFAULT;
      uint32_t v14 = 42;
      goto LABEL_18;
    }
    *((void *)a1 + 27) = (*(uint64_t (**)(MTModeSwitcher *))(*(void *)a1 + 616))(a1);
  }
  *((void *)a1 + 28) = 0;
  if (MTDeviceGetSATelemetryReportID()) {
    operator new();
  }
  int v7 = MTDeviceEnableWorkIntervalNotification();
  if (v7 == -536870201)
  {
    int v9 = MTLoggingPlugin();
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)buf = 136315650;
    double v17 = "";
    __int16 v18 = 2080;
    uint64_t v19 = "";
    __int16 v20 = 2080;
    uint64_t v21 = "initialize";
    unsigned int v10 = "[HID] [MT] %s%s%s Work interval notification not supported by device. Skipping.";
    goto LABEL_15;
  }
  int v8 = v7;
  if (!v7)
  {
    int v9 = MTLoggingPlugin();
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)buf = 136315650;
    double v17 = "";
    __int16 v18 = 2080;
    uint64_t v19 = "";
    __int16 v20 = 2080;
    uint64_t v21 = "initialize";
    unsigned int v10 = "[HID] [MT] %s%s%s Work interval notification enabled";
LABEL_15:
    double v12 = v9;
    os_log_type_t v13 = OS_LOG_TYPE_DEFAULT;
    uint32_t v14 = 32;
    goto LABEL_18;
  }
  uint64_t v15 = MTLoggingPlugin();
  if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
    return;
  }
  *(_DWORD *)buf = 136315906;
  double v17 = "[Error] ";
  __int16 v18 = 2080;
  uint64_t v19 = "";
  __int16 v20 = 2080;
  uint64_t v21 = "initialize";
  __int16 v22 = 1024;
  LODWORD(v23) = v8;
  unsigned int v10 = "[HID] [MT] %s%s%s MTDeviceEnableWorkIntervalNotification returned 0x%08X";
  double v12 = v15;
  os_log_type_t v13 = OS_LOG_TYPE_ERROR;
  uint32_t v14 = 38;
LABEL_18:
  _os_log_impl(&dword_2406FB000, v12, v13, v10, buf, v14);
}

void sub_24073EA0C(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x1020C405F07FB98);
  _Unwind_Resume(a1);
}

uint64_t MTSimpleEmbeddedHIDManager::start(MTSimpleEmbeddedHIDManager *this)
{
  uint64_t v2 = MTSimpleHIDManager::start(this);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 27);
    if (v3)
    {
      uint64_t v4 = *((void *)this + 22);
      uint64_t v5 = (const void *)(*(uint64_t (**)(MTSimpleEmbeddedHIDManager *))(*(void *)this + 80))(this);
      MTInterferenceMonitor::start(v3, v4, v5);
    }
    uint64_t v6 = *((void *)this + 28);
    if (v6)
    {
      int v7 = (const void *)(*(uint64_t (**)(MTSimpleEmbeddedHIDManager *))(*(void *)this + 80))(this);
      MTTelemetryAnalyticsReporter::start(v6, v7);
    }
  }
  return v2;
}

uint64_t MTSimpleEmbeddedHIDManager::stop(MTSimpleEmbeddedHIDManager *this)
{
  uint64_t v2 = (MTInterferenceMonitor *)*((void *)this + 27);
  if (v2) {
    MTInterferenceMonitor::stop(v2);
  }
  uint64_t v3 = (MTTelemetryAnalyticsReporter *)*((void *)this + 28);
  if (v3) {
    MTTelemetryAnalyticsReporter::stop(v3);
  }

  return MTSimpleHIDManager::stop(this);
}

void MTSimpleEmbeddedHIDManager::finalize(MTSimpleEmbeddedHIDManager *this)
{
  uint64_t v2 = *((void *)this + 27);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (MTTelemetryAnalyticsReporter *)*((void *)this + 28);
  if (v3)
  {
    MTTelemetryAnalyticsReporter::~MTTelemetryAnalyticsReporter(v3);
    MEMORY[0x2455F6CE0]();
  }

  MTSimpleHIDManager::finalize(this);
}

void MTSimpleEmbeddedHIDManager::createEventDispatcher(MTSimpleEmbeddedHIDManager *this)
{
}

void MTSimpleEmbeddedHIDManager::createGestureParser(MTSimpleEmbeddedHIDManager *this)
{
  uint64_t v2 = (*(uint64_t (**)(MTSimpleEmbeddedHIDManager *))(*(void *)this + 80))(this);
  MTParser::createParserForMTDevice(v2, *((_DWORD *)this + 39));
}

uint64_t MTSimpleEmbeddedHIDManager::initializeGestureParser(MTSimpleEmbeddedHIDManager *this)
{
  return (*(uint64_t (**)(MTSimpleEmbeddedHIDManager *, void))(*(void *)this + 592))(this, 0);
}

unsigned int *MTSimpleEmbeddedHIDManager::destroyGestureParser(MTSimpleEmbeddedHIDManager *this)
{
  double result = (unsigned int *)*((void *)this + 26);
  if (result)
  {
    double result = MTParser::release(result);
    *((void *)this + 26) = 0;
  }
  return result;
}

uint64_t MTSimpleEmbeddedHIDManager::devicePropertiesBecameAvailable(MTParser **this)
{
  (*((void (**)(MTParser **))*this + 39))(this);
  MTParser::updateSurfaceDimensions(this[26]);

  return MTSimpleHIDManager::devicePropertiesBecameAvailable((MTSimpleHIDManager *)this);
}

void MTSimpleEmbeddedHIDManager::setPluginDefaultProperties(MTSimpleEmbeddedHIDManager *this)
{
  MTSimpleHIDManager::setPluginDefaultProperties(this);
  (*(void (**)(MTSimpleEmbeddedHIDManager *))(*(void *)this + 80))(this);
  if (MTDeviceSupportsForce())
  {
    (*(void (**)(MTSimpleEmbeddedHIDManager *))(*(void *)this + 80))(this);
    int valuePtr = MTDeviceGetMinDigitizerPressureValue();
    (*(void (**)(MTSimpleEmbeddedHIDManager *))(*(void *)this + 80))(this);
    AccurateMaxDigitizerPressureCFNumberRef Value = MTDeviceGetAccurateMaxDigitizerPressureValue();
    (*(void (**)(MTSimpleEmbeddedHIDManager *))(*(void *)this + 80))(this);
    ExtendedMaxDigitizerPressureCFNumberRef Value = MTDeviceGetExtendedMaxDigitizerPressureValue();
    CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt32Type, &valuePtr);
    if (v3)
    {
      CFNumberRef v4 = v3;
      (*(void (**)(MTSimpleEmbeddedHIDManager *, __CFString *, CFNumberRef))(*(void *)this + 568))(this, @"MinDigitizerPressureValue", v3);
      CFRelease(v4);
    }
    CFNumberRef v5 = CFNumberCreate(v2, kCFNumberSInt32Type, &AccurateMaxDigitizerPressureValue);
    if (v5)
    {
      CFNumberRef v6 = v5;
      (*(void (**)(MTSimpleEmbeddedHIDManager *, __CFString *, CFNumberRef))(*(void *)this + 568))(this, @"MaxDigitizerPressureValue", v5);
      (*(void (**)(MTSimpleEmbeddedHIDManager *, __CFString *, CFNumberRef))(*(void *)this + 568))(this, @"AccurateMaxDigitizerPressureValue", v6);
      CFRelease(v6);
    }
    CFNumberRef v7 = CFNumberCreate(v2, kCFNumberSInt32Type, &ExtendedMaxDigitizerPressureValue);
    if (v7)
    {
      CFNumberRef v8 = v7;
      (*(void (**)(MTSimpleEmbeddedHIDManager *, __CFString *, CFNumberRef))(*(void *)this + 568))(this, @"DigitizerPressureDynamicRange", v7);
      (*(void (**)(MTSimpleEmbeddedHIDManager *, __CFString *, CFNumberRef))(*(void *)this + 568))(this, @"ExtendedMaxDigitizerPressureValue", v8);
      CFRelease(v8);
    }
  }
}

uint64_t MTSimpleEmbeddedHIDManager::getGestureParser(MTSimpleEmbeddedHIDManager *this)
{
  return *((void *)this + 26);
}

void MTSimpleEmbeddedHIDManager::createInterferenceMonitor(MTSimpleEmbeddedHIDManager *this)
{
}

void sub_24073F058(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10B1C405A1A1483);
  _Unwind_Resume(a1);
}

__n128 MTSimpleEmbeddedHIDManager::setTipOffsetParameters(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 208) + 64);
  __n128 result = *(__n128 *)a2;
  long long v4 = *(_OWORD *)(a2 + 16);
  long long v5 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v2 + 228) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v2 + 212) = v5;
  *(_OWORD *)(v2 + 196) = v4;
  *(__n128 *)(v2 + 180) = result;
  return result;
}

uint64_t createVendorDefinedTouchFrameEvent(unsigned __int8 *a1)
{
  mach_absolute_time();

  return IOHIDEventCreateVendorDefinedEvent();
}

const char *MTSimpleEmbeddedHIDManager::getName(MTSimpleEmbeddedHIDManager *this)
{
  return "MTSimpleEmbeddedHIDManager";
}

uint64_t MTSimpleEmbeddedHIDManager::handleContactFrame(MTSimpleHIDManager *this, double a2, uint64_t a3, unsigned __int8 *a4, uint64_t a5, uint64_t a6)
{
  *(void *)&v29[9] = *MEMORY[0x263EF8340];
  uint64_t v11 = *((void *)this + 25);
  if (v11) {
    MTSLGLogger::logPaths(v11, (uint64_t)a4, a5);
  }
  if (!MTSimpleHIDManager::touchFramesAllowed(this))
  {
    CFTypeRef cf = 0;
    MTDeviceGetDeviceID();
    double v16 = MTLoggingPlugin();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = *((_DWORD *)this + 32);
      int v18 = *((_DWORD *)this + 48);
      int v19 = *((unsigned __int8 *)this + 122);
      *(_DWORD *)buf = 67109888;
      *(_DWORD *)&uint8_t buf[4] = v17;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v18;
      LOWORD(v28) = 1024;
      *(_DWORD *)((char *)&v28 + 2) = v19;
      HIWORD(v28) = 2048;
      *(void *)unsigned int v29 = cf;
      os_log_type_t v13 = "received a touch frame but preventing dispatch. _currentDetectionMode=%d, _currentTouchMode=%d, _proxIntegra"
            "ted=%d (deviceID 0x%llX)";
      uint32_t v14 = v16;
      uint32_t v15 = 30;
      goto LABEL_13;
    }
    return 0;
  }
  if (*((double *)this + 18) == a2 && *((unsigned __int8 *)this + 152) == a6)
  {
    CFTypeRef cf = 0;
    MTDeviceGetDeviceID();
    double v12 = MTLoggingPlugin();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218496;
      *(void *)&uint8_t buf[4] = a6;
      *(_WORD *)&unsigned char buf[12] = 2048;
      double v28 = a2;
      v29[0] = 2048;
      *(void *)&v29[1] = cf;
      os_log_type_t v13 = "ignoring duplicate frame #%qu @ %f\n (deviceID 0x%llX)";
      uint32_t v14 = v12;
      uint32_t v15 = 32;
LABEL_13:
      _os_log_impl(&dword_2406FB000, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
      return 0;
    }
    return 0;
  }
  if (*((unsigned char *)this + 121))
  {
    CFTypeRef cf = 0;
    MTDeviceGetDeviceID();
    __int16 v20 = MTLoggingPlugin();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = cf;
      os_log_type_t v13 = "received a touch frame but parser is disabled, preventing dispatch (deviceID 0x%llX)";
      uint32_t v14 = v20;
      uint32_t v15 = 12;
      goto LABEL_13;
    }
    return 0;
  }
  kdebug_trace();
  *((double *)this + 18) = a2;
  *((unsigned char *)this + 152) = a6;
  CFTypeRef cf = 0;
  *(void *)buf = 0;
  uint64_t v22 = *((void *)this + 26);
  if (v22)
  {
    MTParser::handleContactFrame(v22, (uint64_t)a4, a5, a2, a6, (uint64_t)buf, (uint64_t *)&cf, 0);
    if (*(void *)buf)
    {
      (*(void (**)(MTSimpleHIDManager *, void, void))(*(void *)this + 136))(this, *(void *)buf, 0);
      CFRelease(*(CFTypeRef *)buf);
    }
    if (cf)
    {
      uint64_t v23 = (*(uint64_t (**)(MTSimpleHIDManager *))(*(void *)this + 120))(this);
      if ((*(unsigned int (**)(uint64_t))(*(void *)v23 + 80))(v23))
      {
        VendorDefinedTouchFrameuint64_t Event = createVendorDefinedTouchFrameEvent(a4);
        if (VendorDefinedTouchFrameEvent)
        {
          float v25 = (const void *)VendorDefinedTouchFrameEvent;
          IOHIDEventAppendEvent();
          CFRelease(v25);
        }
      }
      (*(void (**)(MTSimpleHIDManager *, CFTypeRef, void))(*(void *)this + 136))(this, cf, 0);
      CFRelease(cf);
    }
  }
  kdebug_trace();
  return 1;
}

void MTSimpleEmbeddedHIDManager::handleImageEntry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 200);
  if (v4) {
    MTSLGLogger::logImages(v4, a3, a4);
  }
}

uint64_t MTSimpleEmbeddedHIDManager::handleFrameHeader(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v3 = *(void *)(a1 + 208);
  if (v3) {
    MTParser::handleFrameHeader(v3, a3);
  }
  return 1;
}

void MTSimpleEmbeddedHIDManager::~MTSimpleEmbeddedHIDManager(MTSimpleEmbeddedHIDManager *this)
{
  MTSimpleHIDManager::~MTSimpleHIDManager(this);

  JUMPOUT(0x2455F6CE0);
}

void MTRestZoneIntegrator::clear(float32x2_t *this)
{
}

void MTRestZoneIntegrator::clearMotion(float32x2_t *this, int a2)
{
  char v2 = a2;
  if (a2)
  {
    MTRestZoneIntegrator::clearThumbFingerEnvelope(this);
    this[29].i32[1] = 0;
  }
  this[33] = 0;
  this[34] = 0;
  this[37].i32[1] = 0;
  this[27] = 0;
  *(_OWORD *)this[20].f32 = 0u;
  *(_OWORD *)this[22].f32 = 0u;
  MTFingerToPathMap::clearFingerPathMappings((MTFingerToPathMap *)this);
  uint64_t v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
    MTHandMotion::clearHandMotion(v2, v4);
  }
}

MTFingerToPathMap *MTRestZoneIntegrator::MTRestZoneIntegrator(MTFingerToPathMap *a1, uint64_t a2, __int32 a3, __int32 a4)
{
  MTFingerToPathMap::MTFingerToPathMap(a1, 0);
  *CFNumberRef v8 = (float32x2_t)&unk_26F4DB4A8;
  v8[31] = (float32x2_t)a2;
  v8[32].i32[0] = a3;
  v8[32].i32[1] = a4;
  MTRestZoneIntegrator::clearMotion(v8, 1);
  MTParameterFactory::initRestZoneBalanceParameters((uint64_t)a1 + 108);
  return a1;
}

void sub_24073F620(_Unwind_Exception *a1)
{
  MTFingerToPathMap::~MTFingerToPathMap(v1);
  _Unwind_Resume(a1);
}

void MTRestZoneIntegrator::~MTRestZoneIntegrator(MTRestZoneIntegrator *this)
{
  MTFingerToPathMap::~MTFingerToPathMap(this);

  JUMPOUT(0x2455F6CE0);
}

uint64_t MTRestZoneIntegrator::printExtractedMotion(uint64_t a1, int a2, int a3, uint64_t a4)
{
  printf("%dM/%d fingers, %d<-->%d\n", a3, a2, *(_DWORD *)(a1 + 80), *(_DWORD *)(a1 + 88));
  for (uint64_t i = 3; i != 8; ++i)
  {
    int v7 = *(_DWORD *)(a1 + 4 * i);
    if (v7) {
      printf("\tF%d %5.2fx %5.2fy %5.2fvx %5.2fvy\n", i - 2, *(float *)(a4 + 96 * v7 + 32), *(float *)(a4 + 96 * v7 + 36), *(float *)(a4 + 96 * v7 + 40), *(float *)(a4 + 96 * v7 + 44));
    }
  }
  return printf("\t%4.2fdx %4.2fdy %4.2fds %4.2fdr\n", *(float *)(a1 + 264), *(float *)(a1 + 268), *(float *)(a1 + 272), *(float *)(a1 + 276));
}

uint64_t MTRestZoneIntegrator::clearThumbFingerEnvelope(float32x2_t *this)
{
  if (this[12].u8[6] <= 3u) {
    this[29].f32[1] = MTRestZoneIntegrator::calcResidualBalance(this);
  }
  this[29].i32[0] = 0;
  this[28] = 0;
  this[30].i32[0] = 0;
  this[25] = 0;
  this[26] = 0;
  this[24] = 0;

  return MTFingerToPathMap::clearMaxFingersTouching((uint64_t)this);
}

float MTRestZoneIntegrator::calcResidualBalance(float32x2_t *this)
{
  float32x2_t v1 = vsqrt_f32(vadd_f32(this[28], this[28]));
  float result = (float)((float)(vsub_f32((float32x2_t)vdup_lane_s32((int32x2_t)v1, 1), v1).f32[0]
                         - (float)(this[15].f32[0] * sqrtf(this[27].f32[0])))
                 - (float)(this[15].f32[1] * sqrtf(this[27].f32[1])))
         - (float)(this[16].f32[0] * sqrtf(this[30].f32[0]));
  if (result <= 0.0)
  {
    if (result <= this[19].f32[1]) {
      return this[19].f32[1];
    }
  }
  else if (result >= this[17].f32[0])
  {
    return this[17].f32[0];
  }
  return result;
}

void MTRestZoneIntegrator::translationSimilarityDotProduct(float a1, float a2, float a3, float a4)
{
}

float MTRestZoneIntegrator::scalingFromDotProduct(float a1, float a2, float a3, float a4, float a5, float a6)
{
  return (float)((float)(a2 * a6) + (float)(a5 * a1)) - (float)((float)(a2 * a4) + (float)(a3 * a1));
}

float MTRestZoneIntegrator::rotationFromVectorProduct(float a1, float a2, float a3, float a4, float a5, float a6)
{
  return (float)((float)(a5 * a2) - (float)(a6 * a1)) - (float)((float)(a3 * a2) - (float)(a4 * a1));
}

float MTRestZoneIntegrator::computeSeparationVector(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v3 = *(float *)(a3 + 32) - *(float *)(a2 + 32);
  atan2f(-(float)(*(float *)(a3 + 36) - *(float *)(a2 + 36)), v3);
  return v3;
}

uint64_t MTRestZoneIntegrator::extractMotionDeltas(MTRestZoneIntegrator *this, const MTPathStates *a2, const MTParserPath *a3, const MTParserPath *a4, unsigned __int8 a5)
{
  BOOL v10 = MTParserPath::stableAndMoved(a3);
  uint64_t result = MTParserPath::stableAndMoved(a4);
  *((_DWORD *)this + 76) = 1065353216;
  *((void *)this + 33) = 0;
  *((void *)this + 34) = 0;
  int v12 = *((_DWORD *)a3 + 10);
  char v13 = a5 ^ 1;
  float v14 = 0.0;
  float v15 = 0.0;
  float v16 = 0.0;
  if (v12 && ((a5 ^ 1) & 1) == 0 && *((_DWORD *)a3 + 34) && v10)
  {
    float v16 = *((float *)a3 + 112) + 0.0;
    *((float *)this + 66) = v16;
    float v15 = *((float *)a3 + 113) + 0.0;
    *((float *)this + 67) = v15;
  }
  int v17 = *((_DWORD *)a4 + 10);
  if (v12 != v17 && v17 != 0)
  {
    float v19 = *((float *)a4 + 14) - *((float *)a3 + 14);
    float v20 = *((float *)a4 + 15) - *((float *)a3 + 15);
    float v21 = sqrtf((float)(v20 * v20) + (float)(v19 * v19));
    float v22 = 0.0;
    if (v21 > 0.0)
    {
      float v23 = v19 / v21;
      float v24 = v20 / v21;
      v35[0] = v19 / v21;
      v35[1] = v20 / v21;
      if (!*((_DWORD *)a4 + 34)) {
        char v13 = 1;
      }
      if ((v13 & 1) == 0 && *((_DWORD *)a3 + 34))
      {
        float v25 = *((float *)a4 + 112);
        float v26 = *((float *)a4 + 113);
        float v27 = *((float *)a3 + 112);
        float v28 = *((float *)a3 + 113);
        if ((v10 | result) == 1)
        {
          *((float *)this + 66) = (float)(v25 + v16) * 0.5;
          *((float *)this + 67) = (float)(v26 + v15) * 0.5;
          *((float *)this + 68) = (float)((float)((float)(v26 * v24) + (float)(v25 * v23))
                                        - (float)((float)(v28 * v24) + (float)(v27 * v23)))
                                * 0.5;
          *((float *)this + 69) = (float)((float)((float)(v25 * v24) - (float)(v26 * v23))
                                        - (float)((float)(v27 * v24) - (float)(v28 * v23)))
                                * 0.5;
        }
        MTRestZoneIntegrator::translationSimilarityDotProduct(v27, v28, v25, v26);
        float v22 = v29;
        if ((*((_DWORD *)a3 + 11) - 3) <= 1
          && (*((_DWORD *)a3 + 35) - 3) <= 1
          && MTParserPath::isFingerOrRestingContact(a3))
        {
          MTRestZoneIntegrator::combineCentralFingerScaleRotate(this, (uint64_t)a2, (uint64_t)a3, v35);
        }
      }
    }
    MTContact_getEllipseEccentricity();
    float v31 = v30;
    uint64_t result = MTContact_getEllipseEccentricity();
    float v33 = v31 / v32;
    *((float *)this + 76) = v33;
    if (v22 > 0.0)
    {
      double v34 = v33;
      if (v34 < 1.2) {
        float v14 = ((1.2 - v34) * 2.0 + 0.5) * v22;
      }
    }
  }
  *((float *)this + 75) = v14;
  return result;
}

MTParserPath *MTRestZoneIntegrator::combineCentralFingerScaleRotate(MTParserPath *result, uint64_t a2, uint64_t a3, float *a4)
{
  int v4 = *((_DWORD *)result + 20) + 1;
  if (v4 < *((_DWORD *)result + 22))
  {
    CFNumberRef v8 = result;
    int v9 = 0;
    float v10 = 0.0;
    do
    {
      if (v4 <= 0xF)
      {
        unsigned int v11 = *((_DWORD *)v8 + v4 + 2);
        if ((int)v11 >= 1)
        {
          uint64_t v12 = *(void *)(a2 + 280);
          uint64_t result = (MTParserPath *)(v12 + 600 * v11);
          if ((*((_DWORD *)result + 11) - 3) <= 1
            && (*(_DWORD *)(v12 + 600 * v11 + 140) - 3) <= 1)
          {
            uint64_t result = (MTParserPath *)MTParserPath::isFingerContact(result);
            if (result)
            {
              float v10 = v10
                  + (float)((float)((float)(*(float *)(v12 + 600 * v11 + 452) * a4[1])
                                  + (float)(*(float *)(v12 + 600 * v11 + 448) * *a4))
                          - (float)((float)(*(float *)(a3 + 452) * a4[1]) + (float)(*(float *)(a3 + 448) * *a4)));
              ++v9;
            }
          }
        }
      }
      ++v4;
    }
    while (v4 < *((_DWORD *)v8 + 22));
    if (v9 > 0)
    {
      float v13 = v10 / (float)v9;
      float v14 = *((float *)v8 + 68);
      if (fabsf(v13) > fabsf(v14)) {
        *((float *)v8 + 68) = (float)(v13 + v14) * 0.5;
      }
    }
  }
  return result;
}

void MTRestZoneIntegrator::computeSpeedSimilarity(MTRestZoneIntegrator *this, const MTPathStates *a2)
{
  float v4 = 0.0;
  float v5 = 3.4028e38;
  for (uint64_t i = 12; i != 32; i += 4)
  {
    int v7 = *(_DWORD *)((char *)this + i);
    if (v7 >= 1)
    {
      CFNumberRef v8 = (MTParserPath *)(*((void *)a2 + 35) + 600 * v7);
      if ((*((_DWORD *)v8 + 11) - 3) <= 1 && MTParserPath::isFingerOrRestingContact(v8))
      {
        float AverageVelocity_mm_s = MTParserPath::getAverageVelocity_mm_s(v8);
        float v11 = hypotf(AverageVelocity_mm_s, v10);
        if (v11 < v5) {
          float v5 = v11;
        }
        if (v11 > v4) {
          float v4 = v11;
        }
      }
    }
  }
}

float32x2_t MTRestZoneIntegrator::decayMotionEnvelope(uint64_t a1, float32x2_t *a2, float32x2_t *a3, float *a4, float *a5, float *a6, float a7)
{
  float v12 = 1.0 - expf((float)-a7 / *(float *)(a1 + 132));
  *(double *)&uint64_t v13 = (float)(v12 * 0.0);
  double v14 = 1.0 - v12;
  float v15 = *(double *)&v13 + v14 * *a4;
  *a4 = v15;
  float v16 = *(double *)&v13 + v14 * *a6;
  *a6 = v16;
  float v17 = *(double *)&v13 + v14 * *a5;
  *a5 = v17;
  float64x2_t v18 = (float64x2_t)vdupq_lane_s64(v13, 0);
  *(float32x4_t *)a2->f32 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_n_f64(v18, vcvtq_f64_f32(*a2), v14)), vmlaq_n_f64(v18, vcvt_hight_f64_f32(*(float32x4_t *)a2->f32), v14));
  float32x2_t result = vcvt_f32_f64(vmlaq_n_f64(v18, vcvtq_f64_f32(*a3), v14));
  *a3 = result;
  return result;
}

void MTRestZoneIntegrator::accumulateMotionEnvelope(uint64_t a1, float32x2_t *a2, float32x2_t *a3, float *a4, float *a5, float *a6, float a7)
{
  float v13 = 0.25;
  if (!*(unsigned char *)(a1 + 244)) {
    float v13 = 0.4;
  }
  a2[1] = vmla_n_f32(a2[1], vmul_f32(vmul_n_f32(*(float32x2_t *)(a1 + 108), powf(*(float *)(a1 + 296), v13)), *(float32x2_t *)(a1 + 288)), a7);
  float32_t v14 = a2->f32[0] + (float)(*(float *)(a1 + 280) * a7);
  float32_t v15 = a2->f32[1] + (float)(*(float *)(a1 + 284) * a7);
  a2->f32[0] = v14;
  a2->f32[1] = v15;
  *a3 = vmla_n_f32(*a3, vmul_n_f32(vadd_f32(*(float32x2_t *)(a1 + 280), *(float32x2_t *)(a1 + 280)), a7), *(float *)(a1 + 300));
  float v16 = sqrtf((float)(v15 * v15) + (float)(v14 * v14));
  if (*a4 > v16) {
    float v16 = *a4;
  }
  *a4 = v16;
  float v17 = *a5;
  float v18 = sqrtf((float)(a3->f32[1] * a3->f32[1]) + (float)(a3->f32[0] * a3->f32[0]));
  if (*a5 <= v18) {
    float v17 = v18;
  }
  *a5 = v17;
  float v19 = *a6;
  float v20 = fabsf(a2[1].f32[1]);
  float v21 = fabsf(a2[1].f32[0]);
  if (v20 <= v21)
  {
    if (v19 <= v21) {
      float v19 = v21;
    }
  }
  else if (v19 <= v20)
  {
    float v19 = v20;
  }
  *a6 = v19;
}

float MTRestZoneIntegrator::polarTranslationBalance(MTRestZoneIntegrator *this)
{
  float32x2_t v1 = vsqrt_f32(vadd_f32(*(float32x2_t *)((char *)this + 228), *(float32x2_t *)((char *)this + 228)));
  if (v1.f32[0] <= v1.f32[1]) {
    v1.f32[0] = v1.f32[1];
  }
  return v1.f32[0] - sqrtf(*((float *)this + 56) + *((float *)this + 56));
}

float MTRestZoneIntegrator::adaptivePolarBalance(MTRestZoneIntegrator *this)
{
  float v1 = -(float)(*((float *)this + 32) * sqrtf(*((float *)this + 60)));
  if (*((unsigned char *)this + 244) || *((unsigned __int8 *)this + 101) >= 4u)
  {
    float32x2_t v2 = vsqrt_f32(vadd_f32(*(float32x2_t *)((char *)this + 228), *(float32x2_t *)((char *)this + 228)));
    if (v2.f32[0] <= v2.f32[1]) {
      v2.f32[0] = v2.f32[1];
    }
    float v3 = v2.f32[0] - sqrtf(*((float *)this + 56) + *((float *)this + 56));
    if (v3 <= 0.0) {
      float v3 = -0.0;
    }
    return (float)(v1 + v3) + (float)(*((float *)this + 35) * 2.0);
  }
  else
  {
    float32x2_t v5 = vsqrt_f32(vadd_f32(*(float32x2_t *)((char *)this + 228), *(float32x2_t *)((char *)this + 228)));
    if (v5.f32[0] <= v5.f32[1]) {
      v5.f32[0] = v5.f32[1];
    }
    return (float)((float)((float)(v1 + (float)(v5.f32[0] - sqrtf(*((float *)this + 56) + *((float *)this + 56))))
                         + (float)(*((float *)this + 29) * *((float *)this + 59)))
                 - (float)(*((float *)this + 30) * sqrtf(*((float *)this + 54))))
         - (float)(*((float *)this + 31) * sqrtf(*((float *)this + 55)));
  }
}

BOOL MTRestZoneIntegrator::isLockedOnTranslate(MTRestZoneIntegrator *this)
{
  float32x2_t v2 = vsqrt_f32(vadd_f32(*(float32x2_t *)((char *)this + 228), *(float32x2_t *)((char *)this + 228)));
  if (v2.f32[0] <= v2.f32[1]) {
    v2.f32[0] = v2.f32[1];
  }
  float v3 = *((float *)this + 39);
  return (float)(v2.f32[0] - sqrtf(*((float *)this + 56) + *((float *)this + 56))) < v3
      && MTRestZoneIntegrator::adaptivePolarBalance(this) < v3
      || MTRestZoneIntegrator::adaptivePolarBalance(this) < (float)(v3 + v3);
}

BOOL MTRestZoneIntegrator::isLockedOnPolarSymmetric(MTRestZoneIntegrator *this)
{
  float32x2_t v2 = vsqrt_f32(vadd_f32(*(float32x2_t *)((char *)this + 228), *(float32x2_t *)((char *)this + 228)));
  if (v2.f32[0] <= v2.f32[1]) {
    v2.f32[0] = v2.f32[1];
  }
  float v3 = *((float *)this + 34);
  return (float)(v2.f32[0] - sqrtf(*((float *)this + 56) + *((float *)this + 56))) > v3
      && MTRestZoneIntegrator::adaptivePolarBalance(this) > v3
      || MTRestZoneIntegrator::adaptivePolarBalance(this) > (float)(v3 + v3);
}

BOOL MTRestZoneIntegrator::shouldDoBiPolarIntegration(MTRestZoneIntegrator *this, char a2)
{
  float v2 = 0.0;
  if ((a2 & 1) == 0) {
    float v2 = *((float *)this + 35);
  }
  return MTRestZoneIntegrator::adaptivePolarBalance(this) > v2;
}

float MTRestZoneIntegrator::translationDominance(MTRestZoneIntegrator *this, char a2)
{
  float v3 = 0.0;
  float v4 = 0.0;
  if ((a2 & 1) == 0) {
    float v4 = *((float *)this + 35);
  }
  float v5 = MTRestZoneIntegrator::adaptivePolarBalance(this);
  if (v5 <= v4)
  {
    float v6 = *((float *)this + 38);
    float v3 = 1.0;
    if (v5 >= v6)
    {
      float v3 = *((float *)this + 36);
      float v7 = *((float *)this + 37);
      if (v5 <= v7) {
        return (1.0 - v3) * (float)(v7 - v5) / (float)(v7 - v6) + v3;
      }
    }
  }
  return v3;
}

void MTRestZoneIntegrator::weighDominantMotions(float32x2_t *this, double a2, double a3)
{
  MTRestZoneIntegrator::convertPixelDeltasTo_mm_s((MTRestZoneIntegrator *)this, a2, a3);
  if (!MTRestZoneIntegrator::isLockedOnPolarSymmetric((MTRestZoneIntegrator *)this)
    && !MTRestZoneIntegrator::isLockedOnTranslate((MTRestZoneIntegrator *)this))
  {
    int v12 = -1;
    float32x2_t v11 = (float32x2_t)-1;
    int v10 = -1;
    __int32 v5 = this[10].i32[0];
    if (v5 == this[11].i32[0])
    {
      if (v5 == 1)
      {
        float v7 = this + 22;
        CFNumberRef v8 = (float *)&this[27] + 1;
      }
      else
      {
        float v7 = this + 20;
        CFNumberRef v8 = (float *)&this[27];
      }
      float v6 = a2;
      MTRestZoneIntegrator::accumulateMotionEnvelope((uint64_t)this, v7, &v11, v8, (float *)&v10, (float *)&v12, v6);
    }
    else
    {
      float v9 = a2;
      MTRestZoneIntegrator::decayMotionEnvelope((uint64_t)this, this + 24, this + 26, (float *)&this[28], (float *)&this[29], (float *)&this[28] + 1, v9);
      MTRestZoneIntegrator::accumulateMotionEnvelope((uint64_t)this, this + 24, this + 26, (float *)&this[28], (float *)&this[29], (float *)&this[28] + 1, v9);
      MTRestZoneIntegrator::decayMotionEnvelope((uint64_t)this, this + 20, &v11, (float *)&this[27], (float *)&v10, (float *)&v12, v9);
      MTRestZoneIntegrator::decayMotionEnvelope((uint64_t)this, this + 22, &v11, (float *)&this[27] + 1, (float *)&v10, (float *)&v12, v9);
    }
  }
}

void MTRestZoneIntegrator::convertPixelDeltasTo_mm_s(MTRestZoneIntegrator *this, double a2, double a3)
{
  double v3 = a2;
  LODWORD(a2) = *((_DWORD *)this + 66);
  LODWORD(a3) = *((_DWORD *)this + 67);
  MTSurfaceDimensions::convertPixelDeltasToMillimetersPerSecond(a2, a3, v3);
  *((_DWORD *)this + 70) = v5;
  *((_DWORD *)this + 7MTRestZoneIntegrator::clearMotion(this, 1) = v6;
  *((float *)this + 72) = MTSurfaceDimensions::convertPixelDeltaToMillimetersPerSecond(*((MTSurfaceDimensions **)this + 31), *((float *)this + 68), v3);
  *((float *)this + 73) = MTSurfaceDimensions::convertPixelDeltaToMillimetersPerSecond(*((MTSurfaceDimensions **)this + 31), *((float *)this + 69), v3);
}

void MTRestZoneIntegrator::integrateRestingZoneMotion(float32x2_t *this, const MTPathStates *a2, int a3)
{
  if (a3 <= 1 && this[12].u8[5] >= 2u) {
    MTRestZoneIntegrator::clearThumbFingerEnvelope(this);
  }
  MTFingerToPathMap::updateFingerPathMappings((uint64_t)this, a2);
  if (this[11].i32[1])
  {
    MTRestZoneIntegrator::computeSpeedSimilarity((MTRestZoneIntegrator *)this, a2);
    this[37].i32[0] = v6;
    if (a3)
    {
      uint64_t InnermostTouchingPath = MTFingerToPathMap::getInnermostTouchingPath((MTFingerToPathMap *)this, a2);
      OutermostTouchingPath = (const MTParserPath *)MTFingerToPathMap::getOutermostTouchingPath((MTFingerToPathMap *)this, a2);
      float v9 = (MTRestZoneIntegrator *)this;
      int v10 = a2;
      float32x2_t v11 = (const MTParserPath *)InnermostTouchingPath;
      unsigned __int8 v12 = 1;
    }
    else
    {
      uint64_t InnermostInRangePath = MTFingerToPathMap::getInnermostInRangePath((MTFingerToPathMap *)this, a2);
      OutermostTouchingPath = (const MTParserPath *)MTFingerToPathMap::getOutermostInRangePath((MTFingerToPathMap *)this, a2);
      float v9 = (MTRestZoneIntegrator *)this;
      int v10 = a2;
      float32x2_t v11 = (const MTParserPath *)InnermostInRangePath;
      unsigned __int8 v12 = 0;
    }
    MTRestZoneIntegrator::extractMotionDeltas(v9, v10, v11, OutermostTouchingPath, v12);
    double v14 = *((double *)a2 + 2);
    double v15 = *((double *)a2 + 1) - v14;
    MTRestZoneIntegrator::weighDominantMotions(this, v15, v14);
  }
  else
  {
    MTRestZoneIntegrator::clearMotion(this, 0);
  }
}

void MTForceFilter::MTForceFilter(MTForceFilter *this)
{
  *(void *)this = &unk_26F4DB4E0;
  *((void *)this + MTRestZoneIntegrator::clearMotion(this, 1) = 0x3F75C28F00000000;
  *((_OWORD *)this + MTRestZoneIntegrator::clearMotion(this, 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((void *)this + 6) = 0;
}

{
  *(void *)this = &unk_26F4DB4E0;
  *((void *)this + MTRestZoneIntegrator::clearMotion(this, 1) = 0x3F75C28F00000000;
  *((_OWORD *)this + MTRestZoneIntegrator::clearMotion(this, 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((void *)this + 6) = 0;
}

double MTForceFilter::clear(MTForceFilter *this)
{
  *((void *)this + MTRestZoneIntegrator::clearMotion(this, 1) = 0x3F75C28F00000000;
  double result = 0.0;
  *((_OWORD *)this + MTRestZoneIntegrator::clearMotion(this, 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((void *)this + 6) = 0;
  return result;
}

void MTForceFilter::~MTForceFilter(MTForceFilter *this)
{
}

uint64_t MTForceFilter::resetSliderFilter(uint64_t this)
{
  *(void *)(this + 48) = 0;
  return this;
}

uint64_t MTForceFilter::updateSliderFilter(uint64_t this, float a2, float a3)
{
  float v3 = 0.5;
  if (a2 >= 1.0) {
    float v3 = 0.0;
  }
  float v4 = (float)((float)(1.0 - v3) * a2) + (float)(v3 * *(float *)(this + 48));
  if (v4 >= 0.0) {
    float v5 = v4;
  }
  else {
    float v5 = 0.0;
  }
  if (v4 <= 1.0) {
    float v6 = v5;
  }
  else {
    float v6 = 1.0;
  }
  *(float *)(this + 48) = v6;
  *(float *)(this + 52) = a3;
  return this;
}

float MTForceFilter::forceVelocityFilterAlpha(MTForceFilter *this, float a2)
{
  float v2 = fabsf(a2);
  float v3 = fabsf(*((float *)this + 6));
  if (v2 <= v3) {
    float v2 = v3;
  }
  return (float)(1.0 - (float)(v2 / (float)(v2 + 1500.0))) * 0.9;
}

float MTForceFilter::sigmoidOneSided(MTForceFilter *this, float a2, float a3, float a4)
{
  float v6 = powf(fabsf(a2), a4);
  return v6 / (float)(powf(fabsf(a3), a4) + v6);
}

float MTForceFilter::surgeToActuationStrength(uint64_t a1, float *a2)
{
  float v2 = *a2;
  float v3 = powf(fabsf(*(float *)(a1 + 24)), 1.2);
  return (float)(v3 / (float)(v3 + powf(fabsf(v2), 1.2))) + 0.1;
}

float MTForceFilter::surge_g_s(MTForceFilter *this)
{
  return *((float *)this + 6);
}

void MTForceFilter::updateForceFilter(uint64_t a1, float *a2, float a3, float a4, double a5)
{
  if (a5 <= 0.04) {
    double v6 = a5;
  }
  else {
    double v6 = 0.04;
  }
  float v7 = *(float *)(a1 + 16);
  *(float *)(a1 + 16) = a3;
  *(float *)(a1 + 20) = v7;
  int v8 = *(_DWORD *)(a1 + 28);
  float v9 = (float)(a3 - v7) / v6;
  *(float *)(a1 + 28) = v9;
  *(_DWORD *)(a1 + 32) = v8;
  if (a3 == 0.0 || a5 > 0.04)
  {
    float v11 = *(float *)(a1 + 24);
    float v13 = 0.0;
  }
  else
  {
    float v10 = fabsf(v9);
    float v11 = *(float *)(a1 + 24);
    float v12 = fabsf(v11);
    if (v10 <= v12) {
      float v10 = v12;
    }
    float v13 = (float)(1.0 - (float)(v10 / (float)(v10 + 1500.0))) * 0.9;
  }
  *(float *)(a1 + 24) = (float)((float)(1.0 - v13) * v9) + (float)(v13 * v11);
  float v14 = *(float *)(a1 + 36);
  if (v14 >= a4) {
    float v15 = (float)(a4 * 0.15) + (float)(v14 * 0.85);
  }
  else {
    float v15 = (float)(a4 * 0.75) + (float)(v14 * 0.25);
  }
  *(float *)(a1 + 36) = v15;
  MTForceFilter::updateHystereticForce(a1, a2, a3);
  float v16 = *(float *)(a1 + 40);
  float v17 = *(float *)(a1 + 8);
  float v18 = v16;
  if (v16 > v17) {
    float v18 = (float)(v16 * (float)(1.0 - *(float *)(a1 + 12))) + (float)(*(float *)(a1 + 12) * v17);
  }
  *(float *)(a1 + 8) = v18;
}

float MTForceFilter::updateHystereticForce(uint64_t a1, float *a2, float a3)
{
  float v3 = a2[1];
  float v4 = *a2 * a3;
  if (v4 < v3) {
    float v4 = a2[1];
  }
  float v5 = a2[2];
  if (v4 <= v5) {
    float v5 = v4;
  }
  float v6 = *(float *)(a1 + 40);
  if ((float)(v6 + v5) >= a3)
  {
    if (v3 >= a3)
    {
      float v7 = a3 + a3;
    }
    else
    {
      float v7 = *(float *)(a1 + 40);
      if ((float)(v6 - v5) > a3) {
        float v7 = v5 + a3;
      }
    }
  }
  else
  {
    float v7 = a3 - v5;
  }
  float result = (float)(v7 * (float)(1.0 - a2[3])) + (float)(a2[3] * v6);
  *(float *)(a1 + 40) = result;
  *(float *)(a1 + 44) = v6;
  return result;
}

float MTForceFilter::geometricSigmoid(MTForceFilter *this, float a2)
{
  float v2 = expf(-a2);
  return exp2((float)((float)(1.0 / (float)(v2 + 1.0)) + (float)(1.0 / (float)(v2 + 1.0)))) * 0.5;
}

float MTForceFilter::sigmoid(MTForceFilter *this, float a2)
{
  return 1.0 / (float)(expf(-a2) + 1.0);
}

float MTForceFilter::sigmoidSquare(MTForceFilter *this, float a2, float a3)
{
  return (float)(a2 * a2) / (float)((float)(a3 * a3) + (float)(a2 * a2));
}

void MTForceThresholding::MTForceThresholding(MTForceThresholding *this)
{
  *(void *)this = &unk_26F4DB510;
  MTForceBehavior::MTForceBehavior((MTForceThresholding *)((char *)this + 176));
  *((_DWORD *)this + 80) = 0;
  *((void *)this + 55) = 0;
  *((void *)this + 56) = 0;
  *((void *)this + 54) = 0;
  MTForceThresholding::clear(this);
  MTParameterFactory::initForceThresholdQualifiers((uint64_t)this + 8);
  MTParameterFactory::initForceActuationQualifiers((uint64_t)this + 144);
  *((void *)this + 42) = 0x100000001;
  __asm { FMOV            V0.2S, #1.0 }
  *((void *)this + 46) = _D0;
}

void sub_2407409AC(_Unwind_Exception *a1)
{
  float v4 = v3;
  float v6 = *v4;
  if (*v4)
  {
    *(void *)(v1 + 440) = v6;
    operator delete(v6);
  }
  MTForceBehavior::~MTForceBehavior(v2);
  _Unwind_Resume(a1);
}

void MTForceThresholding::clear(MTForceThresholding *this)
{
  *((_DWORD *)this + 8MTRestZoneIntegrator::clearMotion(this, 1) = 0;
  *((void *)this + 4MTRestZoneIntegrator::clearMotion(this, 1) = 0;
  *((_DWORD *)this + 114) = 0;
  *((void *)this + 58) = 0;
  *((void *)this + 44) = 0;
  *((void *)this + 45) = 0;
  *((void *)this + 43) = 0;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *((void *)this + 55) = *((void *)this + 54);
  unint64_t v1 = *((unsigned int *)this + 48);
  if (v1) {
    std::vector<float>::resize((uint64_t)this + 432, v1);
  }
}

void MTForceThresholding::~MTForceThresholding(MTForceThresholding *this)
{
  *(void *)this = &unk_26F4DB510;
  __asm { FMOV            V0.2S, #1.0 }
  *((void *)this + 46) = _D0;
  float v7 = (void *)*((void *)this + 54);
  if (v7)
  {
    *((void *)this + 55) = v7;
    operator delete(v7);
  }
  int v8 = (void *)*((void *)this + 37);
  if (v8)
  {
    *((void *)this + 38) = v8;
    operator delete(v8);
  }
  float v9 = (void *)*((void *)this + 34);
  if (v9)
  {
    *((void *)this + 35) = v9;
    operator delete(v9);
  }
  float v10 = (void *)*((void *)this + 31);
  if (v10)
  {
    *((void *)this + 32) = v10;
    operator delete(v10);
  }
  float v11 = (void *)*((void *)this + 28);
  if (v11)
  {
    *((void *)this + 29) = v11;
    operator delete(v11);
  }
  float v12 = (void *)*((void *)this + 25);
  if (v12)
  {
    *((void *)this + 26) = v12;
    operator delete(v12);
  }
}

{
  uint64_t vars8;

  MTForceThresholding::~MTForceThresholding(this);

  JUMPOUT(0x2455F6CE0);
}

uint64_t MTForceThresholding::MTForceThresholding(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  *(void *)a1 = &unk_26F4DB510;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)a2;
  long long v4 = *(_OWORD *)(a2 + 16);
  long long v5 = *(_OWORD *)(a2 + 32);
  long long v6 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 56) = v6;
  *(_OWORD *)(a1 + 40) = v5;
  *(_OWORD *)(a1 + 24) = v4;
  long long v7 = *(_OWORD *)(a2 + 80);
  long long v8 = *(_OWORD *)(a2 + 96);
  long long v9 = *(_OWORD *)(a2 + 112);
  *(void *)(a1 + 136) = *(void *)(a2 + 128);
  *(_OWORD *)(a1 + 120) = v9;
  *(_OWORD *)(a1 + 104) = v8;
  *(_OWORD *)(a1 + 88) = v7;
  long long v10 = a3[1];
  *(_OWORD *)(a1 + 144) = *a3;
  *(_OWORD *)(a1 + 160) = v10;
  MTForceBehavior::MTForceBehavior((MTForceBehavior *)(a1 + 176));
  *(_DWORD *)(a1 + 320) = 0;
  *(void *)(a1 + 440) = 0;
  *(void *)(a1 + 448) = 0;
  *(void *)(a1 + 432) = 0;
  MTForceThresholding::clear((MTForceThresholding *)a1);
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)(a1 + 368) = _D0;
  return a1;
}

void sub_240740BB8(_Unwind_Exception *a1)
{
  long long v4 = v3;
  long long v6 = *v4;
  if (*v4)
  {
    *(void *)(v1 + 440) = v6;
    operator delete(v6);
  }
  MTForceBehavior::~MTForceBehavior(v2);
  _Unwind_Resume(a1);
}

uint64_t MTForceThresholding::clearPeakAndStage(uint64_t this)
{
  *(_DWORD *)(this + 332) = 0;
  *(void *)(this + 376) = 0;
  *(void *)(this + 384) = 0;
  *(void *)(this + 408) = 0;
  *(void *)(this + 416) = 0;
  return this;
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    std::vector<float>::__append((char **)a1, a2 - v2);
  }
}

void MTForceThresholding::setForceBehavior(MTForceThresholding *this, const MTForceBehavior *a2, int a3)
{
  MTForceBehavior::operator=((uint64_t)this + 176, (uint64_t)a2);
  *((_DWORD *)this + 80) = a3;

  MTForceThresholding::clear(this);
}

float MTForceThresholding::updateForceBehavior(MTForceThresholding *this, const MTForceBehavior *a2, int a3)
{
  MTForceBehavior::operator=((uint64_t)this + 176, (uint64_t)a2);
  unint64_t v5 = *((unsigned int *)this + 48);
  if (v5 > (uint64_t)(*((void *)this + 55) - *((void *)this + 54)) >> 2)
  {
    std::vector<float>::resize((uint64_t)this + 432, v5);
    LODWORD(v5) = *((_DWORD *)this + 48);
  }
  if (*((_DWORD *)this + 81) >= v5)
  {
    *((_DWORD *)this + 8MTRestZoneIntegrator::clearMotion(this, 1) = v5 - 1;
    *((_DWORD *)this + 82) = v5 - 1;
  }
  *((_DWORD *)this + 80) = a3;
  float result = *((float *)this + 95);
  *((float *)this + 96) = result;
  return result;
}

uint64_t MTForceThresholding::actuationWaveformID(MTForceThresholding *this)
{
  unsigned int v1 = *((_DWORD *)this + 81);
  int v2 = v1 - *((_DWORD *)this + 82);
  if (v2 >= 1)
  {
    float v3 = (char *)this + 272;
    return *(unsigned int *)(*(void *)v3 + 4 * v1);
  }
  if (v2 < 0)
  {
    float v3 = (char *)this + 296;
    unsigned int v1 = *((_DWORD *)this + 82);
    return *(unsigned int *)(*(void *)v3 + 4 * v1);
  }
  return 0;
}

uint64_t MTForceThresholding::activationLevelAbove(int a1)
{
  if ((a1 & 0x80000001) == 1) {
    int v1 = 2;
  }
  else {
    int v1 = 1;
  }
  return (v1 + a1);
}

uint64_t MTForceThresholding::activationLevelForHold(uint64_t result)
{
  if ((result & 0x80000001) == 1) {
    return result;
  }
  else {
    return (result + 1);
  }
}

uint64_t MTForceThresholding::activationLevelBelowHold(int a1)
{
  return a1 - ((a1 & 0x80000001) != 1);
}

uint64_t MTForceThresholding::activationLevelToStage(int a1)
{
  int v1 = a1 + 2;
  if (a1 >= -1) {
    int v1 = a1 + 1;
  }
  return (v1 >> 1);
}

uint64_t MTForceThresholding::stageToActivationLevel(int a1)
{
  return (2 * a1 - 1);
}

__n128 MTForceThresholding::setForceThresholdQualifiers(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 8) = *(_OWORD *)a2;
  long long v2 = *(_OWORD *)(a2 + 16);
  long long v3 = *(_OWORD *)(a2 + 32);
  long long v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 56) = v4;
  *(_OWORD *)(a1 + 40) = v3;
  *(_OWORD *)(a1 + 24) = v2;
  __n128 result = *(__n128 *)(a2 + 80);
  long long v6 = *(_OWORD *)(a2 + 96);
  long long v7 = *(_OWORD *)(a2 + 112);
  *(void *)(a1 + 136) = *(void *)(a2 + 128);
  *(_OWORD *)(a1 + 120) = v7;
  *(_OWORD *)(a1 + 104) = v6;
  *(__n128 *)(a1 + 88) = result;
  return result;
}

__n128 MTForceThresholding::setForceActuationQualifiers(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 144) = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 160) = v3;
  return result;
}

float MTForceThresholding::getClickThresholdMultiplier(uint64_t a1, unsigned int a2)
{
  float result = 1.0;
  if (a2 <= 2) {
    return flt_240750098[a2];
  }
  return result;
}

float MTForceThresholding::basicThresholdForLevel(uint64_t a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0)
  {
    float result = 0.0;
LABEL_7:
    uint64_t v5 = *(int *)(a1 + 336);
    goto LABEL_8;
  }
  uint64_t v3 = *(void *)(a1 + 200);
  uint64_t v2 = *(void *)(a1 + 208);
  if ((int)((unint64_t)(v2 - v3) >> 2) <= (int)a2) {
    float result = *(float *)(v2 - 4) + *(float *)(v2 - 4);
  }
  else {
    float result = *(float *)(v3 + 4 * a2);
  }
  if (a2 <= 1) {
    goto LABEL_7;
  }
  if (a2 > 3) {
    return result;
  }
  uint64_t v5 = *(int *)(a1 + 340);
LABEL_8:
  float v6 = 1.0;
  if (v5 <= 2) {
    float v6 = flt_240750098[v5];
  }
  return result * v6;
}

float MTForceThresholding::adaptiveThresholdForLevel(uint64_t a1, unsigned int a2, float *a3, uint64_t a4)
{
  if ((a2 & 0x80000000) != 0) {
    return 0.0;
  }
  float v8 = *(float *)(a1 + 140);
  float v9 = MTForceThresholding::basicThresholdForLevel(a1, a2);
  if (!*(unsigned char *)(a1 + 424))
  {
    unsigned int v10 = a2 + 2;
    float v11 = MTForceThresholding::basicThresholdForLevel(a1, a2 + 2);
    float v12 = MTForceThresholding::basicThresholdForLevel(a1, a2 - 2);
    float v13 = *(float *)(a1 + 136);
    uint64_t v14 = *(int *)(a1 + 340);
    float v15 = 1.0;
    if (v14 <= 2) {
      float v15 = flt_240750098[v14];
    }
    float v16 = (float)(v13 * v15) + *(float *)(a1 + 364);
    float v17 = v11 - v9;
    float v18 = v9 - v12;
    unsigned int v19 = a2 & 0x80000001;
    if (a2 < 2 || v19 == 1)
    {
      if (v19 == 1)
      {
        int v22 = *(_DWORD *)(a1 + 324);
        if (v22 >= (int)((a2 + 1) >> 1))
        {
          float v25 = v9;
        }
        else
        {
          uint64_t v23 = (*(void *)(a1 + 208) - *(void *)(a1 + 200)) >> 2;
          if ((int)v23 >= -1) {
            int v24 = v23 + 1;
          }
          else {
            int v24 = v23 + 2;
          }
          float v25 = v16;
          if (v22 < v24 >> 1)
          {
            float v25 = v9;
            if (a2 >= 3)
            {
              float v25 = a3[2] + *(float *)(a1 + 456);
              if (v9 > v25) {
                float v25 = v9;
              }
            }
          }
        }
        float v31 = *(float *)(a1 + 392);
        float v32 = *(float *)(a1 + 116);
        float v33 = 1.0;
        if (v31 > v32)
        {
          float v34 = *(float *)(a1 + 120);
          float v33 = 0.0;
          if (v31 < v34) {
            float v33 = (float)(v34 - v31) / (float)(v34 - v32);
          }
        }
        float v30 = (float)((float)((float)(v17 * *(float *)(a1 + 8)) + v25) * (float)(1.0 - v33)) + (float)(v33 * v25);
        goto LABEL_32;
      }
    }
    else if ((signed int)(v10 >> 1) <= *(_DWORD *)(a1 + 324))
    {
      float v20 = *(float *)(*(void *)(a1 + 432) + 4 * (v10 >> 1));
      float v21 = 1.0;
      if (v20 > 300.0)
      {
        float v21 = 0.0;
        if (v20 < v13) {
          float v21 = (float)(v13 - v20) / (float)(v13 + -300.0);
        }
      }
      float v9 = v20 * (float)((float)((float)(1.0 - v21) * 0.625) + (float)(v21 * 0.85));
    }
    float v26 = *(float *)(a1 + 396);
    float v27 = *(float *)(a1 + 124);
    float v28 = 1.0;
    if (v26 > v27)
    {
      float v29 = *(float *)(a1 + 128);
      float v28 = 0.0;
      if (v26 < v29) {
        float v28 = (float)(v29 - v26) / (float)(v29 - v27);
      }
    }
    float v30 = (float)((float)(v9 - (float)(v18 * *(float *)(a1 + 12))) * (float)(1.0 - v28)) + (float)(v28 * v9);
LABEL_32:
    if ((*(unsigned char *)(a1 + 180) & 0x80) == 0)
    {
      float v35 = v17 * *(float *)(a1 + 20);
      float v36 = v18 * *(float *)(a1 + 24);
      float v37 = *(float *)(a4 + 72);
      float v38 = *(float *)(a1 + 108);
      float v39 = *(float *)(a1 + 112);
      BOOL v40 = v37 < v39;
      float v41 = (float)(v39 - v37) / (float)(v39 - v38);
      if (!v40) {
        float v41 = 0.0;
      }
      if (v37 > v38) {
        float v42 = v41;
      }
      else {
        float v42 = 1.0;
      }
      float v30 = (float)((float)(v35 + v30) * (float)(1.0 - v42)) + (float)(v42 * (float)(v30 - v36));
    }
    if (v30 >= v16) {
      float v9 = v16;
    }
    else {
      float v9 = v30;
    }
    if (v19 == 1 && *(_DWORD *)(a1 + 324) < (signed int)((a2 + 1) >> 1))
    {
      float v43 = a3[10];
      float v44 = a3[11];
      float v45 = v43 * *(float *)(a1 + 132);
      if (v45 >= (float)(*(float *)(a1 + 356) - v44)) {
        float v45 = *(float *)(a1 + 356) - v44;
      }
      float v46 = v43 - v44;
      if (v46 < 0.0) {
        float v46 = 0.0;
      }
      float v47 = (float)(v43 + v45) - v46;
      if (v9 <= v47) {
        float v9 = v47;
      }
    }
    if (*(float *)(a1 + 400) > *(float *)(a1 + 128)
      && v19 == 1
      && *(_DWORD *)(a1 + 176) != 16
      && *(_DWORD *)(a1 + 324) < (signed int)((a2 + 1) >> 1)
      && a2 > 2)
    {
      return v8 + v8;
    }
  }
  return v9;
}

float MTForceThresholding::thresholdForNextRelease(MTForceThresholding *this, const MTForceFilter *a2, const MTParserPath *a3)
{
  int v6 = 2 * *((_DWORD *)this + 81);
  long long v7 = (char *)this + 176;
  do
  {
    int v8 = v6;
    if (v6 < 3) {
      break;
    }
    BOOL v9 = MTForceBehavior::skipReleaseStage((uint64_t)v7, (v6 - 1) >> 1);
    int v6 = v8 - 2;
  }
  while (v9);

  return MTForceThresholding::adaptiveThresholdForLevel((uint64_t)this, v8 - 2, (float *)a2, (uint64_t)a3);
}

BOOL MTForceBehavior::skipReleaseStage(uint64_t a1, int a2)
{
  int v6 = 0;
  long long v7 = 0;
  uint64_t v8 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&v6, *(const void **)(a1 + 72), *(void *)(a1 + 80), (uint64_t)(*(void *)(a1 + 80) - *(void *)(a1 + 72)) >> 2);
  uint64_t v3 = v7;
  long long v4 = v6;
  if (v6 != v7)
  {
    long long v4 = v6;
    while (*v4 != a2)
    {
      if (++v4 == v7)
      {
        long long v4 = v7;
        break;
      }
    }
  }
  if (v6)
  {
    long long v7 = v6;
    operator delete(v6);
  }
  return v4 != v3;
}

float MTForceThresholding::thresholdForNextActivation(MTForceThresholding *this, const MTForceFilter *a2, const MTParserPath *a3)
{
  int v6 = (char *)this + 176;
  int v7 = 2 * *((_DWORD *)this + 81) + 2;
  do
  {
    int v8 = v7;
    if (v7 >= (int)((*((void *)this + 26) - *((void *)this + 25)) >> 2)) {
      break;
    }
    BOOL v9 = MTForceBehavior::skipActivationStage((uint64_t)v6, v7 / 2);
    int v7 = v8 + 2;
  }
  while (v9);

  return MTForceThresholding::adaptiveThresholdForLevel((uint64_t)this, v8 - 1, (float *)a2, (uint64_t)a3);
}

BOOL MTForceBehavior::skipActivationStage(uint64_t a1, int a2)
{
  int v6 = 0;
  int v7 = 0;
  uint64_t v8 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&v6, *(const void **)(a1 + 48), *(void *)(a1 + 56), (uint64_t)(*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 2);
  uint64_t v3 = v7;
  long long v4 = v6;
  if (v6 != v7)
  {
    long long v4 = v6;
    while (*v4 != a2)
    {
      if (++v4 == v7)
      {
        long long v4 = v7;
        break;
      }
    }
  }
  if (v6)
  {
    int v7 = v6;
    operator delete(v6);
  }
  return v4 != v3;
}

float MTForceThresholding::preReleaseProgress(MTForceThresholding *this, const MTForceFilter *a2, const MTParserPath *a3)
{
  float v3 = *((float *)this + 88);
  float v4 = v3 * (float)(*((float *)this + 14) + 1.0);
  float result = 0.0;
  if (v3 < v4 && *((int *)this + 81) >= 1)
  {
    float v6 = *((float *)a2 + 10);
    float result = 1.0;
    if (v6 > v3)
    {
      float result = 0.0;
      if (v6 < v4) {
        return (float)(v4 - v6) / (float)(v4 - v3);
      }
    }
  }
  return result;
}

float MTForceThresholding::preActivationProgress(MTForceThresholding *this, const MTForceFilter *a2, const MTParserPath *a3)
{
  float v3 = *((float *)this + 89);
  float v4 = v3 * (float)(1.0 - *((float *)this + 15));
  float result = 0.0;
  if (v4 < v3)
  {
    uint64_t v6 = (*((void *)this + 26) - *((void *)this + 25)) >> 2;
    if ((int)v6 >= -1) {
      int v7 = v6 + 1;
    }
    else {
      int v7 = v6 + 2;
    }
    if (*((_DWORD *)this + 81) < v7 >> 1 && v3 < *((float *)this + 35))
    {
      float v8 = *((float *)a2 + 10);
      if (v8 > v4)
      {
        float result = 1.0;
        if (v8 < v3) {
          return (float)(v8 - v4) / (float)(v3 - v4);
        }
      }
    }
  }
  return result;
}

float MTForceThresholding::postActivationProgress(MTForceThresholding *this, const MTForceFilter *a2, const MTParserPath *a3)
{
  float v3 = *((float *)this + 16);
  uint64_t v4 = *((unsigned int *)this + 81);
  if (*((unsigned char *)this + 188))
  {
    uint64_t v5 = (*((void *)this + 26) - *((void *)this + 25)) >> 2;
    int v6 = (int)v5 >= -1 ? v5 + 1 : (int)v5 + 2;
    if ((int)v4 >= v6 >> 1) {
      float v3 = *((float *)this + 17);
    }
  }
  float v7 = *(float *)(*((void *)this + 54) + 4 * v4);
  int v8 = *((_DWORD *)this + 44);
  if (v8 == 12)
  {
    uint64_t v9 = *((int *)this + 84);
    float v10 = 1.0;
    if (v9 <= 2) {
      float v10 = flt_240750098[v9];
    }
    float v11 = *((float *)this + 34) * v10;
  }
  else
  {
    float v12 = 1.0;
    if (v8 == 11)
    {
      uint64_t v13 = *((int *)this + 84);
      if (v13 <= 2) {
        float v12 = flt_240750098[v13];
      }
      float v11 = (float)(*((float *)this + 34) * v12) * 0.5;
      float v7 = 0.0;
    }
    else
    {
      float v11 = (float)(v3 + 1.0) * v7;
    }
  }
  uint64_t v14 = (*((void *)this + 26) - *((void *)this + 25)) >> 2;
  if ((int)v14 >= -1) {
    int v15 = v14 + 1;
  }
  else {
    int v15 = v14 + 2;
  }
  if ((int)v4 < v15 >> 1 && v11 >= *((float *)this + 89)) {
    float v11 = *((float *)this + 89);
  }
  double v16 = 0.0;
  if ((int)v4 >= 1 && v7 < v11)
  {
    float v17 = *((float *)a2 + 10);
    if (v17 > v7)
    {
      if (v17 >= v11) {
        double v16 = 3.14159265;
      }
      else {
        double v16 = (float)((float)(v17 - v7) / (float)(v11 - v7)) * 3.14159265;
      }
    }
  }
  return (1.0 - cos(v16)) * 0.5;
}

float MTForceThresholding::rescaleForceAsLadderProgress(MTForceThresholding *this, const MTPathStates *a2)
{
  int v2 = *((_DWORD *)this + 80);
  uint64_t v3 = *((void *)a2 + 35);
  uint64_t v4 = (*((void *)this + 26) - *((void *)this + 25)) >> 2;
  if ((v4 & 0x80000000) != 0)
  {
    float v9 = 0.0;
    float v10 = 1.0;
    float v7 = 0.0;
LABEL_11:
    float v11 = (float)(*(float *)(v3 + 600 * v2 + 336) - v9) / (float)(v10 - v9);
    return v7 + v11;
  }
  float v6 = *(float *)(v3 + 600 * v2 + 336);
  float v7 = 0.0;
  signed int v8 = -1;
  do
  {
    float v9 = MTForceThresholding::basicThresholdForLevel((uint64_t)this, v8);
    v8 += 2;
    float v10 = MTForceThresholding::basicThresholdForLevel((uint64_t)this, v8);
    if (v6 < v9 || v6 < v10 || v8 >= (int)v4 && v6 > v10) {
      break;
    }
    float v7 = v7 + 1.0;
  }
  while (v8 < (int)v4);
  float v11 = 0.0;
  if (v10 > v9) {
    goto LABEL_11;
  }
  return v7 + v11;
}

uint64_t MTForceThresholding::classifyForceLevel(MTForceThresholding *this, const MTForceFilter *a2)
{
  unsigned int v3 = 0;
  uint64_t v4 = (*((void *)this + 26) - *((void *)this + 25)) >> 2;
  float v5 = *((float *)a2 + 10);
  int v6 = v4 & ~((int)v4 >> 31);
  uint64_t v7 = (v6 - 1);
  while (v6 != v3)
  {
    float v8 = MTForceThresholding::basicThresholdForLevel((uint64_t)this, v3++);
    if (v5 <= v8) {
      return v3 - 2;
    }
  }
  return v7;
}

uint64_t MTForceThresholding::classifyForceLevelAdaptively(MTForceThresholding *this, const MTForceFilter *a2, const MTParserPath *a3)
{
  unsigned int v6 = 0;
  uint64_t v7 = (*((void *)this + 26) - *((void *)this + 25)) >> 2;
  float v8 = *((float *)a2 + 10);
  int v9 = v7 & ~((int)v7 >> 31);
  uint64_t v10 = (v9 - 1);
  while (v9 != v6)
  {
    float v11 = MTForceThresholding::adaptiveThresholdForLevel((uint64_t)this, v6++, (float *)a2, (uint64_t)a3);
    if (v8 <= v11) {
      return v6 - 2;
    }
  }
  return v10;
}

uint64_t MTForceThresholding::fingersMatchBehavior(MTForceThresholding *this, const MTPathStates *a2, int a3)
{
  float v5 = (char *)this + 176;
  if (MTForceBehavior::forceSourceFingerCount((uint64_t)this + 176) == 2) {
    return *((_DWORD *)a2 + 92) == 2;
  }
  if (MTForceBehavior::forceSourceFingerCount((uint64_t)v5) == 3) {
    return *((_DWORD *)a2 + 92) == 3;
  }
  float v8 = (MTParserPath *)(*((void *)a2 + 35) + 600 * a3);

  return MTParserPath::isValidClickSource(v8);
}

void MTForceThresholding::updateAccidentalClickPreventionOffsets(uint64_t a1, unsigned int a2, uint64_t a3, MTParserPath *this, uint64_t a5, double a6, float a7, float a8)
{
  uint64_t v14 = *(int *)(a1 + 340);
  float v15 = 1.0;
  if (v14 <= 2) {
    float v15 = flt_240750098[v14];
  }
  if (v14) {
    double v16 = dbl_240750070[v14 == 2];
  }
  else {
    double v16 = 0.9992;
  }
  float v17 = *(float *)(a1 + 88) + (v15 + -1.0) * 0.01;
  BOOL isThumbContact = MTParserPath::isThumbContact(this);
  float v19 = v17 + 0.01;
  if (!isThumbContact) {
    float v19 = v17;
  }
  double v20 = pow(v19, (*(double *)(a5 + 8) - *(double *)(a5 + 16)) / 0.00800000038);
  float v21 = *(float *)(a1 + 92);
  if (*(float *)(a1 + 400) > *(float *)(a1 + 128))
  {
    float v22 = *(float *)(a3 + 8);
    float v23 = *(float *)(a1 + 100);
    float v24 = 0.0;
    if (v22 > v23)
    {
      float v25 = *(float *)(a1 + 104);
      BOOL v26 = v22 < v25;
      float v24 = (float)(v22 - v23) / (float)(v25 - v23);
      if (!v26) {
        float v24 = 1.0;
      }
    }
    float v21 = (float)(v21 * (float)(1.0 - v24)) + (float)(v24 * *(float *)(a1 + 96));
  }
  float v27 = *(float *)(a1 + 80);
  float v28 = *(float *)(a1 + 84);
  float v29 = a7 - (float)(*(float *)(a1 + 72) * v15);
  float v30 = a8 - (float)(*(float *)(a1 + 76) * v15);
  float v31 = fmaxf(v29, 0.0);
  if (v31 >= v27) {
    float v32 = *(float *)(a1 + 80);
  }
  else {
    float v32 = v31;
  }
  *(float *)(a1 + 364) = v32;
  if (v29 <= v30) {
    float v29 = v30;
  }
  float v33 = fmaxf(v29, 0.0);
  if (v33 >= v27) {
    float v34 = v27;
  }
  else {
    float v34 = v33;
  }
  *(float *)(a1 + 360) = v34;
  float v35 = MTForceThresholding::basicThresholdForLevel(a1, 3u);
  if (a2 != 0 && a2 < 0xFFFFFFFE)
  {
    double v36 = *(double *)(a1 + 464) * (*(double *)(a1 + 464) * *(double *)(a1 + 464));
    *(double *)(a1 + 464) = v36;
    if (v36 <= 0.01)
    {
      float v38 = v20;
      float v37 = (float)((float)(1.0 - v38) * (float)((float)(v15 * v21) + v32)) + (float)(v38 * *(float *)(a1 + 456));
      goto LABEL_26;
    }
  }
  else
  {
    *(double *)(a1 + 464) = v16;
  }
  float v37 = v35 + (float)(v32 + (float)((float)(v15 * v28) + v34));
LABEL_26:
  *(float *)(a1 + 456) = v37;
}

void MTForceThresholding::updateAdaptiveThresholdingParameters(uint64_t a1, int a2, MTPathStates *this, double a4, uint64_t a5)
{
  MTPathStates::getMaxDisplacement_mm((uint64_t)this);
  *(float *)(a1 + 400) = v9;
  float v10 = *(float *)(a5 + 352);
  *(float *)(a1 + 404) = v10;
  int v11 = *(_DWORD *)(a1 + 324);
  if (*(_DWORD *)(a1 + 332) > v11 && v11 >= 1)
  {
    float v13 = *((double *)this + 1) - a4;
    float v14 = 0.0;
    if (v13 > 0.25)
    {
      float v14 = 1.0;
      if (v13 < 0.5) {
        float v14 = (float)(v13 + -0.25) * 4.0;
      }
    }
    float v10 = (float)(v9 * (float)(1.0 - v14)) + (float)(v14 * v10);
  }
  *(float *)(a1 + 396) = v10;
  *(float *)(a1 + 392) = MTPathStates::sumOfLowpassPeakFingerSpeeds(this);
}

uint64_t MTForceThresholding::analyzeForceAndStage(MTForceThresholding *this, const MTPathStates *a2, int a3, const MTForceBehavior *a4, double a5, double a6, int a7, float a8, float a9)
{
  double v9 = a5;
  int v13 = *((_DWORD *)this + 81);
  int v14 = 2 * v13;
  unsigned int v15 = 2 * v13 - 1;
  int v16 = *((_DWORD *)this + 80);
  if (v13)
  {
    uint64_t v17 = *((void *)a2 + 35);
    LODWORD(a5) = *(_DWORD *)(v17 + 600 * a3 + 336);
    if (*(float *)&a5 <= *(float *)(v17 + 600 * v16 + 336))
    {
      int v38 = *((_DWORD *)this + 80);
    }
    else
    {
      int v16 = a3;
      int v38 = a3;
    }
  }
  else
  {
    int v38 = *((_DWORD *)this + 80);
    uint64_t v17 = *((void *)a2 + 35);
  }
  int v36 = v16;
  float v18 = (float *)(v17 + 600 * v16);
  MTForceThresholding::updateAccidentalClickPreventionOffsets((uint64_t)this, v14 - 1, (uint64_t)(v18 + 74), (MTParserPath *)v18, (uint64_t)a2, a5, a8, a9);
  MTForceThresholding::updateAdaptiveThresholdingParameters((uint64_t)this, v19, a2, v9, (uint64_t)v18);
  int v20 = MTForceThresholding::classifyForceLevelAdaptively(this, (const MTForceFilter *)(v18 + 74), (const MTParserPath *)v18);
  int v21 = v20;
  float v22 = v18[84];
  int v23 = *((_DWORD *)this + 44);
  *((float *)this + 95) = v22;
  if (*(_DWORD *)a4 == 11 && v23 == 11 && !*((_DWORD *)this + 81) && *((double *)a2 + 1) - v9 < *((float *)this + 12))
  {
    if (v20 <= 1) {
      int v24 = 1;
    }
    else {
      int v24 = v20;
    }
    if ((*(_DWORD *)(v17 + 600 * v36 + 44) - 3) >= 2) {
      int v21 = v20;
    }
    else {
      int v21 = v24;
    }
  }
  float v25 = *((float *)this + 96);
  if (vabds_f32(v22, v25) <= (float)(v25 * *((float *)this + 33)))
  {
    if (v25 != 0.0) {
      goto LABEL_40;
    }
  }
  else
  {
    *((_DWORD *)this + 96) = 0;
  }
  if (v21 >= (v14 | 1))
  {
    if (MTForceThresholding::fingersMatchBehavior(this, a2, v38) && a7)
    {
      int v31 = v21 - ((v21 & 0x80000001) != 1);
      int v32 = v31 + 2;
      if (v31 >= -1) {
        int v32 = v31 + 1;
      }
      if (!MTForceBehavior::skipActivationStage((uint64_t)this + 176, v32 >> 1)) {
        unsigned int v15 = v21 - ((v21 & 0x80000001) != 1);
      }
    }
  }
  else if (v21 <= v14 - 3)
  {
    int v26 = (v21 & 0x80000001) == 1 ? v21 : v21 + 1;
    float v27 = *((float *)this + 94);
    float v28 = *((float *)this + 97);
    if (v28 <= v27
      || (float v29 = *((float *)a2 + 90), (float)(v28 - v29) >= (float)((float)(v27 - v22) * *((float *)this + 9)))
      || v29 <= *((float *)this + 10))
    {
      if (v23 != 11 || *((int *)this + 81) < 1 || (*(_DWORD *)(v17 + 600 * v36 + 44) - 3) >= 2)
      {
        int v30 = v26 + 2;
        if (v26 >= -1) {
          int v30 = v26 + 1;
        }
        if (!MTForceBehavior::skipReleaseStage((uint64_t)this + 176, v30 >> 1)) {
          unsigned int v15 = v26;
        }
      }
    }
  }
LABEL_40:
  int v33 = v15 + 2;
  if ((int)(v15 + 1) >= 0) {
    int v33 = v15 + 1;
  }
  uint64_t v34 = (v33 >> 1);
  if ((int)v34 < *((_DWORD *)this + 81)) {
    unsigned int v15 = v15 + 1 - ((v15 & 0x80000001) != 1);
  }
  *((float *)this + 86) = MTForceThresholding::basicThresholdForLevel((uint64_t)this, v15);
  *((float *)this + 87) = MTForceThresholding::adaptiveThresholdForLevel((uint64_t)this, v15, v18 + 74, (uint64_t)v18);
  MTForceThresholding::updateStage((uint64_t)this, v34, v18 + 74, (uint64_t)v18, *((float *)a2 + 90), *((double *)a2 + 1));
  *((float *)this + 88) = MTForceThresholding::thresholdForNextRelease(this, (const MTForceFilter *)(v18 + 74), (const MTParserPath *)v18);
  *((float *)this + 89) = MTForceThresholding::thresholdForNextActivation(this, (const MTForceFilter *)(v18 + 74), (const MTParserPath *)v18);
  return v34;
}

BOOL MTForceThresholding::globalForceBlocksRelease(MTForceThresholding *this, const MTPathStates *a2, const MTForceFilter *a3)
{
  float v3 = *((float *)this + 94);
  float v4 = *((float *)this + 97);
  if (v4 <= v3) {
    return 0;
  }
  float v5 = *((float *)a2 + 90);
  return (float)(v4 - v5) < (float)(*((float *)this + 9) * (float)(v3 - *((float *)a3 + 10)))
      && v5 > *((float *)this + 10);
}

BOOL MTForceThresholding::blocksReleaseWhileTouching(MTForceThresholding *this)
{
  return *((_DWORD *)this + 44) == 11 && *((int *)this + 81) > 0;
}

void MTForceThresholding::updateStage(uint64_t a1, int a2, float *a3, uint64_t a4, float a5, double a6)
{
  int v8 = *(_DWORD *)(a1 + 324);
  *(_DWORD *)(a1 + 328) = v8;
  *(_DWORD *)(a1 + 324) = a2;
  int v9 = *(_DWORD *)(a1 + 332);
  if (v9 < a2)
  {
    *(_DWORD *)(a1 + 332) = a2;
    float v10 = a3[10];
LABEL_3:
    *(float *)(a1 + 376) = v10;
    *(float *)(a1 + 388) = a5;
    *(double *)(a1 + 416) = a6;
    goto LABEL_6;
  }
  if (v9 == a2)
  {
    float v10 = a3[10];
    if (v10 > *(float *)(a1 + 376)) {
      goto LABEL_3;
    }
  }
LABEL_6:
  if (a2 >= 1 && !v8) {
    *(double *)(a1 + 408) = a6;
  }
  if (v8 != a2)
  {
    if (*(unsigned char *)(a1 + 172))
    {
      float v11 = *(float *)(a4 + 72) + -1.0;
      float v12 = 2.0;
      if (v11 < 2.0)
      {
        float v12 = 0.0;
        if (v11 >= 0.0) {
          float v12 = *(float *)(a4 + 72) + -1.0;
        }
      }
      *(float *)(a1 + 368) = (float)(MTForceFilter::surgeToActuationStrength((uint64_t)a3, (float *)(a1 + 144))
                                   + (float)(*(float *)(a1 + 164) * v12))
                           * *(float *)(a1 + 168);
      *(float *)(a1 + 372) = (float)(*(float *)(a1 + 156) * v12) + 1.0;
      a2 = *(_DWORD *)(a1 + 324);
      int v8 = *(_DWORD *)(a1 + 328);
      if (a2 > v8)
      {
        double v13 = MTForceFilter::surge_g_s((MTForceFilter *)a3);
        double v14 = *(float *)(a1 + 144);
        float v15 = MTForceFilter::surgeToActuationStrength((uint64_t)a3, (float *)(a1 + 144));
        printf("Surge=%.2f/%.2f, SurgeAmplitude=%.2f + excess area=%.2f -> stageStrength=%.2f, stageDilation=%.2f\n", v13, v14, v15, v12, *(float *)(a1 + 368), *(float *)(a1 + 372));
        a2 = *(_DWORD *)(a1 + 324);
        int v8 = *(_DWORD *)(a1 + 328);
      }
    }
    else
    {
      __asm { FMOV            V0.2S, #1.0 }
      *(void *)(a1 + 368) = _D0;
    }
    *(_DWORD *)(a1 + 384) = 0;
    if (a2 <= v8)
    {
      if (a2 < v8)
      {
        int v23 = (void *)(*(void *)(a1 + 432) + 4 * a2 + 4);
        size_t v24 = 4 * (v8 + ~a2) + 4;
        bzero(v23, v24);
      }
    }
    else
    {
      uint64_t v21 = a2 - (uint64_t)v8;
      float v22 = (_DWORD *)(*(void *)(a1 + 432) + 4 * v8 + 4);
      do
      {
        *v22++ = *((_DWORD *)a3 + 10);
        --v21;
      }
      while (v21);
    }
  }
}

void *std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unsigned int v6 = result;
    float result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      float result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_240742128(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<float>::__append(char **a1, unint64_t a2)
{
  unsigned int v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  float v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    size_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 2);
    if (v10 >> 62) {
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = v5 - v8;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      double v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v13);
      size_t v8 = *a1;
      uint64_t v7 = a1[1];
    }
    else
    {
      double v14 = 0;
    }
    float v15 = &v14[4 * v11];
    int v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    uint64_t v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      int v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - MTRestZoneIntegrator::clearMotion(this, 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void MTPowerLogger::MTPowerLogger(MTPowerLogger *this, const char *a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  *(void *)this = &unk_26F4DB540;
  atomic_store(1u, (unsigned int *)this + 2);
  uint64_t v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 136446210;
    unint64_t v13 = a2;
    _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_DEFAULT, "MTPowerLogger %{public}s starting!", (uint8_t *)&v12, 0xCu);
  }
  float v5 = dlopen((const char *)[@"/System/Library/PrivateFrameworks/PowerLog.framework/PowerLog" UTF8String], 1);
  *((void *)this + 2) = v5;
  if (v5)
  {
    unsigned int v6 = dlsym(v5, "PLLogRegisteredEvent");
    *((void *)this + 3) = v6;
    if (!v6)
    {
      uint64_t v7 = MTLoggingPlugin();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v12) = 0;
        size_t v8 = "MTPowerLogger could not find PLLogRegisteredEvent function";
LABEL_9:
        _os_log_impl(&dword_2406FB000, v7, OS_LOG_TYPE_ERROR, v8, (uint8_t *)&v12, 2u);
      }
    }
  }
  else
  {
    uint64_t v7 = MTLoggingPlugin();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v12) = 0;
      size_t v8 = "MTPowerLogger could not load PowerLog.framework";
      goto LABEL_9;
    }
  }
  CFStringRef v9 = CFStringCreateWithCString(0, a2, 0x8000100u);
  *((void *)this + 4) = v9;
  if (!v9)
  {
    unint64_t v10 = MTLoggingPlugin();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v12) = 0;
      _os_log_impl(&dword_2406FB000, v10, OS_LOG_TYPE_ERROR, "MTPowerLogger could not create a logger name", (uint8_t *)&v12, 2u);
    }
  }
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *((CFAbsoluteTime *)this + 6) = Current;
  *((CFAbsoluteTime *)this + 7) = Current;
  *((_DWORD *)this + 10) = 1;
  *((unsigned char *)this + 112) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
}

void MTPowerLogger::~MTPowerLogger(MTPowerLogger *this)
{
  *(void *)this = &unk_26F4DB540;
  int v2 = (void *)*((void *)this + 2);
  if (v2) {
    dlclose(v2);
  }
  float v3 = (const void *)*((void *)this + 4);
  if (v3) {
    CFRelease(v3);
  }
}

{
  uint64_t vars8;

  MTPowerLogger::~MTPowerLogger(this);

  JUMPOUT(0x2455F6CE0);
}

uint64_t MTPowerLogger::retain(uint64_t this)
{
  if (!atomic_load((unsigned int *)(this + 8))) {
    MTPowerLogger::retain();
  }
  atomic_fetch_add((atomic_uint *volatile)(this + 8), 1u);
  return this;
}

unsigned int *MTPowerLogger::release(unsigned int *this)
{
  if (!atomic_load(this + 2)) {
    MTPowerLogger::release();
  }
  if (atomic_fetch_add((atomic_uint *volatile)this + 2, 0xFFFFFFFF) == 1)
  {
    int v2 = *(uint64_t (**)(void))(*(void *)this + 8);
    return (unsigned int *)v2();
  }
  return this;
}

void MTPowerLogger::scheduleOnDispatchQueue(MTPowerLogger *this, NSObject *a2)
{
  uint64_t v4 = MTLoggingPlugin();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_DEFAULT, "MTPowerLogger scheduling on dispatch queue", buf, 2u);
  }
  dispatch_source_t v5 = dispatch_source_create(MEMORY[0x263EF8400], 0, 0, a2);
  *((void *)this + 12) = v5;
  if (v5)
  {
    if (!atomic_load((unsigned int *)this + 2)) {
      MTPowerLogger::retain();
    }
    atomic_fetch_add((atomic_uint *volatile)this + 2, 1u);
    dispatch_time_t v7 = dispatch_time(0, 1800000000000);
    dispatch_source_set_timer(*((dispatch_source_t *)this + 12), v7, 0x1A3185C5000uLL, 0x3B9ACA00uLL);
    size_t v8 = *((void *)this + 12);
    handler[0] = MEMORY[0x263EF8330];
    handler[1] = 3221225472;
    handler[2] = ___ZN13MTPowerLogger23scheduleOnDispatchQueueEP16dispatch_queue_s_block_invoke;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    handler[4] = this;
    dispatch_source_set_event_handler(v8, handler);
    CFStringRef v9 = *((void *)this + 12);
    v14[0] = MEMORY[0x263EF8330];
    v14[1] = 3221225472;
    void v14[2] = ___ZN13MTPowerLogger23scheduleOnDispatchQueueEP16dispatch_queue_s_block_invoke_2;
    v14[3] = &__block_descriptor_40_e5_v8__0l;
    v14[4] = this;
    dispatch_source_set_cancel_handler(v9, v14);
    dispatch_resume(*((dispatch_object_t *)this + 12));
  }
  dispatch_source_t v10 = dispatch_source_create(MEMORY[0x263EF8400], 0, 0, a2);
  *((void *)this + 13) = v10;
  if (v10)
  {
    if (!atomic_load((unsigned int *)this + 2)) {
      MTPowerLogger::retain();
    }
    atomic_fetch_add((atomic_uint *volatile)this + 2, 1u);
    int v12 = *((void *)this + 13);
    v13[0] = MEMORY[0x263EF8330];
    v13[1] = 3221225472;
    v13[2] = ___ZN13MTPowerLogger23scheduleOnDispatchQueueEP16dispatch_queue_s_block_invoke_3;
    v13[3] = &__block_descriptor_40_e5_v8__0l;
    void v13[4] = this;
    dispatch_source_set_cancel_handler(v12, v13);
  }
}

uint64_t ___ZN13MTPowerLogger23scheduleOnDispatchQueueEP16dispatch_queue_s_block_invoke(uint64_t a1)
{
  return MTPowerLogger::logPower(*(MTPowerLogger **)(a1 + 32));
}

uint64_t MTPowerLogger::logPower(MTPowerLogger *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  double v2 = *((double *)this + 6);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *((CFAbsoluteTime *)this + 6) = Current;
  CFAbsoluteTime v4 = Current - v2;
  MTPowerLogger::logState(this);
  dispatch_source_t v5 = (void *)[MEMORY[0x263EFF9A0] dictionaryWithCapacity:5];
  objc_msgSend(v5, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithDouble:", v4), @"SampleTime");
  for (uint64_t i = 0; i != 4; ++i)
    uint64_t result = objc_msgSend(v5, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithDouble:", *(double *)((char *)this + i * 8 + 64)), kPowerLogStateFields[i]);
  if (*((void *)this + 3) && *((void *)this + 4))
  {
    size_t v8 = MTLoggingPlugin();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 138543362;
      dispatch_source_t v10 = v5;
      _os_log_impl(&dword_2406FB000, v8, OS_LOG_TYPE_DEFAULT, "MTPowerLogger sending event to PowerLog: %{public}@", (uint8_t *)&v9, 0xCu);
    }
    uint64_t result = (*((uint64_t (**)(uint64_t, void, void *, void))this + 3))(53, *((void *)this + 4), v5, 0);
  }
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  return result;
}

unsigned int *___ZN13MTPowerLogger23scheduleOnDispatchQueueEP16dispatch_queue_s_block_invoke_2(uint64_t a1)
{
  return MTPowerLogger::release(*(unsigned int **)(a1 + 32));
}

unsigned int *___ZN13MTPowerLogger23scheduleOnDispatchQueueEP16dispatch_queue_s_block_invoke_3(uint64_t a1)
{
  return MTPowerLogger::release(*(unsigned int **)(a1 + 32));
}

void MTPowerLogger::unscheduleFromDispatchQueue(dispatch_object_t *this, dispatch_queue_s *a2)
{
  float v3 = MTLoggingPlugin();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v6 = 0;
    _os_log_impl(&dword_2406FB000, v3, OS_LOG_TYPE_DEFAULT, "MTPowerLogger unscheduling from dispatch queue", v6, 2u);
  }
  MTPowerLogger::logPower((MTPowerLogger *)this);
  CFAbsoluteTime v4 = this[13];
  if (v4)
  {
    if (!*((unsigned char *)this + 112))
    {
      dispatch_source_set_event_handler(v4, &__block_literal_global_1);
      dispatch_resume(this[13]);
      CFAbsoluteTime v4 = this[13];
    }
    dispatch_source_cancel(v4);
    dispatch_release(this[13]);
    this[13] = 0;
    *((unsigned char *)this + 112) = 0;
  }
  dispatch_source_t v5 = this[12];
  if (v5)
  {
    dispatch_source_cancel(v5);
    dispatch_release(this[12]);
    this[12] = 0;
  }
}

void MTPowerLogger::transitionTo(MTPowerLogger *this, int a2)
{
  if (*((unsigned char *)this + 112))
  {
    CFAbsoluteTime v4 = *((void *)this + 13);
    if (v4) {
      dispatch_suspend(v4);
    }
    *((unsigned char *)this + 112) = 0;
  }
  if (*((_DWORD *)this + 10) != a2)
  {
    MTPowerLogger::logState(this);
    *((_DWORD *)this + 10) = a2;
  }
}

void MTPowerLogger::logState(MTPowerLogger *this)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  double v2 = *((double *)this + 7);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *((CFAbsoluteTime *)this + 7) = Current;
  double v4 = Current - v2;
  if (v4 > 0.0)
  {
    dispatch_source_t v5 = MTLoggingPlugin();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v6 = kPowerLogStateFields[*((unsigned int *)this + 10)];
      int v8 = 138543618;
      int v9 = v6;
      __int16 v10 = 2048;
      double v11 = v4;
      _os_log_impl(&dword_2406FB000, v5, OS_LOG_TYPE_DEBUG, "MTPowerLogger logging state %{public}@ (%gs)", (uint8_t *)&v8, 0x16u);
    }
    dispatch_time_t v7 = (double *)((char *)this + 8 * *((unsigned int *)this + 10));
    v7[8] = v4 + v7[8];
  }
}

void MTPowerLogger::transitionToDelayed(uint64_t a1, int a2, uint64_t a3)
{
  double v4 = *(NSObject **)(a1 + 104);
  if (v4)
  {
    if (*(unsigned char *)(a1 + 112))
    {
      dispatch_suspend(v4);
      *(unsigned char *)(a1 + 112) = 0;
      double v4 = *(NSObject **)(a1 + 104);
    }
    v8[0] = MEMORY[0x263EF8330];
    v8[1] = 3221225472;
    void v8[2] = ___ZN13MTPowerLogger19transitionToDelayedE18MTPowerLoggerStatex_block_invoke;
    void v8[3] = &__block_descriptor_44_e5_v8__0l;
    v8[4] = a1;
    int v9 = a2;
    dispatch_source_set_event_handler(v4, v8);
    dispatch_time_t v7 = dispatch_time(0, a3);
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 104), v7, a3, 0);
    dispatch_resume(*(dispatch_object_t *)(a1 + 104));
    *(unsigned char *)(a1 + 112) = 1;
  }
}

void ___ZN13MTPowerLogger19transitionToDelayedE18MTPowerLoggerStatex_block_invoke(uint64_t a1)
{
}

uint64_t MTPathStatesBasic::MTPathStatesBasic(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, char a5, int a6)
{
  unsigned int v11 = a4;
  v12[0] = a3;
  *(void *)a1 = &unk_26F4DB590;
  *(_DWORD *)(a1 + 24) = a3;
  *(_DWORD *)(a1 + 28) = a4;
  *(unsigned char *)(a1 + 32) = a5;
  *(_DWORD *)(a1 + 36) = a6;
  *(void *)(a1 + 40) = a2;
  dispatch_time_t v7 = (uint64_t *)(a1 + 280);
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 328) = MTSLGLogger::createLogger((MTSLGLogger *)a1);
  std::vector<MTParserPath>::reserve(v7, 0x20uLL);
  unint64_t v8 = *(void *)(a1 + 288);
  int v9 = 32;
  do
  {
    if (v8 >= *(void *)(a1 + 296))
    {
      unint64_t v8 = std::vector<MTParserPath>::__emplace_back_slow_path<MTParserType const&,MTParserOptions const&,MTSLGLogger *&>(v7, v12, &v11, (void *)(a1 + 328));
    }
    else
    {
      MTParserPath::MTParserPath(v8, v12[0], v11, *(void *)(a1 + 328));
      v8 += 600;
      *(void *)(a1 + 288) = v8;
    }
    *(void *)(a1 + 288) = v8;
    --v9;
  }
  while (v9);
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  return a1;
}

void sub_240742D18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<MTParserPath>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<MTParserPath>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0x2FC962FC962FC963 * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x6D3A06D3A06D3BLL) {
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<MTParserPath>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    void v7[3] = v7[0] + 600 * v6;
    std::vector<MTParserPath>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<MTParserPath>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_240742DEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<MTParserPath>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void MTPathStatesBasic::~MTPathStatesBasic(MTPathStatesBasic *this)
{
  *(void *)this = &unk_26F4DB590;
  double v2 = (MTSLGLogger *)*((void *)this + 41);
  if (v2)
  {
    MTSLGLogger::~MTSLGLogger(v2);
    MEMORY[0x2455F6CE0]();
    *((void *)this + 4MTRestZoneIntegrator::clearMotion(this, 1) = 0;
  }
  float v3 = (void **)((char *)this + 280);
  std::vector<MTParserPath>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void MTPathStatesBasic::clear(MTPathStatesBasic *this)
{
  uint64_t v2 = 0;
  *((void *)this + MTRestZoneIntegrator::clearMotion(this, 1) = 0;
  *((void *)this + 2) = 0;
  uint64_t v3 = 32;
  do
  {
    MTParserPath::clear((MTParserPath *)(*((void *)this + 35) + v2));
    v2 += 600;
    --v3;
  }
  while (v3);
  *((void *)this + 38) = 0;
  *((void *)this + 39) = 0;
}

double MTPathStatesBasic::initializeParams(MTPathStatesBasic *this)
{
  MTParameterFactory::initFingerTipOffsetParams((uint64_t)this + 180, *((_DWORD *)this + 6), *((_DWORD *)this + 7), *((unsigned __int8 *)this + 32));
  MTParameterFactory::initPathFilterParams((uint64_t)this + 48, *((_DWORD *)this + 6), *((_DWORD *)this + 7), *((unsigned __int8 *)this + 32), *((void *)this + 5), *((_DWORD *)this + 9));
  int v2 = *((_DWORD *)this + 6);
  uint64_t v3 = *((unsigned int *)this + 7);
  int v4 = *((unsigned __int8 *)this + 32);

  return MTParameterFactory::initTouchZoneParams((uint64_t)this + 244, v2, v3, v4);
}

float MTPathStatesBasic::updateResolutionDependentParams(MTPathStatesBasic *this)
{
  return MTParameterFactory::updatePathFilterParamsWithNewSurfaceDimensions((uint64_t)this + 48, *((void *)this + 5));
}

uint64_t MTPathStatesBasic::checkForFingersInZones(uint64_t this)
{
  int v1 = *(unsigned __int8 *)(this + 244);
  if (*(unsigned char *)(this + 244))
  {
    int v1 = 0;
    int v2 = (_DWORD *)(*(void *)(this + 280) + 644);
    uint64_t v3 = 31;
    do
    {
      if ((*v2 - 3) <= 1) {
        v1 |= v2[59];
      }
      v2 += 150;
      --v3;
    }
    while (v3);
  }
  *(_DWORD *)(this + 324) = v1;
  return this;
}

void MTPathStatesBasic::updateFastestFingerSpeed(MTPathStatesBasic *this)
{
  int v2 = (float *)((char *)this + 304);
  *((void *)this + 38) = 0;
  *((void *)this + 39) = 0;
  float v3 = 0.0;
  uint64_t v4 = 1;
  uint64_t v5 = 1136;
  float v6 = 0.0;
  float v7 = 0.0;
  float v8 = 0.0;
  float v9 = 0.0;
  float v10 = 0.0;
  do
  {
    uint64_t v11 = *((void *)this + 35);
    if (v4 == *(_DWORD *)(v11 + v5 - 496)
      && *(float *)(v11 + v5 - 464) > 0.0
      && MTParserPath::isFingerContact((MTParserPath *)(v11 + v5 - 536))
      && (*(_DWORD *)(v11 + v5 - 492) - 3) <= 2)
    {
      float v13 = *(float *)(v11 + v5 - 4);
      float v12 = *(float *)(v11 + v5);
      float v14 = *(float *)(v11 + v5 - 8);
      float v6 = v6 + v12;
      float v3 = v3 + (float)(v12 * v12);
      float v9 = v9 + fabsf(v14);
      float v8 = v8 + fabsf(v13);
      float v7 = v7 + (float)(v14 * v14);
      float v10 = v10 + (float)(v13 * v13);
      float v15 = hypotf(*(float *)(v11 + v5 - 436), *(float *)(v11 + v5 - 432));
      if (v15 > *((float *)this + 79)) {
        *((float *)this + 79) = v15;
      }
    }
    ++v4;
    v5 += 600;
  }
  while (v4 != 32);
  if (v6 > 0.0) {
    float *v2 = v3 / v6;
  }
  if (v9 > 0.0) {
    *((float *)this + 77) = v7 / v9;
  }
  if (v8 > 0.0) {
    *((float *)this + 78) = v10 / v8;
  }
}

uint64_t MTPathStatesBasic::forceFingerUniquenessAcrossHands(uint64_t this)
{
  uint64_t v1 = 0;
  uint64_t v13 = *MEMORY[0x263EF8340];
  memset(v12, 0, sizeof(v12));
  uint64_t v2 = *(void *)(this + 280);
  do
  {
    if ((*(_DWORD *)(v2 + 600 * v1 + 44) - 1) <= 5)
    {
      uint64_t v3 = v2 + 600 * v1;
      unsigned int v6 = *(_DWORD *)(v3 + 48);
      uint64_t v5 = (unsigned int *)(v3 + 48);
      unsigned int v4 = v6;
      unsigned int v7 = v6 - 1;
      if (*((_DWORD *)v12 + (int)v6)) {
        BOOL v8 = v7 > 4;
      }
      else {
        BOOL v8 = 1;
      }
      if (!v8)
      {
        uint64_t v9 = (int)v4;
        int v10 = 1;
        while (v9 != 5)
        {
          int v11 = *((_DWORD *)v12 + v9++);
          --v10;
          if (!v11)
          {
            v4 -= v10;
            unsigned int *v5 = v4;
            break;
          }
        }
      }
      ++*((_DWORD *)v12 + v4);
    }
    ++v1;
  }
  while (v1 != 32);
  return this;
}

uint64_t MTPathStatesBasic::tasksPrePixelatedPositions(MTPathStatesBasic *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 32))();
}

void MTPathStatesBasic::expandAndFilterPackedContacts(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v21 = *MEMORY[0x263EF8340];
  *(_DWORD *)(a1 + 320) = 0;
  if (a2)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 40))(a1, a2, a3);
    if ((int)a3 >= 1)
    {
      uint64_t v6 = a3;
      uint64_t v7 = a2;
      do
      {
        unint64_t v8 = *(unsigned int *)(v7 + 16);
        if ((v8 & 0x80000000) != 0
          || (uint64_t v9 = *(void *)(a1 + 280), 0x2FC962FC962FC963 * ((*(void *)(a1 + 288) - v9) >> 3) <= v8))
        {
          int v11 = MTLoggingPlugin();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            int v20 = v8;
            _os_log_error_impl(&dword_2406FB000, v11, OS_LOG_TYPE_ERROR, "Invalid path_id %d, dropping contact", buf, 8u);
          }
        }
        else
        {
          MTParserPath::updateCurPrevContactsWith((MTParserPath *)(v9 + 600 * v8), (long long *)v7, *(void *)(a1 + 40), (float *)(a1 + 244), *(double *)(a1 + 8));
          uint64_t v10 = *(void *)(a1 + 280);
          if (*(_DWORD *)(v10 + 600 * v8 + 44) == 1
            || !*(_DWORD *)(v10 + 600 * v8 + 140))
          {
            ++*(_DWORD *)(a1 + 320);
          }
        }
        v7 += 96;
        --v6;
      }
      while (v6);
    }
    (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
    uint64_t v4 = a2;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 56))(a1, a2, a3);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 64))(a1);
  MTPathStatesBasic::updateFastestFingerSpeed((MTPathStatesBasic *)a1);
  if ((*(_DWORD *)(a1 + 24) - 1000) <= 0xBB7) {
    MTPathStatesBasic::forceFingerUniquenessAcrossHands(a1);
  }
  if ((int)a3 >= 1)
  {
    float v12 = (unsigned int *)(v4 + 16);
    uint64_t v13 = a3;
    do
    {
      unsigned int v15 = *v12;
      v12 += 24;
      unint64_t v14 = v15;
      if ((v15 & 0x80000000) != 0
        || (uint64_t v16 = *(void *)(a1 + 280), 0x2FC962FC962FC963 * ((*(void *)(a1 + 288) - v16) >> 3) <= v14))
      {
        uint64_t v17 = MTLoggingPlugin();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          int v20 = v14;
          _os_log_error_impl(&dword_2406FB000, v17, OS_LOG_TYPE_ERROR, "Invalid path_id %d, dropping contact", buf, 8u);
        }
      }
      else
      {
        MTParserPath::constructPathChangeEventMask((MTParserPath *)(v16 + 600 * v14));
      }
      --v13;
    }
    while (v13);
  }
}

void MTPathStatesBasic::clearExistingPathLiftoffsAndMasks(MTPathStatesBasic *this)
{
  uint64_t v2 = 0;
  uint64_t v3 = *((void *)this + 35);
  uint64_t v4 = 32;
  do
  {
    if (*(_DWORD *)(v3 + v2 + 44) == 7)
    {
      MTParserPath::clear((MTParserPath *)(v3 + v2));
      uint64_t v3 = *((void *)this + 35);
    }
    *(_DWORD *)(v3 + v2 + 364) = 0;
    v2 += 600;
    --v4;
  }
  while (v4);
}

uint64_t MTPathStatesBasic::calculateCentroidOfPaths(uint64_t a1, float32x2_t *a2, double a3)
{
  int v5 = 0;
  int v6 = 0;
  float32x2_t v7 = 0;
  uint64_t v8 = 1;
  uint64_t v9 = 1032;
  int v10 = *(_DWORD *)(a1 + 28) & 0x20;
  float32x2_t v11 = 0;
  do
  {
    uint64_t v12 = *(void *)(a1 + 280);
    uint64_t v13 = (float32x2_t *)(v12 + v9);
    if (v8 == *(_DWORD *)(v12 + v9 - 392) && v13[-45].f32[0] > 0.0)
    {
      float32x2_t v14 = *v13;
      uint64_t v15 = v12 + v9;
      if (MTParserPath::isFingerContact((MTParserPath *)(v12 + v9 - 432)) || v10)
      {
        ++v5;
        a3 = COERCE_DOUBLE(vadd_f32(v14, *(float32x2_t *)(v15 - 32)));
        float32x2_t v7 = vadd_f32(v7, *(float32x2_t *)&a3);
        if ((*(_DWORD *)(v15 - 388) - 3) <= 1)
        {
          ++v6;
          float32x2_t v11 = vadd_f32(v11, *(float32x2_t *)&a3);
        }
      }
    }
    ++v8;
    v9 += 600;
  }
  while (v8 != 32);
  if (v6 > 0)
  {
    if (!a2) {
      return 1;
    }
LABEL_11:
    *(float *)&a3 = (float)v6;
    *a2 = vdiv_f32(v11, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0));
    return 1;
  }
  if (v5 >= 1)
  {
    int v6 = v5;
    float32x2_t v11 = v7;
    if (!a2) {
      return 1;
    }
    goto LABEL_11;
  }
  return 0;
}

uint64_t MTPathStatesBasic::numFingerSlidWhileEngaged(MTPathStatesBasic *this)
{
  uint64_t result = 0;
  uint64_t v3 = *((void *)this + 35) + 644;
  uint64_t v4 = 31;
  do
  {
    if (*(_DWORD *)v3 == 7) {
      uint64_t v5 = 100;
    }
    else {
      uint64_t v5 = 4;
    }
    unsigned int v6 = *(_DWORD *)(v3 + v5) - 1;
    if ((*(_DWORD *)v3 - 3) <= 1 && v6 <= 4) {
      uint64_t result = result + *(unsigned __int8 *)(v3 + 324);
    }
    v3 += 600;
    --v4;
  }
  while (v4);
  return result;
}

void std::vector<MTParserPath>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void (***)(void))**a1;
  if (v2)
  {
    uint64_t v4 = (void (***)(void))v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      unsigned int v6 = v4 - 75;
      float32x2_t v7 = v4 - 75;
      do
      {
        (**v7)(v7);
        v6 -= 75;
        BOOL v8 = v7 == v2;
        v7 -= 75;
      }
      while (!v8);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *std::vector<MTParserPath>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *result;
  uint64_t v5 = result[1];
  uint64_t v6 = a2[1];
  if (v5 == *result)
  {
    uint64_t v8 = a2[1];
  }
  else
  {
    uint64_t v7 = v6 - 600;
    do
    {
      uint64_t v8 = v6 - 600;
      *(void *)(v6 - 600) = &unk_26F4D93E8;
      uint64_t result = (uint64_t *)memcpy((void *)(v6 - 592), (const void *)(v5 - 592), 0x11CuLL);
      *(void *)(v6 - 304) = &unk_26F4DB4E0;
      uint64_t v9 = (_OWORD *)(v6 - 296);
      long long v11 = *(_OWORD *)(v5 - 280);
      long long v10 = *(_OWORD *)(v5 - 264);
      *uint64_t v9 = *(_OWORD *)(v5 - 296);
      v9[1] = v11;
      void v9[2] = v10;
      long long v12 = *(_OWORD *)(v5 - 248);
      long long v13 = *(_OWORD *)(v5 - 200);
      long long v14 = *(_OWORD *)(v5 - 216);
      *(_OWORD *)(v6 - 232) = *(_OWORD *)(v5 - 232);
      *(_OWORD *)(v6 - 216) = v14;
      *(_OWORD *)(v6 - 200) = v13;
      *(_OWORD *)(v6 - 248) = v12;
      long long v15 = *(_OWORD *)(v5 - 168);
      long long v16 = *(_OWORD *)(v5 - 152);
      long long v17 = *(_OWORD *)(v5 - 136);
      *(_OWORD *)(v6 - 184) = *(_OWORD *)(v5 - 184);
      *(_OWORD *)(v6 - 136) = v17;
      *(_OWORD *)(v6 - 152) = v16;
      *(_OWORD *)(v6 - 168) = v15;
      long long v18 = *(_OWORD *)(v5 - 104);
      long long v19 = *(_OWORD *)(v5 - 88);
      long long v20 = *(_OWORD *)(v5 - 72);
      *(_OWORD *)(v6 - 120) = *(_OWORD *)(v5 - 120);
      *(_OWORD *)(v6 - 72) = v20;
      *(_OWORD *)(v6 - 88) = v19;
      *(_OWORD *)(v6 - 104) = v18;
      long long v21 = *(_OWORD *)(v5 - 40);
      long long v22 = *(_OWORD *)(v5 - 24);
      uint64_t v23 = *(void *)(v5 - 8);
      *(_OWORD *)(v6 - 56) = *(_OWORD *)(v5 - 56);
      *(void *)(v6 - 8) = v23;
      *(_OWORD *)(v6 - 24) = v22;
      *(_OWORD *)(v6 - 40) = v21;
      v7 -= 600;
      v5 -= 600;
      v6 -= 600;
    }
    while (v5 != v4);
  }
  a2[1] = v8;
  uint64_t v24 = *v3;
  uint64_t *v3 = v8;
  a2[1] = v24;
  uint64_t v25 = v3[1];
  v3[1] = a2[2];
  a2[2] = v25;
  uint64_t v26 = v3[2];
  v3[2] = a2[3];
  a2[3] = v26;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<MTParserPath>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x6D3A06D3A06D3BLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(600 * a2);
}

uint64_t std::__split_buffer<MTParserPath>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 600;
    (**(void (***)(void))(i - 600))();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::vector<MTParserPath>::__emplace_back_slow_path<MTParserType const&,MTParserOptions const&,MTSLGLogger *&>(uint64_t *a1, unsigned int *a2, unsigned int *a3, void *a4)
{
  uint64_t v5 = *a1;
  uint64_t v6 = 0x2FC962FC962FC963 * ((a1[1] - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) > 0x6D3A06D3A06D3ALL) {
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v11 = (uint64_t)(a1 + 2);
  unint64_t v12 = 0x2FC962FC962FC963 * ((a1[2] - v5) >> 3);
  if (2 * v12 > v7) {
    unint64_t v7 = 2 * v12;
  }
  if (v12 >= 0x369D0369D0369DLL) {
    unint64_t v13 = 0x6D3A06D3A06D3ALL;
  }
  else {
    unint64_t v13 = v7;
  }
  long long v21 = a1 + 2;
  if (v13) {
    long long v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTParserPath>>(v11, v13);
  }
  else {
    long long v14 = 0;
  }
  long long v17 = v14;
  long long v18 = &v14[600 * v6];
  long long v19 = v18;
  long long v20 = &v14[600 * v13];
  MTParserPath::MTParserPath(v18, *a2, *a3, *a4);
  long long v19 = v18 + 600;
  std::vector<MTParserPath>::__swap_out_circular_buffer(a1, &v17);
  uint64_t v15 = a1[1];
  std::__split_buffer<MTParserPath>::~__split_buffer((uint64_t)&v17);
  return v15;
}

void sub_240743B0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void MTFingerToPathMap::MTFingerToPathMap(MTFingerToPathMap *this, char a2)
{
  *(void *)this = &unk_26F4DB610;
  *((unsigned char *)this + 76) = a2;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_WORD *)((char *)this + 103) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 1MTRestZoneIntegrator::clearMotion(this, 1) = 0;
  *(void *)((char *)this + 94) = 0;
}

{
  *(void *)this = &unk_26F4DB610;
  *((unsigned char *)this + 76) = a2;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_WORD *)((char *)this + 103) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 1MTRestZoneIntegrator::clearMotion(this, 1) = 0;
  *(void *)((char *)this + 94) = 0;
}

double MTFingerToPathMap::clearFingerPathMappings(MTFingerToPathMap *this)
{
  double result = 0.0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_WORD *)((char *)this + 103) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 1MTRestZoneIntegrator::clearMotion(this, 1) = 0;
  *(void *)((char *)this + 94) = 0;
  return result;
}

void MTFingerToPathMap::~MTFingerToPathMap(MTFingerToPathMap *this)
{
}

uint64_t MTFingerToPathMap::getInnermostTouchingPath(MTFingerToPathMap *this, const MTPathStates *a2)
{
  uint64_t v2 = *((unsigned int *)this + 20);
  if (v2 > 0xF) {
    int v3 = 0;
  }
  else {
    int v3 = *((_DWORD *)this + v2 + 2);
  }
  return *((void *)a2 + 35) + 600 * v3;
}

uint64_t MTFingerToPathMap::getNextInnermostTouchingPath(MTFingerToPathMap *this, const MTPathStates *a2)
{
  uint64_t v2 = *((unsigned int *)this + 21);
  if (v2 > 0xF) {
    int v3 = 0;
  }
  else {
    int v3 = *((_DWORD *)this + v2 + 2);
  }
  return *((void *)a2 + 35) + 600 * v3;
}

uint64_t MTFingerToPathMap::getOutermostTouchingPath(MTFingerToPathMap *this, const MTPathStates *a2)
{
  uint64_t v2 = *((unsigned int *)this + 22);
  if (v2 > 0xF) {
    int v3 = 0;
  }
  else {
    int v3 = *((_DWORD *)this + v2 + 2);
  }
  return *((void *)a2 + 35) + 600 * v3;
}

uint64_t MTFingerToPathMap::getInnermostInRangePath(MTFingerToPathMap *this, const MTPathStates *a2)
{
  uint64_t v2 = *((unsigned int *)this + 23);
  if (v2 > 0xF) {
    int v3 = 0;
  }
  else {
    int v3 = *((_DWORD *)this + v2 + 2);
  }
  return *((void *)a2 + 35) + 600 * v3;
}

uint64_t MTFingerToPathMap::getOutermostInRangePath(MTFingerToPathMap *this, const MTPathStates *a2)
{
  uint64_t v2 = *((unsigned int *)this + 24);
  if (v2 > 0xF) {
    int v3 = 0;
  }
  else {
    int v3 = *((_DWORD *)this + v2 + 2);
  }
  return *((void *)a2 + 35) + 600 * v3;
}

uint64_t MTFingerToPathMap::getParserPathForFingerID(MTFingerToPathMap *this, unsigned int a2, const MTPathStates *a3)
{
  if (a2 > 0xF) {
    int v3 = 0;
  }
  else {
    int v3 = *((_DWORD *)this + a2 + 2);
  }
  return *((void *)a3 + 35) + 600 * v3;
}

uint64_t MTFingerToPathMap::getMutablePathForFingerID(MTFingerToPathMap *this, unsigned int a2, MTPathStates *a3)
{
  if (a2 > 0xF) {
    int v3 = 0;
  }
  else {
    int v3 = *((_DWORD *)this + a2 + 2);
  }
  return *((void *)a3 + 35) + 600 * v3;
}

uint64_t MTFingerToPathMap::clearMaxFingersTouching(uint64_t this)
{
  *(unsigned char *)(this + 102) = 0;
  return this;
}

uint64_t MTFingerToPathMap::updateMaxFingersTouching(uint64_t this)
{
  unsigned int v1 = *(unsigned __int8 *)(this + 101);
  if (v1 > *(unsigned __int8 *)(this + 102) || !*(unsigned char *)(this + 101)) {
    *(unsigned char *)(this + 102) = v1;
  }
  return this;
}

uint64_t MTFingerToPathMap::updateFingerPathMappings(uint64_t this, const MTPathStates *a2)
{
  uint64_t v3 = this;
  *(_OWORD *)(this + 56) = 0u;
  *(_OWORD *)(this + 40) = 0u;
  *(_OWORD *)(this + 24) = 0u;
  *(_OWORD *)(this + 8) = 0u;
  *(_WORD *)(this + 103) = 0;
  *(void *)(this + 80) = 0;
  *(void *)(this + 88) = 0;
  uint64_t v4 = 1;
  uint64_t v5 = 672;
  *(void *)(this + 94) = 0;
  do
  {
    uint64_t v6 = *((void *)a2 + 35);
    unint64_t v7 = (float *)(v6 + v5);
    if (v4 != *(_DWORD *)(v6 + v5 - 32) || *v7 <= 0.0) {
      goto LABEL_31;
    }
    uint64_t v8 = *(unsigned int *)(v6 + v5 - 24);
    if (v8 <= 0xF) {
      *(_DWORD *)(v3 + 4 * v8 + 8) = v4;
    }
    uint64_t v9 = (MTParserPath *)(v7 - 18);
    this = MTParserPath::isPalmContact((MTParserPath *)(v7 - 18));
    if (this)
    {
      ++*(unsigned char *)(v3 + 104);
      goto LABEL_31;
    }
    this = MTParserPath::isEdgeContact(v9);
    if (this)
    {
      ++*(unsigned char *)(v3 + 103);
      goto LABEL_31;
    }
    if (*(unsigned char *)(v3 + 76))
    {
      this = MTParserPath::isFingerContact(v9);
      if (this) {
        goto LABEL_14;
      }
      if (*(unsigned char *)(v3 + 76)) {
        goto LABEL_31;
      }
    }
    this = MTParserPath::isFingerOrRestingContact(v9);
    if (!this) {
      goto LABEL_31;
    }
LABEL_14:
    ++*(unsigned char *)(v3 + 100);
    int v10 = *(_DWORD *)(v3 + 92);
    if (!v10 || (int)v8 < v10) {
      *(_DWORD *)(v3 + 92) = v8;
    }
    int v11 = *(_DWORD *)(v3 + 96);
    if (!v11 || (int)v8 > v11) {
      *(_DWORD *)(v3 + 96) = v8;
    }
    if ((*(_DWORD *)(v6 + v5 - 28) - 3) <= 1)
    {
      ++*(unsigned char *)(v3 + 101);
      int v12 = *(_DWORD *)(v3 + 80);
      if (v12 && (int)v8 >= v12)
      {
        int v13 = *(_DWORD *)(v3 + 84);
        if (v13 && (int)v8 < v13)
        {
          *(_DWORD *)(v3 + 84) = v8;
          goto LABEL_27;
        }
      }
      else
      {
        *(_DWORD *)(v3 + 80) = v8;
        *(_DWORD *)(v3 + 84) = v12;
LABEL_27:
        *(_DWORD *)(v3 + 72) = *(_DWORD *)(v6 + v5 - 20);
      }
      int v14 = *(_DWORD *)(v3 + 88);
      if (!v14 || (int)v8 > v14)
      {
        *(_DWORD *)(v3 + 88) = v8;
        *(_DWORD *)(v3 + 72) = *(_DWORD *)(v6 + v5 - 20);
      }
    }
LABEL_31:
    ++v4;
    v5 += 600;
  }
  while (v4 != 32);
  char v15 = *(unsigned char *)(v3 + 101);
  if (*(unsigned __int8 *)(v3 + 102) <= (v15 - 1)) {
    *(unsigned char *)(v3 + 102) = v15;
  }
  return this;
}

void MTABCLogger::MTABCLogger(MTABCLogger *this)
{
  *((void *)this + 2) = 0;
  *((void *)this + MTRestZoneIntegrator::clearMotion(this, 1) = 0;
  *(void *)this = (char *)this + 8;
  operator new();
}

void sub_240743F60(_Unwind_Exception *a1)
{
  std::__tree<MTABCSessionHandler *>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void MTABCLogger::~MTABCLogger(MTABCLogger **this)
{
  uint64_t v2 = this + 1;
  uint64_t v3 = *this;
  if (*this != (MTABCLogger *)(this + 1))
  {
    do
    {
      MTABCLogger::endSession((uint64_t)this, *((id **)v3 + 4), 0);
      uint64_t v4 = (MTABCLogger *)*((void *)v3 + 1);
      if (v4)
      {
        do
        {
          uint64_t v5 = (MTABCLogger **)v4;
          uint64_t v4 = *(MTABCLogger **)v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          uint64_t v5 = (MTABCLogger **)*((void *)v3 + 2);
          BOOL v6 = *v5 == v3;
          uint64_t v3 = (MTABCLogger *)v5;
        }
        while (!v6);
      }
      uint64_t v3 = (MTABCLogger *)v5;
    }
    while (v5 != v2);
  }
  unint64_t v7 = this[3];
  if (v7)
  {

    uint64_t v8 = this[3];
    if (v8) {
      MEMORY[0x2455F6CE0](v8, 0x80C40803F642BLL);
    }
    this[3] = 0;
  }
  uint64_t v9 = this[5];
  if (v9) {
    dlclose(v9);
  }
  std::__tree<MTABCSessionHandler *>::destroy((uint64_t)this, this[1]);
}

void MTABCLogger::endSession(uint64_t a1, id *a2, int a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  int v13 = a2;
  if (a2)
  {
    BOOL v6 = MTLoggingPlugin();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      id v7 = *a2;
      *(_DWORD *)buf = 136315906;
      char v15 = "";
      __int16 v16 = 2080;
      long long v17 = "";
      __int16 v18 = 2080;
      long long v19 = "endSession";
      __int16 v20 = 2114;
      id v21 = v7;
      _os_log_impl(&dword_2406FB000, v6, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Ending ABC session %{public}@", buf, 0x2Au);
    }
    uint64_t v8 = std::__tree<MTABCSessionHandler *>::__erase_unique<MTABCSessionHandler *>(a1, (unint64_t *)&v13);
    if (*(void *)(a1 + 16))
    {
      if (!a3) {
        goto LABEL_11;
      }
    }
    else
    {
      uint64_t v8 = MTUnregisterFullFrameCallback();
      if (!a3)
      {
LABEL_11:
        MTABCLogger::_freeSession(v8, v13);
        return;
      }
    }
    uint64_t v9 = (void *)[v13[3] objectAtIndexedSubscript:0];
    int v10 = NSNumber;
    objc_msgSend((id)objc_msgSend(MEMORY[0x263EFF910], "date"), "timeIntervalSince1970");
    objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(v10, "numberWithDouble:"), @"CaptureEndTimestamp");
    int v11 = MTLoggingPlugin();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      id v12 = *v13;
      *(_DWORD *)buf = 136315906;
      char v15 = "";
      __int16 v16 = 2080;
      long long v17 = "";
      __int16 v18 = 2080;
      long long v19 = "endSession";
      __int16 v20 = 2114;
      id v21 = v12;
      _os_log_impl(&dword_2406FB000, v11, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Snapshotting ABC session %{public}@", buf, 0x2Au);
    }
    uint64_t v8 = [*(id *)(*(void *)(a1 + 24) + 8) snapshotWithSignature:v13[2] duration:v13[3] events:0 payload:0 actions:&__block_literal_global_2 reply:0.0];
    goto LABEL_11;
  }
}

uint64_t MTABCLogger::createLogger()
{
  if (MGGetBoolAnswer()) {
    operator new();
  }
  return 0;
}

void sub_2407442F0(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10A0C40E56C3652);
  _Unwind_Resume(a1);
}

objc_class *MTABCLogger::_init(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = a2;
  if (!a2) {
    return 0;
  }
  double result = (objc_class *)dlopen((const char *)[@"/System/Library/PrivateFrameworks/SymptomDiagnosticReporter.framework/SymptomDiagnosticReporter" UTF8String], 1);
  *(void *)(a1 + 40) = result;
  if (result)
  {
    double result = NSClassFromString(&cfstr_Sdrdiagnosticr.isa);
    **(void **)(a1 + 24) = result;
    if (result)
    {
      id v4 = objc_alloc_init(result);
      *(void *)(*(void *)(a1 + 24) + 8) = v4;
      return (objc_class *)(v4 != 0);
    }
  }
  return result;
}

void MTABCLogger::_freeSession(uint64_t a1, id *a2)
{
  if (a2)
  {

    JUMPOUT(0x2455F6CE0);
  }
}

uint64_t MTABCLogger::_prepopulateSessionEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  uint64_t v35 = 0;
  unsigned __int8 v34 = 0;
  unsigned int v33 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  CFMutableDictionaryRef properties = 0;
  CFTypeRef cf = 0;
  MTDeviceGetDeviceID();
  MTDeviceGetSubdeviceID();
  MTDeviceGetFamilyID();
  MTDeviceGetSensorDimensions();
  MTDeviceGetSensorSurfaceDimensions();
  Parserint Type = MTDeviceGetParserType();
  MTDeviceCopyDeviceUsagePairs();
  io_registry_entry_t Service = MTDeviceGetService();
  IORegistryEntryCreateCFProperties(Service, &properties, (CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  uint64_t v5 = (uint64_t)objc_alloc_init(MEMORY[0x263EFF9A0]);
  if (!v5) {
    goto LABEL_30;
  }
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedLongLong:", v35), @"DeviceID");
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedChar:", v34), @"SubdeviceID");
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", v33), @"FamilyID");
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", HIDWORD(v32)), @"Rows");
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", v32), @"Cols");
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", HIDWORD(v31)), @"SensorSurfaceWidth");
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", v31), @"SensorSurfaceHeight");
  objc_msgSend((id)v5, "setObject:forKeyedSubscript:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", ParserType), @"ParserType");
  [(id)v5 setObject:cf forKeyedSubscript:@"UsagePairs"];
  id v6 = objc_alloc_init(MEMORY[0x263EFF9A0]);
  if (!v6) {
    goto LABEL_35;
  }
  id v7 = v6;
  uint64_t v28 = v5;
  CFMutableDictionaryRef v8 = properties;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  uint64_t v9 = [(__CFDictionary *)properties countByEnumeratingWithState:&v36 objects:v50 count:16];
  if (!v9) {
    goto LABEL_27;
  }
  uint64_t v10 = v9;
  uint64_t v11 = *(void *)v37;
  do
  {
    uint64_t v12 = 0;
    do
    {
      if (*(void *)v37 != v11) {
        objc_enumerationMutation(v8);
      }
      uint64_t v13 = *(void *)(*((void *)&v36 + 1) + 8 * v12);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        long long v17 = MTLoggingPlugin();
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
          goto LABEL_22;
        }
        uint64_t v18 = objc_opt_class();
        *(_DWORD *)buf = 136316162;
        float v41 = "[Error] ";
        __int16 v42 = 2080;
        float v43 = "";
        __int16 v44 = 2080;
        float v45 = "_JSONify";
        __int16 v46 = 2114;
        uint64_t v47 = v13;
        __int16 v48 = 2114;
        uint64_t v49 = v18;
        long long v19 = v17;
        __int16 v20 = "[HID] [MT] %s%s%s %{public}@ key has an unexpected type (class %{public}@)";
        goto LABEL_13;
      }
      int v14 = (void *)[(__CFDictionary *)v8 objectForKeyedSubscript:v13];
      if ([MEMORY[0x263F08900] isValidJSONObject:v14])
      {
        char v15 = v7;
        __int16 v16 = v14;
LABEL_21:
        [v15 setObject:v16 forKey:v13];
        goto LABEL_22;
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        uint64_t v21 = [NSString stringWithString:v14];
LABEL_20:
        __int16 v16 = (void *)v21;
        char v15 = v7;
        goto LABEL_21;
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        uint64_t v21 = objc_msgSend(NSNumber, "numberWithLongLong:", objc_msgSend(v14, "longLongValue"));
        goto LABEL_20;
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        uint64_t v21 = [NSString stringWithFormat:@"%@%@", @"NSDAT@", objc_msgSend(v14, "base64EncodedStringWithOptions:", 0)];
        goto LABEL_20;
      }
      uint64_t v22 = MTLoggingPlugin();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        uint64_t v23 = objc_opt_class();
        *(_DWORD *)buf = 136316162;
        float v41 = "[Error] ";
        __int16 v42 = 2080;
        float v43 = "";
        __int16 v44 = 2080;
        float v45 = "_JSONify";
        __int16 v46 = 2114;
        uint64_t v47 = v13;
        __int16 v48 = 2114;
        uint64_t v49 = v23;
        long long v19 = v22;
        __int16 v20 = "[HID] [MT] %s%s%s %{public}@ is not serializable (class %{public}@)";
LABEL_13:
        _os_log_impl(&dword_2406FB000, v19, OS_LOG_TYPE_ERROR, v20, buf, 0x34u);
      }
LABEL_22:
      ++v12;
    }
    while (v10 != v12);
    uint64_t v24 = [(__CFDictionary *)v8 countByEnumeratingWithState:&v36 objects:v50 count:16];
    uint64_t v10 = v24;
  }
  while (v24);
LABEL_27:
  uint64_t v5 = (uint64_t)objc_alloc_init(MEMORY[0x263EFF980]);
  if (!v5) {
    goto LABEL_30;
  }
  id v25 = objc_alloc_init(MEMORY[0x263EFF9A0]);
  if (v25)
  {
    uint64_t v26 = v25;
    [v25 setObject:v28 forKeyedSubscript:@"DeviceInfo"];
    [v26 setObject:v7 forKeyedSubscript:@"RegistryProperties"];
    [v26 setObject:v5 forKeyedSubscript:@"Frames"];
    [*(id *)(a2 + 24) addObject:v26];
    uint64_t v5 = 1;
    goto LABEL_30;
  }
LABEL_35:
  uint64_t v5 = 0;
LABEL_30:
  if (cf) {
    CFRelease(cf);
  }
  if (properties) {
    CFRelease(properties);
  }
  return v5;
}

void MTABCLogger::_dumpSessionToFile(uint64_t a1, uint64_t a2)
{
  id v3 = objc_alloc_init(MEMORY[0x263EFF9A0]);
  [v3 setObject:*(void *)(a2 + 24) forKeyedSubscript:@"events"];
  id v4 = [(NSString *)NSTemporaryDirectory() stringByAppendingPathComponent:@"MTABCLogger.json"];
  uint64_t v11 = 0;
  uint64_t v5 = (void *)[MEMORY[0x263F08900] dataWithJSONObject:v3 options:1 error:&v11];
  if (v5)
  {
    id v6 = v5;
    id v7 = v5;
    CFMutableDictionaryRef v8 = v4;
    global_queue = dispatch_get_global_queue(0, 0);
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = ___ZN11MTABCLogger18_dumpSessionToFileEP19MTABCSessionHandler_block_invoke;
    block[3] = &unk_2650D3A00;
    block[4] = v4;
    void block[5] = v6;
    dispatch_async(global_queue, block);
  }
}

void ___ZN11MTABCLogger18_dumpSessionToFileEP19MTABCSessionHandler_block_invoke(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v2 = MTLoggingPlugin();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 136315906;
    uint64_t v5 = "";
    __int16 v6 = 2080;
    id v7 = "";
    __int16 v8 = 2080;
    uint64_t v9 = "_dumpSessionToFile_block_invoke";
    __int16 v10 = 2114;
    uint64_t v11 = v3;
    _os_log_impl(&dword_2406FB000, v2, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Writing ABC session %{public}@", (uint8_t *)&v4, 0x2Au);
  }
  [*(id *)(a1 + 40) writeToFile:*(void *)(a1 + 32) options:0 error:0];
}

void MTABCLogger::_fullFrameCallback(uint64_t a1, uint64_t a2, unsigned int a3, void *a4)
{
  v24[2] = *MEMORY[0x263EF8340];
  int v4 = a4 + 1;
  uint64_t v5 = (void *)*a4;
  if ((void *)*a4 != a4 + 1)
  {
    uint64_t v7 = a3;
    do
    {
      uint64_t v8 = v5[4];
      uint64_t v9 = (void *)[*(id *)(v8 + 24) objectAtIndexedSubscript:0];
      __int16 v10 = (void *)[v9 objectForKeyedSubscript:@"Frames"];
      uint64_t v11 = objc_msgSend((id)objc_msgSend(MEMORY[0x263EFF8F8], "dataWithBytes:length:", a2, v7), "base64EncodedStringWithOptions:", 0);
      uint64_t v12 = (void *)[v9 objectForKeyedSubscript:@"CaptureBeginTimestamp"];
      if (!v12)
      {
        uint64_t v13 = NSNumber;
        objc_msgSend((id)objc_msgSend(MEMORY[0x263EFF910], "date"), "timeIntervalSince1970");
        uint64_t v12 = objc_msgSend(v13, "numberWithDouble:");
        [v9 setObject:v12 forKeyedSubscript:@"CaptureBeginTimestamp"];
      }
      [v12 doubleValue];
      double v15 = v14;
      objc_msgSend((id)objc_msgSend(MEMORY[0x263EFF910], "date"), "timeIntervalSince1970");
      double v17 = v16 - v15;
      double v18 = *(double *)(v8 + 8);
      if (v18 == 0.0 || v17 <= v18)
      {
        v23[0] = @"bytes";
        v23[1] = @"timestamp";
        v24[0] = v11;
        v24[1] = [NSNumber numberWithDouble:v17];
        objc_msgSend(v10, "addObject:", objc_msgSend(NSDictionary, "dictionaryWithObjects:forKeys:count:", v24, v23, 2));
      }
      __int16 v20 = (void *)v5[1];
      if (v20)
      {
        do
        {
          uint64_t v21 = v20;
          __int16 v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          uint64_t v21 = (void *)v5[2];
          BOOL v22 = *v21 == (void)v5;
          uint64_t v5 = v21;
        }
        while (!v22);
      }
      uint64_t v5 = v21;
    }
    while (v21 != v4);
  }
}

void MTABCLogger::startSession(MTABCLogger *this, const char *a2, double a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v3 = MTLoggingPlugin();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 136315650;
    *(void *)&v4[1] = "";
    __int16 v5 = 2080;
    __int16 v6 = "";
    __int16 v7 = 2080;
    uint64_t v8 = "startSession";
    _os_log_impl(&dword_2406FB000, v3, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s Started new ABC session", (uint8_t *)v4, 0x20u);
  }
  operator new();
}

void ___ZN11MTABCLogger10endSessionEP19MTABCSessionHandlerb_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v3 = MTLoggingPlugin();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315906;
    __int16 v5 = "";
    __int16 v6 = 2080;
    __int16 v7 = "";
    __int16 v8 = 2080;
    uint64_t v9 = "endSession_block_invoke";
    __int16 v10 = 2114;
    uint64_t v11 = a2;
    _os_log_impl(&dword_2406FB000, v3, OS_LOG_TYPE_DEFAULT, "[HID] [MT] %s%s%s ABC response: %{public}@", (uint8_t *)&v4, 0x2Au);
  }
}

void std::__tree<MTABCSessionHandler *>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<MTABCSessionHandler *>::destroy(a1, *a2);
    std::__tree<MTABCSessionHandler *>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t *std::__tree<MTABCSessionHandler *>::__emplace_unique_key_args<MTABCSessionHandler *,MTABCSessionHandler * const&>(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  __int16 v6 = a1 + 1;
  __int16 v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        __int16 v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        __int16 v5 = *v8;
        __int16 v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      __int16 v5 = v8[1];
      if (!v5)
      {
        __int16 v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    __int16 v8 = a1 + 1;
LABEL_10:
    __int16 v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    std::__tree<std::__value_type<unsigned int,std::list<double>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::list<double>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::list<double>>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

uint64_t std::__tree<MTABCSessionHandler *>::__erase_unique<MTABCSessionHandler *>(uint64_t a1, unint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  int v4 = (uint64_t *)(a1 + 8);
  do
  {
    unint64_t v5 = v2[4];
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      unint64_t v7 = v2;
    }
    else {
      unint64_t v7 = v2 + 1;
    }
    if (v6) {
      int v4 = v2;
    }
    uint64_t v2 = (void *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t *)(a1 + 8) || v3 < v4[4]) {
    return 0;
  }
  std::__tree<MTABCSessionHandler *>::__remove_node_pointer((uint64_t **)a1, v4);
  operator delete(v4);
  return 1;
}

uint64_t *std::__tree<MTABCSessionHandler *>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      unint64_t v3 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    int v4 = a2;
    do
    {
      unint64_t v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      int v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  BOOL v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  unint64_t v3 = a2;
  if (*a2)
  {
    int v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      unint64_t v3 = a2;
      goto LABEL_7;
    }
    do
    {
      unint64_t v3 = v4;
      int v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  BOOL v6 = (uint64_t **)v3[2];
  unint64_t v7 = *v6;
  if (*v6 == v3)
  {
    *BOOL v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      unint64_t v7 = 0;
      double result = (uint64_t *)v2;
    }
    else
    {
      unint64_t v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    uint64_t *v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      double result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 == v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24) = 1;
      *(unsigned char *)(v12 + 24) = 0;
      uint64_t v13 = *(uint64_t **)(v12 + 8);
      uint64_t v14 = *v13;
      *(void *)(v12 + 8) = *v13;
      if (v14) {
        *(void *)(v14 + 16) = v12;
      }
      v13[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
      *uint64_t v13 = v12;
      *(void *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7) {
        double result = v7;
      }
      unint64_t v7 = *(uint64_t **)(*v7 + 8);
    }
    double v15 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v15 + 24))
    {
      double v16 = (uint64_t *)v7[1];
      if (!v16) {
        goto LABEL_56;
      }
LABEL_55:
      if (*((unsigned char *)v16 + 24))
      {
LABEL_56:
        *((unsigned char *)v15 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v22 = v15[1];
        *unint64_t v7 = v22;
        if (v22) {
          *(void *)(v22 + 16) = v7;
        }
        v15[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        double v16 = v7;
      }
      else
      {
        double v15 = v7;
      }
      uint64_t v23 = v15[2];
      *((unsigned char *)v15 + 24) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24) = 1;
      *((unsigned char *)v16 + 24) = 1;
      uint64_t v24 = *(uint64_t **)(v23 + 8);
      uint64_t v25 = *v24;
      *(void *)(v23 + 8) = *v24;
      if (v25) {
        *(void *)(v25 + 16) = v23;
      }
      v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      *uint64_t v24 = v23;
      goto LABEL_72;
    }
    double v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_55;
    }
    *((unsigned char *)v7 + 24) = 0;
    double v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      double v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
LABEL_49:
    unint64_t v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24) = 1;
    *(unsigned char *)(v12 + 24) = 0;
    uint64_t v18 = v7[1];
    *(void *)uint64_t v12 = v18;
    if (v18) {
      *(void *)(v18 + 16) = v12;
    }
    v7[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(void *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12) {
      double result = v7;
    }
    unint64_t v7 = *(uint64_t **)v12;
  }
  long long v19 = (void *)*v7;
  if (*v7 && !*((unsigned char *)v19 + 24)) {
    goto LABEL_68;
  }
  __int16 v20 = (uint64_t *)v7[1];
  if (!v20 || *((unsigned char *)v20 + 24))
  {
    *((unsigned char *)v7 + 24) = 0;
    double v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  if (v19 && !*((unsigned char *)v19 + 24))
  {
LABEL_68:
    __int16 v20 = v7;
  }
  else
  {
    *((unsigned char *)v20 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v26 = *v20;
    v7[1] = *v20;
    if (v26) {
      *(void *)(v26 + 16) = v7;
    }
    _DWORD v20[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
    uint64_t *v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    long long v19 = v7;
  }
  uint64_t v23 = v20[2];
  *((unsigned char *)v20 + 24) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24) = 1;
  *((unsigned char *)v19 + 24) = 1;
  uint64_t v24 = *(uint64_t **)v23;
  uint64_t v27 = *(void *)(*(void *)v23 + 8);
  *(void *)uint64_t v23 = v27;
  if (v27) {
    *(void *)(v27 + 16) = v23;
  }
  v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

uint64_t MTForceBehavior::GetNull(MTForceBehavior *this)
{
  if (MTForceBehavior::nullDispatchOnce != -1) {
    dispatch_once(&MTForceBehavior::nullDispatchOnce, &__block_literal_global_3);
  }
  return MTForceBehavior::nullForceBehavior;
}

void ___ZN15MTForceBehavior7GetNullEv_block_invoke()
{
}

void MTForceBehavior::MTForceBehavior(MTForceBehavior *this)
{
  *((_DWORD *)this + 4) = 0;
  *(void *)this = 0;
  *(void *)((char *)this + 5) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((void *)this + 17) = 0;
}

{
  *((_DWORD *)this + 4) = 0;
  *(void *)this = 0;
  *(void *)((char *)this + 5) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((void *)this + 17) = 0;
}

uint64_t MTForceBehavior::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
    *(void *)a1 = *(void *)a2;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a1 + 24), *(char **)(a2 + 24), *(void *)(a2 + 32), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a1 + 96), *(char **)(a2 + 96), *(void *)(a2 + 104), (uint64_t)(*(void *)(a2 + 104) - *(void *)(a2 + 96)) >> 2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a1 + 120), *(char **)(a2 + 120), *(void *)(a2 + 128), (uint64_t)(*(void *)(a2 + 128) - *(void *)(a2 + 120)) >> 2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a1 + 48), *(char **)(a2 + 48), *(void *)(a2 + 56), (uint64_t)(*(void *)(a2 + 56) - *(void *)(a2 + 48)) >> 2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a1 + 72), *(char **)(a2 + 72), *(void *)(a2 + 80), (uint64_t)(*(void *)(a2 + 80) - *(void *)(a2 + 72)) >> 2);
    *(unsigned char *)(a1 + 12) = *(unsigned char *)(a2 + 12);
  }
  return a1;
}

BOOL MTForceBehavior::behaviorEquals(MTForceBehavior *this, const MTForceBehavior *a2)
{
  if (*(_DWORD *)this != *(_DWORD *)a2
    || *((_DWORD *)this + 2) != *((_DWORD *)a2 + 2)
    || *((_DWORD *)this + 1) != *((_DWORD *)a2 + 1)
    || *((_DWORD *)this + 4) != *((_DWORD *)a2 + 4))
  {
    return 0;
  }
  int v4 = (float *)*((void *)this + 3);
  unint64_t v5 = *((void *)this + 4) - (void)v4;
  if ((int)(v5 >> 2) >= 1)
  {
    BOOL v6 = (float *)*((void *)a2 + 3);
    uint64_t v7 = (v5 >> 2);
    while (*v4 == *v6)
    {
      ++v4;
      ++v6;
      if (!--v7) {
        goto LABEL_9;
      }
    }
    return 0;
  }
LABEL_9:
  uint64_t v8 = *((void *)this + 12);
  uint64_t v9 = *((void *)this + 13) - v8;
  if (v9)
  {
    uint64_t v10 = 0;
    unint64_t v11 = v9 >> 2;
    unsigned int v12 = 1;
    while (*(_DWORD *)(v8 + 4 * v10) == *(_DWORD *)(*((void *)a2 + 12) + 4 * v10))
    {
      uint64_t v10 = v12;
      BOOL v13 = v11 > v12++;
      if (!v13) {
        goto LABEL_13;
      }
    }
    return 0;
  }
LABEL_13:
  uint64_t v14 = *((void *)this + 15);
  uint64_t v15 = *((void *)this + 16) - v14;
  if (v15)
  {
    uint64_t v16 = 0;
    unint64_t v17 = v15 >> 2;
    unsigned int v18 = 1;
    while (*(_DWORD *)(v14 + 4 * v16) == *(_DWORD *)(*((void *)a2 + 15) + 4 * v16))
    {
      uint64_t v16 = v18;
      BOOL v13 = v17 > v18++;
      if (!v13) {
        goto LABEL_17;
      }
    }
    return 0;
  }
LABEL_17:
  if (std::operator!=[abi:ne180100]<int,std::allocator<int>>((uint64_t)this + 48, (uint64_t)a2 + 48)
    || std::operator!=[abi:ne180100]<int,std::allocator<int>>((uint64_t)this + 72, (uint64_t)a2 + 72))
  {
    return 0;
  }
  return *((unsigned __int8 *)this + 12) == *((unsigned __int8 *)a2 + 12);
}

BOOL std::operator!=[abi:ne180100]<int,std::allocator<int>>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const void **)a1;
  size_t v4 = *(void *)(a1 + 8) - (void)v2;
  unint64_t v5 = *(const void **)a2;
  return v4 != *(void *)(a2 + 8) - (void)v5 || memcmp(v2, v5, v4) != 0;
}

uint64_t MTForceBehavior::forceSourceFingerCount(uint64_t this)
{
  uint64_t v1 = this;
  LODWORD(this) = 0;
  int v2 = *(_DWORD *)(v1 + 4);
  unsigned int v3 = 16;
  do
  {
    if ((v2 & v3) != 0) {
      this = (this + 1);
    }
    else {
      this = this;
    }
    BOOL v4 = v3 >= 2;
    v3 >>= 1;
  }
  while (v4);
  return this;
}

uint64_t MTForceBehavior::whichButtonBehavior(MTForceBehavior *this)
{
  int v1 = *(_DWORD *)this - 1;
  if (v1 > 0x10) {
    return 0;
  }
  else {
    return dword_2407500E8[v1];
  }
}

void MTForceBehavior::resizeThresholdLadder(MTForceBehavior *this, int a2)
{
}

uint64_t MTForceBehavior::resizeToNumStages(MTForceBehavior *this, unsigned int a2)
{
  uint64_t v4 = a2 - *((_DWORD *)this + 4);
  std::vector<float>::resize((uint64_t)this + 24, 2 * a2 - 2);
  std::vector<int>::resize((std::vector<int> *)this + 4, a2);
  std::vector<int>::resize((std::vector<int> *)this + 5, a2);
  *((_DWORD *)this + 4) = a2;
  return v4;
}

void std::vector<int>::resize(std::vector<int> *this, std::vector<int>::size_type __sz)
{
  std::vector<int>::size_type v2 = this->__end_ - this->__begin_;
  if (__sz <= v2)
  {
    if (__sz < v2) {
      this->__end_ = &this->__begin_[__sz];
    }
  }
  else
  {
    std::vector<int>::__append(this, __sz - v2);
  }
}

BOOL MTForceBehavior::addStage(MTForceBehavior *a1, int a2, int a3, int a4, float a5, float a6)
{
  if ((int)MTForceBehavior::resizeToNumStages(a1, a2 + 1) > 1) {
    return 0;
  }
  if (a2 >= 1)
  {
    uint64_t v13 = *((void *)a1 + 3);
    *(float *)(v13 + 4 * (2 * a2 - 1)) = a5;
    *(float *)(v13 + 4 * (2 * a2 - 2)) = a6;
  }
  BOOL result = MTForceBehavior::isThresholdLadderMonotonic((void *)a1 + 3);
  if (result)
  {
    *(_DWORD *)(*((void *)a1 + 12) + 4 * a2) = a3;
    *(_DWORD *)(*((void *)a1 + 15) + 4 * a2) = a4;
    return 1;
  }
  return result;
}

BOOL MTForceBehavior::isThresholdLadderMonotonic(void *a1)
{
  unint64_t v1 = a1[1] - *a1;
  if ((v1 & 4) != 0) {
    return 0;
  }
  uint64_t v2 = 0;
  int v3 = (v1 >> 2) - 1;
  uint64_t v4 = v3;
  uint64_t v5 = v3 & ~(v3 >> 31);
  do
  {
    uint64_t v6 = v2;
    if (v5 == v2) {
      break;
    }
    uint64_t v7 = (float *)(*a1 + 4 * v2++);
  }
  while (*v7 <= v7[1]);
  return v6 >= v4;
}

BOOL MTForceBehavior::addStage(MTForceBehavior *a1, int a2, uint64_t a3, float a4, float a5)
{
  return MTForceBehavior::addStage(a1, a2, a3, SHIDWORD(a3), a4, a5);
}

uint64_t MTForceBehavior::print(MTForceBehavior *this)
{
  int v2 = 0;
  unsigned int v3 = 16;
  do
  {
    if ((v3 & *((_DWORD *)this + 1)) != 0) {
      ++v2;
    }
    BOOL v4 = v3 > 1;
    v3 >>= 1;
  }
  while (v4);
  uint64_t result = printf("MTForceBehavior type = %d sources = 0x%x fingers = %d\n", *(_DWORD *)this, *((_DWORD *)this + 1), v2);
  uint64_t v6 = *((void *)this + 12);
  if ((unint64_t)(*((void *)this + 13) - v6) >= 5)
  {
    unsigned int v7 = 0;
    unint64_t v8 = 1;
    unsigned int v9 = 1;
    do
    {
      uint64_t v10 = *((void *)this + 3);
      if (v8 >= (unint64_t)(((*((void *)this + 4) - v10) >> 2) + 2) >> 1) {
        break;
      }
      uint64_t result = printf("  Stage %d, Entry[thresh=%f waveform=%d], Exit[ thresh=%f waveform=%d]\n", v9, *(float *)(v10 + 4 * (v7 + 1)), *(_DWORD *)(v6 + 4 * v8), *(float *)(v10 + 4 * v7), *(_DWORD *)(*((void *)this + 15) + 4 * v8));
      uint64_t v6 = *((void *)this + 12);
      v7 += 2;
      unint64_t v8 = ++v9;
    }
    while (v9 < (unint64_t)((*((void *)this + 13) - v6) >> 2));
  }
  return result;
}

char *std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unsigned int v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unsigned int v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 2)
  {
    if (v9)
    {
      *((void *)result + MTRestZoneIntegrator::clearMotion(this, 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *unsigned int v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62) {
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<float>::__vallocate[abi:ne180100](v7, v11);
    uint64_t v13 = (char *)v7[1];
    unsigned int v12 = (void **)(v7 + 1);
    unsigned int v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      unsigned int v18 = v9;
      long long v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  unsigned int v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 2;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    unsigned int v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    unsigned int v18 = v9;
    long long v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *unsigned int v12 = &v9[v17];
  return result;
}

void std::vector<int>::__append(std::vector<int> *this, std::vector<int>::size_type __n)
{
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  uint64_t v5 = value;
  std::__split_buffer<int>::pointer end = p_end_cap[-1].__value_;
  if (__n <= value - end)
  {
    if (__n)
    {
      bzero(p_end_cap[-1].__value_, 4 * __n);
      end += __n;
    }
    this->__end_ = end;
  }
  else
  {
    std::vector<int>::pointer begin = this->__begin_;
    uint64_t v9 = (char *)end - (char *)this->__begin_;
    unint64_t v10 = __n + (v9 >> 2);
    if (v10 >> 62) {
      std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = (char *)v5 - (char *)begin;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, v13);
      std::vector<int>::pointer begin = this->__begin_;
      std::__split_buffer<int>::pointer end = this->__end_;
    }
    else
    {
      uint64_t v14 = 0;
    }
    unint64_t v15 = &v14[4 * v11];
    uint64_t v16 = (int *)&v14[4 * v13];
    bzero(v15, 4 * __n);
    size_t v17 = (int *)&v15[4 * __n];
    while (end != begin)
    {
      int v18 = *--end;
      *((_DWORD *)v15 - MTRestZoneIntegrator::clearMotion(this, 1) = v18;
      v15 -= 4;
    }
    this->__begin_ = (std::vector<int>::pointer)v15;
    this->__end_ = v17;
    this->__end_cap_.__value_ = v16;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

void MTForceBehaviorConfiguration::MTForceBehaviorConfiguration(MTForceBehaviorConfiguration *this)
{
}

{
  std::vector<std::vector<MTForceBehavior>>::vector(this, 6uLL);
}

uint64_t MTForceBehaviorConfiguration::addDefaultBehavior(MTForceBehaviorConfiguration *this, const MTForceBehavior *a2)
{
  unsigned int v4 = MTForceBehavior::forceSourceFingerCount((uint64_t)a2);
  uint64_t v5 = *(void *)this + 24 * v4;
  unsigned int v7 = *(MTForceBehavior **)(v5 + 8);
  unint64_t v6 = *(void *)(v5 + 16);
  uint64_t v8 = (void *)(v5 + 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t result = std::vector<MTForceBehavior>::__push_back_slow_path<MTForceBehavior const&>((uint64_t *)(*(void *)this + 24 * v4), a2);
  }
  else
  {
    MTForceBehavior::MTForceBehavior(v7, a2);
    uint64_t result = (uint64_t)v7 + 144;
    *uint64_t v8 = (char *)v7 + 144;
  }
  *uint64_t v8 = result;
  *(_DWORD *)(result - 136) = 1;
  *((unsigned char *)this + 24) = 1;
  return result;
}

void sub_240745E78(_Unwind_Exception *a1)
{
  void *v2 = v1;
  _Unwind_Resume(a1);
}

uint64_t MTForceBehaviorConfiguration::pushBehavior(MTForceBehaviorConfiguration *this, const MTForceBehavior *a2)
{
  unsigned int v4 = MTForceBehavior::forceSourceFingerCount((uint64_t)a2);
  uint64_t v5 = *(void *)this + 24 * v4;
  unsigned int v7 = *(MTForceBehavior **)(v5 + 8);
  unint64_t v6 = *(void *)(v5 + 16);
  uint64_t v8 = (void *)(v5 + 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t result = std::vector<MTForceBehavior>::__push_back_slow_path<MTForceBehavior const&>((uint64_t *)(*(void *)this + 24 * v4), a2);
  }
  else
  {
    MTForceBehavior::MTForceBehavior(v7, a2);
    uint64_t result = (uint64_t)v7 + 144;
    *uint64_t v8 = (char *)v7 + 144;
  }
  *uint64_t v8 = result;
  *((unsigned char *)this + 24) = 1;
  return result;
}

void sub_240745F04(_Unwind_Exception *a1)
{
  void *v2 = v1;
  _Unwind_Resume(a1);
}

void MTForceBehaviorConfiguration::popBehavior(MTForceBehaviorConfiguration *this, const MTForceBehavior *a2)
{
  unsigned int v4 = MTForceBehavior::forceSourceFingerCount((uint64_t)a2);
  uint64_t v5 = *(void *)this;
  uint64_t v6 = *(void *)this + 24 * v4;
  uint64_t v8 = *(void *)(v6 + 8);
  unsigned int v7 = (void *)(v6 + 8);
  if (MTForceBehavior::behaviorEquals(a2, (const MTForceBehavior *)(v8 - 144)))
  {
    uint64_t v9 = v5 + 24 * v4 + 16;
    unint64_t v10 = (void *)(*v7 - 144);
    std::allocator<MTForceBehavior>::destroy[abi:ne180100](v9, v10);
    *unsigned int v7 = v10;
  }
  *((unsigned char *)this + 24) = 1;
}

void MTForceBehaviorConfiguration::clearBehaviors(MTForceBehaviorConfiguration *this)
{
  for (uint64_t i = 0; i != 6; ++i)
  {
    unsigned int v3 = (uint64_t *)(*(void *)this + 24 * i);
    uint64_t v4 = *v3;
    uint64_t v7 = v3[1];
    uint64_t v6 = v3 + 1;
    uint64_t v5 = v7;
    if (v4 != v7)
    {
      uint64_t v8 = *(void *)this + 24 * i + 16;
      do
      {
        std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,MTForceBehavior *,MTForceBehavior *,MTForceBehavior *,0>(v4 + 144, v5, v4);
        uint64_t v5 = v9;
        for (unint64_t j = (void *)*v6; j != (void *)v5; std::allocator<MTForceBehavior>::destroy[abi:ne180100](v8, j))
          j -= 18;
        *uint64_t v6 = v5;
      }
      while (v4 != v5);
    }
  }
  *((unsigned char *)this + 24) = 1;
}

void MTForceBehaviorConfiguration::clearNonDefaultBehaviors(MTForceBehaviorConfiguration *this)
{
  for (uint64_t i = 0; i != 6; ++i)
  {
    unsigned int v3 = (uint64_t *)(*(void *)this + 24 * i);
    uint64_t v4 = *v3;
    uint64_t v7 = v3[1];
    uint64_t v6 = v3 + 1;
    uint64_t v5 = v7;
    if (v4 != v7)
    {
      uint64_t v8 = *(void *)this + 24 * i + 16;
      do
      {
        if (*(_DWORD *)(v4 + 8) == 1)
        {
          v4 += 144;
        }
        else
        {
          std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,MTForceBehavior *,MTForceBehavior *,MTForceBehavior *,0>(v4 + 144, v5, v4);
          uint64_t v5 = v9;
          for (unint64_t j = (void *)*v6; j != (void *)v5; std::allocator<MTForceBehavior>::destroy[abi:ne180100](v8, j))
            j -= 18;
          *uint64_t v6 = v5;
        }
      }
      while (v4 != v5);
    }
  }
  *((unsigned char *)this + 24) = 1;
}

MTForceBehavior *MTForceBehaviorConfiguration::matchingBehaviorInStack(MTForceBehavior *result, MTForceBehavior **a2, int a3)
{
  unsigned int v3 = a2[1];
  if (v3 == *a2) {
    return (MTForceBehavior *)MTForceBehavior::GetNull(result);
  }
  uint64_t v4 = 0;
  uint64_t result = (MTForceBehavior *)((char *)v3 - 144);
  while (1)
  {
    int v5 = *((_DWORD *)result + 2);
    uint64_t v6 = 1;
    if (v5 != 2 && (v4 & (v5 != 1)) == 0)
    {
      uint64_t v6 = v4;
      if ((*((_DWORD *)result + 1) & a3) != 0) {
        break;
      }
    }
    uint64_t v4 = v6;
    BOOL v7 = result == *a2;
    uint64_t result = (MTForceBehavior *)((char *)result - 144);
    if (v7) {
      return (MTForceBehavior *)MTForceBehavior::GetNull(result);
    }
  }
  return result;
}

MTForceBehavior *MTForceBehaviorConfiguration::firstFingerBehavior(MTForceBehaviorConfiguration *this)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 1) - *(void *)this) >> 3) < 2) {
    return (MTForceBehavior *)MTForceBehavior::GetNull(this);
  }
  else {
    return MTForceBehaviorConfiguration::matchingBehaviorInStack(this, (MTForceBehavior **)(*(void *)this + 24), 32);
  }
}

MTForceBehavior *MTForceBehaviorConfiguration::secondFingerBehavior(MTForceBehaviorConfiguration *this)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 1) - *(void *)this) >> 3) < 2) {
    return (MTForceBehavior *)MTForceBehavior::GetNull(this);
  }
  else {
    return MTForceBehaviorConfiguration::matchingBehaviorInStack(this, (MTForceBehavior **)(*(void *)this + 24), 64);
  }
}

MTForceBehavior *MTForceBehaviorConfiguration::collectiveBehavior(MTForceBehaviorConfiguration *this, int a2)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 1) - *(void *)this) >> 3) <= a2) {
    return (MTForceBehavior *)MTForceBehavior::GetNull(this);
  }
  else {
    return MTForceBehaviorConfiguration::matchingBehaviorInStack(this, (MTForceBehavior **)(*(void *)this + 24 * a2), 128);
  }
}

void MTForceClickHistory::MTForceClickHistory(MTForceClickHistory *this, float a2)
{
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  MTForceClickHistory::initHistory(this, a2);
}

void sub_240746258(_Unwind_Exception *exception_object)
{
  uint64_t v4 = (void *)v1[4];
  if (v4)
  {
    v1[5] = v4;
    operator delete(v4);
  }
  int v5 = *v2;
  if (*v2)
  {
    v1[2] = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void MTForceClickHistory::initHistory(MTForceClickHistory *this, float a2)
{
  int v3 = 0;
  uint64_t v4 = (void **)((char *)this + 8);
  *((void *)this + 2) = *((void *)this + 1);
  int v5 = (void **)((char *)this + 32);
  *((void *)this + 5) = *((void *)this + 4);
  *(void *)this = 0;
  float v6 = a2 * 550.0;
  float v7 = a2 * 350.0;
  uint64_t v8 = (char *)this + 24;
  uint64_t v9 = (char *)this + 48;
  do
  {
    uint64_t v11 = (float *)*((void *)this + 2);
    unint64_t v10 = *((void *)this + 3);
    if ((unint64_t)v11 >= v10)
    {
      unint64_t v13 = (float *)*v4;
      uint64_t v14 = ((char *)v11 - (unsigned char *)*v4) >> 2;
      unint64_t v15 = v14 + 1;
      if ((unint64_t)(v14 + 1) >> 62) {
        std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v16 = v10 - (void)v13;
      if (v16 >> 1 > v15) {
        unint64_t v15 = v16 >> 1;
      }
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v15;
      }
      if (v17)
      {
        int v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v8, v17);
        unint64_t v13 = (float *)*((void *)this + 1);
        uint64_t v11 = (float *)*((void *)this + 2);
      }
      else
      {
        int v18 = 0;
      }
      long long v19 = (float *)&v18[4 * v14];
      *long long v19 = v6;
      uint64_t v12 = v19 + 1;
      while (v11 != v13)
      {
        int v20 = *((_DWORD *)v11-- - 1);
        *((_DWORD *)v19-- - MTRestZoneIntegrator::clearMotion(this, 1) = v20;
      }
      *((void *)this + MTRestZoneIntegrator::clearMotion(this, 1) = v19;
      *((void *)this + 2) = v12;
      *((void *)this + 3) = &v18[4 * v17];
      if (v13) {
        operator delete(v13);
      }
    }
    else
    {
      *uint64_t v11 = v6;
      uint64_t v12 = v11 + 1;
    }
    *((void *)this + 2) = v12;
    uint64_t v22 = (float *)*((void *)this + 5);
    unint64_t v21 = *((void *)this + 6);
    if ((unint64_t)v22 >= v21)
    {
      uint64_t v24 = (float *)*v5;
      uint64_t v25 = ((char *)v22 - (unsigned char *)*v5) >> 2;
      unint64_t v26 = v25 + 1;
      if ((unint64_t)(v25 + 1) >> 62) {
        std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v27 = v21 - (void)v24;
      if (v27 >> 1 > v26) {
        unint64_t v26 = v27 >> 1;
      }
      if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v28 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v28 = v26;
      }
      if (v28)
      {
        float v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v9, v28);
        uint64_t v24 = (float *)*((void *)this + 4);
        uint64_t v22 = (float *)*((void *)this + 5);
      }
      else
      {
        float v29 = 0;
      }
      int v30 = (float *)&v29[4 * v25];
      *int v30 = v7;
      uint64_t v23 = v30 + 1;
      while (v22 != v24)
      {
        int v31 = *((_DWORD *)v22-- - 1);
        *((_DWORD *)v30-- - MTRestZoneIntegrator::clearMotion(this, 1) = v31;
      }
      *((void *)this + 4) = v30;
      *((void *)this + 5) = v23;
      *((void *)this + 6) = &v29[4 * v28];
      if (v24) {
        operator delete(v24);
      }
    }
    else
    {
      *uint64_t v22 = v7;
      uint64_t v23 = v22 + 1;
    }
    *((void *)this + 5) = v23;
    ++v3;
  }
  while (v3 != 3);
  *(float *)this = v6;
  *((float *)this + MTRestZoneIntegrator::clearMotion(this, 1) = v7;
}

void MTForceClickHistory::~MTForceClickHistory(MTForceClickHistory *this)
{
  int v2 = (void *)*((void *)this + 1);
  *((void *)this + 2) = v2;
  int v3 = (void *)*((void *)this + 4);
  *((void *)this + 5) = v3;
  *(void *)this = 0;
  if (v3)
  {
    operator delete(v3);
    int v2 = (void *)*((void *)this + 1);
  }
  if (v2)
  {
    *((void *)this + 2) = v2;
    operator delete(v2);
  }
}

void *MTForceClickHistory::clearHistory(void *this)
{
  this[2] = this[1];
  this[5] = this[4];
  *this = 0;
  return this;
}

float MTForceClickHistory::updateForceArray(float a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(float **)a3;
  float v6 = *(float **)(a3 + 8);
  unint64_t v7 = (unint64_t)v6 - *(void *)a3;
  if (v7 >= 0x75)
  {
    uint64_t v8 = *(float **)a3;
    do
    {
      int64_t v9 = (char *)v6 - (char *)(v5 + 1);
      if (v6 != v5 + 1)
      {
        memmove(v5, v5 + 1, (char *)v6 - (char *)(v5 + 1));
        uint64_t v8 = *(float **)a3;
      }
      --v6;
      *(void *)(a3 + 8) = (char *)v5 + v9;
      unint64_t v7 = (char *)v5 + v9 - (char *)v8;
      int v5 = v8;
    }
    while (v7 > 0x74);
    int v5 = v8;
  }
  unint64_t v10 = *(void *)(a3 + 16);
  if ((unint64_t)v6 >= v10)
  {
    unint64_t v12 = v7 >> 2;
    uint64_t v13 = v10 - (void)v5;
    if (v13 >> 1 <= (v7 >> 2) + 1) {
      uint64_t v14 = v12 + 1;
    }
    else {
      uint64_t v14 = v13 >> 1;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v14;
    }
    uint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a3 + 16, v15);
    unint64_t v17 = *(float **)a3;
    int v18 = *(float **)(a3 + 8);
    int v5 = (float *)&v16[4 * v12];
    int v20 = &v16[4 * v19];
    float *v5 = a1;
    uint64_t v11 = (uint64_t)(v5 + 1);
    while (v18 != v17)
    {
      int v21 = *((_DWORD *)v18-- - 1);
      *((_DWORD *)v5-- - MTRestZoneIntegrator::clearMotion(this, 1) = v21;
    }
    *(void *)a3 = v5;
    *(void *)(a3 + 8) = v11;
    *(void *)(a3 + 16) = v20;
    if (v17)
    {
      operator delete(v17);
      int v5 = *(float **)a3;
    }
  }
  else
  {
    *float v6 = a1;
    uint64_t v11 = (uint64_t)(v6 + 1);
  }
  *(void *)(a3 + 8) = v11;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v24, v5, v11, (v11 - (uint64_t)v5) >> 2);
  char v27 = -86;
  std::__sort<std::__less<float,float> &,float *>();
  if ((unint64_t)((char *)v25 - (char *)v24) >= 9)
  {
    float v22 = (float)((float)(v24[(int)((unint64_t)((char *)v25 - (char *)v24) >> 2) / 2 - 1]
                        + v24[(int)((unint64_t)((char *)v25 - (char *)v24) >> 2) / 2])
                + v24[(int)((unint64_t)((char *)v25 - (char *)v24) >> 2) / 2 + 1])
        / 3.0;
LABEL_23:
    uint64_t v25 = v24;
    operator delete(v24);
    return v22;
  }
  float v22 = 0.0;
  if (v24) {
    goto LABEL_23;
  }
  return v22;
}

void sub_24074667C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void MTForceClickHistory::addDrag(MTForceClickHistory *this, float a2)
{
  *(float *)this = MTForceClickHistory::updateForceArray(a2, (uint64_t)this, (uint64_t)this + 8);
}

void MTForceClickHistory::addClick(MTForceClickHistory *this, float a2)
{
  *((float *)this + MTRestZoneIntegrator::clearMotion(this, 1) = MTForceClickHistory::updateForceArray(a2, (uint64_t)this, (uint64_t)this + 32);
}

uint64_t MTForceManagement::MTForceManagement(uint64_t a1)
{
  *(void *)(a1 + 456) = 0;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  std::vector<MTForceThresholding>::vector((void *)(a1 + 464), 0x20uLL);
  *(void *)(a1 + 504) = 0x100000001;
  MTForceClickHistory::MTForceClickHistory((MTForceClickHistory *)(a1 + 512), 1.0);
  *(_DWORD *)(a1 + 592) = 65537;
  *(_WORD *)(a1 + 596) = 0;
  MTParameterFactory::initForceThresholdQualifiers(a1 + 296);
  MTParameterFactory::initForceActuationQualifiers(a1 + 432);
  MTForceManagement::clearState(a1, 0);
  return a1;
}

{
  return MTForceManagement::MTForceManagement(a1);
}

void sub_2407467B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<MTForceThresholding>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::vector<std::vector<MTForceBehavior>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  MTForceBehavior::~MTForceBehavior(v2);
  _Unwind_Resume(a1);
}

void MTForceManagement::MTForceManagement(MTForceManagement *this)
{
  *((void *)this + 57) = 0;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  std::vector<MTForceThresholding>::vector((void *)this + 58, 0x20uLL);
  *((void *)this + 63) = 0x100000001;
  MTForceClickHistory::MTForceClickHistory((MTForceManagement *)((char *)this + 512), 1.0);
  *((_DWORD *)this + 148) = 65537;
  *((_WORD *)this + 298) = 0;
  MTParameterFactory::initForceThresholdQualifiers((uint64_t)this + 296);
  MTParameterFactory::initForceActuationQualifiers((uint64_t)this + 432);
  MTForceManagement::clearState((uint64_t)this, 0);
}

void sub_2407468D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<MTForceThresholding>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::vector<std::vector<MTForceBehavior>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  MTForceBehavior::~MTForceBehavior(v2);
  _Unwind_Resume(a1);
}

void MTForceManagement::setForceThresholdQualifiers(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 296) = *(_OWORD *)a2;
  long long v4 = *(_OWORD *)(a2 + 16);
  long long v5 = *(_OWORD *)(a2 + 32);
  long long v6 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 344) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 360) = v6;
  *(_OWORD *)(a1 + 312) = v4;
  *(_OWORD *)(a1 + 328) = v5;
  long long v7 = *(_OWORD *)(a2 + 80);
  long long v8 = *(_OWORD *)(a2 + 96);
  long long v9 = *(_OWORD *)(a2 + 112);
  *(void *)(a1 + 424) = *(void *)(a2 + 128);
  *(_OWORD *)(a1 + 392) = v8;
  *(_OWORD *)(a1 + 408) = v9;
  *(_OWORD *)(a1 + 376) = v7;
  uint64_t v10 = 472;
  uint64_t v11 = 31;
  do
  {
    MTForceThresholding::setForceThresholdQualifiers(*(void *)(a1 + 464) + v10, a2);
    v10 += 472;
    --v11;
  }
  while (v11);
}

void MTForceManagement::setForceActuationQualifiers(uint64_t a1, _OWORD *a2)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  long long v4 = a2[1];
  *(_OWORD *)(a1 + 432) = *a2;
  *(_OWORD *)(a1 + 448) = v4;
  long long v5 = MTLoggingPlugin();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    if (*(unsigned char *)(a1 + 460)) {
      long long v6 = "ON";
    }
    else {
      long long v6 = "off";
    }
    double v7 = *(float *)(a1 + 432);
    double v8 = *(float *)(a1 + 436);
    double v9 = *(float *)(a1 + 448);
    double v10 = *(float *)(a1 + 452);
    double v11 = *(float *)(a1 + 440);
    double v12 = *(float *)(a1 + 444);
    double v13 = *(float *)(a1 + 456);
    int v16 = 136317698;
    unint64_t v17 = "[Debug] ";
    __int16 v18 = 2080;
    uint64_t v19 = "";
    __int16 v20 = 2080;
    int v21 = "setForceActuationQualifiers";
    __int16 v22 = 2082;
    uint64_t v23 = v6;
    __int16 v24 = 2048;
    double v25 = v7;
    __int16 v26 = 2048;
    double v27 = v8;
    __int16 v28 = 2048;
    double v29 = v9;
    __int16 v30 = 2048;
    double v31 = v10;
    __int16 v32 = 2048;
    double v33 = v11;
    __int16 v34 = 2048;
    double v35 = v12;
    __int16 v36 = 2048;
    double v37 = v13;
    _os_log_impl(&dword_2406FB000, v5, OS_LOG_TYPE_DEBUG, "[HID] [MT] %s%s%s ForceActuationQualifiers changed  adapt:%{public}s forcespeed:%f stengthMemory:%f strengthFloor:%f strengthAreaGain:%f timedilationMemory:%f timeAreaGin:%f strengthGain:%f", (uint8_t *)&v16, 0x70u);
  }
  uint64_t v14 = 472;
  uint64_t v15 = 31;
  do
  {
    MTForceThresholding::setForceActuationQualifiers(*(void *)(a1 + 464) + v14, (uint64_t)a2);
    v14 += 472;
    --v15;
  }
  while (v15);
}

void MTForceManagement::setDisableClickWaveformAdaptation(MTForceManagement *this, char a2)
{
  int v3 = (char *)this + 432;
  *((unsigned char *)this + 460) = a2 ^ 1;
  uint64_t v4 = 472;
  uint64_t v5 = 31;
  do
  {
    MTForceThresholding::setForceActuationQualifiers(*((void *)this + 58) + v4, (uint64_t)v3);
    v4 += 472;
    --v5;
  }
  while (v5);
}

uint64_t MTForceManagement::setDisableForceThresholdAdaptation(uint64_t this, char a2)
{
  int v2 = (unsigned char *)(*(void *)(this + 464) + 896);
  uint64_t v3 = 31;
  do
  {
    unsigned char *v2 = a2;
    v2 += 472;
    --v3;
  }
  while (v3);
  return this;
}

void MTForceManagement::setFirstStageClickPreference(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 504) != a2)
  {
    float ClickThresholdMultiplier = MTForceThresholding::getClickThresholdMultiplier(*(void *)(a1 + 464), a2);
    MTForceClickHistory::initHistory((MTForceClickHistory *)(a1 + 512), ClickThresholdMultiplier);
  }
  *(_DWORD *)(a1 + 504) = a2;
  uint64_t v5 = *(void *)(a1 + 464) + 336;
  uint64_t v6 = -15104;
  do
  {
    *(_DWORD *)(v5 + v6 + 15104) = a2;
    v6 += 472;
  }
  while (v6);
}

uint64_t MTForceManagement::setSecondStageClickPreference(uint64_t result, int a2)
{
  *(_DWORD *)(result + 508) = a2;
  uint64_t v2 = *(void *)(result + 464) + 340;
  uint64_t v3 = -15104;
  do
  {
    *(_DWORD *)(v2 + v3 + 15104) = a2;
    v3 += 472;
  }
  while (v3);
  return result;
}

uint64_t MTForceManagement::whichForceButtonActivated(MTForceManagement *this)
{
  if (*(unsigned char *)this
    && (int v1 = *((_DWORD *)this + 64), v2 = *((void *)this + 58), *(int *)(v2 + 472 * v1 + 324) >= 1))
  {
    return MTForceBehavior::whichButtonBehavior((MTForceBehavior *)(v2 + 472 * v1 + 176));
  }
  else
  {
    return 0;
  }
}

BOOL MTForceManagement::isForceButtonActivated(MTForceManagement *this)
{
  return (int)MTForceManagement::whichForceButtonActivated(this) > 0;
}

double MTForceManagement::constructForceEvent@<D0>(MTForceManagement *this@<X0>, const MTPathStates *a2@<X3>, int a3@<W1>, int a4@<W2>, uint64_t a5@<X8>)
{
  uint64_t v8 = *((void *)this + 58);
  double v9 = (_DWORD *)(v8 + 472 * a3);
  double v10 = v9 + 81;
  *(void *)((char *)this + 220) = *(void *)(v9 + 81);
  uint64_t v11 = *((void *)a2 + 35);
  double v12 = (const MTForceFilter *)(v11 + 600 * a4 + 296);
  double v13 = (const MTParserPath *)(v11 + 600 * a3);
  float v14 = MTForceThresholding::preReleaseProgress((MTForceThresholding *)v9, v12, v13);
  float v15 = MTForceThresholding::preActivationProgress((MTForceThresholding *)v9, v12, v13);
  float v16 = MTForceThresholding::postActivationProgress((MTForceThresholding *)v9, v12, v13);
  int v17 = *((_DWORD *)this + 55);
  float v18 = 0.0;
  if (v17 == *((_DWORD *)this + 56) && v9[44] != 11) {
    float v18 = *((float *)this + 85);
  }
  __int16 v46 = (MTForceBehavior *)(v9 + 44);
  float v19 = (float)(v14 * (float)(1.0 - v18)) + (float)(v18 * *((float *)this + 61));
  __int16 v20 = v9 + 82;
  float v21 = (float)(v15 * (float)(1.0 - v18)) + (float)(v18 * *((float *)this + 62));
  *((float *)this + 6MTRestZoneIntegrator::clearMotion(this, 1) = v19;
  *((float *)this + 62) = v21;
  float v22 = (float)(v16 * (float)(1.0 - v18)) + (float)(v18 * *((float *)this + 63));
  *((float *)this + 63) = v22;
  int v23 = *((_DWORD *)this + 44);
  BOOL v24 = v23 == 8 || v23 == 2;
  if (v24) {
    int v25 = 16;
  }
  else {
    int v25 = 0;
  }
  if (v24) {
    int v26 = 8;
  }
  else {
    int v26 = 2;
  }
  if (v17 <= 0) {
    int v27 = v25;
  }
  else {
    int v27 = v26;
  }
  *((_DWORD *)this + 44) = v27;
  float v28 = *((float *)this + 107);
  float Release = MTForceThresholding::thresholdForNextRelease((MTForceThresholding *)v9, v12, v13);
  float Activation = MTForceThresholding::thresholdForNextActivation((MTForceThresholding *)v9, v12, v13);
  unint64_t v31 = *((unsigned int *)this + 55);
  uint64_t v32 = *(void *)(v8 + 472 * a3 + 432);
  float v33 = 0.0;
  if (v31 < (*(void *)(v8 + 472 * a3 + 440) - v32) >> 2) {
    float v33 = *(float *)(v32 + 4 * v31);
  }
  if (*v10 == *v20)
  {
    int v34 = 0;
  }
  else if ((int)v31 > *((_DWORD *)this + 56))
  {
    int v34 = 1;
  }
  else
  {
    int v34 = 2;
  }
  double v35 = (float)(Activation / v28);
  if ((v31 + 1) >= *(_DWORD *)(v8 + 472 * a3 + 192)) {
    double v36 = 1.0;
  }
  else {
    double v36 = v35;
  }
  if ((int)v31 >= 1) {
    double v37 = (float)(Release / v28);
  }
  else {
    double v37 = 0.0;
  }
  double v38 = (float)(v33 / v28);
  float v39 = v21 - v19;
  int v40 = *(_DWORD *)v46;
  int v41 = MTForceBehavior::forceSourceFingerCount((uint64_t)v46);
  int v42 = *((_DWORD *)this + 55);
  if ((int)v31 <= 0) {
    double v43 = 0.0;
  }
  else {
    double v43 = v38;
  }
  double v44 = fmax(fmin((float)(*(float *)(v8 + 472 * a3 + 380) / *(float *)(v8 + 472 * a3 + 140)), 1.0), 0.0);
  *(_DWORD *)a5 = v27;
  *(_DWORD *)(a5 + 4) = v40;
  *(_DWORD *)(a5 + 8) = v41;
  *(float *)(a5 + 12) = v39;
  *(_DWORD *)(a5 + 16) = v42;
  *(float *)(a5 + 20) = v22;
  *(float *)&double v44 = v44;
  *(_DWORD *)(a5 + 24) = v42;
  *(_DWORD *)(a5 + 28) = v34;
  *(double *)(a5 + 32) = v36;
  *(double *)(a5 + 40) = v43;
  double result = *(float *)&v44;
  *(double *)(a5 + 48) = v37;
  *(double *)(a5 + 56) = *(float *)&v44;
  *(void *)(a5 + 64) = 0;
  return result;
}

void MTForceManagement::updateStatusVariablesFromForceEvent(uint64_t a1, int a2, int *a3, MTPathStates *this)
{
  uint64_t v6 = *(void *)(a1 + 464);
  uint64_t v7 = v6 + 472 * a2;
  *(void *)&long long v8 = *(void *)(v7 + 344);
  *((void *)&v8 + MTRestZoneIntegrator::clearMotion(this, 1) = *(void *)(v7 + 360);
  *(_OWORD *)(a1 + 228) = v8;
  int v9 = *a3;
  if (*a3 == 2) {
    *(_DWORD *)(a1 + 212) = *(_DWORD *)(a1 + 180);
  }
  if (a3[4])
  {
    uint64_t v10 = v6 + 472 * a2;
    *(_DWORD *)(a1 + 180) = *(_DWORD *)(v10 + 332);
    *(_DWORD *)(a1 + 184) = *(_DWORD *)(v10 + 376);
    *(double *)(a1 + 192) = *(double *)(v10 + 416) - *(double *)(v10 + 408);
    *(_DWORD *)(a1 + 208) = *(_DWORD *)(v10 + 400);
  }
  if (*(_DWORD *)(a1 + 220) == 1 && !*(_DWORD *)(a1 + 224))
  {
    *(float *)(a1 + 200) = MTPathStates::getPrePixelatedPositionFromPostPixelatedPosition(this, a2);
    *(_DWORD *)(a1 + 204) = v11;
    int v9 = *a3;
  }
  if (v9 == 16)
  {
    if (*(float *)(a1 + 208) <= *(float *)(a1 + 416))
    {
      if (*(_DWORD *)(a1 + 180) == 1 && *(_DWORD *)(a1 + 212) == 1 && a3[2] == 1) {
        *(float *)(a1 + 516) = MTForceClickHistory::updateForceArray(*(float *)(a1 + 184), a1, a1 + 544);
      }
    }
    else
    {
      *(float *)(a1 + 512) = MTForceClickHistory::updateForceArray(*(float *)(a1 + 184), a1, a1 + 520);
    }
  }
  BOOL v12 = a3[1] == 11 && a3[4] != 0;
  *(unsigned char *)(a1 + 3) = v12;
}

uint64_t MTForceManagement::appendForceEvent(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)a3;
  BOOL v5 = *(_DWORD *)a3 != *(_DWORD *)(result + 568)
    || *(_DWORD *)(a3 + 4) != *(_DWORD *)(result + 572)
    || *(_DWORD *)(a3 + 8) != *(_DWORD *)(result + 576)
    || vabds_f32(*(float *)(a3 + 12), *(float *)(result + 580)) > 0.001
    || *(_DWORD *)(a3 + 16) != *(_DWORD *)(result + 584)
    || vabds_f32(*(float *)(a3 + 20), *(float *)(result + 588)) > 0.001;
  if (v4 == 2 || v4 == 16) {
    goto LABEL_13;
  }
  char v9 = !v5;
  if (v4 < 1) {
    char v9 = 1;
  }
  if ((v9 & 1) == 0)
  {
LABEL_13:
    uint64_t v7 = result + 568;
    double result = MTAppendForceGestureEvent();
    uint64_t v8 = *(void *)(a3 + 16);
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a3;
    *(void *)(v7 + 16) = v8;
  }
  return result;
}

void MTForceManagement::appendForceStageEvent()
{
  IOHIDEventGetTimeStamp();
  uint64_t VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
  if (VendorDefinedEvent)
  {
    int v1 = (const void *)VendorDefinedEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
}

double MTForceManagement::constructThresholdInfo@<D0>(MTForceManagement *this@<X0>, const MTPathStates *a2@<X3>, int a3@<W2>, uint64_t a4@<X8>)
{
  *(void *)a4 = *(void *)((char *)this + 228);
  uint64_t v4 = *((void *)a2 + 35) + 600 * a3;
  int v5 = *(_DWORD *)(v4 + 304);
  *(_DWORD *)(a4 + 8) = *(_DWORD *)(v4 + 336);
  *(_DWORD *)(a4 + 12) = v5;
  double result = *(double *)((char *)this + 236);
  *(double *)(a4 + 16) = result;
  return result;
}

int32x2_t MTForceManagement::constructClickInfo@<D0>(uint64_t a1@<X0>, uint64_t a2@<X4>, uint64_t a3@<X8>)
{
  *(void *)a3 = *(void *)(a2 + 4);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 180);
  float v3 = *(double *)(a1 + 192);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 184);
  *(float *)(a3 + 16) = v3;
  *(_DWORD *)(a3 + 20) = *(_DWORD *)(a1 + 208);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a1 + 212);
  int32x2_t result = vrev64_s32(*(int32x2_t *)(a1 + 512));
  *(int32x2_t *)(a3 + 28) = result;
  return result;
}

void MTForceManagement::appendThresholdInfo()
{
  IOHIDEventGetTimeStamp();
  uint64_t VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
  if (VendorDefinedEvent)
  {
    int v1 = (const void *)VendorDefinedEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
}

void MTForceManagement::appendClickInfo()
{
  IOHIDEventGetTimeStamp();
  uint64_t VendorDefinedEvent = IOHIDEventCreateVendorDefinedEvent();
  if (VendorDefinedEvent)
  {
    int v1 = (const void *)VendorDefinedEvent;
    IOHIDEventAppendEvent();
    CFRelease(v1);
  }
}

BOOL MTForceManagement::actuateForceAndHIDEvents(uint64_t a1, const MTPathStates *a2, CFDictionaryRef *this, uint64_t a4, char a5)
{
  if (MTActuatorManagement::getActuatorRef((MTActuatorManagement *)this)
    && *(unsigned char *)(a1 + 594)
    && *(unsigned char *)(a1 + 595))
  {
    if ((a5 & 1) == 0) {
      MTForceManagement::actuateOnStageChanges((MTForceManagement *)a1, a2, this);
    }
    if (*(unsigned char *)a1)
    {
      unsigned int v9 = *(_DWORD *)(a1 + 256);
      if (v9) {
        goto LABEL_8;
      }
    }
    else
    {
      unsigned int v9 = MTForceManagement::strongestProgressPathID((MTForceManagement *)a1, a2, 0);
      if (*(_DWORD *)(a1 + 256))
      {
LABEL_8:
        int v10 = MTForceManagement::strongestForcePathID((MTForceManagement *)a1, a2, 0);
        if ((v9 & 0x80000000) != 0) {
          return *(unsigned __int8 *)(a1 + 1) != *(unsigned __int8 *)(a1 + 2);
        }
        goto LABEL_14;
      }
    }
    int v10 = 0;
    if ((v9 & 0x80000000) != 0) {
      return *(unsigned __int8 *)(a1 + 1) != *(unsigned __int8 *)(a1 + 2);
    }
LABEL_14:
    *(void *)&long long v13 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v13 + MTRestZoneIntegrator::clearMotion(this, 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v29 = v13;
    long long v30 = v13;
    long long v27 = v13;
    long long v28 = v13;
    long long v25 = v13;
    long long v26 = v13;
    long long v23 = v13;
    long long v24 = v13;
    long long v22 = v13;
    MTForceBehavior::MTForceBehavior((MTForceBehavior *)&v22, (const MTForceBehavior *)(*(void *)(a1 + 464) + 472 * v9 + 176));
    long long v19 = xmmword_240750150;
    long long v20 = unk_240750160;
    uint64_t v21 = -1;
    long long v17 = xmmword_240750130;
    long long v18 = unk_240750140;
    MTForceManagement::constructForceEvent((MTForceManagement *)a1, a2, v9, v10, (uint64_t)&v17);
    v15[2] = v19;
    v15[3] = v20;
    uint64_t v16 = v21;
    v15[0] = v17;
    v15[1] = v18;
    MTForceManagement::updateStatusVariablesFromForceEvent(a1, v9, (int *)v15, a2);
    if (!*(unsigned char *)(a1 + 596) || (int v14 = *(_DWORD *)(a1 + 568), v14 == 8) || v14 == 2) {
      MTForceManagement::appendForceStageEvent();
    }
    if (*(unsigned char *)(a1 + 216))
    {
      if (*(_DWORD *)(a1 + 220) != *(_DWORD *)(a1 + 224)) {
        MTForceManagement::appendThresholdInfo();
      }
      if (v17 == 16) {
        MTForceManagement::appendClickInfo();
      }
    }
    if (*((void *)&v29 + 1))
    {
      *(void *)&long long v30 = *((void *)&v29 + 1);
      operator delete(*((void **)&v29 + 1));
    }
    if ((void)v28)
    {
      *((void *)&v28 + MTRestZoneIntegrator::clearMotion(this, 1) = v28;
      operator delete((void *)v28);
    }
    if (*((void *)&v26 + 1))
    {
      *(void *)&long long v27 = *((void *)&v26 + 1);
      operator delete(*((void **)&v26 + 1));
    }
    if ((void)v25)
    {
      *((void *)&v25 + MTRestZoneIntegrator::clearMotion(this, 1) = v25;
      operator delete((void *)v25);
    }
    if (*((void *)&v23 + 1))
    {
      *(void *)&long long v24 = *((void *)&v23 + 1);
      operator delete(*((void **)&v23 + 1));
    }
    return *(unsigned __int8 *)(a1 + 1) != *(unsigned __int8 *)(a1 + 2);
  }
  int v11 = MTLoggingPlugin();
  BOOL result = os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    MTForceManagement::actuateForceAndHIDEvents((MTActuatorManagement *)this, a1, v11);
    return 0;
  }
  return result;
}

void sub_24074765C(_Unwind_Exception *a1)
{
  MTForceBehavior::~MTForceBehavior((MTForceBehavior *)(v1 - 192));
  _Unwind_Resume(a1);
}

uint64_t MTActuatorManagement::getActuatorRef(MTActuatorManagement *this)
{
  uint64_t result = *((void *)this + 1);
  if (!result)
  {
    uint64_t result = MTDeviceGetMTActuator();
    *((void *)this + MTRestZoneIntegrator::clearMotion(this, 1) = result;
    if (result)
    {
      if ((MTActuatorIsOpen() & 1) == 0) {
        MTActuatorOpen();
      }
      io_registry_entry_t Service = MTActuatorGetService();
      IORegistryEntryGetRegistryEntryID(Service, (uint64_t *)this + 4);
      CFRetain(*((CFTypeRef *)this + 1));
      return *((void *)this + 1);
    }
  }
  return result;
}

uint64_t MTForceManagement::actuateOnStageChanges(MTForceManagement *this, const MTPathStates *a2, CFDictionaryRef *a3)
{
  *((unsigned char *)this + 2) = *((unsigned char *)this + 1);
  uint64_t result = MTForceManagement::whichForceButtonActivated(this);
  *((unsigned char *)this + MTRestZoneIntegrator::clearMotion(this, 1) = result != 0;
  if (*(unsigned char *)this)
  {
    int v7 = *((_DWORD *)this + 64);
    uint64_t v8 = *((void *)this + 58);
    uint64_t v9 = v8 + 472 * v7;
    int v10 = *(_DWORD *)(v9 + 324);
    int v11 = *(_DWORD *)(v9 + 328);
    if (v10 != v11)
    {
      int v12 = *((unsigned __int8 *)this + 4);
      double v13 = *((double *)a2 + 1);
      float v14 = *((float *)this + 2);
      *((unsigned char *)this + 4) = v10 < v11;
      if (v10 >= v11)
      {
        *((double *)this + 3) = v13;
        return MTForceManagement::actuateThresholderPath(this, a3, v7);
      }
      else
      {
        *((double *)this + 2) = v13;
        uint64_t result = MTForceBehavior::operator=((uint64_t)this + 32, v8 + 472 * v7 + 176);
        if (!v12 || (float v15 = v13 - v14, v15 > 0.2))
        {
          MTForceManagement::actuateThresholderPath(this, a3, *((_DWORD *)this + 64));
          uint64_t result = MTForceThresholding::actuationWaveformID((MTForceThresholding *)(*((void *)this + 58)
                                                                                  + 472 * *((int *)this + 64)));
          if (result)
          {
            float v16 = *((double *)a2 + 1);
            *((float *)this + 2) = v16;
          }
        }
      }
    }
  }
  return result;
}

uint64_t MTForceManagement::strongestProgressPathID(MTForceManagement *this, const MTPathStates *a2, int a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  int v8 = 0;
  float v9 = 0.0;
  uint64_t v10 = 0xFFFFFFFFLL;
  do
  {
    int v11 = (MTForceThresholding *)(*((void *)this + 58) + v6);
    if (*((_DWORD *)v11 + 44)
      && MTForceThresholding::fingersMatchBehavior(v11, a2, v7)
      && (!a3 || v7 && v7 != *((_DWORD *)this + 64)))
    {
      int v12 = (MTForceThresholding *)(*((void *)this + 58) + v6);
      int v13 = (*((_DWORD *)v12 + 45) >> 7) & 1;
      float v14 = MTForceThresholding::rescaleForceAsLadderProgress(v12, a2);
      BOOL v15 = v14 <= 0.0 || v13 <= v8;
      if (!v15 || (v14 > v9 ? (BOOL v16 = v13 < v8) : (BOOL v16 = 1), !v16))
      {
        float v9 = v14;
        uint64_t v10 = v7;
        int v8 = v13;
      }
    }
    ++v7;
    v6 += 472;
  }
  while (v7 != 32);
  return v10;
}

uint64_t MTForceManagement::strongestForcePathID(MTForceManagement *this, const MTPathStates *a2, int a3)
{
  uint64_t v6 = 0;
  float v7 = 0.0;
  uint64_t v8 = 1;
  uint64_t v9 = 472;
  uint64_t v10 = 936;
  do
  {
    if (MTForceThresholding::fingersMatchBehavior((MTForceThresholding *)(*((void *)this + 58) + v9), a2, v8)&& (!a3 || v8 != *((_DWORD *)this + 64)))
    {
      uint64_t v11 = *((void *)a2 + 35);
      if (*(float *)(v11 + v10) <= v7)
      {
        uint64_t v6 = v6;
      }
      else
      {
        float v7 = *(float *)(v11 + v10);
        uint64_t v6 = v8;
      }
    }
    ++v8;
    v9 += 472;
    v10 += 600;
  }
  while (v8 != 32);
  return v6;
}

uint64_t MTForceManagement::actuateThresholderPath(MTForceManagement *this, CFDictionaryRef *a2, int a3)
{
  uint64_t v5 = *((void *)this + 58);
  if (a3) {
    uint64_t v6 = 492;
  }
  else {
    uint64_t v6 = 488;
  }
  if (a3) {
    uint64_t v7 = 500;
  }
  else {
    uint64_t v7 = 496;
  }
  if (*((unsigned char *)this + 460) && !*(_DWORD *)(v5 + 472 * a3 + 328) && *(int *)(v5 + 472 * a3 + 324) >= 1)
  {
    float v8 = *((float *)this + 112);
    double v9 = (float)(*(float *)((char *)this + v6) - v8);
    double v10 = v8;
    *(float *)&double v9 = v9 / (1.0 - v10);
    uint64_t v11 = v5 + 472 * a3;
    *(float *)&double v9 = (float)(*((float *)this + 109) * *(float *)&v9)
                  + (1.0 - *((float *)this + 109)) * *(float *)(v11 + 368);
    *(float *)&double v9 = v10 + (1.0 - v10) * *(float *)&v9;
    *(_DWORD *)((char *)this + v6) = LODWORD(v9);
    *(float *)&double v9 = (float)(*((float *)this + 110) * *(float *)((char *)this + v7))
                  + (1.0 - *((float *)this + 110)) * *(float *)(v11 + 372);
    *(_DWORD *)((char *)this + v7) = LODWORD(v9);
  }
  int v12 = MTForceThresholding::actuationWaveformID((MTForceThresholding *)(v5 + 472 * a3));
  float v13 = *(float *)((char *)this + v6);
  float v14 = *(float *)((char *)this + v7);

  return MTActuatorManagement::actuateWaveformID(a2, v12, v13, v14);
}

uint64_t MTActuatorManagement::getActuationOptions(uint64_t a1, unsigned int a2, int a3)
{
  if (a2 > 2) {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v3 = dword_240750178[a2];
  }
  if (a3) {
    return v3 | 8;
  }
  else {
    return v3;
  }
}

uint64_t MTActuatorManagement::actuateWaveformID(CFDictionaryRef *this, int a2, float a3, float a4)
{
  uint64_t v5 = (const void *)a2;
  kdebug_trace();
  if (*((unsigned char *)this + 24) && MTActuatorManagement::getActuatorRef((MTActuatorManagement *)this))
  {
    CFDataRef Value = (const __CFData *)CFDictionaryGetValue(this[2], v5);
    if (Value)
    {
      CFDataRef v7 = Value;
      CFDataGetBytePtr(Value);
      CFDataGetLength(v7);
      MTActuatorManagement::getActuatorRef((MTActuatorManagement *)this);
      MTActuatorSetReport();
    }
    else
    {
      MTActuatorManagement::getActuatorRef((MTActuatorManagement *)this);
      MTActuatorActuate();
    }
  }
  return 1;
}

uint64_t MTForceManagement::clearState(uint64_t this, char a2)
{
  uint64_t v2 = this;
  if ((a2 & 1) != 0 || !*(unsigned char *)this || !*(unsigned char *)(this + 597))
  {
    *(_WORD *)(this + MTRestZoneIntegrator::clearMotion(this, 1) = 0;
    MTForceManagement::primeBasicBehaviors((MTForceThresholding **)this, 0);
    __asm { FMOV            V0.4S, #1.0 }
    *(_OWORD *)(v2 + 488) = _Q0;
    *(unsigned char *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
    *(void *)(v2 + 16) = 0;
    *(void *)(v2 + 24) = 0;
    uint64_t Null = MTForceBehavior::GetNull(v8);
    MTForceBehavior::operator=(v2 + 32, Null);
    *(_DWORD *)(v2 + 184) = 0;
    *(unsigned char *)(v2 + 3) = 0;
    *(void *)(v2 + 176) = 0;
    *(void *)(v2 + 200) = 0;
    *(void *)(v2 + 208) = 0;
    *(void *)(v2 + 192) = 0;
    *(unsigned char *)(v2 + 216) = 0;
    *(_OWORD *)(v2 + 220) = 0u;
    *(_OWORD *)(v2 + 236) = 0u;
    *(_DWORD *)(v2 + 252) = 0;
    *(unsigned char *)(v2 + 460) = CFPreferencesGetAppBooleanValue(@"DisableClickWaveformAdaptation", @"com.apple.MultitouchSupport", 0) == 0;
    uint64_t v10 = 31;
    uint64_t v11 = 472;
    do
    {
      MTForceThresholding::setForceActuationQualifiers(*(void *)(v2 + 464) + v11, v2 + 432);
      v11 += 472;
      --v10;
    }
    while (v10);
    this = CFPreferencesGetAppBooleanValue(@"DisableForceThresholdAdaptation", @"com.apple.MultitouchSupport", 0);
    int v12 = (BOOL *)(*(void *)(v2 + 464) + 896);
    uint64_t v13 = 31;
    do
    {
      *int v12 = this != 0;
      v12 += 472;
      --v13;
    }
    while (v13);
  }
  return this;
}

void MTForceManagement::primeBasicBehaviors(MTForceThresholding **this, int a2)
{
  MTForceManagement::disableAllThresholders((MTForceManagement *)this);
  uint64_t v4 = MTForceBehaviorConfiguration::collectiveBehavior((MTForceBehaviorConfiguration *)(this + 33), a2);
  MTForceThresholding::setForceBehavior(this[58], v4, 0);
  Fingerint Behavior = MTForceBehaviorConfiguration::firstFingerBehavior((MTForceBehaviorConfiguration *)(this + 33));
  uint64_t v6 = -31;
  uint64_t v7 = 472;
  do
  {
    MTForceThresholding::setForceBehavior((MTForceThresholding *)((char *)this[58] + v7), FingerBehavior, v6 + 32);
    v7 += 472;
  }
  while (!__CFADD__(v6++, 1));
  *((unsigned char *)this + 288) = 0;
}

void MTForceManagement::analyzeAndManageStrongestForces(MTForceManagement *this, const MTPathStates *a2)
{
  if (*(unsigned char *)this)
  {
    MTForceManagement::managePostActivation(this, a2);
  }
  else
  {
    MTForceManagement::primeBasicBehaviors((MTForceThresholding **)this, *((_DWORD *)a2 + 92));
    MTForceManagement::managePreActivation(this, a2);
  }
}

void MTForceManagement::managePreActivation(MTForceManagement *this, const MTPathStates *a2)
{
  MTForceManagement::analyzeDistributedForces(this, a2);
  unsigned int v4 = MTForceManagement::strongestProgressPathID(this, a2, 0);
  if ((v4 & 0x80000000) == 0)
  {
    uint64_t v5 = *((void *)this + 58);
    if (*(int *)(v5 + 472 * v4 + 324) >= 1
      && !*(_DWORD *)(v5 + 472 * v4 + 328)
      && *((double *)a2 + 1) - *((double *)this + 2) > *((float *)this + 83)
      && *((unsigned char *)this + 594))
    {
      MTForceManagement::lockBehaviorsOnActivatedFinger(this, v4);
    }
  }
}

void MTForceManagement::managePostActivation(MTForceManagement *this, const MTPathStates *a2)
{
  if (*(_DWORD *)(*((void *)this + 58) + 472 * *((int *)this + 64) + 324))
  {
    MTForceManagement::analyzeDistributedForces(this, a2);
  }
  else
  {
    MTForceManagement::primeBasicBehaviors((MTForceThresholding **)this, *((_DWORD *)a2 + 92));
    MTForceManagement::managePreActivation(this, a2);
  }
}

MTForceThresholding *MTForceManagement::analyzeDistributedForces(MTForceManagement *this, const MTPathStates *a2)
{
  int v4 = MTForceManagement::strongestForcePathID(this, a2, 0);
  uint64_t v5 = 0;
  float v6 = *((float *)this + 128);
  float v7 = *((float *)this + 129);
  uint64_t v8 = 32;
  do
  {
    uint64_t result = (MTForceThresholding *)(*((void *)this + 58) + v5);
    if (*((_DWORD *)result + 44)) {
      uint64_t result = (MTForceThresholding *)MTForceThresholding::analyzeForceAndStage(result, a2, v4, (MTForceManagement *)((char *)this + 32), *((double *)this + 2), *((double *)this + 3), *((unsigned __int8 *)this + 592), v7, v6);
    }
    v5 += 472;
    --v8;
  }
  while (v8);
  return result;
}

void MTForceManagement::lockBehaviorsOnActivatedFinger(MTForceManagement *this, unsigned int a2)
{
  *(unsigned char *)this = 1;
  *((_DWORD *)this + 64) = a2;
  if (a2)
  {
    uint64_t Null = (const MTForceBehavior *)MTForceBehavior::GetNull(this);
    MTForceThresholding::setForceBehavior(*((MTForceThresholding **)this + 58), Null, 0);
    uint64_t v5 = MTForceBehaviorConfiguration::secondFingerBehavior((MTForceManagement *)((char *)this + 264));
    uint64_t v6 = 472;
    uint64_t v7 = 472 * a2;
    int v8 = 1;
    uint64_t v9 = 14632;
    do
    {
      if (v7 != v6) {
        MTForceThresholding::setForceBehavior((MTForceThresholding *)(*((void *)this + 58) + v6), v5, v8);
      }
      ++v8;
      v6 += 472;
      v9 -= 472;
    }
    while (v9);
  }
  else
  {
    MTForceManagement::disableFingerThresholders(this);
  }
}

void MTForceManagement::disableAllThresholders(MTForceManagement *this)
{
  *(unsigned char *)this = 0;
  *((_DWORD *)this + 64) = 0;
  uint64_t Null = (const MTForceBehavior *)MTForceBehavior::GetNull(this);
  uint64_t v3 = 0;
  for (uint64_t i = 0; i != 32; ++i)
  {
    MTForceThresholding::setForceBehavior((MTForceThresholding *)(*((void *)this + 58) + v3), Null, i);
    v3 += 472;
  }
}

void MTForceManagement::setBehaviorOnThresholders(MTForceManagement *this, const MTForceBehavior *a2, int a3, int a4)
{
  if (a3 <= a4)
  {
    int v4 = a3;
    int v7 = a4 + 1;
    uint64_t v8 = 472 * a3;
    do
    {
      MTForceThresholding::setForceBehavior((MTForceThresholding *)(*((void *)this + 58) + v8), a2, v4++);
      v8 += 472;
    }
    while (v7 != v4);
  }
}

void MTForceManagement::disableFingerThresholders(MTForceManagement *this)
{
  uint64_t v2 = -31;
  uint64_t v3 = 472;
  uint64_t Null = (const MTForceBehavior *)MTForceBehavior::GetNull(this);
  do
  {
    MTForceThresholding::setForceBehavior((MTForceThresholding *)(*((void *)this + 58) + v3), Null, v2 + 32);
    v3 += 472;
  }
  while (!__CFADD__(v2++, 1));
}

void MTForceManagement::disableCollectiveThresholder(MTForceThresholding **this)
{
  uint64_t Null = (const MTForceBehavior *)MTForceBehavior::GetNull((MTForceBehavior *)this);
  uint64_t v3 = this[58];

  MTForceThresholding::setForceBehavior(v3, Null, 0);
}

void MTForceManagement::setBehaviorOnOtherFingerThresholders(MTForceManagement *this, const MTForceBehavior *a2, unsigned int a3)
{
  uint64_t v5 = a3;
  uint64_t v6 = 1;
  uint64_t v7 = 472;
  do
  {
    if (v5 != v6) {
      MTForceThresholding::setForceBehavior((MTForceThresholding *)(*((void *)this + 58) + v7), a2, v6);
    }
    ++v6;
    v7 += 472;
  }
  while (v6 != 32);
}

float MTForceManagement::setOverrideBehavior(MTForceManagement *this, const MTForceBehavior *a2)
{
  int v4 = MTForceBehavior::forceSourceFingerCount(*((void *)this + 58) + 472 * *((int *)this + 64) + 176);
  if (v4 == MTForceBehavior::forceSourceFingerCount((uint64_t)a2) && *(unsigned char *)this && *(_DWORD *)a2)
  {
    int v6 = *((_DWORD *)this + 64);
    uint64_t v7 = (MTForceThresholding *)(*((void *)this + 58) + 472 * v6);
    return MTForceThresholding::updateForceBehavior(v7, a2, v6);
  }
  return result;
}

uint64_t MTActuatorManagement::MTActuatorManagement(uint64_t a1, CFTypeRef cf)
{
  *(void *)a1 = cf;
  CFRetain(cf);
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 24) = 1;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0, MEMORY[0x263EFFF90]);
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  return a1;
}

void MTActuatorManagement::~MTActuatorManagement(CFTypeRef *this)
{
  CFRelease(*this);
  *this = 0;
  if (this[1])
  {
    MTActuatorClose();
    CFRelease(this[1]);
    this[1] = 0;
  }
  CFTypeRef v2 = this[2];
  if (v2)
  {
    CFRelease(v2);
    this[2] = 0;
  }
  io_object_t v3 = *((_DWORD *)this + 14);
  if (v3)
  {
    IOObjectRelease(v3);
    *((_DWORD *)this + 14) = 0;
  }
}

uint64_t MTActuatorManagement::AppleActuatorDeviceMatchedCallback(MTActuatorManagement *this, io_iterator_t iterator)
{
  uint64_t result = IOIteratorNext(iterator);
  if (!result)
  {
    char v6 = 0;
    if (!this) {
      return result;
    }
    goto LABEL_9;
  }
  io_registry_entry_t v5 = result;
  char v6 = 0;
  do
  {
    uint64_t entryID = 0;
    if (!IORegistryEntryGetRegistryEntryID(v5, &entryID)) {
      v6 |= entryID == *((void *)this + 4);
    }
    IOObjectRelease(v5);
    uint64_t result = IOIteratorNext(iterator);
    io_registry_entry_t v5 = result;
  }
  while (result);
  if (this)
  {
LABEL_9:
    if ((v6 & 1) == 0 && *(void *)this)
    {
      if (*((void *)this + 1))
      {
        MTActuatorClose();
        CFRelease(*((CFTypeRef *)this + 1));
        *(void *)(*(void *)this + 32) = 0;
        *((void *)this + MTRestZoneIntegrator::clearMotion(this, 1) = 0;
      }
      return MTActuatorManagement::getActuatorRef(this);
    }
  }
  return result;
}

uint64_t MTActuatorManagement::setFirmwareClicks(MTActuatorManagement *this, unsigned int a2, int a3)
{
  if (*((unsigned char *)this + 24))
  {
    if (a2 > 2) {
      int v4 = 0;
    }
    else {
      int v4 = dword_240750178[a2];
    }
    if (a3) {
      int v5 = v4 | 8;
    }
    else {
      int v5 = v4;
    }
    if (MTActuatorManagement::getActuatorRef(this) && v5 != *((_DWORD *)this + 10))
    {
      *((_DWORD *)this + 10) = v5;
      MTActuatorSetFirmwareClicks();
    }
  }
  return 1;
}

uint64_t MTActuatorManagement::systemActuationsEnabledChanged(MTActuatorManagement *this)
{
  uint64_t result = MTActuatorManagement::getActuatorRef(this);
  if (result)
  {
    MTActuatorManagement::getActuatorRef(this);
    uint64_t result = MTActuatorGetSystemActuationsEnabled();
    *((unsigned char *)this + 24) = result;
  }
  return result;
}

void MTActuatorManagement::scheduleOnDispatchQueue(MTActuatorManagement *this, NSObject *a2)
{
  if (!MTDeviceSupportsActuation()) {
    return;
  }
  IONotificationPortRef v4 = IONotificationPortCreate(0);
  *((void *)this + 6) = v4;
  if (!v4) {
    return;
  }
  uint64_t valuePtr = 0;
  MTDeviceGetDeviceID();
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFNumberRef v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt64Type, &valuePtr);
  uint64_t v7 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
  uint64_t v8 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v5, 1, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  uint64_t v10 = CFDictionaryCreateMutable(v5, 1, v7, v8);
  uint64_t v11 = v10;
  if (v6) {
    BOOL v12 = Mutable == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12 || v10 == 0)
  {
    IONotificationPortSetDispatchQueue(*((IONotificationPortRef *)this + 6), a2);
    if (!v6) {
      goto LABEL_17;
    }
  }
  else
  {
    CFDictionarySetValue(v10, @"Multitouch Actuator ID", v6);
    CFDictionarySetValue(Mutable, @"IOPropertyMatch", v11);
    CFRetain(Mutable);
    if (!IOServiceAddMatchingNotification(*((IONotificationPortRef *)this + 6), "IOServiceFirstMatch", Mutable, (IOServiceMatchingCallback)MTActuatorManagement::AppleActuatorDeviceMatchedCallback, this, (io_iterator_t *)this + 14))MTActuatorManagement::AppleActuatorDeviceMatchedCallback(this, *((_DWORD *)this + 14)); {
    IONotificationPortSetDispatchQueue(*((IONotificationPortRef *)this + 6), a2);
    }
  }
  CFRelease(v6);
LABEL_17:
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v11) {
    CFRelease(v11);
  }
}

void MTActuatorManagement::unscheduleFromDispatchQueue(MTActuatorManagement *this, dispatch_queue_t queue)
{
  dispatch_assert_queue_not_V2(queue);
  io_object_t v3 = (IONotificationPort *)*((void *)this + 6);
  if (v3)
  {
    IONotificationPortDestroy(v3);
    *((void *)this + 6) = 0;
  }
}

uint64_t MTActuatorManagement::reloadActuations(MTActuatorManagement *this)
{
  uint64_t result = MTActuatorManagement::getActuatorRef(this);
  if (result)
  {
    uint64_t ActuatorRef = MTActuatorManagement::getActuatorRef(this);
    return MEMORY[0x270F4C560](ActuatorRef);
  }
  return result;
}

uint64_t MTActuatorManagement::reclaimHostClickControl(MTActuatorManagement *this)
{
  uint64_t result = MTActuatorManagement::getActuatorRef(this);
  if (result)
  {
    uint64_t ActuatorRef = MTActuatorManagement::getActuatorRef(this);
    return MEMORY[0x270F4C570](ActuatorRef);
  }
  return result;
}

void MTForceBehavior::MTForceBehavior(MTForceBehavior *this, const MTForceBehavior *a2)
{
  long long v4 = *(_OWORD *)a2;
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
  *(_OWORD *)this = v4;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)this + 3, *((const void **)a2 + 3), *((void *)a2 + 4), (uint64_t)(*((void *)a2 + 4) - *((void *)a2 + 3)) >> 2);
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((void *)this + 6, *((const void **)a2 + 6), *((void *)a2 + 7), (uint64_t)(*((void *)a2 + 7) - *((void *)a2 + 6)) >> 2);
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 1MTRestZoneIntegrator::clearMotion(this, 1) = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((void *)this + 9, *((const void **)a2 + 9), *((void *)a2 + 10), (uint64_t)(*((void *)a2 + 10) - *((void *)a2 + 9)) >> 2);
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((void *)this + 12, *((const void **)a2 + 12), *((void *)a2 + 13), (uint64_t)(*((void *)a2 + 13) - *((void *)a2 + 12)) >> 2);
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((void *)this + 15, *((const void **)a2 + 15), *((void *)a2 + 16), (uint64_t)(*((void *)a2 + 16) - *((void *)a2 + 15)) >> 2);
}

void sub_240748928(_Unwind_Exception *exception_object)
{
  uint64_t v7 = *v5;
  if (*v5)
  {
    v1[13] = v7;
    operator delete(v7);
  }
  uint64_t v8 = *v4;
  if (*v4)
  {
    v1[10] = v8;
    operator delete(v8);
  }
  uint64_t v9 = *v3;
  if (*v3)
  {
    v1[7] = v9;
    operator delete(v9);
  }
  uint64_t v10 = *v2;
  if (*v2)
  {
    v1[4] = v10;
    operator delete(v10);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<std::vector<MTForceBehavior>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<MTForceBehavior>>::__vallocate[abi:ne180100](a1, a2);
    long long v4 = (char *)a1[1];
    size_t v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_240748A20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *std::vector<std::vector<MTForceBehavior>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<MTForceBehavior>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<MTForceBehavior>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(24 * a2);
}

uint64_t std::vector<MTForceBehavior>::__push_back_slow_path<MTForceBehavior const&>(uint64_t *a1, const MTForceBehavior *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x1C71C71C71C71C7) {
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x8E38E38E38E38E39 * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0xE38E38E38E38E3) {
    unint64_t v9 = 0x1C71C71C71C71C7;
  }
  else {
    unint64_t v9 = v5;
  }
  long long v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTForceBehavior>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v13 = v10;
  float v14 = (MTForceBehavior *)&v10[144 * v4];
  BOOL v16 = &v10[144 * v9];
  MTForceBehavior::MTForceBehavior(v14, a2);
  BOOL v15 = (char *)v14 + 144;
  std::vector<MTForceBehavior>::__swap_out_circular_buffer(a1, &v13);
  uint64_t v11 = a1[1];
  std::__split_buffer<MTForceBehavior>::~__split_buffer(&v13);
  return v11;
}

void sub_240748BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

uint64_t std::vector<MTForceBehavior>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MTForceBehavior>,std::reverse_iterator<MTForceBehavior*>,std::reverse_iterator<MTForceBehavior*>,std::reverse_iterator<MTForceBehavior*>>((uint64_t)(a1 + 2), a1[1], (const MTForceBehavior *)a1[1], *a1, (const MTForceBehavior *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<MTForceBehavior>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1C71C71C71C71C8) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(144 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MTForceBehavior>,std::reverse_iterator<MTForceBehavior*>,std::reverse_iterator<MTForceBehavior*>,std::reverse_iterator<MTForceBehavior*>>(uint64_t a1, uint64_t a2, const MTForceBehavior *a3, uint64_t a4, const MTForceBehavior *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + MTRestZoneIntegrator::clearMotion(this, 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  unint64_t v13 = 0xAAAAAAAAAAAAAA00;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    unint64_t v9 = a3;
    do
    {
      unint64_t v9 = (const MTForceBehavior *)((char *)v9 - 144);
      MTForceBehavior::MTForceBehavior((MTForceBehavior *)(v7 - 144), v9);
      uint64_t v7 = *((void *)&v15 + 1) - 144;
      *((void *)&v15 + 1) -= 144;
    }
    while (v9 != a5);
    uint64_t v10 = v15;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTForceBehavior>,std::reverse_iterator<MTForceBehavior*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

void sub_240748D68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<MTForceBehavior>,std::reverse_iterator<MTForceBehavior*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<MTForceBehavior>,std::reverse_iterator<MTForceBehavior*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<MTForceBehavior>,std::reverse_iterator<MTForceBehavior*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(void **)(a1[2] + 8);
  CFTypeRef v2 = *(void **)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator<MTForceBehavior>::destroy[abi:ne180100](v3, v1);
      v1 += 18;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<MTForceBehavior>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<MTForceBehavior>::clear[abi:ne180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 144;
    std::allocator<MTForceBehavior>::destroy[abi:ne180100](v4, (void *)(i - 144));
  }
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,MTForceBehavior *,MTForceBehavior *,MTForceBehavior *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      MTForceBehavior::operator=(a3, v4);
      v4 += 144;
      a3 += 144;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

void *std::vector<MTForceThresholding>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<MTForceThresholding>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (MTForceThresholding *)a1[1];
    uint64_t v5 = 472 * a2;
    uint64_t v6 = (char *)v4 + 472 * a2;
    do
    {
      MTForceThresholding::MTForceThresholding(v4);
      uint64_t v4 = (MTForceThresholding *)((char *)v4 + 472);
      v5 -= 472;
    }
    while (v5);
    a1[1] = v6;
  }
  return a1;
}

void sub_240748F64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *std::vector<MTForceThresholding>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x8AD8F2FBA93869) {
    std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTForceThresholding>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[472 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<MTForceThresholding>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x8AD8F2FBA93869) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(472 * a2);
}

os_log_t __MTLoggingPlugin_block_invoke()
{
  os_log_t result = os_log_create("com.apple.Multitouch", "Plugin");
  MTLoggingPlugin___logObunint64_t j = (uint64_t)result;
  return result;
}

uint64_t MTForceManagerLite::MTForceManagerLite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  *(unsigned char *)a1 = 0;
  *(void *)(a1 + 40) = a5;
  if (MTDeviceGetForceThresholdForMotion())
  {
    *(void *)(a1 + 12) = 0x4366000043110000;
    MTDeviceGetDeviceID();
    uint64_t v6 = MTLoggingPlugin();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_7;
    }
    double v7 = *(float *)(a1 + 12);
    double v8 = *(float *)(a1 + 16);
    *(_DWORD *)buf = 134218496;
    double v15 = v7;
    __int16 v16 = 2048;
    double v17 = v8;
    __int16 v18 = 2048;
    uint64_t v19 = 0;
    unint64_t v9 = "Init from default %f %f (deviceID 0x%llX)";
  }
  else
  {
    *(float *)(a1 + 12) = (float)0;
    *(float *)(a1 + 16) = (float)0;
    MTDeviceGetDeviceID();
    uint64_t v6 = MTLoggingPlugin();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_7;
    }
    double v10 = *(float *)(a1 + 12);
    double v11 = *(float *)(a1 + 16);
    *(_DWORD *)buf = 134218496;
    double v15 = v10;
    __int16 v16 = 2048;
    double v17 = v11;
    __int16 v18 = 2048;
    uint64_t v19 = 0;
    unint64_t v9 = "Init from MTDeviceRef %f %f (deviceID 0x%llX)";
  }
  _os_log_impl(&dword_2406FB000, v6, OS_LOG_TYPE_DEBUG, v9, buf, 0x20u);
LABEL_7:
  MTDeviceGetReport();
  MTDeviceGetDeviceID();
  BOOL v12 = MTLoggingPlugin();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    double v15 = 0.0;
    _os_log_impl(&dword_2406FB000, v12, OS_LOG_TYPE_DEFAULT, "Can't fetch Orb spec from FW, falling back to default. (deviceID 0x%llX)", buf, 0xCu);
  }
  *(float *)(a1 + 20) = 30.0;
  *(unsigned char *)(a1 + MTRestZoneIntegrator::clearMotion(this, 1) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 24) = 1050253722;
  return a1;
}

void MTForceManagerLite::updatePaths(MTForceManagerLite *this, const MTPathStates *a2)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  float v3 = 0.0;
  uint64_t v4 = -18600;
  do
  {
    memcpy(__dst, &unk_2407501C8, 0x258uLL);
    uint64_t v5 = *((void *)a2 + 35);
    *(void *)&__dst[0] = &unk_26F4D93E8;
    uint64_t v6 = v5 + v4;
    memcpy((char *)__dst + 8, (const void *)(v5 + v4 + 19208), 0x11CuLL);
    *((void *)&__dst[18] + MTRestZoneIntegrator::clearMotion(this, 1) = &unk_26F4DB4E0;
    long long v7 = *(_OWORD *)(v6 + 19536);
    long long v8 = *(_OWORD *)(v6 + 19520);
    __dst[19] = *(_OWORD *)(v6 + 19504);
    __dst[20] = v8;
    __dst[21] = v7;
    long long v9 = *(_OWORD *)(v6 + 19552);
    long long v10 = *(_OWORD *)(v6 + 19600);
    long long v11 = *(_OWORD *)(v6 + 19568);
    __dst[24] = *(_OWORD *)(v6 + 19584);
    __dst[25] = v10;
    __dst[22] = v9;
    __dst[23] = v11;
    long long v12 = *(_OWORD *)(v6 + 19632);
    long long v13 = *(_OWORD *)(v6 + 19664);
    long long v14 = *(_OWORD *)(v6 + 19616);
    __dst[28] = *(_OWORD *)(v6 + 19648);
    __dst[29] = v13;
    __dst[26] = v14;
    __dst[27] = v12;
    long long v15 = *(_OWORD *)(v6 + 19696);
    long long v16 = *(_OWORD *)(v6 + 19728);
    long long v17 = *(_OWORD *)(v6 + 19680);
    __dst[32] = *(_OWORD *)(v6 + 19712);
    __dst[33] = v16;
    __dst[30] = v17;
    __dst[31] = v15;
    long long v18 = *(_OWORD *)(v6 + 19760);
    long long v19 = *(_OWORD *)(v6 + 19776);
    long long v20 = *(_OWORD *)(v6 + 19744);
    *(void *)&__dst[37] = *(void *)(v6 + 19792);
    __dst[35] = v18;
    __dst[36] = v19;
    __dst[34] = v20;
    if ((HIDWORD(__dst[2]) - 3) <= 1 && !MTParserPath::isEdgeContact((MTParserPath *)__dst)) {
      float v3 = v3 + *((float *)&__dst[4] + 3);
    }
    MTParserPath::~MTParserPath((MTParserPath *)__dst);
    v4 += 600;
  }
  while (v4);
  float v21 = *((float *)this + 1);
  if (v3 > v21 || (float v3 = v3 + *((float *)this + 5), v3 < v21))
  {
    *((float *)this + MTRestZoneIntegrator::clearMotion(this, 1) = v3;
    float v21 = v3;
  }
  float v22 = (float)(v21 - *((float *)this + 3)) / (float)(*((float *)this + 4) - *((float *)this + 3));
  if (v22 > 1.0)
  {
    float v23 = *((float *)this + 6);
    float v24 = 0.01;
    if (v23 > 0.0) {
      float v24 = *((float *)this + 6);
    }
    float v22 = (float)(v23 * (float)(1.0 - expf((float)(1.0 - v22) / v24))) + 1.0;
  }
  if (*((unsigned char *)this + 1))
  {
    if (v22 >= 0.0) {
      float v22 = fmaxf(v22, 1.0);
    }
    else {
      *((unsigned char *)this + MTRestZoneIntegrator::clearMotion(this, 1) = 0;
    }
  }
  else if (v22 >= 1.0)
  {
    *((unsigned char *)this + MTRestZoneIntegrator::clearMotion(this, 1) = 1;
    MTDeviceGetDeviceID();
    long long v25 = MTLoggingPlugin();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
    {
      int v26 = *((_DWORD *)this + 7);
      double v27 = *((float *)this + 3);
      double v28 = *((float *)this + 4);
      double v29 = *((float *)this + 5);
      LODWORD(__dst[0]) = 67110144;
      DWORD1(__dst[0]) = v26;
      WORD4(__dst[0]) = 2048;
      *(double *)((char *)__dst + 10) = v27;
      WORD1(__dst[1]) = 2048;
      *(double *)((char *)&__dst[1] + 4) = v28;
      WORD6(__dst[1]) = 2048;
      *(double *)((char *)&__dst[1] + 14) = v29;
      WORD3(__dst[2]) = 2048;
      *((void *)&__dst[2] + MTRestZoneIntegrator::clearMotion(this, 1) = 0;
      _os_log_impl(&dword_2406FB000, v25, OS_LOG_TYPE_DEBUG, "Force activated : Motion (%d) Thresholds (%f, %f) Hysteresis (%f) (deviceID 0x%llX)", (uint8_t *)__dst, 0x30u);
    }
  }
  *((float *)this + 2) = fmaxf(v22, 0.0);
  MTForceManagerLite::updateMotion((uint64_t)this, *((_DWORD *)this + 8));
}

void sub_2407495B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

void MTForceManagerLite::updateMotion(uint64_t a1, int a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (a2 <= 4)
  {
    *(_DWORD *)(a1 + 32) = a2;
    if (*(float *)(a1 + 4) <= 50.0 && *(_DWORD *)(a1 + 28) != a2)
    {
      if (MTDeviceGetForceThresholdForMotion())
      {
        *(void *)(a1 + 12) = _defaultThresholds[a2];
        MTDeviceGetDeviceID();
        uint64_t v4 = MTLoggingPlugin();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          double v5 = *(float *)(a1 + 12);
          double v6 = *(float *)(a1 + 16);
          *(_DWORD *)buf = 67109888;
          int v11 = a2;
          __int16 v12 = 2048;
          double v13 = v5;
          __int16 v14 = 2048;
          double v15 = v6;
          __int16 v16 = 2048;
          uint64_t v17 = 0;
          long long v7 = "Default motion %d %f %f (deviceID 0x%llX)";
LABEL_9:
          _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_DEBUG, v7, buf, 0x26u);
        }
      }
      else
      {
        *(float *)(a1 + 12) = (float)0;
        *(float *)(a1 + 16) = (float)0;
        MTDeviceGetDeviceID();
        uint64_t v4 = MTLoggingPlugin();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          double v8 = *(float *)(a1 + 12);
          double v9 = *(float *)(a1 + 16);
          *(_DWORD *)buf = 67109888;
          int v11 = a2;
          __int16 v12 = 2048;
          double v13 = v8;
          __int16 v14 = 2048;
          double v15 = v9;
          __int16 v16 = 2048;
          uint64_t v17 = 0;
          long long v7 = "MTDeviceRef motion %d %f %f (deviceID 0x%llX)";
          goto LABEL_9;
        }
      }
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 32);
    }
  }
}

void MTInterferenceMonitor::MTInterferenceMonitor(MTInterferenceMonitor *this)
{
  *((void *)this + 3) = 0;
  *(void *)this = &unk_26F4DB6A0;
  *((void *)this + MTRestZoneIntegrator::clearMotion(this, 1) = 0;
  *(_DWORD *)((char *)this + 15) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(void *)((char *)this + 87) = 0;
}

{
  *((void *)this + 3) = 0;
  *(void *)this = &unk_26F4DB6A0;
  *((void *)this + MTRestZoneIntegrator::clearMotion(this, 1) = 0;
  *(_DWORD *)((char *)this + 15) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(void *)((char *)this + 87) = 0;
}

void MTInterferenceMonitor::~MTInterferenceMonitor(MTInterferenceMonitor *this)
{
  *(void *)this = &unk_26F4DB6A0;
  if (*((unsigned char *)this + 16)) {
    MTInterferenceMonitor::_stop(this);
  }
  uint64_t v2 = (void *)*((void *)this + 8);
  if (v2)
  {
    *((void *)this + 9) = v2;
    operator delete(v2);
  }
  float v3 = (void *)*((void *)this + 5);
  if (v3)
  {
    *((void *)this + 6) = v3;
    operator delete(v3);
  }
}

{
  uint64_t vars8;

  MTInterferenceMonitor::~MTInterferenceMonitor(this);

  JUMPOUT(0x2455F6CE0);
}

uint64_t MTInterferenceMonitor::_stop(MTInterferenceMonitor *this)
{
  if (!*((unsigned char *)this + 16)) {
    return 3758096385;
  }
  notify_cancel(*((_DWORD *)this + 8));
  uint64_t v2 = *((void *)this + 3);
  if (v2)
  {
    dispatch_release(v2);
    *((void *)this + 3) = 0;
  }
  (*(void (**)(MTInterferenceMonitor *))(*(void *)this + 72))(this);
  float v3 = (const void *)*((void *)this + 1);
  if (v3)
  {
    CFRelease(v3);
    *((void *)this + MTRestZoneIntegrator::clearMotion(this, 1) = 0;
  }
  uint64_t result = 0;
  *((unsigned char *)this + 16) = 0;
  return result;
}

uint64_t MTInterferenceMonitor::start(uint64_t a1, NSObject *a2, CFTypeRef cf)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t result = 3758097090;
  if (a2 && cf)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      return 3758097106;
    }
    else
    {
      *(void *)(a1 + 8) = CFRetain(cf);
      *(unsigned char *)(a1 + 17) = MTDeviceSupportsWirelessChargingNotification();
      *(unsigned char *)(a1 + 18) = MTDeviceSupportsUSBChargingNotification();
      uint64_t v14 = 0;
      MTDeviceGetDeviceID();
      double v6 = MTLoggingPlugin();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        int v7 = *(unsigned __int8 *)(a1 + 18);
        *(_DWORD *)buf = 67109376;
        int v16 = v7;
        __int16 v17 = 2048;
        uint64_t v18 = v14;
        _os_log_impl(&dword_2406FB000, v6, OS_LOG_TYPE_INFO, "device support usb charging notification = %d (deviceID 0x%llX)", buf, 0x12u);
      }
      *(void *)(a1 + 24) = a2;
      dispatch_retain(a2);
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
      if (!result)
      {
        if (*(unsigned char *)(a1 + 17))
        {
          double v8 = (int *)(a1 + 32);
          double v9 = *(NSObject **)(a1 + 24);
          if (*(unsigned char *)(a1 + 18))
          {
            v13[0] = MEMORY[0x263EF8330];
            v13[1] = 0x40000000;
            v13[2] = ___ZN21MTInterferenceMonitor5startEP16dispatch_queue_sP10__MTDevice_block_invoke;
            v13[3] = &__block_descriptor_tmp_4;
            void v13[4] = a1;
            long long v10 = v13;
          }
          else
          {
            handler[0] = MEMORY[0x263EF8330];
            handler[1] = 0x40000000;
            handler[2] = ___ZN21MTInterferenceMonitor5startEP16dispatch_queue_sP10__MTDevice_block_invoke_2;
            handler[3] = &__block_descriptor_tmp_2;
            handler[4] = a1;
            long long v10 = handler;
          }
        }
        else
        {
          if (!*(unsigned char *)(a1 + 18)) {
            return 0;
          }
          double v8 = (int *)(a1 + 32);
          double v9 = *(NSObject **)(a1 + 24);
          v11[0] = MEMORY[0x263EF8330];
          v11[1] = 0x40000000;
          v11[2] = ___ZN21MTInterferenceMonitor5startEP16dispatch_queue_sP10__MTDevice_block_invoke_3;
          v11[3] = &__block_descriptor_tmp_3;
          v11[4] = a1;
          long long v10 = v11;
        }
        notify_register_dispatch("com.apple.system.powersources", v8, v9, v10);
        uint64_t result = 0;
        *(unsigned char *)(a1 + 16) = 1;
      }
    }
  }
  return result;
}

uint64_t ___ZN21MTInterferenceMonitor5startEP16dispatch_queue_sP10__MTDevice_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(unsigned char **)(a1 + 32);
  int v2 = (*(uint64_t (**)(unsigned char *))(*(void *)v1 + 16))(v1);
  if (v1[92] != v2)
  {
    v1[92] = v2;
    (*(void (**)(unsigned char *))(*(void *)v1 + 32))(v1);
  }
  uint64_t result = (*(uint64_t (**)(unsigned char *))(*(void *)v1 + 24))(v1);
  if (v1[94] != result)
  {
    v1[94] = result;
    uint64_t v4 = *(uint64_t (**)(unsigned char *))(*(void *)v1 + 48);
    return v4(v1);
  }
  return result;
}

uint64_t ___ZN21MTInterferenceMonitor5startEP16dispatch_queue_sP10__MTDevice_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(unsigned char **)(a1 + 32);
  uint64_t result = (*(uint64_t (**)(unsigned char *))(*(void *)v1 + 16))(v1);
  if (v1[92] != result)
  {
    v1[92] = result;
    float v3 = *(uint64_t (**)(unsigned char *))(*(void *)v1 + 32);
    return v3(v1);
  }
  return result;
}

uint64_t ___ZN21MTInterferenceMonitor5startEP16dispatch_queue_sP10__MTDevice_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(unsigned char **)(a1 + 32);
  uint64_t result = (*(uint64_t (**)(unsigned char *))(*(void *)v1 + 24))(v1);
  if (v1[94] != result)
  {
    v1[94] = result;
    float v3 = *(uint64_t (**)(unsigned char *))(*(void *)v1 + 48);
    return v3(v1);
  }
  return result;
}

uint64_t MTInterferenceMonitor::restoreStateToDevice(MTInterferenceMonitor *this)
{
  uint64_t result = 3758097112;
  if (*((unsigned char *)this + 16))
  {
    if (!*((unsigned char *)this + 17)
      || (uint64_t result = (*(uint64_t (**)(MTInterferenceMonitor *))(*(void *)this + 32))(this), !result)
      && (uint64_t result = (*(uint64_t (**)(MTInterferenceMonitor *))(*(void *)this + 40))(this), !result))
    {
      if (*((unsigned char *)this + 18))
      {
        float v3 = *(uint64_t (**)(MTInterferenceMonitor *))(*(void *)this + 48);
        return v3(this);
      }
    }
  }
  return result;
}

uint64_t MTInterferenceMonitor::powerDriverChangedNotification(uint64_t this, void *a2, int a3, unsigned int a4, void *a5)
{
  if (a3 == -536870896) {
    return (*(uint64_t (**)(void))(*(void *)this + 72))();
  }
  return this;
}

uint64_t MTInterferenceMonitor::cachePowerSourceDrivers(io_iterator_t *this)
{
  (*(void (**)(io_iterator_t *))(*(void *)this + 72))(this);
  CFDictionaryRef v2 = IOServiceMatching("IOPMPowerSource");
  if (!v2) {
    return 3758097084;
  }
  CFDictionaryRef v3 = v2;
  uint64_t MatchingServices = IOServiceGetMatchingServices(0, v2, this + 22);
  if (MatchingServices)
  {
    uint64_t v22 = MatchingServices;
    CFRelease(v3);
  }
  else
  {
    io_object_t v5 = IOIteratorNext(this[22]);
    if (v5)
    {
      io_service_t v6 = v5;
      int v7 = (char **)(this + 16);
      double v8 = (void **)(this + 10);
      while (1)
      {
        io_object_t notification = -1431655766;
        double v9 = IONotificationPortCreate(0);
        IONotificationPortSetDispatchQueue(v9, *((dispatch_queue_t *)this + 3));
        int v11 = (IONotificationPort **)*((void *)this + 9);
        unint64_t v10 = *((void *)this + 10);
        if ((unint64_t)v11 >= v10)
        {
          uint64_t v13 = ((char *)v11 - *v7) >> 3;
          if ((unint64_t)(v13 + 1) >> 61) {
            std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v14 = v10 - (void)*v7;
          uint64_t v15 = v14 >> 2;
          if (v14 >> 2 <= (unint64_t)(v13 + 1)) {
            uint64_t v15 = v13 + 1;
          }
          if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v16 = v15;
          }
          if (v16) {
            __int16 v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<MTPoint>>((uint64_t)(this + 20), v16);
          }
          else {
            __int16 v17 = 0;
          }
          uint64_t v18 = (IONotificationPort **)&v17[8 * v13];
          float *v18 = v9;
          __int16 v12 = v18 + 1;
          long long v20 = (char *)*((void *)this + 8);
          uint64_t v19 = (char *)*((void *)this + 9);
          if (v19 != v20)
          {
            do
            {
              float v21 = (IONotificationPort *)*((void *)v19 - 1);
              v19 -= 8;
              *--uint64_t v18 = v21;
            }
            while (v19 != v20);
            uint64_t v19 = *v7;
          }
          *((void *)this + 8) = v18;
          *((void *)this + 9) = v12;
          *((void *)this + 10) = &v17[8 * v16];
          if (v19) {
            operator delete(v19);
          }
        }
        else
        {
          *int v11 = v9;
          __int16 v12 = v11 + 1;
        }
        *((void *)this + 9) = v12;
        uint64_t v22 = IOServiceAddInterestNotification(v9, v6, "IOGeneralInterest", (IOServiceInterestCallback)MTInterferenceMonitor::powerDriverChangedNotification, this, &notification);
        IOObjectRelease(v6);
        if (v22) {
          break;
        }
        float v24 = (char *)*((void *)this + 6);
        unint64_t v23 = *((void *)this + 7);
        if ((unint64_t)v24 >= v23)
        {
          int v26 = (char *)*v8;
          uint64_t v27 = (v24 - (unsigned char *)*v8) >> 2;
          unint64_t v28 = v27 + 1;
          if ((unint64_t)(v27 + 1) >> 62) {
            std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v29 = v23 - (void)v26;
          if (v29 >> 1 > v28) {
            unint64_t v28 = v29 >> 1;
          }
          if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v30 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v30 = v28;
          }
          if (v30)
          {
            unint64_t v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(this + 14), v30);
            int v26 = (char *)*((void *)this + 5);
            float v24 = (char *)*((void *)this + 6);
          }
          else
          {
            unint64_t v31 = 0;
          }
          uint64_t v32 = (io_object_t *)&v31[4 * v27];
          *uint64_t v32 = notification;
          long long v25 = v32 + 1;
          while (v24 != v26)
          {
            io_object_t v33 = *((_DWORD *)v24 - 1);
            v24 -= 4;
            *--uint64_t v32 = v33;
          }
          *((void *)this + 5) = v32;
          *((void *)this + 6) = v25;
          *((void *)this + 7) = &v31[4 * v30];
          if (v26) {
            operator delete(v26);
          }
        }
        else
        {
          *(_DWORD *)float v24 = notification;
          long long v25 = v24 + 4;
        }
        *((void *)this + 6) = v25;
        io_service_t v6 = IOIteratorNext(this[22]);
        if (!v6) {
          goto LABEL_39;
        }
      }
    }
    else
    {
LABEL_39:
      MEMORY[0x2455F62D0](this[22]);
      return 0;
    }
  }
  return v22;
}

void MTInterferenceMonitor::releaseCachedPowerDrivers(MTInterferenceMonitor *this)
{
  io_object_t v2 = *((_DWORD *)this + 22);
  if (v2)
  {
    IOObjectRelease(v2);
    *((_DWORD *)this + 22) = 0;
  }
  uint64_t v4 = *((void *)this + 5);
  for (uint64_t i = *((void *)this + 6); v4 != i; *((void *)this + 6) = i)
  {
    IOObjectRelease(*(_DWORD *)(i - 4));
    uint64_t v4 = *((void *)this + 5);
    uint64_t i = *((void *)this + 6) - 4;
  }
  uint64_t v6 = *((void *)this + 8);
  for (uint64_t j = *((void *)this + 9); v6 != j; *((void *)this + 9) = j)
  {
    IONotificationPortDestroy(*(IONotificationPortRef *)(j - 8));
    uint64_t v6 = *((void *)this + 8);
    uint64_t j = *((void *)this + 9) - 8;
  }
}

uint64_t MTInterferenceMonitor::hasEnteredWirelessField(MTInterferenceMonitor *this)
{
  char context = 0;
  io_iterator_t v2 = *((_DWORD *)this + 22);
  if (!v2 || !IOIteratorIsValid(v2)) {
    (*(void (**)(MTInterferenceMonitor *))(*(void *)this + 64))(this);
  }
  uint64_t result = IOIteratorIsValid(*((_DWORD *)this + 22));
  if (result)
  {
    MEMORY[0x2455F62D0](*((unsigned int *)this + 22));
    uint64_t result = IOIteratorNext(*((_DWORD *)this + 22));
    if (result)
    {
      io_registry_entry_t v4 = result;
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      do
      {
        CFArrayRef CFProperty = (const __CFArray *)IORegistryEntryCreateCFProperty(v4, @"AppleRawAdapterDetails", v5, 0);
        if (CFProperty)
        {
          CFArrayRef v7 = CFProperty;
          v9.length = CFArrayGetCount(CFProperty);
          v9.CFIndex location = 0;
          CFArrayApplyFunction(v7, v9, (CFArrayApplierFunction)MTInterferenceMonitor::isWirelessChargingAvailable, &context);
          CFRelease(v7);
        }
        IOObjectRelease(v4);
        io_registry_entry_t v4 = IOIteratorNext(*((_DWORD *)this + 22));
      }
      while (v4);
      return context != 0;
    }
  }
  return result;
}

uint64_t MTInterferenceMonitor::isWirelessChargingAvailable(uint64_t this, BOOL *a2, void *a3)
{
  if (this)
  {
    if (a2)
    {
      CFDictionaryRef v4 = (const __CFDictionary *)this;
      CFTypeID v5 = CFGetTypeID((CFTypeRef)this);
      this = CFDictionaryGetTypeID();
      if (v5 == this)
      {
        value = (void *)0xAAAAAAAAAAAAAAAALL;
        this = CFDictionaryGetValueIfPresent(v4, @"IsWireless", (const void **)&value);
        if (this)
        {
          CFTypeID v6 = CFGetTypeID(value);
          this = CFBooleanGetTypeID();
          if (v6 == this)
          {
            this = CFBooleanGetValue((CFBooleanRef)value);
            *a2 = (*a2 | this) != 0;
          }
        }
      }
    }
  }
  return this;
}

uint64_t MTInterferenceMonitor::hasConnectedtoUSB(MTInterferenceMonitor *this)
{
  char context = 0;
  io_iterator_t v2 = *((_DWORD *)this + 22);
  if (!v2 || !IOIteratorIsValid(v2)) {
    (*(void (**)(MTInterferenceMonitor *))(*(void *)this + 64))(this);
  }
  uint64_t result = IOIteratorIsValid(*((_DWORD *)this + 22));
  if (result)
  {
    MEMORY[0x2455F62D0](*((unsigned int *)this + 22));
    uint64_t result = IOIteratorNext(*((_DWORD *)this + 22));
    if (result)
    {
      io_registry_entry_t v4 = result;
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      do
      {
        CFArrayRef CFProperty = (const __CFArray *)IORegistryEntryCreateCFProperty(v4, @"AppleRawAdapterDetails", v5, 0);
        if (CFProperty)
        {
          CFArrayRef v7 = CFProperty;
          v9.length = CFArrayGetCount(CFProperty);
          v9.CFIndex location = 0;
          CFArrayApplyFunction(v7, v9, (CFArrayApplierFunction)MTInterferenceMonitor::isUSBChargingAvailable, &context);
          CFRelease(v7);
        }
        IOObjectRelease(v4);
        io_registry_entry_t v4 = IOIteratorNext(*((_DWORD *)this + 22));
      }
      while (v4);
      return context != 0;
    }
  }
  return result;
}

uint64_t MTInterferenceMonitor::isUSBChargingAvailable(uint64_t this, unsigned char *a2, void *a3)
{
  if (this)
  {
    if (a2)
    {
      CFDictionaryRef v4 = (const __CFDictionary *)this;
      CFTypeID v5 = CFGetTypeID((CFTypeRef)this);
      this = CFDictionaryGetTypeID();
      if (v5 == this)
      {
        value = (void *)0xAAAAAAAAAAAAAAAALL;
        int valuePtr = -1431655766;
        this = CFDictionaryGetValueIfPresent(v4, @"FamilyCode", (const void **)&value);
        if (this)
        {
          CFTypeID v6 = CFGetTypeID(value);
          this = CFNumberGetTypeID();
          if (v6 == this)
          {
            this = CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &valuePtr);
            if (this)
            {
              if ((valuePtr + 536854528) <= 0xA && ((1 << valuePtr) & 0x609) != 0) {
                *a2 = 1;
              }
            }
          }
        }
      }
    }
  }
  return this;
}

uint64_t MTInterferenceMonitor::sendWirelessFieldNotification(MTInterferenceMonitor *this)
{
  if (*((unsigned char *)this + 92)) {
    uint64_t v1 = 20;
  }
  else {
    uint64_t v1 = 21;
  }
  return (*(uint64_t (**)(MTInterferenceMonitor *, uint64_t))(*(void *)this + 56))(this, v1);
}

uint64_t MTInterferenceMonitor::sendWirelessFieldAgressorNotification(MTInterferenceMonitor *this)
{
  if (*((unsigned char *)this + 93)) {
    uint64_t v1 = 22;
  }
  else {
    uint64_t v1 = 23;
  }
  return (*(uint64_t (**)(MTInterferenceMonitor *, uint64_t))(*(void *)this + 56))(this, v1);
}

uint64_t MTInterferenceMonitor::sendUSBConnectionNotification(MTInterferenceMonitor *this)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 94)) {
    uint64_t v2 = 24;
  }
  else {
    uint64_t v2 = 25;
  }
  uint64_t v3 = (*(uint64_t (**)(MTInterferenceMonitor *, uint64_t))(*(void *)this + 56))(this, v2);
  if (*((unsigned char *)this + 94))
  {
    MTDeviceGetDeviceID();
    CFDictionaryRef v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v8 = 0;
      CFTypeID v5 = "usb plugged in to charge (deviceID 0x%llX)";
LABEL_9:
      _os_log_impl(&dword_2406FB000, v4, OS_LOG_TYPE_INFO, v5, buf, 0xCu);
    }
  }
  else
  {
    MTDeviceGetDeviceID();
    CFDictionaryRef v4 = MTLoggingPlugin();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v8 = 0;
      CFTypeID v5 = "usb unplugged (deviceID 0x%llX)";
      goto LABEL_9;
    }
  }
  return v3;
}

uint64_t MTInterferenceMonitor::sendEvent()
{
  return MTDeviceSetReport();
}

uint64_t MTEmbeddedStats::create(uint64_t a1)
{
  if (a1 && dispatch_queue_create("com.apple.Multitouch.EmbeddedStatistics.Queue", 0)) {
    operator new();
  }
  return 0;
}

void sub_24074A874(_Unwind_Exception *a1)
{
  MEMORY[0x2455F6CE0](v1, 0x10E0C40A92C740BLL);
  _Unwind_Resume(a1);
}

void std::shared_ptr<MTEmbeddedStatsImpl>::reset[abi:ne180100]<MTEmbeddedStatsImpl,void>(uint64_t a1, uint64_t a2)
{
  std::shared_ptr<MTEmbeddedStatsImpl>::shared_ptr[abi:ne180100]<MTEmbeddedStatsImpl,void>(&v2, a2);
}

void MTEmbeddedStats::handlePaths(MTEmbeddedStats *this, const MTPathStates *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)operator new(0x30uLL);
  shared_owners = 0;
  uint64_t v5 = 0;
  v3[1].__vftable = 0;
  CFTypeID v6 = (void **)&v3[1].__vftable;
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3[1].__shared_weak_owners_ = 0;
  p_shared_weak_owners = &v3[1].__shared_weak_owners_;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_26F4DB818;
  v3[1].__shared_owners_ = 0;
  do
  {
    uint64_t v8 = *((void *)a2 + 35);
    if ((*(_DWORD *)(v8 + 600 * v5 + 44) - 3) <= 1)
    {
      uint64_t v9 = v8 + 600 * v5;
      long long v10 = *(_OWORD *)(v9 + 72);
      long long v39 = *(_OWORD *)(v9 + 56);
      long long v40 = v10;
      long long v11 = *(_OWORD *)(v9 + 104);
      long long v41 = *(_OWORD *)(v9 + 88);
      long long v42 = v11;
      long long v12 = *(_OWORD *)(v9 + 40);
      long long v37 = *(_OWORD *)(v9 + 24);
      long long v38 = v12;
      if ((unint64_t)shared_owners >= *p_shared_weak_owners)
      {
        uint64_t v13 = (char *)*v6;
        uint64_t v14 = 0x4EC4EC4EC4EC4EC5 * ((shared_owners - (unsigned char *)*v6) >> 3);
        unint64_t v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) > 0x276276276276276) {
          std::vector<MTPoint>::__throw_length_error[abi:ne180100]();
        }
        if (0x9D89D89D89D89D8ALL * ((*p_shared_weak_owners - (uint64_t)v13) >> 3) > v15) {
          unint64_t v15 = 0x9D89D89D89D89D8ALL * ((*p_shared_weak_owners - (uint64_t)v13) >> 3);
        }
        if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * ((*p_shared_weak_owners - (uint64_t)v13) >> 3)) >= 0x13B13B13B13B13BLL) {
          unint64_t v16 = 0x276276276276276;
        }
        else {
          unint64_t v16 = v15;
        }
        if (v16)
        {
          __int16 v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TouchingContact>>((uint64_t)p_shared_weak_owners, v16);
          uint64_t v13 = (char *)v3[1].__vftable;
          shared_owners = (char *)v3[1].__shared_owners_;
        }
        else
        {
          __int16 v17 = 0;
        }
        long long v18 = v40;
        uint64_t v19 = &v17[104 * v14];
        *((_OWORD *)v19 + 2) = v39;
        *((_OWORD *)v19 + 3) = v18;
        long long v20 = v42;
        *((_OWORD *)v19 + 4) = v41;
        *((_OWORD *)v19 + 5) = v20;
        long long v21 = v38;
        *(_OWORD *)uint64_t v19 = v37;
        *((_OWORD *)v19 + MTRestZoneIntegrator::clearMotion(this, 1) = v21;
        *((void *)v19 + 12) = v5;
        if (shared_owners == v13)
        {
          unint64_t v28 = (std::__shared_weak_count_vtbl *)&v17[104 * v14];
        }
        else
        {
          uint64_t v22 = &v17[104 * v14];
          do
          {
            long long v23 = *(_OWORD *)(shared_owners - 104);
            long long v24 = *(_OWORD *)(shared_owners - 88);
            *(_OWORD *)(v22 - 72) = *(_OWORD *)(shared_owners - 72);
            *(_OWORD *)(v22 - 88) = v24;
            *(_OWORD *)(v22 - 104) = v23;
            long long v25 = *(_OWORD *)(shared_owners - 56);
            long long v26 = *(_OWORD *)(shared_owners - 40);
            long long v27 = *(_OWORD *)(shared_owners - 24);
            unint64_t v28 = (std::__shared_weak_count_vtbl *)(v22 - 104);
            *((void *)v22 - MTRestZoneIntegrator::clearMotion(this, 1) = *((void *)shared_owners - 1);
            *(_OWORD *)(v22 - 24) = v27;
            *(_OWORD *)(v22 - 40) = v26;
            *(_OWORD *)(v22 - 56) = v25;
            shared_owners -= 104;
            v22 -= 104;
          }
          while (shared_owners != v13);
        }
        shared_owners = v19 + 104;
        v3[1].__vftable = v28;
        v3[1].__shared_owners_ = (uint64_t)(v19 + 104);
        v3[1].__shared_weak_owners_ = (uint64_t)&v17[104 * v16];
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        memmove(shared_owners, (const void *)(v9 + 24), 0x60uLL);
        *((void *)shared_owners + 12) = v5;
        shared_owners += 104;
      }
      v3[1].__shared_owners_ = (uint64_t)shared_owners;
    }
    ++v5;
  }
  while (v5 != 32);
  uint64_t v29 = *(void *)this;
  unint64_t v30 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v30) {
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v31 = *(NSObject **)(v29 + 8);
  block[0] = MEMORY[0x263EF8330];
  block[1] = 3321888768;
  block[2] = ___ZN15MTEmbeddedStats11handlePathsERK12MTPathStates_block_invoke;
  block[3] = &__block_descriptor_64_e8_32c47_ZTSNSt3__110shared_ptrI19MTEmbeddedStatsImplEE48c75_ZTSNSt3__110shared_ptrINS_6vectorI15TouchingContactNS_9allocatorIS2_EEEEEE_e5_v8__0l;
  block[4] = v29;
  int v34 = v30;
  if (v30) {
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  double v35 = v3 + 1;
  double v36 = v3;
  atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  dispatch_async(v31, block);
  if (v36) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v36);
  }
  if (v34) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v34);
  }
  if (v30) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v30);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v3);
}

void sub_24074ABEC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN15MTEmbeddedStats11handlePathsERK12MTPathStates_block_invoke(uint64_t a1)
{
}

void MTEmbeddedStatsImpl::handleTouchingContacts(uint64_t a1, uint64_t *a2)
{
  MTAbsoluteTimeGetCurrent();
  double v5 = v4;
  uint64_t v6 = 0;
  uint64_t v8 = *a2;
  uint64_t v7 = a2[1];
  uint64_t v9 = (float *)(a1 + 24);
  uint64_t v10 = *a2;
  do
  {
    if (v10 == a2[1])
    {
      uint64_t v11 = 0;
    }
    else
    {
      if (v6 == *(void *)(v10 + 96)) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = 0;
      }
      v10 += 104 * (v6 == *(void *)(v10 + 96));
    }
    MTEmbeddedStatsImpl::handleContactForContactTracker(a1, v11, v9);
    ++v6;
    v9 += 16;
  }
  while (v6 != 32);
  int v12 = v7 != v8;
  if (*(unsigned __int8 *)(a1 + 16) != v12)
  {
    *(unsigned char *)(a1 + 16) = v12;
    if (v7 == v8)
    {
      *(double *)(a1 + 2072) = v5;
      bzero((void *)(a1 + 24), 0x800uLL);
      *(_WORD *)(a1 + 16) = 0;
    }
    else
    {
      MTEmbeddedStatsImpl::logDurationBetweenTouches(a1, v5);
    }
  }
}

void *__copy_helper_block_e8_32c47_ZTSNSt3__110shared_ptrI19MTEmbeddedStatsImplEE48c75_ZTSNSt3__110shared_ptrINS_6vectorI15TouchingContactNS_9allocatorIS2_EEEEEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c47_ZTSNSt3__110shared_ptrI19MTEmbeddedStatsImplEE48c75_ZTSNSt3__110shared_ptrINS_6vectorI15TouchingContactNS_9allocatorIS2_EEEEEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void MTEmbeddedStats::handleFrameHeader(uint64_t *a1, _OWORD *a2)
{
  v8[0] = *a2;
  *(_OWORD *)((char *)v8 + 12) = *(_OWORD *)((char *)a2 + 12);
  uint64_t v2 = *a1;
  uint64_t v3 = (std::__shared_weak_count *)a1[1];
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  double v4 = *(NSObject **)(v2 + 8);
  v5[0] = MEMORY[0x263EF8330];
  v5[1] = 3321888768;
  v5[2] = ___ZN15MTEmbeddedStats17handleFrameHeaderERK19MTBinaryFrameHeader_block_invoke;
  void v5[3] = &__block_descriptor_76_e8_32c47_ZTSNSt3__110shared_ptrI19MTEmbeddedStatsImplEE_e5_v8__0l;
  v5[4] = v2;
  uint64_t v6 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v7[0] = v8[0];
  *(_OWORD *)((char *)v7 + 12) = *(_OWORD *)((char *)v8 + 12);
  dispatch_async(v4, v5);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

uint64_t __copy_helper_block_e8_32c47_ZTSNSt3__110shared_ptrI19MTEmbeddedStatsImplEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_32c47_ZTSNSt3__110shared_ptrI19MTEmbeddedStatsImplEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

uint64_t MTEmbeddedStats::deviceWillReset(MTEmbeddedStatsImpl **this)
{
  return MTEmbeddedStatsImpl::updateOpenRows(*this);
}

uint64_t MTEmbeddedStatsImpl::MTEmbeddedStatsImpl(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(_WORD *)(a1 + 16) = 0;
  double v4 = (void *)(a1 + 24);
  double v5 = (_OWORD *)(a1 + 2088);
  bzero((void *)(a1 + 24), 0x809uLL);
  _OWORD *v5 = 0u;
  unsigned int v6 = time(0);
  srand(v6);
  CFRetain(*(CFTypeRef *)a1);
  dispatch_retain(*(dispatch_object_t *)(a1 + 8));
  MTEmbeddedStatsImpl::configureAWDLogging((dispatch_queue_t *)a1);
  bzero(v4, 0x800uLL);
  *(_WORD *)(a1 + 16) = 0;
  return a1;
}

void MTEmbeddedStatsImpl::configureAWDLogging(dispatch_queue_t *this)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v2 = dispatch_source_create(MEMORY[0x263EF8400], 0, 0, this[1]);
  this[261] = v2;
  if (!v2)
  {
    uint64_t v5 = 0;
    MTDeviceGetDeviceID();
    uint64_t v3 = MTLoggingPlugin();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      uint64_t v7 = v5;
      _os_log_impl(&dword_2406FB000, v3, OS_LOG_TYPE_ERROR, "Couldn't create firmware log timer (deviceID 0x%llX)", buf, 0xCu);
    }
    uint64_t v2 = this[261];
  }
  dispatch_source_set_timer(v2, 0, 0x13A52453C000uLL, 0x3B9ACA00uLL);
  v4[0] = MEMORY[0x263EF8330];
  v4[1] = 3221225472;
  v4[2] = ___ZN19MTEmbeddedStatsImpl19configureAWDLoggingEv_block_invoke;
  _DWORD v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = this;
  ___ZN19MTEmbeddedStatsImpl19configureAWDLoggingEv_block_invoke((uint64_t)v4);
  dispatch_source_set_timer(this[261], 0x13A52453C000uLL, 0x13A52453C000uLL, 0x3B9ACA00uLL);
  dispatch_source_set_event_handler(this[261], v4);
  dispatch_resume(this[261]);
}

void ___ZN19MTEmbeddedStatsImpl19configureAWDLoggingEv_block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(MTEmbeddedStatsImpl **)(a1 + 32);
  int Version = MTDeviceGetVersion();
  if (Version)
  {
    int v3 = Version;
    MTDeviceGetDeviceID();
    double v4 = MTLoggingPlugin();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)unint64_t v16 = v3;
    *(_WORD *)&v16[4] = 2048;
    *(void *)&v16[6] = 0;
    uint64_t v5 = "Couldn't read firmware version: error 0x%08X (deviceID 0x%llX)";
    unsigned int v6 = v4;
    os_log_type_t v7 = OS_LOG_TYPE_ERROR;
    uint32_t v8 = 18;
    goto LABEL_13;
  }
  uint64_t v9 = objc_alloc_init(AWDMultitouchBootEvent);
  [(AWDMultitouchBootEvent *)v9 setVersion:2863311530];
  AWDPostMetric();

  MTDeviceGetDeviceID();
  uint64_t v10 = MTLoggingPlugin();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)unint64_t v16 = -1431655766;
    *(_WORD *)&v16[4] = 2048;
    *(void *)&v16[6] = 0;
    _os_log_impl(&dword_2406FB000, v10, OS_LOG_TYPE_DEFAULT, "Logging firmware version 0x%X to AWD (deviceID 0x%llX)", buf, 0x12u);
  }
  if (MTEmbeddedStatsImpl::updateOpenRows(v1))
  {
    unint64_t v11 = *((void *)v1 + 262);
    *((void *)v1 + 262) = 0;
    int v12 = objc_alloc_init(AWDMultitouchHardwareStatus);
    for (uint64_t i = 0; i != 64; ++i)
    {
      if ((v11 >> i)) {
        [(AWDMultitouchHardwareStatus *)v12 addOpenRows:i];
      }
    }
    AWDPostMetric();

    MTDeviceGetDeviceID();
    uint64_t v14 = MTLoggingPlugin();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218240;
      *(void *)unint64_t v16 = v11;
      *(_WORD *)&v16[8] = 2048;
      *(void *)&v16[10] = 0;
      uint64_t v5 = "Logging open rows 0x%016llX to AWD (deviceID 0x%llX)";
      unsigned int v6 = v14;
      os_log_type_t v7 = OS_LOG_TYPE_DEFAULT;
      uint32_t v8 = 22;
LABEL_13:
      _os_log_impl(&dword_2406FB000, v6, v7, v5, buf, v8);
    }
  }
}

double MTEmbeddedStatsImpl::handleContactForContactTracker(uint64_t a1, uint64_t a2, float *a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  int v6 = a2 != 0;
  if (*(unsigned __int8 *)a3 == v6)
  {
    if (!a2) {
      return result;
    }
    float v7 = a3[6];
    float v8 = a3[7];
    goto LABEL_8;
  }
  *(unsigned char *)a3 = v6;
  if (a2)
  {
    MTDeviceGetDeviceID();
    uint64_t v9 = MTLoggingPlugin();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      int v10 = *(_DWORD *)(a2 + 24);
      uint64_t v11 = *(void *)(a2 + 8);
      *(_DWORD *)buf = 67109632;
      int v23 = v10;
      __int16 v24 = 2048;
      uint64_t v25 = v11;
      __int16 v26 = 2048;
      uint64_t v27 = 0;
      _os_log_impl(&dword_2406FB000, v9, OS_LOG_TYPE_DEBUG, "F%d [%f] : Touching (deviceID 0x%llX)", buf, 0x1Cu);
    }
    *((void *)a3 + MTRestZoneIntegrator::clearMotion(this, 1) = *(void *)(a2 + 8);
    *((_DWORD *)a3 + 9) = *(unsigned __int16 *)(a2 + 84);
    unsigned __int8 v12 = *(unsigned char *)(a1 + 17);
    *((unsigned char *)a3 + MTRestZoneIntegrator::clearMotion(this, 1) = v12;
    *(unsigned char *)(a1 + 17) = v12 + 1;
    uint64_t v13 = *(void *)(a2 + 68);
    *((void *)a3 + 3) = v13;
    float v8 = *((float *)&v13 + 1);
    float v7 = *(float *)&v13;
LABEL_8:
    a3[1] = *(float *)(a2 + 24);
    double v14 = *(double *)(a2 + 8);
    *((double *)a3 + 2) = v14;
    float v15 = *(float *)(a2 + 68);
    float v16 = *(float *)(a2 + 72);
    float v17 = a3[8] + sqrtf((float)((float)(v15 - v7) * (float)(v15 - v7)) + (float)((float)(v16 - v8) * (float)(v16 - v8)));
    a3[7] = v16;
    a3[8] = v17;
    a3[6] = v15;
    MTEmbeddedStatsImpl::handleContactRadiiStats(v14, *(float *)(a2 + 60), *(float *)(a2 + 64), a1, (uint64_t)a3);
    return result;
  }
  MTDeviceGetDeviceID();
  uint64_t v19 = MTLoggingPlugin();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
  {
    int v20 = *((_DWORD *)a3 + 1);
    uint64_t v21 = *((void *)a3 + 2);
    *(_DWORD *)buf = 67109632;
    int v23 = v20;
    __int16 v24 = 2048;
    uint64_t v25 = v21;
    __int16 v26 = 2048;
    uint64_t v27 = 0;
    _os_log_impl(&dword_2406FB000, v19, OS_LOG_TYPE_DEBUG, "F%d [%f] : Not touching (deviceID 0x%llX)", buf, 0x1Cu);
  }
  MTEmbeddedStatsImpl::logAndFlushRadiiStatsWithContactIdentity(a1, (unsigned int *)a3);
  double result = 0.0;
  *((_OWORD *)a3 + 2) = 0u;
  *((_OWORD *)a3 + 3) = 0u;
  *(_OWORD *)a3 = 0u;
  *((_OWORD *)a3 + MTRestZoneIntegrator::clearMotion(this, 1) = 0u;
  return result;
}

uint64_t MTEmbeddedStatsImpl::logDurationBetweenTouches(uint64_t this, double a2)
{
  v7[1] = *MEMORY[0x263EF8340];
  if (*(double *)(this + 2072) > 0.0)
  {
    uint64_t v3 = this;
    this = rand();
    HIDWORD(v4) = -1030792151 * this + 85899344;
    LODWORD(v4) = HIDWORD(v4);
    if ((v4 >> 2) <= 0x28F5C28)
    {
      double v5 = a2 - *(double *)(v3 + 2072);
      objc_msgSend(NSString, "stringWithFormat:", @"%s.%s", "com.apple.Multitouch.EmbeddedStatistics", "DurationBetweenTouches");
      int v6 = @"Duration";
      v7[0] = [NSNumber numberWithDouble:v5];
      [NSDictionary dictionaryWithObjects:v7 forKeys:&v6 count:1];
      return AnalyticsSendEventLazy();
    }
  }
  return this;
}

uint64_t MTEmbeddedStatsImpl::logAndFlushRadiiStatsWithContactIdentity(uint64_t a1, unsigned int *a2)
{
  v10[6] = *MEMORY[0x263EF8340];
  uint64_t result = rand();
  HIDWORD(v4) = -1030792151 * result + 85899344;
  LODWORD(v4) = HIDWORD(v4);
  if ((v4 >> 2) <= 0x28F5C28)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"%s.%s", "com.apple.Multitouch.EmbeddedStatistics", "LiftoffPathStats");
    v9[0] = @"MinGeometricMean";
    LODWORD(v5) = a2[10];
    v10[0] = [NSNumber numberWithFloat:v5];
    v9[1] = @"MaxGeometricMean";
    LODWORD(v6) = a2[12];
    v10[1] = [NSNumber numberWithFloat:v6];
    void v9[2] = @"EccentricityForMin";
    LODWORD(v7) = a2[11];
    v10[2] = [NSNumber numberWithFloat:v7];
    v9[3] = @"EccentricityForMax";
    LODWORD(v8) = a2[13];
    v10[3] = [NSNumber numberWithFloat:v8];
    v9[4] = @"InitialTouchIdentity";
    v10[4] = [NSNumber numberWithUnsignedInt:a2[14]];
    v9[5] = @"LiftoffTouchIdentity";
    void v10[5] = [NSNumber numberWithUnsignedInt:a2[1]];
    [NSDictionary dictionaryWithObjects:v10 forKeys:v9 count:6];
    return AnalyticsSendEventLazy();
  }
  return result;
}

void MTEmbeddedStatsImpl::handleContactRadiiStats(double a1, float a2, float a3, uint64_t a4, uint64_t a5)
{
  if (*(double *)(a5 + 8) == a1)
  {
    *(_OWORD *)(a5 + 40) = xmmword_240750450;
    *(_DWORD *)(a5 + 56) = *(_DWORD *)(a5 + 4);
    float v5 = 3.4028e38;
  }
  else
  {
    float v5 = *(float *)(a5 + 40);
  }
  float v6 = sqrtf(a2 * a3);
  float v7 = a2 / a3;
  if (v6 < v5)
  {
    *(float *)(a5 + 40) = v6;
    *(float *)(a5 + 44) = v7;
  }
  if (v6 > *(float *)(a5 + 48))
  {
    *(float *)(a5 + 48) = v6;
    *(float *)(a5 + 52) = v7;
  }
}

uint64_t ___ZN19MTEmbeddedStatsImpl18sendAnalyticsEventEP8NSStringP12NSDictionaryIS1_P8NSObjectE_block_invoke(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void std::shared_ptr<MTEmbeddedStatsImpl>::shared_ptr[abi:ne180100]<MTEmbeddedStatsImpl,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_24074B8FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<MTEmbeddedStatsImpl>::reset[abi:ne180100]((MTEmbeddedStatsImpl **)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<MTEmbeddedStatsImpl *,std::shared_ptr<MTEmbeddedStatsImpl>::__shared_ptr_default_delete<MTEmbeddedStatsImpl,MTEmbeddedStatsImpl>,std::allocator<MTEmbeddedStatsImpl>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x2455F6CE0);
}

MTEmbeddedStatsImpl *std::__shared_ptr_pointer<MTEmbeddedStatsImpl *,std::shared_ptr<MTEmbeddedStatsImpl>::__shared_ptr_default_delete<MTEmbeddedStatsImpl,MTEmbeddedStatsImpl>,std::allocator<MTEmbeddedStatsImpl>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(MTEmbeddedStatsImpl **)(a1 + 24);
  if (result)
  {
    MTEmbeddedStatsImpl::~MTEmbeddedStatsImpl(result);
    JUMPOUT(0x2455F6CE0);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<MTEmbeddedStatsImpl *,std::shared_ptr<MTEmbeddedStatsImpl>::__shared_ptr_default_delete<MTEmbeddedStatsImpl,MTEmbeddedStatsImpl>,std::allocator<MTEmbeddedStatsImpl>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void MTEmbeddedStatsImpl::~MTEmbeddedStatsImpl(MTEmbeddedStatsImpl *this)
{
  uint64_t v2 = *((void *)this + 261);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 261));
  }
  dispatch_release(*((dispatch_object_t *)this + 1));
  CFRelease(*(CFTypeRef *)this);
}

MTEmbeddedStatsImpl *std::unique_ptr<MTEmbeddedStatsImpl>::reset[abi:ne180100](MTEmbeddedStatsImpl **a1, MTEmbeddedStatsImpl *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    MTEmbeddedStatsImpl::~MTEmbeddedStatsImpl(result);
    JUMPOUT(0x2455F6CE0);
  }
  return result;
}

void std::__shared_ptr_emplace<std::vector<TouchingContact>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26F4DB818;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<TouchingContact>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26F4DB818;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x2455F6CE0);
}

void std::__shared_ptr_emplace<std::vector<TouchingContact>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TouchingContact>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(104 * a2);
}

uint64_t AWDMultitouchBootEventReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x263F62290];
  unint64_t v4 = (int *)MEMORY[0x263F62280];
  float v5 = (int *)MEMORY[0x263F62278];
  if (*(void *)(a2 + (int)*MEMORY[0x263F62290]) < *(void *)(a2 + (int)*MEMORY[0x263F62280]))
  {
    float v7 = (int *)MEMORY[0x263F62260];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v1MTRestZoneIntegrator::clearMotion(this, 1) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        char v23 = 0;
        unsigned int v24 = 0;
        uint64_t v25 = 0;
        *(unsigned char *)(a1 + 20) |= 2u;
        while (1)
        {
          uint64_t v26 = *v3;
          unint64_t v27 = *(void *)(a2 + v26);
          if (v27 == -1 || v27 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v28 = *(unsigned char *)(*(void *)(a2 + *v7) + v27);
          *(void *)(a2 + v26) = v27 + 1;
          v25 |= (unint64_t)(v28 & 0x7F) << v23;
          if ((v28 & 0x80) == 0) {
            goto LABEL_41;
          }
          v23 += 7;
          BOOL v14 = v24++ >= 9;
          if (v14)
          {
            LODWORD(v25) = 0;
            goto LABEL_43;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_41:
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v25) = 0;
        }
LABEL_43:
        *(_DWORD *)(a1 + 16) = v25;
      }
      else if ((v10 >> 3) == 1)
      {
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0;
        *(unsigned char *)(a1 + 20) |= 1u;
        while (1)
        {
          uint64_t v20 = *v3;
          unint64_t v21 = *(void *)(a2 + v20);
          if (v21 == -1 || v21 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v22 = *(unsigned char *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0) {
            goto LABEL_37;
          }
          v17 += 7;
          BOOL v14 = v18++ >= 9;
          if (v14)
          {
            uint64_t v19 = 0;
            goto LABEL_39;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_37:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v19 = 0;
        }
LABEL_39:
        *(void *)(a1 + 8) = v19;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t AWDMultitouchHardwareStatusReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x263F62290];
  unint64_t v4 = (int *)MEMORY[0x263F62280];
  float v5 = (int *)MEMORY[0x263F62278];
  if (*(void *)(a2 + (int)*MEMORY[0x263F62290]) < *(void *)(a2 + (int)*MEMORY[0x263F62280]))
  {
    float v7 = (int *)MEMORY[0x263F62260];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v1MTRestZoneIntegrator::clearMotion(this, 1) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      int v16 = v10 & 7;
      if (v15 || v16 == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        if (v16 == 2)
        {
          uint64_t result = PBReaderPlaceMark();
          if (!result) {
            return result;
          }
          while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4) && !*(unsigned char *)(a2 + *v5))
          {
            char v25 = 0;
            unsigned int v26 = 0;
            uint64_t v27 = 0;
            while (1)
            {
              uint64_t v28 = *v3;
              unint64_t v29 = *(void *)(a2 + v28);
              if (v29 == -1 || v29 >= *(void *)(a2 + *v4)) {
                break;
              }
              char v30 = *(unsigned char *)(*(void *)(a2 + *v7) + v29);
              *(void *)(a2 + v28) = v29 + 1;
              v27 |= (unint64_t)(v30 & 0x7F) << v25;
              if (v30 < 0)
              {
                v25 += 7;
                BOOL v14 = v26++ >= 9;
                if (!v14) {
                  continue;
                }
              }
              goto LABEL_39;
            }
            *(unsigned char *)(a2 + *v5) = 1;
LABEL_39:
            PBRepeatedUInt32Add();
          }
          PBReaderRecallMark();
        }
        else
        {
          char v31 = 0;
          unsigned int v32 = 0;
          uint64_t v33 = 0;
          while (1)
          {
            uint64_t v34 = *v3;
            unint64_t v35 = *(void *)(a2 + v34);
            if (v35 == -1 || v35 >= *(void *)(a2 + *v4)) {
              break;
            }
            char v36 = *(unsigned char *)(*(void *)(a2 + *v7) + v35);
            *(void *)(a2 + v34) = v35 + 1;
            v33 |= (unint64_t)(v36 & 0x7F) << v31;
            if (v36 < 0)
            {
              v31 += 7;
              BOOL v14 = v32++ >= 9;
              if (!v14) {
                continue;
              }
            }
            goto LABEL_55;
          }
          *(unsigned char *)(a2 + *v5) = 1;
LABEL_55:
          PBRepeatedUInt32Add();
        }
      }
      else if ((v10 >> 3) == 1)
      {
        char v18 = 0;
        unsigned int v19 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 40) |= 1u;
        while (1)
        {
          uint64_t v21 = *v3;
          unint64_t v22 = *(void *)(a2 + v21);
          if (v22 == -1 || v22 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v23 = *(unsigned char *)(*(void *)(a2 + *v7) + v22);
          *(void *)(a2 + v2MTRestZoneIntegrator::clearMotion(this, 1) = v22 + 1;
          v20 |= (unint64_t)(v23 & 0x7F) << v18;
          if ((v23 & 0x80) == 0) {
            goto LABEL_43;
          }
          v18 += 7;
          BOOL v14 = v19++ >= 9;
          if (v14)
          {
            uint64_t v20 = 0;
            goto LABEL_45;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_43:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v20 = 0;
        }
LABEL_45:
        *(void *)(a1 + 32) = v20;
      }
      else if ((PBReaderSkipValueWithTag() & 1) == 0)
      {
        return 0;
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void MultitouchHIDClass::start(int a1, NSObject *a2)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl(&dword_2406FB000, a2, OS_LOG_TYPE_ERROR, "Invalid parserType: %d", (uint8_t *)v2, 8u);
}

void IOHIDPlugInFactory_cold_1()
{
  uint64_t v1 = *MEMORY[0x263EF8340];
  dlerror();
  OUTLINED_FUNCTION_0();
  _os_log_error_impl(&dword_2406FB000, &_os_log_internal, OS_LOG_TYPE_ERROR, "dlopen failed for %{public}@: %{public}s", v0, 0x16u);
}

void IOHIDPlugInFactory_cold_2()
{
  uint64_t v1 = *MEMORY[0x263EF8340];
  dlerror();
  OUTLINED_FUNCTION_0();
  _os_log_error_impl(&dword_2406FB000, &_os_log_internal, OS_LOG_TYPE_ERROR, "dlsym returned null for symbol '%{public}@': %{public}s", v0, 0x16u);
}

void MTHandMotion::clearHandMotion(char a1, NSObject *a2)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 67109120;
  v2[1] = a1 & 1;
  _os_log_debug_impl(&dword_2406FB000, a2, OS_LOG_TYPE_DEBUG, "\tDHML:  MTHandMotion::resetHandMotion(%d)", (uint8_t *)v2, 8u);
}

void MTParser::retain()
{
  __assert_rtn("retain", "MTParser.cpp", 195, "_retainCount != 0");
}

void MTParser::release()
{
  __assert_rtn("release", "MTParser.cpp", 203, "_retainCount != 0");
}

void MTParserPath::filterContactForScreenUI(uint64_t a1, int *a2, os_log_t log)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  int v3 = *(_DWORD *)(a1 + 40);
  int v4 = *a2;
  int v5 = *(_DWORD *)(a1 + 144);
  v6[0] = 67109632;
  v6[1] = v3;
  __int16 v7 = 1024;
  int v8 = v4;
  __int16 v9 = 1024;
  int v10 = v5;
  _os_log_debug_impl(&dword_2406FB000, log, OS_LOG_TYPE_DEBUG, "\tDHML:  P%d Identity=%d <- %d (ignoring motion)", (uint8_t *)v6, 0x14u);
}

void MTParserPath::filterContactForScreenUI(uint64_t a1, uint64_t a2, NSObject *a3)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a1 + 40);
  v5[0] = 67109378;
  v5[1] = v4;
  __int16 v6 = 2080;
  uint64_t v7 = MTGetPathStageName();
  _os_log_debug_impl(&dword_2406FB000, a3, OS_LOG_TYPE_DEBUG, "\tDHML:  P%d Hover (stage %s -- ignoring motion)", (uint8_t *)v5, 0x12u);
}

void MTSLGLogger::registerControlInterface()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0_0(&dword_2406FB000, v0, v1, "StudyLog logger: could not create notification port for control interface", v2, v3, v4, v5, v6);
}

void MTSLGLogger::registerControlInterface(unsigned int *a1, int a2, os_log_t log)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v3 = *a1;
  v4[0] = 67109376;
  v4[1] = a2;
  __int16 v5 = 2048;
  uint64_t v6 = v3;
  _os_log_error_impl(&dword_2406FB000, log, OS_LOG_TYPE_ERROR, "StudyLog logger: could not register for control interface 0x%08x (deviceIterator: 0x%08jx)", (uint8_t *)v4, 0x12u);
}

void MTSLGLogger::addControlService()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0_0(&dword_2406FB000, v0, v1, "StudyLog logger: could not create MT device for control interface", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0_0(&dword_2406FB000, v0, v1, "StudyLog logger: could not create dispatch source for control interface", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0_0(&dword_2406FB000, v0, v1, "StudyLog logger: could not register callbacks for control interface", v2, v3, v4, v5, v6);
}

void MTSLGLogger::addControlService(int a1, NSObject *a2)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl(&dword_2406FB000, a2, OS_LOG_TYPE_ERROR, "StudyLog logger: could not start MT device for control interface 0x%08x", (uint8_t *)v2, 8u);
}

void MTSimpleEventDispatcher::retain()
{
  __assert_rtn("retain", "MTSimpleEventDispatcher.cpp", 115, "_retainCount != 0");
}

void MTSimpleEventDispatcher::release()
{
  __assert_rtn("release", "MTSimpleEventDispatcher.cpp", 123, "_retainCount != 0");
}

void MTSimpleHIDManager::retain()
{
  __assert_rtn("retain", "MTSimpleHIDManager.cpp", 227, "_retainCount != 0");
}

void MTSimpleHIDManager::release()
{
  __assert_rtn("release", "MTSimpleHIDManager.cpp", 235, "_retainCount != 0");
}

void MTSimpleHIDManager::setPowerState()
{
}

void MTSimpleHIDManager::setPowerStateWithReset()
{
}

void MTPowerLogger::retain()
{
  __assert_rtn("retain", "MTPowerLogger.mm", 72, "_retainCount != 0");
}

void MTPowerLogger::release()
{
  __assert_rtn("release", "MTPowerLogger.mm", 80, "_retainCount != 0");
}

void MTForceManagement::actuateForceAndHIDEvents(MTActuatorManagement *a1, uint64_t a2, NSObject *a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t ActuatorRef = MTActuatorManagement::getActuatorRef(a1);
  int v6 = *(unsigned __int8 *)(a2 + 594);
  int v7 = *(unsigned __int8 *)(a2 + 595);
  int v8 = 134218496;
  uint64_t v9 = ActuatorRef;
  __int16 v10 = 1024;
  int v11 = v6;
  __int16 v12 = 1024;
  int v13 = v7;
  _os_log_debug_impl(&dword_2406FB000, a3, OS_LOG_TYPE_DEBUG, "[HID] Skipping actuation : %p %u %u", (uint8_t *)&v8, 0x18u);
}

uint64_t AWDPostMetric()
{
  return MEMORY[0x270F858D0]();
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x270F18A50]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x270EE4278]();
  return result;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x270EE42F8](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x270EE4300](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x270EE4320](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x270EE4348]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x270EE4360](theArray, idx);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x270EE4528]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x270EE4530](BOOLean);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x270EE4808](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x270EE4820](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x270EE4838]();
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return (CFDateFormatterRef)MEMORY[0x270EE4870](allocator, locale, dateStyle, timeStyle);
}

CFStringRef CFDateFormatterCreateStringWithAbsoluteTime(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFAbsoluteTime at)
{
  return (CFStringRef)MEMORY[0x270EE4890](allocator, formatter, at);
}

void CFDateFormatterSetProperty(CFDateFormatterRef formatter, CFStringRef key, CFTypeRef value)
{
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x270EE4910](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EE4920](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EE4928](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x270EE4930](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x270EE4948]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x270EE4958](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x270EE4968](theDict, key, value);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x270EE4998](cf1, cf2);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x270EE4A30](cf);
}

CFTypeRef CFMakeCollectable(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x270EE4B20](cf);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x270EE4B88]();
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x270EE4BE8](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x270EE4C58]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x270EE4C70](number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return MEMORY[0x270EE4C78](number);
}

void CFPlugInAddInstanceForFactory(CFUUIDRef factoryID)
{
}

void CFPlugInRemoveInstanceForFactory(CFUUIDRef factoryID)
{
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x270EE4CD0](key, applicationID, keyExistsAndHasValidFormat);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x270EE4E10](cf);
}

void CFShow(CFTypeRef obj)
{
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x270EE5048](theString1, theString2, compareOptions);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x270EE50B8](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x270EE50E0](alloc, cStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x270EE5110](alloc, formatOptions, format);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3 = MEMORY[0x270EE5148](theString, stringToFind, compareOptions);
  result.length = v4;
  result.CFIndex location = v3;
  return result;
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x270EE5180](theString, *(void *)&encoding);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x270EE51C8](str);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x270EE5218]();
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  return (CFTimeZoneRef)MEMORY[0x270EE52E8]();
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)MEMORY[0x270EE5480](alloc, *(void *)&bytes.byte0, *(void *)&bytes.byte8);
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)MEMORY[0x270EE5498](alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6);
}

IOReturn IOAllowPowerChange(io_connect_t kernelPort, intptr_t notificationID)
{
  return MEMORY[0x270EF3EE0](*(void *)&kernelPort, notificationID);
}

CFTypeRef IOCFUnserializeBinary(const char *buffer, size_t bufferSize, CFAllocatorRef allocator, CFOptionFlags options, CFStringRef *errorString)
{
  return (CFTypeRef)MEMORY[0x270EF3F00](buffer, bufferSize, allocator, options, errorString);
}

IOReturn IODeregisterForSystemPower(io_object_t *notifier)
{
  return MEMORY[0x270EF4000](notifier);
}

uint64_t IOHIDEventAppendEvent()
{
  return MEMORY[0x270EF41E8]();
}

uint64_t IOHIDEventConformsTo()
{
  return MEMORY[0x270EF41F0]();
}

uint64_t IOHIDEventCreateBoundaryScrollEvent()
{
  return MEMORY[0x270EF4210]();
}

uint64_t IOHIDEventCreateButtonEvent()
{
  return MEMORY[0x270EF4218]();
}

uint64_t IOHIDEventCreateCopy()
{
  return MEMORY[0x270EF4228]();
}

uint64_t IOHIDEventCreateDigitizerEvent()
{
  return MEMORY[0x270EF4238]();
}

uint64_t IOHIDEventCreateDigitizerFingerEventWithQuality()
{
  return MEMORY[0x270EF4248]();
}

uint64_t IOHIDEventCreateDigitizerStylusEventWithPolarOrientation()
{
  return MEMORY[0x270EF4250]();
}

uint64_t IOHIDEventCreateDockSwipeEvent()
{
  return MEMORY[0x270EF4258]();
}

uint64_t IOHIDEventCreateFluidTouchGestureEvent()
{
  return MEMORY[0x270EF4260]();
}

uint64_t IOHIDEventCreateForceEvent()
{
  return MEMORY[0x270EF4268]();
}

uint64_t IOHIDEventCreateKeyboardEvent()
{
  return MEMORY[0x270EF4280]();
}

uint64_t IOHIDEventCreateMouseEvent()
{
  return MEMORY[0x270EF4288]();
}

uint64_t IOHIDEventCreateNavigationSwipeEvent()
{
  return MEMORY[0x270EF4290]();
}

uint64_t IOHIDEventCreatePolarOrientationEvent()
{
  return MEMORY[0x270EF4298]();
}

uint64_t IOHIDEventCreateProximtyEvent()
{
  return MEMORY[0x270EF42A0]();
}

uint64_t IOHIDEventCreateRelativePointerEvent()
{
  return MEMORY[0x270EF42A8]();
}

uint64_t IOHIDEventCreateRotationEvent()
{
  return MEMORY[0x270EF42B0]();
}

uint64_t IOHIDEventCreateScaleEvent()
{
  return MEMORY[0x270EF42B8]();
}

uint64_t IOHIDEventCreateScrollEvent()
{
  return MEMORY[0x270EF42C0]();
}

uint64_t IOHIDEventCreateSwipeEvent()
{
  return MEMORY[0x270EF42C8]();
}

uint64_t IOHIDEventCreateSymbolicHotKeyEvent()
{
  return MEMORY[0x270EF42D0]();
}

uint64_t IOHIDEventCreateTranslationEvent()
{
  return MEMORY[0x270EF42E0]();
}

uint64_t IOHIDEventCreateVelocityEvent()
{
  return MEMORY[0x270EF42E8]();
}

uint64_t IOHIDEventCreateVendorDefinedEvent()
{
  return MEMORY[0x270EF42F0]();
}

uint64_t IOHIDEventCreateZoomToggleEvent()
{
  return MEMORY[0x270EF4308]();
}

uint64_t IOHIDEventGetChildren()
{
  return MEMORY[0x270EF4310]();
}

uint64_t IOHIDEventGetDoubleValue()
{
  return MEMORY[0x270EF4320]();
}

uint64_t IOHIDEventGetEvent()
{
  return MEMORY[0x270EF4328]();
}

uint64_t IOHIDEventGetEventFlags()
{
  return MEMORY[0x270EF4330]();
}

uint64_t IOHIDEventGetFloatValue()
{
  return MEMORY[0x270EF4340]();
}

uint64_t IOHIDEventGetIntegerValue()
{
  return MEMORY[0x270EF4348]();
}

uint64_t IOHIDEventGetPhase()
{
  return MEMORY[0x270EF4358]();
}

uint64_t IOHIDEventGetScrollMomentum()
{
  return MEMORY[0x270EF4360]();
}

uint64_t IOHIDEventGetTimeStamp()
{
  return MEMORY[0x270EF4370]();
}

uint64_t IOHIDEventGetType()
{
  return MEMORY[0x270EF4380]();
}

uint64_t IOHIDEventGetVendorDefinedData()
{
  return MEMORY[0x270EF4398]();
}

uint64_t IOHIDEventIsAbsolute()
{
  return MEMORY[0x270EF43A0]();
}

uint64_t IOHIDEventRemoveEvent()
{
  return MEMORY[0x270EF43B0]();
}

uint64_t IOHIDEventSetEventFlags()
{
  return MEMORY[0x270EF43C0]();
}

uint64_t IOHIDEventSetFloatValue()
{
  return MEMORY[0x270EF43C8]();
}

uint64_t IOHIDEventSetIntegerValue()
{
  return MEMORY[0x270EF43D0]();
}

uint64_t IOHIDEventSetPhase()
{
  return MEMORY[0x270EF43D8]();
}

uint64_t IOHIDEventSetScrollMomentum()
{
  return MEMORY[0x270EF43E8]();
}

uint64_t IOHIDEventSetTimeStamp()
{
  return MEMORY[0x270EF43F8]();
}

uint64_t IOHIDEventTypeGetName()
{
  return MEMORY[0x270EF4520]();
}

uint64_t IOHIDPreferencesCopy()
{
  return MEMORY[0x270EF45C8]();
}

uint64_t IOHIDPreferencesCopyDomain()
{
  return MEMORY[0x270EF45D0]();
}

uint64_t IOHIDPreferencesSet()
{
  return MEMORY[0x270EF45D8]();
}

uint64_t IOHIDPreferencesSynchronize()
{
  return MEMORY[0x270EF45E0]();
}

BOOLean_t IOIteratorIsValid(io_iterator_t iterator)
{
  return MEMORY[0x270EF4788](*(void *)&iterator);
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return MEMORY[0x270EF4790](*(void *)&iterator);
}

void IOIteratorReset(io_iterator_t iterator)
{
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return (IONotificationPortRef)MEMORY[0x270EF47B8](*(void *)&mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x270EF4820](*(void *)&object);
}

kern_return_t IOObjectRetain(io_object_t object)
{
  return MEMORY[0x270EF4828](*(void *)&object);
}

IOReturn IOPMAssertionCreateWithName(CFStringRef AssertionType, IOPMAssertionLevel AssertionLevel, CFStringRef AssertionName, IOPMAssertionID *AssertionID)
{
  return MEMORY[0x270EF4840](AssertionType, *(void *)&AssertionLevel, AssertionName, AssertionID);
}

IOReturn IOPMAssertionRelease(IOPMAssertionID AssertionID)
{
  return MEMORY[0x270EF4868](*(void *)&AssertionID);
}

io_connect_t IORegisterForSystemPower(void *refcon, IONotificationPortRef *thePortRef, IOServiceInterestCallback callback, io_object_t *notifier)
{
  return MEMORY[0x270EF49B0](refcon, thePortRef, callback, notifier);
}

kern_return_t IORegistryEntryCreateCFProperties(io_registry_entry_t entry, CFMutableDictionaryRef *properties, CFAllocatorRef allocator, IOOptionBits options)
{
  return MEMORY[0x270EF49D0](*(void *)&entry, properties, allocator, *(void *)&options);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x270EF49D8](*(void *)&entry, key, allocator, *(void *)&options);
}

kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t *entryID)
{
  return MEMORY[0x270EF4A38](*(void *)&entry, entryID);
}

kern_return_t IORegistryEntrySetCFProperty(io_registry_entry_t entry, CFStringRef propertyName, CFTypeRef property)
{
  return MEMORY[0x270EF4A60](*(void *)&entry, propertyName, property);
}

uint64_t IOReportChannelGetCategories()
{
  return MEMORY[0x270F92708]();
}

uint64_t IOReportCopyChannelsForDriver()
{
  return MEMORY[0x270F92750]();
}

uint64_t IOReportCreateSamples()
{
  return MEMORY[0x270F92780]();
}

uint64_t IOReportCreateSubscription()
{
  return MEMORY[0x270F92798]();
}

uint64_t IOReportGetChannelCount()
{
  return MEMORY[0x270F927A0]();
}

uint64_t IOReportPrune()
{
  return MEMORY[0x270F927E8]();
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  return MEMORY[0x270EF4A80](notifyPort, *(void *)&service, interestType, callback, refCon, notification);
}

kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
{
  return MEMORY[0x270EF4A88](notifyPort, notificationType, matching, callback, refCon, notification);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return MEMORY[0x270EF4A98](*(void *)&connect);
}

kern_return_t IOServiceGetMatchingServices(mach_port_t mainPort, CFDictionaryRef matching, io_iterator_t *existing)
{
  return MEMORY[0x270EF4AB8](*(void *)&mainPort, matching, existing);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EF4AD0](name);
}

CFMutableDictionaryRef IOServiceNameMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EF4AD8](name);
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x270F95FC0]();
}

uint64_t MTAbsoluteTimeGetCurrent()
{
  return MEMORY[0x270F4C528]();
}

uint64_t MTActuatorActuate()
{
  return MEMORY[0x270F4C530]();
}

uint64_t MTActuatorClose()
{
  return MEMORY[0x270F4C538]();
}

uint64_t MTActuatorGetReport()
{
  return MEMORY[0x270F4C540]();
}

uint64_t MTActuatorGetService()
{
  return MEMORY[0x270F4C548]();
}

uint64_t MTActuatorGetSystemActuationsEnabled()
{
  return MEMORY[0x270F4C550]();
}

uint64_t MTActuatorIsOpen()
{
  return MEMORY[0x270F4C558]();
}

uint64_t MTActuatorOpen()
{
  return MEMORY[0x270F4C568]();
}

uint64_t MTActuatorSetFirmwareClicks()
{
  return MEMORY[0x270F4C578]();
}

uint64_t MTActuatorSetReport()
{
  return MEMORY[0x270F4C580]();
}

uint64_t MTContact_getEllipseEccentricity()
{
  return MEMORY[0x270F4C588]();
}

uint64_t MTContact_getEllipseOrientationDegrees()
{
  return MEMORY[0x270F4C590]();
}

uint64_t MTContact_isActive()
{
  return MEMORY[0x270F4C598]();
}

uint64_t MTDeviceCopyDeviceUsagePairs()
{
  return MEMORY[0x270F4C5A0]();
}

uint64_t MTDeviceCreateFromService()
{
  return MEMORY[0x270F4C5A8]();
}

uint64_t MTDeviceCreateMultitouchDispatchSource()
{
  return MEMORY[0x270F4C5B0]();
}

uint64_t MTDeviceDispatchKeyboardEvent()
{
  return MEMORY[0x270F4C5B8]();
}

uint64_t MTDeviceDriverIsReady()
{
  return MEMORY[0x270F4C5C0]();
}

uint64_t MTDeviceEnableBinaryFilters()
{
  return MEMORY[0x270F4C5C8]();
}

uint64_t MTDeviceEnableWorkIntervalNotification()
{
  return MEMORY[0x270F4C5D0]();
}

uint64_t MTDeviceGetAccurateMaxDigitizerPressureValue()
{
  return MEMORY[0x270F4C5D8]();
}

uint64_t MTDeviceGetCriticalErrors()
{
  return MEMORY[0x270F4C5E0]();
}

uint64_t MTDeviceGetDeviceID()
{
  return MEMORY[0x270F4C5E8]();
}

uint64_t MTDeviceGetDeviceTimestampOffset()
{
  return MEMORY[0x270F4C5F0]();
}

uint64_t MTDeviceGetExtendedMaxDigitizerPressureValue()
{
  return MEMORY[0x270F4C5F8]();
}

uint64_t MTDeviceGetFamilyID()
{
  return MEMORY[0x270F4C600]();
}

uint64_t MTDeviceGetForceThresholdForMotion()
{
  return MEMORY[0x270F4C608]();
}

uint64_t MTDeviceGetMTActuator()
{
  return MEMORY[0x270F4C610]();
}

uint64_t MTDeviceGetMaxHoverHeightValue()
{
  return MEMORY[0x270F4C618]();
}

uint64_t MTDeviceGetMinDigitizerPressureValue()
{
  return MEMORY[0x270F4C620]();
}

uint64_t MTDeviceGetMultipleFirmwaresConfig()
{
  return MEMORY[0x270F4C628]();
}

uint64_t MTDeviceGetOpenRows()
{
  return MEMORY[0x270F4C630]();
}

uint64_t MTDeviceGetParserOptions()
{
  return MEMORY[0x270F4C638]();
}

uint64_t MTDeviceGetParserType()
{
  return MEMORY[0x270F4C640]();
}

uint64_t MTDeviceGetReport()
{
  return MEMORY[0x270F4C648]();
}

uint64_t MTDeviceGetResetOnLockMs()
{
  return MEMORY[0x270F4C650]();
}

uint64_t MTDeviceGetResetOnUnlockMs()
{
  return MEMORY[0x270F4C658]();
}

uint64_t MTDeviceGetSATelemetryReportID()
{
  return MEMORY[0x270F4C660]();
}

uint64_t MTDeviceGetSensorDimensions()
{
  return MEMORY[0x270F4C668]();
}

uint64_t MTDeviceGetSensorRegionOfType()
{
  return MEMORY[0x270F4C670]();
}

uint64_t MTDeviceGetSensorSurfaceDimensions()
{
  return MEMORY[0x270F4C678]();
}

uint64_t MTDeviceGetService()
{
  return MEMORY[0x270F4C680]();
}

uint64_t MTDeviceGetSubdeviceID()
{
  return MEMORY[0x270F4C688]();
}

uint64_t MTDeviceGetSystemForceResponseEnabled()
{
  return MEMORY[0x270F4C690]();
}

uint64_t MTDeviceGetTouchSizeIdentifier()
{
  return MEMORY[0x270F4C698]();
}

uint64_t MTDeviceGetVersion()
{
  return MEMORY[0x270F4C6A0]();
}

uint64_t MTDeviceHasExpectedVersion()
{
  return MEMORY[0x270F4C6A8]();
}

uint64_t MTDeviceIsBuiltIn()
{
  return MEMORY[0x270F4C6B8]();
}

uint64_t MTDeviceIsRunning()
{
  return MEMORY[0x270F4C6C0]();
}

uint64_t MTDeviceIssueDriverRequest()
{
  return MEMORY[0x270F4C6C8]();
}

uint64_t MTDeviceNeedsFirstPowerOffSuppressed()
{
  return MEMORY[0x270F4C6D0]();
}

uint64_t MTDeviceNotifyFirstPowerOffSuppressed()
{
  return MEMORY[0x270F4C6D8]();
}

uint64_t MTDeviceNotifyWorkInterval()
{
  return MEMORY[0x270F4C6E0]();
}

uint64_t MTDevicePowerControlSupported()
{
  return MEMORY[0x270F4C6E8]();
}

uint64_t MTDevicePowerGetState()
{
  return MEMORY[0x270F4C6F0]();
}

uint64_t MTDevicePowerSetState()
{
  return MEMORY[0x270F4C6F8]();
}

uint64_t MTDeviceRelease()
{
  return MEMORY[0x270F4C700]();
}

uint64_t MTDeviceSendExternalMessage()
{
  return MEMORY[0x270F4C708]();
}

uint64_t MTDeviceSetBinaryFiltersProperty()
{
  return MEMORY[0x270F4C710]();
}

uint64_t MTDeviceSetInputDetectionCallbackTriggerMask()
{
  return MEMORY[0x270F4C718]();
}

uint64_t MTDeviceSetPickButtonShouldSendSecondaryClick()
{
  return MEMORY[0x270F4C728]();
}

uint64_t MTDeviceSetReport()
{
  return MEMORY[0x270F4C730]();
}

uint64_t MTDeviceSetSurfaceOrientation()
{
  return MEMORY[0x270F4C738]();
}

uint64_t MTDeviceSetSurfaceOrientationMode()
{
  return MEMORY[0x270F4C740]();
}

uint64_t MTDeviceSetTouchMode()
{
  return MEMORY[0x270F4C748]();
}

uint64_t MTDeviceShouldDispatchNormalizedVelocity()
{
  return MEMORY[0x270F4C750]();
}

uint64_t MTDeviceShouldDispatchRelativeCoordinates()
{
  return MEMORY[0x270F4C758]();
}

uint64_t MTDeviceShouldResetOnButton()
{
  return MEMORY[0x270F4C760]();
}

uint64_t MTDeviceStart()
{
  return MEMORY[0x270F4C768]();
}

uint64_t MTDeviceStop()
{
  return MEMORY[0x270F4C770]();
}

uint64_t MTDeviceSupportsActuation()
{
  return MEMORY[0x270F4C778]();
}

uint64_t MTDeviceSupportsForce()
{
  return MEMORY[0x270F4C780]();
}

uint64_t MTDeviceSupportsSilentClick()
{
  return MEMORY[0x270F4C788]();
}

uint64_t MTDeviceSupportsTapToWake()
{
  return MEMORY[0x270F4C790]();
}

uint64_t MTDeviceSupportsTouchReadyNotification()
{
  return MEMORY[0x270F4C798]();
}

uint64_t MTDeviceSupportsUSBChargingNotification()
{
  return MEMORY[0x270F4C7A0]();
}

uint64_t MTDeviceSupportsWirelessChargingNotification()
{
  return MEMORY[0x270F4C7A8]();
}

uint64_t MTDeviceUpdateDynamicCalibration()
{
  return MEMORY[0x270F4C7B0]();
}

uint64_t MTDeviceUpdateUILockState()
{
  return MEMORY[0x270F4C7B8]();
}

uint64_t MTDeviceUseContextualPower()
{
  return MEMORY[0x270F4C7C0]();
}

uint64_t MTGetPathStageName()
{
  return MEMORY[0x270F4C7C8]();
}

uint64_t MTRegisterContactFrameCallbackWithRefcon()
{
  return MEMORY[0x270F4C7D8]();
}

uint64_t MTRegisterFrameHeaderCallback()
{
  return MEMORY[0x270F4C7E8]();
}

uint64_t MTRegisterFullFrameCallback()
{
  return MEMORY[0x270F4C7F8]();
}

uint64_t MTRegisterInputDetectionCallback()
{
  return MEMORY[0x270F4C808]();
}

uint64_t MTRegisterProcessedFrameCallback()
{
  return MEMORY[0x270F4C818]();
}

uint64_t MTRegisterRelativePointerCallback()
{
  return MEMORY[0x270F4C820]();
}

uint64_t MTRegisterTrackingCallback()
{
  return MEMORY[0x270F4C828]();
}

uint64_t MTSwapInt32HostToDevice()
{
  return MEMORY[0x270F4C830]();
}

uint64_t MTUnregisterButtonStateCallback()
{
  return MEMORY[0x270F4C838]();
}

uint64_t MTUnregisterContactFrameCallback()
{
  return MEMORY[0x270F4C840]();
}

uint64_t MTUnregisterFrameProcessingEntryExitCallback()
{
  return MEMORY[0x270F4C850]();
}

uint64_t MTUnregisterFullFrameCallback()
{
  return MEMORY[0x270F4C858]();
}

uint64_t MTUnregisterImageCallback()
{
  return MEMORY[0x270F4C860]();
}

uint64_t MTUnregisterInputDetectionCallback()
{
  return MEMORY[0x270F4C868]();
}

uint64_t MTUnregisterTrackingCallback()
{
  return MEMORY[0x270F4C878]();
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x270EF2A50](aClassName);
}

SEL NSSelectorFromString(NSString *aSelectorName)
{
  return (SEL)MEMORY[0x270EF2BE8](aSelectorName);
}

NSString *NSTemporaryDirectory(void)
{
  return (NSString *)MEMORY[0x270EF2C48]();
}

uint64_t PBDataWriterWriteUint32Field()
{
  return MEMORY[0x270F585A8]();
}

uint64_t PBDataWriterWriteUint64Field()
{
  return MEMORY[0x270F585C0]();
}

uint64_t PBReaderPlaceMark()
{
  return MEMORY[0x270F585D0]();
}

uint64_t PBReaderRecallMark()
{
  return MEMORY[0x270F585F0]();
}

uint64_t PBReaderSkipValueWithTag()
{
  return MEMORY[0x270F58608]();
}

uint64_t PBRepeatedUInt32Add()
{
  return MEMORY[0x270F586F0]();
}

uint64_t PBRepeatedUInt32Clear()
{
  return MEMORY[0x270F58700]();
}

uint64_t PBRepeatedUInt32Copy()
{
  return MEMORY[0x270F58718]();
}

uint64_t PBRepeatedUInt32Hash()
{
  return MEMORY[0x270F58728]();
}

uint64_t PBRepeatedUInt32NSArray()
{
  return MEMORY[0x270F58748]();
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x270EE56F0]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x270EE5700]();
}

uint64_t _IOHIDEventSetAttachment()
{
  return MEMORY[0x270EF4BA8]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x270F98330](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x270F98428](this);
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

uint64_t std::__sort<std::__less<float,float> &,float *>()
{
  return MEMORY[0x270F98BE0]();
}

uint64_t std::__sort<std::__less<int,int> &,int *>()
{
  return MEMORY[0x270F98BE8]();
}

void std::terminate(void)
{
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x270F98EC0](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x270F98ED8](a1);
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

__float2 __sincosf_stret(float a1)
{
  MEMORY[0x270ED7E90](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
}

float atan2f(float a1, float a2)
{
  MEMORY[0x270ED86B8](a1, a2);
  return result;
}

void bzero(void *a1, size_t a2)
{
}

float cbrtf(float a1)
{
  MEMORY[0x270ED87C0](a1);
  return result;
}

long double cos(long double __x)
{
  MEMORY[0x270ED9128](__x);
  return result;
}

float cosf(float a1)
{
  MEMORY[0x270ED9130](a1);
  return result;
}

void dispatch_assert_queue_not_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void *__cdecl dispatch_get_context(dispatch_object_t object)
{
  return (void *)MEMORY[0x270ED9308](object);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x270ED9318](identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x270ED9340]();
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x270ED9378](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x270ED9460](label, attr);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x270ED9510](type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_suspend(dispatch_object_t object)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x270ED95A8](when, delta);
}

dispatch_time_t dispatch_walltime(const timespec *when, int64_t delta)
{
  return MEMORY[0x270ED95B8](when, delta);
}

int dlclose(void *__handle)
{
  return MEMORY[0x270ED9618](__handle);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x270ED9620]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x270ED9628](__path, *(void *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x270ED9648](__handle, __symbol);
}

long double exp(long double __x)
{
  MEMORY[0x270ED9858](__x);
  return result;
}

long double exp2(long double __x)
{
  MEMORY[0x270ED9860](__x);
  return result;
}

float expf(float a1)
{
  MEMORY[0x270ED9870](a1);
  return result;
}

int fflush(FILE *a1)
{
  return MEMORY[0x270ED9938](a1);
}

long double fmod(long double __x, long double __y)
{
  MEMORY[0x270ED99D0](__x, __y);
  return result;
}

float fmodf(float a1, float a2)
{
  MEMORY[0x270ED99D8](a1, a2);
  return result;
}

void free(void *a1)
{
}

long double hypot(long double __x, long double __y)
{
  MEMORY[0x270ED9E58](__x, __y);
  return result;
}

float hypotf(float a1, float a2)
{
  MEMORY[0x270ED9E60](a1, a2);
  return result;
}

uint64_t kdebug_trace()
{
  return MEMORY[0x270ED9F50]();
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x270EDA138]();
}

uint64_t mach_continuous_time(void)
{
  return MEMORY[0x270EDA158]();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return (char *)MEMORY[0x270EDA168](*(void *)&error_value);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x270EDA288](info);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA390](size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDA468](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

float modff(float a1, float *a2)
{
  MEMORY[0x270EDA5B0](a2, a1);
  return result;
}

uint64_t mt_CreateSavedNameForDevice()
{
  return MEMORY[0x270F4C880]();
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x270EDA738](*(void *)&token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x270EDA770](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x270F9A528](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x270F9A540]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x270F9A568](a1);
}

{
  MEMORY[0x270F9A570](context);
}

{
  return (void *)MEMORY[0x270F9A588]();
}

void objc_enumerationMutation(id obj)
{
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x270F9A6E8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x270F9A6F8]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x270F9A700]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x270F9A710]();
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x270F9A870](a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x270EDA9A0](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x270EDAA58](log);
}

uint64_t os_variant_allows_internal_security_policies()
{
  return MEMORY[0x270EDAB10]();
}

long double pow(long double __x, long double __y)
{
  MEMORY[0x270EDACF8](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  MEMORY[0x270EDAD00](a1, a2);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x270EDAD20](a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x270EDAFA0](a1, a2);
}

int putchar(int a1)
{
  return MEMORY[0x270EDB090](*(void *)&a1);
}

int puts(const char *a1)
{
  return MEMORY[0x270EDB098](a1);
}

int rand(void)
{
  return MEMORY[0x270EDB0D8]();
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x270EDB510](__str, __size, __format);
}

void srand(unsigned int a1)
{
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x270EDB5B0](__s1, __s2);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x270EDB648](__dst, __src, __n);
}

void syslog(int a1, const char *a2, ...)
{
}

time_t time(time_t *a1)
{
  return MEMORY[0x270EDB930](a1);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x270EDB9E8](*(void *)&a1);
}

__int32 *__cdecl wmemchr(__int32 *__s, __int32 __c, size_t __n)
{
  return (__int32 *)MEMORY[0x270EDBBE8](__s, *(void *)&__c, __n);
}