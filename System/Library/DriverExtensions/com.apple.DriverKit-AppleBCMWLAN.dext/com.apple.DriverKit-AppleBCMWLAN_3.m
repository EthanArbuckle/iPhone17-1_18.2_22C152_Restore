BOOL AppleBCMWLANBusInterfacePCIe::waitForDeviceReady(AppleBCMWLANBusInterfacePCIe *this)
{
  unsigned int v2;
  CCLogStream *v3;
  CCLogStream *Logger;
  CCLogStream *v6;
  uint16_t readData;
  uint64_t v8;

  v8 = 0xAAAAAAAAAAAAAAAALL;
  readData = -21846;
  clock_interval_to_deadline();
  if (AppleBCMWLANBusInterface::getLogger(this))
  {
    AppleBCMWLANBusInterface::getLogger(this);
    if (CCLogStream::shouldLog())
    {
      Logger = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
      CCLogStream::logAlert(Logger, "[dk] %s@%d:AppleBCMWLANBusInterfacePCIe read config\n", "waitForDeviceReady", 21584);
    }
  }
  while (1)
  {
    IOPCIDevice::ConfigurationRead16(*(IOPCIDevice **)(*((void *)this + 9) + 3248), 2uLL, &readData);
    v2 = readData - 2;
    if (v2 < 0xFFFD) {
      break;
    }
    IOSleep(0xAuLL);
    if (mach_absolute_time() >= v8)
    {
      if (AppleBCMWLANBusInterface::getLogger(this))
      {
        AppleBCMWLANBusInterface::getLogger(this);
        if (CCLogStream::shouldLog())
        {
          v3 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
          CCLogStream::logAlert(v3, "[dk] %s@%d:AppleBCMWLANBusInterfacePCIe read config timeout: productID %#x\n");
        }
      }
      return v2 < 0xFFFD;
    }
  }
  if (AppleBCMWLANBusInterface::getLogger(this))
  {
    AppleBCMWLANBusInterface::getLogger(this);
    if (CCLogStream::shouldLog())
    {
      v6 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
      CCLogStream::logAlert(v6, "[dk] %s@%d:AppleBCMWLANBusInterfacePCIe read config success: productID %#x\n");
    }
  }
  return v2 < 0xFFFD;
}

uint64_t AppleBCMWLANBusInterfacePCIe::init(AppleBCMWLANBusInterfacePCIe *this)
{
  mach_continuous_time();
  absolutetime_to_nanoseconds();
  if ((AppleBCMWLANBusInterface::init((IOService *)this) & 1) != 0 && AppleBCMWLANBusInterfacePCIe::init(this, v2))
  {
    AppleBCMWLANBusInterface::setBootCheckPointAnchorTime((uint64_t)this, 0, 0);
    uint64_t v3 = 1;
    AppleBCMWLANBusInterface::sendBootCheckPointToCoreAnalytics(this, 1u, 1u);
    if (AppleBCMWLANBusInterface::getLogger(this))
    {
      AppleBCMWLANBusInterface::getLogger(this);
      if (CCLogStream::shouldLog())
      {
        Logger = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
        CCLogStream::logEmergency(Logger, "[dk] %s@%d:Bus PCIe INIT", "init", 21637);
      }
    }
  }
  else
  {
    IOLog("pcie bus interface init fail\n");
    stringFromBootCheckPoint(1u);
    io80211_os_log();
    return 0;
  }
  return v3;
}

uint64_t non-virtual thunk to'AppleBCMWLANBusInterfacePCIe::init(AppleBCMWLANBusInterfacePCIe *this)
{
  return AppleBCMWLANBusInterfacePCIe::init((AppleBCMWLANBusInterfacePCIe *)((char *)this - 24));
}

uint64_t AppleBCMWLANBusInterfacePCIe::Start_Impl(AppleBCMWLANBusInterfacePCIe *this, IOService *a2)
{
  kern_return_t (__cdecl *v10)(OSMetaClassBase *, const IORPC);
  uint64_t v11;
  AppleBCMWLANBusInterfacePCIe *v12;
  IOService *v13;
  uint64_t v14;
  int v15;
  IODispatchQueue *v16;
  IODispatchQueue *v17;
  uint64_t v18;
  CCLogStream *v19;
  AppleBCMWLANPCIeMMIOHistory *v20;
  uint64_t v21;
  CCLogStream *v22;
  uint64_t v23;
  AppleBCMWLANChipManagerPCIe *v24;
  AppleBCMWLANPCIeMMIOHistory *v25;
  __int16 v26;
  AppleBCMWLANPCIeMMIOHistory *v27;
  uint64_t v28;
  uint64_t v29;
  IODispatchQueue *v30;
  int v31;
  uint64_t v32;
  CCLogStream *Logger;
  AppleBCMWLANBusInterfacePCIe *v34;
  IOService *v35;
  int v36;
  uint64_t v37;
  IODispatchQueue *v38;
  CCLogStream *v39;
  CCLogStream *v40;
  CCLogStream *v41;
  CCLogStream *v42;
  CCLogStream *v43;
  CCLogStream *v44;
  CCLogStream *v45;
  CCLogStream *v46;
  CCLogStream *v47;
  CCLogStream *v48;
  CCLogStream *v49;
  void v50[6];
  void block[7];
  int v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  int v56;

  if (AppleBCMWLANBusInterface::isAbortInit(this))
  {
    uint64_t v4 = 3758097084;
    IOLog("AppleBCMWLANBusInterfacePCIe::%s(): Aborting WiFi init by boot-arg. \n");
    return v4;
  }
  AppleBCMWLANBusInterface::sendBootCheckPointToCoreAnalytics(this, 1u, 3u);
  if ((*(unsigned int (**)(AppleBCMWLANBusInterfacePCIe *))(*(void *)this + 832))(this))
  {
    uint64_t v4 = 3758097084;
    getClassNameHelper((OSObject *)this);
    IOLog("%s::%s() DriverKit configuration disabled\n");
    return v4;
  }
  v6 = (AppleOLYHAL *)IOLog("%s: Waiting for AppleOLYHAL to registerService()\n", "kern_return_t AppleBCMWLANBusInterfacePCIe::Start_Impl(IOService *)");
  uint64_t v7 = AppleOLYHAL::waitForAppleOLYHALDK(v6);
  if (v7)
  {
    uint64_t v4 = v7;
    IOLog("%s: waitForAppleOLYHALDK failed 0x%08x\n", "kern_return_t AppleBCMWLANBusInterfacePCIe::Start_Impl(IOService *)", v7);
LABEL_8:
    v8 = (IOService *)this;
    v9 = a2;
    v10 = 0;
LABEL_9:
    IOService::Stop(v8, v9, v10);
    return v4;
  }
  *(unsigned char *)(*((void *)this + 9) + 5194) = 1;
  *(void *)(*((void *)this + 9) + 3248) = OSMetaClassBase::safeMetaCast(a2, gIOPCIDeviceMetaClass);
  v11 = *(void *)(*((void *)this + 9) + 3248);
  if (!v11)
  {
    io80211_os_log();
    goto LABEL_18;
  }
  (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  sDevice = *(void *)(*((void *)this + 9) + 3248);
  if (IOPCIDevice::Open((IOPCIDevice *)sDevice, (IOService *)this, 0))
  {
    if (AppleBCMWLANBusInterface::getLogger(this))
    {
      AppleBCMWLANBusInterface::getLogger(this);
      if (CCLogStream::shouldLog())
      {
        Logger = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
        CCLogStream::logEmergency(Logger, "[dk] %s@%d:Could not open IOPCIDevice\n", "Start_Impl", 21703);
      }
    }
    v12 = this;
    v13 = a2;
    v14 = 0;
    v15 = 21704;
LABEL_16:
    AppleBCMWLANBusInterface::reportInitFailure((uint64_t)v12, v13, v14, v15);
LABEL_18:
    IOService::Stop((IOService *)this, a2, 0);
    return 3758097088;
  }
  if (IO80211WorkQueue::Create())
  {
    uint64_t v4 = 3758097084;
LABEL_25:
    io80211_os_log();
LABEL_26:
    v10 = (kern_return_t (__cdecl *)(OSMetaClassBase *, const IORPC))AppleBCMWLANBusInterface::_Dispatch;
    v8 = (IOService *)this;
    v9 = a2;
    goto LABEL_9;
  }
  v16 = (IODispatchQueue *)(*(uint64_t (**)(void))(**(void **)(*((void *)this + 9) + 3464) + 168))(*(void *)(*((void *)this + 9) + 3464));
  if (OSObject::SetDispatchQueue((OSObject *)this, "Default", v16, 0))
  {
    uint64_t v4 = 3758097084;
    goto LABEL_25;
  }
  v17 = (IODispatchQueue *)(*(uint64_t (**)(void))(**(void **)(*((void *)this + 9) + 3464) + 240))(*(void *)(*((void *)this + 9) + 3464));
  if (OSObject::SetDispatchQueue((OSObject *)this, "RxDispatchQueue", v17, 0))
  {
    uint64_t v4 = 3758097084;
    goto LABEL_25;
  }
  v18 = IOService::Start((IOService *)this, a2, (OSDispatchMethod)AppleBCMWLANBusInterface::_Dispatch);
  if (v18)
  {
    uint64_t v4 = v18;
    if (AppleBCMWLANBusInterface::getLogger(this))
    {
      AppleBCMWLANBusInterface::getLogger(this);
      if (CCLogStream::shouldLog())
      {
        v19 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
        CCLogStream::logAlert(v19, "[dk] %s@%d:wlan businterface Start_IMPL failed; ret=0x%x\n",
          "Start_Impl",
          21733,
          v4);
      }
    }
    return v4;
  }
  if (((*(uint64_t (**)(AppleBCMWLANBusInterfacePCIe *, AppleBCMWLANBusInterfacePCIe *))(*(void *)this
                                                                                                  + 848))(this, this) & 1) == 0)
  {
    if (AppleBCMWLANBusInterface::getLogger(this))
    {
      AppleBCMWLANBusInterface::getLogger(this);
      if (CCLogStream::shouldLog())
      {
        v40 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
        CCLogStream::logAlert(v40, "[dk] %s@%d:wlan businterface start failed\n", "Start_Impl", 21739);
      }
    }
    uint64_t v4 = 3758097084;
    goto LABEL_26;
  }
  *(void *)(*((void *)this + 9) + 3352) = AppleBCMWLANChipConfigSpace::withPCIDevice(*(AppleBCMWLANChipConfigSpace **)(*((void *)this + 9) + 3248), 0, v20);
  if (!*(void *)(*((void *)this + 9) + 3352))
  {
    if (AppleBCMWLANBusInterface::getLogger(this))
    {
      AppleBCMWLANBusInterface::getLogger(this);
      if (CCLogStream::shouldLog())
      {
        v22 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
        CCLogStream::logEmergency(v22, "[dk] %s@%d:No config space\n", "Start_Impl", 21747);
      }
    }
    goto LABEL_18;
  }
  if (!AppleBCMWLANBusInterfacePCIe::waitForDeviceReady(this))
  {
    if (AppleBCMWLANBusInterface::getLogger(this))
    {
      AppleBCMWLANBusInterface::getLogger(this);
      if (CCLogStream::shouldLog())
      {
        v41 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
        CCLogStream::logAlert(v41, "[dk] %s@%d:AppleBCMWLANBusIntefacePCIe: deviceReady check failed\n", "Start_Impl", 21753);
      }
    }
    v12 = this;
    v13 = a2;
    v14 = 1;
    v15 = 21755;
    goto LABEL_16;
  }
  AppleBCMWLANBusInterfacePCIe::identifyDevice(this);
  v21 = AppleBCMWLANBusInterfacePCIe::configureDevice(this);
  if (v21)
  {
    uint64_t v4 = v21;
    if (AppleBCMWLANBusInterface::getLogger(this))
    {
      AppleBCMWLANBusInterface::getLogger(this);
      if (CCLogStream::shouldLog())
      {
        v42 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
        CCLogStream::logAlert(v42, "[dk] %s@%d:Failed to configure, 0x%08x\n", "Start_Impl", 21770, v4);
      }
    }
    AppleBCMWLANBusInterface::reportInitFailure((uint64_t)this, a2, 1uLL, 21771);
    goto LABEL_8;
  }
  v23 = *((void *)this + 9);
  if (*(_WORD *)(v23 + 3332) != 5348)
  {
    if (AppleBCMWLANBusInterface::getLogger(this))
    {
      AppleBCMWLANBusInterface::getLogger(this);
      if (CCLogStream::shouldLog())
      {
        v43 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
        CCLogStream::logAlert(v43, "[dk] %s@%d:Unrecognized device\n", "Start_Impl", 21778);
      }
    }
    v12 = this;
    v13 = a2;
    v14 = 1;
    v15 = 21779;
    goto LABEL_16;
  }
  *(_DWORD *)(v23 + 3312) = chipNumberFromDeviceID(*(unsigned __int16 *)(v23 + 3334));
  *(void *)(*((void *)this + 9) + 3280) = AppleBCMWLANChipManagerPCIe::withChip((AppleBCMWLANChipManagerPCIe *)*(unsigned int *)(*((void *)this + 9)+ 3312), *(unsigned __int8 *)(*((void *)this + 9) + 3336));
  v24 = *(AppleBCMWLANChipManagerPCIe **)(*((void *)this + 9) + 3280);
  if (v24)
  {
    *(_DWORD *)(*((void *)this + 9) + 4480) = AppleBCMWLANChipManagerPCIe::getMailboxIntMaskRegisterOffset(v24);
    *(_DWORD *)(*((void *)this + 9) + 4484) = AppleBCMWLANChipManagerPCIe::getMailboxIntStatusRegisterOffset(*(AppleBCMWLANChipManagerPCIe **)(*((void *)this + 9) + 3280));
    if ((*(unsigned int (**)(void))(**(void **)(*((void *)this + 9) + 3280) + 136))(*(void *)(*((void *)this + 9) + 3280))) {
      v26 = 640;
    }
    else {
      v26 = 384;
    }
    *(_WORD *)(*((void *)this + 9) + 4468) = v26;
    *(void *)(*((void *)this + 9) + 3360) = AppleBCMWLANChipBackplane::withConfigAndMap(*(AppleBCMWLANChipBackplane **)(*((void *)this + 9) + 3352), 0, *(IOMemoryMap **)(*((void *)this + 9) + 3280), 0, v25);
    v28 = *((void *)this + 9);
    if (*(void *)(v28 + 3360))
    {
      *(void *)(*((void *)this + 9) + 3368) = AppleBCMWLANChipMemory::withMap(0, *(IOMemoryMap **)(v28 + 3280), 0, v27);
      v29 = *((void *)this + 9);
      if (*(void *)(v29 + 3368))
      {
        v53 = 0;
        v54 = &v53;
        v55 = 0x2000000000;
        v56 = -1431655766;
        v30 = (IODispatchQueue *)(*(uint64_t (**)(void))(**(void **)(v29 + 3464) + 168))(*(void *)(v29 + 3464));
        block[0] = _NSConcreteStackBlock;
        block[1] = 1107296256;
        block[2] = ___ZN28AppleBCMWLANBusInterfacePCIe10Start_ImplEP9IOService_block_invoke;
        block[3] = &__block_descriptor_tmp_1152;
        block[4] = &v53;
        v52 = 0;
        block[5] = this;
        block[6] = a2;
        IODispatchQueue::DispatchSync(v30, block);
        v31 = *((_DWORD *)v54 + 6);
        v32 = AppleBCMWLANBusInterface::getLogger(this);
        if (v31)
        {
          if (v32)
          {
            AppleBCMWLANBusInterface::getLogger(this);
            if (CCLogStream::shouldLog())
            {
              v46 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
              CCLogStream::logAlert(v46, "[dk] %s@%d:Failed to read OTP data\n", "Start_Impl", 21837);
            }
          }
          AppleBCMWLANBusInterface::reportInitFailure((uint64_t)this, a2, 1uLL, 21838);
          IOService::Stop((IOService *)this, a2, 0);
        }
        else
        {
          if (v32)
          {
            AppleBCMWLANBusInterface::getLogger(this);
            if (CCLogStream::shouldLog())
            {
              v48 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
              CCLogStream::logAlert(v48, "[dk] %s@%d:Bus PCIe init success\n", "Start_Impl", 21843);
            }
          }
          v37 = IOService::CopySystemStateNotificationService((IOService *)this, (IOService **)(*((void *)this + 9) + 5208), 0);
          if (v37)
          {
            uint64_t v4 = v37;
            AppleBCMWLANBusInterface::reportInitFailure((uint64_t)this, a2, 1uLL, 21846);
            IOService::Stop((IOService *)this, a2, 0);
            goto LABEL_85;
          }
          if (AppleBCMWLANBusInterface::getLogger(this))
          {
            AppleBCMWLANBusInterface::getLogger(this);
            if (CCLogStream::shouldLog())
            {
              v49 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
              CCLogStream::logAlert(v49, "[dk] %s@%d:Successfully created System State Notification Service\n", "Start_Impl", 21850);
            }
          }
          *((_DWORD *)v54 + 6) = -536870212;
          v38 = (IODispatchQueue *)(*(uint64_t (**)(void))(**(void **)(*((void *)this + 9) + 3464)
                                                                     + 168))(*(void *)(*((void *)this + 9) + 3464));
          v50[0] = _NSConcreteStackBlock;
          v50[1] = 1107296256;
          v50[2] = ___ZN28AppleBCMWLANBusInterfacePCIe10Start_ImplEP9IOService_block_invoke_1156;
          v50[3] = &__block_descriptor_tmp_1159;
          v50[4] = &v53;
          v50[5] = this;
          IODispatchQueue::DispatchSync(v38, v50);
          if (!*((_DWORD *)v54 + 6))
          {
            uint64_t v4 = 0;
            goto LABEL_85;
          }
          if (AppleBCMWLANBusInterface::getLogger(this))
          {
            AppleBCMWLANBusInterface::getLogger(this);
            if (CCLogStream::shouldLog())
            {
              v39 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
              CCLogStream::logAlert(v39, "[dk] %s@%d:Failed deferredStart()", "Start_Impl", 21857);
            }
          }
        }
        uint64_t v4 = *((unsigned int *)v54 + 6);
LABEL_85:
        _Block_object_dispose(&v53, 8);
        return v4;
      }
      if (AppleBCMWLANBusInterface::getLogger(this))
      {
        AppleBCMWLANBusInterface::getLogger(this);
        if (CCLogStream::shouldLog())
        {
          v47 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
          CCLogStream::logAlert(v47, "[dk] %s@%d:Failed to create memory access.\n", "Start_Impl", 21814);
        }
      }
      v34 = this;
      v35 = a2;
      v36 = 21815;
    }
    else
    {
      if (AppleBCMWLANBusInterface::getLogger(this))
      {
        AppleBCMWLANBusInterface::getLogger(this);
        if (CCLogStream::shouldLog())
        {
          v45 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
          CCLogStream::logAlert(v45, "[dk] %s@%d:Failed to create backplane access.\n", "Start_Impl", 21806);
        }
      }
      v34 = this;
      v35 = a2;
      v36 = 21807;
    }
    AppleBCMWLANBusInterface::reportInitFailure((uint64_t)v34, v35, 1uLL, v36);
    IOService::Stop((IOService *)this, a2, 0);
    return 3758097085;
  }
  if (AppleBCMWLANBusInterface::getLogger(this))
  {
    AppleBCMWLANBusInterface::getLogger(this);
    if (CCLogStream::shouldLog())
    {
      v44 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(this);
      CCLogStream::logAlert(v44, "[dk] %s@%d:Failed to create chip manager for chip %u.\n", "Start_Impl", 21787, *(_DWORD *)(*((void *)this + 9) + 3312));
    }
  }
  AppleBCMWLANBusInterface::reportInitFailure((uint64_t)this, a2, 1uLL, 21788);
  IOService::Stop((IOService *)this, a2, 0);
  return 3758097126;
}

uint64_t ___ZN28AppleBCMWLANBusInterfacePCIe10Start_ImplEP9IOService_block_invoke(uint64_t a1)
{
  v2 = *(IOService **)(a1 + 40);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = AppleBCMWLANBusInterfacePCIe::readOTP(v2);
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    if (AppleBCMWLANBusInterface::getLogger((AppleBCMWLANBusInterface *)v2))
    {
      AppleBCMWLANBusInterface::getLogger((AppleBCMWLANBusInterface *)v2);
      if (CCLogStream::shouldLog())
      {
        Logger = (CCLogStream *)AppleBCMWLANBusInterface::getLogger((AppleBCMWLANBusInterface *)v2);
        CCLogStream::logAlert(Logger, "[dk] %s@%d:Failed to read OTP, 0x%08x\n", "Start_Impl_block_invoke", 21825, *(_DWORD *)(a1 + 56));
      }
    }
    AppleBCMWLANBusInterface::reportInitFailure((uint64_t)v2, *(IOService **)(a1 + 48), 1uLL, 21826);
  }
  uint64_t result = ((uint64_t (*)(IOService *, IOService *, kern_return_t (__cdecl *)(IOService *__hidden, const IORPC *__struct_ptr), void))v2->OSObject::OSMetaClassBase::__vftable[16].retain)(v2, v2, v2->OSObject::OSMetaClassBase::__vftable[2].Dispatch, 0);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    if (AppleBCMWLANBusInterface::getLogger((AppleBCMWLANBusInterface *)v2))
    {
      AppleBCMWLANBusInterface::getLogger((AppleBCMWLANBusInterface *)v2);
      if (CCLogStream::shouldLog())
      {
        v6 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger((AppleBCMWLANBusInterface *)v2);
        CCLogStream::logAlert(v6, "[dk] %s@%d:Failed to Parse OTP 0x%08x\n", "Start_Impl_block_invoke", 21831, *(_DWORD *)(a1 + 56));
      }
    }
    uint64_t v4 = *(IOService **)(a1 + 48);
    return AppleBCMWLANBusInterface::reportInitFailure((uint64_t)v2, v4, 1uLL, 21832);
  }
  return result;
}

uint64_t ___ZN28AppleBCMWLANBusInterfacePCIe10Start_ImplEP9IOService_block_invoke_1156(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 856))(*(void *)(a1 + 40));
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t ___ZN28AppleBCMWLANBusInterfacePCIe22InterruptOccurred_ImplEP8OSActionyy_block_invoke(uint64_t a1, unint64_t a2)
{
  return 0;
}

uint64_t AppleBCMWLANBusInterfacePCIe::InterruptOccurredHelper(uint64_t this, unint64_t a2, unint64_t a3)
{
  uint64_t v3 = (AppleBCMWLANBusInterface *)this;
  v5 = (uint64_t *)(this + 72);
  uint64_t v4 = *(void *)(this + 72);
  if (*(void *)(v4 + 4760) >= a3) {
    AppleBCMWLANBusInterfacePCIe::InterruptOccurredHelper((AppleBCMWLANBusInterface *)this, this + 72, a3);
  }
  if (a3 != -1)
  {
    *(void *)(v4 + 4760) = a3;
    uint64_t v4 = *v5;
  }
  if (*(unsigned char *)(v4 + 4801))
  {
    *(unsigned char *)(v4 + 4801) = 0;
    v6 = *(uint64_t (**)(void))(**(void **)(*v5 + 3488) + 88);
    return v6();
  }
  if (!*(unsigned char *)(v4 + 1306) || *(unsigned char *)(v4 + 4552)) {
    return this;
  }
  *(void *)(v4 + 2920) = 0;
  mach_continuous_time();
  absolutetime_to_nanoseconds();
  if (**(_DWORD **)(*v5 + 2832))
  {
    if (AppleBCMWLANBusInterface::getLogger(v3))
    {
      AppleBCMWLANBusInterface::getLogger(v3);
      if (CCLogStream::shouldLog())
      {
        Logger = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(v3);
        CCLogStream::logAlert(Logger, "[dk] %s@%d:FAILED HEALTH CHECK (0x%x)\n", "InterruptOccurredHelper", 21934, **(_DWORD **)(*((void *)v3 + 9) + 2832));
      }
    }
    if (AppleBCMWLANChipManagerPCIe::isTrapBeforeFLRSupported(*(AppleBCMWLANChipManagerPCIe **)(*v5 + 3280)))
    {
      if (AppleBCMWLANBusInterface::getLogger(v3))
      {
        AppleBCMWLANBusInterface::getLogger(v3);
        if (CCLogStream::shouldLog())
        {
          v20 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(v3);
          CCLogStream::logCrit(v20, "[dk] %s@%d:Reset BackPlane Address Register\n", "InterruptOccurredHelper", 21936);
        }
      }
      IOPCIDevice::ConfigurationWrite32(*(IOPCIDevice **)(*v5 + 3248), 0x98uLL, 0);
    }
    uint64_t v7 = *v5;
    if (*(unsigned char *)(*v5 + 4521))
    {
      this = AppleBCMWLANChipManagerPCIe::isTrapBeforeFLRSupported(*(AppleBCMWLANChipManagerPCIe **)(v7 + 3280));
      uint64_t v7 = *v5;
      if (this)
      {
        if (!*(unsigned char *)(v7 + 3717))
        {
          v15 = *(_DWORD **)(v7 + 2832);
          if (v15)
          {
            if ((*v15 & 0x80000000) != 0) {
              goto LABEL_66;
            }
          }
        }
      }
    }
    if (*(unsigned char *)(v7 + 4521))
    {
      v8 = *(AppleBCMWLANChipManagerPCIe **)(v7 + 3280);
      if (v8)
      {
        BOOL isTrapBeforeFLRSupported = AppleBCMWLANChipManagerPCIe::isTrapBeforeFLRSupported(v8);
        uint64_t v7 = *v5;
        if (!isTrapBeforeFLRSupported && !*(unsigned char *)(v7 + 3717))
        {
          this = AppleBCMWLANBusInterface::getLogger(v3);
          if (this)
          {
            AppleBCMWLANBusInterface::getLogger(v3);
            this = CCLogStream::shouldLog();
            if (this)
            {
              v21 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(v3);
              this = CCLogStream::logAlert(v21, "[dk] %s@%d:Host Initiated Mailbox Trap\n", "InterruptOccurredHelper", 21946);
            }
          }
          uint64_t v7 = *v5;
LABEL_66:
          *(unsigned char *)(v7 + 4521) = 0;
          return this;
        }
      }
    }
    v10 = *(AppleBCMWLANChipManagerPCIe **)(v7 + 3280);
    if (v10)
    {
      int isFatalErrorIndicationSupported = AppleBCMWLANChipManagerPCIe::isFatalErrorIndicationSupported(v10);
      uint64_t v7 = *v5;
      if (isFatalErrorIndicationSupported)
      {
        if (!*(unsigned char *)(v7 + 3711))
        {
          uint64_t v16 = *(void *)(v7 + 2832);
          if (v16)
          {
            if ((*(unsigned char *)(v16 + 2) & 0x20) != 0)
            {
              if (AppleBCMWLANBusInterface::getLogger(v3))
              {
                AppleBCMWLANBusInterface::getLogger(v3);
                if (CCLogStream::shouldLog())
                {
                  v22 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(v3);
                  CCLogStream::logAlert(v22, "[dk] %s@%d:Fatal error indicated from Firmware, upgrade to full reset and enabling log collection\n", "InterruptOccurredHelper", 21951);
                }
              }
              *(unsigned char *)(*v5 + 4573) = 1;
              *(unsigned char *)(*v5 + 4574) = 1;
              uint64_t v7 = *v5;
            }
          }
        }
      }
    }
    v12 = *(AppleBCMWLANChipManagerPCIe **)(v7 + 3280);
    if (v12)
    {
      int isCoexCPUTrapSupported = AppleBCMWLANChipManagerPCIe::isCoexCPUTrapSupported(v12);
      uint64_t v7 = *v5;
      if (isCoexCPUTrapSupported)
      {
        if (!*(unsigned char *)(v7 + 3712))
        {
          uint64_t v17 = *(void *)(v7 + 2832);
          if (v17)
          {
            if ((*(unsigned char *)(v17 + 2) & 0x40) != 0)
            {
              if (AppleBCMWLANBusInterface::getLogger(v3))
              {
                AppleBCMWLANBusInterface::getLogger(v3);
                if (CCLogStream::shouldLog())
                {
                  v23 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(v3);
                  CCLogStream::logAlert(v23, "[dk] %s@%d:Coex CPU trap Indicated\n", "InterruptOccurredHelper", 21957);
                }
              }
              *(unsigned char *)(*v5 + 3714) = 1;
              uint64_t v7 = *v5;
            }
          }
        }
      }
    }
    v14 = *(AppleBCMWLANChipManagerPCIe **)(v7 + 3280);
    if (v14)
    {
      if (AppleBCMWLANChipManagerPCIe::isCoexCPUTrapSupported(v14))
      {
        if (!*(unsigned char *)(*v5 + 3712))
        {
          uint64_t v18 = *(void *)(*v5 + 2832);
          if (v18)
          {
            if ((*(unsigned char *)(v18 + 2) & 0x80) != 0)
            {
              if (AppleBCMWLANBusInterface::getLogger(v3))
              {
                AppleBCMWLANBusInterface::getLogger(v3);
                if (CCLogStream::shouldLog())
                {
                  v24 = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(v3);
                  CCLogStream::logAlert(v24, "[dk] %s@%d:Coex CPU trap Requested\n", "InterruptOccurredHelper", 21961);
                }
              }
              *(unsigned char *)(*v5 + 3715) = 1;
            }
          }
        }
      }
    }
    AppleBCMWLANBusInterfacePCIe::handleFWTrap(v3);
  }
  kdebug_trace();
  ++*(_DWORD *)(*((void *)v3 + 9) + 1256);
  AppleBCMWLANBusInterfacePCIe::updateRxBufFillState(v3);
  if (AppleBCMWLANItemRing::getReadableItemCount(*(AppleBCMWLANItemRing **)(*((void *)v3 + 9) + 320))) {
    *(void *)(*v5 + 4768) = *(void *)(*v5 + 4760);
  }
  (*(void (**)(void))(**(void **)(*v5 + 3464) + 160))(*(void *)(*v5 + 3464));
  ++*(_DWORD *)(*v5 + 1284);
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(*v5 + 320) + 112))(*(void *)(*v5 + 320), *v5 + 3852, *v5 + 3856);
  *(void *)(*v5 + 3864) = *(unsigned int *)(*v5 + 1252);
  mach_continuous_time();
  absolutetime_to_nanoseconds();
  return kdebug_trace();
}

uint64_t ___ZN28AppleBCMWLANBusInterfacePCIe22InterruptOccurred_ImplEP8OSActionyy_block_invoke_2(uint64_t a1, unint64_t a2)
{
  return 0;
}

uint64_t AppleBCMWLANBusInterfacePCIe::getDevice(AppleBCMWLANBusInterfacePCIe *this)
{
  return sDevice;
}

uint64_t AppleBCMWLANBusInterfacePCIe::RxSubmissionQueueDataAvailable_Impl(AppleBCMWLANBusInterfacePCIe *this, OSAction *a2)
{
  return AppleBCMWLANPCIeSkywalk::rxSubmissionQueueDataAvailable(*(AppleBCMWLANPCIeSkywalk **)(*((void *)this + 9)
                                                                                             + 4472));
}

void _GLOBAL__sub_I_AppleBCMWLANBusInterfacePCIe_cpp()
{
  kNullRange = 0;
}

OSObject *AppleBCMWLANTimeKeeper::withDriver(AppleBCMWLANTimeKeeper *this, AppleBCMWLANCore *a2)
{
  v5 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANTimeKeeperMetaClass, &v5)) {
    return 0;
  }
  uint64_t v3 = v5;
  if (v5
    && (((uint64_t (*)(OSObject *, AppleBCMWLANTimeKeeper *))v5->OSMetaClassBase::__vftable[1].getMetaClass)(v5, this) & 1) == 0)
  {
    ((void (*)(OSObject *))v3->release)(v3);
    return 0;
  }
  return v3;
}

uint64_t AppleBCMWLANTimeKeeper::initWithDriver(OSObject *this, AppleBCMWLANCore *a2)
{
  if (!OSObject::init(this))
  {
    getClassNameHelper(this);
    IOLog("%s:%s(): Super failed to init!\n");
    return 0;
  }
  uint64_t result = IOMallocZeroTyped();
  *(void *)&this[1].refcount = result;
  if (!result) {
    return result;
  }
  *(void *)(result + 40) = a2;
  *(void *)(*(void *)&this[1].refcount + 32) = (*(uint64_t (**)(AppleBCMWLANCore *))(*(void *)a2 + 1848))(a2);
  uint64_t v5 = *(void *)(*(void *)&this[1].refcount + 32);
  if (!v5)
  {
    getClassNameHelper(this);
    IOLog("%s::%s(): Unable to get debug logger\n");
    return 0;
  }
  (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  *(void *)(*(void *)&this[1].refcount + 24) = AppleBCMWLANCore::getCommander(a2);
  uint64_t v6 = *(void *)&this[1].refcount;
  if (!*(void *)(v6 + 24) && *(void *)(v6 + 32))
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v6 = *(void *)&this[1].refcount;
    if (shouldLog)
    {
      CCLogStream::logAlert(*(CCLogStream **)(v6 + 32), "[dk] %s@%d:Failed to get Commander\n", "initWithDriver", 88);
      uint64_t v6 = *(void *)&this[1].refcount;
    }
  }
  *(unsigned char *)(v6 + 48) = 0;
  return 1;
}

uint64_t non-virtual thunk to'AppleBCMWLANTimeKeeper::initWithDriver(OSObject *this, AppleBCMWLANCore *a2)
{
  return AppleBCMWLANTimeKeeper::initWithDriver(this - 1, a2);
}

uint64_t AppleBCMWLANTimeKeeper::handleRteTimesyncIoVarAsyncCallBack(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = result;
    if (a3 == -469794537)
    {
      *(unsigned char *)(*(void *)(result + 48) + 48) = 1;
    }
    else
    {
      uint64_t result = *(void *)(*(void *)(result + 48) + 32);
      if (result)
      {
        uint64_t result = CCLogStream::shouldLog();
        if (result)
        {
          uint64_t v5 = *(void *)(v4 + 48);
          uint64_t v6 = *(CCLogStream **)(v5 + 32);
          uint64_t v7 = (const char *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v5 + 40) + 112))(*(void *)(v5 + 40), a3);
          return CCLogStream::logAlert(v6, "[dk] %s@%d:Cannot set rte_timestync: %s\n", "handleRteTimesyncIoVarAsyncCallBack", 103, v7);
        }
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANTimeKeeper::synchronizeTime(AppleBCMWLANTimeKeeper *this)
{
  if (*(unsigned char *)(*((void *)this + 6) + 48)) {
    return 3758097095;
  }
  mach_continuous_time();
  absolutetime_to_nanoseconds();
  uint64_t v4 = *((void *)this + 6);
  uint64_t v5 = *(void *)(v4 + 8);
  BOOL v6 = v5 == 0;
  unint64_t v7 = 0x2BB0CF87D9C549 - v5;
  if (!v6 && v7 < 0x11E1A2FF) {
    return 0;
  }
  *(void *)(v4 + 16) = 2863;
  uint64_t v1 = AppleBCMWLANCommander::sendIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 24), (uint64_t)"rte_timesync");
  if (v1)
  {
    if (*(void *)(*((void *)this + 6) + 32) && CCLogStream::shouldLog())
    {
      uint64_t v9 = *((void *)this + 6);
      v10 = *(CCLogStream **)(v9 + 32);
      v11 = (const char *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v9 + 40) + 112))(*(void *)(v9 + 40), v1);
      CCLogStream::logAlert(v10, "[dk] %s@%d: Error: Unable to set rte_timesync: %s\n", "synchronizeTime", 139, v11);
    }
  }
  else
  {
    **((void **)this + 6) = 0x2BB0CF87D9C54ALL;
    *(void *)(*((void *)this + 6) + 8) = 0x2BB0CF87D9C54ALL;
  }
  return v1;
}

void AppleBCMWLANTimeKeeper::free(OSObject *this)
{
  v2 = *(void **)&this[1].refcount;
  if (v2)
  {
    uint64_t v3 = v2[4];
    if (!v3
      || ((*(void (**)(void))(*(void *)v3 + 16))(v2[4]),
          *(void *)(*(void *)&this[1].refcount + 32) = 0,
          (v2 = *(void **)&this[1].refcount) != 0))
    {
      memset_s(v2, 0x38uLL, 0, 0x38uLL);
      uint64_t v4 = *(void **)&this[1].refcount;
      if (v4)
      {
        IOFree(v4, 0x38uLL);
        *(void *)&this[1].refcount = 0;
      }
    }
    OSObject::free(this);
  }
  else if (MEMORY[0x20] && CCLogStream::shouldLog())
  {
    CCLogStream::logCrit(*(CCLogStream **)(*(void *)&this[1].refcount + 32), "[dk] %s@%d:Failed to allocate AppleBCMWLANTimeKeeper_IVars\n", "free", 168);
  }
}

void non-virtual thunk to'AppleBCMWLANTimeKeeper::free(AppleBCMWLANTimeKeeper *this)
{
}

void _GLOBAL__sub_I_AppleBCMWLANTimeKeeper_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANHashtable::alignNextPow2(AppleBCMWLANHashtable *this)
{
  unsigned int v1 = (this - 1) | ((this - 1) >> 1) | (((this - 1) | ((this - 1) >> 1)) >> 2);
  unsigned int v2 = v1 | (v1 >> 4) | ((v1 | (v1 >> 4)) >> 8);
  return (v2 | HIWORD(v2)) + 1;
}

OSObject *AppleBCMWLANHashtable::withCapacity(AppleBCMWLANHashtable *this)
{
  uint64_t v4 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANHashtableMetaClass, &v4)) {
    return 0;
  }
  unsigned int v2 = v4;
  if (v4
    && (((uint64_t (*)(OSObject *, AppleBCMWLANHashtable *))v4->OSMetaClassBase::__vftable[1].free)(v4, this) & 1) == 0)
  {
    ((void (*)(OSObject *))v2->release)(v2);
    return 0;
  }
  return v2;
}

BOOL AppleBCMWLANHashtable::initWithCapacity(OSObject *this, __int32 a2)
{
  uint64_t v4 = IOMallocZeroTyped();
  this[1].ivars = (OSObject_IVars *)v4;
  if (!v4)
  {
    IOLog("hash table ivars alloc fail\n");
    return 0;
  }
  BOOL v5 = OSObject::init(this);
  BOOL result = 0;
  if (v5)
  {
    v6.i32[0] = a2;
    uint8x8_t v8 = (uint8x8_t)vcnt_s8(v6);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.i32[0] <= 1u)
    {
      *(_WORD *)this[1].ivars = a2;
      if ((*(__int16 *)this[1].ivars & 0x80000000) == 0)
      {
        *((void *)this[1].ivars + 1) = IOMallocZeroTyped();
        return *((void *)this[1].ivars + 1) != 0;
      }
      return 0;
    }
  }
  return result;
}

BOOL non-virtual thunk to'AppleBCMWLANHashtable::initWithCapacity(AppleBCMWLANHashtable *this, __int32 a2)
{
  return AppleBCMWLANHashtable::initWithCapacity((OSObject *)((char *)this - 64), a2);
}

void AppleBCMWLANHashtable::free(OSObject *this)
{
  ivars = this[1].ivars;
  if (ivars)
  {
    if (*((void *)ivars + 1))
    {
      ((void (*)(OSObject *))this->OSMetaClassBase::__vftable[1].Dispatch)(this);
      uint64_t v3 = this[1].ivars;
      uint64_t v4 = (void *)*((void *)v3 + 1);
      if (v4)
      {
        if ((*(__int16 *)v3 & 0x80000000) == 0)
        {
          IOFree(v4, 8 * *(unsigned __int16 *)v3);
          uint64_t v3 = this[1].ivars;
        }
        *((void *)v3 + 1) = 0;
        uint64_t v3 = this[1].ivars;
      }
      *((void *)v3 + 1) = 0;
      ivars = this[1].ivars;
    }
    *(void *)ivars = 0;
    *((void *)ivars + 1) = 0;
    *((void *)ivars + 2) = 0;
    BOOL v5 = this[1].ivars;
    if (v5)
    {
      IOFree(v5, 0x18uLL);
      this[1].ivars = 0;
    }
  }
  OSObject::free(this);
}

void non-virtual thunk to'AppleBCMWLANHashtable::free(AppleBCMWLANHashtable *this)
{
}

void *AppleBCMWLANHashtable::flushCollection(void *this)
{
  unsigned int v1 = (__int16 *)this[9];
  int v2 = *v1;
  if (v2 >= 1)
  {
    uint64_t v3 = this;
    uint64_t v4 = 0;
    do
    {
      this = *(void **)(*((void *)v1 + 1) + 8 * v4);
      if (this)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 16))(this);
        *(void *)(*(void *)(v3[9] + 8) + 8 * v4) = 0;
        unsigned int v1 = (__int16 *)v3[9];
        LOWORD(v2) = *v1;
      }
      ++v4;
    }
    while (v4 < (__int16)v2);
  }
  v1[1] = 0;
  return this;
}

void *non-virtual thunk to'AppleBCMWLANHashtable::flushCollection(AppleBCMWLANHashtable *this)
{
  return AppleBCMWLANHashtable::flushCollection((void *)this - 6);
}

uint64_t AppleBCMWLANHashtable::iterateObjects(uint64_t a1, uint64_t a2)
{
  int v2 = *(__int16 **)(a1 + 72);
  int v3 = *v2;
  __int16 v4 = v3 - 1;
  if (v3 < 1) {
    return 0;
  }
  LOWORD(v5) = 0;
  __int16 v6 = v2[8];
  uint64_t v7 = *((void *)v2 + 1);
  while (!*(void *)(v7 + 8 * (__int16)((v6 + v5) & v4)))
  {
    int v5 = (__int16)(v5 + 1);
    if (v5 >= v3) {
      return 0;
    }
  }
  return (*(uint64_t (**)(uint64_t, void))(a2 + 16))(a2, *(void *)(v7 + 8 * (__int16)((v6 + v5) & v4)));
}

uint64_t non-virtual thunk to'AppleBCMWLANHashtable::iterateObjects(uint64_t a1, uint64_t a2)
{
  return AppleBCMWLANHashtable::iterateObjects(a1 - 48, a2);
}

uint64_t AppleBCMWLANHashtable::ensureCapacity(AppleBCMWLANHashtable *this)
{
  return **((__int16 **)this + 9);
}

uint64_t non-virtual thunk to'AppleBCMWLANHashtable::ensureCapacity(AppleBCMWLANHashtable *this)
{
  return **((__int16 **)this + 3);
}

uint64_t AppleBCMWLANHashtable::add(AppleBCMWLANHashtable *this, OSObject *a2, unsigned __int16 *a3)
{
  uint64_t result = 3758097115;
  *a3 = -1;
  int v5 = (__int16 *)*((void *)this + 9);
  int v6 = *v5;
  unsigned __int16 v7 = v6 - 1;
  if (v6 >= 1)
  {
    LOWORD(v10) = 0;
    __int16 v11 = v5[8];
    do
    {
      if (((unsigned __int16)(v11 + v10) & v7 & 0x8000) != 0) {
        break;
      }
      unsigned __int16 v12 = (v11 + v10) & v7;
      if ((__int16)v12 >= v6) {
        break;
      }
      if (!*(void *)(*((void *)v5 + 1) + 8 * v12))
      {
        ((void (*)(OSObject *))a2->retain)(a2);
        uint64_t result = 0;
        *(void *)(*(void *)(*((void *)this + 9) + 8) + 8 * v12) = a2;
        *a3 = v12;
        ++*(_WORD *)(*((void *)this + 9) + 2);
        *(_WORD *)(*((void *)this + 9) + 16) = (**((_WORD **)this + 9) - 1) & (v12 + 1);
        return result;
      }
      int v10 = (__int16)(v10 + 1);
    }
    while (v10 < v6);
  }
  return result;
}

uint64_t AppleBCMWLANHashtable::remove(AppleBCMWLANHashtable *this, int a2)
{
  uint64_t v2 = 0;
  if ((a2 & 0x80000000) == 0)
  {
    __int16 v4 = (__int16 *)*((void *)this + 9);
    if (*v4 >= a2)
    {
      uint64_t v5 = (unsigned __int16)a2;
      uint64_t v2 = *(void *)(*((void *)v4 + 1) + 8 * (unsigned __int16)a2);
      if (v2)
      {
        --v4[1];
        uint64_t v6 = *(void *)(*(void *)(*((void *)this + 9) + 8) + 8 * (unsigned __int16)a2);
        if (v6)
        {
          (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
          *(void *)(*(void *)(*((void *)this + 9) + 8) + 8 * v5) = 0;
        }
      }
    }
  }
  return v2;
}

void *AppleBCMWLANHashtable::flush(void *this, OSObject *a2, void (*a3)(OSObject *, __int16, OSObject *, void *), void *a4)
{
  __int16 v4 = (__int16 *)this[9];
  int v5 = *v4;
  if (v5 >= 1)
  {
    uint64_t v9 = this;
    LOWORD(v10) = 0;
    do
    {
      uint64_t v11 = (__int16)((v4[8] + v10) & (v5 - 1));
      unsigned __int16 v12 = *(OSObject **)(*((void *)v4 + 1) + 8 * v11);
      if (v12)
      {
        a3(a2, (v4[8] + v10) & (v5 - 1), v12, a4);
        uint64_t v13 = v9[9];
        this = *(void **)(*(void *)(v13 + 8) + 8 * v11);
        if (this)
        {
          this = (void *)(*(uint64_t (**)(void *))(*this + 16))(this);
          *(void *)(*(void *)(v9[9] + 8) + 8 * v11) = 0;
          uint64_t v13 = v9[9];
        }
        --*(_WORD *)(v13 + 2);
        __int16 v4 = (__int16 *)v9[9];
        LOWORD(v5) = *v4;
      }
      int v10 = (__int16)(v10 + 1);
    }
    while (v10 < (__int16)v5);
  }
  return this;
}

uint64_t AppleBCMWLANHashtable::getCount(AppleBCMWLANHashtable *this)
{
  return *(__int16 *)(*((void *)this + 9) + 2);
}

uint64_t non-virtual thunk to'AppleBCMWLANHashtable::getCount(AppleBCMWLANHashtable *this)
{
  return *(__int16 *)(*((void *)this + 3) + 2);
}

uint64_t AppleBCMWLANHashtable::getCapacity(AppleBCMWLANHashtable *this)
{
  return **((__int16 **)this + 9);
}

uint64_t non-virtual thunk to'AppleBCMWLANHashtable::getCapacity(AppleBCMWLANHashtable *this)
{
  return **((__int16 **)this + 3);
}

OSObject *AppleBCMWLANPowerManager::withDriver(AppleBCMWLANPowerManager *this, AppleBCMWLANCore *a2)
{
  int v5 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANPowerManagerMetaClass, &v5)) {
    return 0;
  }
  int v3 = v5;
  if (v5
    && (((uint64_t (*)(OSObject *, AppleBCMWLANPowerManager *))v5->OSMetaClassBase::__vftable[1].getMetaClass)(v5, this) & 1) == 0)
  {
    ((void (*)(OSObject *))v3->release)(v3);
    return 0;
  }
  return v3;
}

uint64_t AppleBCMWLANPowerManager::initWithDriver(AppleBCMWLANPowerManager *this, AppleBCMWLANCore *a2)
{
  BOOL v4 = OSObject::init((OSObject *)this);
  uint64_t result = 0;
  if (a2)
  {
    if (v4)
    {
      uint64_t result = IOMallocZeroTyped();
      *((void *)this + 6) = result;
      if (result)
      {
        *(void *)uint64_t result = a2;
        *(void *)(*((void *)this + 6) + 24) = (*(uint64_t (**)(AppleBCMWLANCore *))(*(void *)a2
                                                                                                  + 1848))(a2);
        uint64_t v6 = *(void *)(*((void *)this + 6) + 24);
        if (v6)
        {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
          *(void *)(*((void *)this + 6) + 16) = AppleBCMWLANCore::getConfigManager(a2);
          uint64_t v7 = *((void *)this + 6);
          uint64_t v8 = *(void *)(v7 + 16);
          if (v8)
          {
            (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
            *(void *)(*((void *)this + 6) + 8) = AppleBCMWLANCore::getCommander(a2);
            uint64_t v9 = *((void *)this + 6);
            uint64_t v10 = *(void *)(v9 + 8);
            if (v10)
            {
              (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
              *(void *)(*((void *)this + 6) + 48) = AppleBCMWLANCore::getFaultReporter(**((AppleBCMWLANCore ***)this
                                                                                              + 6));
              (*(void (**)(void))(**(void **)(*((void *)this + 6) + 48) + 8))(*(void *)(*((void *)this + 6) + 48));
              uint64_t result = 1;
              *(_DWORD *)(*((void *)this + 6) + 36) = 1;
              *(_DWORD *)(*((void *)this + 6) + 40) = 0;
              *(unsigned char *)(*((void *)this + 6) + 68) = 0;
              *(void *)(*((void *)this + 6) + 72) = 0;
              *(void *)(*((void *)this + 6) + 80) = 0;
              *(_DWORD *)(*((void *)this + 6) + 96) = 0;
              *(_DWORD *)(*((void *)this + 6) + 104) = 0;
              *(_DWORD *)(*((void *)this + 6) + 100) = 0;
              *(void *)(*((void *)this + 6) + 88) = 0;
              *(unsigned char *)(*((void *)this + 6) + 154) = 0;
              *(_DWORD *)(*((void *)this + 6) + 136) = 10;
              uint64_t v11 = *((void *)this + 6);
              *(void *)(v11 + 164) = 0;
              *(void *)(v11 + 156) = 0;
              *(unsigned char *)(*((void *)this + 6) + 180) = 0;
              *(unsigned char *)(*((void *)this + 6) + 69) = 0;
              return result;
            }
            if (*(void *)(v9 + 24) && CCLogStream::shouldLog()) {
              CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d: Failed to get Command Manager\n");
            }
          }
          else if (*(void *)(v7 + 24) && CCLogStream::shouldLog())
          {
            CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Unable to get Config Manager\n");
          }
        }
        else
        {
          ClassNameHelper = (const char *)getClassNameHelper((OSObject *)this);
          IOLog("%s::%s(): Unable to get debug logger\n", ClassNameHelper, "initWithDriver");
        }
        AppleBCMWLANPowerManager::freeResources(this);
        uint64_t result = *((void *)this + 6);
        if (result)
        {
          memset_s((void *)result, 0xB8uLL, 0, 0xB8uLL);
          uint64_t result = *((void *)this + 6);
          if (result)
          {
            IOFree((void *)result, 0xB8uLL);
            uint64_t result = 0;
            *((void *)this + 6) = 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::freeResources(AppleBCMWLANPowerManager *this)
{
  uint64_t v2 = *((void *)this + 6);
  if (v2)
  {
    if (*(void *)(v2 + 24))
    {
      int shouldLog = CCLogStream::shouldLog();
      uint64_t v2 = *((void *)this + 6);
      if (shouldLog)
      {
        CCLogStream::logNoticeIf(*(CCLogStream **)(v2 + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "freeResources", 200, "freeResources");
        uint64_t v2 = *((void *)this + 6);
      }
    }
    uint64_t v4 = *(void *)(v2 + 8);
    if (v4)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
      *(void *)(*((void *)this + 6) + 8) = 0;
      uint64_t v2 = *((void *)this + 6);
    }
    uint64_t v5 = *(void *)(v2 + 24);
    if (v5)
    {
      (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
      *(void *)(*((void *)this + 6) + 24) = 0;
      uint64_t v2 = *((void *)this + 6);
    }
    uint64_t v6 = *(void *)(v2 + 16);
    if (v6)
    {
      (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
      *(void *)(*((void *)this + 6) + 16) = 0;
      uint64_t v2 = *((void *)this + 6);
    }
    uint64_t v7 = *(void *)(v2 + 48);
    if (v7)
    {
      (*(void (**)(uint64_t))(*(void *)v7 + 16))(v7);
      *(void *)(*((void *)this + 6) + 48) = 0;
      uint64_t v2 = *((void *)this + 6);
    }
    uint64_t result = *(void *)(v2 + 24);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result) {
        return CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "freeResources", 206, "freeResources");
      }
    }
  }
  else
  {
    uint64_t result = MEMORY[0x18];
    if (MEMORY[0x18])
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result) {
        return CCLogStream::logCrit(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Failed to allocate AppleBCMWLANCommander_IVars\n", "freeResources", 199);
      }
    }
  }
  return result;
}

uint64_t non-virtual thunk to'AppleBCMWLANPowerManager::initWithDriver(AppleBCMWLANPowerManager *this, AppleBCMWLANCore *a2)
{
  return AppleBCMWLANPowerManager::initWithDriver((AppleBCMWLANPowerManager *)((char *)this - 40), a2);
}

void AppleBCMWLANPowerManager::free(AppleBCMWLANPowerManager *this)
{
  AppleBCMWLANPowerManager::freeResources(this);
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    memset_s(v2, 0xB8uLL, 0, 0xB8uLL);
    int v3 = (void *)*((void *)this + 6);
    if (v3)
    {
      IOFree(v3, 0xB8uLL);
      *((void *)this + 6) = 0;
    }
  }
  OSObject::free((OSObject *)this);
}

void non-virtual thunk to'AppleBCMWLANPowerManager::free(AppleBCMWLANPowerManager *this)
{
}

uint64_t AppleBCMWLANPowerManager::quiesce(AppleBCMWLANPowerManager *this)
{
  uint64_t v2 = *((void *)this + 6);
  if (*(void *)(v2 + 24))
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = *((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(*(CCLogStream **)(v2 + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "quiesce", 228, "quiesce");
      uint64_t v2 = *((void *)this + 6);
    }
  }
  uint64_t result = *(void *)(v2 + 24);
  if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "quiesce", 230, "quiesce");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::configureMIMOPowerSaveConfiguration(AppleBCMWLANPowerManager *this)
{
  uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v2[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v2[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureMIMOPowerSaveConfiguration", 237, "configureMIMOPowerSaveConfiguration");
      uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  if (!AppleBCMWLANCore::isMIMOPowerSaveEnabled(*v2)) {
    return 0;
  }
  if ((AppleBCMWLANCore::isAssociated(**((AppleBCMWLANCore ***)this + 6)) & 1) == 0) {
    AppleBCMWLANPowerManager::configureSISOPowerSavePolicy(this);
  }
  if (AppleBCMWLANPowerManager::configureScanPowerPolicy(this)
    && *(void *)(*((void *)this + 6) + 24)
    && CCLogStream::shouldLog())
  {
    CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:Failed to configure Scan Power Policy\n", "configureMIMOPowerSaveConfiguration", 252);
  }
  uint64_t v4 = AppleBCMWLANPowerManager::configureMRCThreshold(this, -70);
  if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureMIMOPowerSaveConfiguration", 263, "configureMIMOPowerSaveConfiguration");
  }
  return v4;
}

uint64_t AppleBCMWLANPowerManager::configureSISOPowerSavePolicy(AppleBCMWLANPowerManager *this)
{
  uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v2[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v2[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureSISOPowerSavePolicy", 372, "configureSISOPowerSavePolicy");
      uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  if (!AppleBCMWLANCore::isMIMOPowerSaveEnabled(*v2)) {
    return 0;
  }
  uint64_t v4 = AppleBCMWLANPowerManager::configureMIMOPowerSaveParams(this, 1);
  if (v4 && *(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog())
  {
    uint64_t v6 = (void *)*((void *)this + 6);
    uint64_t v7 = (CCLogStream *)v6[3];
    uint64_t v8 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v6 + 112))(*v6, v4);
    CCLogStream::logAlert(v7, "[dk] %s@%d:MIMO_PS: Failed to Configure MIMO Power Save Params %s\n", "configureSISOPowerSavePolicy", 386, v8);
  }
  AppleBCMWLANPowerManager::getMIMOPowerSaveStatus(this);
  if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureSISOPowerSavePolicy", 392, "configureSISOPowerSavePolicy");
  }
  return v4;
}

uint64_t AppleBCMWLANPowerManager::configureScanPowerPolicy(AppleBCMWLANPowerManager *this)
{
  uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v2[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v2[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureScanPowerPolicy", 337, "configureScanPowerPolicy");
      uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  if (!AppleBCMWLANCore::isMIMOPowerSaveEnabled(*v2)) {
    return 0;
  }
  int v13 = 1;
  v12[0] = &v13;
  v12[1] = 4;
  uint64_t v4 = (*(uint64_t (**)(void))(***((void ***)this + 6) + 88))(**((void **)this + 6));
  if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 136))(v4)) {
    uint64_t v5 = AppleBCMWLANCommander::sendIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"scan_ps");
  }
  else {
    uint64_t v5 = AppleBCMWLANCommander::runIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"scan_ps", (uint64_t)v12, 0, 0);
  }
  uint64_t v6 = v5;
  uint64_t v7 = (void *)*((void *)this + 6);
  if (v5)
  {
    if (v7[3])
    {
      int v8 = CCLogStream::shouldLog();
      uint64_t v7 = (void *)*((void *)this + 6);
      if (v8)
      {
        uint64_t v10 = (CCLogStream *)v7[3];
        uint64_t v11 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v7 + 112))(*v7, v6);
        CCLogStream::logAlert(v10, "[dk] %s@%d:MIMO_PS: Failed to Configure Scan Power Policy  %s\n", "configureScanPowerPolicy", 360, v11);
        uint64_t v7 = (void *)*((void *)this + 6);
      }
    }
  }
  if (v7[3] && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureScanPowerPolicy", 363, "configureScanPowerPolicy");
  }
  return v6;
}

uint64_t AppleBCMWLANPowerManager::configureMRCThreshold(AppleBCMWLANPowerManager *this, int a2)
{
  int v13 = a2;
  int v3 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v3[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    int v3 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v3[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureMRCThreshold", 302, "configureMRCThreshold");
      int v3 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  if (!AppleBCMWLANCore::isMIMOPowerSaveEnabled(*v3)) {
    return 0;
  }
  v12[0] = &v13;
  v12[1] = 4;
  uint64_t v5 = (*(uint64_t (**)(void))(***((void ***)this + 6) + 88))(**((void **)this + 6));
  if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 136))(v5)) {
    uint64_t v6 = AppleBCMWLANCommander::sendIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"mrc_rssi_threshold");
  }
  else {
    uint64_t v6 = AppleBCMWLANCommander::runIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"mrc_rssi_threshold", (uint64_t)v12, 0, 0);
  }
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(*((void *)this + 6) + 24);
  if (v7)
  {
    if (v8 && CCLogStream::shouldLog())
    {
      uint64_t v9 = (void *)*((void *)this + 6);
      uint64_t v10 = (CCLogStream *)v9[3];
      (*(void (**)(void, uint64_t))(*(void *)*v9 + 112))(*v9, v7);
      CCLogStream::logAlert(v10, "[dk] %s@%d:MIMO_PS: Failed to Configure Beacon Based Radio Chain Configuration  %s\n");
    }
  }
  else if (v8 && CCLogStream::shouldLog())
  {
    CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:MRC Threshold for Diversity = %d dB\n");
  }
  if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureMRCThreshold", 329, "configureMRCThreshold");
  }
  return v7;
}

uint64_t AppleBCMWLANPowerManager::configureBeaconBasedRadioChainSwitch(AppleBCMWLANPowerManager *this)
{
  uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v2[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v2[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureBeaconBasedRadioChainSwitch", 270, "configureBeaconBasedRadioChainSwitch");
      uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  int v13 = 1;
  if (!AppleBCMWLANCore::isMIMOPowerSaveEnabled(*v2)) {
    return 0;
  }
  v12[0] = &v13;
  v12[1] = 4;
  uint64_t v4 = (*(uint64_t (**)(void))(***((void ***)this + 6) + 88))(**((void **)this + 6));
  if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 136))(v4)) {
    uint64_t v5 = AppleBCMWLANCommander::sendIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"pm_bcnrx");
  }
  else {
    uint64_t v5 = AppleBCMWLANCommander::runIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"pm_bcnrx", (uint64_t)v12, 0, 0);
  }
  uint64_t v6 = v5;
  uint64_t v7 = (void *)*((void *)this + 6);
  if (v5)
  {
    if (v7[3])
    {
      int v8 = CCLogStream::shouldLog();
      uint64_t v7 = (void *)*((void *)this + 6);
      if (v8)
      {
        uint64_t v10 = (CCLogStream *)v7[3];
        uint64_t v11 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v7 + 112))(*v7, v6);
        CCLogStream::logAlert(v10, "[dk] %s@%d:MIMO_PS: Failed to Configure Beacon Based Radio Chain Configuration  %s\n", "configureBeaconBasedRadioChainSwitch", 291, v11);
        uint64_t v7 = (void *)*((void *)this + 6);
      }
    }
  }
  if (v7[3] && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureBeaconBasedRadioChainSwitch", 294, "configureBeaconBasedRadioChainSwitch");
  }
  return v6;
}

uint64_t AppleBCMWLANPowerManager::handleConfigureBcnBasedRadioChainSwitchAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleConfigureBcnBasedRadioChainSwitchAsyncCallback", 1043, "handleConfigureBcnBasedRadioChainSwitchAsyncCallback");
  }
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (a3)
  {
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        uint64_t v6 = *(void **)(a1 + 48);
        uint64_t v7 = (CCLogStream *)v6[3];
        int v8 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v6 + 112))(*v6, a3);
        return CCLogStream::logAlert(v7, "[dk] %s@%d:MIMO_PS: Error: Failed to Configure Beacon Based Radio Chain Switch: %s\n", "handleConfigureBcnBasedRadioChainSwitchAsyncCallback", 1047, v8);
      }
    }
  }
  else if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleConfigureBcnBasedRadioChainSwitchAsyncCallback", 1051, "handleConfigureBcnBasedRadioChainSwitchAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleMRCThresholdConfigurationAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleMRCThresholdConfigurationAsyncCallback", 1073, "handleMRCThresholdConfigurationAsyncCallback");
  }
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (a3)
  {
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        uint64_t v6 = *(void **)(a1 + 48);
        uint64_t v7 = (CCLogStream *)v6[3];
        int v8 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v6 + 112))(*v6, a3);
        return CCLogStream::logAlert(v7, "[dk] %s@%d:MIMO_PS: Error: Failed to Configure MRC Threshold: %s\n", "handleMRCThresholdConfigurationAsyncCallback", 1077, v8);
      }
    }
  }
  else if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleMRCThresholdConfigurationAsyncCallback", 1081, "handleMRCThresholdConfigurationAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleScanPowerPolicyConfigurationAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleScanPowerPolicyConfigurationAsyncCallback", 1088, "handleScanPowerPolicyConfigurationAsyncCallback");
  }
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (a3)
  {
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        uint64_t v6 = *(void **)(a1 + 48);
        uint64_t v7 = (CCLogStream *)v6[3];
        int v8 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v6 + 112))(*v6, a3);
        return CCLogStream::logAlert(v7, "[dk] %s@%d:MIMO_PS: Error: Failed to Configure Scan Power Policy: %s\n", "handleScanPowerPolicyConfigurationAsyncCallback", 1092, v8);
      }
    }
  }
  else if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleScanPowerPolicyConfigurationAsyncCallback", 1096, "handleScanPowerPolicyConfigurationAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::configureMIMOPowerSaveParams(AppleBCMWLANPowerManager *this, int a2)
{
  uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v4[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v4[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureMIMOPowerSaveParams", 498, "configureMIMOPowerSaveParams");
      uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  uint64_t v18 = 1;
  if (!AppleBCMWLANCore::isMIMOPowerSaveEnabled(*v4)) {
    return 0;
  }
  int isAssociated = AppleBCMWLANCore::isAssociated(**((AppleBCMWLANCore ***)this + 6));
  uint64_t v7 = *((void *)this + 6);
  if (isAssociated)
  {
    if (*(void *)(v7 + 24) && CCLogStream::shouldLog())
    {
      if (a2 == 1) {
        v15 = "SISO";
      }
      else {
        v15 = "MIMO";
      }
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Power Policy - %s Not Allowed in Associated state \n", "configureMIMOPowerSaveParams", 509, v15);
    }
    return 0;
  }
  *(_DWORD *)(v7 + 44) = a2;
  char v10 = 1;
  if (a2 == 1) {
    goto LABEL_13;
  }
  if (a2 == 2)
  {
    char v10 = 3;
LABEL_13:
    BYTE1(v18) = v10;
    WORD1(v18) = 3;
    BYTE4(v18) = 1;
  }
  v17[0] = &v18;
  v17[1] = 8;
  uint64_t v11 = (*(uint64_t (**)(void))(***((void ***)this + 6) + 88))(**((void **)this + 6));
  if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 136))(v11)) {
    uint64_t v12 = AppleBCMWLANCommander::sendIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"mimo_ps_cfg");
  }
  else {
    uint64_t v12 = AppleBCMWLANCommander::runIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"mimo_ps_cfg", (uint64_t)v17, 0, 0);
  }
  uint64_t v8 = v12;
  uint64_t v13 = *((void *)this + 6);
  if (!v12)
  {
    if (*(void *)(v13 + 24))
    {
      int v14 = CCLogStream::shouldLog();
      uint64_t v13 = *((void *)this + 6);
      if (v14)
      {
        if (a2 == 1) {
          uint64_t v16 = "SISO";
        }
        else {
          uint64_t v16 = "MIMO";
        }
        CCLogStream::logAlert(*(CCLogStream **)(v13 + 24), "[dk] %s@%d:Configured %s Power Policy\n", "configureMIMOPowerSaveParams", 547, v16);
        uint64_t v13 = *((void *)this + 6);
      }
    }
  }
  if (*(void *)(v13 + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureMIMOPowerSaveParams", 550, "configureMIMOPowerSaveParams");
  }
  return v8;
}

uint64_t AppleBCMWLANPowerManager::getMIMOPowerSaveStatus(AppleBCMWLANPowerManager *this)
{
  long long v34 = 2uLL;
  v33[0] = &v34;
  v33[1] = 0x1000100010;
  uint64_t v2 = (*(uint64_t (**)(void))(***((void ***)this + 6) + 88))(**((void **)this + 6));
  if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 136))(v2))
  {
    v32[0] = this;
    v32[1] = AppleBCMWLANPowerManager::handleGetMIMOPowerSaveStatusAsyncCallback;
    v32[2] = 0;
    int v3 = *(AppleBCMWLANCommander **)(*((void *)this + 6) + 8);
    *(void *)buf = &v34;
    *(void *)v36 = 16;
    int v31 = 1048592;
    int v4 = AppleBCMWLANCommander::sendIOVarGet(v3, (uint64_t)"mimo_ps_status", (uint64_t)buf, (unsigned __int16 *)&v31, (uint64_t)v32, 0);
    if (v4)
    {
      int v5 = v4;
      if ((!*(void *)(*((void *)this + 6) + 24) || (CCLogStream::shouldLogConsole() & 1) == 0)
        && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = 65;
        *(_WORD *)v36 = 2080;
        *(void *)&v36[2] = "getMIMOPowerSaveStatus";
        __int16 v37 = 1024;
        int v38 = 991;
        __int16 v39 = 1024;
        LODWORD(v40) = v5;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%c [dk] %s@%d:  Failed GET IOCTL, cret[0x%08x]\n", buf, 0x1Eu);
      }
      if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d: Failed GET IOCTL, cret[0x%08x]\n", "getMIMOPowerSaveStatus", 991, v5);
      }
    }
    return 0;
  }
  uint64_t v7 = *(AppleBCMWLANCommander **)(*((void *)this + 6) + 8);
  *(void *)buf = &v34;
  *(void *)v36 = 16;
  uint64_t v8 = AppleBCMWLANCommander::runIOVarGet(v7, (uint64_t)"mimo_ps_status", (uint64_t)buf, (uint64_t)v33, 0);
  if (!v8)
  {
    unsigned int v9 = BYTE1(v34);
    int v10 = BYTE1(v34) >> 4;
    uint64_t v11 = BYTE1(v34) & 0xF;
    if (*(void *)(*((void *)this + 6) + 24) && (CCLogStream::shouldLogConsole() & 1) != 0
      || !os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_71;
    }
    if (v9 >= 0x10)
    {
      if (v10 == 1)
      {
        uint64_t v12 = "20Mhz";
      }
      else if (v10 == 2)
      {
        uint64_t v12 = "40Mhz";
      }
      else
      {
        uint64_t v12 = "80Mhz";
        if (v10 != 3) {
          uint64_t v12 = "NONE";
        }
      }
    }
    else
    {
      uint64_t v12 = "20/40/80Mhz";
    }
    if (v11 >= 3)
    {
      uint64_t v13 = "LEGACY";
      if (v11 != 3) {
        uint64_t v13 = "Invalid AP cap/association status";
      }
    }
    else
    {
      uint64_t v13 = off_10038DA70[v11];
    }
    if ((unint64_t)SBYTE2(v34) >= 3)
    {
      int v14 = "Invalid AP cap/association status";
      if (SBYTE2(v34) == 3) {
        int v14 = "LEGACY ASSOCIATION";
      }
    }
    else
    {
      int v14 = off_10038DA88[SBYTE2(v34)];
    }
    if ((unint64_t)SBYTE3(v34) >= 5)
    {
      v15 = "NONE";
      if (SBYTE3(v34) == 5) {
        v15 = "INFORM AP PENDING";
      }
    }
    else
    {
      v15 = off_10038DAA0[SBYTE3(v34)];
    }
    uint64_t v16 = "NOT ACTIVE";
    if (BYTE4(v34) == 1) {
      uint64_t v16 = "ACTIVE";
    }
    if ((unint64_t)SBYTE7(v34) >= 3)
    {
      uint64_t v17 = "NONE";
      if (SBYTE7(v34) == 3) {
        uint64_t v17 = "80Mhz";
      }
    }
    else
    {
      uint64_t v17 = off_10038DAC8[SBYTE7(v34)];
    }
    uint64_t v18 = "NONE";
    if (WORD4(v34) <= 0xFu)
    {
      v19 = "NONE";
      switch(WORD4(v34))
      {
        case 0:
          goto LABEL_66;
        case 1:
          v19 = "LTE CO-EX";
          break;
        case 2:
          v19 = "MIMOPS BSS";
          break;
        case 4:
          v19 = "AWDL BSS";
          break;
        case 8:
          v19 = "SCAN";
          break;
        default:
          goto LABEL_63;
      }
      goto LABEL_66;
    }
    if (WORD4(v34) > 0x3Fu)
    {
      if (WORD4(v34) == 64)
      {
        v19 = "TEMP SENSE";
        goto LABEL_66;
      }
      if (WORD4(v34) == 128)
      {
        v19 = "IOVAR";
        goto LABEL_66;
      }
    }
    else
    {
      if (WORD4(v34) == 16)
      {
        v19 = "TXPRR";
        goto LABEL_66;
      }
      if (WORD4(v34) == 32)
      {
        v19 = "PWR THROTTLE";
LABEL_66:
        if ((unint64_t)SBYTE12(v34) >= 3)
        {
          if (SBYTE12(v34) == 3) {
            uint64_t v18 = "80Mhz";
          }
        }
        else
        {
          uint64_t v18 = off_10038DAC8[SBYTE12(v34)];
        }
        *(_DWORD *)buf = 67113474;
        *(_DWORD *)&buf[4] = 78;
        *(_WORD *)v36 = 2080;
        *(void *)&v36[2] = "getMIMOPowerSaveStatus";
        __int16 v37 = 1024;
        int v38 = 1007;
        __int16 v39 = 2080;
        v40 = v12;
        __int16 v41 = 2080;
        v42 = v13;
        __int16 v43 = 2080;
        v44 = v14;
        __int16 v45 = 2080;
        v46 = v15;
        __int16 v47 = 2080;
        v48 = v16;
        __int16 v49 = 1024;
        int v50 = BYTE5(v34);
        __int16 v51 = 1024;
        int v52 = BYTE6(v34);
        __int16 v53 = 2080;
        v54 = v17;
        __int16 v55 = 2080;
        v56 = v19;
        __int16 v57 = 1024;
        int v58 = BYTE10(v34);
        __int16 v59 = 1024;
        int v60 = BYTE11(v34);
        __int16 v61 = 2080;
        v62 = v18;
        __int16 v63 = 1024;
        int v64 = BYTE13(v34);
        __int16 v65 = 1024;
        int v66 = BYTE14(v34);
        __int16 v67 = 1024;
        int v68 = HIBYTE(v34);
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%c [dk] %s@%d: MIMO POWER SAVE STATUS:AP BW = %s, AP CAPABILITY = %s, Assoc State = %s, MIMO PS State = %s, MRC State = %s, BSS RxChain = %d, BSS TxChain = %d, BSS Bandwidth = %s, HW State = %s, HW Rx Chain = %d, HW Tx Chain = %d, HW Bandwidth = %s, BCNRX State = %d, Basic Rates Present = %d, BCMC RX State = %d\n", buf, 0x92u);
LABEL_71:
        uint64_t v20 = *((void *)this + 6);
        if (!*(void *)(v20 + 24) || (int shouldLog = CCLogStream::shouldLog(), v20 = *((void *)this + 6), !shouldLog))
        {
LABEL_73:
          uint64_t v6 = 0;
          *(_OWORD *)(v20 + 156) = v34;
          return v6;
        }
        if (v9 >= 0x10)
        {
          if (v10 == 1)
          {
            v23 = "20Mhz";
          }
          else if (v10 == 2)
          {
            v23 = "40Mhz";
          }
          else
          {
            v23 = "NONE";
            if (v10 == 3) {
              v23 = "80Mhz";
            }
          }
        }
        else
        {
          v23 = "20/40/80Mhz";
        }
        if (v11 >= 3)
        {
          v24 = "Invalid AP cap/association status";
          if (v11 == 3) {
            v24 = "LEGACY";
          }
        }
        else
        {
          v24 = off_10038DA70[v11];
        }
        if ((unint64_t)SBYTE2(v34) >= 3)
        {
          if (SBYTE2(v34) == 3) {
            v25 = "LEGACY ASSOCIATION";
          }
          else {
            v25 = "Invalid AP cap/association status";
          }
        }
        else
        {
          v25 = off_10038DA88[SBYTE2(v34)];
        }
        if ((unint64_t)SBYTE3(v34) >= 5)
        {
          if (SBYTE3(v34) == 5) {
            v26 = "INFORM AP PENDING";
          }
          else {
            v26 = "NONE";
          }
        }
        else
        {
          v26 = off_10038DAA0[SBYTE3(v34)];
        }
        if (BYTE4(v34) == 1) {
          v27 = "ACTIVE";
        }
        else {
          v27 = "NOT ACTIVE";
        }
        if ((unint64_t)SBYTE7(v34) >= 3)
        {
          if (SBYTE7(v34) == 3) {
            v28 = "80Mhz";
          }
          else {
            v28 = "NONE";
          }
        }
        else
        {
          v28 = off_10038DAC8[SBYTE7(v34)];
        }
        if (WORD4(v34) <= 0xFu)
        {
          v29 = "NONE";
          switch(WORD4(v34))
          {
            case 0:
              goto LABEL_123;
            case 1:
              v29 = "LTE CO-EX";
              break;
            case 2:
              v29 = "MIMOPS BSS";
              break;
            case 4:
              v29 = "AWDL BSS";
              break;
            case 8:
              v29 = "SCAN";
              break;
            default:
              goto LABEL_120;
          }
          goto LABEL_123;
        }
        if (WORD4(v34) > 0x3Fu)
        {
          if (WORD4(v34) == 64)
          {
            v29 = "TEMP SENSE";
            goto LABEL_123;
          }
          if (WORD4(v34) == 128)
          {
            v29 = "IOVAR";
            goto LABEL_123;
          }
        }
        else
        {
          if (WORD4(v34) == 16)
          {
            v29 = "TXPRR";
            goto LABEL_123;
          }
          if (WORD4(v34) == 32)
          {
            v29 = "PWR THROTTLE";
            goto LABEL_123;
          }
        }
LABEL_120:
        if (WORD4(v34) == 256) {
          v29 = "AP BSS";
        }
        else {
          v29 = "NONE";
        }
LABEL_123:
        if ((unint64_t)SBYTE12(v34) >= 3)
        {
          if (SBYTE12(v34) == 3) {
            v30 = "80Mhz";
          }
          else {
            v30 = "NONE";
          }
        }
        else
        {
          v30 = off_10038DAC8[SBYTE12(v34)];
        }
        CCLogStream::logNotice(*(CCLogStream **)(v20 + 24), "[dk] %s@%d:MIMO POWER SAVE STATUS:AP BW = %s, AP CAPABILITY = %s, Assoc State = %s, MIMO PS State = %s, MRC State = %s, BSS RxChain = %d, BSS TxChain = %d, BSS Bandwidth = %s, HW State = %s, HW Rx Chain = %d, HW Tx Chain = %d, HW Bandwidth = %s, BCNRX State = %d, Basic Rates Present = %d, BCMC RX State = %d\n", "getMIMOPowerSaveStatus", 1007, v23, v24, v25, v26, v27, BYTE5(v34), BYTE6(v34), v28, v29, BYTE10(v34), BYTE11(v34), v30, BYTE13(v34),
          BYTE14(v34),
          HIBYTE(v34));
        uint64_t v20 = *((void *)this + 6);
        goto LABEL_73;
      }
    }
LABEL_63:
    if (WORD4(v34) == 256) {
      v19 = "AP BSS";
    }
    else {
      v19 = "NONE";
    }
    goto LABEL_66;
  }
  uint64_t v6 = v8;
  if ((!*(void *)(*((void *)this + 6) + 24) || (CCLogStream::shouldLogConsole() & 1) == 0)
    && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109634;
    *(_DWORD *)&buf[4] = 65;
    *(_WORD *)v36 = 2080;
    *(void *)&v36[2] = "getMIMOPowerSaveStatus";
    __int16 v37 = 1024;
    int v38 = 999;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%c [dk] %s@%d: Failed to collect MIMO PS Status values \n", buf, 0x18u);
  }
  if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Failed to collect MIMO PS Status values \n", "getMIMOPowerSaveStatus", 999);
  }
  return v6;
}

uint64_t AppleBCMWLANPowerManager::configureMIMOPowerSavePolicy(AppleBCMWLANPowerManager *this)
{
  uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v2[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v2[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureMIMOPowerSavePolicy", 400, "configureMIMOPowerSavePolicy");
      uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  if (!AppleBCMWLANCore::isMIMOPowerSaveEnabled(*v2)) {
    return 0;
  }
  uint64_t v4 = AppleBCMWLANPowerManager::configureMIMOPowerSaveParams(this, 2);
  if (v4 && *(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:MIMO PS: Failed to configure MIMO Power Save Policy\n", "configureMIMOPowerSavePolicy", 410);
  }
  AppleBCMWLANPowerManager::getMIMOPowerSaveStatus(this);
  if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureMIMOPowerSavePolicy", 416, "configureMIMOPowerSavePolicy");
  }
  return v4;
}

uint64_t AppleBCMWLANPowerManager::configureMIMOPowerSaveAssociatedSleepEntry(AppleBCMWLANPowerManager *this)
{
  uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v2[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v2[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureMIMOPowerSaveAssociatedSleepEntry", 425, "configureMIMOPowerSaveAssociatedSleepEntry");
      uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  if (!AppleBCMWLANCore::isMIMOPowerSaveEnabled(*v2)) {
    return 0;
  }
  if (AppleBCMWLANCore::is4377Up(**((AppleBCMWLANCore ***)this + 6))) {
    int v4 = -70;
  }
  else {
    int v4 = -128;
  }
  if (AppleBCMWLANPowerManager::configureMRCThreshold(this, v4)
    && *(void *)(*((void *)this + 6) + 24)
    && CCLogStream::shouldLog())
  {
    CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:Failed to Configure MRC Threshold\n", "configureMIMOPowerSaveAssociatedSleepEntry", 436);
  }
  AppleBCMWLANPowerManager::configureTVPMPeriodicity((AppleBCMWLANCore ***)this, 10);
  uint64_t v5 = AppleBCMWLANPowerManager::configureBeaconBasedChannelWidthSwitch((AppleBCMWLANCore ***)this, 1);
  uint64_t v6 = (void *)*((void *)this + 6);
  if (v5)
  {
    if (v6[3])
    {
      int v7 = CCLogStream::shouldLog();
      uint64_t v6 = (void *)*((void *)this + 6);
      if (v7)
      {
        unsigned int v9 = (CCLogStream *)v6[3];
        int v10 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v6 + 112))(*v6, v5);
        CCLogStream::logAlertIf(v9, 0x20uLL, "[dk] %s@%d: Error: cannot configure beacon based Channel Width : %s\n", "configureMIMOPowerSaveAssociatedSleepEntry", 452, v10);
        uint64_t v6 = (void *)*((void *)this + 6);
      }
    }
  }
  if (v6[3] && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureMIMOPowerSaveAssociatedSleepEntry", 456, "configureMIMOPowerSaveAssociatedSleepEntry");
  }
  return v5;
}

uint64_t AppleBCMWLANPowerManager::configureTVPMPeriodicity(AppleBCMWLANCore ***this, int a2)
{
  if (!AppleBCMWLANCore::checkForTVPMSupport(*this[6])) {
    return 0;
  }
  int isAssociated = AppleBCMWLANCore::isAssociated(*this[6]);
  uint64_t v5 = this[6];
  if (isAssociated && a2 == 1 && !*((unsigned char *)v5 + 181))
  {
    if (v5[3] && CCLogStream::shouldLog()) {
      CCLogStream::logInfo(this[6][3], "[dk] %s@%d:Can not program TVPM Periodicty to %d, Waiting for IP address\n", "configureTVPMPeriodicity", 3572, 1);
    }
    return 0;
  }
  if (*((_DWORD *)v5 + 34) == a2)
  {
    if (v5[3] && CCLogStream::shouldLog()) {
      CCLogStream::logInfoIf(this[6][3], 0x20uLL, "[dk] %s@%d:Programmed TVPM period is same as new TVPM Period\n", "configureTVPMPeriodicity", 3577);
    }
    return 0;
  }
  uint64_t v6 = 3758097084;
  uint64_t v8 = IOMallocZeroData();
  if (!v8) {
    return 3758097085;
  }
  uint64_t v9 = v8;
  *(void *)uint64_t v8 = 0x40004000C0001;
  *(_DWORD *)(v8 + 8) = a2;
  if ((unint64_t)AppleBCMWLANCommander::getMaxCmdTxPayload(this[6][1]) > 0xB)
  {
    v16[0] = v9;
    v16[1] = 12;
    uint64_t v10 = (*(uint64_t (**)(void))(*(void *)*this[6] + 88))(*this[6]);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 136))(v10)) {
      uint64_t v11 = AppleBCMWLANCommander::sendIOVarSet(this[6][1], (uint64_t)"tvpm");
    }
    else {
      uint64_t v11 = AppleBCMWLANCommander::runIOVarSet(this[6][1], (uint64_t)"tvpm", (uint64_t)v16, 0, 0);
    }
    uint64_t v6 = v11;
    uint64_t v12 = this[6];
    if (v11)
    {
      if (v12[3] && CCLogStream::shouldLog())
      {
        uint64_t v13 = this[6];
        int v14 = v13[3];
        v15 = (const char *)(*(uint64_t (**)(AppleBCMWLANCore *, uint64_t))(*(void *)*v13 + 112))(*v13, v6);
        CCLogStream::logAlert(v14, "[dk] %s@%d:TVPM: Failed to Configure TVPM Periodicity  %s\n", "configureTVPMPeriodicity", 3616, v15);
      }
    }
    else
    {
      *((_DWORD *)v12 + 34) = a2;
    }
    if (this[6][3] && CCLogStream::shouldLog()) {
      CCLogStream::logInfo(this[6][3], "[dk] %s@%d: TVPM Periodicity is = %d\n");
    }
  }
  else if (this[6][3] && CCLogStream::shouldLog())
  {
    CCLogStream::logInfo(this[6][3], "[dk] %s@%d:TVPM: invalid request buffer length %lu\n");
  }
  IOFreeData();
  return v6;
}

uint64_t AppleBCMWLANPowerManager::configureBeaconBasedChannelWidthSwitch(AppleBCMWLANCore ***this, int a2)
{
  uint64_t v4 = 3758097085;
  if (a2) {
    int v5 = 1;
  }
  else {
    int v5 = 3;
  }
  if (!AppleBCMWLANCore::isBcnCWSwitchEnabled(*this[6])) {
    return 3758097095;
  }
  if (!AppleBCMWLANCore::isAssociated(*this[6])) {
    return 3758096385;
  }
  uint64_t v6 = this[6];
  if (*((unsigned char *)v6 + 163) != 3 || *((unsigned __int8 *)v6 + 172) == v5) {
    return 3758096385;
  }
  uint64_t v8 = IOMallocZeroData();
  if (v8)
  {
    uint64_t v9 = (AppleBCMWLANCore ***)v8;
    *(_DWORD *)uint64_t v8 = 589825;
    *(_WORD *)(v8 + 4) = 0;
    *(unsigned char *)(v8 + 8) = a2;
    uint64_t v10 = (*(uint64_t (**)(void))(*(void *)*this[6] + 88))(*this[6]);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 136))(v10))
    {
      uint64_t v20 = this;
      uint64_t v21 = (uint64_t)AppleBCMWLANPowerManager::handleConfigureBcnBasedRadioChannelWidthSwitchAsyncCallback;
      uint64_t v22 = 0;
      uint64_t v11 = AppleBCMWLANCommander::sendIOVarSet(this[6][1], (uint64_t)"psbw_cfg");
    }
    else
    {
      uint64_t v12 = this[6][1];
      uint64_t v20 = v9;
      uint64_t v21 = 9;
      uint64_t v11 = AppleBCMWLANCommander::runIOVarSet(v12, (uint64_t)"psbw_cfg", (uint64_t)&v20, 0, 0);
    }
    uint64_t v4 = v11;
    if (v11 == -469793788)
    {
      if (this[6][3] && CCLogStream::shouldLog())
      {
        int v14 = this[6];
        v15 = v14[3];
        uint64_t v16 = (const char *)(*(uint64_t (**)(AppleBCMWLANCore *, uint64_t))(*(void *)*v14 + 112))(*v14, 3825173508);
        CCLogStream::logAlert(v15, "[dk] %s@%d:MIMO_PS: Failed to Configure Beacon Based Radio Channel Width Configuration  %s\n", "configureBeaconBasedChannelWidthSwitch", 3799, v16);
      }
      goto LABEL_33;
    }
    if (!v11)
    {
      *((unsigned char *)this[6] + 172) = v5;
      if (this[6][3] && CCLogStream::shouldLog())
      {
        if (a2) {
          uint64_t v13 = "20Mhz";
        }
        else {
          uint64_t v13 = "80Mhz";
        }
        CCLogStream::logInfo(this[6][3], "[dk] %s@%d:Configured Channel Bandwith to %s \n", "configureBeaconBasedChannelWidthSwitch", 3796, v13);
      }
      goto LABEL_33;
    }
    if (this[6][3] && CCLogStream::shouldLog())
    {
      uint64_t v17 = this[6];
      uint64_t v18 = v17[3];
      v19 = (const char *)(*(uint64_t (**)(AppleBCMWLANCore *, uint64_t))(*(void *)*v17 + 112))(*v17, v4);
      CCLogStream::logAlert(v18, "[dk] %s@%d:MIMO_PS: Failed to Configure Beacon Based Radio Channel Width Configuration  %s\n", "configureBeaconBasedChannelWidthSwitch", 3789, v19);
      if (a2) {
        goto LABEL_33;
      }
    }
    else if (a2)
    {
LABEL_33:
      IOFreeData();
      return v4;
    }
    CCFaultReporter::reportFault(this[6][6], 5u, "/Library/Caches/com.apple.xbs/Sources/AppleBCMWLANV3_driverkit/AppleBCMWLANPowerManager.cpp", 0xECFu, "configureBeaconBasedChannelWidthSwitch", 0, -469790463, 0);
    goto LABEL_33;
  }
  if (this[6][3] && CCLogStream::shouldLog()) {
    CCLogStream::logAlert(this[6][3], "[dk] %s@%d:BCN Channel Switch Param buffer allocation failed\n", "configureBeaconBasedChannelWidthSwitch", 3755);
  }
  return v4;
}

uint64_t AppleBCMWLANPowerManager::configureMIMOPowerSaveAssociatedSleepExit(AppleBCMWLANPowerManager *this)
{
  uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v2[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v2[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureMIMOPowerSaveAssociatedSleepExit", 464, "configureMIMOPowerSaveAssociatedSleepExit");
      uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  if (!AppleBCMWLANCore::isMIMOPowerSaveEnabled(*v2)) {
    return 0;
  }
  if (*(_DWORD *)(*((void *)this + 6) + 40) != 1
    && AppleBCMWLANPowerManager::configureMRCThreshold(this, -70)
    && *(void *)(*((void *)this + 6) + 24)
    && CCLogStream::shouldLog())
  {
    CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:Failed to Configure MRC Threshold\n", "configureMIMOPowerSaveAssociatedSleepExit", 478);
  }
  uint64_t v4 = AppleBCMWLANPowerManager::configureBeaconBasedChannelWidthSwitch((AppleBCMWLANCore ***)this, 0);
  int v5 = (void *)*((void *)this + 6);
  if (v4)
  {
    if (v5[3])
    {
      int v6 = CCLogStream::shouldLog();
      int v5 = (void *)*((void *)this + 6);
      if (v6)
      {
        uint64_t v8 = (CCLogStream *)v5[3];
        uint64_t v9 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 112))(*v5, v4);
        CCLogStream::logAlertIf(v8, 0x20uLL, "[dk] %s@%d:MIMO_PS: Failed to Configure Beacon Based Radio Channel Width Configuration  %s\n", "configureMIMOPowerSaveAssociatedSleepExit", 486, v9);
        int v5 = (void *)*((void *)this + 6);
      }
    }
  }
  if (v5[3] && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureMIMOPowerSaveAssociatedSleepExit", 489, "configureMIMOPowerSaveAssociatedSleepExit");
  }
  return v4;
}

uint64_t AppleBCMWLANPowerManager::handleConfigureMIMOPSCfgAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleConfigureMIMOPSCfgAsyncCallback", 1148, "handleConfigureMIMOPSCfgAsyncCallback");
  }
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (a3)
  {
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        int v6 = *(void **)(a1 + 48);
        int v7 = (CCLogStream *)v6[3];
        uint64_t v8 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v6 + 112))(*v6, a3);
        return CCLogStream::logAlert(v7, "[dk] %s@%d:MIMO_PS: Error: Failed MIMO Power Save Configuration: %s\n", "handleConfigureMIMOPSCfgAsyncCallback", 1152, v8);
      }
    }
  }
  else if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleConfigureMIMOPSCfgAsyncCallback", 1156, "handleConfigureMIMOPSCfgAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::setBatterySaveModeConfiguration(AppleBCMWLANCore ***a1, _DWORD *a2)
{
  uint64_t v4 = a1[6];
  if (v4[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v4 = a1[6];
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v4[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "setBatterySaveModeConfiguration", 562, "setBatterySaveModeConfiguration");
      uint64_t v4 = a1[6];
    }
  }
  if (!AppleBCMWLANCore::isMIMOPowerSaveEnabled(*v4)) {
    return 0;
  }
  *((_DWORD *)a1[6] + 10) = *a2;
  char isAssociated = AppleBCMWLANCore::isAssociated(*a1[6]);
  int v7 = a1[6];
  if ((isAssociated & 1) == 0)
  {
    if (v7[3] && CCLogStream::shouldLog()) {
      CCLogStream::logAlertIf(a1[6][3], 0x20uLL, "[dk] %s@%d:Device is not Associated, operate in SISO while Un-Associated\n", "setBatterySaveModeConfiguration", 573);
    }
    return 0;
  }
  int v8 = *((_DWORD *)v7 + 10);
  if (v8 == 1)
  {
    if (AppleBCMWLANCore::is4377Up(*v7)) {
      int v9 = -70;
    }
    else {
      int v9 = -128;
    }
    uint64_t v10 = AppleBCMWLANPowerManager::configureMRCThreshold((AppleBCMWLANPowerManager *)a1, v9);
    int v7 = a1[6];
    if (*((_DWORD *)v7 + 10)) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  uint64_t v10 = 0;
  if (!v8)
  {
LABEL_18:
    uint64_t v10 = AppleBCMWLANPowerManager::configureMRCThreshold((AppleBCMWLANPowerManager *)a1, -70);
    int v7 = a1[6];
  }
LABEL_19:
  if (v7[3] && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(a1[6][3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "setBatterySaveModeConfiguration", 614, "setBatterySaveModeConfiguration");
  }
  return v10;
}

uint64_t AppleBCMWLANPowerManager::configureMIMOPowerSaveForJoin(AppleBCMWLANPowerManager *this, int a2)
{
  uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v4[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v4[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureMIMOPowerSaveForJoin", 623, "configureMIMOPowerSaveForJoin");
      uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  uint64_t result = AppleBCMWLANCore::isMIMOPowerSaveEnabled(*v4);
  if (result)
  {
    if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog())
    {
      if (a2) {
        uint64_t v11 = "SISO";
      }
      else {
        uint64_t v11 = "MIMO";
      }
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:%s assoc\n", "configureMIMOPowerSaveForJoin", 629, v11);
    }
    if (a2)
    {
      int v7 = AppleBCMWLANPowerManager::configureSISOPowerSavePolicy(this);
      int v8 = (AppleBCMWLANCore **)*((void *)this + 6);
      if (v7)
      {
        if (v8[3])
        {
          int v9 = CCLogStream::shouldLog();
          int v8 = (AppleBCMWLANCore **)*((void *)this + 6);
          if (v9)
          {
            CCLogStream::logAlertIf(v8[3], 0x20uLL, "[dk] %s@%d:Failed to configure SISO Power Policy for Low Power Mode\n", "configureMIMOPowerSaveForJoin", 635);
            int v8 = (AppleBCMWLANCore **)*((void *)this + 6);
          }
        }
      }
      if (AppleBCMWLANCore::isAntennaInEfficiencyMitigationSupported(*v8))
      {
        int v10 = -65;
      }
      else if (AppleBCMWLANCore::is4377Up(**((AppleBCMWLANCore ***)this + 6)))
      {
        int v10 = -70;
      }
      else
      {
        int v10 = -128;
      }
    }
    else
    {
      if (AppleBCMWLANPowerManager::configureMIMOPowerSavePolicy(this)
        && *(void *)(*((void *)this + 6) + 24)
        && CCLogStream::shouldLog())
      {
        CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:Failed to configure MIMO Power Policy\n", "configureMIMOPowerSaveForJoin", 643);
      }
      int v10 = -70;
    }
    AppleBCMWLANPowerManager::configureMRCThreshold(this, v10);
    uint64_t result = *(void *)(*((void *)this + 6) + 24);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result) {
        return CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureMIMOPowerSaveForJoin", 657, "configureMIMOPowerSaveForJoin");
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::configureMIMOPowerSaveForJoinFailure(AppleBCMWLANPowerManager *this)
{
  uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v2[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v2[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureMIMOPowerSaveForJoinFailure", 665, "configureMIMOPowerSaveForJoinFailure");
      uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  uint64_t result = AppleBCMWLANCore::isMIMOPowerSaveEnabled(*v2);
  if (result)
  {
    int v5 = AppleBCMWLANPowerManager::configureSISOPowerSavePolicy(this);
    uint64_t v6 = *((void *)this + 6);
    if (v5)
    {
      if (*(void *)(v6 + 24))
      {
        int v7 = CCLogStream::shouldLog();
        uint64_t v6 = *((void *)this + 6);
        if (v7)
        {
          CCLogStream::logAlertIf(*(CCLogStream **)(v6 + 24), 0x20uLL, "[dk] %s@%d:Failed to configure SISO Power Save Policy \n", "configureMIMOPowerSaveForJoinFailure", 674);
          uint64_t v6 = *((void *)this + 6);
        }
      }
    }
    uint64_t result = *(void *)(v6 + 24);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result) {
        return CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureMIMOPowerSaveForJoinFailure", 677, "configureMIMOPowerSaveForJoinFailure");
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::getCurrentRadioChainConfig(AppleBCMWLANCore ***a1, _DWORD *a2)
{
  if (!AppleBCMWLANCore::isMIMOPowerSaveEnabled(*a1[6])) {
    return 0;
  }
  unsigned __int16 v55 = 0;
  v54 = 0;
  AppleBCMWLANPowerManager::getMIMOPowerSaveConfigParams((AppleBCMWLANPowerManager *)a1);
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)*a1[6] + 88))(*a1[6]);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 136))(v4))
  {
    __int16 v51 = a1;
    uint64_t v52 = (uint64_t)AppleBCMWLANPowerManager::handleGetTxRadioChainsAsyncCallback;
    uint64_t v53 = 0;
    int v5 = a1[6][1];
    LODWORD(v48) = 262148;
    int v6 = AppleBCMWLANCommander::sendIOVarGet(v5, (uint64_t)"txchain", (uint64_t)&kNoTxPayload, (unsigned __int16 *)&v48, (uint64_t)&v51, 0);
    int v7 = a1[6];
    if (v6)
    {
      int v8 = v6;
      if (v7[3])
      {
        int shouldLog = CCLogStream::shouldLog();
        int v7 = a1[6];
        if (shouldLog)
        {
          CCLogStream::logAlert(v7[3], "[dk] %s@%d: Failed GET IOCTL, cret[0x%08x]\n", "getCurrentRadioChainConfig", 707, v8);
          int v7 = a1[6];
        }
      }
    }
    v48 = a1;
    uint64_t v49 = (uint64_t)AppleBCMWLANPowerManager::handleGetRxRadioChainsAsyncCallback;
    uint64_t v50 = 0;
    int v10 = v7[1];
    LODWORD(v45) = 262148;
    int v11 = AppleBCMWLANCommander::sendIOVarGet(v10, (uint64_t)"rxchain", (uint64_t)&kNoTxPayload, (unsigned __int16 *)&v45, (uint64_t)&v48, 0);
    uint64_t v12 = a1[6];
    if (v11)
    {
      int v13 = v11;
      if (v12[3])
      {
        int v14 = CCLogStream::shouldLog();
        uint64_t v12 = a1[6];
        if (v14)
        {
          CCLogStream::logAlert(v12[3], "[dk] %s@%d: Failed GET IOCTL, cret[0x%08x]\n", "getCurrentRadioChainConfig", 716, v13);
          uint64_t v12 = a1[6];
        }
      }
    }
    __int16 v45 = a1;
    uint64_t v46 = (uint64_t)AppleBCMWLANPowerManager::handleGetRxChannelSpecAsyncCallback;
    uint64_t v47 = 0;
    v15 = v12[1];
    LODWORD(v56) = 131074;
    int v16 = AppleBCMWLANCommander::sendIOVarGet(v15, (uint64_t)"chanspec", (uint64_t)&kNoTxPayload, (unsigned __int16 *)&v56, (uint64_t)&v45, 0);
    if (v16)
    {
      int v17 = v16;
      if (a1[6][3])
      {
        if (CCLogStream::shouldLog()) {
          CCLogStream::logAlert(a1[6][3], "[dk] %s@%d: Failed GET IOCTL, cret[0x%08x]\n", "getCurrentRadioChainConfig", 725, v17);
        }
      }
    }
    uint64_t v18 = 0;
  }
  else
  {
    __int16 v51 = (AppleBCMWLANCore ***)((char *)&v54 + 4);
    uint64_t v52 = 0x400040004;
    int v19 = AppleBCMWLANCommander::runIOVarGet(a1[6][1], (uint64_t)"txchain", (uint64_t)&kNoTxPayload, (uint64_t)&v51, 0);
    uint64_t v20 = a1[6];
    if (v19)
    {
      int v21 = v19;
      if (v20[3])
      {
        int v22 = CCLogStream::shouldLog();
        uint64_t v20 = a1[6];
        if (v22)
        {
          CCLogStream::logAlert(v20[3], "[dk] %s@%d: Failed GET IOCTL, cret[0x%08x]\n", "getCurrentRadioChainConfig", 734, v21);
          uint64_t v20 = a1[6];
        }
      }
    }
    v48 = (AppleBCMWLANCore ***)&v54;
    uint64_t v49 = 0x400040004;
    int v23 = AppleBCMWLANCommander::runIOVarGet(v20[1], (uint64_t)"rxchain", (uint64_t)&kNoTxPayload, (uint64_t)&v48, 0);
    v24 = a1[6];
    if (v23)
    {
      int v25 = v23;
      if (v24[3])
      {
        int v26 = CCLogStream::shouldLog();
        v24 = a1[6];
        if (v26)
        {
          CCLogStream::logAlert(v24[3], "[dk] %s@%d: Failed GET IOCTL, cret[0x%08x]\n", "getCurrentRadioChainConfig", 741, v25);
          v24 = a1[6];
        }
      }
    }
    __int16 v45 = (AppleBCMWLANCore ***)&v55;
    uint64_t v46 = 0x200020002;
    uint64_t v18 = AppleBCMWLANCommander::runIOVarGet(v24[1], (uint64_t)"chanspec", (uint64_t)&kNoTxPayload, (uint64_t)&v45, 0);
    a1[6][15] = v54;
    *((_DWORD *)a1[6] + 33) = v55;
  }
  uint64_t v56 = 0;
  v48 = (AppleBCMWLANCore ***)&v56;
  uint64_t v49 = 0x800080008;
  uint64_t v27 = (*(uint64_t (**)(void))(*(void *)*a1[6] + 88))(*a1[6]);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v27 + 136))(v27))
  {
    __int16 v51 = a1;
    uint64_t v52 = (uint64_t)AppleBCMWLANPowerManager::handleConfigureMIMOPSCfgGetAsyncCallback;
    uint64_t v53 = 0;
    v28 = a1[6][1];
    __int16 v45 = (AppleBCMWLANCore ***)&v56;
    uint64_t v46 = 8;
    int v44 = 524296;
    int v29 = AppleBCMWLANCommander::sendIOVarGet(v28, (uint64_t)"mimo_ps_cfg", (uint64_t)&v45, (unsigned __int16 *)&v44, (uint64_t)&v51, 0);
    if (v29)
    {
      int v30 = v29;
      if (a1[6][3])
      {
        if (CCLogStream::shouldLog()) {
          CCLogStream::logAlert(a1[6][3], "[dk] %s@%d: Failed GET IOCTL, cret[0x%08x]\n", "getCurrentRadioChainConfig", 768, v30);
        }
      }
    }
  }
  else
  {
    int v31 = a1[6][1];
    __int16 v51 = (AppleBCMWLANCore ***)&v56;
    uint64_t v52 = 8;
    uint64_t v18 = AppleBCMWLANCommander::runIOVarGet(v31, (uint64_t)"mimo_ps_cfg", (uint64_t)&v51, (uint64_t)&v48, 0);
    *((_DWORD *)a1[6] + 32) = BYTE2(v56);
  }
  a2[9] = *((_DWORD *)a1[6] + 10);
  a2[8] = *((_DWORD *)a1[6] + 8);
  a2[10] = *((_DWORD *)a1[6] + 9);
  *a2 = BYTE1(v56);
  a2[1] = *((_DWORD *)a1[6] + 30);
  a2[2] = *((_DWORD *)a1[6] + 31);
  int v32 = *((_DWORD *)a1[6] + 33) & 0x3800;
  switch(v32)
  {
    case 0x1000:
      int v33 = 1;
      break;
    case 0x2000:
      int v33 = 3;
      break;
    case 0x1800:
      int v33 = 2;
      break;
    default:
      int v33 = 0;
      break;
  }
  a2[4] = v33;
  a2[5] = *((_DWORD *)a1[6] + 27);
  a2[6] = *((_DWORD *)a1[6] + 29);
  a2[7] = *((_DWORD *)a1[6] + 28);
  a2[3] = *((_DWORD *)a1[6] + 32);
  if (a1[6][3] && CCLogStream::shouldLog())
  {
    v35 = a1[6];
    int v36 = a2[3];
    if (v36)
    {
      if (v36 == 1)
      {
        __int16 v37 = "DYNAMIC SMPS";
      }
      else if (v36 == 3)
      {
        __int16 v37 = "SMPS DISABLED";
      }
      else
      {
        __int16 v37 = "SMPS RESERVED";
      }
    }
    else
    {
      __int16 v37 = "STATIC SMPS";
    }
    uint64_t v38 = (int)a2[4];
    if (v38 >= 3)
    {
      if (v38 == 3) {
        __int16 v39 = "80Mhz";
      }
      else {
        __int16 v39 = "NONE";
      }
    }
    else
    {
      __int16 v39 = off_10038DAC8[v38];
    }
    v40 = "Disabled";
    __int16 v41 = "Call Not In Progress";
    if (*((_DWORD *)v35 + 10) == 1) {
      v42 = "Enabled";
    }
    else {
      v42 = "Disabled";
    }
    if (*((_DWORD *)v35 + 8) == 1) {
      __int16 v41 = "Call In Progress";
    }
    __int16 v43 = "Locked";
    if (*((_DWORD *)v35 + 9) == 1) {
      __int16 v43 = "UnLocked";
    }
    if (*((_DWORD *)v35 + 28) == 1) {
      v40 = "Enabled";
    }
    CCLogStream::logAlertIf(v35[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: ActiveChains = %d, RxChain = %d, TxChain = %d, SMPS Mode = %s, ChannelWidth = %s, Battery Save Mode = %s, FaceTime/WiFi = %s, Device = %s, MRC Threshold = %ddB, MIMO Leak Gaurd = %dms, BcnBasedRadioSwitch = %s \n", "getCurrentRadioChainConfig", 807, BYTE1(v56), v54, HIDWORD(v54), v37, v39, v42, v41, v43, *((_DWORD *)v35 + 27), *((_DWORD *)v35 + 29), v40);
  }
  return v18;
}

uint64_t AppleBCMWLANPowerManager::getMIMOPowerSaveConfigParams(AppleBCMWLANPowerManager *this)
{
  uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v2[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v2[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "getMIMOPowerSaveConfigParams", 897, "getMIMOPowerSaveConfigParams");
      uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  uint64_t v39 = 0;
  int v38 = 0;
  int isMIMOPowerSaveEnabled = AppleBCMWLANCore::isMIMOPowerSaveEnabled(*v2);
  uint64_t result = 0;
  if (isMIMOPowerSaveEnabled)
  {
    uint64_t v6 = (*(uint64_t (**)(void))(***((void ***)this + 6) + 88))(**((void **)this + 6));
    if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 136))(v6))
    {
      v35 = this;
      uint64_t v36 = (uint64_t)AppleBCMWLANPowerManager::handleGetMRCRssiThresholdAsyncCallback;
      uint64_t v37 = 0;
      int v7 = *(AppleBCMWLANCommander **)(*((void *)this + 6) + 8);
      LODWORD(v32) = 262148;
      int v8 = AppleBCMWLANCommander::sendIOVarGet(v7, (uint64_t)"mrc_rssi_threshold", (uint64_t)&kNoTxPayload, (unsigned __int16 *)&v32, (uint64_t)&v35, 0);
      uint64_t v9 = *((void *)this + 6);
      if (v8)
      {
        int v10 = v8;
        if (*(void *)(v9 + 24))
        {
          int v11 = CCLogStream::shouldLog();
          uint64_t v9 = *((void *)this + 6);
          if (v11)
          {
            CCLogStream::logAlert(*(CCLogStream **)(v9 + 24), "[dk] %s@%d: Failed GET IOCTL, cret[0x%08x]\n", "getMIMOPowerSaveConfigParams", 917, v10);
            uint64_t v9 = *((void *)this + 6);
          }
        }
      }
      int v32 = this;
      uint64_t v33 = (uint64_t)AppleBCMWLANPowerManager::handleGetBCNRXAsyncCallback;
      uint64_t v34 = 0;
      uint64_t v12 = *(AppleBCMWLANCommander **)(v9 + 8);
      LODWORD(v29) = 262148;
      int v13 = AppleBCMWLANCommander::sendIOVarGet(v12, (uint64_t)"pm_bcnrx", (uint64_t)&kNoTxPayload, (unsigned __int16 *)&v29, (uint64_t)&v32, 0);
      uint64_t v14 = *((void *)this + 6);
      if (v13)
      {
        int v15 = v13;
        if (*(void *)(v14 + 24))
        {
          int v16 = CCLogStream::shouldLog();
          uint64_t v14 = *((void *)this + 6);
          if (v16)
          {
            CCLogStream::logAlert(*(CCLogStream **)(v14 + 24), "[dk] %s@%d: Failed GET IOCTL, cret[0x%08x]\n", "getMIMOPowerSaveConfigParams", 926, v15);
            uint64_t v14 = *((void *)this + 6);
          }
        }
      }
      int v29 = this;
      uint64_t v30 = (uint64_t)AppleBCMWLANPowerManager::handleGetMIMOGaurdAsyncCallback;
      uint64_t v31 = 0;
      int v17 = *(AppleBCMWLANCommander **)(v14 + 8);
      int v28 = 262148;
      int v18 = AppleBCMWLANCommander::sendIOVarGet(v17, (uint64_t)"mimo_ps_cfg_change_wait_time", (uint64_t)&kNoTxPayload, (unsigned __int16 *)&v28, (uint64_t)&v29, 0);
      if (v18)
      {
        int v19 = v18;
        if (*(void *)(*((void *)this + 6) + 24))
        {
          if (CCLogStream::shouldLog()) {
            CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d: Failed GET IOCTL, cret[0x%08x]\n", "getMIMOPowerSaveConfigParams", 935, v19);
          }
        }
      }
      return 0;
    }
    else
    {
      v35 = (AppleBCMWLANPowerManager *)((char *)&v39 + 4);
      uint64_t v36 = 0x400040004;
      int v20 = AppleBCMWLANCommander::runIOVarGet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"mrc_rssi_threshold", (uint64_t)&kNoTxPayload, (uint64_t)&v35, 0);
      uint64_t v21 = *((void *)this + 6);
      if (v20)
      {
        int v22 = v20;
        if (*(void *)(v21 + 24))
        {
          int v23 = CCLogStream::shouldLog();
          uint64_t v21 = *((void *)this + 6);
          if (v23)
          {
            CCLogStream::logAlert(*(CCLogStream **)(v21 + 24), "[dk] %s@%d: Failed GET IOCTL, cret[0x%08x]\n", "getMIMOPowerSaveConfigParams", 944, v22);
            uint64_t v21 = *((void *)this + 6);
          }
        }
      }
      int v32 = (AppleBCMWLANPowerManager *)&v38;
      uint64_t v33 = 0x400040004;
      int v24 = AppleBCMWLANCommander::runIOVarGet(*(AppleBCMWLANCommander **)(v21 + 8), (uint64_t)"pm_bcnrx", (uint64_t)&kNoTxPayload, (uint64_t)&v32, 0);
      uint64_t v25 = *((void *)this + 6);
      if (v24)
      {
        int v26 = v24;
        if (*(void *)(v25 + 24))
        {
          int v27 = CCLogStream::shouldLog();
          uint64_t v25 = *((void *)this + 6);
          if (v27)
          {
            CCLogStream::logAlert(*(CCLogStream **)(v25 + 24), "[dk] %s@%d: Failed GET IOCTL, cret[0x%08x]\n", "getMIMOPowerSaveConfigParams", 951, v26);
            uint64_t v25 = *((void *)this + 6);
          }
        }
      }
      int v29 = (AppleBCMWLANPowerManager *)&v39;
      uint64_t v30 = 0x400040004;
      uint64_t result = AppleBCMWLANCommander::runIOVarGet(*(AppleBCMWLANCommander **)(v25 + 8), (uint64_t)"mimo_ps_cfg_change_wait_time", (uint64_t)&kNoTxPayload, (uint64_t)&v29, 0);
      *(_DWORD *)(*((void *)this + 6) + 108) = HIDWORD(v39);
      *(_DWORD *)(*((void *)this + 6) + 112) = v38;
      *(_DWORD *)(*((void *)this + 6) + 116) = v39;
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleGetTxRadioChainsAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD **a4)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog())
  {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleGetTxRadioChainsAsyncCallback", 1185, "handleGetTxRadioChainsAsyncCallback");
    if (a3)
    {
LABEL_4:
      uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
      if (result)
      {
        uint64_t result = CCLogStream::shouldLog();
        if (result)
        {
          int v8 = *(void **)(a1 + 48);
          uint64_t v9 = (CCLogStream *)v8[3];
          int v10 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v8 + 112))(*v8, a3);
          return CCLogStream::logAlert(v9, "[dk] %s@%d:MIMO_PS: Error: Failed to Get Tx Radio Chain Configuration: %s\n", "handleGetTxRadioChainsAsyncCallback", 1189, v10);
        }
      }
      return result;
    }
  }
  else if (a3)
  {
    goto LABEL_4;
  }
  *(_DWORD *)(*(void *)(a1 + 48) + 124) = **a4;
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleGetTxRadioChainsAsyncCallback", 1195, "handleGetTxRadioChainsAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleGetRxRadioChainsAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD **a4)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog())
  {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleGetRxRadioChainsAsyncCallback", 1202, "handleGetRxRadioChainsAsyncCallback");
    if (a3)
    {
LABEL_4:
      uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
      if (result)
      {
        uint64_t result = CCLogStream::shouldLog();
        if (result)
        {
          int v8 = *(void **)(a1 + 48);
          uint64_t v9 = (CCLogStream *)v8[3];
          int v10 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v8 + 112))(*v8, a3);
          return CCLogStream::logAlert(v9, "[dk] %s@%d:MIMO_PS: Error: Failed to Get Rx Radio Chain Configuration: %s\n", "handleGetRxRadioChainsAsyncCallback", 1206, v10);
        }
      }
      return result;
    }
  }
  else if (a3)
  {
    goto LABEL_4;
  }
  *(_DWORD *)(*(void *)(a1 + 48) + 120) = **a4;
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleGetRxRadioChainsAsyncCallback", 1212, "handleGetRxRadioChainsAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleGetRxChannelSpecAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD **a4)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog())
  {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleGetRxChannelSpecAsyncCallback", 1219, "handleGetRxChannelSpecAsyncCallback");
    if (a3)
    {
LABEL_4:
      uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
      if (result)
      {
        uint64_t result = CCLogStream::shouldLog();
        if (result)
        {
          int v8 = *(void **)(a1 + 48);
          uint64_t v9 = (CCLogStream *)v8[3];
          int v10 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v8 + 112))(*v8, a3);
          return CCLogStream::logAlert(v9, "[dk] %s@%d:MIMO_PS: Error: Failed to Get Rx Radio Chain Configuration: %s\n", "handleGetRxChannelSpecAsyncCallback", 1223, v10);
        }
      }
      return result;
    }
  }
  else if (a3)
  {
    goto LABEL_4;
  }
  *(_DWORD *)(*(void *)(a1 + 48) + 132) = **a4;
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleGetRxChannelSpecAsyncCallback", 1229, "handleGetRxChannelSpecAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleConfigureMIMOPSCfgGetAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog())
  {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleConfigureMIMOPSCfgGetAsyncCallback", 1163, "handleConfigureMIMOPSCfgGetAsyncCallback");
    if (a3)
    {
LABEL_4:
      uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
      if (result)
      {
        uint64_t result = CCLogStream::shouldLog();
        if (result)
        {
          int v8 = *(void **)(a1 + 48);
          uint64_t v9 = (CCLogStream *)v8[3];
          int v10 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v8 + 112))(*v8, a3);
          return CCLogStream::logAlert(v9, "[dk] %s@%d:MIMO_PS: Error: Failed MIMO Power Save Configuration: %s\n", "handleConfigureMIMOPSCfgGetAsyncCallback", 1169, v10);
        }
      }
      return result;
    }
  }
  else if (a3)
  {
    goto LABEL_4;
  }
  *(_DWORD *)(*(void *)(a1 + 48) + 128) = *(unsigned __int8 *)(*(void *)a4 + 2);
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleConfigureMIMOPSCfgGetAsyncCallback", 1177, "handleConfigureMIMOPSCfgGetAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleLinkDownConfiguration(AppleBCMWLANPowerManager *this)
{
  uint64_t v2 = *((void *)this + 6);
  if (*(void *)(v2 + 24))
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = *((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(*(CCLogStream **)(v2 + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleLinkDownConfiguration", 816, "handleLinkDownConfiguration");
      uint64_t v2 = *((void *)this + 6);
    }
  }
  *(unsigned char *)(v2 + 181) = 0;
  uint64_t v4 = 0;
  if (AppleBCMWLANCore::isMIMOPowerSaveEnabled(**((AppleBCMWLANCore ***)this + 6)))
  {
    if (AppleBCMWLANPowerManager::configureSISOPowerSavePolicy(this)
      && *(void *)(*((void *)this + 6) + 24)
      && CCLogStream::shouldLog())
    {
      CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:Failed to configure SISO Power Save Policy\n", "handleLinkDownConfiguration", 829);
    }
    uint64_t v4 = AppleBCMWLANPowerManager::configureTVPMPeriodicity((AppleBCMWLANCore ***)this, 10);
    if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleLinkDownConfiguration", 841, "handleLinkDownConfiguration");
    }
  }
  return v4;
}

uint64_t AppleBCMWLANPowerManager::handleLinkUpConfiguration(AppleBCMWLANPowerManager *this)
{
  uint64_t v2 = *((void *)this + 6);
  if (*(void *)(v2 + 24))
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = *((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(*(CCLogStream **)(v2 + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleLinkUpConfiguration", 848, "handleLinkUpConfiguration");
      uint64_t v2 = *((void *)this + 6);
    }
  }
  *(unsigned char *)(v2 + 181) = 1;
  if (AppleBCMWLANCore::isMIMOPowerSaveEnabled(**((AppleBCMWLANCore ***)this + 6)))
  {
    if (AppleBCMWLANCore::isAssociated(**((AppleBCMWLANCore ***)this + 6)))
    {
      AppleBCMWLANPowerManager::configureBeaconBasedRadioChainSwitch(this);
      AppleBCMWLANPowerManager::getMIMOPowerSaveStatus(this);
      if (*(void *)(*((void *)this + 6) + 24))
      {
        if (CCLogStream::shouldLog()) {
          CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleLinkUpConfiguration", 869, "handleLinkUpConfiguration");
        }
      }
    }
  }
  return 0;
}

uint64_t AppleBCMWLANPowerManager::handleGetMRCRssiThresholdAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD **a4)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog())
  {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleGetMRCRssiThresholdAsyncCallback", 1269, "handleGetMRCRssiThresholdAsyncCallback");
    if (a3)
    {
LABEL_4:
      uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
      if (result)
      {
        uint64_t result = CCLogStream::shouldLog();
        if (result)
        {
          int v8 = *(void **)(a1 + 48);
          uint64_t v9 = (CCLogStream *)v8[3];
          int v10 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v8 + 112))(*v8, a3);
          return CCLogStream::logAlert(v9, "[dk] %s@%d:MIMO_PS: Error: Failed to Get MRC Threshold: %s\n", "handleGetMRCRssiThresholdAsyncCallback", 1273, v10);
        }
      }
      return result;
    }
  }
  else if (a3)
  {
    goto LABEL_4;
  }
  *(_DWORD *)(*(void *)(a1 + 48) + 108) = **a4;
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleGetMRCRssiThresholdAsyncCallback", 1279, "handleGetMRCRssiThresholdAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleGetBCNRXAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD **a4)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog())
  {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleGetBCNRXAsyncCallback", 1286, "handleGetBCNRXAsyncCallback");
    if (a3)
    {
LABEL_4:
      uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
      if (result)
      {
        uint64_t result = CCLogStream::shouldLog();
        if (result)
        {
          int v8 = *(void **)(a1 + 48);
          uint64_t v9 = (CCLogStream *)v8[3];
          int v10 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v8 + 112))(*v8, a3);
          return CCLogStream::logAlert(v9, "[dk] %s@%d:MIMO_PS: Error: Failed to Get Beacon Based Radio Switch State: %s\n", "handleGetBCNRXAsyncCallback", 1290, v10);
        }
      }
      return result;
    }
  }
  else if (a3)
  {
    goto LABEL_4;
  }
  *(_DWORD *)(*(void *)(a1 + 48) + 112) = **a4;
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleGetBCNRXAsyncCallback", 1296, "handleGetBCNRXAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleGetMIMOGaurdAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD **a4)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog())
  {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleGetMIMOGaurdAsyncCallback", 1303, "handleGetMIMOGaurdAsyncCallback");
    if (a3)
    {
LABEL_4:
      uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
      if (result)
      {
        uint64_t result = CCLogStream::shouldLog();
        if (result)
        {
          int v8 = *(void **)(a1 + 48);
          uint64_t v9 = (CCLogStream *)v8[3];
          int v10 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v8 + 112))(*v8, a3);
          return CCLogStream::logAlert(v9, "[dk] %s@%d:MIMO_PS: Error: Failed to get MIMO Leak Gaurd Interval: %s\n", "handleGetMIMOGaurdAsyncCallback", 1307, v10);
        }
      }
      return result;
    }
  }
  else if (a3)
  {
    goto LABEL_4;
  }
  *(_DWORD *)(*(void *)(a1 + 48) + 116) = **a4;
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleGetMIMOGaurdAsyncCallback", 1313, "handleGetMIMOGaurdAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleGetMIMOPowerSaveStatusAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog())
  {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleGetMIMOPowerSaveStatusAsyncCallback", 1336, "handleGetMIMOPowerSaveStatusAsyncCallback");
    if (a3)
    {
LABEL_4:
      uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
      if (result)
      {
        uint64_t result = CCLogStream::shouldLog();
        if (result)
        {
          int v8 = *(void **)(a1 + 48);
          uint64_t v9 = (CCLogStream *)v8[3];
          int v10 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v8 + 112))(*v8, a3);
          return CCLogStream::logAlert(v9, "[dk] %s@%d:MIMO_PS: Error: Failed to get MIMO Power Save Status: %s\n", "handleGetMIMOPowerSaveStatusAsyncCallback", 1343, v10);
        }
      }
      return result;
    }
  }
  else if (a3)
  {
    goto LABEL_4;
  }
  uint64_t v11 = *a4;
  uint64_t v12 = *(void *)(a1 + 48);
  if (*(void *)(v12 + 24))
  {
    unsigned int v13 = *(unsigned __int8 *)(v11 + 1);
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v12 = *(void *)(a1 + 48);
    if (shouldLog)
    {
      uint64_t v15 = v13 & 0xF;
      if (v13 >= 0x10)
      {
        unsigned int v17 = v13 >> 4;
        if (v13 >> 4 == 1)
        {
          int v16 = "20Mhz";
        }
        else if (v17 == 2)
        {
          int v16 = "40Mhz";
        }
        else if (v17 == 3)
        {
          int v16 = "80Mhz";
        }
        else
        {
          int v16 = "NONE";
        }
      }
      else
      {
        int v16 = "20/40/80Mhz";
      }
      int v18 = "Invalid AP cap/association status";
      BOOL v19 = v15 == 3;
      if (v15 >= 3)
      {
        int v20 = "LEGACY";
        if (!v19) {
          int v20 = "Invalid AP cap/association status";
        }
      }
      else
      {
        int v20 = off_10038DA70[v15];
      }
      unint64_t v21 = *(char *)(v11 + 2);
      if (v21 >= 3)
      {
        if (v21 == 3) {
          int v18 = "LEGACY ASSOCIATION";
        }
      }
      else
      {
        int v18 = off_10038DA88[v21];
      }
      unint64_t v22 = *(char *)(v11 + 3);
      if (v22 >= 5)
      {
        if (v22 == 5) {
          int v23 = "INFORM AP PENDING";
        }
        else {
          int v23 = "NONE";
        }
      }
      else
      {
        int v23 = off_10038DAA0[v22];
      }
      if (*(unsigned char *)(v11 + 4) == 1) {
        int v24 = "ACTIVE";
      }
      else {
        int v24 = "NOT ACTIVE";
      }
      unint64_t v25 = *(char *)(v11 + 7);
      if (v25 >= 3)
      {
        if (v25 == 3) {
          int v26 = "80Mhz";
        }
        else {
          int v26 = "NONE";
        }
      }
      else
      {
        int v26 = off_10038DAC8[v25];
      }
      int v27 = *(CCLogStream **)(v12 + 24);
      unsigned int v28 = *(unsigned __int16 *)(v11 + 8);
      if (v28 <= 0xF)
      {
        int v29 = "NONE";
        switch(*(_WORD *)(v11 + 8))
        {
          case 0:
            goto LABEL_62;
          case 1:
            int v29 = "LTE CO-EX";
            break;
          case 2:
            int v29 = "MIMOPS BSS";
            break;
          case 4:
            int v29 = "AWDL BSS";
            break;
          case 8:
            int v29 = "SCAN";
            break;
          default:
            goto LABEL_59;
        }
        goto LABEL_62;
      }
      if (*(unsigned __int16 *)(v11 + 8) > 0x3Fu)
      {
        if (v28 == 64)
        {
          int v29 = "TEMP SENSE";
          goto LABEL_62;
        }
        if (v28 == 128)
        {
          int v29 = "IOVAR";
          goto LABEL_62;
        }
      }
      else
      {
        if (v28 == 16)
        {
          int v29 = "TXPRR";
          goto LABEL_62;
        }
        if (v28 == 32)
        {
          int v29 = "PWR THROTTLE";
          goto LABEL_62;
        }
      }
LABEL_59:
      if (v28 == 256) {
        int v29 = "AP BSS";
      }
      else {
        int v29 = "NONE";
      }
LABEL_62:
      unint64_t v30 = *(char *)(v11 + 12);
      if (v30 >= 3)
      {
        if (v30 == 3) {
          uint64_t v31 = "80Mhz";
        }
        else {
          uint64_t v31 = "NONE";
        }
      }
      else
      {
        uint64_t v31 = off_10038DAC8[v30];
      }
      CCLogStream::logNotice(v27, "[dk] %s@%d:MIMO POWER SAVE STATUS:AP BW = %s, AP CAPABILITY = %s, Assoc State = %s, MIMO PS State = %s, MRC State = %s, BSS RxChain = %d, BSS TxChain = %d, BSS Bandwidth = %s, HW State = %s, HW Rx Chain = %d, HW Tx Chain = %d, HW Bandwidth = %s, BCNRX State = %d, Basic Rates Present = %d, BCMC RX State = %d\n", "handleGetMIMOPowerSaveStatusAsyncCallback", 1352, v16, v20, v18, v23, v24, *(unsigned __int8 *)(v11 + 5), *(unsigned __int8 *)(v11 + 6), v26, v29, *(unsigned __int8 *)(v11 + 10), *(unsigned __int8 *)(v11 + 11), v31, *(unsigned __int8 *)(v11 + 13),
        *(unsigned __int8 *)(v11 + 14),
        *(unsigned __int8 *)(v11 + 15));
      uint64_t v12 = *(void *)(a1 + 48);
    }
  }
  *(_OWORD *)(v12 + 156) = *(_OWORD *)v11;
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleGetMIMOPowerSaveStatusAsyncCallback", 1357, "handleGetMIMOPowerSaveStatusAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleConfigureBcnBasedRadioChannelWidthSwitchAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleConfigureBcnBasedRadioChannelWidthSwitchAsyncCallback", 1058, "handleConfigureBcnBasedRadioChannelWidthSwitchAsyncCallback");
  }
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (a3)
  {
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        uint64_t v6 = *(void **)(a1 + 48);
        int v7 = (CCLogStream *)v6[3];
        int v8 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v6 + 112))(*v6, a3);
        return CCLogStream::logAlert(v7, "[dk] %s@%d:MIMO_PS: Error: Failed to Configure Beacon Based Radio Channel Width Switch: %s\n", "handleConfigureBcnBasedRadioChannelWidthSwitchAsyncCallback", 1062, v8);
      }
    }
  }
  else if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleConfigureBcnBasedRadioChannelWidthSwitchAsyncCallback", 1066, "handleConfigureBcnBasedRadioChannelWidthSwitchAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleConfigureTVPMPeriodicityAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleConfigureTVPMPeriodicityAsyncCallback", 1320, "handleConfigureTVPMPeriodicityAsyncCallback");
  }
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (a3)
  {
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        uint64_t v6 = *(void **)(a1 + 48);
        int v7 = (CCLogStream *)v6[3];
        int v8 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v6 + 112))(*v6, a3);
        return CCLogStream::logAlert(v7, "[dk] %s@%d:TVPM: Error: Failed to Configure TVPM Periodicity: %s\n", "handleConfigureTVPMPeriodicityAsyncCallback", 1324, v8);
      }
    }
  }
  else if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleConfigureTVPMPeriodicityAsyncCallback", 1328, "handleConfigureTVPMPeriodicityAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::setMIMOPowerSaveProperties(uint64_t a1)
{
  uint64_t v2 = *(AppleBCMWLANCore ***)(a1 + 48);
  if (v2[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = *(AppleBCMWLANCore ***)(a1 + 48);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v2[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "setMIMOPowerSaveProperties", 1398, "setMIMOPowerSaveProperties");
      uint64_t v2 = *(AppleBCMWLANCore ***)(a1 + 48);
    }
  }
  if (AppleBCMWLANCore::isMIMOPowerSaveEnabled(*v2)
    && *(void *)(*(void *)(a1 + 48) + 24)
    && CCLogStream::shouldLog())
  {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "setMIMOPowerSaveProperties", 1408, "setMIMOPowerSaveProperties");
  }
  return 0;
}

uint64_t AppleBCMWLANPowerManager::setWiFiCallPowerPolicy(uint64_t a1)
{
  uint64_t v2 = *(AppleBCMWLANCore ***)(a1 + 48);
  if (v2[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = *(AppleBCMWLANCore ***)(a1 + 48);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v2[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "setWiFiCallPowerPolicy", 1608, "setWiFiCallPowerPolicy");
      uint64_t v2 = *(AppleBCMWLANCore ***)(a1 + 48);
    }
  }
  uint64_t result = AppleBCMWLANCore::isMIMOPowerSaveEnabled(*v2);
  if (result)
  {
    uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result) {
        return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "setWiFiCallPowerPolicy", 1618, "setWiFiCallPowerPolicy");
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::configureOCLParams(AppleBCMWLANPowerManager *this)
{
  uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v2[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v2[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureOCLParams", 1941, "configureOCLParams");
      uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  if (AppleBCMWLANCore::isOCLEnabled(*v2))
  {
    AppleBCMWLANPowerManager::configureOCLSetting(this, 1);
    uint64_t v4 = AppleBCMWLANPowerManager::configureOCLRssiThreshold(this, -70);
    uint64_t v5 = *((void *)this + 6);
    if (v4)
    {
      if (*(void *)(v5 + 24))
      {
        int v6 = CCLogStream::shouldLog();
        uint64_t v5 = *((void *)this + 6);
        if (v6)
        {
          CCLogStream::logAlertIf(*(CCLogStream **)(v5 + 24), 0x20uLL, "[dk] %s@%d:OCL: Couldn't configure OCL!", "configureOCLParams", 1957);
          uint64_t v5 = *((void *)this + 6);
        }
      }
    }
    if (*(void *)(v5 + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureOCLParams", 1960, "configureOCLParams");
    }
  }
  else
  {
    if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:OCL: OCL NOT Enabled by Host!\n", "configureOCLParams", 1945);
    }
    return 0;
  }
  return v4;
}

uint64_t AppleBCMWLANPowerManager::configureOCLSetting(AppleBCMWLANPowerManager *this, int a2)
{
  uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v4[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v4[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureOCLSetting", 2253, "configureOCLSetting");
      uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  int v14 = a2;
  if (AppleBCMWLANCore::isOCLEnabled(*v4))
  {
    v13[0] = &v14;
    v13[1] = 4;
    uint64_t v6 = (*(uint64_t (**)(void))(***((void ***)this + 6) + 88))(**((void **)this + 6));
    if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 136))(v6))
    {
      uint64_t v7 = AppleBCMWLANCommander::sendIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"ocl_enable");
    }
    else
    {
      uint64_t v7 = AppleBCMWLANCommander::runIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"ocl_enable", (uint64_t)v13, 0, 0);
      uint64_t v8 = *(void *)(*((void *)this + 6) + 24);
      if (v7)
      {
        if (v8 && CCLogStream::shouldLog())
        {
          uint64_t v9 = (void *)*((void *)this + 6);
          int v10 = (CCLogStream *)v9[3];
          uint64_t v11 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v9 + 112))(*v9, v7);
          CCLogStream::logAlertIf(v10, 0x20uLL, "[dk] %s@%d:OCL: Failed to Configure OCL %s\n", "configureOCLSetting", 2279, v11);
        }
      }
      else
      {
        if (v8 && CCLogStream::shouldLog()) {
          CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:OCL Enabled Flag = %u \n", "configureOCLSetting", 2281, a2);
        }
        uint64_t v7 = 0;
      }
    }
    if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureOCLSetting", 2285, "configureOCLSetting");
    }
  }
  else
  {
    if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:OCL: OCL NOT Enabled by Host!\n", "configureOCLSetting", 2259);
    }
    return 0;
  }
  return v7;
}

uint64_t AppleBCMWLANPowerManager::configureOCLRssiThreshold(AppleBCMWLANPowerManager *this, int a2)
{
  int v13 = a2;
  int v3 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v3[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    int v3 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v3[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureOCLRssiThreshold", 2292, "configureOCLRssiThreshold");
      int v3 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  if (AppleBCMWLANCore::isOCLEnabled(*v3))
  {
    v12[0] = &v13;
    v12[1] = 4;
    uint64_t v5 = (*(uint64_t (**)(void))(***((void ***)this + 6) + 88))(**((void **)this + 6));
    if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 136))(v5))
    {
      uint64_t v6 = AppleBCMWLANCommander::sendIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"ocl_rssi_threshold");
    }
    else
    {
      uint64_t v6 = AppleBCMWLANCommander::runIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"ocl_rssi_threshold", (uint64_t)v12, 0, 0);
      uint64_t v7 = *(void *)(*((void *)this + 6) + 24);
      if (v6)
      {
        if (v7 && CCLogStream::shouldLog())
        {
          uint64_t v8 = (void *)*((void *)this + 6);
          uint64_t v9 = (CCLogStream *)v8[3];
          int v10 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v8 + 112))(*v8, v6);
          CCLogStream::logAlertIf(v9, 0x20uLL, "[dk] %s@%d:OCL: Failed to Configure OCL Threshold  %s\n", "configureOCLRssiThreshold", 2313, v10);
        }
      }
      else
      {
        if (v7 && CCLogStream::shouldLog()) {
          CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:OCL Threshold = %d dB\n", "configureOCLRssiThreshold", 2315, v13);
        }
        uint64_t v6 = 0;
      }
    }
    if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureOCLRssiThreshold", 2319, "configureOCLRssiThreshold");
    }
  }
  else
  {
    if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:OCL: OCL NOT Enabled by Host!\n", "configureOCLRssiThreshold", 2296);
    }
    return 0;
  }
  return v6;
}

uint64_t AppleBCMWLANPowerManager::configurePowerSaveForAWDL(AppleBCMWLANPowerManager *this, int a2)
{
  uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v4[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v4[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configurePowerSaveForAWDL", 1983, "configurePowerSaveForAWDL");
      uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  int isOCLEnabled = AppleBCMWLANCore::isOCLEnabled(*v4);
  uint64_t v7 = *((void *)this + 6);
  if (isOCLEnabled)
  {
    if (AppleBCMWLANCore::isOCLAWDLSupported(*(AppleBCMWLANCore **)v7))
    {
      uint64_t v8 = this;
      int v9 = 1;
    }
    else
    {
      uint64_t v8 = this;
      int v9 = a2;
    }
    AppleBCMWLANPowerManager::configureOCLSetting(v8, v9);
  }
  else if (*(void *)(v7 + 24) && CCLogStream::shouldLog())
  {
    CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:OCL: OCL NOT Enabled by Host!\n", "configurePowerSaveForAWDL", 1998);
  }
  int v10 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (a2)
  {
    AppleBCMWLANCore::setBeaconListenInterval(*v10);
    int v10 = (AppleBCMWLANCore **)*((void *)this + 6);
  }
  if (AppleBCMWLANCore::checkForEarlyBeconTerminationSupport(*v10))
  {
    uint64_t v11 = AppleBCMWLANPowerManager::configureEarlyBeaconTermination(this, a2);
    if (v11 && *(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Configuring Early Beacon termination failed with error %d", "configurePowerSaveForAWDL", 2013, v11);
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  if (AppleBCMWLANCore::checkForOppPowerSaveSupport(**((AppleBCMWLANCore ***)this + 6)))
  {
    uint64_t v11 = AppleBCMWLANPowerManager::configureOpportunisticPowerSave(this, a2);
    if (v11)
    {
      if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Configuring Opportunistic Power Save failed with error %d", "configurePowerSaveForAWDL", 2020, v11);
      }
    }
  }
  if (AppleBCMWLANCore::checkForDigitalNapSupport(**((AppleBCMWLANCore ***)this + 6)))
  {
    uint64_t v11 = AppleBCMWLANPowerManager::configureDigitalNapPowerSave(this, a2);
    if (v11)
    {
      if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Configuring Digital Nap failed with error %d", "configurePowerSaveForAWDL", 2027, v11);
      }
    }
  }
  if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configurePowerSaveForAWDL", 2031, "configurePowerSaveForAWDL");
  }
  return v11;
}

uint64_t AppleBCMWLANPowerManager::configureEarlyBeaconTermination(AppleBCMWLANPowerManager *this, int a2)
{
  uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v4[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v4[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureEarlyBeaconTermination", 2083, "configureEarlyBeaconTermination");
      uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  if (a2) {
    int v6 = 3;
  }
  else {
    int v6 = 0;
  }
  int v15 = v6;
  BssManager = (IO80211BssManager *)AppleBCMWLANCore::getBssManager(*v4);
  if (BssManager && IO80211BssManager::isAssociatedToAdhoc(BssManager))
  {
    uint64_t v8 = 3758097122;
    if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog())
    {
      if (a2) {
        int v9 = "enabling";
      }
      else {
        int v9 = "disabling";
      }
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Currently associated to ad-hoc network. Not %s EBT\n", "configureEarlyBeaconTermination", 2089, v9);
    }
  }
  else
  {
    v14[0] = &v15;
    v14[1] = 4;
    uint64_t v10 = (*(uint64_t (**)(void))(***((void ***)this + 6) + 88))(**((void **)this + 6));
    if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 136))(v10)) {
      uint64_t v11 = AppleBCMWLANCommander::sendIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"bcntrim");
    }
    else {
      uint64_t v11 = AppleBCMWLANCommander::runIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"bcntrim", (uint64_t)v14, 0, 0);
    }
    uint64_t v8 = v11;
    uint64_t v12 = *(void *)(*((void *)this + 6) + 24);
    if (v8)
    {
      if (v12 && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Configuring EBT failed with error %d \n");
      }
    }
    else if (v12 && CCLogStream::shouldLog())
    {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:EBT is %s\n");
    }
    if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureEarlyBeaconTermination", 2113, "configureEarlyBeaconTermination");
    }
  }
  return v8;
}

uint64_t AppleBCMWLANPowerManager::configureOpportunisticPowerSave(AppleBCMWLANPowerManager *this, int a2)
{
  uint64_t v4 = IOMallocZeroData();
  if (v4)
  {
    uint64_t v5 = (AppleBCMWLANPowerManager *)v4;
    *(_DWORD *)uint64_t v4 = 786433;
    *(_WORD *)(v4 + 4) = 0;
    if (a2) {
      int v6 = 15;
    }
    else {
      int v6 = 0;
    }
    *(_DWORD *)(v4 + 8) = v6;
    uint64_t v7 = (*(uint64_t (**)(void))(***((void ***)this + 6) + 88))(**((void **)this + 6));
    if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 136))(v7))
    {
      int v13 = this;
      uint64_t v14 = (uint64_t)AppleBCMWLANPowerManager::handleOPSConfigurationAsyncCallback;
      uint64_t v15 = 0;
      uint64_t v8 = AppleBCMWLANCommander::sendIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"ops_cfg");
    }
    else
    {
      uint64_t v10 = *(AppleBCMWLANCommander **)(*((void *)this + 6) + 8);
      int v13 = v5;
      uint64_t v14 = 12;
      uint64_t v8 = AppleBCMWLANCommander::runIOVarSet(v10, (uint64_t)"ops_cfg", (uint64_t)&v13, 0, 0);
    }
    uint64_t v9 = v8;
    uint64_t v11 = *(void *)(*((void *)this + 6) + 24);
    if (v9)
    {
      if (v11 && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Configuring OPS failed with error %d \n");
      }
    }
    else if (v11 && CCLogStream::shouldLog())
    {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:OPS is %s\n");
    }
    IOFreeData();
  }
  else
  {
    uint64_t v9 = 3758097085;
    if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:OPS Param buffer allocation failed\n", "configureOpportunisticPowerSave", 2134);
    }
  }
  return v9;
}

uint64_t AppleBCMWLANPowerManager::configureDigitalNapPowerSave(AppleBCMWLANPowerManager *this, int a2)
{
  uint64_t v4 = (CCLogStream **)*((void *)this + 6);
  if (v4[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v4 = (CCLogStream **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v4[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureDigitalNapPowerSave", 2177, "configureDigitalNapPowerSave");
      uint64_t v4 = (CCLogStream **)*((void *)this + 6);
    }
  }
  int v12 = a2;
  v11[0] = &v12;
  v11[1] = 4;
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)*v4 + 88))();
  if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 136))(v6)) {
    uint64_t v7 = AppleBCMWLANCommander::sendIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"nap_enable");
  }
  else {
    uint64_t v7 = AppleBCMWLANCommander::runIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"nap_enable", (uint64_t)v11, 0, 0);
  }
  uint64_t v8 = v7;
  uint64_t v9 = *(void *)(*((void *)this + 6) + 24);
  if (v8)
  {
    if (v9 && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Configuring nap_enable failed with error %d \n");
    }
  }
  else if (v9 && CCLogStream::shouldLog())
  {
    CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Nap is %s\n");
  }
  if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureDigitalNapPowerSave", 2201, "configureDigitalNapPowerSave");
  }
  return v8;
}

uint64_t AppleBCMWLANPowerManager::configurePowerSaveForVirtualInterface(AppleBCMWLANPowerManager *this, int a2)
{
  uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v4[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v4[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configurePowerSaveForVirtualInterface", 2044, "configurePowerSaveForVirtualInterface");
      uint64_t v4 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  if (AppleBCMWLANCore::isOCLEnabled(*v4))
  {
    AppleBCMWLANPowerManager::configureOCLSetting(this, a2);
  }
  else if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog())
  {
    CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:OCL: OCL NOT Enabled by Host!\n", "configurePowerSaveForVirtualInterface", 2052);
  }
  if (AppleBCMWLANCore::checkForEarlyBeconTerminationSupport(**((AppleBCMWLANCore ***)this + 6)))
  {
    uint64_t v6 = AppleBCMWLANPowerManager::configureEarlyBeaconTermination(this, a2);
    if (v6 && *(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Configuring Early Beacon termination failed with error %d", "configurePowerSaveForVirtualInterface", 2058, v6);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  if (AppleBCMWLANCore::checkForOppPowerSaveSupport(**((AppleBCMWLANCore ***)this + 6)))
  {
    uint64_t v6 = AppleBCMWLANPowerManager::configureOpportunisticPowerSave(this, a2);
    if (v6)
    {
      if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Configuring Opportunistic Power Save failed with error %d", "configurePowerSaveForVirtualInterface", 2065, v6);
      }
    }
  }
  if (AppleBCMWLANCore::checkForDigitalNapSupport(**((AppleBCMWLANCore ***)this + 6)))
  {
    uint64_t v6 = AppleBCMWLANPowerManager::configureDigitalNapPowerSave(this, a2);
    if (v6)
    {
      if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Configuring Digital Nap failed with error %d", "configurePowerSaveForVirtualInterface", 2072, v6);
      }
    }
  }
  if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configurePowerSaveForVirtualInterface", 2076, "configurePowerSaveForVirtualInterface");
  }
  return v6;
}

uint64_t AppleBCMWLANPowerManager::handleEBTConfigurationAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleEBTConfigurationAsyncCallback", 2223, "handleEBTConfigurationAsyncCallback");
  }
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (a3)
  {
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        uint64_t v6 = *(void **)(a1 + 48);
        uint64_t v7 = (CCLogStream *)v6[3];
        uint64_t v8 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v6 + 112))(*v6, a3);
        return CCLogStream::logAlertIf(v7, 0x20uLL, "[dk] %s@%d:EBT: Error: Failed to Configure Opportunistic Power Save: %s\n", "handleEBTConfigurationAsyncCallback", 2227, v8);
      }
    }
  }
  else if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleEBTConfigurationAsyncCallback", 2231, "handleEBTConfigurationAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleOPSConfigurationAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleOPSConfigurationAsyncCallback", 2208, "handleOPSConfigurationAsyncCallback");
  }
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (a3)
  {
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        uint64_t v6 = *(void **)(a1 + 48);
        uint64_t v7 = (CCLogStream *)v6[3];
        uint64_t v8 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v6 + 112))(*v6, a3);
        return CCLogStream::logAlertIf(v7, 0x20uLL, "[dk] %s@%d:OPS: Error: Failed to Configure Opportunistic Power Save: %s\n", "handleOPSConfigurationAsyncCallback", 2212, v8);
      }
    }
  }
  else if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleOPSConfigurationAsyncCallback", 2216, "handleOPSConfigurationAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleDigitalNapConfigurationAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleDigitalNapConfigurationAsyncCallback", 2238, "handleDigitalNapConfigurationAsyncCallback");
  }
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (a3)
  {
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        uint64_t v6 = *(void **)(a1 + 48);
        uint64_t v7 = (CCLogStream *)v6[3];
        uint64_t v8 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v6 + 112))(*v6, a3);
        return CCLogStream::logAlertIf(v7, 0x20uLL, "[dk] %s@%d:OPS: Error: Failed to Configure Digital Nap Power Save: %s\n", "handleDigitalNapConfigurationAsyncCallback", 2242, v8);
      }
    }
  }
  else if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleDigitalNapConfigurationAsyncCallback", 2246, "handleDigitalNapConfigurationAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleOCLConfigurationAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleOCLConfigurationAsyncCallback", 2435, "handleOCLConfigurationAsyncCallback");
  }
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (a3)
  {
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        uint64_t v6 = *(void **)(a1 + 48);
        uint64_t v7 = (CCLogStream *)v6[3];
        uint64_t v8 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v6 + 112))(*v6, a3);
        return CCLogStream::logAlertIf(v7, 0x20uLL, "[dk] %s@%d:OCL: Error: Failed to Configure OCL: %s\n", "handleOCLConfigurationAsyncCallback", 2439, v8);
      }
    }
  }
  else if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleOCLConfigurationAsyncCallback", 2443, "handleOCLConfigurationAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleOCLRssiThresholdConfigurationAsyncCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "handleOCLRssiThresholdConfigurationAsyncCallback", 2420, "handleOCLRssiThresholdConfigurationAsyncCallback");
  }
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 24);
  if (a3)
  {
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        uint64_t v6 = *(void **)(a1 + 48);
        uint64_t v7 = (CCLogStream *)v6[3];
        uint64_t v8 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v6 + 112))(*v6, a3);
        return CCLogStream::logAlertIf(v7, 0x20uLL, "[dk] %s@%d:OCL: Error: Failed to Configure OCL Threshold: %s\n", "handleOCLRssiThresholdConfigurationAsyncCallback", 2424, v8);
      }
    }
  }
  else if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "handleOCLRssiThresholdConfigurationAsyncCallback", 2428, "handleOCLRssiThresholdConfigurationAsyncCallback");
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::setMWSCoexIoVarsAsync_mws_ocl_coex_bitmap(AppleBCMWLANPowerManager *this, OSObject *a2, int a3)
{
  if ((AppleBCMWLANCore::isOCLEnabled(**((AppleBCMWLANCore ***)this + 6)) & 1) == 0
    && (AppleBCMWLANCore::checkForLtecxlbtSupport(**((AppleBCMWLANCore ***)this + 6)) & 1) == 0)
  {
    uint64_t result = *(void *)(*((void *)this + 6) + 24);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result) {
        return CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:OCL or LBT not Enabled!\n");
      }
    }
    return result;
  }
  uint64_t result = *(void *)(*((void *)this + 6) + 24);
  if (result && (uint64_t result = CCLogStream::shouldLog(), result))
  {
    uint64_t v7 = "FALSE";
    if (a3) {
      uint64_t v7 = "TRUE";
    }
    uint64_t result = CCLogStream::logInfo(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:prop:%p useCachedValue:%s", "setMWSCoexIoVarsAsync_mws_ocl_coex_bitmap", 3397, a2, v7);
    if (a3)
    {
LABEL_6:
      if (*(unsigned char *)(*((void *)this + 6) + 154)) {
        goto LABEL_65;
      }
      return result;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  if (!a2)
  {
    uint64_t result = *(void *)(*((void *)this + 6) + 24);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result) {
        return CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:NO Properties for OCL Coex settings \n");
      }
    }
    return result;
  }
  uint64_t v8 = (const OSDictionary *)OSMetaClassBase::safeMetaCast(a2, gOSDictionaryMetaClass);
  if (!v8) {
    goto LABEL_65;
  }
  Object = OSDictionary::getObject(v8, "MWS_OCL_DISABLE_CHANNELS");
  if (!Object)
  {
    if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:NO OCL Disabled Channels Dictionary in Params\n", "setMWSCoexIoVarsAsync_mws_ocl_coex_bitmap", 3413);
    }
    goto LABEL_65;
  }
  uint64_t v10 = (const OSArray *)OSMetaClassBase::safeMetaCast(Object, gOSArrayMetaClass);
  if (!v10 && *(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:Error - empty Array of Channels(dictionary)!", "setMWSCoexIoVarsAsync_mws_ocl_coex_bitmap", 3421);
  }
  int v11 = ((uint64_t (*)(const OSArray *))v10->getCount)(v10);
  if (!v11)
  {
    LOWORD(v34) = -1;
    LOWORD(v35) = 0x3FFF;
    LOWORD(v32) = 31;
    LOWORD(v33) = -1;
    goto LABEL_64;
  }
  int v12 = v11;
  uint32_t v13 = 0;
  int v35 = 0x3FFF;
  int v32 = 31;
  int v33 = 0xFFFF;
  int v34 = 0xFFFF;
  while (1)
  {
    uint64_t v14 = OSArray::getObject(v10, v13);
    uint64_t v15 = (const OSDictionary *)OSMetaClassBase::safeMetaCast(v14, gOSDictionaryMetaClass);
    if (!v15) {
      goto LABEL_53;
    }
    int v16 = OSDictionary::getObject(v15, "MWS_Channel_Number");
    unsigned int v17 = (const OSNumber *)OSMetaClassBase::safeMetaCast(v16, gOSNumberMetaClass);
    if (!v17) {
      goto LABEL_53;
    }
    unsigned int v18 = OSNumber::unsigned8BitValue(v17);
    if (!v18) {
      goto LABEL_53;
    }
    unsigned int v19 = v18;
    if (v18 <= 0xE)
    {
      v35 &= ~(1 << v18);
      goto LABEL_53;
    }
    if (v18 - 34 <= 0x44)
    {
      uint64_t v20 = 0;
      while (ch_5g_lo_index_map[v20] != v18)
      {
        v20 += 2;
        if (v20 == 32) {
          goto LABEL_50;
        }
      }
      unsigned int v22 = ch_5g_lo_index_map[v20 + 1];
      if (v22 >= 0x10)
      {
        if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
          CCLogStream::logInfo(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Error: mws_coex_bitmap invalid low 5G channel map index %d");
        }
        goto LABEL_64;
      }
      v34 &= ~(1 << v22);
      goto LABEL_53;
    }
    if (v18 - 104 > 0x2F) {
      break;
    }
    uint64_t v21 = 0;
    while (ch_5g_mid_index_map[v21] != v18)
    {
      v21 += 2;
      if (v21 == 32) {
        goto LABEL_50;
      }
    }
    unsigned int v24 = ch_5g_mid_index_map[v21 + 1];
    if (v24 >= 0x10)
    {
      if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
        CCLogStream::logInfo(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Error: mws_coex_bitmap invalid mid 5G channel map index %d");
      }
      goto LABEL_64;
    }
    v33 &= ~(1 << v24);
LABEL_53:
    if (++v13 == v12) {
      goto LABEL_64;
    }
  }
  if ((v18 + 103) > 0xCu)
  {
    if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logInfo(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Error: mws_coex_bitmap invalid channel(%d - %d/%d)\n", "setMWSCoexIoVarsAsync_mws_ocl_coex_bitmap", 3487, v19, v13 + 1, v12);
    }
LABEL_50:
    if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logInfo(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Error: mws_ocl_coex_bitmap invalid channel(%d)\n", "setMWSCoexIoVarsAsync_mws_ocl_coex_bitmap", 3491, v19);
    }
    goto LABEL_53;
  }
  uint64_t v23 = 0;
  while (ch_5g_hi_index_map[v23] != v18)
  {
    v23 += 2;
    if (v23 == 10) {
      goto LABEL_50;
    }
  }
  unsigned int v25 = ch_5g_hi_index_map[v23 + 1];
  if (v25 < 0x10)
  {
    v32 &= ~(1 << v25);
    goto LABEL_53;
  }
  if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog()) {
    CCLogStream::logInfo(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Error: mws_coex_bitmap invalid hi 5G channel map index %d");
  }
LABEL_64:
  int v26 = (_WORD *)*((void *)this + 6);
  v26[72] = 1;
  v26[73] = v35;
  v26[74] = v34;
  v26[75] = v33;
  v26[76] = v32;
  *(unsigned char *)(*((void *)this + 6) + 154) = 1;
LABEL_65:
  uint64_t v27 = *((void *)this + 6);
  if (*(void *)(v27 + 24))
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v27 = *((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNotice(*(CCLogStream **)(v27 + 24), "[dk] %s@%d:\t \n:%s:  mws_ocl_coex_bitmap: version:%u 2GMap:(0x%0x) 5GLoMap:(0x%0x) 5GMidMap:(0x%0x) 5GHiMap:(0x%0x) \n", "setMWSCoexIoVarsAsync_mws_ocl_coex_bitmap", 3516, "setMWSCoexIoVarsAsync_mws_ocl_coex_bitmap", *(unsigned __int16 *)(v27 + 144), *(unsigned __int16 *)(v27 + 146), *(unsigned __int16 *)(v27 + 148), *(unsigned __int16 *)(v27 + 150), *(unsigned __int16 *)(v27 + 152));
      uint64_t v27 = *((void *)this + 6);
    }
  }
  uint64_t v31 = *(void *)v27;
  uint64_t v30 = v27 + 144;
  uint64_t v29 = v31;
  return AppleBCMWLANCore::runSetMwsCoexIoVarsAsync_mws_ocl_coex_bitmap(v29, v30);
}

uint64_t AppleBCMWLANPowerManager::configureTVPM(AppleBCMWLANPowerManager *this)
{
  uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v2[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v2[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "configureTVPM", 3529, "configureTVPM");
      uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
    }
  }
  if (!AppleBCMWLANCore::checkForTVPMSupport(*v2)) {
    return 0;
  }
  uint64_t v4 = AppleBCMWLANPowerManager::configureTVPMPeriodicity((AppleBCMWLANCore ***)this, 10);
  uint64_t v5 = *((void *)this + 6);
  uint64_t v6 = *(void *)(v5 + 24);
  if (!v4)
  {
    if (v6)
    {
      int v7 = CCLogStream::shouldLog();
      uint64_t v5 = *((void *)this + 6);
      if (v7)
      {
        CCLogStream::logInfo(*(CCLogStream **)(v5 + 24), "[dk] %s@%d:Configured TVPM\n", "configureTVPM", 3550);
        uint64_t v5 = *((void *)this + 6);
      }
    }
    if (*(void *)(v5 + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 6) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "configureTVPM", 3551, "configureTVPM");
    }
    return 0;
  }
  if (v6 && CCLogStream::shouldLog()) {
    CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:Failed to Configure TVPM Periodicity\n", "configureTVPM", 3546);
  }
  return v4;
}

uint64_t AppleBCMWLANPowerManager::getOPSStatus(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v4 = *(AppleBCMWLANCore ***)(a1 + 48);
  if (v4[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v4 = *(AppleBCMWLANCore ***)(a1 + 48);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v4[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "getOPSStatus", 3626, "getOPSStatus");
      uint64_t v4 = *(AppleBCMWLANCore ***)(a1 + 48);
    }
  }
  char v6 = AppleBCMWLANCore::checkForOppPowerSaveSupport(*v4);
  uint64_t v7 = *(void *)(a1 + 48);
  if (v6)
  {
    BOOL v8 = AppleBCMWLANCore::is4387Up(*(AppleBCMWLANCore **)v7);
    uint64_t v9 = a2 + 2;
    if (v8)
    {
      *((_OWORD *)a2 + 5) = 0uLL;
      *(_OWORD *)(a2 + 26) = 0uLL;
      *(_OWORD *)(a2 + 34) = 0uLL;
      *(_OWORD *)(a2 + 10) = 0uLL;
      *(_OWORD *)(a2 + 18) = 0uLL;
      _OWORD *v9 = 0uLL;
      size_t v10 = 96;
      *(_DWORD *)a2 = 6291458;
    }
    else
    {
      *(_OWORD *)(a2 + 26) = 0uLL;
      *(_OWORD *)(a2 + 34) = 0uLL;
      *(_OWORD *)(a2 + 10) = 0uLL;
      *(_OWORD *)(a2 + 18) = 0uLL;
      _OWORD *v9 = 0uLL;
      *(_DWORD *)a2 = 5505025;
      size_t v10 = 84;
    }
    uint64_t v12 = IOMallocZeroData();
    uint64_t v13 = *(void *)(a1 + 48);
    if (v12)
    {
      uint64_t v14 = (void *)v12;
      AppleBCMWLANCore::is4387Up(*(AppleBCMWLANCore **)v13);
      memcpy(v14, a2, v10);
      v19[0] = v14;
      v19[1] = v10 | (v10 << 32);
      v18[0] = v14;
      v18[1] = v10;
      uint64_t v15 = AppleBCMWLANCommander::runIOVarGet(*(AppleBCMWLANCommander **)(*(void *)(a1 + 48) + 8), (uint64_t)"ops_status", (uint64_t)v18, (uint64_t)v19, 0);
      if (v15)
      {
        uint64_t v11 = v15;
        if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog()) {
          CCLogStream::logAlertIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:Failed to collect OPS Status values \n", "getOPSStatus", 3668);
        }
      }
      else
      {
        memcpy(a2, v14, v10);
        uint64_t v16 = *(void *)(a1 + 48);
        if (*a2 - 3 > 0xFFFFFFFD)
        {
          if (AppleBCMWLANCore::is4387Up(*(AppleBCMWLANCore **)v16))
          {
            if (*a2 == 2 && *(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog()) {
              CCLogStream::logAlertIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:OPS STATUS: Version=%d Len=%d slice_index=%d disable_obss=%d disable_reasons=%d disable_duration=%d applied_ops_config=%d partial_ops_dur=%d full_ops_dur=%d OPS Histogram[%d] [%d] [%d] [%d] [%d] nav_cnt=%d plcp_cnt=%d mybss_cnt=%d obss_cnt=%d miss_dur_cnt=%d miss_pret_cnt=%d max_dur_cnt=%d wake_cnt=%d bcn_wait_cnt=%d rx_time_mybss=%d,rx_time_ibss=%d,rx_time_obss=%d\n", "getOPSStatus", 3681, *a2, a2[1], *((unsigned __int8 *)a2 + 4), *((unsigned __int8 *)a2 + 5), *((unsigned int *)a2 + 2), *((unsigned int *)a2 + 3), *((unsigned int *)a2 + 4), *((unsigned int *)a2 + 5), *((unsigned int *)a2 + 6), *((unsigned int *)a2 + 7));
            }
          }
          else if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog())
          {
            CCLogStream::logAlertIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:OPS STATUS: Version=%d Len=%d slice_index=%d disable_obss=%d disable_reasons=%d disable_duration=%d applied_ops_config=%d partial_ops_dur=%d full_ops_dur=%d OPS Histogram[%d] [%d] [%d] [%d] [%d] nav_cnt=%d plcp_cnt=%d mybss_cnt=%d obss_cnt=%d miss_dur_cnt=%d miss_pret_cnt=%d max_dur_cnt=%d wake_cnt=%d bcn_wait_cnt=%d\n", "getOPSStatus", 3684, *a2, a2[1], *((unsigned __int8 *)a2 + 4), *((unsigned __int8 *)a2 + 5), *((unsigned int *)a2 + 2), *((unsigned int *)a2 + 3), *((unsigned int *)a2 + 4), *((unsigned int *)a2 + 5));
          }
          if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog()) {
            CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "getOPSStatus", 3686, "getOPSStatus");
          }
          uint64_t v11 = 0;
        }
        else
        {
          uint64_t v11 = 3758097084;
          if (*(void *)(v16 + 24) && CCLogStream::shouldLog()) {
            CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 24), "[dk] %s@%d:Incorrect OPS Version\n", "getOPSStatus", 3675);
          }
        }
      }
      IOFreeData();
    }
    else
    {
      uint64_t v11 = 3758097084;
      if (*(void *)(v13 + 24) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 24), "[dk] %s@%d:OPS: Unable to allocate memory for rxBuffSize\n", "getOPSStatus", 3652);
      }
    }
  }
  else
  {
    uint64_t v11 = 3758097084;
    if (*(void *)(v7 + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logAlertIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:OPS: OPS is not Supported!\n", "getOPSStatus", 3633);
    }
  }
  return v11;
}

uint64_t AppleBCMWLANPowerManager::getEBTStatus(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(AppleBCMWLANCore ***)(a1 + 48);
  if (v4[3])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v4 = *(AppleBCMWLANCore ***)(a1 + 48);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(v4[3], 0x20uLL, "[dk] %s@%d:MIMO_PS: Enter %s \n", "getEBTStatus", 3693, "getEBTStatus");
      uint64_t v4 = *(AppleBCMWLANCore ***)(a1 + 48);
    }
  }
  uint64_t v21 = 524289;
  if (AppleBCMWLANCore::checkForEarlyBeconTerminationSupport(*v4))
  {
    unsigned __int16 MaxCmdRxPayload = AppleBCMWLANCommander::getMaxCmdRxPayload(*(AppleBCMWLANCommander **)(*(void *)(a1 + 48) + 8));
    unsigned __int16 v7 = AppleBCMWLANCommander::getMaxCmdRxPayload(*(AppleBCMWLANCommander **)(*(void *)(a1 + 48) + 8));
    BOOL v8 = a2 != 0;
    BOOL v9 = MaxCmdRxPayload != 0;
    BOOL v10 = !v8 || !v9;
    if (v8 && v9) {
      unint64_t v11 = ((unint64_t)v7 << 32) | MaxCmdRxPayload;
    }
    else {
      unint64_t v11 = 0;
    }
    if (v10) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = a2;
    }
    v20[0] = v12;
    v20[1] = v11;
    uint64_t v13 = *(AppleBCMWLANCommander **)(*(void *)(a1 + 48) + 8);
    v19[0] = &v21;
    v19[1] = 8;
    uint64_t v14 = AppleBCMWLANCommander::runIOVarGet(v13, (uint64_t)"bcntrim_status", (uint64_t)v19, (uint64_t)v20, 0);
    uint64_t v15 = *(void *)(a1 + 48);
    uint64_t v16 = *(void *)(v15 + 24);
    if (v14)
    {
      if (v16 && CCLogStream::shouldLog()) {
        CCLogStream::logAlertIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:Failed to collect EBT Status values \n", "getEBTStatus", 3713);
      }
    }
    else
    {
      if (v16)
      {
        int v18 = CCLogStream::shouldLog();
        uint64_t v15 = *(void *)(a1 + 48);
        if (v18)
        {
          CCLogStream::logAlertIf(*(CCLogStream **)(v15 + 24), 0x20uLL, "[dk] %s@%d:CurrentSlice Index=%d Applied Config=%d Disable Duration=%d Beacons Seen=%d Trimming Considered=%d Trimmed=%d Reasons for Not Trimming: TIM Not Found=%d Beacon Length Change=%d Exceeded TSF Change=%d TIM Bit Set=%d Wake=%d SSID Len Change=%d DTIM Change=%d\n", "getEBTStatus", 3717, *(unsigned __int8 *)(a2 + 4), *(unsigned __int8 *)(a2 + 5), *(_DWORD *)(a2 + 12), *(_DWORD *)(a2 + 24), *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 20), *(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 32), *(_DWORD *)(a2 + 36), *(_DWORD *)(a2 + 40), *(_DWORD *)(a2 + 44), *(_DWORD *)(a2 + 48),
            *(_DWORD *)(a2 + 52));
          uint64_t v15 = *(void *)(a1 + 48);
        }
      }
      if (*(void *)(v15 + 24) && CCLogStream::shouldLog()) {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:MIMO_PS: Leave %s \n", "getEBTStatus", 3719, "getEBTStatus");
      }
    }
  }
  else
  {
    if (*(void *)(*(void *)(a1 + 48) + 24) && CCLogStream::shouldLog()) {
      CCLogStream::logAlertIf(*(CCLogStream **)(*(void *)(a1 + 48) + 24), 0x20uLL, "[dk] %s@%d:EBT: EBT is not Supported!\n", "getEBTStatus", 3704);
    }
    return 0;
  }
  return v14;
}

uint64_t AppleBCMWLANPowerManager::handleConfigureMPCThresholdAsyncCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = result;
    uint64_t result = *(void *)(*(void *)(result + 48) + 24);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        uint64_t v5 = *(void **)(v3 + 48);
        char v6 = (CCLogStream *)v5[3];
        unsigned __int16 v7 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 112))(*v5, a3);
        return CCLogStream::logAlert(v6, "[dk] %s@%d: Error: cannot configure MPC Threshold  value: %s\n", "handleConfigureMPCThresholdAsyncCallback", 3910, v7);
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::handleConfigureBCMInterfaceStateAsyncCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = result;
    uint64_t result = *(void *)(*(void *)(result + 48) + 24);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        uint64_t v5 = *(void **)(v3 + 48);
        char v6 = (CCLogStream *)v5[3];
        unsigned __int16 v7 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v5 + 112))(*v5, a3);
        return CCLogStream::logAlert(v6, "[dk] %s@%d: Error: cannot configure BCM Interface State : %s\n", "handleConfigureBCMInterfaceStateAsyncCallback", 3919, v7);
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANPowerManager::configureUnAssocFRTS(AppleBCMWLANPowerManager *this)
{
  int v15 = 20;
  uint64_t v2 = (AppleBCMWLANCore **)*((void *)this + 6);
  if (v2)
  {
    uint64_t v3 = 3758097095;
    if (AppleBCMWLANCore::checkForScanCoreSupport(*v2))
    {
      uint64_t v4 = *((void *)this + 6);
      if (!*(unsigned char *)(v4 + 180))
      {
        if (AppleBCMWLANCore::isAssociated(*(AppleBCMWLANCore **)v4))
        {
          return 3758097095;
        }
        else
        {
          uint64_t v5 = AppleBCMWLANPowerManager::configureBCMInterface((AppleBCMWLANCore ***)this, 0);
          if (v5)
          {
            uint64_t v3 = v5;
            *(unsigned char *)(*((void *)this + 6) + 180) = 1;
          }
          else
          {
            v14[0] = &v15;
            v14[1] = 4;
            uint64_t v6 = (*(uint64_t (**)(void))(***((void ***)this + 6) + 88))(**((void **)this + 6));
            if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 136))(v6)) {
              uint64_t v7 = AppleBCMWLANCommander::sendIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"mpc_threshold");
            }
            else {
              uint64_t v7 = AppleBCMWLANCommander::runIOVarSet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"mpc_threshold", (uint64_t)v14, 0, 0);
            }
            uint64_t v8 = v7;
            if (v7 && *(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog())
            {
              unint64_t v11 = (void *)*((void *)this + 6);
              uint64_t v12 = (CCLogStream *)v11[3];
              uint64_t v13 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v11 + 112))(*v11, v8);
              CCLogStream::logCrit(v12, "[dk] %s@%d:mpc_threshold value configuration failed %s\n", "configureUnAssocFRTS", 3960, v13);
            }
            uint64_t v3 = AppleBCMWLANPowerManager::configureBCMInterface((AppleBCMWLANCore ***)this, 1);
            uint64_t v9 = *((void *)this + 6);
            if (v3)
            {
              *(unsigned char *)(v9 + 180) = 1;
              CCFaultReporter::reportFault(*(CCFaultReporter **)(*((void *)this + 6) + 48), 5u, "/Library/Caches/com.apple.xbs/Sources/AppleBCMWLANV3_driverkit/AppleBCMWLANPowerManager.cpp", 0xF81u, "configureUnAssocFRTS", 0, -469790462, 0);
            }
            else if (*(void *)(v9 + 24) && CCLogStream::shouldLog())
            {
              CCLogStream::logInfo(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:UnAssoc FRTS is Configred to = %d\n", "configureUnAssocFRTS", 3971, v15);
            }
          }
        }
      }
    }
  }
  else
  {
    if (MEMORY[0x18] && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 24), "[dk] %s@%d:AppleBCMWLANPowerManager_IVARS failed\n", "configureUnAssocFRTS", 3930);
    }
    return 3758097084;
  }
  return v3;
}

uint64_t AppleBCMWLANPowerManager::configureBCMInterface(AppleBCMWLANCore ***this, int a2)
{
  if (!AppleBCMWLANCore::checkForScanCoreSupport(*this[6])) {
    return 3758097095;
  }
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)*this[6] + 88))(*this[6]);
  int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 136))(v4);
  if (a2)
  {
    if (v5)
    {
      unsigned int v22 = this;
      uint64_t v23 = AppleBCMWLANPowerManager::handleConfigureBCMInterfaceStateAsyncCallback;
      uint64_t v24 = 0;
      uint64_t v6 = this[6][1];
      int v7 = 2;
LABEL_8:
      uint64_t v9 = AppleBCMWLANCommander::sendIOCtlSet(v6, v7, (uint64_t)&kNoTxPayload, kNoRxExpected, (uint64_t)&v22, 0);
      goto LABEL_12;
    }
    BOOL v10 = this[6][1];
    int v11 = 2;
  }
  else
  {
    if (v5)
    {
      unsigned int v22 = this;
      uint64_t v23 = AppleBCMWLANPowerManager::handleConfigureBCMInterfaceStateAsyncCallback;
      uint64_t v24 = 0;
      uint64_t v6 = this[6][1];
      int v7 = 3;
      goto LABEL_8;
    }
    BOOL v10 = this[6][1];
    int v11 = 3;
  }
  uint64_t v9 = AppleBCMWLANCommander::runIOCtlSet(v10, v11, (uint64_t)&kNoTxPayload, 0, 0);
LABEL_12:
  uint64_t v8 = v9;
  uint64_t v12 = this[6][3];
  if (v8)
  {
    if (v12 && CCLogStream::shouldLog())
    {
      uint64_t v13 = this[6];
      uint64_t v14 = v13[3];
      if (a2) {
        int v15 = "Up";
      }
      else {
        int v15 = "Down";
      }
      uint64_t v16 = (const char *)(*(uint64_t (**)(AppleBCMWLANCore *, uint64_t))(*(void *)*v13 + 112))(*v13, v8);
      CCLogStream::logAlert(v14, "[dk] %s@%d:Failed to Config BCM Interface to %s %s\n", "configureBCMInterface", 4010, v15, v16);
    }
  }
  else
  {
    if (v12 && CCLogStream::shouldLog())
    {
      int v18 = this[6];
      unsigned int v19 = v18[3];
      if (a2) {
        uint64_t v20 = "Up";
      }
      else {
        uint64_t v20 = "Down";
      }
      uint64_t v21 = (const char *)(*(uint64_t (**)(AppleBCMWLANCore *, void))(*(void *)*v18 + 112))(*v18, 0);
      CCLogStream::logInfo(v19, "[dk] %s@%d:BCM Interface is = %s %s\n", "configureBCMInterface", 4008, v20, v21);
    }
    return 0;
  }
  return v8;
}

uint64_t AppleBCMWLANPowerManager::setHtSisoOnly(AppleBCMWLANPowerManager *this, int a2)
{
  int v11 = a2;
  uint64_t v3 = *(AppleBCMWLANCommander **)(*((void *)this + 6) + 8);
  v10[0] = &v11;
  v10[1] = 4;
  uint64_t v4 = AppleBCMWLANCommander::runIOVarSet(v3, (uint64_t)"ht_siso_only", (uint64_t)v10, 0, 0);
  if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog())
  {
    uint64_t v6 = (void *)*((void *)this + 6);
    int v7 = (CCLogStream *)v6[3];
    int v8 = v11;
    uint64_t v9 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v6 + 112))(*v6, v4);
    CCLogStream::logAlert(v7, "[dk] %s@%d:isHtSisoOnly <%d> rval=<%s>\n", "setHtSisoOnly", 4022, v8, v9);
  }
  return v4;
}

BOOL AppleBCMWLANPowerManager::getHtSisoOnly(AppleBCMWLANPowerManager *this)
{
  int v9 = 0;
  v8[0] = &v9;
  v8[1] = 0x400040004;
  uint64_t v2 = AppleBCMWLANCommander::runIOVarGet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 8), (uint64_t)"ht_siso_only", (uint64_t)&kNoTxPayload, (uint64_t)v8, 0);
  if (*(void *)(*((void *)this + 6) + 24) && CCLogStream::shouldLog())
  {
    uint64_t v4 = (void *)*((void *)this + 6);
    int v5 = (CCLogStream *)v4[3];
    int v6 = v9;
    int v7 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v4 + 112))(*v4, v2);
    CCLogStream::logAlert(v5, "[dk] %s@%d:isHtSisoOnly <%d> rval=<%s>\n", "getHtSisoOnly", 4035, v6, v7);
  }
  return v9 != 0;
}

void _GLOBAL__sub_I_AppleBCMWLANPowerManager_cpp()
{
  kNullRange = 0;
}

AppleBCMWLANPCIeMMIOHistory *AppleBCMWLANPCIeMMIOHistory::withLogger(AppleBCMWLANPCIeMMIOHistory *this, CCLogStream *a2)
{
  int v5 = (AppleBCMWLANPCIeMMIOHistory *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANPCIeMMIOHistoryMetaClass, (OSObject **)&v5)) {
    return 0;
  }
  uint64_t v3 = v5;
  if (v5 && (AppleBCMWLANPCIeMMIOHistory::initWithLogger((OSObject *)v5, this) & 1) == 0)
  {
    (*(void (**)(AppleBCMWLANPCIeMMIOHistory *))(*(void *)v3 + 16))(v3);
    return 0;
  }
  return v3;
}

uint64_t AppleBCMWLANPCIeMMIOHistory::initWithLogger(OSObject *this, CCLogStream *a2)
{
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden, const IORPC);
  OSObject_vtbl *v6;
  unsigned int release_high;
  const char *v8;
  const char *ClassNameHelper;

  uint64_t result = OSObject::init(this);
  if (result)
  {
    uint64_t result = IOMallocZeroTyped();
    this[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)result;
    if (result)
    {
      *(void *)(result + 32) = a2;
      Dispatch = this[1].Dispatch;
      if (Dispatch)
      {
        (*(void (**)(kern_return_t (__cdecl *)(OSObject *__hidden, const IORPC *__struct_ptr)))(*(void *)Dispatch + 8))(Dispatch);
        LOBYTE(this[1].getMetaClass) = 1;
        HIDWORD(this[1].release) = 256;
        IOParseBootArgNumber("wlan.pcie.mmiologdepth", (char *)&this[1].release + 4, 4);
        int v6 = this[1].OSMetaClassBase::__vftable;
        release_high = HIDWORD(v6->release);
        if (release_high <= 0x1F)
        {
          HIDWORD(v6->release) = 32;
          int v6 = this[1].OSMetaClassBase::__vftable;
          release_high = HIDWORD(v6->release);
        }
        if (release_high >= 0x401) {
          HIDWORD(v6->release) = 1024;
        }
        this[1].retain = (void (__cdecl *)(const OSObject *__hidden))IOMallocZeroTyped();
        if (this[1].retain)
        {
          return 1;
        }
        else
        {
          ClassNameHelper = (const char *)getClassNameHelper(this);
          IOLog("%s::%s(): Unable allocate records\n", ClassNameHelper, "initWithLogger");
          uint64_t result = (uint64_t)this[1].Dispatch;
          if (result)
          {
            (*(void (**)(uint64_t))(*(void *)result + 16))(result);
            uint64_t result = 0;
            this[1].Dispatch = 0;
          }
        }
      }
      else
      {
        int v8 = (const char *)getClassNameHelper(this);
        IOLog("%s::%s(): Unable to get debug logger\n", v8, "initWithLogger");
        return 0;
      }
    }
  }
  return result;
}

void AppleBCMWLANPCIeMMIOHistory::free(OSObject *this)
{
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden, const IORPC);
  OSObject_vtbl *v4;
  uint64_t vars8;

  uint64_t v2 = this[1].OSMetaClassBase::__vftable;
  if (v2)
  {
    Dispatch = v2->Dispatch;
    if (Dispatch)
    {
      (*(void (**)(kern_return_t (__cdecl *)(OSObject *__hidden, const IORPC *__struct_ptr)))(*(void *)Dispatch + 16))(v2->Dispatch);
      this[1].Dispatch = 0;
      uint64_t v2 = this[1].OSMetaClassBase::__vftable;
    }
    if (v2->retain)
    {
      IOFree(v2->retain, 56 * HIDWORD(v2->release));
      uint64_t v2 = this[1].OSMetaClassBase::__vftable;
    }
    memset_s(v2, 0x38uLL, 0, 0x38uLL);
    uint64_t v4 = this[1].OSMetaClassBase::__vftable;
    if (v4)
    {
      IOFree(v4, 0x38uLL);
      this[1].OSMetaClassBase::__vftable = 0;
    }
  }
  OSObject::free(this);
}

void non-virtual thunk to'AppleBCMWLANPCIeMMIOHistory::free(AppleBCMWLANPCIeMMIOHistory *this)
{
}

uint64_t AppleBCMWLANPCIeMMIOHistory::recordMMIO(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  uint64_t v6 = *(void *)(result + 40);
  if (*(unsigned char *)v6)
  {
    int v10 = a3;
    uint64_t v12 = result;
    uint64_t v13 = *(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(v6 + 48);
    if (v13)
    {
      uint64_t result = v13(*(void *)(v6 + 40), a2, a3, a4);
      if (!result) {
        return result;
      }
      uint64_t v6 = *(void *)(v12 + 40);
    }
    unsigned int v14 = *(_DWORD *)(v6 + 16);
    if (v14 >= *(_DWORD *)(v6 + 20))
    {
      *(_DWORD *)(v6 + 16) = 0;
      unsigned int v14 = *(_DWORD *)(*(void *)(v12 + 40) + 16);
    }
    mach_continuous_time();
    uint64_t result = absolutetime_to_nanoseconds();
    *(void *)(*(void *)(*(void *)(v12 + 40) + 8) + 56 * v14 + 48) = a2;
    *(_DWORD *)(*(void *)(*(void *)(v12 + 40) + 8) + 56 * v14 + 16) = v10;
    *(void *)(*(void *)(*(void *)(v12 + 40) + 8) + 56 * v14 + 24) = a4;
    *(void *)(*(void *)(*(void *)(v12 + 40) + 8) + 56 * v14 + 32) = a5;
    *(unsigned char *)(*(void *)(*(void *)(v12 + 40) + 8) + 56 * v14 + 40) = a6;
    uint64_t v15 = *(void *)(v12 + 40);
    uint64_t v16 = *(void *)(v15 + 24);
    *(void *)(v15 + 24) = v16 + 1;
    *(void *)(*(void *)(*(void *)(v12 + 40) + 8) + 56 * v14 + 8) = v16;
    ++*(_DWORD *)(*(void *)(v12 + 40) + 16);
  }
  return result;
}

uint64_t AppleBCMWLANPCIeMMIOHistory::dumpMMIO1lineToBuffer(int a1, uint64_t a2, char *__str, size_t __size)
{
  int v4 = *(_DWORD *)(a2 + 16);
  int v5 = "PW";
  uint64_t v6 = "W";
  if (v4 == 1) {
    uint64_t v6 = "R";
  }
  if (v4 != 2) {
    int v5 = v6;
  }
  if (v4) {
    int v7 = v5;
  }
  else {
    int v7 = "PR";
  }
  return snprintf(__str, __size, "%lld %06llu.%06llu %18s 0x%llx %s %dB: 0x%llx\n", *(void *)(a2 + 8), *(void *)a2 / 0x3B9ACA00uLL, *(void *)a2 % 0x3B9ACA00uLL / 0x3E8, *(const char **)(a2 + 48), *(void *)(a2 + 24), v7, *(unsigned __int8 *)(a2 + 40), *(void *)(a2 + 32));
}

uint64_t AppleBCMWLANPCIeMMIOHistory::dumpMMIOlogToBuffer(AppleBCMWLANPCIeMMIOHistory *this, char *a2, uint64_t a3)
{
  uint64_t v6 = (void *)IOMallocZeroData();
  if (!v6) {
    return 12;
  }
  uint64_t v7 = (uint64_t)v6;
  uint64_t v8 = *((void *)this + 5);
  unint64_t v9 = *(unsigned int *)(v8 + 16);
  LODWORD(v10) = memcpy(v6, *(const void **)(v8 + 8), 56 * *(unsigned int *)(v8 + 20));
  uint64_t v11 = *((void *)this + 5);
  uint64_t v12 = 0;
  if (v9 < *(_DWORD *)(v11 + 20) && a3 >= 1)
  {
    uint64_t v14 = v7 + 56 * v9;
    unint64_t v15 = v9 + 1;
    do
    {
      uint64_t v10 = AppleBCMWLANPCIeMMIOHistory::dumpMMIO1lineToBuffer(v10, v14, &a2[v12], a3 - v12);
      v12 += v10;
      uint64_t v11 = *((void *)this + 5);
      v14 += 56;
    }
    while (v15++ < *(unsigned int *)(v11 + 20) && v12 < a3);
  }
  if (v9 && v12 < a3)
  {
    unint64_t v18 = 1;
    uint64_t v19 = v7;
    do
    {
      uint64_t v10 = AppleBCMWLANPCIeMMIOHistory::dumpMMIO1lineToBuffer(v10, v19, &a2[v12], a3 - v12);
      if (v18 >= v9) {
        break;
      }
      v12 += v10;
      v19 += 56;
      ++v18;
    }
    while (v12 < a3);
    uint64_t v11 = *((void *)this + 5);
  }
  if (v9 != *(_DWORD *)(v11 + 16) && *(void *)(v11 + 32))
  {
    if (CCLogStream::shouldLog()) {
      CCLogStream::logWarn(*(CCLogStream **)(*((void *)this + 5) + 32), "[dk] %s@%d:index changed! %d =>%d\n", "dumpMMIOlogToBuffer", 238, v9, *(_DWORD *)(*((void *)this + 5) + 16));
    }
  }
  IOFreeData();
  return 0;
}

uint64_t AppleBCMWLANPCIeMMIOHistory::enableRecording(uint64_t this)
{
  **(unsigned char **)(this + 40) = 1;
  return this;
}

uint64_t AppleBCMWLANPCIeMMIOHistory::disableRecording(uint64_t this)
{
  **(unsigned char **)(this + 40) = 0;
  return this;
}

uint64_t AppleBCMWLANPCIeMMIOHistory::getRecordingStatus(AppleBCMWLANPCIeMMIOHistory *this)
{
  return **((unsigned __int8 **)this + 5);
}

uint64_t AppleBCMWLANPCIeMMIOHistory::recordMMIOBackPlane(AppleBCMWLANPCIeMMIOHistory *this, uint64_t a2, uint64_t a3, char a4, int a5, int a6)
{
  if (a5) {
    unsigned int v7 = 0;
  }
  else {
    unsigned int v7 = 2;
  }
  if (a5) {
    unsigned int v8 = 1;
  }
  else {
    unsigned int v8 = 3;
  }
  if (a6) {
    uint64_t v9 = v7;
  }
  else {
    uint64_t v9 = v8;
  }
  return AppleBCMWLANPCIeMMIOHistory::recordMMIO((uint64_t)this, (uint64_t)"BackPl", v9, a2, a3, a4);
}

uint64_t AppleBCMWLANPCIeMMIOHistory::recordMMIOMemory(AppleBCMWLANPCIeMMIOHistory *this, uint64_t a2, uint64_t a3, char a4, int a5, int a6)
{
  if (a5) {
    unsigned int v7 = 0;
  }
  else {
    unsigned int v7 = 2;
  }
  if (a5) {
    unsigned int v8 = 1;
  }
  else {
    unsigned int v8 = 3;
  }
  if (a6) {
    uint64_t v9 = v7;
  }
  else {
    uint64_t v9 = v8;
  }
  return AppleBCMWLANPCIeMMIOHistory::recordMMIO((uint64_t)this, (uint64_t)"Memory", v9, a2, a3, a4);
}

uint64_t AppleBCMWLANPCIeMMIOHistory::recordMMIOConfig(AppleBCMWLANPCIeMMIOHistory *this, unsigned int a2, unsigned int a3, char a4, int a5, int a6)
{
  if (a5) {
    LODWORD(v6) = 0;
  }
  else {
    LODWORD(v6) = 2;
  }
  if (a5) {
    unsigned int v7 = 1;
  }
  else {
    unsigned int v7 = 3;
  }
  if (a6) {
    uint64_t v6 = v6;
  }
  else {
    uint64_t v6 = v7;
  }
  return AppleBCMWLANPCIeMMIOHistory::recordMMIO((uint64_t)this, (uint64_t)"Config", v6, a2, a3, a4);
}

BOOL AppleBCMWLANTxItemRing::initWithOptions(AppleBCMWLANTxItemRing *this, OSObject *a2, void (*a3)(OSObject *, ...), void (*a4)(OSObject *, AppleBCMWLANByteRing *, int, void *))
{
  BOOL v6 = a3 != 0;
  if (!AppleBCMWLANItemRing::initWithOwnerAndActions(this, a2, a3, a4)) {
    return 0;
  }
  unsigned int v7 = (void *)IOMallocZeroTyped();
  *((void *)this + 12) = v7;
  if (!v7) {
    return 0;
  }
  *unsigned int v7 = a3;
  return v6;
}

BOOL non-virtual thunk to'AppleBCMWLANTxItemRing::initWithOptions(AppleBCMWLANTxItemRing *this, OSObject *a2, void (*a3)(OSObject *, ...), void (*a4)(OSObject *, AppleBCMWLANByteRing *, int, void *))
{
  return AppleBCMWLANTxItemRing::initWithOptions((AppleBCMWLANTxItemRing *)((char *)this - 88), a2, a3, a4);
}

uint64_t AppleBCMWLANTxItemRing::free(AppleBCMWLANTxItemRing *this)
{
  uint64_t v2 = (void *)*((void *)this + 12);
  if (v2)
  {
    void *v2 = 0;
    memset_s(*((void **)this + 12), 8uLL, 0, 8uLL);
    uint64_t v3 = (void *)*((void *)this + 12);
    if (v3)
    {
      IOFree(v3, 8uLL);
      *((void *)this + 12) = 0;
    }
  }
  return AppleBCMWLANItemRing::free(this);
}

uint64_t AppleBCMWLANTxItemRing::getRingFillAction(AppleBCMWLANTxItemRing *this)
{
  return **((void **)this + 12);
}

uint64_t non-virtual thunk to'AppleBCMWLANTxItemRing::getRingFillAction(AppleBCMWLANTxItemRing *this)
{
  return **((void **)this + 1);
}

BOOL AppleBCMWLANRxItemRing::initWithOptions(AppleBCMWLANRxItemRing *this, OSObject *a2, void (*a3)(OSObject *, ...), void (*a4)(OSObject *, AppleBCMWLANByteRing *, int, void *))
{
  BOOL v6 = a3 != 0;
  if (!AppleBCMWLANItemRing::initWithOwnerAndActions(this, a2, a3, a4)) {
    return 0;
  }
  unsigned int v7 = (void *)IOMallocZeroTyped();
  *((void *)this + 12) = v7;
  if (!v7) {
    return 0;
  }
  *unsigned int v7 = a3;
  return v6;
}

BOOL non-virtual thunk to'AppleBCMWLANRxItemRing::initWithOptions(AppleBCMWLANRxItemRing *this, OSObject *a2, void (*a3)(OSObject *, ...), void (*a4)(OSObject *, AppleBCMWLANByteRing *, int, void *))
{
  return AppleBCMWLANRxItemRing::initWithOptions((AppleBCMWLANRxItemRing *)((char *)this - 88), a2, a3, a4);
}

uint64_t AppleBCMWLANRxItemRing::getRingDrainAction(AppleBCMWLANRxItemRing *this)
{
  return **((void **)this + 12);
}

uint64_t non-virtual thunk to'AppleBCMWLANRxItemRing::getRingDrainAction(AppleBCMWLANRxItemRing *this)
{
  return **((void **)this + 1);
}

IO80211BSSBeacon *AppleBCMWLANBSSBeacon::fromWLBSSInfo(const void *a1, __int16 a2, size_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v12 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANBSSBeaconMetaClass, &v12)) {
    return 0;
  }
  uint64_t v10 = (IO80211BSSBeacon *)v12;
  if (v12
    && ((((uint64_t (*)(OSObject *, uint64_t, uint64_t))v12->OSMetaClassBase::__vftable[1].getMetaClass)(v12, a4, a5) & 1) == 0|| (AppleBCMWLANBSSBeacon::setBeaconData(v10, a1, a2, a3) & 1) == 0))
  {
    (*(void (**)(IO80211BSSBeacon *))(*(void *)v10 + 16))(v10);
    return 0;
  }
  return v10;
}

uint64_t AppleBCMWLANBSSBeacon::setBeaconData(IO80211BSSBeacon *a1, const void *a2, __int16 a3, size_t a4)
{
  uint64_t v8 = IOMallocZeroData();
  if (!v8) {
    AppleBCMWLANBSSBeacon::setBeaconData();
  }
  uint64_t v9 = v8;
  *((void *)a1 + 7) = 0;
  uint64_t v10 = (void *)IOMallocZeroData();
  uint64_t v11 = (uint64_t)v10;
  if (v10)
  {
    if (a4)
    {
      memcpy(v10, a2, a4);
      if (a4 > 0x7B)
      {
        if (AppleBCMWLANBSSBeacon::getBeaconMsgFromWLBSSInfo(v9, (void *)(v9 + 64), v11, a3, a4))
        {
          uint64_t v12 = IO80211BSSBeacon::setBeaconDataFromMsg();
          goto LABEL_16;
        }
        if (IO80211BSSBeacon::getLogger(a1))
        {
          IO80211BSSBeacon::getLogger(a1);
          if (CCLogStream::shouldLog())
          {
            Logger = (CCLogStream *)IO80211BSSBeacon::getLogger(a1);
            CCLogStream::logAlert(Logger, "[dk] %s@%d:Beacon assembly failure\n");
          }
        }
      }
      else if (IO80211BSSBeacon::getLogger(a1))
      {
        IO80211BSSBeacon::getLogger(a1);
        if (CCLogStream::shouldLog())
        {
          uint64_t v16 = (CCLogStream *)IO80211BSSBeacon::getLogger(a1);
          CCLogStream::logAlert(v16, "[dk] %s@%d:Not enough space remaining in the data buffer(%llu) for bss -> struct=%lu,%u\n");
        }
      }
      uint64_t v12 = 0;
LABEL_16:
      IOFreeData();
      goto LABEL_17;
    }
  }
  else if (a4)
  {
    if (IO80211BSSBeacon::getLogger(a1))
    {
      IO80211BSSBeacon::getLogger(a1);
      if (CCLogStream::shouldLog())
      {
        unint64_t v15 = (CCLogStream *)IO80211BSSBeacon::getLogger(a1);
        CCLogStream::logAlert(v15, "[dk] %s@%d: Allocation failure\n", "setBeaconData", 123);
      }
    }
    uint64_t v12 = 0;
    goto LABEL_17;
  }
  if (IO80211BSSBeacon::getLogger(a1))
  {
    IO80211BSSBeacon::getLogger(a1);
    if (CCLogStream::shouldLog())
    {
      unsigned int v17 = (CCLogStream *)IO80211BSSBeacon::getLogger(a1);
      CCLogStream::logAlert(v17, "[dk] %s@%d: Invalid argument\n", "setBeaconData", 122);
    }
  }
  uint64_t v12 = 0;
  if (v11) {
    goto LABEL_16;
  }
LABEL_17:
  IOFreeData();
  return v12;
}

uint64_t AppleBCMWLANBSSBeacon::getBeaconMsgFromWLBSSInfo(uint64_t a1, void *a2, uint64_t a3, __int16 a4, unint64_t a5)
{
  unint64_t v5 = *(unsigned int *)(a3 + 120);
  uint64_t v6 = *(unsigned int *)(a3 + 116);
  unint64_t v7 = *(unsigned int *)(a3 + 4);
  if (v7 > a5
    || (v6 - 1) <= 0x7A
    || a5 >> 16
    || v5 > a5
    || __CFADD__(v6, v5)
    || (v6 + v5) > a5
    || !(*(_DWORD *)(a3 + 8) | *(unsigned __int16 *)(a3 + 12))
    || *(unsigned __int8 *)(a3 + 18) >= 0x21u)
  {
    io80211_os_log();
    return 0;
  }
  else
  {
    int v13 = *(_DWORD *)(a3 + 8);
    *(_WORD *)(a1 + 45) = *(_WORD *)(a3 + 12);
    *(_DWORD *)(a1 + 41) = v13;
    size_t v14 = *(unsigned __int8 *)(a3 + 18);
    *(unsigned char *)(a1 + 38) = v14;
    memcpy((void *)(a1 + 6), (const void *)(a3 + 19), v14);
    int v15 = *(_DWORD *)(a1 + 60) | 2;
    *(_DWORD *)(a1 + 60) = v15;
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a3 + 14);
    *(_WORD *)(a1 + 4) = a4;
    if (*(unsigned char *)(a3 + 81))
    {
      char PrimaryChannel = *(unsigned char *)(a3 + 88);
    }
    else
    {
      char PrimaryChannel = ChanSpecGetPrimaryChannel();
      int v15 = *(_DWORD *)(a1 + 60);
    }
    *(unsigned char *)(a1 + 39) = PrimaryChannel;
    *(_DWORD *)(a1 + 48) = *(__int16 *)(a3 + 78);
    *(_DWORD *)(a1 + 60) = v15 & 0xFFFFFFFA;
    unsigned int v17 = v15 & 0xFFFFFFBA | (((*(unsigned __int8 *)(a3 + 96) >> 2) & 1) << 6);
    *(_DWORD *)(a1 + 60) = v17;
    unsigned int v18 = v17 & 0xFFFFFEFF | (((*(unsigned __int8 *)(a3 + 96) >> 5) & 1) << 8);
    *(_DWORD *)(a1 + 60) = v18;
    unsigned int v19 = (v18 & 0xFFFFBFFF | ((*(unsigned char *)(a3 + 96) & 0x10) << 10)) ^ 0x4000;
    *(_DWORD *)(a1 + 60) = v19;
    unsigned int v20 = v19 & 0xFFFFFF7F | ((*(unsigned char *)(a3 + 96) & 1) << 7);
    *(_DWORD *)(a1 + 60) = v20;
    unsigned int v21 = v20 & 0xFFFFFDFF | (((*(unsigned __int8 *)(a3 + 98) >> 3) & 1) << 9);
    *(_DWORD *)(a1 + 60) = v21;
    unsigned int v22 = v21 & 0xFFFFFBFF | (((*(unsigned __int8 *)(a3 + 98) >> 2) & 1) << 10);
    *(_DWORD *)(a1 + 60) = v22;
    unsigned int v23 = v22 & 0xFFFF77FA | (((*(unsigned __int8 *)(a3 + 98) >> 5) & 1) << 11);
    *(_DWORD *)(a1 + 60) = v23;
    if (v7 >= 0x7E && *(_DWORD *)a3 == 109)
    {
      v23 |= 0x3000u;
      *(_DWORD *)(a1 + 60) = v23;
      *(_WORD *)(a1 + 52) = *(char *)(a3 + 80);
      *(_WORD *)(a1 + 54) = *(_WORD *)(a3 + 124);
    }
    if ((*(unsigned char *)(a3 + 51) & 2) != 0)
    {
      if (*(unsigned char *)(a3 + 51))
      {
        *(_DWORD *)(a1 + 60) = v23 | 8;
        unsigned int v25 = v23 & 0xFFFFFFE7 | 8;
        unsigned int v24 = v23 | 0x18;
        if ((*(unsigned char *)(a3 + 77) & 0x10) == 0) {
          unsigned int v24 = v25;
        }
      }
      else
      {
        unsigned int v24 = v23 & 0xFFFFFFF7;
      }
      *(_DWORD *)(a1 + 60) = v24;
    }
    if (v5 >= 0x800) {
      size_t v26 = 2048;
    }
    else {
      size_t v26 = v5;
    }
    *(_DWORD *)a1 = v26;
    memcpy(a2, (const void *)(a3 + v6), v26);
    return 1;
  }
}

uint64_t AppleBCMWLANByteRing::initWithOwnerAndAction(AppleBCMWLANByteRing *this, OSObject *a2, void (*a3)(OSObject *, ...))
{
  uint64_t result = IO80211WorkSource::init(this, a2, a3);
  if (result)
  {
    uint64_t v5 = IOMallocZeroTyped();
    *((void *)this + 8) = v5;
    return v5 != 0;
  }
  return result;
}

uint64_t AppleBCMWLANByteRing::getLogger(AppleBCMWLANByteRing *this)
{
  return **((void **)this + 8);
}

uint64_t AppleBCMWLANByteRing::free(AppleBCMWLANByteRing *this)
{
  uint64_t v2 = (void *)*((void *)this + 8);
  if (v2)
  {
    if (*v2)
    {
      (*(void (**)(void))(*(void *)*v2 + 16))(*v2);
      **((void **)this + 8) = 0;
      uint64_t v2 = (void *)*((void *)this + 8);
    }
    memset_s(v2, 8uLL, 0, 8uLL);
    uint64_t v3 = (void *)*((void *)this + 8);
    if (v3)
    {
      IOFree(v3, 8uLL);
      *((void *)this + 8) = 0;
    }
  }
  return IO80211WorkSource::free(this);
}

uint64_t AppleBCMWLANByteRing::setLogger(uint64_t a1, uint64_t a2)
{
  int v4 = *(void **)(a1 + 64);
  if (*v4)
  {
    (*(void (**)(void))(*(void *)*v4 + 16))(*v4);
    **(void **)(a1 + 64) = 0;
    int v4 = *(void **)(a1 + 64);
  }
  *int v4 = a2;
  uint64_t result = **(void **)(a1 + 64);
  if (result)
  {
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v6();
  }
  return result;
}

OSObject *AppleBCMWLANCommander::withConfig(AppleBCMWLANCommander *this, AppleBCMWLANCore *a2, AppleBCMWLANBusInterface *a3)
{
  uint64_t v8 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANCommanderMetaClass, &v8)) {
    return 0;
  }
  uint64_t v6 = v8;
  if (v8
    && (((uint64_t (*)(OSObject *, AppleBCMWLANCommander *, AppleBCMWLANCore *, AppleBCMWLANBusInterface *))v8->OSMetaClassBase::__vftable[2].getMetaClass)(v8, this, a2, a3) & 1) == 0)
  {
    ((void (*)(OSObject *))v6->release)(v6);
    return 0;
  }
  return v6;
}

uint64_t AppleBCMWLANCommander::initWithConfig(OSObject *this, AppleBCMWLANCore *a2, AppleBCMWLANBusInterface *a3, uint64_t a4)
{
  int v8 = IO80211WorkSource::init((IO80211WorkSource *)this, this, 0);
  uint64_t result = 0;
  if (!a2) {
    return result;
  }
  if (!v8) {
    return result;
  }
  uint64_t result = IOMallocZeroTyped();
  this[1].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)result;
  if (!result) {
    return result;
  }
  *(void *)(result + 176) = a2;
  this[1].OSObjectInterface::__vftable[8].free = (void (__cdecl *)(OSObjectInterface *__hidden))IO80211CagedBuffer::withLayout();
  uint64_t v10 = this[1].OSObjectInterface::__vftable;
  if (!v10[8].free)
  {
    getClassNameHelper(this);
    IOLog("%s::%s(): Failure initializing commandAsyncResponseCagedBuffer\n");
    return 0;
  }
  this[1].OSObjectInterface::__vftable[12].init = (BOOL (__cdecl *)(OSObjectInterface *__hidden))(*(uint64_t (**)(BOOL (__cdecl *)(OSObjectInterface *__hidden)))(*(void *)v10[11].init + 88))(v10[11].init);
  this[1].OSObjectInterface::__vftable[11].free = (void (__cdecl *)(OSObjectInterface *__hidden))IO80211CommandGate::allocWithParams();
  if (!this[1].OSObjectInterface::__vftable[11].free) {
    return 0;
  }
  this[1].OSObjectInterface::__vftable[13].free = (void (__cdecl *)(OSObjectInterface *__hidden))(*(uint64_t (**)(AppleBCMWLANCore *))(*(void *)a2 + 1848))(a2);
  free = this[1].OSObjectInterface::__vftable[13].free;
  if (!free)
  {
    getClassNameHelper(this);
    IOLog("%s::%s(): Unable to get debug logger\n");
    return 0;
  }
  (*(void (**)(void (__cdecl *)(OSObjectInterface *__hidden)))(*(void *)free + 8))(free);
  AppleBCMWLANCommander::initCommanderStreams((AppleBCMWLANCommander *)this);
  this[1].OSObjectInterface::__vftable[7].free = (void (__cdecl *)(OSObjectInterface *__hidden))AppleBCMWLANCommander::checkExpiration;
  uint64_t v12 = this[1].OSObjectInterface::__vftable;
  if (!v12[7].free) {
    return 0;
  }
  v12[8].init = (BOOL (__cdecl *)(OSObjectInterface *__hidden))AppleBCMWLANCommander::updateTimestamp;
  int v13 = this[1].OSObjectInterface::__vftable;
  if (!v13[8].init) {
    return 0;
  }
  v13[13].init = (BOOL (__cdecl *)(OSObjectInterface *__hidden))a3;
  size_t v14 = this[1].OSObjectInterface::__vftable;
  init = v14[13].init;
  if (!init)
  {
    uint64_t result = (uint64_t)v14[13].free;
    if (!result) {
      return result;
    }
    uint64_t result = CCLogStream::shouldLog();
    if (!result) {
      return result;
    }
    CCLogStream::logAlert((CCLogStream *)this[1].OSObjectInterface::__vftable[13].free, "[dk] %s@%d: No bus provided to CmdManager\n");
    return 0;
  }
  (*(void (**)(BOOL (__cdecl *)(OSObjectInterface *__hidden)))(*(void *)init + 8))(init);
  this[1].OSObjectInterface::__vftable[18].free = (void (__cdecl *)(OSObjectInterface *__hidden))AppleBCMWLANCore::getFaultReporter((AppleBCMWLANCore *)this[1].OSObjectInterface::__vftable[11].init);
  (*(void (**)(void (__cdecl *)(OSObjectInterface *__hidden)))(*(void *)this[1].OSObjectInterface::__vftable[18].free
                                                                        + 8))(this[1].OSObjectInterface::__vftable[18].free);
  uint64_t v16 = this[1].OSObjectInterface::__vftable[11].init;
  unsigned int v17 = OSMetaClassBase::safeMetaCast((const OSMetaClassBase *)v16, gIOServiceMetaClass);
  this[1].free = (void (__cdecl *)(OSObjectInterface *__hidden))AppleBCMWLANCommandMonitor::withMonitorLengthProviderAndLogger((uint64_t)v16, 10, (uint64_t)v17, (uint64_t)this[1].OSObjectInterface::__vftable[13].free, (uint64_t)this[1].OSObjectInterface::__vftable[11].free, (uint64_t)this[1].OSObjectInterface::__vftable[18].free, (uint64_t)&IO80211Controller::addReporterLegend, (uint64_t)&IO80211Controller::removeReporterFromLegend);
  unsigned int v18 = this[1].OSObjectInterface::__vftable;
  if (!v18->free)
  {
    uint64_t result = (uint64_t)v18[13].free;
    if (!result) {
      return result;
    }
    uint64_t result = CCLogStream::shouldLog();
    if (!result) {
      return result;
    }
    CCLogStream::logAlert((CCLogStream *)this[1].OSObjectInterface::__vftable[13].free, "[dk] %s@%d:Failed to creat Command Monitor\n");
    return 0;
  }
  unsigned int v50 = 0;
  if (IOParseBootArgNumber("wlan.commander.thresholdn", &v50, 4)) {
    unsigned int v19 = v50;
  }
  else {
    unsigned int v19 = 0;
  }
  if (IOParseBootArgNumber("wlan.commander.thresholdt", &v50, 4)) {
    int v20 = v50;
  }
  else {
    int v20 = 0;
  }
  BOOL v21 = IOParseBootArgNumber("wlan.commander.stats", &v50, 4);
  char v22 = v50 == 1 && v21;
  LOBYTE(this[1].OSObjectInterface::__vftable[1].init) = 1;
  if (IOParseBootArgNumber("wlan.commander.disablecmdwd", &v50, 4)) {
    LOBYTE(this[1].OSObjectInterface::__vftable[1].init) = 0;
  }
  BYTE4(this[1].OSObjectInterface::__vftable[19].init) = 0;
  if (IOParseBootArgNumber("wlan.commander.paniconchecktimer", &v50, 4)) {
    BYTE4(this[1].OSObjectInterface::__vftable[19].init) = 1;
  }
  BYTE5(this[1].OSObjectInterface::__vftable[19].init) = 0;
  if (IOParseBootArgNumber("wlan.commander.testchecktimer", &v50, 4)) {
    BYTE5(this[1].OSObjectInterface::__vftable[19].init) = 1;
  }
  BYTE5(this[1].OSObjectInterface::__vftable[22].init) = 0;
  if (IOParseBootArgNumber("wlan.commander.CCForCmdtOutlierSync", &v50, 4)) {
    BYTE5(this[1].OSObjectInterface::__vftable[22].init) = 1;
  }
  BYTE6(this[1].OSObjectInterface::__vftable[22].init) = 0;
  if (IOParseBootArgNumber("wlan.commander.CCForCmdtOutlierAsync", &v50, 4)) {
    BYTE6(this[1].OSObjectInterface::__vftable[22].init) = 1;
  }
  LODWORD(this[1].OSObjectInterface::__vftable[22].free) = 0;
  if (IOParseBootArgNumber("wlan.commander.PendingThresSync", &v50, 4)) {
    LODWORD(this[1].OSObjectInterface::__vftable[22].free) = v50;
  }
  HIDWORD(this[1].OSObjectInterface::__vftable[22].free) = 0;
  if (IOParseBootArgNumber("wlan.commander.OutboundThres", &v50, 4)) {
    HIDWORD(this[1].OSObjectInterface::__vftable[22].free) = v50;
  }
  LODWORD(this[1].OSObjectInterface::__vftable[23].init) = 0;
  if (IOParseBootArgNumber("wlan.commander.ActiveThres", &v50, 4)) {
    LODWORD(this[1].OSObjectInterface::__vftable[23].init) = v50;
  }
  HIDWORD(this[1].OSObjectInterface::__vftable[23].init) = 0;
  if (IOParseBootArgNumber("wlan.commander.PendingThresAsync", &v50, 4)) {
    HIDWORD(this[1].OSObjectInterface::__vftable[23].init) = v50;
  }
  unsigned int v23 = this[1].free;
  if (v23)
  {
    AppleBCMWLANCommandMonitor::setRateThreshold((AppleBCMWLANCommandMonitor *)v23, v19, v20);
    AppleBCMWLANCommandMonitor::recordStats((uint64_t)this[1].free, v22);
  }
  this[1].OSObjectInterface::__vftable[14].init = (BOOL (__cdecl *)(OSObjectInterface *__hidden))IO80211TimerSource::allocWithParams();
  LOBYTE(this[1].OSObjectInterface::__vftable[14].free) = 0;
  unsigned int v24 = this[1].OSObjectInterface::__vftable;
  if (v24[14].init)
  {
    v24[4].init = (BOOL (__cdecl *)(OSObjectInterface *__hidden))AppleBCMWLANCommander::dequeueByID;
    this[1].OSObjectInterface::__vftable[4].free = (void (__cdecl *)(OSObjectInterface *__hidden))AppleBCMWLANCommander::queryByID;
    unsigned int v25 = this[1].OSObjectInterface::__vftable;
    uint64_t v26 = 80;
    while (1)
    {
      *(BOOL (__cdecl **)(OSObjectInterface *__hidden))((char *)&this[1].init + v26) = (BOOL (__cdecl *)(OSObjectInterface *__hidden))AppleBCMWLANCommandQueue::withGateAndCapacity((uint64_t)v25[11].free, a4);
      unsigned int v25 = this[1].OSObjectInterface::__vftable;
      if (!*(BOOL (__cdecl **)(OSObjectInterface *__hidden))((char *)&v25->init + v26)) {
        return 0;
      }
      v26 += 8;
      if (v26 == 120)
      {
        LODWORD(this[1].OSObjectInterface::__vftable[9].free) = (*(uint64_t (**)(void))(*((void *)v25[13].init + 6)
                                                                                     + 184))();
        uint64_t v27 = ((unsigned __int16)AppleBCMWLANCommander::getMaxCmdTxPayload((AppleBCMWLANCommander *)this) + 16) & 0x7FF;
        AppleBCMWLANCommander::getMaxCmdTxPayload((AppleBCMWLANCommander *)this);
        if (v27) {
          AppleBCMWLANCommander::getMaxCmdTxPayload((AppleBCMWLANCommander *)this);
        }
        (*(void (**)(BOOL (__cdecl *)(OSObjectInterface *__hidden)))(*(void *)this[1].OSObjectInterface::__vftable[11].init
                                                                              + 1840))(this[1].OSObjectInterface::__vftable[11].init);
        this[1].OSObjectInterface::__vftable[21].free = (void (__cdecl *)(OSObjectInterface *__hidden))IO80211BufferPool::withOptions();
        unsigned int v28 = this[1].OSObjectInterface::__vftable;
        uint64_t v29 = v28[21].free;
        if (v29)
        {
          (*(void (**)(void (__cdecl *)(OSObjectInterface *__hidden)))(*(void *)v29 + 8))(v29);
          if (a4)
          {
            int v30 = a4;
            while (1)
            {
              uint64_t v31 = this[1].OSObjectInterface::__vftable[13].init;
              uint64_t MaxCmdTxPayload = AppleBCMWLANCommander::getMaxCmdTxPayload((AppleBCMWLANCommander *)this);
              uint64_t result = (uint64_t)AppleBCMWLANCommand::newCmd((uint64_t)v31, MaxCmdTxPayload, (uint64_t)this[1].OSObjectInterface::__vftable[21].free);
              if (!result) {
                break;
              }
              AppleBCMWLANCommander::enqueueCommand((AppleBCMWLANCommander *)this, 0, (AppleBCMWLANCommand *)result);
              if (!--v30) {
                goto LABEL_64;
              }
            }
          }
          else
          {
LABEL_64:
            HIDWORD(this[1].OSObjectInterface::__vftable[10].init) = 1500;
            LODWORD(this[1].OSObjectInterface::__vftable[10].free) = 2000;
            HIDWORD(this[1].OSObjectInterface::__vftable[10].free) = 5000;
            BOOL v33 = IOParseBootArgNumber("wlan.commander.command_timeout", (char *)&this[1].OSObjectInterface::__vftable[10].init + 4, 4);
            int v34 = this[1].OSObjectInterface::__vftable;
            if (v33)
            {
              int init_high = HIDWORD(v34[10].init);
              if (init_high)
              {
                LODWORD(v34[10].free) = init_high;
                int v34 = this[1].OSObjectInterface::__vftable;
                if (v34[13].free)
                {
                  int shouldLog = CCLogStream::shouldLog();
                  int v34 = this[1].OSObjectInterface::__vftable;
                  if (shouldLog)
                  {
                    CCLogStream::logNotice((CCLogStream *)v34[13].free, "[dk] %s@%d:ivars->fActiveQueueTimeout %ld, ivars->fOutboundQueueTimeout %ld\n", "initWithConfig", 791, HIDWORD(v34[10].init), LODWORD(v34[10].free));
                    int v34 = this[1].OSObjectInterface::__vftable;
                  }
                }
              }
            }
            HIDWORD(v34[16].init) = 55000;
            if (IOParseBootArgNumber("wlan.factory", &v50, 4) && (v50 & 0x10) != 0)
            {
              LODWORD(this[1].OSObjectInterface::__vftable[10].free) = 60000;
              uint64_t v37 = this[1].OSObjectInterface::__vftable;
              if (v37[13].free)
              {
                int v38 = CCLogStream::shouldLog();
                uint64_t v37 = this[1].OSObjectInterface::__vftable;
                if (v38)
                {
                  CCLogStream::logNoticeIf((CCLogStream *)v37[13].free, 0x80uLL, "[dk] %s@%d: Force factory commander timeout[%u ms]\n", "initWithConfig", 799, LODWORD(v37[10].free));
                  uint64_t v37 = this[1].OSObjectInterface::__vftable;
                }
              }
              HIDWORD(v37[16].init) = LODWORD(v37[10].free) + 5000;
            }
            uint64_t v39 = this[1].OSObjectInterface::__vftable;
            unsigned int v40 = v39[10].free;
            if (v40 > HIDWORD(v39[10].free))
            {
              HIDWORD(v39[10].free) = v40;
              uint64_t v39 = this[1].OSObjectInterface::__vftable;
            }
            LODWORD(v39[15].init) = 5;
            IOParseBootArgNumber("wlan.debug.cto_wdcount", &this[1].OSObjectInterface::__vftable[15], 4);
            HIDWORD(this[1].OSObjectInterface::__vftable[15].init) = 24000;
            LODWORD(this[1].OSObjectInterface::__vftable[15].free) = 5000;
            HIDWORD(this[1].OSObjectInterface::__vftable[15].free) = 30000;
            LODWORD(this[1].OSObjectInterface::__vftable[16].init) = 30000;
            IOParseBootArgNumber("wlan.commander.oqs_delay_limit", (char *)&this[1].OSObjectInterface::__vftable[15].init + 4, 4);
            IOParseBootArgNumber("wlan.commander.oqs_delay_limit_lp", &this[1].OSObjectInterface::__vftable[15].free, 4);
            IOParseBootArgNumber("wlan.commander.aqs_delay_limit", (char *)&this[1].OSObjectInterface::__vftable[15].free + 4, 4);
            IOParseBootArgNumber("wlan.commander.aqs_delay_limit_lp", &this[1].OSObjectInterface::__vftable[16], 4);
            IOParseBootArgNumber("wlan.commander.command_complete_timeout", (char *)&this[1].OSObjectInterface::__vftable[16].init + 4, 4);
            LODWORD(this[1].OSObjectInterface::__vftable[9].init) = 0;
            HIDWORD(this[1].OSObjectInterface::__vftable[9].free) = 0;
            this[1].OSObjectInterface::__vftable[1].free = (void (__cdecl *)(OSObjectInterface *__hidden))OSSet::withCapacity((OSSet *)1, v41);
            v42 = this[1].OSObjectInterface::__vftable;
            if (v42[1].free)
            {
              this[1].OSObjectInterface::__vftable[12].free = (void (__cdecl *)(OSObjectInterface *__hidden))OSMetaClassBase::safeMetaCast((const OSMetaClassBase *)v42[11].init, gIOServiceMetaClass);
              ReporterProvider = (IOSimpleReporter *)IO80211Controller::getReporterProvider((IO80211Controller *)this[1].OSObjectInterface::__vftable[11].init);
              this[1].OSObjectInterface::__vftable[2].init = (BOOL (__cdecl *)(OSObjectInterface *__hidden))IOSimpleReporter::with(ReporterProvider, (IOService *)0x8010, 0, v44);
              __int16 v45 = this[1].OSObjectInterface::__vftable;
              uint64_t v46 = (const OSMetaClassBase *)v45[2].init;
              if (v46)
              {
                OSSet::setObject((OSSet *)v45[1].free, v46);
                (*(void (**)(BOOL (__cdecl *)(OSObjectInterface *__hidden)))(*(void *)this[1].OSObjectInterface::__vftable[2].init
                                                                                      + 16))(this[1].OSObjectInterface::__vftable[2].init);
                for (uint64_t i = 0; i != 176; i += 16)
                  IOReporter::addChannel((IOReporter *)this[1].OSObjectInterface::__vftable[2].init, *(void *)((char *)&kCommandsStatusReport + i), *(const char **)((char *)&kCommandsStatusReport + i + 8));
                IO80211Controller::addReporterLegend((IO80211Controller *)this[1].OSObjectInterface::__vftable[11].init, (IOService *)this[1].OSObjectInterface::__vftable[12].free, (IOReporter *)this[1].OSObjectInterface::__vftable[2].init, "Commander", "Counters");
                BYTE4(this[1].OSObjectInterface::__vftable[14].free) = 0;
                LODWORD(this[1].OSObjectInterface::__vftable[22].init) = a4;
                BYTE6(this[1].OSObjectInterface::__vftable[19].init) = 0;
                if (IOParseBootArgNumber("wlan.wdt.disableLogging", &v50, 4))
                {
                  v48 = this[1].OSObjectInterface::__vftable;
                  if (v48[13].free)
                  {
                    int v49 = CCLogStream::shouldLog();
                    v48 = this[1].OSObjectInterface::__vftable;
                    if (v49)
                    {
                      CCLogStream::logInfo((CCLogStream *)v48[13].free, "[dk] %s@%d: wlan.wdt.disableLogging %d\n", "initWithConfig", 851, v50);
                      v48 = this[1].OSObjectInterface::__vftable;
                    }
                  }
                  BYTE6(v48[19].init) = v50 != 0;
                }
                getClassNameHelper(this);
                CCFaultReporter::registerCallbacks();
                return 1;
              }
              else
              {
                uint64_t result = (uint64_t)v45[13].free;
                if (result)
                {
                  uint64_t result = CCLogStream::shouldLog();
                  if (result)
                  {
                    CCLogStream::logAlert((CCLogStream *)this[1].OSObjectInterface::__vftable[13].free, "[dk] %s@%d:Unable to create ivars->fCommandsStatus\n");
                    return 0;
                  }
                }
              }
            }
            else
            {
              uint64_t result = (uint64_t)v42[13].free;
              if (result)
              {
                uint64_t result = CCLogStream::shouldLog();
                if (result)
                {
                  CCLogStream::logAlert((CCLogStream *)this[1].OSObjectInterface::__vftable[13].free, "[dk] %s@%d:unable to create ivars->fCommandReporters\n");
                  return 0;
                }
              }
            }
          }
        }
        else
        {
          uint64_t result = (uint64_t)v28[13].free;
          if (result)
          {
            uint64_t result = CCLogStream::shouldLog();
            if (result)
            {
              CCLogStream::logCrit((CCLogStream *)this[1].OSObjectInterface::__vftable[13].free, "[dk] %s@%d: Unable to allocate control RX Buffer pool\n", "initWithConfig", 768);
              return 0;
            }
          }
        }
        return result;
      }
    }
  }
  uint64_t result = (uint64_t)v24[13].free;
  if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result)
    {
      CCLogStream::logAlert((CCLogStream *)this[1].OSObjectInterface::__vftable[13].free, "[dk] %s@%d: Unable to register command timer\n");
      return 0;
    }
  }
  return result;
}

BOOL AppleBCMWLANCommander::initCommanderStreams(AppleBCMWLANCommander *this)
{
  uint64_t v6 = 0;
  (*(void (**)(void, void, uint64_t *, void))(**(void **)(*((void *)this + 8) + 176) + 232))(*(void *)(*((void *)this + 8) + 176), 0, &v6, 0);
  uint64_t v2 = v6;
  if (v6)
  {
    bzero(v7, 0x358uLL);
    uint64_t v8 = -1;
    char v13 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v10 = 0;
    unint64_t v5 = 0xA5A5000000000003;
    OSDataPtr v14 = OSData::withBytes(&v5, 8uLL);
    __int16 v15 = 150;
    if (AppleBCMWLAN_isVerboseDebugLoggingAllowed())
    {
      LODWORD(v8) = 127;
      uint64_t v9 = 3;
    }
    uint64_t v3 = (const OSMetaClassBase *)CCStream::withPipeAndName();
    **((void **)this + 8) = OSMetaClassBase::safeMetaCast(v3, gCCLogStreamMetaClass);
    ((void (*)(OSDataPtr))v14->release)(v14);
  }
  return v2 != 0;
}

uint64_t AppleBCMWLANCommander::checkExpiration(int a1, AppleBCMWLANCommand *this, uint64_t a3)
{
  if (*(_DWORD *)a3 == -1 || AppleBCMWLANCommand::isCommandState((uint64_t)this, *(_DWORD *)a3))
  {
    unint64_t QueuedDuration_ms = AppleBCMWLANCommand::getQueuedDuration_ms(this);
    if (QueuedDuration_ms > *(void *)(a3 + 8))
    {
      ++*(_DWORD *)(a3 + 16);
      if (QueuedDuration_ms > *(void *)(a3 + 24))
      {
        *(void *)(a3 + 24) = QueuedDuration_ms;
        *(void *)(a3 + 32) = AppleBCMWLANCommand::getQueuedTime_ns(this);
      }
    }
  }
  return 0;
}

uint64_t AppleBCMWLANCommander::updateTimestamp(uint64_t a1, AppleBCMWLANCommand *this, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 8);
  if (v6 && v6 != AppleBCMWLANCommand::getBuffer(this)) {
    return 0;
  }
  AppleBCMWLANCommand::setQueuedTimestamp(this, *(_DWORD *)a3);
  if (*(unsigned char *)(a3 + 4))
  {
    int v7 = AppleBCMWLANCommand::commit(this);
    if (v7)
    {
      int v9 = v7;
      if (*(void *)(*(void *)(a1 + 64) + 216))
      {
        if (CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 64) + 216), "[dk] %s@%d:Commander commit() failed, [0x%08x]\n", "updateTimestamp", 2607, v9);
        }
      }
    }
  }
  if (*(void *)(a3 + 8)) {
    return 2;
  }
  else {
    return 0;
  }
}

uint64_t AppleBCMWLANCommander::checkQueues(AppleBCMWLANCommander *a1)
{
  *(void *)(*((void *)a1 + 8) + 328) = mach_continuous_time();
  if (*(void *)(*((void *)a1 + 8) + 40) && mach_continuous_time() < *(void *)(*((void *)a1 + 8) + 40))
  {
    unint64_t v47 = 0xAAAAAAAAAAAAAAAALL;
    absolutetime_to_nanoseconds();
    uint64_t v2 = *((void *)a1 + 8);
    if (*(void *)(v2 + 216))
    {
      int shouldLog = CCLogStream::shouldLog();
      uint64_t v2 = *((void *)a1 + 8);
      if (shouldLog)
      {
        CCLogStream::logAlert(*(CCLogStream **)(v2 + 216), "[dk] %s@%d:Delaying checkQueues. Deadline=%06llu.%06llu\n", "checkQueues", 2641, v47 / 0x3B9ACA00, v47 % 0x3B9ACA00 / 0x3E8);
LABEL_74:
        uint64_t v2 = *((void *)a1 + 8);
      }
    }
  }
  else
  {
    *(void *)(*((void *)a1 + 8) + 336) = mach_continuous_time();
    v58[0] = v58;
    v58[1] = v58;
    BOOL isPoweringOff = AppleBCMWLANCore::isPoweringOff(*(AppleBCMWLANCore **)(*((void *)a1 + 8) + 176));
    uint64_t v5 = *((void *)a1 + 8);
    uint64_t v6 = 252;
    if (isPoweringOff) {
      uint64_t v6 = 256;
    }
    int v7 = *(_DWORD *)(v5 + v6);
    unint64_t v47 = 0;
    v48 = &v47;
    unint64_t v49 = 0x2000000000;
    LODWORD(v50) = 0;
    uint64_t v54 = 0;
    unsigned __int16 v55 = &v54;
    uint64_t v56 = 0x2000000000;
    int v57 = 0;
    uint64_t v8 = *(void *)(v5 + 104);
    v52[0] = _NSConcreteStackBlock;
    v52[1] = 1107296256;
    v52[2] = ___ZN21AppleBCMWLANCommander11checkQueuesEP18IO80211TimerSource_block_invoke;
    v52[3] = &__block_descriptor_tmp_7;
    v52[4] = &v47;
    int v53 = v7;
    v52[5] = &v54;
    v52[6] = a1;
    AppleBCMWLANCommandQueue::lockFilter(v8, (uint64_t)v52, (uint64_t)v58);
    if (!*((_DWORD *)v48 + 6)) {
      *(void *)(*((void *)a1 + 8) + 56) = 0;
    }
    int v9 = (uint64_t *)v58[0];
    if (v58 == (void *)v58[0])
    {
      uint64_t v11 = 0;
    }
    else
    {
      do
      {
        if (*(uint64_t **)v9[1] != v9 || (uint64_t v10 = *v9, *(uint64_t **)(*v9 + 8) != v9)) {
          __break(1u);
        }
        *(void *)(v10 + 8) = v58;
        v58[0] = v10;
        uint64_t *v9 = 0;
        v9[1] = 0;
        uint64_t v11 = (AppleBCMWLANCommand *)IOCommand::FromChain();
        uint64_t v12 = *((void *)a1 + 8);
        if (*(void *)(v12 + 216))
        {
          int v13 = CCLogStream::shouldLog();
          uint64_t v12 = *((void *)a1 + 8);
          if (v13)
          {
            uint64_t v46 = *(CCLogStream **)(v12 + 216);
            CmdName = (const char *)AppleBCMWLANCommand::getCmdName(v11);
            int TransactionID = AppleBCMWLANCommand::getTransactionID(v11);
            unint64_t QueuedDuration_ms = AppleBCMWLANCommand::getQueuedDuration_ms(v11);
            unint64_t v15 = AppleBCMWLANCommand::getQueuedTime_ns(v11) / 0x3B9ACA00uLL;
            unint64_t QueuedTime_ns = AppleBCMWLANCommand::getQueuedTime_ns(v11);
            CCLogStream::logEmergency(v46, "[dk] %s@%d: Command Timeout on \"%s\" (transID %u) after %lld ms (queued @ %llu.%06llu)\n", "checkQueues", 2705, CmdName, TransactionID, QueuedDuration_ms, v15, (274877907 * (QueuedTime_ns % 0x3B9ACA00)) >> 38);
            uint64_t v12 = *((void *)a1 + 8);
          }
        }
        AppleBCMWLANCommand::logCmd((uint64_t)v11, *(void *)(v12 + 216), (uint64_t)"\t", 1, 1, -1);
        AppleBCMWLANCommand::setStatus((uint64_t)v11, -469793785);
        AppleBCMWLANCommand::getTransactionID(v11);
        AppleBCMWLANCommand::getStatus(v11);
        AppleBCMWLANCommand::getIOCtl(v11);
        AppleBCMWLANCommand::getIOVar(v11);
        kdebug_trace();
        atomic_fetch_add_explicit((atomic_uint *volatile)(*((void *)a1 + 8) + 148), 0xFFFFFFFF, memory_order_relaxed);
        AppleBCMWLANCommander::enqueueCommand(a1, 4u, v11);
        int v9 = (uint64_t *)v58[0];
      }
      while (v58 != (void *)v58[0]);
    }
    int v17 = *((_DWORD *)v55 + 6);
    if (v17)
    {
      ++*(_DWORD *)(*((void *)a1 + 8) + 160);
      uint64_t v18 = *((void *)a1 + 8);
      if (*(unsigned char *)(v18 + 307))
      {
        *(unsigned char *)(v18 + 307) = 0;
        uint64_t v18 = *((void *)a1 + 8);
      }
      if ((AppleBCMWLANCore::getDebugFlags(*(AppleBCMWLANCore **)(v18 + 176)) & 0x20) != 0) {
        unsigned int v19 = 6;
      }
      else {
        unsigned int v19 = 4;
      }
      uint64_t v20 = *((void *)a1 + 8);
      if (*(_DWORD *)(v20 + 160) >= *(_DWORD *)(v20 + 240))
      {
        v19 |= 1u;
        *(_DWORD *)(v20 + 160) = 0;
        *(void *)(*((void *)a1 + 8) + 56) = 0;
      }
      IO80211WorkSource::signalWorkAvailable(a1);
      uint64_t v21 = 3825173511;
    }
    else
    {
      uint64_t v21 = 0;
      unsigned int v19 = 0;
    }
    _Block_object_dispose(&v54, 8);
    _Block_object_dispose(&v47, 8);
    uint64_t v22 = *((void *)a1 + 8);
    v48 = (unint64_t *)*(unsigned int *)(v22 + 168);
    unint64_t v47 = 0xAAAAAAAA00000001;
    unint64_t v50 = 0;
    unint64_t v49 = 0xAAAAAAAA00000000;
    unint64_t v51 = 0;
    if (AppleBCMWLANCore::isPoweringOff(*(AppleBCMWLANCore **)(v22 + 176))) {
      LODWORD(v47) = -1;
    }
    AppleBCMWLANCommandQueue::lockMap(*(void *)(*((void *)a1 + 8) + 96), *(void (**)(uint64_t, uint64_t, uint64_t))(*((void *)a1 + 8) + 120), (uint64_t)a1, (uint64_t)&v47);
    uint64_t v23 = *((void *)a1 + 8);
    if (v49)
    {
      int v24 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v23 + 208) + 600))(*(void *)(v23 + 208), v23 + 48);
      uint64_t v25 = *((void *)a1 + 8);
      if (!v24) {
        goto LABEL_39;
      }
      unint64_t v26 = v50;
      BOOL v27 = AppleBCMWLANCore::isPoweringOff(*(AppleBCMWLANCore **)(v25 + 176));
      uint64_t v25 = *((void *)a1 + 8);
      uint64_t v28 = 244;
      if (v27) {
        uint64_t v28 = 248;
      }
      if (v26 < *(unsigned int *)(v25 + v28))
      {
        if (*(void *)(v25 + 216) && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 8) + 216), "[dk] %s@%d: Delaying Outbound Queue Stall after %lld ms (queued @ %llu.%06llu)\n", "checkQueues", 2758, v50, v51 / 0x3B9ACA00, v51 % 0x3B9ACA00 / 0x3E8);
        }
      }
      else
      {
LABEL_39:
        AppleBCMWLANCore::triggerTTR(*(IO80211Controller **)(v25 + 176), 0);
        uint64_t v29 = *((void *)a1 + 8);
        if (*(void *)(v29 + 216))
        {
          int v30 = CCLogStream::shouldLog();
          uint64_t v29 = *((void *)a1 + 8);
          if (v30)
          {
            CCLogStream::logEmergency(*(CCLogStream **)(v29 + 216), "[dk] %s@%d: Outbound Queue Stall after %lld ms (queued @ %llu.%06llu) OQSTimeooutEpoch %llu\n", "checkQueues", 2767, v50, v51 / 0x3B9ACA00, v51 % 0x3B9ACA00 / 0x3E8, *(void *)(v29 + 48));
            uint64_t v29 = *((void *)a1 + 8);
          }
        }
        v19 |= 5u;
        *(void *)(v29 + 48) = 0;
        if (!v17)
        {
          uint64_t v11 = (AppleBCMWLANCommand *)AppleBCMWLANCommandQueue::lockPeek(*(AppleBCMWLANCommandQueue **)(*((void *)a1 + 8) + 96));
          uint64_t v31 = *((void *)a1 + 8);
          if (*(unsigned char *)(v31 + 306))
          {
            *(unsigned char *)(v31 + 306) = 0;
            uint64_t v31 = *((void *)a1 + 8);
          }
          if ((AppleBCMWLANCore::getDebugFlags(*(AppleBCMWLANCore **)(v31 + 176)) & 0x10) != 0) {
            unsigned int v19 = 7;
          }
          uint64_t v21 = 3825173510;
        }
      }
    }
    else
    {
      *(void *)(v23 + 48) = 0;
    }
    uint64_t v2 = *((void *)a1 + 8);
    if (*(_DWORD *)(v2 + 148) < *(_DWORD *)(v2 + 152))
    {
      v48 = (unint64_t *)*(unsigned int *)(v2 + 172);
      unint64_t v47 = 0xAAAAAAAA00000000;
      unint64_t v50 = 0;
      unint64_t v49 = 0xAAAAAAAA00000000;
      unint64_t v51 = 0;
      AppleBCMWLANCommandQueue::lockMap(*(void *)(v2 + 88), *(void (**)(uint64_t, uint64_t, uint64_t))(v2 + 120), (uint64_t)a1, (uint64_t)&v47);
      uint64_t v2 = *((void *)a1 + 8);
      if (v49)
      {
        if (*(void *)(v2 + 216))
        {
          int v32 = CCLogStream::shouldLog();
          uint64_t v2 = *((void *)a1 + 8);
          if (v32)
          {
            CCLogStream::logEmergency(*(CCLogStream **)(v2 + 216), "[dk] %s@%d: Pending queue stall after %lld ms (queued @ %llu.%06llu)\n", "checkQueues", 2798, v50, v51 / 0x3B9ACA00, v51 % 0x3B9ACA00 / 0x3E8);
            uint64_t v2 = *((void *)a1 + 8);
          }
        }
        v19 |= 5u;
        if (!v21)
        {
          uint64_t v11 = (AppleBCMWLANCommand *)AppleBCMWLANCommandQueue::lockPeek(*(AppleBCMWLANCommandQueue **)(v2 + 88));
          uint64_t v33 = *((void *)a1 + 8);
          if (*(unsigned char *)(v33 + 305))
          {
            *(unsigned char *)(v33 + 305) = 0;
            uint64_t v33 = *((void *)a1 + 8);
          }
          if ((AppleBCMWLANCore::getDebugFlags(*(AppleBCMWLANCore **)(v33 + 176)) & 8) != 0) {
            unsigned int v19 = 7;
          }
          uint64_t v2 = *((void *)a1 + 8);
          uint64_t v21 = 3825173509;
        }
      }
    }
    if (v21)
    {
      IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(v2 + 32), 0x436D644973507200uLL, 1);
      int v34 = (*(uint64_t (**)(void))(**(void **)(*((void *)a1 + 8) + 208) + 208))(*(void *)(*((void *)a1 + 8) + 208));
      uint64_t v35 = *((void *)a1 + 8);
      if (v34)
      {
        if (*(void *)(v35 + 216))
        {
          int v36 = CCLogStream::shouldLog();
          uint64_t v35 = *((void *)a1 + 8);
          if (v36)
          {
            v42 = *(CCLogStream **)(v35 + 216);
            __int16 v43 = (const char *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v35 + 176) + 112))(*(void *)(v35 + 176), v21);
            CCLogStream::logAlert(v42, "[dk] %s@%d:Command error occured while having a FW trap code=%s\n", "checkQueues", 2821, v43);
            uint64_t v35 = *((void *)a1 + 8);
          }
        }
      }
      uint64_t v37 = *(CCFaultReporter **)(v35 + 296);
      int v38 = v11 ? (const char *)AppleBCMWLANCommand::getCmdName(v11) : "NULL";
      int v39 = CCFaultReporter::reportFault(v37, v19, "/Library/Caches/com.apple.xbs/Sources/AppleBCMWLANV3_driverkit/AppleBCMWLANCommander.cpp", 0xB07u, "checkQueues", 0, v21, "cmd=%s", v38);
      uint64_t v2 = *((void *)a1 + 8);
      if (v39)
      {
        int v41 = v39;
        if (*(void *)(v2 + 216) && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 8) + 216), "[dk] %s@%d:FaultReporter return %x, will reset commander\n", "checkQueues", 2825, v41);
        }
        AppleBCMWLANCommander::reset(a1);
        goto LABEL_74;
      }
    }
  }
  *(unsigned char *)(v2 + 232) = 0;
  return AppleBCMWLANCommander::configureWatchdog(a1);
}

uint64_t AppleBCMWLANCommander::dequeueByID(AppleBCMWLANCommander *this, IOCommand *a2, _DWORD *a3)
{
  int v5 = a3[3];
  if (v5 == AppleBCMWLANCommand::getIOCtl(a2)
    && (int v6 = *((unsigned __int16 *)a3 + 8), v6 == AppleBCMWLANCommand::getTransactionID(a2)))
  {
    return 4;
  }
  else
  {
    return 0;
  }
}

uint64_t AppleBCMWLANCommander::queryByID(AppleBCMWLANCommander *this, IOCommand *a2, _DWORD *a3)
{
  int v5 = a3[3];
  if (v5 == AppleBCMWLANCommand::getIOCtl(a2)
    && (int v6 = *((unsigned __int16 *)a3 + 8), v6 == AppleBCMWLANCommand::getTransactionID(a2)))
  {
    return 2;
  }
  else
  {
    return 0;
  }
}

uint64_t AppleBCMWLANCommander::getMaxCmdTxPayload(AppleBCMWLANCommander *this)
{
  uint64_t v2 = *(void *)(*((void *)this + 8) + 208);
  if (v2 && (*(uint64_t (**)(void))(*(void *)(v2 + 48) + 168))()) {
    return (*(uint64_t (**)(void))(*(void *)(*(void *)(*((void *)this + 8) + 208) + 48) + 168))() - 16;
  }
  else {
    return 16;
  }
}

uint64_t AppleBCMWLANCommander::enqueueCommand(AppleBCMWLANCommander *a1, unsigned int a2, AppleBCMWLANCommand *this)
{
  AppleBCMWLANCommand::setQueuedTimestamp(this, a2);
  AppleBCMWLANCommandQueue::lockEnqueue(*(AppleBCMWLANCommandQueue **)(*((void *)a1 + 8) + 8 * a2 + 80), this);
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)a1 + 8) + 88));
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)a1 + 8) + 96));
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)a1 + 8) + 104));
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)a1 + 8) + 112));
  kdebug_trace();
  return AppleBCMWLANCommander::configureWatchdog(a1);
}

uint64_t AppleBCMWLANCommander::prepareFRCallback(AppleBCMWLANCommander *this, const CCFaultReport *a2)
{
  *(unsigned char *)(*((void *)this + 8) + 238) = *(unsigned char *)(*((void *)this + 8) + 237);
  IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647250617500uLL, 1);
  *(unsigned char *)(*((void *)this + 8) + 237) = 1;
  return 0;
}

uint64_t AppleBCMWLANCommander::collectImmediateFaultDataCallback(AppleBCMWLANCommander *this, CCFaultReport *a2)
{
  uint64_t v3 = *((void *)this + 8);
  if (*(unsigned char *)(v3 + 310))
  {
    if (*(void *)(v3 + 216) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d:Skip WDT logging\n", "collectImmediateFaultDataCallback", 3182);
    }
  }
  else
  {
    int v5 = (char *)IOMallocZeroData();
    if (v5)
    {
      int v6 = v5;
      AppleBCMWLANCommander::dumpState(this, v5, 0, 0x3FFF);
      OSStringPtr v7 = OSString::withCString("CommanderState.txt");
      OSStringPtr v8 = OSString::withCString(v6);
      (*(void (**)(CCFaultReport *, OSStringPtr, OSStringPtr))(*(void *)a2 + 192))(a2, v7, v8);
      IOFreeData();
    }
  }
  return 0;
}

uint64_t AppleBCMWLANCommander::completeFaultReportCallback(AppleBCMWLANCommander *this, const CCFaultReport *a2)
{
  if ((*(unsigned int (**)(const CCFaultReport *))(*(void *)a2 + 88))(a2)
    && CCFaultReport::getWatchdogResult(a2))
  {
    if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog())
    {
      OSStringPtr v7 = *(CCLogStream **)(*((void *)this + 8) + 216);
      OSStringPtr v8 = (const OSString *)(*(uint64_t (**)(const CCFaultReport *))(*(void *)a2 + 56))(a2);
      CStringNoCopy = OSString::getCStringNoCopy(v8);
      int WatchdogResult = CCFaultReport::getWatchdogResult(a2);
      CCLogStream::logAlert(v7, "[dk] %s@%d: Failed to trigger WD \"%s\", error 0x%x\n", "completeFaultReportCallback", 3201, CStringNoCopy, WatchdogResult);
    }
    AppleBCMWLANCommander::reset(this);
  }
  else if (((*(uint64_t (**)(const CCFaultReport *))(*(void *)a2 + 88))(a2) & 1) == 0)
  {
    if (AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 88))
      || AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 96))
      || AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 104)))
    {
      AppleBCMWLANCommander::delayQueueTimeouts(this);
      if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog())
      {
        uint64_t v5 = *((void *)this + 8);
        int v6 = *(CCLogStream **)(v5 + 216);
        AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(v5 + 88));
        AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 96));
        AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 104));
        CCLogStream::logNoticeIf(v6, 4uLL, "[dk] %s@%d:Give more time %d, P %u, O %u, A %u\n", "completeFaultReportCallback");
      }
    }
    else if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog())
    {
      CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)this + 8) + 216), 4uLL, "[dk] %s@%d:No command in flight\n");
    }
  }
  if (!*(unsigned char *)(*((void *)this + 8) + 238)) {
    AppleBCMWLANCommander::unpause(this);
  }
  return 0;
}

uint64_t AppleBCMWLANCommander::induceFaultCallback(AppleBCMWLANCommander *this, int a2, const char *a3)
{
  int v14 = 1;
  uint64_t v12 = &v14;
  uint64_t v13 = 0x400040004;
  if (a2 > -469793786)
  {
    if (a2 == -469793785)
    {
      *(unsigned char *)(*((void *)this + 8) + 307) = 1;
      uint64_t v9 = *((void *)this + 8);
      if (*(void *)(v9 + 216))
      {
        int shouldLog = CCLogStream::shouldLog();
        uint64_t v9 = *((void *)this + 8);
        if (shouldLog)
        {
          CCLogStream::logAlert(*(CCLogStream **)(v9 + 216), "[dk] %s@%d:Force Command Timeout\n", "induceFaultCallback", 3272);
          uint64_t v9 = *((void *)this + 8);
        }
      }
      uint64_t v16 = 0;
      uint64_t v15 = 0x1AAAAAA00;
      unint64_t v17 = 0xAAAAAAAA00000005;
      if (AppleBCMWLANCommander::issueCommand(this, (unsigned __int8 *)&v15, (uint64_t)&kNoTxPayload, (uint64_t)&v12, (unsigned __int16 *)&v13 + 1, v9 + 264, 0)&& *(void *)(*((void *)this + 8) + 216)&& CCLogStream::shouldLog())
      {
        int v6 = *(CCLogStream **)(*((void *)this + 8) + 216);
        goto LABEL_31;
      }
    }
    else if (a2 == -469793767)
    {
      *(unsigned char *)(*((void *)this + 8) + 304) = 1;
      if (*(void *)(*((void *)this + 8) + 216))
      {
        if (CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d:Force Return Command Response Invalid\n");
        }
      }
    }
  }
  else if (a2 == -469793787)
  {
    *(unsigned char *)(*((void *)this + 8) + 305) = 1;
    uint64_t v7 = *((void *)this + 8);
    if (*(void *)(v7 + 216))
    {
      int v8 = CCLogStream::shouldLog();
      uint64_t v7 = *((void *)this + 8);
      if (v8)
      {
        CCLogStream::logAlert(*(CCLogStream **)(v7 + 216), "[dk] %s@%d:Force Pending Queue Stall\n", "induceFaultCallback", 3246);
        uint64_t v7 = *((void *)this + 8);
      }
    }
    uint64_t v16 = 0;
    uint64_t v15 = 0x1AAAAAA00;
    unint64_t v17 = 0xAAAAAAAA00000005;
    if (AppleBCMWLANCommander::issueCommand(this, (unsigned __int8 *)&v15, (uint64_t)&kNoTxPayload, (uint64_t)&v12, (unsigned __int16 *)&v13 + 1, v7 + 264, 0)&& *(void *)(*((void *)this + 8) + 216)&& CCLogStream::shouldLog())
    {
      int v6 = *(CCLogStream **)(*((void *)this + 8) + 216);
      goto LABEL_31;
    }
  }
  else if (a2 == -469793786)
  {
    *(unsigned char *)(*((void *)this + 8) + 306) = 1;
    *(unsigned char *)(*((void *)this + 8) + 307) = 1;
    uint64_t v4 = *((void *)this + 8);
    if (*(void *)(v4 + 216))
    {
      int v5 = CCLogStream::shouldLog();
      uint64_t v4 = *((void *)this + 8);
      if (v5)
      {
        CCLogStream::logAlert(*(CCLogStream **)(v4 + 216), "[dk] %s@%d:Force Outbound Queue Stall\n", "induceFaultCallback", 3263);
        uint64_t v4 = *((void *)this + 8);
      }
    }
    uint64_t v16 = 0;
    uint64_t v15 = 0x1AAAAAA00;
    unint64_t v17 = 0xAAAAAAAA00000005;
    if (AppleBCMWLANCommander::issueCommand(this, (unsigned __int8 *)&v15, (uint64_t)&kNoTxPayload, (uint64_t)&v12, (unsigned __int16 *)&v13 + 1, v4 + 264, 0))
    {
      if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog())
      {
        int v6 = *(CCLogStream **)(*((void *)this + 8) + 216);
LABEL_31:
        CCLogStream::logAlert(v6, "[dk] %s@%d: Failed GET IOCTL, cret[0x%08x]\n");
      }
    }
  }
  return 0;
}

uint64_t non-virtual thunk to'AppleBCMWLANCommander::initWithConfig(AppleBCMWLANCommander *this, AppleBCMWLANCore *a2, AppleBCMWLANBusInterface *a3, uint64_t a4)
{
  return AppleBCMWLANCommander::initWithConfig((OSObject *)((char *)this - 56), a2, a3, a4);
}

uint64_t AppleBCMWLANCommander::runIOCtlSet(AppleBCMWLANCommander *a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v9 = 0;
  v8[0] = -1431655936;
  v8[1] = a2;
  unint64_t v10 = 0xAAAAAAAA00000006;
  if (a4) {
    int v6 = (unsigned __int16 *)(a4 + 10);
  }
  else {
    int v6 = (unsigned __int16 *)&kNoRxExpected;
  }
  return AppleBCMWLANCommander::issueCommand(a1, (unsigned __int8 *)v8, a3, a4, v6, *((void *)a1 + 8) + 264, a5);
}

uint64_t AppleBCMWLANCommander::issueCommand(AppleBCMWLANCommander *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, int a7)
{
  unint64_t v14 = *(unsigned __int16 *)(a3 + 8);
  if (*a2 == 255)
  {
    uint64_t v15 = *((void *)this + 8);
    if (*(void *)(v15 + 216))
    {
      int shouldLog = CCLogStream::shouldLog();
      uint64_t v15 = *((void *)this + 8);
      if (shouldLog)
      {
        CCLogStream::logAlert(*(CCLogStream **)(v15 + 216), "[dk] %s@%d:ERROR: IOVAR \"%s\" IOCTL %d on an invalid interface %d\n", "issueCommand", 1639, *((const char **)a2 + 1), *((_DWORD *)a2 + 1), *a2);
        uint64_t v15 = *((void *)this + 8);
      }
    }
    if (*(void *)(v15 + 216) && CCLogStream::shouldLog())
    {
      v117 = (const char *)*((void *)a2 + 1);
      if (!v117) {
        v117 = "<UNKNOWN>";
      }
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1640, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v117);
    }
  }
  unint64_t v17 = (const char *)*((void *)a2 + 1);
  if (v17)
  {
    unsigned int v18 = strnlen(v17, 0x22uLL);
    unsigned int v19 = v18;
    if (v18 >= 0x22)
    {
      uint64_t v20 = *((void *)this + 8);
      if (*(void *)(v20 + 216))
      {
        int v21 = CCLogStream::shouldLog();
        uint64_t v20 = *((void *)this + 8);
        if (v21)
        {
          CCLogStream::logAlert(*(CCLogStream **)(v20 + 216), "[dk] %s@%d: IOVal command iovar is too long (len: %lu)!\n", "issueCommand", 1649, v19);
          uint64_t v20 = *((void *)this + 8);
        }
      }
      uint64_t Status = 3825173527;
      if (*(void *)(v20 + 216) && CCLogStream::shouldLog())
      {
        uint64_t v23 = (const char *)*((void *)a2 + 1);
        if (!v23) {
          uint64_t v23 = "<UNKNOWN>";
        }
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1650, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v23);
        return 3825173527;
      }
      return Status;
    }
    v14 += v18 + 1;
  }
  int v24 = *((_DWORD *)a2 + 4);
  if ((v24 & 2) != 0)
  {
    uint64_t v30 = *(void *)a3;
    if (!*(_WORD *)(a3 + 8) && v30 || *(_WORD *)(a3 + 8) && !v30)
    {
      uint64_t v31 = *((void *)this + 8);
      if (*(void *)(v31 + 216))
      {
        int v32 = CCLogStream::shouldLog();
        uint64_t v31 = *((void *)this + 8);
        if (v32)
        {
          CCLogStream::logAlert(*(CCLogStream **)(v31 + 216), "[dk] %s@%d: Set Command txPayload is invalid\n", "issueCommand", 1660);
          uint64_t v31 = *((void *)this + 8);
        }
      }
      uint64_t Status = 3825173514;
      if (*(void *)(v31 + 216) && CCLogStream::shouldLog())
      {
        uint64_t v33 = (const char *)*((void *)a2 + 1);
        if (!v33) {
          uint64_t v33 = "<UNKNOWN>";
        }
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1661, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v33);
      }
      return Status;
    }
    if (v14 > AppleBCMWLANCommander::getMaxCmdTxPayload(this))
    {
      uint64_t v37 = *((void *)this + 8);
      if (*(void *)(v37 + 216))
      {
        int v38 = CCLogStream::shouldLog();
        uint64_t v37 = *((void *)this + 8);
        if (v38)
        {
          v118 = *(CCLogStream **)(v37 + 216);
          uint64_t MaxCmdTxPayload = AppleBCMWLANCommander::getMaxCmdTxPayload(this);
          CCLogStream::logAlert(v118, "[dk] %s@%d: Not enough buffer space to Set command tx payload. avail(%llu), requested(%u)\n", "issueCommand", 1666, MaxCmdTxPayload, *(unsigned __int16 *)(a3 + 8));
          uint64_t v37 = *((void *)this + 8);
        }
      }
      uint64_t Status = 3825173516;
      if (*(void *)(v37 + 216) && CCLogStream::shouldLog())
      {
        int v39 = (const char *)*((void *)a2 + 1);
        if (!v39) {
          int v39 = "<UNKNOWN>";
        }
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1667, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v39);
      }
      return Status;
    }
    if (a4)
    {
      if (!*(_WORD *)(a4 + 8) || !*(void *)a4)
      {
        uint64_t v56 = *((void *)this + 8);
        if (*(void *)(v56 + 216))
        {
          int v57 = CCLogStream::shouldLog();
          uint64_t v56 = *((void *)this + 8);
          if (v57)
          {
            CCLogStream::logAlert(*(CCLogStream **)(v56 + 216), "[dk] %s@%d: Set Command rxPayload is invalid\n", "issueCommand", 1673);
            uint64_t v56 = *((void *)this + 8);
          }
        }
        uint64_t Status = 3825173518;
        if (*(void *)(v56 + 216) && CCLogStream::shouldLog())
        {
          int v58 = (const char *)*((void *)a2 + 1);
          if (!v58) {
            int v58 = "<UNKNOWN>";
          }
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1674, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v58);
        }
        return Status;
      }
      unint64_t v43 = *(unsigned __int16 *)(a4 + 8);
      if (AppleBCMWLANCommander::getMaxCmdRxPayload(this) < v43)
      {
        uint64_t v44 = *((void *)this + 8);
        if (*(void *)(v44 + 216))
        {
          int v45 = CCLogStream::shouldLog();
          uint64_t v44 = *((void *)this + 8);
          if (v45)
          {
            v124 = *(CCLogStream **)(v44 + 216);
            uint64_t MaxCmdRxPayload = AppleBCMWLANCommander::getMaxCmdRxPayload(this);
            CCLogStream::logAlert(v124, "[dk] %s@%d: Not enough buffer space to Set command rx payload. avail(%llu), requested(%u)\n", "issueCommand", 1679, MaxCmdRxPayload, *(unsigned __int16 *)(a4 + 8));
            uint64_t v44 = *((void *)this + 8);
          }
        }
        uint64_t Status = 3825173520;
        if (*(void *)(v44 + 216) && CCLogStream::shouldLog())
        {
          uint64_t v46 = (const char *)*((void *)a2 + 1);
          if (!v46) {
            uint64_t v46 = "<UNKNOWN>";
          }
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1680, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v46);
          return 3825173520;
        }
        return Status;
      }
      unsigned int v63 = a5[1];
      if (*a5 > v63 || v63 > *(unsigned __int16 *)(a4 + 8))
      {
        uint64_t v64 = *((void *)this + 8);
        if (*(void *)(v64 + 216))
        {
          int v65 = CCLogStream::shouldLog();
          uint64_t v64 = *((void *)this + 8);
          if (v65)
          {
            CCLogStream::logAlert(*(CCLogStream **)(v64 + 216), "[dk] %s@%d: Set Command rxPayload length is invalid(min: %d, length %d, max: %x\n", "issueCommand", 1685, *a5, *(unsigned __int16 *)(a4 + 8), a5[1]);
            uint64_t v64 = *((void *)this + 8);
          }
        }
        uint64_t Status = 3825173522;
        if (*(void *)(v64 + 216) && CCLogStream::shouldLog())
        {
          int v66 = (const char *)*((void *)a2 + 1);
          if (!v66) {
            int v66 = "<UNKNOWN>";
          }
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1686, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v66);
          return 3825173522;
        }
        return Status;
      }
    }
  }
  else if ((~v24 & 5) != 0)
  {
    if ((v24 & 1) == 0)
    {
      uint64_t v34 = *((void *)this + 8);
      if (*(void *)(v34 + 216))
      {
        int v35 = CCLogStream::shouldLog();
        uint64_t v34 = *((void *)this + 8);
        if (v35)
        {
          CCLogStream::logAlert(*(CCLogStream **)(v34 + 216), "[dk] %s@%d: Command type must be either Set or Get\n", "issueCommand", 1729);
          uint64_t v34 = *((void *)this + 8);
        }
      }
      uint64_t Status = 3825173524;
      if (*(void *)(v34 + 216) && CCLogStream::shouldLog())
      {
        int v36 = (const char *)*((void *)a2 + 1);
        if (!v36) {
          int v36 = "<UNKNOWN>";
        }
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1730, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v36);
        return 3825173524;
      }
      return Status;
    }
  }
  else
  {
    uint64_t v25 = *(void *)a3;
    if (*(_WORD *)(a3 + 8) || v25)
    {
      if (!*(_WORD *)(a3 + 8) || !v25)
      {
        uint64_t v47 = *((void *)this + 8);
        if (*(void *)(v47 + 216))
        {
          int v48 = CCLogStream::shouldLog();
          uint64_t v47 = *((void *)this + 8);
          if (v48)
          {
            CCLogStream::logAlert(*(CCLogStream **)(v47 + 216), "[dk] %s@%d: Get Command txPayload is invalid\n", "issueCommand", 1693);
            uint64_t v47 = *((void *)this + 8);
          }
        }
        uint64_t Status = 3825173515;
        if (*(void *)(v47 + 216) && CCLogStream::shouldLog())
        {
          unint64_t v49 = (const char *)*((void *)a2 + 1);
          if (!v49) {
            unint64_t v49 = "<UNKNOWN>";
          }
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1694, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v49);
        }
        return Status;
      }
      if (v14 > AppleBCMWLANCommander::getMaxCmdTxPayload(this))
      {
        uint64_t v40 = *((void *)this + 8);
        if (*(void *)(v40 + 216))
        {
          int v41 = CCLogStream::shouldLog();
          uint64_t v40 = *((void *)this + 8);
          if (v41)
          {
            v120 = *(CCLogStream **)(v40 + 216);
            uint64_t v121 = AppleBCMWLANCommander::getMaxCmdTxPayload(this);
            CCLogStream::logAlert(v120, "[dk] %s@%d: Not enough buffer space to Get command tx payload. avail(%llu), requested(%llu)\n", "issueCommand", 1699, v121, v14);
            uint64_t v40 = *((void *)this + 8);
          }
        }
        uint64_t Status = 3825173517;
        if (*(void *)(v40 + 216) && CCLogStream::shouldLog())
        {
          v42 = (const char *)*((void *)a2 + 1);
          if (!v42) {
            v42 = "<UNKNOWN>";
          }
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1700, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v42);
        }
        return Status;
      }
    }
    if (!a4)
    {
      uint64_t v53 = *((void *)this + 8);
      if (*(void *)(v53 + 216))
      {
        int v54 = CCLogStream::shouldLog();
        uint64_t v53 = *((void *)this + 8);
        if (v54)
        {
          CCLogStream::logAlert(*(CCLogStream **)(v53 + 216), "[dk] %s@%d: Get Command rxPayload cannot be NULL\n", "issueCommand", 1706);
          uint64_t v53 = *((void *)this + 8);
        }
      }
      uint64_t Status = 3825173519;
      if (*(void *)(v53 + 216) && CCLogStream::shouldLog())
      {
        unsigned __int16 v55 = (const char *)*((void *)a2 + 1);
        if (!v55) {
          unsigned __int16 v55 = "<UNKNOWN>";
        }
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1707, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v55);
      }
      return Status;
    }
    if (!*(_WORD *)(a4 + 8) || !*(void *)a4)
    {
      uint64_t v50 = *((void *)this + 8);
      if (*(void *)(v50 + 216))
      {
        int v51 = CCLogStream::shouldLog();
        uint64_t v50 = *((void *)this + 8);
        if (v51)
        {
          CCLogStream::logAlert(*(CCLogStream **)(v50 + 216), "[dk] %s@%d: Get Command rxPayload is invalid\n", "issueCommand", 1712);
          uint64_t v50 = *((void *)this + 8);
        }
      }
      uint64_t Status = 3825173519;
      if (*(void *)(v50 + 216) && CCLogStream::shouldLog())
      {
        uint64_t v52 = (const char *)*((void *)a2 + 1);
        if (!v52) {
          uint64_t v52 = "<UNKNOWN>";
        }
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1713, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v52);
      }
      return Status;
    }
    unint64_t v26 = *(unsigned __int16 *)(a4 + 8);
    if (AppleBCMWLANCommander::getMaxCmdRxPayload(this) < v26)
    {
      uint64_t v27 = *((void *)this + 8);
      if (*(void *)(v27 + 216))
      {
        int v28 = CCLogStream::shouldLog();
        uint64_t v27 = *((void *)this + 8);
        if (v28)
        {
          v122 = *(CCLogStream **)(v27 + 216);
          uint64_t v123 = AppleBCMWLANCommander::getMaxCmdRxPayload(this);
          CCLogStream::logAlert(v122, "[dk] %s@%d: Not enough buffer space to Get command rx payload. avail(%llu), requested(%u)\n", "issueCommand", 1718, v123, *(unsigned __int16 *)(a4 + 8));
          uint64_t v27 = *((void *)this + 8);
        }
      }
      uint64_t Status = 3825173521;
      if (*(void *)(v27 + 216) && CCLogStream::shouldLog())
      {
        uint64_t v29 = (const char *)*((void *)a2 + 1);
        if (!v29) {
          uint64_t v29 = "<UNKNOWN>";
        }
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1719, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v29);
        return 3825173521;
      }
      return Status;
    }
    unsigned int v59 = a5[1];
    if (*a5 > v59 || v59 > *(unsigned __int16 *)(a4 + 8))
    {
      uint64_t v60 = *((void *)this + 8);
      if (*(void *)(v60 + 216))
      {
        int v61 = CCLogStream::shouldLog();
        uint64_t v60 = *((void *)this + 8);
        if (v61)
        {
          CCLogStream::logAlert(*(CCLogStream **)(v60 + 216), "[dk] %s@%d: Get Command rxPayload length is invalid(min: %d, length %d, max: %x\n", "issueCommand", 1724, *a5, *(unsigned __int16 *)(a4 + 8), a5[1]);
          uint64_t v60 = *((void *)this + 8);
        }
      }
      uint64_t Status = 3825173523;
      if (*(void *)(v60 + 216) && CCLogStream::shouldLog())
      {
        v62 = (const char *)*((void *)a2 + 1);
        if (!v62) {
          v62 = "<UNKNOWN>";
        }
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1725, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v62);
        return 3825173523;
      }
      return Status;
    }
  }
  if ((*((_DWORD *)a2 + 1) & 0xFFFFFFFE) == 0x106 && !*((void *)a2 + 1) && !*(void *)a3 && !*(_WORD *)(a3 + 8))
  {
    uint64_t v67 = *((void *)this + 8);
    if (*(void *)(v67 + 216))
    {
      int v68 = CCLogStream::shouldLog();
      uint64_t v67 = *((void *)this + 8);
      if (v68)
      {
        CCLogStream::logAlert(*(CCLogStream **)(v67 + 216), "[dk] %s@%d: IOVal command iovar is NULL!\n", "issueCommand", 1736);
        uint64_t v67 = *((void *)this + 8);
      }
    }
    uint64_t Status = 3825173525;
    if (*(void *)(v67 + 216) && CCLogStream::shouldLog())
    {
      v69 = (const char *)*((void *)a2 + 1);
      if (!v69) {
        v69 = "<UNKNOWN>";
      }
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1737, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v69);
      return 3825173525;
    }
    return Status;
  }
  v70 = (CCLogStream ***)((char *)this + 64);
  if ((*(uint64_t (**)(void))(**(void **)(*((void *)this + 8) + 192) + 144))(*(void *)(*((void *)this + 8) + 192)))
  {
    int v71 = *((_DWORD *)a2 + 4);
    if ((v71 & 4) != 0)
    {
      if ((*(unsigned int (**)(CCLogStream *))(*(void *)(*v70)[24] + 136))((*v70)[24]))
      {
        v78 = *v70;
        if ((*v70)[27])
        {
          int v79 = CCLogStream::shouldLog();
          v78 = *v70;
          if (v79)
          {
            CCLogStream::logAlert(v78[27], "[dk] %s@%d: Cannot send a command synchronously while on the workQueue thread\n", "issueCommand", 1751);
            v78 = *v70;
          }
        }
        uint64_t Status = 3758097122;
        if (v78[27] && CCLogStream::shouldLog())
        {
          v80 = (const char *)*((void *)a2 + 1);
          if (!v80) {
            v80 = "<UNKNOWN>";
          }
          CCLogStream::logAlert((*v70)[27], "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1752, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v80);
          return 3758097122;
        }
        return Status;
      }
    }
    else
    {
      if ((v71 & 8) == 0)
      {
        v72 = *v70;
        if ((*v70)[27])
        {
          int v73 = CCLogStream::shouldLog();
          v72 = *v70;
          if (v73)
          {
            CCLogStream::logAlert(v72[27], "[dk] %s@%d: Command type must be either Sync or Async\n", "issueCommand", 1762);
            v72 = *v70;
          }
        }
        uint64_t Status = 3825173524;
        if (v72[27] && CCLogStream::shouldLog())
        {
          v74 = (const char *)*((void *)a2 + 1);
          if (!v74) {
            v74 = "<UNKNOWN>";
          }
          CCLogStream::logAlert((*v70)[27], "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1763, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v74);
          return 3825173524;
        }
        return Status;
      }
      if (!*(void *)a6 || !*(void *)(a6 + 8))
      {
        v83 = *v70;
        if ((*v70)[27])
        {
          int v84 = CCLogStream::shouldLog();
          v83 = *v70;
          if (v84)
          {
            CCLogStream::logAlert(v83[27], "[dk] %s@%d: Cannot send a command asynchronously without callback\n", "issueCommand", 1757);
            v83 = *v70;
          }
        }
        uint64_t Status = 3825173526;
        if (v83[27] && CCLogStream::shouldLog())
        {
          v85 = (const char *)*((void *)a2 + 1);
          if (!v85) {
            v85 = "<UNKNOWN>";
          }
          CCLogStream::logAlert((*v70)[27], "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1758, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v85);
          return 3825173526;
        }
        return Status;
      }
    }
    v81 = *v70;
    if (*((unsigned char *)*v70 + 309))
    {
      int v82 = AppleBCMWLANCommander::issueCommand(CommandID const&,CommandTxPayload const&,CommandRxPayload *,CommandRxExpected const&,CommandCompletion const&,CommandBusPreference)::cmdCount++;
      if (v82 >= 1002)
      {
        AppleBCMWLANCommander::issueCommand(CommandID const&,CommandTxPayload const&,CommandRxPayload *,CommandRxExpected const&,CommandCompletion const&,CommandBusPreference)::cmdCount = 0;
        v81[39] = 0;
        v81 = *v70;
      }
    }
    if (*((unsigned char *)v81 + 308) && *((unsigned char *)v81 + 232) && v81[39] != (CCLogStream *)-1)
    {
      mach_continuous_time();
      *(void *)&v132[16] = 0xAAAAAAAAAAAAAAAALL;
      absolutetime_to_nanoseconds();
      absolutetime_to_nanoseconds();
      mach_continuous_time();
      absolutetime_to_nanoseconds();
      memset(v132, 170, 24);
      absolutetime_to_nanoseconds();
      v91 = *v70;
      if ((*v70)[27])
      {
        int v92 = CCLogStream::shouldLog();
        v91 = *v70;
        if (v92)
        {
          CCLogStream::logAlert(v91[27], "[dk] %s@%d:Commander Check Queue Timer Stale. Value Set at %06llu.%06llu, Current Time is %06llu.%06llu, Continuous Time is %06llu.%06llu\n", "issueCommand", 1790, *(void *)&v132[16] / 0x3B9ACA00uLL, *(void *)&v132[16] % 0x3B9ACA00uLL / 0x3E8, *(void *)&v132[8] / 0x3B9ACA00uLL, *(void *)&v132[8] % 0x3B9ACA00uLL / 0x3E8, *(void *)v132 / 0x3B9ACA00uLL, *(void *)v132 % 0x3B9ACA00uLL / 0x3E8);
          v91 = *v70;
        }
      }
      uint64_t Status = 3825173533;
      CCFaultReporter::reportFault(v91[37], 6u, "/Library/Caches/com.apple.xbs/Sources/AppleBCMWLANV3_driverkit/AppleBCMWLANCommander.cpp", 0x6FFu, "issueCommand", 0, -469793763, 0);
    }
    else if (*((unsigned char *)v81 + 236))
    {
      return 3825173508;
    }
    else
    {
      v86 = (AppleBCMWLANCommand *)AppleBCMWLANCommander::dequeueCommand((uint64_t)this, 0);
      if (v86
        || (AppleBCMWLANCommander::serviceCompletedQueue((CCLogStream ***)this, 1),
            (v86 = (AppleBCMWLANCommand *)AppleBCMWLANCommander::dequeueCommand((uint64_t)this, 0)) != 0))
      {
        ++*((_DWORD *)*v70 + 36);
        uint64_t v87 = AppleBCMWLANCommand::prepare((uint64_t)v86, a2, *((_WORD *)*v70 + 117), a3, a4, a5, (long long *)a6, a7);
        v88 = *v70;
        if (v87)
        {
          uint64_t Status = v87;
          if (v88[27])
          {
            int v89 = CCLogStream::shouldLog();
            v88 = *v70;
            if (v89)
            {
              CCLogStream::logAlert(v88[27], "[dk] %s@%d: prepare cmd fail!!!\n", "issueCommand", 1848);
              v88 = *v70;
            }
          }
          if (v88[27] && CCLogStream::shouldLog())
          {
            v90 = (const char *)*((void *)a2 + 1);
            if (!v90) {
              v90 = "<UNKNOWN>";
            }
            CCLogStream::logAlert((*v70)[27], "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1849, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v90);
          }
        }
        else
        {
          ++*((_WORD *)v88 + 117);
          AppleBCMWLANCommander::enqueueCommand(this, 1u, v86);
          unsigned int Size = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 88));
          if (IOSimpleReporter::getValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647250516C00uLL) < (unint64_t)Size)
          {
            v94 = (*v70)[4];
            unsigned int v95 = AppleBCMWLANCommandQueue::getSize((*v70)[11]);
            IOSimpleReporter::setValue(v94, 0x436D647250516C00uLL, v95);
          }
          IOSimpleReporter::incrementValue((*v70)[4], 0x436D644973737500uLL, 1);
          v96 = *v70;
          v97 = (*v70)[1];
          if (v97)
          {
            AppleBCMWLANCommandMonitor::monitorCmdPrepared(v97, v86);
            v96 = *v70;
          }
          AppleBCMWLANCommand::logCmd((uint64_t)v86, (uint64_t)v96[27], (uint64_t)"\t", 1, 6, 4);
          v98 = **v70;
          if (v98 && CCLogStream::shouldLog(v98, 1uLL))
          {
            *(_DWORD *)&v132[16] = 0;
            Buffer = (AppleBCMWLANTxBuffer *)AppleBCMWLANCommand::getBuffer(v86);
            unint64_t v100 = AppleBCMWLANTxBuffer::getPayloadLength(Buffer) + 16;
            if (commandLoggingRestricted(v86)) {
              unint64_t v101 = 16;
            }
            else {
              unint64_t v101 = v100;
            }
            v102 = **v70;
            v103 = (AppleBCMWLANTxBuffer *)AppleBCMWLANCommand::getBuffer(v86);
            Payload = (unsigned __int8 *)AppleBCMWLANTxBuffer::getPayload(v103, 0);
            CCLogStream::logHeaderAndBufIf(v102, 1uLL, Payload, 0, v101, v100, &v132[16], 4uLL);
          }
          v105 = (AppleBCMWLANTxBuffer *)AppleBCMWLANCommand::getBuffer(v86);
          AppleBCMWLANTxBuffer::getPayload(v105, 0);
          v106 = (AppleBCMWLANTxBuffer *)AppleBCMWLANCommand::getBuffer(v86);
          AppleBCMWLANTxBuffer::getPayloadLength(v106);
          IO80211HexdumpIf();
          IO80211WorkSource::signalWorkAvailable(this);
          if ((a2[16] & 8) != 0) {
            return 0;
          }
          AppleBCMWLANCommand::setCommandGate((uint64_t)v86, (uint64_t)(*v70)[23]);
          AppleBCMWLANCommand::getTransactionID(v86);
          kdebug_trace();
          int v107 = *((_DWORD *)*v70 + 65);
          BOOL isCommandState = AppleBCMWLANCommand::isCommandState((uint64_t)v86, 2);
          if (v107)
          {
            if (!isCommandState)
            {
              *(void *)&v132[16] = 0xAAAAAAAAAAAAAAAALL;
              clock_interval_to_deadline();
              int v109 = (*(uint64_t (**)(CCLogStream *, AppleBCMWLANCommand *, void))(*(void *)(*v70)[23]
                                                                                             + 80))((*v70)[23], v86, *(void *)&v132[16]);
              mach_continuous_time();
              absolutetime_to_nanoseconds();
              if (v109 == -536870186) {
                AppleBCMWLANCommander::issueCommand((uint64_t *)this + 8);
              }
              if (!AppleBCMWLANCommand::isCommandState((uint64_t)v86, 2)) {
                AppleBCMWLANCommander::issueCommand((uint64_t *)this + 8);
              }
            }
          }
          else if (!isCommandState)
          {
            do
              (*(void (**)(CCLogStream *, AppleBCMWLANCommand *, void))(*(void *)(*v70)[23] + 80))((*v70)[23], v86, 0);
            while (!AppleBCMWLANCommand::isCommandState((uint64_t)v86, 2));
          }
          AppleBCMWLANCommand::getTransactionID(v86);
          kdebug_trace();
          uint64_t Status = AppleBCMWLANCommand::getStatus(v86);
        }
        AppleBCMWLANCommander::enqueueCommand(this, 0, v86);
        --*(_DWORD *)(*((void *)this + 8) + 144);
        uint64_t v115 = *((void *)this + 8);
        if (*(_DWORD *)(v115 + 156) && !*(_DWORD *)(v115 + 144)) {
          (*(void (**)(void, uint64_t))(**(void **)(v115 + 184) + 88))(*(void *)(v115 + 184), v115 + 144);
        }
      }
      else
      {
        *(_DWORD *)&v132[8] = 0;
        *(void *)&long long v110 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v110 + 1) = 0xAAAAAAAAAAAAAAAALL;
        long long v134 = v110;
        long long v135 = v110;
        *(_OWORD *)&v132[16] = v110;
        long long v133 = v110;
        int v111 = *((_DWORD *)a2 + 1);
        unsigned int v112 = v111 & 0xFFFFFFFE;
        cmdID2Name(v111);
        if (v112 == 262) {
          snprintf(&v132[16], 0x40uLL, "%s/%u: %s");
        }
        else {
          snprintf(&v132[16], 0x40uLL, "%s/%u");
        }
        AppleBCMWLANCommandQueue::lockMap((uint64_t)(*v70)[11], (void (*)(uint64_t, uint64_t, uint64_t))AppleBCMWLANCommander::countAsyncCommandsInQueue, 0, (uint64_t)&v132[8]);
        if ((*v70)[27] && CCLogStream::shouldLog())
        {
          v126 = (*v70)[27];
          int v127 = AppleBCMWLANCommandQueue::getSize((*v70)[10]);
          int v128 = AppleBCMWLANCommandQueue::getSize((*v70)[11]);
          int v129 = AppleBCMWLANCommandQueue::getSize((*v70)[12]);
          int v130 = AppleBCMWLANCommandQueue::getSize((*v70)[13]);
          int v131 = AppleBCMWLANCommandQueue::getSize((*v70)[14]);
          CCLogStream::logInfo(v126, "[dk] %s@%d: ACK, no free commands left!!!! Queues: [f%u p%u o%u a%u c%u] async pending=%u drop: %s\n", "issueCommand", 1831, v127, v128, v129, v130, v131, *(_DWORD *)&v132[8], &v132[16]);
        }
        AppleBCMWLANCommander::dumpState(this, 0, 0, 0);
        if ((AppleBCMWLANCore::getDebugFlags(*(AppleBCMWLANCore **)(*((void *)this + 8) + 176)) & 0x800) != 0)
        {
          unsigned int v113 = 6;
          unsigned int v114 = 1834;
        }
        else
        {
          unsigned int v113 = 5;
          unsigned int v114 = 1836;
        }
        CCFaultReporter::reportFault(*(CCFaultReporter **)(*((void *)this + 8) + 296), v113, "/Library/Caches/com.apple.xbs/Sources/AppleBCMWLANV3_driverkit/AppleBCMWLANCommander.cpp", v114, "issueCommand", 0, -469793764, 0);
        return 3758097086;
      }
    }
  }
  else
  {
    v75 = *v70;
    if ((*v70)[27])
    {
      int v76 = CCLogStream::shouldLog();
      v75 = *v70;
      if (v76)
      {
        CCLogStream::logAlert(v75[27], "[dk] %s@%d: Need to have the workQueue gate to send a command\n", "issueCommand", 1744);
        v75 = *v70;
      }
    }
    uint64_t Status = 3758097100;
    if (v75[27] && CCLogStream::shouldLog())
    {
      v77 = (const char *)*((void *)a2 + 1);
      if (!v77) {
        v77 = "<UNKNOWN>";
      }
      CCLogStream::logAlert((*v70)[27], "[dk] %s@%d: CommandID info: interface[%3u] type[0x%04x] ioctl[0x%04x/%4u] iovar['%s']\n", "issueCommand", 1745, *a2, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 1), v77);
    }
  }
  return Status;
}

uint64_t AppleBCMWLANCommander::runIOCtlGet(AppleBCMWLANCommander *a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v7 = 0;
  v6[0] = -1431655936;
  v6[1] = a2;
  unint64_t v8 = 0xAAAAAAAA00000005;
  return AppleBCMWLANCommander::issueCommand(a1, (unsigned __int8 *)v6, a3, a4, (unsigned __int16 *)(a4 + 10), *((void *)a1 + 8) + 264, a5);
}

uint64_t AppleBCMWLANCommander::runIOVarSet(AppleBCMWLANCommander *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (!a2) {
    return 3758097090;
  }
  v8[1] = a2;
  v8[0] = 0x107AAAAAA00;
  _DWORD v8[2] = 0xAAAAAAAA00000006;
  if (a4) {
    int v6 = (unsigned __int16 *)(a4 + 10);
  }
  else {
    int v6 = (unsigned __int16 *)&kNoRxExpected;
  }
  return AppleBCMWLANCommander::issueCommand(a1, (unsigned __int8 *)v8, a3, a4, v6, *((void *)a1 + 8) + 264, a5);
}

uint64_t AppleBCMWLANCommander::runIOVarGet(AppleBCMWLANCommander *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (!a2) {
    return 3758097090;
  }
  v6[1] = a2;
  v6[0] = 0x106AAAAAA00;
  _DWORD v6[2] = 0xAAAAAAAA00000005;
  return AppleBCMWLANCommander::issueCommand(a1, (unsigned __int8 *)v6, a3, a4, (unsigned __int16 *)(a4 + 10), *((void *)a1 + 8) + 264, a5);
}

uint64_t AppleBCMWLANCommander::sendIOCtlSet(AppleBCMWLANCommander *a1, int a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, int a6)
{
  uint64_t v8 = 0;
  v7[0] = -1431655936;
  v7[1] = a2;
  unint64_t v9 = 0xAAAAAAAA0000000ALL;
  return AppleBCMWLANCommander::issueCommand(a1, (unsigned __int8 *)v7, a3, 0, a4, a5, a6);
}

uint64_t AppleBCMWLANCommander::sendIOCtlGet(AppleBCMWLANCommander *a1, int a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, int a6)
{
  uint64_t v8 = 0;
  v7[0] = -1431655936;
  v7[1] = a2;
  unint64_t v9 = 0xAAAAAAAA00000009;
  return AppleBCMWLANCommander::issueCommand(a1, (unsigned __int8 *)v7, a3, 0, a4, a5, a6);
}

uint64_t AppleBCMWLANCommander::sendIOVarSet(AppleBCMWLANCommander *a1, uint64_t a2)
{
  if (a2) {
    return AppleBCMWLANCommander::issueCommand(a1);
  }
  else {
    return 3758097090;
  }
}

uint64_t AppleBCMWLANCommander::sendIOVarGet(AppleBCMWLANCommander *a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, int a6)
{
  if (!a2) {
    return 3758097090;
  }
  v7[1] = a2;
  v7[0] = 0x106AAAAAA00;
  _DWORD v7[2] = 0xAAAAAAAA00000009;
  return AppleBCMWLANCommander::issueCommand(a1, (unsigned __int8 *)v7, a3, 0, a4, a5, a6);
}

uint64_t AppleBCMWLANCommander::runVirtualIOCtlSet(AppleBCMWLANCommander *this, unsigned int a2, int a3, uint64_t a4, uint64_t a5, int a6)
{
  if (a2 < 0xC)
  {
    uint64_t v13 = 0;
    v12[0] = -1431655766;
    LOBYTE(v12[0]) = a2;
    v12[1] = a3;
    unint64_t v14 = 0xAAAAAAAA00000006;
    unint64_t v10 = (unsigned __int16 *)(a5 + 10);
    if (!a5) {
      unint64_t v10 = kNoRxExpected;
    }
    return AppleBCMWLANCommander::issueCommand(this, (unsigned __int8 *)v12, a4, a5, v10, *((void *)this + 8) + 264, a6);
  }
  else
  {
    uint64_t v9 = 3758097090;
    if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: ERROR: Virtual IOCtl %d on invalid interface %d !\n", "runVirtualIOCtlSet", 1024, a3, a2);
    }
  }
  return v9;
}

uint64_t AppleBCMWLANCommander::runVirtualIOCtlGet(AppleBCMWLANCommander *this, unsigned int a2, int a3, uint64_t a4, uint64_t a5, int a6)
{
  if (a2 < 0xC)
  {
    uint64_t v12 = 0;
    v11[0] = -1431655766;
    LOBYTE(v11[0]) = a2;
    v11[1] = a3;
    unint64_t v13 = 0xAAAAAAAA00000005;
    return AppleBCMWLANCommander::issueCommand(this, (unsigned __int8 *)v11, a4, a5, (unsigned __int16 *)(a5 + 10), *((void *)this + 8) + 264, a6);
  }
  else
  {
    uint64_t v9 = 3758097090;
    if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: ERROR: Virtual IOCtl %d on invalid interface %d !\n", "runVirtualIOCtlGet", 1048, a3, a2);
    }
  }
  return v9;
}

uint64_t AppleBCMWLANCommander::runVirtualIOVarSet(AppleBCMWLANCommander *this, unsigned int a2, const char *a3, uint64_t a4, uint64_t a5, int a6)
{
  if (a2 < 0xC)
  {
    if (a3)
    {
      unint64_t v13 = a3;
      v12[0] = -1431655766;
      LOBYTE(v12[0]) = a2;
      v12[1] = 263;
      unint64_t v14 = 0xAAAAAAAA00000006;
      unint64_t v10 = (unsigned __int16 *)(a5 + 10);
      if (!a5) {
        unint64_t v10 = kNoRxExpected;
      }
      return AppleBCMWLANCommander::issueCommand(this, (unsigned __int8 *)v12, a4, a5, v10, *((void *)this + 8) + 264, a6);
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    uint64_t v9 = 3758097090;
    if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: ERROR: Virtual IOVar \"%s\" on invalid interface %d !\n", "runVirtualIOVarSet", 1071, a3, a2);
    }
  }
  return v9;
}

uint64_t AppleBCMWLANCommander::runVirtualIOVarGet(AppleBCMWLANCommander *this, unsigned int a2, const char *a3, uint64_t a4, uint64_t a5, int a6)
{
  if (a2 < 0xC)
  {
    if (a3)
    {
      uint64_t v12 = a3;
      v11[0] = -1431655766;
      LOBYTE(v11[0]) = a2;
      v11[1] = 262;
      unint64_t v13 = 0xAAAAAAAA00000005;
      return AppleBCMWLANCommander::issueCommand(this, (unsigned __int8 *)v11, a4, a5, (unsigned __int16 *)(a5 + 10), *((void *)this + 8) + 264, a6);
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    uint64_t v9 = 3758097090;
    if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: ERROR: Virtual IOVar \"%s\" on invalid interface %d !\n", "runVirtualIOVarGet", 1100, a3, a2);
    }
  }
  return v9;
}

uint64_t AppleBCMWLANCommander::sendVirtualIOCtlSet(AppleBCMWLANCommander *this, unsigned int a2, int a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, int a7)
{
  if (a2 < 0xC)
  {
    uint64_t v13 = 0;
    v12[0] = -1431655766;
    LOBYTE(v12[0]) = a2;
    v12[1] = a3;
    unint64_t v14 = 0xAAAAAAAA0000000ALL;
    return AppleBCMWLANCommander::issueCommand(this, (unsigned __int8 *)v12, a4, 0, a5, a6, a7);
  }
  else
  {
    uint64_t v10 = 3758097090;
    if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: ERROR: Virtual IOCtl %d on invalid interface %d !\n", "sendVirtualIOCtlSet", 1128, a3, a2);
    }
  }
  return v10;
}

uint64_t AppleBCMWLANCommander::sendVirtualIOCtlGet(AppleBCMWLANCommander *this, unsigned int a2, int a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, int a7)
{
  if (a2 < 0xC)
  {
    uint64_t v13 = 0;
    v12[0] = -1431655766;
    LOBYTE(v12[0]) = a2;
    v12[1] = a3;
    unint64_t v14 = 0xAAAAAAAA00000009;
    return AppleBCMWLANCommander::issueCommand(this, (unsigned __int8 *)v12, a4, 0, a5, a6, a7);
  }
  else
  {
    uint64_t v10 = 3758097090;
    if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: ERROR: Virtual IOCtl %d on invalid interface %d !\n", "sendVirtualIOCtlGet", 1151, a3, a2);
    }
  }
  return v10;
}

uint64_t AppleBCMWLANCommander::sendVirtualIOVarSet(AppleBCMWLANCommander *this, unsigned int a2, const char *a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, int a7)
{
  if (a2 < 0xC)
  {
    if (a3)
    {
      uint64_t v13 = a3;
      v12[0] = -1431655766;
      LOBYTE(v12[0]) = a2;
      v12[1] = 263;
      unint64_t v14 = 0xAAAAAAAA0000000ALL;
      return AppleBCMWLANCommander::issueCommand(this, (unsigned __int8 *)v12, a4, 0, a5, a6, a7);
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    uint64_t v10 = 3758097090;
    if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: ERROR: Virtual IOVar \"%s\" on invalid interface %d !\n", "sendVirtualIOVarSet", 1173, a3, a2);
    }
  }
  return v10;
}

uint64_t AppleBCMWLANCommander::sendVirtualIOVarGet(AppleBCMWLANCommander *this, unsigned int a2, const char *a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, int a7)
{
  if (a2 < 0xC)
  {
    if (a3)
    {
      uint64_t v13 = a3;
      v12[0] = -1431655766;
      LOBYTE(v12[0]) = a2;
      v12[1] = 262;
      unint64_t v14 = 0xAAAAAAAA00000009;
      return AppleBCMWLANCommander::issueCommand(this, (unsigned __int8 *)v12, a4, 0, a5, a6, a7);
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    uint64_t v10 = 3758097090;
    if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: ERROR: Virtual IOVar \"%s\" on invalid interface %d !\n", "sendVirtualIOVarGet", 1201, a3, a2);
    }
  }
  return v10;
}

uint64_t AppleBCMWLANCommander::getMaxCmdRxPayload(AppleBCMWLANCommander *this)
{
  uint64_t v2 = *(void *)(*((void *)this + 8) + 208);
  if (v2 && (*(uint64_t (**)(uint64_t))(*(void *)v2 + 152))(v2)) {
    return (*(uint64_t (**)(void))(**(void **)(*((void *)this + 8) + 208) + 152))(*(void *)(*((void *)this + 8) + 208))
  }
         - 16;
  else {
    return 16;
  }
}

BOOL AppleBCMWLANCommander::isBusy(AppleBCMWLANCommander *this)
{
  int Size = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 88));
  int v3 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 96)) + Size;
  int v4 = v3 + AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 104));
  return v4
       + AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 112)) != 0;
}

uint64_t AppleBCMWLANCommander::isSleeping(AppleBCMWLANCommander *this)
{
  return *(unsigned __int8 *)(*((void *)this + 8) + 236);
}

uint64_t AppleBCMWLANCommander::isPaused(AppleBCMWLANCommander *this)
{
  return *(unsigned __int8 *)(*((void *)this + 8) + 237);
}

void (__cdecl *AppleBCMWLANCommander::stop(OSObject *this))(OSObjectInterface *__hidden this)
{
  uint64_t result = this[1].OSObjectInterface::__vftable[18].free;
  if (result) {
    return (void (__cdecl *)(OSObjectInterface *__hidden))CCFaultReporter::unregisterCallbacks((CCFaultReporter *)result, this);
  }
  return result;
}

uint64_t AppleBCMWLANCommander::freeResources(AppleBCMWLANCommander *this)
{
  uint64_t v2 = *((void *)this + 8);
  if (v2)
  {
    *(unsigned char *)(v2 + 236) = 1;
    uint64_t v3 = *((void *)this + 8);
    uint64_t v4 = *(void *)(v3 + 296);
    if (v4)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
      *(void *)(*((void *)this + 8) + 296) = 0;
      uint64_t v3 = *((void *)this + 8);
    }
    uint64_t v5 = *(void *)(v3 + 224);
    if (v5)
    {
      (*(void (**)(uint64_t))(*(void *)v5 + 72))(v5);
      (*(void (**)(void))(**(void **)(*((void *)this + 8) + 224) + 16))(*(void *)(*((void *)this + 8) + 224));
      *(void *)(*((void *)this + 8) + 224) = 0;
    }
    AppleBCMWLANCommander::purgeCommandQueue((uint64_t)this, 0, 0);
    for (uint64_t i = 80; i != 120; i += 8)
    {
      uint64_t v7 = *(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + i);
      if (v7)
      {
        AppleBCMWLANCommandQueue::lockFlush(v7);
        (*(void (**)(void))(**(void **)(*((void *)this + 8) + i) + 16))(*(void *)(*((void *)this + 8) + i));
        *(void *)(*((void *)this + 8) + i) = 0;
      }
    }
    uint64_t v8 = (void *)*((void *)this + 8);
    uint64_t v9 = v8[43];
    if (v9)
    {
      (*(void (**)(uint64_t))(*(void *)v9 + 72))(v9);
      uint64_t v8 = (void *)*((void *)this + 8);
      uint64_t v10 = v8[43];
      if (v10)
      {
        (*(void (**)(uint64_t))(*(void *)v10 + 16))(v10);
        *(void *)(*((void *)this + 8) + 344) = 0;
        uint64_t v8 = (void *)*((void *)this + 8);
      }
    }
    uint64_t v11 = v8[3];
    if (v11)
    {
      (*(void (**)(uint64_t))(*(void *)v11 + 16))(v11);
      *(void *)(*((void *)this + 8) + 24) = 0;
      uint64_t v8 = (void *)*((void *)this + 8);
    }
    uint64_t v12 = v8[1];
    if (v12)
    {
      (*(void (**)(uint64_t))(*(void *)v12 + 16))(v12);
      *(void *)(*((void *)this + 8) + 8) = 0;
      uint64_t v8 = (void *)*((void *)this + 8);
    }
    uint64_t v13 = v8[26];
    if (v13)
    {
      (*(void (**)(uint64_t))(*(void *)v13 + 16))(v13);
      *(void *)(*((void *)this + 8) + 208) = 0;
      uint64_t v8 = (void *)*((void *)this + 8);
    }
    uint64_t v14 = v8[27];
    if (v14)
    {
      (*(void (**)(uint64_t))(*(void *)v14 + 16))(v14);
      *(void *)(*((void *)this + 8) + 216) = 0;
      uint64_t v8 = (void *)*((void *)this + 8);
    }
    if (*v8)
    {
      (*(void (**)(void))(*(void *)*v8 + 16))(*v8);
      **((void **)this + 8) = 0;
      uint64_t v8 = (void *)*((void *)this + 8);
    }
    uint64_t v15 = v8[23];
    if (v15)
    {
      (*(void (**)(uint64_t))(*(void *)v15 + 16))(v15);
      *(void *)(*((void *)this + 8) + 184) = 0;
      uint64_t v8 = (void *)*((void *)this + 8);
    }
    uint64_t result = v8[17];
    if (result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
      *(void *)(*((void *)this + 8) + 136) = 0;
    }
  }
  else
  {
    uint64_t result = MEMORY[0xD8];
    if (MEMORY[0xD8])
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result) {
        return CCLogStream::logCrit(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d:Failed to allocate AppleBCMWLANCommander_IVars\n", "freeResources", 1324);
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANCommander::free(AppleBCMWLANCommander *this)
{
  AppleBCMWLANCommander::freeResources(this);
  uint64_t v2 = (void *)*((void *)this + 8);
  if (v2)
  {
    memset_s(v2, 0x180uLL, 0, 0x180uLL);
    uint64_t v3 = (void *)*((void *)this + 8);
    if (v3)
    {
      IOFree(v3, 0x180uLL);
      *((void *)this + 8) = 0;
    }
  }
  return IO80211WorkSource::free(this);
}

uint64_t non-virtual thunk to'AppleBCMWLANCommander::free(AppleBCMWLANCommander *this)
{
  return AppleBCMWLANCommander::free((AppleBCMWLANCommander *)((char *)this - 24));
}

uint64_t AppleBCMWLANCommander::pause(AppleBCMWLANCommander *this)
{
  uint64_t result = IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647250617500uLL, 1);
  *(unsigned char *)(*((void *)this + 8) + 237) = 1;
  return result;
}

uint64_t AppleBCMWLANCommander::unpause(AppleBCMWLANCommander *this)
{
  IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647255506100uLL, 1);
  *(unsigned char *)(*((void *)this + 8) + 237) = 0;
  uint64_t result = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 88));
  if (result) {
    uint64_t result = IO80211WorkSource::signalWorkAvailable(this);
  }
  *(void *)(*((void *)this + 8) + 40) = 0;
  return result;
}

uint64_t AppleBCMWLANCommander::getQueueSize(uint64_t a1, unsigned int a2)
{
  return AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*(void *)(a1 + 64) + 8 * a2 + 80));
}

uint64_t AppleBCMWLANCommander::quiesce(AppleBCMWLANCommander *this)
{
  uint64_t v2 = (IOSimpleReporter **)*((void *)this + 8);
  if (v2[27])
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = (IOSimpleReporter **)*((void *)this + 8);
    if (shouldLog)
    {
      uint64_t v11 = v2[27];
      int Size = AppleBCMWLANCommandQueue::getSize(v2[10]);
      int v13 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 104));
      int v14 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 96));
      int v15 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 112));
      int v16 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 88));
      int v17 = *(unsigned __int8 *)(*((void *)this + 8) + 236);
      BOOL isBusy = AppleBCMWLANCommander::isBusy(this);
      CCLogStream::logAlert(v11, "[dk] %s@%d:quiesce commander before fq %d aq %d obq %d compq %d pq %d, sleeping[%u] busy[%u] paused[%u]\n", "quiesce", 1408, Size, v13, v14, v15, v16, v17, isBusy, *(unsigned __int8 *)(*((void *)this + 8) + 237));
      uint64_t v2 = (IOSimpleReporter **)*((void *)this + 8);
    }
  }
  IOSimpleReporter::incrementValue(v2[4], 0x436D647251756900uLL, 1);
  *(unsigned char *)(*((void *)this + 8) + 236) = 1;
  *(unsigned char *)(*((void *)this + 8) + 356) = 0;
  if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog()) {
    CCLogStream::logAlertIf(*(CCLogStream **)(*((void *)this + 8) + 216), 4uLL, "[dk] %s@%d: waiting for %lu commands\n", "quiesce", 1418, *(unsigned int *)(*((void *)this + 8) + 144));
  }
  while (1)
  {
    uint64_t v4 = *((void *)this + 8);
    if (!*(_DWORD *)(v4 + 144) || *(unsigned char *)(v4 + 237)) {
      break;
    }
    clock_interval_to_deadline();
    ++*(_DWORD *)(*((void *)this + 8) + 156);
    int v5 = (*(uint64_t (**)(void, uint64_t, unint64_t))(**(void **)(*((void *)this + 8) + 184)
                                                                      + 80))(*(void *)(*((void *)this + 8) + 184), *((void *)this + 8) + 144, 0xAAAAAAAAAAAAAAAALL);
    --*(_DWORD *)(*((void *)this + 8) + 156);
    if (v5)
    {
      if (v5 == -536870186)
      {
        if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog()) {
          CCLogStream::logCrit(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: Time out waiting %d ms commands %u\n");
        }
      }
      else if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog())
      {
        CCLogStream::logCrit(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: Unexpected error (%d) from commandSleep\n");
      }
      break;
    }
  }
  *(void *)(*((void *)this + 8) + 312) = -1;
  int v6 = (AppleBCMWLANCommandQueue **)*((void *)this + 8);
  if (v6[27])
  {
    int v7 = CCLogStream::shouldLog();
    int v6 = (AppleBCMWLANCommandQueue **)*((void *)this + 8);
    if (v7)
    {
      unsigned int v19 = v6[27];
      int v20 = AppleBCMWLANCommandQueue::getSize(v6[10]);
      int v21 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 104));
      int v22 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 96));
      int v23 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 112));
      int v24 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 88));
      int v25 = *(unsigned __int8 *)(*((void *)this + 8) + 236);
      BOOL v26 = AppleBCMWLANCommander::isBusy(this);
      CCLogStream::logAlert(v19, "[dk] %s@%d:quiesce commander after fq %d aq %d obq %d compq %d pq %d, sleeping[%u] busy[%u] paused[%u]\n", "quiesce", 1441, v20, v21, v22, v23, v24, v25, v26, *(unsigned __int8 *)(*((void *)this + 8) + 237));
      int v6 = (AppleBCMWLANCommandQueue **)*((void *)this + 8);
    }
  }
  if (v6[27])
  {
    int v8 = CCLogStream::shouldLog();
    int v6 = (AppleBCMWLANCommandQueue **)*((void *)this + 8);
    if (v8)
    {
      CCLogStream::logAlert(v6[27], "[dk] %s@%d:Command path disabled.\n", "quiesce", 1442);
      int v6 = (AppleBCMWLANCommandQueue **)*((void *)this + 8);
    }
  }
  uint64_t result = AppleBCMWLANCommandQueue::getSize(v6[12]);
  if (result)
  {
    uint64_t v10 = *((void *)this + 8);
    uint64_t result = *(void *)(v10 + 216);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      uint64_t v10 = *((void *)this + 8);
      if (result)
      {
        uint64_t result = CCLogStream::logAlert(*(CCLogStream **)(v10 + 216), "[dk] %s@%d:active commands, do not reset command pool\n", "quiesce", 1444);
        uint64_t v10 = *((void *)this + 8);
      }
    }
    *(unsigned char *)(v10 + 356) = 1;
  }
  return result;
}

uint64_t AppleBCMWLANCommander::wakeup(AppleBCMWLANCommander *this)
{
  *(unsigned char *)(*((void *)this + 8) + 236) = 0;
  *(unsigned char *)(*((void *)this + 8) + 237) = 0;
  if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog()) {
    CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d:Enabled command path.\n", "wakeup", 1454);
  }
  return 1;
}

AppleBCMWLANCommand *AppleBCMWLANCommander::resetFreeCommanderPool(AppleBCMWLANCommander *this)
{
  int Size = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 80));
  uint64_t v3 = *((void *)this + 8);
  if (*(void *)(v3 + 216))
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v3 = *((void *)this + 8);
    if (shouldLog)
    {
      CCLogStream::logAlert(*(CCLogStream **)(v3 + 216), "[dk] %s@%d:kCmdQFree Count %d\n", "resetFreeCommanderPool", 1466, Size);
      uint64_t v3 = *((void *)this + 8);
    }
  }
  if (*(unsigned char *)(v3 + 356))
  {
    uint64_t result = *(AppleBCMWLANCommand **)(v3 + 216);
    if (result)
    {
      uint64_t result = (AppleBCMWLANCommand *)CCLogStream::shouldLog();
      uint64_t v3 = *((void *)this + 8);
      if (result)
      {
        uint64_t result = (AppleBCMWLANCommand *)CCLogStream::logAlert(*(CCLogStream **)(v3 + 216), "[dk] %s@%d:command pool reset not allowed\n", "resetFreeCommanderPool", 1469);
        uint64_t v3 = *((void *)this + 8);
      }
    }
    *(unsigned char *)(v3 + 356) = 0;
  }
  else
  {
    int v6 = (unsigned int *)AppleBCMWLANCommander::dequeueCommand((uint64_t)this, 0);
    if (v6)
    {
      int v7 = v6;
      int v8 = 0;
      do
      {
        unsigned int v9 = atomic_load(v7 + 2);
        if (v9 != 1 && *(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog())
        {
          uint64_t v10 = *(CCLogStream **)(*((void *)this + 8) + 216);
          unsigned int v11 = atomic_load(v7 + 2);
          CCLogStream::logAlert(v10, "[dk] %s@%d:Unexpected command retain count %d\n", "resetFreeCommanderPool", 1481, v11);
        }
        (*(void (**)(unsigned int *))(*(void *)v7 + 16))(v7);
        ++v8;
        int v7 = (unsigned int *)AppleBCMWLANCommander::dequeueCommand((uint64_t)this, 0);
      }
      while (v7);
    }
    else
    {
      int v8 = 0;
    }
    uint64_t v12 = *((void *)this + 8);
    if (v8 == Size)
    {
      int v8 = Size;
    }
    else if (*(void *)(v12 + 216))
    {
      int v13 = CCLogStream::shouldLog();
      uint64_t v12 = *((void *)this + 8);
      if (v13)
      {
        CCLogStream::logAlert(*(CCLogStream **)(v12 + 216), "[dk] %s@%d:Mismatch between Queue size %d and actual freed count %d\n", "resetFreeCommanderPool", 1488, Size, v8);
        uint64_t v12 = *((void *)this + 8);
      }
    }
    uint64_t result = *(AppleBCMWLANCommand **)(v12 + 344);
    if (result) {
      uint64_t result = (AppleBCMWLANCommand *)(*(uint64_t (**)(AppleBCMWLANCommand *))(*(void *)result + 80))(result);
    }
    for (; v8; --v8)
    {
      uint64_t v14 = *(void *)(*((void *)this + 8) + 208);
      uint64_t MaxCmdTxPayload = AppleBCMWLANCommander::getMaxCmdTxPayload(this);
      uint64_t result = (AppleBCMWLANCommand *)AppleBCMWLANCommand::newCmd(v14, MaxCmdTxPayload, *(void *)(*((void *)this + 8) + 344));
      if (!result) {
        break;
      }
      uint64_t result = (AppleBCMWLANCommand *)AppleBCMWLANCommander::enqueueCommand(this, 0, result);
    }
  }
  return result;
}

void *AppleBCMWLANCommander::dequeueCommand(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = AppleBCMWLANCommandQueue::lockDequeue(*(AppleBCMWLANCommandQueue **)(*(void *)(a1 + 64) + 8 * a2 + 80));
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*(void *)(a1 + 64) + 88));
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*(void *)(a1 + 64) + 96));
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*(void *)(a1 + 64) + 104));
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*(void *)(a1 + 64) + 112));
  kdebug_trace();
  return v3;
}

uint64_t AppleBCMWLANCommander::reset(AppleBCMWLANCommander *this)
{
  AppleBCMWLANCommander::dumpState(this, 0, 0, 0);
  *(unsigned char *)(*((void *)this + 8) + 236) = 1;
  *(unsigned char *)(*((void *)this + 8) + 232) = 0;
  int v21 = -469793790;
  AppleBCMWLANCommandQueue::lockMap(*(void *)(*((void *)this + 8) + 112), (void (*)(uint64_t, uint64_t, uint64_t))AppleBCMWLANCommander::setCommandStatus, (uint64_t)this, (uint64_t)&v21);
  if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog())
  {
    uint64_t v8 = *((void *)this + 8);
    unsigned int v9 = *(CCLogStream **)(v8 + 216);
    int Size = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(v8 + 80));
    int v11 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 104));
    int v12 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 96));
    int v13 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 112));
    int v14 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 88));
    CCLogStream::logAlert(v9, "[dk] %s@%d:reset commander before move fq %d aq %d obq %d compq %d pq %d\n", "reset", 1518, Size, v11, v12, v13, v14);
  }
  while (1)
  {
    uint64_t v2 = (AppleBCMWLANCommand *)AppleBCMWLANCommander::dequeueCommand((uint64_t)this, 3u);
    if (!v2)
    {
      uint64_t v2 = (AppleBCMWLANCommand *)AppleBCMWLANCommander::dequeueCommand((uint64_t)this, 2u);
      if (!v2) {
        break;
      }
    }
    AppleBCMWLANCommand::setStatus((uint64_t)v2, v21);
    AppleBCMWLANCommand::getTransactionID(v2);
    AppleBCMWLANCommand::getStatus(v2);
    AppleBCMWLANCommand::getIOCtl(v2);
    AppleBCMWLANCommand::getIOVar(v2);
    kdebug_trace();
    atomic_fetch_add_explicit((atomic_uint *volatile)(*((void *)this + 8) + 148), 0xFFFFFFFF, memory_order_relaxed);
    AppleBCMWLANCommander::enqueueCommand(this, 4u, v2);
  }
  if (AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 104))) {
    AppleBCMWLANCommander::reset();
  }
  if (AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 96))) {
    AppleBCMWLANCommander::reset();
  }
  uint64_t v3 = (AppleBCMWLANCommand *)AppleBCMWLANCommander::dequeueCommand((uint64_t)this, 1u);
  if (v3)
  {
    uint64_t v4 = v3;
    do
    {
      AppleBCMWLANCommand::setStatus((uint64_t)v4, v21);
      AppleBCMWLANCommander::enqueueCommand(this, 4u, v4);
      uint64_t v4 = (AppleBCMWLANCommand *)AppleBCMWLANCommander::dequeueCommand((uint64_t)this, 1u);
    }
    while (v4);
  }
  *(unsigned char *)(*((void *)this + 8) + 237) = 0;
  uint64_t v5 = *((void *)this + 8);
  if (*(void *)(v5 + 216))
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v5 = *((void *)this + 8);
    if (shouldLog)
    {
      int v15 = *(CCLogStream **)(v5 + 216);
      int v16 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(v5 + 80));
      int v17 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 104));
      int v18 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 96));
      int v19 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 112));
      int v20 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 88));
      CCLogStream::logAlert(v15, "[dk] %s@%d:reset commander after move fq %d aq %d obq %d compq %d pq %d\n", "reset", 1544, v16, v17, v18, v19, v20);
      uint64_t v5 = *((void *)this + 8);
    }
  }
  if ((*(unsigned int (**)(void))(**(void **)(v5 + 192) + 144))(*(void *)(v5 + 192))) {
    AppleBCMWLANCommander::serviceCompletedQueue((CCLogStream ***)this, 0);
  }
  else {
    IO80211WorkSource::signalWorkAvailable(this);
  }
  *(void *)(*((void *)this + 8) + 40) = 0;
  *(void *)(*((void *)this + 8) + 48) = 0;
  *(void *)(*((void *)this + 8) + 56) = 0;
  *(unsigned char *)(*((void *)this + 8) + 307) = 0;
  *(unsigned char *)(*((void *)this + 8) + 306) = 0;
  *(unsigned char *)(*((void *)this + 8) + 305) = 0;
  return 0;
}

uint64_t AppleBCMWLANCommander::setCommandStatus(AppleBCMWLANCommander *this, OSObject *a2, IOCommand *a3, void *a4)
{
  return 0;
}

uint64_t AppleBCMWLANCommander::serviceCompletedQueue(CCLogStream ***this, int a2)
{
  int Size = a2;
  if (a2 || (int Size = AppleBCMWLANCommandQueue::getSize(this[8][14])) != 0)
  {
    do
    {
      uint64_t v4 = (AppleBCMWLANCommand *)AppleBCMWLANCommander::dequeueCommand((uint64_t)this, 4u);
      if (!v4) {
        break;
      }
      uint64_t v5 = v4;
      int v6 = AppleBCMWLANCommander::processCompletedCommand(this, v4);
      if (AppleBCMWLANCommand::getStatus(v5) == -536870911) {
        AppleBCMWLANCommand::setStatus((uint64_t)v5, v6);
      }
      int v7 = this[8][1];
      if (v7) {
        AppleBCMWLANCommandMonitor::monitorCmdCompleted(v7, v5);
      }
      uint64_t QueuedTime_ns = AppleBCMWLANCommand::getQueuedTime_ns(v5, 2u);
      unint64_t v9 = (QueuedTime_ns - AppleBCMWLANCommand::getQueuedTime_ns(v5, 1u)) / 0x3E8uLL;
      if (v9 > IOSimpleReporter::getValue(this[8][4], 0x436D647250517400uLL)) {
        IOSimpleReporter::setValue(this[8][4], 0x436D647250517400uLL, v9);
      }
      uint64_t v10 = AppleBCMWLANCommand::getQueuedTime_ns(v5, 3u);
      unint64_t v11 = (v10 - AppleBCMWLANCommand::getQueuedTime_ns(v5, 2u)) / 0x3E8uLL;
      if (v11 > IOSimpleReporter::getValue(this[8][4], 0x436D64724F517400uLL)) {
        IOSimpleReporter::setValue(this[8][4], 0x436D64724F517400uLL, v11);
      }
      uint64_t v12 = AppleBCMWLANCommand::getQueuedTime_ns(v5, 4u);
      unint64_t v13 = (v12 - AppleBCMWLANCommand::getQueuedTime_ns(v5, 3u)) / 0x3E8uLL;
      if (v13 > IOSimpleReporter::getValue(this[8][4], 0x436D647241517400uLL)) {
        IOSimpleReporter::setValue(this[8][4], 0x436D647241517400uLL, v13);
      }
      int v14 = AppleBCMWLANCommand::complete((OSObject *)v5, this[8][17]);
      if (v14)
      {
        int v15 = v14;
        if (this[8][27])
        {
          if (CCLogStream::shouldLog()) {
            CCLogStream::logAlert(this[8][27], "[dk] %s@%d: Failed to CMD complete(), cret[0x%08x]\n", "serviceCompletedQueue", 2323, v15);
          }
        }
      }
      if ((AppleBCMWLANCommand::getCommandType(v5) & 8) != 0)
      {
        AppleBCMWLANCommander::enqueueCommand((AppleBCMWLANCommander *)this, 0, v5);
        --*((_DWORD *)this[8] + 36);
        int v16 = this[8];
        if (*((_DWORD *)v16 + 39))
        {
          if (!*((_DWORD *)v16 + 36)) {
            (*(void (**)(CCLogStream *, CCLogStream **))(*(void *)v16[23] + 88))(v16[23], v16 + 18);
          }
        }
      }
      --Size;
    }
    while (Size);
  }
  if (!AppleBCMWLANCommandQueue::getSize(this[8][11])
    && !AppleBCMWLANCommandQueue::getSize(this[8][13])
    && !AppleBCMWLANCommandQueue::getSize(this[8][12]))
  {
    AppleBCMWLANCore::syncChipTimer(this[8][22]);
  }
  return 0;
}

uint64_t AppleBCMWLANCommander::handleCrashCommanderAsyncCallBack(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 64) + 216);
  if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      uint64_t result = CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 64) + 216), "[dk] %s@%d:\n Async CB count %d\n", "handleCrashCommanderAsyncCallBack", 1580, AppleBCMWLANCommander::handleCrashCommanderAsyncCallBack(CommandID &,int,CommandRxPayload &,void *)::count);
    }
  }
  ++AppleBCMWLANCommander::handleCrashCommanderAsyncCallBack(CommandID &,int,CommandRxPayload &,void *)::count;
  return result;
}

void AppleBCMWLANCommander::crashCommander(AppleBCMWLANCommander *this)
{
  v5[0] = this;
  v5[1] = AppleBCMWLANCommander::handleCrashCommanderAsyncCallBack;
  v5[2] = 0;
  if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog()) {
    CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d:Crash commander unit test\n", "crashCommander", 1591);
  }
  while (1)
  {
    do
    {
      int v4 = 262148;
      v6[1] = 0;
      v6[0] = 0x1AAAAAA00;
      _DWORD v6[2] = 0xAAAAAAAA00000009;
      int v2 = AppleBCMWLANCommander::issueCommand(this, (unsigned __int8 *)v6, (uint64_t)&kNoTxPayload, 0, (unsigned __int16 *)&v4, (uint64_t)v5, 0);
    }
    while (!v2);
    int v3 = v2;
    if (*(void *)(*((void *)this + 8) + 216))
    {
      if (CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d: Failed GET IOCTL, cret[0x%08x]\n", "crashCommander", 1597, v3);
      }
    }
  }
}

uint64_t AppleBCMWLANCommander::crashIOVar(AppleBCMWLANCommander *this)
{
  uint64_t v2 = *((void *)this + 8);
  if (*(void *)(v2 + 216))
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = *((void *)this + 8);
    if (shouldLog)
    {
      CCLogStream::logAlert(*(CCLogStream **)(v2 + 216), "[dk] %s@%d:Crash IOVAR commander unit test\n", "crashIOVar", 1605);
      uint64_t v2 = *((void *)this + 8);
    }
  }
  int v9 = 1;
  *(unsigned char *)(v2 + 288) = 1;
  int v7 = &v9;
  uint64_t v8 = 0x400040004;
  v10[1] = 0;
  v10[0] = 0x1AAAAAA00;
  void v10[2] = 0xAAAAAAAA00000005;
  uint64_t result = AppleBCMWLANCommander::issueCommand(this, (unsigned __int8 *)v10, (uint64_t)&kNoTxPayload, (uint64_t)&v7, (unsigned __int16 *)&v8 + 1, *((void *)this + 8) + 264, 0);
  uint64_t v5 = *((void *)this + 8);
  if (result)
  {
    int v6 = result;
    uint64_t result = *(void *)(v5 + 216);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      uint64_t v5 = *((void *)this + 8);
      if (result)
      {
        uint64_t result = CCLogStream::logAlert(*(CCLogStream **)(v5 + 216), "[dk] %s@%d: Failed GET IOCTL, cret[0x%08x]\n", "crashIOVar", 1612, v6);
        uint64_t v5 = *((void *)this + 8);
      }
    }
  }
  *(unsigned char *)(v5 + 288) = 0;
  return result;
}

uint64_t AppleBCMWLANCommander::countAsyncCommandsInQueue(AppleBCMWLANCommander *this, OSObject *a2, IOCommand *a3, void *a4)
{
  if (!a3) {
    return 2;
  }
  unsigned int CommandType = AppleBCMWLANCommand::getCommandType((AppleBCMWLANCommand *)a2);
  uint64_t result = 0;
  *(_DWORD *)a3 += (CommandType >> 3) & 1;
  return result;
}

uint64_t commandLoggingRestricted(AppleBCMWLANCommand *a1)
{
  int IOCtl = AppleBCMWLANCommand::getIOCtl(a1);
  uint64_t result = 1;
  char v4 = IOCtl + 21;
  if ((IOCtl - 235) > 0x21) {
    goto LABEL_4;
  }
  if (((1 << v4) & 0x200000003) != 0) {
    return result;
  }
  if (((1 << v4) & 0x18000000) != 0)
  {
    IOVar = (const char *)AppleBCMWLANCommand::getIOVar(a1);
    if (strncmp(IOVar, "pmkid_info", 0xAuLL))
    {
      int v6 = (const char *)AppleBCMWLANCommand::getIOVar(a1);
      if (strncmp(v6, "wsec_key", 8uLL))
      {
        int v7 = (const char *)AppleBCMWLANCommand::getIOVar(a1);
        if (strncmp(v7, "wapiie", 6uLL))
        {
          uint64_t v8 = (const char *)AppleBCMWLANCommand::getIOVar(a1);
          if (strncmp(v8, "wpaie", 5uLL))
          {
            int v9 = (const char *)AppleBCMWLANCommand::getIOVar(a1);
            if (strncmp(v9, "wsec_info", 9uLL)) {
              return 0;
            }
            Buffer = (AppleBCMWLANTxBuffer *)AppleBCMWLANCommand::getBuffer(a1);
            if (!Buffer) {
              return 0;
            }
            unint64_t v11 = Buffer;
            uint64_t Payload = AppleBCMWLANTxBuffer::getPayload(Buffer, 0);
            if ((unint64_t)AppleBCMWLANTxBuffer::getPayloadLength(v11) < 0x25
              || !*(unsigned char *)(Payload + 29)
              || *(_WORD *)(Payload + 30) != 264)
            {
              return 0;
            }
          }
        }
      }
    }
    return 1;
  }
  else
  {
LABEL_4:
    if (((IOCtl - 133) > 0x32 || ((1 << (IOCtl + 123)) & 0x4000000000003) == 0)
      && (IOCtl - 44) >= 2)
    {
      return 0;
    }
  }
  return result;
}

uint64_t AppleBCMWLANCommander::parseResponseHeader(uint64_t a1, IO80211Buffer *this, uint64_t a3)
{
  if ((unint64_t)IO80211Buffer::getLength(this) <= 0xF)
  {
    uint64_t v8 = 3758097084;
    if (*(void *)(*(void *)(a1 + 64) + 216) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 64) + 216), "[dk] %s@%d: Buffer too small for header.\n");
    }
  }
  else
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
    if (IO80211Buffer::readBytes(this, 0, &v10))
    {
      unint64_t v7 = HIDWORD(v10);
      int v6 = v11;
      *(_WORD *)(a3 + 16) = WORD1(v11);
      *(_DWORD *)(a3 + 12) = v10;
      *(_DWORD *)a3 = v6;
      *(_DWORD *)(a3 + 4) = v7;
      if (IO80211Buffer::getLength(this) < v7)
      {
        uint64_t v8 = 3758097084;
        if (*(void *)(*(void *)(a1 + 64) + 216) && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 64) + 216), "[dk] %s@%d: Invalid CDC Header Length %d.\n");
        }
      }
      else
      {
        uint64_t v8 = 0;
        *(_DWORD *)(a3 + 8) = HIDWORD(v11);
      }
    }
    else
    {
      uint64_t v8 = 3758097084;
      if (*(void *)(*(void *)(a1 + 64) + 216) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 64) + 216), "[dk] %s@%d: Unable to copy header data, %d\n");
      }
    }
  }
  return v8;
}

uint64_t AppleBCMWLANCommander::dequeueByBuffer(AppleBCMWLANCommander *this, OSObject *a2, IOCommand *a3, void *a4)
{
  return 4 * (AppleBCMWLANCommand::getBuffer((AppleBCMWLANCommand *)a2) == (void)a3);
}

uint64_t AppleBCMWLANCommander::servicePendingQueue(AppleBCMWLANCommander *this)
{
  if (!AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 88))) {
    return 0;
  }
  uint64_t v2 = *((void *)this + 8);
  if (*(unsigned char *)(v2 + 237) || *(_DWORD *)(v2 + 148) >= *(_DWORD *)(v2 + 152)) {
    return 0;
  }
  int v3 = *(uint64_t (**)(void))(**(void **)(v2 + 208) + 352);
  return v3();
}

AppleBCMWLANCommand *AppleBCMWLANCommander::dequeueTxCommands(AppleBCMWLANCommander *a1, unsigned __int16 *a2)
{
  uint64_t v2 = *((void *)a1 + 8);
  unsigned int v3 = *(_DWORD *)(v2 + 148);
  LODWORD(v2) = *(_DWORD *)(v2 + 152);
  BOOL v4 = v2 >= v3;
  unsigned int v5 = v2 - v3;
  if (v5 == 0 || !v4) {
    return 0;
  }
  if (HIWORD(v5)) {
    return (AppleBCMWLANCommand *)3758097128;
  }
  if (v5 > *a2) {
    LOWORD(v5) = *a2;
  }
  *a2 = v5;
  if (*(unsigned char *)(*((void *)a1 + 8) + 305) || (unsigned __int16)v5 == 0) {
    return 0;
  }
  int v9 = 0;
  while (1)
  {
    uint64_t result = (AppleBCMWLANCommand *)AppleBCMWLANCommander::dequeueCommand((uint64_t)a1, 1u);
    if (!result) {
      break;
    }
    unint64_t v11 = result;
    uint64_t v12 = (AppleBCMWLANCommandQueue *)*((void *)a2 + 1);
    Buffer = (IOCommand *)AppleBCMWLANCommand::getBuffer(result);
    AppleBCMWLANCommandQueue::lockEnqueue(v12, Buffer);
    atomic_fetch_add_explicit((atomic_uint *volatile)(*((void *)a1 + 8) + 148), 1u, memory_order_relaxed);
    unint64_t QueuedDuration_ms = AppleBCMWLANCommand::getQueuedDuration_ms(v11);
    uint64_t v15 = *((void *)a1 + 8);
    if (QueuedDuration_ms > *(unsigned int *)(v15 + 172)) {
      AppleBCMWLANCommand::logCmd((uint64_t)v11, *(void *)(v15 + 216), (uint64_t)"Command Delayed", 1, 3, -1);
    }
    AppleBCMWLANCommand::getTransactionID(v11);
    kdebug_trace();
    AppleBCMWLANCommander::enqueueCommand(a1, 2u, v11);
    if (++v9 >= *a2) {
      return 0;
    }
  }
  return result;
}

uint64_t AppleBCMWLANCommander::reportCommittedTxCommands(AppleBCMWLANCommander *a1, uint64_t a2)
{
  for (uint64_t i = AppleBCMWLANCommandQueue::lockDequeue(*(AppleBCMWLANCommandQueue **)(a2 + 8));
        i;
        uint64_t i = AppleBCMWLANCommandQueue::lockDequeue(*(AppleBCMWLANCommandQueue **)(a2 + 8)))
  {
    v6[1] = i;
    v6[0] = 0xAAAAAA0100000002;
    AppleBCMWLANCommandQueue::lockMap(*(void *)(*((void *)a1 + 8) + 96), *(void (**)(uint64_t, uint64_t, uint64_t))(*((void *)a1 + 8) + 128), (uint64_t)a1, (uint64_t)v6);
  }
  AppleBCMWLANCommander::configureWatchdog(a1);
  return 0;
}

uint64_t AppleBCMWLANCommander::configureWatchdog(AppleBCMWLANCommander *this)
{
  uint64_t result = mach_continuous_time();
  *(void *)(*((void *)this + 8) + 320) = result;
  uint64_t v3 = *((void *)this + 8);
  if (!*(unsigned char *)(v3 + 232))
  {
    if (AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(v3 + 88))
      || AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 104))
      || (uint64_t result = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 96)),
          result))
    {
      (*(void (**)(void, uint64_t))(**(void **)(*((void *)this + 8) + 224) + 120))(*(void *)(*((void *)this + 8) + 224), 1500);
      uint64_t result = mach_continuous_time();
      *(void *)(*((void *)this + 8) + 312) = result;
      char v4 = 1;
    }
    else
    {
      char v4 = 0;
    }
    *(unsigned char *)(*((void *)this + 8) + 232) = v4;
  }
  return result;
}

uint64_t AppleBCMWLANCommander::reportCompletedTxCommands(AppleBCMWLANCommander *a1, uint64_t a2)
{
  uint64_t v4 = *((void *)a1 + 8);
  if (*(_DWORD *)(v4 + 148) >= *(_DWORD *)(v4 + 152))
  {
    BOOL v5 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(v4 + 88)) != 0;
    uint64_t v4 = *((void *)a1 + 8);
  }
  else
  {
    BOOL v5 = 0;
  }
  if (!*(unsigned char *)(v4 + 306))
  {
    int v6 = (AppleBCMWLANTxBuffer *)AppleBCMWLANCommandQueue::lockDequeue(*(AppleBCMWLANCommandQueue **)(a2 + 8));
    if (v6)
    {
      unint64_t v7 = v6;
      char v8 = 0;
      do
      {
        uint64_t v9 = AppleBCMWLANCommandQueue::lockMap(*(void *)(*((void *)a1 + 8) + 96), (void (*)(uint64_t, uint64_t, uint64_t))AppleBCMWLANCommander::dequeueByBuffer, (uint64_t)a1, (uint64_t)v7);
        if (v9)
        {
          unint64_t v10 = (AppleBCMWLANCommand *)v9;
          uint64_t Status = AppleBCMWLANTxBuffer::getStatus(v7);
          unint64_t QueuedDuration_ms = AppleBCMWLANCommand::getQueuedDuration_ms(v10);
          uint64_t v13 = *((void *)a1 + 8);
          if (QueuedDuration_ms > *(unsigned int *)(v13 + 168)) {
            AppleBCMWLANCommand::logCmd((uint64_t)v10, *(void *)(v13 + 216), (uint64_t)"Command Tx Delayed", 1, 3, -1);
          }
          if Status || (AppleBCMWLANCommand::hasOutofOrderResponse(v10))
          {
            AppleBCMWLANCommand::setStatus((uint64_t)v10, Status);
            AppleBCMWLANCommand::getTransactionID(v10);
            AppleBCMWLANCommand::getStatus(v10);
            AppleBCMWLANCommand::getIOCtl(v10);
            AppleBCMWLANCommand::getIOVar(v10);
            kdebug_trace();
            atomic_fetch_add_explicit((atomic_uint *volatile)(*((void *)a1 + 8) + 148), 0xFFFFFFFF, memory_order_relaxed);
            AppleBCMWLANCommander::enqueueCommand(a1, 4u, v10);
            *(void *)(*((void *)a1 + 8) + 48) = 0;
            char v8 = 1;
            if (Status != -536870163 && Status)
            {
              uint64_t v14 = *((void *)a1 + 8);
              if (*(void *)(v14 + 216))
              {
                int shouldLog = CCLogStream::shouldLog();
                uint64_t v14 = *((void *)a1 + 8);
                if (shouldLog)
                {
                  int v16 = *(CCLogStream **)(v14 + 216);
                  CmdName = (const char *)AppleBCMWLANCommand::getCmdName(v10);
                  int TransactionID = AppleBCMWLANCommand::getTransactionID(v10);
                  int v17 = (const char *)(*(uint64_t (**)(void, uint64_t))(**(void **)(*((void *)a1 + 8)
                                                                                               + 176)
                                                                                 + 112))(*(void *)(*((void *)a1 + 8) + 176), Status);
                  CCLogStream::logEmergency(v16, "[dk] %s@%d: Command Tx Failed for \"%s\" (transID %u), %s. Completing.\n", "reportCompletedTxCommands", 2137, CmdName, TransactionID, v17);
                  uint64_t v14 = *((void *)a1 + 8);
                }
              }
              char v8 = 1;
              AppleBCMWLANCommand::logCmd((uint64_t)v10, *(void *)(v14 + 216), (uint64_t)"\tCommand: ", 1, 4, -1);
            }
          }
          else
          {
            AppleBCMWLANCommander::enqueueCommand(a1, 3u, v10);
            *(_DWORD *)(*((void *)a1 + 8) + 160) = 0;
            *(void *)(*((void *)a1 + 8) + 48) = 0;
          }
        }
        else
        {
          if (*(void *)(*((void *)a1 + 8) + 216) && CCLogStream::shouldLog()) {
            CCLogStream::logEmergency(*(CCLogStream **)(*((void *)a1 + 8) + 216), "[dk] %s@%d: Command for completion %p not in Outbound queue, dropping.\n", "reportCompletedTxCommands", 2108, v7);
          }
          AppleBCMWLANCommander::dumpState(a1, 0, 0, 0);
          (*(void (**)(void))(**(void **)(*((void *)a1 + 8) + 208) + 352))();
        }
        unint64_t v7 = (AppleBCMWLANTxBuffer *)AppleBCMWLANCommandQueue::lockDequeue(*(AppleBCMWLANCommandQueue **)(a2 + 8));
      }
      while (v7);
      if (v8) {
        IO80211WorkSource::signalWorkAvailable(a1);
      }
    }
    if (v5)
    {
      uint64_t v18 = *((void *)a1 + 8);
      if (*(_DWORD *)(v18 + 148) < *(_DWORD *)(v18 + 152))
      {
        long long v22 = xmmword_100371410;
        AppleBCMWLANCommandQueue::lockMap(*(void *)(v18 + 88), *(void (**)(uint64_t, uint64_t, uint64_t))(v18 + 128), (uint64_t)a1, (uint64_t)&v22);
        AppleBCMWLANCommander::configureWatchdog(a1);
      }
    }
  }
  return 0;
}

uint64_t AppleBCMWLANCommander::enqueueRxCommands(AppleBCMWLANCommander *a1, AppleBCMWLANObjectQueue **a2)
{
  uint64_t v4 = *((void *)a1 + 8);
  if (*(_DWORD *)(v4 + 148) >= *(_DWORD *)(v4 + 152))
  {
    BOOL v5 = AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(v4 + 88)) != 0;
    uint64_t v4 = *((void *)a1 + 8);
  }
  else
  {
    BOOL v5 = 0;
  }
  if (!*(unsigned char *)(v4 + 307))
  {
    int v6 = (const OSMetaClassBase *)AppleBCMWLANObjectQueue::dequeue(*a2);
    unint64_t v7 = OSMetaClassBase::safeMetaCast(v6, gIO80211BufferMetaClass);
    if (v7)
    {
      char v8 = v7;
      do
      {
        long long v69 = 0uLL;
        int v70 = 0;
        int v9 = AppleBCMWLANCommander::parseResponseHeader((uint64_t)a1, (IO80211Buffer *)v8, (uint64_t)&v69);
        uint64_t v10 = *((void *)a1 + 8);
        if (v9)
        {
          if (*(void *)(v10 + 216) && CCLogStream::shouldLog())
          {
            int v16 = *(CCLogStream **)(*((void *)a1 + 8) + 216);
            int v17 = (unsigned __int16)v70;
            uint64_t BytesNoCopy = IO80211Buffer::getBytesNoCopy((IO80211Buffer *)v8);
            int v19 = (const void *)BytesNoCopy;
            uint64_t v21 = v69;
            uint64_t v20 = DWORD1(v69);
            uint64_t v23 = DWORD2(v69);
            uint64_t v22 = HIDWORD(v69);
            if (DWORD2(v69))
            {
              int v63 = v17;
              int v66 = (const void *)BytesNoCopy;
              int v24 = v16;
              uint64_t v25 = *(void *)(*((void *)a1 + 8) + 176);
              uint64_t v57 = DWORD1(v69);
              uint64_t v60 = HIDWORD(v69);
              uint64_t v54 = DWORD2(v69);
              uint64_t v26 = mapBcmErrorToIOReturn(DWORD2(v69));
              uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v25 + 112);
              uint64_t v28 = v25;
              int v16 = v24;
              int v17 = v63;
              uint64_t v29 = (const char *)v27(v28, v26);
              uint64_t v23 = v54;
              uint64_t v20 = v57;
              uint64_t v22 = v60;
              int v19 = v66;
            }
            else
            {
              uint64_t v29 = "?";
            }
            CCLogStream::logEmergency(v16, "[dk] %s@%d: Command response unparsable:  %5u) %p [ cmd 0x%08lX len 0x%08lX flags 0x08%lX status 0x%08lX \"%s\"]\n", "enqueueRxCommands", 2172, v17, v19, v22, v20, v21, v23, v29);
          }
        }
        else
        {
          uint64_t v11 = AppleBCMWLANCommandQueue::lockMap(*(void *)(v10 + 104), *(void (**)(uint64_t, uint64_t, uint64_t))(v10 + 64), (uint64_t)a1, (uint64_t)&v69);
          if (v11)
          {
            uint64_t v12 = (AppleBCMWLANCommand *)v11;
            AppleBCMWLANCommand::setResponse(v11, (uint64_t)v8);
            unint64_t QueuedDuration_ms = AppleBCMWLANCommand::getQueuedDuration_ms(v12);
            uint64_t v14 = *((void *)a1 + 8);
            if (QueuedDuration_ms > *(unsigned int *)(v14 + 164)) {
              AppleBCMWLANCommand::logCmd((uint64_t)v12, *(void *)(v14 + 216), (uint64_t)"Command Response Delayed", 1, 3, -1);
            }
            AppleBCMWLANCommand::getTransactionID(v12);
            AppleBCMWLANCommand::getStatus(v12);
            AppleBCMWLANCommand::getIOCtl(v12);
            AppleBCMWLANCommand::getIOVar(v12);
            kdebug_trace();
            atomic_fetch_add_explicit((atomic_uint *volatile)(*((void *)a1 + 8) + 148), 0xFFFFFFFF, memory_order_relaxed);
            AppleBCMWLANCommander::enqueueCommand(a1, 4u, v12);
            goto LABEL_15;
          }
          uint64_t v30 = AppleBCMWLANCommandQueue::lockMap(*(void *)(*((void *)a1 + 8) + 96), *(void (**)(uint64_t, uint64_t, uint64_t))(*((void *)a1 + 8) + 72), (uint64_t)a1, (uint64_t)&v69);
          uint64_t v31 = *((void *)a1 + 8);
          if (v30)
          {
            uint64_t v32 = v30;
            if (*(void *)(v31 + 216) && CCLogStream::shouldLog()) {
              CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 8) + 216), "[dk] %s@%d:Command response is for Outbound Queue\n", "enqueueRxCommands", 2184);
            }
            AppleBCMWLANCommand::setOutofOrderResponse(v32);
            AppleBCMWLANCommand::setResponse(v32, (uint64_t)v8);
            goto LABEL_15;
          }
          uint64_t v33 = (AppleBCMWLANCommand *)AppleBCMWLANCommandQueue::lockMap(*(void *)(v31 + 80), *(void (**)(uint64_t, uint64_t, uint64_t))(v31 + 72), (uint64_t)a1, (uint64_t)&v69);
          if (v33 && AppleBCMWLANCommand::getStatus(v33) == -469793790)
          {
            if (*(void *)(*((void *)a1 + 8) + 216) && CCLogStream::shouldLog())
            {
              int v64 = (unsigned __int16)v70;
              uint64_t v67 = *(CCLogStream **)(*((void *)a1 + 8) + 216);
              uint64_t v34 = IO80211Buffer::getBytesNoCopy((IO80211Buffer *)v8);
              uint64_t v35 = v69;
              uint64_t v58 = DWORD1(v69);
              int v61 = (const void *)v34;
              uint64_t v36 = DWORD2(v69);
              uint64_t v55 = HIDWORD(v69);
              uint64_t v37 = *(void *)(*((void *)a1 + 8) + 176);
              uint64_t v38 = mapBcmErrorToIOReturn(DWORD2(v69));
              int v39 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v37 + 112))(v37, v38);
              CCLogStream::logAlert(v67, "[dk] %s@%d:Command response received for flushed command:  %5u) %p [ cmd 0x%08lX len 0x%08lX flags 0x08%lX status 0x%08lX \"%s\"]\n", "enqueueRxCommands", 2200, v64, v61, v55, v58, v35, v36, v39);
            }
          }
          else
          {
            if (*(void *)(*((void *)a1 + 8) + 216) && CCLogStream::shouldLog())
            {
              int v65 = (unsigned __int16)v70;
              int v68 = *(CCLogStream **)(*((void *)a1 + 8) + 216);
              uint64_t v44 = IO80211Buffer::getBytesNoCopy((IO80211Buffer *)v8);
              uint64_t v45 = v69;
              uint64_t v59 = DWORD1(v69);
              v62 = (const void *)v44;
              uint64_t v46 = DWORD2(v69);
              uint64_t v56 = HIDWORD(v69);
              uint64_t v47 = *(void *)(*((void *)a1 + 8) + 176);
              uint64_t v48 = mapBcmErrorToIOReturn(DWORD2(v69));
              unint64_t v49 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v47 + 112))(v47, v48);
              CCLogStream::logEmergency(v68, "[dk] %s@%d: Command response unexpected:  %5u) %p [ cmd 0x%08lX len 0x%08lX flags 0x08%lX status 0x%08lX \"%s\"]\n", "enqueueRxCommands", 2204, v65, v62, v56, v59, v45, v46, v49);
            }
            AppleBCMWLANCommander::dumpState(a1, 0, 0, 0);
            uint64_t v40 = CCFaultReporter::reportFault(*(CCFaultReporter **)(*((void *)a1 + 8) + 296), 5u, "/Library/Caches/com.apple.xbs/Sources/AppleBCMWLANV3_driverkit/AppleBCMWLANCommander.cpp", 0x89Eu, "enqueueRxCommands", 0, -469793768, 0);
            uint64_t v41 = *((void *)a1 + 8);
            if (v40)
            {
              uint64_t v42 = v40;
              if (*(void *)(v41 + 216))
              {
                int shouldLog = CCLogStream::shouldLog();
                uint64_t v41 = *((void *)a1 + 8);
                if (shouldLog)
                {
                  uint64_t v50 = *(CCLogStream **)(v41 + 216);
                  int v51 = (const char *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v41 + 176) + 112))(*(void *)(v41 + 176), v42);
                  CCLogStream::logAlert(v50, "[dk] %s@%d: Failed to trigger WD, \"%s\"\n", "enqueueRxCommands", 2209, v51);
                  uint64_t v41 = *((void *)a1 + 8);
                }
              }
            }
            IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(v41 + 32), 0x436D644973507200uLL, 1);
            (*(void (**)(void))(**(void **)(*((void *)a1 + 8) + 208) + 352))();
          }
        }
        IO80211Buffer::returnBuffer((IO80211Buffer *)v8);
LABEL_15:
        uint64_t v15 = (const OSMetaClassBase *)AppleBCMWLANObjectQueue::dequeue(*a2);
        char v8 = OSMetaClassBase::safeMetaCast(v15, gIO80211BufferMetaClass);
      }
      while (v8);
    }
    if (AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)a1 + 8) + 112))) {
      IO80211WorkSource::signalWorkAvailable(a1);
    }
    if (v5)
    {
      uint64_t v52 = *((void *)a1 + 8);
      if (*(_DWORD *)(v52 + 148) < *(_DWORD *)(v52 + 152))
      {
        long long v69 = xmmword_100371410;
        AppleBCMWLANCommandQueue::lockMap(*(void *)(v52 + 88), *(void (**)(uint64_t, uint64_t, uint64_t))(v52 + 128), (uint64_t)a1, (uint64_t)&v69);
        AppleBCMWLANCommander::configureWatchdog(a1);
      }
    }
  }
  return 0;
}

uint64_t AppleBCMWLANCommander::checkForWork(AppleBCMWLANCommander *this)
{
  if (IO80211WorkSource::isEnabled(this)
    && AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 88)))
  {
    AppleBCMWLANCommander::servicePendingQueue(this);
  }
  if (IO80211WorkSource::isEnabled(this))
  {
    if (AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 112)))
    {
      AppleBCMWLANCommander::serviceCompletedQueue((CCLogStream ***)this, 0);
      if (AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 112)))
      {
        if (!*(unsigned char *)(*((void *)this + 8) + 237)) {
          IO80211WorkSource::signalWorkAvailable(this);
        }
      }
    }
  }
  return 0;
}

uint64_t non-virtual thunk to'AppleBCMWLANCommander::checkForWork(AppleBCMWLANCommander *this)
{
  return 0;
}

uint64_t AppleBCMWLANCommander::processCompletedCommand(CCLogStream ***this, AppleBCMWLANCommand *a2)
{
  Response = (IO80211Buffer *)AppleBCMWLANCommand::getResponse(a2);
  if (!Response) {
    return 3825173505;
  }
  BOOL v5 = Response;
  IO80211Buffer::getBytesNoCopy(Response);
  IO80211Buffer::getLength(v5);
  IO80211HexdumpIf();
  uint64_t v231 = 0;
  *(void *)v232 = 0;
  int v233 = 0;
  uint64_t v6 = AppleBCMWLANCommander::parseResponseHeader((uint64_t)this, v5, (uint64_t)&v231);
  unsigned int v7 = v232[0];
  if (!v232[0] && this[8][1])
  {
    char CommandType = AppleBCMWLANCommand::getCommandType(a2);
    uint64_t QueuedTime_ns = AppleBCMWLANCommand::getQueuedTime_ns(a2, 2u);
    unint64_t v11 = (QueuedTime_ns - AppleBCMWLANCommand::getQueuedTime_ns(a2, 1u)) / 0x3E8uLL;
    uint64_t v12 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 3u);
    unint64_t v13 = (v12 - AppleBCMWLANCommand::getQueuedTime_ns(a2, 2u)) / 0x3E8uLL;
    uint64_t v14 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 4u);
    unint64_t v15 = (v14 - AppleBCMWLANCommand::getQueuedTime_ns(a2, 3u)) / 0x3E8uLL;
    if ((CommandType & 4) != 0)
    {
      AppleBCMWLANCommander::sendCommandResponseEventToCoreAnalytics((AppleBCMWLANCommander *)this, 1, v11, v13, v15);
      uint64_t v49 = (uint64_t)this[8][1];
      uint64_t v50 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 2u);
      uint64_t v51 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 1u);
      if (AppleBCMWLANCommandMonitor::reportQueueWaitTimeus(v49, 0, (v50 - v51) / 0x3E8uLL)
        || (uint64_t v52 = (uint64_t)this[8][1],
            uint64_t v53 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 3u),
            uint64_t v54 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 2u),
            AppleBCMWLANCommandMonitor::reportQueueWaitTimeus(v52, 1, (v53 - v54) / 0x3E8uLL))
        || (uint64_t v55 = (uint64_t)this[8][1],
            uint64_t v56 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 4u),
            uint64_t v57 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 3u),
            AppleBCMWLANCommandMonitor::reportQueueWaitTimeus(v55, 2, (v56 - v57) / 0x3E8uLL)))
      {
        if (this[8][27] && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(this[8][27], "[dk] %s@%d:Unable to update queue wait time\n", "processCompletedCommand", 2425);
        }
      }
      if (*((unsigned char *)this[8] + 357))
      {
        uint64_t v58 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 2u);
        uint64_t v59 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 1u);
        uint64_t v27 = this[8];
        if (*((_DWORD *)v27 + 90) <= ((v58 - v59) / 0x3E8uLL)
          || (uint64_t v60 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 3u),
              uint64_t v61 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 2u),
              uint64_t v27 = this[8],
              *((_DWORD *)v27 + 91) <= ((v60 - v61) / 0x3E8uLL))
          || (uint64_t v62 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 4u),
              uint64_t v63 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 3u),
              uint64_t v27 = this[8],
              *((_DWORD *)v27 + 92) <= ((v62 - v63) / 0x3E8uLL)))
        {
          if (v27[27])
          {
            int shouldLog = CCLogStream::shouldLog();
            uint64_t v27 = this[8];
            if (shouldLog)
            {
              v199 = v27[27];
              CmdName = (const char *)AppleBCMWLANCommand::getCmdName(a2);
              uint64_t v201 = v232[1];
              char v202 = AppleBCMWLANCommand::getCommandType(a2);
              v203 = "async";
              if ((v202 & 8) == 0) {
                v203 = " sync";
              }
              CCLogStream::logAlert(v199, "[dk] %s@%d:AppleBCMWLANCommander for command %s[0x%08lX] send as %s with status %s[%u]\n", "processCompletedCommand", 2431, CmdName, v201, v203, "?", 0);
              uint64_t v27 = this[8];
            }
          }
          if (!v27[27])
          {
            unsigned int v34 = 2435;
            goto LABEL_58;
          }
          char v65 = CCLogStream::shouldLog();
          uint64_t v27 = this[8];
          unsigned int v34 = 2435;
          if (v65)
          {
            int v35 = 2434;
            goto LABEL_55;
          }
LABEL_58:
          v72 = v27[37];
          int v73 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
          uint64_t v74 = v232[1];
          char v75 = AppleBCMWLANCommand::getCommandType(a2);
          int v76 = "async";
          if ((v75 & 8) == 0) {
            int v76 = " sync";
          }
          CCFaultReporter::reportFault(v72, 5u, "/Library/Caches/com.apple.xbs/Sources/AppleBCMWLANV3_driverkit/AppleBCMWLANCommander.cpp", v34, "processCompletedCommand", 0, -469793762, "command %s[0x%08lX] send as %s", v73, v74, v76);
        }
      }
    }
    else
    {
      AppleBCMWLANCommander::sendCommandResponseEventToCoreAnalytics((AppleBCMWLANCommander *)this, 0, v11, v13, v15);
      uint64_t v16 = (uint64_t)this[8][1];
      uint64_t v17 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 2u);
      uint64_t v18 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 1u);
      if (AppleBCMWLANCommandMonitor::reportQueueWaitTimeus(v16, 3, (v17 - v18) / 0x3E8uLL)
        || (uint64_t v19 = (uint64_t)this[8][1],
            uint64_t v20 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 3u),
            uint64_t v21 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 2u),
            AppleBCMWLANCommandMonitor::reportQueueWaitTimeus(v19, 1, (v20 - v21) / 0x3E8uLL))
        || (uint64_t v22 = (uint64_t)this[8][1],
            uint64_t v23 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 4u),
            uint64_t v24 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 3u),
            AppleBCMWLANCommandMonitor::reportQueueWaitTimeus(v22, 2, (v23 - v24) / 0x3E8uLL)))
      {
        if (this[8][27] && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(this[8][27], "[dk] %s@%d:Unable to update queue wait time\n", "processCompletedCommand", 2448);
        }
      }
      if (*((unsigned char *)this[8] + 358))
      {
        uint64_t v25 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 2u);
        uint64_t v26 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 1u);
        uint64_t v27 = this[8];
        if (*((_DWORD *)v27 + 93) <= ((v25 - v26) / 0x3E8uLL)
          || (uint64_t v28 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 3u),
              uint64_t v29 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 2u),
              uint64_t v27 = this[8],
              *((_DWORD *)v27 + 91) <= ((v28 - v29) / 0x3E8uLL))
          || (uint64_t v30 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 4u),
              uint64_t v31 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 3u),
              uint64_t v27 = this[8],
              *((_DWORD *)v27 + 92) <= ((v30 - v31) / 0x3E8uLL)))
        {
          if (v27[27])
          {
            int v32 = CCLogStream::shouldLog();
            uint64_t v27 = this[8];
            if (v32)
            {
              v194 = v27[27];
              v195 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
              uint64_t v196 = v232[1];
              char v197 = AppleBCMWLANCommand::getCommandType(a2);
              v198 = "async";
              if ((v197 & 8) == 0) {
                v198 = " sync";
              }
              CCLogStream::logAlert(v194, "[dk] %s@%d:AppleBCMWLANCommander for command %s[0x%08lX] send as %s with status %s[%u]\n", "processCompletedCommand", 2454, v195, v196, v198, "?", 0);
              uint64_t v27 = this[8];
            }
          }
          if (!v27[27])
          {
            unsigned int v34 = 2458;
            goto LABEL_58;
          }
          int v33 = CCLogStream::shouldLog();
          uint64_t v27 = this[8];
          unsigned int v34 = 2458;
          if (v33)
          {
            int v35 = 2457;
LABEL_55:
            v227 = v27[27];
            int v228 = v35;
            uint64_t v66 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 2u);
            unint64_t v67 = (v66 - AppleBCMWLANCommand::getQueuedTime_ns(a2, 1u)) / 0x3E8uLL;
            uint64_t v68 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 3u);
            unint64_t v69 = (v68 - AppleBCMWLANCommand::getQueuedTime_ns(a2, 2u)) / 0x3E8uLL;
            uint64_t v70 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 4u);
            uint64_t v71 = AppleBCMWLANCommand::getQueuedTime_ns(a2, 3u);
            CCLogStream::logAlert(v227, "[dk] %s@%d:AppleBCMWLANCommander time in pendingQ %u us time in outboundQ %u us time in activeQ %u us\n", "processCompletedCommand", v228, v67, v69, (v70 - v71) / 0x3E8uLL);
            uint64_t v27 = this[8];
            goto LABEL_58;
          }
          goto LABEL_58;
        }
      }
    }
  }
  char v8 = this[8];
  if (v6)
  {
    if (!*((unsigned char *)v8 + 304))
    {
LABEL_26:
      if (v8[27] && CCLogStream::shouldLog())
      {
        v177 = this[8][27];
        int v178 = (unsigned __int16)v233;
        uint64_t BytesNoCopy = (const void *)IO80211Buffer::getBytesNoCopy(v5);
        uint64_t v180 = v232[1];
        uint64_t v181 = HIDWORD(v231);
        if ((v231 & 2) != 0) {
          v182 = "set";
        }
        else {
          v182 = "get";
        }
        if (v7)
        {
          int v230 = v178;
          v183 = v177;
          v184 = this[8][22];
          unsigned int v185 = v7;
          v186 = BytesNoCopy;
          uint64_t v187 = mapBcmErrorToIOReturn(v185);
          v188 = *(uint64_t (**)(CCLogStream *, uint64_t))(*(void *)v184 + 112);
          v189 = v184;
          v177 = v183;
          int v178 = v230;
          v190 = (const char *)v188(v189, v187);
          uint64_t BytesNoCopy = v186;
        }
        else
        {
          v190 = "?";
        }
        CCLogStream::logEmergency(v177, "[dk] %s@%d: Command response unparsable:  %5u) %p [ cmd 0x%08lX len %6lu flags %s status \"%s\"]\n", "processCompletedCommand", 2469, v178, BytesNoCopy, v180, v181, v182, v190);
      }
      keys[0] = OSString::withCString("CommandResponse.bin");
      uint64_t v36 = (const void *)IO80211Buffer::getBytesNoCopy(v5);
      unsigned int Length = IO80211Buffer::getLength(v5);
      values[0] = OSData::withBytes(v36, Length);
      uint64_t v38 = this[8][37];
      int v39 = OSDictionary::withObjects((const OSObject **)values, (const OSObject **)keys, 1u, 0);
      uint64_t v40 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
      CCFaultReporter::reportFault(v38, 4u, "/Library/Caches/com.apple.xbs/Sources/AppleBCMWLANV3_driverkit/AppleBCMWLANCommander.cpp", 0x9B1u, "processCompletedCommand", v39, -469793767, "cmd=%s", v40);
      AppleBCMWLANUtil::releaseOSObjectArray(keys, (const OSString **)values, (const OSObject **)1);
      goto LABEL_29;
    }
LABEL_25:
    *((unsigned char *)v8 + 304) = 0;
    char v8 = this[8];
    goto LABEL_26;
  }
  if (*((unsigned char *)v8 + 304)) {
    goto LABEL_25;
  }
  uint64_t v6 = mapBcmErrorToIOReturn(v7);
  unint64_t v43 = *this[8];
  if (v43 && CCLogStream::shouldLog(v43, 2uLL))
  {
    LODWORD(keys[0]) = 1;
    unint64_t v44 = IO80211Buffer::getLength(v5);
    unint64_t v45 = HIDWORD(v231) + 16;
    if (v44 < v45) {
      unint64_t v45 = IO80211Buffer::getLength(v5);
    }
    if (commandLoggingRestricted(a2)) {
      unint64_t v45 = 16;
    }
    uint64_t v46 = *this[8];
    uint64_t v47 = (unsigned __int8 *)IO80211Buffer::getBytesNoCopy(v5);
    unint64_t v48 = IO80211Buffer::getLength(v5);
    if (v6) {
      CCLogStream::logHeaderAndBuf(v46, v47, 0, v45, v48, keys, 4uLL);
    }
    else {
      CCLogStream::logHeaderAndBufIf(v46, 2uLL, v47, 0, v45, v48, keys, 4uLL);
    }
  }
  if (v6 == -469794537 || !v6) {
    goto LABEL_64;
  }
  if (v6 == -469794543)
  {
    if (AppleBCMWLANCommand::getIOCtl(a2) == 23) {
      goto LABEL_64;
    }
    v81 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    int v82 = "WLC_GET_VAR: bssload_report";
    size_t v83 = 27;
LABEL_76:
    if (!strncmp(v81, v82, v83)) {
      goto LABEL_64;
    }
LABEL_77:
    int v84 = 0;
    int v85 = 0;
    int v86 = 0;
    int v87 = 0;
    int v88 = 0;
    goto LABEL_78;
  }
  int v84 = 0;
  if ((int)v6 > -469794545)
  {
    int v85 = 0;
    int v86 = 0;
    int v87 = 0;
    int v88 = 0;
    switch(v6)
    {
      case 0xE3FF8110:
        v99 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
        if (!strncmp(v99, "WLC_SET_VAR: escan", 0x12uLL)) {
          goto LABEL_64;
        }
        int v85 = 0;
        int v86 = 0;
        int v87 = 0;
        int v88 = 0;
        int v84 = 1;
        goto LABEL_78;
      case 0xE3FF8111:
      case 0xE3FF8112:
      case 0xE3FF8114:
      case 0xE3FF8116:
      case 0xE3FF8117:
      case 0xE3FF8118:
      case 0xE3FF811D:
        goto LABEL_78;
      case 0xE3FF8113:
        v81 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
        int v82 = "WLC_SET_VAR: awdl_oob_af";
        size_t v83 = 24;
        goto LABEL_76;
      case 0xE3FF8115:
        v81 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
        int v82 = "WLC_GET_VAR: sta_info";
        size_t v83 = 21;
        goto LABEL_76;
      case 0xE3FF8119:
        v157 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
        if (!strncmp(v157, "WLC_SET_VAR: awdl_oob_af_auto", 0x1DuLL)) {
          goto LABEL_64;
        }
        v158 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
        if (!strncmp(v158, "WLC_SET_VAR: awdl_afs_pload", 0x1BuLL)) {
          goto LABEL_64;
        }
        v159 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
        if (!strncmp(v159, "WLC_SET_VAR: awdl_oob_af", 0x18uLL)) {
          goto LABEL_64;
        }
        int v84 = 0;
        int v85 = 0;
        int v86 = 0;
        int v87 = 0;
        int v88 = 1;
        goto LABEL_78;
      case 0xE3FF811A:
        v160 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
        if (!strncmp(v160, "WLC_SET_VAR: pfn_macaddr", 0x18uLL)) {
          goto LABEL_64;
        }
        v161 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
        if (!strncmp(v161, "WLC_GET_VAR: pfnbest_bssid", 0x1AuLL)) {
          goto LABEL_64;
        }
        int v84 = 0;
        int v85 = 0;
        int v86 = 0;
        int v88 = 0;
        int v87 = 1;
        goto LABEL_78;
      case 0xE3FF811B:
        v81 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
        int v82 = "WLC_SET_VAR: awdl_peer_op";
        size_t v83 = 25;
        goto LABEL_76;
      case 0xE3FF811C:
        if (AppleBCMWLANCommand::getIOCtl(a2) == 84) {
          goto LABEL_64;
        }
        v81 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
        int v82 = "WLC_SET_VAR: country";
        size_t v83 = 20;
        goto LABEL_76;
      case 0xE3FF811E:
        if (AppleBCMWLANCommand::getIOCtl(a2) == 51) {
          goto LABEL_64;
        }
        v162 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
        if (!strncmp(v162, "WLC_SET_VAR: proxd", 0x12uLL)) {
          goto LABEL_64;
        }
        int v84 = 0;
        int v86 = 0;
        int v87 = 0;
        int v88 = 0;
        int v85 = 1;
        goto LABEL_78;
      default:
        int v85 = 0;
        int v86 = 0;
        int v87 = 0;
        int v88 = 0;
        if (v6 != -469794487) {
          goto LABEL_78;
        }
        v81 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
        int v82 = "WLC_SET_VAR: escan";
        size_t v83 = 18;
        goto LABEL_76;
    }
  }
  if (v6 == -469794559)
  {
    v163 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    if (strncmp(v163, "WLC_GET_VAR: calload", 0x14uLL)) {
      goto LABEL_64;
    }
    goto LABEL_77;
  }
  int v85 = 0;
  int v86 = 0;
  int v87 = 0;
  int v88 = 0;
  if (v6 == -469794558)
  {
    v146 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    if (!strncmp(v146, "WLC_SET_VAR: pkt_filter_delete", 0x1EuLL)) {
      goto LABEL_64;
    }
    v147 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    if (!strncmp(v147, "WLC_SET_VAR: pkt_filter_enable", 0x1EuLL)) {
      goto LABEL_64;
    }
    int v84 = 0;
    int v85 = 0;
    int v87 = 0;
    int v88 = 0;
    int v86 = 1;
  }
LABEL_78:
  int v229 = v86;
  int v89 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
  int v90 = strncmp(v89, "WLC_GET_VAR: beacon_info", 0x18uLL);
  unsigned int v91 = v6 + 469794552;
  if (v90)
  {
    if (v91 > 0xE || ((1 << (v6 - 8)) & 0x6101) == 0) {
      goto LABEL_127;
    }
LABEL_129:
    uint64_t v115 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    v116 = "WLC_SET_VAR: ptk_start";
    size_t v117 = 22;
    goto LABEL_130;
  }
  if (v91 <= 0x16)
  {
    int v114 = 1 << (v6 - 8);
    if ((v114 & 0x6101) == 0)
    {
      if ((v114 & 0x420240) != 0) {
        goto LABEL_64;
      }
      goto LABEL_127;
    }
    goto LABEL_129;
  }
LABEL_127:
  if ((v6 + 469794535) > 1) {
    goto LABEL_131;
  }
  uint64_t v115 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
  v116 = "WLC_SET_VAR: event_log_get";
  size_t v117 = 26;
LABEL_130:
  if (!strncmp(v115, v116, v117)) {
    goto LABEL_64;
  }
LABEL_131:
  if (v6 == -469794546)
  {
    v118 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    v119 = "WLC_GET_VAR: awdl_stats";
    size_t v120 = 23;
LABEL_176:
    if (!strncmp(v118, v119, v120)) {
      goto LABEL_64;
    }
    goto LABEL_177;
  }
  if (v6 == -469794523)
  {
    v118 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    v119 = "WLC_SET_VAR: roam_prof";
    size_t v120 = 22;
    goto LABEL_176;
  }
LABEL_177:
  if (v87)
  {
    v148 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    if (!strncmp(v148, "WLC_SET_VAR: escan", 0x12uLL) || AppleBCMWLANCommand::getIOCtl(a2) == 50) {
      goto LABEL_64;
    }
  }
  v149 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
  if (!strncmp(v149, "WLC_SET_VAR: actframe", 0x15uLL)) {
    goto LABEL_64;
  }
  v150 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
  if (!strncmp(v150, "WLC_GET_VAR: awd_data_info", 0x1AuLL)) {
    goto LABEL_64;
  }
  if (v85)
  {
    v151 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    if (!strncmp(v151, "WLC_SET_VAR: hc_tx_failure_to_rpt", 0x21uLL)) {
      goto LABEL_64;
    }
  }
  v152 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
  char v153 = !strncmp(v152, "WLC_SET_VAR: bcn_report", 0x17uLL) ? v85 : 0;
  if (v153) {
    goto LABEL_64;
  }
  if (v88)
  {
    v154 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    if (!strncmp(v154, "WLC_GET_VAR: roam_cache", 0x17uLL)) {
      goto LABEL_64;
    }
  }
  if (v6 == -469794556)
  {
    v155 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    if (!strncmp(v155, "WLC_SET_VAR: btc_flags", 0x16uLL)) {
      goto LABEL_64;
    }
    if (AppleBCMWLANCommand::getIOCtl(a2) == 53) {
      goto LABEL_64;
    }
    v156 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    if (!strncmp(v156, "WLC_GET_VAR: btc_status", 0x17uLL)) {
      goto LABEL_64;
    }
  }
  else if (v6 == -469794543 && AppleBCMWLANCommand::getIOCtl(a2) == 53)
  {
    goto LABEL_64;
  }
  if (v85)
  {
    v164 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    if (!strncmp(v164, "WLC_GET_VAR: wpaie", 0x12uLL)) {
      goto LABEL_64;
    }
  }
  if (v229)
  {
    v165 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    if (!strncmp(v165, "WLC_SET_VAR: wnm_dms_set", 0x18uLL)) {
      goto LABEL_64;
    }
  }
  if (v85)
  {
    v166 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    if (!strncmp(v166, "WLC_GET_VAR: phy_rssi_ant", 0x19uLL)) {
      goto LABEL_64;
    }
  }
  if (v6 == -469794553)
  {
    v167 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    if (!strncmp(v167, "WLC_SET_VAR: rssi_win", 0x15uLL)) {
      goto LABEL_64;
    }
  }
  if (v88)
  {
    v168 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
    if (!strncmp(v168, "WLC_SET_VAR: scanmac", 0x14uLL)) {
      goto LABEL_64;
    }
  }
  v169 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
  if (!strncmp(v169, "WLC_SET_VAR: ampdu_tx_ba_window_cfg", 0x23uLL)) {
    goto LABEL_64;
  }
  v170 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
  if (!strncmp(v170, "WLC_SET_VAR: ampdu_rx_ba_window_cfg", 0x23uLL)) {
    goto LABEL_64;
  }
  v171 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
  if (!strncmp(v171, "WLC_SET_VAR: wnm_prune_rssi_thresh", 0x22uLL)) {
    goto LABEL_64;
  }
  v172 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
  if (!strncmp(v172, "WLC_SET_VAR: sib", 0x10uLL)
    && (v6 + 469794559) <= 0x18
    && ((1 << (v6 - 1)) & 0x100800B) != 0)
  {
    goto LABEL_64;
  }
  v173 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
  if (!strncmp(v173, "WLC_GET_VAR: csi", 0x10uLL) && (v6 == -469794556 || v6 == -469794535)) {
    goto LABEL_64;
  }
  v174 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
  if (!strncmp(v174, "WLC_SET_VAR: csi", 0x10uLL) && (v6 == -469794556 || v6 == -469794535)) {
    goto LABEL_64;
  }
  v175 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
  if (strncmp(v175, "WLC_SET_VAR: qos_mgmt", 0x15uLL))
  {
    if (v6 != -469794507) {
      goto LABEL_268;
    }
    goto LABEL_234;
  }
  if ((int)v6 > -469794508)
  {
    if (v6 == -469794507)
    {
LABEL_234:
      v176 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
      if (!strncmp(v176, "WLC_GET_VAR: dump", 0x11uLL)) {
        goto LABEL_64;
      }
LABEL_268:
      AppleBCMWLANCommand::getCmdName(a2);
      v218 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
      if (strncmp(v218, "WLC_GET_VAR: wpaie", 0x12uLL))
      {
        v219 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
        if (strncmp(v219, "WLC_GET_VAR: phy_noise_ant", 0x1AuLL)
          || v6 != -469794556 && v6 != -469794535)
        {
          v220 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
          if (strncmp(v220, "WLC_SET_VAR: reassoc", 0x14uLL)
            || (v6 + 469794556) > 0x15
            || ((1 << (v6 - 4)) & 0x202001) == 0)
          {
            if ((v221 = (const char *)AppleBCMWLANCommand::getCmdName(a2), strncmp(v221, "WLC_SET_VAR: nan", 0x11uLL))
              && (v222 = (const char *)AppleBCMWLANCommand::getCmdName(a2), strncmp(v222, "WLC_GET_VAR: nan", 0x11uLL))
              || ((v223 = (AppleBCMWLANTxBuffer *)AppleBCMWLANCommand::getBuffer(a2),
                   uint64_t v224 = AppleBCMWLANTxBuffer::getPayload(v223, 20),
                   AppleBCMWLANCommand::setSubCmdID((uint64_t)a2, *(_WORD *)(v224 + 4)),
                   !v85)
               || *(_WORD *)(v224 + 4) != 1286)
              && (!v229 || *(_WORD *)(v224 + 4) != 1286)
              && (!v84 || (int v225 = *(unsigned __int16 *)(v224 + 4), v225 != 779) && v225 != 2051))
            {
              if (v6 != -469794480
                || (v226 = (const char *)AppleBCMWLANCommand::getCmdName(a2),
                    strncmp(v226, "WLC_SET_VAR: escan", 0x12uLL)))
              {
LABEL_65:
                v78 = this[8];
                int v79 = v78[27];
                if (*((unsigned char *)v78 + 288))
                {
                  if (v79 && CCLogStream::shouldLog()) {
                    CCLogStream::logAlert(this[8][27], "[dk] %s@%d: Crash IOVAR Unit Test\n", "processCompletedCommand", 2508);
                  }
                }
                else
                {
                  if (v79)
                  {
                    int v92 = CCLogStream::shouldLog();
                    v78 = this[8];
                    if (v92)
                    {
                      v207 = v78[27];
                      v208 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                      v209 = (const char *)(*(uint64_t (**)(CCLogStream *, uint64_t))(*(void *)this[8][22]
                                                                                             + 112))(this[8][22], v6);
                      CCLogStream::logEmergency(v207, "[dk] %s@%d: Command Failed on \"%s\" with status %s\n", "processCompletedCommand", 2504, v208, v209);
                      v78 = this[8];
                    }
                  }
                  AppleBCMWLANCommand::logCmd((uint64_t)a2, (uint64_t)v78[27], (uint64_t)"\tCommand: ", 1, 4, -1);
                  if (this[8][27] && CCLogStream::shouldLog())
                  {
                    v210 = this[8];
                    v211 = v210[27];
                    int v212 = (unsigned __int16)v233;
                    uint64_t v213 = v232[1];
                    uint64_t v214 = HIDWORD(v231);
                    if ((v231 & 2) != 0) {
                      v215 = "set";
                    }
                    else {
                      v215 = "get";
                    }
                    v216 = (const char *)(*(uint64_t (**)(CCLogStream *, uint64_t))(*(void *)v210[22] + 112))(v210[22], v6);
                    CCLogStream::logEmergency(v211, "[dk] %s@%d:\tResponse: %5u) [ cmd 0x%08lX len %6lu flags \"%s\" status \"%s\"]\n", "processCompletedCommand", 2506, v212, v213, v214, v215, v216);
                  }
                }
                int v93 = 0;
                if (v6 == -469794549 || v6 == -469794537) {
                  unsigned int v95 = 8;
                }
                else {
                  unsigned int v95 = 4;
                }
                if ((int)v6 > -469794545)
                {
                  int v96 = 0;
                  int v97 = 0;
                  switch(v6)
                  {
                    case 0xE3FF8110:
                      v98 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                      if (!strncmp(v98, "WLC_SET_VAR: awdl_oob_af", 0x18uLL)) {
                        goto LABEL_159;
                      }
                      int v96 = 0;
                      int v97 = 0;
                      int v93 = 1;
                      goto LABEL_137;
                    case 0xE3FF8111:
                    case 0xE3FF8112:
                    case 0xE3FF8114:
                    case 0xE3FF8115:
                    case 0xE3FF8116:
                    case 0xE3FF8118:
                    case 0xE3FF811C:
                    case 0xE3FF811D:
                      goto LABEL_137;
                    case 0xE3FF8113:
                      goto LABEL_116;
                    case 0xE3FF8117:
                      v106 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                      if (!strncmp(v106, "WLC_SET_VAR: wsec_info", 0x16uLL)) {
                        goto LABEL_159;
                      }
                      int v107 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                      if (!strncmp(v107, "WLC_SET_VAR: bcn_mute_miti_config", 0x21uLL)) {
                        goto LABEL_159;
                      }
                      v108 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                      if (!strncmp(v108, "WLC_GET_VAR: bcn_mute_miti_config", 0x21uLL)) {
                        goto LABEL_159;
                      }
                      v103 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                      v104 = "WLC_SET_VAR: bcn_tbtt_config";
                      size_t v105 = 28;
                      goto LABEL_135;
                    case 0xE3FF8119:
                      int v109 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                      if (strncmp(v109, "WLC_SET_VAR: txcapstate", 0x17uLL))
                      {
                        long long v110 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                        if (strncmp(v110, "WLC_SET_VAR: txcapbypass", 0x18uLL)) {
                          goto LABEL_116;
                        }
                      }
                      goto LABEL_159;
                    case 0xE3FF811A:
                      if (AppleBCMWLANCommand::getIOCtl(a2) == 53) {
                        goto LABEL_159;
                      }
                      v103 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                      v104 = "WLC_SET_VAR: reassoc";
                      size_t v105 = 20;
                      goto LABEL_135;
                    case 0xE3FF811B:
                      int v111 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                      if (!strncmp(v111, "WLC_SET_VAR: awdl_oob_af", 0x18uLL)) {
                        goto LABEL_159;
                      }
                      v103 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                      v104 = "WLC_SET_VAR: awdl_payload";
                      size_t v105 = 25;
                      goto LABEL_135;
                    case 0xE3FF811E:
                      unsigned int v112 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                      if (!strncmp(v112, "WLC_SET_VAR: awdl_opmode", 0x18uLL)) {
                        goto LABEL_159;
                      }
                      unsigned int v113 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                      if (!strncmp(v113, "WLC_SET_WSEC_PMK", 0x10uLL)) {
                        goto LABEL_159;
                      }
                      int v93 = 0;
                      int v97 = 0;
                      int v96 = 1;
                      goto LABEL_137;
                    default:
                      if (v6 == -469794490)
                      {
                        v103 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                        v104 = "WLC_SET_VAR: escan";
                        size_t v105 = 18;
                        goto LABEL_135;
                      }
                      int v96 = 0;
                      int v97 = 0;
                      if (v6 != -469794481) {
                        goto LABEL_137;
                      }
                      v102 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                      if (strncmp(v102, "WLC_SET_COUNTRY", 0xFuLL))
                      {
                        v103 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                        v104 = "WLC_SET_SSID";
                        size_t v105 = 12;
                        goto LABEL_135;
                      }
                      break;
                  }
                  goto LABEL_159;
                }
                if (v6 == -469794559)
                {
LABEL_116:
                  v103 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                  v104 = "WLC_SET_VAR: awdl_oob_af";
                  size_t v105 = 24;
LABEL_135:
                  if (!strncmp(v103, v104, v105)) {
                    goto LABEL_159;
                  }
                  int v93 = 0;
                  int v96 = 0;
                  int v97 = 0;
                }
                else
                {
                  int v96 = 0;
                  int v97 = 0;
                  if (v6 == -469794558)
                  {
                    unint64_t v100 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                    if (!strncmp(v100, "WLC_SET_VAR: wnm_keepalives_max_i", 0x21uLL)) {
                      goto LABEL_159;
                    }
                    unint64_t v101 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                    if (!strncmp(v101, "WLC_SET_COUNTRY", 0xFuLL)) {
                      goto LABEL_159;
                    }
                    int v93 = 0;
                    int v96 = 0;
                    int v97 = 1;
                  }
                }
LABEL_137:
                uint64_t v121 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                if (strncmp(v121, "WLC_SET_VAR: nan", 0x11uLL)
                  && (v122 = (const char *)AppleBCMWLANCommand::getCmdName(a2),
                      strncmp(v122, "WLC_GET_VAR: nan", 0x11uLL))
                  || ((uint64_t v123 = (AppleBCMWLANTxBuffer *)AppleBCMWLANCommand::getBuffer(a2),
                       uint64_t v124 = AppleBCMWLANTxBuffer::getPayload(v123, 20),
                       AppleBCMWLANCommand::setSubCmdID((uint64_t)a2, *(_WORD *)(v124 + 4)),
                       !v96)
                   || *(_WORD *)(v124 + 4) != 1286)
                  && (!v97 || *(_WORD *)(v124 + 4) != 1286)
                  && (!v93 || (int v125 = *(unsigned __int16 *)(v124 + 4), v125 != 779) && v125 != 2051))
                {
                  v126 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                  if (strncmp(v126, "WLC_GET_VAR: csi", 0x10uLL)
                    || v6 != -469794556 && v6 != -469794535)
                  {
                    int v127 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                    if (strncmp(v127, "WLC_SET_VAR: csi", 0x10uLL)
                      || v6 != -469794556 && v6 != -469794535)
                    {
                      int v128 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                      if (strncmp(v128, "WLC_GET_VAR: phy_noise_ant", 0x1AuLL)
                        || v6 != -469794556 && v6 != -469794535)
                      {
                        if (*((unsigned char *)this[8] + 16))
                        {
                          v95 |= 1u;
LABEL_162:
                          keys[0] = OSString::withCString("CommandRequest.bin");
                          keys[1] = OSString::withCString("CommandResponse.bin");
                          Buffer = (AppleBCMWLANTxBuffer *)AppleBCMWLANCommand::getBuffer(a2);
                          uint64_t Payload = (const void *)AppleBCMWLANTxBuffer::getPayload(Buffer, 0);
                          int v131 = (AppleBCMWLANTxBuffer *)AppleBCMWLANCommand::getBuffer(a2);
                          Payloadunsigned int Length = AppleBCMWLANTxBuffer::getPayloadLength(v131);
                          values[0] = OSData::withBytes(Payload, PayloadLength);
                          long long v133 = (const void *)IO80211Buffer::getBytesNoCopy(v5);
                          unsigned int v134 = IO80211Buffer::getLength(v5);
                          values[1] = OSData::withBytes(v133, v134);
                          if (!AppleBCMWLANCommand::getSubCmdID(a2))
                          {
                            long long v135 = this[8][37];
                            v136 = OSDictionary::withObjects((const OSObject **)values, (const OSObject **)keys, 2u, 0);
                            v137 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                            v138 = (const char *)(*(uint64_t (**)(CCLogStream *, uint64_t))(*(void *)this[8][22] + 112))(this[8][22], v6);
                            CCFaultReporter::reportFault(v135, v95, "/Library/Caches/com.apple.xbs/Sources/AppleBCMWLANV3_driverkit/AppleBCMWLANCommander.cpp", 0x9F6u, "processCompletedCommand", v136, -469793766, "cmd=%s,status=%s", v137, v138);
                          }
                          AppleBCMWLANUtil::releaseOSObjectArray(keys, (const OSString **)values, (const OSObject **)2);
                          uint64_t v41 = this[8];
                          if (!v41[27]) {
                            goto LABEL_30;
                          }
                          int v139 = CCLogStream::shouldLog();
                          uint64_t v41 = this[8];
                          if (!v139) {
                            goto LABEL_30;
                          }
                          v140 = v41[27];
                          int v141 = (unsigned __int16)v233;
                          uint64_t v142 = v232[1];
                          uint64_t v143 = HIDWORD(v231);
                          if ((v231 & 2) != 0) {
                            v144 = "set";
                          }
                          else {
                            v144 = "get";
                          }
                          v145 = (const char *)(*(uint64_t (**)(CCLogStream *, uint64_t))(*(void *)v41[22]
                                                                                                 + 112))(v41[22], v6);
                          CCLogStream::logNotice(v140, "\tResponse: %5u) [ cmd 0x%08lX len %6lu flags \"%s\" status \"%s\"]\n", v141, v142, v143, v144, v145);
LABEL_29:
                          uint64_t v41 = this[8];
LABEL_30:
                          IOSimpleReporter::incrementValue(v41[4], 0x436D644973507200uLL, 1);
                          return v6;
                        }
                      }
                    }
                  }
                }
LABEL_159:
                if (this[8][27] && CCLogStream::shouldLog())
                {
                  v191 = this[8][27];
                  v192 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
                  v193 = (const char *)(*(uint64_t (**)(CCLogStream *, uint64_t))(*(void *)this[8][22] + 112))(this[8][22], v6);
                  CCLogStream::logInfo(v191, "[dk] %s@%d:Not Triggering WD, ignoring failed command %s with return code %s\n", "processCompletedCommand", 2517, v192, v193);
                }
                goto LABEL_162;
              }
            }
          }
        }
      }
      goto LABEL_64;
    }
    unsigned __int16 v217 = -32436;
  }
  else
  {
    if (v6 == -469794560) {
      goto LABEL_64;
    }
    unsigned __int16 v217 = -32486;
  }
  if (v6 != (v217 | 0xE3FF0000)) {
    goto LABEL_268;
  }
LABEL_64:
  v77 = this[8];
  if (*((unsigned char *)v77 + 288)) {
    goto LABEL_65;
  }
  if (v77[27])
  {
    int v80 = CCLogStream::shouldLog();
    v77 = this[8];
    if (v80)
    {
      v204 = v77[27];
      v205 = (const char *)AppleBCMWLANCommand::getCmdName(a2);
      v206 = (const char *)(*(uint64_t (**)(CCLogStream *, uint64_t))(*(void *)this[8][22] + 112))(this[8][22], v6);
      CCLogStream::logNoticeIf(v204, 4uLL, "[dk] %s@%d: Command response received for %s with status (%s):\n", "processCompletedCommand", 2560, v205, v206);
      v77 = this[8];
    }
  }
  AppleBCMWLANCommand::logCmd((uint64_t)a2, (uint64_t)v77[27], (uint64_t)"\t", 1, 4, 4);
  return v6;
}

uint64_t AppleBCMWLANCommander::sendCommandResponseEventToCoreAnalytics(AppleBCMWLANCommander *this, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  read_random();
  OSStringPtr v10 = OSString::withCString("com.apple.wifi.commanderResponseTime");
  if (v10)
  {
    unint64_t v11 = v10;
    uint64_t v12 = OSDictionary::withCapacity(4u);
    if (!v12)
    {
      if (*(void *)(*((void *)this + 8) + 216) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d:Fail to allocate eventPayload\n");
      }
      goto LABEL_16;
    }
    if (a2) {
      unint64_t v13 = "pendingQueueSync";
    }
    else {
      unint64_t v13 = "pendingQueueAsync";
    }
    OSStringPtr v14 = OSString::withCString(v13);
    if (v14)
    {
      unint64_t v15 = v14;
      OSNumberPtr v16 = OSNumber::withNumber(a3, 0x20uLL);
      if (!v16)
      {
        uint64_t v27 = *((void *)this + 8);
        uint64_t v26 = (char *)this + 64;
        if (!*(void *)(v27 + 216) || (CCLogStream::shouldLog() & 1) == 0) {
          goto LABEL_43;
        }
        int v28 = 2369;
        goto LABEL_45;
      }
      OSNumberPtr v17 = v16;
      OSDictionary::setObject(v12, v15, v16);
      ((void (*)(const OSObject *))v15->release)(v15);
      ((void (*)(OSNumberPtr))v17->release)(v17);
      OSStringPtr v18 = OSString::withCString("outboundQueue");
      if (v18)
      {
        unint64_t v15 = v18;
        OSNumberPtr v19 = OSNumber::withNumber(a4, 0x20uLL);
        if (!v19)
        {
          uint64_t v29 = *((void *)this + 8);
          uint64_t v26 = (char *)this + 64;
          if (!*(void *)(v29 + 216) || (CCLogStream::shouldLog() & 1) == 0) {
            goto LABEL_43;
          }
          int v28 = 2377;
LABEL_45:
          CCLogStream::logAlert(*(CCLogStream **)(*(void *)v26 + 216), "[dk] %s@%d:Fail to allocate numValue\n", "sendCommandResponseEventToCoreAnalytics", v28);
LABEL_43:
          ((void (*)(const OSObject *))v15->release)(v15);
LABEL_16:
          uint64_t result = ((uint64_t (*)(OSString *))v11->release)(v11);
          if (v12) {
            return ((uint64_t (*)(OSDictionary *))v12->release)(v12);
          }
          return result;
        }
        OSNumberPtr v20 = v19;
        OSDictionary::setObject(v12, v15, v19);
        ((void (*)(const OSObject *))v15->release)(v15);
        ((void (*)(OSNumberPtr))v20->release)(v20);
        OSStringPtr v21 = OSString::withCString("activeQueue");
        if (v21)
        {
          unint64_t v15 = v21;
          OSNumberPtr v22 = OSNumber::withNumber(a5, 0x20uLL);
          if (v22)
          {
            OSNumberPtr v23 = v22;
            OSDictionary::setObject(v12, v15, v22);
            ((void (*)(const OSObject *))v15->release)(v15);
            ((void (*)(OSNumberPtr))v23->release)(v23);
            if (IOService::CoreAnalyticsSendEvent(*(IOService **)(*((void *)this + 8) + 176), 0, v11, v12, 0)&& *(void *)(*((void *)this + 8) + 216)&& CCLogStream::shouldLog())
            {
              uint64_t v31 = *(CCLogStream **)(*((void *)this + 8) + 216);
              CStringNoCopy = OSString::getCStringNoCopy(v11);
              CCLogStream::logEmergency(v31, "[dk] %s@%d:Failed to send CoreAnalyticsSendEvent for event %s", "sendCommandResponseEventToCoreAnalytics", 2391, CStringNoCopy);
            }
            goto LABEL_16;
          }
          uint64_t v30 = *((void *)this + 8);
          uint64_t v26 = (char *)this + 64;
          if (!*(void *)(v30 + 216) || (CCLogStream::shouldLog() & 1) == 0) {
            goto LABEL_43;
          }
          int v28 = 2385;
          goto LABEL_45;
        }
        if (!*(void *)(*((void *)this + 8) + 216) || !CCLogStream::shouldLog()) {
          goto LABEL_16;
        }
        uint64_t v25 = *(CCLogStream **)(*((void *)this + 8) + 216);
      }
      else
      {
        if (!*(void *)(*((void *)this + 8) + 216) || !CCLogStream::shouldLog()) {
          goto LABEL_16;
        }
        uint64_t v25 = *(CCLogStream **)(*((void *)this + 8) + 216);
      }
    }
    else
    {
      if (!*(void *)(*((void *)this + 8) + 216) || !CCLogStream::shouldLog()) {
        goto LABEL_16;
      }
      uint64_t v25 = *(CCLogStream **)(*((void *)this + 8) + 216);
    }
    CCLogStream::logAlert(v25, "[dk] %s@%d:Fail to allocate keyString\n");
    goto LABEL_16;
  }
  uint64_t result = *(void *)(*((void *)this + 8) + 216);
  if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 216), "[dk] %s@%d:Fail to allocate eventName\n", "sendCommandResponseEventToCoreAnalytics", 2357);
    }
  }
  return result;
}

uint64_t AppleBCMWLANCommander::delayQueueTimeouts(AppleBCMWLANCommander *this)
{
  uint64_t result = clock_interval_to_deadline();
  uint64_t v3 = *((void *)this + 8);
  unint64_t v4 = *(void *)(v3 + 40);
  if (v4) {
    BOOL v5 = v4 < 0xAAAAAAAAAAAAAAAALL;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    *(void *)(v3 + 40) = 0xAAAAAAAAAAAAAAAALL;
  }
  return result;
}

uint64_t ___ZN21AppleBCMWLANCommander11checkQueuesEP18IO80211TimerSource_block_invoke(uint64_t a1, AppleBCMWLANCommand *this)
{
  uint64_t v4 = *(void *)(a1 + 48);
  unint64_t QueuedDuration_ms = AppleBCMWLANCommand::getQueuedDuration_ms(this);
  uint64_t v6 = *(void *)(v4 + 64);
  if (QueuedDuration_ms <= *(unsigned int *)(v6 + 164)) {
    return 0;
  }
  unint64_t v7 = QueuedDuration_ms;
  char v8 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 208) + 600))(*(void *)(v6 + 208), v6 + 56);
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (v7 < *(unsigned int *)(a1 + 56) && (v8 & 1) != 0)
  {
    uint64_t result = *(void *)(*(void *)(v4 + 64) + 216);
    if (result)
    {
      int shouldLog = CCLogStream::shouldLog();
      uint64_t result = 0;
      if (shouldLog)
      {
        unint64_t v11 = *(CCLogStream **)(*(void *)(v4 + 64) + 216);
        CmdName = (const char *)AppleBCMWLANCommand::getCmdName(this);
        int TransactionID = AppleBCMWLANCommand::getTransactionID(this);
        unint64_t v14 = AppleBCMWLANCommand::getQueuedTime_ns(this) / 0x3B9ACA00uLL;
        unint64_t QueuedTime_ns = AppleBCMWLANCommand::getQueuedTime_ns(this);
        CCLogStream::logEmergency(v11, "[dk] %s@%d: Command Timeout on \"%s\" (transID %u) (queued @ %llu.%06llu) suppressed\n", "checkQueues_block_invoke", 2678, CmdName, TransactionID, v14, (274877907 * (QueuedTime_ns % 0x3B9ACA00)) >> 38);
        return 0;
      }
    }
  }
  else
  {
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    return 1;
  }
  return result;
}

OSObject *AppleBCMWLANCommander::purgeCommandQueue(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result = (OSObject *)AppleBCMWLANCommander::dequeueCommand(a1, a2);
  if (result)
  {
    unint64_t v7 = result;
    do
    {
      if (a3)
      {
        int v8 = AppleBCMWLANCommand::complete(v7, *(IO80211CagedBuffer **)(*(void *)(a1 + 64) + 136));
        if (v8)
        {
          int v9 = v8;
          if (*(void *)(*(void *)(a1 + 64) + 216))
          {
            if (CCLogStream::shouldLog()) {
              CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 64) + 216), "[dk] %s@%d: Failed complete(), cret[0x%08x]\n", "purgeCommandQueue", 2919, v9);
            }
          }
        }
      }
      ((void (*)(OSObject *))v7->release)(v7);
      uint64_t result = (OSObject *)AppleBCMWLANCommander::dequeueCommand(a1, a2);
      unint64_t v7 = result;
    }
    while (result);
  }
  return result;
}

uint64_t AppleBCMWLANCommander::printCommandCallback(AppleBCMWLANCommander *this, OSObject *a2, IOCommand *a3, void *a4)
{
  return 0;
}

uint64_t AppleBCMWLANCommander::dumpState(AppleBCMWLANCommander *this, char *a2, unsigned int a3, int a4)
{
  uint64_t v4 = (void *)*((void *)this + 8);
  if (!v4[10] || !v4[11] || !v4[12] || !v4[13] || !v4[14] || !v4[27] || !CCLogStream::shouldLog()) {
    return 0;
  }
  absolutetime_to_nanoseconds();
  CCFaultReporter::isBusy(*(CCFaultReporter **)(*((void *)this + 8) + 296));
  uint64_t v42 = a3;
  uint64_t v9 = IO80211Print();
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 80));
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 88));
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 96));
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 104));
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 112));
  uint64_t v10 = IO80211Print() + v9;
  mach_continuous_time();
  absolutetime_to_nanoseconds();
  mach_continuous_time();
  absolutetime_to_nanoseconds();
  absolutetime_to_nanoseconds();
  absolutetime_to_nanoseconds();
  absolutetime_to_nanoseconds();
  memset(v45, 170, sizeof(v45));
  absolutetime_to_nanoseconds();
  uint64_t v11 = IO80211Print() + v10;
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 80));
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 88));
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 96));
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 104));
  AppleBCMWLANCommandQueue::getSize(*(AppleBCMWLANCommandQueue **)(*((void *)this + 8) + 112));
  uint64_t v12 = IO80211Print() + v11;
  *(_OWORD *)__src = xmmword_1003713F0;
  uint64_t v44 = 0;
  unint64_t v13 = (void *)IOMallocZeroData();
  unint64_t v14 = v13;
  if (v13)
  {
    __src[1] = v13;
    unint64_t v15 = v13;
LABEL_13:
    unsigned char *v15 = 0;
    goto LABEL_14;
  }
  unint64_t v15 = __src[1];
  if (__src[1]) {
    goto LABEL_13;
  }
LABEL_14:
  uint64_t v18 = IO80211Print() + v12;
  AppleBCMWLANCommandQueue::lockMap(*(void *)(*((void *)this + 8) + 88), (void (*)(uint64_t, uint64_t, uint64_t))AppleBCMWLANCommander::printCommandCallback, (uint64_t)this, (uint64_t)__src);
  OSNumberPtr v19 = __src[1];
  if (a2)
  {
    if (__src[1])
    {
      OSNumberPtr v20 = &a2[v42 + v18];
      if (a4 - (int)v18 >= v44) {
        size_t v21 = v44;
      }
      else {
        size_t v21 = (a4 - v18);
      }
      if ((unint64_t)v20 > 0x7FFFFDFFFFFFLL)
      {
        IOLog("%s:%06u: BUF_PRINT_EMIT: Invalid address detected: buf[%p] addr[%p] len[%6d] remain[%6d] printed[%6d] e[%d]\n", "dumpState", 3020, __src[1], &a2[v42 + v18], v21, a4 - v18, v44, 0);
        OSNumberPtr v19 = __src[1];
      }
      else
      {
        memmove(v20, __src[1], v21);
      }
      unsigned char *v19 = 0;
      v18 += v21;
    }
  }
  else if (__src[1])
  {
    if (*(void *)(*((void *)this + 8) + 216))
    {
      int shouldLog = CCLogStream::shouldLog();
      OSNumberPtr v19 = __src[1];
      if (shouldLog)
      {
        CCLogStream::log();
        OSNumberPtr v19 = __src[1];
      }
    }
    unsigned char *v19 = 0;
  }
  LODWORD(v44) = 0;
  uint64_t v23 = IO80211Print() + v18;
  AppleBCMWLANCommandQueue::lockMap(*(void *)(*((void *)this + 8) + 96), (void (*)(uint64_t, uint64_t, uint64_t))AppleBCMWLANCommander::printCommandCallback, (uint64_t)this, (uint64_t)__src);
  uint64_t v24 = __src[1];
  if (a2)
  {
    if (__src[1])
    {
      uint64_t v25 = &a2[v42 + v23];
      if (a4 - (int)v23 >= v44) {
        size_t v26 = v44;
      }
      else {
        size_t v26 = (a4 - v23);
      }
      if ((unint64_t)v25 > 0x7FFFFDFFFFFFLL)
      {
        IOLog("%s:%06u: BUF_PRINT_EMIT: Invalid address detected: buf[%p] addr[%p] len[%6d] remain[%6d] printed[%6d] e[%d]\n", "dumpState", 3024, __src[1], &a2[v42 + v23], v26, a4 - v23, v44, 0);
        uint64_t v24 = __src[1];
      }
      else
      {
        memmove(v25, __src[1], v26);
      }
      unsigned char *v24 = 0;
      v23 += v26;
    }
  }
  else if (__src[1])
  {
    if (*(void *)(*((void *)this + 8) + 216))
    {
      int v27 = CCLogStream::shouldLog();
      uint64_t v24 = __src[1];
      if (v27)
      {
        CCLogStream::log();
        uint64_t v24 = __src[1];
      }
    }
    unsigned char *v24 = 0;
  }
  LODWORD(v44) = 0;
  uint64_t v28 = IO80211Print() + v23;
  AppleBCMWLANCommandQueue::lockMap(*(void *)(*((void *)this + 8) + 104), (void (*)(uint64_t, uint64_t, uint64_t))AppleBCMWLANCommander::printCommandCallback, (uint64_t)this, (uint64_t)__src);
  uint64_t v29 = __src[1];
  if (a2)
  {
    if (__src[1])
    {
      uint64_t v30 = &a2[v42 + v28];
      if (a4 - (int)v28 >= v44) {
        size_t v31 = v44;
      }
      else {
        size_t v31 = (a4 - v28);
      }
      if ((unint64_t)v30 > 0x7FFFFDFFFFFFLL)
      {
        IOLog("%s:%06u: BUF_PRINT_EMIT: Invalid address detected: buf[%p] addr[%p] len[%6d] remain[%6d] printed[%6d] e[%d]\n", "dumpState", 3028, __src[1], &a2[v42 + v28], v31, a4 - v28, v44, 0);
        uint64_t v29 = __src[1];
      }
      else
      {
        memmove(v30, __src[1], v31);
      }
      unsigned char *v29 = 0;
      v28 += v31;
    }
  }
  else if (__src[1])
  {
    if (*(void *)(*((void *)this + 8) + 216))
    {
      int v32 = CCLogStream::shouldLog();
      uint64_t v29 = __src[1];
      if (v32)
      {
        CCLogStream::log();
        uint64_t v29 = __src[1];
      }
    }
    unsigned char *v29 = 0;
  }
  LODWORD(v44) = 0;
  uint64_t v33 = IO80211Print() + v28;
  AppleBCMWLANCommandQueue::lockMap(*(void *)(*((void *)this + 8) + 112), (void (*)(uint64_t, uint64_t, uint64_t))AppleBCMWLANCommander::printCommandCallback, (uint64_t)this, (uint64_t)__src);
  unsigned int v34 = __src[1];
  if (a2)
  {
    if (__src[1])
    {
      int v35 = &a2[v42 + v33];
      if (a4 - (int)v33 >= v44) {
        size_t v36 = v44;
      }
      else {
        size_t v36 = (a4 - v33);
      }
      if ((unint64_t)v35 > 0x7FFFFDFFFFFFLL)
      {
        IOLog("%s:%06u: BUF_PRINT_EMIT: Invalid address detected: buf[%p] addr[%p] len[%6d] remain[%6d] printed[%6d] e[%d]\n", "dumpState", 3032, __src[1], &a2[v42 + v33], v36, a4 - v33, v44, 0);
        unsigned int v34 = __src[1];
      }
      else
      {
        memmove(v35, __src[1], v36);
      }
      *unsigned int v34 = 0;
      v33 += v36;
    }
  }
  else if (__src[1])
  {
    if (*(void *)(*((void *)this + 8) + 216))
    {
      int v37 = CCLogStream::shouldLog();
      unsigned int v34 = __src[1];
      if (v37)
      {
        CCLogStream::log();
        unsigned int v34 = __src[1];
      }
    }
    *unsigned int v34 = 0;
  }
  LODWORD(v44) = 0;
  uint64_t v16 = IO80211Print() + v33;
  AppleBCMWLANCommandQueue::lockMap(*(void *)(*((void *)this + 8) + 80), (void (*)(uint64_t, uint64_t, uint64_t))AppleBCMWLANCommander::printCommandCallback, (uint64_t)this, (uint64_t)__src);
  uint64_t v38 = __src[1];
  if (a2)
  {
    if (__src[1])
    {
      int v39 = &a2[v42 + v16];
      if (a4 - (int)v16 >= v44) {
        size_t v40 = v44;
      }
      else {
        size_t v40 = (a4 - v16);
      }
      if ((unint64_t)v39 > 0x7FFFFDFFFFFFLL)
      {
        IOLog("%s:%06u: BUF_PRINT_EMIT: Invalid address detected: buf[%p] addr[%p] len[%6d] remain[%6d] printed[%6d] e[%d]\n", "dumpState", 3036, __src[1], &a2[v42 + v16], v40, a4 - v16, v44, 0);
        uint64_t v38 = __src[1];
      }
      else
      {
        memmove(v39, __src[1], v40);
      }
      *uint64_t v38 = 0;
      uint64_t v16 = (v40 + v16);
    }
  }
  else if (__src[1])
  {
    if (*(void *)(*((void *)this + 8) + 216))
    {
      int v41 = CCLogStream::shouldLog();
      uint64_t v38 = __src[1];
      if (v41)
      {
        CCLogStream::log();
        uint64_t v38 = __src[1];
      }
    }
    *uint64_t v38 = 0;
  }
  LODWORD(v44) = 0;
  if (v14) {
    IOFreeData();
  }
  return v16;
}

uint64_t AppleBCMWLANCommander::configureReport(OSObject *this, OSCollection *a2, OSData *a3, unsigned int *a4, unsigned int *a5)
{
  uint64_t v6 = 3758097084;
  unsigned int v22 = 0;
  unint64_t v7 = this[1].OSObjectInterface::__vftable;
  free = (IOReporter *)v7[1].free;
  if (!free) {
    return v6;
  }
  uint64_t v12 = (OSObject *)v7->free;
  if (!v12) {
    goto LABEL_5;
  }
  int v13 = AppleBCMWLANCommandMonitor::configureReport(v12, a2, a3, a4);
  unint64_t v14 = this[1].OSObjectInterface::__vftable;
  if (!v13)
  {
    free = (IOReporter *)v14[1].free;
LABEL_5:
    int v23 = IOReporter::configureAllReports(free, a2, a3, &v22, a5);
    unint64_t v15 = this[1].OSObjectInterface::__vftable;
    uint64_t v16 = (CCLogStream *)v15[13].free;
    OSNumberPtr v17 = (CCFaultReporter *)v15[18].free;
    ClassNameHelper = (const char *)getClassNameHelper(this);
    int v23 = testPostConfigureAllAndAdjustV3(v16, v17, ClassNameHelper, a3, (unsigned int *)&v23, a4, v22, -2);
    if (!v23) {
      return 0;
    }
    if (this[1].OSObjectInterface::__vftable[13].free && CCLogStream::shouldLog())
    {
      OSNumberPtr v20 = (CCLogStream *)this[1].OSObjectInterface::__vftable[13].free;
      getClassNameHelper(this);
      CCLogStream::logEmergency(v20, "[dk] %s@%d:DKReporter::%s::%s(%d) testPostConfigureAllAndAdjustV3 failed\n");
    }
    return v6;
  }
  if (v14[13].free && CCLogStream::shouldLog())
  {
    size_t v21 = (CCLogStream *)this[1].OSObjectInterface::__vftable[13].free;
    getClassNameHelper(this);
    CCLogStream::logEmergency(v21, "[dk] %s@%d:DKReporter::%s::%s(%d) ivars->fCommandMonitor->configureReport failed");
  }
  return v6;
}

uint64_t AppleBCMWLANCommander::updateReport(OSObject *this, OSCollection *a2, OSData *a3, unsigned int *a4, unint64_t *a5, unint64_t *a6, IOMemoryDescriptor *a7)
{
  uint64_t v8 = 3758097084;
  unsigned int v32 = 0;
  uint64_t v9 = this[1].OSObjectInterface::__vftable;
  free = v9[11].free;
  if (free && v9[1].free)
  {
    (*(void (**)(void (__cdecl *)(OSObjectInterface *__hidden), uint64_t (*)(AppleBCMWLANCommander *), void, void, void, void))(*(void *)free + 56))(free, AppleBCMWLANCommander::updateAllReports, 0, 0, 0, 0);
    OSNumberPtr v17 = this[1].OSObjectInterface::__vftable;
    uint64_t v18 = (OSObject *)v17->free;
    if (v18
      && (int v19 = AppleBCMWLANCommandMonitor::updateReport(v18, a2, a3, a4, a5, a6, a7),
          OSNumberPtr v17 = this[1].OSObjectInterface::__vftable,
          v19))
    {
      if (v17[13].free && CCLogStream::shouldLog())
      {
        uint64_t v30 = (CCLogStream *)this[1].OSObjectInterface::__vftable[13].free;
        ClassNameHelper = (const char *)getClassNameHelper(this);
        CCLogStream::logEmergency(v30, "[dk] %s@%d:DKReporter::%s::%s(%d) ivars->fControllerMonitor->updateReport failed outElementCount %u offset %llu capacity %llu", "updateReport", 3098, ClassNameHelper, "updateReport", 3098, *a4, *a5, *a6);
      }
    }
    else
    {
      OSNumberPtr v20 = (CCLogStream *)v17[13].free;
      size_t v21 = (const char *)getClassNameHelper(this);
      testPreUpdateAllReportersV3(v20, v21, (OSSet *)this[1].OSObjectInterface::__vftable[1].free, *a5, *a6, a7);
      int updated = IOReporter::updateAllReports((IOReporter *)this[1].OSObjectInterface::__vftable[1].free, a2, a3, &v32, (unsigned int *)*a5, *a6, (unint64_t)a7, v22);
      int v23 = this[1].OSObjectInterface::__vftable;
      uint64_t v24 = (CCLogStream *)v23[13].free;
      uint64_t v25 = (CCFaultReporter *)v23[18].free;
      size_t v26 = (const char *)getClassNameHelper(this);
      int updated = testPostUpdateAllAndAdjustV3(v24, v25, v26, (unsigned int *)&updated, v32, a4, a5, a6, -2);
      if (updated && this[1].OSObjectInterface::__vftable[13].free && CCLogStream::shouldLog())
      {
        uint64_t v28 = (CCLogStream *)this[1].OSObjectInterface::__vftable[13].free;
        uint64_t v29 = (const char *)getClassNameHelper(this);
        CCLogStream::logEmergency(v28, "[dk] %s@%d:DKReporter::%s::%s(%d) testAndAdjustOffsetAndCapacity failed count %u outElementCount %u offset %llu capacity %llu", "updateReport", 3106, v29, "updateReport", 3106, v32, *a4, *a5, *a6);
      }
      return updated;
    }
  }
  return v8;
}

uint64_t AppleBCMWLANCommander::updateAllReports(AppleBCMWLANCommander *this)
{
  return 0;
}

BOOL AppleBCMWLANCommander::deviceBootStationaryNotification(AppleBCMWLANCommander *this)
{
  uint64_t v2 = *((void *)this + 8);
  if (*(void *)(v2 + 216))
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = *((void *)this + 8);
    if (shouldLog)
    {
      CCLogStream::logAlert(*(CCLogStream **)(v2 + 216), "[dk] %s@%d:device boot done, stationary state, update command timeout", "deviceBootStationaryNotification", 3290);
      uint64_t v2 = *((void *)this + 8);
    }
  }
  *(_DWORD *)(v2 + 260) = 25000;
  int v5 = -1431655766;
  BOOL result = IOParseBootArgNumber("wlan.factory", &v5, 4);
  if (result && (v5 & 0x10) != 0) {
    *(_DWORD *)(*((void *)this + 8) + 260) = *(_DWORD *)(*((void *)this + 8) + 168) + 5000;
  }
  return result;
}

void _GLOBAL__sub_I_AppleBCMWLANCommander_cpp()
{
  kNullRange = 0;
}

uint64_t mapBcomAlgoToBcomWsecFlags(unsigned int *a1, int a2, int a3)
{
  uint64_t v3 = 3758097090;
  int v4 = 1;
  switch(a2)
  {
    case 0:
      goto LABEL_4;
    case 1:
    case 3:
      goto LABEL_3;
    case 2:
      int v4 = 2;
      goto LABEL_3;
    case 4:
    case 14:
    case 15:
    case 16:
      int v4 = 4;
LABEL_3:
      *a1 |= v4;
LABEL_4:
      int v5 = 1;
      switch(a3)
      {
        case 0:
          goto LABEL_9;
        case 1:
        case 3:
          goto LABEL_8;
        case 2:
          int v5 = 2;
          goto LABEL_8;
        case 4:
        case 14:
        case 15:
        case 16:
          int v5 = 4;
LABEL_8:
          *a1 |= v5;
LABEL_9:
          uint64_t v3 = 0;
          break;
        default:
          return v3;
      }
      break;
    default:
      return v3;
  }
  return v3;
}

uint64_t getBcomPropertiesFromWPARSN(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int a5, unsigned __int8 *a6)
{
  if (!a5) {
    return 0;
  }
  uint64_t v7 = 3758097090;
  if (a5 >= 6 && a6)
  {
    char v27 = 0;
    IOParseBootArgNumber("wlan.debug.wpa-rsn", &v27, 1);
    int v13 = &a6[a5 - 1];
    BOOL v14 = __CFADD__(a5 - 1, a6);
    int v15 = *a6;
    if (v15 == 48)
    {
      if (v14
        || (uint64_t v18 = a6 + 4, (uint64_t)(a6 + 9) < (uint64_t)a6)
        || (unint64_t)(a6 + 4) >= 0xFFFFFFFFFFFFFFFBLL
        || (uint64_t)(a6 + 9) > (uint64_t)v13
        || (uint64_t)v18 < (uint64_t)a6
        || (uint64_t)v13 < (uint64_t)v18)
      {
        IOLog("%s:%6u: Insufficient space to parse RSN info, rsnIeLength[%u] len[%ld]\n");
      }
      else
      {
        int v19 = a6 + 10;
        *a1 = getRSNCipherSuiteToBcomWsec(v18);
        int v20 = *((unsigned __int16 *)a6 + 4);
        *a2 = 0;
        *a3 = 0;
        if (v20
          && (uint64_t)(a6 + 13) >= (uint64_t)a6
          && (unint64_t)v19 < 0xFFFFFFFFFFFFFFFDLL
          && (uint64_t)(a6 + 13) <= (uint64_t)v13
          && (uint64_t)v19 >= (uint64_t)a6
          && (uint64_t)v13 >= (uint64_t)v19)
        {
          *a2 = getRSNCipherSuiteToBcomWsec(a6 + 10);
          int v19 = a6 + 14;
        }
        if ((uint64_t)(v19 + 5) >= (uint64_t)a6
          && (unint64_t)v19 < 0xFFFFFFFFFFFFFFFBLL
          && (uint64_t)(v19 + 5) <= (uint64_t)v13
          && (uint64_t)v19 >= (uint64_t)a6
          && (uint64_t)v13 >= (uint64_t)v19)
        {
          uint64_t v21 = *(unsigned __int16 *)v19;
          unsigned int v22 = &v19[4 * v21 + 2];
          uint64_t v23 = (uint64_t)&v19[4 * v21 + 3];
          if (v23 >= (uint64_t)a6
            && &v19[4 * v21] != (unsigned __int8 *)-3
            && v23 <= (uint64_t)v13
            && (uint64_t)v22 >= (uint64_t)a6
            && (uint64_t)v13 >= (uint64_t)v22)
          {
            uint64_t v24 = &v19[4 * v21 + 4];
            if ((~*(unsigned __int16 *)v22 & 0xC0) != 0) {
              unsigned int v25 = 1;
            }
            else {
              unsigned int v25 = 2;
            }
            *a4 = v25;
            if ((uint64_t)&v19[4 * v21 + 5] >= (uint64_t)a6
              && &v19[4 * v21] != (unsigned __int8 *)-5
              && (uint64_t)&v19[4 * v21 + 5] <= (uint64_t)v13
              && (uint64_t)v24 >= (uint64_t)a6
              && (uint64_t)v13 >= (uint64_t)v24)
            {
              uint64_t v24 = &v22[16 * *(unsigned __int16 *)&v19[4 * v21 + 4] + 4];
            }
            if ((uint64_t)(v24 + 3) >= (uint64_t)a6
              && (unint64_t)v24 < 0xFFFFFFFFFFFFFFFDLL
              && (uint64_t)(v24 + 3) <= (uint64_t)v13
              && (uint64_t)v24 >= (uint64_t)a6
              && (uint64_t)v13 >= (uint64_t)v24)
            {
              *a3 = getRSNCipherSuiteToBcomWsec(v24);
            }
          }
        }
        if (v27) {
          IOLog("[dk] %s@%d: groupAlgo[%u], PW(count[%u], algo[%u]), AKM count[%u], capabilities[0x%04x] mfp[0x%08x] pmkidCount[%u] bipAlgo[%u]\n", "getBcomPropertiesFromWPARSN", 505);
        }
      }
      return 0;
    }
    if (v15 == 221)
    {
      if (v14
        || (uint64_t v16 = a6 + 8, (uint64_t)(a6 + 13) < (uint64_t)a6)
        || (unint64_t)(a6 + 8) >= 0xFFFFFFFFFFFFFFFBLL
        || (uint64_t)(a6 + 13) > (uint64_t)v13
        || (uint64_t)v16 < (uint64_t)a6
        || (uint64_t)v13 < (uint64_t)v16)
      {
        IOLog("%s:%6u: Insufficient space to parse WPA info\n");
      }
      else
      {
        *a1 = getWPACipherSuiteToBcomWsec((_DWORD *)a6 + 2);
        int v17 = *((unsigned __int16 *)a6 + 6);
        *a2 = 0;
        if (v17)
        {
          if (v17 != 1) {
            IOLog("%s: Multiple (%d) WPA pairwise cipher present, only use first one\n", "getBcomPropertiesFromWPARSN", v17);
          }
          if ((uint64_t)(a6 + 17) >= (uint64_t)a6
            && (unint64_t)v16 < 0xFFFFFFFFFFFFFFF7
            && (uint64_t)(a6 + 17) <= (uint64_t)v13)
          {
            *a2 = getWPACipherSuiteToBcomWsec(a6 + 14);
          }
        }
        if (v27) {
          IOLog("[dk] %s@%d: groupAlgo[%u], PW(count[%u], algo[%u])\n");
        }
      }
      return 0;
    }
  }
  return v7;
}

uint64_t getWPACipherSuiteToBcomWsec(_DWORD *a1)
{
  switch(*a1)
  {
    case 0x1F25000:
      return 1;
    case 0x5F25000:
      return 3;
    case 0x4F25000:
      return 4;
  }
  return 2 * (*a1 == 49434624);
}

uint64_t getRSNCipherSuiteToBcomWsec(_DWORD *a1)
{
  switch(*a1)
  {
    case 0x4AC0F00:
      return 4;
    case 0x2AC0F00:
      return 2;
    case 0x9AC0F00:
      return 16;
    case 0xCAC0F00:
      return 19;
    case 0xAAC0F00:
      return 15;
    case 0x1AC0F00:
      return 1;
    case 0x5AC0F00:
      return 3;
    case 0xBAC0F00:
      return 18;
    case 0x8AC0F00:
      return 14;
    case 0xDAC0F00:
      return 17;
    case 0x6AC0F00:
      return 13;
  }
  return 0;
}

uint64_t mapAppleAPModeToBcomBssType(unsigned int *a1, unsigned int a2)
{
  if (a2 > 3) {
    return 3758097090;
  }
  uint64_t result = 0;
  *a1 = mapAppleAPModeToBcomBssType(unsigned int &,unsigned int)::map[a2];
  return result;
}

uint64_t mapAppleLowerAuthToBcomAuth(unsigned int *a1, int a2)
{
  if ((a2 - 3) < 0xFFFFFFFE) {
    return 3758097090;
  }
  uint64_t result = 0;
  *a1 = a2 - 1;
  return result;
}

uint64_t mapAppleUpperAuthToBcomWpaAuth(unsigned int *a1, int a2, int a3, unsigned __int8 a4, int a5)
{
  uint64_t v5 = 3758097090;
  if (a2 > 255)
  {
    if (a2 >= 0x2000)
    {
      if (a2 < 0x8000)
      {
        if (a2 != 0x2000)
        {
          if (a2 == 0x4000)
          {
            unsigned int v6 = 0x400000;
            goto LABEL_41;
          }
          return v5;
        }
      }
      else
      {
        if (a2 == 0x8000)
        {
          unsigned int v6 = 4210688;
          goto LABEL_41;
        }
        if (a2 == 0x10000) {
          goto LABEL_29;
        }
        if (a2 != 0x20000) {
          return v5;
        }
      }
      unsigned int v6 = 278528;
      goto LABEL_41;
    }
    if (a2 > 1023)
    {
      if (a2 == 1024)
      {
        if (a3) {
          unsigned int v6 = 0x8000;
        }
        else {
          unsigned int v6 = 128;
        }
        goto LABEL_41;
      }
      if (a2 != 2048)
      {
        if (a2 != 4096) {
          return v5;
        }
LABEL_29:
        unsigned int v6 = 0x40000;
        goto LABEL_41;
      }
LABEL_25:
      unsigned int v6 = 64;
LABEL_41:
      uint64_t v5 = 0;
      *a1 = v6;
      return v5;
    }
    if (a2 != 256)
    {
      if (a2 == 512)
      {
        unsigned int v6 = 1024;
        goto LABEL_41;
      }
      return v5;
    }
LABEL_34:
    unsigned int v6 = 0;
    goto LABEL_41;
  }
  if (a2 <= 15)
  {
    unsigned int v6 = 2;
    switch(a2)
    {
      case 0:
        if (((a5 == 1) & a4) != 0) {
          unsigned int v6 = 0x100000;
        }
        else {
          unsigned int v6 = 0;
        }
        goto LABEL_41;
      case 1:
        goto LABEL_41;
      case 2:
        unsigned int v6 = 4;
        goto LABEL_41;
      case 4:
        goto LABEL_25;
      case 8:
        goto LABEL_21;
      default:
        return v5;
    }
    return v5;
  }
  if (a2 > 63)
  {
    if (a2 != 64)
    {
      if (a2 == 128)
      {
        unsigned int v6 = 16448;
        goto LABEL_41;
      }
      return v5;
    }
    goto LABEL_34;
  }
  if (a2 == 16)
  {
    unsigned int v6 = 16512;
    goto LABEL_41;
  }
  if (a2 == 32)
  {
LABEL_21:
    unsigned int v6 = 128;
    goto LABEL_41;
  }
  return v5;
}

uint64_t mapAppleCipherToBcomWsecFlags(unsigned int *a1, unsigned int a2)
{
  if (a2 <= 8) {
    *a1 |= mapAppleCipherToBcomWsecFlags(unsigned int &,unsigned int)::map[a2];
  }
  return 0;
}

uint64_t mapAppleCipherToBcomCryptoAlg(unsigned int *a1, unsigned int a2)
{
  if (a2 > 0xC) {
    return 3758097090;
  }
  uint64_t result = 0;
  *a1 = mapAppleCipherToBcomCryptoAlg(unsigned int &,unsigned int)::map[a2];
  return result;
}

uint64_t mapBcomCryptoAlgToAppleCipher(unsigned int *a1, unsigned int a2)
{
  if (a2 > 0xF) {
    return 3758097090;
  }
  uint64_t result = 0;
  *a1 = mapBcomCryptoAlgToAppleCipher(unsigned int &,unsigned int)::map[a2];
  return result;
}

uint64_t mapAppleKeyToBcomKey(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 3758097084;
  if (a2)
  {
    *(_DWORD *)(a1 + 160) = 0;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    int v5 = *(unsigned __int16 *)(a2 + 14);
    unsigned int v6 = *(_DWORD *)(a2 + 4);
    int v7 = *(_DWORD *)(a2 + 8);
    if (v6 >= 0x20) {
      size_t v8 = 32;
    }
    else {
      size_t v8 = v6;
    }
    *(_DWORD *)a1 = v5;
    *(_DWORD *)(a1 + 4) = v8;
    if (v7 == 3)
    {
      if (v6 < 0x20) {
        return v2;
      }
      *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 16);
      *(void *)(a1 + 24) = *(void *)(a2 + 40);
      *(void *)(a1 + 32) = *(void *)(a2 + 32);
    }
    else
    {
      memcpy((void *)(a1 + 8), (const void *)(a2 + 16), v8);
    }
    uint64_t v9 = *(unsigned int *)(a2 + 8);
    if (v9 <= 0xC)
    {
      int v10 = mapAppleCipherToBcomCryptoAlg(unsigned int &,unsigned int)::map[v9];
      if (v5 == 1 && v9 == 8) {
        int v12 = 0;
      }
      else {
        int v12 = (*(unsigned __int16 *)(a2 + 12) >> 1) & 2;
      }
      *(_DWORD *)(a1 + 112) = v10;
      *(_DWORD *)(a1 + 116) = v12;
      int v14 = *(_DWORD *)(a2 + 92);
      int v13 = (int *)(a2 + 92);
      uint64_t v2 = 0;
      if (v14 != -1 || *((__int16 *)v13 + 2) != -1)
      {
        int v16 = *v13;
        *(_WORD *)(a1 + 160) = *((_WORD *)v13 + 2);
        *(_DWORD *)(a1 + 156) = v16;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  return v2;
}

uint64_t mapBcomRatesetToAppleRateset(uint64_t result, _DWORD *a2)
{
  LODWORD(v2) = *a2;
  if ((*a2 & 0xFFF0) != 0) {
    LOWORD(v2) = 16;
  }
  *(_WORD *)(result + 4) = v2;
  if ((_WORD)v2)
  {
    uint64_t v2 = (unsigned __int16)v2;
    uint64_t v3 = (unsigned int *)(result + 16);
    int v4 = (unsigned __int8 *)(a2 + 1);
    do
    {
      *(v3 - IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = (*v4 >> 1) & 0x3F;
      unsigned int v5 = *v4++;
      *uint64_t v3 = v5 >> 7;
      v3 += 3;
      --v2;
    }
    while (v2);
  }
  return result;
}

__int16 *mapBcomStatusEventToIEEEStatus(__int16 *result, unsigned int a2, int a3)
{
  if (a2 <= 0xE) {
    __int16 v3 = byte_100371467[a2];
  }
  else {
    __int16 v3 = 1;
  }
  if (a3) {
    __int16 v3 = a3;
  }
  *uint64_t result = v3;
  return result;
}

uint64_t mapBcomSsidEventToAppleStatus(uint64_t result, unsigned int a2, unsigned int a3)
{
  __int16 v3 = (_WORD *)result;
  if (a2 > 0xE) {
    goto LABEL_5;
  }
  int v4 = byte_100371467[a2];
  if (!a2 && a3)
  {
    uint64_t result = IOLog("AppleBCMWLAN: Warning: SET_SSID status indicates success (%lu), but reason indicates failure (%lu)!\n", 0, a3);
LABEL_5:
    int v4 = 1;
  }
  if ((unsigned __int16)*v3 == 0xFFFF)
  {
LABEL_15:
    *__int16 v3 = v4;
    return result;
  }
  if (*v3) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (!v5)
  {
    uint64_t result = IOLog("AppleBCMWLAN: Warning: Auth / Assoc succeeded (%u) but SET_SSID failed (%u)!\n");
    goto LABEL_15;
  }
  if (*v3 && !v4)
  {
    uint64_t result = IOLog("AppleBCMWLAN: Warning: Auth / Assoc failed (%u) but SET_SSID succeeded (%u)!\n");
    goto LABEL_15;
  }
  return result;
}

uint64_t mapBcmSupplicantEventToAppleStatus(int a1, unsigned int a2)
{
  int v2 = 1 << a2;
  if (a1 == 5) {
    int v3 = 53;
  }
  else {
    int v3 = 1014;
  }
  if (a1 == 6) {
    int v3 = 0;
  }
  if ((v2 & 0x200001) != 0) {
    int v4 = v3;
  }
  else {
    int v4 = 0xFFFF;
  }
  if ((v2 & 0xCACE) != 0) {
    unsigned int v5 = 1014;
  }
  else {
    unsigned int v5 = v4;
  }
  if (a2 <= 0x15) {
    return v5;
  }
  else {
    return 0xFFFFLL;
  }
}

uint64_t mapBcmErrorToIOReturn(unsigned int a1)
{
  if (a1 >= 0xFFFFFFA9) {
    unsigned int v1 = -a1 | 0xE3FF8100;
  }
  else {
    unsigned int v1 = -469794560;
  }
  if (a1) {
    return v1;
  }
  else {
    return 0;
  }
}

uint64_t mapBcmStatusToApple80211IOReturnIEEEStatus(unsigned int a1)
{
  unsigned int v1 = a1 | 0xE0821000;
  if (a1 > 0x44) {
    unsigned int v1 = -469794560;
  }
  if (a1) {
    return v1;
  }
  else {
    return 0;
  }
}

uint64_t mapBcmReasonToApple80211IOReturnIEEEReason(unsigned int a1)
{
  unsigned int v1 = a1 | 0xE0823000;
  if (a1 > 0x2D) {
    unsigned int v1 = -469794560;
  }
  if (a1) {
    return v1;
  }
  else {
    return 0;
  }
}

uint64_t mapBcmStatusToApple80211IOReturnScan(unsigned int a1)
{
  unsigned int v1 = a1 | 0xE0820400;
  if (a1 > 0xFF) {
    unsigned int v1 = -469794560;
  }
  if (a1) {
    return v1;
  }
  else {
    return 0;
  }
}

uint64_t mapBcmStatusToApple80211IOReturnSupplicantStatus(unsigned int a1)
{
  unsigned int v1 = a1 | 0xE0821A00;
  if (a1 > 0xFF) {
    unsigned int v1 = -469794560;
  }
  if (a1) {
    return v1;
  }
  else {
    return 0;
  }
}

uint64_t mapBcmReasonToApple80211IOReturnPrune(int a1)
{
  if (a1 <= 23) {
    return a1 & 0x1FF | 0xE0823400;
  }
  else {
    return 3825172736;
  }
}

uint64_t mapBcmReasonToApple80211IOReturnRoam(int a1)
{
  if (a1 <= 19) {
    return a1 & 0x1FF | 0xE0820C00;
  }
  else {
    return 3825172736;
  }
}

uint64_t mapBcmReasonToApple80211IOReturnSupplicant(int a1)
{
  if (a1 <= 22) {
    return a1 & 0x1FF | 0xE0822C00;
  }
  else {
    return 3825172736;
  }
}

void _GLOBAL__sub_I_AppleBCMWLANAPIMap_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANItemRing::initWithOwnerAndActions(AppleBCMWLANItemRing *this, OSObject *a2, void (*a3)(OSObject *, ...), void (*a4)(OSObject *, AppleBCMWLANByteRing *, int, void *))
{
  uint64_t result = AppleBCMWLANByteRing::initWithOwnerAndAction(this, a2, a3);
  if (result)
  {
    uint64_t result = IOMallocZeroTyped();
    *((void *)this + 10) = result;
    if (result)
    {
      *(void *)(result + 24) = a4;
      **((void **)this + 10) = a2;
      return 1;
    }
  }
  return result;
}

uint64_t non-virtual thunk to'AppleBCMWLANItemRing::initWithOwnerAndActions(AppleBCMWLANItemRing *this, OSObject *a2, void (*a3)(OSObject *, ...), void (*a4)(OSObject *, AppleBCMWLANByteRing *, int, void *))
{
  return AppleBCMWLANItemRing::initWithOwnerAndActions((AppleBCMWLANItemRing *)((char *)this - 72), a2, a3, a4);
}

uint64_t AppleBCMWLANItemRing::free(AppleBCMWLANItemRing *this)
{
  int v2 = (void *)*((void *)this + 10);
  if (v2)
  {
    memset_s(v2, 0x20uLL, 0, 0x20uLL);
    int v3 = (void *)*((void *)this + 10);
    if (v3)
    {
      IOFree(v3, 0x20uLL);
      *((void *)this + 10) = 0;
    }
  }
  return AppleBCMWLANByteRing::free(this);
}

uint64_t AppleBCMWLANItemRing::setMMIORecorder(uint64_t this, AppleBCMWLANPCIeMMIOHistory *a2)
{
  *(void *)(*(void *)(this + 80) + 16) = a2;
  return this;
}

uint64_t AppleBCMWLANItemRing::getReadOffset(AppleBCMWLANItemRing *this)
{
  return *(_DWORD *)(*((void *)this + 10) + 12)
       * (**((unsigned int (***)(char *))this + 9))((char *)this + 72);
}

uint64_t AppleBCMWLANItemRing::getItemSize(AppleBCMWLANItemRing *this)
{
  return *(unsigned int *)(*((void *)this + 10) + 12);
}

uint64_t non-virtual thunk to'AppleBCMWLANItemRing::getReadOffset(AppleBCMWLANItemRing *this)
{
  return *(_DWORD *)(*((void *)this + 3) + 12)
       * (**((unsigned int (***)(char *))this + 2))((char *)this + 16);
}

uint64_t AppleBCMWLANItemRing::getWriteOffset(AppleBCMWLANItemRing *this)
{
  return *(_DWORD *)(*((void *)this + 10) + 12)
       * (*(unsigned int (**)(char *))(*((void *)this + 9) + 8))((char *)this + 72);
}

uint64_t non-virtual thunk to'AppleBCMWLANItemRing::getWriteOffset(AppleBCMWLANItemRing *this)
{
  return *(_DWORD *)(*((void *)this + 3) + 12)
       * (*(unsigned int (**)(char *))(*((void *)this + 2) + 8))((char *)this + 16);
}

uint64_t AppleBCMWLANItemRing::setItemSize(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 80) + 12) = a2;
  return this;
}

uint64_t AppleBCMWLANItemRing::getItemCount(AppleBCMWLANItemRing *this)
{
  return *(unsigned int *)(*((void *)this + 10) + 8);
}

uint64_t AppleBCMWLANItemRing::setItemCount(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 80) + 8) = a2;
  return this;
}

uint64_t AppleBCMWLANItemRing::getWritableByteCount(AppleBCMWLANItemRing *this)
{
  int v3 = -1431655766;
  int v4 = -1431655766;
  (*(void (**)(AppleBCMWLANItemRing *, int *, int *))(*(void *)this + 112))(this, &v3, &v4);
  return *(_DWORD *)(*((void *)this + 10) + 12)
       * ((v3 + ~v4 + *(_DWORD *)(*((void *)this + 10) + 8))
        % *(_DWORD *)(*((void *)this + 10) + 8));
}

uint64_t AppleBCMWLANItemRing::getWritableItemCount(AppleBCMWLANItemRing *this)
{
  int v3 = -1431655766;
  int v4 = -1431655766;
  (*(void (**)(AppleBCMWLANItemRing *, int *, int *))(*(void *)this + 112))(this, &v3, &v4);
  return (v3 + ~v4 + *(_DWORD *)(*((void *)this + 10) + 8))
       % *(_DWORD *)(*((void *)this + 10) + 8);
}

uint64_t non-virtual thunk to'AppleBCMWLANItemRing::getWritableByteCount(AppleBCMWLANItemRing *this)
{
  return AppleBCMWLANItemRing::getWritableByteCount((AppleBCMWLANItemRing *)((char *)this - 56));
}

uint64_t AppleBCMWLANItemRing::getReadableByteCount(AppleBCMWLANItemRing *this)
{
  unsigned int v1 = (char *)this + 72;
  int v2 = (*(uint64_t (**)(char *))(*((void *)this + 9) + 8))((char *)this + 72);
  return *(_DWORD *)(*((void *)v1 + 1) + 12)
       * ((v2 - (**(unsigned int (***)(char *))v1)(v1) + *(_DWORD *)(*((void *)v1 + 1) + 8))
        % *(_DWORD *)(*((void *)v1 + 1) + 8));
}

uint64_t AppleBCMWLANItemRing::getReadableItemCount(AppleBCMWLANItemRing *this)
{
  unsigned int v1 = (char *)this + 72;
  int v2 = (*(uint64_t (**)(char *))(*((void *)this + 9) + 8))((char *)this + 72);
  return (v2 - (**(unsigned int (***)(char *))v1)(v1) + *(_DWORD *)(*((void *)v1 + 1) + 8))
       % *(_DWORD *)(*((void *)v1 + 1) + 8);
}

uint64_t non-virtual thunk to'AppleBCMWLANItemRing::getReadableByteCount(AppleBCMWLANItemRing *this)
{
  unsigned int v1 = (char *)this + 16;
  int v2 = (*(uint64_t (**)(char *))(*((void *)this + 2) + 8))((char *)this + 16);
  return *(_DWORD *)(*((void *)v1 + 1) + 12)
       * ((v2 - (**(unsigned int (***)(char *))v1)(v1) + *(_DWORD *)(*((void *)v1 + 1) + 8))
        % *(_DWORD *)(*((void *)v1 + 1) + 8));
}

uint64_t AppleBCMWLANItemRing::getWritableItemCount(AppleBCMWLANItemRing *this, int a2, int a3)
{
  return (~a2 + a3 + *(_DWORD *)(*((void *)this + 10) + 8))
       % *(_DWORD *)(*((void *)this + 10) + 8);
}

uint64_t AppleBCMWLANItemRing::getWritableItemCountContinuous(AppleBCMWLANItemRing *this, unsigned int a2, unsigned int a3)
{
  if (a2 < a3) {
    return ~a2 + a3;
  }
  if (a3) {
    int v4 = 0;
  }
  else {
    int v4 = -1;
  }
  return v4 - a2 + *(_DWORD *)(*((void *)this + 10) + 8);
}

uint64_t AppleBCMWLANItemRing::getReadableItemCount(AppleBCMWLANItemRing *this, int a2, int a3)
{
  return (a2 - a3 + *(_DWORD *)(*((void *)this + 10) + 8)) % *(_DWORD *)(*((void *)this + 10) + 8);
}

uint64_t AppleBCMWLANItemRing::getReadableItemCountContinuous(AppleBCMWLANItemRing *this, unsigned int a2, unsigned int a3)
{
  if (a3 > a2) {
    a2 = *(_DWORD *)(*((void *)this + 10) + 8);
  }
  return a2 - a3;
}

uint64_t AppleBCMWLANItemRing::CallErrorAction(uint64_t this, uint64_t a2, void *a3)
{
  int v3 = *(void **)(this + 80);
  int v4 = (uint64_t (*)(void, uint64_t, uint64_t, void *))v3[3];
  if (v4) {
    return v4(*v3, this, a2, a3);
  }
  return this;
}

unint64_t AppleBCMWLANItemRing::hexDumpRing(AppleBCMWLANItemRing *this)
{
  int v2 = 3 * *(_DWORD *)(*((void *)this + 10) + 12);
  unsigned int v3 = v2 + 32;
  int v4 = (unsigned char *)IOMallocZeroData();
  unsigned int v5 = v4;
  if (v4) {
    *int v4 = 0;
  }
  unsigned int v6 = (char *)this + 56;
  unint64_t result = (*(uint64_t (**)(char *))(*((void *)this + 7) + 16))((char *)this + 56);
  if (result)
  {
    unint64_t v8 = 0;
    unsigned int v9 = 0;
    unsigned int v10 = v2 + 31;
    while (v8 % *(unsigned int *)(*((void *)this + 10) + 12))
    {
LABEL_23:
      unsigned int v14 = 0;
      if (v5 && v9 < v10)
      {
        uint64_t v15 = (*(uint64_t (**)(char *))(*(void *)v6 + 8))((char *)this + 56);
        unsigned int v14 = snprintf(&v5[v9], v3 - v9, " %02x", *(unsigned __int8 *)(v15 + v8));
      }
      if (v14 >= v3) {
        unsigned int v16 = v2 + 32;
      }
      else {
        unsigned int v16 = v14;
      }
      v9 += v16;
      ++v8;
      unint64_t result = (*(uint64_t (**)(char *))(*(void *)v6 + 16))((char *)this + 56);
      if (v8 >= result) {
        goto LABEL_30;
      }
    }
    if (v8)
    {
      if (v5 && v9 < v10)
      {
        snprintf(&v5[v9], v3 - v9, "\n");
      }
      else if (!v5)
      {
        unsigned int v9 = 0;
        unsigned int v11 = 0;
LABEL_19:
        if (v11 >= v3) {
          unsigned int v13 = v2 + 32;
        }
        else {
          unsigned int v13 = v11;
        }
        v9 += v13;
        goto LABEL_23;
      }
      if (AppleBCMWLANByteRing::getLogger(this))
      {
        AppleBCMWLANByteRing::getLogger(this);
        if (CCLogStream::shouldLog())
        {
          AppleBCMWLANByteRing::getLogger(this);
          CCLogStream::log();
        }
      }
      unsigned int v9 = 0;
      unsigned char *v5 = 0;
    }
    unsigned int v11 = 0;
    if (v5 && v9 < v10)
    {
      uint64_t v12 = (*(uint64_t (**)(char *))(*(void *)v6 + 8))((char *)this + 56);
      unsigned int v11 = snprintf(&v5[v9], v3 - v9, "%p:", (const void *)(v12 + v8));
    }
    goto LABEL_19;
  }
LABEL_30:
  if (v5)
  {
    if (AppleBCMWLANByteRing::getLogger(this))
    {
      AppleBCMWLANByteRing::getLogger(this);
      if (CCLogStream::shouldLog())
      {
        AppleBCMWLANByteRing::getLogger(this);
        CCLogStream::log();
      }
    }
    unsigned char *v5 = 0;
    return IOFreeData();
  }
  return result;
}

unint64_t non-virtual thunk to'AppleBCMWLANItemRing::hexDumpRing(AppleBCMWLANItemRing *this)
{
  return AppleBCMWLANItemRing::hexDumpRing((AppleBCMWLANItemRing *)((char *)this - 56));
}

AppleBCMWLANCallbackEventSource *AppleBCMWLANCallbackEventSource::withCallbacks(OSObject *this, OSObject *a2, BOOL (*a3)(OSObject *, IO80211WorkSource *))
{
  int v7 = (AppleBCMWLANCallbackEventSource *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANCallbackEventSourceMetaClass, (OSObject **)&v7)) {
    return 0;
  }
  unsigned int v5 = v7;
  if (v7 && (AppleBCMWLANCallbackEventSource::initWithCallbacks(v7, this, (void (*)(OSObject *, ...))a2) & 1) == 0)
  {
    (*(void (**)(AppleBCMWLANCallbackEventSource *))(*(void *)v5 + 16))(v5);
    return 0;
  }
  return v5;
}

uint64_t AppleBCMWLANCallbackEventSource::initWithCallbacks(AppleBCMWLANCallbackEventSource *this, OSObject *a2, void (*a3)(OSObject *, ...))
{
  uint64_t result = 0;
  if (a2)
  {
    if (a3)
    {
      uint64_t result = IO80211WorkSource::init(this, (OSObject *)this, a3);
      if (result)
      {
        uint64_t result = IOMallocZeroTyped();
        *((void *)this + 7) = result;
        if (result)
        {
          *(void *)uint64_t result = a2;
          (*(void (**)(void))(***((void ***)this + 7) + 8))(**((void **)this + 7));
          *(void *)(*((void *)this + 7) + 8) = a3;
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANCallbackEventSource::free(AppleBCMWLANCallbackEventSource *this)
{
  int v2 = (void *)*((void *)this + 7);
  if (!*v2
    || ((*(void (**)(void))(*(void *)*v2 + 16))(*v2),
        **((void **)this + 7) = 0,
        (int v2 = (void *)*((void *)this + 7)) != 0))
  {
    memset_s(v2, 0x40uLL, 0, 0x40uLL);
    unsigned int v3 = (void *)*((void *)this + 7);
    if (v3)
    {
      IOFree(v3, 0x40uLL);
      *((void *)this + 7) = 0;
    }
  }
  return IO80211WorkSource::free(this);
}

uint64_t non-virtual thunk to'AppleBCMWLANCallbackEventSource::free(AppleBCMWLANCallbackEventSource *this)
{
  return AppleBCMWLANCallbackEventSource::free((AppleBCMWLANCallbackEventSource *)((char *)this - 24));
}

uint64_t AppleBCMWLANCallbackEventSource::signalCallbackNeeded(AppleBCMWLANCallbackEventSource *this)
{
  return IO80211WorkSource::signalWorkAvailable(this);
}

uint64_t AppleBCMWLANCallbackEventSource::checkForWork(AppleBCMWLANCallbackEventSource *this)
{
  if (IO80211WorkSource::isEnabled(this))
  {
    mach_continuous_time();
    absolutetime_to_nanoseconds();
    uint64_t v2 = *((void *)this + 7);
    if (*(_DWORD *)(v2 + 56))
    {
      int v3 = 1;
      atomic_compare_exchange_strong((atomic_uint *volatile)(v2 + 56), (unsigned int *)&v3, 0);
      atomic_fetch_or((atomic_uint *volatile)(*((void *)this + 7) + 56), (*(uint64_t (**)(void, void))(*((void *)this + 7) + 8))(**((void **)this + 7), 0));
      if (*(_DWORD *)(*((void *)this + 7) + 56)) {
        IO80211WorkSource::signalWorkAvailable(this);
      }
    }
  }
  return 0;
}

uint64_t non-virtual thunk to'AppleBCMWLANCallbackEventSource::checkForWork(AppleBCMWLANCallbackEventSource *this)
{
  return 0;
}

AppleBCMWLANSensingAdapter *AppleBCMWLANSensingAdapter::withDriver(AppleBCMWLANSensingAdapter *this, AppleBCMWLANCore *a2)
{
  unsigned int v5 = (AppleBCMWLANSensingAdapter *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANSensingAdapterMetaClass, (OSObject **)&v5)) {
    return 0;
  }
  int v3 = v5;
  if (v5 && (AppleBCMWLANSensingAdapter::initWithDriver((OSObject *)v5, this) & 1) == 0)
  {
    (*(void (**)(AppleBCMWLANSensingAdapter *))(*(void *)v3 + 16))(v3);
    return 0;
  }
  return v3;
}

uint64_t AppleBCMWLANSensingAdapter::initWithDriver(OSObject *this, AppleBCMWLANCore *a2)
{
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden, const IORPC);
  const char *ClassNameHelper;

  BOOL v4 = OSObject::init(this);
  uint64_t result = 0;
  if (a2)
  {
    if (v4)
    {
      uint64_t result = IOMallocZeroTyped();
      this[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)result;
      if (result)
      {
        *(void *)(result + 8) = a2;
        this[1].isEqualTo = (BOOL (__cdecl *)(const OSMetaClassBase *__hidden, const OSMetaClassBase *))(*(uint64_t (**)(AppleBCMWLANCore *))(*(void *)a2 + 1848))(a2);
        isEqualTo = this[1].isEqualTo;
        if (isEqualTo)
        {
          (*(void (**)(BOOL (__cdecl *)(const OSMetaClassBase *__hidden, const OSMetaClassBase *)))(*(void *)isEqualTo + 8))(isEqualTo);
          this[1].release = (void (__cdecl *)(const OSObject *__hidden))AppleBCMWLANCore::getCommander(a2);
          int v7 = this[1].OSMetaClassBase::__vftable;
          release = v7->release;
          if (release)
          {
            (*(void (**)(void (__cdecl *)(const OSObject *__hidden)))(*(void *)release + 8))(release);
            this[1].Dispatch = (kern_return_t (__cdecl *)(OSObject *__hidden, const IORPC))AppleBCMWLANCore::getFaultReporter((AppleBCMWLANCore *)this[1].retain);
            unsigned int v9 = this[1].OSMetaClassBase::__vftable;
            Dispatch = v9->Dispatch;
            if (Dispatch)
            {
              (*(void (**)(kern_return_t (__cdecl *)(OSObject *__hidden, const IORPC *__struct_ptr)))(*(void *)Dispatch + 8))(Dispatch);
              LODWORD(this[1].getMetaClass) = 0;
              return 1;
            }
            if (v9->isEqualTo)
            {
              if (CCLogStream::shouldLog()) {
                CCLogStream::logAlert((CCLogStream *)this[1].isEqualTo, "[dk] %s@%d: Unable to get fFaultReporter\n");
              }
            }
          }
          else if (v7->isEqualTo && CCLogStream::shouldLog())
          {
            CCLogStream::logAlert((CCLogStream *)this[1].isEqualTo, "[dk] %s@%d: Unable to get Command Manager\n");
          }
        }
        else
        {
          ClassNameHelper = (const char *)getClassNameHelper(this);
          IOLog("%s::%s(): Unable to get debug logger\n", ClassNameHelper, "initWithDriver");
        }
        AppleBCMWLANSensingAdapter::freeResources((AppleBCMWLANSensingAdapter *)this);
        return 0;
      }
    }
  }
  return result;
}

void AppleBCMWLANSensingAdapter::free(void **this)
{
  if (this[5])
  {
    AppleBCMWLANSensingAdapter::freeResources((AppleBCMWLANSensingAdapter *)this);
    memset_s(this[5], 0x28uLL, 0, 0x28uLL);
    uint64_t v2 = this[5];
    if (v2)
    {
      IOFree(v2, 0x28uLL);
      this[5] = 0;
    }
  }
  OSObject::free((OSObject *)this);
}

uint64_t AppleBCMWLANSensingAdapter::freeResources(AppleBCMWLANSensingAdapter *this)
{
  uint64_t v2 = (void *)*((void *)this + 5);
  uint64_t v3 = v2[2];
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 16))(v3);
    *(void *)(*((void *)this + 5) + 16) = 0;
    uint64_t v2 = (void *)*((void *)this + 5);
  }
  uint64_t v4 = v2[3];
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
    *(void *)(*((void *)this + 5) + 24) = 0;
    uint64_t v2 = (void *)*((void *)this + 5);
  }
  uint64_t result = v2[4];
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
    *(void *)(*((void *)this + 5) + 32) = 0;
  }
  return result;
}

void non-virtual thunk to'AppleBCMWLANSensingAdapter::free(void **this)
{
}

uint64_t AppleBCMWLANSensingAdapter::updateSensingVersion(AppleBCMWLANSensingAdapter *this)
{
  __int16 v13 = -21846;
  if (AppleBCMWLANCore::isSensingCapable(*(AppleBCMWLANCore **)(*((void *)this + 5) + 8)))
  {
    int v12 = 0;
    v10[0] = this;
    v10[1] = AppleBCMWLANSensingAdapter::handleSensingVersion;
    void v10[2] = 0;
    v11[0] = &v12;
    v11[1] = 6;
    uint64_t v2 = *(AppleBCMWLANCommander **)(*((void *)this + 5) + 16);
    int v9 = 131074;
    uint64_t result = AppleBCMWLANCommander::sendIOVarGet(v2, (uint64_t)"csi", (uint64_t)v11, (unsigned __int16 *)&v9, (uint64_t)v10, 0);
    if (result)
    {
      uint64_t v4 = result;
      uint64_t result = *(void *)(*((void *)this + 5) + 24);
      if (result)
      {
        uint64_t result = CCLogStream::shouldLog();
        if (result)
        {
          uint64_t v7 = *((void *)this + 5);
          unint64_t v8 = *(CCLogStream **)(v7 + 24);
          (*(void (**)(void, uint64_t))(**(void **)(v7 + 8) + 112))(*(void *)(v7 + 8), v4);
          return CCLogStream::logAlert(v8, "[dk] %s@%d:Unable to get WL_CSI_SUBCMD_VERSION: %s\n");
        }
      }
    }
  }
  else
  {
    uint64_t result = *(void *)(*((void *)this + 5) + 24);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        uint64_t v5 = *((void *)this + 5);
        unsigned int v6 = *(CCLogStream **)(v5 + 24);
        AppleBCMWLANCore::isSensingCapable(*(AppleBCMWLANCore **)(v5 + 8));
        return CCLogStream::logAlert(v6, "[dk] %s@%d:Sensing not supported %d\n");
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANSensingAdapter::handleSensingVersion(uint64_t a1, uint64_t a2, int a3, unsigned __int16 **a4)
{
  if (a3)
  {
    uint64_t result = *(void *)(*(void *)(a1 + 40) + 24);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result) {
        return CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 40) + 24), "[dk] %s@%d:Unable to get sensing version from FW %d\n");
      }
    }
  }
  else if (*((unsigned __int16 *)a4 + 4) <= 1u)
  {
    uint64_t result = *(void *)(*(void *)(a1 + 40) + 24);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result) {
        return CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 40) + 24), "[dk] %s@%d:Payload length is not of expected value, expected %zu, received %u\n");
      }
    }
  }
  else
  {
    **(_DWORD **)(a1 + 40) = **a4;
    uint64_t result = *(void *)(*(void *)(a1 + 40) + 24);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result) {
        return CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 40) + 24), "[dk] %s@%d:Sensing adapter version is %d\n");
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANSensingAdapter::handleSensingEvent(uint64_t a1, uint64_t a2)
{
  int v4 = mapBcmStatusToApple80211IOReturnScan(*(_DWORD *)(a2 + 8));
  return AppleBCMWLANCore::postMessageInfra(*(AppleBCMWLANCore **)(*(void *)(a1 + 40) + 8), 0xC1u, &v4, 4uLL);
}

uint64_t AppleBCMWLANSensingAdapter::setSENSING_ENABLE(uint64_t a1)
{
  int v8 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  long long v17 = 0u;
  memset(v18, 0, sizeof(v18));
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 40) + 8) + 88))(*(void *)(*(void *)(a1 + 40) + 8));
  if ((*(uint64_t (**)(uint64_t))(*(void *)v2 + 136))(v2)) {
    return 3766626305;
  }
  uint64_t v3 = 3758097095;
  if (AppleBCMWLANCore::isSensingCapable(*(AppleBCMWLANCore **)(*(void *)(a1 + 40) + 8)))
  {
    if (AppleBCMWLANCore::isSensingOSFeatureFlagEnabled(*(AppleBCMWLANCore **)(*(void *)(a1 + 40) + 8)))
    {
      uint64_t v4 = *(void *)(a1 + 40);
      if (*(_DWORD *)v4)
      {
        if (AppleBCMWLANCore::isAssociated(*(AppleBCMWLANCore **)(v4 + 8)))
        {
          AppleBCMWLANCore::getBssManager(*(AppleBCMWLANCore **)(*(void *)(a1 + 40) + 8));
          IO80211BssManager::getCurrentBand();
          AppleBCMWLANCore::getBssManager(*(AppleBCMWLANCore **)(*(void *)(a1 + 40) + 8));
          IO80211BssManager::getCurrentChannel();
        }
      }
    }
  }
  return v3;
}

uint64_t AppleBCMWLANSensingAdapter::setSENSING_DISABLE(uint64_t a1)
{
  __int16 v11 = -21846;
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 40) + 8) + 88))(*(void *)(*(void *)(a1 + 40) + 8));
  if ((*(uint64_t (**)(uint64_t))(*(void *)v2 + 136))(v2)) {
    return 3766626305;
  }
  uint64_t v3 = 3758097095;
  if (AppleBCMWLANCore::isSensingCapable(*(AppleBCMWLANCore **)(*(void *)(a1 + 40) + 8)))
  {
    if (AppleBCMWLANCore::isSensingOSFeatureFlagEnabled(*(AppleBCMWLANCore **)(*(void *)(a1 + 40) + 8)))
    {
      uint64_t v4 = *(void *)(a1 + 40);
      if (*(_DWORD *)v4)
      {
        int v10 = 1;
        v9[0] = &v10;
        v9[1] = 6;
        uint64_t v3 = AppleBCMWLANCommander::runIOVarSet(*(AppleBCMWLANCommander **)(v4 + 16), (uint64_t)"csi", (uint64_t)v9, 0, 0);
        if (v3)
        {
          if (*(void *)(*(void *)(a1 + 40) + 24) && CCLogStream::shouldLog())
          {
            uint64_t v6 = *(void *)(a1 + 40);
            uint64_t v7 = *(CCLogStream **)(v6 + 24);
            int v8 = (const char *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 8) + 112))(*(void *)(v6 + 8), v3);
            CCLogStream::logAlert(v7, "[dk] %s@%d:Unable to set WL_CSI_SUBCMD_DISABLE: %s\n", "setSENSING_DISABLE", 341, v8);
          }
        }
      }
    }
  }
  return v3;
}

uint64_t AppleBCMWLANSensingAdapter::getSENSING_DATA(uint64_t a1, _DWORD *a2)
{
  uint64_t MaxCmdRxPayload = AppleBCMWLANCommander::getMaxCmdRxPayload(*(AppleBCMWLANCommander **)(*(void *)(a1 + 40) + 16));
  *a2 = 1;
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 40) + 8) + 88))(*(void *)(*(void *)(a1 + 40) + 8));
  if ((*(uint64_t (**)(uint64_t))(*(void *)v5 + 136))(v5)) {
    return 3766626305;
  }
  uint64_t v6 = 3758097095;
  if (AppleBCMWLANCore::isSensingCapable(*(AppleBCMWLANCore **)(*(void *)(a1 + 40) + 8))
    && AppleBCMWLANCore::isSensingOSFeatureFlagEnabled(*(AppleBCMWLANCore **)(*(void *)(a1 + 40) + 8)))
  {
    uint64_t v7 = IOMallocZeroData();
    int v8 = (_DWORD *)v7;
    if (v7)
    {
      unsigned int v9 = 0;
      unsigned int v10 = 0;
      int v11 = 0;
      int v12 = 0;
      uint64_t v29 = (unsigned int *)v7;
      if ((_WORD)MaxCmdRxPayload) {
        uint64_t v13 = v7;
      }
      else {
        uint64_t v13 = 0;
      }
      char v27 = a2;
      uint64_t v28 = v13;
      size_t v26 = (const void *)(v7 + 12);
      while (1)
      {
        unsigned int v32 = 0;
        uint64_t v33 = 0;
        uint64_t v30 = 0;
        uint64_t v31 = 0;
        long long v14 = (_DWORD *)IOMallocZeroData();
        if (!v14)
        {
          uint64_t v6 = 3758097085;
          goto LABEL_34;
        }
        v12 += v9;
        _DWORD *v14 = 524292;
        v14[1] = v12;
        void v14[2] = -1;
        unsigned int v32 = v14;
        uint64_t v33 = 14;
        uint64_t v30 = v28;
        uint64_t v31 = 0x100010001 * (unsigned __int16)MaxCmdRxPayload;
        uint64_t v15 = AppleBCMWLANCommander::runIOVarGet(*(AppleBCMWLANCommander **)(*(void *)(a1 + 40) + 16), (uint64_t)"csi", (uint64_t)&v32, (uint64_t)&v30, 0);
        uint64_t v6 = v15;
        if (**(_DWORD **)(a1 + 40) == 1 && v15 != 0)
        {
          unsigned int v17 = 0;
          do
          {
            AppleBCMWLANCore::waitForDriverEvent(*(void **)(*(void *)(a1 + 40) + 8), 6u, 0xAu);
            uint64_t v18 = AppleBCMWLANCommander::runIOVarGet(*(AppleBCMWLANCommander **)(*(void *)(a1 + 40) + 16), (uint64_t)"csi", (uint64_t)&v32, (uint64_t)&v30, 0);
            if (v18) {
              BOOL v19 = v17 >= 9;
            }
            else {
              BOOL v19 = 1;
            }
            ++v17;
          }
          while (!v19);
          uint64_t v6 = v18;
        }
        if (v6) {
          break;
        }
        unsigned int v20 = *v29;
        unsigned int v9 = v29[2];
        unsigned int v21 = v9 + v12;
        if (((v9 + v12) & 0x3FFFFC00) == 0) {
          memcpy(&v27[v12 + 20], v26, 4 * v9);
        }
        ++v11;
        IOFreeData();
        unsigned int v10 = v20;
        if (v21 >= v20 || ((v9 + v12) & 0x3FFFFC00) != 0)
        {
          v27[1044] = 4 * v21;
          AppleBCMWLANSensingAdapter::getSENSING_DATA_INFO(a1, (uint64_t)(v27 + 1));
          uint64_t v6 = 0;
          goto LABEL_34;
        }
      }
      if (*(void *)(*(void *)(a1 + 40) + 24) && CCLogStream::shouldLog())
      {
        uint64_t v23 = *(void *)(a1 + 40);
        uint64_t v24 = *(CCLogStream **)(v23 + 24);
        unsigned int v25 = (const char *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v23 + 8) + 112))(*(void *)(v23 + 8), v6);
        CCLogStream::logAlert(v24, "[dk] %s@%d:Unable to get WL_CSI_SUBCMD_GET_DATA: %s\n", "getSENSING_DATA", 423, v25);
      }
      IOFreeData();
LABEL_34:
      int v8 = v29;
    }
    else
    {
      unsigned int v10 = 0;
      int v11 = 0;
      uint64_t v6 = 3758097085;
    }
    if (*(void *)(*(void *)(a1 + 40) + 24) && CCLogStream::shouldLog())
    {
      CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 40) + 24), "[dk] %s@%d:CSI data read - #fragments %d, total_length: %d bytes, data_size: %d bytes, rx_buffer_total_len %lld\n", "getSENSING_DATA", 453, v11, 4 * v10, 4, MaxCmdRxPayload);
      if (!v8) {
        return v6;
      }
    }
    else if (!v8)
    {
      return v6;
    }
    IOFreeData();
  }
  return v6;
}

uint64_t AppleBCMWLANSensingAdapter::getSENSING_DATA_INFO(uint64_t a1, uint64_t a2)
{
  __int16 v25 = -21846;
  int v24 = 3;
  v22[0] = &v24;
  v22[1] = 6;
  memset(v23, 0, 30);
  v21[0] = v23;
  v21[1] = 0x1E001E001ELL;
  uint64_t v4 = AppleBCMWLANCommander::runIOVarGet(*(AppleBCMWLANCommander **)(*(void *)(a1 + 40) + 16), (uint64_t)"csi", (uint64_t)v22, (uint64_t)v21, 0);
  uint64_t v5 = v4;
  if (**(_DWORD **)(a1 + 40) == 1 && v4 != 0)
  {
    unsigned int v7 = 0;
    do
    {
      AppleBCMWLANCore::waitForDriverEvent(*(void **)(*(void *)(a1 + 40) + 8), 6u, 0xAu);
      uint64_t v8 = AppleBCMWLANCommander::runIOVarGet(*(AppleBCMWLANCommander **)(*(void *)(a1 + 40) + 16), (uint64_t)"csi", (uint64_t)v22, (uint64_t)v21, 0);
      if (v8) {
        BOOL v9 = v7 >= 9;
      }
      else {
        BOOL v9 = 1;
      }
      ++v7;
    }
    while (!v9);
    uint64_t v5 = v8;
  }
  uint64_t v10 = *(void *)(a1 + 40);
  if (v5)
  {
    if (*(void *)(v10 + 24) && CCLogStream::shouldLog())
    {
      uint64_t v11 = *(void *)(a1 + 40);
      int v12 = *(CCLogStream **)(v11 + 24);
      uint64_t v13 = (const char *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v11 + 8) + 112))(*(void *)(v11 + 8), v5);
      CCLogStream::logAlert(v12, "[dk] %s@%d:Unable to get WL_CSI_SUBCMD_DATA_INFO: %s\n", "getSENSING_DATA_INFO", 492, v13);
    }
  }
  else
  {
    if (AppleBCMWLANCore::isAssociated(*(AppleBCMWLANCore **)(v10 + 8)))
    {
      AppleBCMWLANCore::getBssManager(*(AppleBCMWLANCore **)(*(void *)(a1 + 40) + 8));
      IO80211BssManager::getCurrentChannel();
    }
    *(_OWORD *)a2 = v23[0];
    *(_WORD *)(a2 + 16) = v23[1];
    int v15 = WORD2(v23[1]);
    *(_DWORD *)(a2 + 24) = 0;
    *(_DWORD *)(a2 + 28) = v15;
    *(_DWORD *)(a2 + 20) = WORD1(v23[1]);
    v14.i32[0] = *(_DWORD *)((char *)&v23[1] + 6);
    *(uint32x4_t *)(a2 + 32) = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v14));
    *(_DWORD *)(a2 + 48) = BYTE10(v23[1]);
    LODWORD(v16) = BYTE11(v23[1]);
    if (BYTE11(v23[1]) < 5u)
    {
      *(_DWORD *)(a2 + 56) = BYTE11(v23[1]);
      if (!v16) {
        return v5;
      }
    }
    else
    {
      LODWORD(v16) = 4;
      *(_DWORD *)(a2 + 56) = 4;
    }
    uint64_t v16 = v16;
    unsigned int v17 = (char *)&v23[1] + 12;
    uint64_t v18 = (_DWORD *)(a2 + 60);
    do
    {
      int v19 = *v17++;
      *v18++ = v19;
      --v16;
    }
    while (v16);
  }
  return v5;
}

void _GLOBAL__sub_I_AppleBCMWLANSensingAdapter_cpp()
{
  kNullRange = 0;
}

OSObject *AppleBCMWLANChipManagerPCIe4378::withChip(AppleBCMWLANChipManagerPCIe4378 *this, uint64_t a2)
{
  uint64_t v6 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANChipManagerPCIe4378MetaClass, &v6)) {
    return 0;
  }
  uint64_t v4 = v6;
  if (v6
    && (((uint64_t (*)(OSObject *, AppleBCMWLANChipManagerPCIe4378 *, uint64_t))v6->OSMetaClassBase::__vftable[4].isEqualTo)(v6, this, a2) & 1) == 0)
  {
    ((void (*)(OSObject *))v4->release)(v4);
    return 0;
  }
  return v4;
}

BOOL AppleBCMWLANChipManagerPCIe4378::initWithChip(OSObject *this, int a2)
{
  BOOL result = AppleBCMWLANChipManagerPCIe::init(this);
  if (result)
  {
    AppleBCMWLANChipManagerPCIe::setOTPCoreID((uint64_t)this, 0);
    AppleBCMWLANChipManagerPCIe::setAWDLSupported((AppleBCMWLANChipManagerPCIe *)this, 1);
    AppleBCMWLANChipManagerPCIe::setChipNumber((uint64_t)this, a2);
    AppleBCMWLANChipManagerPCIe::setCoreCount((uint64_t)this, 9);
    AppleBCMWLANChipManagerPCIe::setCoreRegionList((uint64_t)this, (uint64_t)&kBCOM4378ChipCores);
    AppleBCMWLANChipManagerPCIe::setWrapperCount((uint64_t)this, 17);
    AppleBCMWLANChipManagerPCIe::setWrapperRegionList((uint64_t)this, (uint64_t)&kBCOM4378ChipWrappers);
    AppleBCMWLANChipManagerPCIe::setMemoryCount((uint64_t)this, 7);
    AppleBCMWLANChipManagerPCIe::setMemoryRegionList((uint64_t)this, (uint64_t)&kBCOM4378ChipMemories);
    AppleBCMWLANChipManagerPCIe::setBackplaneWindowCount((uint64_t)this, 8);
    AppleBCMWLANChipManagerPCIe::setBackplaneWindows((uint64_t)this, (uint64_t)&kBCOM4378ChipBackplaneWindows);
    AppleBCMWLANChipManagerPCIe::setOTPCoreID((uint64_t)this, 8);
    AppleBCMWLANChipManagerPCIe::setUserOTPRange((uint64_t)this, (uint64_t)&kBCOM4378ChipUserOTP);
    AppleBCMWLANChipManagerPCIe::setChipOTPRange((uint64_t)this, (uint64_t)&kBCOM4378ChipOTP);
    AppleBCMWLANChipManagerPCIe::setCoreIDTable((uint64_t)this, kBCOM4378CoreIDTable);
    AppleBCMWLANChipManagerPCIe::setUCodeRegionInfo((uint64_t)this, (uint64_t)&kBCOM4378UCodeSCRRegionInfo, 0);
    AppleBCMWLANChipManagerPCIe::setUCodeRegionInfo((uint64_t)this, (uint64_t)&kBCOM4378UCodeSHMRegionInfo, 1);
    AppleBCMWLANChipManagerPCIe::setConfigSpaceSaveRange((uint64_t)this, (uint64_t)&kBCOM4378ChipConfigSpaceStateTable);
    AppleBCMWLANChipManagerPCIe::setConfigSpaceSaveCount((uint64_t)this, 3);
    AppleBCMWLANChipManagerPCIe::setMemoryRAMAddress((uint64_t)this, 3481600);
    AppleBCMWLANChipManagerPCIe::setPCIeHeaderLength((uint64_t)this, 256);
    AppleBCMWLANChipManagerPCIe::setSROMVersion((uint64_t)this, 16);
    AppleBCMWLANChipManagerPCIe::setSROMWordCount((uint64_t)this, 1024);
    AppleBCMWLANChipManagerPCIe::setSROMSignature((uint64_t)this, 4378);
    AppleBCMWLANChipManagerPCIe::setMultiFunctionChip((uint64_t)this, 1);
    AppleBCMWLANChipManagerPCIe::setSafeToCaptureSoCRAM((uint64_t)this, 1);
    AppleBCMWLANChipManagerPCIe::setHMAPSupported((uint64_t)this, 1);
    AppleBCMWLANChipManagerPCIe::setTrapBeforeFLRUnSupported((uint64_t)this, 0);
    AppleBCMWLANChipManagerPCIe::setHMAPBaseAddress((uint64_t)this, 1408);
    AppleBCMWLANChipManagerPCIe::sethostWakeToggleNotConfigured((uint64_t)this, 1);
    AppleBCMWLANChipManagerPCIe::setPowerControlRequired((uint64_t)this, 1);
    int v10 = 0;
    while (1)
    {
      uint64_t BackplaneWindows = AppleBCMWLANChipManagerPCIe::getBackplaneWindows((AppleBCMWLANChipManagerPCIe *)this);
      unsigned int PacketCount = AppleBCMWLANPCIeFlowQueue::getPacketCount((AppleBCMWLANPCIeFlowQueue *)this);
      if (!AppleBCMWLANChipManagerPCIe::findRemappableWindow(BackplaneWindows, PacketCount, 0, &v10)) {
        break;
      }
      AppleBCMWLANChipManagerPCIe::incrementCoreRemapperCount((uint64_t)this);
    }
    int v10 = 0;
    while (1)
    {
      uint64_t v7 = AppleBCMWLANChipManagerPCIe::getBackplaneWindows((AppleBCMWLANChipManagerPCIe *)this);
      unsigned int v8 = AppleBCMWLANPCIeFlowQueue::getPacketCount((AppleBCMWLANPCIeFlowQueue *)this);
      if (!AppleBCMWLANChipManagerPCIe::findRemappableWindow(v7, v8, 1, &v10)) {
        break;
      }
      AppleBCMWLANChipManagerPCIe::incrementWrapperRemapperCount((uint64_t)this);
    }
    BOOL v9 = OSDictionary::withCapacity(0x20u);
    return AppleBCMWLANChipManagerPCIe::setChipProvisioningData((AppleBCMWLANChipManagerPCIe *)this, v9);
  }
  return result;
}

BOOL non-virtual thunk to'AppleBCMWLANChipManagerPCIe4378::initWithChip(AppleBCMWLANChipManagerPCIe4378 *this, int a2)
{
  return AppleBCMWLANChipManagerPCIe4378::initWithChip((OSObject *)((char *)this - 56), a2);
}

uint64_t AppleBCMWLANChipManagerPCIe4378::prepareHardware(AppleBCMWLANChipManagerPCIe4378 *this, AppleBCMWLANChipConfigSpace *a2, AppleBCMWLANChipBackplane *a3)
{
  uint64_t v3 = 3758097090;
  unsigned int v6 = 0;
  if (a2 && a3)
  {
    if (AppleBCMWLANChipBackplane::readGCICoreReg32(a3, 0xE64u, &v6))
    {
      return 3758097098;
    }
    else
    {
      unsigned int v6 = v6 & 0xFFFFFFFC | 1;
      AppleBCMWLANChipBackplane::writeGCICoreReg32(a3, 0xE64u, v6);
      return 0;
    }
  }
  return v3;
}

uint64_t AppleBCMWLANChipManagerPCIe4378::checkHardware(AppleBCMWLANChipManagerPCIe4378 *this, AppleBCMWLANChipConfigSpace *a2, AppleBCMWLANChipBackplane *a3)
{
  unsigned int v6 = 0;
  uint64_t result = 3758097090;
  if (a2 && a3)
  {
    AppleBCMWLANChipBackplane::writeGCICoreReg32(a3, 0x40u, 4u);
    if (AppleBCMWLANChipBackplane::readGCICoreReg32(a3, 0x204u, &v6) || (v6 & 0x4000) != 0)
    {
      return 3758097098;
    }
    else
    {
      int v5 = AppleBCMWLANChipBackplane::readGCICoreReg32(a3, 0x40u, &v6);
      uint64_t result = 3758097098;
      if (!v5)
      {
        if (v6 == 4) {
          return 0;
        }
        else {
          return 3758097098;
        }
      }
    }
  }
  return result;
}

void _GLOBAL__sub_I_AppleBCMWLANChipManagerPCIe4378_cpp()
{
  kNullRange = 0;
}

OSObject *AppleBCMWLANChipConfigSpace::withPCIDevice(AppleBCMWLANChipConfigSpace *this, IOPCIDevice *a2, AppleBCMWLANPCIeMMIOHistory *a3)
{
  uint64_t v7 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANChipConfigSpaceMetaClass, &v7)) {
    return 0;
  }
  int v5 = v7;
  if (v7
    && (((uint64_t (*)(OSObject *, AppleBCMWLANChipConfigSpace *, IOPCIDevice *))v7->OSMetaClassBase::__vftable[1].getMetaClass)(v7, this, a2) & 1) == 0)
  {
    ((void (*)(OSObject *))v5->release)(v5);
    return 0;
  }
  return v5;
}

uint64_t AppleBCMWLANChipConfigSpace::initWithPCIDevice(OSObject *this, IOPCIDevice *a2, AppleBCMWLANPCIeMMIOHistory *a3)
{
  uint64_t result = OSObject::init(this);
  if (result)
  {
    uint64_t result = IOMallocZeroTyped();
    *(void *)&this[1].refcount = result;
    if (result)
    {
      *(void *)uint64_t result = a2;
      uint64_t result = **(void **)&this[1].refcount;
      if (result)
      {
        (*(void (**)(uint64_t))(*(void *)result + 8))(result);
        if (a3)
        {
          *(void *)(*(void *)&this[1].refcount + 8) = a3;
          (*(void (**)(void))(**(void **)(*(void *)&this[1].refcount + 8) + 8))(*(void *)(*(void *)&this[1].refcount + 8));
        }
        return 1;
      }
    }
  }
  return result;
}

uint64_t non-virtual thunk to'AppleBCMWLANChipConfigSpace::initWithPCIDevice(OSObject *this, IOPCIDevice *a2, AppleBCMWLANPCIeMMIOHistory *a3)
{
  return AppleBCMWLANChipConfigSpace::initWithPCIDevice(this - 1, a2, a3);
}

void AppleBCMWLANChipConfigSpace::free(OSObject *this)
{
  uint64_t v2 = *(void **)&this[1].refcount;
  if (v2)
  {
    if (*v2)
    {
      (*(void (**)(void))(*(void *)*v2 + 16))(*v2);
      **(void **)&this[1].refcount = 0;
      uint64_t v2 = *(void **)&this[1].refcount;
    }
    uint64_t v3 = v2[1];
    if (v3)
    {
      (*(void (**)(void))(*(void *)v3 + 16))(v2[1]);
      *(void *)(*(void *)&this[1].refcount + 8) = 0;
      uint64_t v2 = *(void **)&this[1].refcount;
    }
    memset_s(v2, 0x10uLL, 0, 0x10uLL);
    uint64_t v4 = *(void **)&this[1].refcount;
    if (v4)
    {
      IOFree(v4, 0x10uLL);
      *(void *)&this[1].refcount = 0;
    }
  }
  OSObject::free(this);
}

void non-virtual thunk to'AppleBCMWLANChipConfigSpace::free(AppleBCMWLANChipConfigSpace *this)
{
}

uint64_t AppleBCMWLANChipConfigSpace::readReg8(AppleBCMWLANChipConfigSpace *this, unsigned int a2, unsigned __int8 *a3)
{
  uint8_t readData = 0;
  uint64_t v6 = *((void *)this + 6);
  uint64_t v7 = *(AppleBCMWLANPCIeMMIOHistory **)(v6 + 8);
  if (v7)
  {
    AppleBCMWLANPCIeMMIOHistory::recordMMIOConfig(v7, a2, 0, 1, 1, 1);
    uint64_t v6 = *((void *)this + 6);
  }
  IOPCIDevice::ConfigurationRead8(*(IOPCIDevice **)v6, a2, &readData);
  unsigned int v8 = readData;
  *a3 = readData;
  BOOL v9 = *(AppleBCMWLANPCIeMMIOHistory **)(*((void *)this + 6) + 8);
  if (v9)
  {
    AppleBCMWLANPCIeMMIOHistory::recordMMIOConfig(v9, a2, v8, 1, 1, 0);
    unsigned int v8 = *a3;
  }
  if (v8 == 255) {
    return 3825173258;
  }
  else {
    return 0;
  }
}

uint64_t AppleBCMWLANChipConfigSpace::modifyReg16(AppleBCMWLANChipConfigSpace *this, unsigned int a2, int a3, int a4, unsigned __int16 *a5)
{
  unsigned __int16 v13 = 0;
  uint64_t v10 = AppleBCMWLANChipConfigSpace::readReg16(this, a2, &v13);
  if (!v10)
  {
    int v11 = v13;
    if (a5) {
      *a5 = v13;
    }
    AppleBCMWLANChipConfigSpace::writeReg16(this, a2, v11 & ~a3 | a4);
  }
  return v10;
}

uint64_t AppleBCMWLANChipConfigSpace::readReg16(AppleBCMWLANChipConfigSpace *this, unsigned int a2, unsigned __int16 *a3)
{
  uint16_t readData = 0;
  uint64_t v6 = *((void *)this + 6);
  uint64_t v7 = *(AppleBCMWLANPCIeMMIOHistory **)(v6 + 8);
  if (v7)
  {
    AppleBCMWLANPCIeMMIOHistory::recordMMIOConfig(v7, a2, 0, 2, 1, 1);
    uint64_t v6 = *((void *)this + 6);
  }
  IOPCIDevice::ConfigurationRead16(*(IOPCIDevice **)v6, a2, &readData);
  unsigned int v8 = readData;
  *a3 = readData;
  BOOL v9 = *(AppleBCMWLANPCIeMMIOHistory **)(*((void *)this + 6) + 8);
  if (v9)
  {
    AppleBCMWLANPCIeMMIOHistory::recordMMIOConfig(v9, a2, v8, 2, 1, 0);
    unsigned int v8 = *a3;
  }
  if (v8 == 0xFFFF) {
    return 3825173258;
  }
  else {
    return 0;
  }
}

AppleBCMWLANPCIeMMIOHistory *AppleBCMWLANChipConfigSpace::writeReg16(AppleBCMWLANChipConfigSpace *this, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *((void *)this + 6);
  uint64_t v7 = *(AppleBCMWLANPCIeMMIOHistory **)(v6 + 8);
  if (v7)
  {
    AppleBCMWLANPCIeMMIOHistory::recordMMIOConfig(v7, a2, a3, 2, 0, 1);
    uint64_t v6 = *((void *)this + 6);
  }
  IOPCIDevice::ConfigurationWrite16(*(IOPCIDevice **)v6, a2, a3);
  uint64_t result = *(AppleBCMWLANPCIeMMIOHistory **)(*((void *)this + 6) + 8);
  if (result)
  {
    return (AppleBCMWLANPCIeMMIOHistory *)AppleBCMWLANPCIeMMIOHistory::recordMMIOConfig(result, a2, a3, 2, 0, 0);
  }
  return result;
}

uint64_t AppleBCMWLANChipConfigSpace::modifyReg32(AppleBCMWLANChipConfigSpace *this, unsigned int a2, int a3, int a4, unsigned int *a5)
{
  unsigned int v13 = 0;
  uint64_t v10 = AppleBCMWLANChipConfigSpace::readReg32(this, a2, &v13);
  if (!v10)
  {
    unsigned int v11 = v13;
    if (a5) {
      *a5 = v13;
    }
    AppleBCMWLANChipConfigSpace::writeReg32(this, a2, v11 & ~a3 | a4);
  }
  return v10;
}

uint64_t AppleBCMWLANChipConfigSpace::readReg32(AppleBCMWLANChipConfigSpace *this, unsigned int a2, unsigned int *a3)
{
  uint32_t readData = 0;
  uint64_t v6 = *((void *)this + 6);
  uint64_t v7 = *(AppleBCMWLANPCIeMMIOHistory **)(v6 + 8);
  if (v7)
  {
    AppleBCMWLANPCIeMMIOHistory::recordMMIOConfig(v7, a2, 0, 4, 1, 1);
    uint64_t v6 = *((void *)this + 6);
  }
  IOPCIDevice::ConfigurationRead32(*(IOPCIDevice **)v6, a2, &readData);
  uint32_t v8 = readData;
  *a3 = readData;
  BOOL v9 = *(AppleBCMWLANPCIeMMIOHistory **)(*((void *)this + 6) + 8);
  if (v9)
  {
    AppleBCMWLANPCIeMMIOHistory::recordMMIOConfig(v9, a2, v8, 4, 1, 0);
    uint32_t v8 = *a3;
  }
  if (v8 == -1) {
    return 3825173258;
  }
  else {
    return 0;
  }
}

AppleBCMWLANPCIeMMIOHistory *AppleBCMWLANChipConfigSpace::writeReg32(AppleBCMWLANChipConfigSpace *this, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *((void *)this + 6);
  uint64_t v7 = *(AppleBCMWLANPCIeMMIOHistory **)(v6 + 8);
  if (v7)
  {
    AppleBCMWLANPCIeMMIOHistory::recordMMIOConfig(v7, a2, a3, 4, 0, 1);
    uint64_t v6 = *((void *)this + 6);
  }
  IOPCIDevice::ConfigurationWrite32(*(IOPCIDevice **)v6, a2, a3);
  uint64_t result = *(AppleBCMWLANPCIeMMIOHistory **)(*((void *)this + 6) + 8);
  if (result)
  {
    return (AppleBCMWLANPCIeMMIOHistory *)AppleBCMWLANPCIeMMIOHistory::recordMMIOConfig(result, a2, a3, 4, 0, 0);
  }
  return result;
}

uint64_t AppleBCMWLANChipConfigSpace::dumpConfigSpaceRegisters(AppleBCMWLANChipConfigSpace *this, char *a2, size_t a3)
{
  uint64_t v3 = 3825172738;
  if (a3 >> 5 >= 0xD7)
  {
    size_t v4 = a3;
    unsigned int v15 = -1431655766;
    unsigned __int16 v14 = -21846;
    bzero(a2, a3);
    uint64_t v7 = 0;
    int v8 = 0;
    int v9 = 0;
    while (1)
    {
      int v10 = v9;
      int v9 = AppleBCMWLANChipConfigSpace::dumpConfigSpaceRegisters(char *,unsigned long)::configSpaceRegs[v7];
      if ((v9 - v10) < 4)
      {
        int v11 = AppleBCMWLANChipConfigSpace::readReg16(this, AppleBCMWLANChipConfigSpace::dumpConfigSpaceRegisters(char *,unsigned long)::configSpaceRegs[v7], &v14);
        unsigned int v15 = v14;
        if (v11) {
          return 3825173258;
        }
      }
      else if (AppleBCMWLANChipConfigSpace::readReg32(this, AppleBCMWLANChipConfigSpace::dumpConfigSpaceRegisters(char *,unsigned long)::configSpaceRegs[v7], &v15))
      {
        return 3825173258;
      }
      int v12 = snprintf(&a2[v8], v4, "[%03x]%s: 0x%08x \n", v9, *(const char **)&AppleBCMWLANChipConfigSpace::dumpConfigSpaceRegisters(char *,unsigned long)::configSpaceRegs[v7 + 2], v15);
      if (v12 < 1 || v4 <= v12) {
        return v3;
      }
      v7 += 4;
      v8 += v12;
      v4 -= v12;
      if (v7 == 344) {
        return 0;
      }
    }
  }
  return v3;
}

uint64_t AppleBCMWLANChipConfigSpace::getBus(IOPCIDevice ***this)
{
  uint8_t returnFunctionNumber;
  uint8_t returnDeviceNumber;
  uint8_t returnBusNumber;

  returnBusNumber = -86;
  returnDeviceNumber = -86;
  returnFunctionNumber = -86;
  IOPCIDevice::GetBusDeviceFunction(*this[6], &returnBusNumber, &returnDeviceNumber, &returnFunctionNumber, 0);
  return returnBusNumber;
}

uint64_t AppleBCMWLANChipConfigSpace::getDevice(IOPCIDevice ***this)
{
  uint8_t returnFunctionNumber;
  uint8_t returnDeviceNumber;
  uint8_t returnBusNumber;

  returnBusNumber = -86;
  returnDeviceNumber = -86;
  returnFunctionNumber = -86;
  IOPCIDevice::GetBusDeviceFunction(*this[6], &returnBusNumber, &returnDeviceNumber, &returnFunctionNumber, 0);
  return returnDeviceNumber;
}

uint64_t AppleBCMWLANChipConfigSpace::getFunction(IOPCIDevice ***this)
{
  uint8_t returnFunctionNumber;
  uint8_t returnDeviceNumber;
  uint8_t returnBusNumber;

  returnBusNumber = -86;
  returnDeviceNumber = -86;
  returnFunctionNumber = -86;
  IOPCIDevice::GetBusDeviceFunction(*this[6], &returnBusNumber, &returnDeviceNumber, &returnFunctionNumber, 0);
  return returnFunctionNumber;
}

uint64_t AppleBCMWLANChipConfigSpace::findCapability(IOPCIDevice ***this, uint32_t a2, uint64_t searchOffset)
{
  uint64_t v4 = searchOffset;
  if (IOPCIDevice::FindPCICapability(*this[6], a2, searchOffset, &v4, 0)) {
    return 0;
  }
  else {
    return v4;
  }
}

void _GLOBAL__sub_I_AppleBCMWLANChipConfigSpace_cpp()
{
  kNullRange = 0;
}

OSObject *AppleBCMWLANWorkOrder::withID(AppleBCMWLANWorkOrder *this)
{
  uint64_t v4 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANWorkOrderMetaClass, &v4)) {
    return 0;
  }
  uint64_t v2 = v4;
  if (v4
    && (((uint64_t (*)(OSObject *, AppleBCMWLANWorkOrder *))v4->OSMetaClassBase::__vftable[1].getMetaClass)(v4, this) & 1) == 0)
  {
    ((void (*)(OSObject *))v2->release)(v2);
    return 0;
  }
  return v2;
}

uint64_t AppleBCMWLANWorkOrder::initWithID(AppleBCMWLANWorkOrder *this, int a2)
{
  uint64_t result = IOCommand::init(this);
  if (result)
  {
    uint64_t v5 = IOMallocZeroTyped();
    *((void *)this + 7) = v5;
    if (v5)
    {
      *(_DWORD *)(v5 + 60) = a2;
      return 1;
    }
    else
    {
      IOLog("Failed to allocate AppleBCMWLANWorkOrder_IVars\n");
      return 0;
    }
  }
  return result;
}

uint64_t non-virtual thunk to'AppleBCMWLANWorkOrder::initWithID(AppleBCMWLANWorkOrder *this, int a2)
{
  return AppleBCMWLANWorkOrder::initWithID((AppleBCMWLANWorkOrder *)((char *)this - 48), a2);
}

uint64_t AppleBCMWLANWorkOrder::free(AppleBCMWLANWorkOrder *this)
{
  uint64_t v2 = (void *)*((void *)this + 7);
  if (v2)
  {
    memset_s(v2, 0x60uLL, 0, 0x60uLL);
    uint64_t v3 = (void *)*((void *)this + 7);
    if (v3)
    {
      IOFree(v3, 0x60uLL);
      *((void *)this + 7) = 0;
    }
  }
  return IOCommand::free(this);
}

uint64_t non-virtual thunk to'AppleBCMWLANWorkOrder::free(AppleBCMWLANWorkOrder *this)
{
  return AppleBCMWLANWorkOrder::free((AppleBCMWLANWorkOrder *)((char *)this - 24));
}

uint64_t AppleBCMWLANWorkOrder::execute(AppleBCMWLANWorkOrder *this)
{
  *(_DWORD *)(*((void *)this + 7) + 64) = 2;
  *(void *)(*((void *)this + 7) + 80) = mach_continuous_time();
  uint64_t result = (**((uint64_t (***)(void, void, uint64_t))this + 7))(*(void *)(*((void *)this + 7) + 8), *(void *)(*((void *)this + 7) + 48), *((void *)this + 7) + 16);
  *(_DWORD *)(*((void *)this + 7) + 56) = result;
  *(_DWORD *)(*((void *)this + 7) + 64) = 3;
  return result;
}

uint64_t AppleBCMWLANWorkOrder::complete(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(a1 + 56) + 64) = 4;
  *(void *)(*(void *)(a1 + 56) + 88) = mach_continuous_time();
  uint64_t v4 = *(void *)(a1 + 56);
  if (*(_DWORD *)(v4 + 68) == 1
    && (uint64_t v5 = *(void (**)(uint64_t, void, void))(v4 + 32)) != 0
    && (uint64_t v6 = *(void *)(v4 + 40)) != 0)
  {
    v5(v6, *(void *)(v4 + 48), *(unsigned int *)(v4 + 56));
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 88))(a2, a1);
  }
  *(_DWORD *)(*(void *)(a1 + 56) + 64) = 5;
  return kdebug_trace();
}

BOOL AppleBCMWLANWorkOrder::isAsync(AppleBCMWLANWorkOrder *this)
{
  return *(_DWORD *)(*((void *)this + 7) + 68) == 1;
}

uint64_t AppleBCMWLANTaskmaster::initWithWorkQueue(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = OSObject::init((OSObject *)a1);
  if (!result) {
    return result;
  }
  uint64_t v7 = IOMallocZeroTyped();
  *(void *)(a1 + 48) = v7;
  if (!v7)
  {
    IOLog("Failed to allocate AppleBCMWLANTaskmaster_IVars\n");
    return 0;
  }
  (*(void (**)(uint64_t))(*(void *)a2 + 8))(a2);
  **(void **)(a1 + 48) = a2;
  *(void *)(*(void *)(a1 + 48) + 8) = IO80211CommandGate::allocWithParams();
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 8);
  if (!result) {
    return result;
  }
  *(void *)(*(void *)(a1 + 48) + 32) = AppleBCMWLANCommandQueue::withGateAndCapacity(result, 0);
  uint64_t v8 = *(void *)(a1 + 48);
  if (!*(void *)(v8 + 32)) {
    return 0;
  }
  *(void *)(*(void *)(a1 + 48) + 16) = AppleBCMWLANCommandQueue::withGateAndCapacity(*(void *)(v8 + 8), 0);
  if (!*(void *)(*(void *)(a1 + 48) + 16)) {
    return 0;
  }
  if (!a3)
  {
LABEL_10:
    *(void *)(*(void *)(a1 + 48) + 48) = IOLockAlloc();
    if (*(void *)(*(void *)(a1 + 48) + 48))
    {
      *(void *)(*(void *)(a1 + 48) + 40) = IO80211TimerSource::allocWithParams();
      uint64_t result = *(void *)(*(void *)(a1 + 48) + 40);
      if (result)
      {
        (*(void (**)(uint64_t))(*(void *)result + 64))(result);
        return 1;
      }
      return result;
    }
    getClassNameHelper((OSObject *)a1);
    IOLog("%s::%s() failed to create _lock\n");
    return 0;
  }
  while (1)
  {
    uint64_t result = (uint64_t)AppleBCMWLANWorkOrder::withID(0);
    if (!result) {
      return result;
    }
    uint64_t v9 = result;
    if ((AppleBCMWLANCommandQueue::enqueue(*(AppleBCMWLANCommandQueue **)(*(void *)(a1 + 48) + 16), (IOCommand *)result) & 1) == 0)
    {
      (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
      return 0;
    }
    if (!--a3) {
      goto LABEL_10;
    }
  }
}

uint64_t AppleBCMWLANTaskmaster::work(uint64_t a1)
{
  kdebug_trace();
  while (1)
  {
    IOLockLock(*(IOLock **)(*(void *)(a1 + 48) + 48));
    *(void *)(*(void *)(a1 + 48) + 72) = mach_continuous_time();
    uint64_t v2 = (AppleBCMWLANWorkOrder *)AppleBCMWLANCommandQueue::lockDequeue(*(AppleBCMWLANCommandQueue **)(*(void *)(a1 + 48) + 32));
    IOLockUnlock(*(IOLock **)(*(void *)(a1 + 48) + 48));
    if (!v2) {
      break;
    }
    AppleBCMWLANWorkOrder::execute(v2);
    AppleBCMWLANWorkOrder::complete((uint64_t)v2, *(void *)(*(void *)(a1 + 48) + 8));
    if (AppleBCMWLANWorkOrder::isAsync(v2)) {
      AppleBCMWLANCommandQueue::lockEnqueue(*(AppleBCMWLANCommandQueue **)(*(void *)(a1 + 48) + 16), v2);
    }
  }
  return kdebug_trace();
}

uint64_t non-virtual thunk to'AppleBCMWLANTaskmaster::initWithWorkQueue(uint64_t a1, uint64_t a2, int a3)
{
  return AppleBCMWLANTaskmaster::initWithWorkQueue(a1 - 40, a2, a3);
}

void AppleBCMWLANTaskmaster::free(OSObject *this)
{
  uint64_t v2 = *(void **)&this[1].refcount;
  if (v2)
  {
    uint64_t v3 = v2[5];
    if (v3)
    {
      (*(void (**)(void))(*(void *)v3 + 72))(v2[5]);
      (*(void (**)(void))(**(void **)(*(void *)&this[1].refcount + 40) + 16))(*(void *)(*(void *)&this[1].refcount + 40));
      *(void *)(*(void *)&this[1].refcount + 40) = 0;
      uint64_t v2 = *(void **)&this[1].refcount;
    }
    uint64_t v4 = v2[2];
    if (v4)
    {
      (*(void (**)(void))(*(void *)v4 + 16))(v2[2]);
      *(void *)(*(void *)&this[1].refcount + 16) = 0;
      uint64_t v2 = *(void **)&this[1].refcount;
    }
    uint64_t v5 = v2[4];
    if (v5)
    {
      (*(void (**)(void))(*(void *)v5 + 16))(v2[4]);
      *(void *)(*(void *)&this[1].refcount + 32) = 0;
      uint64_t v2 = *(void **)&this[1].refcount;
    }
    uint64_t v6 = v2[1];
    if (v6)
    {
      (*(void (**)(void))(*(void *)v6 + 16))(v2[1]);
      *(void *)(*(void *)&this[1].refcount + 8) = 0;
      uint64_t v2 = *(void **)&this[1].refcount;
    }
    if (*v2)
    {
      (*(void (**)(void))(*(void *)*v2 + 16))(*v2);
      **(void **)&this[1].refcount = 0;
      uint64_t v2 = *(void **)&this[1].refcount;
    }
    if (v2[6])
    {
      IOLockFree((IOLock *)v2[6]);
      *(void *)(*(void *)&this[1].refcount + 48) = 0;
      uint64_t v2 = *(void **)&this[1].refcount;
    }
    memset_s(v2, 0x50uLL, 0, 0x50uLL);
    uint64_t v7 = *(void **)&this[1].refcount;
    if (v7)
    {
      IOFree(v7, 0x50uLL);
      *(void *)&this[1].refcount = 0;
    }
  }
  OSObject::free(this);
}

void non-virtual thunk to'AppleBCMWLANTaskmaster::free(AppleBCMWLANTaskmaster *this)
{
}

OSObject *AppleBCMWLANCommandQueue::withCapacity(AppleBCMWLANCommandQueue *this)
{
  uint64_t v4 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANCommandQueueMetaClass, &v4)) {
    return 0;
  }
  uint64_t v2 = v4;
  if (v4
    && (((uint64_t (*)(OSObject *, void, AppleBCMWLANCommandQueue *))v4->OSMetaClassBase::__vftable[1].getMetaClass)(v4, 0, this) & 1) == 0)
  {
    ((void (*)(OSObject *))v2->release)(v2);
    return 0;
  }
  return v2;
}

OSObject *AppleBCMWLANCommandQueue::withGateAndCapacity(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANCommandQueueMetaClass, &v6)) {
    return 0;
  }
  uint64_t v4 = v6;
  if (v6
    && (((uint64_t (*)(OSObject *, uint64_t, uint64_t))v6->OSMetaClassBase::__vftable[1].getMetaClass)(v6, a1, a2) & 1) == 0)
  {
    ((void (*)(OSObject *))v4->release)(v4);
    return 0;
  }
  return v4;
}

uint64_t AppleBCMWLANCommandQueue::initWithGateAndCapacity(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = OSObject::init((OSObject *)a1);
  if (result)
  {
    uint64_t result = IOMallocZeroTyped();
    *(void *)(a1 + 48) = result;
    if (result)
    {
      *(void *)(result + 32) = result + 32;
      *(void *)(*(void *)(a1 + 48) + 40) = *(void *)(a1 + 48) + 32;
      if (a2) {
        (*(void (**)(uint64_t))(*(void *)a2 + 8))(a2);
      }
      *(void *)(*(void *)(a1 + 48) + 8) = a2;
      *(void *)(*(void *)(a1 + 48) + 24) = IOLockAlloc();
      uint64_t v7 = *(void *)(a1 + 48);
      if (*(void *)(v7 + 24))
      {
        *(_DWORD *)uint64_t v7 = a3;
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t non-virtual thunk to'AppleBCMWLANCommandQueue::initWithGateAndCapacity(uint64_t a1, uint64_t a2, int a3)
{
  return AppleBCMWLANCommandQueue::initWithGateAndCapacity(a1 - 40, a2, a3);
}

void AppleBCMWLANCommandQueue::free(AppleBCMWLANCommandQueue *this)
{
  if (*((void *)this + 6))
  {
    AppleBCMWLANCommandQueue::flush(this);
    uint64_t v2 = *((void *)this + 6);
    if (v2)
    {
      if (*(void *)(v2 + 24))
      {
        IOLockFree(*(IOLock **)(v2 + 24));
        uint64_t v2 = *((void *)this + 6);
      }
      uint64_t v3 = *(void *)(v2 + 8);
      if (v3)
      {
        (*(void (**)(void))(*(void *)v3 + 16))(*(void *)(v2 + 8));
        *(void *)(*((void *)this + 6) + 8) = 0;
        uint64_t v2 = *((void *)this + 6);
      }
      memset_s((void *)v2, 0x30uLL, 0, 0x30uLL);
      uint64_t v4 = (void *)*((void *)this + 6);
      if (v4)
      {
        IOFree(v4, 0x30uLL);
        *((void *)this + 6) = 0;
      }
    }
    OSObject::free((OSObject *)this);
  }
  else
  {
    IOLog("Failed to allocate AppleBCMWLANCommandQueue_IVars\n");
  }
}

uint64_t AppleBCMWLANCommandQueue::flush(AppleBCMWLANCommandQueue *this)
{
  uint64_t v2 = AppleBCMWLANCommandQueue::dequeue(this);
  for (i = 0; v2; uint64_t v2 = AppleBCMWLANCommandQueue::dequeue(this))
  {
    (*(void (**)(void *))(*v2 + 16))(v2);
    uint64_t i = (i + 1);
  }
  return i;
}

void non-virtual thunk to'AppleBCMWLANCommandQueue::free(AppleBCMWLANCommandQueue *this)
{
}

uint64_t AppleBCMWLANCommandQueue::enqueue(AppleBCMWLANCommandQueue *this, IOCommand *a2)
{
  uint64_t v4 = (_DWORD *)*((void *)this + 6);
  if (*v4 && v4[1] >= *v4) {
    return 0;
  }
  (*(void (**)(IOCommand *))(*(void *)a2 + 8))(a2);
  atomic_fetch_add_explicit((atomic_uint *volatile)(*((void *)this + 6) + 4), 1u, memory_order_relaxed);
  uint64_t v5 = *((void *)this + 6);
  uint64_t result = IOCommand::CommandChain(a2);
  uint64_t v7 = *(void **)(v5 + 40);
  if (*v7 == v5 + 32)
  {
    *(void *)uint64_t result = v5 + 32;
    *(void *)(result + 8) = v7;
    *uint64_t v7 = result;
    *(void *)(v5 + 40) = result;
    uint64_t v8 = *((void *)this + 6);
    if (*(_DWORD *)(v8 + 16))
    {
      uint64_t v9 = *(void *)(v8 + 8);
      if (v9) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 88))(v9, v8 + 32);
      }
    }
    return 1;
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t AppleBCMWLANCommandQueue::getSize(AppleBCMWLANCommandQueue *this)
{
  return *(unsigned int *)(*((void *)this + 6) + 4);
}

void *AppleBCMWLANCommandQueue::dequeue(AppleBCMWLANCommandQueue *this)
{
  uint64_t v2 = *((void *)this + 6);
  uint64_t v5 = *(void **)(v2 + 32);
  uint64_t v4 = (void *)(v2 + 32);
  uint64_t result = v5;
  if (v4 == v5) {
    return 0;
  }
  if (*(void **)result[1] == result)
  {
    uint64_t v6 = *result;
    if (*(void **)(*result + 8) == result)
    {
      *(void *)(v6 + 8) = v4;
      *uint64_t v4 = v6;
      *uint64_t result = 0;
      result[1] = 0;
      uint64_t v7 = IOCommand::FromChain();
      atomic_fetch_add_explicit((atomic_uint *volatile)(*((void *)this + 6) + 4), 0xFFFFFFFF, memory_order_relaxed);
      (*(void (**)(uint64_t))(*(void *)v7 + 16))(v7);
      return (void *)v7;
    }
  }
  __break(1u);
  return result;
}

uint64_t AppleBCMWLANCommandQueue::remove(AppleBCMWLANCommandQueue *this, IOCommand *a2)
{
  uint64_t v2 = *((void *)this + 6);
  uint64_t v3 = *(void **)(v2 + 32);
  if ((void *)(v2 + 32) != v3)
  {
    while (v3 != (void *)(*((void *)this + 6) + 32))
    {
      uint64_t v6 = v3;
      uint64_t v3 = (void *)*v3;
      uint64_t result = IOCommand::CommandChain(a2);
      if (v6 == (void *)result)
      {
        uint64_t v8 = (void *)v6[1];
        if ((void *)*v8 == v6 && (uint64_t v9 = *v6, *(void **)(*v6 + 8) == v6))
        {
          *(void *)(v9 + 8) = v8;
          void *v8 = v9;
          void *v6 = 0;
          v6[1] = 0;
          atomic_fetch_add_explicit((atomic_uint *volatile)(*((void *)this + 6) + 4), 0xFFFFFFFF, memory_order_relaxed);
          (*(void (**)(IOCommand *))(*(void *)a2 + 16))(a2);
          return 1;
        }
        else
        {
          __break(1u);
        }
        return result;
      }
    }
  }
  return 0;
}

uint64_t AppleBCMWLANCommandQueue::lockEnqueue(AppleBCMWLANCommandQueue *this, IOCommand *a2)
{
  uint64_t v4 = *(IOLock **)(*((void *)this + 6) + 24);
  IOLockLock(v4);
  uint64_t v5 = AppleBCMWLANCommandQueue::enqueue(this, a2);
  IOLockUnlock(v4);
  return v5;
}

void *AppleBCMWLANCommandQueue::lockDequeue(AppleBCMWLANCommandQueue *this)
{
  uint64_t v2 = *(IOLock **)(*((void *)this + 6) + 24);
  IOLockLock(v2);
  uint64_t v3 = AppleBCMWLANCommandQueue::dequeue(this);
  IOLockUnlock(v2);
  return v3;
}

uint64_t AppleBCMWLANCommandQueue::lockFlush(AppleBCMWLANCommandQueue *this)
{
  uint64_t v2 = *(IOLock **)(*((void *)this + 6) + 24);
  IOLockLock(v2);
  uint64_t v3 = AppleBCMWLANCommandQueue::flush(this);
  IOLockUnlock(v2);
  return v3;
}

uint64_t AppleBCMWLANCommandQueue::map(uint64_t a1, void *a2, void (*a3)(uint64_t, uint64_t, uint64_t), uint64_t a4, uint64_t a5)
{
  if ((void *)*a2 != a2)
  {
    uint64_t v10 = IOCommand::FromChain();
    int v11 = (void *)*a2;
    if ((void *)*a2 != a2)
    {
      uint64_t v12 = v10;
      while (2)
      {
        unsigned int v13 = (void *)*v11;
        uint64_t v14 = IOCommand::FromChain();
        a3(a4, v14, a5);
        uint64_t result = v14;
        switch((int)v14)
        {
          case 0:
            goto LABEL_8;
          case 1:
            return 0;
          case 2:
            return result;
          case 3:
            uint64_t v16 = (void *)v11[1];
            if ((void *)*v16 != v11) {
              goto LABEL_23;
            }
            unsigned int v17 = (void *)*v11;
            if (*(void **)(*v11 + 8) != v11) {
              goto LABEL_23;
            }
            v17[1] = v16;
            *uint64_t v16 = v17;
            void *v11 = 0;
            v11[1] = 0;
            atomic_fetch_add_explicit((atomic_uint *volatile)(*(void *)(a1 + 48) + 4), 0xFFFFFFFF, memory_order_relaxed);
            (*(void (**)(uint64_t))(*(void *)v14 + 16))(v14);
LABEL_8:
            int v11 = v13;
            if (v13 == a2) {
              return 0;
            }
            continue;
          case 4:
            uint64_t v18 = (void *)v11[1];
            if ((void *)*v18 != v11) {
              goto LABEL_23;
            }
            uint64_t v19 = *v11;
            if (*(void **)(*v11 + 8) != v11) {
              goto LABEL_23;
            }
            *(void *)(v19 + 8) = v18;
            *uint64_t v18 = v19;
            void *v11 = 0;
            v11[1] = 0;
            atomic_fetch_add_explicit((atomic_uint *volatile)(*(void *)(a1 + 48) + 4), 0xFFFFFFFF, memory_order_relaxed);
            (*(void (**)(uint64_t))(*(void *)v14 + 16))(v14);
            return v14;
          case 5:
            uint64_t result = v12;
            if (v14 == v12) {
              return result;
            }
            unsigned int v20 = (void *)v11[1];
            if ((void *)*v20 != v11
              || (uint64_t v21 = *v11, *(void **)(*v11 + 8) != v11)
              || (*(void *)(v21 + 8) = v20,
                  void *v20 = v21,
                  void *v11 = 0,
                  v11[1] = 0,
                  unsigned int v22 = (void *)*a2,
                  *(void **)(*a2 + 8) != a2))
            {
LABEL_23:
              __break(1u);
LABEL_24:
              AppleBCMWLANCommandQueue::map();
            }
            void *v11 = v22;
            v11[1] = a2;
            v22[1] = v11;
            uint64_t result = v14;
            *a2 = v11;
            return result;
          case 6:
            uint64_t v23 = (void *)v11[1];
            if ((void *)*v23 != v11) {
              goto LABEL_23;
            }
            uint64_t v24 = *v11;
            if (*(void **)(*v11 + 8) != v11) {
              goto LABEL_23;
            }
            *(void *)(v24 + 8) = v23;
            void *v23 = v24;
            void *v11 = 0;
            v11[1] = 0;
            __int16 v25 = (void *)a2[1];
            if ((void *)*v25 != a2) {
              goto LABEL_23;
            }
            void *v11 = a2;
            v11[1] = v25;
            void *v25 = v11;
            uint64_t result = v14;
            a2[1] = v11;
            return result;
          default:
            goto LABEL_24;
        }
      }
    }
  }
  return 0;
}

uint64_t AppleBCMWLANCommandQueue::lockMap(uint64_t a1, void (*a2)(uint64_t, uint64_t, uint64_t), uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(IOLock **)(*(void *)(a1 + 48) + 24);
  IOLockLock(v8);
  uint64_t v9 = AppleBCMWLANCommandQueue::map(a1, (void *)(*(void *)(a1 + 48) + 32), a2, a3, a4);
  IOLockUnlock(v8);
  return v9;
}

uint64_t AppleBCMWLANCommandQueue::filterInternal(uint64_t result, uint64_t (*a2)(uint64_t, uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void **)(v6 + 32);
  if ((void *)(v6 + 32) != v7)
  {
    uint64_t v13 = result;
    do
    {
      uint64_t v14 = (void *)*v7;
      uint64_t v15 = IOCommand::FromChain();
      if (a3)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a3 + 16))(a3, v15);
        if ((result & 1) == 0) {
          goto LABEL_11;
        }
      }
      else
      {
        uint64_t result = a2(a4, v15, a5);
        if (!result) {
          goto LABEL_11;
        }
      }
      uint64_t v16 = (void *)v7[1];
      if ((void *)*v16 != v7
        || (unsigned int v17 = (void *)*v7, *(void **)(*v7 + 8) != v7)
        || (v17[1] = v16,
            *uint64_t v16 = v17,
            *uint64_t v7 = 0,
            v7[1] = 0,
            atomic_fetch_add_explicit((atomic_uint *volatile)(*(void *)(v13 + 48) + 4), 0xFFFFFFFF, memory_order_relaxed), uint64_t v18 = *(void **)(a6 + 8), *v18 != a6))
      {
        __break(1u);
        return result;
      }
      *uint64_t v7 = a6;
      v7[1] = v18;
      *uint64_t v18 = v7;
      *(void *)(a6 + 8) = v7;
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 16))(v15);
LABEL_11:
      uint64_t v7 = v14;
    }
    while (v14 != (void *)(*(void *)(v13 + 48) + 32));
  }
  return result;
}

void AppleBCMWLANCommandQueue::lockFilter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(IOLock **)(*(void *)(a1 + 48) + 24);
  IOLockLock(v6);
  AppleBCMWLANCommandQueue::filterInternal(a1, 0, a2, 0, 0, a3);
  IOLockUnlock(v6);
}

uint64_t AppleBCMWLANCommandQueue::lockPeek(AppleBCMWLANCommandQueue *this)
{
  uint64_t v2 = *(IOLock **)(*((void *)this + 6) + 24);
  IOLockLock(v2);
  if (*((void *)this + 6) + 32 == *(void *)(*((void *)this + 6) + 32)) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = IOCommand::FromChain();
  }
  IOLockUnlock(v2);
  return v3;
}

uint64_t AppleBCMWLANChipManager::init(OSObject *this, AppleBCMWLANBusInterface *a2)
{
  if (OSObject::init(this))
  {
    uint64_t result = IOMallocZeroTyped();
    *(void *)&this[1].refcount = result;
    if (!result) {
      return result;
    }
    **(void **)&this[1].refcount = AppleBCMWLANBusInterface::getLogger(a2);
    uint64_t v5 = **(void **)&this[1].refcount;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
      return 1;
    }
    getClassNameHelper(this);
    IOLog("%s::%s(): Unable to get debug logger\n");
  }
  else
  {
    getClassNameHelper(this);
    IOLog("%s:%s(): Super failed to init!\n");
  }
  return 0;
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManager::init(OSObject *this, AppleBCMWLANBusInterface *a2)
{
  return AppleBCMWLANChipManager::init(this - 1, a2);
}

BOOL AppleBCMWLANChipManager::init(OSObject *this)
{
  if (OSObject::init(this))
  {
    uint64_t v2 = IOMallocZeroTyped();
    *(void *)&this[1].refcount = v2;
    return v2 != 0;
  }
  else
  {
    ClassNameHelper = (const char *)getClassNameHelper(this);
    IOLog("%s:%s(): Super failed to init!\n", ClassNameHelper, "init");
    return 0;
  }
}

BOOL non-virtual thunk to'AppleBCMWLANChipManager::init(AppleBCMWLANChipManager *this)
{
  return AppleBCMWLANChipManager::init((OSObject *)((char *)this - 24));
}

void AppleBCMWLANChipManager::free(OSObject *this)
{
  uint64_t v2 = *(void **)&this[1].refcount;
  if (v2)
  {
    if (*v2)
    {
      (*(void (**)(void))(*(void *)*v2 + 16))(*v2);
      **(void **)&this[1].refcount = 0;
      uint64_t v2 = *(void **)&this[1].refcount;
    }
    memset_s(v2, 8uLL, 0, 8uLL);
    uint64_t v3 = *(void **)&this[1].refcount;
    if (v3)
    {
      IOFree(v3, 8uLL);
      *(void *)&this[1].refcount = 0;
    }
  }
  OSObject::free(this);
}

void non-virtual thunk to'AppleBCMWLANChipManager::free(AppleBCMWLANChipManager *this)
{
}

uint64_t AppleBCMWLANChipManager::getSoCRAMSize(AppleBCMWLANChipManager *this)
{
  return 393216;
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManager::getSoCRAMSize(AppleBCMWLANChipManager *this)
{
  return 393216;
}

uint64_t AppleBCMWLANChipManager::getNVRAMLimit(AppleBCMWLANChipManager *this)
{
  return 2048;
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManager::getNVRAMLimit(AppleBCMWLANChipManager *this)
{
  return 2048;
}

uint64_t AppleBCMWLANChipManager::getLogger(AppleBCMWLANChipManager *this)
{
  return **((void **)this + 6);
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManager::getLogger(AppleBCMWLANChipManager *this)
{
  return **((void **)this + 1);
}

void _GLOBAL__sub_I_AppleBCMWLANChipManager_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANPCIeFlowQueue::unassignFlowRing(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 64);
  if (*(void *)(v1 + 24))
  {
    *(void *)(v1 + 24) = 0;
    uint64_t v1 = *(void *)(this + 64);
  }
  if (*(void *)(v1 + 112))
  {
    *(void *)(v1 + 112) = 0;
    uint64_t v1 = *(void *)(this + 64);
  }
  *(_DWORD *)(v1 + 32) = 0;
  return this;
}

uint64_t AppleBCMWLANPCIeFlowQueue::getAssignedFlowRingID(AppleBCMWLANPCIeFlowQueue *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 8) + 24);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 208))();
  }
  else {
    return 0xFFFFLL;
  }
}

uint64_t AppleBCMWLANPCIeFlowQueue::queueSpace(AppleBCMWLANPCIeFlowQueue *this)
{
  unint64_t v2 = *((void *)this + 8);
  uint64_t v3 = *(AppleBCMWLANItemRing **)(v2 + 24);
  if (v3)
  {
    unsigned int WritableItemCount = AppleBCMWLANItemRing::getWritableItemCount(v3);
    unint64_t v2 = WritableItemCount
       - (unint64_t)AppleBCMWLANPCIeTransmitFlowRing::packetsWaitingForRingCount(*(AppleBCMWLANPCIeTransmitFlowRing **)(*((void *)this + 8) + 24), 3);
    if ((v2 & 0x1FFFFFFFFLL) == ((int)v2 & 0x1FFFFFFFFLL)) {
      unsigned int v5 = v2;
    }
    else {
      unsigned int v5 = 0;
    }
  }
  else
  {
    LODWORD(v2) = 255 - *(unsigned __int16 *)(v2 + 16);
    unsigned int v5 = v2;
  }
  if ((v2 & 0x80000000) == 0) {
    return v5;
  }
  else {
    return 0;
  }
}

uint64_t non-virtual thunk to'AppleBCMWLANPCIeFlowQueue::queueSpace(AppleBCMWLANPCIeFlowQueue *this)
{
  return AppleBCMWLANPCIeFlowQueue::queueSpace((AppleBCMWLANPCIeFlowQueue *)((char *)this - 40));
}

uint64_t AppleBCMWLANPCIeFlowQueue::queueSize(AppleBCMWLANPCIeFlowQueue *this)
{
  uint64_t v1 = *(AppleBCMWLANItemRing **)(*((void *)this + 8) + 24);
  if (!v1) {
    return 255;
  }
  unsigned int ItemCount = AppleBCMWLANItemRing::getItemCount(v1);
  if (((ItemCount + 0x1FFFFFFFFLL) & 0x1FFFFFFFFLL) != ((int)(ItemCount - 1) & 0x1FFFFFFFFLL)
    || (int)(ItemCount - 1) < 0)
  {
    return 0;
  }
  else
  {
    return ItemCount - 1;
  }
}

uint64_t non-virtual thunk to'AppleBCMWLANPCIeFlowQueue::queueSize(AppleBCMWLANPCIeFlowQueue *this)
{
  return AppleBCMWLANPCIeFlowQueue::queueSize((AppleBCMWLANPCIeFlowQueue *)((char *)this - 40));
}

uint64_t AppleBCMWLANPCIeFlowQueue::pendingPackets(AppleBCMWLANPCIeFlowQueue *this)
{
  uint64_t v2 = *((void *)this + 8);
  uint64_t v3 = *(AppleBCMWLANItemRing **)(v2 + 24);
  if (!v3) {
    return *(unsigned __int16 *)(v2 + 16);
  }
  Readableunsigned int ItemCount = AppleBCMWLANItemRing::getReadableItemCount(v3);
  int v5 = AppleBCMWLANPCIeTransmitFlowRing::packetsWaitingForRingCount(*(AppleBCMWLANPCIeTransmitFlowRing **)(*((void *)this + 8) + 24), 3);
  BOOL v6 = __CFADD__(ReadableItemCount, v5);
  uint64_t v7 = (ReadableItemCount + v5);
  if (v6)
  {
    int v8 = AppleBCMWLANItemRing::getReadableItemCount(*(AppleBCMWLANItemRing **)(*((void *)this + 8) + 24));
    int v9 = AppleBCMWLANPCIeTransmitFlowRing::packetsWaitingForRingCount(*(AppleBCMWLANPCIeTransmitFlowRing **)(*((void *)this + 8) + 24), 3);
    IOLog(" AppleBCMWLANPCIeFlowQueue::pendingPackets(), Overflow detected, getReadableItemCount[%u] packetsWaitingForRingCount[%u] packets[%u]", v8, v9, v7);
  }
  return v7;
}

uint64_t non-virtual thunk to'AppleBCMWLANPCIeFlowQueue::pendingPackets(AppleBCMWLANPCIeFlowQueue *this)
{
  return AppleBCMWLANPCIeFlowQueue::pendingPackets((AppleBCMWLANPCIeFlowQueue *)((char *)this - 40));
}

uint64_t AppleBCMWLANPCIeFlowQueue::DEBUG_totalStagedPackets(AppleBCMWLANPCIeFlowQueue *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 20);
}

uint64_t non-virtual thunk to'AppleBCMWLANPCIeFlowQueue::DEBUG_totalStagedPackets(AppleBCMWLANPCIeFlowQueue *this)
{
  return *(unsigned int *)(*((void *)this + 3) + 20);
}

uint64_t AppleBCMWLANPCIeFlowQueue::DEBUG_curStagedPackets(AppleBCMWLANPCIeFlowQueue *this)
{
  return *(unsigned __int16 *)(*((void *)this + 8) + 16);
}

uint64_t non-virtual thunk to'AppleBCMWLANPCIeFlowQueue::DEBUG_curStagedPackets(AppleBCMWLANPCIeFlowQueue *this)
{
  return *(unsigned __int16 *)(*((void *)this + 3) + 16);
}

OSObject *AppleBCMWLANPCIeFlowQueue::withProviderAndQueueInfo(AppleBCMWLANBusInterfacePCIe *a1, uint64_t a2, unsigned __int8 a3, IO80211SkywalkInterface *a4, BOOL (__cdecl *a5)(OSObjectInterface *__hidden this), void (__cdecl *a6)(OSObjectInterface *__hidden this))
{
  uint64_t v14 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANPCIeFlowQueueMetaClass, &v14)) {
    return 0;
  }
  uint64_t v12 = v14;
  if (v14
    && (AppleBCMWLANPCIeFlowQueue::initWithProviderAndQueueInfo(v14, a1, a2 & 0xFFFFFFFFFFFFLL, a3, a4, a5, a6) & 1) == 0)
  {
    ((void (*)(OSObject *))v12->release)(v12);
    return 0;
  }
  return v12;
}

uint64_t AppleBCMWLANPCIeFlowQueue::initWithProviderAndQueueInfo(OSObject *a1, AppleBCMWLANBusInterfacePCIe *a2, uint64_t a3, unsigned __int8 a4, IO80211SkywalkInterface *a5, BOOL (__cdecl *a6)(OSObjectInterface *__hidden this), void (__cdecl *a7)(OSObjectInterface *__hidden this))
{
  *(_DWORD *)v26.octet = a3;
  *(_WORD *)&v26.octet[4] = WORD2(a3);
  uint64_t result = OSObject::init(a1);
  if (result)
  {
    unsigned __int8 InterfaceId = IO80211SkywalkInterface::getInterfaceId(a5);
    uint64_t result = IO80211FlowQueue::initWithParamaters((IO80211FlowQueue *)a1, &v26, InterfaceId, a4);
    if (result)
    {
      uint64_t result = IOMallocZeroTyped();
      a1[1].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)result;
      if (result)
      {
        *(ether_addr *)(result + 36) = v26;
        a1[1].OSObjectInterface::__vftable[5].init = a6;
        uint64_t v15 = a1[1].OSObjectInterface::__vftable;
        init = v15[5].init;
        if (init)
        {
          (*(void (**)(BOOL (__cdecl *)(OSObjectInterface *__hidden)))(*(void *)init + 8))(init);
          uint64_t v15 = a1[1].OSObjectInterface::__vftable;
        }
        v15[5].free = a7;
        a1[1].OSObjectInterface::__vftable[6].free = (void (__cdecl *)(OSObjectInterface *__hidden))a5;
        LOWORD(a1[1].OSObjectInterface::__vftable[8].free) = -1;
        a1[1].OSObjectInterface::__vftable[6].init = (BOOL (__cdecl *)(OSObjectInterface *__hidden))a2;
        a1[1].OSObjectInterface::__vftable[4].free = 0;
        unsigned int v17 = (const OSMetaClassBase *)(*(uint64_t (**)(void))(*(void *)a1[1].OSObjectInterface::__vftable[6].init
                                                            + 752))();
        uint64_t v18 = OSMetaClassBase::safeMetaCast(v17, (const OSMetaClass *)gAppleBCMWLANPCIeSkywalkMetaClass);
        a1[1].OSObjectInterface::__vftable[7].free = (void (__cdecl *)(OSObjectInterface *__hidden))AppleBCMWLANPCIeSkywalk::getPacketPool((AppleBCMWLANPCIeSkywalk *)v18);
        uint64_t v19 = a1[1].OSObjectInterface::__vftable;
        if (v19[5].init)
        {
          int shouldLog = CCLogStream::shouldLog();
          uint64_t v19 = a1[1].OSObjectInterface::__vftable;
          if (shouldLog)
          {
            uint64_t v24 = (CCLogStream *)v19[5].init;
            unsigned __int8 v25 = IO80211SkywalkInterface::getInterfaceId(a5);
            CCLogStream::logAlert(v24, "[dk] %s@%d:%s: flowQ %p IfID:%u ac:%u \n", "initWithProviderAndQueueInfo", 334, "initWithProviderAndQueueInfo", a1, v25, a4);
            uint64_t v19 = a1[1].OSObjectInterface::__vftable;
          }
        }
        v19[3].init = (BOOL (__cdecl *)(OSObjectInterface *__hidden))&v19[3];
        a1[1].OSObjectInterface::__vftable[3].free = (void (__cdecl *)(OSObjectInterface *__hidden))&a1[1].OSObjectInterface::__vftable[3];
        WORD1(a1[1].OSObjectInterface::__vftable[8].free) = 0;
        LODWORD(a1[1].OSObjectInterface::__vftable[4].init) = 0;
        BYTE1(a1[1].OSObjectInterface::__vftable[8].init) = a4;
        LOBYTE(a1[1].OSObjectInterface::__vftable[8].init) = IO80211SkywalkInterface::getInterfaceId(a5);
        uint64_t v21 = a1[1].OSObjectInterface::__vftable;
        HIWORD(v21[8].init) = v21[2].free;
        *(_DWORD *)((char *)&v21[8].init + 2) = HIDWORD(v21[2].init);
        if (AppleBCMWLANBusInterfacePCIe::isTSICMPV6LoggingEnabled(a2)) {
          char TweakAllTxAsTS = 1;
        }
        else {
          char TweakAllTxAsTS = AppleBCMWLANBusInterfacePCIe::getTweakAllTxAsTS(a2);
        }
        BYTE4(a1[1].OSObjectInterface::__vftable[8].free) = TweakAllTxAsTS;
        BYTE5(a1[1].OSObjectInterface::__vftable[8].free) = AppleBCMWLANBusInterfacePCIe::isTSLoggingEnabled(a2);
        unsigned int IgnoreTSIfBitmap = AppleBCMWLANBusInterfacePCIe::getIgnoreTSIfBitmap(a2);
        BYTE6(a1[1].OSObjectInterface::__vftable[8].free) = (IgnoreTSIfBitmap >> IO80211SkywalkInterface::getInterfaceId(a5)) & 1;
        HIBYTE(a1[1].OSObjectInterface::__vftable[8].free) = AppleBCMWLANBusInterfacePCIe::getTSTxExtendedFlags(a2);
        LODWORD(a1[1].OSObjectInterface::__vftable[9].init) = AppleBCMWLANBusInterfacePCIe::getTimestampingMode(a2);
        return 1;
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANPCIeFlowQueue::free(AppleBCMWLANPCIeFlowQueue *this)
{
  if (*((void *)this + 8))
  {
    AppleBCMWLANPCIeFlowQueue::setFWRing(this, 0);
    uint64_t v2 = *((void *)this + 8);
    if (*(void *)(v2 + 80))
    {
      int shouldLog = CCLogStream::shouldLog();
      uint64_t v2 = *((void *)this + 8);
      if (shouldLog)
      {
        BOOL v6 = *(CCLogStream **)(v2 + 80);
        unsigned __int8 InterfaceId = IO80211SkywalkInterface::getInterfaceId(*(IO80211SkywalkInterface **)(v2 + 104));
        CCLogStream::logInfo(v6, "[dk] %s@%d:%s: flowQ %p IfID:%u", "free", 358, "free", this, InterfaceId);
        uint64_t v2 = *((void *)this + 8);
      }
    }
    uint64_t v4 = *(void *)(v2 + 80);
    if (v4)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
      *(void *)(*((void *)this + 8) + 80) = 0;
      uint64_t v2 = *((void *)this + 8);
    }
    *(void *)(v2 + 176) = 0;
    *(_OWORD *)(v2 + 144) = 0u;
    *(_OWORD *)(v2 + 160) = 0u;
    *(_OWORD *)(v2 + 112) = 0u;
    *(_OWORD *)(v2 + 128) = 0u;
    *(_OWORD *)(v2 + 80) = 0u;
    *(_OWORD *)(v2 + 96) = 0u;
    *(_OWORD *)(v2 + 48) = 0u;
    *(_OWORD *)(v2 + 64) = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    *(_OWORD *)(v2 + 32) = 0u;
    *(_OWORD *)uint64_t v2 = 0u;
    int v5 = (void *)*((void *)this + 8);
    if (v5)
    {
      IOFree(v5, 0xB8uLL);
      *((void *)this + 8) = 0;
    }
  }
  return IO80211FlowQueue::free(this);
}

void *AppleBCMWLANPCIeFlowQueue::setFWRing(void *this, AppleBCMWLANPCIeTransmitFlowRing *a2)
{
  uint64_t v2 = this;
  if (a2)
  {
    *(void *)(this[8] + 112) = a2;
  }
  else
  {
    this = AppleBCMWLANPCIeFlowQueue::flushPackets((AppleBCMWLANPCIeFlowQueue *)this);
    uint64_t v3 = v2[8];
    unsigned int v4 = *(unsigned __int16 *)(v3 + 136);
    if (v4 != 0xFFFF)
    {
      this = (void *)AppleBCMWLANBusInterfacePCIe::releaseFlowId(*(AppleBCMWLANBusInterfacePCIe **)(v3 + 96), v4);
      *(_WORD *)(v2[8] + 136) = -1;
      uint64_t v3 = v2[8];
    }
    if (*(void *)(v3 + 112)) {
      *(void *)(v3 + 112) = 0;
    }
  }
  return this;
}

uint64_t non-virtual thunk to'AppleBCMWLANPCIeFlowQueue::free(AppleBCMWLANPCIeFlowQueue *this)
{
  return AppleBCMWLANPCIeFlowQueue::free((AppleBCMWLANPCIeFlowQueue *)((char *)this - 24));
}

uint64_t AppleBCMWLANPCIeFlowQueue::setBusy(AppleBCMWLANPCIeFlowQueue *this)
{
  *(unsigned char *)(*((void *)this + 8) + 148) = 1;
  return (*(uint64_t (**)(void))(*(void *)this + 8))();
}

uint64_t non-virtual thunk to'AppleBCMWLANPCIeFlowQueue::setBusy(AppleBCMWLANPCIeFlowQueue *this)
{
  uint64_t v1 = *((void *)this - 7);
  *(unsigned char *)(*((void *)this + 1) + 148) = 1;
  return (*(uint64_t (**)(void))(v1 + 8))();
}

uint64_t AppleBCMWLANPCIeFlowQueue::clearBusy(AppleBCMWLANPCIeFlowQueue *this)
{
  *(unsigned char *)(*((void *)this + 8) + 148) = 0;
  return (*(uint64_t (**)(void))(*(void *)this + 16))();
}

uint64_t non-virtual thunk to'AppleBCMWLANPCIeFlowQueue::clearBusy(AppleBCMWLANPCIeFlowQueue *this)
{
  uint64_t v1 = *((void *)this - 7);
  *(unsigned char *)(*((void *)this + 1) + 148) = 0;
  return (*(uint64_t (**)(void))(v1 + 16))();
}

void *AppleBCMWLANPCIeFlowQueue::enqueuePacket(AppleBCMWLANPCIeFlowQueue *this, AppleBCMWLANPCIeSkywalkPacket *a2, int a3)
{
  uint64_t v5 = *((void *)this + 8);
  if (*(__int16 *)(v5 + 136) != -1 || a3 == 0)
  {
LABEL_51:
    uint64_t result = (void *)AppleBCMWLANPCIeSkywalkPacket::getChain(a2);
    char v27 = *(void **)(v5 + 56);
    if (*v27 == v5 + 48)
    {
      *uint64_t result = v5 + 48;
      result[1] = v27;
      void *v27 = result;
      *(void *)(v5 + 56) = result;
      uint64_t result = (void *)AppleBCMWLANPCIeSkywalkPacket::setAc((uint64_t)a2, *(unsigned char *)(*((void *)this + 8) + 129));
      ++*(_DWORD *)(*((void *)this + 8) + 64);
      ++*(void *)(*((void *)this + 8) + 152);
    }
    else
    {
      __break(1u);
    }
    return result;
  }
  int v29 = 0;
  int v7 = *(unsigned __int8 *)(v5 + 129);
  uint64_t v8 = *(void *)(v5 + 96);
  if (!v8)
  {
    BOOL v11 = 0;
    uint64_t v10 = 0;
LABEL_13:
    if (IO80211SkywalkInterface::isLowLatencyEnabled(*(IO80211SkywalkInterface **)(*((void *)this + 8)
                                                                                                + 104)))
    {
      switch(v7)
      {
        case 1:
          unsigned __int8 v13 = 2;
          break;
        case 2:
          unsigned __int8 v13 = 4;
          break;
        case 3:
          unsigned __int8 v13 = 7;
          break;
        default:
          unsigned __int8 v13 = 3;
          break;
      }
    }
    else
    {
      switch(v7)
      {
        case 1:
          unsigned __int8 v13 = 1;
          break;
        case 2:
          unsigned __int8 v13 = 5;
          break;
        case 3:
          unsigned __int8 v13 = 6;
          break;
        default:
          unsigned __int8 v13 = 0;
          break;
      }
    }
    goto LABEL_36;
  }
  int v9 = (AppleBCMWLANCore *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 1104))(v8);
  uint64_t v10 = v9;
  BOOL v11 = v9 != 0;
  if (v7 != 3 || v9 == 0) {
    goto LABEL_13;
  }
  if (AppleBCMWLANCore::checkForHP2PSupport(v9))
  {
    BOOL v11 = 1;
    goto LABEL_13;
  }
  if (AppleBCMWLANCore::isP2pAirplayActive(v10)
    && AppleBCMWLANCore::mapLowLatencyLowPriority(v10)
    && (int InterfaceId = IO80211SkywalkInterface::getInterfaceId(*(IO80211SkywalkInterface **)(*((void *)this + 8) + 104)),
        InterfaceId == AppleBCMWLANCore::getProximityInterfaceId(v10)))
  {
    unsigned __int8 v13 = 5;
  }
  else if (IO80211SkywalkInterface::isLowLatencyEnabled(*(IO80211SkywalkInterface **)(*((void *)this + 8) + 104)))
  {
    unsigned __int8 v13 = 7;
  }
  else
  {
    unsigned __int8 v13 = 6;
  }
  BOOL v11 = 1;
LABEL_36:
  int isLowLatencyEnabled = IO80211SkywalkInterface::isLowLatencyEnabled(*(IO80211SkywalkInterface **)(*((void *)this + 8)
                                                                                                 + 104));
  unsigned __int8 v16 = isLowLatencyEnabled;
  if (isLowLatencyEnabled) {
    BOOL v17 = !v11;
  }
  else {
    BOOL v17 = 1;
  }
  if (!v17)
  {
    if (AppleBCMWLANCore::isSplitTxStatusEnabled(v10)) {
      unsigned __int8 v16 = 3;
    }
    else {
      unsigned __int8 v16 = 1;
    }
  }
  int v18 = IO80211SkywalkInterface::getInterfaceId(*(IO80211SkywalkInterface **)(*((void *)this + 8) + 104));
  if (IO80211SkywalkInterface::isLowLatencyEnabled(*(IO80211SkywalkInterface **)(*((void *)this + 8)
                                                                                              + 104)))
  {
    ParentInterface = (IO80211SkywalkInterface *)IO80211SkywalkInterface::getParentInterface(*(IO80211SkywalkInterface **)(*((void *)this + 8) + 104));
    if (!ParentInterface)
    {
      uint64_t v20 = *((void *)this + 8);
      if (*(void *)(v20 + 80))
      {
        int shouldLog = CCLogStream::shouldLog();
        uint64_t v20 = *((void *)this + 8);
        if (shouldLog)
        {
          CCLogStream::logAlert(*(CCLogStream **)(v20 + 80), "[dk] %s@%d:Invalid parentIf\n", "enqueuePacket", 437);
          uint64_t v20 = *((void *)this + 8);
        }
      }
      goto LABEL_57;
    }
    int v18 = IO80211SkywalkInterface::getInterfaceId(ParentInterface);
  }
  uint64_t v20 = *((void *)this + 8);
  if (v18 != -1)
  {
    uint64_t v21 = *(AppleBCMWLANBusInterfacePCIe **)(v20 + 96);
    uint64_t v22 = (*(uint64_t (**)(void))(**(void **)(v20 + 104) + 1008))(*(void *)(v20 + 104));
    AppleBCMWLANBusInterfacePCIe::requestFlowId(v21, v22 & 0xFFFFFFFFFFFFLL, *(unsigned int *)(*((void *)this + 8) + 36) | ((unint64_t)*(unsigned __int16 *)(*((void *)this + 8)+ 40) << 32), v18, v13, v7, (unsigned __int16 *)(*((void *)this + 8) + 136), &v29, 0, (uint64_t)this, (uint64_t)AppleBCMWLANPCIeFlowQueue::fwRingPending, (uint64_t)AppleBCMWLANPCIeFlowQueue::fwRingFill, (uint64_t)AppleBCMWLANPCIeFlowQueue::fwRingError, v16);
    uint64_t v23 = *((void *)this + 8);
    unsigned int v24 = *(unsigned __int16 *)(v23 + 136);
    if (v24 != 0xFFFF)
    {
      uint64_t TransmitFlowRing = AppleBCMWLANBusInterfacePCIe::getTransmitFlowRing(*(AppleBCMWLANBusInterfacePCIe **)(v23 + 96), v24);
      if (TransmitFlowRing) {
        AppleBCMWLANPCIeTransmitFlowRing::setSkywalkFlow(TransmitFlowRing, 1);
      }
    }
    uint64_t v5 = *((void *)this + 8);
    goto LABEL_51;
  }
LABEL_57:
  uint64_t result = *(void **)(v20 + 80);
  if (result)
  {
    uint64_t result = (void *)CCLogStream::shouldLog();
    if (result) {
      return (void *)CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 80), "[dk] %s@%d:Invalid InterfaceId\n", "enqueuePacket", 442);
    }
  }
  return result;
}

uint64_t AppleBCMWLANPCIeFlowQueue::fwRingPending(AppleBCMWLANPCIeFlowQueue *this)
{
  uint64_t v1 = *((void *)this + 8);
  if (v1) {
    return *(unsigned int *)(v1 + 64);
  }
  else {
    return 0;
  }
}

uint64_t AppleBCMWLANPCIeFlowQueue::fwRingFill(AppleBCMWLANPCIeFlowQueue *this, AppleBCMWLANByteRing *a2, unsigned char *a3, unsigned int a4)
{
  TxPacketTracker = (AppleBCMWLANHashtable *)AppleBCMWLANPCIeSkywalkPacketPool::getTxPacketTracker(*(AppleBCMWLANPCIeSkywalkPacketPool **)(*((void *)this + 8) + 120));
  char InterfaceId = IO80211SkywalkInterface::getInterfaceId(*(IO80211SkywalkInterface **)(*((void *)this + 8) + 104));
  unsigned int v9 = (*(uint64_t (**)(void))(**(void **)(*((void *)this + 8) + 104) + 1120))();
  int isLowLatencyEnabled = IO80211SkywalkInterface::isLowLatencyEnabled(*(IO80211SkywalkInterface **)(*((void *)this + 8)
                                                                                                 + 104));
  uint64_t v10 = *((void *)this + 8);
  int v11 = *(_DWORD *)(v10 + 36);
  int v12 = *(__int16 *)(v10 + 40);
  BOOL v14 = v11 != -1 || v12 != -1;
  *(void *)(*((void *)this + 8) + 176) = mach_continuous_time();
  uint64_t v15 = *((void *)this + 8);
  unsigned __int8 v16 = *(AppleBCMWLANByteRing **)(v15 + 112);
  if (!v16
    && (*(void *)(*((void *)this + 8) + 112) = OSMetaClassBase::safeMetaCast((const OSMetaClassBase *)a2, (const OSMetaClass *)gAppleBCMWLANPCIeTransmitFlowRingMetaClass), v15 = *((void *)this + 8), (unsigned __int8 v16 = *(AppleBCMWLANByteRing **)(v15 + 112)) == 0)|| !a2|| v16 != a2)
  {
    if (*(void *)(v15 + 80) && CCLogStream::shouldLog()) {
      CCLogStream::logInfo(*(CCLogStream **)(*((void *)this + 8) + 80), "[dk] %s@%d:Invalid fFWRing/ring ivars->fFWRing:%p ring:%p\n", "fwRingFill", 597, *(const void **)(*((void *)this + 8) + 112), a2);
    }
    return 0;
  }
  if (InterfaceId != 9)
  {
    if (InterfaceId == 10) {
      char v19 = 3;
    }
    else {
      char v19 = InterfaceId;
    }
LABEL_25:
    char v79 = v19;
    goto LABEL_26;
  }
  ParentInterface = (IO80211SkywalkInterface *)IO80211SkywalkInterface::getParentInterface(*(IO80211SkywalkInterface **)(v15 + 104));
  if (!ParentInterface)
  {
    if (*(void *)(*((void *)this + 8) + 80) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 80), "[dk] %s@%d:Invalid parentIf\n", "fwRingFill", 610);
    }
    char v19 = -1;
    goto LABEL_25;
  }
  char v79 = IO80211SkywalkInterface::getInterfaceId(ParentInterface);
LABEL_26:
  __int16 v87 = -21846;
  memset(&v86[1], 170, 24);
  BOOL v75 = v14;
  if (a4)
  {
    uint64_t v18 = 0;
    int v20 = isLowLatencyEnabled;
    if (v14) {
      int v20 = 0;
    }
    unsigned int v77 = v9;
    int v78 = v20;
    uint64_t v76 = -(uint64_t)v9;
    while (1)
    {
      uint64_t v21 = (IOUserNetworkPacket *)AppleBCMWLANPCIeFlowQueue::dequeueSkywalkPacket(this);
      if (!v21) {
        goto LABEL_97;
      }
      uint64_t v22 = v21;
      unsigned int v23 = ((uint64_t (*)(IOUserNetworkPacket *))v21->getDataLength)(v21);
      if (v23 <= 0xE) {
        break;
      }
      char v27 = &a3[48 * v18];
      *((_OWORD *)v27 + IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = 0u;
      *((_OWORD *)v27 + 2) = 0u;
      *(_OWORD *)char v27 = 0u;
      if (isLowLatencyEnabled
        && AppleBCMWLANBusInterfacePCIe::isFWPacketTimestampEnabled(*(AppleBCMWLANBusInterfacePCIe **)(*((void *)this + 8) + 96)))
      {
        mach_continuous_time();
        absolutetime_to_nanoseconds();
        unint64_t v28 = *(void *)&v86[17] / 0x3E8uLL;
        int v29 = &a3[48 * v18];
        v29[47] = -1;
        uint64_t v30 = (unsigned __int8 *)(v29 + 47);
        *(_DWORD *)(v30 - 2AppleBCMWLANSensingAdapter::free(this - 3) = v28;
        if (((unsigned int (*)(IOUserNetworkPacket *, char *))v22->OSObject::OSMetaClassBase::__vftable[1]._PrepareWithQueue)(v22, &v86[9]))
        {
          AppleBCMWLANPCIeSkywalkPacket::setPktLifetime((uint64_t)v22, -1);
        }
        else
        {
          if (*(void *)&v86[9] <= mach_absolute_time())
          {
            uint64_t v25 = *((void *)this + 8);
            if (*(void *)(v25 + 80))
            {
              int shouldLog = CCLogStream::shouldLog();
              uint64_t v25 = *((void *)this + 8);
              if (shouldLog)
              {
                CCLogStream::logAlertIf(*(CCLogStream **)(v25 + 80), 0x400uLL, "[dk] %s@%d:Got an expired packet. Deallocating\n", "fwRingFill", 648);
                goto LABEL_95;
              }
            }
LABEL_34:
            AppleBCMWLANPCIeSkywalkPacketPool::deallocatePacket(*(AppleBCMWLANPCIeSkywalkPacketPool **)(v25 + 120), v22);
            ++*(void *)(*((void *)this + 8) + 168);
            goto LABEL_92;
          }
          absolutetime_to_nanoseconds();
          unint64_t v55 = *(void *)&v86[1];
          *(void *)&v86[1] /= 0x3E8uLL;
          unint64_t v56 = (unsigned __int16)(v55 / 0xF4240);
          if (v56 >= 0x7FFF) {
            __int16 v57 = 0x7FFF;
          }
          else {
            __int16 v57 = v56;
          }
          AppleBCMWLANPCIeSkywalkPacket::setPktLifetime((uint64_t)v22, v57);
          unsigned int v58 = *(_DWORD *)&v86[1];
          if (*(void *)&v86[1] >= 0xF4241uLL)
          {
            AppleBCMWLANPCIeSkywalkPacket::setPktLifetime((uint64_t)v22, -2);
            if (*(void *)(*((void *)this + 8) + 80) && CCLogStream::shouldLog()) {
              CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 80), "[dk] %s@%d:com.apple.p2p: Got an packet with lifetime more than a second: lifetime:%llu msg[fillCount].lifetime_250us: %d, scale=%d\n", "fwRingFill", 669, *(void *)&v86[1], *v30, a3[48 * v18 + 45] & 7);
            }
          }
          else
          {
            unint64_t v59 = *(unsigned int *)&v86[1] / 0xFAuLL;
            *(void *)&v86[1] = v59;
            uint64_t v60 = &a3[48 * v18];
            char v62 = v60[45];
            uint64_t v61 = v60 + 45;
            char v63 = v62 & 0xF8;
            if (v58 >> 9 >= 0x7D)
            {
              do
              {
                unint64_t v64 = v59;
                v59 >>= 1;
                char v63 = v63 & 0xF8 | (v63 + 1) & 7;
              }
              while (v64 > 0x1FF);
              *(void *)&v86[1] = v59;
            }
            *uint64_t v61 = v63;
            unsigned __int8 *v30 = v59;
          }
        }
      }
      char *v27 = 15;
      v27[1] = v79;
      if ((*(unsigned int (**)(void))(**(void **)(*((void *)this + 8) + 112) + 248))(*(void *)(*((void *)this + 8) + 112))) {
        char v31 = -127;
      }
      else {
        char v31 = 1;
      }
      v27[2] = v31;
      unsigned int v32 = &a3[48 * v18];
      v32[22] = 0;
      v32[22] |= (32 * (*(uint64_t (**)(void))(**(void **)(*((void *)this + 8) + 112) + 344))()) | 1;
      v32[44] = 0;
      uint64_t v33 = v32 + 44;
      *(v33 - 2IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = 1;
      __int16 v87 = -1;
      if (AppleBCMWLANHashtable::add(TxPacketTracker, v22, (unsigned __int16 *)&v87))
      {
        if (*(void *)(*((void *)this + 8) + 80) && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 8) + 80), "[dk] %s@%d:tx submit, out of tracker\n", "fwRingFill", 700);
        }
        AppleBCMWLANPCIeFlowQueue::enqueuePacket(this, (AppleBCMWLANPCIeSkywalkPacket *)v22, 1);
        return v18;
      }
      AppleBCMWLANPCIeSkywalkPacket::setPacketId((uint64_t)v22, v87);
      unsigned int Headroom = IO80211NetworkPacket::getHeadroom((IO80211NetworkPacket *)v22);
      uint64_t v35 = ((uint64_t (*)(IOUserNetworkPacket *))v22->OSObject::OSMetaClassBase::__vftable[1].getDataLength)(v22)
          + Headroom;
      if (v78)
      {
        uint64_t v36 = v35 + v76;
        Headroom -= v77;
        uint64_t v37 = *(void *)v35;
        int v38 = *(_DWORD *)(v35 + 8);
        *(_WORD *)(v36 + 12) = *(_WORD *)(v35 + 12);
        *(_DWORD *)(v36 + 8) = v38;
        *(void *)uint64_t v36 = v37;
        *(void *)(v36 + 14) = 0x8F2170003AAAALL;
        *(void *)(v36 + 20) = 0xDEADBEEF04030008;
        *(_WORD *)(v36 + 12) = bswap32(((uint64_t (*)(IOUserNetworkPacket *))v22->getDataLength)(v22) + 14) >> 16;
        ((void (*)(IOUserNetworkPacket *))v22->setDataLength)(v22);
        uint64_t v35 = v36;
      }
      int v39 = &a3[48 * v18];
      uint64_t v40 = *(void *)v35;
      int v41 = *(_DWORD *)(v35 + 8);
      *((_WORD *)v39 + 10) = *(_WORD *)(v35 + 12);
      *((_DWORD *)v39 + 4) = v41;
      *((void *)v39 + IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = v40;
      uint64_t v42 = AppleBCMWLANPCIeSkywalkPacket::getBusAddress((AppleBCMWLANPCIeSkywalkPacket *)v22) + Headroom + 14;
      *((_WORD *)v39 + 2IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = ((uint64_t (*)(IOUserNetworkPacket *))v22->getDataLength)(v22) - 14;
      *((void *)v39 + 4) = v42;
      *((_WORD *)v27 + 2) = v87;
      *((_WORD *)v27 + AppleBCMWLANSensingAdapter::free(this - 3) = (*(uint64_t (**)(void))(**(void **)(*((void *)this + 8) + 112) + 296))();
      if (((unsigned int (*)(IOUserNetworkPacket *))v22->OSObject::OSMetaClassBase::__vftable[1].Dispatch)(v22) == 4718992
        && AppleBCMWLANPCIeSkywalkPacket::getAc((AppleBCMWLANPCIeSkywalkPacket *)v22) == 3)
      {
        if (IO80211SkywalkInterface::getController(*(IO80211SkywalkInterface **)(*((void *)this + 8) + 104)))
        {
          Controller = (AppleBCMWLANCore *)IO80211SkywalkInterface::getController(*(IO80211SkywalkInterface **)(*((void *)this + 8) + 104));
          if (AppleBCMWLANCore::getReliableL3CtrlTxProfileActive(Controller)) {
            a3[48 * v18 + 46] = 0x80;
          }
        }
      }
      char v44 = ((uint64_t (*)(IOUserNetworkPacket *))v22->OSObject::OSMetaClassBase::__vftable[1]._SetPacketIndex)(v22);
      uint64_t v45 = *((void *)this + 8);
      if ((v44 & 1) != 0 || *(unsigned char *)(v45 + 140))
      {
        if (*(_DWORD *)(v45 + 144) == 3)
        {
          uint64_t HostSWTimestamp = AppleBCMWLANBusInterfacePCIe::readHostSWTimestamp(*(AppleBCMWLANBusInterfacePCIe **)(v45 + 96), "fwRingFill");
          ((void (*)(IOUserNetworkPacket *, uint64_t))v22->OSObject::OSMetaClassBase::__vftable[1].free)(v22, HostSWTimestamp);
          uint64_t v45 = *((void *)this + 8);
        }
        if (!*(unsigned char *)(v45 + 142))
        {
          *v33 |= *(unsigned char *)(v45 + 143);
          if ((*(unsigned char *)(*((void *)this + 8) + 143) & 4) != 0) {
            a3[48 * v18 + 46] = 0;
          }
        }
      }
      int v47 = ((uint64_t (*)(IOUserNetworkPacket *))v22->OSObject::OSMetaClassBase::__vftable[1]._SetPacketIndex)(v22);
      uint64_t v49 = *((void *)this + 8);
      if (v47 && *(unsigned char *)(v49 + 141))
      {
        v86[0] = 0;
        *(void *)int v85 = 0;
        memset(v84, 0, sizeof(v84));
        *(_WORD *)size_t v83 = 0;
        if (AppleBCMWLANUtil::isPTPPacket((AppleBCMWLANUtil *)v22, (AppleBCMWLANPCIeSkywalkPacket *)1, v86, v85, (unsigned __int8 **)&v84[1], (unsigned __int8 **)v84, v83, v48))
        {
          uint64_t v50 = *(unsigned __int8 **)v85;
          uint64_t v51 = -16;
          if (!v86[0]) {
            uint64_t v51 = -4;
          }
          uint64_t v52 = (unsigned __int8 *)(*(void *)&v84[1] + v51);
          uint64_t v82 = 0;
          ((void (*)(IOUserNetworkPacket *, uint64_t *))v22->OSObject::OSMetaClassBase::__vftable[1]._GetPacketIndex)(v22, &v82);
          if (v86[0])
          {
            uint64_t v53 = 0;
            while (AppleBCMWLANUtil::kPTPMessageTypeStringMapping[v53] != v84[0])
            {
              v53 += 4;
              if (v53 == 36)
              {
                uint64_t v54 = "unknown";
                goto LABEL_84;
              }
            }
            uint64_t v54 = *(const char **)&AppleBCMWLANUtil::kPTPMessageTypeStringMapping[v53 + 2];
LABEL_84:
            IOLog("[WiFiTimeSync+] Tx UDPv6 message %s sequence %d from %02x%02x:%02x%02x_%02x%02x:%02x%02x @ %02x:%02x:%02x:%02x:%02x:%02x to %02x%02x:%02x%02x_%02x%02x:%02x%02x @ %02x:%02x:%02x:%02x:%02x:%02x submitted. fIgnore %d extendedFlags 0x%x ts %llu", v54, *(unsigned __int16 *)v83, *v52, v52[1], v52[2], v52[3], v52[12], v52[13], v52[14], v52[15], v50[6], v50[7], v50[8], v50[9]);
          }
          else
          {
            uint64_t v65 = 0;
            while (AppleBCMWLANUtil::kPTPMessageTypeStringMapping[v65] != v84[0])
            {
              v65 += 4;
              if (v65 == 36)
              {
                uint64_t v66 = "unknown";
                goto LABEL_89;
              }
            }
            uint64_t v66 = *(const char **)&AppleBCMWLANUtil::kPTPMessageTypeStringMapping[v65 + 2];
LABEL_89:
            IOLog("[WiFiTimeSync+] Tx UDPv4 message %s sequence %d from %u.%u.%u.%u @ %02x:%02x:%02x:%02x:%02x:%02x to %u.%u.%u.%u @ %02x:%02x:%02x:%02x:%02x:%02x submitted. fIgnore %d extendedFlags 0x%x ts %llu", v66, *(unsigned __int16 *)v83, *v52, v52[1], v52[2], v52[3], v50[6], v50[7], v50[8], v50[9]);
          }
        }
        uint64_t v49 = *((void *)this + 8);
      }
      ++*(void *)(v49 + 160);
      uint64_t v18 = (v18 + 1);
LABEL_92:
      if (v18 >= a4) {
        goto LABEL_97;
      }
    }
    unsigned int v24 = v23;
    uint64_t v25 = *((void *)this + 8);
    if (*(void *)(v25 + 80))
    {
      int v26 = CCLogStream::shouldLog();
      uint64_t v25 = *((void *)this + 8);
      if (v26)
      {
        uint64_t v68 = *(CCLogStream **)(v25 + 80);
        unint64_t v69 = (const char *)(*(uint64_t (**)(void))(**(void **)(v25 + 104) + 160))(*(void *)(v25 + 104));
        CCLogStream::logAlert(v68, "[dk] %s@%d:Got packet of invalid length %d on %s. Deallocating\n", "fwRingFill", 630, v24, v69);
LABEL_95:
        uint64_t v25 = *((void *)this + 8);
      }
    }
    goto LABEL_34;
  }
  uint64_t v18 = 0;
LABEL_97:
  AppleBCMWLANBusInterfacePCIe::updateActiveTxPacketCount(*(void *)(*((void *)this + 8) + 96), v18);
  unsigned int RingFreeSpace = AppleBCMWLANPCIeFlowQueue::getRingFreeSpace(this);
  if (!v75)
  {
    unsigned int v71 = RingFreeSpace;
    uint64_t v72 = (*(uint64_t (**)(void))(**(void **)(*((void *)this + 8) + 104) + 1096))(*(void *)(*((void *)this + 8) + 104));
    if (v72) {
      BOOL v73 = v71 == 0;
    }
    else {
      BOOL v73 = 1;
    }
    if (!v73) {
      (*(void (**)(uint64_t))(*(void *)v72 + 120))(v72);
    }
  }
  return v18;
}

uint64_t AppleBCMWLANPCIeFlowQueue::fwRingError(AppleBCMWLANPCIeFlowQueue *this, AppleBCMWLANByteRing *a2, int a3, void *a4)
{
  uint64_t result = *(void *)(*((void *)this + 8) + 80);
  if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result)
    {
      uint64_t v7 = *((void *)this + 8);
      return CCLogStream::logAlert(*(CCLogStream **)(v7 + 80), "[dk] %s@%d:FW Ring error for peer [%02x:%02x:%02x:%02x:%02x:%02x]: %d", "fwRingError", 566, *(unsigned __int8 *)(v7 + 36), *(unsigned __int8 *)(v7 + 37), *(unsigned __int8 *)(v7 + 38), *(unsigned __int8 *)(v7 + 39), *(unsigned __int8 *)(v7 + 40), *(unsigned __int8 *)(v7 + 41), a3);
    }
  }
  return result;
}

void *AppleBCMWLANPCIeFlowQueue::dequeueSkywalkPacket(AppleBCMWLANPCIeFlowQueue *this)
{
  if (*((void *)this + 8) + 48 == *(void *)(*((void *)this + 8) + 48)) {
    return 0;
  }
  --*(_DWORD *)(*((void *)this + 8) + 64);
  uint64_t v1 = *((void *)this + 8);
  unsigned int v4 = *(void **)(v1 + 48);
  uint64_t v3 = (void *)(v1 + 48);
  uint64_t result = v4;
  if (v4 == v3) {
    return (void *)AppleBCMWLANPCIeSkywalkPacket::fromChain(0);
  }
  if (*(void **)result[1] == result && (uint64_t v5 = *result, *(void **)(*result + 8) == result))
  {
    *(void *)(v5 + 8) = v3;
    *uint64_t v3 = v5;
    *uint64_t result = 0;
    result[1] = 0;
    return (void *)AppleBCMWLANPCIeSkywalkPacket::fromChain((uint64_t)result);
  }
  else
  {
    __break(1u);
  }
  return result;
}

IOUserNetworkPacket *AppleBCMWLANPCIeFlowQueue::flushPackets(AppleBCMWLANPCIeFlowQueue *this)
{
  uint64_t result = (IOUserNetworkPacket *)AppleBCMWLANPCIeFlowQueue::dequeueSkywalkPacket(this);
  if (result)
  {
    uint64_t v3 = result;
    do
    {
      AppleBCMWLANPCIeSkywalkPacketPool::deallocatePacket(*(AppleBCMWLANPCIeSkywalkPacketPool **)(*((void *)this + 8) + 120), v3);
      ++*(void *)(*((void *)this + 8) + 168);
      uint64_t result = (IOUserNetworkPacket *)AppleBCMWLANPCIeFlowQueue::dequeueSkywalkPacket(this);
      uint64_t v3 = result;
    }
    while (result);
  }
  return result;
}

uint64_t AppleBCMWLANPCIeFlowQueue::clearFlowId(uint64_t this)
{
  *(_WORD *)(*(void *)(this + 64) + 136) = -1;
  return this;
}

uint64_t AppleBCMWLANPCIeFlowQueue::getPendingPacketCount(AppleBCMWLANPCIeFlowQueue *this)
{
  uint64_t v2 = *((void *)this + 8);
  uint64_t v3 = *(AppleBCMWLANItemRing **)(v2 + 112);
  if (v3) {
    return *(_DWORD *)(*((void *)this + 8) + 64) + AppleBCMWLANItemRing::getReadableItemCount(v3);
  }
  else {
    return *(unsigned int *)(v2 + 64);
  }
}

uint64_t AppleBCMWLANPCIeFlowQueue::requestPendingPackets(AppleBCMWLANPCIeFlowQueue *this)
{
  uint64_t v1 = *((void *)this + 8);
  uint64_t result = *(void *)(v1 + 112);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)result + 192))(result, *(unsigned int *)(v1 + 64), 1);
  }
  return result;
}

AppleBCMWLANItemRing *AppleBCMWLANPCIeFlowQueue::getRingFreeSpace(AppleBCMWLANPCIeFlowQueue *this)
{
  uint64_t v2 = *((void *)this + 8);
  uint64_t result = *(AppleBCMWLANItemRing **)(v2 + 112);
  if (result)
  {
    unsigned int v4 = *(_DWORD *)(v2 + 64);
    if (v4 > AppleBCMWLANItemRing::getWritableItemCount(result)) {
      return 0;
    }
    else {
      return (AppleBCMWLANItemRing *)(AppleBCMWLANItemRing::getWritableItemCount(*(AppleBCMWLANItemRing **)(*((void *)this + 8) + 112))
    }
                                    - *(_DWORD *)(*((void *)this + 8) + 64));
  }
  return result;
}

uint64_t AppleBCMWLANPCIeFlowQueue::collectQueueStats(AppleBCMWLANPCIeFlowQueue *this, char *a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v7 = *(IO80211WorkSource **)(*((void *)this + 8) + 112);
  if (v7)
  {
    IO80211WorkSource::isEnabled(v7);
    (*(void (**)(void))(**(void **)(*((void *)this + 8) + 112) + 208))(*(void *)(*((void *)this + 8) + 112));
    AppleBCMWLANItemRing::getReadableItemCount(*(AppleBCMWLANItemRing **)(*((void *)this + 8) + 112));
    AppleBCMWLANItemRing::getWritableItemCount(*(AppleBCMWLANItemRing **)(*((void *)this + 8) + 112));
  }
  uint64_t v8 = IO80211Print() + a5;
  uint64_t v9 = IO80211Print() + v8;
  absolutetime_to_nanoseconds();
  return IO80211Print() + v9;
}

uint64_t AppleBCMWLANPCIeFlowQueue::getPacketCount(AppleBCMWLANPCIeFlowQueue *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 64);
}

uint64_t AppleBCMWLANPCIeFlowQueue::getFlowHash(AppleBCMWLANPCIeFlowQueue *this)
{
  return *((void *)this + 8) + 128;
}

uint64_t AppleBCMWLANPCIeFlowQueue::getFlowId(AppleBCMWLANPCIeFlowQueue *this)
{
  return *(unsigned __int16 *)(*((void *)this + 8) + 136);
}

uint64_t AppleBCMWLANPCIeFlowQueue::getDestination(AppleBCMWLANPCIeFlowQueue *this)
{
  return *((void *)this + 8) + 36;
}

uint64_t AppleBCMWLANPCIeFlowQueue::getTxCompLatency(AppleBCMWLANPCIeFlowQueue *this)
{
  return *(void *)(*((void *)this + 8) + 72);
}

uint64_t AppleBCMWLANPCIeFlowQueue::setTxCompLatency(uint64_t this, uint64_t a2)
{
  *(void *)(*(void *)(this + 64) + 72) = a2;
  return this;
}

uint64_t AppleBCMWLANPCIeFlowQueue::getSequenceNumber(AppleBCMWLANPCIeFlowQueue *this)
{
  uint64_t v1 = *((void *)this + 8);
  uint64_t result = *(unsigned __int16 *)(v1 + 138);
  *(_WORD *)(v1 + 138) = result + 1;
  return result;
}

void _GLOBAL__sub_I_AppleBCMWLANPCIeFlowQueue_cpp()
{
  kNullRange = 0;
}

OSObject *AppleBCMWLANCommand::newCmd(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANCommandMetaClass, &v8)) {
    return 0;
  }
  BOOL v6 = v8;
  if (v8
    && (((uint64_t (*)(OSObject *, uint64_t, uint64_t, uint64_t))v8->OSMetaClassBase::__vftable[1].getMetaClass)(v8, a1, a2, a3) & 1) == 0)
  {
    ((void (*)(OSObject *))v6->release)(v6);
    return 0;
  }
  return v6;
}

uint64_t AppleBCMWLANCommand::initWithOptions(IOCommand *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = IOCommand::init(a1);
  if (result)
  {
    uint64_t result = IOMallocZeroTyped();
    *((void *)a1 + 7) = result;
    if (result)
    {
      *(void *)(*((void *)a1 + 7) + 152) = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a2 + 48) + 120))(a2 + 48, a3 + 16, a4);
      if (*(void *)(*((void *)a1 + 7) + 152))
      {
        return 1;
      }
      else
      {
        ClassNameHelper = (const char *)getClassNameHelper((OSObject *)a1);
        IOLog("%s::%s(): Failure allocating txBuffer\n", ClassNameHelper, "initWithOptions");
        return 0;
      }
    }
  }
  return result;
}

uint64_t non-virtual thunk to'AppleBCMWLANCommand::initWithOptions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return AppleBCMWLANCommand::initWithOptions((IOCommand *)(a1 - 48), a2, a3, a4);
}

uint64_t AppleBCMWLANCommand::free(AppleBCMWLANCommand *this)
{
  uint64_t v2 = (void *)*((void *)this + 7);
  uint64_t v3 = v2[19];
  if (!v3
    || ((*(void (**)(void))(*(void *)v3 + 16))(v2[19]),
        *(void *)(*((void *)this + 7) + 152) = 0,
        (uint64_t v2 = (void *)*((void *)this + 7)) != 0))
  {
    memset_s(v2, 0xE8uLL, 0, 0xE8uLL);
    unsigned int v4 = (void *)*((void *)this + 7);
    if (v4)
    {
      IOFree(v4, 0xE8uLL);
      *((void *)this + 7) = 0;
    }
  }
  return IOCommand::free(this);
}

uint64_t non-virtual thunk to'AppleBCMWLANCommand::free(AppleBCMWLANCommand *this)
{
  return AppleBCMWLANCommand::free((AppleBCMWLANCommand *)((char *)this - 24));
}

uint64_t AppleBCMWLANCommand::prepare(uint64_t a1, unsigned __int8 *a2, __int16 a3, uint64_t a4, uint64_t a5, _DWORD *a6, long long *a7, int a8)
{
  size_t v16 = *(unsigned __int16 *)(a4 + 8);
  BOOL v17 = (const char *)*((void *)a2 + 1);
  if (v17)
  {
    size_t v18 = strlen(v17) + 1;
    v16 += v18;
    if (v16 >> 16) {
      return 3758096385;
    }
    uint64_t v37 = a5;
  }
  else
  {
    uint64_t v37 = a5;
    size_t v18 = 0;
  }
  int v19 = a8;
  AppleBCMWLANTxBuffer::setPayloadLength(*(void *)(*(void *)(a1 + 56) + 152), v16 + 16);
  uint64_t v20 = *(void *)(a1 + 56);
  *(void *)(v20 + 72) = 0;
  *(_OWORD *)(v20 + 56) = 0u;
  *(_OWORD *)(v20 + 40) = 0u;
  *(_DWORD *)(*(void *)(a1 + 56) + 80) = 0;
  if (*((void *)a2 + 1))
  {
    uint64_t Payload = (char *)AppleBCMWLANTxBuffer::getPayload(*(AppleBCMWLANTxBuffer **)(*(void *)(a1 + 56) + 152), 16);
    strlcpy(Payload, *((const char **)a2 + 1), v16);
    uint64_t v22 = (const char *)*((void *)a2 + 1);
    uint64_t v23 = strlen(v22) + 17;
  }
  else
  {
    uint64_t v22 = 0;
    uint64_t v23 = 16;
  }
  if (*(_WORD *)(a4 + 8) && *(void *)a4)
  {
    unsigned int v24 = (void *)AppleBCMWLANTxBuffer::getPayload(*(AppleBCMWLANTxBuffer **)(*(void *)(a1 + 56) + 152), v23);
    memcpy(v24, *(const void **)a4, *(unsigned __int16 *)(a4 + 8));
    uint64_t v22 = (const char *)*((void *)a2 + 1);
  }
  *(unsigned char *)(*(void *)(a1 + 56) + 100) = *a2;
  *(_DWORD *)(*(void *)(a1 + 56) + 104) = *((_DWORD *)a2 + 1);
  *(_DWORD *)(*(void *)(a1 + 56) + 140) = *((_DWORD *)a2 + 4);
  uint64_t v25 = (char *)(*(void *)(a1 + 56) + 108);
  if (v22) {
    strlcpy(v25, v22, 0x20uLL);
  }
  else {
    char *v25 = 0;
  }
  *(_WORD *)(*(void *)(a1 + 56) + 144) = a3;
  *(_DWORD *)(*(void *)(a1 + 56) + 160) = *a6;
  uint64_t v26 = *(void *)(a1 + 56);
  long long v27 = *a7;
  *(void *)(v26 + 200) = *((void *)a7 + 2);
  *(_OWORD *)(v26 + 184) = v27;
  *(void *)(*(void *)(a1 + 56) + 176) = v37;
  *(_DWORD *)(*(void *)(a1 + 56) + 216) = -536870911;
  *(unsigned char *)(*(void *)(a1 + 56) + 220) = 0;
  unint64_t v28 = (_DWORD *)AppleBCMWLANTxBuffer::getPayload(*(AppleBCMWLANTxBuffer **)(*(void *)(a1 + 56) + 152), 0);
  int v29 = *((_DWORD *)a2 + 4) & 2;
  v28[2] = v29;
  v28[3] = 0;
  v28[2] = (*(unsigned __int16 *)(*(void *)(a1 + 56) + 144) << 16) | (*a2 << 12) | v29;
  _DWORD *v28 = *((_DWORD *)a2 + 1);
  uint64_t v30 = *(void *)(a1 + 56);
  int v31 = *(_DWORD *)(v30 + 104);
  unsigned int v32 = *(unsigned __int16 *)(v30 + 162);
  if (v31 == 262 && v32 < 0x7FD)
  {
    size_t v33 = v18 + v32;
    if (v33 >> 16) {
      return 3758096385;
    }
    int v35 = v33 | (v16 << 16);
  }
  else
  {
    int v35 = v32 | (v16 << 16);
  }
  v28[1] = v35;
  AppleBCMWLANTxBuffer::setBusPreference(*(void *)(*(void *)(a1 + 56) + 152), v19);
  *(_DWORD *)(*(void *)(a1 + 56) + 224) = v19;
  *(_DWORD *)(*(void *)(a1 + 56) + 96) = 0;
  cmdID2Name(*((_DWORD *)a2 + 1));
  uint64_t v36 = *(void *)(a1 + 56);
  if ((*((_DWORD *)a2 + 1) & 0xFFFFFFFE) == 0x106)
  {
    AppleBCMWLANTxBuffer::getPayload(*(AppleBCMWLANTxBuffer **)(v36 + 152), 16);
    snprintf((char *)v36, 0x22uLL, "%s: %s");
  }
  else
  {
    snprintf((char *)v36, 0x22uLL, "%s");
  }
  return 0;
}

uint64_t AppleBCMWLANCommand::commit(AppleBCMWLANCommand *this)
{
  *(_DWORD *)(*((void *)this + 7) + 96) = 1;
  return 0;
}

uint64_t AppleBCMWLANCommand::complete(OSObject *this, IO80211CagedBuffer *a2)
{
  uint64_t v36 = 0;
  *(void *)uint64_t v37 = 0;
  meta = this[1].meta;
  uint64_t v5 = *(IO80211Buffer **)&meta[5].refcount;
  if (!v5
    || !IO80211Buffer::getBytesNoCopy(*(IO80211Buffer **)&meta[5].refcount)
    || !IO80211Buffer::readBytes(v5, 0, &v36))
  {
    goto LABEL_7;
  }
  uint64_t BytesNoCopy = IO80211Buffer::getBytesNoCopy(v5);
  int metaClassPrivate = (int)this[1].meta[6].metaClassPrivate;
  if (metaClassPrivate == -536870911)
  {
    LODWORD(this[1].meta[6].metaClassPrivate) = mapBcmErrorToIOReturn(v37[1]);
    int metaClassPrivate = (int)this[1].meta[6].metaClassPrivate;
  }
  if (metaClassPrivate)
  {
LABEL_7:
    unint64_t v8 = 0;
    uint64_t v9 = 0;
    goto LABEL_8;
  }
  if (BytesNoCopy - 16 >= (unint64_t)WORD2(v36)) {
    unint64_t v8 = WORD2(v36);
  }
  else {
    unint64_t v8 = BytesNoCopy - 16;
  }
  uint64_t v9 = (const void *)(IO80211Buffer::getBytesNoCopy(v5) + 16);
  unsigned __int8 v13 = this[1].meta;
  BOOL v14 = v13[5].meta;
  if (v14 && v14->__vftable)
  {
    if (LOBYTE(v13[3].reserved) && v13[3].refcount == 262 && LOWORD(v14->refcount) <= 0x7FCu)
    {
      size_t v15 = strlen((const char *)&v13[3].reserved);
      if (v8 > v15 + 1) {
        size_t v16 = v15 + 1;
      }
      else {
        size_t v16 = 0;
      }
      v8 -= v16;
    }
    int v17 = -536870168;
    if (v8 <= (unint64_t)LOWORD(v14->refcount) + 3 && v8 <= (unint64_t)WORD1(v13[5].__vftable) + 3)
    {
      if (v8 >= LOWORD(v13[5].__vftable))
      {
LABEL_31:
        if (v8 >= LOWORD(this[1].meta[5].meta->refcount)) {
          unint64_t refcount_low = LOWORD(this[1].meta[5].meta->refcount);
        }
        else {
          unint64_t refcount_low = v8;
        }
        if (refcount_low >= IO80211Buffer::getLength(v5) - 16) {
          LOWORD(refcount_low) = IO80211Buffer::getLength(v5) - 16;
        }
        IO80211Buffer::readBytes(v5, 16, this[1].meta[5].meta->OSMetaClassBase::__vftable);
        LOWORD(this[1].meta[5].meta->refcount) = refcount_low;
        goto LABEL_8;
      }
      int v17 = -536870169;
    }
    LODWORD(v13[6].metaClassPrivate) = v17;
    goto LABEL_31;
  }
LABEL_8:
  uint64_t v10 = this[1].meta;
  if (v10[6].__vftable && v10[5].metaClassPrivate)
  {
    if (IO80211CagedBuffer::tryLock(a2))
    {
      if (v8) {
        uint64_t v11 = IO80211CagedBuffer::copyIn(a2, v9, v8);
      }
      else {
        uint64_t v11 = 0;
      }
    }
    else
    {
      ClassNameHelper = (const char *)getClassNameHelper(this);
      IOLog("%s::%s(): Failed to lock commandAsyncResponseCagedBuffer\n", ClassNameHelper, "complete");
      uint64_t v11 = 0;
      LODWORD(this[1].meta[6].metaClassPrivate) = -536870196;
    }
    long long v35 = kNoRxPayload;
    if (v8 - 1 <= 0xFFFE && v11 == v8)
    {
      uint64_t Buffer = IO80211CagedBuffer::getBuffer(a2);
      uint64_t v20 = this[1].meta;
      unint64_t v21 = v8 | ((unint64_t)LODWORD(v20[5].__vftable) << 16);
      if (!Buffer) {
        unint64_t v21 = 0;
      }
      *(void *)&long long v35 = Buffer;
      *((void *)&v35 + IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = v21;
    }
    else
    {
      uint64_t v20 = this[1].meta;
    }
    uint64_t v22 = v20[5].metaClassPrivate;
    uint64_t v23 = v20[6].__vftable;
    char v24 = BYTE4(v20[3].__vftable);
    __int32 refcount = v20[3].refcount;
    int32_t reserved = v20[4].reserved;
    p_int32_t reserved = &v20[3].reserved;
    int v34 = -1431655766;
    v31[0] = -1431655766;
    LOBYTE(v31[0]) = v24;
    v31[1] = refcount;
    int32_t v33 = reserved;
    ((void (*)(OSMetaClassPrivate *, _DWORD *, void, long long *, void))v23)(v22, v31, LODWORD(v20[6].metaClassPrivate), &v35, *(void *)&v20[6].refcount);
    IO80211CagedBuffer::unlock(a2);
    uint64_t v10 = this[1].meta;
  }
  long long v27 = *(IO80211Buffer **)&v10[5].refcount;
  if (v27)
  {
    IO80211Buffer::returnBuffer(v27);
    *(void *)&this[1].meta[5].__int32 refcount = 0;
    uint64_t v10 = this[1].meta;
  }
  LODWORD(v10[3].__vftable) = 2;
  unint64_t v28 = this[1].meta;
  if ((v28[4].reserved & 4) != 0)
  {
    int v29 = v28[2].metaClassPrivate;
    if (v29) {
      (*(void (**)(OSMetaClassPrivate *, OSObject *))(*(void *)v29 + 88))(v29, this);
    }
  }
  return 0;
}

uint64_t AppleBCMWLANCommand::getStatus(AppleBCMWLANCommand *this)
{
  return *(unsigned int *)(*((void *)this + 7) + 216);
}

uint64_t AppleBCMWLANCommand::setStatus(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 56) + 216) = a2;
  return this;
}

uint64_t AppleBCMWLANCommand::setResponse(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(result + 56) + 168) = a2;
  return result;
}

uint64_t AppleBCMWLANCommand::setQueuedTimestamp(AppleBCMWLANCommand *this, int a2)
{
  mach_continuous_time();
  uint64_t result = absolutetime_to_nanoseconds();
  *(_DWORD *)(*((void *)this + 7) + 80) = a2;
  return result;
}

uint64_t AppleBCMWLANCommand::setCommandGate(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(result + 56) + 88) = a2;
  return result;
}

uint64_t AppleBCMWLANCommand::setOutofOrderResponse(uint64_t this)
{
  *(unsigned char *)(*(void *)(this + 56) + 220) = 1;
  return this;
}

uint64_t AppleBCMWLANCommand::setSubCmdID(uint64_t this, __int16 a2)
{
  *(_WORD *)(*(void *)(this + 56) + 228) = a2;
  return this;
}

uint64_t AppleBCMWLANCommand::getBuffer(AppleBCMWLANCommand *this)
{
  return *(void *)(*((void *)this + 7) + 152);
}

BOOL AppleBCMWLANCommand::isCommandState(uint64_t a1, int a2)
{
  return *(_DWORD *)(*(void *)(a1 + 56) + 96) == a2;
}

uint64_t AppleBCMWLANCommand::getIOCtl(AppleBCMWLANCommand *this)
{
  return *(unsigned int *)(*((void *)this + 7) + 104);
}

uint64_t AppleBCMWLANCommand::getIOVar(AppleBCMWLANCommand *this)
{
  return *((void *)this + 7) + 108;
}

uint64_t AppleBCMWLANCommand::getCommandType(AppleBCMWLANCommand *this)
{
  return *(unsigned int *)(*((void *)this + 7) + 140);
}

uint64_t AppleBCMWLANCommand::getTransactionID(AppleBCMWLANCommand *this)
{
  return *(unsigned __int16 *)(*((void *)this + 7) + 144);
}

uint64_t AppleBCMWLANCommand::getResponse(AppleBCMWLANCommand *this)
{
  return *(void *)(*((void *)this + 7) + 168);
}

uint64_t AppleBCMWLANCommand::hasOutofOrderResponse(AppleBCMWLANCommand *this)
{
  return *(unsigned __int8 *)(*((void *)this + 7) + 220);
}

uint64_t AppleBCMWLANCommand::getCmdName(AppleBCMWLANCommand *this)
{
  return *((void *)this + 7);
}

uint64_t AppleBCMWLANCommand::getSubCmdID(AppleBCMWLANCommand *this)
{
  return *(unsigned __int16 *)(*((void *)this + 7) + 228);
}

uint64_t AppleBCMWLANCommand::getQueuedTime_ns(AppleBCMWLANCommand *this, unsigned int a2)
{
  return *(void *)(*((void *)this + 7) + 8 * a2 + 40);
}

uint64_t AppleBCMWLANCommand::getQueuedTime_ns(AppleBCMWLANCommand *this)
{
  return *(void *)(*((void *)this + 7) + 8 * *(unsigned int *)(*((void *)this + 7) + 80) + 40);
}

unint64_t AppleBCMWLANCommand::getQueuedDuration_ms(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 56);
  unint64_t v3 = *(void *)(v2 + 8 * a2 + 40);
  if (!v3) {
    return 0;
  }
  unint64_t v8 = 0;
  unint64_t v4 = ((int)(a2 + 1) % 5);
  if (v4 > 4) {
    goto LABEL_7;
  }
  uint64_t v5 = v2 + 40;
  do
  {
    unint64_t v6 = *(void *)(v5 + 8 * v4);
    unint64_t v8 = v6;
    if (v4 > 3) {
      break;
    }
    ++v4;
  }
  while (!v6);
  if (!v6)
  {
LABEL_7:
    mach_continuous_time();
    absolutetime_to_nanoseconds();
    unint64_t v6 = v8;
  }
  if (v6 >= v3) {
    return (v6 - v3) / 0xF4240;
  }
  else {
    return 0;
  }
}

unint64_t AppleBCMWLANCommand::getQueuedDuration_ms(AppleBCMWLANCommand *this)
{
  return -*(void *)(*((void *)this + 7) + 8 * *(unsigned int *)(*((void *)this + 7) + 80) + 40) / 0xF4240uLL;
}

uint64_t AppleBCMWLANCommand::logCmd(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6)
{
  uint64_t result = AppleBCMWLANTxBuffer::getPayload(*(AppleBCMWLANTxBuffer **)(*(void *)(a1 + 56) + 152), 0);
  if (a2)
  {
    uint64_t result = CCLogStream::shouldLog();
    if ((result & 1) != 0 || a6 == -1 && (uint64_t result = CCLogStream::shouldLog(), result))
    {
      AppleBCMWLANCommand::getQueuedDuration_ms(a1, 1u);
      AppleBCMWLANCommand::getQueuedDuration_ms(a1, 2u);
      AppleBCMWLANCommand::getQueuedDuration_ms(a1, 3u);
      AppleBCMWLANCommand::getQueuedDuration_ms(a1, 4u);
      if (a4)
      {
        uint64_t v11 = *(IO80211Buffer **)(*(void *)(a1 + 56) + 168);
        if (v11) {
          IO80211Buffer::getBytesNoCopy(v11);
        }
      }
      return CCLogStream::logIf();
    }
  }
  return result;
}

uint64_t AppleBCMWLANCommand::logCmdBuf(AppleBCMWLANCommand *this, void *a2, const char *a3, char a4)
{
  AppleBCMWLANTxBuffer::getPayload(*(AppleBCMWLANTxBuffer **)(*((void *)this + 7) + 152), 0);
  unint64_t v8 = *(void *)(*((void *)this + 7) + 48);
  uint64_t v9 = *((unsigned int *)a2 + 4);
  unsigned int v10 = *(_DWORD *)a2;
  unsigned int v11 = *(_DWORD *)a2 - 1;
  if (a4)
  {
    if (v9 < v11)
    {
      uint64_t v20 = a2[1];
      if (v20)
      {
        size_t v34 = v10 - v9;
        uint64_t v36 = (char *)(v20 + v9);
        unint64_t v33 = v8 / 0x3B9ACA00;
        unint64_t v32 = (274877907 * (v8 % 0x3B9ACA00)) >> 38;
        unint64_t QueuedDuration_ms = AppleBCMWLANCommand::getQueuedDuration_ms((uint64_t)this, 1u);
        unint64_t v30 = AppleBCMWLANCommand::getQueuedDuration_ms((uint64_t)this, 2u);
        unint64_t v29 = AppleBCMWLANCommand::getQueuedDuration_ms((uint64_t)this, 3u);
        unint64_t v21 = AppleBCMWLANCommand::getQueuedDuration_ms((uint64_t)this, 4u);
        uint64_t v22 = *((void *)this + 7);
        uint64_t v23 = *(unsigned __int16 *)(v22 + 144);
        if ((*(unsigned char *)(v22 + 140) & 8) != 0) {
          char v24 = "async";
        }
        else {
          char v24 = " sync";
        }
        uint64_t v25 = *(void *)(v22 + 152);
        uint64_t v26 = *(IO80211Buffer **)(v22 + 168);
        if (v26)
        {
          uint64_t v27 = *(unsigned __int16 *)(v22 + 144);
          uint64_t v28 = *(void *)(v22 + 152);
          IO80211Buffer::getBytesNoCopy(v26);
          uint64_t v25 = v28;
          uint64_t v23 = v27;
        }
        uint64_t result = snprintf(v36, v34, "%s %06lld.%06lld [p%-2lld o%-2lld a%-2lld c%-2lld] %5u) %-32s %s %p %p [ 0x%08X len 0x%08X flgs 0x%08X stat 0x%08X if %u resp %p o %d %x]\n", a3, v33, v32, QueuedDuration_ms, v30, v29, v21, v23, v22, v24, this, v25);
        goto LABEL_14;
      }
    }
LABEL_12:
    uint64_t result = 0;
    goto LABEL_15;
  }
  if (v9 >= v11) {
    goto LABEL_12;
  }
  uint64_t v12 = a2[1];
  if (!v12) {
    goto LABEL_12;
  }
  long long v35 = (char *)(v12 + v9);
  size_t v13 = v10 - v9;
  unint64_t v14 = v8 / 0x3B9ACA00;
  unint64_t v15 = v8 % 0x3B9ACA00 / 0x3E8;
  unint64_t v16 = AppleBCMWLANCommand::getQueuedDuration_ms((uint64_t)this, 1u);
  unint64_t v17 = AppleBCMWLANCommand::getQueuedDuration_ms((uint64_t)this, 2u);
  unint64_t v18 = AppleBCMWLANCommand::getQueuedDuration_ms((uint64_t)this, 3u);
  AppleBCMWLANCommand::getQueuedDuration_ms((uint64_t)this, 4u);
  uint64_t result = snprintf(v35, v13, "%s %06lld.%06lld [p%-2lld o%-2lld a%-2lld c%-2lld] %5u) (0x%08X) %-32s %s 0x%x\n", a3, v14, v15, v16, v17, v18);
LABEL_14:
  unsigned int v10 = *(_DWORD *)a2;
  LODWORD(v9) = *((_DWORD *)a2 + 4);
LABEL_15:
  if (result < v10) {
    unsigned int v10 = result;
  }
  *((_DWORD *)a2 + 4) = v9 + v10;
  return result;
}

void _GLOBAL__sub_I_AppleBCMWLANCommand_cpp()
{
  kNullRange = 0;
}

OSObject *AppleBCMWLANTimeTrace::withSize(AppleBCMWLANTimeTrace *this, int a2, int a3)
{
  if (!this) {
    return 0;
  }
  int v5 = (int)this;
  unint64_t v8 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANTimeTraceMetaClass, &v8)) {
    return 0;
  }
  unint64_t v6 = v8;
  if (v8)
  {
    if ((((uint64_t (*)(OSObject *))v8->init)(v8) & 1) == 0
      || (LODWORD(v6[1].retain) = v5,
          HIDWORD(v6[1].getMetaClass) = a2,
          LODWORD(v6[1].getMetaClass) = a3,
          HIDWORD(v6[1].retain) = 0,
          v6[1].Dispatch = (kern_return_t (__cdecl *)(OSObject *__hidden, const IORPC))(552 * LODWORD(v6[1].retain)),
          (v6[1].isEqualTo = (BOOL (__cdecl *)(const OSMetaClassBase *__hidden, const OSMetaClassBase *))IOMallocZeroData()) == 0))
    {
      ((void (*)(OSObject *))v6->release)(v6);
      return 0;
    }
  }
  return v6;
}

BOOL AppleBCMWLANTimeTrace::init(OSObject *this)
{
  BOOL result = OSObject::init(this);
  if (result)
  {
    uint64_t v3 = IOMallocZeroTyped();
    this[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)v3;
    return v3 != 0;
  }
  return result;
}

BOOL non-virtual thunk to'AppleBCMWLANTimeTrace::init(AppleBCMWLANTimeTrace *this)
{
  return AppleBCMWLANTimeTrace::init((OSObject *)((char *)this - 24));
}

void AppleBCMWLANTimeTrace::free(OSObject *this)
{
  uint64_t v2 = this[1].OSMetaClassBase::__vftable;
  if (v2)
  {
    if (v2->isEqualTo)
    {
      IOFreeData();
      this[1].isEqualTo = 0;
    }
    else
    {
      v2->isEqualTo = 0;
      this[1].Dispatch = 0;
    }
    memset_s(this[1].OSMetaClassBase::__vftable, 0x28uLL, 0, 0x28uLL);
    uint64_t v3 = this[1].OSMetaClassBase::__vftable;
    if (v3)
    {
      IOFree(v3, 0x28uLL);
      this[1].OSMetaClassBase::__vftable = 0;
    }
  }
  OSObject::free(this);
}

void non-virtual thunk to'AppleBCMWLANTimeTrace::free(AppleBCMWLANTimeTrace *this)
{
}

uint64_t AppleBCMWLANTimeTrace::iterate(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, uint64_t, uint64_t), unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = *(void *)(a1 + 40);
  if (!a3) {
    a3 = *(_DWORD *)(v11 + 12);
  }
  if (!*(_DWORD *)(v11 + 8)) {
    return 0;
  }
  if (!a2) {
    return 3758097090;
  }
  if (!*(_DWORD *)(v11 + 12) || a3 == 0) {
    return 0;
  }
  uint64_t v13 = 0;
  unint64_t v14 = a3;
  for (unint64_t i = 1; ; ++i)
  {
    uint64_t result = a2(*(void *)(v11 + 24) + v13, a4, a5, a6);
    if (result) {
      break;
    }
    uint64_t v11 = *(void *)(a1 + 40);
    v13 += 552;
    if (i >= *(unsigned int *)(v11 + 12) || i >= v14) {
      return 0;
    }
  }
  return result;
}

uint64_t AppleBCMWLANTimeTrace::reset(AppleBCMWLANTimeTrace *this)
{
  *(_DWORD *)(*((void *)this + 5) + 12) = 0;
  bzero(*(void **)(*((void *)this + 5) + 24), *(void *)(*((void *)this + 5) + 32));
  return 0;
}

uint64_t AppleBCMWLANTimeTrace::recordTracevWithTimestamp(AppleBCMWLANTimeTrace *this, unint64_t *a2, uint64_t a3, uint64_t a4, const char *a5, va_list a6)
{
  if (!**((_DWORD **)this + 5)) {
    return 0;
  }
  uint64_t mach_continuous_nanoseconds = AppleBCMWLANUtil::get_mach_continuous_nanoseconds(0, a2);
  uint64_t result = (uint64_t)AppleBCMWLANTimeTrace::getRecordTraceElement(this);
  if (result)
  {
    *(void *)(result + 8) = mach_continuous_nanoseconds;
    *(void *)(result + 16) = a2;
    *(void *)(result + 24) = a3;
    *(void *)(result + 32) = a4;
    vsnprintf((char *)(result + 40), 0x200uLL, a5, a6);
    return 1;
  }
  return result;
}

void *AppleBCMWLANTimeTrace::getRecordTraceElement(AppleBCMWLANTimeTrace *this)
{
  uint64_t v1 = *((void *)this + 5);
  uint64_t v2 = *(void *)(v1 + 24);
  if (!v2) {
    return 0;
  }
  unsigned int v3 = *(_DWORD *)(v1 + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(unsigned int *)(v1 + 12);
  if (v4 >= v3) {
    return 0;
  }
  uint64_t result = (void *)(v2 + 552 * v4);
  *uint64_t result = v4;
  uint64_t v7 = (_DWORD *)*((void *)this + 5);
  unsigned int v8 = v7[3] + 1;
  if (v7[1] == 1) {
    v8 %= v7[2];
  }
  void v7[3] = v8;
  return result;
}

uint64_t AppleBCMWLANTimeTrace::recordTracevFromMarkTimestamp(AppleBCMWLANTimeTrace *this, unint64_t *a2, uint64_t a3, const char *a4, va_list a5)
{
  if (!**((_DWORD **)this + 5)) {
    return 0;
  }
  uint64_t mach_continuous_nanoseconds = AppleBCMWLANUtil::get_mach_continuous_nanoseconds(0, a2);
  return AppleBCMWLANTimeTrace::recordTracevWithTimestamp(this, (unint64_t *)(mach_continuous_nanoseconds - *(void *)(*((void *)this + 5) + 16)), (uint64_t)a2, a3, a4, a5);
}

uint64_t AppleBCMWLANTimeTrace::enable(AppleBCMWLANTimeTrace *this, int a2)
{
  **((_DWORD **)this + 5) = a2;
  return 0;
}

uint64_t AppleBCMWLANTimeTrace::setMarkTimestamp(AppleBCMWLANTimeTrace *this, uint64_t a2)
{
  *(void *)(*((void *)this + 5) + 16) = a2;
  return 1;
}

uint64_t AppleBCMWLANPCIeAllocateDartMappedMemory(uint64_t a1, unint64_t a2, int a3, IOService *a4)
{
  segments.address = 0xAAAAAAAAAAAAAAAALL;
  segments.uint64_t length = 0xAAAAAAAAAAAAAAAALL;
  uint32_t segmentsCount = 1;
  uint64_t flags = 0;
  unint64_t v7 = *(void *)(a1 + 32);
  if (v7 >> 31)
  {
    IOLog("%s:%06u: ERROR: Invalid memory size: direction[%u] size[0x%08llx] bufferSize[0x%08llx] alignment[0x%08llx] > 0x%08lx\n", "AppleBCMWLANPCIeAllocateDartMappedMemory", 59, a3, v7, *(void *)(a1 + 24), a2, 0x7FFFLL);
    return 0;
  }
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&specification._resv[12] = v10;
  *(_OWORD *)&specification._resv[14] = v10;
  *(_OWORD *)&specification._resv[8] = v10;
  *(_OWORD *)&specification._resv[10] = v10;
  *(_OWORD *)&specification._resv[4] = v10;
  *(_OWORD *)&specification._resv[6] = v10;
  *(_OWORD *)specification._resv = v10;
  *(_OWORD *)&specification._resv[2] = v10;
  *(_OWORD *)&specification.options = v10;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 40) = 0;
  if (v7 % a2) {
    int v11 = a2 - v7 % a2;
  }
  else {
    int v11 = 0;
  }
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 24) = (v11 + v7);
  uint64_t v12 = (IO80211Buffer *)IO80211Buffer::allocBufferSingle();
  *(void *)a1 = v12;
  if (!v12)
  {
    IOLog("%s:%06u: ERROR: Failed allocBufferSingle, direction[%u] size[0x%08llx] bufferSize[0x%08llx]\n");
LABEL_22:
    IOLog("%s:%06u: ERROR: Failed mapping memory: direction[%u] size[0x%08llx] bufferSize[0x%08llx] alignment[0x%08llx]\n", "AppleBCMWLANPCIeAllocateDartMappedMemory", 136, a3, *(void *)(a1 + 32), *(void *)(a1 + 24), a2);
    AppleBCMWLANPCIeFreeDartMappedMemory(a1);
    return 0;
  }
  uint64_t BytesNoCopy = IO80211Buffer::getBytesNoCopy(v12, 0, *(void *)(a1 + 32));
  *(void *)(a1 + 40) = BytesNoCopy;
  if (!BytesNoCopy)
  {
    IOLog("%s:%06u: ERROR: Failed getBytesNoCopy()\n");
    goto LABEL_22;
  }
  memset(specification._resv, 0, sizeof(specification._resv));
  specification.options = 0;
  specification.maxAddressBits = 64;
  if (IODMACommand::Create(a4, 0, &specification, (IODMACommand **)(a1 + 16)))
  {
    IOLog("%s:%06u: ERROR: Failed IODMACommand::Create()\n");
    goto LABEL_22;
  }
  unint64_t v14 = *(IODMACommand **)(a1 + 16);
  MemoryDescriptor = (IOMemoryDescriptor *)IO80211Buffer::getMemoryDescriptor(*(IO80211Buffer **)a1);
  if (IODMACommand::PrepareForDMA(v14, 0, MemoryDescriptor, 0, 0, &flags, &segmentsCount, &segments, 0))
  {
    IOLog("%s:%06u: ERROR: Failed PrepareForDMA() status 0x%x\n");
    goto LABEL_22;
  }
  if (segmentsCount != 1 || (uint64_t length = segments.length, segments.length < *(void *)(a1 + 24)))
  {
    IOLog("%s:%06u: ERROR: Failed sanity checks\n");
    goto LABEL_22;
  }
  if (*(void *)(a1 + 32) < segments.length) {
    uint64_t length = *(void *)(a1 + 32);
  }
  *(void *)(a1 + 32) = length;
  *(void *)(a1 + 48) = segments.address;
  return 1;
}

uint64_t AppleBCMWLANPCIeFreeDartMappedMemory(uint64_t a1)
{
  uint64_t v2 = *(IODMACommand **)(a1 + 16);
  if (v2)
  {
    IODMACommand::CompleteDMA(v2, 0, 0);
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)v3 + 16))(v3);
      *(void *)(a1 + 16) = 0;
    }
  }
  *(void *)(a1 + 40) = 0;
  if (*(void *)a1)
  {
    IO80211Buffer::returnBuffer(*(IO80211Buffer **)a1);
    *(void *)a1 = 0;
  }
  uint64_t result = *(void *)(a1 + 8);
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 72))(result);
    uint64_t result = *(void *)(a1 + 8);
    if (result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
      *(void *)(a1 + 8) = 0;
    }
  }
  return result;
}

void _GLOBAL__sub_I_AppleBCMWLANPCIeUtilities_cpp()
{
  kNullRange = 0;
}

_DWORD *AppleBCMWLANChipManagerPCIe::findRemappableWindow(uint64_t a1, unsigned int a2, int a3, _DWORD *a4)
{
  uint64_t v4 = *a4;
  if (v4 >= a2) {
    return 0;
  }
  int v5 = (_DWORD *)(a1 + 20 * v4);
  unint64_t v6 = v4 + 1;
  do
  {
    if (*v5 == a3)
    {
      if (v5[2]) {
        uint64_t result = v5;
      }
      else {
        uint64_t result = 0;
      }
    }
    else
    {
      uint64_t result = 0;
    }
    *a4 = v6;
    if (result) {
      break;
    }
    v5 += 5;
  }
  while (v6++ < a2);
  return result;
}

OSObject *AppleBCMWLANChipManagerPCIe::withChip(AppleBCMWLANChipManagerPCIe *this, uint64_t a2)
{
  if ((int)this <= 4377)
  {
    if ((int)this <= 4356)
    {
      if (this == 4350)
      {
        return AppleBCMWLANChipManagerPCIe4350::withChip((AppleBCMWLANChipManagerPCIe4350 *)0x10FE, a2);
      }
      else
      {
        if (this != 4355) {
          goto LABEL_48;
        }
        return AppleBCMWLANChipManagerPCIe4355::withChip((AppleBCMWLANChipManagerPCIe4355 *)0x1103, a2);
      }
    }
    else
    {
      switch(this)
      {
        case 0x1105:
          return AppleBCMWLANChipManagerPCIe4357::withChip((AppleBCMWLANChipManagerPCIe4357 *)0x1105, a2);
        case 0x110C:
          return AppleBCMWLANChipManagerPCIe4364::withChip((AppleBCMWLANChipManagerPCIe4364 *)0x110C, a2);
        case 0x1119:
          return AppleBCMWLANChipManagerPCIe4377::withChip((AppleBCMWLANChipManagerPCIe4377 *)0x1119, a2);
        default:
          goto LABEL_48;
      }
    }
  }
  else if ((int)this > 4398)
  {
    switch(this)
    {
      case 0x112F:
        return AppleBCMWLANChipManagerPCIe4399::withChip((AppleBCMWLANChipManagerPCIe4399 *)0x112F, a2);
      case 0x4377B:
        return AppleBCMWLANChipManagerPCIe0x4377b::withChip((AppleBCMWLANChipManagerPCIe0x4377b *)0x4377B, a2);
      case 0xA9BC:
        return AppleBCMWLANChipManagerPCIe43452::withChip((AppleBCMWLANChipManagerPCIe43452 *)0xA9BC, a2);
      default:
        goto LABEL_48;
    }
  }
  else
  {
    switch(this)
    {
      case 0x111A:
        return AppleBCMWLANChipManagerPCIe4378::withChip((AppleBCMWLANChipManagerPCIe4378 *)0x111A, a2);
      case 0x1123:
        return AppleBCMWLANChipManagerPCIe4387::withChip((AppleBCMWLANChipManagerPCIe4387 *)0x1123, a2);
      case 0x1124:
        return AppleBCMWLANChipManagerPCIe4388::withChip((AppleBCMWLANChipManagerPCIe4388 *)0x1124, a2);
      default:
LABEL_48:
        IOLog("AppleBCMWLANChipManager::%s(): Unknown/Unsupported chipNumber: 0x%X", "withChip", this);
        return 0;
    }
  }
}

BOOL AppleBCMWLANChipManagerPCIe::init(OSObject *this)
{
  BOOL result = AppleBCMWLANChipManager::init(this);
  if (result)
  {
    uint64_t v3 = IOMallocZeroTyped();
    this[1].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)v3;
    return v3 != 0;
  }
  return result;
}

BOOL non-virtual thunk to'AppleBCMWLANChipManagerPCIe::init(AppleBCMWLANChipManagerPCIe *this)
{
  return AppleBCMWLANChipManagerPCIe::init((OSObject *)((char *)this - 24));
}

void AppleBCMWLANChipManagerPCIe::free(OSObject *this)
{
  uint64_t v2 = this[1].OSObjectInterface::__vftable;
  if (v2)
  {
    free = v2[10].free;
    if (free)
    {
      (*(void (**)(void (__cdecl *)(OSObjectInterface *__hidden)))(*(void *)free + 16))(v2[10].free);
      this[1].OSObjectInterface::__vftable[10].free = 0;
      uint64_t v2 = this[1].OSObjectInterface::__vftable;
    }
    init = v2[11].init;
    if (init)
    {
      (*(void (**)(BOOL (__cdecl *)(OSObjectInterface *__hidden)))(*(void *)init + 16))(v2[11].init);
      this[1].OSObjectInterface::__vftable[11].init = 0;
      uint64_t v2 = this[1].OSObjectInterface::__vftable;
    }
    memset_s(v2, 0xD8uLL, 0, 0xD8uLL);
    int v5 = this[1].OSObjectInterface::__vftable;
    if (v5)
    {
      IOFree(v5, 0xD8uLL);
      this[1].OSObjectInterface::__vftable = 0;
    }
  }
  AppleBCMWLANChipManager::free(this);
}

void non-virtual thunk to'AppleBCMWLANChipManagerPCIe::free(AppleBCMWLANChipManagerPCIe *this)
{
}

uint64_t AppleBCMWLANChipManagerPCIe::getCoreCount(AppleBCMWLANChipManagerPCIe *this)
{
  return **((unsigned int **)this + 8);
}

uint64_t AppleBCMWLANChipManagerPCIe::setCoreCount(uint64_t this, int a2)
{
  **(_DWORD **)(this + 64) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::setCoreRegionList(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(result + 64) + 8) = a2;
  return result;
}

uint64_t AppleBCMWLANChipManagerPCIe::getWrapperCount(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 16);
}

uint64_t AppleBCMWLANChipManagerPCIe::setWrapperCount(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 64) + 16) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::setWrapperRegionList(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(result + 64) + 24) = a2;
  return result;
}

uint64_t AppleBCMWLANChipManagerPCIe::getMemoryCount(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 32);
}

uint64_t AppleBCMWLANChipManagerPCIe::setMemoryCount(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 64) + 32) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::setMemoryRegionList(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(result + 64) + 40) = a2;
  return result;
}

uint64_t AppleBCMWLANChipManagerPCIe::getRAMSize(AppleBCMWLANChipManagerPCIe *this)
{
  uint64_t v1 = *(_DWORD **)(*((void *)this + 8) + 40);
  if (*v1 == 131076)
  {
    uint64_t v2 = 0;
  }
  else
  {
    uint64_t v2 = 0;
    uint64_t v3 = v1 + 3;
    do
    {
      ++v2;
      int v4 = *v3;
      v3 += 3;
    }
    while (v4 != 131076);
  }
  return v1[3 * v2 + 2];
}

uint64_t AppleBCMWLANChipManagerPCIe::getUCodeSCRSize(AppleBCMWLANChipManagerPCIe *this)
{
  return **(unsigned int **)(*((void *)this + 8) + 104);
}

uint64_t AppleBCMWLANChipManagerPCIe::getUCodeSHMSize(AppleBCMWLANChipManagerPCIe *this)
{
  return **(unsigned int **)(*((void *)this + 8) + 112);
}

uint64_t AppleBCMWLANChipManagerPCIe::copyBackplaneRegion(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  int v4 = (unsigned int *)(*(void *)(a1 + 64) + 16 * a3);
  uint64_t v5 = *v4;
  if (!v5) {
    return 0;
  }
  for (unint64_t i = (void *)(*((void *)v4 + 1) + 4); *((_DWORD *)i - 1) != a4; unint64_t i = (void *)((char *)i + 12))
  {
    if (!--v5) {
      return 0;
    }
  }
  *(_DWORD *)a2 = a4;
  *(void *)(a2 + 4) = *i;
  uint64_t v8 = *(void *)(a1 + 64);
  uint64_t v9 = *(unsigned int *)(v8 + 64);
  if (!v9) {
    return 1;
  }
  for (j = (_DWORD *)(*(void *)(v8 + 56) + 8); *(j - 2) != a3 || *(j - 1) != a4 || *j; j += 5)
  {
    if (!--v9) {
      return 1;
    }
  }
  *(unsigned char *)(a2 + 12) = 0;
  *(void *)(a2 + 16) = j[2];
  uint64_t result = 1;
  *(unsigned char *)(a2 + 24) = 1;
  return result;
}

uint64_t AppleBCMWLANChipManagerPCIe::copyMemoryRegion(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  int v4 = (unsigned int *)(*(void *)(a1 + 64) + 16 * a3);
  uint64_t v5 = *v4;
  if (!v5) {
    return 0;
  }
  for (unint64_t i = (void *)(*((void *)v4 + 1) + 4); *((_DWORD *)i - 1) != a4; unint64_t i = (void *)((char *)i + 12))
  {
    if (!--v5) {
      return 0;
    }
  }
  *(_DWORD *)a2 = a4;
  uint64_t v8 = *i;
  *(void *)(a2 + 4) = *i;
  uint64_t result = 1;
  *(unsigned char *)(a2 + 12) = 1;
  *(void *)(a2 + 16) = v8;
  *(unsigned char *)(a2 + 24) = 1;
  return result;
}

uint64_t AppleBCMWLANChipManagerPCIe::getCoreRemappableWindowCount(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 68);
}

uint64_t AppleBCMWLANChipManagerPCIe::incrementCoreRemapperCount(uint64_t this)
{
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::getWrapperRemappableWindowCount(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 72);
}

uint64_t AppleBCMWLANChipManagerPCIe::incrementWrapperRemapperCount(uint64_t this)
{
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::copyRemappableWindows(uint64_t a1, char *a2, unsigned int a3, int a4)
{
  bzero(a2, 32 * a3);
  if (!a3) {
    return 0;
  }
  uint64_t v8 = 0;
  uint64_t result = 0;
  unint64_t v10 = 0;
  do
  {
    uint64_t v11 = *(void *)(a1 + 64);
    unint64_t v12 = *(unsigned int *)(v11 + 64);
    if (v10 >= v12) {
      break;
    }
    uint64_t v13 = *(void *)(v11 + 56);
    do
    {
      while (1)
      {
        unint64_t v14 = v10;
        if (*(_DWORD *)(v13 + 20 * v10) == a4) {
          break;
        }
        ++v10;
        if (v14 + 1 >= v12) {
          goto LABEL_13;
        }
      }
      int v15 = *(_DWORD *)(v13 + 20 * v10++ + 8);
    }
    while (v14 + 1 < v12 && !v15);
    if (v15)
    {
      unint64_t v16 = &a2[32 * v8];
      *(_DWORD *)unint64_t v16 = -1;
      *((_DWORD *)v16 + IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = v15;
      uint64_t v17 = v13 + 20 * v14;
      int v19 = *(_DWORD *)(v17 + 12);
      uint64_t v18 = *(unsigned int *)(v17 + 16);
      *((_DWORD *)v16 + 2) = v19;
      v16[12] = 0;
      *((void *)v16 + 2) = v18;
      v16[24] = 1;
      uint64_t result = (result + 1);
    }
LABEL_13:
    unint64_t v10 = v10;
    ++v8;
  }
  while (v8 != a3);
  return result;
}

uint64_t AppleBCMWLANChipManagerPCIe::getCoreID(AppleBCMWLANChipManagerPCIe *this, unsigned int a2)
{
  return *(unsigned int *)(*(void *)(*((void *)this + 8) + 96) + 4 * a2);
}

uint64_t AppleBCMWLANChipManagerPCIe::setCoreIDTable(uint64_t this, const unsigned int *a2)
{
  *(void *)(*(void *)(this + 64) + 96) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::getUCodeRegionInfo(AppleBCMWLANChipManagerPCIe *this, int a2)
{
  if (a2 == 1)
  {
    uint64_t v2 = *((void *)this + 8) + 112;
    return *(void *)v2;
  }
  if (!a2)
  {
    uint64_t v2 = *((void *)this + 8) + 104;
    return *(void *)v2;
  }
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe::setUCodeRegionInfo(uint64_t result, uint64_t a2, int a3)
{
  if (a3 != 1)
  {
    if (a3) {
      return result;
    }
    *(void *)(*(void *)(result + 64) + 104) = a2;
  }
  *(void *)(*(void *)(result + 64) + 112) = a2;
  return result;
}

uint64_t AppleBCMWLANChipManagerPCIe::setSafeToCaptureSoCRAM(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 64) + 199) = a2;
  return this;
}

OSObject *AppleBCMWLANChipManagerPCIe::getChipProvisioningData(AppleBCMWLANChipManagerPCIe *this, const char *a2)
{
  uint64_t v3 = *(void *)(*((void *)this + 8) + 168);
  if (!v3 || !(*(unsigned int (**)(uint64_t))(*(void *)v3 + 72))(v3)) {
    return 0;
  }
  uint64_t v5 = *(const OSDictionary **)(*((void *)this + 8) + 168);
  return OSDictionary::getObject(v5, a2);
}

uint64_t AppleBCMWLANChipManagerPCIe::getChipProvisioningData(AppleBCMWLANChipManagerPCIe *this, const char *a2, unsigned __int8 *a3, size_t Length, unint64_t *a5)
{
  uint64_t v5 = 3758097086;
  if (*(void *)(*((void *)this + 8) + 168))
  {
    ChipProvisioningData = AppleBCMWLANChipManagerPCIe::getChipProvisioningData(this, a2);
    if (ChipProvisioningData)
    {
      unint64_t v10 = (const OSData *)OSMetaClassBase::safeMetaCast(ChipProvisioningData, gOSDataMetaClass);
      if (v10)
      {
        uint64_t v11 = v10;
        if (OSData::getLength(v10))
        {
          if (OSData::getBytesNoCopy(v11))
          {
            if (OSData::getLength(v11) < Length) {
              unsigned int Length = OSData::getLength(v11);
            }
            if (a3 && Length)
            {
              uint64_t BytesNoCopy = OSData::getBytesNoCopy(v11);
              memcpy(a3, BytesNoCopy, Length);
            }
            uint64_t v5 = 0;
            if (a5) {
              *a5 = OSData::getLength(v11);
            }
          }
        }
      }
    }
  }
  return v5;
}

uint64_t AppleBCMWLANChipManagerPCIe::setChipProvisioningData(AppleBCMWLANChipManagerPCIe *this, const char *a2, OSObject *a3)
{
  uint64_t result = 0;
  if (a3)
  {
    uint64_t v5 = *(OSDictionary **)(*((void *)this + 8) + 168);
    if (v5)
    {
      if (OSDictionary::setObject(v5, a2, a3)) {
        return 0;
      }
      else {
        return 3758097084;
      }
    }
  }
  return result;
}

BOOL AppleBCMWLANChipManagerPCIe::setChipProvisioningData(AppleBCMWLANChipManagerPCIe *this, OSDictionary *a2)
{
  *(void *)(*((void *)this + 8) + 1++*(_DWORD *)(*(void *)(this + 64) + 68) = a2;
  return a2 != 0;
}

uint64_t AppleBCMWLANChipManagerPCIe::readChipProvisioningData(AppleBCMWLANChipManagerPCIe *this, AppleBCMWLANChipBackplane *a2, const OSData *a3)
{
  __int16 v38 = 0;
  if (*(void *)(*((void *)this + 8) + 176)) {
    return 0;
  }
  uint64_t v3 = 3758097085;
  if (!a2 || AppleBCMWLANChipManagerPCIe::readSROM(this, a2, a3)) {
    return 3758097086;
  }
  uint64_t v5 = *((void *)this + 8);
  unint64_t v6 = *(const OSData **)(v5 + 176);
  if (!v6) {
    return 3758097086;
  }
  uint64_t v7 = (2 * *(_DWORD *)(v5 + 140));
  if (OSData::getLength(v6) != v7) {
    return 3825175817;
  }
  uint64_t BytesNoCopy = (unsigned __int8 *)OSData::getBytesNoCopy(*(const OSData **)(*((void *)this + 8) + 176));
  if (!BytesNoCopy) {
    return 3825175818;
  }
  uint64_t v9 = BytesNoCopy;
  OSDataPtr v10 = OSData::withBytes(BytesNoCopy, (2 * *(_DWORD *)(*((void *)this + 8) + 140)));
  if (v10)
  {
    uint64_t v11 = v10;
    unint64_t v12 = *(OSDictionary **)(*((void *)this + 8) + 168);
    if (v12) {
      OSDictionary::setObject(v12, "SROM", v11);
    }
    ((void (*)(const OSMetaClassBase *))v11->release)(v11);
    uint64_t v13 = (char *)OSData::getBytesNoCopy(*(const OSData **)(*((void *)this + 8) + 176))
        + *(unsigned int *)(*((void *)this + 8) + 156);
    bytes[0] = v13[1];
    bytes[1] = *v13;
    bytes[2] = v13[3];
    bytes[3] = v13[2];
    bytes[4] = v13[5];
    bytes[5] = v13[4];
    OSDataPtr v14 = OSData::withBytes(bytes, 6uLL);
    if (v14)
    {
      int v15 = v14;
      unint64_t v16 = *(OSDictionary **)(*((void *)this + 8) + 168);
      if (v16) {
        OSDictionary::setObject(v16, "macaddress", v15);
      }
      ((void (*)(const OSMetaClassBase *))v15->release)(v15);
      uint64_t v17 = OSData::withCapacity(1u);
      if (v17)
      {
        uint64_t v18 = v17;
        OSData::appendBytes(v17, &v9[*(unsigned int *)(*((void *)this + 8) + 148)], 1uLL);
        int v19 = *(OSDictionary **)(*((void *)this + 8) + 168);
        if (v19) {
          OSDictionary::setObject(v19, "SROM:version", v18);
        }
        ((void (*)(const OSMetaClassBase *))v18->release)(v18);
        uint64_t v20 = OSData::withCapacity(2u);
        if (v20)
        {
          unint64_t v21 = v20;
          OSData::appendBytes(v20, &v9[*(_DWORD *)(*((void *)this + 8) + 152) + 1], 1uLL);
          OSData::appendBytes(v21, &v9[*(unsigned int *)(*((void *)this + 8) + 152)], 1uLL);
          uint64_t v22 = *(OSDictionary **)(*((void *)this + 8) + 168);
          if (v22) {
            OSDictionary::setObject(v22, "SROM:signature", v21);
          }
          ((void (*)(OSData *))v21->release)(v21);
          uint64_t v23 = OSData::withCapacity(2u);
          if (v23)
          {
            char v24 = v23;
            OSData::appendBytes(v23, v9 + 7, 1uLL);
            OSData::appendBytes(v24, v9 + 6, 1uLL);
            uint64_t v25 = *(OSDictionary **)(*((void *)this + 8) + 168);
            if (v25) {
              OSDictionary::setObject(v25, "svid", v24);
            }
            ((void (*)(OSData *))v24->release)(v24);
            unsigned __int8 v37 = getcrc8(v9, 2 * *(_DWORD *)(*((void *)this + 8) + 140), 0xFFu);
            uint64_t v26 = OSData::withCapacity(1u);
            if (v26)
            {
              uint64_t v27 = v26;
              OSData::appendBytes(v26, &v37, 1uLL);
              uint64_t v28 = *(OSDictionary **)(*((void *)this + 8) + 168);
              if (v28) {
                OSDictionary::setObject(v28, "checksum:value", v27);
              }
              ((void (*)(const OSMetaClassBase *))v27->release)(v27);
              BOOL v36 = v37 == 159;
              unint64_t v29 = OSData::withCapacity(1u);
              if (v29)
              {
                unint64_t v30 = v29;
                OSData::appendBytes(v29, &v36, 1uLL);
                int v31 = *(OSDictionary **)(*((void *)this + 8) + 168);
                if (v31) {
                  OSDictionary::setObject(v31, "checksum:valid", v30);
                }
                ((void (*)(const OSMetaClassBase *))v30->release)(v30);
                LOBYTE(v38) = *(unsigned char *)OSData::getBytesNoCopy(*(const OSData **)(*((void *)this + 8) + 176), (*(_DWORD *)(*((void *)this + 8) + 160) + 1), 1uLL);
                HIBYTE(v38) = *(unsigned char *)OSData::getBytesNoCopy(*(const OSData **)(*((void *)this + 8) + 176), *(unsigned int *)(*((void *)this + 8) + 160), 1uLL);
                unint64_t v32 = OSData::withCapacity(2u);
                if (v32)
                {
                  unint64_t v33 = v32;
                  OSData::appendBytes(v32, &v38, 1uLL);
                  OSData::appendBytes(v33, (char *)&v38 + 1, 1uLL);
                  size_t v34 = *(OSDictionary **)(*((void *)this + 8) + 168);
                  if (v34) {
                    OSDictionary::setObject(v34, "SKU", v33);
                  }
                  ((void (*)(OSData *))v33->release)(v33);
                  return 0;
                }
              }
            }
          }
        }
      }
    }
  }
  return v3;
}

uint64_t AppleBCMWLANChipManagerPCIe::readSROM(AppleBCMWLANChipManagerPCIe *this, AppleBCMWLANChipBackplane *a2, const OSData *a3)
{
  unsigned __int16 v21 = 0;
  unsigned int v19 = 0;
  unsigned int v20 = 0;
  char bytes = 0;
  uint64_t v5 = *((void *)this + 8);
  if (*(void *)(v5 + 176)) {
    goto LABEL_20;
  }
  if (!a2)
  {
    uint64_t v8 = 3758097086;
    goto LABEL_21;
  }
  if (a3)
  {
    if (OSData::getLength(a3))
    {
      OSDataPtr v7 = OSData::withData(a3);
      goto LABEL_8;
    }
    uint64_t v5 = *((void *)this + 8);
  }
  OSDataPtr v7 = OSData::withCapacity(2 * *(_DWORD *)(v5 + 140));
LABEL_8:
  *(void *)(*((void *)this + 8) + 176) = v7;
  uint64_t v8 = 3758097085;
  if (!*(void *)(*((void *)this + 8) + 176)) {
    goto LABEL_21;
  }
  if (AppleBCMWLANChipBackplane::readCommonCoreReg32(a2, 4u, &v19))
  {
    uint64_t v8 = 3758097129;
    if ((*(uint64_t (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this))
    {
      (*(void (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this);
      if (CCLogStream::shouldLog())
      {
        int v15 = (CCLogStream *)(*(uint64_t (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this);
        CCLogStream::logAlert(v15, "[dk] %s@%d:Failed to read core capabilities\n", "readSROM", 1024);
        uint64_t v8 = 3758097129;
      }
    }
    goto LABEL_21;
  }
  if ((v19 & 0x40000000) == 0)
  {
    if ((*(uint64_t (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this))
    {
      (*(void (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this);
      if (CCLogStream::shouldLog())
      {
        uint64_t v17 = (CCLogStream *)(*(uint64_t (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this);
        CCLogStream::logAlert(v17, "[dk] %s@%d:Chip does not support SPROM\n", "readSROM", 1028);
      }
    }
    uint64_t v8 = 3758097105;
    goto LABEL_21;
  }
  AppleBCMWLANChipBackplane::readCommonCoreReg32(a2, 0x190u, &v20);
  if (a3)
  {
LABEL_20:
    uint64_t v8 = 0;
    goto LABEL_21;
  }
  uint64_t v9 = *((void *)this + 8);
  if ((*(_DWORD *)(v9 + 140) & 0x7FFFFFFF) != 0)
  {
    unsigned int v10 = 0;
    do
    {
      OSData::appendBytes(*(OSData **)(v9 + 176), &bytes, 1uLL);
      ++v10;
      uint64_t v9 = *((void *)this + 8);
    }
    while (v10 < 2 * *(_DWORD *)(v9 + 140));
  }
  if (OSData::getBytesNoCopy(*(const OSData **)(v9 + 176)))
  {
    uint64_t BytesNoCopy = (AppleBCMWLANChipManagerPCIe *)AppleBCMWLANChipBackplane::writeCommonCoreReg32(a2, 0x190u, v20 & 0xFFFFFFEF);
    if ((*(_DWORD *)(*((void *)this + 8) + 140) & 0x7FFFFFFF) != 0)
    {
      unint64_t v12 = 0;
      do
      {
        AppleBCMWLANChipManagerPCIe::SROM_cc_cmd(BytesNoCopy, a2, 0, v12, &v21);
        unsigned __int16 v13 = v21;
        uint64_t BytesNoCopy = (AppleBCMWLANChipManagerPCIe *)OSData::getBytesNoCopy(*(const OSData **)(*((void *)this + 8)
                                                                                             + 176));
        *((_WORD *)BytesNoCopy + v12++) = v13;
      }
      while (v12 < (*(_DWORD *)(*((void *)this + 8) + 140) & 0x7FFFFFFFu));
    }
    AppleBCMWLANChipBackplane::writeCommonCoreReg32(a2, 0x190u, v20);
    goto LABEL_20;
  }
LABEL_21:
  if ((*(uint64_t (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this))
  {
    (*(void (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this);
    if (CCLogStream::shouldLog())
    {
      unint64_t v16 = (CCLogStream *)(*(uint64_t (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this);
      CCLogStream::logAlert(v16, "[dk] %s@%d: SROM present:%d, OTP present:%d, SROM forced:%d\n", "readSROM", 1060, v20 & 1, (v20 >> 5) & 1, a3 != 0);
    }
  }
  return v8;
}

uint64_t AppleBCMWLANChipManagerPCIe::getSROMByteCount(AppleBCMWLANChipManagerPCIe *this)
{
  return (2 * *(_DWORD *)(*((void *)this + 8) + 140));
}

uint64_t AppleBCMWLANChipManagerPCIe::getSROMoffsetMacAddress(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 156);
}

uint64_t AppleBCMWLANChipManagerPCIe::getSROMoffsetSignature(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 152);
}

uint64_t AppleBCMWLANChipManagerPCIe::getSROMoffsetSKU(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 160);
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManagerPCIe::readChipProvisioningData(AppleBCMWLANChipManagerPCIe *this, AppleBCMWLANChipBackplane *a2, const OSData *a3)
{
  return AppleBCMWLANChipManagerPCIe::readChipProvisioningData((AppleBCMWLANChipManagerPCIe *)((char *)this - 56), a2, a3);
}

uint64_t AppleBCMWLANChipManagerPCIe::validateChipProvisioningData(AppleBCMWLANChipManagerPCIe *this)
{
  unint64_t v7 = 0;
  if (!*(void *)(*((void *)this + 8) + 168)) {
    return 3758097086;
  }
  *(_OWORD *)uint64_t v8 = 0u;
  long long v9 = 0u;
  if (AppleBCMWLANChipManagerPCIe::getChipProvisioningData(this, "checksum:valid", v8, 0x20uLL, &v7)
    || !v8[0])
  {
    if ((*(uint64_t (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this))
    {
      (*(void (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this);
      uint64_t v2 = 3825175815;
      if (CCLogStream::shouldLog())
      {
        unint64_t v6 = (CCLogStream *)(*(uint64_t (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this);
        CCLogStream::logAlert(v6, "[dk] %s@%d: Invalid checksum\n");
      }
    }
    else
    {
      return 3825175815;
    }
  }
  else
  {
    *(_OWORD *)uint64_t v8 = 0u;
    long long v9 = 0u;
    if (AppleBCMWLANChipManagerPCIe::getChipProvisioningData(this, "SROM:version", v8, 0x20uLL, &v7)
      || *(_DWORD *)(*((void *)this + 8) + 136) != v8[0])
    {
      uint64_t v2 = 3825175811;
      if ((*(uint64_t (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this))
      {
        (*(void (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this);
        if (CCLogStream::shouldLog())
        {
          uint64_t v3 = (CCLogStream *)(*(uint64_t (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this);
          CCLogStream::logAlert(v3, "[dk] %s@%d: Invalid version\n");
        }
      }
    }
    else
    {
      *(_OWORD *)uint64_t v8 = 0u;
      long long v9 = 0u;
      if (AppleBCMWLANChipManagerPCIe::getChipProvisioningData(this, "SROM:signature", v8, 0x20uLL, &v7)
        || *(_DWORD *)(*((void *)this + 8) + 144) != bswap32(*(unsigned __int16 *)v8) >> 16)
      {
        uint64_t v2 = 3825175812;
        if ((*(uint64_t (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this))
        {
          (*(void (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this);
          if (CCLogStream::shouldLog())
          {
            int v4 = (CCLogStream *)(*(uint64_t (**)(AppleBCMWLANChipManagerPCIe *))(*(void *)this + 72))(this);
            CCLogStream::logAlert(v4, "[dk] %s@%d: Invalid signature\n", "validateChipProvisioningData", 935);
            return 3825175812;
          }
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return v2;
}

uint64_t AppleBCMWLANChipManagerPCIe::getSROMVersion(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 136);
}

uint64_t AppleBCMWLANChipManagerPCIe::getSROMSignature(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 144);
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManagerPCIe::validateChipProvisioningData(AppleBCMWLANChipManagerPCIe *this)
{
  return AppleBCMWLANChipManagerPCIe::validateChipProvisioningData((AppleBCMWLANChipManagerPCIe *)((char *)this - 56));
}

OSDataPtr AppleBCMWLANChipManagerPCIe::copySROM(AppleBCMWLANChipManagerPCIe *this)
{
  uint64_t v2 = *(const OSData **)(*((void *)this + 8) + 176);
  if (!v2 || !OSData::getLength(v2)) {
    return 0;
  }
  uint64_t v3 = *(const OSData **)(*((void *)this + 8) + 176);
  return OSData::withData(v3);
}

OSDataPtr non-virtual thunk to'AppleBCMWLANChipManagerPCIe::copySROM(AppleBCMWLANChipManagerPCIe *this)
{
  return AppleBCMWLANChipManagerPCIe::copySROM((AppleBCMWLANChipManagerPCIe *)((char *)this - 56));
}

uint64_t AppleBCMWLANChipManagerPCIe::SROM_cc_cmd(AppleBCMWLANChipManagerPCIe *this, AppleBCMWLANChipBackplane *a2, int a3, int a4, unsigned __int16 *a5)
{
  uint64_t v5 = 3758097090;
  unsigned int v10 = -1;
  unsigned int v11 = -1;
  *a5 = -1;
  if (a2 && !a3)
  {
    AppleBCMWLANChipBackplane::writeCommonCoreReg32(a2, 0x194u, 2 * a4);
    AppleBCMWLANChipBackplane::writeCommonCoreReg32(a2, 0x190u, 0x80000000);
    int v8 = -1000;
    do
    {
      if (!v8) {
        goto LABEL_7;
      }
      AppleBCMWLANChipBackplane::readCommonCoreReg32(a2, 0x190u, &v11);
      ++v8;
    }
    while ((v11 & 0x80000000) != 0);
    if (v8)
    {
LABEL_7:
      AppleBCMWLANChipBackplane::readCommonCoreReg32(a2, 0x198u, &v10);
      uint64_t v5 = 0;
      *a5 = v10;
      return v5;
    }
    return 3758097110;
  }
  return v5;
}

uint64_t AppleBCMWLANChipManagerPCIe::prepareHardware(AppleBCMWLANChipManagerPCIe *this, AppleBCMWLANChipConfigSpace *a2, AppleBCMWLANChipBackplane *a3)
{
  unsigned int v6 = 0;
  uint64_t result = 3758097090;
  if (a2 && a3)
  {
    AppleBCMWLANChipBackplane::writeCommonCoreReg32(a3, 0xC40u, 6u);
    if (AppleBCMWLANChipBackplane::readCommonCoreReg32(a3, 0xE00u, &v6))
    {
      return 3758097098;
    }
    else
    {
      AppleBCMWLANChipBackplane::writeCommonCoreReg32(a3, 0xE00u, v6 | 0x10);
      int v5 = AppleBCMWLANChipBackplane::readCommonCoreReg32(a3, 0xC40u, &v6);
      uint64_t result = 3758097098;
      if (!v5)
      {
        if (v6 == 6) {
          return 0;
        }
        else {
          return 3758097098;
        }
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANChipManagerPCIe::checkHardware(AppleBCMWLANChipManagerPCIe *this, AppleBCMWLANChipConfigSpace *a2, AppleBCMWLANChipBackplane *a3)
{
  unsigned int v6 = 0;
  uint64_t result = 3758097090;
  if (a2 && a3)
  {
    AppleBCMWLANChipBackplane::writeCommonCoreReg32(a3, 0xC40u, 6u);
    if (AppleBCMWLANChipBackplane::readCommonCoreReg32(a3, 0xE00u, &v6) || (v6 & 0x10) == 0)
    {
      return 3758097098;
    }
    else
    {
      int v5 = AppleBCMWLANChipBackplane::readCommonCoreReg32(a3, 0xC40u, &v6);
      uint64_t result = 3758097098;
      if (!v5)
      {
        if (v6 == 6) {
          return 0;
        }
        else {
          return 3758097098;
        }
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANChipManagerPCIe::copyCore(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  return AppleBCMWLANChipManagerPCIe::copyBackplaneRegion(a1, a2, 0, a3);
}

uint64_t AppleBCMWLANChipManagerPCIe::getOTPCoreID(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 76);
}

uint64_t AppleBCMWLANChipManagerPCIe::setOTPCoreID(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(result + 64) + 76) = a2;
  return result;
}

uint64_t AppleBCMWLANChipManagerPCIe::copyWrapper(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  return AppleBCMWLANChipManagerPCIe::copyBackplaneRegion(a1, a2, 1u, a3 | 0x10000u);
}

uint64_t AppleBCMWLANChipManagerPCIe::setBackplaneWindowCount(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 64) + 64) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::getBackplaneWindows(AppleBCMWLANChipManagerPCIe *this)
{
  return *(void *)(*((void *)this + 8) + 56);
}

uint64_t AppleBCMWLANChipManagerPCIe::setBackplaneWindows(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(result + 64) + 56) = a2;
  return result;
}

uint64_t AppleBCMWLANChipManagerPCIe::getChipNumber(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 48);
}

uint64_t AppleBCMWLANChipManagerPCIe::setChipNumber(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 64) + 48) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::copyMemory(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  return AppleBCMWLANChipManagerPCIe::copyMemoryRegion(a1, a2, 2u, a3 | 0x20000u);
}

uint64_t AppleBCMWLANChipManagerPCIe::copyRemappableCoreWindows(uint64_t a1, char *a2, unsigned int a3)
{
  return AppleBCMWLANChipManagerPCIe::copyRemappableWindows(a1, a2, a3, 0);
}

uint64_t AppleBCMWLANChipManagerPCIe::copyRemappableWrapperWindows(uint64_t a1, char *a2, unsigned int a3)
{
  return AppleBCMWLANChipManagerPCIe::copyRemappableWindows(a1, a2, a3, 1);
}

uint64_t AppleBCMWLANChipManagerPCIe::getUserOTPRange(AppleBCMWLANChipManagerPCIe *this)
{
  return *(void *)(*((void *)this + 8) + 80);
}

uint64_t AppleBCMWLANChipManagerPCIe::setUserOTPRange(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(result + 64) + 80) = a2;
  return result;
}

uint64_t AppleBCMWLANChipManagerPCIe::getChipOTPRange(AppleBCMWLANChipManagerPCIe *this)
{
  return *(void *)(*((void *)this + 8) + 88);
}

uint64_t AppleBCMWLANChipManagerPCIe::setChipOTPRange(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(result + 64) + 88) = a2;
  return result;
}

uint64_t AppleBCMWLANChipManagerPCIe::getConfigSpaceSaveRange(AppleBCMWLANChipManagerPCIe *this)
{
  return *(void *)(*((void *)this + 8) + 120);
}

uint64_t AppleBCMWLANChipManagerPCIe::setConfigSpaceSaveRange(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(result + 64) + 120) = a2;
  return result;
}

uint64_t AppleBCMWLANChipManagerPCIe::getConfigSpaceSaveCount(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 128);
}

uint64_t AppleBCMWLANChipManagerPCIe::setConfigSpaceSaveCount(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 64) + 128) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::setPCIeHeaderLength(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 64) + 132) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::setSROMVersion(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 64) + 136) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::setSROMoffsetVersion(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 64) + 148) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::getSROMWordCount(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 140);
}

uint64_t AppleBCMWLANChipManagerPCIe::setSROMWordCount(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 64) + 140) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::setSROMSignature(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 64) + 144) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::setSROMoffsetSignature(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 64) + 152) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::setSROMoffsetMacAddress(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 64) + 156) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::setSROMoffsetSKU(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 64) + 160) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::getMemoryRAMAddress(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 164);
}

uint64_t AppleBCMWLANChipManagerPCIe::setMemoryRAMAddress(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 64) + 164) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::isAWDLSupported(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned __int8 *)(*((void *)this + 8) + 196);
}

uint64_t AppleBCMWLANChipManagerPCIe::setAWDLSupported(AppleBCMWLANChipManagerPCIe *this, char a2)
{
  uint64_t v2 = *((void *)this + 8);
  uint64_t result = *(unsigned __int8 *)(v2 + 196);
  *(unsigned char *)(v2 + 196) = a2;
  return result;
}

uint64_t AppleBCMWLANChipManagerPCIe::isRangingSupported(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned __int8 *)(*((void *)this + 8) + 197);
}

uint64_t AppleBCMWLANChipManagerPCIe::setRangingSupport(AppleBCMWLANChipManagerPCIe *this, char a2)
{
  uint64_t v2 = *((void *)this + 8);
  uint64_t result = *(unsigned __int8 *)(v2 + 197);
  *(unsigned char *)(v2 + 197) = a2;
  return result;
}

uint64_t AppleBCMWLANChipManagerPCIe::isHMAPSupported(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned __int8 *)(*((void *)this + 8) + 201);
}

uint64_t AppleBCMWLANChipManagerPCIe::setHMAPSupported(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 64) + 20IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = a2;
  return this;
}

BOOL AppleBCMWLANChipManagerPCIe::isBMEDisableSupported(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned char *)(*((void *)this + 8) + 203) == 0;
}

uint64_t AppleBCMWLANChipManagerPCIe::setBMEDisableUnSupported(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 64) + 20AppleBCMWLANSensingAdapter::free(this - 3) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::isPTMSupported(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned __int8 *)(*((void *)this + 8) + 204);
}

uint64_t AppleBCMWLANChipManagerPCIe::setPTMSupport(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 64) + 204) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::isFatalErrorIndicationSupported(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned __int8 *)(*((void *)this + 8) + 205);
}

uint64_t AppleBCMWLANChipManagerPCIe::setFatalErrorIndicationSupported(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 64) + 205) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::isCoexCPUTrapSupported(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned __int8 *)(*((void *)this + 8) + 206);
}

uint64_t AppleBCMWLANChipManagerPCIe::setCoexCPUTrapSupported(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 64) + 206) = a2;
  return this;
}

BOOL AppleBCMWLANChipManagerPCIe::isTrapBeforeFLRSupported(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned char *)(*((void *)this + 8) + 207) == 0;
}

uint64_t AppleBCMWLANChipManagerPCIe::setTrapBeforeFLRUnSupported(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 64) + 207) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::setM2MResetOnSSResetDisabled(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 64) + 208) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::getHMAPBaseAddress(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned int *)(*((void *)this + 8) + 184);
}

uint64_t AppleBCMWLANChipManagerPCIe::setHMAPBaseAddress(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 64) + 184) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::hostWakeToggleNotConfigured(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned __int8 *)(*((void *)this + 8) + 202);
}

uint64_t AppleBCMWLANChipManagerPCIe::sethostWakeToggleNotConfigured(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 64) + 202) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::isPowerControlRequired(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned __int8 *)(*((void *)this + 8) + 209);
}

uint64_t AppleBCMWLANChipManagerPCIe::setPowerControlRequired(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 64) + 209) = a2;
  return this;
}

BOOL AppleBCMWLANChipManagerPCIe::isSplitArchitecture(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned char *)(*((void *)this + 8) + 212) == 0;
}

uint64_t AppleBCMWLANChipManagerPCIe::setNotSplitArchitecture(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 64) + 212) = a2;
  return this;
}

BOOL AppleBCMWLANChipManagerPCIe::isBootMSISupported(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned char *)(*((void *)this + 8) + 213) == 0;
}

uint64_t AppleBCMWLANChipManagerPCIe::setBootMSIUnsupported(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 64) + 21AppleBCMWLANSensingAdapter::free(this - 3) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::getPCIeBootMinPollingDelay(AppleBCMWLANChipManagerPCIe *this)
{
  unsigned int v1 = *(_DWORD *)(*((void *)this + 8) + 188);
  if (v1) {
    return v1;
  }
  else {
    return 600;
  }
}

uint64_t AppleBCMWLANChipManagerPCIe::setPCIeBootMinPollingDelay(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 64) + 188) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::getPCIeBootPollingInterval(AppleBCMWLANChipManagerPCIe *this)
{
  unsigned int v1 = *(_DWORD *)(*((void *)this + 8) + 192);
  if (v1) {
    return v1;
  }
  else {
    return 10;
  }
}

uint64_t AppleBCMWLANChipManagerPCIe::sysmemEnabled(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned __int8 *)(*((void *)this + 8) + 210);
}

uint64_t AppleBCMWLANChipManagerPCIe::setsysmemEnabled(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 64) + 210) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::needsASPMWorkaround(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned __int8 *)(*((void *)this + 8) + 211);
}

uint64_t AppleBCMWLANChipManagerPCIe::setASPMWorkaround(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 64) + 21IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::needsCacheCoherency(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned __int8 *)(*((void *)this + 8) + 200);
}

uint64_t AppleBCMWLANChipManagerPCIe::setCacheCoherency(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 64) + 200) = a2;
  return this;
}

uint64_t AppleBCMWLANChipManagerPCIe::getChipProvisioningData(AppleBCMWLANChipManagerPCIe *this)
{
  return *(void *)(*((void *)this + 8) + 168);
}

uint64_t AppleBCMWLANChipManagerPCIe::shouldGenerateFileName(AppleBCMWLANChipManagerPCIe *this)
{
  return 1;
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManagerPCIe::shouldGenerateFileName(AppleBCMWLANChipManagerPCIe *this)
{
  return 1;
}

uint64_t AppleBCMWLANChipManagerPCIe::isHighResourceChip(AppleBCMWLANChipManagerPCIe *this)
{
  return 0;
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManagerPCIe::isHighResourceChip(AppleBCMWLANChipManagerPCIe *this)
{
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe::getMailboxIntStatusRegisterOffset(AppleBCMWLANChipManagerPCIe *this)
{
  if (*(unsigned char *)(*((void *)this + 8) + 198)) {
    return 3120;
  }
  else {
    return 72;
  }
}

uint64_t AppleBCMWLANChipManagerPCIe::getMailboxIntMaskRegisterOffset(AppleBCMWLANChipManagerPCIe *this)
{
  if (*(unsigned char *)(*((void *)this + 8) + 198)) {
    return 3124;
  }
  else {
    return 76;
  }
}

uint64_t AppleBCMWLANChipManagerPCIe::isMultiFunctionChip(AppleBCMWLANChipManagerPCIe *this)
{
  return *(unsigned __int8 *)(*((void *)this + 8) + 198);
}

uint64_t AppleBCMWLANChipManagerPCIe::setMultiFunctionChip(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 64) + 198) = a2;
  return this;
}

void *AppleBCMWLANChipManagerPCIe::getARMCoreRegionTable(AppleBCMWLANChipManagerPCIe *this)
{
  return &kBCOMDefaultARMCoreRanges;
}

void *non-virtual thunk to'AppleBCMWLANChipManagerPCIe::getARMCoreRegionTable(AppleBCMWLANChipManagerPCIe *this)
{
  return &kBCOMDefaultARMCoreRanges;
}

uint64_t AppleBCMWLANChipManagerPCIe::getARMCoreRegionTableSize(AppleBCMWLANChipManagerPCIe *this)
{
  return 3;
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManagerPCIe::getARMCoreRegionTableSize(AppleBCMWLANChipManagerPCIe *this)
{
  return 3;
}

void *AppleBCMWLANChipManagerPCIe::getFWDebugARMCoreRegionTable(AppleBCMWLANChipManagerPCIe *this)
{
  return &kBCOMDefaultARMCoreRanges;
}

void *non-virtual thunk to'AppleBCMWLANChipManagerPCIe::getFWDebugARMCoreRegionTable(AppleBCMWLANChipManagerPCIe *this)
{
  return &kBCOMDefaultARMCoreRanges;
}

uint64_t AppleBCMWLANChipManagerPCIe::getFWDebugARMCoreRegionTableSize(AppleBCMWLANChipManagerPCIe *this)
{
  return 3;
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManagerPCIe::getFWDebugARMCoreRegionTableSize(AppleBCMWLANChipManagerPCIe *this)
{
  return 3;
}

void *AppleBCMWLANChipManagerPCIe::getFWDebugCommonCoreRegionTable(AppleBCMWLANChipManagerPCIe *this)
{
  return &kBCOMDefaultCommonCoreRanges;
}

void *non-virtual thunk to'AppleBCMWLANChipManagerPCIe::getFWDebugCommonCoreRegionTable(AppleBCMWLANChipManagerPCIe *this)
{
  return &kBCOMDefaultCommonCoreRanges;
}

uint64_t AppleBCMWLANChipManagerPCIe::getFWDebugCommonCoreRegionTableSize(AppleBCMWLANChipManagerPCIe *this)
{
  return 0;
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManagerPCIe::getFWDebugCommonCoreRegionTableSize(AppleBCMWLANChipManagerPCIe *this)
{
  return 0;
}

void *AppleBCMWLANChipManagerPCIe::getFWDebugPMUCoreRegionTable(AppleBCMWLANChipManagerPCIe *this)
{
  return &kBCOMDefaultPMUCoreRanges;
}

void *non-virtual thunk to'AppleBCMWLANChipManagerPCIe::getFWDebugPMUCoreRegionTable(AppleBCMWLANChipManagerPCIe *this)
{
  return &kBCOMDefaultPMUCoreRanges;
}

uint64_t AppleBCMWLANChipManagerPCIe::getFWDebugPMUCoreRegionTableSize(AppleBCMWLANChipManagerPCIe *this)
{
  return 0;
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManagerPCIe::getFWDebugPMUCoreRegionTableSize(AppleBCMWLANChipManagerPCIe *this)
{
  return 0;
}

void *AppleBCMWLANChipManagerPCIe::getFWDebugPCIEFunc0CoreRegionTable(AppleBCMWLANChipManagerPCIe *this)
{
  return &kBCOMDefaultPCIEFunc0CoreRanges;
}

void *non-virtual thunk to'AppleBCMWLANChipManagerPCIe::getFWDebugPCIEFunc0CoreRegionTable(AppleBCMWLANChipManagerPCIe *this)
{
  return &kBCOMDefaultPCIEFunc0CoreRanges;
}

uint64_t AppleBCMWLANChipManagerPCIe::getFWDebugPCIEFunc0CoreRegionTableSize(AppleBCMWLANChipManagerPCIe *this)
{
  return 0;
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManagerPCIe::getFWDebugPCIEFunc0CoreRegionTableSize(AppleBCMWLANChipManagerPCIe *this)
{
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe::initWithChip(AppleBCMWLANChipManagerPCIe *this)
{
  return 0;
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManagerPCIe::initWithChip(AppleBCMWLANChipManagerPCIe *this)
{
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe::getDARSecurityStatusReg()
{
  return 0;
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManagerPCIe::getDARSecurityStatusReg()
{
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe::isSecureBootSupported(AppleBCMWLANChipManagerPCIe *this)
{
  return 0;
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManagerPCIe::isSecureBootSupported(AppleBCMWLANChipManagerPCIe *this)
{
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe::hasMNIInterface(AppleBCMWLANChipManagerPCIe *this)
{
  return 0;
}

uint64_t non-virtual thunk to'AppleBCMWLANChipManagerPCIe::hasMNIInterface(AppleBCMWLANChipManagerPCIe *this)
{
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANChipManagerPCIe_cpp()
{
  kNullRange = 0;
}

OSObject *AppleBCMWLANStopwatch::withUptime(AppleBCMWLANStopwatch *this)
{
  uint64_t v3 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANStopwatchMetaClass, &v3)) {
    return 0;
  }
  unsigned int v1 = v3;
  if (v3 && (((uint64_t (*)(OSObject *))v3->init)(v3) & 1) == 0)
  {
    ((void (*)(OSObject *))v1->release)(v1);
    return 0;
  }
  return v1;
}

BOOL AppleBCMWLANStopwatch::init(OSObject *this)
{
  BOOL result = OSObject::init(this);
  if (result)
  {
    uint64_t v3 = IOMallocZeroTyped();
    this[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)v3;
    if (v3)
    {
      return 1;
    }
    else
    {
      IOLog("Failed to allocate AppleBCMWLANStopwatch_IVars\n");
      return 0;
    }
  }
  return result;
}

BOOL non-virtual thunk to'AppleBCMWLANStopwatch::init(AppleBCMWLANStopwatch *this)
{
  return AppleBCMWLANStopwatch::init((OSObject *)((char *)this - 24));
}

void AppleBCMWLANStopwatch::free(OSObject *this)
{
  uint64_t v2 = this[1].OSMetaClassBase::__vftable;
  if (v2)
  {
    memset_s(v2, 0x10uLL, 0, 0x10uLL);
    uint64_t v3 = this[1].OSMetaClassBase::__vftable;
    if (v3)
    {
      IOFree(v3, 0x10uLL);
      this[1].OSMetaClassBase::__vftable = 0;
    }
  }
  OSObject::free(this);
}

void non-virtual thunk to'AppleBCMWLANStopwatch::free(AppleBCMWLANStopwatch *this)
{
}

uint64_t AppleBCMWLANStopwatch::start(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void **)(this + 40);
  if (v2[1])
  {
    mach_continuous_time();
    this = absolutetime_to_nanoseconds();
    **(void **)(v1 + 40) += 0xAAAAAAAAAAAAAAAALL - *(void *)(*(void *)(v1 + 40) + 8);
    *(void *)(*(void *)(v1 + 40) + 8) = 0;
  }
  else if (!*v2)
  {
    mach_continuous_time();
    return absolutetime_to_nanoseconds();
  }
  return this;
}

uint64_t AppleBCMWLANStopwatch::restart(AppleBCMWLANStopwatch *this)
{
  mach_continuous_time();
  uint64_t result = absolutetime_to_nanoseconds();
  *(void *)(*((void *)this + 5) + 8) = 0;
  return result;
}

unint64_t AppleBCMWLANStopwatch::getSplit_us(AppleBCMWLANStopwatch *this)
{
  return (0xAAAAAAAAAAAAAAAALL - **((void **)this + 5)) / 0x3E8;
}

OSObject *AppleBCMWLANScanAdapter::withDriverAndCallBack(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v8 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANScanAdapterMetaClass, &v8)) {
    return 0;
  }
  unsigned int v6 = v8;
  if (v8
    && (((uint64_t (*)(OSObject *, uint64_t, uint64_t, uint64_t))v8->OSMetaClassBase::__vftable[1].getMetaClass)(v8, a1, a2, a3) & 1) == 0)
  {
    ((void (*)(OSObject *))v6->release)(v6);
    return 0;
  }
  return v6;
}

void AppleBCMWLANScanAdapter::free(void **this)
{
  if (this[6])
  {
    AppleBCMWLANScanAdapter::freeResources((AppleBCMWLANScanAdapter *)this);
    memset_s(this[6], 0x9F0uLL, 0, 0x9F0uLL);
    uint64_t v2 = this[6];
    if (v2)
    {
      IOFree(v2, 0x9F0uLL);
      this[6] = 0;
    }
  }
  OSObject::free((OSObject *)this);
}

uint64_t AppleBCMWLANScanAdapter::freeResources(AppleBCMWLANScanAdapter *this)
{
  uint64_t v2 = (void *)*((void *)this + 6);
  uint64_t v3 = v2[8];
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 16))(v3);
    *(void *)(*((void *)this + 6) + 64) = 0;
    uint64_t v2 = (void *)*((void *)this + 6);
  }
  uint64_t v4 = v2[9];
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
    *(void *)(*((void *)this + 6) + ++*(_DWORD *)(*(void *)(this + 64) + 72) = 0;
    uint64_t v2 = (void *)*((void *)this + 6);
  }
  uint64_t result = v2[10];
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
    *(void *)(*((void *)this + 6) + 80) = 0;
  }
  return result;
}

void non-virtual thunk to'AppleBCMWLANScanAdapter::free(void **this)
{
}

uint64_t AppleBCMWLANScanAdapter::setScanHomeAwayTime(AppleBCMWLANScanAdapter *this, int a2)
{
  uint64_t v3 = *((void *)this + 6);
  if (*(void *)(v3 + 72))
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v3 = *((void *)this + 6);
    if (shouldLog)
    {
      CCLogStream::logNotice(*(CCLogStream **)(v3 + 72), "[dk] %s@%d:Setting Scan Home away time to %u\n", "setScanHomeAwayTime", 121, a2);
      uint64_t v3 = *((void *)this + 6);
    }
  }
  uint64_t v6 = AppleBCMWLANCommander::sendIOVarSet(*(AppleBCMWLANCommander **)(v3 + 64), (uint64_t)"scan_home_away_time");
  if (v6 && *(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d: Error %d in setting home away time\n", "setScanHomeAwayTime", 128, v6);
  }
  return v6;
}

uint64_t AppleBCMWLANScanAdapter::setScanHomeAwayTimeCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = result;
    uint64_t result = *(void *)(*(void *)(result + 48) + 72);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        uint64_t v5 = *(void *)(v3 + 48);
        uint64_t v6 = *(CCLogStream **)(v5 + 72);
        unint64_t v7 = (const char *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v5 + 56) + 112))(*(void *)(v5 + 56), a3);
        return CCLogStream::logAlert(v6, "[dk] %s@%d: Error setting scan home away time request: %s\n", "setScanHomeAwayTimeCallback", 139, v7);
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANScanAdapter::startScan(AppleBCMWLANScanAdapter *a1, uint64_t a2)
{
  *(_DWORD *)(*((void *)a1 + 6) + 44) = AppleBCMWLANCore::getScanAlgorithm(*(AppleBCMWLANCore **)(*((void *)a1 + 6) + 56));
  uint64_t v4 = *((void *)a1 + 6);
  if (*(unsigned char *)v4) {
    return 3766617161;
  }
  if (AppleBCMWLANCore::getActionFrameProgress(*(AppleBCMWLANCore **)(v4 + 56)))
  {
    uint64_t started = 3758097109;
    if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d:Action frame in progress. Rejecting escan request!\n", "startScan", 165);
    }
  }
  else
  {
    AppleBCMWLANScanAdapter::setScanHomeAwayTime(a1, *(_DWORD *)(a2 + 8));
    if (*(unsigned char *)(a2 + 4))
    {
      BGScanAdapter = (AppleBCMWLANCore ***)AppleBCMWLANCore::getBGScanAdapter(*(AppleBCMWLANCore **)(*((void *)a1 + 6) + 56));
      AppleBCMWLANBGScanAdapter::generateAndApplyNewPrivateMACForScans(BGScanAdapter);
    }
    uint64_t v8 = *((void *)a1 + 6);
    if (*(_DWORD *)(v8 + 44) == 2)
    {
      uint64_t started = AppleBCMWLANScanAdapter::startEventScan(a1, a2);
      uint64_t v8 = *((void *)a1 + 6);
    }
    else
    {
      uint64_t started = 3758097090;
    }
    if (AppleBCMWLANCore::isConcurrencyEnabled(*(AppleBCMWLANCore **)(v8 + 56))
      && AppleBCMWLANCore::isConcurrencyOpModeSet(*(void *)(*((void *)a1 + 6) + 56), 4))
    {
      AppleBCMWLANCore::setSoftAPPowerState(*(void *)(*((void *)a1 + 6) + 56), 1u, 7u);
    }
  }
  return started;
}

uint64_t AppleBCMWLANScanAdapter::startEventScan(AppleBCMWLANScanAdapter *a1, uint64_t a2)
{
  uint64_t v4 = *((void *)a1 + 6);
  if (*(void *)(v4 + 72))
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v4 = *((void *)a1 + 6);
    if (shouldLog)
    {
      CCLogStream::logNoticeIf(*(CCLogStream **)(v4 + 72), 0x40uLL, "[dk] %s@%d:Starting Event scan, number of channels: %d\n", "startEventScan", 1055, *(_DWORD *)(a2 + 84));
      uint64_t v4 = *((void *)a1 + 6);
    }
  }
  if (AppleBCMWLANCore::getFirmwareInterfaceVersion(*(AppleBCMWLANCore **)(v4 + 56)) < 0x15
    || AppleBCMWLANCore::is4399B0(*(OSDictionary **)(*((void *)a1 + 6) + 56)))
  {
    if (AppleBCMWLANCore::getFirmwareInterfaceVersion(*(AppleBCMWLANCore **)(*((void *)a1 + 6) + 56)) < 0x11)
    {
      if (AppleBCMWLANCore::getFirmwareInterfaceVersion(*(AppleBCMWLANCore **)(*((void *)a1 + 6) + 56)) < 0xE)
      {
        bzero((void *)(*((void *)a1 + 6) + 1312), 0x4D0uLL);
        *(_DWORD *)(*((void *)a1 + 6) + 1312) = 1;
        *(_WORD *)(*((void *)a1 + 6) + 1316) = 1;
        uint64_t v24 = *((void *)a1 + 6);
        __int16 v25 = *(_WORD *)(v24 + 40) + 1;
        *(_WORD *)(v24 + 40) = v25;
        *(_WORD *)(*((void *)a1 + 6) + 1318) = v25;
        AppleBCMWLANScanAdapter::fillScanParams((uint64_t)a1, (char *)(*((void *)a1 + 6) + 1320), a2);
        memcpy((void *)(*((void *)a1 + 6) + 88), (const void *)(*((void *)a1 + 6) + 1320), 0x4C8uLL);
        uint64_t v26 = *((void *)a1 + 6);
        uint64_t v27 = *(AppleBCMWLANCommander **)(v26 + 64);
        uint64_t v54 = v26 + 1312;
        uint64_t v55 = 1232;
        uint64_t v12 = AppleBCMWLANCommander::runIOVarSet(v27, (uint64_t)"escan", (uint64_t)&v54, 0, 0);
        if (!v12) {
          return v12;
        }
LABEL_59:
        if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog())
        {
          uint64_t v52 = *((void *)a1 + 6);
          uint64_t v53 = *(CCLogStream **)(v52 + 72);
          (*(void (**)(void, uint64_t))(**(void **)(v52 + 56) + 112))(*(void *)(v52 + 56), v12);
          CCLogStream::logAlert(v53, "[dk] %s@%d:Error sending event scan request: %s\n");
        }
        return v12;
      }
      uint64_t v13 = IOMallocZeroData();
      if (v13)
      {
        uint64_t v7 = v13;
        *(_DWORD *)uint64_t v13 = 2;
        *(_WORD *)(v13 + 4) = 1;
        uint64_t v14 = *((void *)a1 + 6);
        __int16 v15 = *(_WORD *)(v14 + 40) + 1;
        *(_WORD *)(v14 + 40) = v15;
        *(_WORD *)(v13 + 6) = v15;
        uint64_t v16 = AppleBCMWLANScanAdapter::fillScanParams2(a1, (char *)(v13 + 8), a2);
        uint64_t v17 = *((void *)a1 + 6);
        if (v16)
        {
          uint64_t v12 = v16;
          if (*(void *)(v17 + 72) && CCLogStream::shouldLog()) {
            CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d:Error in fillScanParams2\n");
          }
          goto LABEL_23;
        }
        long long v43 = *(_OWORD *)(v7 + 12);
        long long v44 = *(_OWORD *)(v7 + 28);
        *(_DWORD *)(v17 + 120) = *(_DWORD *)(v7 + 44);
        *(_OWORD *)(v17 + 104) = v44;
        *(_OWORD *)(v17 + 88) = v43;
        uint64_t v45 = *((void *)a1 + 6);
        int v46 = *(_DWORD *)(v7 + 48);
        *(_WORD *)(v45 + 128) = *(_WORD *)(v7 + 52);
        *(_DWORD *)(v45 + 124) = v46;
        *(unsigned char *)(*((void *)a1 + 6) + 130) = *(unsigned char *)(v7 + 54);
        *(unsigned char *)(*((void *)a1 + 6) + 13IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = *(_DWORD *)(v7 + 56);
        *(_DWORD *)(*((void *)a1 + 6) + 132) = *(_DWORD *)(v7 + 60);
        *(_DWORD *)(*((void *)a1 + 6) + 136) = *(_DWORD *)(v7 + 64);
        *(_DWORD *)(*((void *)a1 + 6) + 140) = *(_DWORD *)(v7 + 68);
        *(_DWORD *)(*((void *)a1 + 6) + 144) = *(_DWORD *)(v7 + 72);
        *(_DWORD *)(*((void *)a1 + 6) + 148) = *(_DWORD *)(v7 + 76);
        memcpy((void *)(*((void *)a1 + 6) + 152), (const void *)(v7 + 80), 0x320uLL);
        memcpy((void *)(*((void *)a1 + 6) + 952), (const void *)(v7 + 880), 0x168uLL);
        *(_DWORD *)(*((void *)a1 + 6) + 48) = 0;
        int v47 = *(AppleBCMWLANCore **)(*((void *)a1 + 6) + 56);
        if (v47)
        {
          if (AppleBCMWLANCore::checkForScanCoreSupport(v47))
          {
            if ((AppleBCMWLANCore::checkForLPSCDisable(*(AppleBCMWLANCore **)(*((void *)a1 + 6) + 56)) & 1) == 0)
            {
              int v48 = AppleBCMWLANScanAdapter::resetSCChanimStats(a1);
              if (v48)
              {
                int v49 = v48;
                if (*(void *)(*((void *)a1 + 6) + 72))
                {
                  if (CCLogStream::shouldLog()) {
                    CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d: Error %d in resetting LP scan chanim stats\n", "startEventScan", 1238, v49);
                  }
                }
              }
            }
          }
        }
        goto LABEL_57;
      }
      uint64_t v12 = 3758097085;
      if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d:No memory for escan v2\n");
      }
    }
    else
    {
      uint64_t v6 = IOMallocZeroData();
      if (v6)
      {
        uint64_t v7 = v6;
        *(_DWORD *)uint64_t v6 = 3;
        *(_WORD *)(v6 + 4) = 1;
        uint64_t v8 = *((void *)a1 + 6);
        __int16 v9 = *(_WORD *)(v8 + 40) + 1;
        *(_WORD *)(v8 + 40) = v9;
        *(_WORD *)(v6 + 6) = v9;
        uint64_t v10 = AppleBCMWLANScanAdapter::fillScanParams3(a1, (char *)(v6 + 8), a2);
        uint64_t v11 = *((void *)a1 + 6);
        if (v10)
        {
          uint64_t v12 = v10;
          if (*(void *)(v11 + 72) && CCLogStream::shouldLog()) {
            CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d:Error in fillScanParams3\n");
          }
LABEL_23:
          IOFreeData();
          return v12;
        }
        long long v28 = *(_OWORD *)(v7 + 12);
        long long v29 = *(_OWORD *)(v7 + 28);
        *(_DWORD *)(v11 + 120) = *(_DWORD *)(v7 + 44);
        *(_OWORD *)(v11 + 104) = v29;
        *(_OWORD *)(v11 + 88) = v28;
        uint64_t v30 = *((void *)a1 + 6);
        int v31 = *(_DWORD *)(v7 + 48);
        *(_WORD *)(v30 + 128) = *(_WORD *)(v7 + 52);
        *(_DWORD *)(v30 + 124) = v31;
        *(unsigned char *)(*((void *)a1 + 6) + 130) = *(unsigned char *)(v7 + 54);
        *(unsigned char *)(*((void *)a1 + 6) + 13IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = *(_DWORD *)(v7 + 56);
        *(_DWORD *)(*((void *)a1 + 6) + 132) = *(_DWORD *)(v7 + 60);
        *(_DWORD *)(*((void *)a1 + 6) + 136) = *(_DWORD *)(v7 + 64);
        *(_DWORD *)(*((void *)a1 + 6) + 140) = *(_DWORD *)(v7 + 68);
        *(_DWORD *)(*((void *)a1 + 6) + 144) = *(_DWORD *)(v7 + 72);
        *(_DWORD *)(*((void *)a1 + 6) + 148) = *(_DWORD *)(v7 + 76);
        memcpy((void *)(*((void *)a1 + 6) + 152), (const void *)(v7 + 80), 0x320uLL);
        memcpy((void *)(*((void *)a1 + 6) + 952), (const void *)(v7 + 880), 0x168uLL);
        *(_DWORD *)(*((void *)a1 + 6) + 48) = 0;
        unint64_t v32 = *(AppleBCMWLANCore **)(*((void *)a1 + 6) + 56);
        if (v32)
        {
          if (AppleBCMWLANCore::checkForScanCoreSupport(v32))
          {
            if ((AppleBCMWLANCore::checkForLPSCDisable(*(AppleBCMWLANCore **)(*((void *)a1 + 6) + 56)) & 1) == 0)
            {
              int v33 = AppleBCMWLANScanAdapter::resetSCChanimStats(a1);
              if (v33)
              {
                int v34 = v33;
                if (*(void *)(*((void *)a1 + 6) + 72))
                {
                  if (CCLogStream::shouldLog()) {
                    CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d: Error %d in resetting LP scan chanim stats\n", "startEventScan", 1146, v34);
                  }
                }
              }
            }
          }
        }
LABEL_57:
        uint64_t v50 = *(AppleBCMWLANCommander **)(*((void *)a1 + 6) + 64);
        uint64_t v54 = v7;
        uint64_t v55 = 1240;
        uint64_t v12 = AppleBCMWLANCommander::runIOVarSet(v50, (uint64_t)"escan", (uint64_t)&v54, 0, 0);
LABEL_58:
        IOFreeData();
        if (!v12) {
          return v12;
        }
        goto LABEL_59;
      }
      uint64_t v12 = 3758097085;
      if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d:No memory for escan v3\n");
      }
    }
  }
  else
  {
    uint64_t v18 = IOMallocZeroData();
    if (v18)
    {
      uint64_t v19 = v18;
      *(_DWORD *)uint64_t v18 = 4;
      *(_WORD *)(v18 + 4) = 1;
      uint64_t v20 = *((void *)a1 + 6);
      __int16 v21 = *(_WORD *)(v20 + 40) + 1;
      *(_WORD *)(v20 + 40) = v21;
      *(_WORD *)(v18 + 6) = v21;
      uint64_t v22 = AppleBCMWLANScanAdapter::fillScanParams4(a1, (char *)(v18 + 8), a2);
      uint64_t v23 = *((void *)a1 + 6);
      if (v22)
      {
        uint64_t v12 = v22;
        if (*(void *)(v23 + 72) && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d:Error in fillScanParams4\n", "startEventScan", 1072);
        }
        goto LABEL_23;
      }
      long long v35 = *(_OWORD *)(v19 + 12);
      long long v36 = *(_OWORD *)(v19 + 28);
      *(_DWORD *)(v23 + 120) = *(_DWORD *)(v19 + 44);
      *(_OWORD *)(v23 + 104) = v36;
      *(_OWORD *)(v23 + 88) = v35;
      uint64_t v37 = *((void *)a1 + 6);
      int v38 = *(_DWORD *)(v19 + 48);
      *(_WORD *)(v37 + 128) = *(_WORD *)(v19 + 52);
      *(_DWORD *)(v37 + 124) = v38;
      *(unsigned char *)(*((void *)a1 + 6) + 130) = *(unsigned char *)(v19 + 54);
      *(unsigned char *)(*((void *)a1 + 6) + 13IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = *(_DWORD *)(v19 + 56);
      *(_DWORD *)(*((void *)a1 + 6) + 132) = *(_DWORD *)(v19 + 64);
      *(_DWORD *)(*((void *)a1 + 6) + 136) = *(_DWORD *)(v19 + 68);
      *(_DWORD *)(*((void *)a1 + 6) + 140) = *(_DWORD *)(v19 + 72);
      *(_DWORD *)(*((void *)a1 + 6) + 144) = *(_DWORD *)(v19 + 76);
      *(_DWORD *)(*((void *)a1 + 6) + 148) = *(_DWORD *)(v19 + 80);
      memcpy((void *)(*((void *)a1 + 6) + 152), (const void *)(v19 + 84), 0x320uLL);
      memcpy((void *)(*((void *)a1 + 6) + 952), (const void *)(v19 + 884), 0x168uLL);
      *(_DWORD *)(*((void *)a1 + 6) + 48) = 0;
      int v39 = *(AppleBCMWLANCore **)(*((void *)a1 + 6) + 56);
      if (v39)
      {
        if (AppleBCMWLANCore::checkForScanCoreSupport(v39))
        {
          if ((AppleBCMWLANCore::checkForLPSCDisable(*(AppleBCMWLANCore **)(*((void *)a1 + 6) + 56)) & 1) == 0)
          {
            int v40 = AppleBCMWLANScanAdapter::resetSCChanimStats(a1);
            if (v40)
            {
              int v41 = v40;
              if (*(void *)(*((void *)a1 + 6) + 72))
              {
                if (CCLogStream::shouldLog()) {
                  CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d: Error %d in resetting LP scan chanim stats\n", "startEventScan", 1099, v41);
                }
              }
            }
          }
        }
      }
      uint64_t v42 = *(AppleBCMWLANCommander **)(*((void *)a1 + 6) + 64);
      uint64_t v54 = v19;
      uint64_t v55 = 1244;
      uint64_t v12 = AppleBCMWLANCommander::runIOVarSet(v42, (uint64_t)"escan", (uint64_t)&v54, 0, 0);
      goto LABEL_58;
    }
    uint64_t v12 = 3758097085;
    if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d:No memory for escan v4\n");
    }
  }
  return v12;
}

uint64_t AppleBCMWLANScanAdapter::eventRoamScanResult(AppleBCMWLANScanAdapter *this, uint64_t a2)
{
  if (a2)
  {
    if (*(_WORD *)(a2 + 56))
    {
      if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:Found the sync id to be non zero in roam scan results event!\n");
      }
    }
    else if (*(_DWORD *)(a2 + 20) <= 0x8Fu)
    {
      if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:wle->datalen %lu is less than wl_escan_result_t %lu\n");
      }
    }
    else
    {
      if (*(_WORD *)(a2 + 58) != 1
        && *(void *)(*((void *)this + 6) + 72)
        && CCLogStream::shouldLog())
      {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:Error, BSS count is not 1: %d\n", "eventRoamScanResult", 210, *(unsigned __int16 *)(a2 + 58));
      }
      unsigned int v4 = *(_DWORD *)(a2 + 48);
      if (v4 >= 0x10000)
      {
        if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d: Too large buflen for bss_info(%u)\n");
        }
      }
      else
      {
        unint64_t v5 = *(unsigned int *)(a2 + 20);
        if (v4 > v5)
        {
          if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
            CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d: Not enough space datalen(%lu) for bss_info(%u), buflen(%u) offset(%lu)\n");
          }
        }
        else if (v4 <= 0x8F)
        {
          if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
            CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:res->buflen %u is less than wl_escan_result_t %lu\n");
          }
        }
        else
        {
          AppleBCMWLANScanAdapter::processScanResults(this, (void *)(a2 + 60), v5, *(unsigned __int16 *)(a2 + 58), *(unsigned int *)(a2 + 48), 0xCDu);
        }
      }
    }
  }
  else if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog())
  {
    CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:Invalid escan result!\n");
  }
  return 0;
}

uint64_t AppleBCMWLANScanAdapter::processScanResults(AppleBCMWLANScanAdapter *this, void *a2, unint64_t a3, unsigned int a4, size_t a5, unsigned int a6)
{
  uint64_t v12 = IOMallocZeroData();
  if (!v12) {
    AppleBCMWLANScanAdapter::processScanResults();
  }
  uint64_t v13 = (unsigned int *)v12;
  uint64_t v14 = (void *)IOMallocZeroData();
  uint64_t v15 = (uint64_t)v14;
  if (a5 > 0x7B)
  {
    if (a3 <= 0x7B)
    {
      if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d: Not enough space in the data buffer(%lu) for bss_info(%u)\n", "processScanResults", 346, a3, 124);
      }
      uint64_t v16 = 0;
      if (v15) {
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    if (!v14)
    {
      if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d: Allocation failure\n", "processScanResults", 349);
      }
      uint64_t v16 = 0;
      goto LABEL_51;
    }
    memcpy(v14, a2, a5);
    uint64_t v35 = v15;
    if (!a4)
    {
      char v34 = 0;
      BOOL v19 = 1;
      goto LABEL_45;
    }
    uint64_t v17 = v15;
    uint64_t v18 = 0;
    BOOL v19 = 0;
    unint64_t v20 = a5;
    uint64_t v21 = v17;
    while (v20 > 0x7B)
    {
      if (v20 < *(unsigned int *)(v21 + 4))
      {
        if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d: i=%lu/%lu Not enough space remaining in the data buffer(%lu) for bss len=%lu \n");
        }
        goto LABEL_44;
      }
      int v22 = *(unsigned __int16 *)(v21 + 116);
      if ((v22 - 124) >= 0xFFFFFF85)
      {
        if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d: i=%lu/%lu ie_offset=%d is less than size of bss  struct=%u\n");
        }
        goto LABEL_44;
      }
      if (v20 >> 16 || (unint64_t v23 = *(unsigned int *)(v21 + 120), v20 < v23) || v20 < (v23 + v22))
      {
        if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d: i=%lu/%lu Not enough space remaining in the data buffer(%lu) for ie_offset=%d + ie_len=%lu\n", "processScanResults");
        }
        goto LABEL_44;
      }
      uint64_t v24 = *(CCLogStream **)(*((void *)this + 6) + 72);
      if (v24 && CCLogStream::shouldLog(v24, 0x40uLL))
      {
        uint64_t v25 = *(unsigned int *)(v21 + 4);
        uint64_t v36 = v21;
        uint64_t v37 = v25;
        if (!v25)
        {
          uint64_t v36 = 0;
          uint64_t v37 = 0;
        }
        AppleBCMWLANScanAdapter::dumpScanResult(this, (const IO80211BufferCursor *)&v36);
      }
      ChanSpecHandler = (int **)AppleBCMWLANCore::getChanSpecHandler(*(AppleBCMWLANCore **)(*((void *)this + 6) + 56));
      __int16 AppleChannelSpec = AppleBCMWLANChanSpec::getAppleChannelSpec(ChanSpecHandler, *(unsigned __int16 *)(v21 + 72));
      unsigned int v28 = *(_DWORD *)(v21 + 120);
      if (v28 >= 0x801)
      {
        uint64_t v29 = *((void *)this + 6);
        if (*(void *)(v29 + 72))
        {
          int shouldLog = CCLogStream::shouldLog();
          uint64_t v29 = *((void *)this + 6);
          if (shouldLog)
          {
            CCLogStream::logAlert(*(CCLogStream **)(v29 + 72), "[dk] %s@%d:Received IE length is greater than expected \n", "processScanResults", 385);
            uint64_t v29 = *((void *)this + 6);
          }
        }
        CCFaultReporter::reportFault(*(CCFaultReporter **)(v29 + 80), 4u, "/Library/Caches/com.apple.xbs/Sources/AppleBCMWLANV3_driverkit/AppleBCMWLANScanAdapter.cpp", 0x182u, "processScanResults", 0, -528350132, "Larger than expected IE size %u", v28);
      }
      char BeaconMsgFromWLBSSInfo = AppleBCMWLANBSSBeacon::getBeaconMsgFromWLBSSInfo((uint64_t)v13, v13 + 16, v21, AppleChannelSpec, v20);
      uint64_t v32 = *((void *)this + 6);
      if ((BeaconMsgFromWLBSSInfo & 1) == 0)
      {
        if (*(void *)(v32 + 72))
        {
          char v34 = 1;
          if (CCLogStream::shouldLog()) {
            CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d: Beacon assembly failure\n", "processScanResults", 390);
          }
        }
        else
        {
          char v34 = 1;
        }
        goto LABEL_45;
      }
      AppleBCMWLANCore::postMessageInfra(*(AppleBCMWLANCore **)(v32 + 56), a6, v13, *v13 + 64);
      v20 -= *(unsigned int *)(v21 + 4);
      v21 += *(unsigned int *)(v21 + 4);
      BOOL v19 = ++v18 >= a4;
      if (a4 == v18)
      {
        char v34 = 0;
        BOOL v19 = 1;
        goto LABEL_45;
      }
    }
    if (!*(void *)(*((void *)this + 6) + 72))
    {
LABEL_44:
      char v34 = 0;
      goto LABEL_45;
    }
    if (CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d: i=%lu/%lu Not enough space remaining in the data buffer(%lu) for bss -> struct=%u \n", "processScanResults", 359, v18, a4, v20, 124);
    }
    char v34 = 0;
LABEL_45:
    if ((v19 | v34)) {
      uint64_t v16 = 0;
    }
    else {
      uint64_t v16 = 3758097084;
    }
    uint64_t v15 = v35;
  }
  else
  {
    uint64_t v16 = 3758097084;
    if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog())
    {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d: Not enough space in the data buffer(%lu) for bss_info(%u)\n", "processScanResults", 341, a5, 124);
      if (!v15) {
        goto LABEL_51;
      }
      goto LABEL_50;
    }
  }
  if (v15) {
LABEL_50:
  }
    IOFreeData();
LABEL_51:
  IOFreeData();
  return v16;
}

uint64_t AppleBCMWLANScanAdapter::eventScanComplete(AppleBCMWLANScanAdapter *this, uint64_t a2)
{
  if (!a2)
  {
    if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
      CCLogStream::logCrit(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:Event message invalid\n", "eventScanComplete", 259);
    }
    return 0;
  }
  unsigned int v4 = *(_DWORD *)(a2 + 8);
  if (v4 != 8)
  {
    int v10 = mapBcmStatusToApple80211IOReturnScan(v4);
    AppleBCMWLANCore::postMessageInfra(*(AppleBCMWLANCore **)(*((void *)this + 6) + 56), 0xEDu, &v10, 4uLL);
    return 0;
  }
  if (*(_DWORD *)(a2 + 20) <= 0x8Fu)
  {
    if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:wle->datalen %lu is less than wl_escan_result_t %lu\n");
    }
    return 0;
  }
  uint64_t v5 = *((void *)this + 6);
  if (*(unsigned __int16 *)(a2 + 56) != *(unsigned __int16 *)(v5 + 40)
    && *(void *)(v5 + 72)
    && CCLogStream::shouldLog())
  {
    CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:Error, syncId mismatch.  Expecting(%lu), got(%d)\n", "eventScanComplete", 272, *(unsigned __int16 *)(*((void *)this + 6) + 40), *(unsigned __int16 *)(a2 + 56));
  }
  if (*(_WORD *)(a2 + 58) != 1 && *(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:Error, BSS count is not 1: %d\n", "eventScanComplete", 276, *(unsigned __int16 *)(a2 + 58));
  }
  size_t v6 = *(unsigned int *)(a2 + 48);
  if (v6 >= 0x10000)
  {
    if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d: Too large buflen for bss_info(%u)\n");
    }
    return 0;
  }
  unint64_t v7 = *(unsigned int *)(a2 + 20);
  if (v6 > v7)
  {
    if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d: Not enough space datalen(%lu) for bss_info(%u), buflen(%u) offset(%lu)\n");
    }
    return 0;
  }
  if (v6 <= 0x8F)
  {
    if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:res->buflen %u is less than wl_escan_result_t %lu\n");
    }
    return 0;
  }
  unsigned int v8 = *(unsigned __int16 *)(a2 + 58);
  return AppleBCMWLANScanAdapter::processScanResults(this, (void *)(a2 + 60), v7, v8, v6, 0xC9u);
}

uint64_t AppleBCMWLANScanAdapter::dumpScanResult(AppleBCMWLANScanAdapter *this, const IO80211BufferCursor *a2)
{
  unint64_t v4 = *((void *)a2 + 1);
  if (v4 >= 0x84 && (uint64_t v5 = *(void *)a2) != 0)
  {
    unint64_t v6 = *(unsigned int *)(v5 + 120);
    if (v4 < v6 || v4 < v6 + *(unsigned __int16 *)(v5 + 116))
    {
      uint64_t result = *(void *)(*((void *)this + 6) + 72);
      if (result)
      {
        uint64_t result = CCLogStream::shouldLog();
        if (result) {
          return CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d: Not enough cursor size in the data buffer(%zu) for ie_offset=%u + ie_len=%u\n", "dumpScanResult", 421, *((void *)a2 + 1), *(unsigned __int16 *)(v5 + 116), *(_DWORD *)(v5 + 120));
        }
      }
      return result;
    }
    unsigned int v8 = (char *)IOMallocZeroData();
    __int16 v9 = v8;
    if (!v8
      || (char *v8 = 0,
          LODWORD(v8) = snprintf(v8, 0x800uLL, "BSSID: %02x:%02x:%02x:%02x:%02x:%02x SSID[%d]:", *(unsigned __int8 *)(v5 + 8), *(unsigned __int8 *)(v5 + 9), *(unsigned __int8 *)(v5 + 10), *(unsigned __int8 *)(v5 + 11), *(unsigned __int8 *)(v5 + 12), *(unsigned __int8 *)(v5 + 13), *(unsigned __int8 *)(v5 + 18)), unsigned int v10 = 2048, v8 <= 0x7FF))
    {
      unsigned int v10 = v8;
    }
    if (*(unsigned char *)(v5 + 18))
    {
      unint64_t v11 = 0;
      while (1)
      {
        if (v9) {
          BOOL v12 = v10 > 0x7FE;
        }
        else {
          BOOL v12 = 1;
        }
        char v13 = v12;
        if (*(unsigned __int8 *)(v5 + 19 + v11) - 127 >= 0xFFFFFFA1)
        {
          if ((v13 & 1) == 0)
          {
            int v14 = 2048;
            unsigned int v15 = snprintf(&v9[v10], 2048 - v10, "%c");
LABEL_28:
            if (v15 > 0x7FF) {
              goto LABEL_30;
            }
            goto LABEL_29;
          }
        }
        else if ((v13 & 1) == 0)
        {
          int v14 = 2048;
          unsigned int v15 = snprintf(&v9[v10], 2048 - v10, "\\%03d");
          goto LABEL_28;
        }
        unsigned int v15 = 0;
LABEL_29:
        int v14 = v15;
LABEL_30:
        v10 += v14;
        if (v11 <= 0x1E && ++v11 < *(unsigned __int8 *)(v5 + 18)) {
          continue;
        }
        break;
      }
    }
    ChanSpecHandler = (int **)AppleBCMWLANCore::getChanSpecHandler(*(AppleBCMWLANCore **)(*((void *)this + 6) + 56));
    unsigned __int8 AppleChannelSpec = AppleBCMWLANChanSpec::getAppleChannelSpec(ChanSpecHandler, *(unsigned __int16 *)(v5 + 72));
    unsigned int v18 = 0;
    if (!v9
      || v10 > 0x7FE
      || (int v19 = 2048,
          unsigned int v18 = snprintf(&v9[v10], 2048 - v10, "    Channel: %d RSSI: %d raw RSSI: %d flag: %x ", AppleChannelSpec, *(__int16 *)(v5 + 78), *(__int16 *)(v5 + 78), *(unsigned __int8 *)(v5 + 96)), v18 <= 0x7FF))
    {
      int v19 = v18;
    }
    uint64_t result = 0;
    unsigned int v20 = v19 + v10;
    if (!v9
      || v20 > 0x7FE
      || ((int v21 = 2048, *(unsigned char *)(v5 + 81)) ? (v22 = "N cap, ") : (v22 = (const char *)&unk_10029A2CA),
          uint64_t result = snprintf(&v9[v20], 2048 - v20, "capability: %04x beacon_period: %d dtim period: %d %s", *(unsigned __int16 *)(v5 + 16), *(unsigned __int16 *)(v5 + 14), *(unsigned __int8 *)(v5 + 76), v22), result <= 0x7FF))
    {
      int v21 = result;
    }
    if (v9 && v21 + v20 <= 0x7FE) {
      uint64_t result = snprintf(&v9[v21 + v20], 2048 - (v21 + v20), "N BSS cap: %08x N ctrl chan: %d\n", *(_DWORD *)(v5 + 84), *(unsigned __int8 *)(v5 + 88));
    }
    if (v9)
    {
      uint64_t result = *(void *)(*((void *)this + 6) + 72);
      if (result)
      {
        uint64_t result = CCLogStream::shouldLog();
        if (result) {
          uint64_t result = CCLogStream::log();
        }
      }
      char *v9 = 0;
    }
    uint64_t v23 = *(unsigned __int16 *)(v5 + 116);
    unint64_t v24 = *(unsigned int *)(v5 + 120);
    if (v24 + v23 > *((void *)a2 + 1)) {
      goto LABEL_73;
    }
    uint64_t v25 = *(void *)a2;
    uint64_t v26 = *(void *)a2 + v23;
    uint64_t v30 = v26;
    unint64_t v31 = v24;
    if (!v24) {
      goto LABEL_73;
    }
    if (!v25) {
      goto LABEL_73;
    }
    uint64_t result = *(void *)(*((void *)this + 6) + 72);
    if (!result) {
      goto LABEL_73;
    }
    uint64_t result = CCLogStream::shouldLog();
    if (!result) {
      goto LABEL_73;
    }
    uint64_t result = AppleBCMWLANScanAdapter::parseIE(this, (const IO80211BufferCursor *)&v30);
    if (v31)
    {
      unint64_t v27 = 0;
      unsigned int v28 = 0;
      do
      {
        uint64_t result = 0;
        if (!v9
          || v28 > 0x7FE
          || (int v29 = 2048,
              uint64_t result = snprintf(&v9[v28], 2048 - v28, "%02x ", *(unsigned __int8 *)(v26 + v27)),
              result <= 0x7FF))
        {
          int v29 = result;
        }
        v28 += v29;
        ++v27;
      }
      while (v27 < v31);
    }
    else
    {
      unsigned int v28 = 0;
    }
    if (v9 && v28 <= 0x7FE) {
      uint64_t result = snprintf(&v9[v28], 2048 - v28, "\n");
    }
    if (v9)
    {
      uint64_t result = *(void *)(*((void *)this + 6) + 72);
      if (result)
      {
        uint64_t result = CCLogStream::shouldLog();
        if (result) {
          uint64_t result = CCLogStream::log();
        }
      }
      char *v9 = 0;
LABEL_73:
      if (v9) {
        return IOFreeData();
      }
    }
  }
  else
  {
    uint64_t result = *(void *)(*((void *)this + 6) + 72);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result) {
        return CCLogStream::logCrit(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:Invalid BSS cursor size[%zu], expected %zu\n", "dumpScanResult", 416, *((void *)a2 + 1), 0x84uLL);
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANScanAdapter::parseIE(AppleBCMWLANScanAdapter *this, const IO80211BufferCursor *a2)
{
  uint64_t result = *(void *)(*((void *)this + 6) + 72);
  if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    BOOL v4 = !result || *(void *)a2 == 0;
    if (!v4 && *((void *)a2 + 1) != 0)
    {
      uint64_t result = (uint64_t)IO80211BufferCursor::_crop((uint64_t *)a2, 0, 0xFFFFFFFFFFFFFFFFLL, &v9);
      unint64_t v7 = v9;
      unint64_t v8 = v10;
      unint64_t v10 = v9;
      unint64_t v11 = v8;
      if (v9)
      {
        if (v8 >= 2)
        {
          do
          {
            if ((unint64_t)*(unsigned __int8 *)(v7 + 1) + 2 > v8) {
              break;
            }
            if (v7 + 2 < v7) {
              os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range", v6);
            }
            uint64_t result = (uint64_t)IO80211TLVIterator<IO80211TLVHeader<unsigned char,unsigned char,0ul,1ul,0ul>>::operator++((uint64_t)&v9);
            unint64_t v7 = v10;
            if (!v10) {
              break;
            }
            unint64_t v8 = v11;
          }
          while (v11 > 1);
        }
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANScanAdapter::abortEventScan(AppleBCMWLANScanAdapter *this)
{
  if (AppleBCMWLANCore::getFirmwareInterfaceVersion(*(AppleBCMWLANCore **)(*((void *)this + 6) + 56)) < 0x15
    || AppleBCMWLANCore::is4399B0(*(OSDictionary **)(*((void *)this + 6) + 56)))
  {
    if (AppleBCMWLANCore::getFirmwareInterfaceVersion(*(AppleBCMWLANCore **)(*((void *)this + 6) + 56)) < 0x11)
    {
      if (AppleBCMWLANCore::getFirmwareInterfaceVersion(*(AppleBCMWLANCore **)(*((void *)this + 6)
                                                                                            + 56)) < 0xE)
      {
        bzero((void *)(*((void *)this + 6) + 1312), 0x4D0uLL);
        *(_DWORD *)(*((void *)this + 6) + 1312) = 1;
        *(_WORD *)(*((void *)this + 6) + 1316) = 3;
        uint64_t v16 = *((void *)this + 6);
        __int16 v17 = *(_WORD *)(v16 + 40) + 1;
        *(_WORD *)(v16 + 40) = v17;
        *(_WORD *)(*((void *)this + 6) + 1318) = v17;
        uint64_t v18 = *((void *)this + 6);
        if (*(void *)(v18 + 72))
        {
          int shouldLog = CCLogStream::shouldLog();
          uint64_t v18 = *((void *)this + 6);
          if (shouldLog)
          {
            CCLogStream::logNotice(*(CCLogStream **)(v18 + 72), "[dk] %s@%d:Event scan is in progress, aborting...\n", "abortEventScan", 586);
            uint64_t v18 = *((void *)this + 6);
          }
        }
        uint64_t v15 = AppleBCMWLANCommander::sendIOVarSet(*(AppleBCMWLANCommander **)(v18 + 64), (uint64_t)"escan");
        if (v15)
        {
LABEL_23:
          if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog())
          {
            uint64_t v20 = *((void *)this + 6);
            int v21 = *(CCLogStream **)(v20 + 72);
            (*(void (**)(void, uint64_t))(**(void **)(v20 + 56) + 112))(*(void *)(v20 + 56), v15);
            CCLogStream::logAlert(v21, "[dk] %s@%d: Error aborting event scan: %s\n");
          }
        }
      }
      else
      {
        uint64_t v7 = IOMallocZeroData();
        if (v7)
        {
          *(_DWORD *)uint64_t v7 = 2;
          *(_WORD *)(v7 + 4) = 3;
          uint64_t v8 = *((void *)this + 6);
          __int16 v9 = *(_WORD *)(v8 + 40) + 1;
          *(_WORD *)(v8 + 40) = v9;
          *(_WORD *)(v7 + 6) = v9;
          uint64_t v5 = *((void *)this + 6);
          if (*(void *)(v5 + 72))
          {
            int v10 = CCLogStream::shouldLog();
            uint64_t v5 = *((void *)this + 6);
            if (v10)
            {
              CCLogStream::logNotice(*(CCLogStream **)(v5 + 72), "[dk] %s@%d:Event scan V2 is in progress, aborting...\n");
              goto LABEL_37;
            }
          }
LABEL_17:
          uint64_t v15 = AppleBCMWLANCommander::sendIOVarSet(*(AppleBCMWLANCommander **)(v5 + 64), (uint64_t)"escan");
          IOFreeData();
          if (!v15) {
            return v15;
          }
          goto LABEL_23;
        }
        uint64_t v15 = 3758097085;
        if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:No memory for escan v2\n");
        }
      }
    }
    else
    {
      uint64_t v2 = IOMallocZeroData();
      if (v2)
      {
        *(_DWORD *)uint64_t v2 = 3;
        *(_WORD *)(v2 + 4) = 3;
        uint64_t v3 = *((void *)this + 6);
        __int16 v4 = *(_WORD *)(v3 + 40) + 1;
        *(_WORD *)(v3 + 40) = v4;
        *(_WORD *)(v2 + 6) = v4;
        uint64_t v5 = *((void *)this + 6);
        if (*(void *)(v5 + 72))
        {
          int v6 = CCLogStream::shouldLog();
          uint64_t v5 = *((void *)this + 6);
          if (v6)
          {
            CCLogStream::logNotice(*(CCLogStream **)(v5 + 72), "[dk] %s@%d:Event scan V3 is in progress, aborting...\n");
LABEL_37:
            uint64_t v5 = *((void *)this + 6);
            goto LABEL_17;
          }
        }
        goto LABEL_17;
      }
      uint64_t v15 = 3758097085;
      if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:No memory for escan v3\n");
      }
    }
  }
  else
  {
    uint64_t v11 = IOMallocZeroData();
    if (v11)
    {
      *(_DWORD *)uint64_t v11 = 4;
      *(_WORD *)(v11 + 4) = 3;
      uint64_t v12 = *((void *)this + 6);
      __int16 v13 = *(_WORD *)(v12 + 40) + 1;
      *(_WORD *)(v12 + 40) = v13;
      *(_WORD *)(v11 + 6) = v13;
      uint64_t v5 = *((void *)this + 6);
      if (*(void *)(v5 + 72))
      {
        int v14 = CCLogStream::shouldLog();
        uint64_t v5 = *((void *)this + 6);
        if (v14)
        {
          CCLogStream::logNotice(*(CCLogStream **)(v5 + 72), "[dk] %s@%d:Event scan V4 is in progress, aborting...\n", "abortEventScan", 516);
          uint64_t v5 = *((void *)this + 6);
        }
      }
      goto LABEL_17;
    }
    uint64_t v15 = 3758097085;
    if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:No memory for escan v4\n");
    }
  }
  return v15;
}

uint64_t AppleBCMWLANScanAdapter::handleEScanAbortResults(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = *(void *)(*(void *)(a1 + 48) + 72);
  if (a3)
  {
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        uint64_t v6 = *(void *)(a1 + 48);
        uint64_t v7 = *(CCLogStream **)(v6 + 72);
        uint64_t v8 = (const char *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 56) + 112))(*(void *)(v6 + 56), a3);
        return CCLogStream::logAlert(v7, "[dk] %s@%d: Error aborting scan : %s\n", "handleEScanAbortResults", 601, v8);
      }
    }
  }
  else if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result) {
      return CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 72), 0x40uLL, "[dk] %s@%d: : Success in Scan Abort\n", "handleEScanAbortResults", 604);
    }
  }
  return result;
}

uint64_t AppleBCMWLANScanAdapter::setSCTxBlankStatus(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 48);
  int v3 = *(_DWORD *)(v2 + 48);
  if ((v3 & a2) != 0xFFFFFFFF) {
    *(_DWORD *)(v2 + 48) = v3 | a2;
  }
  return result;
}

uint64_t AppleBCMWLANScanAdapter::getSCTxBlankStatus(AppleBCMWLANScanAdapter *this)
{
  int v1 = *(_DWORD *)(*((void *)this + 6) + 48);
  if ((v1 & 2) != 0) {
    unsigned int v2 = 2;
  }
  else {
    unsigned int v2 = 1;
  }
  if ((v1 & 4) != 0) {
    return 4;
  }
  else {
    return v2;
  }
}

uint64_t AppleBCMWLANScanAdapter::scanComplete(uint64_t a1, uint64_t a2)
{
  int v4 = mapBcmStatusToApple80211IOReturnScan(*(_DWORD *)(a2 + 8));
  return AppleBCMWLANCore::postMessageInfra(*(AppleBCMWLANCore **)(*(void *)(a1 + 48) + 56), 0xEDu, &v4, 4uLL);
}

uint64_t AppleBCMWLANScanAdapter::processAndSendWLBSSInfo(AppleBCMWLANScanAdapter *a1, const void *a2, size_t a3)
{
  if (!IOMallocZeroData()) {
    AppleBCMWLANScanAdapter::processAndSendWLBSSInfo();
  }
  uint64_t v6 = IOMallocZeroData();
  if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog())
  {
    CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d:\n", "processAndSendWLBSSInfo", 648);
    if (v6) {
      goto LABEL_5;
    }
  }
  else if (v6)
  {
LABEL_5:
    if (a2)
    {
      if (a3 <= 3)
      {
        uint64_t v12 = 3758097084;
        if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d: bss too small\n");
        }
      }
      else
      {
        memcpy((void *)v6, a2, a3);
        if (*(unsigned int *)(v6 + 4) > a3)
        {
          uint64_t v12 = 3758097084;
          if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
            CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d: Can't add beacon, buffer(%lu) does not have enough space for bss(%lu)\n");
          }
        }
        else if (a3 >> 16 || *(_DWORD *)(v6 + 120) + *(unsigned __int16 *)(v6 + 116) > a3)
        {
          uint64_t v12 = 3758097084;
          if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
            CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d: Not enough space remaining in the data buffer(%lu) for ie_offset=%d + ie_len=%lu\n");
          }
        }
        else
        {
          uint64_t v7 = *((void *)a1 + 6);
          uint64_t v8 = *(CCLogStream **)(v7 + 72);
          if (v8)
          {
            int shouldLog = CCLogStream::shouldLog(v8, 0x8000uLL);
            uint64_t v7 = *((void *)a1 + 6);
            if (shouldLog)
            {
              if (*(void *)(v7 + 72) && CCLogStream::shouldLog()) {
                CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x8000uLL, "[dk] %s@%d: Adding beacon\n", "processAndSendWLBSSInfo", 676);
              }
              uint64_t v10 = *(unsigned int *)(v6 + 4);
              uint64_t v14 = v6;
              uint64_t v15 = v10;
              if (!v10)
              {
                uint64_t v14 = 0;
                uint64_t v15 = 0;
              }
              AppleBCMWLANScanAdapter::dumpScanResult(a1, (const IO80211BufferCursor *)&v14);
              uint64_t v7 = *((void *)a1 + 6);
            }
          }
          ChanSpecHandler = (int **)AppleBCMWLANCore::getChanSpecHandler(*(AppleBCMWLANCore **)(v7 + 56));
          AppleBCMWLANChanSpec::getAppleChannelSpec(ChanSpecHandler, *(unsigned __int16 *)(v6 + 72));
          if (*(_DWORD *)(v6 + 8) | *(unsigned __int16 *)(v6 + 12))
          {
            uint64_t v12 = AppleBCMWLANScanAdapter::processScanResults(a1, (void *)v6, a3, 1u, *(unsigned int *)(v6 + 4), 0xCEu);
          }
          else
          {
            uint64_t v12 = 3758097084;
            if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
              CCLogStream::logNotice(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d: Can't add beacon, bssid is zero\n", "processAndSendWLBSSInfo", 682);
            }
          }
        }
      }
    }
    else
    {
      uint64_t v12 = 3758097084;
      if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d: Can't add beacon, bss is null \n");
      }
    }
    IOFreeData();
    goto LABEL_21;
  }
  uint64_t v12 = 3758097084;
  if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d: Can't add beacon, allocation failure\n", "processAndSendWLBSSInfo", 653);
  }
LABEL_21:
  IOFreeData();
  return v12;
}

uint64_t AppleBCMWLANScanAdapter::handleGetSCChanQualAsyncCallback(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4 = result;
  if (a3)
  {
    uint64_t result = *(void *)(*(void *)(result + 48) + 72);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        uint64_t v46 = *(void *)(v4 + 48);
        int v47 = *(CCLogStream **)(v46 + 72);
        (*(void (**)(void, uint64_t))(**(void **)(v46 + 56) + 112))(*(void *)(v46 + 56), a3);
        return CCLogStream::logAlert(v47, "[dk] %s@%d:LPSC: Error: Failed to get SC chanim_stats: %s\n");
      }
    }
  }
  else
  {
    uint64_t v6 = *a4;
    if (*a4)
    {
      if ((*(_DWORD *)v6 & 0xFFFFFFFC) == 4)
      {
        unsigned int v7 = *(unsigned __int8 *)(v6 + 10);
        if (*(unsigned char *)(v6 + 8) == 1 && v7 > 1)
        {
          uint64_t result = *(void *)(*(void *)(result + 48) + 72);
          if (result)
          {
            uint64_t result = CCLogStream::shouldLog();
            if (result) {
              return CCLogStream::logAlert(*(CCLogStream **)(*(void *)(v4 + 48) + 72), "[dk] %s@%d:LPSC: Invalid chanim_stats channel count, expect 1, output %d\n");
            }
          }
        }
        else if (*(unsigned char *)(v6 + 10))
        {
          LOBYTE(v48) = 0;
          uint64_t v9 = v6 + 12;
          unsigned __int8 v10 = 1;
          do
          {
            int v11 = v10 - 1;
            uint64_t v12 = v9 + 60 * v11;
            if (v10 != v7 || (*(_WORD *)(v12 + 4) & 1) != 0)
            {
              ChanSpecHandler = (int **)AppleBCMWLANCore::getChanSpecHandler(*(AppleBCMWLANCore **)(*(void *)(v4 + 48)
                                                                                                  + 56));
              AppleBCMWLANChanSpec::getAppleChannelSpec(ChanSpecHandler, *(unsigned __int16 *)(v12 + 4));
              unsigned int PrimaryChannel = ChanSpecGetPrimaryChannel();
              unsigned int v15 = PrimaryChannel;
              if (*(_DWORD *)v12)
              {
                float v16 = (float)*(unsigned int *)v12;
                __int16 v17 = (unsigned int *)(v9 + 60 * v11);
                if (PrimaryChannel > 0x23)
                {
                  unsigned int v48 = (int)(float)((float)((float)v17[5] / v16) * 100.0);
                  BOOL v19 = v48 > 0x19;
                  if (v48 <= 0x19) {
                    uint64_t v20 = "No";
                  }
                  else {
                    uint64_t v20 = "Yes";
                  }
                  int v21 = "MC Tx";
                }
                else
                {
                  unsigned int v18 = ((int)(float)((float)(50 * v17[7]) / 100.0)
                                        + (int)(float)((float)((float)v17[6] / v16) * 100.0));
                  if (v18 >= 0x64) {
                    unsigned int v18 = 100;
                  }
                  LOBYTE(v48) = v18;
                  BOOL v19 = v18 > 0x19;
                  if (v18 <= 0x19) {
                    uint64_t v20 = "No";
                  }
                  else {
                    uint64_t v20 = "Yes";
                  }
                  int v21 = "AC/BT Tx";
                }
                if (v19) {
                  int v22 = v21;
                }
                else {
                  int v22 = "N/A";
                }
              }
              else
              {
                uint64_t v20 = "No";
                int v22 = "N/A";
              }
              uint64_t result = AppleBCMWLANCore::isLPSCDebugEnabled(*(AppleBCMWLANCore **)(*(void *)(v4 + 48) + 56));
              if (result)
              {
                uint64_t v23 = *(void *)(v4 + 48);
                if (*(void *)(v23 + 72))
                {
                  int shouldLog = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (shouldLog)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:|| [Channel: %-3d] ===========================================================================\n", "handleGetSCChanQualAsyncCallback", 762, v15);
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v25 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v25)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:|| [Summary] --------------------------------------------------------------------------------\n", "handleGetSCChanQualAsyncCallback", 763);
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v26 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v26)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   Tx Blanking                                    |                       | %-12s ||\n", "handleGetSCChanQualAsyncCallback", 764, v20);
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v27 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v27)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   Tx Blanking Reason                             |                       | %-12s ||\n", "handleGetSCChanQualAsyncCallback", 765, v22);
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v28 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v28)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   Tx Blanking Thresh Perc                        |                       | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 766, 25);
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v29 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v29)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   Tx Blanking Perc                               |                       | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 767, v48);
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v30 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v30)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   Duration on SC                                 | sc_only_rx_dur        | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 768, *(_DWORD *)(v9 + 60 * v11 + 8));
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v31 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v31)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   Duration total                                 | time_dur              | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 769, *(_DWORD *)v12);
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v32 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v32)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   Timestamp                                      | timestamp             | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 770, *(_DWORD *)(v9 + 60 * v11 + 56));
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v33 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v33)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:|| [Details] --------------------------------------------------------------------------------\n", "handleGetSCChanQualAsyncCallback", 771);
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v34 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v34)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   Rx only on SC                                  | sc_only_rx_dur        | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 772, *(_DWORD *)(v9 + 60 * v11 + 8));
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v35 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v35)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   Rx on SC when MC active                        | sc_rx_mc_rx_dur       | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 773, *(_DWORD *)(v9 + 60 * v11 + 12));
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v36 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v36)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   Rx on SC when AC active                        | sc_rx_ac_rx_dur       | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 774, *(_DWORD *)(v9 + 60 * v11 + 16));
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v37 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v37)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   Rx on SC when BT Main active                   | sc_rx_bt_rx_dur       | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 775, *(_DWORD *)(v9 + 60 * v11 + 28));
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v38 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v38)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   Rx on SC when MC Tx                            | sc_rx_mc_tx_dur       | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 776, *(_DWORD *)(v9 + 60 * v11 + 20));
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v39 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v39)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   Rx on SC when AC-BT Tx                         | sc_rx_ac_bt_tx_dur    | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 777, *(_DWORD *)(v9 + 60 * v11 + 24));
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if ((*(_DWORD *)v6 - 5) <= 1)
                {
                  if (*(void *)(v23 + 72))
                  {
                    int v40 = CCLogStream::shouldLog();
                    uint64_t v23 = *(void *)(v4 + 48);
                    if (v40)
                    {
                      CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   BT Rx transitions                              | sc_btrx_trans_cnt     | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 779, *(unsigned __int16 *)(v9 + 60 * v11 + 6));
                      uint64_t v23 = *(void *)(v4 + 48);
                    }
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v41 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v41)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   WLAN SC awake and BT SC LE scan overlapped     | sc_btle_overlap_dur   | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 780, *(_DWORD *)(v9 + 60 * v11 + 32));
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v42 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v42)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   WLAN SC awake and BT SC Page scan overlapped   | sc_btpage_overlap_dur | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 781, *(_DWORD *)(v9 + 60 * v11 + 36));
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v43 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v43)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   WLAN Aux Tx blanked BT SC LE scan              | ac_btle_blnk_dur      | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 782, *(_DWORD *)(v9 + 60 * v11 + 40));
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v44 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v44)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   WLAN Aux Tx blanked BT SC Page scan            | ac_btpage_blnk_dur    | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 783, *(_DWORD *)(v9 + 60 * v11 + 44));
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                if (*(void *)(v23 + 72))
                {
                  int v45 = CCLogStream::shouldLog();
                  uint64_t v23 = *(void *)(v4 + 48);
                  if (v45)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v23 + 72), "[dk] %s@%d:||   WLAN Aux awake and BT SC LE scan overlapped    | ac_btle_overlap_dur   | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 784, *(_DWORD *)(v9 + 60 * v11 + 48));
                    uint64_t v23 = *(void *)(v4 + 48);
                  }
                }
                uint64_t result = *(void *)(v23 + 72);
                if (result)
                {
                  uint64_t result = CCLogStream::shouldLog();
                  if (result) {
                    uint64_t result = CCLogStream::logInfo(*(CCLogStream **)(*(void *)(v4 + 48) + 72), "[dk] %s@%d:||   WLAN Aux awake and BT SC Page scan overlapped  | ac_btpage_overlap_dur | %-12u ||\n", "handleGetSCChanQualAsyncCallback", 785, *(_DWORD *)(v9 + 60 * v11 + 52));
                  }
                }
              }
            }
            ++v10;
            unsigned int v7 = *(unsigned __int8 *)(v6 + 10);
          }
          while (v7 >= v10);
        }
      }
      else
      {
        uint64_t result = *(void *)(*(void *)(result + 48) + 72);
        if (result)
        {
          uint64_t result = CCLogStream::shouldLog();
          if (result) {
            return CCLogStream::logAlert(*(CCLogStream **)(*(void *)(v4 + 48) + 72), "[dk] %s@%d:LPSC: Invalid version for LPSC chanim_stats response\n");
          }
        }
      }
    }
    else
    {
      uint64_t result = *(void *)(*(void *)(result + 48) + 72);
      if (result)
      {
        uint64_t result = CCLogStream::shouldLog();
        if (result) {
          return CCLogStream::logNotice(*(CCLogStream **)(*(void *)(v4 + 48) + 72), "[dk] %s@%d:LPSC: No valid data\n", "handleGetSCChanQualAsyncCallback", 711);
        }
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANScanAdapter::getSCChanQual(uint64_t a1, int a2)
{
  if (AppleBCMWLANCore::checkForScanCoreSupport(*(AppleBCMWLANCore **)(*(void *)(a1 + 48) + 56)))
  {
    if (a2 == 1) {
      uint64_t v4 = 72;
    }
    else {
      uint64_t v4 = 1812;
    }
    uint64_t v5 = IOMallocZeroData();
    if (v5)
    {
      uint64_t v6 = v5;
      *(_DWORD *)(v5 + 4) = v4;
      *(unsigned char *)(v5 + 8) = a2;
      v55[0] = v5;
      v55[1] = v4;
      v54[0] = v5;
      v54[1] = v4 & 0xFFFFF800FFFFFFFFLL | ((((unint64_t)(v4 << 16) >> 16) & 0x7FF) << 32);
      uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 48) + 56) + 88))(*(void *)(*(void *)(a1 + 48) + 56));
      if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 136))(v7))
      {
        v53[0] = a1;
        v53[1] = AppleBCMWLANScanAdapter::handleGetSCChanQualAsyncCallback;
        v53[2] = 0;
        uint64_t v8 = *(AppleBCMWLANCommander **)(*(void *)(a1 + 48) + 64);
        int v52 = v4 << 16;
        int v9 = AppleBCMWLANCommander::sendIOVarGet(v8, (uint64_t)"sc:chanim_stats", (uint64_t)v55, (unsigned __int16 *)&v52, (uint64_t)v53, 0);
        if (v9)
        {
          int v10 = v9;
          if (*(void *)(*(void *)(a1 + 48) + 72))
          {
            if (CCLogStream::shouldLog()) {
              CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d: Failed GET IOCTL, cret[0x%08x]\n", "getSCChanQual", 836, v10);
            }
          }
        }
LABEL_11:
        uint64_t v11 = 0;
LABEL_31:
        IOFreeData();
        return v11;
      }
      uint64_t v12 = AppleBCMWLANCommander::runIOVarGet(*(AppleBCMWLANCommander **)(*(void *)(a1 + 48) + 64), (uint64_t)"sc:chanim_stats", (uint64_t)v55, (uint64_t)v54, 0);
      if (v12)
      {
        uint64_t v11 = v12;
        if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:LPSC: Failed to get sc chanim_stats\n", "getSCChanQual", 842);
        }
        goto LABEL_31;
      }
      if ((*(_DWORD *)v6 & 0xFFFFFFFC) == 4)
      {
        if (*(unsigned char *)(v6 + 8) != 1 || *(unsigned __int8 *)(v6 + 10) <= 1u)
        {
          if (*(unsigned char *)(v6 + 10))
          {
            LOBYTE(v5IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = 0;
            uint64_t v14 = v6 + 12;
            unsigned __int8 v15 = 1;
            do
            {
              int v16 = v15 - 1;
              uint64_t v17 = v14 + 60 * v16;
              ChanSpecHandler = (int **)AppleBCMWLANCore::getChanSpecHandler(*(AppleBCMWLANCore **)(*(void *)(a1 + 48)
                                                                                                  + 56));
              AppleBCMWLANChanSpec::getAppleChannelSpec(ChanSpecHandler, *(unsigned __int16 *)(v17 + 4));
              unsigned int PrimaryChannel = ChanSpecGetPrimaryChannel();
              unsigned int v20 = PrimaryChannel;
              if (*(_DWORD *)v17)
              {
                float v21 = (float)*(unsigned int *)v17;
                int v22 = (unsigned int *)(v14 + 60 * v16);
                if (PrimaryChannel > 0x23)
                {
                  unsigned int v51 = (int)(float)((float)((float)v22[5] / v21) * 100.0);
                  BOOL v24 = v51 > 0x19;
                  if (v51 <= 0x19) {
                    int v25 = "No";
                  }
                  else {
                    int v25 = "Yes";
                  }
                  int v26 = "MC Tx";
                }
                else
                {
                  unsigned int v23 = ((int)(float)((float)(50 * v22[7]) / 100.0)
                                        + (int)(float)((float)((float)v22[6] / v21) * 100.0));
                  if (v23 >= 0x64) {
                    unsigned int v23 = 100;
                  }
                  LOBYTE(v5IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = v23;
                  BOOL v24 = v23 > 0x19;
                  if (v23 <= 0x19) {
                    int v25 = "No";
                  }
                  else {
                    int v25 = "Yes";
                  }
                  int v26 = "AC/BT Tx";
                }
                if (v24) {
                  int v27 = v26;
                }
                else {
                  int v27 = "N/A";
                }
              }
              else
              {
                int v25 = "No";
                int v27 = "N/A";
              }
              if (AppleBCMWLANCore::isLPSCDebugEnabled(*(AppleBCMWLANCore **)(*(void *)(a1 + 48) + 56)))
              {
                uint64_t v28 = *(void *)(a1 + 48);
                if (*(void *)(v28 + 72))
                {
                  int shouldLog = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (shouldLog)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:|| [Channel: %-3d] ===========================================================================\n", "getSCChanQual", 888, v20);
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v30 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v30)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:|| [Summary] --------------------------------------------------------------------------------\n", "getSCChanQual", 889);
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v31 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v31)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   Tx Blanking                                    |                       | %-12s ||\n", "getSCChanQual", 890, v25);
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v32 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v32)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   Tx Blanking Reason                             |                       | %-12s ||\n", "getSCChanQual", 891, v27);
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v33 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v33)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   Tx Blanking Thresh Perc                        |                       | %-12u ||\n", "getSCChanQual", 892, 25);
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v34 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v34)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   Tx Blanking Perc                               |                       | %-12u ||\n", "getSCChanQual", 893, v51);
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v35 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v35)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   Duration on SC                                 | sc_only_rx_dur        | %-12u ||\n", "getSCChanQual", 894, *(_DWORD *)(v14 + 60 * v16 + 8));
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v36 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v36)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   Duration total                                 | time_dur              | %-12u ||\n", "getSCChanQual", 895, *(_DWORD *)v17);
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v37 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v37)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   Timestamp                                      | timestamp             | %-12u ||\n", "getSCChanQual", 896, *(_DWORD *)(v14 + 60 * v16 + 56));
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v38 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v38)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:|| [Details] --------------------------------------------------------------------------------\n", "getSCChanQual", 897);
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v39 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v39)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   Rx only on SC                                  | sc_only_rx_dur        | %-12u ||\n", "getSCChanQual", 898, *(_DWORD *)(v14 + 60 * v16 + 8));
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v40 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v40)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   Rx on SC when MC active                        | sc_rx_mc_rx_dur       | %-12u ||\n", "getSCChanQual", 899, *(_DWORD *)(v14 + 60 * v16 + 12));
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v41 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v41)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   Rx on SC when AC active                        | sc_rx_ac_rx_dur       | %-12u ||\n", "getSCChanQual", 900, *(_DWORD *)(v14 + 60 * v16 + 16));
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v42 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v42)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   Rx on SC when BT Main active                   | sc_rx_bt_rx_dur       | %-12u ||\n", "getSCChanQual", 901, *(_DWORD *)(v14 + 60 * v16 + 28));
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v43 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v43)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   Rx on SC when MC Tx                            | sc_rx_mc_tx_dur       | %-12u ||\n", "getSCChanQual", 902, *(_DWORD *)(v14 + 60 * v16 + 20));
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v44 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v44)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   Rx on SC when AC-BT Tx                         | sc_rx_ac_bt_tx_dur    | %-12u ||\n", "getSCChanQual", 903, *(_DWORD *)(v14 + 60 * v16 + 24));
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if ((*(_DWORD *)v6 - 5) <= 1)
                {
                  if (*(void *)(v28 + 72))
                  {
                    int v45 = CCLogStream::shouldLog();
                    uint64_t v28 = *(void *)(a1 + 48);
                    if (v45)
                    {
                      CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   BT Rx transitions                              | sc_btrx_trans_cnt     | %-12u ||\n", "getSCChanQual", 905, *(unsigned __int16 *)(v14 + 60 * v16 + 6));
                      uint64_t v28 = *(void *)(a1 + 48);
                    }
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v46 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v46)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   WLAN SC awake and BT SC LE scan overlapped     | sc_btle_overlap_dur   | %-12u ||\n", "getSCChanQual", 906, *(_DWORD *)(v14 + 60 * v16 + 32));
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v47 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v47)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   WLAN SC awake and BT SC Page scan overlapped   | sc_btpage_overlap_dur | %-12u ||\n", "getSCChanQual", 907, *(_DWORD *)(v14 + 60 * v16 + 36));
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v48 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v48)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   WLAN Aux Tx blanked BT SC LE scan              | ac_btle_blnk_dur      | %-12u ||\n", "getSCChanQual", 908, *(_DWORD *)(v14 + 60 * v16 + 40));
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v49 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v49)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   WLAN Aux Tx blanked BT SC Page scan            | ac_btpage_blnk_dur    | %-12u ||\n", "getSCChanQual", 909, *(_DWORD *)(v14 + 60 * v16 + 44));
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72))
                {
                  int v50 = CCLogStream::shouldLog();
                  uint64_t v28 = *(void *)(a1 + 48);
                  if (v50)
                  {
                    CCLogStream::logInfo(*(CCLogStream **)(v28 + 72), "[dk] %s@%d:||   WLAN Aux awake and BT SC LE scan overlapped    | ac_btle_overlap_dur   | %-12u ||\n", "getSCChanQual", 910, *(_DWORD *)(v14 + 60 * v16 + 48));
                    uint64_t v28 = *(void *)(a1 + 48);
                  }
                }
                if (*(void *)(v28 + 72) && CCLogStream::shouldLog()) {
                  CCLogStream::logInfo(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:||   WLAN Aux awake and BT SC Page scan overlapped  | ac_btpage_overlap_dur | %-12u ||\n", "getSCChanQual", 911, *(_DWORD *)(v14 + 60 * v16 + 52));
                }
              }
              uint64_t v11 = 0;
              ++v15;
            }
            while (*(unsigned __int8 *)(v6 + 10) >= v15);
            goto LABEL_31;
          }
          goto LABEL_11;
        }
        if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:LPSC: Invalid chanim_stats channel count, expect 1, output %d\n");
        }
      }
      else if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog())
      {
        CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:LPSC: Invalid version for LPSC chanim_stats response\n");
      }
      uint64_t v11 = 3758097084;
      goto LABEL_31;
    }
    return 3758097085;
  }
  else
  {
    if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
      CCLogStream::logAlertIf(*(CCLogStream **)(*(void *)(a1 + 48) + 72), 0x20uLL, "[dk] %s@%d:LPSC is not supported \n", "getSCChanQual", 808);
    }
    return 0;
  }
}

uint64_t AppleBCMWLANScanAdapter::initWithDriverAndCallBack(uint64_t a1, AppleBCMWLANCore *a2)
{
  BOOL v4 = OSObject::init((OSObject *)a1);
  uint64_t result = 0;
  if (a2)
  {
    if (v4)
    {
      uint64_t result = IOMallocZeroTyped();
      *(void *)(a1 + 48) = result;
      if (result)
      {
        *(void *)(result + 56) = a2;
        *(void *)(*(void *)(a1 + 48) + ++*(_DWORD *)(*(void *)(this + 64) + 72) = (*(uint64_t (**)(AppleBCMWLANCore *))(*(void *)a2 + 1848))(a2);
        uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 72);
        if (v6)
        {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
          *(void *)(*(void *)(a1 + 48) + 64) = AppleBCMWLANCore::getCommander(a2);
          uint64_t v7 = *(void *)(a1 + 48);
          uint64_t v8 = *(void *)(v7 + 64);
          if (v8)
          {
            (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
            *(_DWORD *)(*(void *)(a1 + 48) + 48) = 0;
            *(void *)(*(void *)(a1 + 48) + 80) = AppleBCMWLANCore::getFaultReporter(*(AppleBCMWLANCore **)(*(void *)(a1 + 48) + 56));
            (*(void (**)(void))(**(void **)(*(void *)(a1 + 48) + 80) + 8))(*(void *)(*(void *)(a1 + 48) + 80));
            getClassNameHelper((OSObject *)a1);
            CCFaultReporter::registerCallbacks();
            return 1;
          }
          if (*(void *)(v7 + 72))
          {
            if (CCLogStream::shouldLog()) {
              CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d: Unable to get Command Manager\n", "initWithDriverAndCallBack", 964);
            }
          }
        }
        else
        {
          ClassNameHelper = (const char *)getClassNameHelper((OSObject *)a1);
          IOLog("%s::%s(): Unable to get debug logger\n", ClassNameHelper, "initWithDriverAndCallBack");
        }
        AppleBCMWLANScanAdapter::freeResources((AppleBCMWLANScanAdapter *)a1);
        return 0;
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANScanAdapter::prepareFRCallback(uint64_t a1)
{
  **(unsigned char **)(a1 + 48) = 1;
  return 0;
}

uint64_t AppleBCMWLANScanAdapter::collectImmediateFaultDataCallback(AppleBCMWLANScanAdapter *this, CCFaultReport *a2)
{
  BOOL v4 = (char *)IOMallocZeroData();
  if (v4)
  {
    uint64_t v5 = v4;
    AppleBCMWLANScanAdapter::logState(this, v4);
    OSStringPtr v6 = OSString::withCString("ScanManagerState.txt");
    OSStringPtr v7 = OSString::withCString(v5);
    (*(void (**)(CCFaultReport *, OSStringPtr, OSStringPtr))(*(void *)a2 + 192))(a2, v6, v7);
    IOFreeData();
  }
  return 0;
}

uint64_t AppleBCMWLANScanAdapter::completeFaultReportCallback(uint64_t a1)
{
  **(unsigned char **)(a1 + 48) = 0;
  return 0;
}

uint64_t AppleBCMWLANScanAdapter::induceFaultCallback(AppleBCMWLANScanAdapter *this, int a2, const char *a3)
{
  if (a2 == -469793274 && *(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:Change of scan timeout via induce fault callback not supported\n", "induceFaultCallback", 2151);
  }
  return 0;
}

uint64_t non-virtual thunk to'AppleBCMWLANScanAdapter::initWithDriverAndCallBack(uint64_t a1, AppleBCMWLANCore *a2)
{
  return AppleBCMWLANScanAdapter::initWithDriverAndCallBack(a1 - 40, a2);
}

uint64_t *IO80211TLVIterator<IO80211TLVHeader<unsigned char,unsigned char,0ul,1ul,0ul>>::operator++(uint64_t a1)
{
  unsigned int v2 = (void *)(a1 + 8);
  unint64_t v3 = *(void *)(a1 + 16);
  if (v3 >= 2 && *v2)
  {
    if ((unint64_t)*(unsigned __int8 *)(*v2 + 1) + 2 > v3) {
      unint64_t v4 = 0;
    }
    else {
      unint64_t v4 = *(unsigned __int8 *)(*v2 + 1) + 2;
    }
  }
  else
  {
    unint64_t v4 = 0;
  }
  uint64_t result = IO80211BufferCursor::_crop((uint64_t *)(a1 + 8), v4, 0xFFFFFFFFFFFFFFFFLL, v7);
  if (v2 == v7)
  {
    unint64_t v6 = *(void *)(a1 + 16);
  }
  else
  {
    unint64_t v6 = v7[1];
    *(void *)(a1 + 8) = v7[0];
    *(void *)(a1 + 16) = v6;
  }
  if (v6 < 2 || !*v2 || (unint64_t)*(unsigned __int8 *)(*v2 + 1) + 2 > v6)
  {
    void *v2 = 0;
    v2[1] = 0;
  }
  return result;
}

uint64_t AppleBCMWLANScanAdapter::fillScanParams4(AppleBCMWLANScanAdapter *a1, char *a2, uint64_t a3)
{
  bzero(a2, 0x4D4uLL);
  AppleBCMWLANCore::setTxBlankingHappened(*(void *)(*((void *)a1 + 6) + 56), 0);
  *(_DWORD *)a2 = 4980740;
  unsigned int v6 = *(_DWORD *)(a3 + 28);
  if (v6 && !*(_DWORD *)(a3 + 4888))
  {
    if (*(_DWORD *)(a3 + 5452))
    {
      a2[47] |= 1u;
      *((_DWORD *)a2 + IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = 4;
      *((_DWORD *)a2 + 2) = *(_DWORD *)(a3 + 5452);
      uint64_t v12 = *(CCLogStream **)(*((void *)a1 + 6) + 72);
      if (v12
        && CCLogStream::shouldLog(v12, 0x40uLL)
        && *(void *)(*((void *)a1 + 6) + 72)
        && CCLogStream::shouldLog())
      {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: This is a directed scan for short SSID: %u\n");
      }
    }
    else
    {
      if (v6 >= 0x20) {
        size_t v42 = 32;
      }
      else {
        size_t v42 = v6;
      }
      *((_DWORD *)a2 + IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = v42;
      memcpy(a2 + 8, (const void *)(a3 + 32), v42);
      int v43 = *(CCLogStream **)(*((void *)a1 + 6) + 72);
      if (v43
        && CCLogStream::shouldLog(v43, 0x40uLL)
        && *(void *)(*((void *)a1 + 6) + 72)
        && CCLogStream::shouldLog())
      {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: This is a directed scan for SSID: %s\n");
      }
    }
  }
  unsigned int v7 = *((_DWORD *)a2 + 12) & 0xFFFF8FFF;
  *((void *)a2 + 6) = v7;
  uint64_t v8 = a2 + 40;
  if (*(_DWORD *)(a3 + 20) | *(unsigned __int16 *)(a3 + 24))
  {
    int v9 = *(_DWORD *)(a3 + 20);
    *((_WORD *)a2 + 22) = *(_WORD *)(a3 + 24);
    _DWORD *v8 = v9;
  }
  else
  {
    *((_WORD *)a2 + 22) = -1;
    _DWORD *v8 = -1;
  }
  int v10 = *(_DWORD *)(a3 + 16);
  if (v10 == 1) {
    char v11 = 1;
  }
  else {
    char v11 = 2 * (v10 != 2);
  }
  a2[46] = v11;
  switch(*(_DWORD *)(a3 + 64))
  {
    case 1:
      if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Active scan\n", "fillScanParams4", 1302);
      }
      unsigned int v7 = 0;
      goto LABEL_32;
    case 2:
      if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Passive scan\n", "fillScanParams4", 1305);
      }
      unsigned int v7 = 1;
      goto LABEL_32;
    case 3:
      if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: High accuracy scan\n", "fillScanParams4", 1309);
      }
      unsigned int v7 = *((_DWORD *)a2 + 12) | 0x2000;
      goto LABEL_32;
    case 4:
      if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Low span scan\n", "fillScanParams4", 1313);
      }
      unsigned int v7 = *((_DWORD *)a2 + 12) | 0x4000;
LABEL_32:
      *((_DWORD *)a2 + 12) = v7;
      break;
    default:
      break;
  }
  __int16 v13 = *(_WORD *)(a3 + 68);
  if ((v13 & 2) != 0)
  {
    v7 |= 2u;
    *((_DWORD *)a2 + 12) = v7;
    __int16 v13 = *(_WORD *)(a3 + 68);
  }
  if (v13)
  {
    *((_DWORD *)a2 + 12) = v7 | 0x1000;
    if ((*(_WORD *)(a3 + 68) & 0x10) != 0)
    {
      a2[47] |= 0x40u;
      if (*(void *)(*((void *)a1 + 6) + 72))
      {
        if (CCLogStream::shouldLog()) {
          CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Restrict scan to low power only\n", "fillScanParams4", 1328);
        }
      }
    }
    int v14 = AppleBCMWLANScanAdapter::setLpScanRetryCfg(a1, *(_DWORD *)(a3 + 12) != 0);
    if (v14)
    {
      int v15 = v14;
      if (*(void *)(*((void *)a1 + 6) + 72))
      {
        if (CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d: Error %d in setting LP scan retry config\n", "fillScanParams4", 1332, v15);
        }
      }
    }
  }
  __int16 v16 = *(_WORD *)(a3 + 68);
  if ((v16 & 8) != 0)
  {
    *((_DWORD *)a2 + 12) |= 4u;
    __int16 v16 = *(_WORD *)(a3 + 68);
    if ((v16 & 4) == 0)
    {
LABEL_46:
      if ((v16 & 0x40) == 0) {
        goto LABEL_47;
      }
      goto LABEL_71;
    }
  }
  else if ((v16 & 4) == 0)
  {
    goto LABEL_46;
  }
  if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Offchannel scan results requested\n", "fillScanParams4", 1343);
  }
  *((_DWORD *)a2 + 12) |= 8u;
  __int16 v16 = *(_WORD *)(a3 + 68);
  if ((v16 & 0x40) == 0)
  {
LABEL_47:
    if ((v16 & 0x20) != 0) {
      goto LABEL_48;
    }
    goto LABEL_75;
  }
LABEL_71:
  if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: FILS Discovery frames will be included in scan results\n", "fillScanParams4", 1349);
  }
  *((_DWORD *)a2 + 12) |= 0x200u;
  __int16 v16 = *(_WORD *)(a3 + 68);
  if ((v16 & 0x20) != 0)
  {
LABEL_48:
    if ((v16 & 0x100) == 0) {
      goto LABEL_49;
    }
    goto LABEL_79;
  }
LABEL_75:
  if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: 6GHz followup probe requests NOT allowed\n", "fillScanParams4", 1355);
  }
  *((_DWORD *)a2 + 12) |= 0x100u;
  __int16 v16 = *(_WORD *)(a3 + 68);
  if ((v16 & 0x100) == 0)
  {
LABEL_49:
    if ((v16 & 0x80) == 0) {
      goto LABEL_50;
    }
    goto LABEL_83;
  }
LABEL_79:
  if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Originating RNR scan results will be included\n", "fillScanParams4", 1360);
  }
  *((_DWORD *)a2 + 12) |= 0x800u;
  __int16 v16 = *(_WORD *)(a3 + 68);
  if ((v16 & 0x80) == 0)
  {
LABEL_50:
    if ((v16 & 0x200) == 0) {
      goto LABEL_52;
    }
    goto LABEL_51;
  }
LABEL_83:
  if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Originating RNR scan results will be included\n", "fillScanParams4", 1365);
  }
  a2[47] |= 4u;
  if ((*(_WORD *)(a3 + 68) & 0x200) != 0) {
LABEL_51:
  }
    a2[47] |= 8u;
LABEL_52:
  *((_DWORD *)a2 + 14) = -1;
  *(void *)(a2 + 60) = *(void *)(a3 + 72);
  int v17 = *(_DWORD *)(a3 + 80);
  if (!v17) {
    int v17 = -1;
  }
  *((_DWORD *)a2 + 17) = v17;
  int v18 = *(_DWORD *)(a3 + 84);
  if (v18)
  {
    unint64_t v19 = 0;
    int v20 = 0;
    unsigned __int16 v53 = 0;
    *((_DWORD *)a2 + 18) = v18;
    float v21 = (int *)(a3 + 96);
    do
    {
      int v22 = *(v21 - 1);
      LODWORD(__src[0]) = 0;
      DWORD1(__src[0]) = v22;
      int v23 = *v21;
      if ((*v21 & 0xC06) == 0) {
        int v23 = *v21 | 2;
      }
      DWORD2(__src[0]) = v23;
      if (AppleBCMWLANCore::getChanSpec(*(void **)(*((void *)a1 + 6) + 56), (uint64_t)__src, &v53)) {
        BOOL v24 = 1;
      }
      else {
        BOOL v24 = v53 == 0;
      }
      if (!v24) {
        *(_WORD *)&a2[2 * v20++ + 76] = v53;
      }
      v21 += 3;
      ++v19;
    }
    while (v19 < *(unsigned int *)(a3 + 84));
    *((_DWORD *)a2 + 18) = v20;
    if (!v20) {
      return 3766617101;
    }
  }
  else if (AppleBCMWLANCore::getSupportedBands(*(AppleBCMWLANCore **)(*((void *)a1 + 6) + 56)) == 1)
  {
    *((_DWORD *)a2 + 18) = 13;
    *(_OWORD *)(a2 + 76) = kDefaultScanList;
    *(_OWORD *)(a2 + 86) = *(long long *)((char *)&kDefaultScanList + 10);
  }
  unsigned int v26 = *(_DWORD *)(a3 + 4888);
  if (v26)
  {
    int v52 = a1;
    uint64_t v27 = 0;
    char v28 = 0;
    char v29 = 0;
    uint64_t v55 = 0;
    int v30 = *((_DWORD *)a2 + 18);
    LODWORD(v3IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = 2 * v30 + 76;
    memset(__src, 0, sizeof(__src));
    uint64_t v31 = (v30 & 1) != 0 ? (v31 & 0xFFFFFFFC) + 4 : v31;
    uint64_t v51 = v31;
    uint64_t v32 = v26 >= 0xA ? 10 : v26;
    int v33 = (_DWORD *)(a3 + 4900);
    do
    {
      unsigned int v34 = *(v33 - 1);
      if (v34 >= 0x20) {
        size_t v35 = 32;
      }
      else {
        size_t v35 = v34;
      }
      *(_DWORD *)((char *)__src + v27) = v35;
      v29 |= v35 == 0;
      v28 |= v35 != 0;
      memcpy((char *)__src + v27 + 4, v33, v35);
      v27 += 36;
      v33 += 14;
    }
    while (4 * (v32 + 8 * v32) != v27);
    *((_DWORD *)a2 + 18) = (unsigned __int16)v30 | ((unsigned __int16)v32 << 16);
    memcpy(&a2[v51], __src, (36 * v32));
    int v36 = *(CCLogStream **)(*((void *)a1 + 6) + 72);
    if (v36)
    {
      if (CCLogStream::shouldLog(v36, 0x40uLL))
      {
        int v37 = (char *)IOMallocZeroData();
        int v38 = v37;
        if (v37)
        {
          strcpy(v37, " Performing ");
          if (v29)
          {
            int v39 = v37 + 12;
            int v40 = (const char *)&unk_10029A2CA;
            if (v28) {
              int v40 = "and ";
            }
            LODWORD(v37) = snprintf(v39, 0x3F4uLL, "Broadcast Scan %s", v40);
            if (v37 > 0x3FF)
            {
              unsigned int v44 = 1036;
              if ((v28 & 1) == 0)
              {
LABEL_135:
                if (v38)
                {
                  if (*(void *)(*((void *)v52 + 6) + 72))
                  {
                    if (CCLogStream::shouldLog()) {
                      CCLogStream::logIf();
                    }
                  }
                  *int v38 = 0;
                  IOFreeData();
                }
                return 0;
              }
LABEL_123:
              unsigned int v45 = 0;
              if (!v38
                || v44 > 0x3FE
                || (v46 = 1024, unsigned int v45 = snprintf(&v38[v44], 1024 - v44, "Directed Scan for "), v45 <= 0x3FF))
              {
                int v46 = v45;
              }
              unsigned int v47 = v46 + v44;
              int v48 = (char *)__src + 4;
              do
              {
                if (*((_DWORD *)v48 - 1))
                {
                  unsigned int v49 = 0;
                  if (!v38
                    || v47 > 0x3FE
                    || (v50 = 1024, unsigned int v49 = snprintf(&v38[v47], 1024 - v47, "%s ", v48), v49 <= 0x3FF))
                  {
                    int v50 = v49;
                  }
                  v47 += v50;
                }
                v48 += 36;
                --v32;
              }
              while (v32);
              goto LABEL_135;
            }
            int v41 = 12;
LABEL_119:
            unsigned int v44 = v41 + v37;
            if ((v28 & 1) == 0) {
              goto LABEL_135;
            }
            goto LABEL_123;
          }
          unsigned int v44 = 12;
        }
        else
        {
          int v41 = 0;
          unsigned int v44 = 0;
          if (v29) {
            goto LABEL_119;
          }
        }
        if ((v28 & 1) == 0) {
          goto LABEL_135;
        }
        goto LABEL_123;
      }
    }
  }
  return 0;
}

uint64_t AppleBCMWLANScanAdapter::resetSCChanimStats(AppleBCMWLANScanAdapter *this)
{
  int v10 = -1;
  v9[0] = &v10;
  v9[1] = 0x400040004;
  unsigned int v2 = *(AppleBCMWLANCore **)(*((void *)this + 6) + 56);
  if (!v2
    || !AppleBCMWLANCore::checkForScanCoreSupport(v2)
    || (AppleBCMWLANCore::checkForLPSCDisable(*(AppleBCMWLANCore **)(*((void *)this + 6) + 56)) & 1) != 0)
  {
LABEL_4:
    if (v10) {
      return 3758097084;
    }
    else {
      return 0;
    }
  }
  uint64_t v5 = AppleBCMWLANCommander::runIOVarGet(*(AppleBCMWLANCommander **)(*((void *)this + 6) + 64), (uint64_t)"sc:reset_chanim_stats", (uint64_t)&kNoTxPayload, (uint64_t)v9, 0);
  if (!v5)
  {
    if (v10 && *(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:LPSC: reset_chanim_stats status invalid, status %d\n", "resetSCChanimStats", 2100, v10);
    }
    goto LABEL_4;
  }
  uint64_t v3 = v5;
  if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog())
  {
    uint64_t v6 = *((void *)this + 6);
    unsigned int v7 = *(CCLogStream **)(v6 + 72);
    uint64_t v8 = (const char *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 56) + 112))(*(void *)(v6 + 56), v3);
    CCLogStream::logAlert(v7, "[dk] %s@%d:LPSC: reset_chanim_stats failed, error %s\n", "resetSCChanimStats", 2096, v8);
  }
  return v3;
}

uint64_t AppleBCMWLANScanAdapter::fillScanParams3(AppleBCMWLANScanAdapter *a1, char *a2, uint64_t a3)
{
  bzero(a2, 0x4D0uLL);
  AppleBCMWLANCore::setTxBlankingHappened(*(void *)(*((void *)a1 + 6) + 56), 0);
  *(_DWORD *)a2 = 4718595;
  unsigned int v6 = *(_DWORD *)(a3 + 28);
  if (v6 && !*(_DWORD *)(a3 + 4888))
  {
    if (*(_DWORD *)(a3 + 5452))
    {
      a2[47] |= 1u;
      *((_DWORD *)a2 + IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = 4;
      *((_DWORD *)a2 + 2) = *(_DWORD *)(a3 + 5452);
      uint64_t v12 = *(CCLogStream **)(*((void *)a1 + 6) + 72);
      if (v12
        && CCLogStream::shouldLog(v12, 0x40uLL)
        && *(void *)(*((void *)a1 + 6) + 72)
        && CCLogStream::shouldLog())
      {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: This is a directed scan for short SSID: %u\n");
      }
    }
    else
    {
      if (v6 >= 0x20) {
        size_t v42 = 32;
      }
      else {
        size_t v42 = v6;
      }
      *((_DWORD *)a2 + IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = v42;
      memcpy(a2 + 8, (const void *)(a3 + 32), v42);
      int v43 = *(CCLogStream **)(*((void *)a1 + 6) + 72);
      if (v43
        && CCLogStream::shouldLog(v43, 0x40uLL)
        && *(void *)(*((void *)a1 + 6) + 72)
        && CCLogStream::shouldLog())
      {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: This is a directed scan for SSID: %s\n");
      }
    }
  }
  int v7 = *((_DWORD *)a2 + 12) & 0xFFFF8FFF;
  *((_DWORD *)a2 + 12) = v7;
  uint64_t v8 = a2 + 40;
  if (*(_DWORD *)(a3 + 20) | *(unsigned __int16 *)(a3 + 24))
  {
    int v9 = *(_DWORD *)(a3 + 20);
    *((_WORD *)a2 + 22) = *(_WORD *)(a3 + 24);
    _DWORD *v8 = v9;
  }
  else
  {
    *((_WORD *)a2 + 22) = -1;
    _DWORD *v8 = -1;
  }
  int v10 = *(_DWORD *)(a3 + 16);
  if (v10 == 1) {
    char v11 = 1;
  }
  else {
    char v11 = 2 * (v10 != 2);
  }
  a2[46] = v11;
  switch(*(_DWORD *)(a3 + 64))
  {
    case 1:
      if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Active scan\n", "fillScanParams3", 1517);
      }
      int v7 = 0;
      goto LABEL_32;
    case 2:
      if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Passive scan\n", "fillScanParams3", 1520);
      }
      int v7 = 1;
      goto LABEL_32;
    case 3:
      if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: High accuracy scan\n", "fillScanParams3", 1524);
      }
      int v7 = *((_DWORD *)a2 + 12) | 0x2000;
      goto LABEL_32;
    case 4:
      if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Low span scan\n", "fillScanParams3", 1528);
      }
      int v7 = *((_DWORD *)a2 + 12) | 0x4000;
LABEL_32:
      *((_DWORD *)a2 + 12) = v7;
      break;
    default:
      break;
  }
  __int16 v13 = *(_WORD *)(a3 + 68);
  if ((v13 & 2) != 0)
  {
    v7 |= 2u;
    *((_DWORD *)a2 + 12) = v7;
    __int16 v13 = *(_WORD *)(a3 + 68);
  }
  if (v13)
  {
    *((_DWORD *)a2 + 12) = v7 | 0x1000;
    if ((*(_WORD *)(a3 + 68) & 0x10) != 0)
    {
      a2[47] |= 0x40u;
      if (*(void *)(*((void *)a1 + 6) + 72))
      {
        if (CCLogStream::shouldLog()) {
          CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Restrict scan to low power only\n", "fillScanParams3", 1543);
        }
      }
    }
    int v14 = AppleBCMWLANScanAdapter::setLpScanRetryCfg(a1, *(_DWORD *)(a3 + 12) != 0);
    if (v14)
    {
      int v15 = v14;
      if (*(void *)(*((void *)a1 + 6) + 72))
      {
        if (CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d: Error %d in setting LP scan retry config\n", "fillScanParams3", 1547, v15);
        }
      }
    }
  }
  __int16 v16 = *(_WORD *)(a3 + 68);
  if ((v16 & 8) != 0)
  {
    *((_DWORD *)a2 + 12) |= 4u;
    __int16 v16 = *(_WORD *)(a3 + 68);
    if ((v16 & 4) == 0)
    {
LABEL_46:
      if ((v16 & 0x40) == 0) {
        goto LABEL_47;
      }
      goto LABEL_71;
    }
  }
  else if ((v16 & 4) == 0)
  {
    goto LABEL_46;
  }
  if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Offchannel scan results requested\n", "fillScanParams3", 1558);
  }
  *((_DWORD *)a2 + 12) |= 8u;
  __int16 v16 = *(_WORD *)(a3 + 68);
  if ((v16 & 0x40) == 0)
  {
LABEL_47:
    if ((v16 & 0x20) != 0) {
      goto LABEL_48;
    }
    goto LABEL_75;
  }
LABEL_71:
  if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: FILS Discovery frames will be included in scan results\n", "fillScanParams3", 1564);
  }
  *((_DWORD *)a2 + 12) |= 0x200u;
  __int16 v16 = *(_WORD *)(a3 + 68);
  if ((v16 & 0x20) != 0)
  {
LABEL_48:
    if ((v16 & 0x100) == 0) {
      goto LABEL_49;
    }
    goto LABEL_79;
  }
LABEL_75:
  if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: 6GHz followup probe requests NOT allowed\n", "fillScanParams3", 1570);
  }
  *((_DWORD *)a2 + 12) |= 0x100u;
  __int16 v16 = *(_WORD *)(a3 + 68);
  if ((v16 & 0x100) == 0)
  {
LABEL_49:
    if ((v16 & 0x80) == 0) {
      goto LABEL_50;
    }
    goto LABEL_83;
  }
LABEL_79:
  if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Originating RNR scan results will be included\n", "fillScanParams3", 1575);
  }
  *((_DWORD *)a2 + 12) |= 0x800u;
  __int16 v16 = *(_WORD *)(a3 + 68);
  if ((v16 & 0x80) == 0)
  {
LABEL_50:
    if ((v16 & 0x200) == 0) {
      goto LABEL_52;
    }
    goto LABEL_51;
  }
LABEL_83:
  if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Originating RNR scan results will be included\n", "fillScanParams3", 1580);
  }
  a2[47] |= 4u;
  if ((*(_WORD *)(a3 + 68) & 0x200) != 0) {
LABEL_51:
  }
    a2[47] |= 8u;
LABEL_52:
  *((_DWORD *)a2 + 1AppleBCMWLANScanAdapter::free(this - 3) = -1;
  *((void *)a2 + 7) = *(void *)(a3 + 72);
  int v17 = *(_DWORD *)(a3 + 80);
  if (!v17) {
    int v17 = -1;
  }
  *((_DWORD *)a2 + 16) = v17;
  int v18 = *(_DWORD *)(a3 + 84);
  if (v18)
  {
    unint64_t v19 = 0;
    int v20 = 0;
    unsigned __int16 v53 = 0;
    *((_DWORD *)a2 + 17) = v18;
    float v21 = (int *)(a3 + 96);
    do
    {
      int v22 = *(v21 - 1);
      LODWORD(__src[0]) = 0;
      DWORD1(__src[0]) = v22;
      int v23 = *v21;
      if ((*v21 & 0xC06) == 0) {
        int v23 = *v21 | 2;
      }
      DWORD2(__src[0]) = v23;
      if (AppleBCMWLANCore::getChanSpec(*(void **)(*((void *)a1 + 6) + 56), (uint64_t)__src, &v53)) {
        BOOL v24 = 1;
      }
      else {
        BOOL v24 = v53 == 0;
      }
      if (!v24) {
        *(_WORD *)&a2[2 * v20++ + 72] = v53;
      }
      v21 += 3;
      ++v19;
    }
    while (v19 < *(unsigned int *)(a3 + 84));
    *((_DWORD *)a2 + 17) = v20;
    if (!v20) {
      return 3766617101;
    }
  }
  else if (AppleBCMWLANCore::getSupportedBands(*(AppleBCMWLANCore **)(*((void *)a1 + 6) + 56)) == 1)
  {
    *((_DWORD *)a2 + 17) = 13;
    *(_OWORD *)(a2 + ++*(_DWORD *)(*(void *)(this + 64) + 72) = kDefaultScanList;
    *(_OWORD *)(a2 + 82) = *(long long *)((char *)&kDefaultScanList + 10);
  }
  unsigned int v26 = *(_DWORD *)(a3 + 4888);
  if (v26)
  {
    int v52 = a1;
    uint64_t v27 = 0;
    char v28 = 0;
    char v29 = 0;
    uint64_t v55 = 0;
    int v30 = *((_DWORD *)a2 + 17);
    LODWORD(v3IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = 2 * v30 + 72;
    memset(__src, 0, sizeof(__src));
    uint64_t v31 = (v30 & 1) != 0 ? (v31 & 0xFFFFFFFC) + 4 : v31;
    uint64_t v51 = v31;
    uint64_t v32 = v26 >= 0xA ? 10 : v26;
    int v33 = (_DWORD *)(a3 + 4900);
    do
    {
      unsigned int v34 = *(v33 - 1);
      if (v34 >= 0x20) {
        size_t v35 = 32;
      }
      else {
        size_t v35 = v34;
      }
      *(_DWORD *)((char *)__src + v27) = v35;
      v29 |= v35 == 0;
      v28 |= v35 != 0;
      memcpy((char *)__src + v27 + 4, v33, v35);
      v27 += 36;
      v33 += 14;
    }
    while (4 * (v32 + 8 * v32) != v27);
    *((_DWORD *)a2 + 17) = (unsigned __int16)v30 | ((unsigned __int16)v32 << 16);
    memcpy(&a2[v51], __src, (36 * v32));
    int v36 = *(CCLogStream **)(*((void *)a1 + 6) + 72);
    if (v36)
    {
      if (CCLogStream::shouldLog(v36, 0x40uLL))
      {
        int v37 = (char *)IOMallocZeroData();
        int v38 = v37;
        if (v37)
        {
          strcpy(v37, " Performing ");
          if (v29)
          {
            int v39 = v37 + 12;
            int v40 = (const char *)&unk_10029A2CA;
            if (v28) {
              int v40 = "and ";
            }
            LODWORD(v37) = snprintf(v39, 0x3F4uLL, "Broadcast Scan %s", v40);
            if (v37 > 0x3FF)
            {
              unsigned int v44 = 1036;
              if ((v28 & 1) == 0)
              {
LABEL_135:
                if (v38)
                {
                  if (*(void *)(*((void *)v52 + 6) + 72))
                  {
                    if (CCLogStream::shouldLog()) {
                      CCLogStream::logIf();
                    }
                  }
                  *int v38 = 0;
                  IOFreeData();
                }
                return 0;
              }
LABEL_123:
              unsigned int v45 = 0;
              if (!v38
                || v44 > 0x3FE
                || (v46 = 1024, unsigned int v45 = snprintf(&v38[v44], 1024 - v44, "Directed Scan for "), v45 <= 0x3FF))
              {
                int v46 = v45;
              }
              unsigned int v47 = v46 + v44;
              int v48 = (char *)__src + 4;
              do
              {
                if (*((_DWORD *)v48 - 1))
                {
                  unsigned int v49 = 0;
                  if (!v38
                    || v47 > 0x3FE
                    || (v50 = 1024, unsigned int v49 = snprintf(&v38[v47], 1024 - v47, "%s ", v48), v49 <= 0x3FF))
                  {
                    int v50 = v49;
                  }
                  v47 += v50;
                }
                v48 += 36;
                --v32;
              }
              while (v32);
              goto LABEL_135;
            }
            int v41 = 12;
LABEL_119:
            unsigned int v44 = v41 + v37;
            if ((v28 & 1) == 0) {
              goto LABEL_135;
            }
            goto LABEL_123;
          }
          unsigned int v44 = 12;
        }
        else
        {
          int v41 = 0;
          unsigned int v44 = 0;
          if (v29) {
            goto LABEL_119;
          }
        }
        if ((v28 & 1) == 0) {
          goto LABEL_135;
        }
        goto LABEL_123;
      }
    }
  }
  return 0;
}

uint64_t AppleBCMWLANScanAdapter::fillScanParams2(AppleBCMWLANScanAdapter *a1, char *a2, uint64_t a3)
{
  bzero(a2, 0x4D0uLL);
  AppleBCMWLANCore::setTxBlankingHappened(*(void *)(*((void *)a1 + 6) + 56), 0);
  *(_DWORD *)a2 = 4980738;
  unsigned int v6 = *(_DWORD *)(a3 + 28);
  if (v6 && !*(_DWORD *)(a3 + 4888))
  {
    size_t v12 = v6 >= 0x20 ? 32 : v6;
    *((_DWORD *)a2 + IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = v12;
    memcpy(a2 + 8, (const void *)(a3 + 32), v12);
    __int16 v13 = *(CCLogStream **)(*((void *)a1 + 6) + 72);
    if (v13)
    {
      if (CCLogStream::shouldLog(v13, 0x40uLL)
        && *(void *)(*((void *)a1 + 6) + 72)
        && CCLogStream::shouldLog())
      {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: This is a directed scan for SSID: %s\n", "fillScanParams2", 1706, a2 + 8);
      }
    }
  }
  int v7 = *((_DWORD *)a2 + 12) & 0xFFFF8FFF;
  *((_DWORD *)a2 + 12) = v7;
  uint64_t v8 = a2 + 40;
  if (*(_DWORD *)(a3 + 20) | *(unsigned __int16 *)(a3 + 24))
  {
    int v9 = *(_DWORD *)(a3 + 20);
    *((_WORD *)a2 + 22) = *(_WORD *)(a3 + 24);
    _DWORD *v8 = v9;
  }
  else
  {
    *((_WORD *)a2 + 22) = -1;
    _DWORD *v8 = -1;
  }
  int v10 = *(_DWORD *)(a3 + 16);
  if (v10 == 1) {
    char v11 = 1;
  }
  else {
    char v11 = 2 * (v10 != 2);
  }
  a2[46] = v11;
  switch(*(_DWORD *)(a3 + 64))
  {
    case 1:
      if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Active scan\n", "fillScanParams2", 1721);
      }
      int v7 = 0;
      goto LABEL_34;
    case 2:
      if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Passive scan\n", "fillScanParams2", 1724);
      }
      int v7 = 1;
      goto LABEL_34;
    case 3:
      if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: High accuracy scan\n", "fillScanParams2", 1728);
      }
      int v7 = *((_DWORD *)a2 + 12) | 0x2000;
      goto LABEL_34;
    case 4:
      if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Low span scan\n", "fillScanParams2", 1732);
      }
      int v7 = *((_DWORD *)a2 + 12) | 0x4000;
LABEL_34:
      *((_DWORD *)a2 + 12) = v7;
      break;
    default:
      break;
  }
  __int16 v14 = *(_WORD *)(a3 + 68);
  if ((v14 & 2) != 0)
  {
    v7 |= 2u;
    *((_DWORD *)a2 + 12) = v7;
    __int16 v14 = *(_WORD *)(a3 + 68);
  }
  if (v14)
  {
    *((_DWORD *)a2 + 12) = v7 | 0x1000;
    int v15 = AppleBCMWLANScanAdapter::setLpScanRetryCfg(a1, *(_DWORD *)(a3 + 12) != 0);
    if (v15)
    {
      int v16 = v15;
      if (*(void *)(*((void *)a1 + 6) + 72))
      {
        if (CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*((void *)a1 + 6) + 72), "[dk] %s@%d: Error %d in setting LP scan retry config\n", "fillScanParams2", 1746, v16);
        }
      }
    }
  }
  __int16 v17 = *(_WORD *)(a3 + 68);
  if ((v17 & 8) != 0)
  {
    *((_DWORD *)a2 + 12) |= 4u;
    __int16 v17 = *(_WORD *)(a3 + 68);
  }
  if ((v17 & 4) != 0)
  {
    if (*(void *)(*((void *)a1 + 6) + 72) && CCLogStream::shouldLog()) {
      CCLogStream::logNoticeIf(*(CCLogStream **)(*((void *)a1 + 6) + 72), 0x40uLL, "[dk] %s@%d: Offchannel scan results requested\n", "fillScanParams2", 1757);
    }
    *((_DWORD *)a2 + 12) |= 8u;
  }
  *((_DWORD *)a2 + 1AppleBCMWLANScanAdapter::free(this - 3) = -1;
  *((void *)a2 + 7) = *(void *)(a3 + 72);
  int v18 = *(_DWORD *)(a3 + 80);
  if (!v18) {
    int v18 = -1;
  }
  *((_DWORD *)a2 + 16) = v18;
  int v19 = *(_DWORD *)(a3 + 84);
  if (v19)
  {
    unint64_t v20 = 0;
    int v21 = 0;
    *((_DWORD *)a2 + 17) = v19;
    int v22 = (_DWORD *)(a3 + 96);
    int v23 = (_DWORD *)(a3 + 96);
    do
    {
      LODWORD(__src[0]) = 2;
      int v25 = *v23;
      v23 += 3;
      __int16 v24 = v25;
      if ((v25 & 4) != 0)
      {
        LODWORD(__src[0]) = 3;
      }
      else if ((v24 & 0x400) != 0)
      {
        LODWORD(__src[0]) = 4;
      }
      int ChanSpec = AppleBCMWLANCore::getChanSpec(*(void *)(*((void *)a1 + 6) + 56), *((unsigned __int8 *)v22 - 4), (int *)__src);
      if (ChanSpec) {
        *(_WORD *)&a2[2 * v21++ + 72] = ChanSpec;
      }
      ++v20;
      int v22 = v23;
    }
    while (v20 < *(unsigned int *)(a3 + 84));
    *((_DWORD *)a2 + 17) = v21;
    if (!v21) {
      return 3766617101;
    }
  }
  else if (AppleBCMWLANCore::getSupportedBands(*(AppleBCMWLANCore **)(*((void *)a1 + 6) + 56)) == 1)
  {
    *((_DWORD *)a2 + 17) = 13;
    *(_OWORD *)(a2 + ++*(_DWORD *)(*(void *)(this + 64) + 72) = kDefaultScanList;
    *(_OWORD *)(a2 + 82) = *(long long *)((char *)&kDefaultScanList + 10);
  }
  unsigned int v28 = *(_DWORD *)(a3 + 4888);
  if (v28)
  {
    int v52 = a1;
    uint64_t v29 = 0;
    char v30 = 0;
    char v31 = 0;
    uint64_t v54 = 0;
    int v32 = *((_DWORD *)a2 + 17);
    LODWORD(v3AppleBCMWLANScanAdapter::free(this - 3) = 2 * v32 + 72;
    memset(__src, 0, sizeof(__src));
    uint64_t v33 = (v32 & 1) != 0 ? (v33 & 0xFFFFFFFC) + 4 : v33;
    uint64_t v51 = v33;
    uint64_t v34 = v28 >= 0xA ? 10 : v28;
    size_t v35 = (_DWORD *)(a3 + 4900);
    do
    {
      unsigned int v36 = *(v35 - 1);
      if (v36 >= 0x20) {
        size_t v37 = 32;
      }
      else {
        size_t v37 = v36;
      }
      *(_DWORD *)((char *)__src + v29) = v37;
      v31 |= v37 == 0;
      v30 |= v37 != 0;
      memcpy((char *)__src + v29 + 4, v35, v37);
      v29 += 36;
      v35 += 14;
    }
    while (4 * (v34 + 8 * v34) != v29);
    *((_DWORD *)a2 + 17) = (unsigned __int16)v32 | ((unsigned __int16)v34 << 16);
    memcpy(&a2[v51], __src, (36 * v34));
    int v38 = *(CCLogStream **)(*((void *)a1 + 6) + 72);
    if (v38)
    {
      if (CCLogStream::shouldLog(v38, 0x40uLL))
      {
        int v39 = (char *)IOMallocZeroData();
        int v40 = v39;
        if (v39)
        {
          strcpy(v39, " Performing ");
          if (v31)
          {
            int v41 = v39 + 12;
            size_t v42 = (const char *)&unk_10029A2CA;
            if (v30) {
              size_t v42 = "and ";
            }
            LODWORD(v39) = snprintf(v41, 0x3F4uLL, "Broadcast Scan %s", v42);
            if (v39 > 0x3FF)
            {
              unsigned int v44 = 1036;
              if ((v30 & 1) == 0)
              {
LABEL_101:
                if (v40)
                {
                  if (*(void *)(*((void *)v52 + 6) + 72))
                  {
                    if (CCLogStream::shouldLog()) {
                      CCLogStream::logIf();
                    }
                  }
                  char *v40 = 0;
                  IOFreeData();
                }
                return 0;
              }
LABEL_89:
              unsigned int v45 = 0;
              if (!v40
                || v44 > 0x3FE
                || (v46 = 1024, unsigned int v45 = snprintf(&v40[v44], 1024 - v44, "Directed Scan for "), v45 <= 0x3FF))
              {
                int v46 = v45;
              }
              unsigned int v47 = v46 + v44;
              int v48 = (char *)__src + 4;
              do
              {
                if (*((_DWORD *)v48 - 1))
                {
                  unsigned int v49 = 0;
                  if (!v40
                    || v47 > 0x3FE
                    || (v50 = 1024, unsigned int v49 = snprintf(&v40[v47], 1024 - v47, "%s ", v48), v49 <= 0x3FF))
                  {
                    int v50 = v49;
                  }
                  v47 += v50;
                }
                v48 += 36;
                --v34;
              }
              while (v34);
              goto LABEL_101;
            }
            int v43 = 12;
LABEL_85:
            unsigned int v44 = v43 + v39;
            if ((v30 & 1) == 0) {
              goto LABEL_101;
            }
            goto LABEL_89;
          }
          unsigned int v44 = 12;
        }
        else
        {
          int v43 = 0;
          unsigned int v44 = 0;
          if (v31) {
            goto LABEL_85;
          }
        }
        if ((v30 & 1) == 0) {
          goto LABEL_101;
        }
        goto LABEL_89;
      }
    }
  }
  return 0;
}

uint64_t AppleBCMWLANScanAdapter::fillScanParams(uint64_t a1, char *a2, uint64_t a3)
{
  bzero(a2, 0x4C8uLL);
  unsigned int v6 = *(_DWORD *)(a3 + 28);
  if (v6 && !*(_DWORD *)(a3 + 4888))
  {
    size_t v35 = v6 >= 0x20 ? 32 : v6;
    *(_DWORD *)a2 = v35;
    memcpy(a2 + 4, (const void *)(a3 + 32), v35);
    unsigned int v36 = *(CCLogStream **)(*(void *)(a1 + 48) + 72);
    if (v36)
    {
      if (CCLogStream::shouldLog(v36, 0x40uLL)
        && *(void *)(*(void *)(a1 + 48) + 72)
        && CCLogStream::shouldLog())
      {
        CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 72), 0x40uLL, "[dk] %s@%d: This is a directed scan for SSID: %s\n", "fillScanParams", 1875, a2 + 4);
      }
    }
  }
  int v7 = a2 + 36;
  if (*(_DWORD *)(a3 + 20) | *(unsigned __int16 *)(a3 + 24))
  {
    int v8 = *(_DWORD *)(a3 + 20);
    *((_WORD *)a2 + 20) = *(_WORD *)(a3 + 24);
    *int v7 = v8;
  }
  else
  {
    *((_WORD *)a2 + 20) = -1;
    *int v7 = -1;
  }
  int v9 = *(_DWORD *)(a3 + 16);
  if (v9 == 1) {
    char v10 = 1;
  }
  else {
    char v10 = 2 * (v9 != 2);
  }
  a2[42] = v10;
  int v11 = *(_DWORD *)(a3 + 64);
  if (v11 == 2)
  {
    if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
      CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 72), 0x40uLL, "[dk] %s@%d: Passive scan\n", "fillScanParams", 1890);
    }
    char v12 = 1;
  }
  else
  {
    if (v11 != 1) {
      goto LABEL_20;
    }
    if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
      CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 72), 0x40uLL, "[dk] %s@%d: Active scan\n", "fillScanParams", 1887);
    }
    char v12 = 0;
  }
  a2[43] = v12;
LABEL_20:
  __int16 v13 = *(_WORD *)(a3 + 68);
  if ((v13 & 8) != 0)
  {
    a2[43] |= 4u;
    __int16 v13 = *(_WORD *)(a3 + 68);
    if ((v13 & 2) == 0)
    {
LABEL_22:
      if ((v13 & 4) == 0) {
        goto LABEL_30;
      }
      goto LABEL_26;
    }
  }
  else if ((v13 & 2) == 0)
  {
    goto LABEL_22;
  }
  a2[43] |= 2u;
  if ((*(_WORD *)(a3 + 68) & 4) == 0) {
    goto LABEL_30;
  }
LABEL_26:
  if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logNoticeIf(*(CCLogStream **)(*(void *)(a1 + 48) + 72), 0x40uLL, "[dk] %s@%d: Offchannel scan results requested\n", "fillScanParams", 1906);
  }
  a2[43] |= 8u;
LABEL_30:
  *((_DWORD *)a2 + 1IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = -1;
  *((void *)a2 + 6) = *(void *)(a3 + 72);
  int v14 = *(_DWORD *)(a3 + 80);
  if (!v14) {
    int v14 = -1;
  }
  *((_DWORD *)a2 + 14) = v14;
  uint64_t v15 = *(unsigned int *)(a3 + 84);
  if (v15)
  {
    *((_DWORD *)a2 + 15) = v15;
    int v16 = (int *)(a3 + 92);
    __int16 v17 = a2 + 64;
    do
    {
      int v18 = *v16;
      v16 += 3;
      *v17++ = v18;
      --v15;
    }
    while (v15);
  }
  else if (AppleBCMWLANCore::getSupportedBands(*(AppleBCMWLANCore **)(*(void *)(a1 + 48) + 56)) == 1)
  {
    *((_DWORD *)a2 + 15) = 13;
    *((_OWORD *)a2 + 4) = kDefaultScanList;
    *(_OWORD *)(a2 + 74) = *(long long *)((char *)&kDefaultScanList + 10);
  }
  unsigned int v19 = *(_DWORD *)(a3 + 4888);
  if (v19)
  {
    uint64_t v46 = a1;
    uint64_t v20 = 0;
    char v21 = 0;
    char v22 = 0;
    uint64_t v48 = 0;
    int v23 = *((_DWORD *)a2 + 15);
    LODWORD(v24) = 2 * v23 + 64;
    memset(__src, 0, sizeof(__src));
    uint64_t v24 = (v23 & 1) != 0 ? (v24 & 0xFFFFFFFC) + 4 : v24;
    uint64_t v45 = v24;
    uint64_t v25 = v19 >= 0xA ? 10 : v19;
    unsigned int v26 = (_DWORD *)(a3 + 4900);
    do
    {
      unsigned int v27 = *(v26 - 1);
      if (v27 >= 0x20) {
        size_t v28 = 32;
      }
      else {
        size_t v28 = v27;
      }
      *(_DWORD *)((char *)__src + v20) = v28;
      v22 |= v28 != 0;
      v21 |= v28 == 0;
      memcpy((char *)__src + v20 + 4, v26, v28);
      v20 += 36;
      v26 += 14;
    }
    while (4 * (v25 + 8 * v25) != v20);
    *((_DWORD *)a2 + 15) = (unsigned __int16)v23 | ((unsigned __int16)v25 << 16);
    memcpy(&a2[v45], __src, (36 * v25));
    uint64_t v29 = *(CCLogStream **)(*(void *)(a1 + 48) + 72);
    if (v29)
    {
      if (CCLogStream::shouldLog(v29, 0x40uLL))
      {
        char v30 = (char *)IOMallocZeroData();
        char v31 = v30;
        if (v30)
        {
          strcpy(v30, " Performing ");
          if (v21)
          {
            int v32 = v30 + 12;
            uint64_t v33 = (const char *)&unk_10029A2CA;
            if (v22) {
              uint64_t v33 = "and ";
            }
            LODWORD(v30) = snprintf(v32, 0x3F4uLL, "Broadcast Scan %s", v33);
            if (v30 > 0x3FF)
            {
              unsigned int v37 = 1036;
              if ((v22 & 1) == 0)
              {
LABEL_83:
                if (v31)
                {
                  if (*(void *)(*(void *)(v46 + 48) + 72) && CCLogStream::shouldLog()) {
                    CCLogStream::logIf();
                  }
                  *char v31 = 0;
                  IOFreeData();
                }
                return 0;
              }
LABEL_71:
              unsigned int v38 = 0;
              if (!v31
                || v37 > 0x3FE
                || (v39 = 1024, unsigned int v38 = snprintf(&v31[v37], 1024 - v37, "Directed Scan for "), v38 <= 0x3FF))
              {
                int v39 = v38;
              }
              unsigned int v40 = v39 + v37;
              int v41 = (char *)__src + 4;
              do
              {
                if (*((_DWORD *)v41 - 1))
                {
                  unsigned int v42 = 0;
                  if (!v31
                    || v40 > 0x3FE
                    || (int v43 = 1024, v42 = snprintf(&v31[v40], 1024 - v40, "%s ", v41), v42 <= 0x3FF))
                  {
                    int v43 = v42;
                  }
                  v40 += v43;
                }
                v41 += 36;
                --v25;
              }
              while (v25);
              goto LABEL_83;
            }
            int v34 = 12;
LABEL_67:
            unsigned int v37 = v34 + v30;
            if ((v22 & 1) == 0) {
              goto LABEL_83;
            }
            goto LABEL_71;
          }
          unsigned int v37 = 12;
        }
        else
        {
          int v34 = 0;
          unsigned int v37 = 0;
          if (v21) {
            goto LABEL_67;
          }
        }
        if ((v22 & 1) == 0) {
          goto LABEL_83;
        }
        goto LABEL_71;
      }
    }
  }
  return 0;
}

uint64_t AppleBCMWLANScanAdapter::setLpScanRetryCfg(AppleBCMWLANScanAdapter *this, int a2)
{
  if (AppleBCMWLANCore::getFirmwareInterfaceVersion(*(AppleBCMWLANCore **)(*((void *)this + 6) + 56)) > 0xE)
  {
    if (AppleBCMWLANCore::getFirmwareInterfaceVersion(*(AppleBCMWLANCore **)(*((void *)this + 6) + 56)) > 0x10)
    {
      AppleBCMWLANCore::getFirmwareInterfaceVersion(*(AppleBCMWLANCore **)(*((void *)this + 6) + 56));
      return AppleBCMWLANScanAdapter::setLpScanRetryCfgV4(this, a2);
    }
    else
    {
      return AppleBCMWLANScanAdapter::setLpScanRetryCfgV3(this, a2);
    }
  }
  else
  {
    return AppleBCMWLANScanAdapter::setLpScanRetryCfgV2(this, a2);
  }
}

uint64_t AppleBCMWLANScanAdapter::setLpScanRetryCfgV2(AppleBCMWLANScanAdapter *this, int a2)
{
  int v9 = 786433;
  unint64_t v10 = 0xAAAAAAAA00000002;
  if (a2)
  {
    BYTE4(v10) = 25;
    BYTE6(v10) = 50;
    LODWORD(v10) = 7;
    char v4 = 1;
  }
  else
  {
    char v4 = 0;
  }
  BYTE5(v10) = v4;
  uint64_t v5 = *(AppleBCMWLANCommander **)(*((void *)this + 6) + 64);
  v8[0] = &v9;
  v8[1] = 12;
  uint64_t v6 = AppleBCMWLANCommander::runIOVarSet(v5, (uint64_t)"scan_retry_cfg", (uint64_t)v8, 0, 0);
  if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logInfo(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:Setting LP scan retry config to %d [0: None, 1: High Accuracy]\n", "setLpScanRetryCfgV2", 2020, a2);
  }
  return v6;
}

uint64_t AppleBCMWLANScanAdapter::setLpScanRetryCfgV3(AppleBCMWLANScanAdapter *this, int a2)
{
  uint64_t v9 = 0x200100003;
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  if (a2)
  {
    LOBYTE(v10) = 25;
    BYTE2(v10) = 50;
    HIDWORD(v9) = 7;
    char v4 = 1;
  }
  else
  {
    char v4 = 0;
  }
  BYTE1(v10) = v4;
  uint64_t v5 = *(AppleBCMWLANCommander **)(*((void *)this + 6) + 64);
  v8[0] = &v9;
  v8[1] = 16;
  uint64_t v6 = AppleBCMWLANCommander::runIOVarSet(v5, (uint64_t)"scan_retry_cfg", (uint64_t)v8, 0, 0);
  if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logInfo(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:Setting LP scan retry config v3 to %d [0: None, 1: High Accuracy]\n", "setLpScanRetryCfgV3", 2041, a2);
  }
  return v6;
}

uint64_t AppleBCMWLANScanAdapter::setLpScanRetryCfgV4(AppleBCMWLANScanAdapter *this, int a2)
{
  uint64_t v9 = 0x200100004;
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  if (a2)
  {
    LOBYTE(v10) = 25;
    HIWORD(v10) = 12825;
    BYTE2(v10) = 50;
    HIDWORD(v9) = 199;
    char v4 = 1;
  }
  else
  {
    char v4 = 0;
  }
  BYTE1(v10) = v4;
  uint64_t v5 = *(AppleBCMWLANCommander **)(*((void *)this + 6) + 64);
  v8[0] = &v9;
  v8[1] = 16;
  uint64_t v6 = AppleBCMWLANCommander::runIOVarSet(v5, (uint64_t)"scan_retry_cfg", (uint64_t)v8, 0, 0);
  if (*(void *)(*((void *)this + 6) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logInfo(*(CCLogStream **)(*((void *)this + 6) + 72), "[dk] %s@%d:Setting LP scan retry config v4 to %d [0: None, 1: High Accuracy]\n", "setLpScanRetryCfgV4", 2066, a2);
  }
  return v6;
}

uint64_t AppleBCMWLANScanAdapter::logState(AppleBCMWLANScanAdapter *this, char *a2)
{
  return IO80211Print();
}

uint64_t AppleBCMWLANScanAdapter::triggerCC(uint64_t a1, long long *a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  long long v3 = *a2;
  *(_OWORD *)(v2 + 24) = a2[1];
  *(_OWORD *)(v2 + 8) = v3;
  return CCFaultReporter::reportFault(*(CCFaultReporter **)(*(void *)(a1 + 48) + 80), *((_DWORD *)a2 + 4), "/Library/Caches/com.apple.xbs/Sources/AppleBCMWLANV3_driverkit/AppleBCMWLANScanAdapter.cpp", 0x84Au, "triggerCC", 0, *((_DWORD *)a2 + 1), 0);
}

uint64_t AppleBCMWLANScanAdapter::handleScanEvent(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  int v4 = *(_DWORD *)(a2 + 12);
  switch(v4)
  {
    case 3:
      return AppleBCMWLANScanAdapter::handleEventScanAdd(a1, a2);
    case 2:
      return AppleBCMWLANScanAdapter::handleEventScanComplete(a1, a2);
    case 1:
      return AppleBCMWLANScanAdapter::handleEventScanStart(a1, a2, a3, a4);
  }
  return a1;
}

uint64_t AppleBCMWLANScanAdapter::handleEventScanStart(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  memset(v46, 0, sizeof(v46));
  int64_t v7 = a2 + 48;
  unsigned int v6 = *(_DWORD *)(a2 + 48);
  if (v6 <= 1)
  {
    unint64_t v8 = *(unsigned int *)(a2 + 20);
    if (v8 <= 0xB)
    {
      if (*(void *)(*(void *)(a1 + 48) + 72))
      {
        uint64_t v9 = 1;
        if (!CCLogStream::shouldLog()) {
          return v9;
        }
        unint64_t v10 = *(CCLogStream **)(*(void *)(a1 + 48) + 72);
LABEL_11:
        CCLogStream::logAlert(v10, "[dk] %s@%d:ERROR: Invalid event data length %d \n");
        return v9;
      }
      return 1;
    }
    int64_t v12 = v8 - 1 + v7;
    if (!__CFADD__(v8 - 1, v7)
      && a2 + 59 >= v7
      && (unint64_t)v7 < 0xFFFFFFFFFFFFFFF5
      && a2 + 59 <= v12
      && v12 >= v7)
    {
      uint64_t v13 = *(unsigned __int16 *)(a2 + 56);
      uint64_t v14 = *(unsigned __int16 *)(a2 + 58);
      if (2 * (v14 + v13) + 12 > v8)
      {
        if (*(void *)(*(void *)(a1 + 48) + 72))
        {
          uint64_t v9 = 1;
          if (CCLogStream::shouldLog()) {
            CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:ERROR: Invalid event data length %d, num channels slice0 %d, slice1 %d \n");
          }
          return v9;
        }
        return 1;
      }
      v46[0] = *(_WORD *)(a2 + 58);
      v46[1] = v13;
      if ((v14 + v13) <= 0x190)
      {
        unsigned int v34 = v13 + v14;
        if (v34 >= 0x190) {
          uint64_t v35 = 400;
        }
        else {
          uint64_t v35 = v34;
        }
        if (v35)
        {
          unsigned int v36 = (unsigned __int16 *)(a2 + 60);
          unsigned int v37 = &v46[2];
          do
          {
            ChanSpecHandler = (int **)AppleBCMWLANCore::getChanSpecHandler(*(AppleBCMWLANCore **)(*(void *)(a1 + 48)
                                                                                                + 56));
            unsigned int v39 = *v36++;
            AppleBCMWLANChanSpec::getAppleChannelSpec(ChanSpecHandler, v39);
            *v37++ = ChanSpecGetPrimaryChannel();
            --v35;
          }
          while (v35);
        }
      }
      else if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog())
      {
        CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:ERROR: Channels in scan list %d > max %d\n", "handleEventScanStart", 2208, *(unsigned __int16 *)(a2 + 58) + *(unsigned __int16 *)(a2 + 56), 400);
      }
      if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:Infra Scan started, flags %x, 2.4G channels %d, 5G channels %d\n", "handleEventScanStart", 2215, *(_DWORD *)(a2 + 52), v14, v13);
      }
      goto LABEL_88;
    }
    if (!*(void *)(*(void *)(a1 + 48) + 72)) {
      return 1;
    }
    uint64_t v9 = 1;
    if (!CCLogStream::shouldLog()) {
      return v9;
    }
    uint64_t v15 = *(CCLogStream **)(*(void *)(a1 + 48) + 72);
LABEL_70:
    CCLogStream::logAlert(v15, "[dk] %s@%d: ERROR: Boundary condition detected\n");
    return v9;
  }
  if (v6 != 2)
  {
    if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:Unsupproted scan start version %d\n", "handleEventScanStart", 2269, v6);
    }
    return 0;
  }
  uint64_t v11 = *(unsigned int *)(a2 + 20);
  if (v11 <= 0xB)
  {
    if (*(void *)(*(void *)(a1 + 48) + 72))
    {
      uint64_t v9 = 1;
      if (!CCLogStream::shouldLog()) {
        return v9;
      }
      unint64_t v10 = *(CCLogStream **)(*(void *)(a1 + 48) + 72);
      goto LABEL_11;
    }
    return 1;
  }
  uint64_t v16 = v11 - 1;
  int64_t v17 = v16 + v7;
  if (__CFADD__(v16, v7) || a2 + 63 < v7 || (unint64_t)v7 >= 0xFFFFFFFFFFFFFFF1 || a2 + 63 > v17 || v17 < v7)
  {
    if (!*(void *)(*(void *)(a1 + 48) + 72)) {
      return 1;
    }
    uint64_t v9 = 1;
    if (!CCLogStream::shouldLog()) {
      return v9;
    }
    uint64_t v15 = *(CCLogStream **)(*(void *)(a1 + 48) + 72);
    goto LABEL_70;
  }
  unsigned int v18 = *(_DWORD *)(a2 + 56);
  if (!v18)
  {
    LOBYTE(v4AppleBCMWLANScanAdapter::free(this - 3) = 0;
    LOBYTE(v19) = 0;
LABEL_85:
    if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:Infra Scan started, flags %x, 2.4G channels %d, 5G channels %d\n", "handleEventScanStart", 2267, *(_DWORD *)(a2 + 52), v19, v43);
    }
LABEL_88:
    AppleBCMWLANCore::postMessageInfra(*(AppleBCMWLANCore **)(*(void *)(a1 + 48) + 56), 0x7Du, v46, 0x193uLL);
    return 0;
  }
  uint64_t v19 = 0;
  int v20 = 0;
  uint64_t v21 = 0;
  int v22 = 0;
  int v43 = 0;
  uint64_t v44 = a2 + 60;
  int64_t v41 = v17;
  while (1)
  {
    int v23 = (_WORD *)(v44 + v21);
    uint64_t v24 = v44 + v21 + 5;
    if (v24 < v7
      || (unint64_t)(v44 + v21) >= 0xFFFFFFFFFFFFFFFBLL
      || v24 > v17
      || v7 > (uint64_t)v23
      || v17 < (uint64_t)v23)
    {
      if (!*(void *)(*(void *)(a1 + 48) + 72)) {
        return 1;
      }
      uint64_t v9 = 1;
      if (CCLogStream::shouldLog())
      {
        uint64_t v15 = *(CCLogStream **)(*(void *)(a1 + 48) + 72);
        goto LABEL_70;
      }
      return v9;
    }
    uint64_t v29 = (unsigned __int16)v23[1];
    if (v23[1])
    {
      if (v22 + (v29 >> 1) < 0x191)
      {
        if (*v23 == 1)
        {
          uint64_t v19 = v19 + (v29 >> 1);
          v46[0] = v19;
        }
        else
        {
          if (*v23) {
            goto LABEL_65;
          }
          v43 += v29 >> 1;
          v46[1] = v43;
        }
        if (v29 >= 2)
        {
          uint64_t v42 = v19;
          char v30 = v23 + 2;
          if (v29 >> 1 <= 1) {
            uint64_t v31 = 1;
          }
          else {
            uint64_t v31 = v29 >> 1;
          }
          do
          {
            int v32 = (int **)AppleBCMWLANCore::getChanSpecHandler(*(AppleBCMWLANCore **)(*(void *)(a1 + 48) + 56));
            unsigned int v33 = *v30++;
            AppleBCMWLANChanSpec::getAppleChannelSpec(v32, v33);
            v46[v22++ + 2] = ChanSpecGetPrimaryChannel();
            --v31;
          }
          while (v31);
          int64_t v17 = v41;
          uint64_t v19 = v42;
        }
      }
      else if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog())
      {
        CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:ERROR: Channels in scan list %d > max %d\n", "handleEventScanStart", 2240, v22 + (v29 >> 1), 400);
      }
    }
    unint64_t v45 = 0;
    if (AppleBCMWLANUtil::safe_align_up((AppleBCMWLANUtil *)(v21 + v29 + 4), 4, &v45, a4)) {
      break;
    }
    if (v45 >= 0xFFFF)
    {
      if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:UINT16_MAX overflow nextAlignedIndex\n");
      }
      goto LABEL_101;
    }
    uint64_t v21 = (unsigned __int16)v45;
    unsigned int v18 = *(_DWORD *)(a2 + 56);
LABEL_65:
    if (v18 <= (unsigned __int16)++v20) {
      goto LABEL_85;
    }
  }
  if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:safe_align_up failed\n");
  }
LABEL_101:
  if (!*(void *)(*(void *)(a1 + 48) + 72)) {
    return 0;
  }
  uint64_t v9 = 0;
  if (CCLogStream::shouldLog())
  {
    CCLogStream::logEmergency(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:Failed to parse Event Log Record xtlv \n", "handleEventScanStart", 2277);
    return 0;
  }
  return v9;
}

uint64_t AppleBCMWLANScanAdapter::handleEventScanComplete(uint64_t a1, uint64_t a2)
{
  __int16 v7 = 0;
  uint64_t v3 = *(void *)(a1 + 48);
  if (*(void *)(v3 + 72))
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v3 = *(void *)(a1 + 48);
    if (shouldLog)
    {
      CCLogStream::logAlert(*(CCLogStream **)(v3 + 72), "[dk] %s@%d:Infra Scan complete status %d\n", "handleEventScanComplete", 2290, *(_DWORD *)(a2 + 8));
      uint64_t v3 = *(void *)(a1 + 48);
    }
  }
  AppleBCMWLANCore::postMessageInfra(*(AppleBCMWLANCore **)(v3 + 56), 0x7Eu, &v7, 2uLL);
  return 0;
}

uint64_t AppleBCMWLANScanAdapter::handleEventScanAdd(uint64_t a1, uint64_t a2)
{
  char v45 = 0;
  int CurrentSlice = AppleBCMWLANCore::getCurrentSlice(*(AppleBCMWLANCore **)(*(void *)(a1 + 48) + 56));
  int64_t v7 = a2 + 48;
  unsigned int v6 = *(_DWORD *)(a2 + 48);
  if (v6 <= 1)
  {
    unint64_t v8 = *(unsigned int *)(a2 + 20);
    if (v8 <= 0xB)
    {
      if (!*(void *)(*(void *)(a1 + 48) + 72) || !CCLogStream::shouldLog()) {
        return 22;
      }
      uint64_t v9 = *(CCLogStream **)(*(void *)(a1 + 48) + 72);
LABEL_11:
      CCLogStream::logAlert(v9, "[dk] %s@%d:ERROR: Invalid event data length %d \n");
      return 22;
    }
    int64_t v11 = v8 - 1 + v7;
    if (!__CFADD__(v8 - 1, v7))
    {
      int64_t v17 = a2 + 59;
      if (v17 >= v7 && (unint64_t)v7 < 0xFFFFFFFFFFFFFFF5 && v17 <= v11 && v11 >= v7)
      {
        uint64_t v18 = *(unsigned __int16 *)(a2 + 56);
        uint64_t v19 = *(unsigned __int16 *)(a2 + 58);
        if (2 * (v19 + v18) + 12 > v8)
        {
          if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
            CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:ERROR: Invalid event data length %d, num channels slice0 %d, slice1 %d \n");
          }
          return 22;
        }
        if ((v19 + v18) >= 0x191)
        {
          if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
            CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:ERROR: Channels in scan list %d > max %d\n");
          }
          return 22;
        }
        LOBYTE(v2IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = 0;
        if (CurrentSlice) {
          unsigned int v35 = *(unsigned __int16 *)(a2 + 56);
        }
        else {
          unsigned int v35 = 0;
        }
        if (!CurrentSlice) {
          LOWORD(v19) = 0;
        }
        unsigned __int16 v36 = v19 + v18;
        if (v35 < v36)
        {
          int v21 = 0;
          unsigned int v37 = (unsigned __int16 *)(a2 + 2 * v35 + 60);
          unint64_t v38 = v36 - (unint64_t)v35;
          do
          {
            unsigned int v39 = *v37++;
            v21 += AppleBCMWLANCore::is6GChanSpec(*(AppleBCMWLANCore **)(*(void *)(a1 + 48) + 56), v39);
            --v38;
          }
          while (v38);
        }
        char v45 = v21;
        if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:6G follow up scan started total %d channels, after %d 2.4G channels or %d 5G channels\n", "handleEventScanAdd", 2348, v21, *(unsigned __int16 *)(a2 + 58), *(unsigned __int16 *)(a2 + 56));
        }
        goto LABEL_88;
      }
    }
    if (*(void *)(*(void *)(a1 + 48) + 72))
    {
      uint64_t v12 = 1;
      if (!CCLogStream::shouldLog()) {
        return v12;
      }
      uint64_t v13 = *(CCLogStream **)(*(void *)(a1 + 48) + 72);
      int v14 = 2324;
LABEL_27:
      CCLogStream::logAlert(v13, "[dk] %s@%d: ERROR: Boundary condition detected\n", "handleEventScanAdd", v14);
      return v12;
    }
    return 1;
  }
  if (v6 != 2)
  {
    if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:Unsupproted scan add version %d\n");
    }
    return 22;
  }
  uint64_t v10 = *(unsigned int *)(a2 + 20);
  if (v10 <= 0xB)
  {
    if (!*(void *)(*(void *)(a1 + 48) + 72) || !CCLogStream::shouldLog()) {
      return 22;
    }
    uint64_t v9 = *(CCLogStream **)(*(void *)(a1 + 48) + 72);
    goto LABEL_11;
  }
  uint64_t v16 = v10 - 1;
  int64_t v43 = v16 + v7;
  if (__CFADD__(v16, v7)
    || (int64_t v20 = a2 + 63, v20 < v7 || (unint64_t)v7 >= 0xFFFFFFFFFFFFFFF1 || v20 > v43 || v43 < v7))
  {
    if (*(void *)(*(void *)(a1 + 48) + 72))
    {
      uint64_t v12 = 1;
      if (!CCLogStream::shouldLog()) {
        return v12;
      }
      uint64_t v13 = *(CCLogStream **)(*(void *)(a1 + 48) + 72);
      int v14 = 2362;
      goto LABEL_27;
    }
    return 1;
  }
  if (!*(_DWORD *)(a2 + 56))
  {
    LOBYTE(v2IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = 0;
LABEL_88:
    uint64_t v40 = *(void *)(a1 + 48);
    if (*(void *)(v40 + 72))
    {
      int shouldLog = CCLogStream::shouldLog();
      uint64_t v40 = *(void *)(a1 + 48);
      if (shouldLog)
      {
        CCLogStream::logAlert(*(CCLogStream **)(v40 + 72), "[dk] %s@%d:6G follow up scan started total %d channels after 2.4G or 5G scans \n", "handleEventScanAdd", 2402, v21);
        uint64_t v40 = *(void *)(a1 + 48);
      }
    }
    AppleBCMWLANCore::postMessageInfra(*(AppleBCMWLANCore **)(v40 + 56), 0xC6u, &v45, 1uLL);
    return 0;
  }
  LOBYTE(v2IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = 0;
  int v22 = 0;
  unint64_t v23 = 0;
  int v24 = 0;
  uint64_t v42 = a2 + 60;
  while (1)
  {
    int64_t v25 = v42 + v23;
    uint64_t v26 = v42 + v23 + 5;
    if (v26 < v7 || v42 + v23 >= 0xFFFFFFFFFFFFFFFBLL || v26 > v43 || v7 > v25 || v43 < v25)
    {
      if (!*(void *)(*(void *)(a1 + 48) + 72)) {
        return 1;
      }
      uint64_t v12 = 1;
      if (CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d: ERROR: Boundary condition detected\n", "handleEventScanAdd", 2368);
      }
      return v12;
    }
    uint64_t v31 = *(unsigned __int16 *)(v25 + 2);
    if (*(_WORD *)(v25 + 2))
    {
      if (v24 + (v31 >> 1) < 0x191)
      {
        if (v31 >= 2)
        {
          int v32 = (unsigned __int16 *)(v25 + 4);
          if (v31 >> 1 <= 1) {
            LOWORD(v3AppleBCMWLANScanAdapter::free(this - 3) = 1;
          }
          else {
            unsigned int v33 = v31 >> 1;
          }
          unsigned __int16 v34 = v33 + v24;
          do
          {
            if (AppleBCMWLANCore::is6GChanSpec(*(AppleBCMWLANCore **)(*(void *)(a1 + 48) + 56), *v32))
            {
              LOBYTE(v2IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = v21 + 1;
              char v45 = v21;
            }
            ++v32;
            ++v24;
          }
          while (v34 != (unsigned __int16)v24);
        }
      }
      else if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog())
      {
        CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:ERROR: Channels in scan list %d > max %d\n", "handleEventScanAdd", 2373, v24 + (v31 >> 1), 400);
      }
    }
    unint64_t v44 = 0;
    if (AppleBCMWLANUtil::safe_align_up((AppleBCMWLANUtil *)(v23 + v31 + 4), 4, &v44, v5)) {
      break;
    }
    unint64_t v23 = v44;
    if (v44 >= 0xFFFF)
    {
      if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:UINT16_MAX overflow nextAlignedIndex\n");
      }
      goto LABEL_103;
    }
    if (*(_DWORD *)(a2 + 56) <= (unsigned __int16)++v22) {
      goto LABEL_88;
    }
  }
  if (*(void *)(*(void *)(a1 + 48) + 72) && CCLogStream::shouldLog()) {
    CCLogStream::logAlert(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:safe_align_up failed\n");
  }
LABEL_103:
  if (!*(void *)(*(void *)(a1 + 48) + 72)) {
    return 0;
  }
  uint64_t v12 = 0;
  if (CCLogStream::shouldLog())
  {
    CCLogStream::logEmergency(*(CCLogStream **)(*(void *)(a1 + 48) + 72), "[dk] %s@%d:Failed to parse Event Log Record xtlv \n", "handleEventScanAdd", 2408);
    return 0;
  }
  return v12;
}

void _GLOBAL__sub_I_AppleBCMWLANScanAdapter_cpp()
{
  kNullRange = 0;
}

AppleBCMWLANHistogram *AppleBCMWLANHistogram::withBinCountAndQuantizer(AppleBCMWLANHistogram *this, unsigned int (*a2)(unsigned int), int a3)
{
  int v4 = (int)a2;
  unint64_t v8 = (AppleBCMWLANHistogram *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANHistogramMetaClass, (OSObject **)&v8)) {
    return 0;
  }
  unsigned int v6 = v8;
  if (v8
    && (AppleBCMWLANHistogram::initWithBins((OSObject *)v8, v4, a3, (BOOL (__cdecl *)(const OSMetaClassBase *__hidden, const OSMetaClassBase *))this) & 1) == 0)
  {
    (*(void (**)(AppleBCMWLANHistogram *))(*(void *)v6 + 16))(v6);
    return 0;
  }
  return v6;
}

uint64_t AppleBCMWLANHistogram::initWithBins(OSObject *this, int a2, int a3, BOOL (__cdecl *a4)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject))
{
  uint64_t result = OSObject::init(this);
  if (result)
  {
    uint64_t result = IOMallocZeroTyped();
    this[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)result;
    if (result)
    {
      *(_DWORD *)uint64_t result = a2;
      HIDWORD(this[1].getMetaClass) = a3;
      this[1].isEqualTo = a4;
      this[1].retain = (void (__cdecl *)(const OSObject *__hidden))IOMallocZeroData();
      uint64_t v9 = this[1].OSMetaClassBase::__vftable;
      retain = v9->retain;
      if (retain)
      {
        bzero(retain, 4 * LODWORD(v9->getMetaClass));
        uint64_t v9 = this[1].OSMetaClassBase::__vftable;
      }
      HIDWORD(v9->release) = 0;
      LODWORD(this[1].release) = -1;
      return this[1].retain != 0;
    }
  }
  return result;
}

uint64_t AppleBCMWLANHistogram::log2Quantize(AppleBCMWLANHistogram *this)
{
  return __clz(this | 1) ^ 0x1F;
}

void AppleBCMWLANHistogram::free(OSObject *this)
{
  uint64_t v2 = this[1].OSMetaClassBase::__vftable;
  if (v2)
  {
    if (!v2->retain || (IOFreeData(), v2->retain = 0, (uint64_t v2 = this[1].OSMetaClassBase::__vftable) != 0))
    {
      IOFree(v2, 0x20uLL);
      this[1].OSMetaClassBase::__vftable = 0;
    }
  }
  OSObject::free(this);
}

void non-virtual thunk to'AppleBCMWLANHistogram::free(AppleBCMWLANHistogram *this)
{
}

uint64_t AppleBCMWLANHistogram::dump(AppleBCMWLANHistogram *this, const char *a2, char *__str, int64_t __size, char a5)
{
  if (!__str) {
    return 0;
  }
  if (__size < 1) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = snprintf(__str, __size, "%s=[", a2);
  }
  unsigned int v10 = 0;
  int v11 = 0;
  int v12 = 0;
  uint64_t v13 = *((void *)this + 5);
  do
  {
    if (__size > (int)v9)
    {
      uint64_t v9 = (snprintf(&__str[(int)v9], __size - (int)v9, "%u,", *(_DWORD *)(*(void *)(v13 + 8) + 4 * v10))+ v9);
      uint64_t v13 = *((void *)this + 5);
    }
    int v14 = *(_DWORD *)(*(void *)(v13 + 8) + 4 * v10);
    v12 += v14;
    v11 += v14 * v10++;
  }
  while (v10 <= *(_DWORD *)v13);
  if (__size > (int)v9) {
    uint64_t v9 = (snprintf(&__str[(int)v9], __size - (int)v9, "]; sum=%u,cnt=%u; min=%u; max=%u",
  }
                          v11,
                          v12,
                          *(_DWORD *)(v13 + 16),
                          *(_DWORD *)(v13 + 20))
                      + v9);
  if (a5)
  {
    if (__size > (int)v9) {
      uint64_t v9 = (snprintf(&__str[(int)v9], __size - (int)v9, "\n\n") + v9);
    }
    unsigned int v15 = 0;
    unint64_t v27 = v12;
    uint64_t v16 = *((void *)this + 5);
    uint64_t v17 = v9;
    while (1)
    {
      uint64_t v18 = *(uint64_t (**)(uint64_t))(v16 + 24);
      uint64_t v19 = *(unsigned int *)(v16 + 16);
      if (v18)
      {
        unsigned int v20 = v18(v19);
        uint64_t v16 = *((void *)this + 5);
        if (v15 >= v20)
        {
          unsigned int v21 = (*(uint64_t (**)(void))(v16 + 24))(*(unsigned int *)(v16 + 20));
          uint64_t v16 = *((void *)this + 5);
          if (v15 <= v21) {
            goto LABEL_22;
          }
        }
      }
      else if (v15 >= v19 && v15 <= *(_DWORD *)(v16 + 20))
      {
LABEL_22:
        uint64_t v22 = *(unsigned int *)(*(void *)(v16 + 8) + 4 * v15);
        if (__size > (int)v17) {
          uint64_t v17 = (snprintf(&__str[(int)v17], __size - (int)v17, "%3u |", v15) + v17);
        }
        unsigned int v23 = 0;
        unint64_t v24 = 80 * v22 / v27;
        do
        {
          if (__size > (int)v17)
          {
            if (v23 <= v24) {
              uint64_t v25 = 37;
            }
            else {
              uint64_t v25 = 32;
            }
            uint64_t v17 = (snprintf(&__str[(int)v17], __size - (int)v17, "%c", v25) + v17);
          }
          ++v23;
        }
        while (v23 != 80);
        uint64_t v16 = *((void *)this + 5);
        if (__size > (int)v17)
        {
          uint64_t v17 = (snprintf(&__str[(int)v17], __size - (int)v17, "| %-6u\n", *(_DWORD *)(*(void *)(v16 + 8) + 4 * v15))+ v17);
          uint64_t v16 = *((void *)this + 5);
        }
      }
      if (++v15 > *(_DWORD *)v16)
      {
        if (__size <= (int)v17) {
          return v17;
        }
        else {
          return (snprintf(&__str[(int)v17], __size - (int)v17, "\n") + v17);
        }
      }
    }
  }
  return v9;
}

uint64_t AppleBCMWLANTxBuffer::free(AppleBCMWLANTxBuffer *this)
{
  int v1 = (void *)*((void *)this + 7);
  if (v1)
  {
    uint64_t v3 = (IO80211Buffer *)v1[4];
    if (v3)
    {
      IO80211Buffer::returnBuffer(v3);
      int v1 = (void *)*((void *)this + 7);
    }
    *int v1 = 0;
    memset_s(*((void **)this + 7), 0x30uLL, 0, 0x30uLL);
    int v4 = (void *)*((void *)this + 7);
    if (v4)
    {
      IOFree(v4, 0x30uLL);
      *((void *)this + 7) = 0;
    }
    return IOCommand::free(this);
  }
  else
  {
    return IOLog("Failed to allocate AppleBCMWLANTxBuffer_IVars\n");
  }
}

uint64_t non-virtual thunk to'AppleBCMWLANTxBuffer::free(AppleBCMWLANTxBuffer *this)
{
  return AppleBCMWLANTxBuffer::free((AppleBCMWLANTxBuffer *)((char *)this - 24));
}

uint64_t AppleBCMWLANTxBuffer::initWithParams(IOCommand *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t result = 0;
  if (a2 && a3)
  {
    uint64_t v8 = a2 + 48;
    uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)(a2 + 48) + 168))(a2 + 48);
    if ((*(uint64_t (**)(uint64_t))(*(void *)v8 + 144))(v8) + v9 < a3
      || (*(uint64_t (**)(uint64_t))(*(void *)v8 + 144))(v8) >= a3)
    {
      return 0;
    }
    uint64_t result = IOCommand::init(a1);
    if (result)
    {
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 168))(v8);
      if ((*(uint64_t (**)(uint64_t))(*(void *)v8 + 144))(v8) + v10 < a3) {
        return 0;
      }
      uint64_t v11 = IOMallocZeroTyped();
      *((void *)a1 + 7) = v11;
      if (!v11)
      {
        IOLog("Failed to allocate AppleBCMWLANTxBuffer_IVars\n");
        return 0;
      }
      *(void *)(v11 + 40) = a4;
      uint64_t v12 = *(void *)(*((void *)a1 + 7) + 40);
      if (!v12)
      {
        IOLog("invalid buffer pool\n");
        return 0;
      }
      *(void *)(*((void *)a1 + 7) + 32) = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 56))(v12);
      uint64_t v13 = *(IO80211Buffer **)(*((void *)a1 + 7) + 32);
      if (!v13)
      {
        IOLog("get buffer descriptor fail\n");
        return 0;
      }
      IO80211Buffer::setLength(v13, a3);
      **((void **)a1 + 7) = IO80211Buffer::getBytesNoCopy(*(IO80211Buffer **)(*((void *)a1 + 7) + 32));
      uint64_t v14 = *((void *)a1 + 7);
      if (!*(void *)(v14 + 32))
      {
        IOLog("get buffer fail\n");
        return 0;
      }
      bzero(*(void **)v14, a3);
      *(_DWORD *)(*((void *)a1 + 7) + 16) = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 144))(v8);
      *(_DWORD *)(*((void *)a1 + 7) + 20) = -536870911;
      return 1;
    }
  }
  return result;
}

uint64_t non-virtual thunk to'AppleBCMWLANTxBuffer::initWithParams(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  return AppleBCMWLANTxBuffer::initWithParams((IOCommand *)(a1 - 48), a2, a3, a4);
}

OSObject *AppleBCMWLANTxBuffer::withOptions(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANTxBufferMetaClass, &v8)) {
    return 0;
  }
  unsigned int v6 = v8;
  if (v8
    && (((uint64_t (*)(OSObject *, uint64_t, uint64_t, uint64_t))v8->OSMetaClassBase::__vftable[1].getMetaClass)(v8, a1, a2, a3) & 1) == 0)
  {
    ((void (*)(OSObject *))v6->release)(v6);
    return 0;
  }
  return v6;
}

uint64_t AppleBCMWLANTxBuffer::getPayload(AppleBCMWLANTxBuffer *this, uint64_t a2)
{
  return **((void **)this + 7) + *(unsigned int *)(*((void *)this + 7) + 16) + a2;
}

uint64_t AppleBCMWLANTxBuffer::getPayloadLength(AppleBCMWLANTxBuffer *this)
{
  return *(void *)(*((void *)this + 7) + 8);
}

uint64_t AppleBCMWLANTxBuffer::setPayloadLength(uint64_t this, uint64_t a2)
{
  *(void *)(*(void *)(this + 56) + 8) = a2;
  return this;
}

uint64_t AppleBCMWLANTxBuffer::getStatus(AppleBCMWLANTxBuffer *this)
{
  return *(unsigned int *)(*((void *)this + 7) + 20);
}

uint64_t AppleBCMWLANTxBuffer::setStatus(uint64_t this, int a2)
{
  *(_DWORD *)(*(void *)(this + 56) + 20) = a2;
  return this;
}

uint64_t AppleBCMWLANTxBuffer::setBusPreference(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(result + 56) + 24) = a2;
  return result;
}

void _GLOBAL__sub_I_AppleBCMWLANTxBuffer_cpp()
{
  kNullRange = 0;
}

OSObject *AppleBCMWLANChipBackplane::withConfigAndMap(AppleBCMWLANChipBackplane *this, AppleBCMWLANChipConfigSpace *a2, IOMemoryMap *a3, AppleBCMWLANChipManagerPCIe *a4, AppleBCMWLANPCIeMMIOHistory *a5)
{
  uint64_t v11 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANChipBackplaneMetaClass, &v11)) {
    return 0;
  }
  uint64_t v9 = v11;
  if (v11
    && (((uint64_t (*)(OSObject *, AppleBCMWLANChipBackplane *, AppleBCMWLANChipConfigSpace *, IOMemoryMap *, AppleBCMWLANChipManagerPCIe *))v11->OSMetaClassBase::__vftable[1].getMetaClass)(v11, this, a2, a3, a4) & 1) == 0)
  {
    ((void (*)(OSObject *))v9->release)(v9);
    return 0;
  }
  return v9;
}

uint64_t AppleBCMWLANChipBackplane::initWithConfigAndMap(OSObject *this, AppleBCMWLANChipConfigSpace *a2, IOMemoryMap *a3, AppleBCMWLANChipManagerPCIe *a4, AppleBCMWLANPCIeMMIOHistory *a5)
{
  uint64_t result = OSObject::init(this);
  if (result)
  {
    uint64_t result = IOMallocZeroTyped();
    *(void *)&this[1].__int32 refcount = result;
    if (result)
    {
      *(void *)(result + 3120) = a4;
      uint64_t v10 = *(void *)&this[1].refcount;
      if (*(void *)(v10 + 3120))
      {
        *(void *)(v10 + 1624) = a2;
        uint64_t result = *(void *)(*(void *)&this[1].refcount + 1624);
        if (!result) {
          return result;
        }
        (*(void (**)(uint64_t))(*(void *)result + 8))(result);
        if (a5)
        {
          *(void *)(*(void *)&this[1].refcount + 3112) = a5;
          (*(void (**)(void))(**(void **)(*(void *)&this[1].refcount + 3112) + 8))(*(void *)(*(void *)&this[1].refcount + 3112));
        }
        *(void *)(*(void *)&this[1].refcount + 1632) = 0;
        if (AppleBCMWLANChipManagerPCIe::getCoreCount(a4) <= 0xB)
        {
          uint64_t v11 = 0;
          uint64_t v12 = 1640;
          do
          {
            AppleBCMWLANChipManagerPCIe::copyCore((uint64_t)a4, *(void *)&this[1].refcount + v12, v11++);
            v12 += 32;
          }
          while (v11 != 11);
          if (AppleBCMWLANChipManagerPCIe::getWrapperCount(a4) <= 0x22)
          {
            uint64_t v13 = 0;
            uint64_t v14 = 2008;
            do
            {
              AppleBCMWLANChipManagerPCIe::copyWrapper((uint64_t)a4, *(void *)&this[1].refcount + v14, v13++);
              v14 += 32;
            }
            while (v13 != 34);
            *(_DWORD *)(*(void *)&this[1].refcount + 2000) = AppleBCMWLANChipManagerPCIe::getCoreRemappableWindowCount(a4);
            *(void *)(*(void *)&this[1].refcount + 1992) = IOMallocZeroTyped();
            AppleBCMWLANChipManagerPCIe::copyRemappableCoreWindows((uint64_t)a4, *(char **)(*(void *)&this[1].refcount + 1992), *(_DWORD *)(*(void *)&this[1].refcount + 2000));
            *(_DWORD *)(*(void *)&this[1].refcount + 3104) = AppleBCMWLANChipManagerPCIe::getWrapperRemappableWindowCount(a4);
            *(void *)(*(void *)&this[1].refcount + 3096) = IOMallocZeroTyped();
            AppleBCMWLANChipManagerPCIe::copyRemappableWrapperWindows((uint64_t)a4, *(char **)(*(void *)&this[1].refcount + 3096), *(_DWORD *)(*(void *)&this[1].refcount + 3104));
            *(void *)(*(void *)&this[1].refcount + 3128) = AppleBCMWLANChipManagerPCIe::getConfigSpaceSaveRange(*(AppleBCMWLANChipManagerPCIe **)(*(void *)&this[1].refcount + 3120));
            *(_DWORD *)(*(void *)&this[1].refcount + 3136) = AppleBCMWLANChipManagerPCIe::getConfigSpaceSaveCount(*(AppleBCMWLANChipManagerPCIe **)(*(void *)&this[1].refcount + 3120));
            *(void *)(*(void *)&this[1].refcount + 3152) = 0;
            uint64_t v15 = *(void *)&this[1].refcount;
            if (*(_DWORD *)(v15 + 3136))
            {
              unint64_t v16 = 0;
              uint64_t v17 = 4;
              do
              {
                *(void *)(v15 + 3152) += *(unsigned int *)(*(void *)(v15 + 3128) + v17);
                ++v16;
                uint64_t v15 = *(void *)&this[1].refcount;
                v17 += 8;
              }
              while (v16 < *(unsigned int *)(v15 + 3136));
            }
            *(void *)(*(void *)&this[1].refcount + 3144) = IOMallocZeroData();
            if (*(void *)(*(void *)&this[1].refcount + 3144))
            {
              read_random();
              *(_DWORD *)(*(void *)&this[1].refcount + 2004) %= *(_DWORD *)(*(void *)&this[1].refcount + 2000);
              read_random();
              *(_DWORD *)(*(void *)&this[1].refcount + 3108) %= *(_DWORD *)(*(void *)&this[1].refcount + 3104);
              *(_DWORD *)(*(void *)&this[1].refcount + 3160) = 0;
              return 1;
            }
            IOLog("AppleBCMWLANChipManagerPCIe::initWithConfigAndMap() Failed to allocate config space buffer\n");
          }
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t AppleBCMWLANChipBackplane::setAPBAccessibilityState(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(result + 48) + 3160) = a2;
  return result;
}

uint64_t non-virtual thunk to'AppleBCMWLANChipBackplane::initWithConfigAndMap(OSObject *this, AppleBCMWLANChipConfigSpace *a2, IOMemoryMap *a3, AppleBCMWLANChipManagerPCIe *a4, AppleBCMWLANPCIeMMIOHistory *a5)
{
  return AppleBCMWLANChipBackplane::initWithConfigAndMap(this - 1, a2, a3, a4, a5);
}

uint64_t AppleBCMWLANChipBackplane::setPCIeLinkState(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(result + 48) + 3164) = a2;
  return result;
}

uint64_t AppleBCMWLANChipBackplane::getAPBAccessibilityState(AppleBCMWLANChipBackplane *this)
{
  return *(unsigned int *)(*((void *)this + 6) + 3160);
}

uint64_t AppleBCMWLANChipBackplane::getPowerControlRegReadStatus(AppleBCMWLANChipBackplane *this)
{
  uint32_t v6 = 0;
  uint64_t v2 = *(AppleBCMWLANChipManagerPCIe **)(*((void *)this + 6) + 3120);
  if (!v2) {
    return 1;
  }
  if (!AppleBCMWLANChipManagerPCIe::isPowerControlRequired(v2)) {
    return 1;
  }
  ++*(_DWORD *)(*((void *)this + 6) + 444);
  uint64_t v3 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 3u);
  int v4 = AppleBCMWLANChipBackplane::readRegister32(this, v3, 0x1E8u, &v6, 0);
  uint64_t result = 0;
  if (!v4) {
    return 1;
  }
  return result;
}

uint64_t AppleBCMWLANChipBackplane::readPCIeCoreReg32(AppleBCMWLANChipBackplane *this, uint64_t a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 444);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 3u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

void AppleBCMWLANChipBackplane::free(OSObject *this)
{
  uint64_t v2 = *(void *)&this[1].refcount;
  if (v2)
  {
    if (*(void *)(v2 + 3144))
    {
      IOFreeData();
      *(void *)(*(void *)&this[1].refcount + 3144) = 0;
      uint64_t v2 = *(void *)&this[1].refcount;
    }
    if (*(void *)(v2 + 3096))
    {
      IOFree(*(void **)(v2 + 3096), 32 * *(unsigned int *)(v2 + 3104));
      *(void *)(*(void *)&this[1].refcount + 3096) = 0;
      *(void *)(*(void *)&this[1].refcount + 3096) = 0;
      uint64_t v2 = *(void *)&this[1].refcount;
    }
    if (*(void *)(v2 + 1992))
    {
      IOFree(*(void **)(v2 + 1992), 32 * *(unsigned int *)(v2 + 2000));
      *(void *)(*(void *)&this[1].refcount + 1992) = 0;
      *(void *)(*(void *)&this[1].refcount + 1992) = 0;
      uint64_t v2 = *(void *)&this[1].refcount;
    }
    uint64_t v3 = *(void *)(v2 + 3112);
    if (v3)
    {
      (*(void (**)(void))(*(void *)v3 + 16))(*(void *)(v2 + 3112));
      *(void *)(*(void *)&this[1].refcount + 3112) = 0;
      uint64_t v2 = *(void *)&this[1].refcount;
    }
    uint64_t v4 = *(void *)(v2 + 1624);
    if (v4)
    {
      (*(void (**)(void))(*(void *)v4 + 16))(*(void *)(v2 + 1624));
      *(void *)(*(void *)&this[1].refcount + 1624) = 0;
      uint64_t v2 = *(void *)&this[1].refcount;
    }
    memset_s((void *)v2, 0xC60uLL, 0, 0xC60uLL);
    uint64_t v5 = *(void **)&this[1].refcount;
    if (v5)
    {
      IOFree(v5, 0xC60uLL);
      *(void *)&this[1].__int32 refcount = 0;
    }
  }
  OSObject::free(this);
}

void non-virtual thunk to'AppleBCMWLANChipBackplane::free(AppleBCMWLANChipBackplane *this)
{
}

uint64_t AppleBCMWLANChipBackplane::validateCores(AppleBCMWLANChipBackplane *this)
{
  uint64_t v1 = *((void *)this + 6);
  if (!*(_DWORD *)(v1 + 2000)) {
    return 1;
  }
  uint64_t v3 = 0;
  unint64_t v4 = 0;
  char v5 = 1;
  do
  {
    uint64_t v6 = (_DWORD *)(*(void *)(v1 + 1992) + v3);
    uint64_t v7 = *v6;
    uint64_t result = (v7 == 0xFFFFFFFFLL) & v5;
    if v7 != -1 && (v5)
    {
      uint64_t result = AppleBCMWLANChipBackplane::validateWindow((uint64_t)this, v6, *(_DWORD *)(v1 + 32 * *v6 + 1644));
      uint64_t v1 = *((void *)this + 6);
    }
    ++v4;
    v3 += 32;
    char v5 = result;
  }
  while (v4 < *(unsigned int *)(v1 + 2000));
  return result;
}

BOOL AppleBCMWLANChipBackplane::validateWindow(uint64_t a1, _DWORD *a2, int a3)
{
  unsigned int v5 = 0;
  return a2
      && *a2 != -1
      && !AppleBCMWLANChipConfigSpace::readReg32(*(AppleBCMWLANChipConfigSpace **)(*(void *)(a1 + 48) + 1624), a2[1], &v5)&& v5 == a3;
}

uint64_t AppleBCMWLANChipBackplane::isCoreMapped(uint64_t a1, unsigned int a2)
{
  if (a2 > 0xA) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = v2 + 32 * a2;
  if (*(unsigned char *)(v3 + 1664) && *(_DWORD *)(v3 + 1648) && *(_DWORD *)(v2 + 32 * a2 + 1640) == a2) {
    return 1;
  }
  uint64_t v5 = *(unsigned int *)(v2 + 2000);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = *(int **)(v2 + 1992);
  uint64_t v7 = v5 - 1;
  do
  {
    uint64_t v8 = v7;
    int v9 = *v6;
    v6 += 8;
    int v10 = v9;
    BOOL v11 = v9 != -1 && a2 == v10;
    uint64_t result = v11;
    if (v11) {
      break;
    }
    uint64_t v7 = v8 - 1;
  }
  while (v8);
  return result;
}

uint64_t AppleBCMWLANChipBackplane::mapCore(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = a2;
  if (!*(unsigned char *)(v2 + 32 * a2 + 1664))
  {
    unsigned __int8 v4 = a2;
    uint64_t v6 = *(void *)(v2 + 1992) + 32 * *(unsigned int *)(v2 + 2004);
    if (*(_DWORD *)v6 != -1)
    {
      uint64_t v7 = *(_DWORD *)v6;
      *(unsigned char *)(v2 + 32 * v7 + 1664) = 0;
      *(void *)(*(void *)(a1 + 48) + 32 * v7 + 1656) = 0;
      uint64_t v2 = *(void *)(a1 + 48);
    }
    AppleBCMWLANChipConfigSpace::writeReg32(*(AppleBCMWLANChipConfigSpace **)(v2 + 1624), *(_DWORD *)(v6 + 4), *(_DWORD *)(v2 + 32 * a2 + 1644));
    *(unsigned char *)(*(void *)(a1 + 48) + 32 * v3 + 1664) = 1;
    *(void *)(*(void *)(a1 + 48) + 32 * v3 + 1656) = *(void *)(v6 + 16);
    *(_DWORD *)uint64_t v6 = v4;
    *(_DWORD *)(*(void *)(a1 + 48) + 2004) = (*(_DWORD *)(*(void *)(a1 + 48) + 2004) + 1)
                                               % *(_DWORD *)(*(void *)(a1 + 48) + 2000);
    uint64_t v2 = *(void *)(a1 + 48);
  }
  return v2 + 32 * v3 + 1640;
}

uint64_t AppleBCMWLANChipBackplane::validateWrappers(AppleBCMWLANChipBackplane *this)
{
  uint64_t v1 = *((void *)this + 6);
  if (!*(_DWORD *)(v1 + 3104)) {
    return 1;
  }
  uint64_t v3 = 0;
  unint64_t v4 = 0;
  char v5 = 1;
  do
  {
    uint64_t v6 = (_DWORD *)(*(void *)(v1 + 3096) + v3);
    uint64_t v7 = *v6;
    uint64_t result = (v7 == 0xFFFFFFFFLL) & v5;
    if v7 != -1 && (v5)
    {
      uint64_t result = AppleBCMWLANChipBackplane::validateWindow((uint64_t)this, v6, *(_DWORD *)(v1 + 32 * *v6 + 2012));
      uint64_t v1 = *((void *)this + 6);
    }
    ++v4;
    v3 += 32;
    char v5 = result;
  }
  while (v4 < *(unsigned int *)(v1 + 3104));
  return result;
}

BOOL AppleBCMWLANChipBackplane::isWrapperMapped(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = v2 + 32 * a2;
  if (*(unsigned char *)(v3 + 2032)
    && *(_DWORD *)(v3 + 2016)
    && (a2 | 0x10000) == *(_DWORD *)(v2 + 32 * a2 + 2008))
  {
    return 1;
  }
  unint64_t v4 = *(unsigned int *)(v2 + 3104);
  if (!v4) {
    return 0;
  }
  char v5 = *(_DWORD **)(v2 + 3096);
  if (*v5 != -1 && *v5 == a2) {
    return 1;
  }
  uint64_t v7 = v5 + 8;
  uint64_t v8 = 1;
  do
  {
    unint64_t v9 = v8;
    if (v4 == v8) {
      break;
    }
    int v10 = *v7;
    v7 += 8;
    int v11 = v10;
    ++v8;
  }
  while (v10 == -1 || v11 != a2);
  return v9 < v4;
}

uint64_t AppleBCMWLANChipBackplane::mapWrapper(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = a2;
  if (!*(unsigned char *)(v2 + 32 * a2 + 2032))
  {
    unsigned __int8 v4 = a2;
    uint64_t v6 = *(void *)(v2 + 3096) + 32 * *(unsigned int *)(v2 + 3108);
    if (*(_DWORD *)v6 != -1)
    {
      uint64_t v7 = *(_DWORD *)v6;
      *(unsigned char *)(v2 + 32 * v7 + 2032) = 0;
      *(void *)(*(void *)(a1 + 48) + 32 * v7 + 2024) = 0;
      uint64_t v2 = *(void *)(a1 + 48);
    }
    AppleBCMWLANChipConfigSpace::writeReg32(*(AppleBCMWLANChipConfigSpace **)(v2 + 1624), *(_DWORD *)(v6 + 4), *(_DWORD *)(v2 + 32 * a2 + 2012));
    *(unsigned char *)(*(void *)(a1 + 48) + 32 * v3 + 2032) = 1;
    *(void *)(*(void *)(a1 + 48) + 32 * v3 + 2024) = *(void *)(v6 + 16);
    *(_DWORD *)uint64_t v6 = v4 | 0x10000;
    *(_DWORD *)(*(void *)(a1 + 48) + 3108) = (*(_DWORD *)(*(void *)(a1 + 48) + 3108) + 1)
                                               % *(_DWORD *)(*(void *)(a1 + 48) + 3104);
    uint64_t v2 = *(void *)(a1 + 48);
  }
  return v2 + 32 * v3 + 2008;
}

uint64_t AppleBCMWLANChipBackplane::writeRegister32(uint64_t a1, uint64_t a2, unsigned int a3, uint32_t a4)
{
  uint64_t v7 = a3;
  uint64_t v8 = *(void *)(a2 + 16) + a3;
  uint64_t v9 = a4;
  kdebug_trace();
  int v10 = *(AppleBCMWLANPCIeMMIOHistory **)(*(void *)(a1 + 48) + 3112);
  if (v10) {
    int v10 = (AppleBCMWLANPCIeMMIOHistory *)AppleBCMWLANPCIeMMIOHistory::recordMMIOBackPlane(v10, v8, v9, 4, 0, 1);
  }
  Device = (IOPCIDevice *)AppleBCMWLANBusInterfacePCIe::getDevice(v10);
  IOPCIDevice::MemoryWrite32(Device, *(unsigned char *)(a2 + 12), *(void *)(a2 + 16) + v7, a4);
  uint64_t v12 = *(AppleBCMWLANPCIeMMIOHistory **)(*(void *)(a1 + 48) + 3112);
  if (v12) {
    AppleBCMWLANPCIeMMIOHistory::recordMMIOBackPlane(v12, v8, v9, 4, 0, 0);
  }
  return kdebug_trace();
}

uint64_t AppleBCMWLANChipBackplane::readRegister32(AppleBCMWLANChipBackplane *a1, uint64_t a2, unsigned int a3, uint32_t *a4, int a5)
{
  if (a5) {
    int v10 = AppleBCMWLANChipBackplane::forcePowerLite(a1, 1, 0) ^ 1;
  }
  else {
    int v10 = 0;
  }
  uint64_t v11 = a3;
  uint64_t v12 = *(void *)(a2 + 16) + a3;
  kdebug_trace();
  uint64_t v13 = *(AppleBCMWLANPCIeMMIOHistory **)(*((void *)a1 + 6) + 3112);
  if (v13) {
    uint64_t v13 = (AppleBCMWLANPCIeMMIOHistory *)AppleBCMWLANPCIeMMIOHistory::recordMMIOBackPlane(v13, v12, 0, 4, 1, 1);
  }
  Device = (IOPCIDevice *)AppleBCMWLANBusInterfacePCIe::getDevice(v13);
  IOPCIDevice::MemoryRead32(Device, *(unsigned char *)(a2 + 12), *(void *)(a2 + 16) + v11, a4);
  uint64_t v15 = *(AppleBCMWLANPCIeMMIOHistory **)(*((void *)a1 + 6) + 3112);
  if (v15) {
    AppleBCMWLANPCIeMMIOHistory::recordMMIOBackPlane(v15, v12, *a4, 4, 1, 0);
  }
  kdebug_trace();
  if (((a5 ^ 1 | v10) & 1) == 0) {
    AppleBCMWLANChipBackplane::forcePowerLite(a1, 0, 0);
  }
  if (*a4 == -1) {
    return 3825173258;
  }
  else {
    return 0;
  }
}

uint64_t AppleBCMWLANChipBackplane::forcePowerLite(AppleBCMWLANChipBackplane *this, int a2, int a3)
{
  uint64_t v6 = (char *)this + 48;
  if (!AppleBCMWLANChipManagerPCIe::isPowerControlRequired(*(AppleBCMWLANChipManagerPCIe **)(*((void *)this + 6) + 3120))) {
    return 1;
  }
  if (!a3)
  {
    unsigned int v14 = 0;
    if (AppleBCMWLANConfigManager::setupFirmwareWithDTDefaults(*(AppleBCMWLANConfigManager **)(*(void *)v6 + 3120)))
    {
      ++*(_DWORD *)(*((void *)this + 6) + 444);
      uint64_t v8 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 3u);
      if (AppleBCMWLANChipBackplane::readRegister32(this, v8, 2572, &v14, 0)) {
        AppleBCMWLANChipBackplane::forcePowerLite();
      }
      if (!a2)
      {
        unsigned int v9 = v14 & 0xFFFFFCFF;
LABEL_16:
        unsigned int v14 = v9;
        ++*(_DWORD *)(*((void *)this + 6) + 448);
        uint64_t v11 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 3u);
        AppleBCMWLANChipBackplane::writeRegister32((uint64_t)this, v11, 0xA0Cu, v9);
        if (a2)
        {
          IOSleep(0xFuLL);
          ++*(_DWORD *)(*((void *)this + 6) + 444);
          uint64_t v12 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 3u);
          if (AppleBCMWLANChipBackplane::readRegister32(this, v12, 2572, &v14, 0)) {
            AppleBCMWLANChipBackplane::forcePowerLite();
          }
          if ((~v14 & 0x30000) != 0) {
            AppleBCMWLANChipBackplane::forcePowerLite();
          }
        }
        return 1;
      }
      if ((~v14 & 0x300) != 0)
      {
        unsigned int v9 = v14 | 0x300;
        goto LABEL_16;
      }
    }
    else
    {
      if (!a2)
      {
        ++*(_DWORD *)(*((void *)this + 6) + 448);
        uint64_t v10 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 3u);
        AppleBCMWLANChipBackplane::writeRegister32((uint64_t)this, v10, 0x1E8u, 0);
        AppleBCMWLANChipBackplane::forcePowerLite(BOOL,BOOL)::currentPoweruint64_t Status = 0;
        IOSleep(0xFuLL);
        return 1;
      }
      if (!AppleBCMWLANChipBackplane::forcePowerLite(BOOL,BOOL)::currentPowerStatus)
      {
        unsigned int v14 = 768;
        ++*(_DWORD *)(*((void *)this + 6) + 448);
        uint64_t v13 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 3u);
        AppleBCMWLANChipBackplane::writeRegister32((uint64_t)this, v13, 0x1E8u, 0x300u);
        AppleBCMWLANChipBackplane::forcePowerLite(BOOL,BOOL)::currentPoweruint64_t Status = a2;
        IOSleep(0xFuLL);
        if (AppleBCMWLANChipBackplane::readPCIeCoreReg32(this, 488, &v14)) {
          AppleBCMWLANChipBackplane::forcePowerLite((uint64_t)v6);
        }
        return 1;
      }
    }
    return 0;
  }
  AppleBCMWLANChipBackplane::forcePowerLite(BOOL,BOOL)::currentPoweruint64_t Status = a2;
  return 1;
}

uint64_t AppleBCMWLANChipBackplane::waitForValue32(AppleBCMWLANChipBackplane *a1, uint64_t a2, unsigned int a3, int a4, int a5, uint64_t a6, int a7)
{
  nanoseconds_to_absolutetime();
  uint64_t v18 = mach_continuous_time();
  uint32_t v17 = 0;
  while (1)
  {
    AppleBCMWLANChipBackplane::readRegister32(a1, a2, a3, &v17, a7);
    uint32_t v13 = v17 & a4;
    if ((v17 & a4) == a4 && (v17 & a5) == 0) {
      break;
    }
    if (mach_continuous_time() >= v18)
    {
      uint32_t v13 = v17 & a4;
      BOOL v15 = (v17 & a5) == 0;
      goto LABEL_9;
    }
  }
  BOOL v15 = 1;
LABEL_9:
  if (v13 == a4 && v15) {
    return 0;
  }
  else {
    return 3758097110;
  }
}

uint64_t AppleBCMWLANChipBackplane::copyRegisters16(uint64_t a1, uint64_t a2, unsigned int *a3, IO80211Buffer *this)
{
  uint64_t v4 = 3825173258;
  uint16_t readData = 0;
  if (a2)
  {
    unsigned int v7 = *(_DWORD *)(a2 + 8);
    if (*a3 < v7)
    {
      unint64_t v8 = a3[1];
      if (v8 + *a3 < v7 && IO80211Buffer::getLength(this) >= v8)
      {
        uint64_t BytesNoCopy = IO80211Buffer::getBytesNoCopy(this);
        unint64_t v12 = *a3;
        if ((v12 & 1) == 0)
        {
          unsigned int v13 = a3[1];
          if ((v13 & 1) == 0)
          {
            if (v13 >= 2)
            {
              unsigned int v14 = (_WORD *)BytesNoCopy;
              char v15 = 0;
              unint64_t v16 = v12 >> 1;
              unint64_t v17 = (*a3 >> 1) + (v13 >> 1);
              uint64_t v18 = 2 * (v12 >> 1);
              do
              {
                uint64_t v19 = v18 + *(void *)(a2 + 16);
                unsigned int v20 = *(AppleBCMWLANPCIeMMIOHistory **)(*(void *)(a1 + 48) + 3112);
                if (v20) {
                  unsigned int v20 = (AppleBCMWLANPCIeMMIOHistory *)AppleBCMWLANPCIeMMIOHistory::recordMMIOBackPlane(v20, v18 + *(void *)(a2 + 16), 0, 2, 1, 1);
                }
                Device = (IOPCIDevice *)AppleBCMWLANBusInterfacePCIe::getDevice(v20);
                IOPCIDevice::MemoryRead16(Device, *(unsigned char *)(a2 + 12), v18 + *(void *)(a2 + 16), &readData);
                uint64_t v22 = readData;
                BOOL v23 = readData == 0xFFFFLL;
                _WORD *v14 = readData;
                unint64_t v24 = *(AppleBCMWLANPCIeMMIOHistory **)(*(void *)(a1 + 48) + 3112);
                if (v24) {
                  AppleBCMWLANPCIeMMIOHistory::recordMMIOBackPlane(v24, v19, v22, 2, 1, 0);
                }
                v15 |= v23;
                ++v16;
                v18 += 2;
                ++v14;
              }
              while (v16 < v17);
              if (v15) {
                return 3825173258;
              }
              else {
                return 0;
              }
            }
            else
            {
              return 0;
            }
          }
        }
      }
    }
  }
  return v4;
}

uint64_t AppleBCMWLANChipBackplane::copyOTPReg16(uint64_t a1, unsigned int *a2, IO80211Buffer *a3)
{
  unsigned int OTPCoreID = AppleBCMWLANChipManagerPCIe::getOTPCoreID(*(AppleBCMWLANChipManagerPCIe **)(*(void *)(a1 + 48) + 3120));
  uint64_t v7 = AppleBCMWLANChipBackplane::mapCore(a1, OTPCoreID);
  return AppleBCMWLANChipBackplane::copyRegisters16(a1, v7, a2, a3);
}

uint64_t AppleBCMWLANChipBackplane::writePCIeDoorbell(AppleBCMWLANChipBackplane *this, unsigned int a2, uint32_t a3)
{
  uint64_t v6 = *((void *)this + 6);
  if ((a2 & 0xFFFFFFFB) == 0x140)
  {
    ++*(_DWORD *)(v6 + 448);
    uint64_t v7 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 3u);
    return AppleBCMWLANChipBackplane::writeRegister32((uint64_t)this, v7, a2, a3);
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(v6 + 3120) + 72))(*(void *)(v6 + 3120));
    if (result)
    {
      (*(void (**)(void))(**(void **)(*((void *)this + 6) + 3120) + 72))(*(void *)(*((void *)this + 6) + 3120));
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        unsigned int v9 = (CCLogStream *)(*(uint64_t (**)(void))(**(void **)(*((void *)this + 6) + 3120) + 72))(*(void *)(*((void *)this + 6) + 3120));
        return CCLogStream::logAlert(v9, "[dk] %s@%d:Invalid DB index %u, db= %u", "writePCIeDoorbell", 779, a2, a3);
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANChipBackplane::writePCIeCoreReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, uint32_t a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 448);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 3u);
  return AppleBCMWLANChipBackplane::writeRegister32((uint64_t)this, v6, a2, a3);
}

uint64_t AppleBCMWLANChipBackplane::dumpPCIeCoreEnumerationRegistersSF(AppleBCMWLANChipBackplane *this, char *a2, size_t a3)
{
  if (a3 < 0x3C0) {
    return 3825172738;
  }
  size_t v4 = a3;
  uint32_t v19 = -1431655766;
  bzero(a2, a3);
  uint64_t v7 = 0;
  int v8 = 0;
  do
  {
    unsigned int v9 = AppleBCMWLANChipBackplane::dumpPCIeCoreEnumerationRegistersSF(char *,unsigned long)::dRegs[v7];
    ++*(_DWORD *)(*((void *)this + 6) + 444);
    uint64_t v10 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 3u);
    if (AppleBCMWLANChipBackplane::readRegister32(this, v10, v9, &v19, 0)) {
      return 3825173258;
    }
    int v11 = snprintf(&a2[v8], v4, "[%03x]%s: 0x%08x \n", v9, *(const char **)&AppleBCMWLANChipBackplane::dumpPCIeCoreEnumerationRegistersSF(char *,unsigned long)::dRegs[v7 + 2], v19);
    if (v11 < 1 || v4 <= v11) {
      return 3825172738;
    }
    v7 += 4;
    v8 += v11;
    v4 -= v11;
  }
  while (v7 != 48);
  unint64_t v12 = 0;
  while (1)
  {
    unsigned int v13 = (unsigned int *)((char *)&unk_100371754 + 8 * v12);
    unsigned int v14 = *v13;
    unsigned int v15 = v13[1];
    if (*v13 < v15) {
      break;
    }
LABEL_18:
    uint64_t result = 0;
    if (++v12 == 4) {
      return result;
    }
  }
  if (v12 >= 2) {
    unint64_t v16 = "PCIeCoreRegDmaDevToHost";
  }
  else {
    unint64_t v16 = "PCIeCoreRegDmaHostToDev";
  }
  while (1)
  {
    ++*(_DWORD *)(*((void *)this + 6) + 444);
    uint64_t v17 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 3u);
    uint64_t result = AppleBCMWLANChipBackplane::readRegister32(this, v17, v14, &v19, 0);
    if (result) {
      return result;
    }
    int v18 = snprintf(&a2[v8], v4, "[%03x]%s: 0x%08x \n", v14, v16, v19);
    if (v18 < 1 || v4 <= v18) {
      return 3825172738;
    }
    v8 += v18;
    v4 -= v18;
    v14 += 4;
    if (v14 >= v15) {
      goto LABEL_18;
    }
  }
}

uint64_t AppleBCMWLANChipBackplane::dumpPCIeCoreEnumerationRegistersMF(AppleBCMWLANChipBackplane *this, char *a2, size_t a3)
{
  if (a3 < 0x3C0) {
    return 3825172738;
  }
  size_t v4 = a3;
  uint32_t v19 = -1431655766;
  bzero(a2, a3);
  uint64_t v7 = 0;
  int v8 = 0;
  do
  {
    unsigned int v9 = AppleBCMWLANChipBackplane::dumpPCIeCoreEnumerationRegistersMF(char *,unsigned long)::dRegs[v7];
    ++*(_DWORD *)(*((void *)this + 6) + 444);
    uint64_t v10 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 3u);
    if (AppleBCMWLANChipBackplane::readRegister32(this, v10, v9, &v19, 0)) {
      return 3825173258;
    }
    int v11 = snprintf(&a2[v8], v4, "[%03x]%s: 0x%08x \n", v9, *(const char **)&AppleBCMWLANChipBackplane::dumpPCIeCoreEnumerationRegistersMF(char *,unsigned long)::dRegs[v7 + 2], v19);
    if (v11 < 1 || v4 <= v11) {
      return 3825172738;
    }
    v7 += 4;
    v8 += v11;
    v4 -= v11;
  }
  while (v7 != 48);
  unint64_t v12 = 0;
  while (1)
  {
    unsigned int v13 = (unsigned int *)((char *)&unk_100371754 + 8 * v12);
    unsigned int v14 = *v13;
    unsigned int v15 = v13[1];
    if (*v13 < v15) {
      break;
    }
LABEL_18:
    uint64_t result = 0;
    if (++v12 == 4) {
      return result;
    }
  }
  if (v12 >= 2) {
    unint64_t v16 = "PCIeCoreRegDmaDevToHost";
  }
  else {
    unint64_t v16 = "PCIeCoreRegDmaHostToDev";
  }
  while (1)
  {
    ++*(_DWORD *)(*((void *)this + 6) + 444);
    uint64_t v17 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 3u);
    uint64_t result = AppleBCMWLANChipBackplane::readRegister32(this, v17, v14, &v19, 0);
    if (result) {
      return result;
    }
    int v18 = snprintf(&a2[v8], v4, "[%03x]%s: 0x%08x \n", v14, v16, v19);
    if (v18 < 1 || v4 <= v18) {
      return 3825172738;
    }
    v8 += v18;
    v4 -= v18;
    v14 += 4;
    if (v14 >= v15) {
      goto LABEL_18;
    }
  }
}

uint64_t AppleBCMWLANChipBackplane::dumpPCIeCoreEnumerationRegisters(AppleBCMWLANChipBackplane *this, char *a2, size_t a3)
{
  if (AppleBCMWLANChipManagerPCIe::isMultiFunctionChip(*(AppleBCMWLANChipManagerPCIe **)(*((void *)this + 6) + 3120)))
  {
    return AppleBCMWLANChipBackplane::dumpPCIeCoreEnumerationRegistersMF(this, a2, a3);
  }
  else
  {
    return AppleBCMWLANChipBackplane::dumpPCIeCoreEnumerationRegistersSF(this, a2, a3);
  }
}

uint64_t AppleBCMWLANChipBackplane::dumpWrapperRegisters(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, int *), const char *a3, uint64_t a4, uint64_t a5, size_t *a6, uint64_t a7, unint64_t a8)
{
  int v23 = -1431655766;
  if (a8)
  {
    uint64_t v13 = 0;
    unsigned int v14 = 0;
    size_t v15 = a5 - *a6;
    uint64_t v21 = a7;
    while (2)
    {
      unint64_t v16 = (unsigned int *)(a7 + 8 * v13);
      uint64_t v17 = *v16;
      for (unsigned int i = v16[1] + v17; v17 < i; unsigned int i = v16[1] + *v16)
      {
        uint64_t result = a2(a1, v17, &v23);
        if (result) {
          return result;
        }
        unsigned int v20 = snprintf((char *)(a4 + v15), *a6, "%s[%03x]: 0x%08x \n", a3, v17, v23);
        if ((int)v20 < 1 || *a6 <= v20) {
          return 3825172738;
        }
        uint64_t v17 = (v17 + 4);
        v15 += v20;
        *a6 -= v20;
      }
      uint64_t v13 = ++v14;
      a7 = v21;
      if (v14 < a8) {
        continue;
      }
      break;
    }
  }
  return 0;
}

uint64_t AppleBCMWLANChipBackplane::dumpCoreRegisters(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, unsigned int *), const char *a3, uint64_t a4, uint64_t a5, size_t *a6, uint64_t a7, unint64_t a8, uint64_t a9)
{
  unsigned int v26 = -1431655766;
  if (!a8) {
    return 0;
  }
  unint64_t v14 = 0;
  int v15 = 0;
  size_t v16 = a5 - *a6;
  uint64_t v23 = a7;
  while (1)
  {
    int v25 = v15;
    uint64_t v17 = (unsigned int *)(a7 + 8 * v14);
    uint64_t v18 = *v17;
    if (v18 < v17[1] + v18) {
      break;
    }
LABEL_15:
    unint64_t v14 = (v25 + 1);
    int v15 = v25 + 1;
    a7 = v23;
    if (v14 >= a8) {
      return 0;
    }
  }
  int v19 = *v17;
  while (1)
  {
    uint64_t result = a2(a1, v18, &v26);
    if (result) {
      return result;
    }
    if (a9 == 4)
    {
      unsigned int v21 = snprintf((char *)(a4 + v16), *a6, "%s[%03x]: 0x%08x \n", a3, v19, v26);
      int v19 = v18 + 4;
      uint64_t v18 = (v18 + 4);
    }
    else
    {
      unsigned int v22 = HIWORD(v26);
      if ((v19 & 3) != 0)
      {
        unsigned int v22 = (unsigned __int16)v26;
        uint64_t v18 = v18;
      }
      else
      {
        uint64_t v18 = (v18 + 4);
      }
      unsigned int v21 = snprintf((char *)(a4 + v16), *a6, "%s[%03x]: 0x%04x \n", a3, v19, v22);
      v19 += 2;
    }
    if ((int)v21 < 1 || *a6 <= v21) {
      return 3825172738;
    }
    v16 += v21;
    *a6 -= v21;
    if (v18 >= v17[1] + *v17) {
      goto LABEL_15;
    }
  }
}

uint64_t AppleBCMWLANChipBackplane::dumpD11CoreEnumerationRegisters(AppleBCMWLANChipBackplane *this, char *a2, size_t a3)
{
  size_t v7 = a3;
  bzero(a2, a3);
  return AppleBCMWLANChipBackplane::dumpCoreRegisters((uint64_t)this, (uint64_t (*)(uint64_t, uint64_t, unsigned int *))AppleBCMWLANChipBackplane::readMACCoreReg32, "MAC", (uint64_t)a2, a3, &v7, (uint64_t)&unk_100371774, 0x11uLL, 4);
}

uint64_t AppleBCMWLANChipBackplane::readMACCoreReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 420);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 1u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::dumpCommonCoreEnumerationRegisters(AppleBCMWLANChipBackplane *this, char *a2, size_t a3)
{
  size_t v7 = a3;
  uint64_t v8 = 0x2000000600;
  bzero(a2, a3);
  return AppleBCMWLANChipBackplane::dumpCoreRegisters((uint64_t)this, (uint64_t (*)(uint64_t, uint64_t, unsigned int *))AppleBCMWLANChipBackplane::readCommonCoreReg32, "COMMON", (uint64_t)a2, a3, &v7, (uint64_t)&v8, 1uLL, 4);
}

uint64_t AppleBCMWLANChipBackplane::readCommonCoreReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 408);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 0);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

uint64_t AppleBCMWLANChipBackplane::dumpPMUCoreEnumerationRegisters(AppleBCMWLANChipBackplane *this, char *a2, size_t a3)
{
  uint64_t v11 = 0x2000000600;
  int v6 = (*(uint64_t (**)(void))(**(void **)(*((void *)this + 6) + 3120) + 240))(*(void *)(*((void *)this + 6) + 3120));
  if (v6) {
    size_t v7 = (uint64_t *)&unk_1003717FC;
  }
  else {
    size_t v7 = &v11;
  }
  if (v6) {
    unint64_t v8 = 7;
  }
  else {
    unint64_t v8 = 1;
  }
  size_t v10 = a3;
  bzero(a2, a3);
  return AppleBCMWLANChipBackplane::dumpCoreRegisters((uint64_t)this, (uint64_t (*)(uint64_t, uint64_t, unsigned int *))AppleBCMWLANChipBackplane::readPMUCoreReg32, "PMU", (uint64_t)a2, a3, &v10, (uint64_t)v7, v8, 4);
}

uint64_t AppleBCMWLANChipBackplane::readPMUCoreReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 492);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 7u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

uint64_t AppleBCMWLANChipBackplane::dumpARMCoreEnumerationRegisters(uint64_t a1, void *a2, size_t a3, uint64_t a4, unint64_t a5)
{
  size_t v11 = a3;
  bzero(a2, a3);
  return AppleBCMWLANChipBackplane::dumpCoreRegisters(a1, (uint64_t (*)(uint64_t, uint64_t, unsigned int *))AppleBCMWLANChipBackplane::readARMCoreReg32, "ARM", (uint64_t)a2, a3, &v11, a4, a5, 4);
}

uint64_t AppleBCMWLANChipBackplane::readARMCoreReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 432);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 2u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::dumpWrapperRegisters(uint64_t a1, uint64_t (*a2)(uint64_t, void, int *), const char *a3, uint64_t a4, uint64_t a5, size_t *a6, const char **a7, uint64_t a8)
{
  uint64_t v8 = 3825172738;
  size_t v9 = *a6;
  if (*a6 >= 80 * a8)
  {
    uint64_t v10 = a8;
    if (a8)
    {
      int v21 = -1431655766;
      size_t v17 = a5 - v9;
      while (1)
      {
        uint64_t v18 = a2(a1, *(unsigned int *)a7, &v21);
        if (v18) {
          break;
        }
        unsigned int v19 = snprintf((char *)(a4 + v17), *a6, "%s[%03x]%s: 0x%08x \n", a3, *(_DWORD *)a7, a7[1], v21);
        if ((int)v19 < 1 || *a6 <= v19) {
          return v8;
        }
        v17 += v19;
        *a6 -= v19;
        a7 += 2;
        if (!--v10) {
          return 0;
        }
      }
      return v18;
    }
    else
    {
      return 0;
    }
  }
  return v8;
}

uint64_t AppleBCMWLANChipBackplane::dumpMNIIDMRegisters(AppleBCMWLANChipBackplane *this, char *a2, size_t a3)
{
  size_t v7 = a3;
  bzero(a2, a3);
  uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readAMNIChipCommonWrapperReg32, "AMNI_CHIPCOMMON", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpMNIIDMRegisters(char *,unsigned long)::dmpMNIRegs, 34);
  if (!result)
  {
    uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readPCIeSlaveWrapperReg32, "AMNI_PCIeF0", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpMNIIDMRegisters(char *,unsigned long)::dmpMNIRegs, 34);
    if (!result)
    {
      uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readPMNIWLAPBWrapperReg32, "PMNI_APB-CB", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpMNIIDMRegisters(char *,unsigned long)::dmpMNIRegs, 34);
      if (!result)
      {
        uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readPMNIAONPBWrapperReg32, "PMNI_APB-AAON", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpMNIIDMRegisters(char *,unsigned long)::dmpMNIRegs, 34);
        if (!result)
        {
          uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readHMNIBTWrapperReg32, "HMNI_BT", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpMNIIDMRegisters(char *,unsigned long)::dmpMNIRegs, 34);
          if (!result)
          {
            uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readHMNIGCIWrapperReg32, "HMNI_GCI", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpMNIIDMRegisters(char *,unsigned long)::dmpMNIRegs, 34);
            if (!result)
            {
              uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readSysmemSlaveWrapperReg32, "AMNI_CCI", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpMNIIDMRegisters(char *,unsigned long)::dmpMNIRegs, 34);
              if (!result)
              {
                uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readD11AUXSlaveWrapperReg32, "AMNI_AuxMAC", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpMNIIDMRegisters(char *,unsigned long)::dmpMNIRegs, 34);
                if (!result)
                {
                  uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readD11SlaveWrapperReg32, "AMNI_MainMAC", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpMNIIDMRegisters(char *,unsigned long)::dmpMNIRegs, 34);
                  if (!result)
                  {
                    uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readAMNIScanMacWrapperReg32, "AMNI_ScanMAC", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpMNIIDMRegisters(char *,unsigned long)::dmpMNIRegs, 34);
                    if (!result)
                    {
                      uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readAMNIAuxPhyWrapperReg32, "AMNI_AuxPHY", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpMNIIDMRegisters(char *,unsigned long)::dmpMNIRegs, 34);
                      if (!result)
                      {
                        uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readAMNIMainPhyWrapperReg32, "AMNI_MainPHY", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpMNIIDMRegisters(char *,unsigned long)::dmpMNIRegs, 34);
                        if (!result)
                        {
                          uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readAMNIScanPhyWrapperReg32, "AMNI_ScanPHY", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpMNIIDMRegisters(char *,unsigned long)::dmpMNIRegs, 34);
                          if (!result) {
                            return AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readPMNIWLAPBWrapperReg32, "PMNI_WLANCB", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpMNIIDMRegisters(char *,unsigned long)::dmpMNIRegs, 34);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANChipBackplane::readAMNIChipCommonWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 864);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x1Bu);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

uint64_t AppleBCMWLANChipBackplane::readPCIeSlaveWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 636);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 8u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

uint64_t AppleBCMWLANChipBackplane::readPMNIWLAPBWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 828);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x18u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::readPMNIAONPBWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 852);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x1Au);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

uint64_t AppleBCMWLANChipBackplane::readHMNIBTWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 876);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x1Cu);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

uint64_t AppleBCMWLANChipBackplane::readHMNIGCIWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 888);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x1Du);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

uint64_t AppleBCMWLANChipBackplane::readSysmemSlaveWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 804);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x16u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::readD11AUXSlaveWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 732);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x10u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::readD11SlaveWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 720);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0xFu);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::readAMNIScanMacWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 900);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x1Eu);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::readAMNIAuxPhyWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 912);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x1Fu);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::readAMNIMainPhyWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 924);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x20u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::readAMNIScanPhyWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 936);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x21u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::dumpOOBConfigStatusRegisters(AppleBCMWLANChipBackplane *this, char *a2, size_t a3)
{
  size_t v3 = a3;
  unsigned int v15 = 0;
  bzero(a2, a3);
  uint64_t v6 = 0;
  uint64_t v7 = 0;
LABEL_2:
  uint64_t v8 = 0;
  uint64_t v14 = v6;
  size_t v9 = &(&off_10038F330)[2 * v6];
  int v10 = *((_DWORD *)v9 + 2);
  while (1)
  {
    int v11 = AppleBCMWLANChipBackplane::dumpOOBConfigStatusRegisters(char *,unsigned long)::oobCoreRegs[v8];
    uint64_t result = AppleBCMWLANChipBackplane::readOOBRouterWrapperReg32(this, v11 + v10, &v15);
    if (result) {
      return result;
    }
    unsigned int v13 = snprintf(&a2[v7], v3, "%s[%03x]%s: 0x%08x\n", *v9, v11, *(const char **)&AppleBCMWLANChipBackplane::dumpOOBConfigStatusRegisters(char *,unsigned long)::oobCoreRegs[v8 + 2], v15);
    if ((int)v13 < 1 || v3 <= v13) {
      return 3825172738;
    }
    v7 += v13;
    v3 -= v13;
    v8 += 4;
    if (v8 == 16)
    {
      uint64_t v6 = v14 + 1;
      if (v14 != 10) {
        goto LABEL_2;
      }
      return 0;
    }
  }
}

uint64_t AppleBCMWLANChipBackplane::readOOBRouterWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 756);
  BOOL v6 = *(_DWORD *)(*((void *)this + 6) + 3160) != 1;
  uint64_t v7 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x12u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v7, a2, a3, v6);
}

uint64_t AppleBCMWLANChipBackplane::dumpCoreRegisterRegionswithMNIInterface(AppleBCMWLANChipBackplane *this, char *a2, size_t a3)
{
  size_t v7 = a3;
  bzero(a2, a3);
  uint64_t result = AppleBCMWLANChipBackplane::dumpCoreRegisters((uint64_t)this, (uint64_t (*)(uint64_t, uint64_t, unsigned int *))AppleBCMWLANChipBackplane::readGCICoreReg32, "LHL", (uint64_t)a2, a3, &v7, (uint64_t)&unk_100371834, 4uLL, 4);
  if (!result)
  {
    uint64_t result = AppleBCMWLANChipBackplane::dumpCoreRegisters((uint64_t)this, (uint64_t (*)(uint64_t, uint64_t, unsigned int *))AppleBCMWLANChipBackplane::readCommonCoreReg32, "COMMON", (uint64_t)a2, a3, &v7, (uint64_t)&unk_100371950, 2uLL, 4);
    if (!result)
    {
      uint64_t result = AppleBCMWLANChipBackplane::dumpCoreRegisters((uint64_t)this, (uint64_t (*)(uint64_t, uint64_t, unsigned int *))AppleBCMWLANChipBackplane::readGCICoreReg32, "GCI", (uint64_t)a2, a3, &v7, (uint64_t)&unk_100371960, 2uLL, 4);
      if (!result)
      {
        uint64_t result = AppleBCMWLANChipBackplane::dumpCoreRegisters((uint64_t)this, (uint64_t (*)(uint64_t, uint64_t, unsigned int *))AppleBCMWLANChipBackplane::readSRCBCoreReg32, "SRCB", (uint64_t)a2, a3, &v7, (uint64_t)&unk_100371970, 2uLL, 4);
        if (!result) {
          return AppleBCMWLANChipBackplane::dumpCoreRegisters((uint64_t)this, (uint64_t (*)(uint64_t, uint64_t, unsigned int *))AppleBCMWLANChipBackplane::readPCIeCoreReg32, "PCIE", (uint64_t)a2, a3, &v7, (uint64_t)&unk_100371854, 0xDuLL, 4);
        }
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANChipBackplane::readGCICoreReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 480);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 6u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

uint64_t AppleBCMWLANChipBackplane::readSRCBCoreReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 528);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 0xAu);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

uint64_t AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(AppleBCMWLANChipBackplane *this, char *a2, size_t a3)
{
  int v6 = *(_DWORD *)(*((void *)this + 6) + 3160);
  size_t v16 = a3;
  bzero(a2, a3);
  if (v6 == 1)
  {
    uint64_t v7 = *((void *)this + 6);
    if (*(_WORD *)(v7 + 2014) == 385)
    {
      uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readCommonMasterWrapperReg32, "COMMON_M", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
      if (result) {
        return result;
      }
      uint64_t v7 = *((void *)this + 6);
    }
    if (*(_WORD *)(v7 + 2046) != 385
      || (uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readMACMasterWrapperReg32, "MAC_M", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15), !result))
    {
      uint64_t v9 = *((void *)this + 6);
      if (*(_WORD *)(v9 + 2078) == 385)
      {
        uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readARMMasterWrapperReg32, "ARM_M", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
        if (result) {
          return result;
        }
        uint64_t v9 = *((void *)this + 6);
      }
      if (*(_WORD *)(v9 + 2110) != 385
        || (uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readPCIeMasterWrapperReg32, "PCIE_M", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15), !result))
      {
        uint64_t v10 = *((void *)this + 6);
        if (*(_WORD *)(v10 + 2398) == 385)
        {
          uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readD11AUXMasterWrapperReg32, "D11_AUX_M0", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
          if (result) {
            return result;
          }
          uint64_t v10 = *((void *)this + 6);
        }
        if (*(_WORD *)(v10 + 2430) != 385
          || (uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readD11AUXMaster1WrapperReg32, "D11_AUX_M1", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15), !result))
        {
          uint64_t v11 = *((void *)this + 6);
          if (*(_WORD *)(v11 + 2462) == 385)
          {
            uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readD11Master1WrapperReg32, "D11_M1", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
            if (result) {
              return result;
            }
            uint64_t v11 = *((void *)this + 6);
          }
          if (*(_WORD *)(v11 + 2494) != 385
            || (uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readD11SlaveWrapperReg32, "D11_S", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15), !result))
          {
            uint64_t v12 = *((void *)this + 6);
            if (*(_WORD *)(v12 + 2238) == 385)
            {
              uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readARMSlaveWrapperReg32, "ARM_S", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
              if (result) {
                return result;
              }
              uint64_t v12 = *((void *)this + 6);
            }
            if (*(_WORD *)(v12 + 2270) != 385
              || (uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readPCIeSlaveWrapperReg32, "PCIE_S", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15), !result))
            {
              uint64_t v13 = *((void *)this + 6);
              if (*(_WORD *)(v13 + 2526) == 385)
              {
                uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readD11AUXSlaveWrapperReg32, "D11_AUX_S", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
                if (result) {
                  return result;
                }
                uint64_t v13 = *((void *)this + 6);
              }
              if (*(_WORD *)(v13 + 2558) != 385
                || (uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readBTAXI2AAHBWrapperReg32, "BT_AXI2AHB", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15), !result))
              {
                uint64_t v14 = *((void *)this + 6);
                if (*(_WORD *)(v14 + 2366) == 385)
                {
                  uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readDefaultSlaveWrapperReg32, "DEFAULT_S", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
                  if (result) {
                    return result;
                  }
                  uint64_t v14 = *((void *)this + 6);
                }
                if (*(_WORD *)(v14 + 2590) != 385
                  || (uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readOOBRouterWrapperReg32, "OOB_ROUTER", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15), !result))
                {
                  uint64_t v15 = *((void *)this + 6);
                  if (*(_WORD *)(v15 + 2622) == 385)
                  {
                    uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readEROMWrapperReg32, "EROM", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
                    if (result) {
                      return result;
                    }
                    uint64_t v15 = *((void *)this + 6);
                  }
                  if (*(_WORD *)(v15 + 2302) != 385
                    || (uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readAPBBridge0SlaveWrapperReg32, "APB0_S", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15), !result))
                  {
                    if (*(_WORD *)(*((void *)this + 6) + 2334) == 385) {
                      return AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readAPBBridge1SlaveWrapperReg32, "APB1_S", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
                    }
                    return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readCommonMasterWrapperReg32, "COMMON_M", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
    if (!result)
    {
      uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readMACMasterWrapperReg32, "MAC_M", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
      if (!result)
      {
        uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readARMMasterWrapperReg32, "ARM_M", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
        if (!result)
        {
          uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readPCIeMasterWrapperReg32, "PCIE_M", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
          if (!result)
          {
            uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readD11AUXMasterWrapperReg32, "D11_AUX_M0", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
            if (!result)
            {
              uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readD11AUXMaster1WrapperReg32, "D11_AUX_M1", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
              if (!result)
              {
                uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readD11Master1WrapperReg32, "D11_M1", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
                if (!result)
                {
                  uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readD11SlaveWrapperReg32, "D11_S", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
                  if (!result)
                  {
                    uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readARMSlaveWrapperReg32, "ARM_S", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
                    if (!result)
                    {
                      uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readPCIeSlaveWrapperReg32, "PCIE_S", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
                      if (!result)
                      {
                        uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readD11AUXSlaveWrapperReg32, "D11_AUX_S", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
                        if (!result)
                        {
                          uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readBTAXI2AAHBWrapperReg32, "BT_AXI2AHB", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
                          if (!result)
                          {
                            uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readDefaultSlaveWrapperReg32, "DEFAULT_S", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
                            if (!result)
                            {
                              uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readOOBRouterWrapperReg32, "OOB_ROUTER", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
                              if (!result)
                              {
                                uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readEROMWrapperReg32, "EROM", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
                                if (!result)
                                {
                                  uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readAPBBridge0SlaveWrapperReg32, "APB0_S", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
                                  if (!result) {
                                    return AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readAPBBridge1SlaveWrapperReg32, "APB1_S", (uint64_t)a2, a3, &v16, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters43x7(char *,unsigned long)::dmpRegs, 15);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANChipBackplane::readCommonMasterWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 540);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

uint64_t AppleBCMWLANChipBackplane::readMACMasterWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 552);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 1u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::readARMMasterWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 564);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 2u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::readPCIeMasterWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 576);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 3u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

uint64_t AppleBCMWLANChipBackplane::readD11AUXMasterWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 684);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0xCu);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::readD11AUXMaster1WrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 696);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0xDu);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::readD11Master1WrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 708);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0xEu);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::readARMSlaveWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 624);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 7u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::readBTAXI2AAHBWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 744);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x11u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

uint64_t AppleBCMWLANChipBackplane::readDefaultSlaveWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 672);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0xBu);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

uint64_t AppleBCMWLANChipBackplane::readEROMWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 768);
  BOOL v6 = *(_DWORD *)(*((void *)this + 6) + 3160) != 1;
  uint64_t v7 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x13u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v7, a2, a3, v6);
}

uint64_t AppleBCMWLANChipBackplane::readAPBBridge0SlaveWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3, int a4)
{
  ++*(_DWORD *)(*((void *)this + 6) + 648);
  if (a4) {
    BOOL v7 = *(_DWORD *)(*((void *)this + 6) + 3160) != 1;
  }
  else {
    BOOL v7 = 0;
  }
  uint64_t v8 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 9u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v8, a2, a3, v7);
}

uint64_t AppleBCMWLANChipBackplane::readAPBBridge1SlaveWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3, int a4)
{
  ++*(_DWORD *)(*((void *)this + 6) + 660);
  if (a4) {
    BOOL v7 = *(_DWORD *)(*((void *)this + 6) + 3160) != 1;
  }
  else {
    BOOL v7 = 0;
  }
  uint64_t v8 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0xAu);
  return AppleBCMWLANChipBackplane::readRegister32(this, v8, a2, a3, v7);
}

uint64_t AppleBCMWLANChipBackplane::dumpAPBBridge0SlaveWrapperRegisters(AppleBCMWLANChipBackplane *this, char *a2, size_t a3)
{
  size_t v7 = a3;
  bzero(a2, a3);
  return AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, uint64_t, int *))AppleBCMWLANChipBackplane::readAPBBridgeWLB0SlaveWrapperReg32, "APB_BRIDGE0_S", (uint64_t)a2, a3, &v7, (uint64_t)&unk_1003718BC, 5uLL);
}

uint64_t AppleBCMWLANChipBackplane::readAPBBridgeWLB0SlaveWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 816);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x17u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 1);
}

uint64_t AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters(AppleBCMWLANChipBackplane *this, char *a2, size_t a3)
{
  size_t v7 = a3;
  bzero(a2, a3);
  uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readCommonMasterWrapperReg32, "COMMON_M", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters(char *,unsigned long)::dmpRegs, 14);
  if (!result)
  {
    uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readMACMasterWrapperReg32, "MAC_M", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters(char *,unsigned long)::dmpRegs, 14);
    if (!result)
    {
      uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readARMMasterWrapperReg32, "ARM_M", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters(char *,unsigned long)::dmpRegs, 14);
      if (!result)
      {
        uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readPCIeMasterWrapperReg32, "PCIE_M", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters(char *,unsigned long)::dmpRegs, 14);
        if (!result)
        {
          uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readCommonSlaveWrapperReg32, "COMMON_S", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters(char *,unsigned long)::dmpRegs, 14);
          if (!result)
          {
            uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readARMSlaveWrapperReg32, "ARM_S", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters(char *,unsigned long)::dmpRegs, 14);
            if (!result)
            {
              uint64_t result = AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readPCIeSlaveWrapperReg32, "PCIE_S", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters(char *,unsigned long)::dmpRegs, 14);
              if (!result) {
                return AppleBCMWLANChipBackplane::dumpWrapperRegisters((uint64_t)this, (uint64_t (*)(uint64_t, void, int *))AppleBCMWLANChipBackplane::readAPBBridge0SlaveWrapperReg32, "APB0_S", (uint64_t)a2, a3, &v7, &AppleBCMWLANChipBackplane::dumpDMPWrapperRegisters(char *,unsigned long)::dmpRegs, 14);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANChipBackplane::readCommonSlaveWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 612);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 6u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

uint64_t AppleBCMWLANChipBackplane::dumpUCodeRegisters(AppleBCMWLANChipBackplane *this, char *a2, size_t a3)
{
  size_t v7 = a3;
  uint64_t v8 = 0x2800000A40;
  bzero(a2, a3);
  uint64_t result = AppleBCMWLANChipBackplane::dumpCoreRegisters((uint64_t)this, (uint64_t (*)(uint64_t, uint64_t, unsigned int *))AppleBCMWLANChipBackplane::readMACCoreReg32, "IHR32", (uint64_t)a2, a3, &v7, (uint64_t)&unk_1003718E4, 0xCuLL, 4);
  if (!result) {
    return AppleBCMWLANChipBackplane::dumpCoreRegisters((uint64_t)this, (uint64_t (*)(uint64_t, uint64_t, unsigned int *))AppleBCMWLANChipBackplane::readMACCoreReg32, "IHR16", (uint64_t)a2, a3, &v7, (uint64_t)&v8, 1uLL, 2);
  }
  return result;
}

uint64_t AppleBCMWLANChipBackplane::readUCodeSCRRAM(AppleBCMWLANChipBackplane *this, char *a2, uint64_t a3)
{
  UCodeRegionInfo = (_DWORD *)AppleBCMWLANChipManagerPCIe::getUCodeRegionInfo(*(AppleBCMWLANChipManagerPCIe **)(*((void *)this + 6) + 3120), 0);
  uint64_t result = 0;
  unsigned int v8 = UCodeRegionInfo[1];
  if (v8 < UCodeRegionInfo[2])
  {
    uint32_t v14 = -1431655766;
    while (a3)
    {
      uint32_t v9 = v8 + UCodeRegionInfo[3];
      ++*(_DWORD *)(*((void *)this + 6) + 424);
      uint64_t v10 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 1u);
      AppleBCMWLANChipBackplane::writeRegister32((uint64_t)this, v10, 0x160u, v9);
      ++*(_DWORD *)(*((void *)this + 6) + 420);
      uint64_t v11 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 1u);
      uint64_t result = AppleBCMWLANChipBackplane::readRegister32(this, v11, 0x160u, &v14, 1);
      if (result) {
        return result;
      }
      ++*(_DWORD *)(*((void *)this + 6) + 420);
      uint64_t v12 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 1u);
      uint64_t result = AppleBCMWLANChipBackplane::readRegister32(this, v12, 0x164u, &v14, 1);
      if (result) {
        return result;
      }
      __int16 v13 = v14;
      if ((v8 & 1) == 0) {
        __int16 v13 = HIWORD(v14);
      }
      *(_WORD *)a2 = v13;
      a2 += 2;
      a3 -= 2;
      if (++v8 >= UCodeRegionInfo[2]) {
        return 0;
      }
    }
    return 3825172738;
  }
  return result;
}

uint64_t AppleBCMWLANChipBackplane::readUCodeSHMRAM(AppleBCMWLANChipBackplane *this, char *a2, uint64_t a3)
{
  uint64_t UCodeRegionInfo = AppleBCMWLANChipManagerPCIe::getUCodeRegionInfo(*(AppleBCMWLANChipManagerPCIe **)(*((void *)this + 6) + 3120), 1);
  unsigned int v7 = *(_DWORD *)(UCodeRegionInfo + 4);
  if (v7 >= *(_DWORD *)(UCodeRegionInfo + 8)) {
    return 0;
  }
  uint64_t v8 = UCodeRegionInfo;
  uint32_t v15 = -1431655766;
  while (a3)
  {
    uint32_t v9 = *(_DWORD *)(v8 + 12) + (v7 >> 2);
    ++*(_DWORD *)(*((void *)this + 6) + 424);
    uint64_t v10 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 1u);
    AppleBCMWLANChipBackplane::writeRegister32((uint64_t)this, v10, 0x160u, v9);
    ++*(_DWORD *)(*((void *)this + 6) + 420);
    uint64_t v11 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 1u);
    uint64_t result = AppleBCMWLANChipBackplane::readRegister32(this, v11, 0x160u, &v15, 1);
    if (result) {
      return result;
    }
    ++*(_DWORD *)(*((void *)this + 6) + 420);
    uint64_t v13 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 1u);
    uint64_t result = AppleBCMWLANChipBackplane::readRegister32(this, v13, 0x164u, &v15, 1);
    if (result) {
      return result;
    }
    __int16 v14 = v15;
    if ((v7 & 3) == 0) {
      __int16 v14 = HIWORD(v15);
    }
    *(_WORD *)a2 = v14;
    a2 += 2;
    a3 -= 2;
    v7 += 2;
    if (v7 >= *(_DWORD *)(v8 + 8)) {
      return 0;
    }
  }
  return 3825172738;
}

uint64_t AppleBCMWLANChipBackplane::saveDeviceState(AppleBCMWLANChipBackplane *this)
{
  uint64_t v1 = *((void *)this + 6);
  if (*(_DWORD *)(v1 + 3136))
  {
    unint64_t v3 = 0;
    int v4 = 0;
    do
    {
      char v5 = (unsigned int *)(*(void *)(v1 + 3128) + 8 * v3);
      unsigned int v6 = *v5;
      unsigned int v7 = v5[1] + *v5;
      if (*v5 < v7)
      {
        uint64_t v8 = 4 * v4;
        do
        {
          AppleBCMWLANChipConfigSpace::readReg32(*(AppleBCMWLANChipConfigSpace **)(*((void *)this + 6) + 1624), v6, (unsigned int *)(*(void *)(*((void *)this + 6) + 3144) + v8));
          v6 += 4;
          v8 += 4;
          ++v4;
        }
        while (v6 < v7);
        uint64_t v1 = *((void *)this + 6);
      }
      ++v3;
    }
    while (v3 < *(unsigned int *)(v1 + 3136));
  }
  return 0;
}

uint64_t AppleBCMWLANChipBackplane::restoreDeviceState(AppleBCMWLANChipBackplane *this)
{
  uint64_t v1 = *((void *)this + 6);
  if (*(_DWORD *)(v1 + 3136))
  {
    unint64_t v3 = 0;
    int v4 = 0;
    do
    {
      char v5 = (unsigned int *)(*(void *)(v1 + 3128) + 8 * v3);
      unsigned int v6 = *v5;
      unsigned int v7 = v5[1] + *v5;
      if (*v5 < v7)
      {
        uint64_t v8 = 4 * v4;
        do
        {
          AppleBCMWLANChipConfigSpace::writeReg32(*(AppleBCMWLANChipConfigSpace **)(*((void *)this + 6) + 1624), v6, *(_DWORD *)(*(void *)(*((void *)this + 6) + 3144) + v8));
          v6 += 4;
          v8 += 4;
          ++v4;
        }
        while (v6 < v7);
        uint64_t v1 = *((void *)this + 6);
      }
      ++v3;
    }
    while (v3 < *(unsigned int *)(v1 + 3136));
  }
  return 0;
}

uint64_t AppleBCMWLANChipBackplane::forcePower(AppleBCMWLANChipBackplane *this, int a2, int a3)
{
  uint64_t v4 = *((void *)this + 6);
  if (*(_DWORD *)(v4 + 3164) == 1)
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(v4 + 3120) + 72))(*(void *)(v4 + 3120));
    if (result)
    {
      (*(void (**)(void))(**(void **)(*((void *)this + 6) + 3120) + 72))(*(void *)(*((void *)this + 6) + 3120));
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        unsigned int v6 = (CCLogStream *)(*(uint64_t (**)(void))(**(void **)(*((void *)this + 6) + 3120) + 72))(*(void *)(*((void *)this + 6) + 3120));
        return CCLogStream::logAlert(v6, "[dk] %s@%d:link down detected. Bailing out\n", "forcePower", 1876);
      }
    }
  }
  else
  {
    uint64_t result = AppleBCMWLANChipBackplane::forcePowerLite(this, a2, a3);
    if ((result & 1) == 0) {
      AppleBCMWLANChipBackplane::forcePower();
    }
  }
  return result;
}

uint64_t AppleBCMWLANChipBackplane::sysmemReset(AppleBCMWLANChipBackplane *this, uint32_t a2)
{
  unint64_t v3 = *(AppleBCMWLANChipManagerPCIe **)(*((void *)this + 6) + 3120);
  if (v3 && AppleBCMWLANChipManagerPCIe::sysmemEnabled(v3))
  {
    ++*(_DWORD *)(*((void *)this + 6) + 808);
    uint64_t v5 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x16u);
    AppleBCMWLANChipBackplane::writeRegister32((uint64_t)this, v5, 0x800u, a2);
    IOSleep(2uLL);
    if (a2) {
      uint32_t v6 = 3;
    }
    else {
      uint32_t v6 = 1;
    }
    ++*(_DWORD *)(*((void *)this + 6) + 808);
    uint64_t v7 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x16u);
    AppleBCMWLANChipBackplane::writeRegister32((uint64_t)this, v7, 0x408u, v6);
    IOSleep(2uLL);
  }
  return 0;
}

uint64_t AppleBCMWLANChipBackplane::getRegionAccessCounters(AppleBCMWLANChipBackplane *this)
{
  return *((void *)this + 6);
}

uint64_t AppleBCMWLANChipBackplane::readPMNICBAPBWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 840);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x19u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

uint64_t AppleBCMWLANChipBackplane::readCommonSFLASHWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, unsigned int *a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 792);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x15u);
  return AppleBCMWLANChipBackplane::readRegister32(this, v6, a2, a3, 0);
}

uint64_t AppleBCMWLANChipBackplane::writeCommonCoreReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, uint32_t a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 412);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 0);
  return AppleBCMWLANChipBackplane::writeRegister32((uint64_t)this, v6, a2, a3);
}

uint64_t AppleBCMWLANChipBackplane::writePMUCoreReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, uint32_t a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 496);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 7u);
  return AppleBCMWLANChipBackplane::writeRegister32((uint64_t)this, v6, a2, a3);
}

uint64_t AppleBCMWLANChipBackplane::writeGCICoreReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, uint32_t a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 484);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapCore((uint64_t)this, 6u);
  return AppleBCMWLANChipBackplane::writeRegister32((uint64_t)this, v6, a2, a3);
}

uint64_t AppleBCMWLANChipBackplane::writeARMMasterWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, uint32_t a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 568);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 2u);
  return AppleBCMWLANChipBackplane::writeRegister32((uint64_t)this, v6, a2, a3);
}

uint64_t AppleBCMWLANChipBackplane::writeOOBRouterWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, uint32_t a3)
{
  ++*(_DWORD *)(*((void *)this + 6) + 760);
  uint64_t v6 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 0x12u);
  return AppleBCMWLANChipBackplane::writeRegister32((uint64_t)this, v6, a2, a3);
}

uint64_t AppleBCMWLANChipBackplane::waitARMMasterWrapperReg32(AppleBCMWLANChipBackplane *this, unsigned int a2, int a3, int a4, uint64_t a5)
{
  ++*(_DWORD *)(*((void *)this + 6) + 572);
  uint64_t v10 = AppleBCMWLANChipBackplane::mapWrapper((uint64_t)this, 2u);
  return AppleBCMWLANChipBackplane::waitForValue32(this, v10, a2, a3, a4, a5, 1);
}

uint64_t AppleBCMWLANChipBackplane::dumpARMCoreEnumerationRegistersFWDebug(uint64_t a1, void *a2, size_t a3, uint64_t a4, unint64_t a5)
{
  size_t v12 = a3;
  if (AppleBCMWLANChipManagerPCIe::getChipNumber(*(AppleBCMWLANChipManagerPCIe **)(*(void *)(a1 + 48)
                                                                                                + 3120)) == 4399)
    uint64_t v10 = "ARM Core 0x18080";
  else {
    uint64_t v10 = "ARM Core 0x18020";
  }
  bzero(a2, a3);
  return AppleBCMWLANChipBackplane::dumpCoreRegisters(a1, (uint64_t (*)(uint64_t, uint64_t, unsigned int *))AppleBCMWLANChipBackplane::readARMCoreReg32, v10, (uint64_t)a2, a3, &v12, a4, a5, 4);
}

uint64_t AppleBCMWLANChipBackplane::dumpCommonCoreEnumerationRegistersFWDebug(uint64_t a1, void *a2, size_t a3, uint64_t a4, unint64_t a5)
{
  size_t v11 = a3;
  bzero(a2, a3);
  return AppleBCMWLANChipBackplane::dumpCoreRegisters(a1, (uint64_t (*)(uint64_t, uint64_t, unsigned int *))AppleBCMWLANChipBackplane::readCommonCoreReg32, "Common Core 0x18000", (uint64_t)a2, a3, &v11, a4, a5, 4);
}

uint64_t AppleBCMWLANChipBackplane::dumpPMUCoreEnumerationRegistersFWDebug(uint64_t a1, void *a2, size_t a3, uint64_t a4, unint64_t a5)
{
  size_t v12 = a3;
  if (AppleBCMWLANChipManagerPCIe::getChipNumber(*(AppleBCMWLANChipManagerPCIe **)(*(void *)(a1 + 48)
                                                                                                + 3120)) == 4399)
    uint64_t v10 = "PMU Core 0x18018";
  else {
    uint64_t v10 = "PMU Core 0x18012";
  }
  bzero(a2, a3);
  return AppleBCMWLANChipBackplane::dumpCoreRegisters(a1, (uint64_t (*)(uint64_t, uint64_t, unsigned int *))AppleBCMWLANChipBackplane::readPMUCoreReg32, v10, (uint64_t)a2, a3, &v12, a4, a5, 4);
}

uint64_t AppleBCMWLANChipBackplane::dumpPCIEFunc0CoreEnumerationRegistersFWDebug(uint64_t a1, void *a2, size_t a3, uint64_t a4, unint64_t a5)
{
  size_t v11 = a3;
  bzero(a2, a3);
  return AppleBCMWLANChipBackplane::dumpCoreRegisters(a1, (uint64_t (*)(uint64_t, uint64_t, unsigned int *))AppleBCMWLANChipBackplane::readPCIeCoreReg32, "PCIe Func0 Core 0x18001", (uint64_t)a2, a3, &v11, a4, a5, 4);
}

void _GLOBAL__sub_I_AppleBCMWLANChipBackplane_cpp()
{
  kNullRange = 0;
}

OSObject *AppleBCMWLANCommandWithXTLV::withLengthAndHeader(AppleBCMWLANCommandWithXTLV *this, void *a2, void *a3, CCLogStream *a4, CCLogStream *a5)
{
  unsigned int v6 = a3;
  unsigned int v8 = this;
  size_t v11 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANCommandWithXTLVMetaClass, &v11)) {
    return 0;
  }
  uint32_t v9 = v11;
  if (v11 && (AppleBCMWLANCommandWithXTLV::initWithLengthAndHeader(v11, v8, a2, v6, a4) & 1) == 0)
  {
    ((void (*)(OSObject *))v9->release)(v9);
    return 0;
  }
  return v9;
}

uint64_t AppleBCMWLANCommandWithXTLV::initWithLengthAndHeader(OSObject *this, unsigned int a2, void *a3, unsigned int a4, CCLogStream *a5)
{
  if (a2 <= 3)
  {
    if (this[1].isEqualTo && CCLogStream::shouldLog()) {
      CCLogStream::logEmergency((CCLogStream *)this[1].isEqualTo, "[dk] %s@%d:length too large %d\n");
    }
    goto LABEL_30;
  }
  LODWORD(v7) = a4;
  if (a4 > a2)
  {
    if (!this[1].isEqualTo || !CCLogStream::shouldLog()) {
      goto LABEL_30;
    }
    isEqualTo = this[1].isEqualTo;
    goto LABEL_35;
  }
  if (!a3)
  {
    if (this[1].isEqualTo && CCLogStream::shouldLog()) {
      CCLogStream::logEmergency((CCLogStream *)this[1].isEqualTo, "[dk] %s@%d:invalid hdr\n");
    }
    goto LABEL_30;
  }
  uint64_t result = OSObject::init(this);
  if (!result) {
    return result;
  }
  uint64_t v11 = IOMallocZeroTyped();
  this[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)v11;
  if (!v11)
  {
    IOLog("Failed to allocate AppleBCMWLANCommandWithXTLV_IVars\n");
    goto LABEL_30;
  }
  *(_DWORD *)(v11 + 4) = a2;
  this[1].isEqualTo = (BOOL (__cdecl *)(const OSMetaClassBase *__hidden, const OSMetaClassBase *))a5;
  size_t v12 = this[1].isEqualTo;
  if (!v12)
  {
    IOLog("Bad logger\n");
    goto LABEL_30;
  }
  (*(void (**)(BOOL (__cdecl *)(const OSMetaClassBase *__hidden, const OSMetaClassBase *)))(*(void *)v12 + 8))(v12);
  this[1].retain = (void (__cdecl *)(const OSObject *__hidden))IOMallocZeroData();
  uint64_t v13 = this[1].OSMetaClassBase::__vftable;
  retain = v13->retain;
  if (!retain)
  {
    if (v13->isEqualTo && CCLogStream::shouldLog()) {
      CCLogStream::logEmergency((CCLogStream *)this[1].isEqualTo, "[dk] %s@%d:Bad fBuffer\n");
    }
    goto LABEL_30;
  }
  v13->release = retain;
  if (!v7)
  {
    uint64_t v7 = 0;
    goto LABEL_12;
  }
  uint32_t v15 = this[1].OSMetaClassBase::__vftable;
  if (HIDWORD(v15->getMetaClass) >= v7)
  {
    uint64_t v7 = v7;
    memcpy(v15->release, a3, v7);
LABEL_12:
    this[1].release = (void (__cdecl *)(const OSObject *__hidden))((char *)this[1].release + v7);
    return 1;
  }
  if (v15->isEqualTo && CCLogStream::shouldLog())
  {
    isEqualTo = this[1].isEqualTo;
LABEL_35:
    CCLogStream::logEmergency((CCLogStream *)isEqualTo, "[dk] %s@%d:hdr_length too large %d\n");
  }
LABEL_30:
  size_t v17 = this[1].OSMetaClassBase::__vftable;
  if (v17->retain)
  {
    IOFreeData();
    this[1].retain = 0;
    size_t v17 = this[1].OSMetaClassBase::__vftable;
  }
  HIDWORD(v17->getMetaClass) = 0;
  this[1].release = 0;
  uint64_t result = (uint64_t)this[1].isEqualTo;
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 16))(result);
    uint64_t result = 0;
    this[1].isEqualTo = 0;
  }
  return result;
}

uint64_t AppleBCMWLANCommandWithXTLV::addXTLV(AppleBCMWLANCommandWithXTLV *this, __int16 a2, size_t __n, const void *__src)
{
  uint64_t v4 = 3758097084;
  uint64_t v5 = *((void *)this + 5);
  unsigned int v6 = *(_WORD **)(v5 + 16);
  if ((uint64_t)v6 + __n - *(void *)(v5 + 8) + 4 <= *(unsigned int *)(v5 + 4))
  {
    _WORD *v6 = a2;
    v6[1] = __n;
    *(void *)(*((void *)this + 5) + 16) += 4;
    if (__n)
    {
      unsigned int v8 = (AppleBCMWLANUtil *)__n;
      memcpy(*(void **)(*((void *)this + 5) + 16), __src, __n);
      uint64_t v11 = 0;
      if (!AppleBCMWLANUtil::safe_align_up(v8, 4, &v11, v9))
      {
        uint64_t v4 = 0;
        *(void *)(*((void *)this + 5) + 16) += v11;
      }
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

uint64_t AppleBCMWLANCommandWithXTLV::complete(AppleBCMWLANCommandWithXTLV *this)
{
  uint64_t v1 = *((void *)this + 5);
  uint64_t v3 = *(void *)(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    __int16 v4 = v2 - v3;
  }
  else {
    __int16 v4 = 0;
  }
  *(_WORD *)(v3 + 2) = v4;
  return 0;
}

uint64_t AppleBCMWLANCommandWithXTLV::getCommandLength(AppleBCMWLANCommandWithXTLV *this)
{
  uint64_t v1 = *((void *)this + 5);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    LODWORD(v2) = v2 - *(_DWORD *)(v1 + 8);
  }
  return (unsigned __int16)v2;
}

uint64_t AppleBCMWLANCommandWithXTLV::freeResources(AppleBCMWLANCommandWithXTLV *this)
{
  uint64_t v2 = *((void *)this + 5);
  if (*(void *)(v2 + 8))
  {
    IOFreeData();
    *(void *)(*((void *)this + 5) + 8) = 0;
    *(void *)(*((void *)this + 5) + 16) = 0;
    uint64_t v2 = *((void *)this + 5);
  }
  uint64_t result = *(void *)(v2 + 24);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
    *(void *)(*((void *)this + 5) + 24) = 0;
  }
  return result;
}

void AppleBCMWLANCommandWithXTLV::free(void **this)
{
  if (this[5])
  {
    AppleBCMWLANCommandWithXTLV::freeResources((AppleBCMWLANCommandWithXTLV *)this);
    memset_s(this[5], 0x20uLL, 0, 0x20uLL);
    uint64_t v2 = this[5];
    if (v2)
    {
      IOFree(v2, 0x20uLL);
      this[5] = 0;
    }
  }
  OSObject::free((OSObject *)this);
}

void non-virtual thunk to'AppleBCMWLANCommandWithXTLV::free(void **this)
{
}

uint64_t AppleBCMWLANUtil::isPTPPacket(AppleBCMWLANUtil *this, AppleBCMWLANPCIeSkywalkPacket *a2, char *a3, unsigned __int8 *a4, unsigned __int8 **a5, unsigned __int8 **a6, unsigned __int8 *a7, unsigned __int16 *a8)
{
  int v13 = (int)a2;
  unsigned int v15 = (*(uint64_t (**)(AppleBCMWLANUtil *, AppleBCMWLANPCIeSkywalkPacket *, char *, unsigned __int8 *, unsigned __int8 **, unsigned __int8 **, unsigned __int8 *, unsigned __int16 *))(*(void *)this + 240))(this, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v16 = (*(uint64_t (**)(AppleBCMWLANUtil *))(*(void *)this + 480))(this);
  unsigned int v17 = (*(uint64_t (**)(AppleBCMWLANUtil *))(*(void *)this + 224))(this);
  if (v17 < 0x11) {
    return 0;
  }
  uint64_t v18 = v16 + v15;
  uint64_t v19 = v17;
  unsigned int v20 = bswap32(*(unsigned __int16 *)(v18 + 12)) >> 16;
  if (*(unsigned __int8 *)(v18 + 14) != 170 || *(unsigned __int8 *)(v18 + 15) != 170 || *(unsigned char *)(v18 + 16) != 3)
  {
    uint64_t v21 = 14;
    goto LABEL_9;
  }
  if (v17 < 0x16) {
    return 0;
  }
  if (*(unsigned char *)(v18 + 17)) {
    goto LABEL_7;
  }
  if (*(unsigned char *)(v18 + 18) != 23)
  {
    if (!*(unsigned char *)(v18 + 18) && !*(unsigned char *)(v18 + 19)) {
      unsigned int v20 = bswap32(*(unsigned __int16 *)(v18 + 20)) >> 16;
    }
    goto LABEL_7;
  }
  if (*(unsigned __int8 *)(v18 + 19) != 242)
  {
LABEL_7:
    uint64_t v21 = 22;
    goto LABEL_9;
  }
  int v36 = *(unsigned __int8 *)(v18 + 26);
  if (*(unsigned char *)(v18 + 26))
  {
    uint64_t v37 = 6;
    while (v37 + 25 <= (unint64_t)v17)
    {
      v37 += 2 + *(unsigned __int8 *)(v18 + 23 + v37 + 2);
      if (!--v36) {
        goto LABEL_44;
      }
    }
    return 0;
  }
  uint64_t v37 = 6;
LABEL_44:
  unsigned int v20 = bswap32(*(unsigned __int16 *)(v37 + v18 + 22)) >> 16;
  uint64_t v21 = v37 + 24;
LABEL_9:
  if (v20 != 34525 && v20 != 2048) {
    return 0;
  }
  uint64_t v22 = v18 + v21;
  if (v20 == 34525)
  {
    uint64_t v23 = v21 + 48;
    if (v21 + 48 <= (unint64_t)v17 && *(unsigned char *)(v22 + 6) == 17)
    {
      char v25 = 1;
      uint64_t v26 = 40;
      goto LABEL_18;
    }
    return 0;
  }
  uint64_t v23 = v21 + 28;
  if (v21 + 28 > (unint64_t)v17) {
    return 0;
  }
  uint64_t result = 0;
  if (*(unsigned char *)(v22 + 9) != 17) {
    return result;
  }
  char v25 = 0;
  uint64_t v26 = 20;
LABEL_18:
  *a3 = v25;
  if ((unint64_t)(v19 - v23) < 0x22) {
    return 0;
  }
  uint64_t v27 = v22 + v26;
  unsigned int v28 = __rev16(*(unsigned __int16 *)(v22 + v26));
  if (v28 - 321 < 0xFFFFFFFE) {
    return 0;
  }
  unsigned int v29 = *(unsigned __int16 *)(v27 + 2);
  unsigned int v30 = bswap32(v29);
  unsigned int v31 = __rev16(v29) - 319;
  if (v28 != HIWORD(v30) || v31 > 1) {
    return 0;
  }
  if (v13)
  {
    *(void *)a4 = v18;
    BOOL v33 = *a3 == 0;
    uint64_t v34 = 24;
    uint64_t v35 = 16;
  }
  else
  {
    *(void *)a4 = v18 + 6;
    BOOL v33 = *a3 == 0;
    uint64_t v34 = 8;
    uint64_t v35 = 12;
  }
  if (v33) {
    uint64_t v34 = v35;
  }
  *a5 = (unsigned __int8 *)(v22 + v34);
  *(unsigned char *)a6 = *(unsigned char *)(v27 + 8) & 0xF;
  *(_WORD *)a7 = bswap32(*(unsigned __int16 *)(v27 + 38)) >> 16;
  return 1;
}

uint64_t AppleBCMWLANUtil::removeReporterFromLegend(IOService *this, IOService *a2, IOReporter *a3, char *a4, const char *a5)
{
  unsigned int v6 = (const char *)a3;
  uint64_t v9 = 3758097136;
  BOOL v10 = a2 == 0;
  if (a3) {
    BOOL v11 = a4 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  BOOL v12 = !v11 && a2 == 0;
  property = 0;
  if (IOService::SearchProperty(this, "IOReportLegend", "IOService", 1uLL, &property, 0)) {
    return v9;
  }
  BOOL v56 = v12;
  int v13 = OSMetaClassBase::safeMetaCast(property, gOSObjectMetaClass);
  if (!v13) {
    return v9;
  }
  __int16 v14 = v13;
  unsigned int v15 = OSMetaClassBase::safeMetaCast(v13, gOSArrayMetaClass);
  if (!v15
    || (uint64_t v54 = (const OSArray *)v15,
        uint32_t v16 = ((uint64_t (*)(void))v15->__vftable[2].getMetaClass)(),
        uint64_t v9 = 3758097085,
        (OSArrayPtr v57 = OSArray::withCapacity(v16)) == 0))
  {
    OSArrayPtr v22 = (OSArrayPtr)v14;
    goto LABEL_48;
  }
  if (a2)
  {
    Legend = (const OSDictionary *)IOReporter::createLegend((IOReporter *)a2);
    if (Legend)
    {
      uint64_t v18 = Legend;
      unsigned int v49 = v14;
      int v50 = this;
      uint64_t v55 = a2;
      cString = a4;
      Object = OSDictionary::getObject(Legend, "IOReportChannels");
      unsigned int v20 = (const OSArray *)OSMetaClassBase::safeMetaCast(Object, gOSArrayMetaClass);
      uint64_t v48 = v18;
      uint64_t v21 = OSDictionary::getObject(v18, "IOReportChannelInfo");
      anObject = OSMetaClassBase::safeMetaCast(v21, gOSDictionaryMetaClass);
      goto LABEL_16;
    }
    ((void (*)(OSMetaClassBase *))v14->release)(v14);
    OSArrayPtr v22 = v57;
LABEL_48:
    ((void (*)(OSArrayPtr))v22->release)(v22);
    return v9;
  }
  unsigned int v49 = v14;
  int v50 = this;
  uint64_t v55 = 0;
  cString = a4;
  uint64_t v48 = 0;
  unsigned int v20 = 0;
  anObject = 0;
LABEL_16:
  uint64_t v23 = v54;
  BOOL v24 = v56;
  if (((unsigned int (*)(const OSArray *))v54->getCount)(v54))
  {
    uint32_t v25 = 0;
    int v58 = v10 ^ v56;
    int v52 = v6;
    do
    {
      uint64_t v26 = OSArray::getObject(v23, v25);
      uint64_t v27 = (const OSDictionary *)OSMetaClassBase::safeMetaCast(v26, gOSDictionaryMetaClass);
      unsigned int v28 = OSDictionary::getObject(v27, "IOReportGroupName");
      unsigned int v29 = (const OSString *)OSMetaClassBase::safeMetaCast(v28, gOSStringMetaClass);
      unsigned int v30 = OSDictionary::getObject(v27, "IOReportSubGroupName");
      unsigned int v31 = (const OSString *)OSMetaClassBase::safeMetaCast(v30, gOSStringMetaClass);
      unint64_t v59 = &v27->OSCollection;
      int v32 = OSDictionary::getObject(v27, "IOReportChannels");
      BOOL v33 = (const OSArray *)OSMetaClassBase::safeMetaCast(v32, gOSArrayMetaClass);
      BOOL v61 = 1;
      OSDictionaryPtr v60 = OSDictionary::withCapacity(1u);
      if (v58) {
        BOOL v61 = !OSString::isEqualTo(v29, v6);
      }
      if (v24)
      {
        if (OSString::isEqualTo(v29, v6))
        {
          OSDictionaryPtr v34 = v60;
          if ((v61 & ~OSString::isEqualTo(v31, cString) & 1) == 0) {
            goto LABEL_42;
          }
        }
        else
        {
          OSDictionaryPtr v34 = v60;
          if (!v61) {
            goto LABEL_42;
          }
        }
      }
      else if (v55)
      {
        OSDictionary::setObject(v60, "IOReportGroupName", v29);
        OSDictionary::setObject(v60, "IOReportSubGroupName", v31);
        OSDictionary::setObject(v60, "IOReportChannelInfo", anObject);
        uint64_t v35 = OSArray::withCapacity(1u);
        if (((unsigned int (*)(const OSArray *))v33->getCount)(v33))
        {
          uint32_t v36 = 0;
          do
          {
            uint64_t v37 = OSArray::getObject(v33, v36);
            unint64_t v38 = (const OSArray *)OSMetaClassBase::safeMetaCast(v37, gOSArrayMetaClass);
            unsigned int v39 = OSArray::getObject(v38, 0);
            uint64_t v40 = (const OSNumber *)OSMetaClassBase::safeMetaCast(v39, gOSNumberMetaClass);
            if (((unsigned int (*)(const OSArray *))v20->getCount)(v20))
            {
              uint32_t v41 = 0;
              while (1)
              {
                uint64_t v42 = OSArray::getObject(v20, v41);
                int64_t v43 = (const OSArray *)OSMetaClassBase::safeMetaCast(v42, gOSArrayMetaClass);
                unint64_t v44 = OSArray::getObject(v43, 0);
                char v45 = (const OSNumber *)OSMetaClassBase::safeMetaCast(v44, gOSNumberMetaClass);
                if (OSNumber::isEqualTo(v40, v45)) {
                  break;
                }
                if (++v41 >= ((unsigned int (*)(const OSArray *))v20->getCount)(v20)) {
                  goto LABEL_31;
                }
              }
            }
            else
            {
LABEL_31:
              OSArray::setObject(v35, v38);
            }
            ++v36;
          }
          while (v36 < ((unsigned int (*)(const OSArray *))v33->getCount)(v33));
        }
        if (((unsigned int (*)(OSArray *))v35->getCount)(v35))
        {
          OSDictionaryPtr v34 = v60;
          OSDictionary::setObject(v60, "IOReportChannels", v35);
          unint64_t v59 = v60;
          unsigned int v6 = v52;
          BOOL v24 = v56;
          uint64_t v23 = v54;
          BOOL v46 = v61;
        }
        else
        {
          BOOL v46 = 0;
          unsigned int v6 = v52;
          BOOL v24 = v56;
          uint64_t v23 = v54;
          OSDictionaryPtr v34 = v60;
        }
        ((void (*)(OSArray *))v35->release)(v35);
        if (!v46) {
          goto LABEL_42;
        }
      }
      else
      {
        OSDictionaryPtr v34 = v60;
        if (!v61) {
          goto LABEL_42;
        }
      }
      OSArray::setObject(v57, v59);
LABEL_42:
      if (v34) {
        ((void (*)(OSDictionaryPtr))v34->release)(v34);
      }
      ++v25;
    }
    while (v25 < ((unsigned int (*)(const OSArray *))v23->getCount)(v23));
  }
  IOService::SetLegend(v50, v57, 1, 0);
  ((void (*)(OSMetaClassBase *))v49->release)(v49);
  ((void (*)(OSArrayPtr))v57->release)(v57);
  uint64_t v9 = 0;
  OSArrayPtr v22 = (OSArrayPtr)v48;
  if (v48) {
    goto LABEL_48;
  }
  return v9;
}

uint64_t AppleBCMWLANUtil::getDTParameter32(IOService *this, IOService *a2, const char *arg_string, const char *a4)
{
  unsigned int v4 = a4;
  unsigned int v12 = a4;
  if (!IOParseBootArgNumber(arg_string, &v12, 4))
  {
    unsigned int v12 = v4;
    property = 0;
    IOService::SearchProperty(this, arg_string, (const char *)a2, 1uLL, &property, 0);
    unsigned int v8 = (const OSData *)OSMetaClassBase::safeMetaCast(property, gOSDataMetaClass);
    if (v8)
    {
      uint64_t BytesNoCopy = (unsigned int *)OSData::getBytesNoCopy(v8, 0, 4uLL);
      if (BytesNoCopy) {
        unsigned int v12 = *BytesNoCopy;
      }
    }
    if (property) {
      ((void (*)(OSContainer *))property->release)(property);
    }
  }
  return v12;
}

const char *AppleBCMWLANUtil::copyDTParameterString(IOService *this, IOService *plane, const char *name, const char *a4, OSString *a5)
{
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  *(_OWORD *)BOOL v11 = 0u;
  long long v12 = 0u;
  property = 0;
  IOService::SearchProperty(this, name, (const char *)plane, 1uLL, &property, 0);
  uint64_t v7 = (const OSData *)OSMetaClassBase::safeMetaCast(property, gOSDataMetaClass);
  if (IOParseBootArgString(name, v11, 255))
  {
    uint64_t BytesNoCopy = v11;
LABEL_5:
    a4 = (const char *)OSString::withCString(BytesNoCopy);
    goto LABEL_8;
  }
  if (v7)
  {
    uint64_t BytesNoCopy = (const char *)OSData::getBytesNoCopy(v7);
    if (BytesNoCopy) {
      goto LABEL_5;
    }
  }
  if (a4) {
    (*(void (**)(const char *))(*(void *)a4 + 8))(a4);
  }
LABEL_8:
  if (property) {
    ((void (*)(OSContainer *))property->release)(property);
  }
  return a4;
}

AppleBCMWLANUtil *AppleBCMWLANUtil::findpattern(AppleBCMWLANUtil *this, const char *__s, const char *a3)
{
  unsigned int v4 = __s + 1;
  int v5 = *(unsigned __int8 *)__s;
  if (*__s)
  {
    size_t v7 = strlen(__s + 1);
    for (unsigned int i = a3 - 1; i != (const char *)-1; --i)
    {
      if (*(unsigned __int8 *)this == v5)
      {
        if (v7 > (unint64_t)i) {
          return 0;
        }
        if (!strncmp((const char *)this + 1, v4, v7)) {
          return this;
        }
      }
      this = (AppleBCMWLANUtil *)((char *)this + 1);
    }
    return 0;
  }
  return this;
}

BOOL AppleBCMWLANUtil::matchIESignature(unsigned __int8 *a1, int a2, unsigned __int8 *a3)
{
  if (*a3 != *a1) {
    return 0;
  }
  if (a2 == 1) {
    return 1;
  }
  return bcmp(a1 + 1, a3 + 2, (a2 - 1)) == 0;
}

void *AppleBCMWLANUtil::releaseOSObjectArray(void *this, const OSString **a2, const OSObject **a3)
{
  if (a3)
  {
    unsigned int v4 = this;
    uint64_t v5 = a3;
    do
    {
      if (*v4)
      {
        (*(void (**)(void))(*(void *)*v4 + 16))(*v4);
        *unsigned int v4 = 0;
      }
      this = *a2;
      if (*a2)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 16))(this);
        *a2 = 0;
      }
      ++v4;
      ++a2;
      --v5;
    }
    while (v5);
  }
  return this;
}

unsigned __int16 *AppleBCMWLANUtil::getCounterValueSafe(AppleBCMWLANUtil *this, int *a2, OSData *a3, size_t start)
{
  int v4 = start;
  size_t v8 = start;
  size_t v9 = a2;
  if (((a2 - 1) & OSData::getBytesNoCopy(a3, start, a2)) != 0) {
    IOLog("cnt->getBytesNoCopy not aligned offset %d sizeOfRead %zd ", v4, (size_t)a2);
  }
  if (a2 == (int *)2)
  {
    uint64_t result = (unsigned __int16 *)OSData::getBytesNoCopy(a3, v8, v9);
    if (result) {
      return (unsigned __int16 *)*result;
    }
  }
  else
  {
    if (a2 != (int *)4)
    {
      IOLog("APPLE80211_DRIVERKIT getCounterValueSafe is not supported for uint64_t\n");
      return 0;
    }
    uint64_t result = (unsigned __int16 *)OSData::getBytesNoCopy(a3, v8, v9);
    if (result) {
      return (unsigned __int16 *)*(unsigned int *)result;
    }
  }
  *(_DWORD *)this = -536870169;
  return result;
}

uint64_t AppleBCMWLANUtil::safe_align_up(AppleBCMWLANUtil *this, uint64_t a2, void *a3, unint64_t *a4)
{
  uint64_t result = 3758097084;
  if (!this)
  {
    if (!a2) {
      return result;
    }
    goto LABEL_4;
  }
  if (a2)
  {
    unint64_t v6 = ((unint64_t)this - 1) & -a2;
    BOOL v7 = __CFADD__(a2, v6);
    a2 += v6;
    if (!v7)
    {
LABEL_4:
      uint64_t result = 0;
      *a3 = a2;
    }
  }
  return result;
}

uint64_t AppleBCMWLANUtil::get_mach_continuous_nanoseconds(AppleBCMWLANUtil *this, unint64_t *a2)
{
  mach_continuous_time();
  absolutetime_to_nanoseconds();
  uint64_t result = 0xAAAAAAAAAAAAAAAALL;
  if (this) {
    *(void *)this = 0xAAAAAAAAAAAAAAAALL;
  }
  return result;
}

uint64_t AppleBCMWLANUtil::appendParsedKeyValuePairsToDictionary(OSDictionary *this, const OSString *a2, const OSString *a3)
{
  unsigned int v3 = a3;
  if (OSString::getLength(a2) >= a3) {
    size_t Length = v3;
  }
  else {
    size_t Length = OSString::getLength(a2);
  }
  unint64_t v6 = (void *)IOMallocZeroData();
  if (v6) {
    unint64_t v7 = Length + 1;
  }
  else {
    unint64_t v7 = 0;
  }
  unint64_t v32 = v7;
  uint64_t v8 = IOMallocZeroData();
  if (v8) {
    unint64_t v9 = Length + 1;
  }
  else {
    unint64_t v9 = 0;
  }
  __dst = (void *)v8;
  if (v6)
  {
    if (!v8)
    {
      uint64_t v23 = 3758097085;
      goto LABEL_49;
    }
    if (!Length)
    {
      uint64_t v23 = 0;
      goto LABEL_48;
    }
    unsigned int v29 = v6;
    uint64_t v10 = 0;
    unsigned int v11 = 0;
    unint64_t v30 = v9;
    do
    {
      if (OSString::getCStringNoCopy(a2)[v10] == 32)
      {
        ++v11;
      }
      else
      {
        BOOL v12 = Length >= v11;
        unsigned int v13 = 0;
        if (Length > v11)
        {
          size_t v14 = v11;
          while (OSString::getCStringNoCopy(a2)[v14] != 61)
          {
            size_t v14 = ++v13 + v11;
            BOOL v12 = Length >= v14;
            if (Length < v14 || Length == v14)
            {
              v11 += v13;
              goto LABEL_25;
            }
          }
          v11 += v13;
          BOOL v12 = 1;
        }
LABEL_25:
        size_t v16 = v11 + 1;
        BOOL v17 = Length >= v16;
        if (Length > v16)
        {
          int v18 = 0;
          size_t v19 = v11 + 1;
          while (OSString::getCStringNoCopy(a2)[v19] != 32)
          {
            unsigned int v21 = v18 + 1;
            size_t v19 = v11 + v18 + 2;
            BOOL v17 = Length >= v19;
            BOOL v20 = Length >= v19 && Length != v19;
            ++v18;
            if (!v20)
            {
              v11 += v21 + 1;
              goto LABEL_35;
            }
          }
          v11 += v18 + 1;
          BOOL v17 = 1;
          unsigned int v21 = v18;
LABEL_35:
          unint64_t v6 = v29;
        }
        else
        {
          unsigned int v21 = 0;
          ++v11;
        }
        int v22 = v17 && v12;
        uint64_t v23 = 3758097105;
        if (v22 != 1 || Length <= v16) {
          goto LABEL_44;
        }
        bzero(v6, v32);
        bzero(__dst, v30);
        CStringNoCopy = OSString::getCStringNoCopy(a2);
        if (v32 < v13) {
          AppleBCMWLANUtil::appendParsedKeyValuePairsToDictionary();
        }
        memcpy(v6, &CStringNoCopy[v10], v13);
        long long v25 = OSString::getCStringNoCopy(a2);
        if (v30 < v21) {
          AppleBCMWLANUtil::appendParsedKeyValuePairsToDictionary();
        }
        memcpy(__dst, &v25[v16], v21);
        OSStringPtr v26 = OSString::withCString((const char *)__dst);
        if (!v26) {
          goto LABEL_51;
        }
        OSStringPtr v27 = v26;
        OSDictionary::setObject(this, (const char *)v6, v26);
        ((void (*)(OSStringPtr))v27->release)(v27);
      }
      uint64_t v10 = v11;
    }
    while (Length > v11);
    uint64_t v23 = 0;
  }
  else
  {
LABEL_51:
    uint64_t v23 = 3758097085;
  }
LABEL_44:
  if (!__dst)
  {
    if (!v6) {
      return v23;
    }
    goto LABEL_49;
  }
LABEL_48:
  IOFreeData();
  if (v6) {
LABEL_49:
  }
    IOFreeData();
  return v23;
}

uint64_t AppleBCMWLANUtil::getHwFeatureFlags(IOService *this, IOService *a2, const char *a3)
{
  if (!this || !a2) {
    return 0;
  }
  int DTParameter32 = AppleBCMWLANUtil::getDTParameter32(this, a2, "wlan.hw.feature-flags.set", 0);
  unint64_t v6 = (const char *)(DTParameter32 & ~AppleBCMWLANUtil::getDTParameter32(this, a2, "wlan.hw.feature-flags.clr", 0));
  return AppleBCMWLANUtil::getDTParameter32(this, a2, "wlan.hw.feature-flags", v6);
}

const OSString *AppleBCMWLANUtil::doesDictionaryKeyContainString(const OSDictionary *this, OSDictionary *a2, const char *a3, const char *a4)
{
  uint64_t result = 0;
  if (this)
  {
    if (a2)
    {
      if (a3)
      {
        uint64_t result = (const OSString *)((uint64_t (*)(const OSDictionary *))this->getCount)(this);
        if (result)
        {
          Object = OSDictionary::getObject(this, (const char *)a2);
          uint64_t result = (const OSString *)OSMetaClassBase::safeMetaCast(Object, gOSStringMetaClass);
          if (result)
          {
            uint64_t v10 = result;
            uint64_t result = (const OSString *)OSString::getCStringNoCopy(result);
            if (result)
            {
              size_t Length = (const char *)OSString::getLength(v10);
              if (a4)
              {
                if (Length > a4)
                {
LABEL_11:
                  CStringNoCopy = OSString::getCStringNoCopy(v10);
                  return (const OSString *)(strnstr(CStringNoCopy, a3, (size_t)a4) != 0);
                }
                size_t Length = (const char *)OSString::getLength(v10);
              }
              a4 = Length;
              if (!Length) {
                return 0;
              }
              goto LABEL_11;
            }
          }
        }
      }
    }
  }
  return result;
}

const OSString *AppleBCMWLANUtil::doesDictionaryKeyEqualString(const OSDictionary *this, OSDictionary *a2, const char *a3, const char *a4)
{
  uint64_t result = 0;
  if (this)
  {
    if (a2)
    {
      if (a3)
      {
        uint64_t result = (const OSString *)((uint64_t (*)(const OSDictionary *))this->getCount)(this);
        if (result)
        {
          Object = OSDictionary::getObject(this, (const char *)a2);
          uint64_t result = (const OSString *)OSMetaClassBase::safeMetaCast(Object, gOSStringMetaClass);
          if (result)
          {
            uint64_t v10 = result;
            uint64_t result = (const OSString *)OSString::getCStringNoCopy(result);
            if (result)
            {
              size_t Length = (const char *)OSString::getLength(v10);
              if (a4)
              {
                if (Length > a4)
                {
LABEL_11:
                  CStringNoCopy = OSString::getCStringNoCopy(v10);
                  return (const OSString *)(strncmp(CStringNoCopy, a3, (size_t)a4) == 0);
                }
                size_t Length = (const char *)OSString::getLength(v10);
              }
              a4 = Length;
              if (!Length) {
                return 0;
              }
              goto LABEL_11;
            }
          }
        }
      }
    }
  }
  return result;
}

BOOL AppleBCMWLANUtil::AutoreleasedTimeTrace::setMarkTimestamp(AppleBCMWLANTimeTrace **this, uint64_t a2)
{
  uint64_t v2 = *this;
  if (*this) {
    AppleBCMWLANTimeTrace::setMarkTimestamp(*this, a2);
  }
  return v2 != 0;
}

uint64_t AppleBCMWLANUtil::AutoreleasedTimeTrace::recordTraceWithTimestamp(AppleBCMWLANTimeTrace **this, unint64_t *a2, uint64_t a3, uint64_t a4, const char *a5, ...)
{
  va_start(va, a5);
  if (*this) {
    return AppleBCMWLANTimeTrace::recordTracevWithTimestamp(*this, a2, a3, a4, a5, va);
  }
  else {
    return 0;
  }
}

uint64_t AppleBCMWLANUtil::AutoreleasedTimeTrace::recordTraceFromMarkTimestamp(AppleBCMWLANTimeTrace **this, unint64_t *a2, uint64_t a3, const char *a4, ...)
{
  va_start(va, a4);
  if (*this) {
    return AppleBCMWLANTimeTrace::recordTracevFromMarkTimestamp(*this, a2, a3, a4, va);
  }
  else {
    return 0;
  }
}

uint64_t AppleBCMWLANUtil::AutoreleasedTimeTrace::timeTraceCallback(void *a1, uint64_t a2)
{
  if (a1 && a2 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v3 = a1[1];
    unint64_t v4 = a1[2];
    uint64_t v5 = a1[3];
    uint64_t v6 = a1[4];
    int v8 = 134219522;
    unint64_t v9 = v3 / 0x3B9ACA00;
    __int16 v10 = 2048;
    unint64_t v11 = v3 % 0x3B9ACA00;
    __int16 v12 = 2048;
    unint64_t v13 = v4 / 0x3B9ACA00;
    __int16 v14 = 2048;
    unint64_t v15 = v4 % 0x3B9ACA00;
    __int16 v16 = 2048;
    uint64_t v17 = v5;
    __int16 v18 = 2048;
    uint64_t v19 = v6;
    __int16 v20 = 2080;
    unsigned int v21 = a1 + 5;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "OSLog: AutoreleasedTimeTrace: logged@[%016llu.%09llu] trace@[%016llu.%09llu] type[0x%016llx] tag[0x%016llx] log['%s']\n", (uint8_t *)&v8, 0x48u);
  }
  return 0;
}

BOOL AppleBCMWLANUtil::AutoreleasedTimeTrace::dumpToLog(AppleBCMWLANUtil::AutoreleasedTimeTrace *this, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = *(void *)this;
  if (*(void *)this) {
    AppleBCMWLANTimeTrace::iterate(*(void *)this, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))AppleBCMWLANUtil::AutoreleasedTimeTrace::timeTraceCallback, a2, (uint64_t)this, a3, 0);
  }
  return v3 != 0;
}

const char *getLogLevelName(int a1)
{
  switch(a1)
  {
    case -1:
      uint64_t result = "LogLevelNone";
      break;
    case 0:
      uint64_t result = "LogLevelEmergency";
      break;
    case 1:
      uint64_t result = "LogLevelAlert";
      break;
    case 2:
      uint64_t result = "LogLevelCritical";
      break;
    case 3:
      uint64_t result = "LogLevelWarning";
      break;
    case 4:
      uint64_t result = "LogLevelNotice";
      break;
    case 5:
      uint64_t result = "LogLevelInfo";
      break;
    case 6:
      uint64_t result = "LogLevelDebug";
      break;
    case 7:
      uint64_t result = "LogLevelSpam";
      break;
    default:
      if (a1 == 127) {
        uint64_t result = "LogLevelAll";
      }
      else {
        uint64_t result = (const char *)&unk_10029A2CA;
      }
      break;
  }
  return result;
}

const char *cmdID2Name(int a1)
{
  uint64_t v2 = 0;
  uint64_t result = "<unknown ioctl>";
  while (dCmds[v2] != a1)
  {
    v2 += 4;
    if (v2 == 232) {
      return result;
    }
  }
  return *(const char **)&dCmds[v2 + 2];
}

const char *convertEventToString(int a1, char *__dst, size_t __size)
{
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  do
  {
    if (kEventBitMapping[v4] == a1) {
      uint64_t v5 = *(const char **)&kEventBitMapping[v4 + 2];
    }
    v4 += 4;
  }
  while (v4 != 472);
  if (__size && __dst && !v5)
  {
    snprintf(__dst, __size, "unknown event (%u)", a1);
  }
  else if (__size && __dst && v5)
  {
    strlcpy(__dst, v5, __size);
  }
  else if (v5)
  {
    return v5;
  }
  else
  {
    return "unknown event";
  }
  return __dst;
}

uint64_t convertStringToEvent(const char *a1)
{
  uint64_t v2 = 0;
  while (1)
  {
    size_t v3 = strlen(*(const char **)&kEventBitMapping[v2 + 2]);
    if (!strncmp(*(const char **)&kEventBitMapping[v2 + 2], a1, v3)) {
      break;
    }
    v2 += 4;
    if (v2 == 472) {
      return 0xFFFFFFFFLL;
    }
  }
  return kEventBitMapping[v2];
}

uint64_t convertAdditionalEventToString(int a1)
{
  uint64_t v1 = 0;
  for (char i = 1; ; char i = 0)
  {
    char v3 = i;
    if (kAdditionalEventBitMapping[4 * v1] == a1) {
      break;
    }
    uint64_t v1 = 1;
    if ((v3 & 1) == 0) {
      return 0;
    }
  }
  return *(void *)&kAdditionalEventBitMapping[4 * v1 + 2];
}

uint64_t stringFromReason(int a1, int a2)
{
  uint64_t result = 0;
  if (a1 <= 22)
  {
    if (a1 == 16)
    {
      uint64_t v4 = (char *)&kLinkMapping;
      uint64_t v5 = 5;
    }
    else
    {
      if (a1 != 19) {
        return result;
      }
      uint64_t v4 = (char *)&kRoamMapping;
      uint64_t v5 = 20;
    }
  }
  else
  {
    switch(a1)
    {
      case 23:
        uint64_t v4 = (char *)&kPruneMapping;
        uint64_t v5 = 32;
        break;
      case 188:
        uint64_t v4 = (char *)&kBcnMuteReasonMapping;
        uint64_t v5 = 4;
        break;
      case 46:
        uint64_t v4 = (char *)&kSupplicantMapping;
        uint64_t v5 = 16;
        break;
      default:
        return result;
    }
  }
  for (char i = v4 + 8; *((_DWORD *)i - 2) != a2; i += 16)
  {
    if (!--v5) {
      return 0;
    }
  }
  return *(void *)i;
}

const char *stringFromStatusInEvent(unsigned int a1, int a2)
{
  if (a2 == 46)
  {
    uint64_t v2 = (char *)&KSupplicantStatus;
    uint64_t v3 = 15;
LABEL_5:
    uint64_t v4 = (_UNKNOWN **)(v2 + 8);
    while (*((_DWORD *)v4 - 2) != a1)
    {
      v4 += 2;
      if (!--v3) {
        goto LABEL_8;
      }
    }
    return (const char *)*v4;
  }
  if (a2 == 188)
  {
    uint64_t v2 = (char *)&kBcnMuteStatusMapping;
    uint64_t v3 = 14;
    goto LABEL_5;
  }
LABEL_8:
  if (a1 <= 0x10)
  {
    uint64_t v4 = &off_100390928 + (int)a1;
    return (const char *)*v4;
  }
  return "UNKNOWN!!";
}

BOOL AppleBCMWLAN_isVerboseDebugLoggingAllowed(void)
{
  if ((AppleBCMWLAN_isVerboseDebugLoggingAllowed(void)::checked & 1) == 0)
  {
    AppleBCMWLAN_isVerboseDebugLoggingAllowed(void)::debuggable |= AppleBCMWLAN_isDevFusedOrCSRInternal();
    IOParseBootArgNumber("wlan.debug.enable", &AppleBCMWLAN_isVerboseDebugLoggingAllowed(void)::debuggable, 4);
    AppleBCMWLAN_isVerboseDebugLoggingAllowed(void)::checked = 1;
  }
  return AppleBCMWLAN_isVerboseDebugLoggingAllowed(void)::debuggable != 0;
}

BOOL AppleBCMWLAN_isDevFusedOrCSRInternal(void)
{
  if ((AppleBCMWLAN_isDevFusedOrCSRInternal(void)::checked & 1) == 0)
  {
    AppleBCMWLAN_isDevFusedOrCSRInternal(void)::isDev = isDevFusedOrCSRInternal();
    IOParseBootArgNumber("v3.internal", &AppleBCMWLAN_isDevFusedOrCSRInternal(void)::isDev, 4);
    AppleBCMWLAN_isDevFusedOrCSRInternal(void)::checked = 1;
  }
  return AppleBCMWLAN_isDevFusedOrCSRInternal(void)::isDev == 1;
}

BOOL AppleBCMWLAN_isSoCRAMCaptureAllowed(void)
{
  if ((AppleBCMWLAN_isSoCRAMCaptureAllowed(void)::checked & 1) == 0)
  {
    AppleBCMWLAN_isSoCRAMCaptureAllowed(void)::debuggable |= AppleBCMWLAN_isDevFusedOrCSRInternal();
    IOParseBootArgNumber("wlan.debug.enable", &AppleBCMWLAN_isSoCRAMCaptureAllowed(void)::debuggable, 4);
    AppleBCMWLAN_isSoCRAMCaptureAllowed(void)::checked = 1;
  }
  return AppleBCMWLAN_isSoCRAMCaptureAllowed(void)::debuggable != 0;
}

uint64_t AppleBCMWLAN_isDebugCommandActionAllowed(void)
{
  return IO80211_isDebugCommandActionAllowed();
}

OSObject *AppleBCMWLANLogger::withDriverAndOptions(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v8 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANLoggerMetaClass, &v8)) {
    return 0;
  }
  uint64_t v6 = v8;
  if (v8
    && (((uint64_t (*)(OSObject *, uint64_t, uint64_t, uint64_t))v8->OSMetaClassBase::__vftable[1].getMetaClass)(v8, a1, a2, a3) & 1) == 0)
  {
    ((void (*)(OSObject *))v6->release)(v6);
    return 0;
  }
  return v6;
}

BOOL AppleBCMWLANLogger::initWithDriverAndOptions(uint64_t a1, IOService *a2, const char **a3)
{
  if (!OSObject::init((OSObject *)a1)) {
    return 0;
  }
  uint64_t v6 = (void *)IOMallocZeroTyped();
  *(void *)(a1 + 48) = v6;
  if (!v6) {
    return 0;
  }
  void *v6 = a2;
  (*(void (**)(void))(***(void ***)(a1 + 48) + 8))(**(void **)(a1 + 48));
  uint64_t v7 = IOMallocZeroData();
  if (!v7) {
    return 0;
  }
  uint64_t v8 = v7;
  uint64_t v9 = IOMallocZeroData();
  if (v9)
  {
    __int16 v10 = (void *)v9;
    uint64_t v11 = IOMallocZeroData();
    BOOL v12 = v11 != 0;
    if (v11)
    {
      unint64_t v13 = (char *)v11;
      strlcpy((char *)(*(void *)(a1 + 48) + 8), *a3, 3uLL);
      *(_DWORD *)(v8 + 548) = 0x200000;
      *(_OWORD *)uint64_t v8 = xmmword_100371990;
      *(_OWORD *)(v8 + 16) = xmmword_1003712B0;
      *(_DWORD *)(v8 + 32) = 1000;
      uint32_t v36 = (char *)(v8 + 36);
      strcpy((char *)(v8 + 36), "AppleBCMWLAN_Logs");
      snprintf((char *)(v8 + 292), 0xF0uLL, "wlan%s", *a3);
      uint64_t v35 = (char *)(v8 + 580);
      strcpy((char *)(v8 + 580), "WiFi");
      *(_DWORD *)(v8 + 552) = 2;
      *(_OWORD *)(v8 + 560) = 0u;
      snprintf((char *)a3[4], 0x80uLL, "%s.%s", "com.apple.driver.AppleBCMWLANCoreV3", *a3);
      __int16 v14 = (const OSMetaClassBase *)CCPipe::withOwnerNameCapacity();
      unint64_t v15 = OSMetaClassBase::safeMetaCast(v14, gCCLogPipeMetaClass);
      *((void *)a3[1] + IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = v15;
      *(void *)(*(void *)(a1 + 48) + 24) = v15;
      ((void (*)(OSMetaClassBase *))v15->__vftable[1].Dispatch)(v15);
      if (*((void *)a3[1] + 1))
      {
        BOOL isVerboseDebugLoggingAllowed = AppleBCMWLAN_isVerboseDebugLoggingAllowed();
        if (isVerboseDebugLoggingAllowed) {
          int v17 = 1;
        }
        else {
          int v17 = -1;
        }
        if (isVerboseDebugLoggingAllowed) {
          int v18 = 5;
        }
        else {
          int v18 = -1;
        }
        uint64_t v19 = 289664;
        if (!isVerboseDebugLoggingAllowed) {
          uint64_t v19 = 0;
        }
        uint64_t v34 = v19;
        int v38 = -1431655766;
        snprintf(v13, 0x80uLL, "%s%s%s.", "wlan", *a3, "log.level");
        if ((IOParseBootArgNumber("wlan.log.level", &v38, 4) || IOParseBootArgNumber(v13, &v38, 4))
          && (v38 == 127 || (v38 + 1) < 9))
        {
          int v17 = v38;
          int v18 = v38;
        }
        snprintf(v13, 0x80uLL, "%s%s%s.", "wlan", *a3, "log.cclevel");
        if ((IOParseBootArgNumber("wlan.log.cclevel", &v38, 4) || IOParseBootArgNumber(v13, &v38, 4))
          && ((v38 + 1) < 9 || v38 == 127))
        {
          int v18 = v38;
        }
        int v33 = v17;
        uint64_t v37 = 0;
        snprintf(v13, 0x80uLL, "%s%s%s.", "wlan", *a3, "log.flags");
        if (IOParseBootArgNumber("wlan.log.flags", &v37, 8) || IOParseBootArgNumber(v13, &v37, 8))
        {
          uint64_t v23 = v37;
          uint64_t v34 = v37;
        }
        else
        {
          uint64_t v23 = 0;
        }
        snprintf(v13, 0x80uLL, "%s%s%s.", "wlan", *a3, "log.ccflags");
        if (IOParseBootArgNumber("wlan.log.cflags", &v37, 8) || IOParseBootArgNumber(v13, &v37, 8)) {
          uint64_t v34 = v37;
        }
        memcpy(v10 + 43, LoggerFlagNameStrings, 0x200uLL);
        *(_DWORD *)__int16 v10 = 0;
        *((_DWORD *)v10 + 2) = v18;
        *((_DWORD *)v10 + AppleBCMWLANCommandWithXTLV::free(this - 3) = v33;
        void v10[3] = v34;
        v10[4] = v23;
        v10[6] = a2;
        v10[7] = 0;
        v10[8] = a3[3];
        snprintf((char *)v10 + 88, 0xF0uLL, "wlan%s", *a3);
        long long v25 = (const OSMetaClassBase *)CCStream::withPipeAndName();
        OSStringPtr v26 = OSMetaClassBase::safeMetaCast(v25, gCCLogStreamMetaClass);
        *((void *)a3[1] + 2) = v26;
        *(void *)(*(void *)(a1 + 48) + 32) = v26;
      }
      bzero((void *)v8, 0x350uLL);
      *(_OWORD *)(v8 + 16) = xmmword_1003712B0;
      *(_DWORD *)(v8 + 32) = 1000;
      strcpy(v36, "AppleBCMWLAN_Datapath");
      strcpy(v35, "WiFi");
      unsigned int DTParameter32 = AppleBCMWLANUtil::getDTParameter32(a2, (IOService *)"IOService", "wlan.data.log.ring.size", 0);
      if (DTParameter32) {
        *(void *)(v8 + 16) = DTParameter32;
      }
      *(void *)(v8 + 548) = 0x202800000;
      *(void *)(v8 + 560) = 0;
      *(void *)(v8 + 5++*(_DWORD *)(*(void *)(this + 64) + 68) = 0;
      unsigned int v28 = (const OSMetaClassBase *)CCPipe::withOwnerNameCapacity();
      unsigned int v29 = OSMetaClassBase::safeMetaCast(v28, gCCLogPipeMetaClass);
      *(void *)a3[1] = v29;
      *(void *)(*(void *)(a1 + 48) + 16) = v29;
      bzero((void *)(v8 + 16), 0x340uLL);
      *(_OWORD *)uint64_t v8 = xmmword_1003719A0;
      strcpy(v36, "StateSnapshots");
      strlcpy((char *)(v8 + 292), *a3, 0x100uLL);
      strcpy(v35, "WiFi");
      *(void *)(v8 + 16) = 128;
      *(void *)(v8 + 560) = a2;
      *(void *)(v8 + 5++*(_DWORD *)(*(void *)(this + 64) + 68) = a3[2];
      uint64_t v30 = CCPipe::withOwnerNameCapacity();
      *((void *)a3[1] + AppleBCMWLANCommandWithXTLV::free(this - 3) = v30;
      *(void *)(*(void *)(a1 + 48) + 40) = v30;
      bzero(v10, 0x358uLL);
      *(_DWORD *)__int16 v10 = 1;
      v10[1] = -1;
      void v10[3] = 0;
      v10[4] = 0;
      v10[7] = 0;
      v10[8] = 0;
      v10[6] = 0;
      if (*((void *)a3[1] + 3))
      {
        unsigned int v31 = (const OSMetaClassBase *)CCStream::withPipeAndName();
        unint64_t v32 = OSMetaClassBase::safeMetaCast(v31, gCCDataStreamMetaClass);
        *((void *)a3[1] + 4) = v32;
        *(void *)(*(void *)(a1 + 48) + 48) = v32;
      }
      IOFreeData();
    }
    IOFreeData();
  }
  else
  {
    BOOL v12 = 0;
  }
  IOFreeData();
  return v12;
}

BOOL non-virtual thunk to'AppleBCMWLANLogger::initWithDriverAndOptions(uint64_t a1, IOService *a2, const char **a3)
{
  return AppleBCMWLANLogger::initWithDriverAndOptions(a1 - 40, a2, a3);
}

void AppleBCMWLANLogger::free(OSObject *this)
{
  uint64_t v2 = *(void **)&this[1].refcount;
  if (v2)
  {
    if (*v2)
    {
      (*(void (**)(void))(*(void *)*v2 + 16))(*v2);
      **(void **)&this[1].__int32 refcount = 0;
      uint64_t v2 = *(void **)&this[1].refcount;
    }
    uint64_t v3 = v2[5];
    if (v3)
    {
      (*(void (**)(void))(*(void *)v3 + 16))(v2[5]);
      *(void *)(*(void *)&this[1].refcount + 40) = 0;
      uint64_t v2 = *(void **)&this[1].refcount;
    }
    uint64_t v4 = v2[6];
    if (v4)
    {
      (*(void (**)(void))(*(void *)v4 + 16))(v2[6]);
      *(void *)(*(void *)&this[1].refcount + 48) = 0;
      uint64_t v2 = *(void **)&this[1].refcount;
    }
    uint64_t v5 = v2[2];
    if (v5)
    {
      (*(void (**)(void))(*(void *)v5 + 16))(v2[2]);
      *(void *)(*(void *)&this[1].refcount + 16) = 0;
      uint64_t v2 = *(void **)&this[1].refcount;
    }
    uint64_t v6 = v2[3];
    if (v6)
    {
      (*(void (**)(void))(*(void *)v6 + 16))(v2[3]);
      *(void *)(*(void *)&this[1].refcount + 24) = 0;
      uint64_t v2 = *(void **)&this[1].refcount;
    }
    uint64_t v7 = v2[4];
    if (v7)
    {
      (*(void (**)(void))(*(void *)v7 + 16))(v2[4]);
      *(void *)(*(void *)&this[1].refcount + 32) = 0;
      uint64_t v2 = *(void **)&this[1].refcount;
    }
    memset_s(v2, 0x38uLL, 0, 0x38uLL);
    uint64_t v8 = *(void **)&this[1].refcount;
    if (v8)
    {
      IOFree(v8, 0x38uLL);
      *(void *)&this[1].__int32 refcount = 0;
    }
  }
  OSObject::free(this);
}

void non-virtual thunk to'AppleBCMWLANLogger::free(AppleBCMWLANLogger *this)
{
}

const char *getForcedFwTrapReasonString(int a1)
{
  if ((a1 - 1) > 6) {
    return "Unknown";
  }
  else {
    return off_1003909B0[a1 - 1];
  }
}

const char *stringFromBootCheckPoint(unsigned int a1)
{
  if (a1 > 0xB) {
    return "Unknown";
  }
  else {
    return off_1003909E8[a1];
  }
}

void _GLOBAL__sub_I_AppleBCMWLANDebug_cpp()
{
  kNullRange = 0;
}

OSObject *AppleBCMWLANPCIeDoorbell::withCallbacks(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANPCIeDoorbellMetaClass, &v8)) {
    return 0;
  }
  uint64_t v6 = v8;
  if (v8 && (AppleBCMWLANPCIeDoorbell::initWithCallbacks((uint64_t)v8, a1, a2, a3) & 1) == 0)
  {
    ((void (*)(OSObject *))v6->release)(v6);
    return 0;
  }
  return v6;
}

uint64_t AppleBCMWLANPCIeDoorbell::initWithCallbacks(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = OSObject::init((OSObject *)a1);
  if (result)
  {
    uint64_t result = 0;
    if (a2)
    {
      if (a3)
      {
        uint64_t result = IOMallocZeroTyped();
        *(void *)(a1 + 48) = result;
        if (result)
        {
          *(void *)(result + 8) = a2;
          (*(void (**)(void))(**(void **)(*(void *)(a1 + 48) + 8) + 8))(*(void *)(*(void *)(a1 + 48) + 8));
          *(void *)(*(void *)(a1 + 48) + 16) = a3;
          *(void *)(*(void *)(a1 + 48) + 24) = a4;
          (*(void (**)(uint64_t))(*(void *)a1 + 56))(a1);
          **(void **)(a1 + 48) = IO80211TimerSource::allocWithParams();
          return **(void **)(a1 + 48) != 0;
        }
      }
    }
  }
  return result;
}

uint64_t AppleBCMWLANPCIeDoorbell::handleCoalescingTimer(AppleBCMWLANPCIeDoorbell *a1)
{
  mach_continuous_time();
  uint64_t result = absolutetime_to_nanoseconds();
  if (*(unsigned char *)(*((void *)a1 + 6) + 32))
  {
    BOOL v3 = AppleBCMWLANPCIeDoorbell::ringNow(a1) == 0;
    return AppleBCMWLANPCIeDoorbell::updateDBRecord(a1, 0, v3);
  }
  return result;
}

uint64_t AppleBCMWLANPCIeDoorbell::getWorkQueue(AppleBCMWLANPCIeDoorbell *this)
{
  return *(void *)(*((void *)this + 6) + 24);
}

uint64_t non-virtual thunk to'AppleBCMWLANPCIeDoorbell::getWorkQueue(AppleBCMWLANPCIeDoorbell *this)
{
  return *(void *)(*((void *)this + 1) + 24);
}

void AppleBCMWLANPCIeDoorbell::free(OSObject *this)
{
  uint64_t v2 = *(IOLock ***)&this[1].refcount;
  if (v2)
  {
    if (v2[67])
    {
      IOLockFree(v2[67]);
      *(void *)(*(void *)&this[1].refcount + 536) = 0;
      uint64_t v2 = *(IOLock ***)&this[1].refcount;
    }
    if (*v2)
    {
      (*(void (**)(IOLock *))(*(void *)*v2 + 72))(*v2);
      uint64_t v2 = *(IOLock ***)&this[1].refcount;
      if (*v2)
      {
        (*(void (**)(IOLock *))(*(void *)*v2 + 16))(*v2);
        **(void **)&this[1].__int32 refcount = 0;
        uint64_t v2 = *(IOLock ***)&this[1].refcount;
      }
    }
    BOOL v3 = v2[1];
    if (v3)
    {
      (*(void (**)(IOLock *))(*(void *)v3 + 16))(v2[1]);
      *(void *)(*(void *)&this[1].refcount + 8) = 0;
      uint64_t v2 = *(IOLock ***)&this[1].refcount;
    }
    memset_s(v2, 0x238uLL, 0, 0x238uLL);
    uint64_t v4 = *(void **)&this[1].refcount;
    if (v4)
    {
      IOFree(v4, 0x238uLL);
      *(void *)&this[1].__int32 refcount = 0;
    }
  }
  OSObject::free(this);
}

void non-virtual thunk to'AppleBCMWLANPCIeDoorbell::free(AppleBCMWLANPCIeDoorbell *this)
{
}

uint64_t AppleBCMWLANPCIeDoorbell::ringNow(AppleBCMWLANPCIeDoorbell *this)
{
  uint64_t v2 = (*(uint64_t (**)(void))(*((void *)this + 6) + 16))(*(void *)(*((void *)this + 6) + 8));
  if (!v2)
  {
    mach_continuous_time();
    absolutetime_to_nanoseconds();
    *(unsigned char *)(*((void *)this + 6) + 32) = 0;
    *(void *)(*((void *)this + 6) + 544) = 0;
  }
  return v2;
}

uint64_t AppleBCMWLANPCIeDoorbell::updateDBRecord(AppleBCMWLANPCIeDoorbell *this, int a2, int a3)
{
  mach_continuous_time();
  uint64_t result = absolutetime_to_nanoseconds();
  *(_DWORD *)(*((void *)this + 6) + 24 * (*(void *)(*((void *)this + 6) + 528) & 0xFLL) + 144) = a2;
  *(void *)(*((void *)this + 6) + 24 * (*(void *)(*((void *)this + 6) + 528) & 0xFLL) + 152) = *(void *)(*((void *)this + 6) + 528);
  *(_DWORD *)(*((void *)this + 6) + 24 * (*(void *)(*((void *)this + 6) + 528) & 0xFLL) + 148) = a3;
  *(void *)(*((void *)this + 6) + 24 * (*(_DWORD *)(*((void *)this + 6) + 528) & 0xF) + 160) = 0xAAAAAAAAAAAAAAAALL;
  ++*(void *)(*((void *)this + 6) + 528);
  return result;
}

uint64_t AppleBCMWLANPCIeDoorbell::cancelRing(uint64_t this)
{
  *(unsigned char *)(*(void *)(this + 48) + 32) = 0;
  *(void *)(*(void *)(this + 48) + 544) = *(void *)(*(void *)(this + 48) + 552);
  return this;
}

AppleBCMWLANPCIeDoorbell *AppleBCMWLANPCIeDoorbell::ring(AppleBCMWLANPCIeDoorbell *this, int a2, int a3, uint64_t a4)
{
  uint64_t v4 = *((void *)this + 6);
  if (*(unsigned char *)(v4 + 32)) {
    return this;
  }
  uint64_t v5 = this;
  *(_DWORD *)(v4 + 48) = 0;
  if (a3)
  {
    *(void *)(*((void *)this + 6) + 544) += a4;
    if (*(void *)(*((void *)this + 6) + 544) < *(void *)(*((void *)this + 6) + 552)) {
      return this;
    }
    int v6 = 1;
  }
  else if (a2)
  {
    mach_continuous_time();
    absolutetime_to_nanoseconds();
    uint64_t v10 = *((void *)v5 + 6);
    if (0xAAAAAAAAAAAAAAAALL - *(void *)(v10 + 56) <= 0xF423F)
    {
      uint64_t v11 = *(void *)(v10 + 560);
      *(void *)(*((void *)v5 + 6) + 560) = AppleBCMWLANBusInterfacePCIe::getTotalTxPacketCount(*(AppleBCMWLANBusInterfacePCIe **)(v10 + 8));
      uint64_t v12 = *((void *)v5 + 6);
      if ((unint64_t)(*(void *)(v12 + 560) - v11) <= 0x63)
      {
        unint64_t v13 = *(void *)(v12 + 64) + *(void *)(v12 + 56);
        if (v13 >= 0xAAAAAAAAAAAAAAAALL) {
          int v14 = (v13 + 0x5555555555555556) / 0x3E8;
        }
        else {
          int v14 = 0;
        }
        *(_DWORD *)(v12 + 48) = v14;
        uint64_t v15 = *((void *)v5 + 6);
        if (0xAAAAAAAAAAAAAAAALL - *(void *)(v15 + 72) < 0x4C4B40)
        {
          int v6 = 0;
        }
        else
        {
          *(void *)(v15 + 64) += 50000;
          uint64_t v16 = *((void *)v5 + 6);
          if (*(void *)(v16 + 64) > 0xF423FuLL)
          {
            *(void *)(v16 + 64) = 1000000;
            uint64_t v16 = *((void *)v5 + 6);
          }
          int v6 = 0;
          *(void *)(v16 + ++*(_DWORD *)(*(void *)(this + 64) + 72) = 0xAAAAAAAAAAAAAAAALL;
        }
      }
      else
      {
        int v6 = 1;
      }
    }
    else
    {
      int v6 = 1;
    }
  }
  else
  {
    int v6 = 1;
  }
  uint64_t v7 = *((void *)v5 + 6);
  if (!*(_DWORD *)(v7 + 48))
  {
    int isCTS = AppleBCMWLANBusInterfacePCIe::isCTS(*(AppleBCMWLANBusInterfacePCIe **)(v7 + 8));
    uint64_t v7 = *((void *)v5 + 6);
    if (isCTS)
    {
      if (AppleBCMWLANBusInterfacePCIe::isBusLeadEnabled(*(AppleBCMWLANBusInterfacePCIe **)(v7 + 8)))
      {
        int v9 = AppleBCMWLANPCIeDoorbell::ringNow(v5);
        if (v9)
        {
          *(unsigned char *)(*((void *)v5 + 6) + 32) = 1;
          (*(void (**)(void, void))(***((void ***)v5 + 6) + 128))(**((void **)v5 + 6), *(unsigned int *)(*((void *)v5 + 6) + 48));
        }
        AppleBCMWLANPCIeDoorbell::updateDBRecord(v5, 1, v9 == 0);
        goto LABEL_13;
      }
      uint64_t v7 = *((void *)v5 + 6);
    }
  }
  *(unsigned char *)(v7 + 32) = 1;
  (*(void (**)(void, void))(***((void ***)v5 + 6) + 128))(**((void **)v5 + 6), *(unsigned int *)(*((void *)v5 + 6) + 48));
LABEL_13:
  if (v6)
  {
    *(void *)(*((void *)v5 + 6) + 64) = 850000;
    *(void *)(*((void *)v5 + 6) + 560) = AppleBCMWLANBusInterfacePCIe::getTotalTxPacketCount(*(AppleBCMWLANBusInterfacePCIe **)(*((void *)v5 + 6) + 8));
  }
  return (AppleBCMWLANPCIeDoorbell *)kdebug_trace();
}

void *AppleBCMWLANPCIeDoorbell::getDebugInfo(void *result, void *__dst)
{
  if (__dst) {
    return memcpy(__dst, (const void *)(result[6] + 80), 0x1C0uLL);
  }
  return result;
}

uint64_t AppleBCMWLANPCIeDoorbell::setRXPacketThreshold(uint64_t this, uint64_t a2)
{
  *(void *)(*(void *)(this + 48) + 552) = a2;
  return this;
}

void _GLOBAL__sub_I_AppleBCMWLANPCIeDoorbell_cpp()
{
  kNullRange = 0;
}

OSObject *AppleBCMWLANLeakyApParser::withLogger(AppleBCMWLANLeakyApParser *this, CCLogStream *a2)
{
  uint64_t v5 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANLeakyApParserMetaClass, &v5)) {
    return 0;
  }
  BOOL v3 = v5;
  if (v5
    && (((uint64_t (*)(OSObject *, AppleBCMWLANLeakyApParser *))v5->OSMetaClassBase::__vftable[1].getMetaClass)(v5, this) & 1) == 0)
  {
    ((void (*)(OSObject *))v3->release)(v3);
    return 0;
  }
  return v3;
}

uint64_t AppleBCMWLANLeakyApParser::init(OSObject *this, CCLogStream *a2)
{
  if (OSObject::init(this))
  {
    uint64_t result = IOMallocZeroTyped();
    *(void *)&this[1].__int32 refcount = result;
    if (!result) {
      return result;
    }
    *(void *)uint64_t result = a2;
    uint64_t v5 = **(void **)&this[1].refcount;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
      uint64_t v6 = *(void *)&this[1].refcount;
      *(void *)(v6 + 40) = 0;
      *(_OWORD *)(v6 + 24) = 0u;
      *(_OWORD *)(v6 + 8) = 0u;
      uint64_t v7 = *(void *)&this[1].refcount;
      *(void *)(v7 + 48) = 0;
      *(void *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      uint64_t v8 = *(void *)&this[1].refcount;
      *(void *)(v8 + ++*(_DWORD *)(*(void *)(this + 64) + 72) = 0;
      *(void *)(v8 + 80) = 0;
      return 1;
    }
    getClassNameHelper(this);
    IOLog("%s:%s(): Unable to get debug logger\n");
  }
  else
  {
    getClassNameHelper(this);
    IOLog("%s:%s(): Super failed to init!\n");
  }
  return 0;
}

uint64_t non-virtual thunk to'AppleBCMWLANLeakyApParser::init(OSObject *this, CCLogStream *a2)
{
  return AppleBCMWLANLeakyApParser::init(this - 1, a2);
}

double AppleBCMWLANLeakyApParser::releaseLeakyApParserResources(AppleBCMWLANLeakyApParser *this)
{
  for (uint64_t i = *((void *)this + 6); ; uint64_t i = *((void *)this + 6))
  {
    BOOL v3 = *(void **)(i + 40);
    if (!v3) {
      break;
    }
    *(void *)(i + 40) = v3[2];
    IOFree(v3, 0x18uLL);
  }
  *(void *)(i + 40) = 0;
  double result = 0.0;
  *(_OWORD *)(i + 24) = 0u;
  *(_OWORD *)(i + 8) = 0u;
  return result;
}

void AppleBCMWLANLeakyApParser::free(AppleBCMWLANLeakyApParser *this)
{
  if (*((void *)this + 6))
  {
    double v2 = AppleBCMWLANLeakyApParser::releaseLeakyApParserResources(this);
    BOOL v3 = (void *)*((void *)this + 6);
    if (*v3)
    {
      (*(void (**)(void, double))(*(void *)*v3 + 16))(*v3, v2);
      **((void **)this + 6) = 0;
      BOOL v3 = (void *)*((void *)this + 6);
    }
    memset_s(v3, 0x58uLL, 0, 0x58uLL);
    uint64_t v4 = (void *)*((void *)this + 6);
    if (v4)
    {
      IOFree(v4, 0x58uLL);
      *((void *)this + 6) = 0;
    }
  }
  OSObject::free((OSObject *)this);
}

void non-virtual thunk to'AppleBCMWLANLeakyApParser::free(AppleBCMWLANLeakyApParser *this)
{
}

uint64_t AppleBCMWLANLeakyApParser::printLeakyAPLog(AppleBCMWLANLeakyApParser *this)
{
  uint64_t result = **((void **)this + 6);
  if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result)
    {
      uint64_t v3 = *((void *)this + 6);
      return CCLogStream::logInfo(*(CCLogStream **)v3, "[dk] %s@%d: Total Leaky AP GT received: FRTS %d, SCAN %d, AWDL_PSF %d, AWDL_AW %d INVALID %d\n", "printLeakyAPLog", 150, *(_DWORD *)(v3 + 48), *(_DWORD *)(v3 + 52), *(_DWORD *)(v3 + 56), *(_DWORD *)(v3 + 60), *(_DWORD *)(v3 + 64));
    }
  }
  return result;
}

uint64_t AppleBCMWLANLeakyApParser::parseRxRate(CCLogStream ***this, unsigned int a2, unsigned int *a3)
{
  if (a3)
  {
    if ((a2 & 0x7000000) == 0)
    {
      *a3 = a2 >> 1;
      if (*this[6] && CCLogStream::shouldLog()) {
        CCLogStream::logInfo(*this[6], "[dk] %s@%d: INFO: BASIC RATE: the Mbps is %d \n ");
      }
      return 1;
    }
    unsigned int v6 = ratespec2rate((uint64_t)*this[6], a2);
    *a3 = v6;
    if (v6)
    {
      if (*this[6])
      {
        if (CCLogStream::shouldLog()) {
          CCLogStream::logInfo(*this[6], "[dk] %s@%d: INFO: %s RATE: BW is %s Short GI is %d the Mbps is %d \n ");
        }
      }
      return 1;
    }
  }
  else if (*this[6] && CCLogStream::shouldLog())
  {
    CCLogStream::logAlert(*this[6], "[dk] %s@%d: ERROR: Received NULL pointer parameter \n", "parseRxRate", 165);
  }
  uint64_t result = (uint64_t)*this[6];
  if (result)
  {
    uint64_t result = CCLogStream::shouldLog();
    if (result)
    {
      CCLogStream::logAlert(*this[6], "[dk] %s@%d: ERROR: Failed to parse wl rx rate. The rateSpec value is 0x%X \n ", "parseRxRate", 200, a2);
      return 0;
    }
  }
  return result;
}

uint64_t AppleBCMWLANLeakyApParser::addLeakyAPStatsClient(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(*(void *)(result + 48) + ++*(_DWORD *)(*(void *)(this + 64) + 72) = a2;
  *(void *)(*(void *)(result + 48) + 80) = a3;
  return result;
}

uint64_t AppleBCMWLANLeakyApParser::parseLeakyApGuardTimeMrk(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    int v4 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(*(void *)(a1 + 48) + 12) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(*(void *)(a1 + 48) + 16) = v4;
    *(_DWORD *)(*(void *)(a1 + 48) + 20) = *(_DWORD *)(a2 + 12);
    *(_WORD *)(*(void *)(a1 + 48) + 24) = *(_WORD *)(a2 + 16);
    *(_WORD *)(*(void *)(a1 + 48) + 26) = *(_WORD *)(a2 + 18);
    if ((*(unsigned char *)(a2 + 20) & 8) != 0)
    {
      uint64_t v7 = 0;
      uint64_t v5 = *(void *)(a1 + 48);
      int v8 = 3;
    }
    else if ((*(unsigned char *)(a2 + 20) & 4) != 0)
    {
      uint64_t v7 = 0;
      uint64_t v5 = *(void *)(a1 + 48);
      int v8 = 2;
    }
    else if ((*(unsigned char *)(a2 + 20) & 2) != 0)
    {
      uint64_t v7 = 0;
      uint64_t v5 = *(void *)(a1 + 48);
      int v8 = 1;
    }
    else
    {
      if (*(unsigned char *)(a2 + 20))
      {
        uint64_t v7 = 0;
        *(_DWORD *)(*(void *)(a1 + 48) + 28) = 0;
        return v7;
      }
      if ((*(unsigned char *)(a2 + 20) & 0x10) != 0)
      {
        uint64_t v7 = 0;
        uint64_t v5 = *(void *)(a1 + 48);
      }
      else
      {
        uint64_t v5 = *(void *)(a1 + 48);
        if ((*(unsigned char *)(a2 + 20) & 0x80) == 0)
        {
          if (*(void *)v5)
          {
            int shouldLog = CCLogStream::shouldLog();
            uint64_t v5 = *(void *)(a1 + 48);
            if (shouldLog)
            {
              CCLogStream::logAlert(*(CCLogStream **)v5, "[dk] %s@%d: ERROR: Got Invalid Failed reason 0x%X \n", "parseLeakyApGuardTimeMrk", 242, *(unsigned __int8 *)(a2 + 20));
              uint64_t v5 = *(void *)(a1 + 48);
            }
          }
          *(_DWORD *)(v5 + 28) = 4;
          return 3758097084;
        }
        uint64_t v7 = 0;
      }
      int v8 = 4;
    }
    *(_DWORD *)(v5 + 28) = v8;
    return v7;
  }
  uint64_t v7 = 3758097090;
  if (**(void **)(a1 + 48) && CCLogStream::shouldLog()) {
    CCLogStream::logAlert(**(CCLogStream ***)(a1 + 48), "[dk] %s@%d: ERROR: Bad wlcLeakyInfraGrdMark \n", "parseLeakyApGuardTimeMrk", 221);
  }
  return v7;
}

uint64_t AppleBCMWLANLeakyApParser::parseLeakyApPacket(CCLogStream ***a1, uint64_t a2)
{
  uint64_t v3 = a1[6];
  if (a2)
  {
    if ((v3[5] == 0) == (*((_WORD *)v3 + 4) == 0))
    {
      if (*((unsigned __int16 *)v3 + 4) >= 0x100u)
      {
        if (*v3 && CCLogStream::shouldLog()) {
          CCLogStream::logAlert(*a1[6], "[dk] %s@%d:Received too many leaky ap packets \n", "parseLeakyApPacket", 260);
        }
        return 0;
      }
      else
      {
        uint64_t v5 = (CCLogStream *)IOMallocZeroTyped();
        if (v5)
        {
          *(void *)uint64_t v5 = 0;
          *((void *)v5 + IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = 0;
          *((void *)v5 + 2) = 0;
          *((void *)v5 + 2) = a1[6][5];
          a1[6][5] = v5;
          ++*((_WORD *)a1[6] + 4);
          if (AppleBCMWLANLeakyApParser::parseRxRate(a1, *(_DWORD *)(a2 + 12), (unsigned int *)a1[6][5] + 2))
          {
            uint64_t v6 = 0;
            *(_WORD *)a1[6][5] = *(_WORD *)(a2 + 4);
            *((_WORD *)a1[6][5] + IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = *(_WORD *)(a2 + 6);
            *((_DWORD *)a1[6][5] + IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = *(_DWORD *)(a2 + 8);
            *((_WORD *)a1[6][5] + 6) = *(_WORD *)(a2 + 16);
            *((unsigned char *)a1[6][5] + 14) = *(unsigned char *)(a2 + 18);
            *((unsigned char *)a1[6][5] + 15) = *(unsigned char *)(a2 + 19);
          }
          else
          {
            uint64_t v6 = 3758097090;
            if (*a1[6] && CCLogStream::shouldLog()) {
              CCLogStream::logAlert(*a1[6], "[dk] %s@%d:Failed to parseRxRate \n");
            }
          }
        }
        else
        {
          uint64_t v6 = 3758097085;
          if (*a1[6] && CCLogStream::shouldLog()) {
            CCLogStream::logAlert(*a1[6], "[dk] %s@%d:Failed to allocate pckLog\n");
          }
        }
      }
    }
    else
    {
      uint64_t v6 = 3758097084;
      if (*v3 && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*a1[6], "[dk] %s@%d: ERROR: packet management failed. Num of log is %d, but expected zero \n");
      }
    }
  }
  else
  {
    uint64_t v6 = 3758097090;
    if (*v3 && CCLogStream::shouldLog()) {
      CCLogStream::logWarn(*a1[6], "[dk] %s@%d: ERROR: Received NULL pointer parameter \n", "parseLeakyApPacket", 256);
    }
  }
  return v6;
}

uint64_t AppleBCMWLANLeakyApParser::parseEventLogRecordLeakyAP(CCLogStream ***this, OSData *a2)
{
  uint64_t v4 = IOMallocZeroData();
  if (v4)
  {
    uint64_t v5 = (_WORD *)v4;
    if (OSData::getLength(a2) >= 0x19)
    {
      if (*this[6])
      {
        uint64_t v8 = 0;
        if (!CCLogStream::shouldLog()) {
          goto LABEL_30;
        }
        CCLogStream::logEmergency(*this[6], "[dk] %s@%d:Insufficient buf sized wlc_leaked_infra_datarecord_t %ld to hold payload", "parseEventLogRecordLeakyAP", 298, 24);
      }
      uint64_t v8 = 0;
      goto LABEL_30;
    }
    uint64_t BytesNoCopy = OSData::getBytesNoCopy(a2);
    size_t Length = OSData::getLength(a2);
    memcpy(v5, BytesNoCopy, Length);
    if (!a2 || !OSData::getBytesNoCopy(a2, 0, 0x14uLL))
    {
      uint64_t v8 = 3758097084;
      if (*this[6] && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(*this[6], "[dk] %s@%d: Received NULL pointer or malformed data \n", "parseEventLogRecordLeakyAP", 301);
      }
      goto LABEL_30;
    }
    if (*v5)
    {
      if (*v5 == 1 && v5[1] == 16)
      {
        if (*this[6] && CCLogStream::shouldLog()) {
          CCLogStream::logInfoIf(*this[6], 0x200000000uLL, "[dk] %s@%d: Received  WL_LEAKY_AP_STATS_PKT_TYPE \n", "parseEventLogRecordLeakyAP", 306);
        }
        uint64_t v8 = AppleBCMWLANLeakyApParser::parseLeakyApPacket(this, (uint64_t)v5);
        goto LABEL_24;
      }
    }
    else if (v5[1] == 20)
    {
      if (*this[6] && CCLogStream::shouldLog()) {
        CCLogStream::logInfoIf(*this[6], 0x200000000uLL, "[dk] %s@%d: Received  WL_LEAKY_AP_STATS_GT_TYPE \n", "parseEventLogRecordLeakyAP", 311);
      }
      uint64_t v8 = AppleBCMWLANLeakyApParser::parseLeakyApGuardTimeMrk((uint64_t)this, (uint64_t)v5);
      if (!v8
        && AppleBCMWLANLeakyApParser::sendLeakyApInfo((AppleBCMWLANLeakyApParser *)this)
        && *this[6]
        && CCLogStream::shouldLog())
      {
        CCLogStream::logWarn(*this[6], "[dk] %s@%d: WARNING: FAILED to send Guard Time infomartion to the Family... \n", "parseEventLogRecordLeakyAP", 316);
      }
      int v9 = this[6];
      uint64_t v10 = *((unsigned int *)v9 + 7);
      if ((int)v10 <= 4) {
        ++*((_DWORD *)v9 + v10 + 12);
      }
      AppleBCMWLANLeakyApParser::releaseLeakyApParserResources((AppleBCMWLANLeakyApParser *)this);
LABEL_24:
      if (!v8) {
        goto LABEL_30;
      }
      goto LABEL_29;
    }
    uint64_t v8 = 3758097090;
    if (*this[6] && CCLogStream::shouldLog())
    {
      CCLogStream::logAlert(*this[6], "[dk] %s@%d: WARNING: Leaky AP event tag len/type mismatch: \n", "parseEventLogRecordLeakyAP", 328);
      uint64_t v8 = 3758097090;
    }
LABEL_29:
    AppleBCMWLANLeakyApParser::releaseLeakyApParserResources((AppleBCMWLANLeakyApParser *)this);
LABEL_30:
    IOFreeData();
    return v8;
  }
  if (*this[6] && CCLogStream::shouldLog()) {
    CCLogStream::logAlert(*this[6], "[dk] %s@%d:Failed to allocate wlc_leaked_infra_packet_stat_t buf", "parseEventLogRecordLeakyAP", 295);
  }
  return 0;
}

uint64_t AppleBCMWLANLeakyApParser::sendLeakyApInfo(AppleBCMWLANLeakyApParser *this)
{
  uint64_t v2 = *((void *)this + 6);
  if (*(void *)(v2 + 72) && *(void *)(v2 + 80))
  {
    if (CCLogStream::shouldLog(*(CCLogStream **)v2, 0x200000000uLL)) {
      AppleBCMWLANLeakyApParser::printLeakyAPLog(this);
    }
    if ((*(uint64_t (**)(void, uint64_t))(*((void *)this + 6) + 80))(*(void *)(*((void *)this + 6) + 72), *((void *)this + 6) + 8))
    {
      return 0;
    }
    else
    {
      uint64_t v3 = 3758097097;
      if (**((void **)this + 6) && CCLogStream::shouldLog()) {
        CCLogStream::logAlert(**((CCLogStream ***)this + 6), "[dk] %s@%d: ERROR: Family callback function returned status  FAIL,\n");
      }
    }
  }
  else
  {
    uint64_t v3 = 3758097097;
    if (*(void *)v2 && CCLogStream::shouldLog()) {
      CCLogStream::logAlert(**((CCLogStream ***)this + 6), "[dk] %s@%d: ERROR: Family callback function or owner is NULL \n");
    }
  }
  return v3;
}

BOOL non-virtual thunk to'DriverKit_AppleBCMWLAN::init(DriverKit_AppleBCMWLAN *this)
{
  return IOService::init((IOService *)((char *)this - 24));
}

void non-virtual thunk to'DriverKit_AppleBCMWLAN::free(DriverKit_AppleBCMWLAN *this)
{
}

uint64_t DriverKit_AppleBCMWLAN::Start_Impl(IOService *this, IOService *a2)
{
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "V3 Driver Hello World", v5, 2u);
  }
  return IOService::Start(this, a2, (OSDispatchMethod)&IOService::_Dispatch);
}

OSObject *AppleBCMWLANChanSpec::withFWAPIVer(int a1)
{
  uint64_t v4 = (OSObject *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLANChanSpecMetaClass, &v4)) {
    return 0;
  }
  uint64_t v2 = v4;
  if (v4 && (AppleBCMWLANChanSpec::initWithFWAPIVer(v4, a1) & 1) == 0)
  {
    ((void (*)(OSObject *))v2->release)(v2);
    return 0;
  }
  return v2;
}

uint64_t AppleBCMWLANChanSpec::initWithFWAPIVer(OSObject *a1, int a2)
{
  uint64_t result = OSObject::init(a1);
  if (result)
  {
    uint64_t result = IOMallocZeroTyped();
    a1[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)result;
    if (result)
    {
      *(_DWORD *)uint64_t result = a2;
      return 1;
    }
  }
  return result;
}

void AppleBCMWLANChanSpec::free(OSObject *this)
{
  uint64_t v2 = this[1].OSMetaClassBase::__vftable;
  if (v2)
  {
    memset_s(v2, 4uLL, 0, 4uLL);
    uint64_t v3 = this[1].OSMetaClassBase::__vftable;
    if (v3)
    {
      IOFree(v3, 4uLL);
      this[1].OSMetaClassBase::__vftable = 0;
    }
  }
  OSObject::free(this);
}

void non-virtual thunk to'AppleBCMWLANChanSpec::free(AppleBCMWLANChanSpec *this)
{
}

uint64_t AppleBCMWLANChanSpec::convToStateID(unint64_t a1)
{
  memset(__str, 170, 10);
  int PrimaryChannel = ChanSpecGetPrimaryChannel();
  snprintf(__str, 0xAuLL, "%03d", PrimaryChannel);
  uint64_t v3 = __str[0];
  uint64_t v4 = __str[1];
  uint64_t v5 = __str[2];
  snprintf(__str, 0xAuLL, "%1s", CTL_SB_STRING[(a1 >> 8) & 7]);
  uint64_t v6 = __str[0];
  snprintf(__str, 0xAuLL, "%2s", BW_STRING[(a1 >> 11) & 7]);
  return (v3 << 56) | (v4 << 48) | (v5 << 40) | (v6 << 32) | __str[1] | ((uint64_t)__str[0] << 8) | 0x20200000;
}

char *AppleBCMWLANChanSpec::convToAscii(unint64_t a1, char *a2, unsigned int a3)
{
  uint64_t result = 0;
  if (a2 && a3 >= 0x10)
  {
    if (!(_WORD)a1 || (a1 & 0x3800) == 0x3800)
    {
      *a2 = 0;
    }
    else
    {
      int PrimaryChannel = ChanSpecGetPrimaryChannel();
      uint64_t v7 = (const char *)&unk_10029A2CA;
      uint64_t v8 = "6g";
      if ((unsigned __int16)a1 >> 14 != 1) {
        uint64_t v8 = (const char *)&unk_10029A2CA;
      }
      if ((unsigned __int16)a1 >> 14 == 3) {
        int v9 = "5g";
      }
      else {
        int v9 = v8;
      }
      if ((unsigned __int16)a1 < 0x4000u) {
        int v9 = "2g";
      }
      unsigned int v10 = ((unsigned __int16)a1 >> 11) & 7;
      if (v10 < 3)
      {
        if (v10 == 2) {
          uint64_t v7 = "n";
        }
      }
      else
      {
        uint64_t v7 = CTL_SB_STRING[(a1 >> 8) & 7];
      }
      snprintf(a2, 0x10uLL, "%3u %1s %5s %1s", PrimaryChannel, v9, BW_STRING[v10], v7);
    }
    return a2;
  }
  return result;
}

int **AppleBCMWLANChanSpec::getApple80211ChannelSpec(int **result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    AppleBCMWLANChanSpec::getAppleChannelSpec(result, a2);
    return (int **)ChanSpecConvToApple80211Channel();
  }
  return result;
}

uint64_t AppleBCMWLANChanSpec::getAppleChannelSpec(int **this, uint64_t a2)
{
  if (*this[5] > 1)
  {
    if ((a2 & 0xF800) == 0x4000)
    {
      uint64_t v3 = a2 & 7;
      unsigned int v4 = (a2 >> 7) & 0xF;
      if ((a2 & 7) != 7) {
        LOBYTE(vAppleBCMWLANCommandWithXTLV::free(this - 3) = AppleBCMWLANChanSpec::getAppleChannelSpec(unsigned short)::chanIdToCenterlMap320[v3];
      }
      if (v4 < 8) {
        char v5 = -16;
      }
      else {
        char v5 = 16;
      }
      unsigned __int8 v6 = v3 + v5;
      if (v4 >= 8) {
        v4 -= 8;
      }
      return v6 | (v4 << 8) | 0x6800;
    }
  }
  else
  {
    if ((a2 & 0xF000) == 0x1000) {
      unsigned int v2 = a2 | (((a2 >> 10) & 3) << 11) | 0xFFFFC000;
    }
    else {
      unsigned int v2 = a2 | (((a2 >> 10) & 3) << 11);
    }
    if ((a2 & 0x300) == 0x200) {
      return v2 | 0x100;
    }
    else {
      return v2;
    }
  }
  return a2;
}

uint64_t AppleBCMWLANChanSpec::getBCMChannelSpec(uint64_t a1, unsigned __int16 a2)
{
  uint64_t result = a2;
  if (**(int **)(a1 + 40) <= 1)
  {
    if (a2 >> 14 <= 2u) {
      int v4 = 0x2000;
    }
    else {
      int v4 = 4096;
    }
    int v5 = a2 | (((a2 >> 11) & 7) << 10) | v4;
    unsigned int v6 = v5 | 0x300;
    int v7 = v5 | 0x100;
    unsigned int v8 = v5 | 0x200;
    if ((a2 & 0x700) != 0x100) {
      unsigned int v8 = v7;
    }
    if (((a2 >> 11) & 7) == 3) {
      return v8;
    }
    else {
      return v6;
    }
  }
  return result;
}

uint64_t AppleBCMWLANChanSpec::isValid5GChanSpec(int **this, __int16 a2)
{
  if (*this[5] >= 2)
  {
    uint64_t v2 = 0;
    while (a2 != chan_5g[v2 + 1] || (a2 & 0x3800) != chan_5g[v2])
    {
      v2 += 2;
      if (v2 == 110) {
        return 0;
      }
    }
  }
  return 1;
}

AppleBCMWLAN11axAdapter *AppleBCMWLAN11axAdapter::withDriver(AppleBCMWLAN11axAdapter *this, AppleBCMWLANCore *a2)
{
  int v5 = (AppleBCMWLAN11axAdapter *)0xAAAAAAAAAAAAAAAALL;
  if (OSObjectAllocate((OSMetaClass *)gAppleBCMWLAN11axAdapterMetaClass, (OSObject **)&v5)) {
    return 0;
  }
  uint64_t v3 = v5;
  if (v5 && (AppleBCMWLAN11axAdapter::initWithDriver((OSObject *)v5, this) & 1) == 0)
  {
    (*(void (**)(AppleBCMWLAN11axAdapter *))(*(void *)v3 + 16))(v3);
    return 0;
  }
  return v3;
}

uint64_t AppleBCMWLAN11axAdapter::initWithDriver(OSObject *this, AppleBCMWLANCore *a2)
{
  int v4 = (OSObject_vtbl *)IOMallocZeroTyped();
  this[1].OSMetaClassBase::__vftable = v4;
  if (v4)
  {
    v4->getMetaClass = (const OSMetaClass *(__cdecl *)(const OSMetaClassBase *__hidden))a2;
    getMetaClass = (AppleBCMWLANCore *)this[1].getMetaClass;
    if (getMetaClass)
    {
      this[1].retain = (void (__cdecl *)(const OSObject *__hidden))AppleBCMWLANCore::getCommander(getMetaClass);
      unsigned int v6 = this[1].OSMetaClassBase::__vftable;
      if (v6->retain)
      {
        this[1].release = (void (__cdecl *)(const OSObject *__hidden))AppleBCMWLANCore::getConfigManager((AppleBCMWLANCore *)v6->getMetaClass);
        if (this[1].release)
        {
          this[1].isEqualTo = (BOOL (__cdecl *)(const OSMetaClassBase *__hidden, const OSMetaClassBase *))(*(uint64_t (**)(AppleBCMWLANCore *))(*(void *)a2 + 1848))(a2);
          isEqualTo = this[1].isEqualTo;
          if (isEqualTo)
          {
            (*(void (**)(BOOL (__cdecl *)(const OSMetaClassBase *__hidden, const OSMetaClassBase *)))(*(void *)isEqualTo + 8))(isEqualTo);
            if (OSObject::init(this)) {
              return 1;
            }
            IOLog("AppleBCMWLAN11axAdapter super init failied\n");
          }
          else
          {
            IOLog("AppleBCMWLAN11axAdapter Failed to init fLogger\n");
          }
        }
        else
        {
          IOLog("AppleBCMWLAN11axAdapter configManager is null\n");
        }
      }
      else
      {
        IOLog("AppleBCMWLAN11axAdapter commander is null\n");
      }
    }
    else
    {
      IOLog("AppleBCMWLAN11axAdapter driver is null\n");
    }
  }
  else
  {
    IOLog("Failed to allocate AppleBCMWLAN11axAdapter_IVars\n");
  }
  return 0;
}

void AppleBCMWLAN11axAdapter::free(OSObject *this)
{
  uint64_t v2 = this[1].OSMetaClassBase::__vftable;
  if (v2)
  {
    isEqualTo = v2->isEqualTo;
    if (!isEqualTo
      || ((*(void (**)(BOOL (__cdecl *)(const OSMetaClassBase *__hidden, const OSMetaClassBase *)))(*(void *)isEqualTo + 16))(v2->isEqualTo),
          this[1].isEqualTo = 0,
          (uint64_t v2 = this[1].OSMetaClassBase::__vftable) != 0))
    {
      IOFree(v2, 0x20uLL);
      this[1].OSMetaClassBase::__vftable = 0;
    }
  }
  OSObject::free(this);
}

void non-virtual thunk to'AppleBCMWLAN11axAdapter::free(AppleBCMWLAN11axAdapter *this)
{
}

uint64_t AppleBCMWLAN11axAdapter::configureUpLinkOFDMA(AppleBCMWLANCore ***this, int a2)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  int v12 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  if (AppleBCMWLANCore::getFirmwareInterfaceVersion(*this[5]) > 0x14)
  {
    int v4 = &v14;
    int v5 = (BOOL *)&v16;
    unsigned int v6 = (uint64_t *)((char *)&v15 + 4);
    uint64_t v14 = 0x400020014000DLL;
    LOBYTE(v15) = 7;
    uint64_t v7 = 24;
  }
  else
  {
    int v4 = &v10;
    int v5 = (BOOL *)&v11 + 4;
    unsigned int v6 = &v11;
    uint64_t v10 = 0x400010010000DLL;
    uint64_t v7 = 20;
  }
  *(_WORD *)unsigned int v6 = 4;
  BOOL *v5 = a2 != 0;
  v13[0] = v4;
  v13[1] = v7;
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)*this[5] + 88))(*this[5]);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 136))(v8)) {
    return AppleBCMWLANCommander::sendIOVarSet(this[5][1], (uint64_t)"he");
  }
  else {
    return AppleBCMWLANCommander::runIOVarSet(this[5][1], (uint64_t)"he", (uint64_t)v13, 0, 0);
  }
}

uint64_t AppleBCMWLAN11axAdapter::handleUlOfdmaConfigurationAsyncCallback(uint64_t result, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = result;
  if (a3)
  {
    uint64_t result = *(void *)(*(void *)(result + 40) + 24);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result)
      {
        unsigned int v6 = *(void **)(v4 + 40);
        uint64_t v7 = (CCLogStream *)v6[3];
        uint64_t v8 = (const char *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v6 + 112))(*v6, a3);
        return CCLogStream::logAlert(v7, "[dk] %s@%d:11ax: Error: Failed to Configure UL OFDMA: %s\n", "handleUlOfdmaConfigurationAsyncCallback", 250, v8);
      }
    }
  }
  else if (!*a4)
  {
    uint64_t result = *(void *)(*(void *)(result + 40) + 24);
    if (result)
    {
      uint64_t result = CCLogStream::shouldLog();
      if (result) {
        return CCLogStream::logNotice(*(CCLogStream **)(*(void *)(v4 + 40) + 24), "[dk] %s@%d:11ax: No valid data while configuring UL OFDMA\n", "handleUlOfdmaConfigurationAsyncCallback", 255);
      }
    }
  }
  return result;
}

void _GLOBAL__sub_I_AppleBCMWLAN11axAdapter_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANNearbyDeviceDiscoveryAdapter_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100390CD8;
  return 0;
}

uint64_t AppleBCMWLANNearbyDeviceDiscoveryAdapterMetaClass::New(AppleBCMWLANNearbyDeviceDiscoveryAdapterMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100381550;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100381598;
  return 0;
}

uint64_t AppleBCMWLANSensingAdapter_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100390DB8;
  return 0;
}

uint64_t AppleBCMWLANSensingAdapterMetaClass::New(AppleBCMWLANSensingAdapterMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038DE28;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038DE70;
  return 0;
}

uint64_t AppleBCMWLANWnmAdapter_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100390E98;
  return 0;
}

uint64_t AppleBCMWLANWnmAdapterMetaClass::New(AppleBCMWLANWnmAdapterMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038AE08;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038AE58;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038AE78;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANWnmAdapter_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANLQM_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100390F78;
  return 0;
}

uint64_t AppleBCMWLANLQMMetaClass::New(AppleBCMWLANLQMMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100381358;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_1003813A0;
  return 0;
}

uint64_t AppleBCMWLANNetAdapter_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100391058;
  return 0;
}

uint64_t AppleBCMWLANNetAdapterMetaClass::New(AppleBCMWLANNetAdapterMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100381470;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_1003814B8;
  return 0;
}

uint64_t AppleBCMWLANInfraProtocol_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100391138;
  return 0;
}

uint64_t AppleBCMWLANInfraProtocolMetaClass::New(AppleBCMWLANInfraProtocolMetaClass *this, OSObject *a2)
{
  return 3758097127;
}

uint64_t AppleBCMWLANInfraProtocol::_Dispatch(AppleBCMWLANInfraProtocol *this, IORPCMessageMach **a2, IORPC *a3)
{
  return IO80211InfraProtocol::_Dispatch();
}

uint64_t AppleBCMWLANInfraProtocolMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

uint64_t AppleBCMWLANRoamAdapter_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100391218;
  return 0;
}

uint64_t AppleBCMWLANRoamAdapterMetaClass::New(AppleBCMWLANRoamAdapterMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003814E8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100381530;
  return 0;
}

uint64_t AppleBCMWLANScanAdapter_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003912F8;
  return 0;
}

uint64_t AppleBCMWLANScanAdapterMetaClass::New(AppleBCMWLANScanAdapterMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038EE28;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038EE78;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038EE98;
  return 0;
}

uint64_t AppleBCMWLANApFeatureConfig_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003913D8;
  return 0;
}

uint64_t AppleBCMWLANApFeatureConfigMetaClass::New(AppleBCMWLANApFeatureConfigMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003815B8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100381610;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100381630;
  return 0;
}

uint64_t AppleBCMWLANGASAdapter_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003914B8;
  return 0;
}

uint64_t AppleBCMWLANGASAdapterMetaClass::New(AppleBCMWLANGASAdapterMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100381650;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100381698;
  return 0;
}

uint64_t AppleBCMWLANBssManager_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100391598;
  return 0;
}

uint64_t AppleBCMWLANBssManagerMetaClass::New(AppleBCMWLANBssManagerMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003816B8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100381700;
  return 0;
}

uint64_t AppleBCMWLANIOReportingCore_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100391678;
  return 0;
}

uint64_t AppleBCMWLANIOReportingCoreMetaClass::New(AppleBCMWLANIOReportingCoreMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100381CC0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100381D30;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100381D50;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANIOReportingCore_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANIOReportingPerSlice_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100391758;
  return 0;
}

uint64_t AppleBCMWLANIOReportingPerSliceMetaClass::New(AppleBCMWLANIOReportingPerSliceMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100383898;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100383908;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100383928;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANIOReportingPerSlice_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANIOReporting_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100391838;
  return 0;
}

uint64_t AppleBCMWLANIOReportingMetaClass::New(AppleBCMWLANIOReportingMetaClass *this, OSObject *a2)
{
  return 3758097127;
}

uint64_t AppleBCMWLANChipManagerPCIe4388_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100391918;
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe4388MetaClass::New(AppleBCMWLANChipManagerPCIe4388MetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100383960;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_100383A70;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_100383A90;
  a2[1].meta = (OSMetaClass *)off_100383AC0;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANChipManagerPCIe4388_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANChipManagerPCIe4350_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003919F8;
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe4350MetaClass::New(AppleBCMWLANChipManagerPCIe4350MetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100383B78;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_100383C88;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_100383CA8;
  a2[1].meta = (OSMetaClass *)off_100383CD8;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANChipManagerPCIe4350_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANChipManagerPCIe4364_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100391AD8;
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe4364MetaClass::New(AppleBCMWLANChipManagerPCIe4364MetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100383D90;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_100383EA0;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_100383EC0;
  a2[1].meta = (OSMetaClass *)off_100383EF0;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANChipManagerPCIe4364_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANChipManagerPCIe43452_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100391BB8;
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe43452MetaClass::New(AppleBCMWLANChipManagerPCIe43452MetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100383FA8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_1003840B8;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_1003840D8;
  a2[1].meta = (OSMetaClass *)off_100384108;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANChipManagerPCIe43452_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANChipManagerPCIe4355_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100391C98;
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe4355MetaClass::New(AppleBCMWLANChipManagerPCIe4355MetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003841C0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_1003842D0;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_1003842F0;
  a2[1].meta = (OSMetaClass *)off_100384320;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANChipManagerPCIe4355_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANJoinAdapter_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100391D78;
  return 0;
}

uint64_t AppleBCMWLANJoinAdapterMetaClass::New(AppleBCMWLANJoinAdapterMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003845F0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100384640;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100384660;
  return 0;
}

uint64_t AppleBCMWLANIO80211APSTAInterface_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100391E58;
  return 0;
}

uint64_t AppleBCMWLANIO80211APSTAInterfaceMetaClass::New(AppleBCMWLANIO80211APSTAInterfaceMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100391E98;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_100392578;
  *(void *)&a2[1].__int32 refcount = &off_100392598;
  a2[1].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_1003926F0;
  a2[2].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100392768;
  a2[2].meta = (OSMetaClass *)&off_100392AD8;
  a2[2].ivars = (OSObject_IVars *)off_100392B90;
  *(void *)&a2[3].__int32 refcount = off_100392C78;
  return 0;
}

uint64_t AppleBCMWLANIO80211APSTAInterface::Dispatch(AppleBCMWLANIO80211APSTAInterface *this, IORPC *a2)
{
  return IO80211SapProtocol::_Dispatch();
}

uint64_t AppleBCMWLANIO80211APSTAInterfaceMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

void _GLOBAL__sub_I_AppleBCMWLANIO80211APSTAInterface_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANLowLatencyInterface_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100392E08;
  return 0;
}

uint64_t AppleBCMWLANLowLatencyInterfaceMetaClass::New(AppleBCMWLANLowLatencyInterfaceMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100392E48;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_1003939B8;
  *(void *)&a2[1].__int32 refcount = &off_1003939D8;
  a2[1].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100393B30;
  a2[2].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100393BA8;
  a2[2].meta = (OSMetaClass *)&off_100393F18;
  a2[2].ivars = (OSObject_IVars *)off_100393F50;
  *(void *)&a2[3].__int32 refcount = off_100394548;
  a2[3].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100394B40;
  return 0;
}

uint64_t AppleBCMWLANLowLatencyInterface::Dispatch(AppleBCMWLANLowLatencyInterface *this, IORPC *a2)
{
  message = a2->message;
  long long v7 = *(_OWORD *)&a2->reply;
  IORPCMessageFromMach(message, 0);
  unsigned int v6 = message;
  return AppleBCMWLANSkywalkInterface::_Dispatch(this, &v6, v4);
}

uint64_t AppleBCMWLANLowLatencyInterfaceMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

uint64_t AppleBCMWLANNANDataInterface_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100394BF8;
  return 0;
}

uint64_t AppleBCMWLANNANDataInterfaceMetaClass::New(AppleBCMWLANNANDataInterfaceMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100394C38;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_100395258;
  *(void *)&a2[1].__int32 refcount = &off_100395278;
  a2[1].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_1003953D0;
  a2[2].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100395448;
  a2[2].meta = (OSMetaClass *)&off_1003957B8;
  a2[2].ivars = (OSObject_IVars *)off_100395870;
  *(void *)&a2[3].__int32 refcount = &off_100395890;
  return 0;
}

uint64_t AppleBCMWLANNANDataInterface::Dispatch(AppleBCMWLANNANDataInterface *this, IORPC *a2)
{
  return IO80211NANDataProtocol::_Dispatch();
}

uint64_t AppleBCMWLANNANDataInterfaceMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

uint64_t AppleBCMWLANNANInterface_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100395960;
  return 0;
}

uint64_t AppleBCMWLANNANInterfaceMetaClass::New(AppleBCMWLANNANInterfaceMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003959A0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_1003962A0;
  *(void *)&a2[1].__int32 refcount = &off_1003962C0;
  a2[1].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100396418;
  a2[2].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100396490;
  a2[2].meta = (OSMetaClass *)&off_100396800;
  a2[2].ivars = (OSObject_IVars *)off_1003968B8;
  *(void *)&a2[3].__int32 refcount = &off_100396BB8;
  return 0;
}

uint64_t AppleBCMWLANNANInterface::Dispatch(AppleBCMWLANNANInterface *this, IORPC *a2)
{
  return IO80211NANProtocol::_Dispatch();
}

uint64_t AppleBCMWLANNANInterfaceMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

void _GLOBAL__sub_I_AppleBCMWLANNANInterface_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANProximityInterface_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100396F68;
  return 0;
}

uint64_t AppleBCMWLANProximityInterfaceMetaClass::New(AppleBCMWLANProximityInterfaceMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100396FA8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_1003977C0;
  *(void *)&a2[1].__int32 refcount = &off_1003977E0;
  a2[1].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100397938;
  a2[2].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003979B0;
  a2[2].meta = (OSMetaClass *)&off_100397D20;
  a2[2].ivars = (OSObject_IVars *)off_100397DD8;
  *(void *)&a2[3].__int32 refcount = off_100397FE8;
  return 0;
}

uint64_t AppleBCMWLANProximityInterface::Dispatch(AppleBCMWLANProximityInterface *this, IORPC *a2)
{
  return IO80211AWDLProtocol::_Dispatch();
}

uint64_t AppleBCMWLANProximityInterfaceMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

void _GLOBAL__sub_I_AppleBCMWLANProximityInterface_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANChipManagerPCIe4357_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003982B0;
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe4357MetaClass::New(AppleBCMWLANChipManagerPCIe4357MetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100384958;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_100384A68;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_100384A88;
  a2[1].meta = (OSMetaClass *)off_100384AB8;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANChipManagerPCIe4357_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANChipManagerPCIe4387_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100398390;
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe4387MetaClass::New(AppleBCMWLANChipManagerPCIe4387MetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100384B70;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_100384C80;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_100384CA0;
  a2[1].meta = (OSMetaClass *)off_100384CD0;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANChipManagerPCIe4387_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANAudioProtector_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100398470;
  return 0;
}

uint64_t AppleBCMWLANAudioProtectorMetaClass::New(AppleBCMWLANAudioProtectorMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100384DF8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100384E80;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100384EA0;
  a2[1].meta = (OSMetaClass *)&off_100384EE8;
  return 0;
}

uint64_t AppleBCMWLANCoreDbg_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100398550;
  return 0;
}

uint64_t AppleBCMWLANCoreDbgMetaClass::New(AppleBCMWLANCoreDbgMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100386E60;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100386EA8;
  return 0;
}

uint64_t AppleBCMWLANBusSkywalk_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100398630;
  return 0;
}

uint64_t AppleBCMWLANBusSkywalkMetaClass::New(AppleBCMWLANBusSkywalkMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100387040;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_1003870E0;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100387100;
  return 0;
}

uint64_t AppleBCMWLANPCIeSkywalk_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100398710;
  return 0;
}

uint64_t AppleBCMWLANPCIeSkywalkMetaClass::New(AppleBCMWLANPCIeSkywalkMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003871E8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_100387288;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003872A8;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANPCIeSkywalk_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANPCIeSkywalkFlowQueue_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003987F0;
  return 0;
}

uint64_t AppleBCMWLANPCIeSkywalkFlowQueueMetaClass::New(AppleBCMWLANPCIeSkywalkFlowQueueMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003873A0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_1003873E8;
  return 0;
}

uint64_t AppleBCMWLANPCIeSkywalkMulticastQueue_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003988D0;
  return 0;
}

uint64_t AppleBCMWLANPCIeSkywalkMulticastQueueMetaClass::New(AppleBCMWLANPCIeSkywalkMulticastQueueMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100387498;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100387538;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_100387558;
  a2[1].meta = (OSMetaClass *)&off_1003875A0;
  return 0;
}

uint64_t AppleBCMWLANPCIeSkywalkRxCompletionQueue_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003989B0;
  return 0;
}

uint64_t AppleBCMWLANPCIeSkywalkRxCompletionQueueMetaClass::New(AppleBCMWLANPCIeSkywalkRxCompletionQueueMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003875D0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_1003876D8;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003876F8;
  a2[1].meta = (OSMetaClass *)&off_100387768;
  a2[1].ivars = (OSObject_IVars *)&off_100387780;
  return 0;
}

uint64_t AppleBCMWLANPCIeSkywalkRxSubmissionQueue_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100398A90;
  return 0;
}

uint64_t AppleBCMWLANPCIeSkywalkRxSubmissionQueueMetaClass::New(AppleBCMWLANPCIeSkywalkRxSubmissionQueueMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003877E8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_1003878E0;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100387900;
  a2[1].meta = (OSMetaClass *)&off_100387970;
  a2[1].ivars = (OSObject_IVars *)&off_100387988;
  return 0;
}

uint64_t AppleBCMWLANBGScanAdapter_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100398B70;
  return 0;
}

uint64_t AppleBCMWLANBGScanAdapterMetaClass::New(AppleBCMWLANBGScanAdapterMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003813C0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100381408;
  return 0;
}

uint64_t AppleBCMWLANPCIeSkywalkTxCompletionQueue_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100398C50;
  return 0;
}

uint64_t AppleBCMWLANPCIeSkywalkTxCompletionQueueMetaClass::New(AppleBCMWLANPCIeSkywalkTxCompletionQueueMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003879E0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100387AD0;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100387AF0;
  a2[1].meta = (OSMetaClass *)&off_100387B60;
  a2[1].ivars = (OSObject_IVars *)&off_100387B78;
  return 0;
}

uint64_t AppleBCMWLANPCIeSkywalkTxSubmissionQueue_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100398D30;
  return 0;
}

uint64_t AppleBCMWLANPCIeSkywalkTxSubmissionQueueMetaClass::New(AppleBCMWLANPCIeSkywalkTxSubmissionQueueMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100387BC8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100387D08;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100387D28;
  a2[1].meta = (OSMetaClass *)&off_100387D98;
  a2[1].ivars = (OSObject_IVars *)&off_100387DB8;
  return 0;
}

uint64_t AppleBCMWLANConfigManager_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100398E10;
  return 0;
}

uint64_t AppleBCMWLANConfigManagerMetaClass::New(AppleBCMWLANConfigManagerMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100387E90;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100387EE0;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100387F00;
  return 0;
}

uint64_t IOImageLoaderImageDictionary_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100398EF0;
  return 0;
}

uint64_t IOImageLoaderImageDictionaryMetaClass::New(IOImageLoaderImageDictionaryMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100398F30;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100398FA8;
  *(void *)&a2[1].__int32 refcount = off_100398FC8;
  return 0;
}

uint64_t AppleBCMWLAN11axAdapter_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003990A8;
  return 0;
}

uint64_t AppleBCMWLAN11axAdapterMetaClass::New(AppleBCMWLAN11axAdapterMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100390BD0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100390C18;
  return 0;
}

uint64_t AppleBCMWLANChipMemory_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100399188;
  return 0;
}

uint64_t AppleBCMWLANChipMemoryMetaClass::New(AppleBCMWLANChipMemoryMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100387F18;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100387F68;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100387F88;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANChipMemory_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANPCIeSkywalkPacket_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100399268;
  return 0;
}

uint64_t AppleBCMWLANPCIeSkywalkPacketMetaClass::New(AppleBCMWLANPCIeSkywalkPacketMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003880D8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100388338;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100388358;
  a2[1].meta = (OSMetaClass *)off_100388510;
  a2[1].ivars = (OSObject_IVars *)&off_100388588;
  return 0;
}

uint64_t AppleBCMWLANPCIeSkywalkPacketPool_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100399348;
  return 0;
}

uint64_t AppleBCMWLANPCIeSkywalkPacketPoolMetaClass::New(AppleBCMWLANPCIeSkywalkPacketPoolMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100387FA0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100388040;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100388060;
  a2[1].meta = (OSMetaClass *)off_1003880B8;
  return 0;
}

uint64_t AppleBCMWLANDynamicRingOperationContext_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100399428;
  return 0;
}

uint64_t AppleBCMWLANDynamicRingOperationContextMetaClass::New(AppleBCMWLANDynamicRingOperationContextMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100388638;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100388680;
  return 0;
}

uint64_t AppleBCMWLANKeepAliveOffload_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100399508;
  return 0;
}

uint64_t AppleBCMWLANKeepAliveOffloadMetaClass::New(AppleBCMWLANKeepAliveOffloadMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100388748;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100388790;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANKeepAliveOffload_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANBusInterface_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003995E8;
  return 0;
}

uint64_t AppleBCMWLANBusInterfaceMetaClass::New(AppleBCMWLANBusInterfaceMetaClass *this, OSObject *a2)
{
  return 3758097127;
}

uint64_t AppleBCMWLANBusInterface::_Dispatch(IOService *this, IORPC *a2, IORPC *a3)
{
  uint64_t msgid = IORPCMessageFromMach(a2->message, 0)->msgid;
  if (msgid == 0x98E715041C459FA5)
  {
    IORPC v8 = *a2;
    return IOService::Stop_Invoke(&v8, this, (IOService::Stop_Handler)AppleBCMWLANBusInterface::Stop_Impl);
  }
  else if (msgid == 0xAB6F76DDE6D693F2)
  {
    IORPC rpc = *a2;
    return IOService::Start_Invoke(&rpc, this, (IOService::Start_Handler)AppleBCMWLANBusInterface::Start_Impl);
  }
  else
  {
    IORPC v7 = *a2;
    return IOService::_Dispatch(this, &v7);
  }
}

uint64_t AppleBCMWLANBusInterfaceMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

void _GLOBAL__sub_I_AppleBCMWLANBusInterface_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANUserClient_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003996C8;
  return 0;
}

uint64_t AppleBCMWLANUserClientMetaClass::New(AppleBCMWLANUserClientMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100399708;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_100399758;
  *(void *)&a2[1].__int32 refcount = &off_100399778;
  return 0;
}

uint64_t AppleBCMWLANUserClient::Dispatch(IOUserClient *this, IORPC *a2, IORPC *a3)
{
  IORPC v4 = *a2;
  return AppleBCMWLANUserClient::_Dispatch(this, &v4, a3);
}

uint64_t AppleBCMWLANUserClient::_Dispatch(IOUserClient *this, IORPC *a2, IORPC *a3)
{
  uint64_t msgid = IORPCMessageFromMach(a2->message, 0)->msgid;
  switch(msgid)
  {
    case 0x8399BDB3D0B4F474:
      if (OSMetaClassBase::IsRemote(this))
      {
        IORPC invoke = *a2;
        return OSMetaClassBase::Dispatch(this, &invoke);
      }
      else
      {
        IORPC v8 = *a2;
        return IOUserClient::CopyClientMemoryForType_Invoke(&v8, this, (IOUserClient::CopyClientMemoryForType_Handler)AppleBCMWLANUserClient::CopyClientMemoryForType_Impl);
      }
    case 0x98E715041C459FA5:
      IORPC v10 = *a2;
      return IOService::Stop_Invoke(&v10, this, (IOService::Stop_Handler)AppleBCMWLANUserClient::Stop_Impl);
    case 0xAB6F76DDE6D693F2:
      IORPC rpc = *a2;
      return IOService::Start_Invoke(&rpc, this, (IOService::Start_Handler)AppleBCMWLANUserClient::Start_Impl);
    default:
      IORPC v7 = *a2;
      return IOUserClient::_Dispatch(this, &v7);
  }
}

uint64_t AppleBCMWLANUserClientMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

void _GLOBAL__sub_I_AppleBCMWLANUserClient_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANProvisioningManager_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100399830;
  return 0;
}

uint64_t AppleBCMWLANProvisioningManagerMetaClass::New(AppleBCMWLANProvisioningManagerMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038A1F8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038A248;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038A268;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANProvisioningManager_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANCoreFirmwareLoader_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100399910;
  return 0;
}

uint64_t AppleBCMWLANCoreFirmwareLoaderMetaClass::New(AppleBCMWLANCoreFirmwareLoaderMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100399950;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_100399998;
  return 0;
}

uint64_t AppleBCMWLANCoreFirmwareLoader::Dispatch(IOService *this, IORPC *a2, IORPC *a3)
{
  IORPC v4 = *a2;
  return AppleBCMWLANCoreFirmwareLoader::_Dispatch(this, &v4, a3);
}

uint64_t AppleBCMWLANCoreFirmwareLoader::_Dispatch(IOService *this, IORPC *a2, IORPC *a3)
{
  uint64_t msgid = IORPCMessageFromMach(a2->message, 0)->msgid;
  if (msgid == 0x98E715041C459FA5)
  {
    IORPC v8 = *a2;
    return IOService::Stop_Invoke(&v8, this, (IOService::Stop_Handler)AppleBCMWLANCoreFirmwareLoader::Stop_Impl);
  }
  else if (msgid == 0xAB6F76DDE6D693F2)
  {
    IORPC rpc = *a2;
    return IOService::Start_Invoke(&rpc, this, (IOService::Start_Handler)AppleBCMWLANCoreFirmwareLoader::Start_Impl);
  }
  else
  {
    IORPC v7 = *a2;
    return IOService::_Dispatch(this, &v7);
  }
}

uint64_t AppleBCMWLANCoreFirmwareLoaderMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

uint64_t AppleBCMWLANLogger_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100399A58;
  return 0;
}

uint64_t AppleBCMWLANLoggerMetaClass::New(AppleBCMWLANLoggerMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003908B0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100390900;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100390920;
  return 0;
}

uint64_t AppleBCMWLANChipImage_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100399B38;
  return 0;
}

uint64_t AppleBCMWLANChipImageMetaClass::New(AppleBCMWLANChipImageMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038A2A8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038A378;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_10038A398;
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe4378_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100399C18;
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe4378MetaClass::New(AppleBCMWLANChipManagerPCIe4378MetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038DE90;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_10038DFA0;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_10038DFC0;
  a2[1].meta = (OSMetaClass *)off_10038DFF0;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANChipManagerPCIe4378_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANPCIeIO_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100399CF8;
  return 0;
}

uint64_t AppleBCMWLANPCIeIOMetaClass::New(AppleBCMWLANPCIeIOMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038AE90;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038AEE0;
  *(void *)&a2[1].__int32 refcount = &off_10038AF00;
  return 0;
}

uint64_t AppleBCMWLANDMASlab_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100399DD8;
  return 0;
}

uint64_t AppleBCMWLANDMASlabMetaClass::New(AppleBCMWLANDMASlabMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038AF18;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038AF68;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038AF88;
  return 0;
}

uint64_t AppleBCMWLANPCIeLinkChangeEventSource_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100399EB8;
  return 0;
}

uint64_t AppleBCMWLANPCIeLinkChangeEventSourceMetaClass::New(AppleBCMWLANPCIeLinkChangeEventSourceMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038AFA0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038B020;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038B040;
  return 0;
}

uint64_t AppleBCMWLANLeakyApParser_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_100399F98;
  return 0;
}

uint64_t AppleBCMWLANLeakyApParserMetaClass::New(AppleBCMWLANLeakyApParserMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100390AE0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100390B30;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100390B50;
  return 0;
}

uint64_t AppleBCMWLANSkywalkInterface_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039A078;
  return 0;
}

uint64_t AppleBCMWLANSkywalkInterfaceMetaClass::New(AppleBCMWLANSkywalkInterfaceMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10039A0B8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_10039AC28;
  *(void *)&a2[1].__int32 refcount = &off_10039AC48;
  a2[1].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10039ADA0;
  a2[2].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10039AE18;
  a2[2].meta = (OSMetaClass *)&off_10039B188;
  a2[2].ivars = (OSObject_IVars *)off_10039B1C0;
  *(void *)&a2[3].__int32 refcount = off_10039B7B8;
  a2[3].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10039BDB0;
  return 0;
}

uint64_t AppleBCMWLANSkywalkInterface::Dispatch(AppleBCMWLANSkywalkInterface *this, IORPC *a2)
{
  message = a2->message;
  long long v7 = *(_OWORD *)&a2->reply;
  IORPCMessageFromMach(message, 0);
  unsigned int v6 = message;
  return AppleBCMWLANInfraProtocol::_Dispatch(this, &v6, v4);
}

uint64_t AppleBCMWLANSkywalkInterface::_Dispatch(AppleBCMWLANSkywalkInterface *this, IORPCMessageMach **a2, IORPC *a3)
{
  IORPCMessageFromMach(*a2, 0);
  long long v7 = *(_OWORD *)a2;
  IORPC v8 = a2[2];
  return AppleBCMWLANInfraProtocol::_Dispatch(this, (IORPCMessageMach **)&v7, v5);
}

uint64_t AppleBCMWLANSkywalkInterfaceMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

uint64_t AppleBCMWLANSkywalkRxSubmissionQueue_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039BE68;
  return 0;
}

uint64_t AppleBCMWLANSkywalkRxSubmissionQueueMetaClass::New(AppleBCMWLANSkywalkRxSubmissionQueueMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038A8C0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038A9B8;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038A9D8;
  a2[1].meta = (OSMetaClass *)&off_10038AA48;
  a2[1].ivars = (OSObject_IVars *)&off_10038AA60;
  return 0;
}

uint64_t AppleBCMWLANPCIeCompletionRing_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039BF48;
  return 0;
}

uint64_t AppleBCMWLANPCIeCompletionRingMetaClass::New(AppleBCMWLANPCIeCompletionRingMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038B430;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038B570;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038B590;
  a2[1].meta = (OSMetaClass *)&off_10038B5D8;
  a2[1].ivars = (OSObject_IVars *)off_10038B630;
  *(void *)&a2[2].__int32 refcount = &off_10038B660;
  a2[2].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_10038B688;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANPCIeCompletionRing_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANPCIeTransmitFlowRing_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039C028;
  return 0;
}

uint64_t AppleBCMWLANPCIeTransmitFlowRingMetaClass::New(AppleBCMWLANPCIeTransmitFlowRingMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038B6D8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038B8A0;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_10038B8C0;
  a2[1].meta = (OSMetaClass *)&off_10038B908;
  a2[1].ivars = (OSObject_IVars *)off_10038B960;
  *(void *)&a2[2].__int32 refcount = &off_10038B990;
  a2[2].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_10038B9B8;
  a2[3].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038BA10;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANPCIeTransmitFlowRing_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANPCIeSubmissionRing_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039C108;
  return 0;
}

uint64_t AppleBCMWLANPCIeSubmissionRingMetaClass::New(AppleBCMWLANPCIeSubmissionRingMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038BAA0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038BBE8;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038BC08;
  a2[1].meta = (OSMetaClass *)&off_10038BC50;
  a2[1].ivars = (OSObject_IVars *)off_10038BCA8;
  *(void *)&a2[2].__int32 refcount = &off_10038BCD8;
  a2[2].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_10038BD00;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANPCIeSubmissionRing_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANChipManagerPCIe0x4377b_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039C1E8;
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe0x4377bMetaClass::New(AppleBCMWLANChipManagerPCIe0x4377bMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038B088;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_10038B198;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_10038B1B8;
  a2[1].meta = (OSMetaClass *)off_10038B1E8;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANChipManagerPCIe0x4377b_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANObjectQueue_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039C2C8;
  return 0;
}

uint64_t AppleBCMWLANObjectQueueMetaClass::New(AppleBCMWLANObjectQueueMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003886A0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100388700;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_100388720;
  return 0;
}

uint64_t AppleBCMWLANCore_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039C448;
  return 0;
}

uint64_t AppleBCMWLANCoreMetaClass::New(AppleBCMWLANCoreMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10039C488;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_10039CC00;
  *(void *)&a2[1].__int32 refcount = &off_10039CC20;
  a2[1].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_10039CE08;
  return 0;
}

uint64_t AppleBCMWLANCore::Dispatch(OSMetaClassBase *this, IORPC *a2, IORPC *a3)
{
  IORPC v4 = *a2;
  return AppleBCMWLANCore::_Dispatch(this, (AppleBCMWLANCore *)&v4, a3);
}

uint64_t AppleBCMWLANCore::_Dispatch(OSMetaClassBase *this, AppleBCMWLANCore *a2, IORPC *a3)
{
  int64_t msgid = IORPCMessageFromMach(*(IORPCMessageMach **)a2, 0)->msgid;
  if (msgid <= (uint64_t)0xD200FDE7D57ECCA5)
  {
    switch(msgid)
    {
      case 0x98E715041C459FA5:
        IORPC v20 = *(IORPC *)a2;
        return IOService::Stop_Invoke(&v20, this, (IOService::Stop_Handler)AppleBCMWLANCore::Stop_Impl);
      case 0xAB6F76DDE6D693F2:
        IORPC v21 = *(IORPC *)a2;
        return IOService::Start_Invoke(&v21, this, (IOService::Start_Handler)AppleBCMWLANCore::Start_Impl);
      case 0xAD8461D6BB5E656DLL:
        *(_OWORD *)&v17.OSObject::OSMetaClassBase::__vftable = *(_OWORD *)a2;
        v17.meta = (OSMetaClass *)*((void *)a2 + 2);
        return IOService::UserSetProperties_Invoke(&v17, (IORPC *)this, (OSMetaClassBase *)AppleBCMWLANCore::UserSetProperties_Impl, v6);
    }
    goto LABEL_17;
  }
  switch(msgid)
  {
    case 0x60115E833B5C88C7:
      if (OSMetaClassBase::IsRemote(this))
      {
        long long v15 = *(_OWORD *)a2;
        uint64_t v16 = *((void *)a2 + 2);
        p_IORPC invoke = (IORPC *)&v15;
        return OSMetaClassBase::Dispatch(this, p_invoke);
      }
      long long v13 = *(_OWORD *)a2;
      uint64_t v14 = *((void *)a2 + 2);
      return IOServiceStateNotificationDispatchSource::StateNotificationReady_Invoke((IOServiceStateNotificationDispatchSource *)&v13, (IORPC *)this, (OSMetaClassBase *)AppleBCMWLANCore::SystemStateNotificationReady_Impl, (void (*)(OSMetaClassBase *, OSAction *))gOSAction_AppleBCMWLANCore_SystemStateNotificationReadyMetaClass, v9);
    case 0xF669EFFFCB89ED9CLL:
      if (OSMetaClassBase::IsRemote(this))
      {
        IORPC invoke = *(IORPC *)a2;
        p_IORPC invoke = &invoke;
        return OSMetaClassBase::Dispatch(this, p_invoke);
      }
      *(_OWORD *)&v17.ivars = *(_OWORD *)a2;
      uint64_t v18 = *((void *)a2 + 2);
      return IOService::NewUserClient_Invoke((const IORPC *)&v17.ivars, this, (IOService::NewUserClient_Handler)AppleBCMWLANCore::NewUserClient_Impl);
    case 0xD200FDE7D57ECCA6:
      IORPC rpc = *(IORPC *)a2;
      return IOService::SetPowerState_Invoke(&rpc, this, (IOService::SetPowerState_Handler)AppleBCMWLANCore::SetPowerState_Impl);
    default:
LABEL_17:
      long long v11 = *(_OWORD *)a2;
      uint64_t v12 = *((void *)a2 + 2);
      return IO80211Controller::_Dispatch((IO80211Controller *)this, (IO80211Controller *)&v11, v5);
  }
}

uint64_t AppleBCMWLANCoreMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

uint64_t AppleBCMWLANCore::CreateActionSystemStateNotificationReady(OSObject *this, size_t a2, OSAction **a3)
{
  unsigned int v6 = OSString::withCString("OSAction_AppleBCMWLANCore_SystemStateNotificationReady");
  if (!v6) {
    return 3758097085;
  }
  long long v7 = v6;
  uint64_t v8 = OSAction::CreateWithTypeName(this, 0x60115E833B5C88C7uLL, 0xDA6F23BBB0B49076, a2, v6, a3);
  ((void (*)(OSString *))v7->release)(v7);
  return v8;
}

uint64_t OSAction_AppleBCMWLANCore_SystemStateNotificationReady_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039D370;
  return 0;
}

uint64_t OSAction_AppleBCMWLANCore_SystemStateNotificationReadyMetaClass::New(OSAction_AppleBCMWLANCore_SystemStateNotificationReadyMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10039D3B0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10039D3F8;
  return 0;
}

uint64_t OSAction_AppleBCMWLANCore_SystemStateNotificationReady::Dispatch(OSAction *this, IORPC *a2)
{
  message = a2->message;
  *(_OWORD *)&v5.reply = *(_OWORD *)&a2->reply;
  IORPCMessageFromMach(message, 0);
  v5.message = message;
  return OSAction::_Dispatch(this, &v5);
}

uint64_t OSAction_AppleBCMWLANCore_SystemStateNotificationReadyMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

uint64_t OSAction_AppleBCMWLANCore_SystemStateNotificationReady::getMetaClass(OSAction_AppleBCMWLANCore_SystemStateNotificationReady *this)
{
  return gOSAction_AppleBCMWLANCore_SystemStateNotificationReadyMetaClass;
}

void _GLOBAL__sub_I_AppleBCMWLANCore_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANPowerManager_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039D4B8;
  return 0;
}

uint64_t AppleBCMWLANPowerManagerMetaClass::New(AppleBCMWLANPowerManagerMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038D9F8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038DA48;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038DA68;
  return 0;
}

uint64_t AppleBCMWLANBusInterfacePCIe_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039D818;
  return 0;
}

uint64_t AppleBCMWLANBusInterfacePCIeMetaClass::New(AppleBCMWLANBusInterfacePCIeMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10039D858;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_10039DD30;
  *(void *)&a2[1].__int32 refcount = &off_10039DD50;
  a2[1].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10039E130;
  return 0;
}

void AppleBCMWLANBusInterfacePCIe::Dispatch(IOService *this, IORPC *a2, IORPC *a3)
{
  IORPC v3 = *a2;
  AppleBCMWLANBusInterfacePCIe::_Dispatch(this, (AppleBCMWLANBusInterfacePCIe *)&v3, a3);
}

void AppleBCMWLANBusInterfacePCIe::_Dispatch(IOService *this, AppleBCMWLANBusInterfacePCIe *a2, IORPC *a3)
{
  int64_t msgid = IORPCMessageFromMach(*(IORPCMessageMach **)a2, 0)->msgid;
  if (msgid > 0xEAC9639AD90BD5FLL)
  {
    if (msgid > 0x26A3EF2B8FBB0C52)
    {
      switch(msgid)
      {
        case 0x26A3EF2B8FBB0C53:
          if (!OSMetaClassBase::IsRemote(this))
          {
            long long v24 = *(_OWORD *)a2;
            uint64_t v25 = *((void *)a2 + 2);
            AppleBCMWLANBusInterfacePCIe::SetPowerStateGatedAMFM_Invoke((uint64_t *)&v24, (uint64_t)this, (unsigned int (*)(uint64_t, void))AppleBCMWLANBusInterfacePCIe::SetPowerStateGatedAMFM_Impl);
            return;
          }
          long long v26 = *(_OWORD *)a2;
          uint64_t v27 = *((void *)a2 + 2);
          p_ivars = (OSObject::$4342D741BF926617E558AFFE07804AA4 *)&v26;
          goto LABEL_34;
        case 0x32D377BD98125256:
          if (!OSMetaClassBase::IsRemote(this))
          {
            IORPC v37 = *(IORPC *)a2;
            IOInterruptDispatchSource::InterruptOccurred_Invoke(&v37, this, (IOInterruptDispatchSource::InterruptOccurred_Handler)AppleBCMWLANBusInterfacePCIe::InterruptOccurred_Impl, (const OSMetaClass *)gOSAction_AppleBCMWLANBusInterfacePCIe_InterruptOccurredMetaClass);
            return;
          }
          long long v38 = *(_OWORD *)a2;
          uint64_t v39 = *((void *)a2 + 2);
          p_ivars = (OSObject::$4342D741BF926617E558AFFE07804AA4 *)&v38;
          goto LABEL_34;
        case 0x445E2EBCE9BB479DLL:
          if (!OSMetaClassBase::IsRemote(this))
          {
            long long v28 = *(_OWORD *)a2;
            uint64_t v29 = *((void *)a2 + 2);
            AppleBCMWLANBusInterfacePCIe::SetPowerStateGated_Invoke((uint64_t *)&v28, (uint64_t)this, (unsigned int (*)(uint64_t, void))AppleBCMWLANBusInterfacePCIe::SetPowerStateGated_Impl);
            return;
          }
          long long v30 = *(_OWORD *)a2;
          uint64_t v31 = *((void *)a2 + 2);
          p_ivars = (OSObject::$4342D741BF926617E558AFFE07804AA4 *)&v30;
          goto LABEL_34;
      }
    }
    else
    {
      switch(msgid)
      {
        case 0xEAC9639AD90BD60:
          if (!OSMetaClassBase::IsRemote(this))
          {
            IORPC v13 = *(IORPC *)a2;
            IODataQueueDispatchSource::DataAvailable_Invoke(&v13, this, (IODataQueueDispatchSource::DataAvailable_Handler)AppleBCMWLANBusInterfacePCIe::RxSubmissionQueueDataAvailable_Impl, (const OSMetaClass *)gOSAction_AppleBCMWLANBusInterfacePCIe_RxSubmissionQueueDataAvailableMetaClass);
            return;
          }
          long long v14 = *(_OWORD *)a2;
          uint64_t v15 = *((void *)a2 + 2);
          p_ivars = (OSObject::$4342D741BF926617E558AFFE07804AA4 *)&v14;
          goto LABEL_34;
        case 0x14C7DCE3B379EA66:
          if (!OSMetaClassBase::IsRemote(this))
          {
            long long v16 = *(_OWORD *)a2;
            uint64_t v17 = *((void *)a2 + 2);
            AppleOLYHALPortInterfacePCIe::portErrorMsgHandler_Invoke((AppleOLYHALPortInterfacePCIe *)&v16, (IORPC *)this, (OSMetaClassBase *)AppleBCMWLANBusInterfacePCIe::PortErrorMsgHandler_Impl, (void (*)(OSMetaClassBase *, OSAction *, OSNumber *, OSNumber *, OSData *))gOSAction_AppleBCMWLANBusInterfacePCIe_PortErrorMsgHandlerMetaClass, v10);
            return;
          }
          long long v18 = *(_OWORD *)a2;
          uint64_t v19 = *((void *)a2 + 2);
          p_ivars = (OSObject::$4342D741BF926617E558AFFE07804AA4 *)&v18;
          goto LABEL_34;
        case 0x1A36D1895F2C94E9:
          if (!OSMetaClassBase::IsRemote(this))
          {
            long long v20 = *(_OWORD *)a2;
            uint64_t v21 = *((void *)a2 + 2);
            AppleOLYHALPortInterfacePCIe::portEventMsgHandler_Invoke((AppleOLYHALPortInterfacePCIe *)&v20, (IORPC *)this, (OSMetaClassBase *)AppleBCMWLANBusInterfacePCIe::PortEventMsgHandler_Impl, (void (*)(OSMetaClassBase *, OSAction *, OSNumber *, OSNumber *, OSNumber *, OSData *))gOSAction_AppleBCMWLANBusInterfacePCIe_PortEventMsgHandlerMetaClass, v7);
            return;
          }
          long long v22 = *(_OWORD *)a2;
          uint64_t v23 = *((void *)a2 + 2);
          p_ivars = (OSObject::$4342D741BF926617E558AFFE07804AA4 *)&v22;
          goto LABEL_34;
      }
    }
LABEL_36:
    IORPC v12 = *(IORPC *)a2;
    AppleBCMWLANBusInterface::_Dispatch(this, &v12, v5);
    return;
  }
  if (msgid > (uint64_t)0x98E715041C459FA4)
  {
    switch(msgid)
    {
      case 0x98E715041C459FA5:
        IORPC v40 = *(IORPC *)a2;
        IOService::Stop_Invoke(&v40, this, (IOService::Stop_Handler)AppleBCMWLANBusInterfacePCIe::Stop_Impl);
        return;
      case 0xAB6F76DDE6D693F2:
        IORPC v41 = *(IORPC *)a2;
        IOService::Start_Invoke(&v41, this, (IOService::Start_Handler)AppleBCMWLANBusInterfacePCIe::Start_Impl);
        return;
      case 0xD200FDE7D57ECCA6:
        IORPC rpc = *(IORPC *)a2;
        IOService::SetPowerState_Invoke(&rpc, this, (IOService::SetPowerState_Handler)AppleBCMWLANBusInterfacePCIe::SetPowerState_Impl);
        return;
    }
    goto LABEL_36;
  }
  if (msgid != 0x8509EED786C7FF1ALL)
  {
    if (msgid == 0x85D9DEF59E3F02BELL)
    {
      if (!OSMetaClassBase::IsRemote(this))
      {
        *(_OWORD *)&v34.OSObject::OSMetaClassBase::__vftable = *(_OWORD *)a2;
        v34.meta = (OSMetaClass *)*((void *)a2 + 2);
        IOService::ConfigureReport_Invoke(&v34, (IORPC *)this, (OSMetaClassBase *)AppleBCMWLANBusInterfacePCIe::ConfigureReport_Impl, v9);
        return;
      }
      *(_OWORD *)&v34.ivars = *(_OWORD *)a2;
      uint64_t v35 = *((void *)a2 + 2);
      p_ivars = (OSObject::$4342D741BF926617E558AFFE07804AA4 *)&v34.ivars;
      goto LABEL_34;
    }
    goto LABEL_36;
  }
  if (!OSMetaClassBase::IsRemote(this))
  {
    *(_OWORD *)&v32.OSObject::OSMetaClassBase::__vftable = *(_OWORD *)a2;
    v32.meta = (OSMetaClass *)*((void *)a2 + 2);
    IOService::UpdateReport_Invoke(&v32, (IORPC *)this, (OSMetaClassBase *)AppleBCMWLANBusInterfacePCIe::UpdateReport_Impl, v11);
    return;
  }
  *(_OWORD *)&v32.ivars = *(_OWORD *)a2;
  uint64_t v33 = *((void *)a2 + 2);
  p_ivars = (OSObject::$4342D741BF926617E558AFFE07804AA4 *)&v32.ivars;
LABEL_34:
  OSMetaClassBase::Dispatch(this, (IORPC *)p_ivars);
}

double AppleBCMWLANBusInterfacePCIe::SetPowerStateGated_Invoke(uint64_t *a1, uint64_t a2, unsigned int (*a3)(uint64_t, void))
{
  uint64_t v3 = *a1;
  if (*(_DWORD *)(*a1 + 24) == 1
    && *(void *)(v3 + 56) == 1
    && *((_DWORD *)a1 + 4) >= 0x50u
    && *((_DWORD *)a1 + 5) >= 0x34u)
  {
    uint64_t v4 = a1[1];
    if (!a3(a2, *(unsigned int *)(v3 + 72)))
    {
      *(_OWORD *)(v4 + 28) = xmmword_1003771C0;
      *(_DWORD *)(v4 + 4) = 52;
      *(void *)&double result = 1302509197;
      *(void *)(v4 + 20) = 1302509197;
      *(void *)(v4 + 44) = 0;
    }
  }
  return result;
}

double AppleBCMWLANBusInterfacePCIe::SetPowerStateGatedAMFM_Invoke(uint64_t *a1, uint64_t a2, unsigned int (*a3)(uint64_t, void))
{
  uint64_t v3 = *a1;
  if (*(_DWORD *)(*a1 + 24) == 1
    && *(void *)(v3 + 56) == 1
    && *((_DWORD *)a1 + 4) >= 0x50u
    && *((_DWORD *)a1 + 5) >= 0x34u)
  {
    uint64_t v4 = a1[1];
    if (!a3(a2, *(unsigned int *)(v3 + 72)))
    {
      *(_OWORD *)(v4 + 28) = xmmword_1003771D0;
      *(_DWORD *)(v4 + 4) = 52;
      *(void *)&double result = 1302509197;
      *(void *)(v4 + 20) = 1302509197;
      *(void *)(v4 + 44) = 0;
    }
  }
  return result;
}

uint64_t AppleBCMWLANBusInterfacePCIeMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

uint64_t AppleBCMWLANBusInterfacePCIe::CreateActionInterruptOccurred(OSObject *this, size_t a2, OSAction **a3)
{
  unsigned int v6 = OSString::withCString("OSAction_AppleBCMWLANBusInterfacePCIe_InterruptOccurred");
  if (!v6) {
    return 3758097085;
  }
  long long v7 = v6;
  uint64_t v8 = OSAction::CreateWithTypeName(this, 0x32D377BD98125256uLL, 0xCE0513291CFA1EE1, a2, v6, a3);
  ((void (*)(OSString *))v7->release)(v7);
  return v8;
}

uint64_t AppleBCMWLANBusInterfacePCIe::SetPowerStateGated(OSMetaClassBase *a1, unsigned int a2, uint64_t (*a3)(OSMetaClassBase *, void *))
{
  int v15 = -1431655766;
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v13 = v3;
  long long v14 = v3;
  long long v12 = v3;
  memset(v7, 0, sizeof(v7));
  *(_DWORD *)&v7[4] = 80;
  long long v8 = xmmword_1003771E0;
  uint64_t v9 = 1;
  IORPC v10 = a1;
  *(void *)&v7[20] = 0x14DA2B68CLL;
  uint64_t v11 = a2;
  if (a3)
  {
    v6[0] = v7;
    v6[1] = v7;
    void v6[2] = 0x8400000050;
    uint64_t result = a3(a1, v6);
    if (result) {
      return result;
    }
  }
  else
  {
    v5.message = (IORPCMessageMach *)v7;
    v5.reply = (IORPCMessageMach *)v7;
    *(void *)&v5.sendint Size = 0x8400000050;
    uint64_t result = OSMetaClassBase::Invoke(a1, &v5);
    if (result) {
      return result;
    }
  }
  uint64_t result = 3758097087;
  if (*(_DWORD *)&v7[4] == 52 && *(void *)&v7[28] == 0x445E2EBCE9BB479DLL && !*(_DWORD *)&v7[24])
  {
    if (*(void *)((char *)&v8 + 4)) {
      return 3758097087;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t AppleBCMWLANBusInterfacePCIe::SetPowerStateGatedAMFM(OSMetaClassBase *a1, unsigned int a2, uint64_t (*a3)(OSMetaClassBase *, void *))
{
  int v15 = -1431655766;
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + IOSimpleReporter::incrementValue(*(IOSimpleReporter **)(*((void *)this + 8) + 32), 0x436D647257616B00uLL, 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v13 = v3;
  long long v14 = v3;
  long long v12 = v3;
  memset(v7, 0, sizeof(v7));
  *(_DWORD *)&v7[4] = 80;
  long long v8 = xmmword_1003771F0;
  uint64_t v9 = 1;
  IORPC v10 = a1;
  *(void *)&v7[20] = 0x14DA2B68CLL;
  uint64_t v11 = a2;
  if (a3)
  {
    v6[0] = v7;
    v6[1] = v7;
    void v6[2] = 0x8400000050;
    uint64_t result = a3(a1, v6);
    if (result) {
      return result;
    }
  }
  else
  {
    v5.message = (IORPCMessageMach *)v7;
    v5.reply = (IORPCMessageMach *)v7;
    *(void *)&v5.sendint Size = 0x8400000050;
    uint64_t result = OSMetaClassBase::Invoke(a1, &v5);
    if (result) {
      return result;
    }
  }
  uint64_t result = 3758097087;
  if (*(_DWORD *)&v7[4] == 52 && *(void *)&v7[28] == 0x26A3EF2B8FBB0C53 && !*(_DWORD *)&v7[24])
  {
    if (*(void *)((char *)&v8 + 4)) {
      return 3758097087;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t AppleBCMWLANBusInterfacePCIe::CreateActionPortEventMsgHandler(OSObject *this, size_t a2, OSAction **a3)
{
  unsigned int v6 = OSString::withCString("OSAction_AppleBCMWLANBusInterfacePCIe_PortEventMsgHandler");
  if (!v6) {
    return 3758097085;
  }
  long long v7 = v6;
  uint64_t v8 = OSAction::CreateWithTypeName(this, 0x1A36D1895F2C94E9uLL, 0xB7772DAADC3FD545, a2, v6, a3);
  ((void (*)(OSString *))v7->release)(v7);
  return v8;
}

uint64_t AppleBCMWLANBusInterfacePCIe::CreateActionPortErrorMsgHandler(OSObject *this, size_t a2, OSAction **a3)
{
  unsigned int v6 = OSString::withCString("OSAction_AppleBCMWLANBusInterfacePCIe_PortErrorMsgHandler");
  if (!v6) {
    return 3758097085;
  }
  long long v7 = v6;
  uint64_t v8 = OSAction::CreateWithTypeName(this, 0x14C7DCE3B379EA66uLL, 0xE9662CCDFD1D7708, a2, v6, a3);
  ((void (*)(OSString *))v7->release)(v7);
  return v8;
}

uint64_t AppleBCMWLANBusInterfacePCIe::CreateActionRxSubmissionQueueDataAvailable(OSObject *this, size_t a2, OSAction **a3)
{
  unsigned int v6 = OSString::withCString("OSAction_AppleBCMWLANBusInterfacePCIe_RxSubmissionQueueDataAvailable");
  if (!v6) {
    return 3758097085;
  }
  long long v7 = v6;
  uint64_t v8 = OSAction::CreateWithTypeName(this, 0xEAC9639AD90BD60uLL, 0xF799C876BAF566F3, a2, v6, a3);
  ((void (*)(OSString *))v7->release)(v7);
  return v8;
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_InterruptOccurred_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039E200;
  return 0;
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_InterruptOccurredMetaClass::New(OSAction_AppleBCMWLANBusInterfacePCIe_InterruptOccurredMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10039E240;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10039E288;
  return 0;
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_InterruptOccurred::Dispatch(OSAction *this, IORPC *a2)
{
  message = a2->message;
  *(_OWORD *)&v5.reply = *(_OWORD *)&a2->reply;
  IORPCMessageFromMach(message, 0);
  v5.message = message;
  return OSAction::_Dispatch(this, &v5);
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_InterruptOccurredMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_PortEventMsgHandler_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039E2A8;
  return 0;
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_PortEventMsgHandlerMetaClass::New(OSAction_AppleBCMWLANBusInterfacePCIe_PortEventMsgHandlerMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10039E2E8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10039E330;
  return 0;
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_PortEventMsgHandler::Dispatch(OSAction *this, IORPC *a2)
{
  message = a2->message;
  *(_OWORD *)&v5.reply = *(_OWORD *)&a2->reply;
  IORPCMessageFromMach(message, 0);
  v5.message = message;
  return OSAction::_Dispatch(this, &v5);
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_PortEventMsgHandlerMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_PortErrorMsgHandler_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039E350;
  return 0;
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_PortErrorMsgHandlerMetaClass::New(OSAction_AppleBCMWLANBusInterfacePCIe_PortErrorMsgHandlerMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10039E390;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10039E3D8;
  return 0;
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_PortErrorMsgHandler::Dispatch(OSAction *this, IORPC *a2)
{
  message = a2->message;
  *(_OWORD *)&v5.reply = *(_OWORD *)&a2->reply;
  IORPCMessageFromMach(message, 0);
  v5.message = message;
  return OSAction::_Dispatch(this, &v5);
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_PortErrorMsgHandlerMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_RxSubmissionQueueDataAvailable_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039E3F8;
  return 0;
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_RxSubmissionQueueDataAvailableMetaClass::New(OSAction_AppleBCMWLANBusInterfacePCIe_RxSubmissionQueueDataAvailableMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10039E438;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10039E480;
  return 0;
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_RxSubmissionQueueDataAvailable::Dispatch(OSAction *this, IORPC *a2)
{
  message = a2->message;
  *(_OWORD *)&v5.reply = *(_OWORD *)&a2->reply;
  IORPCMessageFromMach(message, 0);
  v5.message = message;
  return OSAction::_Dispatch(this, &v5);
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_RxSubmissionQueueDataAvailableMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_InterruptOccurred::getMetaClass(OSAction_AppleBCMWLANBusInterfacePCIe_InterruptOccurred *this)
{
  return gOSAction_AppleBCMWLANBusInterfacePCIe_InterruptOccurredMetaClass;
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_PortEventMsgHandler::getMetaClass(OSAction_AppleBCMWLANBusInterfacePCIe_PortEventMsgHandler *this)
{
  return gOSAction_AppleBCMWLANBusInterfacePCIe_PortEventMsgHandlerMetaClass;
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_PortErrorMsgHandler::getMetaClass(OSAction_AppleBCMWLANBusInterfacePCIe_PortErrorMsgHandler *this)
{
  return gOSAction_AppleBCMWLANBusInterfacePCIe_PortErrorMsgHandlerMetaClass;
}

uint64_t OSAction_AppleBCMWLANBusInterfacePCIe_RxSubmissionQueueDataAvailable::getMetaClass(OSAction_AppleBCMWLANBusInterfacePCIe_RxSubmissionQueueDataAvailable *this)
{
  return gOSAction_AppleBCMWLANBusInterfacePCIe_RxSubmissionQueueDataAvailableMetaClass;
}

void _GLOBAL__sub_I_AppleBCMWLANBusInterfacePCIe_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANCommandMonitor_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039E540;
  return 0;
}

uint64_t AppleBCMWLANCommandMonitorMetaClass::New(AppleBCMWLANCommandMonitorMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038B3A8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038B3F8;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038B418;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANCommandMonitor_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANHashtable_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039E620;
  return 0;
}

uint64_t AppleBCMWLANHashtableMetaClass::New(AppleBCMWLANHashtableMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038D900;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038D980;
  *(void *)&a2[1].__int32 refcount = off_10038D9A0;
  a2[1].OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038D9E0;
  return 0;
}

uint64_t AppleBCMWLANSkywalkTxSubmissionQueue_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039E700;
  return 0;
}

uint64_t AppleBCMWLANSkywalkTxSubmissionQueueMetaClass::New(AppleBCMWLANSkywalkTxSubmissionQueueMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038A450;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038A590;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038A5B0;
  a2[1].meta = (OSMetaClass *)&off_10038A620;
  a2[1].ivars = (OSObject_IVars *)&off_10038A640;
  return 0;
}

uint64_t AppleBCMWLANChipConfigSpace_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039E7E0;
  return 0;
}

uint64_t AppleBCMWLANChipConfigSpaceMetaClass::New(AppleBCMWLANChipConfigSpaceMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038E608;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038E658;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038E678;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANChipConfigSpace_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANTxBuffer_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039E8C0;
  return 0;
}

uint64_t AppleBCMWLANTxBufferMetaClass::New(AppleBCMWLANTxBufferMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038EF18;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038EF68;
  *(void *)&a2[1].__int32 refcount = &off_10038EF88;
  return 0;
}

uint64_t AppleBCMWLANPCIeMMIOHistory_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039E9A0;
  return 0;
}

uint64_t AppleBCMWLANPCIeMMIOHistoryMetaClass::New(AppleBCMWLANPCIeMMIOHistoryMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038DAF0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038DB38;
  return 0;
}

uint64_t AppleBCMWLANRxByteRing_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039EA80;
  return 0;
}

uint64_t AppleBCMWLANRxByteRingMetaClass::New(AppleBCMWLANRxByteRingMetaClass *this, OSObject *a2)
{
  return 3758097127;
}

uint64_t AppleBCMWLANTxItemRing_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039EB60;
  return 0;
}

uint64_t AppleBCMWLANTxItemRingMetaClass::New(AppleBCMWLANTxItemRingMetaClass *this, OSObject *a2)
{
  return 3758097127;
}

uint64_t AppleBCMWLANChipManagerPCIe4377_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039EC40;
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe4377MetaClass::New(AppleBCMWLANChipManagerPCIe4377MetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100389E30;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_100389F40;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_100389F60;
  a2[1].meta = (OSMetaClass *)off_100389F90;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANChipManagerPCIe4377_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANSkywalkRxCompletionQueue_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039ED20;
  return 0;
}

uint64_t AppleBCMWLANSkywalkRxCompletionQueueMetaClass::New(AppleBCMWLANSkywalkRxCompletionQueueMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038AAB8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038ABC0;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038ABE0;
  a2[1].meta = (OSMetaClass *)&off_10038AC50;
  a2[1].ivars = (OSObject_IVars *)&off_10038AC68;
  return 0;
}

uint64_t AppleBCMWLANRxItemRing_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039EE00;
  return 0;
}

uint64_t AppleBCMWLANRxItemRingMetaClass::New(AppleBCMWLANRxItemRingMetaClass *this, OSObject *a2)
{
  return 3758097127;
}

uint64_t AppleBCMWLANChipBackplane_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039EEE0;
  return 0;
}

uint64_t AppleBCMWLANChipBackplaneMetaClass::New(AppleBCMWLANChipBackplaneMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038F600;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038F650;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038F670;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANChipBackplane_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANCommand_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039EFC0;
  return 0;
}

uint64_t AppleBCMWLANCommandMetaClass::New(AppleBCMWLANCommandMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038EAB8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038EB08;
  *(void *)&a2[1].__int32 refcount = &off_10038EB28;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANCommand_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANByteRing_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039F0A0;
  return 0;
}

uint64_t AppleBCMWLANByteRingMetaClass::New(AppleBCMWLANByteRingMetaClass *this, OSObject *a2)
{
  return 3758097127;
}

uint64_t AppleBCMWLANItemRing_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039F180;
  return 0;
}

uint64_t AppleBCMWLANItemRingMetaClass::New(AppleBCMWLANItemRingMetaClass *this, OSObject *a2)
{
  return 3758097127;
}

uint64_t AppleBCMWLANSkywalkTxCompletionQueue_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039F260;
  return 0;
}

uint64_t AppleBCMWLANSkywalkTxCompletionQueueMetaClass::New(AppleBCMWLANSkywalkTxCompletionQueueMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038A6D8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038A7C8;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038A7E8;
  a2[1].meta = (OSMetaClass *)&off_10038A858;
  a2[1].ivars = (OSObject_IVars *)&off_10038A870;
  return 0;
}

uint64_t AppleBCMWLANCallbackEventSource_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039F340;
  return 0;
}

uint64_t AppleBCMWLANCallbackEventSourceMetaClass::New(AppleBCMWLANCallbackEventSourceMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038DD40;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038DDC0;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038DDE0;
  return 0;
}

uint64_t AppleBCMWLAN11beAdapter_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039F420;
  return 0;
}

uint64_t AppleBCMWLAN11beAdapterMetaClass::New(AppleBCMWLAN11beAdapterMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003846E0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100384728;
  return 0;
}

uint64_t AppleBCMWLANWorkOrder_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039F500;
  return 0;
}

uint64_t AppleBCMWLANWorkOrderMetaClass::New(AppleBCMWLANWorkOrderMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038E690;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038E6E0;
  *(void *)&a2[1].__int32 refcount = &off_10038E700;
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe4399_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039F5E0;
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe4399MetaClass::New(AppleBCMWLANChipManagerPCIe4399MetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003843D8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_1003844E8;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_100384508;
  a2[1].meta = (OSMetaClass *)off_100384538;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANChipManagerPCIe4399_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANTaskmaster_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039F6C0;
  return 0;
}

uint64_t AppleBCMWLANTaskmasterMetaClass::New(AppleBCMWLANTaskmasterMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038E718;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038E768;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038E788;
  return 0;
}

uint64_t AppleBCMWLANCommandQueue_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039F7A0;
  return 0;
}

uint64_t AppleBCMWLANCommandQueueMetaClass::New(AppleBCMWLANCommandQueueMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038E7A0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038E7F0;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038E810;
  return 0;
}

uint64_t AppleBCMWLANTimeTrace_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039F880;
  return 0;
}

uint64_t AppleBCMWLANTimeTraceMetaClass::New(AppleBCMWLANTimeTraceMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038EB40;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_10038EB88;
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIe_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039F960;
  return 0;
}

uint64_t AppleBCMWLANChipManagerPCIeMetaClass::New(AppleBCMWLANChipManagerPCIeMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038EBA8;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_10038ECB8;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_10038ECD8;
  a2[1].meta = (OSMetaClass *)off_10038ED08;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANChipManagerPCIe_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANPCIeFlowQueue_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039FA40;
  return 0;
}

uint64_t AppleBCMWLANPCIeFlowQueueMetaClass::New(AppleBCMWLANPCIeFlowQueueMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038E8E0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038E988;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038E9A8;
  a2[1].meta = (OSMetaClass *)off_10038EA08;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANPCIeFlowQueue_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANChipManager_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039FB20;
  return 0;
}

uint64_t AppleBCMWLANChipManagerMetaClass::New(AppleBCMWLANChipManagerMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038E828;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_10038E890;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)off_10038E8B0;
  return 0;
}

uint64_t AppleBCMWLANStopwatch_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039FC00;
  return 0;
}

uint64_t AppleBCMWLANStopwatchMetaClass::New(AppleBCMWLANStopwatchMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038EDC0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_10038EE08;
  return 0;
}

uint64_t AppleBCMWLANHistogram_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039FCE0;
  return 0;
}

uint64_t AppleBCMWLANHistogramMetaClass::New(AppleBCMWLANHistogramMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038EEB0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038EEF8;
  return 0;
}

uint64_t AppleBCMWLANTimeKeeper_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039FDC0;
  return 0;
}

uint64_t AppleBCMWLANTimeKeeperMetaClass::New(AppleBCMWLANTimeKeeperMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038D878;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038D8C8;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038D8E8;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANTimeKeeper_iig_cpp()
{
  kNullRange = 0;
}

uint64_t AppleBCMWLANCommandWithXTLV_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039FEA0;
  return 0;
}

uint64_t AppleBCMWLANCommandWithXTLVMetaClass::New(AppleBCMWLANCommandWithXTLVMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038F688;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038F6D0;
  return 0;
}

uint64_t AppleBCMWLANSkywalkPacketPool_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_10039FF80;
  return 0;
}

uint64_t AppleBCMWLANSkywalkPacketPoolMetaClass::New(AppleBCMWLANSkywalkPacketPoolMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100384820;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_1003848C0;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003848E0;
  a2[1].meta = (OSMetaClass *)off_100384938;
  return 0;
}

uint64_t AppleBCMWLANPowerStateAdapter_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003A0060;
  return 0;
}

uint64_t AppleBCMWLANPowerStateAdapterMetaClass::New(AppleBCMWLANPowerStateAdapterMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100384678;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_1003846C0;
  return 0;
}

uint64_t AppleBCMWLANSkywalkMulticastQueue_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003A0140;
  return 0;
}

uint64_t AppleBCMWLANSkywalkMulticastQueueMetaClass::New(AppleBCMWLANSkywalkMulticastQueueMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038ACD0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038AD70;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038AD90;
  a2[1].meta = (OSMetaClass *)&off_10038ADD8;
  return 0;
}

uint64_t AppleBCMWLANTxPowerManager_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003A0220;
  return 0;
}

uint64_t AppleBCMWLANTxPowerManagerMetaClass::New(AppleBCMWLANTxPowerManagerMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038B2A0;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038B2F0;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038B310;
  return 0;
}

uint64_t AppleBCMWLANChanSpec_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003A0300;
  return 0;
}

uint64_t AppleBCMWLANChanSpecMetaClass::New(AppleBCMWLANChanSpecMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100390B68;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100390BB0;
  return 0;
}

uint64_t AppleBCMWLANBSSBeacon_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003A03E0;
  return 0;
}

uint64_t AppleBCMWLANBSSBeaconMetaClass::New(AppleBCMWLANBSSBeaconMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003A0420;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_1003A0768;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003A0788;
  return 0;
}

uint64_t AppleBCMWLANPCIeDoorbell_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003A0B38;
  return 0;
}

uint64_t AppleBCMWLANPCIeDoorbellMetaClass::New(AppleBCMWLANPCIeDoorbellMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100390A58;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_100390AA8;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_100390AC8;
  return 0;
}

uint64_t AppleBCMWLANCommander_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003A0C18;
  return 0;
}

uint64_t AppleBCMWLANCommanderMetaClass::New(AppleBCMWLANCommanderMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038DC38;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)&off_10038DCC0;
  a2[1].OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_10038DCE0;
  a2[1].meta = (OSMetaClass *)&off_10038DD28;
  return 0;
}

void _GLOBAL__sub_I_AppleBCMWLANCommander_iig_cpp()
{
  kNullRange = 0;
}

uint64_t DriverKit_AppleBCMWLAN_New(OSMetaClass *a1)
{
  a1->__vftable = (OSMetaClass_vtbl *)off_1003A0CF8;
  return 0;
}

uint64_t DriverKit_AppleBCMWLANMetaClass::New(DriverKit_AppleBCMWLANMetaClass *this, OSObject *a2)
{
  a2->OSMetaClassBase::__vftable = (OSObject_vtbl *)&off_1003A0D38;
  a2->OSObjectInterface::__vftable = (OSObjectInterface_vtbl *)off_1003A0D80;
  return 0;
}

uint64_t DriverKit_AppleBCMWLAN::Dispatch(IOService *this, IORPC *a2, IORPC *a3)
{
  IORPC v4 = *a2;
  return DriverKit_AppleBCMWLAN::_Dispatch(this, &v4, a3);
}

uint64_t DriverKit_AppleBCMWLAN::_Dispatch(IOService *this, IORPC *a2, IORPC *a3)
{
  if (IORPCMessageFromMach(a2->message, 0)->msgid == 0xAB6F76DDE6D693F2)
  {
    IORPC rpc = *a2;
    return IOService::Start_Invoke(&rpc, this, (IOService::Start_Handler)DriverKit_AppleBCMWLAN::Start_Impl);
  }
  else
  {
    IORPC v6 = *a2;
    return IOService::_Dispatch(this, &v6);
  }
}

uint64_t DriverKit_AppleBCMWLANMetaClass::Dispatch(OSMetaClassBase *this, IORPC *a2)
{
  IORPCMessageFromMach(a2->message, 0);
  IORPC v5 = *a2;
  return OSMetaClassBase::Dispatch(this, &v5);
}

void AppleBCMWLANLQM::getMloPerLinkStats()
{
}

void AppleBCMWLANChipManagerPCIe4355::initWithChip(OSObject *a1)
{
  ClassNameHelper = (const char *)getClassNameHelper(a1);
  panic("%s::%s(): Unrecognized BCM4355 chip revision ID", ClassNameHelper, "initWithChip");
}

void AppleBCMWLAN11beAdapter::setupJoinConfig()
{
}

void AppleBCMWLAN11beAdapter::configureMlo()
{
}

void AppleBCMWLAN11beAdapter::dumpMloStatus()
{
}

void AppleBCMWLAN11beAdapter::isMloConnection()
{
}

void AppleBCMWLAN11beAdapter::getMloStatus()
{
}

void AppleBCMWLANCoreDbg::dbgTriggerCrash()
{
}

void AppleBCMWLANPCIeSkywalkTxCompletionQueue::enqueuePackets()
{
}

void AppleBCMWLANPCIeSkywalkTxSubmissionQueue::dequeuePackets()
{
}

void AppleBCMWLANBusInterface::freeResources(OSObject *a1, uint64_t a2)
{
  ClassNameHelper = (const char *)getClassNameHelper(a1);
  panic("%s::%s(): Unbalanced driver registrations in %p: %lu\n", ClassNameHelper, "freeResources", a1, *(unsigned int *)(*(void *)a2 + 8));
}

void AppleBCMWLANProvisioningManager::validateData(OSObject *a1)
{
  ClassNameHelper = (const char *)getClassNameHelper(a1);
  panic("%s::%s(): Unit isn't properly provisioned (no WiFi MAC Address)!\n", ClassNameHelper, "validateData");
}

void AppleBCMWLANPCIeCompletionRing::getReadIndex(uint64_t a1)
{
  OUTLINED_FUNCTION_0(a1);
  panic("AppleBCMWLANPCIeCompletionRing::getReadIndex() Invalid index(0x%x)\n", v1);
}

void AppleBCMWLANPCIeCompletionRing::getWriteIndex(uint64_t a1)
{
  OUTLINED_FUNCTION_0(a1);
  panic("AppleBCMWLANPCIeCompletionRing::getWriteIndex() Invalid index(0x%x)\n", v1);
}

void AppleBCMWLANPCIeSubmissionRing::getReadIndex(uint64_t a1)
{
  OUTLINED_FUNCTION_0(a1);
  panic("AppleBCMWLANPCIeSubmissionRing::getReadIndex() Invalid index(0x%x)\n", v1);
}

void AppleBCMWLANPCIeSubmissionRing::getWriteIndex(uint64_t a1)
{
  OUTLINED_FUNCTION_0(a1);
  panic("AppleBCMWLANPCIeSubmissionRing::getWriteIndex() Invalid index(0x%x)\n", v1);
}

void AppleBCMWLANCore::completePeerCacheControl()
{
}

void AppleBCMWLANCore::powerOffSystem()
{
}

void AppleBCMWLANBusInterfacePCIe::handleShutdownAtTermination()
{
}

void AppleBCMWLANBusInterfacePCIe::attachPCIeBusGated(OSObject *a1)
{
  ClassNameHelper = (const char *)getClassNameHelper(a1);
  panic("%s::%s(): Get Interrupt Attempts maxed out\n", ClassNameHelper, "attachPCIeBusGated");
}

void AppleBCMWLANBusInterfacePCIe::nanoPowerCycleGated(OSObject *a1, uint64_t a2)
{
  ClassNameHelper = (const char *)getClassNameHelper(a1);
  IORPC v5 = (const char *)((uint64_t (*)(OSObject *, uint64_t))a1->OSMetaClassBase::__vftable[1].free)(a1, a2);
  panic("%s::%s(): Failed to enable port (%s)\n", ClassNameHelper, "nanoPowerCycleGated", v5);
}

void AppleBCMWLANBusInterfacePCIe::PortEventMsgHandlerGated(OSObject *a1, const OSNumber *a2)
{
  ClassNameHelper = (const char *)getClassNameHelper(a1);
  uint32_t v4 = OSNumber::unsigned32BitValue(a2);
  panic("%s::%s(): PCIe port error type %u not handled\n", ClassNameHelper, "PortEventMsgHandlerGated", v4);
}

void AppleBCMWLANBusInterfacePCIe::flr(OSObject *a1)
{
  ClassNameHelper = (const char *)getClassNameHelper(a1);
  panic("%s::%s(): WiFi FLR resulted in pending backplane errors!", ClassNameHelper, "flr");
}

void AppleBCMWLANBusInterfacePCIe::halt(OSObject *a1)
{
  ClassNameHelper = (const char *)getClassNameHelper(a1);
  panic("%s::%s(): Detach notification didn't execute within 5 seconds", ClassNameHelper, "halt");
}

void AppleBCMWLANBusInterfacePCIe::flushTrackedControlIO(OSObject *a1, AppleBCMWLANDMASlab ***a2)
{
  ClassNameHelper = (const char *)getClassNameHelper(a1);
  int Direction = AppleBCMWLANPCIeIO::getDirection(a2);
  panic("%s::%s():  Bad direction on io %p, %#X", ClassNameHelper, "flushTrackedControlIO", a2, Direction);
}

void AppleBCMWLANBusInterfacePCIe::handleMBDataOOBDW()
{
}

void AppleBCMWLANBusInterfacePCIe::ackDSRequestInbandDS()
{
}

void AppleBCMWLANBusInterfacePCIe::InterruptOccurredHelper(AppleBCMWLANBusInterface *a1, uint64_t a2, uint64_t a3)
{
  if (AppleBCMWLANBusInterface::getLogger(a1))
  {
    AppleBCMWLANBusInterface::getLogger(a1);
    if (CCLogStream::shouldLog())
    {
      Logger = (CCLogStream *)AppleBCMWLANBusInterface::getLogger(a1);
      CCLogStream::logAlert(Logger, "[dk] %s@%d:BusInterfacePCIe: MSIEpoch %llu greater than interrupt timestamp %llu", "InterruptOccurredHelper", 21907, *(void *)(*(void *)a2 + 4760), a3);
    }
  }
  panic("AppleBCMWLANBusInterfacePCIe: MSIEpoch %llu greater than interrupt timestamp %llu", *(void *)(*(void *)a2 + 4760), a3);
}

void AppleBCMWLANBSSBeacon::setBeaconData()
{
}

void AppleBCMWLANCommander::issueCommand(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*(void *)(*a1 + 216))
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = *a1;
    if (shouldLog)
    {
      CCLogStream::logAlert(*(CCLogStream **)(v2 + 216), "[dk] %s@%d:Dumping IPC stats before assert , current ts=%llu\n", "issueCommand", 1907, *(void *)(v2 + 376));
      uint64_t v2 = *a1;
    }
  }
  (*(void (**)(void))(**(void **)(v2 + 208) + 688))(*(void *)(v2 + 208));
  panic("%s Induce Dext Crash as issueCommand timeout occurs", "issueCommand");
}

{
  uint64_t v2;
  int shouldLog;

  uint64_t v2 = *a1;
  if (*(void *)(*a1 + 216))
  {
    int shouldLog = CCLogStream::shouldLog();
    uint64_t v2 = *a1;
    if (shouldLog)
    {
      CCLogStream::logAlert(*(CCLogStream **)(v2 + 216), "[dk] %s@%d:Dumping IPC stats before assert , current ts=%llu\n", "issueCommand", 1913, *(void *)(v2 + 376));
      uint64_t v2 = *a1;
    }
  }
  (*(void (**)(void))(**(void **)(v2 + 208) + 688))(*(void *)(v2 + 208));
  panic("%s Induce Dext Crash as Command is not in Completed State", "issueCommand");
}

void AppleBCMWLANCommander::reset()
{
}

{
  panic("Induce Dext Crash as AQ not Empty\n");
}

void AppleBCMWLANSensingAdapter::setSENSING_ENABLE()
{
}

void AppleBCMWLANCommandQueue::map()
{
}

void AppleBCMWLANScanAdapter::processScanResults()
{
}

void AppleBCMWLANScanAdapter::processAndSendWLBSSInfo()
{
}

void AppleBCMWLANChipBackplane::forcePowerLite()
{
}

{
  panic("read failed for power control reg");
}

void AppleBCMWLANChipBackplane::forcePowerLite(uint64_t a1)
{
  if ((*(uint64_t (**)(void))(**(void **)(*(void *)a1 + 3120) + 72))(*(void *)(*(void *)a1 + 3120)))
  {
    (*(void (**)(void))(**(void **)(*(void *)a1 + 3120) + 72))(*(void *)(*(void *)a1 + 3120));
    if (CCLogStream::shouldLog())
    {
      uint64_t v2 = (CCLogStream *)(*(uint64_t (**)(void))(**(void **)(*(void *)a1 + 3120) + 72))(*(void *)(*(void *)a1 + 3120));
      CCLogStream::logAlert(v2, "[dk] %s@%d:Failed to read PowerControl register\n", "forcePowerLite", 1949);
    }
  }
  panic("read failed for power control reg");
}

void AppleBCMWLANChipBackplane::forcePower()
{
}

void AppleBCMWLANUtil::appendParsedKeyValuePairsToDictionary()
{
}

void IODelay(uint64_t us)
{
}

void IOFree(void *address, size_t length)
{
}

uint64_t IOFreeData()
{
  return _IOFreeData();
}

IOLock *IOLockAlloc(void)
{
  return _IOLockAlloc();
}

void IOLockFree(IOLock *lock)
{
}

void IOLockLock(IOLock *lock)
{
}

void IOLockUnlock(IOLock *lock)
{
}

int IOLog(const char *format, ...)
{
  return _IOLog(format);
}

uint64_t IOMallocZeroData()
{
  return _IOMallocZeroData();
}

uint64_t IOMallocZeroTyped()
{
  return _IOMallocZeroTyped();
}

BOOL IOParseBootArgNumber(const char *arg_string, void *arg_ptr, int max_len)
{
  return _IOParseBootArgNumber(arg_string, arg_ptr, max_len);
}

BOOL IOParseBootArgString(const char *arg_string, char *arg_ptr, int strlen)
{
  return _IOParseBootArgString(arg_string, arg_ptr, strlen);
}

IORPCMessage *__cdecl IORPCMessageFromMach(IORPCMessageMach *msg, BOOL reply)
{
  return _IORPCMessageFromMach(msg, reply);
}

void IOSleep(uint64_t ms)
{
}

void OSSynchronizeIO(void)
{
}

uint32_t PE_i_can_has_debugger(uint32_t *a1)
{
  return _PE_i_can_has_debugger(a1);
}

uint64_t SHA1Final()
{
  return _SHA1Final();
}

uint64_t SHA1Init()
{
  return _SHA1Init();
}

uint64_t SHA1Update()
{
  return _SHA1Update();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return __Block_copy(aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

uint64_t thread_tid(void *a1)
{
  return thread_tid(a1);
}

uint64_t IO80211Print()
{
  return IO80211Print();
}

uint64_t IO80211Hexdump()
{
  return IO80211Hexdump();
}

uint64_t ciphertype2str(unsigned int a1)
{
  return ciphertype2str(a1);
}

uint64_t current_thread(void)
{
  return current_thread();
}

uint64_t my_ip6_sprintf(const unsigned __int8 *a1)
{
  return my_ip6_sprintf(a1);
}

uint64_t IO80211HexdumpIf()
{
  return IO80211HexdumpIf();
}

kern_return_t OSObjectAllocate(OSMetaClass *meta, OSObject **pObject)
{
  return OSObjectAllocate(meta, pObject);
}

uint64_t OSUnserializeXML(const char *a1, OSString **a2)
{
  return OSUnserializeXML(a1, a2);
}

uint64_t authtypelower2str(unsigned int a1)
{
  return authtypelower2str(a1);
}

uint64_t authtypeupper2str(unsigned int a1, unsigned int a2)
{
  return authtypeupper2str(a1, a2);
}

uint64_t checkPropertyTrue(IOService *a1, const char *a2, unint64_t a3, const char *a4)
{
  return checkPropertyTrue(a1, a2, a3, a4);
}

uint64_t setPropertyHelper(IOService *a1, const OSString *a2, const OSObject *a3)
{
  return setPropertyHelper(a1, a2, a3);
}

uint64_t setPropertyHelper(IOService *a1, const char *a2, const OSObject *a3)
{
  return setPropertyHelper(a1, a2, a3);
}

uint64_t setPropertyHelper(IOService *a1, const char *a2, const char *a3)
{
  return setPropertyHelper(a1, a2, a3);
}

uint64_t setPropertyHelper(IOService *a1, const char *a2, BOOL a3)
{
  return setPropertyHelper(a1, a2, a3);
}

uint64_t setPropertyHelper(IOService *a1, const char *a2, unint64_t a3, unsigned int a4)
{
  return setPropertyHelper(a1, a2, a3, a4);
}

uint64_t getClassNameHelper(OSObject *a1)
{
  return getClassNameHelper(a1);
}

uint64_t checkPropertyExists(IOService *a1, const char *a2, unint64_t a3, const char *a4)
{
  return checkPropertyExists(a1, a2, a3, a4);
}

uint64_t iterateObjectsHelper()
{
  return iterateObjectsHelper();
}

uint64_t removePropertyHelper(IOService *a1, const char *a2)
{
  return removePropertyHelper(a1, a2);
}

uint64_t _DebugStateSaveObject(void *a1)
{
  return _DebugStateSaveObject(a1);
}

uint64_t IO80211HexdumpIfKernel()
{
  return IO80211HexdumpIfKernel();
}

uint64_t isDevFusedOrCSRInternal(void)
{
  return isDevFusedOrCSRInternal();
}

uint64_t IO80211GetBandInfoBitmap(unsigned int a1)
{
  return IO80211GetBandInfoBitmap(a1);
}

uint64_t ChanSpecGetPrimaryChannel()
{
  return ChanSpecGetPrimaryChannel();
}

uint64_t IO80211GetBPFLoggerEnable(void)
{
  return IO80211GetBPFLoggerEnable();
}

uint64_t IO80211SetBPFLoggerEnable(BOOL a1)
{
  return IO80211SetBPFLoggerEnable(a1);
}

uint64_t IO80211SetBPFLoggerTarget(IO80211Controller *a1)
{
  return IO80211SetBPFLoggerTarget(a1);
}

uint64_t acquirePropertyWithString(IOService *a1, const char *a2, OSContainer **a3, unint64_t a4, const char *a5)
{
  return acquirePropertyWithString(a1, a2, a3, a4, a5);
}

uint64_t IO80211_io80211isDebuggable(void)
{
  return IO80211_io80211isDebuggable();
}

uint64_t ChanSpecConvToApple80211Channel()
{
  return ChanSpecConvToApple80211Channel();
}

uint64_t checkAcquireDataPropertyNotEmpty(IOService *a1, const char *a2, OSData **a3, unint64_t a4, unint64_t a5, const char *a6)
{
  return checkAcquireDataPropertyNotEmpty(a1, a2, a3, a4, a5, a6);
}

uint64_t IOFileValidationRequestImageVerify()
{
  return IOFileValidationRequestImageVerify();
}

uint64_t getcrc8(unsigned __int8 *a1, unsigned int a2, unsigned __int8 a3)
{
  return getcrc8(a1, a2, a3);
}

uint64_t isMemZero(const char *a1, unsigned int a2)
{
  return isMemZero(a1, a2);
}

uint64_t IOReporter::addChannel(IOReporter *this, unint64_t a2, const char *a3)
{
  return IOReporter::addChannel(this, a2, a3);
}

uint64_t IOReporter::createLegend(IOReporter *this)
{
  return IOReporter::createLegend(this);
}

uint64_t IOReporter::updateAllReports(IOReporter *this, OSCollection *a2, OSData *a3, unsigned int a4, unsigned int *a5, unint64_t a6, unint64_t a7, IOMemoryDescriptor *a8)
{
  return IOReporter::updateAllReports(this, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t IOReporter::configureAllReports(IOReporter *this, OSCollection *a2, OSData *a3, unsigned int a4, unsigned int *a5)
{
  return IOReporter::configureAllReports(this, a2, a3, a4, a5);
}

uint64_t AppleOLYHAL::killDextDK(AppleOLYHAL *this, const char *a2)
{
  return AppleOLYHAL::killDextDK(this, a2);
}

uint64_t AppleOLYHAL::addSacFreqDK(AppleOLYHAL *this, unint64_t a2, unsigned int a3, unsigned int a4)
{
  return AppleOLYHAL::addSacFreqDK(this, a2, a3, a4);
}

uint64_t AppleOLYHAL::removeSacFreqDK(AppleOLYHAL *this, unint64_t a2, unsigned int a3, unsigned int a4)
{
  return AppleOLYHAL::removeSacFreqDK(this, a2, a3, a4);
}

uint64_t AppleOLYHAL::reportInitFailureDK(AppleOLYHAL *this, OSString *a2)
{
  return AppleOLYHAL::reportInitFailureDK(this, a2);
}

uint64_t AppleOLYHAL::waitForAppleOLYHALDK(AppleOLYHAL *this)
{
  return AppleOLYHAL::waitForAppleOLYHALDK(this);
}

uint64_t AppleOLYHAL::setBoolPropertyHelperDK(AppleOLYHAL *this, OSString *a2, OSBoolean *a3)
{
  return AppleOLYHAL::setBoolPropertyHelperDK(this, a2, a3);
}

uint64_t AppleOLYHAL::setDataPropertyHelperDK(AppleOLYHAL *this, OSString *a2, OSData *a3)
{
  return AppleOLYHAL::setDataPropertyHelperDK(this, a2, a3);
}

uint64_t AppleOLYHAL::setDictPropertyHelperDK(AppleOLYHAL *this, OSString *a2, OSDictionary *a3)
{
  return AppleOLYHAL::setDictPropertyHelperDK(this, a2, a3);
}

uint64_t AppleOLYHAL::createPortInterfacePCIeDK(AppleOLYHAL *a1, const char *a2, AppleOLYHALPortInterfacePCIe **a3)
{
  return AppleOLYHAL::createPortInterfacePCIeDK(a1, a2, a3);
}

uint64_t AppleOLYHAL::setStringPropertyHelperDK(AppleOLYHAL *this, OSString *a2, OSString *a3)
{
  return AppleOLYHAL::setStringPropertyHelperDK(this, a2, a3);
}

uint64_t AppleOLYHAL::createPlatformFunctionInterfaceDK(AppleOLYHAL *a1, AppleOLYHALPlatformFunction **a2)
{
  return AppleOLYHAL::createPlatformFunctionInterfaceDK(a1, a2);
}

uint64_t CCLogStream::logAlertIf(CCLogStream *this, unint64_t a2, const char *a3, ...)
{
  return CCLogStream::logAlertIf(this, a2, a3);
}

uint64_t CCLogStream::logNoticeIf(CCLogStream *this, unint64_t a2, const char *a3, ...)
{
  return CCLogStream::logNoticeIf(this, a2, a3);
}

uint64_t CCLogStream::logEmergency(CCLogStream *this, const char *a2, ...)
{
  return CCLogStream::logEmergency(this, a2);
}

uint64_t CCLogStream::getConsoleLevel(CCLogStream *this)
{
  return CCLogStream::getConsoleLevel(this);
}

uint64_t CCLogStream::logHeaderAndBuf(CCLogStream *this, unsigned __int8 *a2, unint64_t a3, unint64_t a4, unint64_t a5, void *a6, unint64_t a7)
{
  return CCLogStream::logHeaderAndBuf(this, a2, a3, a4, a5, a6, a7);
}

uint64_t CCLogStream::shouldLogConsole()
{
  return CCLogStream::shouldLogConsole();
}

uint64_t CCLogStream::logHeaderAndBufIf(CCLogStream *this, unint64_t a2, unsigned __int8 *a3, unint64_t a4, unint64_t a5, unint64_t a6, void *a7, unint64_t a8)
{
  return CCLogStream::logHeaderAndBufIf(this, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t CCLogStream::log()
{
  return CCLogStream::log();
}

uint64_t CCLogStream::logv()
{
  return CCLogStream::logv();
}

uint64_t CCLogStream::logIf()
{
  return CCLogStream::logIf();
}

uint64_t CCLogStream::logCrit(CCLogStream *this, const char *a2, ...)
{
  return CCLogStream::logCrit(this, a2);
}

uint64_t CCLogStream::logInfo(CCLogStream *this, const char *a2, ...)
{
  return CCLogStream::logInfo(this, a2);
}

uint64_t CCLogStream::logWarn(CCLogStream *this, const char *a2, ...)
{
  return CCLogStream::logWarn(this, a2);
}

uint64_t CCLogStream::logAlert(CCLogStream *this, const char *a2, ...)
{
  return CCLogStream::logAlert(this, a2);
}

uint64_t CCLogStream::logCritIf(CCLogStream *this, unint64_t a2, const char *a3, ...)
{
  return CCLogStream::logCritIf(this, a2, a3);
}

uint64_t CCLogStream::logInfoIf(CCLogStream *this, unint64_t a2, const char *a3, ...)
{
  return CCLogStream::logInfoIf(this, a2, a3);
}

uint64_t CCLogStream::logNotice(CCLogStream *this, const char *a2, ...)
{
  return CCLogStream::logNotice(this, a2);
}

uint64_t CCLogStream::logWarnIf(CCLogStream *this, unint64_t a2, const char *a3, ...)
{
  return CCLogStream::logWarnIf(this, a2, a3);
}

uint64_t CCLogStream::shouldLog()
{
  return CCLogStream::shouldLog();
}

{
  return CCLogStream::shouldLog();
}

uint64_t CCLogStream::shouldLog(CCLogStream *this, unint64_t a2)
{
  return CCLogStream::shouldLog(this, a2);
}

void IOPCIDevice::MemoryRead8(IOPCIDevice *this, uint8_t memoryIndex, uint64_t offset, uint8_t *readData)
{
}

void IOPCIDevice::MemoryRead16(IOPCIDevice *this, uint8_t memoryIndex, uint64_t offset, uint16_t *readData)
{
}

void IOPCIDevice::MemoryRead32(IOPCIDevice *this, uint8_t memoryIndex, uint64_t offset, uint32_t *readData)
{
}

void IOPCIDevice::MemoryRead64(IOPCIDevice *this, uint8_t memoryIndex, uint64_t offset, uint64_t *readData)
{
}

void IOPCIDevice::MemoryWrite8(IOPCIDevice *this, uint8_t memoryIndex, uint64_t offset, uint8_t data)
{
}

uint64_t IOPCIDevice::SetASPMState(IOPCIDevice *this, unsigned int a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return IOPCIDevice::SetASPMState(this, a2, a3);
}

void IOPCIDevice::MemoryWrite16(IOPCIDevice *this, uint8_t memoryIndex, uint64_t offset, uint16_t data)
{
}

void IOPCIDevice::MemoryWrite32(IOPCIDevice *this, uint8_t memoryIndex, uint64_t offset, uint32_t data)
{
}

void IOPCIDevice::MemoryWrite64(IOPCIDevice *this, uint8_t memoryIndex, uint64_t offset, uint64_t data)
{
}

uint64_t IOPCIDevice::SaveDeviceState(IOPCIDevice *this, unsigned int a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return IOPCIDevice::SaveDeviceState(this, a2, a3);
}

kern_return_t IOPCIDevice::FindPCICapability(IOPCIDevice *this, uint32_t capabilityID, uint64_t searchOffset, uint64_t *foundCapabilityOffset, OSDispatchMethod supermethod)
{
  return IOPCIDevice::FindPCICapability(this, capabilityID, searchOffset, foundCapabilityOffset, supermethod);
}

void IOPCIDevice::ConfigurationRead8(IOPCIDevice *this, uint64_t offset, uint8_t *readData)
{
}

uint64_t IOPCIDevice::RestoreDeviceState(IOPCIDevice *this, unsigned int a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return IOPCIDevice::RestoreDeviceState(this, a2, a3);
}

void IOPCIDevice::ConfigurationRead16(IOPCIDevice *this, uint64_t offset, uint16_t *readData)
{
}

void IOPCIDevice::ConfigurationRead32(IOPCIDevice *this, uint64_t offset, uint32_t *readData)
{
}

void IOPCIDevice::ConfigurationWrite16(IOPCIDevice *this, uint64_t offset, uint16_t data)
{
}

void IOPCIDevice::ConfigurationWrite32(IOPCIDevice *this, uint64_t offset, uint32_t data)
{
}

kern_return_t IOPCIDevice::GetBusDeviceFunction(IOPCIDevice *this, uint8_t *returnBusNumber, uint8_t *returnDeviceNumber, uint8_t *returnFunctionNumber, OSDispatchMethod supermethod)
{
  return IOPCIDevice::GetBusDeviceFunction(this, returnBusNumber, returnDeviceNumber, returnFunctionNumber, supermethod);
}

kern_return_t IOPCIDevice::EnablePCIPowerManagement(IOPCIDevice *this, uint64_t state, OSDispatchMethod supermethod)
{
  return IOPCIDevice::EnablePCIPowerManagement(this, state, supermethod);
}

kern_return_t IOPCIDevice::Open(IOPCIDevice *this, IOService *forClient, IOOptionBits options)
{
  return IOPCIDevice::Open(this, forClient, options);
}

void IOPCIDevice::Close(IOPCIDevice *this, IOService *forClient, IOOptionBits options)
{
}

uint64_t CCDataStream::openSession(CCDataStream *this, const char *a2)
{
  return CCDataStream::openSession(this, a2);
}

uint64_t CCDataStream::closeSession()
{
  return CCDataStream::closeSession();
}

uint64_t CCDataStream::hasProfileLoaded(CCDataStream *this)
{
  return CCDataStream::hasProfileLoaded(this);
}

uint64_t CCDataStream::saveData()
{
  return CCDataStream::saveData();
}

kern_return_t IODMACommand::CompleteDMA(IODMACommand *this, uint64_t options, OSDispatchMethod supermethod)
{
  return IODMACommand::CompleteDMA(this, options, supermethod);
}

kern_return_t IODMACommand::PrepareForDMA(IODMACommand *this, uint64_t options, IOMemoryDescriptor *memory, uint64_t offset, uint64_t length, uint64_t *flags, uint32_t *segmentsCount, IOAddressSegment *segments, OSDispatchMethod supermethod)
{
  return IODMACommand::PrepareForDMA(this, options, memory, offset, length, flags, segmentsCount, segments, supermethod);
}

kern_return_t IODMACommand::Create(IOService *device, uint64_t options, const IODMACommandSpecification *specification, IODMACommand **command)
{
  return IODMACommand::Create(device, options, specification, command);
}

kern_return_t IOUserClient::ExternalMethod(IOUserClient *this, uint64_t selector, IOUserClientMethodArguments *arguments, const IOUserClientMethodDispatch *dispatch, OSObject *target, void *reference)
{
  return IOUserClient::ExternalMethod(this, selector, arguments, dispatch, target, reference);
}

uint64_t IOUserClient::CopyClientEntitlements(IOUserClient *this, OSDictionary **a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return IOUserClient::CopyClientEntitlements(this, a2, a3);
}

kern_return_t IOUserClient::CopyClientMemoryForType_Invoke(const IORPC *rpc, OSMetaClassBase *target, IOUserClient::CopyClientMemoryForType_Handler func)
{
  return IOUserClient::CopyClientMemoryForType_Invoke(rpc, target, func);
}

void IOUserClient::free(IOUserClient *this)
{
}

BOOL IOUserClient::init(IOUserClient *this)
{
  return IOUserClient::init(this);
}

kern_return_t IOUserClient::_Dispatch(IOUserClient *self, const IORPC *rpc)
{
  return IOUserClient::_Dispatch(self, rpc);
}

OSDictionaryPtr OSDictionary::withObjects(const OSObject **values, const OSObject **keys, uint32_t count, uint32_t capacity)
{
  return OSDictionary::withObjects(values, keys, count, capacity);
}

void OSDictionary::removeObject(OSDictionary *this, const OSObject *aKey)
{
}

void OSDictionary::removeObject(OSDictionary *this, const char *aKey)
{
}

OSDictionaryPtr OSDictionary::withCapacity(uint32_t capacity)
{
  return OSDictionary::withCapacity(capacity);
}

BOOL OSDictionary::setObject(OSDictionary *this, const OSObject *aKey, const OSMetaClassBase *anObject)
{
  return OSDictionary::setObject(this, aKey, anObject);
}

BOOL OSDictionary::setObject(OSDictionary *this, const char *aKey, const OSMetaClassBase *anObject)
{
  return OSDictionary::setObject(this, aKey, anObject);
}

uint64_t OSOrderedSet::withCapacity()
{
  return OSOrderedSet::withCapacity();
}

uint64_t OSOrderedSet::setFirstObject(OSOrderedSet *this, const OSMetaClassBase *a2)
{
  return OSOrderedSet::setFirstObject(this, a2);
}

uint64_t CCDataSession::setTimestamp()
{
  return CCDataSession::setTimestamp();
}

uint64_t CCFaultReport::setLinkRegiser(CCFaultReport *this, unint64_t a2)
{
  return CCFaultReport::setLinkRegiser(this, a2);
}

uint64_t CCFaultReport::setProgamCounter(CCFaultReport *this, unint64_t a2)
{
  return CCFaultReport::setProgamCounter(this, a2);
}

uint64_t IO80211Buffer::writeBytes(IO80211Buffer *this, unint64_t a2, const void *a3, unint64_t a4)
{
  return IO80211Buffer::writeBytes(this, a2, a3, a4);
}

uint64_t IO80211Buffer::returnBuffer(IO80211Buffer *this)
{
  return IO80211Buffer::returnBuffer(this);
}

uint64_t IO80211Buffer::getBytesNoCopy(IO80211Buffer *this, unint64_t a2, unint64_t a3)
{
  return IO80211Buffer::getBytesNoCopy(this, a2, a3);
}

uint64_t IO80211Buffer::getBytesNoCopy(IO80211Buffer *this)
{
  return IO80211Buffer::getBytesNoCopy(this);
}

{
  return IO80211Buffer::getBytesNoCopy(this);
}

uint64_t IO80211Buffer::allocBufferSingle()
{
  return IO80211Buffer::allocBufferSingle();
}

uint64_t IO80211Buffer::getMemoryDescriptor(IO80211Buffer *this)
{
  return IO80211Buffer::getMemoryDescriptor(this);
}

uint64_t IO80211Buffer::getCursor(IO80211Buffer *this)
{
  return IO80211Buffer::getCursor(this);
}

uint64_t IO80211Buffer::setLength(IO80211Buffer *this, unint64_t a2)
{
  return IO80211Buffer::setLength(this, a2);
}

uint64_t IOCommandPool::withQueue(IOCommandPool *this, IODispatchQueue *a2)
{
  return IOCommandPool::withQueue(this, a2);
}

uint64_t IO80211CoreDbg::soiCmdPrint()
{
  return IO80211CoreDbg::soiCmdPrint();
}

uint64_t IO80211CoreDbg::handleDebugCmd()
{
  return IO80211CoreDbg::handleDebugCmd();
}

uint64_t IO80211CoreDbg::scanStatsPrint()
{
  return IO80211CoreDbg::scanStatsPrint();
}

uint64_t IO80211CoreDbg::initWithOptions()
{
  return IO80211CoreDbg::initWithOptions();
}

uint64_t IO80211CoreDbg::pktLifetimePrint()
{
  return IO80211CoreDbg::pktLifetimePrint();
}

uint64_t IO80211CoreDbg::parseSInt32FromCMD()
{
  return IO80211CoreDbg::parseSInt32FromCMD();
}

uint64_t IO80211CoreDbg::parseUInt32FromCMD()
{
  return IO80211CoreDbg::parseUInt32FromCMD();
}

uint64_t IO80211CoreDbg::parseUInt64FromCMD()
{
  return IO80211CoreDbg::parseUInt64FromCMD();
}

uint64_t IO80211CoreDbg::btmThresholdCmdPrint()
{
  return IO80211CoreDbg::btmThresholdCmdPrint();
}

uint64_t IOReportLegend::addReporterLegend(IOReportLegend *this, IOService *a2, IOReporter *a3, const char *a4, const char *a5)
{
  return IOReportLegend::addReporterLegend(this, a2, a3, a4, a5);
}

uint64_t CCFaultReporter::clearAction(CCFaultReporter *this)
{
  return CCFaultReporter::clearAction(this);
}

uint64_t CCFaultReporter::reportFault(CCFaultReporter *this, unsigned int a2, const char *a3, unsigned int a4, const char *a5, OSDictionary *a6, int a7, const char *a8, ...)
{
  return CCFaultReporter::reportFault(this, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t CCFaultReporter::registerPanic(CCFaultReporter *this, int (*a2)(OSObject *, const CCFaultReport *), OSObject *a3)
{
  return CCFaultReporter::registerPanic(this, a2, a3);
}

uint64_t CCFaultReporter::panicForReason(CCFaultReporter *this, int a2)
{
  return CCFaultReporter::panicForReason(this, a2);
}

uint64_t CCFaultReporter::induceErrorCode(CCFaultReporter *this, int a2, const char *a3)
{
  return CCFaultReporter::induceErrorCode(this, a2, a3);
}

uint64_t CCFaultReporter::registerWatchdog(CCFaultReporter *this, int (*a2)(OSObject *, const CCFaultReport *), OSObject *a3)
{
  return CCFaultReporter::registerWatchdog(this, a2, a3);
}

uint64_t CCFaultReporter::enableCoreCapture(CCFaultReporter *this, BOOL a2)
{
  return CCFaultReporter::enableCoreCapture(this, a2);
}

uint64_t CCFaultReporter::registerCallbacks()
{
  return CCFaultReporter::registerCallbacks();
}

uint64_t CCFaultReporter::unregisterCallbacks(CCFaultReporter *this, OSObject *a2)
{
  return CCFaultReporter::unregisterCallbacks(this, a2);
}

uint64_t CCFaultReporter::registerErrorDecoder(CCFaultReporter *this, const char *(*a2)(OSObject *, int), OSObject *a3)
{
  return CCFaultReporter::registerErrorDecoder(this, a2, a3);
}

uint64_t CCFaultReporter::withStreamDispatchQueue(CCFaultReporter *this, IOService *a2, CCDataStream *a3, IODispatchQueue *a4)
{
  return CCFaultReporter::withStreamDispatchQueue(this, a2, a3, a4);
}

uint64_t CCFaultReporter::dumpClientListAndHistory(CCFaultReporter *this)
{
  return CCFaultReporter::dumpClientListAndHistory(this);
}

uint64_t CCFaultReporter::enableCollectDeferredFaultData(CCFaultReporter *this, BOOL a2)
{
  return CCFaultReporter::enableCollectDeferredFaultData(this, a2);
}

uint64_t CCFaultReporter::enableCollectImmediateFaultData(CCFaultReporter *this, BOOL a2)
{
  return CCFaultReporter::enableCollectImmediateFaultData(this, a2);
}

uint64_t CCFaultReporter::isBusy(CCFaultReporter *this)
{
  return CCFaultReporter::isBusy(this);
}

uint64_t CCFaultReporter::addOwner(CCFaultReporter *this, const char *a2)
{
  return CCFaultReporter::addOwner(this, a2);
}

uint64_t CCFaultReporter::setAction(CCFaultReporter *this, unsigned int a2)
{
  return CCFaultReporter::setAction(this, a2);
}

uint64_t CCFaultReporter::setEnable(CCFaultReporter *this, BOOL a2)
{
  return CCFaultReporter::setEnable(this, a2);
}

void IODispatchQueue::DispatchSync(IODispatchQueue *this, IODispatchBlock block)
{
}

void IODispatchQueue::DispatchAsync(IODispatchQueue *this, IODispatchBlock block)
{
}

kern_return_t IODispatchQueue::Create(const IODispatchQueueName name, uint64_t options, uint64_t priority, IODispatchQueue **queue)
{
  return IODispatchQueue::Create(name, options, priority, queue);
}

uint64_t IOStateReporter::setStateID(IOStateReporter *this, unint64_t a2, int a3, unint64_t a4)
{
  return IOStateReporter::setStateID(this, a2, a3, a4);
}

uint64_t IOStateReporter::setChannelState(IOStateReporter *this, unint64_t a2, unint64_t a3)
{
  return IOStateReporter::setChannelState(this, a2, a3);
}

uint64_t IOStateReporter::overrideChannelState(IOStateReporter *this, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  return IOStateReporter::overrideChannelState(this, a2, a3, a4, a5, a6);
}

uint64_t IOStateReporter::with(IOStateReporter *this, IOService *a2, unsigned __int16 a3, int a4, unint64_t a5)
{
  return IOStateReporter::with(this, a2, a3, a4, a5);
}

OSMetaClassBase *__cdecl OSMetaClassBase::safeMetaCast(const OSMetaClassBase *anObject, const OSMetaClass *toMeta)
{
  return OSMetaClassBase::safeMetaCast(anObject, toMeta);
}

kern_return_t OSMetaClassBase::Invoke(OSMetaClassBase *this, IORPC *invoke)
{
  return OSMetaClassBase::Invoke(this, invoke);
}

kern_return_t OSMetaClassBase::Dispatch(OSMetaClassBase *this, IORPC *invoke)
{
  return OSMetaClassBase::Dispatch(this, invoke);
}

const OSMetaClass *__cdecl OSMetaClassBase::GetClass(OSMetaClassBase *this)
{
  return OSMetaClassBase::GetClass(this);
}

BOOL OSMetaClassBase::IsRemote(OSMetaClassBase *this)
{
  return OSMetaClassBase::IsRemote(this);
}

uint64_t IO80211BSSBeacon::updateRSSI(IO80211BSSBeacon *this, int a2)
{
  return IO80211BSSBeacon::updateRSSI(this, a2);
}

uint64_t IO80211BSSBeacon::isFtEnabled(IO80211BSSBeacon *this)
{
  return IO80211BSSBeacon::isFtEnabled(this);
}

uint64_t IO80211BSSBeacon::updateNoise(IO80211BSSBeacon *this, __int16 a2)
{
  return IO80211BSSBeacon::updateNoise(this, a2);
}

uint64_t IO80211BSSBeacon::is8021xEnabled(IO80211BSSBeacon *this)
{
  return IO80211BSSBeacon::is8021xEnabled(this);
}

uint64_t IO80211BSSBeacon::updateCCAStats()
{
  return IO80211BSSBeacon::updateCCAStats();
}

uint64_t IO80211BSSBeacon::getCurrentBSSAKMs(IO80211BSSBeacon *this)
{
  return IO80211BSSBeacon::getCurrentBSSAKMs(this);
}

uint64_t IO80211BSSBeacon::updateChannelInfo()
{
  return IO80211BSSBeacon::updateChannelInfo();
}

uint64_t IO80211BSSBeacon::setBeaconDataFromMsg()
{
  return IO80211BSSBeacon::setBeaconDataFromMsg();
}

uint64_t IO80211BSSBeacon::updateLegacyCCAStats()
{
  return IO80211BSSBeacon::updateLegacyCCAStats();
}

uint64_t IO80211BSSBeacon::isLikelyAlpineBMWNetwork(IO80211BSSBeacon *this)
{
  return IO80211BSSBeacon::isLikelyAlpineBMWNetwork(this);
}

uint64_t IO80211BSSBeacon::updateNoiseDeltaOverTwoCores(IO80211BSSBeacon *this, signed __int8 a2)
{
  return IO80211BSSBeacon::updateNoiseDeltaOverTwoCores(this, a2);
}

uint64_t IO80211BSSBeacon::updateCCA(IO80211BSSBeacon *this, signed __int8 a2)
{
  return IO80211BSSBeacon::updateCCA(this, a2);
}

uint64_t IO80211BSSBeacon::updateSNR(IO80211BSSBeacon *this, __int16 a2)
{
  return IO80211BSSBeacon::updateSNR(this, a2);
}

uint64_t IO80211FlowQueue::initWithParamaters(IO80211FlowQueue *this, const ether_addr *a2, unsigned __int8 a3, unsigned __int8 a4)
{
  return IO80211FlowQueue::initWithParamaters(this, a2, a3, a4);
}

uint64_t IO80211WorkQueue::Create()
{
  return IO80211WorkQueue::Create();
}

{
  return IO80211WorkQueue::Create();
}

kern_return_t IODispatchSource::SetEnable(IODispatchSource *this, BOOL enable, OSDispatchMethod supermethod)
{
  return IODispatchSource::SetEnable(this, enable, supermethod);
}

uint64_t IOSimpleReporter::incrementValue(IOSimpleReporter *this, unint64_t a2, uint64_t a3)
{
  return IOSimpleReporter::incrementValue(this, a2, a3);
}

uint64_t IOSimpleReporter::with(IOSimpleReporter *this, IOService *a2, unsigned __int16 a3, unint64_t a4)
{
  return IOSimpleReporter::with(this, a2, a3, a4);
}

uint64_t IOSimpleReporter::getValue(IOSimpleReporter *this, unint64_t a2)
{
  return IOSimpleReporter::getValue(this, a2);
}

uint64_t IOSimpleReporter::setValue(IOSimpleReporter *this, unint64_t a2, uint64_t a3)
{
  return IOSimpleReporter::setValue(this, a2, a3);
}

uint64_t IO80211BssManager::setRateSet()
{
  return IO80211BssManager::setRateSet();
}

uint64_t IO80211BssManager::getAuthType()
{
  return IO80211BssManager::getAuthType();
}

uint64_t IO80211BssManager::isAssociated(IO80211BssManager *this)
{
  return IO80211BssManager::isAssociated(this);
}

uint64_t IO80211BssManager::setAssocSSID(IO80211BssManager *this, const unsigned __int8 *a2, unint64_t a3)
{
  return IO80211BssManager::setAssocSSID(this, a2, a3);
}

uint64_t IO80211BssManager::getCurrentCCA(IO80211BssManager *this, signed __int8 *a2)
{
  return IO80211BssManager::getCurrentCCA(this, a2);
}

uint64_t IO80211BssManager::setCurrentBSS(IO80211BssManager *this, IO80211BSSBeacon *a2, BOOL a3)
{
  return IO80211BssManager::setCurrentBSS(this, a2, a3);
}

uint64_t IO80211BssManager::getAuthContext()
{
  return IO80211BssManager::getAuthContext();
}

uint64_t IO80211BssManager::getCurrentBand()
{
  return IO80211BssManager::getCurrentBand();
}

uint64_t IO80211BssManager::getCurrentRSSI(IO80211BssManager *this, int *a2)
{
  return IO80211BssManager::getCurrentRSSI(this, a2);
}

uint64_t IO80211BssManager::setAuthContext()
{
  return IO80211BssManager::setAuthContext();
}

uint64_t IO80211BssManager::setLastBSSRssi(IO80211BssManager *this)
{
  return IO80211BssManager::setLastBSSRssi(this);
}

uint64_t IO80211BssManager::setMCSIndexSet()
{
  return IO80211BssManager::setMCSIndexSet();
}

uint64_t IO80211BssManager::getCurrentBSSID(IO80211BssManager *this, ether_addr *a2)
{
  return IO80211BssManager::getCurrentBSSID(this, a2);
}

uint64_t IO80211BssManager::getCurrentNoise(IO80211BssManager *this, __int16 *a2)
{
  return IO80211BssManager::getCurrentNoise(this, a2);
}

uint64_t IO80211BssManager::initwithOptions(IO80211BssManager *this, CCLogStream *a2)
{
  return IO80211BssManager::initwithOptions(this, a2);
}

uint64_t IO80211BssManager::setAdHocCreated(IO80211BssManager *this, BOOL a2)
{
  return IO80211BssManager::setAdHocCreated(this, a2);
}

uint64_t IO80211BssManager::getCurrentIEList(IO80211BssManager *this, unsigned __int8 *a2, unsigned int *a3)
{
  return IO80211BssManager::getCurrentIEList(this, a2, a3);
}

uint64_t IO80211BssManager::isAssociatedOn2G(IO80211BssManager *this)
{
  return IO80211BssManager::isAssociatedOn2G(this);
}

uint64_t IO80211BssManager::isAssociatedOn5G(IO80211BssManager *this)
{
  return IO80211BssManager::isAssociatedOn5G(this);
}

uint64_t IO80211BssManager::isAssociatedOn6G(IO80211BssManager *this)
{
  return IO80211BssManager::isAssociatedOn6G(this);
}

uint64_t IO80211BssManager::set5GhPreference(IO80211BssManager *this, BOOL a2)
{
  return IO80211BssManager::set5GhPreference(this, a2);
}

uint64_t IO80211BssManager::getCurrentBSSAKMs(IO80211BssManager *this)
{
  return IO80211BssManager::getCurrentBSSAKMs(this);
}

uint64_t IO80211BssManager::getCurrentChannel()
{
  return IO80211BssManager::getCurrentChannel();
}

uint64_t IO80211BssManager::setBandInfoBitmap(IO80211BssManager *this, unsigned int a2)
{
  return IO80211BssManager::setBandInfoBitmap(this, a2);
}

uint64_t IO80211BssManager::setVHTMCSIndexSet()
{
  return IO80211BssManager::setVHTMCSIndexSet();
}

uint64_t IO80211BssManager::getCurrentAuthType(IO80211BssManager *this)
{
  return IO80211BssManager::getCurrentAuthType(this);
}

uint64_t IO80211BssManager::getCurrentCCAStats()
{
  return IO80211BssManager::getCurrentCCAStats();
}

uint64_t IO80211BssManager::updateWeightAvgLQM()
{
  return IO80211BssManager::updateWeightAvgLQM();
}

uint64_t IO80211BssManager::isAssociatedToAdhoc(IO80211BssManager *this)
{
  return IO80211BssManager::isAssociatedToAdhoc(this);
}

uint64_t IO80211BssManager::resetRateAndIndexSet(IO80211BssManager *this)
{
  return IO80211BssManager::resetRateAndIndexSet(this);
}

uint64_t IO80211BssManager::isAssociatedOnHighBand(IO80211BssManager *this)
{
  return IO80211BssManager::isAssociatedOnHighBand(this);
}

uint64_t IO80211BssManager::setAssociateToHotspotInWoWMode(IO80211BssManager *this, BOOL a2)
{
  return IO80211BssManager::setAssociateToHotspotInWoWMode(this, a2);
}

uint64_t IO80211BssManager::get6GMode(IO80211BssManager *this)
{
  return IO80211BssManager::get6GMode(this);
}

uint64_t IO80211BssManager::getOPMode(IO80211BssManager *this)
{
  return IO80211BssManager::getOPMode(this);
}

uint64_t IO80211BssManager::set6GMode(IO80211BssManager *this, unsigned int a2)
{
  return IO80211BssManager::set6GMode(this, a2);
}

uint64_t IO80211BufferPool::withOptions()
{
  return IO80211BufferPool::withOptions();
}

uint64_t IO80211Controller::logLQMToCC(IO80211Controller *this, const char *a2, ...)
{
  return IO80211Controller::logLQMToCC(this, a2);
}

uint64_t IO80211Controller::setChanCCA()
{
  return IO80211Controller::setChanCCA();
}

uint64_t IO80211Controller::postMessage(IO80211Controller *a1, IO80211SkywalkInterface *a2, unsigned int a3, void *a4, unint64_t a5, BOOL a6)
{
  return IO80211Controller::postMessage(a1, a2, a3, a4, a5, a6);
}

uint64_t IO80211Controller::setAMPDUstat()
{
  return IO80211Controller::setAMPDUstat();
}

uint64_t IO80211Controller::updateReport(IO80211Controller *this, OSData *a2, unsigned int a3, unsigned int *a4, unint64_t a5, unint64_t a6, IOMemoryDescriptor *a7)
{
  return IO80211Controller::updateReport(this, a2, a3, a4, a5, a6, a7);
}

uint64_t IO80211Controller::setBTCoexstat()
{
  return IO80211Controller::setBTCoexstat();
}

uint64_t IO80211Controller::setFrameStats()
{
  return IO80211Controller::setFrameStats();
}

uint64_t IO80211Controller::setPowerStats()
{
  return IO80211Controller::setPowerStats();
}

uint64_t IO80211Controller::getProcessName(IO80211Controller *this, char *a2, unint64_t a3)
{
  return IO80211Controller::getProcessName(this, a2, a3);
}

uint64_t IO80211Controller::setLTECoexstat()
{
  return IO80211Controller::setLTECoexstat();
}

uint64_t IO80211Controller::configureReport(IO80211Controller *this, OSData *a2, unsigned int a3, unsigned int *a4)
{
  return IO80211Controller::configureReport(this, a2, a3, a4);
}

uint64_t IO80211Controller::addReporterLegend(IO80211Controller *this, IOService *a2, IOReporter *a3, const char *a4, const char *a5)
{
  return IO80211Controller::addReporterLegend(this, a2, a3, a4, a5);
}

uint64_t IO80211Controller::getDeadlockPolice(IO80211Controller *this)
{
  return IO80211Controller::getDeadlockPolice(this);
}

uint64_t IO80211Controller::isLQMCCLOGEnabled(IO80211Controller *this)
{
  return IO80211Controller::isLQMCCLOGEnabled(this);
}

uint64_t IO80211Controller::isLQMIOLOGEnabled(IO80211Controller *this)
{
  return IO80211Controller::isLQMIOLOGEnabled(this);
}

uint64_t IO80211Controller::isLQMOSLOGEnabled(IO80211Controller *this)
{
  return IO80211Controller::isLQMOSLOGEnabled(this);
}

uint64_t IO80211Controller::setChanNoiseFloor()
{
  return IO80211Controller::setChanNoiseFloor();
}

uint64_t IO80211Controller::setChanExtendedCCA()
{
  return IO80211Controller::setChanExtendedCCA();
}

uint64_t IO80211Controller::getReporterProvider(IO80211Controller *this)
{
  return IO80211Controller::getReporterProvider(this);
}

uint64_t IO80211Controller::setChipCounterStats()
{
  return IO80211Controller::setChipCounterStats();
}

uint64_t IO80211Controller::setChanNoiseFloorLTE()
{
  return IO80211Controller::setChanNoiseFloorLTE();
}

uint64_t IO80211Controller::enablePacketTimestamping(IO80211Controller *this)
{
  return IO80211Controller::enablePacketTimestamping(this);
}

uint64_t IO80211Controller::disablePacketTimestamping(IO80211Controller *this)
{
  return IO80211Controller::disablePacketTimestamping(this);
}

uint64_t IO80211Controller::PublishReporterProxyService(IO80211Controller *this)
{
  return IO80211Controller::PublishReporterProxyService(this);
}

uint64_t IO80211Controller::setExtendedChipCounterStats()
{
  return IO80211Controller::setExtendedChipCounterStats();
}

uint64_t IO80211Controller::init(IO80211Controller *this, OSDictionary *a2)
{
  return IO80211Controller::init(this, a2);
}

uint64_t IO80211Controller::init(IO80211Controller *this)
{
  return IO80211Controller::init(this);
}

uint64_t IO80211Controller::start(IO80211Controller *this, IOService *a2)
{
  return IO80211Controller::start(this, a2);
}

uint64_t IO80211Controller::getPid(IO80211Controller *this)
{
  return IO80211Controller::getPid(this);
}

uint64_t IO80211Controller::_Dispatch(IO80211Controller *this, IO80211Controller *a2, IORPC *a3)
{
  return IO80211Controller::_Dispatch(this, a2, a3);
}

uint64_t IO80211WorkSource::signalWorkAvailable(IO80211WorkSource *this)
{
  return IO80211WorkSource::signalWorkAvailable(this);
}

uint64_t IO80211WorkSource::init(IO80211WorkSource *this, OSObject *a2, void (*a3)(OSObject *, ...))
{
  return IO80211WorkSource::init(this, a2, a3);
}

uint64_t IO80211WorkSource::enable(IO80211WorkSource *this)
{
  return IO80211WorkSource::enable(this);
}

uint64_t IO80211WorkSource::isEnabled(IO80211WorkSource *this)
{
  return IO80211WorkSource::isEnabled(this);
}

uint64_t IO80211CagedBuffer::withLayout()
{
  return IO80211CagedBuffer::withLayout();
}

uint64_t IO80211CagedBuffer::copyIn(IO80211CagedBuffer *this, const void *a2, unint64_t a3)
{
  return IO80211CagedBuffer::copyIn(this, a2, a3);
}

uint64_t IO80211CagedBuffer::unlock(IO80211CagedBuffer *this)
{
  return IO80211CagedBuffer::unlock(this);
}

uint64_t IO80211CagedBuffer::tryLock(IO80211CagedBuffer *this)
{
  return IO80211CagedBuffer::tryLock(this);
}

uint64_t IO80211CagedBuffer::getBuffer(IO80211CagedBuffer *this)
{
  return IO80211CagedBuffer::getBuffer(this);
}

uint64_t IO80211CommandGate::allocWithParams()
{
  return IO80211CommandGate::allocWithParams();
}

uint64_t IO80211NANProtocol::_Dispatch()
{
  return IO80211NANProtocol::_Dispatch();
}

uint64_t IO80211SapProtocol::_Dispatch()
{
  return IO80211SapProtocol::_Dispatch();
}

uint64_t IO80211TimerSource::allocWithParams()
{
  return IO80211TimerSource::allocWithParams();
}

kern_return_t IOMemoryDescriptor::CreateMapping(IOMemoryDescriptor *this, uint64_t options, uint64_t address, uint64_t offset, uint64_t length, uint64_t alignment, IOMemoryMap **map, OSDispatchMethod supermethod)
{
  return IOMemoryDescriptor::CreateMapping(this, options, address, offset, length, alignment, map, supermethod);
}

uint64_t IOMemoryDescriptor::CreateSubMemoryDescriptor(IOMemoryDescriptor *this, unint64_t a2, unint64_t a3, unint64_t a4, IOMemoryDescriptor *a5, IOMemoryDescriptor **a6)
{
  return IOMemoryDescriptor::CreateSubMemoryDescriptor(this, a2, a3, a4, a5, a6);
}

kern_return_t IOMemoryDescriptor::GetLength(IOMemoryDescriptor *this, uint64_t *returnLength)
{
  return IOMemoryDescriptor::GetLength(this, returnLength);
}

uint64_t IO80211AWDLProtocol::_Dispatch()
{
  return IO80211AWDLProtocol::_Dispatch();
}

uint64_t IOHistogramReporter::tallyValue(IOHistogramReporter *this, uint64_t a2)
{
  return IOHistogramReporter::tallyValue(this, a2);
}

uint64_t IOHistogramReporter::with()
{
  return IOHistogramReporter::with();
}

uint64_t IOUserNetworkPacket::initWithPool()
{
  return IOUserNetworkPacket::initWithPool();
}

uint64_t IOUserNetworkPacket::setIsLinkMulticast(IOUserNetworkPacket *this, BOOL a2)
{
  return IOUserNetworkPacket::setIsLinkMulticast(this, a2);
}

void IOUserNetworkPacket::free(IOUserNetworkPacket *this)
{
}

uint64_t IO80211FaultReporter::allocWithParams(IO80211FaultReporter *this, CCFaultReporter *a2)
{
  return IO80211FaultReporter::allocWithParams(this, a2);
}

uint64_t IO80211InfraProtocol::_Dispatch()
{
  return IO80211InfraProtocol::_Dispatch();
}

uint64_t IO80211NetworkPacket::getHeadroom(IO80211NetworkPacket *this)
{
  return IO80211NetworkPacket::getHeadroom(this);
}

uint64_t IO80211NetworkPacket::setHeadroom(IO80211NetworkPacket *this, unsigned __int8 a2)
{
  return IO80211NetworkPacket::setHeadroom(this, a2);
}

uint64_t IO80211NetworkPacket::setLinkHeaderOffset(IO80211NetworkPacket *this, unsigned int a2)
{
  return IO80211NetworkPacket::setLinkHeaderOffset(this, a2);
}

uint64_t IO80211DeadlockPolice::resetDeadlockPolice(IO80211DeadlockPolice *this, IODispatchQueue *a2)
{
  return IO80211DeadlockPolice::resetDeadlockPolice(this, a2);
}

uint64_t IO80211InfraInterface::getWMMBWReset(IO80211InfraInterface *this)
{
  return IO80211InfraInterface::getWMMBWReset(this);
}

uint64_t IO80211InfraInterface::setIPv4Params()
{
  return IO80211InfraInterface::setIPv4Params();
}

uint64_t IO80211InfraInterface::setIPv6Params()
{
  return IO80211InfraInterface::setIPv6Params();
}

uint64_t IO80211InfraInterface::setWMMBWReset(IO80211InfraInterface *this, BOOL a2)
{
  return IO80211InfraInterface::setWMMBWReset(this, a2);
}

uint64_t IO80211InfraInterface::getBtCoexState(IO80211InfraInterface *this)
{
  return IO80211InfraInterface::getBtCoexState(this);
}

uint64_t IO80211InfraInterface::getTrafficMonitor(IO80211InfraInterface *this)
{
  return IO80211InfraInterface::getTrafficMonitor(this);
}

uint64_t IO80211InfraInterface::setInterfaceEnable(IO80211InfraInterface *this, BOOL a2)
{
  return IO80211InfraInterface::setInterfaceEnable(this, a2);
}

uint64_t IO80211InfraInterface::cancelDebounceTimer(IO80211InfraInterface *this)
{
  return IO80211InfraInterface::cancelDebounceTimer(this);
}

uint64_t IO80211InfraInterface::getArpKeepAliveData()
{
  return IO80211InfraInterface::getArpKeepAliveData();
}

uint64_t IO80211InfraInterface::getCurrentApAddress(IO80211InfraInterface *this)
{
  return IO80211InfraInterface::getCurrentApAddress(this);
}

uint64_t IO80211InfraInterface::getMagicPatternData()
{
  return IO80211InfraInterface::getMagicPatternData();
}

uint64_t IO80211InfraInterface::getPacketFilterData()
{
  return IO80211InfraInterface::getPacketFilterData();
}

uint64_t IO80211InfraInterface::setCurrentApAddress(IO80211InfraInterface *this, ether_addr *a2)
{
  return IO80211InfraInterface::setCurrentApAddress(this, a2);
}

uint64_t IO80211InfraInterface::getProtocolOffloadData()
{
  return IO80211InfraInterface::getProtocolOffloadData();
}

uint64_t IO80211InfraInterface::getTcpUdpKeepAliveData()
{
  return IO80211InfraInterface::getTcpUdpKeepAliveData();
}

uint64_t IO80211InfraInterface::init(IO80211InfraInterface *this)
{
  return IO80211InfraInterface::init(this);
}

uint64_t IO80211InfraInterface::start(IO80211InfraInterface *this, IOService *a2)
{
  return IO80211InfraInterface::start(this, a2);
}

uint64_t IO80211InfraInterface::bpfTap(IO80211InfraInterface *this, unsigned int a2, unsigned int a3)
{
  return IO80211InfraInterface::bpfTap(this, a2, a3);
}

uint64_t IO80211TrafficMonitor::createTrafficNotification()
{
  return IO80211TrafficMonitor::createTrafficNotification();
}

kern_return_t IOUserNetworkEthernet::SetTxPacketHeadroom(IOUserNetworkEthernet *this, uint16_t numBytes)
{
  return IOUserNetworkEthernet::SetTxPacketHeadroom(this, numBytes);
}

uint64_t IO80211ApFeatureConfig::getLimitedAggregationEnable(IO80211ApFeatureConfig *this)
{
  return IO80211ApFeatureConfig::getLimitedAggregationEnable(this);
}

uint64_t IO80211NANDataProtocol::_Dispatch()
{
  return IO80211NANDataProtocol::_Dispatch();
}

uint64_t IO80211SkywalkInterface::getWorkQueue(IO80211SkywalkInterface *this)
{
  return IO80211SkywalkInterface::getWorkQueue(this);
}

uint64_t IO80211SkywalkInterface::getController(IO80211SkywalkInterface *this)
{
  return IO80211SkywalkInterface::getController(this);
}

uint64_t IO80211SkywalkInterface::printDataPath()
{
  return IO80211SkywalkInterface::printDataPath();
}

uint64_t IO80211SkywalkInterface::getInterfaceId(IO80211SkywalkInterface *this)
{
  return IO80211SkywalkInterface::getInterfaceId(this);
}

uint64_t IO80211SkywalkInterface::setInterfaceId(IO80211SkywalkInterface *this, unsigned int a2)
{
  return IO80211SkywalkInterface::setInterfaceId(this, a2);
}

uint64_t IO80211SkywalkInterface::getInterfaceRole(IO80211SkywalkInterface *this)
{
  return IO80211SkywalkInterface::getInterfaceRole(this);
}

uint64_t IO80211SkywalkInterface::setInterfaceRole(IO80211SkywalkInterface *this, unsigned int a2)
{
  return IO80211SkywalkInterface::setInterfaceRole(this, a2);
}

uint64_t IO80211SkywalkInterface::recordInputPacket(IO80211SkywalkInterface *this, int a2, int a3)
{
  return IO80211SkywalkInterface::recordInputPacket(this, a2, a3);
}

uint64_t IO80211SkywalkInterface::registerInterface(IO80211SkywalkInterface *this)
{
  return IO80211SkywalkInterface::registerInterface(this);
}

uint64_t IO80211SkywalkInterface::setInitMacAddress(IO80211SkywalkInterface *this, ether_addr *a2)
{
  return IO80211SkywalkInterface::setInitMacAddress(this, a2);
}

uint64_t IO80211SkywalkInterface::getActiveMediaType(IO80211SkywalkInterface *this)
{
  return IO80211SkywalkInterface::getActiveMediaType(this);
}

uint64_t IO80211SkywalkInterface::getParentInterface(IO80211SkywalkInterface *this)
{
  return IO80211SkywalkInterface::getParentInterface(this);
}

uint64_t IO80211SkywalkInterface::setParentInterface(IO80211SkywalkInterface *a1, IO80211VirtualInterface *a2)
{
  return IO80211SkywalkInterface::setParentInterface(a1, a2);
}

uint64_t IO80211SkywalkInterface::getInterfaceRoleStr(IO80211SkywalkInterface *this)
{
  return IO80211SkywalkInterface::getInterfaceRoleStr(this);
}

uint64_t IO80211SkywalkInterface::isLowLatencyEnabled(IO80211SkywalkInterface *this)
{
  return IO80211SkywalkInterface::isLowLatencyEnabled(this);
}

uint64_t IO80211SkywalkInterface::setLowLatencyEnabled(IO80211SkywalkInterface *this, BOOL a2)
{
  return IO80211SkywalkInterface::setLowLatencyEnabled(this, a2);
}

uint64_t IO80211SkywalkInterface::validateDispatchQueue(IO80211SkywalkInterface *this)
{
  return IO80211SkywalkInterface::validateDispatchQueue(this);
}

uint64_t IO80211SkywalkInterface::setCompanionInterfaceId(IO80211SkywalkInterface *this, unsigned int a2)
{
  return IO80211SkywalkInterface::setCompanionInterfaceId(this, a2);
}

uint64_t IO80211SkywalkInterface::init(IO80211SkywalkInterface *this)
{
  return IO80211SkywalkInterface::init(this);
}

uint64_t IO80211SkywalkInterface::enable(IO80211SkywalkInterface *this, unsigned int a2)
{
  return IO80211SkywalkInterface::enable(this, a2);
}

uint64_t IO80211SkywalkInterface::disable(IO80211SkywalkInterface *this, unsigned int a2)
{
  return IO80211SkywalkInterface::disable(this, a2);
}

uint64_t IO80211VirtualInterface::bpfTapInput(IO80211VirtualInterface *this, IO80211Buffer *a2, unsigned int a3, void *a4, unint64_t a5)
{
  return IO80211VirtualInterface::bpfTapInput(this, a2, a3, a4, a5);
}

uint64_t IO80211VirtualInterface::printDataPath()
{
  return IO80211VirtualInterface::printDataPath();
}

uint64_t IO80211VirtualInterface::getMgmtFramePool(IO80211VirtualInterface *this)
{
  return IO80211VirtualInterface::getMgmtFramePool(this);
}

uint64_t IO80211VirtualInterface::setInterfaceEnable(IO80211VirtualInterface *this, BOOL a2)
{
  return IO80211VirtualInterface::setInterfaceEnable(this, a2);
}

uint64_t IO80211VirtualInterface::modifyUnicastPacket(IO80211VirtualInterface *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 a4, unsigned int *a5, unsigned __int8 *a6)
{
  return IO80211VirtualInterface::modifyUnicastPacket(this, a2, a3, a4, a5, a6);
}

uint64_t IO80211VirtualInterface::handleMulticastTransmit(IO80211VirtualInterface *this, IO80211NetworkPacket *a2, unsigned __int8 *a3, unsigned int a4, unsigned __int8 a5)
{
  return IO80211VirtualInterface::handleMulticastTransmit(this, a2, a3, a4, a5);
}

uint64_t IO80211VirtualInterface::stashMulticastPacketPair(IO80211VirtualInterface *this, IO80211NetworkPacket *a2, IO80211NetworkPacket *a3)
{
  return IO80211VirtualInterface::stashMulticastPacketPair(this, a2, a3);
}

uint64_t IO80211VirtualInterface::setCompanionLowLatencySkywalkInterface(IO80211VirtualInterface *this, IO80211SkywalkInterface *a2)
{
  return IO80211VirtualInterface::setCompanionLowLatencySkywalkInterface(this, a2);
}

uint64_t IO80211VirtualInterface::init(IO80211VirtualInterface *this, IO80211Controller *a2, ether_addr *a3, unsigned int a4, const char *a5)
{
  return IO80211VirtualInterface::init(this, a2, a3, a4, a5);
}

uint64_t IO80211VirtualInterface::start(IO80211VirtualInterface *this, IOService *a2)
{
  return IO80211VirtualInterface::start(this, a2);
}

uint64_t IO80211VirtualInterface::logDebug(IO80211VirtualInterface *this, const char *a2, ...)
{
  return IO80211VirtualInterface::logDebug(this, a2);
}

uint64_t IO80211FlowQueueDatabase::initialize(IO80211FlowQueueDatabase *this)
{
  return IO80211FlowQueueDatabase::initialize(this);
}

uint64_t IO80211FlowQueueDatabase::find(IO80211FlowQueueDatabase *this, BOOL (*a2)(IO80211FlowQueue *, void *), void *a3)
{
  return IO80211FlowQueueDatabase::find(this, a2, a3);
}

uint64_t IO80211FlowQueueDatabase::find(IO80211FlowQueueDatabase *this, unint64_t a2)
{
  return IO80211FlowQueueDatabase::find(this, a2);
}

uint64_t IO80211FlowQueueDatabase::print(IO80211FlowQueueDatabase *this, void *a2)
{
  return IO80211FlowQueueDatabase::print(this, a2);
}

uint64_t IO80211FlowQueueDatabase::insert(IO80211FlowQueueDatabase *this, IO80211FlowQueue *a2)
{
  return IO80211FlowQueueDatabase::insert(this, a2);
}

uint64_t IO80211FlowQueueDatabase::remove(IO80211FlowQueueDatabase *this, unint64_t a2)
{
  return IO80211FlowQueueDatabase::remove(this, a2);
}

uint64_t IO80211ThreadProcessInfo::getProcessPid(IO80211ThreadProcessInfo *this, int *a2)
{
  return IO80211ThreadProcessInfo::getProcessPid(this, a2);
}

uint64_t IO80211ThreadProcessInfo::getProcessName(IO80211ThreadProcessInfo *this, char *a2, unint64_t a3)
{
  return IO80211ThreadProcessInfo::getProcessName(this, a2, a3);
}

kern_return_t IOBufferMemoryDescriptor::GetAddressRange(IOBufferMemoryDescriptor *this, IOAddressSegment *range)
{
  return IOBufferMemoryDescriptor::GetAddressRange(this, range);
}

kern_return_t IOUserNetworkPacketQueue::SetEnable(IOUserNetworkPacketQueue *this, BOOL isEnable, OSDispatchMethod supermethod)
{
  return IOUserNetworkPacketQueue::SetEnable(this, isEnable, supermethod);
}

kern_return_t IODataQueueDispatchSource::DataAvailable_Invoke(const IORPC *rpc, OSMetaClassBase *target, IODataQueueDispatchSource::DataAvailable_Handler func, const OSMetaClass *targetActionClass)
{
  return IODataQueueDispatchSource::DataAvailable_Invoke(rpc, target, func, targetActionClass);
}

kern_return_t IODataQueueDispatchSource::SetDataAvailableHandler(IODataQueueDispatchSource *this, OSAction *action, OSDispatchMethod supermethod)
{
  return IODataQueueDispatchSource::SetDataAvailableHandler(this, action, supermethod);
}

kern_return_t IOInterruptDispatchSource::SetHandler(IOInterruptDispatchSource *this, OSAction *action, OSDispatchMethod supermethod)
{
  return IOInterruptDispatchSource::SetHandler(this, action, supermethod);
}

kern_return_t IOInterruptDispatchSource::GetInterruptType(IOService *provider, uint32_t index, uint64_t *interruptType)
{
  return IOInterruptDispatchSource::GetInterruptType(provider, index, interruptType);
}

uint64_t IOInterruptDispatchSource::GetLastInterrupt(IOInterruptDispatchSource *this, unint64_t *a2, unint64_t *a3, int (*a4)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return IOInterruptDispatchSource::GetLastInterrupt(this, a2, a3, a4);
}

kern_return_t IOInterruptDispatchSource::InterruptOccurred_Invoke(const IORPC *rpc, OSMetaClassBase *target, IOInterruptDispatchSource::InterruptOccurred_Handler func, const OSMetaClass *targetActionClass)
{
  return IOInterruptDispatchSource::InterruptOccurred_Invoke(rpc, target, func, targetActionClass);
}

kern_return_t IOInterruptDispatchSource::Create(IOService *provider, uint32_t index, IODispatchQueue *queue, IOInterruptDispatchSource **source)
{
  return IOInterruptDispatchSource::Create(provider, index, queue, source);
}

uint64_t AppleOLYHALPlatformFunction::flrReleaseDK(AppleOLYHALPlatformFunction *this, int (*a2)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPlatformFunction::flrReleaseDK(this, a2);
}

uint64_t AppleOLYHALPlatformFunction::setPowerEnableDK(AppleOLYHALPlatformFunction *this, BOOL a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPlatformFunction::setPowerEnableDK(this, a2, a3);
}

uint64_t AppleOLYHALPlatformFunction::deviceCheckLPEMDK(AppleOLYHALPlatformFunction *this, int (*a2)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPlatformFunction::deviceCheckLPEMDK(this, a2);
}

uint64_t AppleOLYHALPlatformFunction::copyWLANPropertiesDK(AppleOLYHALPlatformFunction *this, OSDictionary **a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPlatformFunction::copyWLANPropertiesDK(this, a2, a3);
}

uint64_t AppleOLYHALPlatformFunction::getLowPowerDetectedDK(AppleOLYHALPlatformFunction *this, int (*a2)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPlatformFunction::getLowPowerDetectedDK(this, a2);
}

uint64_t AppleOLYHALPlatformFunction::setLowPowerDetectedDK(AppleOLYHALPlatformFunction *this, BOOL a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPlatformFunction::setLowPowerDetectedDK(this, a2, a3);
}

uint64_t AppleOLYHALPlatformFunction::getLastChipsetPowerOnDK(AppleOLYHALPlatformFunction *this, unint64_t *a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPlatformFunction::getLastChipsetPowerOnDK(this, a2, a3);
}

uint64_t AppleOLYHALPlatformFunction::getLastChipsetPowerOffDK(AppleOLYHALPlatformFunction *this, unint64_t *a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPlatformFunction::getLastChipsetPowerOffDK(this, a2, a3);
}

uint64_t AppleOLYHALPlatformFunction::flrHoldDK(AppleOLYHALPlatformFunction *this, int (*a2)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPlatformFunction::flrHoldDK(this, a2);
}

uint64_t AppleOLYHALPortInterfacePCIe::setDeviceWakeDK(AppleOLYHALPortInterfacePCIe *this, BOOL a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPortInterfacePCIe::setDeviceWakeDK(this, a2, a3);
}

uint64_t AppleOLYHALPortInterfacePCIe::deviceTurnedOnDK(AppleOLYHALPortInterfacePCIe *this, int (*a2)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPortInterfacePCIe::deviceTurnedOnDK(this, a2);
}

uint64_t AppleOLYHALPortInterfacePCIe::completePortErrorMsg(AppleOLYHALPortInterfacePCIe *this, unsigned int a2, unsigned int a3, int a4, int (*a5)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPortInterfacePCIe::completePortErrorMsg(this, a2, a3, a4, a5);
}

uint64_t AppleOLYHALPortInterfacePCIe::completePortEventMsg(AppleOLYHALPortInterfacePCIe *this, unsigned int a2, unsigned int a3, int a4, int (*a5)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPortInterfacePCIe::completePortEventMsg(this, a2, a3, a4, a5);
}

uint64_t AppleOLYHALPortInterfacePCIe::checkBuiltInPropertyDK(AppleOLYHALPortInterfacePCIe *this, int (*a2)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPortInterfacePCIe::checkBuiltInPropertyDK(this, a2);
}

uint64_t AppleOLYHALPortInterfacePCIe::enableDumpLogBTResetDK(AppleOLYHALPortInterfacePCIe *this, BOOL a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPortInterfacePCIe::enableDumpLogBTResetDK(this, a2, a3);
}

uint64_t AppleOLYHALPortInterfacePCIe::setPortErrorMsgHandler(AppleOLYHALPortInterfacePCIe *this, OSAction *a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPortInterfacePCIe::setPortErrorMsgHandler(this, a2, a3);
}

uint64_t AppleOLYHALPortInterfacePCIe::setPortEventMsgHandler(AppleOLYHALPortInterfacePCIe *this, OSAction *a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPortInterfacePCIe::setPortEventMsgHandler(this, a2, a3);
}

uint64_t AppleOLYHALPortInterfacePCIe::isPTMWorkaroundNeededDK(AppleOLYHALPortInterfacePCIe *this, int (*a2)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPortInterfacePCIe::isPTMWorkaroundNeededDK(this, a2);
}

uint64_t AppleOLYHALPortInterfacePCIe::isLPEMWorkaroundNeededDK(AppleOLYHALPortInterfacePCIe *this, int (*a2)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPortInterfacePCIe::isLPEMWorkaroundNeededDK(this, a2);
}

uint64_t AppleOLYHALPortInterfacePCIe::deviceWakeGPIOAvailableDK(AppleOLYHALPortInterfacePCIe *this, int (*a2)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPortInterfacePCIe::deviceWakeGPIOAvailableDK(this, a2);
}

uint64_t AppleOLYHALPortInterfacePCIe::bridgePTMPropertyEnabledDK(AppleOLYHALPortInterfacePCIe *this, int (*a2)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPortInterfacePCIe::bridgePTMPropertyEnabledDK(this, a2);
}

uint64_t AppleOLYHALPortInterfacePCIe::isPortControlAMFMManagedDK(AppleOLYHALPortInterfacePCIe *this, int (*a2)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return AppleOLYHALPortInterfacePCIe::isPortControlAMFMManagedDK(this, a2);
}

uint64_t AppleOLYHALPortInterfacePCIe::portErrorMsgHandler_Invoke(AppleOLYHALPortInterfacePCIe *this, IORPC *a2, OSMetaClassBase *a3, void (*a4)(OSMetaClassBase *, OSAction *, OSNumber *, OSNumber *, OSData *), const OSMetaClass *a5)
{
  return AppleOLYHALPortInterfacePCIe::portErrorMsgHandler_Invoke(this, a2, a3, a4, a5);
}

uint64_t AppleOLYHALPortInterfacePCIe::portEventMsgHandler_Invoke(AppleOLYHALPortInterfacePCIe *this, IORPC *a2, OSMetaClassBase *a3, void (*a4)(OSMetaClassBase *, OSAction *, OSNumber *, OSNumber *, OSNumber *, OSData *), const OSMetaClass *a5)
{
  return AppleOLYHALPortInterfacePCIe::portEventMsgHandler_Invoke(this, a2, a3, a4, a5);
}

uint64_t AppleOLYHALPortInterfacePCIe::enableDK()
{
  return AppleOLYHALPortInterfacePCIe::enableDK();
}

uint64_t IOUserNetworkPacketBufferPool::initWithName(IOUserNetworkPacketBufferPool *this, const char *a2, OSObject *a3, unsigned int a4, const IOUserNetworkPacketBufferPoolOptions *a5)
{
  return IOUserNetworkPacketBufferPool::initWithName(this, a2, a3, a4, a5);
}

uint64_t IOUserNetworkPacketBufferPool::allocatePacket(IOUserNetworkPacketBufferPool *this, IOUserNetworkPacket **a2, unsigned int a3)
{
  return IOUserNetworkPacketBufferPool::allocatePacket(this, a2, a3);
}

void IOUserNetworkPacketBufferPool::free(IOUserNetworkPacketBufferPool *this)
{
}

uint64_t IOUserNetworkRxCompletionQueue::initWithPool(IOUserNetworkRxCompletionQueue *this, IOUserNetworkPacketBufferPool *a2, unsigned int a3, unsigned int a4, OSObject *a5, unsigned int (*a6)(OSObject *, IOUserNetworkPacketQueue *, IOUserNetworkPacket **, unsigned int, void *), void *a7, unsigned int a8)
{
  return IOUserNetworkRxCompletionQueue::initWithPool(this, a2, a3, a4, a5, a6, a7, a8);
}

void IOUserNetworkRxCompletionQueue::free(IOUserNetworkRxCompletionQueue *this)
{
}

uint64_t IOUserNetworkRxSubmissionQueue::initWithPool(IOUserNetworkRxSubmissionQueue *this, IOUserNetworkPacketBufferPool *a2, unsigned int a3, unsigned int a4, unsigned int a5, OSObject *a6, unsigned int (*a7)(OSObject *, IOUserNetworkPacketQueue *, IOUserNetworkPacket **, unsigned int, void *), void *a8, unsigned int a9)
{
  return IOUserNetworkRxSubmissionQueue::initWithPool(this, a2, a3, a4, a5, a6, a7, a8, a9);
}

void IOUserNetworkRxSubmissionQueue::free(IOUserNetworkRxSubmissionQueue *this)
{
}

uint64_t IOUserNetworkTxCompletionQueue::initWithPool(IOUserNetworkTxCompletionQueue *this, IOUserNetworkPacketBufferPool *a2, unsigned int a3, unsigned int a4, OSObject *a5, unsigned int (*a6)(OSObject *, IOUserNetworkPacketQueue *, IOUserNetworkPacket **, unsigned int, void *), void *a7, unsigned int a8)
{
  return IOUserNetworkTxCompletionQueue::initWithPool(this, a2, a3, a4, a5, a6, a7, a8);
}

void IOUserNetworkTxCompletionQueue::free(IOUserNetworkTxCompletionQueue *this)
{
}

uint64_t IOUserNetworkTxSubmissionQueue::initWithPool(IOUserNetworkTxSubmissionQueue *this, IOUserNetworkPacketBufferPool *a2, unsigned int a3, unsigned int a4, unsigned int a5, OSObject *a6, unsigned int (*a7)(OSObject *, IOUserNetworkPacketQueue *, unsigned int *), unsigned int (*a8)(OSObject *, IOUserNetworkPacketQueue *, IOUserNetworkPacket **, unsigned int, void *), void *a9, unsigned int a10)
{
  return IOUserNetworkTxSubmissionQueue::initWithPool(this, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

void IOUserNetworkTxSubmissionQueue::free(IOUserNetworkTxSubmissionQueue *this)
{
}

uint64_t IOServiceStateNotificationDispatchSource::SetHandler(IOServiceStateNotificationDispatchSource *this, OSAction *a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return IOServiceStateNotificationDispatchSource::SetHandler(this, a2, a3);
}

uint64_t IOServiceStateNotificationDispatchSource::StateNotificationBegin(IOServiceStateNotificationDispatchSource *this, int (*a2)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return IOServiceStateNotificationDispatchSource::StateNotificationBegin(this, a2);
}

uint64_t IOServiceStateNotificationDispatchSource::StateNotificationReady_Invoke(IOServiceStateNotificationDispatchSource *this, IORPC *a2, OSMetaClassBase *a3, void (*a4)(OSMetaClassBase *, OSAction *), const OSMetaClass *a5)
{
  return IOServiceStateNotificationDispatchSource::StateNotificationReady_Invoke(this, a2, a3, a4, a5);
}

uint64_t IOServiceStateNotificationDispatchSource::Create(IOServiceStateNotificationDispatchSource *this, IOService *a2, OSArray *a3, IODispatchQueue *a4, IOServiceStateNotificationDispatchSource **a5)
{
  return IOServiceStateNotificationDispatchSource::Create(this, a2, a3, a4, a5);
}

uint64_t OSSet::removeObject(OSSet *this, const OSMetaClassBase *a2)
{
  return OSSet::removeObject(this, a2);
}

uint64_t OSSet::withCapacity(OSSet *this, unsigned int a2)
{
  return OSSet::withCapacity(this, a2);
}

uint64_t OSSet::setObject(OSSet *this, const OSMetaClassBase *a2)
{
  return OSSet::setObject(this, a2);
}

uint64_t CCPipe::withOwnerNameCapacity()
{
  return CCPipe::withOwnerNameCapacity();
}

BOOL OSData::appendBytes(OSData *this, const void *bytes, size_t numBytes)
{
  return OSData::appendBytes(this, bytes, numBytes);
}

OSDataPtr OSData::withCapacity(uint32_t capacity)
{
  return OSData::withCapacity(capacity);
}

OSDataPtr OSData::withBytesNoCopy(void *bytes, size_t numBytes)
{
  return OSData::withBytesNoCopy(bytes, numBytes);
}

OSDataPtr OSData::withData(const OSData *inData)
{
  return OSData::withData(inData);
}

OSDataPtr OSData::withBytes(const void *bytes, size_t numBytes)
{
  return OSData::withBytes(bytes, numBytes);
}

OSArrayPtr OSArray::withObjects(const OSObject **values, uint32_t count, uint32_t capacity)
{
  return OSArray::withObjects(values, count, capacity);
}

OSArrayPtr OSArray::withCapacity(uint32_t capacity)
{
  return OSArray::withCapacity(capacity);
}

BOOL OSArray::setObject(OSArray *this, const OSMetaClassBase *anObject)
{
  return OSArray::setObject(this, anObject);
}

BOOL OSArray::setObject(OSArray *this, uint32_t index, const OSMetaClassBase *anObject)
{
  return OSArray::setObject(this, index, anObject);
}

uint64_t CCStream::withPipeAndName()
{
  return CCStream::withPipeAndName();
}

kern_return_t OSAction::CreateWithTypeName(OSObject *target, uint64_t targetmsgid, uint64_t msgid, size_t referenceSize, OSString *typeName, OSAction **action)
{
  return OSAction::CreateWithTypeName(target, targetmsgid, msgid, referenceSize, typeName, action);
}

kern_return_t OSAction::_Dispatch(OSAction *self, const IORPC *rpc)
{
  return OSAction::_Dispatch(self, rpc);
}

uint64_t OSBundle::mainBundle(OSBundle *this)
{
  return OSBundle::mainBundle(this);
}

uint64_t OSBundle::loadResource(OSBundle *a1, const char *a2, unint64_t a3, unint64_t a4, OSMappedFile **a5)
{
  return OSBundle::loadResource(a1, a2, a3, a4, a5);
}

OSNumberPtr OSNumber::withNumber(uint64_t value, size_t numberOfBits)
{
  return OSNumber::withNumber(value, numberOfBits);
}

kern_return_t OSObject::SetDispatchQueue(OSObject *this, const IODispatchQueueName name, IODispatchQueue *queue, OSDispatchMethod supermethod)
{
  return OSObject::SetDispatchQueue(this, name, queue, supermethod);
}

kern_return_t OSObject::CopyDispatchQueue(OSObject *this, const IODispatchQueueName name, IODispatchQueue **queue, OSDispatchMethod supermethod)
{
  return OSObject::CopyDispatchQueue(this, name, queue, supermethod);
}

void OSObject::free(OSObject *this)
{
}

BOOL OSObject::init(OSObject *this)
{
  return OSObject::init(this);
}

OSStringPtr OSString::withString(const OSString *aString)
{
  return OSString::withString(aString);
}

OSStringPtr OSString::withCString(const char *cString)
{
  return OSString::withCString(cString);
}

OSStringPtr OSString::withCStringNoCopy(const char *cString)
{
  return OSString::withCStringNoCopy(cString);
}

uint64_t IOCommand::CommandChain(IOCommand *this)
{
  return IOCommand::CommandChain(this);
}

uint64_t IOCommand::init(IOCommand *this)
{
  return IOCommand::init(this);
}

uint64_t IOCommand::FromChain()
{
  return IOCommand::FromChain();
}

uint64_t IOService::AdjustBusy(IOService *this, int a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return IOService::AdjustBusy(this, a2, a3);
}

kern_return_t IOService::Stop_Invoke(const IORPC *rpc, OSMetaClassBase *target, IOService::Stop_Handler func)
{
  return IOService::Stop_Invoke(rpc, target, func);
}

uint64_t IOService::GetBusyState(IOService *this, unsigned int *a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return IOService::GetBusyState(this, a2, a3);
}

kern_return_t IOService::Start_Invoke(const IORPC *rpc, OSMetaClassBase *target, IOService::Start_Handler func)
{
  return IOService::Start_Invoke(rpc, target, func);
}

kern_return_t IOService::SetPowerState(IOService *this, uint32_t powerFlags, OSDispatchMethod supermethod)
{
  return IOService::SetPowerState(this, powerFlags, supermethod);
}

kern_return_t IOService::SetProperties(IOService *this, OSDictionary *properties, OSDispatchMethod supermethod)
{
  return IOService::SetProperties(this, properties, supermethod);
}

kern_return_t IOService::SearchProperty(IOService *this, const IOPropertyName name, const IORegistryPlaneName plane, uint64_t options, OSContainer **property, OSDispatchMethod supermethod)
{
  return IOService::SearchProperty(this, name, plane, options, property, supermethod);
}

kern_return_t IOService::RegisterService(IOService *this, OSDispatchMethod supermethod)
{
  return IOService::RegisterService(this, supermethod);
}

kern_return_t IOService::ChangePowerState(IOService *this, uint32_t powerFlags, OSDispatchMethod supermethod)
{
  return IOService::ChangePowerState(this, powerFlags, supermethod);
}

uint64_t IOService::StringFromReturn(IOService *this, int a2, OSString **a3, int (*a4)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return IOService::StringFromReturn(this, a2, a3, a4);
}

uint64_t IOService::UpdateReport_Invoke(IOService *this, IORPC *a2, OSMetaClassBase *a3, int (*a4)(OSMetaClassBase *, OSData *, unsigned int, unsigned int *, unint64_t, unint64_t, IOMemoryDescriptor *))
{
  return IOService::UpdateReport_Invoke(this, a2, a3, a4);
}

kern_return_t IOService::NewUserClient_Invoke(const IORPC *rpc, OSMetaClassBase *target, IOService::NewUserClient_Handler func)
{
  return IOService::NewUserClient_Invoke(rpc, target, func);
}

kern_return_t IOService::SetPowerState_Invoke(const IORPC *rpc, OSMetaClassBase *target, IOService::SetPowerState_Handler func)
{
  return IOService::SetPowerState_Invoke(rpc, target, func);
}

uint64_t IOService::_ClaimSystemWakeEvent(IOService *this, IOService *a2, unint64_t a3, const char *a4, OSContainer *a5, int (*a6)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return IOService::_ClaimSystemWakeEvent(this, a2, a3, a4, a5, a6);
}

uint64_t IOService::ConfigureReport_Invoke(IOService *this, IORPC *a2, OSMetaClassBase *a3, int (*a4)(OSMetaClassBase *, OSData *, unsigned int, unsigned int *))
{
  return IOService::ConfigureReport_Invoke(this, a2, a3, a4);
}

kern_return_t IOService::CopyProviderProperties(IOService *this, OSArray *propertyKeys, OSArray **properties, OSDispatchMethod supermethod)
{
  return IOService::CopyProviderProperties(this, propertyKeys, properties, supermethod);
}

uint64_t IOService::CoreAnalyticsSendEvent(IOService *this, unint64_t a2, OSString *a3, OSDictionary *a4, int (*a5)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return IOService::CoreAnalyticsSendEvent(this, a2, a3, a4, a5);
}

uint64_t IOService::UserSetProperties_Invoke(IOService *this, IORPC *a2, OSMetaClassBase *a3, int (*a4)(OSMetaClassBase *, OSContainer *))
{
  return IOService::UserSetProperties_Invoke(this, a2, a3, a4);
}

uint64_t IOService::StateNotificationItemCopy(IOService *this, OSString *a2, OSDictionary **a3, int (*a4)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return IOService::StateNotificationItemCopy(this, a2, a3, a4);
}

uint64_t IOService::CopySystemStateNotificationService(IOService *this, IOService **a2, int (*a3)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return IOService::CopySystemStateNotificationService(this, a2, a3);
}

kern_return_t IOService::Stop(IOService *this, IOService *provider, OSDispatchMethod supermethod)
{
  return IOService::Stop(this, provider, supermethod);
}

void IOService::free(IOService *this)
{
}

BOOL IOService::init(IOService *this)
{
  return IOService::init(this);
}

kern_return_t IOService::Start(IOService *this, IOService *provider, OSDispatchMethod supermethod)
{
  return IOService::Start(this, provider, supermethod);
}

kern_return_t IOService::Create(IOService *this, IOService *provider, const IOPropertyName propertiesKey, IOService **result, OSDispatchMethod supermethod)
{
  return IOService::Create(this, provider, propertiesKey, result, supermethod);
}

uint64_t IOService::SetLegend(IOService *this, OSArray *a2, BOOL a3, int (*a4)(OSMetaClassBase *, IORPC *__struct_ptr))
{
  return IOService::SetLegend(this, a2, a3, a4);
}

kern_return_t IOService::Terminate(IOService *this, uint64_t options, OSDispatchMethod supermethod)
{
  return IOService::Terminate(this, options, supermethod);
}

kern_return_t IOService::_Dispatch(IOService *self, const IORPC *rpc)
{
  return IOService::_Dispatch(self, rpc);
}

OSObject *__cdecl OSDictionary::getObject(const OSDictionary *this, const OSObject *aKey)
{
  return OSDictionary::getObject(this, aKey);
}

OSObject *__cdecl OSDictionary::getObject(const OSDictionary *this, const char *aKey)
{
  return OSDictionary::getObject(this, aKey);
}

uint64_t OSMappedFile::data(OSMappedFile *this)
{
  return OSMappedFile::data(this);
}

uint64_t OSMappedFile::size(OSMappedFile *this)
{
  return OSMappedFile::size(this);
}

uint64_t OSOrderedSet::getLastObject(OSOrderedSet *this)
{
  return OSOrderedSet::getLastObject(this);
}

uint64_t OSOrderedSet::getFirstObject(OSOrderedSet *this)
{
  return OSOrderedSet::getFirstObject(this);
}

uint64_t CCFaultReport::getLinkRegister(CCFaultReport *this)
{
  return CCFaultReport::getLinkRegister(this);
}

uint64_t CCFaultReport::getProgramCounter(CCFaultReport *this)
{
  return CCFaultReport::getProgramCounter(this);
}

uint64_t CCFaultReport::getWatchdogResult(CCFaultReport *this)
{
  return CCFaultReport::getWatchdogResult(this);
}

uint64_t IO80211Buffer::getLength(IO80211Buffer *this)
{
  return IO80211Buffer::getLength(this);
}

uint64_t IO80211Buffer::readBytes(IO80211Buffer *this, uint64_t a2, void *a3)
{
  return IO80211Buffer::readBytes(this, a2, a3);
}

uint64_t OSMetaClassBase::getRetainCount(OSMetaClassBase *this)
{
  return OSMetaClassBase::getRetainCount(this);
}

uint64_t IO80211BSSBeacon::getRSSI(IO80211BSSBeacon *this)
{
  return IO80211BSSBeacon::getRSSI(this);
}

uint64_t IO80211BSSBeacon::getLogger(IO80211BSSBeacon *this)
{
  return IO80211BSSBeacon::getLogger(this);
}

uint64_t IO80211FlowQueue::getHash(IO80211FlowQueue *this)
{
  return IO80211FlowQueue::getHash(this);
}

uint64_t IO80211BssManager::getAssocSSID(IO80211BssManager *this, unsigned __int8 *a2, unint64_t *a3)
{
  return IO80211BssManager::getAssocSSID(this, a2, a3);
}

uint64_t IO80211BssManager::isAdhocCreated(IO80211BssManager *this)
{
  return IO80211BssManager::isAdhocCreated(this);
}

uint64_t IO80211BssManager::getAssocColocatedNetworkScopeId(IO80211BssManager *this, unsigned __int8 *a2, unint64_t *a3)
{
  return IO80211BssManager::getAssocColocatedNetworkScopeId(this, a2, a3);
}

uint64_t IO80211BssManager::dumpBSS(IO80211BssManager *this, char *a2)
{
  return IO80211BssManager::dumpBSS(this, a2);
}

uint64_t IO80211SkywalkInterface::getLogger(IO80211SkywalkInterface *this)
{
  return IO80211SkywalkInterface::getLogger(this);
}

const void *__cdecl OSData::getBytesNoCopy(const OSData *this, size_t start, size_t numBytes)
{
  return OSData::getBytesNoCopy(this, start, numBytes);
}

const void *__cdecl OSData::getBytesNoCopy(const OSData *this)
{
  return OSData::getBytesNoCopy(this);
}

size_t OSData::getLength(const OSData *this)
{
  return OSData::getLength(this);
}

OSObject *__cdecl OSArray::getObject(const OSArray *this, uint32_t index)
{
  return OSArray::getObject(this, index);
}

size_t OSNumber::numberOfBits(const OSNumber *this)
{
  return OSNumber::numberOfBits(this);
}

uint8_t OSNumber::unsigned8BitValue(const OSNumber *this)
{
  return OSNumber::unsigned8BitValue(this);
}

uint16_t OSNumber::unsigned16BitValue(const OSNumber *this)
{
  return OSNumber::unsigned16BitValue(this);
}

uint32_t OSNumber::unsigned32BitValue(const OSNumber *this)
{
  return OSNumber::unsigned32BitValue(this);
}

uint64_t OSNumber::unsigned64BitValue(const OSNumber *this)
{
  return OSNumber::unsigned64BitValue(this);
}

BOOL OSNumber::isEqualTo(const OSNumber *this, const OSNumber *aNumber)
{
  return OSNumber::isEqualTo(this, aNumber);
}

const char *__cdecl OSString::getCStringNoCopy(const OSString *this)
{
  return OSString::getCStringNoCopy(this);
}

size_t OSString::getLength(const OSString *this)
{
  return OSString::getLength(this);
}

BOOL OSString::isEqualTo(const OSString *this, const OSString *aString)
{
  return OSString::isEqualTo(this, aString);
}

BOOL OSString::isEqualTo(const OSString *this, const char *cString)
{
  return OSString::isEqualTo(this, cString);
}

uint64_t IOService::GetProvider(IOService *this)
{
  return IOService::GetProvider(this);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t absolutetime_to_nanoseconds()
{
  return _absolutetime_to_nanoseconds();
}

int bcmp(const void *a1, const void *a2, size_t a3)
{
  return _bcmp(a1, a2, a3);
}

void bzero(void *a1, size_t a2)
{
}

uint64_t clock_interval_to_deadline()
{
  return _clock_interval_to_deadline();
}

uint64_t continuoustime_to_absolutetime()
{
  return _continuoustime_to_absolutetime();
}

uint64_t convertApple80211IOCTLToString()
{
  return _convertApple80211IOCTLToString();
}

uint64_t io80211_os_log()
{
  return _io80211_os_log();
}

uint64_t kdebug_trace()
{
  return _kdebug_trace();
}

uint64_t mach_absolute_time(void)
{
  return _mach_absolute_time();
}

uint64_t mach_continuous_time(void)
{
  return _mach_continuous_time();
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return _memcmp(__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return _memmove(__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return _memset(__b, __c, __len);
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  return _memset_s(__s, __smax, __c, __n);
}

uint64_t nanoseconds_to_absolutetime()
{
  return _nanoseconds_to_absolutetime();
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return _os_log_type_enabled(oslog, type);
}

void panic(const char *a1, ...)
{
}

uint64_t read_random()
{
  return _read_random();
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return _snprintf(__str, __size, __format);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return _sscanf(a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return _strlcat(__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return _strlcpy(__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return _strncasecmp(a1, a2, a3);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return _strncmp(__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return _strncpy(__dst, __src, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return _strnlen(__s1, __n);
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  return _strnstr(__big, __little, __len);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return _strtoul(__str, __endptr, __base);
}

void uuid_generate(uuid_t out)
{
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return _vsnprintf(__str, __size, __format, a4);
}